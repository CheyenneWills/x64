-title min2asm: translation from minimal lexemes to x86 assembly code
-stitl description
* copyright 1987-2012 robert b. k. dewar and mark emmer.
* copyright 2012 david shields
* 
* this file is part of macro spitbol.
* 
*     macro spitbol is free software: you can redistribute it and/or modify
*     it under the terms of the gnu general public license as published by
*     the free software foundation, either version 3 of the license, or
*     (at your option) any later version.
* 
*     macro spitbol is distributed in the hope that it will be useful,
*     but without any warranty; without even the implied warranty of
*     merchantability or fitness for a particular purpose.  see the
*     gnu general public license for more details.
* 
*     you should have received a copy of the gnu general public license
*     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
*
*
*  this program takes input file in minimal lexeme form and
*  produces assembly code for intel x86 processor.
*  the program obtains the name of the file to be translated from the
*  command line string in host(0).  options relating to the processing
*  of comments can be changed by modifying the source.
*
*  in addition to the minimal lexeme file, the program requires the
*  name of a "machine definition file" that contains code specific
*  to a particular x86 assembler.
*
*  you may also specify option flags on the command line to control the
*  code generation.  the following flags are processed:
*	compress	generate tabs rather than spaces in output file
*       comments        retain full-line and end-of-line comments
*
*  the variable machine is set equal to the uppercase name of the machine
*  being processed.  specific tests upon this variable are discouraged, as
*  all machine-dependent code should be placed in the machine-definition
*  file if possible.
*
*  in addition to the normal minimal register complement, one scratch
*  work register, w0 is defined.
*  see the register map below for specific allocations.
*
*  this program is based in part on earlier translators for the
*  it is based in part on earlier translators for the dec vax
*  (vms and un*x) written by steve duff and robert goldberg, and the
*  pc-spitbol translator by david shields.
*
*  to run under spitbol:
*       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt
*
*	reads <file>.lex	containing lexemeized source code
*       writes <file>.s         with x86 assembly code
*	also writes <file>.err	with err and erb error messages
*	using <machine>.def	to provide machine-specific information
*       parts of <machine>.hdr  are prepended and appended to <file>.s
*	also sets flags		to 1 after converting names to upper case
*	also reads <file>.pub	for debug symbols to be declared public
*
*  example:
*       spitbol -u v37:dos:compress codlinux.spt
*
*
*  revision history:
*
        version = 'v1.12'
-eject
*
*  keyword initialization
*
	&anchor = 1;	
	&dump = 1
	&dump = 2
	&stlimit = 10000000;	
	&trim	= 1;  
*
*  useful constants
*
	letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	ucase   = letters
	lcase   = 'abcdefghijklmnopqrstuvwxyz'
	nos     = '0123456789'
	tab	= char(9)
*
*  data structures
*
	data('minarg(i.type,i.text)')
	data('stmt(s.label,s.opc,s.op1,s.op2,s.op3,s.comment)')

	sectnow = 0

*	set generating_code whilst generating executable code

	generating_code =

	trapped_stmts = table(100)

*	ppm_cases gives count of ppm/err statments that must follow call to
*	a procedure
	
	ppm_cases = table(50,,0)
*
*  function definitions
*
*  crack parses stmt into a stmt data plex and returns it.
*  it fails if there is a syntax error.
*
	define('crack(line)operands,operand,char')
*
*	comregs - map minimal register names to target register names
	define('comregs(line)t,pre,word')
*
*  error is used to report an error for current statement
*
	define('asm(aopc,aop1,aop2,aop3)')
	define('cstmt(gopc,gop1,gop2,gop3)')
	define('deflabel(dlabel)')
	define('error(text)')
	define('flush()')
	define('genaop(stmt)')
	define('genbop(stmt)')
        define('genlab()')
	define('getarg(iarg,iacc)l1,l2,t1,t2')
	define('ifreg(iarg)')
	define('memmem(iarg)')
	define('mov()dst,src,r.dst,r.src')
	define('prcent(n)')
	define('prsarg(iarg)l1,l2')
	define('pseudo(aopl,aopc,aop1,aop2,aop3)')
	define('tblini(str)pos,cnt,index,val,lastval')

*  outstmt is used to send a target statement to the target code
*  output file outfile
*
	define('outstmt(ostmt)label,opcode,op1,op2,op3,comment,t,stmtout')
*  readline is called to return the next non-comment line from
*  the minimal input file (infile <=> lu1).   note that it will
*  not fail on eof, but it will return a minimal end statement
*
	define('readline()')
*
	 p.comregs = break(letters) . pre span(letters) . word

*  exttab has entry for external procedures
*
	exttab = table(50)

*  labtab records labels in the code section, and their line numbers
*
	labtab = table(500)

*  for each statement, code in generated into three
*  arrays of statements:
*
*	astmts:	statements after opcode (()+, etc.)
*	bstmts: statements before code (-(), etc)
*	cstmts: generated code proper
*
	astmts = array(20,'')
	bstmts = array(10,'')
	cstmts = array(20,'')
*
*  genlabels is count of generated labels (cf. genlab)
*
	genlabels = 0

*
*  initialize variables
*
	labcnt = olines = ilines = nstmts = ntarget = nerrors = 0
	noptim1 = noptim2 = 0
	lastopc = lastop1 = lastop2 =
	data_lc = 0
	max_exi = 0
*
*  initial patterns
*
*  p.csparse parses lexemeized line
	p.csparse = '|' break('|') . inlabel
.	'|' break('|') . incode
.	'|' break('|') . iarg1
.	'|' break('|') . iarg2
.	'|' break('|') . iarg3
.	'|' break('|') . incomment
	'|' rem . slineno

*  dispatch table
*
	getargcase = table(27)
	getargcase[1] = .getarg.c.1;   getargcase[2] = .getarg.c.2
	getargcase[3] = .getarg.c.3;   getargcase[4] = .getarg.c.4
	getargcase[5] = .getarg.c.5;   getargcase[6] = .getarg.c.6
	getargcase[7] = .getarg.c.7;   getargcase[8] = .getarg.c.8
	getargcase[9] = .getarg.c.9;   getargcase[10] = .getarg.c.10
	getargcase[11] = .getarg.c.11; getargcase[12] = .getarg.c.12
	getargcase[13] = .getarg.c.13; getargcase[14] = .getarg.c.14
	getargcase[15] = .getarg.c.15; getargcase[16] = .getarg.c.16
	getargcase[17] = .getarg.c.17; getargcase[18] = .getarg.c.18
	getargcase[19] = .getarg.c.19; getargcase[20] = .getarg.c.20
	getargcase[21] = .getarg.c.21; getargcase[22] = .getarg.c.22
	getargcase[23] = .getarg.c.23; getargcase[24] = .getarg.c.24
	getargcase[25] = .getarg.c.25; getargcase[26] = .getarg.c.26
	getargcase[27] = .getarg.c.27

*
*  pifatal maps minimal opcodes for which no a code allowed
*  to nonzero value. such operations include conditional
*  branches with operand of form (x)+
*
	pifatal = tblini(
.	'aov[1]beq[1]bne[1]bge[1]bgt[1]bhi[1]ble[1]blo[1]'
.	'blt[1]bne[1]bnz[1]ceq[1]cne[1]mfi[1]nzb[1]zrb[1]')
*
*

* create map of executable statements (needed when instrumenting code)

	is_executable = table(100)
	s = 
+       'add adi adr anb aov atn '
+	'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti dvi dvr erb esw etx exi flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp '
+       'jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvc mvw mwb ngi eti ngr nzb orb plc prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer '
+       'zgb zrb'
is_exec.1
	s len(3) . opc ' ' =				:f(is_exec.2)
	is_executable[opc] = 1				:(is_exec.1)
is_exec.2

* create map of branch statements (needed when instrumenting code)

	is_branch = table(100)
	s = 
+	'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze ceq cmc cne '
+       'ieq ige igt ile ilt ine ino iov '
+       'jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
is_branch.1
	s len(3) . opc ' ' =				:f(is_branch.2)
	is_branch[opc] = 1				:(is_branch.1)
is_branch.2

*  is_exp_procedure is a table list of procedures declared with 'exp' intruction
	is_exp_procedure = table()

-stitl main program
*  here follows the driver code for the "main" program.

*
*  loop until program exits via g.end
*
*  opnext is invoked to initiate processing of the next line from
*  readline.
*  after doing this, opnext branches to the generator routine indicated
*  for this opcode if there is one.
*  the generators all have entry points beginning
*  with "g.", and can be considered a logical extension of the
*  opnext routine.  the generators have the choice of branching back
*  to dsgen to cause the thisstmt plex to be sent to outstmt, or
*  or branching to opnext, in which case the generator must output
*  all needed code itself.
*
*  the generators are listed in a separate section below.
*
*
*  get file name
*
	transdate = date()
*
*  default the parameter string if none present
*
        parms = (differ(host(0)) host(0), "v37:linux:compress")
        output = ident(parms) "filename (.lex) required" :s(end)

*
* get machine definition file name following lexeme file name, and flags.
*
	parms ? break(';:') . parms len(1) (break(';:') | rem) . machine
+		((len(1) rem . flags) | '')
        output = ident(machine)
+		"machine type file (.def) required"	:s(end)
	$replace(machine,lcase,ucase) = 1
*
* parse and display flags, setting each one's name to non-null value (1).
*
flgs	flags ? ((len(1) break(';:')) . flag len(1)) |
+	 ((len(1) rem) . flag) =			:f(flgs2)
	flag = replace(flag,lcase,ucase)
        output = "flag: " flag
	$flag = 1					:(flgs)
*
flgs2	
* various constants
*
        comment.delim = ';'
	label.delim   = ':'
*
*
*  branchtab maps minimal opcodes 'beq', etc to desired
*  target instruction
*
	branchtab = table(10)
	branchtab['beq'] = 'je'
	branchtab['bne'] = 'jne'
	branchtab['bgt'] = 'ja'
	branchtab['bge'] = 'jae'
	branchtab['ble'] = 'jbe'
	branchtab['blt'] = 'jb'
	branchtab['blo'] = 'jb'
	branchtab['bhi'] = 'ja'

*  optim.tab flags opcodes capable of participating in or optimization
*		in outstmt routine
*
	optim.tab = table(10)
	optim.tab<"and"> = 1
	optim.tab<"add"> = 1
	optim.tab<"sub"> = 1
	optim.tab<"neg"> = 1
	optim.tab<"or"> = 1
	optim.tab<"xor"> = 1
	optim.tab<"shr"> = 1
	optim.tab<"shl"> = 1
	optim.tab<"inc"> = 1
	optim.tab<"dec"> = 1


*  ismem is table indexed by operand type which is nonzero if
*  operand type implies memory reference.

	ismem = array(30,0)
	ismem<3> = 1; ismem<4> = 1; ismem<5> = 1
	ismem<9> = 1; ismem<10> = 1; ismem<11> = 1
	ismem<12> = 1; ismem<13> = 1; ismem<14> = 1
	ismem<15> = 1
*
*  regmap maps minimal register name to target machine
*  register/memory-location name.
*
	regmap = table(30)
*	reg.ia = regmap['ia']
*	reg.wa = regmap['wa']
*	reg.cp = regmap['cp']

	regmap['xl'] = 'esi.xl';  regmap['xt'] = 'esi.xt'
	regmap['xr'] = 'edi.xr';  regmap['xs'] = 'esp.xs'
	regmap['wa'] = 'ecx.wa';  regmap['wb'] = 'ebx.wb'
	regmap['wc'] = 'edx.wc';  regmap['ia'] = 'edx.ia'
	regmap['cp'] = 'ebp.cp'
*	w0 is temp register
 	regmap['w0'] = 'eax.w0'

*  quick reference:
	reg.ia = regmap['ia']
	reg.wa = regmap['wa']
	reg.cp = regmap['cp']
	w0 = regmap['w0']
*  other definitions that are dependent upon things defined in the
*  machine definition file, and cannot be built until after the definition
*  file has been read in.
*
	fillc	  = (ident(compress) " ",tab)

*  strip end of comments if y
*
	strip_comment = (differ(comments) 'n', 'y')
	strip_comment = 'y'

	filenami = parms '.lex'
        input(.infile,1,filenami)                     :s(inpulex)
        output = 'cannot open lexeme file: ' filenami  :(end)
inpulex 
*
*
*
*  associate output files.  
*

*
* open file for compilation of minimal err and erb messages
*
	filenamo = parms ".s"
        output(.outfile,2,filenamo '[-m10 -n0]')
        output(.errfile,3, parms ".err")             :s(err_ok)
	output = 'error file ' parms ".err"
        output = "cannot open error message file: " parms ".err" :(end)
err_ok

* begin with standard preamble
        pseudo(,';','"spitbol translator ' replace(parms,lcase,ucase) '"')
        pseudo(,';','"' replace(parms,lcase,ucase) '"')

*  then copy contents of <machine>.hdr (if it exists) to outfile
*  stop at line with just 'end' or end of file
*
	outfile = comment.delim ' minimal/x86 translator ' version
+		  ' ' transdate ' for ' machine
	olines = olines + 1
	output = 'machine is ' machine

	input(.hdrfile,4,machine '/' machine '.hdr')	:f(nohdr)
	havehdr = 1
        output = rpad('input header file:',24) machine '/' machine '.hdr'
	output = rpad('input lexeme file:',24) filenami
	output = rpad('output assembly file:',24) filenamo
hdrcopy line = hdrfile				:f(hdrend)
	ident(line,'end')			:s(nohdr)
	outfile = line
	olines = olines + 1		:(hdrcopy)
hdrend	havehdr =
*	outfile = '	section .data'
*	outfile = '      global ati_line'
*	outfile = 'atline: dd	0'
nohdr
*
*  will have havehdr non-null if more remains to copy out at end.
*
*  read in pub file if it exists.  this contains a list of symbols to
*  be declared public when encountered.
*
	pubtab = table(2)
	input(.pubfile,5, parms ".pub")		:f(nopub)
	pubtab = table(101)
pubcopy	line = pubfile				:f(pubend)
	pubtab[line] = 1			:(pubcopy)
pubend	endfile(5)
nopub

						:(opnext)
  &trace = 2000
  &ftrace = 1000
*  &profile = 1

opnext	
	thisline = readline()
	inlabel = incode = iarg1 = iarg2 = iarg2 = incomment =
	crack(thisline)				:f(opnext.3)
	i1 = prsarg(iarg1)
	i2 = prsarg(iarg2)
	i3 = prsarg(iarg3)
	tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.		i.text(i2) ' ' i.text(i3)
	argerrs = 0
*  	output = differ(inlabel) 'input line ' ilines ' label ' inlabel
*	output = 'input line ' ilines ' label ' inlabel
	ident(is_executable[incode])		:s(opnext.2)
*	emit label here for an executable instruction
	atlabel = (differ(inlabel) 1, 0)
*	output = 'defining label for exec. instr' inlabel ' ' incode
	deflabel()
*  	outfile = '      ' 'ati' '   ' ilines
	eq(atlabel,0)				:s(opnext.2)
*	here if executing statement with label
*	issue trace call to atlin
*	differ(is_branch[incode])		:s(opnext.2)

*   	outfile = '  mov dword [ilines],'   ilines 
*   	outfile = '  call  atlin'
opnext.2
*	branch via opcode to the generator for this operation
						:($('g.' incode))
opnext.3
*  here if bad opcode
	error('bad op-code')			:(opnext)

*  generate lexemes.
*
-stitl	asm(aopc,aop,aop2,aop3)
asm	
	asm_count = asm_count + 1
	outstmt(stmt(,aopc,aop1,aop2,aop3)) :(return)

-stitl	pseudo(aopl,aopc,aop,aop2,aop3)
pseudo	
	asm_pseudo = asm_pseudo + 1
	outstmt(stmt(aopl,aopc,aop1,aop2,aop3)) :(return)

-stitl comregs(line)t,pre,word
comregs
	line p.comregs =			:f(comregs1)
	word = eq(size(word),2) differ(t = regmap[word]) t
	comregs = comregs pre word		:(comregs)
comregs1 comregs = comregs line			:(return)
-stitl crack(line)
*  crack is called to create a stmt plex containing the various
*  entrails of the minimal source statement in line.  for
*  conditional assembly ops, the opcode is the op, and op1
*  is the symbol.  note that dtc is handled as a special case to
*  assure that the decomposition is correct.
*
*  crack will print an error and fail if a syntax error occurs.
*
crack   nstmts  = nstmts + 1
	op1 = op2 = op3 = typ1 = typ2 = typ3 = 
	line    p.csparse			:s(return)
*  here on syntax error
*
	error('source line syntax error')	:(freturn)
-stitl cstmt(gopc,gop1,gop2,gop3)
cstmt
	cstmts[cstmt.n = cstmt.n + 1] = stmt(,gopc,gop1,gop2,gop3)
						:(return)
-stitl deflabel(label)
*	define a label
deflabel
	differ(dlabel)				:s(deflabel.1)
*	here if null argument indicating defining label of current statement
	dlabel = inlabel
	inlabel =

deflabel.1
	ident(dlabel)				:s(return)
	
	pseudo(dlabel)
						:(return)
-stitl error(text)
*  this module handles reporting of errors with the offending
*  statement text in thisline.  comments explaining
*  the error are written to the listing (including error chain), and
*  the appropriate counts are updated.
*
error   
	outfile = '* *???* ' thisline
	outfile = '*       ' text
.	          (ident(lasterror),'. last error was line ' lasterror)
	lasterror = olines
	olines = olines + 2
	le(nerrors = nerrors + 1, 10)		:s(opnext)
        output = 'too many errors, quitting'  :(end)
-stitl genaop(stmt)
genaop
	astmts[astmts.n = astmts.n + 1] = stmt	:(return)
-stitl genbop(stmt)
genbop
	bstmts[bstmts.n = bstmts.n + 1] = stmt	:(return)

-stitl genlab()
*  generate unique labels for use in generated code
genlab	genlab = 'l' lpad(genlabels = genlabels + 1,4,'0') :(return)

-stitl getarg(iarg,iacc)
getarg	l1 = i.text(iarg)
	l2 = i.type(iarg)
	eq(l2)					:f($(getargcase[l2]))
	getarg = l1				:(return)

* int
getarg.c.1 getarg = l1				:(return)

* dlbl
getarg.c.2 getarg = l1				:(return)

* wlbl, clbl
getarg.c.3
getarg.c.4 getarg = 'dword [' l1 ']'     	:(return)

* elbl, plbl
getarg.c.5
getarg.c.6 getarg = l1				:(return)

* w,x, map register name
getarg.c.7
getarg.c.8
	getarg = regmap[l1]			:(return)

* (x), register indirect
getarg.c.9
	l1 len(1) len(2) . l2
	l2 = regmap[l2]
	getarg = 'dword [' l2 ']'		:(return)

* (x)+, register indirect, post increment
* use lea reg,[reg+4] unless reg is esp, since it takes an extra byte.
* actually, lea reg,[reg+4] and add reg,4 are both 2 cycles and 3 bytes
* for all the other regs, and either could be used.
getarg.c.10
	l1 = substr(l1,2,2)
	t1 = regmap[l1]
	getarg = 'dword [' t1 ']'
	(ident(l1,'xs') genaop(stmt(,'add',t1,'4'))) :s(return)
	genaop(stmt(,'lea',t1,'[' t1 '+4]'))	:(return)

*  -(x), register indirect, pre decrement
getarg.c.11
	t1 = regmap[substr(l1,3,2)]
	getarg = 'dword [' t1 ']'
	genbop(stmt(,'lea',t1,'[' t1 '-4]'))	:(return)

* int(x)
* dlbl(x)
getarg.c.12
getarg.c.13
	l1 break('(') . t1 '(' len(2) . t2
	getarg = 'dword [4*' t1 '+' regmap[t2] ']'	:(return)

*  name(x), where name is in working section
getarg.c.14
getarg.c.15
	l1 break('(') . t1 '(' len(2) . t2
	getarg = '['  t1 ' + ' regmap[t2] ']'	:(return)
*ds ds todo?

* signed integer
getarg.c.16 getarg = l1				:(return)

* signed real
getarg.c.17 getarg = l1				:(return)

*  =dlbl
getarg.c.18
	getarg = substr(l1,2)			:(return)

*  *dlbl
getarg.c.19
	getarg = '4*' substr(l1,2)	:(return)

*  =name (data section)
getarg.c.20
getarg.c.21
        getarg =  substr(l1,2)		:(return)

*  =name (program section)
getarg.c.22
        getarg =  substr(l1,2)		  :(return)

*  pnam, eqop
getarg.c.23
getarg.c.24 getarg = l1			:(return)

* ptyp, text, dtext
getarg.c.25
getarg.c.26
getarg.c.27 getarg = l1				:(return)

-stitl memmem(iarg)
memmem
*  memmem is called for those ops for which both operands may be
*  in memory, in which case, we generate code to load the specified
*  operand to work register 'w0', which then replaces the argument.
*
  ne(ismem[i.type(i1)]) ne(ismem[i.type(i2)])		:f(freturn)
  memmem = minarg(8,'w0')
  asm('mov','eax.w0', getarg(iarg))				:(return)


mov
   dst = i.text(i1)
   src = i.text(i2)  
*  perhaps change mov x,(xr)+ to
*	mov ax,x; stows
*
*  perhaps do  mov (xl)+,wx as
*	lodsw
*	xchg ax,tx
*  and also mov (xl)+,name as
*	lodsw
*	mov name,eax
*  need to process memory-memory case
*  change 'mov a,(xs)+' to 'pop a'
*  change 'mov -(xs),a' to 'push a'
	ident(src,'(xl)+')			:s(mov.xlp)
	ident(src,'(xt)+')			:s(mov.xtp)
	ident(src,'(xs)+')			:s(mov.xsp)
	ident(dst,'(xr)+')			:s(mov.xrp)
	ident(dst,'-(xs)')			:s(mov.mxs)
*  here if memory to memory. Bring second argument, the source, to register
*	output = ilines ' before move ' getarg(i1) ':' getarg(i2)
	i2 = memmem(i2)
*	output = ilines ' after  move ' getarg(i1) ':' getarg(i2)
	asm('mov',getarg(i1),getarg(i2))
						:(return)
mov.xtp
mov.xlp
	ident(src,'(xr)+') asm('movsd')	:s(return)
	asm('lodsd')
	ident(src,'-(xs)') asm('push','eax')	:s(return)
	asm('mov',getarg(i1),'eax')		:(return)
mov.xsp
	ident(src,'(xr)+')		:s(mov.xsprp)
	asm('pop',  getarg(i1))	:(return)
mov.xsprp 
	asm('pop','eax')
	asm('stosd')				:(return)
mov.xrp asm('mov','eax',getarg(i2))
	asm('stosd')				:(return)
mov.mxs
	asm('push',getarg(i2))		:(return)


-stitl prcent(n)
prcent prcent = 'prc$' '+'  (4 * ( n - 1)) :(return)

-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment)
*  this module writes the components of the statement
*  passed in the argument list to the formatted .s file
*
outstmt	
	ident(ostmt)				:s(return)
	thistmt = ostmt
	label = s.label(ostmt)
*	output = differ(label) 'outstmt ' ilines ' ' label
*  attach source label to first generated instruction
	comment = s.comment(ostmt)
*  attach source comment to first generated instruction
	differ(comment)				:s(outstmt2)
	ident(tcomment)				:s(outstmt2)
	comment = tcomment; tcomment =
outstmt2
	ident(label)				:s(outstmt3)
	le(sectnow,2)				:s(outstmt3)
*	here if label requires delimiter
	label = label label.delim
outstmt3
	opcode = s.opc(ostmt)
	op1 = s.op1(ostmt)
	op2 = s.op2(ostmt)
	op3 = s.op3(ostmt)
	differ(compress)			:s(outstmt6)
	stmtout = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.		  (ident(op1), op1
.			(ident(op2), ',' op2
.				(ident(op3), ',' op3))) ,27)
.       (ident(strip_comment,'y'), ' ' (ident(comment), ';') comment)
.						:(outstmt7)
outstmt6
	stmtout = label tab opcode tab
.		  (ident(op1), op1
.		    (ident(op2), ',' op2
.		      (ident(op3), ',' op3)))
.       (ident(strip_comment,'y'), tab (ident(comment), ';') comment)
*
**	send text to outfile
*
**
**  here is the peephole optimizer
**
*   optimization if:
*	1) this statement is not labeled
*   and	2) this opcode is or op1,op1 or cmp op1,0
*   and 3) last opcode was and, add, sub, neg, or, xor, shr, shl, inc or dec.
*   and	4) last op1 = current op1
*
outstmt7 (
.	ident(label)
.	  (ident(opcode,"or") ident(op1,op2),
.	   ident(opcode,"cmp") ident(op2,"0"))
.	      differ(optim.tab<lastopc>)
.	        ident(lastop1,op1)
.		)				:f(outstmt4)
*
*  criteria satisfied.  make current line into a comment.
*
	stmtout = comment.delim stmtout fillc "(optimized)"
	noptim1 = noptim1 + 1
*
*  record this statement's components for next time
*
outstmt4
	lastopc = opcode
	lastop1 = op1
	lastop2 = op2
**
**	send text to output file if not null.
*
	stmtout = replace(trim(stmtout),'$','_')
	ident(stmtout)				:s(return)
	outfile = stmtout
*	output = olines ':' stmtout
	ntarget	= ntarget + 1
	olines = olines + 1
*
*  record code labels in table with delimiter removed.
	(ge(sectnow,5) differ(label))		:f(return)
	label ? break(label.delim) . label	:f(return)
	labtab<label> = olines		:(return)
-stitl prsarg(iarg)
prsarg	prsarg = minarg(0)
	iarg break(',') . l1 ',' rem . l2	:f(return)
	prsarg = minarg(convert(l1,'integer'),l2)	:(return)
-stitl readline()
*  this routine returns the next statement line in the input file
*  to the caller.  it never fails.  if there is no more input,
*  then a minimal end statement is returned.
*  comments are passed through to the output file directly.
*
*
readline readline = infile                      :f(rl02)
	ilines = ilines + 1
*DS	output = lpad(ilines,6) ' ' readline
	ident(readline )			:s(readline)
	leq( substr(readline,1,1 ),'*' )       :f(rl01)
*
*  only print comment if requested.
*
	ident(strip_comment,'n')		:f(readline)
        readline len(1) = ';'
	outfile = readline
	olines = olines + 1               :(readline)
*
*  here if not a comment line
*
rl01						:(return)
*
*  here on eof
*
rl02    readline = '       end'
						:(rl01)
-stitl tblini(str)
*  this routine is called to initialize a table from a string of
*  index/value pairs.
*
tblini   pos     = 0
*
*  count the number of "[" symbols to get an assessment of the table
*  size we need.
*
tin01   str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.						:s(tin01)
*
*  allocate the table, and then fill it. note that a small memory
*  optimisation is attempted here by trying to re-use the previous
*  value string if it is the same as the present one.
*
	tblini   = table(cnt)
tin02   str     (break('[') $ index len(1) break(']') $ val len(1)) =
.						:f(return)
	val     = convert( val,'integer' )
	val     = ident(val,lastval) lastval
	lastval = val
	tblini[index] = val			:(tin02)
-stitl generators

ifreg	ge(i.type(iarg),7) le(i.type(iarg),8)
.						:f(freturn)s(return)

g.flc
	t1 = substr(getarg(i1),2,1) 'l'
	flc.label = genlab()
	asm('cmp',t1,"'a'")
	asm('jb', flc.label)
	asm('cmp',t1,"'z'")
	asm('ja', flc.label)
	asm('sub',t1,'32')
        deflabel(flc.label)                  
						:(opdone)

g.mov
	mov(i.text(i1),i.text(i2))		:(opdone)

* odd/even tests.  if w reg, use low byte of register.
g.bod	t1 = getarg(i1)
	t1 = eq(i.type(i1),8) substr(t1,2,1) 'l'
	asm('test',t1,'1')
	asm('jne',getarg(i2))			:(opdone)

g.bev	t1 = getarg(i1)
	t1 = eq(i.type(i1),8) substr(t1,2,1) 'l'
	asm('test',t1,'1')
	asm('je',getarg(i2))			:(opdone)

g.brn   asm('jmp',getarg(i1))			:(opdone)

g.bsw	
	t1 = getarg(i1)
	bsw.label = genlab()
	ident(i.text(i3))			:s(g.bsw1)
	asm('cmp',t1,getarg(i2))
	asm('jge',getarg(i3))
* here after default case.
g.bsw1	asm('jmp', 'dword  [' bsw.label '+' t1 '*4]')
*	indicate now generating data

	generating_code =
        pseudo(,'segment','.data')
        deflabel(bsw.label)		                  :(opdone)

g.iff   pseudo(,'dd',getarg(i2))               :(opdone)

g.esw  						
	generating_code = 1

						:(opdone)

g.ent
*
*  entry points are stored in byte before program entry label
*  last arg is optional, in which case no initial 'db' need be
*  issued. we force odd alignment so can distinguish entry point
*  addresses from block addresses (which are always even).
*
*  note that this address of odd/even is less restrictive than
*  the minimal definition, which defines an even address as being
*  a multiple of cfp$b (4), and an odd address as one that is not
*  a multiple of cfp$b (ends in 1, 2, or 3).  the definition here
*  is a simple odd/even, least significant bit definition.
*  that is, for us, 1 and 3 are odd, 2 and 4 are even.
*
        pseudo(,'align',2)
        (differ(i.text(i1)) pseudo(,'db',i.text(i1)), asm('nop'))
*  here to see if want label made public
*	output = 'g.ent label ' inlabel
*        (differ(pubtab[inlabel]), differ(debug)) pseudo(,'global',inlabel)
        pseudo(,'global',inlabel)
	deflabel() 				
						:(opdone)
g.bri	
	asm('jmp',getarg(i1))			
						:(opdone)
g.lei	t1 = regmap[i.text(i1)]
	asm('movzx',t1,'byte [' t1 '-1]')	
						:(opdone)
g.jsr	
	jsr_proc = getarg(i1)
	asm('call',jsr_proc)		
*	get count of following ppm statements
	jsr_count = ppm_cases[jsr_proc]
*	output = ne(jsr_count) ilines ' ' ' jsr ' getarg(i1) ' ' jsr_count
	eq(jsr_count)				:s(opdone)
	jsr_calls = jsr_calls +  1
	jsr_label = 'call_' jsr_calls
	jsr_label_ok = jsr_label '_ok'
	jsr_label_exi = jsr_label '_exi'
*	generate branch around for ppms that will follow
*	take the branch if normal return (eax==0)
	deflabel(jsr_label_exi)
	asm('dec','eax.w0')
*`	l1 = genlabel()
	asm('js',jsr_label_ok)
						:(opdone)
g.ppm
*  last arg is optional. generate four bytes
	ident(i.text(i1))			:s(g.ppm1)
	count.ppm = count.ppm + 1
	asm('dec','eax')
	asm('js',	getarg(i1))
	jsr_count = jsr_count - 1
	eq(jsr_count) pseudo(jsr_label_ok)
						:(opdone)
g.ppm1
*  a ppm with no arguments, which should never be executed, is
*  translated to err 299,internal logic error: unexpected ppm branch
	t1 = 299
	errfile =  t1 ' internal logic error: unexpected ppm branch'
						:(g.err1)

g.prc
	deflabel(prc_label)
	prc.args = getarg(i2)
	max_exi = gt(prc.args,max_exi) prc.args
	prc.type = i.text(i1)		:($('g.prc.' prc.type))

g.prc.e

g.prc.r						
						:(opdone)
g.prc.n
*  store return address in reserved location
	prc.count = prc.count + 1
	asm('pop','dword [' prcent(prc.count) ']')	
						:(opdone)
g.enp   					:(opdone)

g.exi	
	t1 = getarg(i1); t2 = prc.type; t3 = i.text(i1)
	t3 = ident(t3) '0'
	asm('mov','eax',t3)
	asm('ret')
						:(opdone)

g.err
*  assume ax is zero, then err nnn,text is translated to
*       dd  err-nnn
*  and will be branched through indirectly
*  where the sequence of instructions
*	inc eax
*	inc eax
*  err	mov	wa,eax
*	jmp	sec07
*  is defined elsewhere.
*  remove '0' prefix from t1 so it's not perceived as an octal constant by assembler.
	count.err = count.err + 1
	errfile =  i.text(i1) ' ' i.text(i2)
	t1 = getarg(i1)
g.err1	
	max.err = gt(t1,max.err) t1
	asm('dec','eax')
 	asm('js','err_' lpad(t1,3,'0'))
	jsr_count = jsr_count - 1
	eq(jsr_count) deflabel(jsr_label_ok)
						:(opdone)
g.erb
	count.erb = count.erb + 1	
	errfile =  i.text(i1) ' ' i.text(i2)
	t1 = getarg(i1)
 	asm('js','err_' lpad(t1,3,'0'))
						:(opdone)
g.icv   asm('inc',getarg(i1))    		
						:(opdone)
g.dcv   asm('dec',getarg(i1))
						:(opdone) 
g.zer	ident(i.text(i1),'(xr)+') asm('xor','eax','eax')
+		asm('stosd')			:s(opdone)
	ifreg(i1)				:s(g.zer1)
	ident(i.text(i1),'-(xs)')		:s(g.zer.xs)
	asm('xor','eax','eax')
	asm('mov',getarg(i1),'eax')		
						:(opdone)
g.zer1	
	t1 = getarg(i1)
	asm('xor',t1,t1)			
						:(opdone)
g.zer.xs 
	asm('push','0')			
						:(opdone)
g.mnz   
	asm('mov',getarg(i1),'esp')		
						:(opdone)
g.ssl   					
						:(opdone)
g.sss   					
						:(opdone)

g.rtn
*	generate public declaration and then regenerate label
	
						:(opdone)

g.add
*	bring second argument to register	
	i2 = memmem(i2)
*	outfile = 'ADD ' ilines ' ' getarg(i1) ' ' getarg(i2)
	asm('add',getarg(i1),getarg(i2))	:(opdone)

g.sub	
*	bring second argument to register	
	i2 = memmem(i2)
	asm('sub',getarg(i1),getarg(i2))	:(opdone)

g.ica   asm('add',getarg(i1),'4')		:(opdone)

g.dca   asm('sub',getarg(i1),'4')		:(opdone)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi
*
*  these operators all have two operands, memmem may apply
*  issue target opcode by table lookup.
*
*	bring first argument to work register
	i1 = memmem(i1)
	t1 = branchtab[incode]
	asm('cmp',getarg(i1),getarg(i2))
	asm(branchtab[incode],getarg(i3))
.						:(opdone)

g.bnz
	ifreg(i1)				:s(g.bnz1)
        asm('cmp', getarg(i1), '0')
	asm('jnz',getarg(i2))			
						:(opdone)
g.bnz1	
	asm('or',getarg(i1), getarg(i1))
	asm('jnz',getarg(i2))			
						:(opdone)
g.bze   
	ifreg(i1)				:s(g.bze1)
        asm('cmp', getarg(i1), '0')
	asm('jz', getarg(i2))			
						:(opdone)
g.bze1
	t1 = getarg(i1)
	asm('or', t1,t1)
	asm('jz', getarg(i2))			:(opdone)

g.lct
*
*  if operands differ must emit code
*
	differ(i.text(i1),i.text(i2))		:s(g.lct.1)
*  here if operands same. emit no code if no label, else emit null
	ident(inlabel)				:s(opnext)
						:(opdone)

g.lct.1	asm('mov', getarg(i1), getarg(i2))	:(opdone)

g.bct
*  can issue loop if target register is cx.
	t1 = getarg(i1)
	t2 = getarg(i2)
	ident(t1,'ecx')				:s(g.bct1)
g.bct2	asm('dec',t1)
	asm('jnz',t2)				:(opdone)
g.bct1	asm('loop',t2)			:(opdone)

g.aov   asm('add',getarg(i1),getarg(i2))
	asm('jc',getarg(i3))			:(opdone)
g.lcp
*  use cp for code pointer.
	asm('mov',reg.cp,getarg(i1))		:(opdone)
g.scp   asm('mov',getarg(i1),reg.cp)		:(opdone)
g.lcw
*  should be able to get lodsd; xchg eax,getarg(i1)
	asm('mov',getarg(i1),'[' reg.cp ']')
	asm('add',reg.cp,'4')			:(opdone)


g.icp   asm('add',reg.cp,'4')			:(opdone)

*  integer accumulator kept in wdx (wc)
g.ldi	asm('mov',reg.ia,getarg(i1))		:(opdone)

g.adi   asm('add',reg.ia,getarg(i1))		:(opdone)

g.mli	asm('imul',reg.ia,getarg(i1))		:(opdone)

g.sbi   asm('sub',reg.ia,getarg(i1))		:(opdone)

g.dvi
*	move argument to eax, call procedure
	asm('mov','eax',getarg(i1))
	asm('dvi_')	:(opdone)

g.rmi
*	move argument to eax, call procedure
	asm('mov','eax',getarg(i1))
	asm('rmi_')	:(opdone)

g.sti   asm('mov',getarg(i1),reg.ia)		:(opdone)

g.ngi   asm('neg',reg.ia)			:(opdone)

g.ino   asm('jno',getarg(i1))			:(opdone)
g.iov   asm('jo',getarg(i1))			:(opdone)

g.ieq	asm('or',reg.ia,reg.ia)
	asm('je',getarg(i1))			:(opdone)
g.ige   asm('or',reg.ia,reg.ia)
	asm('jge',getarg(i1))			:(opdone)
g.igt   asm('or',reg.ia,reg.ia)
	asm('jg',getarg(i1))			:(opdone)
g.ile   asm('or',reg.ia,reg.ia)
	asm('jle',getarg(i1))			:(opdone)
g.ilt   asm('or',reg.ia,reg.ia)
	asm('jl',getarg(i1))			:(opdone)
g.ine   asm('or',reg.ia,reg.ia)
	asm('jne',getarg(i1))			:(opdone)



*
*  real operations
*
g.itr	asm('itr_')	:(opdone)

g.rti	asm('rti_')
	eq(i.type(i1))				:s(opdone)
*  here if label given, branch if real too large
        asm('jc',getarg(i1))                 :(opdone)

g.ldr
g.str
g.adr
g.sbr
g.mlr
g.dvr	
*  unlike the other minimal registers, ra is maintained not as a single
*  storage location, but as two successive 32-bit words, due to the x86
*  architecture. The consequence here is that we must deal with the address
*  of the ra, not its value.
	t1 = getarg(i1)
	typ1 = i.type(i1)
* 	output = 'g.rop before dword test ' t1 ' ' typ1
*	t1 'dword [' break(']') . leaarg rem
	t1 'dword' =
	t1 = trim(t1)
*	output = 'g.rop after dword test ' t1 ' leaarg ' leaarg
	(ge(typ1,9) le(typ1,15) asm('lea','eax', t1),
+	 ge(typ1,3) le(typ1,4)  asm('lea','eax', t1),
+               asm('mov','eax', getarg(i1)))
	asm(incode '_')		:(opdone)

g.ngr
g.atn
g.chp
g.cos
g.etx
g.lnf
g.sin
g.sqr
g.tan	asm(incode '_')
						:(opdone)


g.rno	t1 = 'jno'				:(g.rov1)
g.rov	t1 = 'jo'
g.rov1  asm('ovr_')
	asm(t1,getarg(i1))			:(opdone)

g.req	t1 = 'je'				:(g.r1)
g.rne	t1 = 'jne'				:(g.r1)
g.rge	t1 = 'jge'				:(g.r1)
g.rgt	t1 = 'jg'				:(g.r1)
g.rle	t1 = 'jle'				:(g.r1)
g.rlt	t1 = 'jl'
g.r1	asm('cpr_')
	asm(t1,getarg(i1))			:(opdone)

g.plc
g.psc
*  last arg is optinal.  if present and a register or constant,
*  use lea instead.

	t1 = getarg(i1)
	t2 = i.type(i2)
	((ifreg(i2), ge(t2,1) le(t2,2))
+	asm('lea',t1,'[cfp$f+' t1 '+' getarg(i2) ']')) :s(opdone)
	asm('add',t1,'cfp$f')
	eq(i.type(i2))				:s(opdone)
*
*  here if offset given (in a variable), so add it in.
*
	asm('add',t1,getarg(i2))		:(opdone)
*
*  lch requires separate cases for each first operand possibility.
*
g.lch
	t2 = i.text(i2)
	t1 = getarg(i1)

*  see if predecrement.
	leq('-',substr(t2,1,1))			:f(g.lcg.1)
	t2 break('(') len(1) len(2) . t3
	asm('dec',regmap[t3])
g.lcg.1
	t2 break('(') len(1) len(2) . t3
	asm('movzx',t1,'byte [' regmap[t3] ']')

*  see if postincrement needed
	t2 rtab(1) '+'				:f(g.lcg.2)
	asm('inc',regmap[t3])
g.lcg.2						:(opdone)

g.sch
	t2 = i.text(i2)
	eq(i.type(i1),8)			:s(g.scg.w)
	t1 = getarg(i1)
	ident(t2,'(xr)+')			:f(g.scg.0)
*
*  here if can use stosb.
*
	asm('mov','al',getarg(i1))
	asm('stosb')				:(opdone)

g.scg.0
	leq('-',substr(t2,1,1))			:f(g.scg.1)
	t2 break('(') len(1) len(2) . t3
	asm('dec',regmap[t3])
g.scg.1
	t2 break('(') len(1) len(2) . t3
	asm('mov','eax',t1,)
	asm('mov','[' regmap[t3] ']','al')
*  see if postincrement needed.
	t2 rtab(1) '+'				:f(g.scg.2)
	asm('inc',regmap[t3])
g.scg.2						:(opdone)
g.scg.w
*
*  here if moving character from work register, convert t1
*  to name of low part.
*
	t1 = substr(regmap[i.text(i1)],2,1) 'l'
	output = 'scg.w ' i.text(i1) ':' t1 ':'
	ident(t2,'(xl)')			:s(g.scg.w.xl)
	ident(t2,'-(xl)')			:s(g.scg.w.pxl)
	ident(t2,'(xl)+')			:s(g.scg.w.xlp)
	ident(t2,'(xr)')			:s(g.scg.w.xr)
	ident(t2,'-(xr)')			:s(g.scg.w.pxr)
	ident(t2,'(xr)+')			:s(g.scg.w.xrp)
g.scg.w.xl
	asm('mov','[esi]',t1)			:(opdone)
g.scg.w.pxl
	asm('dec','esi.xl')
	asm('mov','[esi.xl]',t1)			:(opdone)
g.scg.w.xlp
	asm('mov','[esi.xl]',t1)
	asm('inc','esi')			:(opdone)
g.scg.w.xr
	asm('mov','[edi.xr]',t1)			:(opdone)
g.scg.w.pxr
	asm('dec','edi.xr')
	asm('mov','[edi.xr]',t1)			:(opdone)
g.scg.w.xrp
	asm('mov','al',t1)
	asm('stosb')				:(opdone)
g.csc  	
						:(opdone)

g.ceq
*	bring first argument to register
	i1 = memmem(i1)
	asm('cmp',getarg(i1),getarg(i2))
	asm('je',getarg(i3))			:(opdone)

g.cne   
*	bring first argument to register
	i1 = memmem(i1)
	asm('cmp',getarg(i1),getarg(i2))
	asm('jnz',getarg(i3))			:(opdone)

g.cmc
*	repe	cmpsb		;compare strings
*	mov	esi,0		;clear xl (without changing flags)
*	mov	edi,esi		;v1.02  xr also
*
	asm('repe','cmpsb')
	asm('mov','esi','0')
	asm('mov','edi','esi')
	t1 = getarg(i1)
	t2 = getarg(i2)
	(ident(t1,t2) asm('jnz',t1))		:s(opdone)
	asm('ja',t2)
	asm('jb',t1)				:(opdone)

g.trc
*	xchg	esi,edi
*  tmp	movzx   eax,byte ptr [edi]	;get character
*	mov	al,[esi+eax]		;translate
*	stosd				;put back and increment ptr
*	loop	tmp
*	xor	esi,esi			;set xl to zero
*	xor	edi,edi			;v1.02  xr also
	asm('xchg','esi','edi')
        trc.label = genlab()
	deflabel(trc.label)
	asm('movzx','eax','byte [edi]')
	asm('mov','al','byte [esi+eax]')
	asm('stosb')
	asm('loop',trc.label)
	asm('xor','esi','esi')
	asm('xor','edi','edi')		
						:(opdone)


g.anb   asm('and',getarg(i1),getarg(i2))	:(opdone)

g.orb   asm('or',getarg(i1),getarg(i2))	:(opdone)

g.xob   asm('xor',getarg(i1),getarg(i2))	:(opdone)

g.cmb   asm('not',getarg(i1))			:(opdone)

g.rsh
	asm('shr',getarg(i1),getarg(i2))		:(opdone)

g.lsh
	asm('shl',getarg(i1),getarg(i2))		:(opdone)

g.rsx	t1 = regmap[substr(i.text(i2),2,2)]
	ident(i.text(i1),'wa')				:s(g.rsx.c)
	asm('xchg',t1,'ecx')
	asm('shr',getarg(i1),'cl')
	asm('xchg',t1,'ecx')				:(opdone)

g.rsx.c	asm('xchg',t1,'ecx')
	asm('shr',t1,'cl')
	asm('xchg',t1,'ecx')				:(opdone)

g.lsx	t1 = regmap[substr(i.text(i2),2,2)]
	ident(i.text(i1),'wa')				:s(g.lsx.c)
	asm('xchg',t1,'ecx')
	asm('shl',getarg(i1),'cl')
	asm('xchg',t1,'ecx')				:(opdone)

g.lsx.c	asm('xchg',t1,'ecx')
	asm('shl',t1,'cl')
	asm('xchg',t1,'ecx')				:(opdone)

g.nzb	ifreg(i1)				:s(g.nzb1)
	asm('cmp',getarg(i1),'0')
	asm('jnz',getarg(i2))			:(opdone)
g.nzb1	asm('or',getarg(i1),getarg(i1))
	asm('jnz',getarg(i2))			:(opdone)

g.zrb	ifreg(i1)				:s(g.zrb1)
	asm('cmp',getarg(i1),'0')
	asm('jz',getarg(i2))			:(opdone)
g.zrb1	asm('or',getarg(i1),getarg(i1))
	asm('jz',getarg(i2))			:(opdone)

* x86 is a little-endian machine, so zgb must swap bytes.
*
* note that on a 486 and later cpu, this can be done with one instruction, bswap.
* should consider abandoning the x86 so can use bswap.
*
g.zgb	t1 = getarg(i1)			;* 32-bit register name, e.g., edx
        t2 = substr(t1,2,1) 'l'         ;* 8-bit low register name, e.g., dl
	t3 = substr(t1,2,1) 'h'		;* 8-bit high register name, e.g., dh
	asm('xchg',t2,t3)		;* e.g., xchg dl,dh
	asm('rol',t1,16)		;* e.g., rol edx,16
	asm('xchg',t2,t3)		;* e.g., xchg dl,dh
						:(opdone)

g.wtb   asm('sal',getarg(i1),'2')		:(opdone)
g.btw   asm('shr',getarg(i1),'2')		:(opdone)

g.mti	(ident(i.text(i1),'(xs)+') asm('pop',reg.ia)) :s(opdone)
	asm('mov',reg.ia,getarg(i1))		:(opdone)

g.mfi
*  last arg is optional
*  compare with cfp$m, branching if result negative
	eq(i.type(i2))				:s(g.mfi1)
*  here if label given, branch if wc not in range (ie, negative)
	asm('or',reg.ia,reg.ia)
	asm('js',getarg(i2))
g.mfi1	ident(i.text(i1),'wc') 		:s(opdone)
	ident(i.text(i1),'-(xs)') asm('push',reg.ia)	:s(opdone)
	asm('mov',getarg(i1),reg.ia)		:(opdone)

g.ctw
*  assume four chars per word
	t1 = getarg(i1)
	asm('add',t1,'3+4*' i.text(i2))
	asm('shr',t1,'2')		:(opdone)

g.ctb
*  use add w,val*cfp.b+3; and w,-4
	t1 = getarg(i1)
	asm('add',t1,'3+4*' i.text(i2))
	asm('and',t1,'-4')	:(opdone)

g.cvm	t1 = getarg(i1)
	asm('imul',reg.ia,'10')
	asm('jo',t1)
	asm('sub',regmap['wb'],'ch$d0')
	asm('sub',reg.ia,regmap['wb'])
	asm('jo',t1)				:(opdone)

g.cvd	asm('cvd_')			:(opdone)

g.mvc
*	move chars from xl (esi) to xr (edi), count in wa (ecx)
*
*  the following sequence "old method" is shorter than the "new method"
*  shown below, but is much slower because of the conditional jumps that
*  cause the instruction cache to be flushed for 3 out of 4 count values.
*
*  old method:
*	shr	ecx,1
*	jnc	tmp1
*	movsb		; move odd byte
*  tmp1	shr	ecx,1
*	jnc	tmp2
*	movsw		; move odd word
*  tmp2 rep	movsd	; move string as double words
*
*	asm('shr','ecx','1')
*	asm('jnc','short ' (t1 = genlab()))
*	asm('movsb')
*       asm(t1)
*       asm('shr','ecx','1')
*	asm('jnc','short ' (t1 = genlab()))
*	asm('movsw')
*       asm(t1)
*       asm('rep','movsd')        :(opdone)
*
*  new method:
*	shrd	eax,ecx,1 ; preserve ecx[0] in eax[31]
*	shr	ecx,2	  ; preserve ecx[1] in cy, divide by 4
*	rep	movsd	  ; move dwords, leaves ecx=0
*	adc	ecx,ecx	  ; copy cy to ecx[0]
*	rep	movsw	  ; copy 1 or 0 words, leaves ecx=0
*	shld	ecx,eax,1 ; copy eax[31] to ecx[0]
*	rep	movsb	  ; copy 1 or 0 bytes
*
	asm('shrd','eax','ecx','1')
	asm('shr','ecx','2')
	asm('rep','movsd')
	asm('adc','ecx','ecx')
	asm('rep','movsw')
	asm('shld','ecx','eax','1')
	asm('rep','movsb')			:(opdone)

g.mvw
	asm('shr','ecx','2')
	asm('rep','movsd')			:(opdone)

g.mwb
*   move words backwards
	asm('shr','ecx','2')
	asm('std')
	asm('lea','esi','[esi-4]')
	asm('lea','edi','[edi-4]')
	asm('rep','movsd')
	asm('cld')				:(opdone)

g.mcb
*   move characters backwards
	asm('std')
	asm('dec','esi')
	asm('dec','edi')
	asm('rep','movsb')
	asm('cld')				:(opdone)

g.chk   
 	asm('cmp', 'esp', 'stklo')
	asm('jb','sec06')			:(opdone)

decend
*  here at end of dic or dac to see if want label made public
*	tlabel ? rtab(1) . tlabel label.delim
*        differ(pubtab[tlabel]) asm('global',label)  
						:(opdone)

g.dac	
	t1 = i.type(i1)
        t2 = "" ;*(le(t1,2) "", le(t1,4) " ", le(t1,6) " ", "")
        pseudo(inlabel,'dd',t2 i.text(i1))		:(decend)

g.dic   
	pseudo(inlabel,'dd',i.text(i1))		:(decend)

*
* make sure don't attach label to the align.
*
*
g.drc   pseudo(,'align','4')
        pseudo(inlabel,'dq', i.text(i1))
						:(opdone)

g.dtc
*  change first and last chars to " (assume / used in source)
	t1 = i.text(i1)
	t1 tab(1) rtab(1) . t2
	t3 = remdr(size(t2),4)
        t2 = '"' t2
*  append "\x00" if string has odd length to complete last dword
        t2 = ne(t3) t2 dupl('\x00',4 - t3)
        t2 = t2  '"'
        pseudo(inlabel,'dd',t2)              :(opdone)

g.dbc   
	pseudo(inlabel,'dd',getarg(i1))       
						:(opdone)
g.equ   
	pseudo(inlabel,'equ',i.text(i1))			
						:(opdone)
g.exp  	

	is_exp_procedure[inlabel] = 1
*	output = 'g.exp setting ppm_cases <' inlabel '> to ' i.text(i1)
	ppm_cases[inlabel] = i.text(i1)
	pseudo(,'extern',inlabel)
					:(opnext)

g.inp	
	prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
	ppm_cases[inlabel] = i.text(i2)
+						:(opnext)

g.inr						:(opnext)

g.ejc	
						:(opdone)

g.ttl	
        pseudo(';','"' i.text(i1) '"')      
						:(opdone)

g.sec	
	sectnow = sectnow + 1			:($("g.sec." sectnow))

* procedure declaration section
g.sec.1 
        pseudo(,'segment','.text')
        pseudo(,'global','sec01')
        deflabel('sec01:')             :(opdone)

* definitions section
g.sec.2 
        pseudo(,'segment','.data')
        pseudo(,'global','sec02')
        deflabel('sec02:')             :(opdone)

* constants section
g.sec.3 
        pseudo(,'segment','.data')
        pseudo(,'global','sec03')
        deflabel('sec03')     :(opdone)

* working variables section
g.sec.4 
	pseudo(,'global','esec03')
        pseudo('esec03')
        pseudo(,'segment','.data')
        pseudo(,'global','sec04')
        deflabel('sec04')     :(opdone)

*  here at start of program section.  if any n type procedures,
*  put out entry-word block declaration at end of working storage
g.sec.5
*  emit code to indicate in code section
*  get direction set to up.
        pseudo(,'global','esec04')
        pseudo('esec04')
        (gt(prc.count1) pseudo('prc$','times', prc.count1 ' dd 0'))
*       pseudo(,'global','lowspmin')
*       pseudo('lowspmin','dd','0')
	pseudo(,'global','stack.low')
	pseudo(,'global','stack.top')
	pseudo('stack.low','dd','0')
	pseudo('','times 500 dd','0')
	pseudo('stack.top','dd','0')
        pseudo(,'global','end_min_data')
        pseudo('end_min_data')
        pseudo(,'segment','.text')
        pseudo(,'global','sec05')
        deflabel('sec05')     
	generating_code = 1
						:(opdone)

*  stack overflow section.  output exi__n tail code
g.sec.6	i1 = 1
g.sec.6.1
*        (differ(debug) pseudo(,'global','exi__' i1))
        pseudo(,'global','exi__' i1)
        deflabel('exi__' i1)
	asm( 'movsx', 'eax','word [eax+' (2 * (i1 - 1)) ']')
        asm('add','eax', 'dffnc')
	asm('push','eax')
	asm('xor','eax','eax')
	asm('ret')
	flush()
	i1 = lt(i1,max_exi) i1 + 1		:s(g.sec.6.1)

* now being the stack overflow section
        pseudo(,'global','sec06')
        deflabel('sec06')             :(opdone)

*  error section.  produce code to receive erb's
g.sec.7

        pseudo(,'global','sec07')
        deflabel('sec07') 
*	flush()

*  loop to emit inc eax for each possible error code
*	allow for some extra cases in case of max.err bad estimate
	n1 = max.err +8
g.sec.7.1
	deflabel('err_' lpad(n1,3,'0'))
	ge(n1 = n1 - 1) asm('inc','eax')	:s(g.sec.7.1)
        deflabel('err_')
	asm('xchg',reg.wa,'eax')



opdone	flush()					:(opnext)
*
*  here to emit bstmts, cstmts, astmts. attach input label and
*  comment to first instruction generated.
*
flush	eq(astmts.n) eq(bstmts.n) eq(cstmts.n)	:f(opdone1)
*
*  here if no statements, so output single 'null' statement to get label
*  and comment field right.
*
	outstmt(stmt())			:(opdone.6)
opdone1	eq(bstmts.n)				:s(opdone.2)
	i = 1
opdone.1
	outstmt(bstmts[i])
	le(i = i + 1, bstmts.n)			:s(opdone.1)

opdone.2	eq(cstmts.n)			:s(opdone.4)
	i = 1
opdone.3
	outstmt(cstmts[i])
	le(i = i + 1, cstmts.n)			:s(opdone.3)

opdone.4	eq(astmts.n)			:s(opdone.6)
	i = 1
	ident(pifatal[incode])			:s(opdone.5)
*  here if post incrementing code not allowed
	error('post increment not allowed for op ' incode)
opdone.5	outstmt(astmts[i])
	le(i = i + 1, astmts.n)			:s(opdone.5)
opdone.6 astmts.n = bstmts.n = cstmts.n =	:(return)
flush_end

g.end
* DS END 
	ident(havehdr)				:s(g.end.2)
*  here to copy remaining part from hdr file
g.end.1	line = hdrfile				:f(g.end.2)
	ntarget = ntarget + 1
	olines = olines + 1
	outfile = line				:(g.end.1)
g.end.2
        outstmt(stmt(,,,,,comment))


	endfile(1)

g.end.3 
g.end.4 
	host(1,"touch " parms ".err")
        output = rpad('lines read:',24)		 	ilines 
        output = rpad('minimal statements:',24)	 nstmts 
        output = rpad('assembler statements:',24)	 asm_count 
        output = rpad('assembler instructions:',24)	 ntarget 
        output = rpad('assembly declarations:',24)	 asm_pseudo
        output = ne(noptim1) ' "or" optimizations:' 	 noptim1 
        output = rpad('maximum err/erb number',24)	 max.err 
        output = rpad('prc count:',24)			 prc.count1 
	output = rpad('erb,err,ppm counts:',24) ' ' count.err ' ' count.err 
        output = gt(prc.count,prc.count1)
+		' ' count.ppm
.	  'differing counts for n-procedures:'
.	  ' inp ' prc.count1 ' prc ' prc.count
        output = ne(nerrors) 'errors detected: '  nerrors 
	errfile = '* ' max.err ' maximum err/erb number: '
	errfile  = '* ' prc.count ' prc count: '
.		differ(lasterror) 'the last error was in line ' lasterror
	&code   = ne(nerrors) 2001
*        output = collect() ' free words'
	labtab =
	&dump = 0
	:(end)
end
