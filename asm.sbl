.def comment_asterisk
-title mincod: phase 2 translation from minimal tokens to 80386 code
-stitl description
/*
 copyright 1987-2012 robert b. k. dewar and mark emmer.
 copyright 2012-2015 david shields

 this file is part of macro spitbol.

	macro spitbol is free software: you can redistribute it and/or modify it under the terms of the 
	gnu general public license as published by the free software foundation, either version 2 of the license, or
	(at your option) any later version.

	macro spitbol is distributed in the hope that it will be useful, but without any warranty; without even 
	the implied warranty of merchantability or fitness for a particular purpose.  see the gnu general 
	public license for more details.

	you should have received a copy of the gnu general public license along with macro spitbol.  
	if not, see <http://www.gnu.org/licenses/>.

 no case folding
*/
-case  0

/*
	Hereafter: When we say 'asm' we really mean 'nasm,' and when we say 'gas' we mean 'as', the GNU assembler.

	Note:

	A symbol begins with a capital in the output assembly language iff it reflects a difference between asm 
	and gas that will be resolved later, either by one-line macros in the case of asm, or via expansion by 
def.sbl in the case of gas.

	For example, 'Mov_' is generated instead of 'mov' since asm wants destination before the source, whilst
	gas wants the destination after the source.


	this program takes input file in minimal token form and produces assembly code for intel 80386 processor.
	the program obtains the name of the file to be translated from the command line string in host(0).  
	options relating to the processing of comments can be changed by modifying the source.

	in addition to the minimal token file, the program requires the name of a "machine definition file" 
	that contains code specific to a particular 80386 assembler.

	you may also specify option flags on the command line to control the code generation.  
	the following flags are processed:

		compress	generate tabs rather than spaces in output file
		comments        retain full-line and end-of-line comments

	in addition to the normal minimal register complement, one scratch work register, w0 is defined.  
	see the register map below for specific allocations.

	this program is based in part on earlier translators for the it is based in part on earlier 
	translators for the dec vax (vms and un*x) written by steve duff and robert goldberg, and the
	pc-spitbol translator by david shields.
	
	to run under spitbol:

       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt

	reads <file>.lex	containing tokenized source code writes <file>.s with 80386 assembly code
	also writes <file>.err	with err and erb error messages parts of n.hdr  are prepended and appended to <file>.s
	also sets flags		to 1 after converting names to upper case also reads <file>.pub	for 
	debug symbols to be declared public

	example:
       spitbol -u v37:dos:compress codlinux.spt
*/

*	revision history:

        version = 'v1.12'
	rcode = '_rc_'

*	data structures

	data('minarg(i.type,i.text)')
	data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment)')


*	keyword initialization

	&anchor = &trim	= &dump = 1
	&dump = 3
	&stlimit = 10000000


*  useful constants

	letters = 'abcdefghijklmnopqrstuvwxyz'
	ucase		=	letters
	lcase		=	'abcdefghijklmnopqrstuvwxyz'
	nos		= 	'0123456789'
	tab		=	char(9)
	
	D_byte		=	'D_byte'
	D_char		=	'D_char'
	D_real		=	'D_real'
	D_word		=	'D_word'

* gas requires '$' before literals, nasm doesn't

.if asm
	Comment		= ';';* comment character
	literal_	= 
.fi
.if gas
	Comment		= '#';* comment character
	literal_	= '$'
.fi

*  function definitions

*  crack parses stmt into a stmt data plex and returns it. it fails if there is a syntax error.

	define('crack(line)operands,operand,char')

	define('chktrace()')

*	comregs - map minimal register names to target register names

	define('comregs(line)t,pre,word')

*  error is used to report an error for current statement

	define('a(text)')
	define('align(n)')
	define('error(text)')
	define('extern(var)')
	define('flush()')
	define('g(text)')
	define('genz()')
	define('genaop(stmt)')
	define('genbop(stmt)')
        define('genlab(prefix)')
	define('getreg(iarg)')
	define('global(var)')
	define('mem(ref)')
	define('mov(i1,i2)i.src,i.dst,t.src')
	define('op(gopc,gop1,gop2,gop3)')
	define('opl(gopl,gopc,gop1,gop2,gop3)tmp,opc')
	define('genrep(op)l1,l2)')
	define('getarg(iarg)txt,typ,pre,post')
	define('getlea(iarg)txt,typ,pre,post')
	define('getval(iarg)txt,typ,pre,post')
	define('ifreg(iarg)')
	define('memmemm()t')
	define('outline(txt)')
	define('prcent(n)')
	define('prsarg(iarg)l1,l2')
	define('report(num,text)')
	define('section(sec)')
	define('tblini(str)pos,cnt,index,val,lastval')

*  outstmt is used to send a target statement to the target code output file outfile

	define('outstmt(ostmt)label,opcode,op1,op2,op3,comment,t,stmtout')

*	readline is called to return the next non-comment line from the minimal input file (infile <=> lu1).   
*	note that it will not fail on eof, but it will return a minimal end statement

	define('readline()')

	options = host(0)
	os = 'unix';	ws = '64'
	output = 'options: ' options

*	add trailing colon so always have colon after an argument

	options = options ':'
option.next

*	ignore extraneous : in list (helps with writing makefiles)
	options ':' =				:s(option.next)
	options break(':') . option ':' =	:f(options.done)



	ident(option,'unix_32_asm')		:s(option.unix.32.asm)
	ident(option,'unix_32_gas')		:s(option.unix.32.gas)
	ident(option,'unix_64_asm')		:s(option.unix.64.asm)
	ident(option,'unix_64_gas')		:s(option.unix.64.gas)
	ident(option,'osx_32_gas')		:s(option.osx.32.gas)
	ident(option,'xt')			:s(option.xt)
	ident(option,'trc')			:s(option.trc)

* here if unknown option

	output = "error: unknown option '" option "', translation ends."
	&dump = 0				:(end)

option.unix.32.asm
	os = 'unix'; 	ws = '32';	assembler = 'asm'		:(option.next)
option.unix.32.gas
	os = 'unix'; 	ws = '32';	assembler = 'gas'		:(option.next)
option.unix.64.asm
	os = 'unix'; 	ws = '64';	assembler = 'asm'		:(option.next)
option.unix.64.gas
	os = 'unix'; 	ws = '64';	assembler = 'gas'		:(option.next)
option.osx.32.gas
	os = 'osx'; 	ws = '32';	assembler = 'gas'		:(option.next)
option.trc

*	turn on instruction trace
	i_trace = 1				:(option.next)
option.xt

*  x_trace turns on tracing for executable instructions

	x_trace = 1				:(option.next)

options.done
	target = os '_' ws
	report(target,'target')
	filebase = "s"

*	cfp_b is bytes per word, cfp_c is characters per word these should agree with values used in translator
*	set target-dependent configuration parameters

	:($('config.' ws))

config.32
	cfp_b = 4
	cfp_bm1 = 3
	cfp_c = 4
	log_cfp_b = 2
	log_cfp_c = 2
	op_b = 'b'

*	op_c is instruction suffix for minimal character size

	op_c = 'b'

*	op_w is instruction suffix for 32-bit word-size

.if asm
	op_w = 'd'
.fi
.if gas
	op_w = 'l'
.fi
	rel = ''

*	suffix for opcode to indicate double word (32 bits)
	o_ =	'd'
						:(config.done)

config.64

*	cfp_b is bytes per word, cfp_c is characters per word these should agree with values used in translator
	cfp_b = 8
	cfp_bm1 = 7
	cfp_c = 8
	log_cfp_b = 3
	log_cfp_c = 3
	op_b = 'b'
	op_c = 'b'
	op_w = 'q'

*	rel = 'rel '
*	suffix for opcode to indicate quad word (64 bits)

	o_ =	'q'



config.done

*	set ab_suspend to avoid emitting 'a' and 'b' statments which flushing code buffer.

	ab_suspend = 0

*	trc_limit is maximum number of calls to be generated if non-zero

	trc_limit = 000

*	set trc_first non-zero to skip first number of instructions that would generate trace

	trc_first = 1

*	will set in_executable when in part of program where executable instructions may occur

	trc_exec = 0

*	trc_suspend is set nonzero to temporarily disable the instruction trace.
*	it is initially nonzero so no trace can be emitted until reach code section.

	trc_suspend = 1

*	set in_skip when should not insert trace code, else assembly errors result.
*	start with skip on, turn off when see first start of code.

	trc_skip = 1
/*
	skip_on and skip_off are labels indicating the start and end, respectively, of sections of the code 
	that should not be traced, usually because they contain a loop instruction that won't
	compile if too much trace code is inserted.
*/
	skip_on = table(50)
	skip_off = table(50)

	define('skip_init(s)on,off')		:(skip_init.end)
skip_init	s break(':') . on ':' rem . off	:f(return)
	skip_on[on] = 1
	skip_off[off] = 1			:(return)
skip_init.end

*	skip_init('start:ini03')
   	skip_init('gbcol:gtarr')
*	skip_init('gtn01:gtnvr')
*	skip_init('bpf05:bpf07')
*	skip_init('scv12:scv19')
*	skip_init('exbl1:exbl2')
*	skip_init('exbl5:expan')
*	skip_init('prn17:prn18')
*	skip_init('ini11:ini13')
*	skip_init('oex13:oexp2')
*	skip_init('oex14:oexp6')
*	skip_init('bdfc1:b_efc')
*	skip_init('sar01:sar10')
*	skip_init('srpl5:srpl8')
*	skip_init('pflu1:pflu2')
*	skip_init('prpa4:prpa5')
*	skip_init('prn17:prn18')
*	skip_init('prtvl:prtt1')
*	skip_init('trim4:trim5')
*	skip_init('prnl1:prnl2')
*	skip_init('prti1:prtmi')
*	skip_init('srpl5:srpl8')



	sectnow = 0

*	ppm_cases gives count of ppm/err statments that must follow call to a procedure

	ppm_cases = table(50,,0)


	 p.comregs = break(letters) . pre span(letters) . word

*  exttab has entry for external procedures

	exttab = table(50)

*  labtab records labels in the code section, and their line numbers

	labtab = table(500)

*  for each statement, code in generated into three arrays of statements:

*	astmts:	statements after opcode (()+, etc.)
*	bstmts: statements before code (-(), etc)
*	cstmts: generated code proper

	astmts = array(20,'')
	bstmts = array(10,'')
	cstmts = array(20,'')

*  genlabels is count of generated labels (cf. genlab)

	genlabels = 0

*  initialize variables

	labcnt = outlines = nlines = nstmts = ntarget = nerrors = 0
	lastopc = lastop1 = lastop2 =
	data_lc = 0
	max_exi = 0

*  initial patterns

*  p.csparse parses tokenized line
	p.csparse = '|' break('|') . inlabel
.	'|' break('|') . incode
.	'|' break('|') . iarg1
.	'|' break('|') . iarg2
.	'|' break('|') . iarg3
.	'|' break('|') . incomment
	'|' rem . slineno

*  dispatch table

	argcase = table(100)
	argcase[01] = .getarg.c.1;	argcase[2]  = .getarg.c.2;	argcase[3]  = .getarg.c.3;
	argcase[04] = .getarg.c.4;	argcase[5]  = .getarg.c.5;	argcase[6]  = .getarg.c.6;
	argcase[07] = .getarg.c.7;	argcase[8]  = .getarg.c.8;	argcase[9]  = .getarg.c.9;
	argcase[10] = .getarg.c.10;	argcase[11] = .getarg.c.11;	argcase[12] = .getarg.c.12;
	argcase[13] = .getarg.c.13;	argcase[14] = .getarg.c.14;	argcase[15] = .getarg.c.15;
	argcase[16] = .getarg.c.16;	argcase[17] = .getarg.c.17;	argcase[18] = .getarg.c.18;
	argcase[19] = .getarg.c.19;	argcase[20] = .getarg.c.20;	argcase[21] = .getarg.c.21;
	argcase[22] = .getarg.c.22;	argcase[23] = .getarg.c.23;	argcase[24] = .getarg.c.24;
	argcase[25] = .getarg.c.25;	argcase[26] = .getarg.c.26;	argcase[27] = .getarg.c.27

	adrcase = table(50)
	adrcase[03] = .getlea.c.3;	adrcase[04] = .getlea.c.4;	adrcase[09] = .getlea.c.9;
	adrcase[12] = .getlea.c.12;	adrcase[13] = .getlea.c.13;	adrcase[14] = .getlea.c.14
	adrcase[15] = .getlea.c.15;

.if asm
	valcase = table(50)
	valcase[18] = .getval.c.18;	valcase[19] = .getval.c.19;	valcase[20] = .getval.c.20;
	valcase[21] = .getval.c.21;	valcase[22] = .getval.c.22
.fi
.if gas

	valtable = table(100)
.fi

*	pifatal maps minimal opcodes for which no a code allowed to nonzero value. such operations include 
*	conditional branches with operand of form (x)+

	pifatal = tblini(
.	'aov[1]beq[1]bne[1]bge[1]bgt[1]bhi[1]ble[1]blo[1]'
.	'blt[1]bne[1]bnz[1]ceq[1]cne[1]mfi[1]nzb[1]zrb[1]')

*	trace not working for mvc (x32/x64)

	is_executable = table(100)
	s =
+       'add adi adr anb aov atn bct beq bev bge bgt bhi ble blo blt bne bnz bod brn bri bsw btw '
+	'bze ceq chk chp cmb cmc cmp cne csc cos ctb ctw cvd cvm dca dcv eti dvi dvr erb esw etx flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx '
+	'mcb mfi mli mlr mnz mov mti mvw mwb ngi eti ngr nzb orb plc prc psc req rge rgt rle rlt rmi rne '
+	'rno rov rsh rsx rti rtn sbi sbr sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer zgb zrb'

*	don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)

is_exec.1
	s len(3) . opc ' ' =			:f(is_exec.2)
	is_executable[opc] = 1			:(is_exec.1)
is_exec.2
/*
	We say an opcode is 'simple' if it translates to a single machine instruction. We name the ops with 
	the instruction name, capitalizing the first letter, and appending an underline. 
	For example,  'Add_' represents 'add'.
*/
	simple_op = table(50)
	s = 'Add_ add And_ and Cmp_ cmp Dec_ dec Inc_ inc Or_ or Mov_ mov Not_ not Sal_ sal Sar_ sar Sub_ sub Xor_ xor '
simple_op.init
	s break(' ') . name ' ' break(' ') . opcode ' ' =	:f(simple_op.done)
.if asm
	simple_op[name] = opcode 		
.fi
.if gas
	simple_op[name] = opcode (eq(ws,32) 'l', 'q')	:(simple_op.init)
.fi
						:(simple_op.init)
simple_op.done

-stitl main program
/*
*  	follows the driver code for the "main" program.


*	loop until program exits via g.end

*	opnext is invoked to initiate processing of the next line from readline.  after doing this, opnext branches 
	to the generator routine indicated for this opcode if there is one.  the generators all have entry points 
	beginning with "g.", and can be considered a logical extension of the opnext routine.  the generators 
	have the choice of branching back to dsgen to cause the thisstmt plex to be sent to outstmt, or
  	of branching to dsout, in which case the generator must output all needed code itself.

	the generators are listed in a separate section below.
*/

*  get file name


* get definition file name following token file name, and flags.

*	filebase ? break(';:') . filebase len(1) (break(';:') | rem) . target
*+		((len(1) rem . flags) | '')
*	$replace(target,lcase,ucase) = 1

* parse and display flags, setting each one's name to non-null value (1).

 :(flgs.skip)
flgs	flags ? ((len(1) break(';:')) . flag len(1)) |
+	 ((len(1) rem) . flag) =			:f(flgs2)
	flag = replace(flag,lcase,ucase)
        output = "  flag: " flag
	$flag = 1					:(flgs)

flgs.skip
flgs2

* various constants

	tab = char(9)
        comment.delim = ';'

	arg_w0 = minarg(8,'w0')
	arg_xl = minarg(7,'xl')
	arg_xr = minarg(7,'xr')

*  branchtab maps minimal opcodes 'beq', etc to desired target instruction

	branchtab = table(10)
	branchtab['beq'] = 'je'
	branchtab['bne'] = 'jne'
	branchtab['bgt'] = 'ja'
	branchtab['bge'] = 'jae'
	branchtab['ble'] = 'jbe'
	branchtab['blt'] = 'jb'
	branchtab['blo'] = 'jb'
	branchtab['bhi'] = 'ja'

*  optim.tab flags opcodes capable of participating in or optimization in outstmt routine

	optim.tab = table(10)
	optim.tab<"and"> = 1
	optim.tab<"add"> = 1
	optim.tab<"sub"> = 1
	optim.tab<"neg"> = 1
	optim.tab<"or"> = 1
	optim.tab<"xor"> = 1
	optim.tab<"shr"> = 1
	optim.tab<"shl"> = 1
	optim.tab<"inc"> = 1
	optim.tab<"dec"> = 1


*  ismem is table indexed by operand type which is nonzero if operand type implies memory reference.

	ismem = array(30,0)
	ismem<3> = 1; ismem<4> = 1; ismem<5> = 1
	ismem<9> = 1; ismem<10> = 1; ismem<11> = 1
	ismem<12> = 1; ismem<13> = 1; ismem<14> = 1
	ismem<15> = 1

*  regmap maps minimal register name to target machine register/memory-location name.

	regmap = table(30)
	s = 'xlXLxrXRxsXSxtXTwaWAwbWBwcWCw0W0iaIAcpCP'
regmap.loop
	s len(2) . min len(2) . reg =		:f(regmap.done)
	regmap[min] = reg			:(regmap.loop)
regmap.done

	reglow = table(10)
.if asm
	s = 'w0 W0_L wa WA_L wb WB_L wc WC_L '
.fi
.if gas
	s = 'w0 %al wa %cl wb %bl wc %dl '
.fi
reglow.loop
	s break(' ') . min ' ' break(' ') . reg ' '  = :f(reglow.done)
	reglow[min] = reg			:(reglow.loop)
reglow.done

	w0 = "JUNK_W0"
	w0_arg = minarg(8,'w0')

*  quick reference:

	reg.xl = regmap['xl']
	reg.xr = regmap['xr']
	reg.xs = regmap['xs']
	reg.w0 = regmap['w0']
	reg.wa = regmap['wa']
	reg.wb = regmap['wb']
	reg.wc = regmap['wc']
	reg.cp = regmap['cp']
	reg.ia = regmap['ia']

* real_op maps minimal real opcode to machine opcode

	real_op = table(10)
	real_op['adr'] = 'fadd'
	real_op['atn'] = 'fpatan'
	real_op['chp'] = 'frndint'
	real_op['cos'] = 'fcos'
	real_op['dvr'] = 'fdiv'
	real_op['ldr'] = 'fld'
	real_op['mlr'] = 'fmul'
	real_op['ngr'] = 'fchs'
	real_op['sbr'] = 'fsub'
	real_op['sin'] = 'fsin'
	real_op['sqr'] = 'fsqrt'
	real_op['str'] = 'fst'

*  other definitions that are dependent upon things defined in the machine definition file, and cannot 
be built until after the definition file has been read in.

*  p.outstmt examines output lines for certain types of comment contructions

	fillc	  = (ident(compress) " ",tab)
	p.outstmt = (break(fillc) . label span(fillc)) . leader
+			comment.delim rem . comment
	p.alltabs = span(tab) rpos(0)

*  strip end of comments if y

	strip_comment = (differ(comments) 'n', 'y')

*  base name of file

	basename = 'sbl'
        output = ~input(.infile,1,basename '.lex') "no input file"	:s(end)

inputok



*  associate output files.

        output = ~output(.outfile,2,basename '.s') "no output file"	:s(end)
outputok


* open file for compilation of minimal err and erb messages

        output = ~output(.errfile,3,basename '.err') "no error file"	:s(end)
err_ok
* 	&dump = 0

*  read in .equ file with value for symbols defined by equ opcode (this is really only needed for gas)

	output = ~input(.equfile,6,basename '.equ') 'cannot open equ file'	:s(end)
	equ_value = table(1000)
equ.copy
	line = equfile				:f(equ.end)
	line break(' ') . key ' ' rem . val
	equ_value[key] = val			:(equ.copy)
equ.end
	endfile(6)

*  read in pub file if it exists.  this contains a list of symbols to be declared public when encountered.

	pubtab = table(2)
	input(.pubfile,5, filebase ".pub")		:f(nopub)
	pubtab = table(101)
pubcopy	line = pubfile				:f(pubend)
	pubtab[line] = 1			:(pubcopy)
pubend	endfile(5)
nopub

						:(dsout)
-stitl comregs(line)t,pre,word
comregs
	line p.comregs =			:f(comregs1)
	word = eq(size(word),2) differ(t = regmap[word]) t
	comregs = comregs pre word		:(comregs)
comregs1 comregs = comregs line			:(return)
-stitl crack(line)
/*
	crack is called to create a stmt plex containing the various parts  of the minimal source statement 
	in line.  for conditional assembly ops, the opcode is the op, and op1 is the symbol.  
	note that dtc is handled as a special case to assure that the decomposition is correct.

	crack prints an error and fails if a syntax error occurs.
*/
crack   nstmts  = nstmts + 1
	op1 = op2 = op3 = typ1 = typ2 = typ3 =
	line    p.csparse			:s(return)

*  here on syntax error

	error('source line syntax error')	:(freturn)
-stitl a(text)
* emit text if using asm
a
.if asm
	a = text
.fi
						:(return)
-stitl align(n)

*  emit code to align on specified address

align
.if asm
	op('align',n)				
.fi
.if gas
	op('.balign',n,'0')
.fi
						:(return)
-stitl error(text)
/*
	this module handles reporting of errors with the offending statement text in inline.  
	comments explaining the error are written to the listing (including error chain), and the appropriate 
	counts are updated.
*/

error   outline('* *???* ' inline)
	outline('*       ' text)
.	          (ident(lasterror),'. last error was line ' lasterror)
	lasterror = outlines
	le(nerrors = nerrors + 1, 10)		:s(dsout)
        output = 'too many errors, quitting'  :(end)

-stitl g(text)

* emit text if using gas

g
.if gas
	g = text
.fi
						:(return)
-stitl genaop(stmt)
genaop

	astmts[astmts.n = astmts.n + 1] = stmt	:(return)
-stitl genbop(stmt)
genbop
	bstmts[bstmts.n = bstmts.n + 1] = stmt	:(return)

-stitl genlab(prefix)

*  generate unique labels for use in generated code

genlab	genlab = (differ(prefix) prefix,'')  '_' lpad(genlabels = genlabels + 1,4,'0') :(return)

-stitl opl(gopl,gopc,gop1,gop2,gop3)

*  generate operation with label

opl	
	ident(gopc)				:s(opl.done)
simple
	opc = simple_op[gopc]
	ident(opc)				:s(opl.done)
	gopc = opc
	simples = simples + 1
.if gas

*	Nothing to do if unary op.

	ident(gop2)				:s(opl.done)

*	here if binary op. Swap arguments since targeting gas

	tmp = gop1; gop1 = gop2; gop2 = tmp
.fi
opl.done
	cstmts[cstmts.n = cstmts.n + 1] =
.		tstmt(gopl,gopc,gop1,gop2,gop3)	:(return)

-stitl op(gopc,gop1,gop2,gop3)

*  generate operation with no label

op   opl(,gopc,gop1,gop2,gop3)            :(return)

-stitl getreg(iarg)

*  return register associated with argument for types 7-11

getreg
						:($('getreg.' i.type(iarg)))
getreg.7	
getreg.8	 getreg = i.text(iarg)			:(return)

getreg.9
getreg.10	getreg = substr(i.text(iarg),2,2)	:(return)

getreg.11	getreg = substr(i.text(iarg),3,2)	:(return)

-stitl global(var)

*	generate global directive

global
.if asm
	op('global',var)				:(return)
.fi
.if gas
	op('.global',var)				:(return)
.fi

-stitl mem(ref)
mem

*	invoke macro M to resolve ref at assembly

	ident(ref) error('null argument to mem')
	mem = 'Mem(' ref ')'				:(return)
-stitl mov(i1,i2)i.src,i.dst,t.src

*   translate 'mov' instruction
mov
/*
  perhaps change mov x,(xr)+ to
	mov ax,x; stows

	perhaps do  mov (xl)+,wx as
	lodsw
	xchg ax,tx
  and also mov (xl)+,name as
	lodsw
	mov name,reg.w0
	need to process memory-memory case
	change 'mov (xs)+,a' to 'pop a'
	change 'mov a,-(xs)' to 'push a'
*/
        i.src = i2; i.dst = i1
	t.src = i.text(i.src); t.dst = i.text(i.dst)
	ident(t.src,'(xl)+')			:s(mov.xlp)
	ident(t.src,'(xt)+')			:s(mov.xtp)
	ident(t.src,'(xs)+')			:s(mov.xsp)
	ident(t.dst,'(xr)+')			:s(mov.xrp)
	ident(t.dst,'-(xs)')			:s(mov.2)
	memmemm()
	op('Mov_',getarg(i1),getarg(i2))		:(return)
mov.xtp
mov.xlp
	ident(t.dst,'(xr)+') op('movs' op_w)	:s(return)
	op('lods' op_w)
	op('Mov_',getarg(i.dst),reg.w0)		:(return)
	ident(t.dst,'-(xs)') op('push',reg.w0)	:s(return)

mov.xsp
	ident(t.dst,'(xr)+')		:s(mov.xsprp)
	op('pop',getarg(i.dst))		:(return)
mov.xsrp
	op('pop',reg.w0)
	op('stos' op_w)				:(return) 
mov.xrp
	op('Mov_',reg.w0,getarg(i.src))
	op('stos' op_w)				:(return)
mov.2
	op('push',getarg(i.src))		:(return)

-stitl getarg(iarg)
getarg

*	imem is null to generate memory reference, otherwise just get address for use in 'Lea_' instruction.

.if gas
	base = disp = indx = scale =

.fi
	txt = i.text(iarg)
	typ = i.type(iarg)
	trc_suspend = 1
	eq(typ)					:f($(argcase[typ]))
	getarg = txt				:(getarg.done)

*	int

getarg.c.1 getarg = txt				:(getarg.done)

*	dlbl

getarg.c.2 getarg = txt				:(getarg.done)

*	wlbl, clbl

getarg.c.3
getarg.c.4 
.if asm
	getarg = mem(txt)			:(getarg.done)
.fi
.if gas
	disp = txt				:(getarg.mem)
.fi

* elbl, plbl

getarg.c.5
getarg.c.6 getarg = txt				:(getarg.done)

*	w,x, map register name

getarg.c.7
getarg.c.8
	getarg = regmap[txt]			:(getarg.done)

*	(x), register indirect

getarg.c.9
.if asm
	txt len(1) len(2) . typ
	typ = regmap[typ]
	getarg = mem( typ )
						:(getarg.done)
.fi
.if gas
	txt len(1) len(2) . indx		:(getarg.mem)
.fi
/*
	(x)+, register indirect, post increment use lea reg,[reg+cfp_b] unless reg is esp, 
	since it takes an extra byte.  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 
	2 cycles and 3 bytes for all the other regs, and either could be used.
*/
getarg.c.10
.if asm
	txt = substr(txt,2,2)
	t1 = regmap[txt]
	getarg = mem( t1 )
	(ident(txt,'xs') genaop(tstmt(,'Add_',t1,cfp_b))) :s(getarg.done)
	genaop(tstmt(,'Lea_',t1,'Adr(' t1 '+cfp_b)')):(getarg.done)
.fi
.if gas
	indx = substr(txt,2,2)
	genaop(tstmt(,'Add_',regmap[indx],literal_ cfp_b)) :(getarg.mem)
.fi

*	-(x), register indirect, pre decrement

getarg.c.11
.if asm
	t1 = regmap[substr(txt,3,2)]
	getarg = mem( t1 )
	genbop(tstmt(,'Lea_',t1,'Adr(' t1 '-cfp_b)')) :(getarg.done)
.fi
.if gas
	indx = substr(txt,3,2)
	genbop(tstmt(,'Sub_',regmap[indx],literal_ cfp_b,)) 	:(getarg.mem)
.fi

*	int(x)
*	dlbl(x)

getarg.c.12
getarg.c.13
.if asm
	txt break('(') . t1 '(' len(2) . t2
	getarg = mem('(cfp_b*' t1 ')+' regmap[t2])
						:(getarg.done)
.fi
.if gas
	txt break('(') . disp '(' len(2) . indx
	disp = cfp_b * equ_value[disp]
	base = indx
	indx = 					:(getarg.mem)
.fi

*	name(x), where name is in working section

getarg.c.14
getarg.c.15
.if asm
	txt break('(') . t1 '(' len(2) . t2
	getarg = mem(    t1 '+'  regmap[t2])
						:(getarg.done)
.fi
.if gas
	txt break('(') . disp '(' len(2) . indx	:(getarg.mem)
.fi

*	signed integer

getarg.c.16 getarg = txt			:(getarg.done)

*	signed real

getarg.c.17 getarg = txt			:(getarg.done)

.if asm
getarg.c.18
getarg.c.19
getarg.c.20
getarg.c.21
getarg.c.22
	getarg = getval(iarg)			:(getarg.done)
.fi
.if gas

*	=dlbl

getarg.c.18	
	getarg = literal_ substr(txt,2)		:(getarg.done)
	
*	*dlbl

getarg.c.19
	getarg  = literal_  cfp_b '*' substr(txt,2)	:(getarg.done)

*	=name (data section)

getarg.c.20
getarg.c.21
        getarg = literal_ substr(txt,2)	
						:(getarg.done)
	op('Lea_',reg.w0,substr(txt,2))
	getarg = reg.w0				:(getarg.done)

*	=name (program section)

getarg.c.22

       getarg = literal_ substr(txt,2)		:(getarg.done)

.fi

*	pnam, eqop
getarg.c.23
getarg.c.24 
.if asm
	getarg = txt				:(getarg.done)
.fi
.if gas
*	getarg = '$(' equ_value[txt] ')'	:(arg.done)
	getarg =  equ_value[txt]		:(arg.done)
.fi

*	ptyp, text, dtext
getarg.c.25
getarg.c.26
getarg.c.27 getarg = txt			:(getarg.done)
getarg.done
	trc_suspend = 0

*	ne(x_trace) outline('; arg ' typ ':' txt   ' -> ' getarg)
						:(return)
.if gas
getarg.mem
	getarg = differ(base) disp '(' regmap[base] ')'		:s(getarg.done)	
	getarg = ident(indx) disp 				:s(getarg.done)
	getarg = ident(scale) ident(disp) '(' regmap[indx] ')'	:s(getarg.done)
	getarg = ident(disp) ident(scale) '(' regmap[indx] ')' 	:s(getarg.done)
	getarg = differ(disp) ident(scale) disp '(' regmap[indx]  ')'	:s(getarg.done)
	error('getarg');

.fi
-stitl getlea(iarg)
getlea
.if asm
/*
	similar to getarg, but gets effective address this procedure only called if operand is
	ops: 3,4,9,12,13,14,15 imem is null to generate memory reference, otherwise just get
	address for use in 'Lea_' instruction.
*/
.fi
.if gas

*	similar to getarg, but gets effective address this procedure only called if operand is in 
*	range 3-4 or 9-15 it generates code to load effective address of the argument to w0

.fi
	txt = i.text(iarg)
	typ = i.type(iarg)
	eq(typ)					:f($(adrcase[typ]))

*	wlbl, clbl

getlea.c.3
getlea.c.4
.if asm
	getlea = txt	 			:(getlea.asm)
.fi
.if gas
i	op('Mov_',reg.w0,literal_ txt)		:(return)
.fi

*	(x), register indirect

getlea.c.9
	txt len(1) len(2) . typ
	typ = regmap[typ]
.if asm
	getlea = typ				:(getlea.asm)
.fi
.if gas
	op('Mov_',reg.w0,typ)			:(return)
.fi

*	int(x)
*	dlbl(x)

getlea.c.12
getlea.c.13
	txt break('(') . t1 '(' len(2) . t2
.if asm
	getlea = '(cfp_b*' t1 ')+' regmap[t2]	:(getlea.asm)
.fi
.if gas
	op('Mov_',reg.w0,regmap[t2])
	op('Add_',reg.w0,'(cfp_b*' t1 ')')	:(return)
.fi

*	name(x), where name is in working section

getlea.c.14
getlea.c.15
	txt break('(') . t1 '(' len(2) . t2
.if asm
	getlea = t1 '+'  regmap[t2]		:(getlea.asm)
.fi
.if gas
	op('Mov_',reg.w0,regmap[t2])
	op('Add_',reg.w0,t1)			:(return)
.fi
getlea.asm

*	here to generate Lea instruction (asm case)

	op('Lea_',reg.w0,'Adr(' getlea ')')	:(return)
-stitl getval(iarg)
getval

	txt = i.text(iarg)
	typ = i.type(iarg)
	output = lt(typ, 18) gt(typ.22) ' impossible type for getval ' typ
	eq(typ)					:f($(valcase[typ]))
	getarg = txt				:(getval.done)

*  =dlbl

getval.c.18
	getval = substr(txt,2)			:(getval.done)
getval.c.18.1
	getval = substr(txt,2)			:(getval.done)
*	*dlbl

getval.c.19
	getval = 'cfp_b*' substr(txt,2)		:(getval.done)
*	=name (data section)

getval.c.20
getval.c.21
        getval =  substr(txt,2)			:(getval.done)
*	=name (program section)
getval.c.22
        getval =  substr(txt,2)			:(getval.done)
getval.done
						:(return)

-stitl memmemm()t
memmemm
/*
	memmemm is called for those ops for which both operands may be in memory, in which case, 
	we generate code to load second operand to pseudo-register w0, and then modify the second argument
	to reference this register
*/

	eq(ismem[i.type(i1)])				:s(return)
	eq(ismem[i.type(i2)])				:s(return)

*	here if memory-memory case, load second argument

	t = getarg(i2)
	i2 = arg_w0
	op('Mov_',reg.w0,t)				:(return)

-stitl outline(txt)
outline
	outlines = outlines + 1
	outfile = txt
						:(return)

-stitl prcent(n)
prcent prcent = 'prc_+' cfp_b '*' ( n - 1)	:(return)

-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment)

*	this module writes the components of the statement passed in the argument list to the formatted .s file

outstmt	label = t.label(ostmt)

*	clear label if definition already emitted
	label = ident(label, lastlabel)

outstmt1
	comment = t.comment(ostmt)

*	ds suppress comments

 	comment = tcomment = comments =
 	:(outstmt2)

*  attach source comment to first generated instruction

	differ(comment)				:s(outstmt2)
	ident(tcomment)				:s(outstmt2)
	comment = tcomment; tcomment =
outstmt2
	opcode = t.opc(ostmt)
	op1 = t.op1(ostmt)
	op2 = t.op2(ostmt)
	op3 = t.op3(ostmt)

*	outfile = '; opcode ' opcode
*	outfile = '; op1 ' op1
*	outfile = '; op2 ' op2
*	outfile = '; op3 ' op3

	differ(compress)			:s(outstmt3)
	stmtout = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.		  (ident(op1), op1
.			(ident(op2), ',' op2
.				(ident(op3), ',' op3))) ,27)
.       (ident(strip_comment,'y'), ' ' (ident(comment), ';') comment)
.						:(outstmt4)
outstmt3
	stmtout = label tab opcode tab
.		  (ident(op1), op1
.		    (ident(op2), ',' op2
.		      (ident(op3), ',' op3)))
.       (ident(strip_comment,'y'), tab (ident(comment), ';') comment)

*	send text to outfile

outstmt4

*	send text to output file if not null.

*	stmtout = replace(trim(stmtout),literal_ ,'_')

	stmtout = trim(stmtout)
	ident(stmtout)				:s(return)
	outline(stmtout)
	ntarget	= ntarget + 1

*  record code labels in table with delimiter removed.

	(ge(sectnow,5) differ(thislabel))	:f(return)
	label ? break(':') . label		:f(return)
	labtab<label> = outlines		:(return)

-stitl  chktrace()
chktrace
	ident(i_trace)				:s(return)
	ne(trc_suspend)				:s(return)
	clabel = inlabel
 	old_trc_skip = trc_skip
 	old_trc_exec = trc_exec
 	old_is_exec = is_exec
	trc_skip = ident(inlabel,'s_aaa') 0

	is_exec = is_executable[incode]
	trc_exec = differ(i_trace)  ident(inlabel, 's_aaa') 1
	trc_exec = differ(i_trace) ge(sectnow,5) 1

* 	trc_skip  = differ(inlabel) differ(skip_on[inlabel]) 1
* 	trc_skip  = differ(inlabel) differ(skip_off[inlabel]) 0

	ne(trc_skip)				:s(return)
	eq(trc_exec)				:s(return)
	eq(is_exec)				:s(return)

*	ne(in_gcol)				:s(return)

chktrace.1

*	no trace if trace has been suspended

*	 only trace at label definition

*	ident(thislabel)			:s(return)

	trc_count = trc_count + 1

	gt(trc_first) le(trc_count,trc_first)	:s(return)
	gt(trc_limit)  gt(trc_count, trc_limit)	:s(return)

*	only trace an instruction once

	eq(nlines,nlast)			:s(return)
	nlast = nlines

	trc_desc = '"' replace(inline,'|',' ') '"'
	ab_suspend = 1
	section('data')
	flush()
	lbl = genlab('it')
.if asm
	opl(lbl,D_char,trc_desc)
	op(D_char,'0');* string terminator
.fi
.if gas
	opl(lbl ':' ,'.asciz',trc_desc)
.fi
	section('text')
	op('Mov_',reg.w0,literal_ lbl)
	op('Mov_',mem('trc_de'),reg.w0)
	op('call','trc_')
	flush()
	ab_suspend = 0
						:(return)

-stitl prsarg(iarg)
prsarg	prsarg = minarg(0)
	iarg break(',') . l1 ',' rem . l2	:f(return)
	prsarg = minarg(convert(l1,'integer'),l2)	:(return)
-stitl readline()
/*
	this routine returns the next statement line in the input file to the caller.  it never fails.  
	if there is no more input, then a minimal end statement is returned.
	comments are passed through to the output file directly.
*/


readline readline = infile                      :f(rl02)
	nlines  = nlines + 1

*	outfile = '$' lpad(nlines,6) tab readline

	ident( readline )			:s(readline)
readline.0
	leq( substr(readline,1,1 ),';' )       	:f(rl01)
	trc_skip = ident(readline,';i+') 0	:s(readline)

*	trc_skip = ident(readline,';i-') 1	:s(readline)

* force skip of full line comments

	:(readline)

*	only print comment if requested.

	ident(strip_comment,'n')		:f(readline)
	readline len(1) = ';'
	outlines = outlines + 1               :(readline)

*	here if not a comment line

rl01

*	add 2 since need to account for this line and one that will follow

	ne(x_trace) outline(Comment ':' outlines + 2 ':' tab readline) :(return)

*  here on eof

rl02    readline = '       end'
						:(rl01)
-stitl section(sec)

*	declare section of specified type asm requires op of section, operation of kind, gas just 
*	gives the kind as an op.

section
.if asm
	op('section', '.' sec)
.fi
.if gas
	op('.' sec)
.fi
						:(return)
-stitl tblini(str)

*	this routine is called to initialize a table from a string of index/value pairs.

tblini   pos     = 0

*	count the number of "[" symbols to get an assessment of the table size we need.

tin01   str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.						:s(tin01)

*	allocate the table, and then fill it. note that a small memory optimisation is attempted here by 
*	trying to re-use the previous value string if it is the same as the present one.

	tblini   = table(cnt)
tin02   str     (break('[') $ index len(1) break(']') $ val len(1)) =
.						:f(return)
	val     = convert( val,'integer' )
	val     = ident(val,lastval) lastval
	lastval = val
	tblini[index] = val			:(tin02)
-stitl generators

-stitl ifreg
ifreg	ge(i.type(iarg),7) le(i.type(iarg),8)
.						:f(freturn)s(return)

*	translate minimal

translate

	&trace = 2000
	&ftrace = 1000
*	&profile = 1
dsout
opnext	inline = readline()
	crack(inline)				:f(dsout)
	op_ = incode '_'

*	append ':' after label if in code or data.

*	output label of executable instruction immediately if there is one, as it simplifies later processing, 
*	especially for tracing.

	ident(inlabel)				:s(opnext.1)
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

* keep the label as is is not in executable code

	lt(sectnow,5)				:s(opnext.1)

*	here if in code, so output label now
*	defer label processing for ent to allow emission of alignment ops for x86.

	ident(incode,'ent')			:s(opnext.1)
	outline(thislabel)

*	set lastlabel so can check to avoid emitting duplicate label definitions

	lastlabel = thislabel

*	clear out label info once generated

	label = thislabel =
opnext.1
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
	i1 = prsarg(iarg1)
	i2 = prsarg(iarg2)
	i3 = prsarg(iarg3)
	tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' ' i.text(i2) ' ' i.text(i3)
	argerrs = 0
	differ(trc_trace) ge(sectnow,5) eq(trc_suspend) chktrace()
	ge(sectnow,5) chktrace()
						:($('g.' incode))
*  here if bad opcode

ds01	error('bad op-code')			:(dsout)

*	generate tokens.

ds.typerr
	error('operand type zero')		:(dsout)
g.flc
.if asm
	reg = reglow[getreg(i1)]
	lbl = genlab('flc')
*	trc_suspend = 1
	op('Cmpb_',reg,"'A'")
	op('jb', lbl)
	op('Cmpb_',reg,"'Z'")
	op('ja', lbl)
	op('Add_',reg,'32')
        opl(lbl ':')
*	trc_suspend = 0
.fi
.if gas
	
	txt = i.text(i1)
	reg = '%'  (ident(txt,'wa') 'c', ident(txt,reg.wb) 'b', 'd') 'l'
	lbl = genlab('flc')
	trc_suspend = 1
	op('cmpb',reg,"'A'")
	op('jb', lbl )
	op('cmpb',reg,"'Z'")
	op('ja', lbl)
	op('addb','$32',reg)
        opl(lbl ':')
	trc_suspend = 0
.fi
						:(opdone)
g.mov
	mov(i1,i2)				:(opdone)

*	even/odd tests.  Set w0 to zero, and with register, then branch accordingly

g.bev
g.bod
	op('Xor_',reg.w0,reg.w0)
	op('Inc_',reg.w0)
	op('And_',reg.w0,getarg(i1))
	op((ident(incode,'bod') 'jne', 'je'),getarg(i2)) :(opdone) 
g.brn  
	op('Jmp_',getarg(i1))			:(opdone)

g.bsw
	reg = getarg(i1)
	lbl = genlab('bsw')
	trc_suspend = 1
	ident(i.text(i3))			:s(g.bsw1)
	op('Cmp_',reg,literal_ getarg(i2))
	op('jge',getarg(i3))
* here after default case.
g.bsw1
.if asm
	op('Jmp_', mem( lbl '+' reg '*' cfp_b)) 
.fi
.if gas
	op('jmp','*' lbl '(,' reg ',' cfp_b ')' )
.fi
	section('data')
        opl(lbl ':')
	trc_suspend =				:(opdone)

g.iff   op(D_word,getarg(i2))              :(opdone)

g.esw
	section('text')		:(opdone)
g.ent
/*
	entry points are stored in byte before program entry label last arg is optional, in which case no 
	initial 'db' need be issued. we force odd alignment so can distinguish entry point addresses from 
	block addresses (which are always even).

	note that this address of odd/even is less restrictive than the minimal definition, which defines 
	an even address as being a multiple of cfp_b (4), and an odd address as one that is not a multiple 
	of cfp_b (ends in 1, 2, or 3).  the definition here is a simple odd/even, least significant bit definition.
	that is, for us, 1 and 3 are odd, 2 and 4 are even.
*/
	  t1 = i.text(i1)

*       align(2)

	outline(tab 'Align_' tab '2')
	differ(t1)				:s(g.ent.1)
	outline(tab 'nop')
						:(g.ent.2)
g.ent.1
	outline(tab a('db') g('.byte')  tab	t1)
g.ent.2
	opl(thislabel)
/*
	note that want to attach label to last instruction
	t1 = cstmts[cstmts.n]
	t.label(t1) = tlabel
	cstmts[cstmts.n] = t1
	here to see if want label made public
*/

	thislabel ? rtab(1) . thislabel ':'
	(differ(pubtab[thislabel]), differ(debug)) op('global',thislabel)
	thislabel =				:(opdone)
g.bri

*	need to indicate absolute jump for gas.

	op('Jmp_',g('*') getarg(i1))			:(opdone)

g.lei
	t1 = regmap[i.text(i1)]
.if asm
	op('movzx',t1,'byte [' t1 '-1]' )	:(opdone)
.fi
.if gas
	op('Dec_',t1)
	op('mov', '(' t1 ')', reglow['w0'])
	op('movz' (eq(ws,32) 'bl','bq'),reglow['w0'],t1) :(opdone)
.fi

g.jsr
	jsr_proc = getarg(i1)
	op('call',jsr_proc)

*	get count of following ppm statements

	jsr_count = ppm_cases[jsr_proc]
	eq(jsr_count)				:s(opdone)
	trc_suspend = 1
	jsr_calls = jsr_calls +  1
	jsr_label = 'call_' jsr_calls
	jsr_label_norm = jsr_label
	op('Dec_',mem( rcode ))
	op('js',jsr_label_norm)
	trc_suspend = 0

*	generate branch around for ppms that will follow take the branch if normal return (eax==0)

						:(opdone)

g.err
g.ppm
/*
	here with return code in rcode. it is zero for normal return and positive for error return. 
	decrement the value. if it is negative then this is normal return. otherwise, proceed decrementing 
	rcode until it goes negative,and then take the appropriate branch.
*/
	t1 = getarg(i1)

*	branch to next case if rcode code still not negative.

	ident(incode,'ppm')			:s(g.ppm.loop)
	count.err =  count.err + 1
	errfile =   i.text(i1) ' ' i.text(i2)
	max.err = gt(t1,max.err) t1
						:(g.ppm.loop)

g.ppm.loop.next
	opl(lab_next ':')
 	jsr_count = jsr_count - 1
 	trc_suspend = eq(jsr_count) 0
	eq(jsr_count) opl(jsr_label_norm ':') :(opdone)
g.ppm.loop
	lab_next = genlab('ppm')
	op('Dec_',mem(rcode) )
	op('jns',lab_next)
	ident(incode,'ppm')			:s(g.ppm.loop.ppm)

*	here if error exit via exi. set rcode to exit code and jump to error handler with error code in rcode

g.ppm.loop.err
	op('Mov_',mem(rcode), literal_ +t1)
	op('Jmp_','err_')
						:(g.ppm.loop.next)
g.ppm.loop.ppm

*	check each ppm case and take branch if appropriate

	ident(i.text(i1))			:s(g.ppm.2)
	count.ppm = count.ppm + 1
	op('Jmp_',getarg(i1))
						:(g.ppm.loop.next)

g.ppm.2
/*
	a ppm with no arguments, which should never be executed, is translated to 
		err 299,internal logic error: unexpected ppm branch
*/
	t1 = 299
	errfile =  t1 ' internal logic error: unexpected ppm branch'
						:(g.ppm.loop.err)

g.prc
/*
*	generate public declaration
*	t1 = thislabel
*	t1 ? rtab(1) . t1 ':'
*	op()
*	op('global',t1)
*	nop needed to get labels straight
*/
	prc.args = getarg(i2)
	ppm_cases[thislabel] = i.text(i2)
	thislabel =
	max_exi = gt(prc.args,max_exi) prc.args
	prc.type = i.text(i1)			:($('g.prc.' prc.type))
g.prc.e
g.prc.r						:(opdone)

g.prc.n

*	store return address in reserved location
	prc.count = prc.count + 1
	op('pop', mem(prcent(prc.count)))
						:(opdone)

g.exi
	t1 = getarg(i1); t2 = prc.type; t3 = i.text(i1)

*	if type r or e, and no exit parameters, just return

 	differ(t2,'n') eq(prc.args)	op('ret')	:s(opdone)
	t3 = ident(t3) '0'
	op('Mov_',mem(rcode),literal_ +t3)
	ident(t2,'n')				:s(g.exi.1)
	op('ret')				:(opdone)
g.exi.1
	op('Mov_',reg.w0, mem(prcent(prc.count)))
	op('Jmp_', g('*') reg.w0)			:(opdone)

g.enp   op()					:(opdone)

g.erb
	errfile =  i.text(i1) ' ' i.text(i2)

*	set rcode to error code and branch to error handler

	op('Mov_', mem(rcode),  literal_ +(i.text(i1)))
 	op('Jmp_','err_')
						:(opdone)

g.icv
	op('Inc_',getarg(i1))    		:(opdone)

g.dcv   
	op('Dec_',getarg(i1))    		:(opdone)

g.zer
	op('Xor_',reg.w0,reg.w0)		
	mov(i1,arg_w0)				:(opdone)
g.mnz
	op('Xor_',reg.w0,reg.w0)
	op('Inc_',reg.w0)
	mov(i1,arg_w0)				:(opdone)

g.ssl
g.sss
g.rtn
	op()					:(opdone)

g.add	memmemm()
	op('Add_',getarg(i1),getarg(i2))	:(opdone)

g.sub	memmemm()
	op('Sub_',getarg(i1),getarg(i2))	:(opdone)

g.ica
	op('Add_',getarg(i1),literal_ cfp_b)		:(opdone)

g.dca
	op('Sub_',getarg(i1),literal_ cfp_b)		:(opdone)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi

*	these operators all have two operands, memmemm may apply issue target opcode by table lookup.

	memmemm()
	t1 = branchtab[incode]
	op('Cmp_',getarg(i1),getarg(i2))
	op(branchtab[incode],getarg(i3))
						:(opdone)

g.bnz
	ifreg(i1)				:s(g.bnz1)
	op('Xor_',reg.w0,reg.w0)
	op('Cmp_',getarg(i1) ,reg.w0)
	op('jnz',getarg(i2))
						:(opdone)
g.bnz1
	op('or',getarg(i1),getarg(i1))
	op('jnz',getarg(i2))
						:(opdone)

g.bze   ifreg(i1)				:s(g.bze1)
	op('Xor_',reg.w0,reg.w0);* clear w0 t0 zero
        op('Cmp_', getarg(i1)  ,reg.w0)
	op('jz',getarg(i2))
						:(opdone)
g.bze1
	t1 = getarg(i1)
	op('or',t1,t1)
	op('jz',getarg(i2))			:(opdone)

g.lct

*  if operands differ must emit code

	differ(i.text(i1),i.text(i2))		:s(g.lct.1)

*	here if operands same. emit no code if no label, else emit null

	ident(thislabel)			:s(opnext)
	op()					:(opdone)

g.lct.1
	op('Mov_',getarg(i1),getarg(i2))	:(opdone)

g.bct

*  can issue loop if target register is cx.

	t1 = getarg(i1)
	t2 = getarg(i2)				:(g.bct2)
	ident(t1,reg.wa)			:s(g.bct1)
g.bct2
	op('Dec_',t1)
	op('jnz',t2)				:(opdone)
g.bct1
	op('loop',t2)				:(opdone)

g.aov
	op('Add_',getarg(i2),getarg(i1))
	op('jc',getarg(i3))
						:(opdone)
g.lcp
	op('Lcp_',getarg(i1))			:(opdone)
g.lcw
	op('Lcw_',getarg(i1))			:(opdone)
g.scp
	op('Scp_',getarg(i1))			:(opdone)

g.icp
	op('Icp_')				:(opdone)

*	integer accumulator kept in memory (reg_ia)

g.ldi
g.sti
	op(op_,getarg(i1))			:(opdone)

g.adi
g.mli
g.sbi
g.dvi
	op('Mov_',reg.w0,getarg(i1))
	op(op_)					:(opdone)

g.rmi
	op('Mov_',reg.w0,getarg(i1))
	op(op_)					:(opdone)
g.ngi
	op(op_)					:(opdone)
g.ino
g.iov
	op(op_,getarg(i1))			:(opdone)


g.ieq	jop = 'je'				:(op.cmp)
g.ige	jop = 'jge'				:(op.cmp)
g.igt	jop = 'jg'				:(op.cmp)
g.ile	jop = 'jle'				:(op.cmp)
g.ilt	jop = 'jl'				:(op.cmp)
g.ine	jop = 'jne'				:(op.cmp)
op.cmp
	op('Mov_',reg.w0,mem('reg_ia'))
	op('or',reg.w0,reg.w0)
	op(jop,getarg(i1))			:(opdone)

*  real operations

g.itr	op('call',op_)	:(opdone)

g.rti	op('call',op_)
	eq(i.type(i1))				:s(opdone)
*	here if label given, branch if real too large
        op('jc',getarg(i1))                 :(opdone)

g.ldr
g.str
g.adr
g.sbr
g.mlr
g.dvr
	getlea(i1)				;* get operand address in w0
	op('call',op_)				:(opdone)


g.ngr
g.atn
g.chp
g.cos
g.etx
g.lnf
g.sin
g.sqr
g.tan
	op('call',op_)
						:(opdone)

g.rov
g.rno	op(op_,getarg(i1))			:(opdone)

g.req	jop = 'je'				:(g.r1)
g.rne	jop = 'jne'				:(g.r1)
g.rge	jop = 'jge'				:(g.r1)
g.rgt	jop = 'jg'				:(g.r1)
g.rle	jop = 'jle'				:(g.r1)
g.rlt	jop = 'jl'
g.r1	
	op('call','cpr_')
.if asm
	op('Mov_',reglow['w0'],'byte [reg_fl]')
.fi
.if gas
	op('movb','reg_fl', reglow['w0'])
.fi
	op('or',reglow['w0'],reglow['w0'])
	op(jop,getarg(i1))			:(opdone)

g.plc
g.psc

*	last arg is optional.  if present and a register or constant, use lea instead.

	t1 = getarg(i1)
	typ = i.type(i2)
.if asm
	((ifreg(i2), ge(typ,1) le(typ,2)) op('Lea_',t1,'Adr(cfp_f+' t1 '+' getarg(i2) ')')) :s(opdone)
.fi
.if gas
	ifreg(i2)				:s(g.psc.1)
	ge(typ,1) le(typ,2)			:s(g.psc.1)
						:(g.psc.2)
g.psc.1
	op('Add_',t1,getarg(i2))
	op('Add_',t1,literal_ 'cfp_f')		:(opdone)
g.psc.2
.fi
	op('Add_',t1,literal_ 'cfp_f')
	eq(i.type(i2))				:s(opdone)

*	here if d_offset_(given (in a variable), so add it in.

	op('Add_',t1,getarg(i2))		:(opdone)

*  always load to w0, which allows use of 'lods' if second argument is '(xr)+'

g.lch
	lch_pre = lch_post =
	src = i2; dst = i1
	s.text = i.text(src); s.type = i.type(src); s.reg = getreg(src)
	d.text = i.text(dst); d.type = i.type(dst); d.reg = getreg(dst)
	w = (eq(i.type(dst),8) 0,1);* dst is w-register
	outfile = Comment 'lch s.text ' s.text '  s.type ' s.type '  s.reg ' s.reg
	outfile = Comment 'lch d.text ' d.text '  d.type ' d.type '  d.reg ' d.reg '  w ' w
	ident(s.text,'(xl)+')			:s(g.lch.lods)

*	decrement source register if needed

	eq(s.type,11) op('Dec_',regmap[s.reg])

*	clear result register

	op('Xor_', (eq(w) getarg(dst),reg.w0), (eq(w) getarg(dst),reg.w0))

*	if target is w register, can load to it. otherwise, load to w0 and then move to x do indexed 
*	load of source register

*	outfile = Comment 'lch 1 reglow[(eq(w) d.reg, 'w0')]' reglow[(eq(w) d.reg, 'w0')]
*	outfile = Comment 'lch,2 M_char [regmap[s.reg]])'  regmap[s.reg]

.if asm
	op('mov',reglow[(eq(w) d.reg, 'w0')],'M_char [' regmap[s.reg] ']')
	ne(w) op('mov',regmap[d.reg],reg.w0)
.fi
.if gas
	op('movb','(' regmap[s.reg] ')' ,reglow[(eq(w) d.reg, 'w0')])
	ne(w) op('mov',reg.w0,regmap[d.reg])
.fi

*	do post increment if needed

	eq(s.type,10)	op('Inc_',regmap[s.reg])
						:(opdone)
g.lch.lods

*  clear result register, do lodsb, and then move character to result register

	op('Xor_',reg.w0,reg.w0)
	op('lodsb')
	op('Mov_',getarg(dst),reg.w0)
						:(opdone)
g.sch
	sch_pre = sch_post =
	src = i1; dst = i2
	s.text = i.text(src); s.type = i.type(src); s.reg = getreg(src)
	d.text = i.text(dst); d.type = i.type(dst); d.reg = getreg(dst)
	w = (eq(i.type(src),8) 0,1);* dst is w-register
	outfile = Comment 'sch s.text ' s.text '  s.type ' s.type '  s.reg ' s.reg
	outfile = Comment 'sch d.text ' d.text '  d.type ' d.type '  d.reg ' d.reg '  w ' w
	ident(s.text,'(xr)+')			:s(g.sch.stos)


*	decrement destination register if needed

	eq(d.type,11) op('Dec_',regmap[d.reg])

*	if source is x register, move it to w0, so can store character from lower part of a w register

	ne(w) op('Mov_',reg.w0, regmap[s.reg])

.if asm
	op('mov','M_char [' regmap[d.reg] ']', reglow[(eq(w) s.reg, 'w0')])
.fi
.if gas
	op('movb', reglow[(eq(w) s.reg, 'w0')], '(' regmap[d.reg] ')') 
.fi

*	increment target register if needed

	eq(d.type,10)  op('Inc_',regmap[d.reg])
						:(opdone)
g.sch.stos
*	move source register to w0, setting up low part, then store from w0
	op('Mov_',reg.w0, regmap[s.reg])
	op('stosb')
						:(opdone)

g.csc  	ident(thislabel)			:s(opnext)
	op()					:(opdone)

g.ceq
	memmem()
	op('Cmp_',getarg(i1),getarg(i2))
	op('je',getarg(i3))
						:(opdone)

g.cne   memmemm()
	op('Cmp_',getarg(i1),getarg(i2))
	op('jnz',getarg(i3))
						:(opdone)

g.cmc
	op('repe','cmpsb')
	op('Xor_',reg.xl,reg.xl)
	op('Xor_',reg.xr,reg.xl)
	t1 = getarg(i1)
	t2 = getarg(i2)
	(ident(t1,t2) op('jnz',t1))		:s(opdone)
	op('ja',t2)
	op('jb',t1)				:(opdone)

g.trc
	op('xchg',reg.xl,reg.xr)
.if asm
	opl((labl = genlab('trc')) ':','movzx',reg.w0,'M_char [XR]')
	op('mov',reglow['w0'],'[XL+W0]')
.fi
.if gas
	lbl = genlab('trc')
	opl(lbl ':','movz' (eq(ws,32) 'bl', 'bq'),'(' reg.xr ')',reg.w0)
	op('Add_','(' reg.xl ')',reg.w0)
	op('mov','(' reg.w0 ')', reglow['w0'])
.fi
	op('stos' op_b)
	op('Dec_',reg.wa)
	op('jnz',lbl)
	op('Xor_',reg.xl,reg.xl)
	op('Xor_',reg.xr,reg.xr)
						:(opdone)
g.anb	op('And_',getarg(i1),getarg(i2))	:(opdone)
g.orb	op('Or_',getarg(i1),getarg(i2))	:(opdone)
g.xob	op('Xor_',getarg(i1),getarg(i2))	:(opdone)
g.cmb	op('not',getarg(i1))			:(opdone)

g.lsh
	op('Sal_',getarg(i1),literal_ getarg(i2))	:(opdone)

g.rsh
	op('Sar_',getarg(i1),literal_ getarg(i2))	:(opdone)

g.rsx
	error('rsx not supported')
g.lsx
	error('lsx not supported')

g.nzb	ifreg(i1)				:s(g.nzb1)
	op('Xor_',reg.w0,reg.w0)
	op('Cmp_',getarg(i1),reg.w0)
	op('jnz',getarg(i2))
						:(opdone)
g.nzb1
	op('or',getarg(i1),getarg(i1))
	op('jnz',getarg(i2))
						:(opdone)

g.zrb
	ifreg(i1)				:s(g.zrb1)
	op('Xor_',reg.w0,reg.w0)
	op('Cmp_',getarg(i1),reg.w0)
	op('jz',getarg(i2))
						:(opdone)
g.zrb1
	op('or',getarg(i1),getarg(i1))
	op('jz',getarg(i2))
						:(opdone)

g.zgb
	op('nop')				:(opdone)

g.zzz
 	op('zzz',getarg(i1))			:(opdone)

g.wtb
	op('Sal_',getarg(i1),literal_ log_cfp_b)	:(opdone)

g.btw
	op('Sar_',getarg(i1),literal_ log_cfp_b)	:(opdone)

g.mti
	ident(i.text(i1),'(xs)+')		:f(g.mti.1)
	op('pop',reg.w0)
	op('ldi_',reg.w0)			:(opdone)
g.mti.1
	op('ldi_',getarg(i1))			:(opdone)


g.mfi
*	last arg is optional

*  compare with cfp$m, branching if result negative

	eq(i.type(i2))				:s(g.mfi.1)

*	here if label given, branch if wc not in range (ie, negative)

	op('sti_',reg.w0)
	op('or',reg.w0,reg.w0)
	op('js',getarg(i2))
g.mfi.1
	ident(i.text(i1),'-(xs)')		:s(g.mfi.2)
	op('sti_',getarg(i1))			:(opdone)
g.mfi.2
	op('sti_',reg.w0)
	op('push',reg.w0)			:(opdone)
.if asm
g.ctw

*	assume cfp_c chars per word

	t1 = getarg(i1)
	op('Add_',t1,'(' cfp_c '-1)+' cfp_c '*' i.text(i2))
	op('Sar_',t1,literal_ log_cfp_c)
					:(opdone)
g.ctb
	t1 = getarg(i1)
	op('Add_',t1,'(' cfp_b '-1)+' cfp_b '*' i.text(i2))
	op('and',t1,'-' cfp_b)
						:(opdone)
.fi
.if gas
g.ctb
g.ctw
	w.reg = getarg(i1); 
	op('mov',w.reg,'ctbw_r')
	op('mov' op_w,literal_ i.text(i2), 'ctbw_v')

*	op('mov' op_w,w.reg,reg.w0)	

	op('call', incode '_')
	op('mov' op_w,'ctbw_r',w.reg)
						:(opdone)
.fi

g.cvm	
	t1 = getarg(i1)
	op('sti_',reg.w0)
	op('imul',reg.w0,intvt)
	op('jo',t1)
	op('Sub_',reg.wb,'ch_d0')
	op('Sub_',reg.w0,reg.wb)
	op('ldi_',reg.w0)
	op('jo',t1)
						:(opdone)
g.cvd
	op('cvd_')				:(opdone)

g.mvc
	trc_suspend = 1
	t1 = genlab('mvc')
.if asm
	op('rep')
	op('movsb')
.fi
.if gas
	op('rep', 'movsb')
.fi
	trc_suspend = 0				:(opdone)
g.mvw
	op('Sar_',reg.wa,literal_ log_cfp_b)
 	op('rep','movs' op_w)
						:(opdone)
g.mwb
	op('Sar_',reg.wa,literal_ log_cfp_b)
	op('std')
	op('Sub_',reg.xl,literal_ cfp_b)
	op('Sub_',reg.xr,literal_ cfp_b)
 	genrep('movs' op_w)
	op('cld')				
						:(opdone)

	op('std')
	op('Sar_',reg.wa,literal_ log_cfp_b)
	op('rep')
	op('Movs_w')
	op('ctd')
						:(opdone)

g.mcb
	op('std')
	op('Dec_',reg.xl)
	op('Dec_',reg.xr)
 	genrep('Movs_b')
	op('cld')
						:(opdone)
genrep

*	generate equivalent of rep op loop

	l1 = genlab('rep')
	l2 = genlab('rep')
	opl(l1 ':')
	op('or',reg.wa,reg.wa)
	op('jz',l2)
	op(op)
	op('Dec_',reg.wa)
	op('Jmp_',l1)
	opl(l2 ':')
						:(return)
g.chk
	op('chk_')
	op('or',reg.w0,reg.w0);
	op('jne','sec06')			:(opdone)

decend

*	here at end of dic or dac to see if want label made public

	thislabel ? rtab(1) . thislabel ':'
	differ(pubtab[thislabel]) global(thislabel)
						:(opdone)

g.dac	
	t1 = i.type(i1)
	t2 = "" ;*(le(t1,2) "", le(t1,4) "d_offset_(", le(t1,6) "d_offset_(", "")
	opl(thislabel,D_word,t2 i.text(i1))
						:(decend)
g.dic
	opl(thislabel,D_word,i.text(i1))
						:(decend)

g.drc
	align(8)
	t1 = i.text(i1)
	t1 ? fence "+" = ""
	op(D_real,t1)

*	note that want to attach label to last instruction

	t.label(cstmts[cstmts.n]) = thislabel
	thislabel =				:(opdone)

g.dtc

*	change first and last chars to " (assume / used in source)
	txt = i.text(i1)
	txt = substr(txt,2,size(txt) - 2)
	opl(thislabel,D_char, '"' txt '"')

	n = remdr(size(txt),cfp_b)
	eq(n)					:s(opdone)
	n = cfp_b - n

*	Pad out with null bytes to next word boundary

dtc.1	eq(n)					:s(opdone)
	op(D_byte,'0')
	n = n - 1				:(dtc.1)

	align(cfp_b)			
	section('d_word','0')
						:(opdone)
	dtc.rem = remdr(size(dtc.txt),cfp_c)

*	append nulls to complete last word so constant length is multiple of word word

	dtc_i = 1
	tmp =
g.dtc.1
	tmp = gt(dtc_i, 1) t4 ","
	tmp = t4 "'" substr(t2,dtc_i,1) "'"
	le(dtc_i = dtc_i + 1, size(t2))		:s(g.dtc.1)

	tmp = ne(gtc.rem) t4 dupl(',0',cfp_c - gtc.rem)
	opl(thislabel,D_char,tmp)
						:(opdone)
g.dbc
	opl(thislabel,D_word,getarg(i1))
						:(opdone)
g.equ
	op('Equ_',thislabel,i.text(i1))		:(opdone)

g.exp
	ppm_cases[thislabel] = i.text(i1)

*	extern(thislabel)

	thislabel =				:(opdone)

g.inp
	ppm_cases[thislabel] = i.text(i2)
	prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
+						:(opnext)

g.inr						:(opnext)

g.ejc	op('')				:(opdone)

g.ttl	op('')
						:(opdone)

g.sec	op('')
	sectnow = sectnow + 1			:($("g.sec." sectnow))

* procedure declaration section

g.sec.1
	section('text')
	global('sec01')
	opl('sec01:')	             	:(opdone)

*	definitions section

g.sec.2
	section('data')
	global('sec02')
        opl('sec02:')       		      	:(opdone)

*	constants section

g.sec.3
	section('data')
	global('sec03')
	opl('sec03:')
						:(opdone)

* working variables section

g.sec.4 
	global('esec03')
	opl('esec03' ':')
	section('data')
	global('sec04')
	opl('sec04:')			:(opdone)

*	here at start of program section.  if any n type procedures, put out entry-word block declaration at 
*	end of working storage

g.sec.5

*	emit code to indicate in code section get direction set to up.

        global('esec04')
        opl('esec04' ':')

*        (gt(prc.count1) opl('prc$' ':','times', prc.count1 ' dd 0'))

.if asm
	op('prc_: times ' prc.count1 ' dd 0')
.fi
.if gas
	opl('prc_:','.fill', prc.count1,cfp_b)
.fi
	global('end_min_data')
	opl('end_min_data' ':')
	section('text')
	global('sec05')
	opl('sec05' ':')
						:(opdone)

*	stack overflow section.  output exi__n tail code

g.sec.6
        global('sec06')
        opl('sec06'  ':', 'nop')
				             :(opdone)

*	error section.  produce code to receive erb's

g.sec.7
        global('sec07')
        opl('sec07:')
	flush()

*	error section.  produce code to receive erb's

*	allow for some extra cases in case of max.err bad estimate

	n1 = max.err + 8
	opl('err_:')
	outfile = Comment 'sec07:a:' a(mem( rcode)) ':g:' g('rcode')
	op('xchg',reg.wa,a(mem(rcode)) g(rcode))
						:(opdone)


-stitl extern(var)

*	generate extern declaration
extern
.if asm
	op('extern',var)			:(return)
.fi
.if gas
	op('.extern',var)			:(return)
.fi

opdone	flush()					:(opnext)

*	here to emit bstmts, cstmts, astmts. attach input label and comment to first instruction generated.

flush	
	eq(astmts.n) eq(bstmts.n) eq(cstmts.n)	:f(opdone1)
	ne(ab_suspend)				:s(opdone.2)
	

*	here if some statements to emit, so output single 'null' statement to get label and comment field right.

	label = thislabel =
	outstmt(tstmt())			:(opdone.6)
opdone1	
	eq(bstmts.n)				:s(opdone.2)
	i = 1
opdone.1
	outstmt(bstmts[i])
	le(i = i + 1, bstmts.n)			:s(opdone.1)

opdone.2	eq(cstmts.n)			:s(opdone.4)
	i = 1
opdone.3
	outstmt(cstmts[i])
	le(i = i + 1, cstmts.n)			:s(opdone.3)

opdone.4	eq(astmts.n)			:s(opdone.6)
	i = 1
	ident(pifatal[incode])			:s(opdone.5)

*  here if post incrementing code not allowed

	error('post increment not allowed for op ' incode)
opdone.5	outstmt(astmts[i])
	le(i = i + 1, astmts.n)			:s(opdone.5)
opdone.6 astmts.n = bstmts.n = cstmts.n =	:(return)
flush_end
-stitl report - write statistic to output file
report
	output = lpad(num,7) tab text		:(return)


g.end

*	here at end of code generation.

	endfile(1)
	endfile(2)
	endfile(3)
	report(assembler,	 'assembler')
	differ(i_trace) report(i_trace,'instruction trace enabled')
	report(nlines,		'lines read')
	report(nstmts,		'statements processed')
	report(+simples,		'simple operations translated')
	report(ntarget,		'target code lines produced')
	report(&stcount,	'spitbol statements executed')
	report(max.err,		'maximum err/erb number')
	report(prc.count1, 	'prc count')
	output  = '  ' gt(prc.count,prc.count1)
.	  'differing counts for n-procedures:'
.	  ' inp ' prc.count1 ' prc ' prc.count
	differ(nerrors) report(nerrors,'errors detected')

	errfile = '* ' max.err 'maximum err/erb number'
	errfile  = '* ' prc.count 'prc count'
.		differ(lasterror) '  the last error was in line ' lasterror

*	&code   = ne(nerrors) 2001
	report(collect(), 'free words')
	report(time(),'execution time ms')
	&dump = 0
	:(end)
end
