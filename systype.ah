# copyright 1987-2012 robert b. k. dewar and mark emmer.
# 
# this file is part of macro spitbol.
# 
#     macro spitbol is free software: you can redistribute it and/or modify
#     it under the terms of the gnu general public license as published by
#     the free software foundation, either version 3 of the license, or
#     (at your option) any later version.
# 
#     macro spitbol is distributed in the hope that it will be useful,
#     but without any warranty; without even the implied warranty of
#     merchantability or fitness for a particular purpose.  see the
#     gnu general public license for more details.
# 
#     you should have received a copy of the gnu general public license
#     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.

# configuration information for inter.s
#
linux=1
winnt=0

#        segment declarations macros
#
                .macro          cseg_           # open a code segment
                .section        .text
                .endm

                .macro          csegend_        # close a code segment
                .endm

                .macro          dseg_           # open a data segment
                .section        .data
                .endm

                .macro          dsegend_        # close a data segment
                .endm

                .macro          bssseg_         # open a bss segment
                .section        .bss
                .endm

                .macro          bsssegend_      # close a bss segment
                .endm

                .macro          header_         # group and assume directives
                cseg_
                csegend_
                dseg_
                dsegend_
                .endm

# structure definition macros
#
        .macro  struc name
        .struct 0
        .endm

        .macro  ends name
        dseg_
        .endm

# define how data locations in the minimal code are accessed from
# assembly-language and c routines.  "direct" is non-zero to make
# the symbols public for direct access, zero to have access via
# a table of pointers and the minadr procedure.
#
direct=1

# define how floating point results are returned from a function
# (either in st(0) or in edx:eax.
fretst0=1
freteax=0

# macros defining whether a leading underscore is required for public minimal
# names that will be referenced from c.
#
underscore=0
        .macro  address name
.ifne underscore
        .long   _\name
.else
        .long   \name
.endif
        .endm

        .macro  ext name,type
        .extern name:type
        .endm

        .macro  cext name,type
.ifne underscore
\name	=	_\name
.endif
        ext     \name,\type
        .endm

        .macro  def name,op,val
\name:   \op    \val
        .endm

        .macro  pubdef name,op,val
.ifne underscore
        .global _\name
_\name: \op     \val
\name   =	_\name
.else
        .global \name
\name:  \op     \val
.endif
        .endm

        .macro  pubname procname
.ifne underscore
        .global _\procname
.else
        .global \procname
.endif
        .endm

        .macro  proc procname,distance
\procname:
        .endm

        .macro  endp procname
        .endm

        .macro  cproc procname,distance
.ifne underscore
_\procname:
.else
\procname:
.endif
        .endm

        .macro  cendp procname
        .endm

        .macro  publab procname
        .global \procname
        .endm

# call c function.  intel follows standard c conventions, and
# caller pops arguments.
        .macro  callc routine,nbytes
.ifne underscore
        call    _\routine
.else
        call    \routine
.endif
.ifne \nbytes
        add     esp,\nbytes
.endif
        .endm

# intel runs in one flat segment.  far calls are the same as near calls.
        .macro  callfar routine,nbytes
        ext     \routine:near
        callc   \routine,\nbytes
        .endm

# return from an assembly-language function that will be called by c.
# caller pops arguments
        .macro  retc nbytes
	ret
        .endm

