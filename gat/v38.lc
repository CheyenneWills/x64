        .title "spitbol translator v38"
        .sbttl "v38"
# minimal/80386 translator v1.12 08/07/12 21:06:33 for linux
        .psize          80,132
        .arch           pentium
        .include        "systype.ah"

        header_

        cseg_

        .include        "hdrcode.inc"
        .include        "hdrdata.inc"

        .extern         ldr_:near
        .extern         str_:near
        .extern         ovr_:near
        .extern         dvi_:near
        .extern         rmi_:near
        .extern         cvd_:near
        .extern         rti_:near
        .extern         itr_:near
        .extern         adr_:near
        .extern         sbr_:near
        .extern         mlr_:near
        .extern         dvr_:near
        .extern         ngr_:near
        .extern         atn_:near
        .extern         chp_:near
        .extern         cos_:near
        .extern         etx_:near
        .extern         lnf_:near
        .extern         sin_:near
        .extern         sqr_:near
        .extern         tan_:near
        .extern         cpr_:near

        csegend_
#      spitbol conditional assembly symbols for use by token.spt
#      ---------------------------------------------------------
#
#      this file of conditional symbols will override the conditional
#      definitions contained in the spitbol minimal file.   in addition,
#      lines beginning with ">" are treated as spitbol statements and
#      immediately executed.
#
#      for linux spitbol-x86
#
#      in the spitbol translator, the following conditional
#      assembly symbols are referred to. to incorporate the
#      features referred to, the minimal source should be
#      prefaced by suitable conditional assembly symbol
#      definitions.
#      in all cases it is permissible to default the definitions
#      in which case the additional features will be omitted
#      from the target code.
#
#
#                            conditional options
#                            since .undef not allowed if symbol not
#                            defined, a full comment line indicates
#                            symbol initially not defined.
#
#      .cavt                 define to include vertical tab
#      .ccmc                 define to include syscm function
#      .ceng                 define to include engine features
#      .cnci                 define to enable sysci routine
#      .cncr                 define to enable syscr routine
#      .cnex                 define to omit exit() code.
#      .cnld                 define to omit load() code.
#      .cnpf                 define to omit profile stuff
#      .cnra                 define to omit all real arithmetic
#      .cnsr                 define to omit sort, rsort
#      .crpp                 define if return points have odd parity
#      .cs16                 define to initialize stlim to 32767
#      .csn5                 define to pad stmt nos to 5 chars
#      .csn6                 define to pad stmt nos to 6 chars
#      .ctmd                 define if systm unit is decisecond
#      .cusr                 define to have set() use real values
#                             (must also #define setreal 1 in systype.h)
#
                            #} ttl l i c e n s e -- software license for this program
        .sbttl "l i c e n s e -- software license for this program"
#
#     copyright 1983-2012 robert b. k. dewar
#
#     this file is part of macro spitbol.
#
#     macro spitbol is free software: you can redistribute it and/or modify
#     it under the terms of the gnu general public license as published by
#     the free software foundation, either version 3 of the license, or
#     (at your option) any later version.
#
#     macro spitbol is distributed in the hope that it will be useful,
#     but without any warranty; without even the implied warranty of
#     merchantability or fitness for a particular purpose.  see the
#     gnu general public license for more details.
#
#     you should have received a copy of the gnu general public license
#     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
#
                            #} ttl s p i t b o l -- notes to implementors
        .sbttl "s p i t b o l -- notes to implementors"
#
#      m a c r o   s p i t b o l     v e r s i o n   3 . 8
#      ---------------------------------------------------
#
#      date of release  -  june 2012
#
#      version 3.8 is maintained by
#           dr. david shields
#           260 garth rd apt 3h4
#           scarsdale, ny 10583
#      e-mail - thedaveshields at gmail dot com
#
#      version 3.7 was maintained by
#           mark emmer
#           catspaw, inc.
#           p.o. box 1123
#           salida, colorado 81021
#           u.s.a
#      e-mail - marke at snobol4 dot com
#
#      versions 2.6 through 3.4 were maintained by
#           dr. a. p. mccann
#           department of computer studies
#           university of leeds
#           leeds ls2 9jt
#           england.
#
#      from 1979 through early 1983 a number of fixes and
#      enhancements were made by steve duff and robert goldberg.
#
#      to assist implementors a revision history based on
#      version 2.7 is being maintained.
#
                            #} ttl s p i t b o l - revision history
        .sbttl "s p i t b o l - revision history"
                            #} ejc
        .eject
#      r e v i s i o n   h i s t o r y
#      -------------------------------
#
#
#      version 3.8 (june 2012, david shields)
#      --------------------------------------
#
#	       this version is very close to v3.7, with the
#              same functionality.
#
#              the source is now maintained using git, so going forward
#              the detailed revision history will be recorded in the git
#              commit logs, not in this file.
#
#      version 3.6a to 3.7 (november 1, 1991, mark b. emmer)
#      -----------------------------------------------------
#
#      bugs fixed
#      ----------
#
#      b3.701  add btkwv and refined test at cdgvl+9 to prevent
#              variable names alphabet, lcase, ucase from being
#              pre-evaluated because of their associated
#              constant keywords.  the code
#                 alphabet = "abc"; output = size(alphabet)
#              returned zero because of pre-evaluation.
#      b3.702  delay binding to function block of fourth
#              argument to trace function.  this permits the
#              trace function to be invoked before the 4th
#              argument function is defined.  accomplished by
#              storing a vrblk pointer in trfnc, and fetching
#              its vrfnc entry later, in trxeq.
#      b3.703  references to keywords with constant pattern
#              values (&arb, &bal, etc.) did not work.  a wtb
#              instruction had been omitted at acs14+2.
#      b3.704  if a program employed the code function to
#              redefine a label that was the entry location of
#              a user-defined function, the function would
#              continue to jump to its old function body.  pfcod
#              in pfblk was pointing directly to the target code
#              block, instead of doing so indirectly through the
#              vrblk for the entry label.
#      b3.705  the test that required a label to be defined
#              before it could be used as the entry of a user-
#              defined function has been removed.  functions
#              may be defined even if the label is yet
#              undefined.
#      b3.706  after a compilation error in the code function,
#              the eval function produces spurrious errors.  the
#              code offset cwcof was not being reset to the
#              beginning of code block.  add line at err04+1 to
#              accomplish this reset.
#      b3.707  inconsistant tests with mxlen corrected.  several
#              places were testing with bge instead of bgt,
#              resulting in such anomalies as the statement
#                 &maxlngth = &maxlngth
#              failing.  since mxlen is guaranteed to be
#              strictly less than dnamb, it is permissible to
#              create objects of size mxlen.  bge changed to
#              bgt at locations
#                 s$arr+14, sar07+8, alobf+3, asg14+8, gtar6+10.
#      b3.708  exit(command string) was not loading ptr to fcb
#              chain into wb.  corrected at sext1.
#      b3.709  change patst to return non-string error for null
#              argument.  previously, break(), any(), etc., were
#              succeeding, contrary to the language definition.
#      b3.710  convert function with null second argument
#              crashed system by calling flstg with wa=0.  added
#              test at s$cnv, moved error 74 to separate erb at
#              scv29.
#      b3.711  leq(,) crashed system.  lcomp did not obey
#              minimal assumption that cmc opcode will always
#              be called with wa .gt. 0.  added test at lcmp1.
#      b3.712  modified line at sdf07+4 to use register wa
#              instead of wb.  this corrects problem of define
#              function with local variable list that begins
#              with comma-  define("f(x),l1,l2")
#      b3.713  erroneous plc on uninitialised r$cim in listr.
#      b3.714  erroneous call to flstg possible with null string
#              at sdat1.
#      b3.715  when copy function used with table argument, fix
#              problem at cop07.  when copying first teblk on a
#              chain, the pseudo-previous block pointer in xr
#              is pushed on the stack prior to calling alloc.
#              this is not a valid block pointer, as it points
#              within the tbblk.  if the subsequent alloc
#              invokes gbcol, the heap becomes scrambled.
#              recoded to save pointer to start of block, plus
#              offset in wb.
#      b3.716  at iop01, if gtvar triggered garbage collection
#              via alost, trap block in wc was not collected.
#              save wc on stack to make it collectable across
#              gtvar call.
#      b3.717  at asg10, allow case of variable with more than
#              one trblk, as happens with the following stmt -
#              output(.output, .output, filename).
#      b3.718  at senf1, trblk chain search was reloading chain
#              head, causing infinite loop if the desired trblk
#              was not the first on chain.  system crashed with
#              trace(.v1) output(.v2,.v1,file).
#      b3.719  prototype strings (define, load, data, etc.) were
#              allowing blank characters, producing bogus
#              variable names.
#      b3.720  the fact that iofcb destroyed register wc was not
#              documented.  b$efc conversion of file argument
#              never worked because wc and xt were destroyed by
#              call to iofcb.
#      b3.721  ioput left a trblk attached to filearg1 if sysio
#              failed.  subsequent use of this filearg1 variable
#              in another i/o call would crash system.
#      b3.722  add chk at evlp1 to catch recursive pattern error.
#      b3.723  allow -line to work properly within code function
#              by setting cmpln directly in cnc44.  if file name
#              absent, decrement scnpt to rescan terminator.
#      b3.724  when mxlen exceeds start of dynamic memory, round
#              it up to multiple of word size prior to storing
#              in dnamb at ini06.
#      b3.725  provide right padding of zero characters to any
#              string returned by an external function.
#      b3.726  reset flptr at bpf17 for undefined function
#              when evalx is evaluating an expression.
#      b3.727  modify code after read5 for outer nesting of
#              an execute-time compile of -include statement.
#              create a substring of remainder of original
#              code function argument string and return as
#              result of readr function
#      b3.728  the definition of the aov opcode is corrected.
#              formerly the definition specified that the branch
#              was to be taken if the result of the addition
#              exceeded cfp$m, implying a test for overflow
#              from signed addition.
#              however, address arithmetic must be unsigned to
#              allow for systems where the high order address
#              bit is set.  therefore, the test must be for
#              carry out of the high order bit, if the result
#              would exceed cfp$l.
#      b3.729  a label trace on the entry label for a function
#              was undetected, resulting in a transfer to
#              b$trt and subsequent crash.  see bpf08 for fix.
#      b3.730  pop first argument to substr if it is a buffer.
#      b3.731  pattern replacement with buffer subject returned
#              null string instead of new subject value.
#              changed to behave as if subject was a string.
#      b3.732  if convert function was called with a buffer
#              first argument and "buffer" second argument,
#              it would convert the buffer to a string, and
#              then back to a buffer.  this has be corrected
#              to simply return the first argument as the
#              function result.
#      b3.733  detect external function returning a null string
#              unconverted result at bef12, and jump to exnul.
#      b3.734  fix problem at ins04 when inserting zero length
#              string into buffer.  defend against invoking
#              mvc with a zero value in wa, which will cause
#              some implementations to wrap the counter.
#      b3.735  add overflow test for cos and sin to detect
#              out-of-range argument.
#      b3.736  fixed problem introduced with b3.727 not
#              restoring r$cim, scnpt and scnil after creating
#              substring.
#      b3.737  fixed tfind to place default value in newly
#              allocated teblk.
#      b3.738  added bl$p0 to p$nth entry point.  the expression
#              datatype(convert("","pattern")) would crash when
#              the dtype function uses the non-existant type
#              word preceding p$nth.
#      b3.739  bug at gtn35 in the case of overflow during cvm.
#              wb can be destroyed by cvm on some platforms.
#      b3.740  protect scontinue from usage in other than error
#              320 case.
#      b3.741  protect continue from usage following error
#              evaluating complex failure goto.
#
#
#      changes
#      -------
#
#      c3.701  add .culk conditional to include &lcase, &ucase.
#      c3.702  add -line nn "filename" control card.
#      c3.703  move .cnld conditional up in routine dffnc to
#              omit all tests for b$efc.
#      c3.704  add conditional .cicc to ignore unrecognized
#              control cards.
#      c3.705  add conditional .cnsc to omit string to numeric
#              conversion in sort.  the presence of this
#              conversion mode produces a sort result that is
#              dependent upon the order of input data.
#              for example, given input data "2", 5, "10",
#              string comparison yields "10" lt "2", but string
#              to integer conversion yields "2" lt 5 lt "10".
#      c3.706  add seventh return from syshs that allows callee
#              to return a string pointer and length.  this is
#              done to eliminate the need for the caller to have
#              an scblk big enough to accommodate long strings.
#      c3.707  add eighth return from syshs to force copy of
#              block pointed to by xr.
#      c3.708  made -copy a synonym for -include.
#      c3.709  add conditional .cbyt for statistics displayed
#              in bytes rather than words.
#      c3.710  dump null valued variables when dump = 3.  core
#              dump produced for dump = 4.
#      c3.711  restrict minimum value to which keyword maxlngth
#              can be set to 1,024 via new variable mnlen.
#      c3.712  add conditional symbol .cmth for extended math
#              functions- atan, chop, cos, exp, ln, sin, sqrt,
#              tan.  x**y and remdr(x,y) are extended to include
#              reals.
#      c3.713  add bit to syspp to set -print upon entry
#      c3.714  add conditional .csfn to track source file name
#              associated with each code block.
#      c3.715  add conditional .cinc for -include control card
#              feature.  the format of the card is
#                 -include "filename"
#              include control cards may be used during both the
#              initial compile and execute-time compile.  the
#              filename is saved in a table, and redundant
#              includes of that file are ignored.
#      c3.716  add conditional .csln to include source line
#              number in code blocks.  release current ccblk
#              after initial compile.
#      c3.717  changed rilen to 258 (from 120) to provide
#              uniform input line length when reading from
#              terminal or input.
#      c3.718  add additional exit to iofcb to distinguish
#              argument not convertable to string and argument
#              file not open.
#      c3.719  add fourth and fifth arguments to host function.
#      c3.720  add &compare keyword to control string
#              comparisons.
#      c3.721  setup pfdmp at iniy0 in case osint forced
#              &profile non-zero.
#      c3.722  add conditional symbol .caex to include up arrow
#              as synonym for exponentiation.
#      c3.723  add conditional .ccmc and external function syscm
#              to provide string comparison using collation
#              sequence other than strict ordering of character
#              codes (international compares).
#      c3.724  add conditional .cpol and external function syspl
#              to provide interactive control of spitbol
#              execution.
#      c3.725  add conditional symbol .cera and external
#              function sysea to provide advice of compilation
#              and runtime errors to osint.
#      c3.726  add cmpln, rdcln, rdnln to track source line
#              number.
#      c3.727  converted error messages to upper/lower case.
#      c3.728  add conditional .cgbc to external routine sysgc.
#              called at the start and end of garbage collection
#              to perform any needed notification to operating
#              system or user.
#      c3.729  modified last line of s$set from exnul to exint
#              so seek can return final file position after
#              seek.
#      c3.730  place mov xr,(xs) at s$rmd+4 to allow real second
#              arg to remdr.
#      c3.731  remove redundant bge xr,=cfp$u,scn07 at scn06+4
#      c3.732  change definition of cmc and trc such that only
#              xl must be cleared after operation.  note, this
#              change was subsequently voided.  cmc and trc must
#              clear both xl and xr, because utility routines
#              may preserve xl or xr on the stack, and the stack
#              is collectable by gbcol.
#      c3.733  remove most branches to exits and exixr.
#              instead, jump directly to next code word.
#      c3.734  add error 260 for array too large in gtarr.
#      c3.735  add conditional .cs32 to initialize stlim to
#              2147483647.
#      c3.736  add second argument to exit function, allowing
#              user to specify file name of load module being
#              written.  if omitted, osint will provide a
#              default name.
#      c3.737  add conditional .cspr to include spare locations
#              in working area.  these may be used in later bug
#              fixes without changing the size of the working
#              storage and obsoleting modules created by exit().
#              subsuently removed in c3.767.
#      c3.738  add r$cts to remember last string used to build
#              bit column in patst.
#      c3.739  change flstg to type e procedure instead of r.
#      c3.740  standardize on big-endian systems.  at the
#              implementors choice, the zgb opcode can also
#              perform a byte swap if necessary to achieve big-
#              endian byte ordering.  this is done so that
#              systems with similar word lengths will produce
#              the same hash code for strings, and hence the
#              same ordering for table entries.  the hashs
#              procedure has an additional zgb added to reorder
#              the length word.
#      c3.741  add conditional .csou to cause assignments to
#              output and terminal variables to be processed
#              through calls to sysou rather than through
#              listing buffer.  done to eliminate short record
#              lengths enforced by buffer size.  a code of 0 or
#              1 is passed to sysou instead of an fcblk.
#      c3.742  increased iniln, inils, rilen to 1024.
#      c3.743  add bit to syspp to set noerrors mode.
#      c3.744  add .ccmk conditional to include keyword compare
#              even if syscm is not being included.  done to
#              provide identical data regions in systems that
#              implement syscm and those which do not, so that
#              save files can be exchanged in the next release.
#      c3.745  add wc return parameter to sysil to allow
#              interface to inform spitbol if file about to be
#              read is a binary file.  if so, no blank trimming
#              occurs.
#      c3.746  fold load function argument types to upper case.
#      c3.747  add .cexp conditional to have sysex pop its
#              arguments.
#      c3.748  in stopr, do not attempt to display file name and
#              line number if stopping because of stack overflow
#              during garbage collection.  pointers to file name
#              table and code block are wrong.
#      c3.749  add bit to syspp to set case folding mode.
#      c3.750  add additional return from sysld if insufficient
#              memory to load/call external function.
#      c3.751  add additional returns from sysex if insufficient
#              memory or bad argument type.
#      c3.752  ignore leading and trailing blanks in arguments
#              within prototype strings to clear, data, define
#              and load.
#      c3.753  test for fatal error at err04 and abort if so.
#              force termination on stack overflow by setting
#              errft to 4 in stack overflow section.
#      c3.754  recode copy loop at srt14 to exchange usage of
#              registers xl and xr.  this permits use of the
#              mvw order instead of the explicit loop coding
#              previously employed.
#      c3.755  add .ceng conditional to include routines needed
#              by text processing engine. add routines enevs and
#              engts for use by engine or debugger.  copy xr to
#              xl around call to syspl to allow syspl to
#              trigger garbage collection.
#      c3.756  add &file, &lastfile, &line, &lastline keywords.
#              for now, line and lastline are maintained in the
#              same manner as stno and lastno, which adds over-
#              head to the statement initialization code.  a
#              possible change is to create a stmln procedure
#              that maps statement numbers to line numbers.
#              one simple strategy would be to sweep code blocks
#              in memory looking for the statement number and
#              extracting the line number from that code block.
#              such a procedure would also allow line numbers
#              (and file names) to be added to statement profile
#              reports.
#      c3.757  change sort to fail instead of producing error
#              message if argument table is null.  change sorta
#              to return failure.  add another return to gtarr
#              to distinguish null table from bad argument.
#      c3.758  create procedure prtmm to display memory usage
#              statistics, and call it when producing end-of-
#              run stats.
#      c3.759  add label scontinue to allow setexit to resume
#              execution exactly where it was interrupted.
#      c3.760  add snobol4 backspace function and conditional
#              .cbsp.
#      c3.761  add additional arguments to sysgc to assist
#              virtual memory managers.
#      c3.762  the method of converting a table to an array has
#              been revised.  previously, table elements were
#              copied to the result array in the order they were
#              encountered along the various hash chains.  this
#              appeared to the user as a random ordering.  how-
#              ever, spitbol/370 as well as sil snobol4 ordered
#              array elements according to their time of entry
#              into the table.  user programs that relied upon
#              this behavior malfunctioned when ported to macro
#              spitbol.
#              to remedy this, the conversion is performed in
#              three steps:
#              1. convert table to an array placing the address
#                 of each teblk in the array instead of the key
#                 and value.
#              2. sort the array of addresses.  this orders ele-
#                 ments by time of creation (ascending address).
#              3. scan the array, replacing addresses with the
#                 key and value from the referenced teblk.
#              the affected portions of the program are at s$cnv
#              and in gtarr, which now accepts an additional
#              argument specifying whether to place key/values
#              in the array or teblk addresses.
#      c3.763  if case-folding is active, fold the function name
#              provided to the load() function before passing it
#              to sysld.
#      c3.764  add sediment algorithm to garbage collector,
#              conditioned on .csed.
#      c3.765  add optimization to discard null statements and
#              statements which just have a constant subject
#              (see code at cmp12).
#      c3.766  rearranged order of initial objects in static
#              memory so that hash table is the last of the four
#              object created by initialization code.  this is
#              done so that the print buffer, gts work area, and
#              &alphabet keywords do not need to be saved in
#              any save file created by osint.  added routine to
#              initialize these structures.
#      c3.767  removed .cspr conditional and spare locations.
#      c3.768  added .crel conditional and extensive routines
#              (reloc et. al.) to perform relocation of data
#              in working section, static region, and dynamic
#              region after reload of a saved memory image.
#              routines relaj, relcr, and reloc are invoked
#              by osint after reloading a save file.
#              it is now possible to reload such an image even
#              if the spitbol compiler and its data structures
#              are reloaded to other addresses.  the working
#              section has been extensively rearranged to
#              accommodate the reloc procedure.
#      c3.769  zero r$ccb (interim ccblk ptr) in collect,
#              convert, eval, and exit functions to release
#              unneeded ccblk memory.
#      c3.770  add exit(4) and exit(-4) to allow execution to
#              continue after writing save file or load module.
#              revised sysxi interface to detect continuation
#              after performance of exit(4) or exit(-4) action.
#      c3.771  change filnm to preserve registers.
#      c3.772  addition of .cncr and syscr (real to string
#              system routine option).
#      c3.773  modified replace function to optimize usage
#              when second argument is &alphabet.  in this case,
#              the third argument can be used as the translate
#              table directly.
#      c3.774  modified conditionals for buffers and reals so
#              that their respective block codes are always
#              present, even if these data types are conditioned
#              out.  this provides consistent block code
#              numbering for external functions.
#      c3.775  modified alobf to test string length against
#              kvmxl instead of mxlen.  also, alobf was testing
#              total size of bfblk, instead of just string len.
#      c3.776  move utility routines source up to lie between
#              predefined snobol functions (s$xxx) routines and
#              utility procedures.  this was done to assist
#              translation on platforms such as apple macintosh
#              that use 15-bit offsets to store error exits (ppm
#              branches).  offsets to labels like exfal were
#              just too far away.  similarly, functions tfind,
#              tmake, and vmake are located out of alphabetic
#              order to satisfy the macintosh's limited range
#              for subroutine calls.  move built-in labels
#              beyond the block and pattern routines to get it
#              within 32k of the error routines.
#      c3.777  at scn46, allow colon, right paren and right
#              bracket to terminate = operator with default
#              null operand.
#      c3.778  added .ctet conditional for table entry trace.
#      c3.779  introduce cfp$l, the largest unsigned value
#              that may be stored in a one-word integer.  this
#              is done to accommodate machines where memory
#              addresses have the high-order address bit set.
#      c3.780  perform replace in place if first arg is buffer.
#      c3.781  perform reverse in place if first arg is buffer.
#      c3.782  change sysou to accept buffer as well as string
#              to be output.  change code at asg11 to prevent
#              conversion of buffer to string.
#      c3.783  optimize pos and rpos when it is the first node
#              of a pattern and has either an integer or simple
#              expression variable argument.  if unanchored mode
#              and the cursor is zero, it is advanced directly
#              to the desired cursor position.
#      c3.784  perform trim function in place if arg is buffer.
#      c3.785  add gtstb procedure to get a string or buffer
#              argument for replace, reverse, size, trim, etc.
#      c3.786  change leq, lgt, etc. to perform comparisons
#              without converting buffer arguments to strings.
#              this is done by changing lcomp to accept buffer
#              argument(s).  this also affects sort function,
#              which will compare two buffers as strings.
#      c3.787  change gtnum to use characters in buffer without
#              conversion to a string.  this implies that acomp
#              will perform arithmetic comparisons of buffers
#              without converting to strings first.
#      c3.788  perform comparisons of strings and buffers in
#              sortc.
#      c3.789  change insbf to allow insertion of a buffer into
#              a buffer without first converting it to a string.
#              note that this only works when the two buffers
#              are not the same.
#      c3.790  documentation change:  note that all of the block
#              move opcodes should have wa .gt. 0.  not all
#              implementations avoid moving objects when wa is
#              zero.
#      c3.791  change ident to provide buffer/buffer and
#              buffer/string comparisons, to accommodate users
#              who perform ident(buf) to check for null string
#              in buffer.
#      c3.792  added fullscan keyword initialized to one.  user
#              may set to any non-zero value, will receive an
#              error message if attempts to set to zero, since
#              quickscan mode is not supported.
#      c3.793  rewrote statement startup code at stmgo to only
#              perform checking of profiling, stcount tracing,
#              and statement counting if necessary.
#      c3.794  add additional exit to sysfc and ioput to signal
#              that i/o channel (fcblk) is already in use.
#              added error message numbers 289 and 290.
#      c3.795  added optional integer argument to date function
#              to specify format of date string returned by
#              sysdt.
#
#
#      version 3.6 to 3.6a (oct 83)
#      ---------------------------
#
#      changes
#      -------
#
#      c3.617  add .cnlf. if defined, then arguments to external
#              functions may be declared to have type file.
#              such arguments must have been used as second
#              arg to input() or output() and a pointer to the
#              fcb is passed to the external function.
#
#
#      version 3.5 to 3.6 (jun 83)
#      ---------------------------
#
#      codes used to identify authors are (sgd) for duff,
#      (reg) for  goldberg, and (lds) for shields.
#
#      bugs fixed
#      ----------
#      b3.601  (sgd) to fix multiple trap block problem in asign
#      b3.602  (sgd) patch in gtarr to fix null convert.
#      b3.603  (sgd) inserted missing wtb after sysmm calls.
#      b3.604  (sgd) use string length in hashs.
#      b3.605  (sgd) fixed serious parser problem
#              relating to (x y) on line being viewed as pattern
#              match.  fixed by addition of new cmtyp value
#              c$cnp (concatenation - not pattern match).
#      b3.606  (sgd) fixed exit(n) respecification code
#              to properly observe header semantics on return.
#      b3.607  (sgd) bypass prtpg call at initialization
#              following compilation if no output generated.
#              this prevents output files consisting of the
#              headers and a few blank lines when there is no
#              source listing and no compilation stats.
#              also fix timsx initialization in same code.
#      b3.608  (sgd) b$efc code did not check for
#              unconverted result returning null string.
#      b3.609  (sgd) load pfvbl field in retrn for
#              return tracing. this was causing bug on return
#              traces that tried to access the variable name.
#      b3.610  (sgd) fixed problem relating to compilation of
#              goto fields containing small integers
#              (in const sec).
#      b3.611  (reg) prevent clear() from clobbering protected
#              variables at label sclr5.
#      b3.612  (reg) fixed gtexp from accepting trailing
#              semicolon or colon. this is not a legal way
#              to end an expression.
#      b3.613  (reg) fixed difficulties with listings during
#              execution when no listing generated during
#              compilation. -list to code() caused bomb.
#              fix is to reset r$ttl and r$stl to nulls not 0
#              after compilation.
#              (listr and listt expect nulls)
#              when listing and statistics routed to different
#              file than execution output, error message is sent
#              to execution output (and gets separated from
#              ... in statement ... msg). labo1 calls sysax and
#              stopr does not call sysax if entered from labo1.
#      b3.614  (lds) fix misuse of wc just after asg10.
#      b3.615  (lds) add comment pointing out suspicious code
#              after tfn02
#      b3.616  (lds) fix inconsistent declaration of sorth.
#      b3.617  (lds) insert missing conditional tests on cnbf.
#      b3.618  (lds) fix some violations of minimal language
#              that had slipped past some translators.
#      b3.619  (lds) correct error introduced in fixing b3.614.
                            #} ejc
        .eject
#      changes
#      -------
#
#
#      c3.601  (sgd) addition of .cnci and sysci (int to string
#              system routine option)
#      c3.602  (reg) changed iniln and and inils to 258
#      c3.603  (sgd) merged in profiler patches, repaired code.
#      c3.604  (sgd) added buffer type and symbol cnbf
#      c3.605  (sgd) added char function.  char(n) returns nth
#              character of host machine character set.
#      c3.606  (reg) added cfp$u to ease translation on smaller
#              systems - conditional .cucf
#      c3.607  (reg) added lower case support, conditional .culc
#      c3.608  (reg) added set i/o function, conditional .cust
#      c3.609  (reg) conditionalized page eject after call to
#              sysbx and added another before call to sysbx,
#              so that, if desired by the implementor,
#              standard output will reflect assignments made
#              by executing program only.
#              conditional .cuej controls - if defined then
#              eject is before call to sysbx.
#      c3.610  (lds) introduce .ctmd to support systm that
#              reports elapsed time in deciseconds instead of
#              milliseconds.
#      c3.611  (lds)  provide place for .def or .und for each
#              conditional  option, so that settings can be
#              changed without changing line numbers.
#              current settings are for 808x translation.
#      c3.612  (lds) obey (new) restriction that operand in
#              conditional branch instruction cannot have form
#              (x)+ in order to simplify translations for which
#              postincrement not readily available.
#      c3.613  (reg,lds) add op
#                    flc wreg
#              that folds character in wreg to upper case.
#              this op is used only if .culc is defined.
#              this change also involves addition of keyword
#              &case which when nonzero (the initial setting)
#              causes the case folding just described to be
#              done.
#      c3.614  (lds) add option .cs16 to permit initialization
#              of statement limit values to 32767 for 16 bit
#              machines.
#      c3.615  (lds) permit return point and entry point
#              addresses to be distinguished by their parity
#              instead of by lying within a certain range
#              of values.  introduce conditional symbols
#              .crpp  return points have odd parity
#              .cepp  entry points have odd parity
#      c3.616  (lds) introduce new minimal opcodes to branch
#              according to parity,
#                bev  opn,plbl  branch if address even
#                bod  opn,plbl  branch if address odd
#              an address is even if it is a multiple of cfp$b.
                            #} ejc
        .eject
#      documentation revisions
#      -----------------------
#
#      d3.601  (lds) bring minimal machine description up to
#              date
#
                            #} ejc
        .eject
#      version 3.4 to 3.5 (feb 79)
#      ---------------------------
#
#
#      bugs fixed
#      ----------
#
#      b3.401  prtst should be declared as an r type procedure.
#      b3.402  timing error if spitbol fails in dump.
#      b3.403  error in handling omitted args of operators.
#      b3.404  too many lines put on first page of listing.
#      b3.405  leading unary operator in eval erroneously needed
#              preceding blank.
#      b3.406  identifying name in dump of array or table values
#              was omitted.
#      b3.407  eval unable to return a deferred expression.
#      b3.408  illegal if setexit code branches to return.
#      b3.409  illegal on detaching input, output, terminal.
#
#      changes
#      -------
#
#      c3.401  -sequ and -nose control cards removed.
#      c3.402  option provided to suppress system identification
#              on listing.
#      c3.403  description of sysbx slightly revised.
#      c3.404  permissible to modify scblk length before taking
#              error returns from sysin, sysrd, sysri.
#      c3.405  conditional .cnld may be defined to omit load().
#      c3.406  conditional .cnex may be defined to omit exit().
#      c3.407  table now accepts a third argument specifying
#              default initial lookup value.
#      c3.408  routines sort, rsort for sorting arrays and table
#              introduced. specification is as in sitbol.
#              routines may be omitted by defining .cnsr .
#      c3.409  error in code(), eval() call now causes statement
#              failure but errtext keyword is still set.
#      c3.410  arg to code() may contain embedded control cards
#              and comment delimited by a semicolon.
#
#      documentation revisions
#      -----------------------
#
#      d3.401  purpose of restriction 2 in minimal section -6-
#              (operations on char values), erroneously stated
#              to be for cmc, rather than for ceq, cne.
#              descriptions of above opcodes revised.
#      d3.402  description of ent clarified.
#      d3.403  descriptions of several opcodes revised to remove
#              technically invalid literals e.g. =0 , *1.
#      d3.405  restricted use of letter z in minimal clarified.
#      d3.406  divide by zero explicitly mentioned in relation
#              to overflow setting.
                            #} ejc
        .eject
#      version 3.3 to 3.4 (oct 78)
#      ---------------------------
#
#
#      bugs fixed
#      ----------
#
#      b3.301  illegal for erroneous eval() arg.
#      b3.302  address arithmetic overflow in alloc and alocs.
#      b3.303  -eject and -space ignored -nolist option.
#      b3.304  erroneous argument scan in load().
#      b3.305  erroneous plc on uninitialised r$cim in nexts.
#      b3.306  ldi used instead of mti after prv07.
#      b3.307  misuse of rmi at erra2.
#      b3.308  misuse of mti in hashs.
#      b3.309  bug in -sequ card sequence number checking.
#      b3.310  stack overflow error message not always printed.
#      b3.311  corrupt prototype print for traced arrays.
#      b3.312  pattern first arg in dupl caused error.
#      b3.313  omitted csc in s$rpd, erroneous csc in convert.
#      b3.314  misplaced btw in exbld.
#      b3.315  incorrect code in hashs.
#      b3.316  failure of load to scan integer arg.
#      b3.317  table access with negative integer arg. failed.
#      b3.318  error in returning result of loaded function.
#      b3.319  =e$srs used after ini01 instead of *e$srs.
#      b3.320  err used instead of erb after systu
#      b3.321  label could start with disallowed character.
#      b3.322  continue after setexit had bad heuristic.
                            #} ejc
        .eject
#
#
#      changes
#      -------
#
#      c3.301  sysax and .csax introduced - see sysax
#              in procedures section.
#      c3.302  variable mxlen introduced. contains the maximum
#              size of a spitbol object and is not changeable
#              after initialisation. may be defaulted or set
#              explicitly by sysmx.
#      c3.303  syshs returns revised - see syshs.
#      c3.304  new minimal opcode aov to fix b3.302.
#      c3.305  inhibit stlimit check if stlimit made negative.
#      c3.306  cfp$m is required to be of form 2**n - 1.
#      c3.307  dupl made to conform to sil snobol4 standard.
#      c3.308  lch and sch actions more closely defined.
#      c3.309  batch initialisation code omitted if conditional
#              assembly symbol .cnbt (no batch) defined.
#      c3.310  (wa) contains argument count in sysex call.
#      c3.311  sysfc  may request allocation of static fcblk.
#      c3.312  if ia,wc overlap, restriction put on dumping/
#              restoring these registers.
#      c3.313  new listing option intermediate between compact
#              and extended provided (see syspp).
#      c3.314  revision of sysxi interface to permit options for
#              load module standard o/p file (see sysxi,syspp).
#      c3.315  last arg of substr may be omitted - treated
#              as remainder of string.
                            #} ejc
        .eject
#      version 3.2 to 3.3 (jan 78)
#      ---------------------------
#
#      bugs fixed
#      ----------
#
#      b3.201  array reference and external function load
#              routines illegally accessed information
#              beyond the stack front.
#              similar fault in unanchored pattern matching.
#      b3.202  dump(1) produced dump(2) type output.
#      b3.203  wtb conversion omitted in code following
#              ini01, ini02, exbld.
#      b3.204  incorrect fail return from tfind in arref.
#      b3.205  endfile did not detach i/o associated variables.
#      b3.206  -space with omitted arg. failed
#      b3.207  looped if dump keyword non-zero after stack
#              overflow in garbage collect failure.
#      b3.208  failure in reading numbers with trailing blanks.
#
#      changes
#      -------
#
#      the extensive changes made here mostly result from a
#      snobol4 implementors meeting held at new york university
#      in august 1977. they are aimed at
#           (1) having spitbol conform to certain snobol4
#           language standards  and
#           (2) producing a stable definition of minimal by
#           carrying out a few essential revisions in the light
#           of experience in its use.
#
#      changes to spitbol
#      ------------------
#
#      c3.201  default values for keywords trim and anchor are
#              zero. on systems where records are customarily
#              handled without traling blanks, there is no
#              obligation to supply such blanks.
#      c3.202  default value of -inxx control card is -in72.
                            #} ejc
        .eject
#      c3.203  the second argument of input and output is
#              permitted to be an integer as in snobol4.
#              in addition input(), output() now give a snobol4
#              statement failure if sysio uses the file not
#              found return.
#              the third argument has a recommended format and
#              to override its default delimiter (,) a
#              conditional assembly symbol, .ciod, is used.
#              interfaces to sysef,sysej,syfc,sysio,sysrw
#              are revised.
#              wc may now be used to return from sysio, a max
#              record length.
#      c3.204  a new configuration parameter cfp$f (scblk offset
#              is introduced. cfp$u is removed.
#      c3.205  implementation and version identification is
#              required - see sysid.
#      c3.206  routine sysmx returns the maximum length of
#              spitbol objects (strings arrays etc).  this
#              information is not now needed at time of entry to
#              spitbol and hence wc should be zero on entry.
#      c3.207  a conditional parameter .cnra permits assembly
#              of a more compact version with no real
#              arithmetic code.
#      c3.208  terminal is a new pre-associated variable
#              capable of performing input and output to an
#              online terminal.
#              sysri is a new routine used in the implementation
#              of this. see also syspp.
#      c3.209  the environment parameters e$--- are now
#              provided by the minimal translator using the
#              revised   equ  *   format (see c3.229 and start
#              of spitbol definitions section - some reordering
#              of symbols has occurred).
#      c3.210  the interface of sysxi has been slightly revised.
#              unavailability of i/o channels after exit(1),
#              exit(-1) is documented together with additional
#              error return usage for sysin,sysou,syspr,sysrd.
#      c3.211  spitbol error codes have been frozen - see c3.230
#      c3.212  the utility routines arref etc. are now
#              introduced by rtn statements.
#      c3.213  sysrl (record length for std input file) is
#              removed. since implementation of a general -inxxx
#              control card and an ability to specify max record
#              length using the third argument of input, sysrl
#              has become redundant.
#      c3.214  sysej and sysxi are now passed a chain linking
#              all fcblks in use.
#      c3.215  a special ending code in sysej is used when
#              attempts to use standard output channel fail.
#      c3.216  restriction c3.233 observed so simplifying
#              optimised translation of ent with omitted val.
                            #} ejc
        .eject
#
#      changes to minimal
#      ------------------
#
#      c3.220  minimal opcodes dec, dim, inc, and bmp
#              are withdrawn and replaced by the more consistent
#              set dca, dcv, ica, icv.
#      c3.221  chs has been replaced by the more generally
#              useful zgb (still likely to be a no-op for most
#              implementations however).
#      c3.222  the set of character comparisons has been
#              reduced to ceq and cne to ease implementation
#              problems.
#      c3.223  opcode irz is removed and dvi, rmi orders are
#              redefined to conform to more common usage.
#      c3.224  new opcodes ssl and sss are defined. their use
#              permits return links for n type procedures to be
#              placed on a local stack if desired.
#      c3.225  opcode mnz complements zer. it moves a non-zero
#              flag to its destination.
#      c3.226  for some machines it is preferable for the stack
#              to build up rather than down. to permit this
#              without need for massive changes in minimal and
#              recoding of existing programs, a scheme has been
#              devised in which an additional register name, xt,
#              is used as a synonym for xl when this register
#              is involved in stack manipulation- see section 4.
#      c3.227  section 0 of a minimal program is renamed the
#              procedure section. it now contains, in addition
#              to exp, specifications of internal procedures
#              and routines by means of the inp and inr opcodes.
#      c3.228  the literal operand formats =int and *int have
#              been withdrawn. =dlbl and *dlbl must be used in
#              their stead.
#      c3.229  the format
#              label  equ  *nn
#              used to specify values supplied by the minimal
#              translator for char. codes etc. is replaced by
#              label  equ  *
#              where the order in which the definitions are
#              supplied by the translator should match the
#              order of occurrence in the definitions section.
#      c3.230  the format of err,erb opcodes is changed to
#              require a numeric operand.
#      c3.231  the rtn opcode is used to introduce routines
#              (which are quite distinct from procedures).
#      c3.232  conditional assembly directives may be nested.
#      c3.233  minor restriction placed on the omission of
#              val with the ent opcode.
                            #} ejc
        .eject
#      version 3.1 to 3.2 (aug 77)
#      ---------------------------
#
#      bugs fixed
#      ----------
#
#      b3.101  astonishing this was unnoticed for three years.
#              bad code for snobol4 integer divide, /, gave
#              wrong result for operands of opposite signs.
#              implementations have either wrongly translated
#              dvi and got correct result or correctly
#              translated dvi and got wrong result - leeds had
#              one of each. see also c3.106.
#              test program no. 1 now extended to check /
#              more thoroughly.
#      b3.102  garbage collection bug in scane
#
#      changes
#      -------
#
#      c3.101  option to use additional characters ch$ht,ch$vt
#              (horizontal and vertical tab) with same syntactic
#              significance as ch$bl (blank).
#      c3.102  option to use a set of shifted case alphabetic
#              characters ch$$a ... ch$$$.
#      c3.103  conditional assembly features are introduced into
#              minimal on account of the above.
#              see minimal documentation section for details
#              of above changes.
#      c3.104  lch and sch may use an x register first
#              operand as alternative to a w register.
#      c3.105  spitbol statement numbers in the listing may
#              optionally be padded to 6 or 8 chars instead of 5
#              by defining conditional assembly symbols
#              .csn6 or .csn8 .
#      c3.106  to fix bug 3.101. at moderate cost,
#              opcode irz (branch if integer divide remainder
#              zero) introduced.
#      c3.107  to handle possible machine dependency in string
#              hashing, chs (complete hashing of string) opcode
#              is introduced. probably a no-op on most machines
#              - not on the dec10.
#      c3.108  procedures patin,tfind,trace have been
#              modified to conform to the minimal standard
#              call and return regime.
#      c3.109  sysfc interface revised slightly to permit
#              osint to return a pointer to a privately
#              allocated fcblk which spitbol will return on
#              subsequent i/o - see sysfc doc.
#      c3.110  to remove inconsistencies in calling sequences,
#              all sys routines having access to a possible
#              fcblk have fcblk ptr or zero in reg. wa on entry.
#              change affects sysef, sysen, sysil, sysin,
#              sysou, sysrw.
#      c3.111  syspp bit allocated to provide
#               -noexec option on entry to spitbol.
                            #} ejc
        .eject
#
#      documentation revisions
#      -----------------------
#
#      d3.101  need to preserve registers in syspi, syspr,
#              sysrd calls was overstated.
                            #} ejc
        .eject
#      version 3.0 to 3.1 (mar 77)
#      ---------------------------
#
#      bugs fixed
#      ----------
#
#      b3.001  replace() could fail during pre-evaluation.
#              spitbol now signals an error for null or
#              unequally long 2nd and 3rd arguments.
#      b3.002  negative second arguments to dupl, lpad, rpad
#              caused spitbol to signal an error. now causes
#              return of null string or first arg respectively.
#      b3.003  brn-s used instead of ppm-s in s$sub.
#      b3.004  err used instead of erb after cmp30.
#      b3.005  b$pfc, s$cnv, s$def, arith and arref kept
#              information illegally above the stack top.
#      b3.006  pre-evaluation of constant parts of
#              complex gotos was erroneous.
#      b3.007  incorrect handling of labels compiled by code().
#      b3.008  the single use of trc (in s$rpl) was not in
#              accord with its definition. some translations of
#              trc may need revision now that the use
#              has been brought into line with definition.
#
#      changes
#      -------
#
#      a debate on a few weaknesses in minimal design has
#      been resolved by introducing 4 new opcodes.
#
#      c3.001  new minimal opcodes bmp and dim introduced
#              to augment inc and dec which are applicable
#              only to addresses.
#      c3.002  the opcode szc (store zero characters) had
#              a restricted applicability. it has been
#              replaced by the more general zer (zeroise).
#      c3.003  fcblks may be optionally allocated as xrblk-s or
#              xnblk-s  - see sysfc for vital information.
#      c3.004  control card processing has been recoded.
#              -inxxx allows specification of standard input
#              file record lengths other than 72 or 80, see also
#              sysrl. -sequ is ignored unless -in80 is in effect
#      c3.005  to enable efficient buffering of chars on
#              machines without char. handling orders, the
#              csc (complete store characters) instruction
#              is introduced. current implementations can
#              translate it as a no-op if it is of no benefit.
#      c3.006  integers 0,1,2 are treated specially.
#              icblks in static are used instead of
#              allocating space in dynamic.
                            #} ejc
        .eject
#
#      version 2.7 (june 76) to 3.0 (jan 77)
#      -------------------------------------
#
#      bugs fixed
#      ----------
#
#      b2.701  goes illegal if timed out during processing of
#              dump() call.
#      b2.702  goes illegal if spitbol error detected in args of
#              code() or eval(). bug fixed so that user now gets
#              a spitbol error report (trappable by setexit)
#              before statement failure.
#      b2.703  goes illegal in some circumstances when
#              multiple compilation errors occur in a statement
#      b2.704  goes illegal if garbage collector runs out of
#              stack space.
#      b2.705  control card processing incorrect for cdc 6400.
#      b2.706  incorrect handling of multiple occurrences of
#              chars in replace 2nd and 3rd args.
#      b2.707  stack overflow in pre-evaluation of replace in
#              cdc 6400 version.
#      b2.708  an explicit call of sysmw was coded in s$dat
#              instead of the mvw opcode.
#      b2.709  call of garbage collector whilst dumping
#              caused havoc.
#      b2.710  size restriction on spitbol objects (size must be
#              numerically less than lowest dynamic address)
#              was not enforced, with potential for catastrophe.
#      b2.711  deferred expressions involving alternation or
#              negation were incorrectly translated.
#      b2.712  listing of a compilation error at the end of a
#              long line could cause compiler to go illegal.
#      b2.713  incorrect -nofail code with success goto.
                            #} ejc
        .eject
#
#
#      changes
#      -------
#
#      (it is not anticipated that major revisions on this
#      scale will be frequent).
#
#      c2.701  default value of anchor keyword is set to 1. this
#              conflicts with snobol4 practice but is a
#              preferable default for most applications.
#      c2.702  if errtype is out of range the string in keyword
#              errtext is printed as the error message.
#      c2.703  if stlimit is exceeded, up to 10 more statements
#              may be obeyed to permit setexit trap to gain
#              control.
#      c2.704  the concept of an interactive channel is
#              introduced for implementations where an online
#              terminal may be used for spitbol. the standard
#              print file may be specified as interactive in
#              which case shorter title lines are output.
#              alternatively copies of compilation and
#              execution errors only may be sent to this channel
#      c2.705  printing of compilation statistics may be
#              suppressed.
#      c2.706  printing of execution statistics may be
#              suppressed.
#      c2.707  extended or compact listing format may be
#              selected.
#      c2.708  an initial -nolist option may be specified
#              before compilation starts.
#      c2.709  to specify choices implied by c2.704 to c2.708
#              syspp interface is revised and syspi is defined.
#      c2.710  compilation and execution time statistics
#              messages have been shortened.
#      c2.711  the exit function as in sitbol is introduced
#              to permit saving load modules - see sysxi, s$ext.
#      c2.712  diagnostic routines sysgb and sysgd have been
#              removed. they were useful in the early debugging
#              days but have fallen into disuse now.
#      c2.713  szc may have an operand of type opn instead of
#              type opw
#      c2.714  input/output association interface has been
#              revised. sysif,sysof have been consolidated into
#              the new system routine, sysio, and the
#              specification of sysfc has been slightly changed.
#      c2.715  configuration parameter mxlen has been withdrawn
#              and the maximum size of a spitbol object which
#              was formerly fixed at spitbol compile time by
#              reference to it may now be specified as a run
#              time option by placing a value in wc before entry
#              to spitbol. (see comment on dynamic area in
#              basic information section).
#      c2.716  a function, host, is introduced which yields
#              information about the host machine - see syshs
#              and s$hst.
                            #} ejc
        .eject
#
#      documentation revisions
#      -----------------------
#
#      d2.701  the description of mvc has been revised to
#              reflect the fact that some spitbol code sequences
#              rely on mvc not destroying wb. minor changes
#              have been made to mwb and mvw descriptions to
#              emphasise similarities in the implicit loops of
#              these orders.
#      d2.702  descriptions of dvi and rmi have been clarified.
#      d2.703  implementation of rsx,lsx,ceq,cge,cgt,chi,clo,clt
#              is optional at present since they are currently
#              unused. their use in later versions is not
#              excluded.
#      d2.704  impossibility of using stack for return links of
#              n type procedures is emphasised.
#      d2.705  notation (xl),(wc) etc in language description is
#              clarified.
#      d2.706  documentation of sysfc, sysio has been improved.
#      d2.707  opcode descriptions are cross referenced from
#              the alphabetical opcode list.
#      d2.708  general description of compiler has been moved to
#              the start of the compiler proper.
#      d2.709  definitions of environment parameters have been
#              put near the front of the definitions section.
                            #} ttl minimal -- machine independent macro assembly lang.
        .sbttl "minimal -- machine independent macro assembly lang."
                            #} ejc
        .eject
#
#      the following sections describe the implementation
#      language originally developed for spitbol but now more
#      widely used. minimal is an assembly language
#      for an idealized machine. the following describes the
#      basic characteristics of this machine.
#
#      section 1 - configuration parameters
#
#      there are several parameters which may vary with the
#      target machine. the macro-program is independent of the
#      actual definitions of these parameters.
#
#      the definitions of these parameters are supplied by
#      the translation program to match the target machine.
#
#      cfp$a                 number of distinct characters in
#                            internal alphabet in the range
#                            64 le cfp$a le mxlen.
#
#      cfp$b                 number of bytes in a word where a
#                            byte is the amount of storage
#                            addressed by the least significant
#                            address bit.
#
#      cfp$c                 number of characters which can
#                            be stored in a single word.
#
#      cfp$f                 byte offset from start of a string
#                            block to the first character.
#                            depends both on target machine and
#                            string data structure. see plc, psc
#
#      cfp$i                 number of words in a signed
#                            integer constant
#
#      cfp$l                 the largest unsigned integer
#                            of form 2**n - 1 which can be
#                            stored in a single word.  n will
#                            often be cfp$n but need not be.
#
#      cfp$m                 the largest positive signed integer
#                            of form 2**n - 1 which can be
#                            stored in a single word.  n will
#                            often be cfp$n-1 but need not be.
#
#      cfp$n                 number of bits which can be stored
#                            in a one word bit string.
#
#      cfp$r                 number of words in a real constant
#
#      cfp$s                 number of significant digits to
#                            be output in conversion of a real
#                            quantity.
#                            the integer consisting of
#                            this number of 9s must not be too
#                            large to fit in the integer accum.
#
#      cfp$u                 realistic upper bound on alphabet.
#
#
#      cfp$x                 number of digits in real exponent
                            #} ejc
        .eject
#
#      section 2 - memory
#
#      memory is organized into words which each contain cfp$b
#      bytes. for word machines cfp$b, which is a configuration
#      parameter, may be one in which case words and bytes are
#      identical. to each word corresponds an address which is
#      a non-negative quantity which is a multiple of cfp$b.
#      data is organized into words as follows.
#
#      1)   a signed integer value occupies cfp$i consecutive
#           words (cfp$i is a configuration parameter).
#           the range may include more negative numbers than
#           positive (e.g. the twos complement representation).
#
#      2)   a signed real value occupies cfp$r consecutive
#           words. (cfp$r is a configuration parameter).
#
#      3)   cfp$c characters may be stored in a single word
#           (cfp$c is a configuration parameter).
#
#      4)   a bit string containing cfp$n bits can be stored in
#           a single word (cfp$n is a configuration parameter).
#
#      5)   a word can contain a unsigned integer value in
#           the range (0 le n le cfp$l). these integer values
#           may represent addresses of other words and some of
#           the instructions use this fact to provide indexing
#           and indirection facilities.
#
#      6)   program instructions occupy words in an undefined
#           manner. depending on the actual implementation,
#           instructions may occupy several words, or part of
#           a word, or even be split over word boundaries.
#
#      the following regions of memory are available to the
#      program. each region consists of a series of words with
#      consecutive addresses.
#
#      1)   constant section           assembled constants
#      2)   working storage section    assembled work areas
#      3)   program section            assembled instructions
#      4)   stack area                 allocated stack area
#      5)   data area                  allocated data area
                            #} ejc
        .eject
#
#      section 3 - registers
#
#      there are three index registers called xr,xl,xs. in
#      addition xl may sometimes be referred to by the alias
#      of xt - see section 4. any of the above registers
#      may hold a positive unsigned integer in the range
#      (0 le n le cfp$l). when the index register is used for
#      indexing purposes, this must be an appropriate address.
#      xs is special in that it is used to point to the top
#      item of a stack in memory. the stack may build up or
#      down in memory.since it is required that xs points to the
#      stack top but access to items below the top is permitted,
#      registers xs and xt may be used with suitable offsets
#      to index stacked items. only xs and xt may be used for
#      this purpose since the direction of the offset is
#      target machine dependent. xt is a synonym for xl
#      which therefore cannot be used in code sequences
#      referencing xt.
#
#      the stack is used for s-r linkage and temporary
#      data storage for which the stack arrangement is suitable.
#      xr,xl can also contain a character pointer in conjunction
#      with the character instructions (see description of plc).
                            #} ejc
        .eject
#
#      there are three work registers called wa,wb,wc which
#      can contain any data item which can be stored in a
#      single memory word. in fact, the work registers are just
#      like memory locations except that they have no addresses
#      and are referenced in a special way by the instructions.
#
#      note that registers wa,wb have special uses in connection
#      with the cvd, cvm, mvc, mvw, mwb, cmc, trc instructions.
#
#      register wc may overlap the integer accumulator (ia) in
#      some implementations. thus any operation changing the
#      value in wc leaves (ia) undefined and vice versa
#      except as noted in the following restriction on simple
#      dump/restore operations.
#
#          restriction
#          -----------
#
#      if ia and wc overlap then
#          sti  iasav
#          ldi  iasav
#      does not change wc, and
#          mov  wc,wcsav
#          mov  wcsav,wc
#      does not change ia.
#
#
#
#      there is an integer accumulator (ia) which is capable of
#      holding a signed integer value (cfp$i words long).
#      register wc may overlap the integer accumulator (ia) in
#      some implementations. thus any operation changing the
#      value in wc leaves (ia) undefined and vice versa
#      except as noted in the above restriction on simple
#      dump/restore operations.
#
#
#
#      there is a single real accumulator (ra) which can hold
#      any real value and is completely separate from any of
#      the other registers or program accessible locations.
#
#
#
#      the code pointer register (cp) is a special index
#      register for use in implementations of interpretors.
#      it is used to contain a pseudo-code pointer and can
#      only be affected by icp, lcp, scp and lcw instructions.
                            #} ejc
        .eject
#      section 4 - the stack
#
#      the following notes are to guide both implementors of
#      systems written in minimal and minimal programmers in
#      dealing with stack manipulation. implementation of a
#      downwards building stack is easiest and in general is
#      to be preferred, in which case it is merely necessary to
#      consider xt as an alternative name for xl.
#
#      the minimal virtual machine includes a stack and has
#      operand formats -(xs) and (xs)+ for pushing and popping
#      items with an implication that the stack builds down in
#      memory (a d-stack). however on some target machines it is
#      better for the stack to build up (a u-stack).
#      a stack addressed only by push and pop operations can
#      build in either direction with no complication but
#      such a pure scheme of stack access proves restrictive.
#      hence it is permitted to access buried items using an
#      integer offset past the index register pointing to the
#      stack top. on target machines this offset will be
#      positive/negative for d-stacks/u-stacks and this must
#      be allowed for in the translation.
#      a further restriction is that at no time may an item be
#      placed above the stack top. for some operations this
#      makes it convenient to advance the stack pointer and then
#      address items below it using a second index register.
#      the problem of signed offsets past such a register then
#      arises. to distinguish stack offsets, which in some
#      implementations may be negative, from non-stack offsets
#      which are invariably positive, xt, an alias or
#      synonym for xl is used. for a u-stack implementation, the
#      minimal translator should negate the sign of offsets
#      applied to both (xs) and (xt).
#      programmers should note that since xt is not a
#      separate register, xl should not be used in code where
#      xt is referenced. other modifications needed in u-stack
#      translations are in the add, sub, ica, dca opcodes
#      applied to xs, xt. for example
#
#      minimal           d-stack trans.  u-stack trans.
#
#      mov  wa,-(xs)     sbi  xs,1       adi  xs,1
#                        sto  wa,(xs)    sto  wa,(xs)
#      mov  (xt)+,wc     lod  wc,(xl)    lod  wc,(xl)
#                        adi  xl,1       sbi  xl,1
#      add  =seven,xs    adi  xs,7       sbi  xs,7
#      mov  2(xt),wa     lod  wa,2(xl)   lod  wa,-2(xl)
#      ica  xs           adi  xs,1       sbi  xs,1
#
#      note that forms such as
#      mov  -(xs),wa
#      add  wa,(xs)+
#      are illegal, since they assume information storage
#      above the stack top.
                            #} ejc
        .eject
#      section 5 - internal character set
#
#      the internal character set is represented by a set of
#      contiguous codes from 0 to cfp$a-1. the codes for the
#      digits 0-9 must be contiguous and in sequence. other
#      than this, there are no restraints.
#
#      the following symbols are automatically defined to have
#      the value of the corresponding internal character code.
#
#      ch$la                 letter a
#      ch$lb                 letter b
#      .                     .
#      ch$l$                 letter z
#
#      ch$d0                 digit 0
#      .                     .
#      ch$d9                 digit 9
#
#      ch$am                 ampersand
#      ch$as                 asterisk
#      ch$at                 at
#      ch$bb                 left bracket
#      ch$bl                 blank
#      ch$br                 vertical bar
#      ch$cl                 colon
#      ch$cm                 comma
#      ch$dl                 dollar sign
#      ch$dt                 dot (period)
#      ch$dq                 double quote
#      ch$eq                 equal sign
#      ch$ex                 exclamation mark
#      ch$mn                 minus
#      ch$nm                 number sign
#      ch$nt                 not
#      ch$pc                 percent
#      ch$pl                 plus
#      ch$pp                 left paren
#      ch$rb                 right bracket
#      ch$rp                 right paren
#      ch$qu                 question mark
#      ch$sl                 slash
#      ch$sm                 semi-colon
#      ch$sq                 single quote
#      ch$un                 underline
#
#      the following optional symbols are incorporated
#      by defining the conditional assembly symbol named.
#
#      26 shifted letters incorporated by defining .casl
#
#      ch$$a                 shifted a
#      ch$$b                 shifted b
#      .                     .
#      ch$$$                 shifted z
#
#      ch$ht                 horizontal tab - define .caht
#      ch$vt                 vertical tab   - define .cavt
#      ch$ey                 up arrow       - define .caex
                            #} ejc
        .eject
#
#      section 6 - conditional assembly features
#
#      some features of the interpreter are applicable to only
#      certain target machines. they may be incorporated or
#      omitted by use of conditional assembly. the full
#      form of a condition is -
#      .if    conditional assembly symbol    (cas)
#      .then
#             minimal statements1   (ms1)
#      .else
#             minimal statements2   (ms2)
#      .fi
#      the following rules apply
#      1.   the directives .if, .then, .else, .fi must
#           start in column 1.
#      2.   the conditional assembly symbol must start with a
#           dot in column 8 followed by 4 letters or digits e.g.
#              .ca$1
#      3.   .then is redundant and may be omitted if wished.
#      4.   ms1, ms2 are arbitrary sequences of minimal
#           statements either of which may be null or may
#           contain further conditions.
#      5.   if ms2 is omitted, .else may also be omitted.
#      6.   .fi is required.
#      7.   conditions may be nested to a depth determined
#           by the translator (not less than 20, say).
#
#      selection of the alternatives ms1, ms2 is by means of the
#      define and undefine directives of form -
#      .def   cas
#      .undef cas
#      which obey rules 1. and 2. above and may occur at any
#      point in a minimal program, including within a condition.
#      multiply defining a symbol is an error.
#      undefining a symbol which is not defined is not an error.
#
#      the effect is that if a symbol is currently defined,
#      then in any condition depending on it, ms1 will be
#      processed and ms2 omitted. conversely if it is undefined,
#      ms1 will be omitted and ms2 processed.
#
#      nesting of conditions is such that conditions
#      in a section not selected for processing must not be
#      evaluated. nested conditions must remember their
#      environment whilst being processed. effectively this
#      implies use of a scheme based on a stack with .if, .fi
#      matching by the condition processor of the translator.
                            #} ejc
        .eject
#
#      section 7 - operand formats
#
#      the following section describes the various possibilities
#      for operands of instructions and assembly operations.
#
#      01   int              unsigned integer le cfp$l
#      02   dlbl             symbol defined in definitions sec
#      03   wlbl             label in working storage section
#      04   clbl             label in constant section
#      05   elbl             program section entry label
#      06   plbl             program section label (non-entry)
#      07   x                one of the three index registers
#      08   w                one of the three work registers
#      09   (x)              location indexed by x
#      10   (x)+             like (x) but post increment x
#      11   -(x)             like (x) but predecrement x
#      12   int(x)           location int words beyond addr in x
#      13   dlbl(x)          location dlbl words past addr in x
#      14   clbl(x)          location (x) bytes beyond clbl
#      15   wlbl(x)          location (x) bytes beyond wlbl
#      16   integer          signed integer (dic)
#      17   real             signed real (drc)
#      18   =dlbl            location containing dac dlbl
#      19   *dlbl            location containing dac cfp$b*dlbl
#      20   =wlbl            location containing dac wlbl
#      21   =clbl            location containing dac clbl
#      22   =elbl            location containing dac elbl
#      23   pnam             procedure label (on prc instruc)
#      24   eqop             operand for equ instruction
#      25   ptyp             procedure type (see prc)
#      26   text             arbitrary text (erb,err,ttl)
#      27   dtext            delimited text string (dtc)
#
#      the numbers in the above list are used in subsequent
#      description and in some of the minimal translators.
                            #} ejc
        .eject
#
#      operand formats (continued)
#
#      the following special symbols refer to a collection of
#      the listed possibilities
#
#      val  01,02                      predefined value
#
#           val is used to refer to a predefined one word
#           integer value in the range 0 le n le cfp$l.
#
#      reg  07,08                      register
#
#           reg is used to describe an operand which can be
#           any of the registers (xl,xr,xs,xt,wa,wb,wc). such
#           an operand can hold a one word integer (address).
#
#      opc  09,10,11                   character
#
#           opc is used to designate a specific character
#           operand for use in the lch and sch instructions.
#           the index register referenced must be either xr or
#           xl (not xs,xt). see section on character operations.
#
#      ops  03,04,09,12,13,14,15       memory reference
#
#           ops is used to describe an operand which is in
#           memory. the operand may be one or more words long
#           depending on the data type. in the case of multiword
#           operands, the address given is the first word.
#
#      opw  as for ops + 08,10,11      full word
#
#           opw is used to refer to an operand whose capacity is
#           that of a full memory word. opw includes all the
#           possibilities for ops (the referenced word is used)
#           plus the use of one of the three work registers
#           (wa,wb,wc). in addition, the formats (x)+ and -(x)
#           allow indexed operations in which the index register
#           is popped by one word after the reference (x)+,
#           or pushed by one word before the reference -(x)
#           these latter two formats provide a facility for
#           manipulation of stacks. the format does not imply
#           a particular direction in which stacks must build -
#           it is used for compactness. note that there is a
#           restriction which disallows an instruction to use
#           an index register in one of these formats
#           in some other manner in the same instruction.
#           e.g.   mov  xl,(xl)+   is illegal.
#           the formats -(x) and (x)+ may also be used in
#           pre-decrementation, post-incrementation to access
#           the adjacent character of a string.
                            #} ejc
        .eject
#
#      operand formats (continued)
#
#      opn  as for opw + 07            one word integer
#
#           opn is used to represent an operand location which
#           can contain a one word integer (e.g. an address).
#           this includes all the possibilities for opw plus
#           the use of one of the index registers (xl,xr,xt,
#           xs). the range of integer values is 0 le n le cfp$l.
#
#      opv  as for opn + 18-22         one word integer value
#
#           opv is used for an operand which can yield a one
#           word integer value (e.g. an address). it includes
#           all the possibilities for opn (the current value of
#           the location is used) plus the use of literals. note
#           that although the literal formats are described in
#           terms of a reference to a location containing an
#           address constant, this location may not actually
#           exist in some implementations since only the value
#           is required. a restriction is placed on literals
#           which may consist only of defined symbols and
#           certain labels. consequently small integers to be
#           used as literals must be pre-defined, a discipline
#           aiding program maintenance and revision.
#
#      addr 01,02,03,04,05             address
#
#           addr is used to describe an explicit address value
#           (one word integer value) for use with dac.
#
#
#           ****************************************************
#           *   in the following descriptions the usage --     *
#           *      (xl),(xr), ... ,(ia)                        *
#           *   in the descriptive text signifies the          +
#           *   contents of the stated register.               *
#           ****************************************************
                            #} ejc
        .eject
#
#      section 8 - list of instruction mnemonics
#
#      the following list includes all instruction and
#      assembly operation mnemonics in alphabetical order.
#      the mnemonics are preceded by a number identifying
#      the following section where the instruction is described.
#      a star (*) is appended to the mnemonic if the last
#      operand may optionally be omitted.
#      see section -15- for details of statement format and
#      comment conventions.
#
#       2.1  add  opv,opn      add address
#       4.2  adi  ops          add integer
#       5.3  adr  ops          add real
#       7.1  anb  opw,w        and bit string
#       2.17 aov  opv,opn,plbl add address, fail if overflow
#       5.16 atn               arctangent of real accum
#       2.16 bct  w,plbl       branch and count
#       2.5  beq  opn,opv,plbl branch if address equal
#       2.18 bev  opn,plbl     branch if address even
#       2.8  bge  opn,opv,plbl branch if address greater or equl
#       2.7  bgt  opn,opv,plbl branch if address greater
#       2.12 bhi  opn,opv,plbl branch if address high
#       2.10 ble  opn,opv,plbl branch if address less or equal
#       2.11 blo  opn,opv,plbl branch if address low
#       2.9  blt  opn,opv,plbl branch if address less than
#       2.6  bne  opn,opv,plbl branch if address not equal
#       2.13 bnz  opn,plbl     branch if address non-zero
#       2.19 bod  opn,plbl     branch if address odd
#       1.2  brn  plbl         branch unconditional
#       1.7  bri  opn          branch indirect
#       1.3  bsw* x,val,plbl   branch on switch value
#       8.2  btw  reg          convert bytes to words
#       2.14 bze  opn,plbl     branch if address zero
#       6.6  ceq  opw,opw,plbl branch if characters equal
#      10.1  chk               check stack overflow
#       5.17 chp               integer portion of real accum
#       7.4  cmb  w            complement bit string
#       6.8  cmc  plbl,plbl    compare character strings
#       6.7  cne  opw,opw,plbl branch if characters not equal
#       6.5  csc  x            complete store characters
#       5.18 cos               cosine of real accum
#       8.8  ctb  w,val        convert character count to bytes
#       8.7  ctw  w,val        convert character count to words
#       8.10 cvd               convert by division
#       8.9  cvm  plbl         convert by multiplication
#      11.1  dac  addr         define address constant
#      11.5  dbc  val          define bit string constant
#       2.4  dca  opn          decrement address by one word
#       1.17 dcv  opn          decrement value by one
#      11.2  dic  integer      define integer constant
                            #} ejc
        .eject
#
#      alphabetical list of mnemonics (continued)
#
#      11.3  drc  real         define real constant
#      11.4  dtc  dtext        define text (character) constant
#       4.5  dvi  ops          divide integer
#       5.6  dvr  ops          divide real
#      13.1  ejc               eject assembly listing
#      14.2  end               end of assembly
#       1.13 enp               define end of procedure
#       1.6  ent* val          define entry point
#      12.1  equ  eqop         define symbolic value
#       1.15 erb  int,text     assemble error code and branch
#       1.14 err  int,text     assemble error code
#       1.5  esw               end of switch list for bsw
#       5.19 etx               e to the power in the real accum
#       1.12 exi* int          exit from procedure
#      12.2  exp               define external procedure
#       6.10 flc  w            fold character to upper case
#       2.3  ica  opn          increment address by one word
#       3.4  icp               increment code pointer
#       1.16 icv  opn          increment value by one
#       4.11 ieq  plbl         jump if integer zero
#       1.4  iff  val,plbl     specify branch for bsw
#       4.12 ige  plbl         jump if integer non-negative
#       4.13 igt  plbl         jump if integer positive
#       4.14 ile  plbl         jump if integer negative or zero
#       4.15 ilt  plbl         jump if integer negative
#       4.16 ine  plbl         jump if integer non-zero
#       4.9  ino  plbl         jump if no integer overflow
#      12.3  inp  ptyp,int     internal procedure
#      12.4  inr               internal routine
#       4.10 iov  plbl         jump if integer overflow
#       8.5  itr               convert integer to real
#       1.9  jsr  pnam         call procedure
#       6.3  lch  reg,opc      load character
#       2.15 lct  w,opv        load counter for loop
#       3.1  lcp  reg          load code pointer register
#       3.3  lcw  reg          load next code word
#       4.1  ldi  ops          load integer
#       5.1  ldr  ops          load real
#       1.8  lei  x            load entry point id
#       5.20 lnf               natural logorithm of real accum
#       7.6  lsh  w,val        left shift bit string
#       7.8  lsx  w,(x)        left shift indexed
#       9.4  mcb               move characterswords backwards
#       8.4  mfi* opn,plbl     convert (ia) to address value
#       4.3  mli  ops          multiply integer
#       5.5  mlr  ops          multiply real
#       1.19 mnz  opn          move non-zero
#       1.1  mov  opv,opn      move
#       8.3  mti  opn          move address value to (ia)
#       9.1  mvc               move characters
#       9.2  mvw               move words
#       9.3  mwb               move words backwards
#       4.8  ngi               negate integer
                            #} ejc
        .eject
#
#      alphabetical list of mnemonics (continued)
#
#       5.9  ngr               negate real
#       7.9  nzb  w,plbl       jump if not all zero bits
#       7.2  orb  opw,w        or bit strings
#       6.1  plc* x,opv        prepare to load characters
#       1.10 ppm* plbl         provide procedure exit parameter
#       1.11 prc  ptyp,val     define start of procedure
#       6.2  psc* x,opv        prepare to store characters
#       5.10 req  plbl         jump if real zero
#       5.11 rge  plbl         jump if real positive or zero
#       5.12 rgt  plbl         jump if real positive
#       5.13 rle  plbl         jump if real negative or zero
#       5.14 rlt  plbl         jump if real negative
#       4.6  rmi  ops          remainder integer
#       5.15 rne  plbl         jump if real non-zero
#       5.8  rno  plbl         jump if no real overflow
#       5.7  rov  plbl         jump if real overflow
#       7.5  rsh  w,val        right shift bit string
#       7.7  rsx  w,(x)        right shift indexed
#       8.6  rti* plbl         convert real to integer
#       1.22 rtn               define start of routine
#       4.4  sbi  ops          subtract integer
#       5.4  sbr  ops          subtract reals
#       6.4  sch  reg,opc      store character
#       3.2  scp  reg          store code pointer
#      14.1  sec               define start of assembly section
#       5.21 sin               sine of real accum
#       5.22 sqr               square root of real accum
#       1.20 ssl  opw          subroutine stack load
#       1.21 sss  opw          subroutine stack store
#       4.7  sti  ops          store integer
#       5.2  str  ops          store real
#       2.2  sub  opv,opn      subtract address
#       5.23 tan               tangent of real accum
#       6.9  trc               translate character string
#      13.2  ttl  text         supply assembly title
#       8.1  wtb  reg          convert words to bytes
#       7.3  xob  opw,w        exclusive or bit strings
#       1.18 zer  opn          zeroise integer location
#       7.11 zgb  opn          zeroise garbage bits
#       7.10 zrb  w,plbl       jump if all zero bits
                            #} ejc
        .eject
#
#      section 9 - minimal instructions
#
#      the following descriptions assume the definitions -
#
#      zeroe  equ  0
#      unity  equ  1
#
#      -1-  basic instruction set
#
#      1.1  mov  opv,opn     move one word value
#
#           mov causes the value of operand opv to be set as
#           the new contents of operand location opn. in the
#           case where opn is not an index register, any value
#           which can normally occupy a memory word (including
#           a part of a multiword real or integer value)
#           can be transferred using mov. if the target location
#           opn is an index register, then opv must specify an
#           appropriate one word value or operand containing
#           such an appropriate value.
#
#      1.2  brn  plbl        unconditional branch
#
#           brn causes control to be passed to the indicated
#           label in the program section.
#
#      1.3  bsw  x,val,plbl  branch on switch value
#      1.4  iff  val,plbl    provide branch for switch
#           iff  val,plbl     ...
#           ...
#           ...
#      1.5  esw              end of branch switch table
#
#           bsw,iff,esw provide a capability for a switched
#           branch similar to a fortran computed goto. the
#           val on the bsw instruction is the maximum number
#           of branches. the value in x ranges from zero up to
#           but not including this maximum. each iff provides a
#           branch. val must be less than that given on the bsw
#           and control goes to plbl if the value in x matches.
#           if the value in x does not correspond to any of the
#           iff entries, then control passes to the plbl on the
#           bsw. this plbl operand may be omitted if there are
#           no values missing from the list.
#
#           iff and esw may only be used in this context.
#           execution of bsw may destroy the contents of x.
#           the iff entries may be in any order and since
#           a translator may thus need to store and sort them,
#           the comment field is restricted in length (sec 11).
                            #} ejc
        .eject
#
#      -1-  basic instructions (continued)
#
#      1.6  ent  val         define program entry point
#
#           the symbol appearing in the label field is defined
#           to be a program entry point which can subsequently
#           be used in conjunction with the bri instruction,
#           which provides the only means of entering the
#           code. it is illegal to fall into code
#           identified by an entry point. the
#           entry symbol is assigned an address which need not
#           be a multiple of cfp$b but which must be in the
#           range 0 le cfp$l and the address must not lie within
#           the address range of the allocated data area.
#           furthermore, addresses of successive entry points
#           must be assigned in some ascending sequence so
#           that the address comparison instructions can be
#           used to test the order in which two entry points
#           occur. the symbol val gives an identifying value
#           to the entry point which can be accessed with the
#           lei instruction.
#
#           note - subject to the restriction below, val may
#           be omitted if no such identification is needed i.e.
#           if no lei references the entry point. for this
#           case, a translation optimisation is possible in
#           which no memory need be reserved for a null
#           identification which is never to be referenced, but
#           only provided this is done so as not to interfere
#           with the strictly ascending sequence of entry point
#           addresses. to simplify this optimisation for all
#           implementors, the following restriction is observed
#                val may only be omitted if the entry point is
#                separated from a following entry point by a
#                non-null minimal code sequence.
#           entry point addresses are accessible only by use of
#           literals (=elbl, section 7) or dac constants
#           (section 8-11.1).
#
#      1.7  bri  opn         branch indirect
#
#           opn contains the address of a program entry point
#           (see ent). control is passed to the executable
#           code starting at the entry point address. opn is
#           left unchanged.
#
#      1.8  lei  x           load entry point identification
#
#           x contains the address of an entry point for which
#           an identifying value was given on the the ent line.
#           lei replaces the contents of x by this value.
                            #} ejc
        .eject
#
#      -1-  basic instructions (continued)
#
#      1.9  jsr  pnam        call procedure pnam
#      1.10 ppm  plbl        provide exit parameter
#           ppm  plbl         ...
#           ...
#           ppm  plbl         ...
#
#           jsr causes control to be passed to the named
#           procedure. pnam is the label on a prc statement
#           elsewhere in the program section (see prc)
#           or has been defined using an exp instruction.
#           the ppm exit parameters following the call give
#           names of program locations (plbl-s) to which
#           alternative exi returns of the called procedure may
#           pass control. they may optionally be replaced by
#           error returns (see err). the number of exit
#           parameters following a jsr must equal the int in the
#           procedure definition. the operand of ppm may be
#           omitted if the corresponding exi return is certain
#           not to be taken.
#
#      1.11 prc  ptyp,int    define start of procedure
#
#           the symbol appearing in the label field is defined
#           to be the name of a procedure for use with jsr.
#           a procedure is a contiguous section of instructions
#           to which control may be passed with a jsr
#           instruction. this is the only way in which the
#           instructions in a procedure may be executed. it is
#           not permitted to fall into a procedure.
#           all procedures should be named in section 0
#           inp  statements.
#
#           int is the number of exit parameters (ppm-s) to
#           be used in jsr calls.
#
#           there are three possibilities for ptyp, each
#           consisting of a single letter as follows.
#
#           r                recursive
#
#           the return point (one or more words) is stored on
#           the stack as though one or more mov ...,-(xs)
#           instructions were executed.
                            #} ejc
        .eject
#
#      -1-  basic instructions (continued)
#
#           n                non-recursive
#
#           the return point is to be stored either
#           (1) in a local storage word associated
#           with the procedure and not directly
#           available to the program in any other manner or
#           (2) on a subroutine link stack quite distinct from
#           the minimal stack addressed by xs.
#           it is an error to use the stack for n-links, since
#           procedure parameters or results may be passed via
#           the stack.
#           if method (2) is used for links, error exits
#           (erb,err) from a procedure will necessitate link
#           stack resetting. the ssl and sss orders provided
#           for this may be regarded as no-ops for
#           implementations using method (1).
#
#           e                either
#
#           the return point may be stored in either manner
#           according to efficiency requirements of the actual
#           physical machine used for the implementation. note
#           that programming of e type procedures must be
#           independent of the actual implementation.
#
#           the actual form of the return point is undefined.
#           however, each word stored on the stack for an
#           r-type call must meet the following requirements.
#
#           1)               it can be handled as an address
#                            and placed in an index register.
#
#           2)               when used as an operand in an
#                            address comparison instruction, it
#                            must not appear to lie within
#                            the allocated data area.
#
#           3)               it is not required to appear
#                            to lie within the program section.
                            #} ejc
        .eject
#
#      -1-  basic instructions (continued)
#
#      1.12 exi  int         exit from procedure
#
#           the ppm and err parameters following a jsr are
#           numbered starting from 1.  exi  int causes control
#           to be returned to the int-th such param. exi 1 gives
#           control to the plbl of the first ppm after the jsr.
#           if int is omitted, control is passed back past the
#           last exit parameter (or past the jsr if there are
#           none). for r and e type procedures, the
#           stack pointer xs must be set to its appropriate
#           entry value before executing an exi instruction.
#           in this case, exi removes return points from the
#           stack if any are stored there so that the stack
#           pointer is restored to its calling value.
#
#      1.13 enp              define end of procedure body
#
#           enp delimits a procedure body and may not actually
#           be executed, hence it must have no label.
#
#      1.14 err  int,text    provide error return
#
#           err may replace an exit parameter (ppm) in
#           any procedure call. the int argument is a unique
#           error code in 0 to 899.
#           the text supplied as the other operand is
#           arbitrary text in the fortran character set and
#           may be used in constructing a file of error
#           messages for documenting purposes or for building
#           a direct access or other file of messages to be
#           used by the error handling code.
#           in the event that an exi attempts
#           to return control via an exit parameter to
#           an err, control is instead passed to the first
#           instruction in the error section (which follows the
#           program section) with the error code in wa.
#
#      1.15 erb  int,text    error branch
#
#           this instruction resembles err except that it may
#           occur at any point where a branch is permitted.
#           it effects a transfer of control to the error
#           section with the error code in wa.
#
#      1.16 icv  opn         increment value by one
#
#           icv increments the value of the operand by unity.
#           it is equivalent to   add  =unity,opn
#
#      1.17 dcv  opn         decrement value by one
#
#           dcv decrements the value of the operand by unity.
#           it is equivalent to   sub  =unity,opn
                            #} ejc
        .eject
#
#      basic instructions (continued)
#
#      1.18 zer  opn         zeroise opn
#
#           zer is equivalent to  mov  =zeroe,opn
#
#      1.19 mnz  opn         move non-zero to opn
#
#           any non-zero collectable value may used, for which
#           the opcodes bnz/bze will branch/fail to branch.
#
#      1.20 ssl  opw         subroutine stack load
#
#      1.21 sss  opw         subroutine stack store
#
#           this pair of operations is provided to make possible
#           the use of a local stack to hold subroutine (s-r)
#           return links for n-type procedures. sss stores the
#           s-r stack pointer in opw and ssl loads the s-r
#           stack pointer from opw. by using sss in the main
#           program or on entry to a procedure which should
#           regain control on occurrence of an err or erb and by
#           use of ssl in the error processing sections the
#           s-r stack pointer can be restored giving a link
#           stack cleaned up ready for resumed execution.
#           the form of the link stack pointer is undefined in
#           minimal (it is likely to be a private register
#           known to the translator) and the only requirement
#           is that it should fit into a single full word.
#           ssl and sss are no-ops if a private link stack is
#           not used.
#
#      1.22 rtn              define start of routine
#
#           a routine is a code chunk used for similar purposes
#           to a procedure. however it is entered by any type of
#           conditional or unconditional branch (not by jsr). on
#           termination it passes control by a branch (often
#           bri through a code word) or even permits control
#           to drop through to another routine. no return link
#           exists and the end of a routine is not marked by
#           an explicit opcode (compare enp).
#           all routines should be named in section 0
#           inr  statements.
                            #} ejc
        .eject
#
#      -2-  operations on one word integer values (addresses)
#
#      2.1  add  opv,opn     adds opv to the value in opn and
#                            stores the result in opn. undefined
#                            if the result exceeds cfp$l.
#
#      2.2  sub  opv,opn     subtracts opv from opn. stores the
#                            result in opn. undefined if the
#                            result is negative.
#
#      2.3  ica  opn         increment address in opn
#                            equivalent to add *unity,opn
#
#      2.4  dca  opn         decrement address in opn
#                            equivalent to sub *unity,opn
#
#      2.5  beq  opn,opv,plbl branch to plbl if opn eq opv
#      2.6  bne  opn,opv,plbl branch to plbl if opn ne opv
#      2.7  bgt  opn,opv,plbl branch to plbl if opn gt opv
#      2.8  bge  opn,opv,plbl branch to plbl if opn ge opv
#      2.9  blt  opn,opv,plbl branch to plbl if opn lt opv
#      2.10 ble  opn,opv,plbl branch to plbl if opn le opv
#      2.11 blo  opn,opv,plbl equivalent to blt or ble
#      2.12 bhi  opn,opv,plbl equivalent to bgt or bge
#
#           the above instructions compare two address
#           values as unsigned integer values.
#           the blo and bhi instructions are used in cases where
#           the equal condition either does not occur or can
#           result either in a branch or no branch. this avoids
#           inefficient translations in some implementations.
#
#      2.13 bnz  opn,plbl    equivalent to bne opn,=zeroe,plbl
#
#      2.14 bze  opn,plbl    equivalent to beq opn,=zeroe,plbl
#
#
#      2.15 lct  w,opv       load counter for bct
#
#           lct loads a counter value for use with the bct
#           instruction. the value in opv is the number of loops
#           to be executed. the value in w after this operation
#           is an undefined one word integer quantity.
#
#      2.16 bct  w,plbl      branch and count
#
#           bct uses the counter value in w to branch the
#           required number of times and then finally to fall
#           through to the next instruction. bct can only be
#           used following an appropriate lct instruction.
#           the value in w after execution of bct is undefined.
#
#      2.17 aov  opv,opn,plbl add with carry test
#
#           adds opv to the value in opn and stores result in
#           opn. branches to plbl if result exceeds cfp$l
#           with result in opn undefined. cf. add.
#
#      2.18 bev  opn,plbl     branch if even
#      2.19 bod  opn,plbl     branch if odd
#
#           these operations are used only if .cepp or .crpp is
#           defined.  on some implementations, a more efficient
#           implementation is possible by noting that address of
#           blocks must always be a multiple of cfp$b. we call
#           such addresses even.  thus return address on the
#           stack (.crpp) and entry point addresses (.cepp) can
#           be distinguished from block addresses if they are
#           forced to be odd (not a multiple of cfp$b).
#           bev and bod branch according as operand is even
#           or odd, respectively.
                            #} ejc
        .eject
#
#      -3-  operations on the code pointer register (cp)
#
#           the code pointer register provides a psuedo
#           instruction counter for use in an interpretor. it
#           may be implemented as a real register or as a
#           memory location, but in either case it is separate
#           from any other register. the value in the code
#           pointer register is always a word address (i.e.
#           a one word integer which is a multiple of cfp$b).
#
#      3.1  lcp  reg         load code pointer register
#                            this instruction causes the code
#                            pointer register to be set from
#                            the value in reg which is unchanged
#
#      3.2  scp  reg         store code pointer register
#                            this instruction loads the current
#                            value in the code pointer register
#                            into reg. (cp) is unchanged.
#
#      3.3  lcw  reg         load next code word
#                            this instruction causes the word
#                            pointed to by cp to be loaded into
#                            the indicated reg. the value in cp
#                            is then incremented by one word.
#                            execution of lcw may destroy xl.
#
#      3.4  icp              increment cp by one word
#
#           on machines with more than three index registers,
#           cp can be treated simply as an index register.
#           in this case, the following equivalences apply.
#
#           lcp reg is like mov reg,cp
#           scp reg is like mov cp,reg
#           lcw reg is like mov (cp)+,reg
#           icp     is like ica cp
#
#           since lcw is allowed to destroy xl, the following
#           implementation using a work location cp$$$ can
#           also be used.
#
#           lcp  reg         mov  reg,cp$$$
#
#           scp  reg         mov  cp$$$,reg
#
#           lcw  reg         mov  cp$$$,xl
#                            mov  (xl)+,reg
#                            mov  xl,cp$$$
#
#           icp              ica  cp$$$
                            #} ejc
        .eject
#
#      -4-  operations on signed integer values
#
#      4.1  ldi  ops         load integer accumulator from ops
#      4.2  adi  ops         add ops to integer accumulator
#      4.3  mli  ops         multiply integer accumulator by ops
#      4.4  sbi  ops         subtract ops from int accumulator
#      4.5  dvi  ops         divide integer accumulator by ops
#      4.6  rmi  ops         set int accum to mod(intacc,ops)
#      4.7  sti  ops         store integer accumulator at ops
#      4.8  ngi              negate the value in the integer
#                            accumulator (change its sign)
#
#           the equation satisfied by operands and results of
#           dvi and rmi is
#                  div = qot * ops + rem          where
#           div = dividend in integer accumulator
#           qot = quotient left in ia by div
#           ops = the divisor
#           rem = remainder left in ia by rmi
#           the sign of the result of dvi is + if (ia) and (ops)
#           have the same sign and is - if they have opposite
#           signs. the sign of (ia) is always used as the sign
#           of the result of rem.
#           assuming in each case that ia contains the number
#           specified in parentheses and that seven and msevn
#           hold +7 and -7 resp. the algorithm is illustrated
#           below.
#           (ia = 13)
#           dvi  seven       ia = 1
#           rmi  seven       ia = 6
#           dvi  msevn       ia = -1
#           rmi  msevn       ia = 6
#           (ia = -13)
#           dvi  seven       ia = -1
#           rmi  seven       ia = -6
#           dvi  msevn       ia = 1
#           rmi  msevn       ia = -6
                            #} ejc
        .eject
#
#           the above instructions operate on a full range of
#           signed integer values. with the exception of ldi and
#           sti, these instructions may cause integer overflow
#           by attempting to produce an undefined or out of
#           range result in which case integer overflow is set,
#           the result in (ia) is undefined and the following
#           instruction must be iov or ino.
#           particular care may be needed on target machines
#           having distinct overflow and divide by zero
#           conditions.
#
#      4.9  ino  plbl        jump to plbl if no integer overflow
#      4.10 iov  plbl        jump to plbl if integer overflow
#
#           these instructions can only occur immediately
#           following an instruction which can cause integer
#           overflow (adi, sbi, mli, dvi, rmi, ngi) and
#           test the result of the preceding instruction.
#           iov and ino may not have labels.
#
#      4.11 ieq  plbl        jump to plbl if (ia) eq 0
#      4.12 ige  plbl        jump to plbl if (ia) ge 0
#      4.13 igt  plbl        jump to plbl if (ia) gt 0
#      4.14 ile  plbl        jump to plbl if (ia) le 0
#      4.15 ilt  plbl        jump to plbl if (ia) lt 0
#      4.16 ine  plbl        jump to plbl if (ia) ne 0
#
#           the above conditional jump instructions do
#           not change the contents of the accumulator.
#           on a ones complement machine, it is permissible to
#           produce negative zero in ia provided these
#           instructions operate correctly with such a value.
                            #} ejc
        .eject
#
#      -5-  operations on real values
#
#      5.1  ldr  ops         load real accumulator from ops
#      5.2  str  ops         store real accumulator at ops
#      5.3  adr  ops         add ops to real accumulator
#      5.4  sbr  ops         subtract ops from real accumulator
#      5.5  mlr  ops         multiply real accumulator by ops
#      5.6  dvr  ops         divide real accumulator by ops
#
#           if the result of any of the above operations causes
#           underflow, the result yielded is 0.0.
#
#           if the result of any of the above operations is
#           undefined or out of range, real overflow is set,
#           the contents of (ra) are undefined and the following
#           instruction must be either rov or rno.
#           particular care may be needed on target machines
#           having distinct overflow and divide by zero
#           conditions.
#
#      5.7  rov  plbl        jump to plbl if real overflow
#      5.8  rno  plbl        jump to plbl if no real overflow
#
#           these instructions can only occur immediately
#           following an instruction which can cause real
#           overflow (adr,sbr,mlr,dvr).
#
#      5.9  ngr              negate real accum (change sign)
#
#      5.10 req  plbl        jump to plbl if (ra) eq 0.0
#      5.11 rge  plbl        jump to plbl if (ra) ge 0.0
#      5.12 rgt  plbl        jump to plbl if (ra) gt 0.0
#      5.13 rle  plbl        jump to plbl if (ra) le 0.0
#      5.14 rlt  plbl        jump to plbl if (ra) lt 0.0
#      5.15 rne  plbl        jump to plbl if (ra) ne 0.0
#
#           the above conditional instructions do not affect
#           the value stored in the real accumulator.
#           on a ones complement machine, it is permissible to
#           produce negative zero in ra provided these
#           instructions operate correctly with such a value.
#
#      5.16 atn              arctangent of real accum
#      5.17 chp              integer portion of real accum
#      5.18 cos              cosine of real accum
#      5.19 etx              e to the power in the real accum
#      5.20 lnf              natural logorithm of real accum
#      5.21 sin              sine of real accum
#      5.22 sqr              square root of real accum
#      5.23 tan              tangent of real accum
#
#           the above orders operate upon the real accumulator,
#           and replace the contents of the accumulator with the
#           result.
#
#           if the result of any of the above operations is
#           undefined or out of range, real overflow is set,
#           the contents of (ra) are undefined and the following
#           instruction must be either rov or rno.
                            #} ejc
        .eject
#
#      -6-  operations on character values
#
#           character operations employ the concept of a
#           character pointer which uses either
#           index register xr or xl (not xs).
#
#           a character pointer points to a specific character
#           in a string of characters stored cfp$c chars to a
#           word. the only operations permitted on a character
#           pointer are lch and sch. in particular, a character
#           pointer may not even be moved with mov.
#
#              restriction 1.
#              --------------
#           it is important when coding in minimal to ensure
#           that no action occurring between the initial use of
#           plc or psc and the eventual clearing of xl or xr on
#           completion of character operations can initiate a
#           garbage collection. the latter of course could cause
#           the addressed characters to be moved leaving the
#           character pointers pointing to rubbish.
#
#              restriction 2.
#              --------------
#           a further restriction to be observed in code
#           handling character strings, is that strings built
#           dynamically should be right padded with zero
#           characters to a full word boundary to permit easy
#           hashing and use of ceq or cne in testing strings
#           for equality.
#
#      6.1  plc  x,opv       prepare ch ptr for lch,cmc,mvc,trc,
#                            mcb.
#
#      6.2  psc  x,opv       prepare char. ptr for sch,mvc,mcb.
#
#           opv can be omitted if it is zero.
#           the char. initially addressed is determined by the
#           word address in x and the integer offset opv.
#           there is an automatic implied offset of cfp$f bytes.
#           cfp$f is used to formally introduce into minimal a
#           value needed in translating these opcodes which,
#           since minimal itself does not prescribe a string
#           structure in detail, depends on the choice of a data
#           structure for strings in the minimal program.
#           e.g. if cfp$b = cfp$c = 3, cfp$f = 6, num01 = 1, xl
#           points to a series of 4 words, abc/def/ghi/jkl, then
#               plc  xl,=num01
#           points to h.
                            #} ejc
        .eject
#
#      -6- operations on character values (continued)
#
#      6.3  lch  reg,opc     load character into reg
#
#      6.4  sch  reg,opc     store character from reg
#
#           these operations are defined such that the character
#           is right justified in register reg with zero bits to
#           the left. after lch for example, it is legitimate
#           to regard reg as containing the ordinal integer
#           corresponding to the character.
#
#           opc is one of the following three possibilities.
#
#           (x)              the character pointed to by the
#                            character pointer in x. the
#                            character pointer is not changed.
#
#           (x)+             same character as (x) but the
#                            character pointer is incremented
#                            to point to the next character
#                            following execution.
#
#           -(x)             the character pointer is decre-
#                            mented before accessing the
#                            character so that the previous
#                            character is referenced.
#
#      6.5  csc  x           complete store characters
#
#           this instruction marks completion of a
#           psc,sch,sch,...,sch sequence initiated by
#           a  psc  x instruction. no more sch instructions
#           using  x  should be obeyed until another psc is
#           obeyed. it is provided solely as an efficiency aid
#           on machines without character orders since it
#           permits use of register buffering of chars in sch
#           sequences. where csc is not a no-op, it must observe
#           restriction 2. (e.g. in spitbol, alocs zeroises the
#           last word of a string frame prior to sch sequence
#           being started so csc must not nullify this action.)
#
#           the following instructions are used to compare
#           two words containing cfp$c characters.
#           comparisons distinct from beq,bne are provided as
#           on some target machines, the possibility of the sign
#           bit being set may require special action.
#           note that restriction 2 above, eases use of these
#           orders in testing complete strings for equality,
#           since whole word tests are possible.
#
#      6.6  ceq  opw,opw,plbl jump to plbl if opw eq opw
#      6.7  cne  opw,opw,plbl jump to plbl if opw ne opw
                            #} ejc
        .eject
#
#      -6- operations on character values (continued)
#
#      6.8  cmc  plbl,plbl   compare characters
#
#           cmc is used to compare two character strings. before
#           executing cmc, registers are set up as follows.
#           (xl)             character ptr for first string
#           (xr)             character pointer for second string
#           (wa)             character count (must be .gt. zero)
#           xl and xr should have been prepared by plc.
#           control passes to first plbl if the first string
#           is lexically less than the second string, and to
#           the second plbl if the first string is lexically
#           greater. control passes to the following instruction
#           if the strings are identical. after executing this
#           instruction, the values of xr and xl are set to
#           zero and the value in (wa) is undefined.
#           arguments to cmc may be complete or partial
#           strings, so making optimisation to use whole word
#           comparisons difficult (dependent in general on
#           shifts and masking).
#
#      6.9  trc              translate characters
#
#           trc is used to translate a character string using a
#           supplied translation table. before executing trc the
#           registers are set as follows.
#           (xl)             char ptr to string to be translated
#           (xr)             char ptr to translate table
#           (wa)             length of string to be translated
#           xl and xr should have been prepared by plc.
#           the translate table consists of cfp$a contiguous
#           characters giving the translations of the cfp$a
#           characters in the alphabet. on completion, (xr) and
#           (xl) are set to zero and (wa) is undefined.
#
#      6.10 flc  w           fold character to upper case
#           flc is used only if .culc is defined. the character
#           code value in w is translated to upper case if it
#           corresponds to a lower case character.
                            #} ejc
        .eject
#
#      -7-  operations on bit string values
#
#      7.1  anb  opw,w       and bit string values
#      7.2  orb  opw,w       or bit string values
#      7.3  xob  opw,w       exclusive or bit string values
#
#           in the above operations, the logical connective is
#           applied separately to each of the cfp$n bits.
#           the result is stored in the second operand location.
#
#      7.4  cmb  w           complement all bits in opw
#
#      7.5  rsh  w,val       right shift by val bits
#      7.6  lsh  w,val       left shift by val bits
#      7.7  rsx  w,(x)       right shift w number of bits in x
#      7.8  lsx  w,(x)       left shift w number of bits in x
#
#           the above shifts are logical shifts in which bits
#           shifted out are lost and zero bits supplied as
#           required. the shift count is in the range 0-cfp$n.
#
#      7.9  nzb  w,plbl      jump to plbl if w is not
#                            all zero bits.
#
#      7.10 zrb  w,plbl      jump to plbl if w is all zero bits
#
#      7.11 zgb  opn         zeroise garbage bits
#
#           opn contains a bit string representing a word
#           of characters from a string or some function
#           formed from such characters (e.g. as a result of
#           hashing). on a machine where the word size is not a
#           multiple of the character size, some bits in reg may
#           be undefined. this opcode replaces such bits by the
#           zero bit. zgb is a no-op if the word size is a
#           multiple of the character size.
                            #} ejc
        .eject
#
#      -8-  conversion instructions
#
#           the following instructions provide for conversion
#           between lengths in bytes and lengths in words.
#
#      8.1  wtb  reg         convert reg from words to bytes.
#                            that is, multiply by cfp$b. this is
#                            a no-op if cfp$b is one.
#
#      8.2  btw  reg         convert reg from bytes to words
#                            by dividing reg by cfp$b discarding
#                            the fraction. no-op if cfp$b is one
#
#           the following instructions provide for conversion
#           of one word integer values (addresses) to and
#           from the full signed integer format.
#
#      8.3  mti  opn         the value of opn (an address)
#                            is moved as a positive integer
#                            to the integer accumulator.
#
#      8.4  mfi  opn,plbl    the value currently stored in the
#                            integer accumulator is moved
#                            to opn as an address if it is in
#                            the range 0 to cfp$m inclusive.
#                            if the accumulator value is
#                            outside this range, then the result
#                            in opn is undefined and control is
#                            passed to plbl. mfi destroys the
#                            value of (ia) whether or not
#                            integer overflow is signalled.
#                            plbl may be omitted if overflow
#                            is impossible.
#
#           the following instructions provide for conversion
#           between real values and integer values.
#
#      8.5  itr              convert integer value in integer
#                            accumulator to real and store in
#                            real accumulator (may lose
#                            precision in some cases)
#
#      8.6  rti  plbl        convert the real value in ra to
#                            an integer and place result in ia.
#                            conversion is by truncation of the
#                            fraction - no rounding occurs.
#                            jump to plbl if out of range. (ra)
#                            is not changed in either case.
#                            plbl may be omitted if overflow
#                            is impossible.
                            #} ejc
        .eject
#
#      -8-  conversion instructions (continued)
#
#           the following instructions provide for computing
#           the length of storage required for a text string.
#
#      8.7  ctw  w,val       this instruction computes the sum
#                            (number of words required to store
#                            w characters) + (val). the sum
#                            is stored in w.
#                            for example, if cfp$c is 5, and wa
#                            contains 32, then ctw wa,2
#                            gives a result of 9 in wa.
#
#      8.8  ctb  w,val       ctb is exactly like ctw except that
#                            the result is in bytes. it has the
#                            same effect as ctw w,val  wtb w
#
#           the following instructions provide for conversion
#           from integers to and from numeric digit characters
#           for use in numeric conversion routines. they employ
#           negative integer values to allow for proper
#           conversion of numbers which cannot be complemented.
#
#      8.9  cvm  plbl        convert by multiplication
#
#           the integer accumulator, which is zero or negative,
#           is multiplied by 10. wb contains the character
#           code for a digit. the value of this digit is then
#           subtracted from the result. if the result is out of
#           range, then control is passed to plbl with the
#           result in (ia) undefined. execution of cvm leaves
#           the result in (wb) undefined.
#
#      8.10 cvd              convert by division
#
#           the integer accumulator, which is zero or negative,
#           is divided by 10. the quotient (zero or negative)
#           is replaced in the accumulator. the remainder is
#           converted to the character code of a digit and
#           placed in wa. for example, an operand of -523 gives
#           a quotient of -52 and a remainder in wa of ch$d3.
                            #} ejc
        .eject
#
#      -9-  block move instructions
#
#      the following instructions are used for transferring
#      data from one area of memory to another in blocks.
#      they can be implemented with the indicated series of
#      other macro-instructions, but more efficient imple-
#      mentations will be possible on most machines.
#
#      note that in the equivalent code sequence shown below, a
#      zero value in wa will move at least one item, and may
#      may wrap the counter causing a core dump in some imple-
#      mentations.  thus wa should be .gt. 0 prior to invoking
#      any of these block move instructions.
#
#      9.1  mvc              move characters
#
#           before obeying this order wa,xl,xr should have been
#           set up, the latter two by plc, psc resp.
#           mvc is equivalent to the sequence
#
#                  mov  wb,dumpb
#                  lct  wa,wa
#           loopc  lch  wb,(xl)+
#                  sch  wb,(xr)+
#                  bct  wa,loopc
#                  csc  xr
#                  mov  dumpb,wb
#
#           the character pointers are bumped as indicated
#           and the final value of wa is undefined.
#
#
#      9.2  mvw              move words
#
#           mvw is equivalent to the sequence
#
#           loopw  mov  (xl)+,(xr)+
#                  dca  wa               wa = bytes to move
#                  bnz  wa,loopw
#
#           note that this implies that the value in wa is the
#           length in bytes which is a multiple of cfp$b.
#           the initial addresses in xr,xl are word addresses.
#           as indicated, the final xr,xl values point past the
#           new and old regions of memory respectively.
#           the final value of wa is undefined.
#           wa,xl,xr must be set up before obeying mvw.
#
#      9.3  mwb              move words backwards
#
#           mwb is equivalent to the sequence
#
#           loopb  mov  -(xl),-(xr)
#                  dca  wa               wa = bytes to move
#                  bnz  wa,loopb
#
#           there is a requirement that the initial value in xl
#           be at least 256 less than the value in xr. this
#           allows an implementation in which chunks of 256
#           bytes are moved forward (ibm 360, icl 1900).
#           the final value of wa is undefined.
#           wa,xl,xr must be set up before obeying mwb.
#
#      9.4  mcb              move characters backwards
#
#           mcb is equivalent to the sequence
#
#                  mov  wb,dumpb
#                  lct  wa,wa
#           loopc  lch  wb,-(xl)
#                  sch  wb,-(xr)
#                  bct  wa,loopc
#                  csc  xr
#                  mov  dumpb,wb
#
#           there is a requirement that the initial value in xl
#           be at least 256 less than the value in xr. this
#           allows an implementation in which chunks of 256
#           bytes are moved forward (ibm 360, icl 1900).
#           the final value of wa is undefined.
#           wa,xl,xr must be set up before obeying mcb.
                            #} ejc
        .eject
#
#      -10- operations connected with the stack
#
#      the stack is an area in memory which is dedicated for use
#      in conjunction with the stack pointer register (xs). as
#      previously described, it is used by the jsr and exi
#      instructions and may be used for storage of any other
#      data as required.
#
#      the stack builds either way in memory and an important
#      restriction is that the value in (xs) must be the address
#      of the stack front at all times since
#      some implementations may randomly destroy stack locations
#      beyond (xs).
#
#      the starting stack base address is passed
#      in (xs) at the start of execution. during execution it
#      is necessary to make sure that the stack does not
#      overflow. this is achieved by executing the following
#      instruction periodically.
#
#      10.1 chk              check stack overflow
#
#      after successfully executing chk, it is permissible to
#      use up to 100 additional words before issuing another chk
#      thus chk need not be issued every time the stack is
#      expanded. in some implementations, the checking may be
#      automatic and chk will have no effect. following the
#      above rule makes sure that the program will operate
#      correctly in implementations with no automatic check.
#
#      if stack overflow occurs (detected either automatically
#      or by a chk instruction), then control is passed to the
#      stack overflow section (see program form). note that this
#      transfer may take place following any instruction which
#      stores data at a new location on the stack.
#      after stack overflow, stack is arbitrarily popped
#      to give some space in which the error procedure may
#      operate. otherwise a loop of stack overflows may occur.
                            #} ejc
        .eject
#
#      -11- data generation instructions
#
#      the following instructions are used to generate constant
#      values in the constant section and also to assemble
#      initial values in the working storage section. they
#      may not appear except in these two sections.
#
#      11.1 dac  addr        assemble address constant.
#                            generates one word containing the
#                            specified one word integer
#                            value (address).
#
#      11.2 dic  integer     generates an integer value which
#                            occupies cfp$i consecutive words.
#                            the operand is a digit string with
#                            a required leading sign.
#
#      11.3 drc  real        assembles a real constant which
#                            occupies cfp$r consecutive words.
#                            the operand form must obey the
#                            rules for a fortran real constant
#                            with the extra requirement that a
#                            leading sign be present.
#
#      11.4 dtc  dtext       define text constant. dtext
#                            is started and ended with any
#                            character not contained in the
#                            characters to be assembled. the
#                            constant occupies consecutive words
#                            as dictated by the configuration
#                            parameter cfp$c. any unused chars
#                            in the last word are right filled
#                            with zeros (i.e. the character
#                            whose internal code is zero).
#                            the string contains a sequence of
#                            letters, digits, blanks and any of
#                            the following special characters.
#                            =,$.(*)/+-
#                            no other characters
#                            may be used in a dtext operand.
#
#      11.5 dbc  val         assemble bit string constant. the
#                            operand is a positive integer
#                            value which is interpreted in
#                            binary, right justified and left
#                            filled with zero bits. thus 5 would
#                            imply the bit string value 00...101.
                            #} ejc
        .eject
#
#      -12- symbol definition instructions
#
#      the following instruction is used to define symbols
#      in the definitions section. it may not be used elsewhere.
#
#      12.1 equ  eqop        define symbol
#
#           the symbol which appears in the label field is
#           defined to have the absolute value given
#           by the eqop operand. a given symbol may be defined
#           only once in this manner, and any symbols occuring
#           in eqop must be previously defined.
#
#           the following are the possibilities for eqop
#
#           val              the indicated value is used
#
#           val+val          the sum of the two values is used.
#                            this sum must not exceed cfp$m
#
#           val-val          the difference between the two
#                            values (must be positive) is used.
#
#           *                this format defines the label by
#                            using a value supplied by the
#                            minimal translator. values are
#                            required for the
#           cfp$x            (configuration parameters)
#           e$xxx            (environment parameters)
#           ch$xx            (character codes).
#                            in order for a translator to
#                            handle this format correctly the
#                            definitions section must be
#                            consulted for details of required
#                            symbols as listed at the front of
#                            the section.
                            #} ejc
        .eject
#
#      symbol definition instructions (continued)
#
#      the following instructions may be used to define symbols
#      in the procedure section. they may not be used in
#      any other part of the program.
#
#      12.2 exp              define external procedure
#
#           exp defines the symbol appearing in the label field
#           to be the name of an external procedure which can be
#           referenced in a subsequent jsr instruction. the
#           coding for the procedure is external to the
#           coding of the source program in this language.
#           the code for external procedures may be
#           referred to collectively as the operating system
#           interface, or more briefly, osint, and will
#           frequently be a separately compiled segment of code
#           loaded with spitbol to produce a complete system.
#
#      12.3 inp  ptyp,int    define internal procedure
#
#           inp defines the symbol appearing in the label field
#           to be the name of an internal procedure and gives
#           its type and number of exit parameters. the label
#           can be referenced in jsr instructions and
#           it must appear labelling a prc instruction in the
#           program section.
#
#      12.4 inr              define internal routine
#
#           inr defines the symbol appearing in the label
#           field to be the name of an internal routine. the
#           label may be referenced in any type of branch order
#           and it must appear labelling a rtn instruction in
#           the program section.
                            #} ejc
        .eject
#
#      -13- assembly listing layout instructions
#
#      13.1 ejc              eject to next page
#
#      13.2 ttl  text        set new assembly title
#
#           ttl implies an immediate eject of the
#           assembly listing to print the new title.
#
#           the use of ttl and ejc cards is such that the
#           program will list neatly if the printer prints
#           as many as 58 lines per page. in the event that
#           the printer depth is less than this, or if the
#           listing contains interspersed lines (such as actual
#           generated code), then the format may be upset.
#
#           lines starting with an asterisk are comment lines
#           which cause no code to be generated and may occur
#           freely anywhere in the program. the format for
#           comment lines is given in section -15-.
                            #} ejc
        .eject
#
#      -14- program form
#
#           the program consists of separate sections separated
#           by sec operations. the sections must appear in the
#           following specified order.
#
#      14.1 sec              start of procedure section
#
#           (procedure section)
#
#           sec               start of definitions section
#
#           (definitions section)
#
#           sec               start of constant storage section
#
#           (constant storage section)
#
#           sec               start of working storage section
#
#           (working storage section)
#
#           sec               start of program section
#
#           (program section)
#
#           sec               start of stack overflow section
#
#           (stack overflow section)
#
#           sec               start of error section
#
#           (error section)
#
#      14.2 end              end of assembly
                            #} ejc
        .eject
#
#      section 10 - program form
#
#      procedure section
#
#           the procedure section contains all the exp
#           instructions for externally available procedures
#           and inp,inr opcodes for internal procedures,routines
#           so that a single pass minimal translator has advance
#           knowledge of procedure types when translating calls.
#
#      definitions section
#
#           the definitions section contains equ instructions
#           which define symbols referenced later on in the
#           program, constant and work sections.
#
#      constant storage section
#
#           the constant storage section consists entirely
#           of constants assembled with the dac,dic,drc,dtc,dbc
#           assembly operations. these constants can be freely
#           referenced by the program instructions.
#
#      working storage section
#
#           the working storage section consists entirely of
#           dac,dic,drc,dbc,dtc instructions to define a fixed
#           length work area. the work locations in this area
#           can be directly referenced in program instructions.
#           the area is initialized in accordance with the
#           values assembled in the instructions.
#
#      program section
#
#           the program section contains program instructions
#           and associated operations (such as prc, enp, ent).
#           control is passed to the first instruction in this
#           section when execution is initiated.
#
#      stack overflow section
#
#           the stack overflow section contains instructions
#           like the program section. control is passed to the
#           first instruction in this section following the
#           occurrence of stack overflow, see chk instruction.
#
#      error section
#
#           the error section contains instructions like the
#           program section. control is passed to the first
#           instruction in this section when a procedure exit
#           corresponds to an error parameter (see err)
#           or when an erb opcode is obeyed. the error code
#           must clean up the main stack and cater for the
#           possibility that a subroutine stack may need clean
#           up.
                            #} ejc
        .eject
#      osint
#
#           though not part of the minimal source, it is useful
#           to refer to the collection of initialisation and
#           exp routines as osint (operating system interface).
#           errors occurring within osint procedures are
#           usually handled by making an error return. if this
#           is not feasible or appropriate, osint may use the
#           minimal error section to report errors directly by
#           branching to it with a suitable numeric error
#           code in wa.
                            #} ejc
        .eject
#
#      section 11 - statement format
#
#      all labels are exactly five characters long and start
#      with three letters (abcdefghijklmnopqrstuvwxy$) followed
#      by two letters or digits.
#      the letter z may not be used in minimal symbols but $ is
#      permitted.
#      for implementations where $ may not appear in the
#      target code , a simple substitution of z for $
#      may thus be made without risk of producing non-unique
#      symbols.
#      the letter z is however permitted in opcode mnemonics and
#      in comments.
#
#      minimal statements are in a fixed format as follows.
#
#      cols 1-5              label if any (else blank)
#
#      cols 6-7              always blank
#
#      cols 8-10             operation mnemonic
#
#      cols 11-12            blanks
#
#      cols 13-28            operand field, terminated by a
#                            blank. may occasionally
#                            extend past column 28.
#
#      cols 30-64            comment. always separated from the
#                            operand field by at least one blank
#                            may occasionally start after column
#                            30 if the operand extends past 28.
#                            a special exception occurs for the
#                            iff instruction, whose comment may
#                            be only 20 characters long (30-49).
#
#      cols 65 on            unused
#
#
#      comment lines have the following format
#
#      col 1                 asterisk
#
#      cols 2-7              blank
#
#      cols 8-64             arbitrary text, restricted to the
#                            fortran character set.
#
#
#      the fortran character set is a-z 0-9 =,$.(*)-/+
                            #} ejc
        .eject
#
#      section 12 - program execution
#
#      execution of the program begins with the first
#      instruction in the program section.
#
#      in addition to the fixed length memory regions defined
#      by the assembly, there are two dynamically allocated
#      memory regions as follows.
#
#      data area             this is an area available to the
#                            program for general storage of data
#                            any data value may be stored in
#                            this area except instructions.
#                            in some implementations, it may be
#                            possible to increase the size of
#                            this area dynamically by adding
#                            words at the top end with a call
#                            to a system procedure.
#
#      stack area            this region of memory holds
#                            the stack used for subroutine calls
#                            and other storage of one word
#                            integer values (addresses). this
#                            is the stack associated with
#                            index register xs.
#
#      the locations and sizes of these areas are specified
#      by the values in the registers at the start of program
#      execution as follows.
#
#      (xs)                  address one past the stack base.
#                            e.g. if xs is 23456, a d-stack will
#                            occupy words 23455,23454,...
#                            whereas a u-stack will occupy
#                            23457,23458,...
#
#      (xr)                  address of the first word
#                            in the data area
#
#      (xl)                  address of the last word in the
#                            data area.
#
#      (wa)                  initial stack pointer
#
#      (wb,wc,ia,ra,cp)      zero
#
#      there is no explicit way to terminate the execution of a
#      program. this function is performed by an appropriate
#      system procedure referenced with the sysej instruction.
                            #} ttl s p i t b o l  -- basic information
        .sbttl "s p i t b o l  -- basic information"
                            #} ejc
        .eject
#
#      general structure
#      -----------------
#
#      this program is a translator for a version of the snobol4
#      programming language. language details are contained in
#      the manual macro spitbol by dewar and mccann, technical
#      report 90, university of leeds 1976.
#      the implementation is discussed in dewar and mccann,
#      macro spitbol - a snobol4 compiler, software practice and
#      experience, 7, 95-113, 1977.
#      the language is as implemented by the btl translator
#      (griswold, poage and polonsky, prentice hall, 1971)
#      with the following principal exceptions.
#
#      1)   redefinition of standard system functions and
#           operators is not permitted.
#
#      2)   the value function is not provided.
#
#      3)   access tracing is provided in addition to the
#           other standard trace modes.
#
#      4)   the keyword stfcount is not provided.
#
#      5)   the keyword fullscan is not provided and all pattern
#           matching takes place in fullscan mode (i.e. with no
#           heuristics applied).
#
#      6)   a series of expressions separated by commas may
#           be grouped within parentheses to provide a selection
#           capability. the semantics are that the selection
#           assumes the value of the first expression within it
#           which succeeds as they are evaluated from the left.
#           if no expression succeeds the entire statement fails
#
#      7)   an explicit pattern matching operator is provided.
#           this is the binary query (see gimpel sigplan oct 74)
#
#      8)   the assignment operator is introduced as in the
#           gimpel reference.
#
#      9)   the exit function is provided for generating load
#           modules - cf. gimpels sitbol.
#
#
#      the method used in this program is to translate the
#      source code into an internal pseudo-code (see following
#      section). an interpretor is then used to execute this
#      generated pseudo-code. the nature of the snobol4 language
#      is such that the latter task is much more complex than
#      the actual translation phase. accordingly, nearly all the
#      code in the program section is concerned with the actual
#      execution of the snobol4 program.
                            #} ejc
        .eject
#
#      interpretive code format
#      ------------------------
#
#      the interpretive pseudo-code consists of a series of
#      address pointers. the exact format of the code is
#      described in connection with the cdblk format. the
#      purpose of this section is to give general insight into
#      the interpretive approach involved.
#
#      the basic form of the code is related to reverse polish.
#      in other words, the operands precede the operators which
#      are zero address operators. there are some exceptions to
#      these rules, notably the unary not operator and the
#      selection construction which clearly require advance
#      knowledge of the operator involved.
#
#      the operands are moved to the top of the main stack and
#      the operators are applied to the top stack entries. like
#      other versions of spitbol, this processor depends on
#      knowing whether operands are required by name or by value
#      and moves the appropriate object to the stack. thus no
#      name/value checks are included in the operator circuits.
#
#      the actual pointers in the code point to a block whose
#      first word is the address of the interpretor routine
#      to be executed for the code word.
#
#      in the case of operators, the pointer is to a word which
#      contains the address of the operator to be executed. in
#      the case of operands such as constants, the pointer is to
#      the operand itself. accordingly, all operands contain
#      a field which points to the routine to load the value of
#      the operand onto the stack. in the case of a variable,
#      there are three such pointers. one to load the value,
#      one to store the value and a third to jump to the label.
#
#      the handling of failure returns deserves special comment.
#      the location flptr contains the pointer to the location
#      on the main stack which contains the failure return
#      which is in the form of a byte offset in the current
#      code block (cdblk or exblk). when a failure occurs, the
#      stack is popped as indicated by the setting of flptr and
#      control is passed to the appropriate location in the
#      current code block with the stack pointer pointing to the
#      failure offset on the stack and flptr unchanged.
                            #} ejc
        .eject
#
#      internal data representations
#      -----------------------------
#
#      representation of values
#
#      a value is represented by a pointer to a block which
#      describes the type and particulars of the data value.
#      in general, a variable is a location containing such a
#      pointer (although in the case of trace associations this
#      is modified, see description of trblk).
#
#      the following is a list of possible datatypes showing the
#      type of block used to hold the value. the details of
#      each block format are given later.
#
#      datatype              block type
#      --------              ----------
#
#      array                 arblk or vcblk
#
#      code                  cdblk
#
#      expression            exblk or seblk
#
#      integer               icblk
#
#      name                  nmblk
#
#      pattern               p0blk or p1blk or p2blk
#
#      real                  rcblk
#
#      string                scblk
#
#      table                 tbblk
#
#      program datatype      pdblk
                            #} ejc
        .eject
#
#      representation of variables
#      ---------------------------
#
#      during the course of evaluating expressions, it is
#      necessary to generate names of variables (for example
#      on the left side of a binary equals operator). these are
#      not to be confused with objects of datatype name which
#      are in fact values.
#
#      from a logical point of view, such names could be simply
#      represented by a pointer to the appropriate value cell.
#      however in the case of arrays and program defined
#      datatypes, this would violate the rule that there must be
#      no pointers into the middle of a block in dynamic store.
#      accordingly, a name is always represented by a base and
#      offset. the base points to the start of the block
#      containing the variable value and the offset is the
#      offset within this block in bytes. thus the address
#      of the actual variable is determined by adding the base
#      and offset values.
#
#      the following are the instances of variables represented
#      in this manner.
#
#      1)   natural variable base is ptr to vrblk
#                            offset is *vrval
#
#      2)   table element    base is ptr to teblk
#                            offset is *teval
#
#      3)   array element    base is ptr to arblk
#                            offset is offset to element
#
#      4)   vector element   base is ptr to vcblk
#                            offset is offset to element
#
#      5)   prog def dtp     base is ptr to pdblk
#                            offset is offset to field value
#
#      in addition there are two cases of objects which are
#      like variables but cannot be handled in this manner.
#      these are called pseudo-variables and are represented
#      with a special base pointer as follows=
#
#      expression variable   ptr to evblk (see evblk)
#
#      keyword variable      ptr to kvblk (see kvblk)
#
#      pseudo-variables are handled as special cases by the
#      access procedure (acess) and the assignment procedure
#      (asign). see these two procedures for details.
                            #} ejc
        .eject
#
#      organization of data area
#      -------------------------
#
#      the data area is divided into two regions.
#
#      static area
#
#      the static area builds up from the bottom and contains
#      data areas which are allocated dynamically but are never
#      deleted or moved around. the macro-program itself
#      uses the static area for the following.
#
#      1)   all variable blocks (vrblk).
#
#      2)   the hash table for variable blocks.
#
#      3)   miscellaneous buffers and work areas (see program
#           initialization section).
#
#      in addition, the system procedures may use this area for
#      input/output buffers, external functions etc. space in
#      the static region is allocated by calling procedure alost
#
#      the following global variables define the current
#      location and size of the static area.
#
#      statb                 address of start of static area
#      state                 address+1 of last word in area.
#
#      the minimum size of static is given approximately by
#           12 + *e$hnb + *e$sts + space for alphabet string
#           and standard print buffer.
                            #} ejc
        .eject
#      dynamic area
#
#      the dynamic area is built upwards in memory after the
#      static region. data in this area must all be in standard
#      block formats so that it can be processed by the garbage
#      collector (procedure gbcol). gbcol compacts blocks down
#      in this region as required by space exhaustion and can
#      also move all blocks up to allow for expansion of the
#      static region.
#      with the exception of tables and arrays, no spitbol
#      object once built in dynamic memory is ever subsequently
#      modified. observing this rule necessitates a copying
#      action during string and pattern concatenation.
#
#      garbage collection is fundamental to the allocation of
#      space for values. spitbol uses a very efficient garbage
#      collector which insists that pointers into dynamic store
#      should be identifiable without use of bit tables,
#      marker bits etc. to satisfy this requirement, dynamic
#      memory must not start at too low an address and lengths
#      of arrays, tables, strings, code and expression blocks
#      may not exceed the numerical value of the lowest dynamic
#      address.
#
#      to avoid either penalizing users with modest
#      requirements or restricting those with greater needs on
#      host systems where dynamic memory is allocated in low
#      addresses, the minimum dynamic address may be specified
#      sufficiently high to permit arbitrarily large spitbol
#      objects to be created (with the possibility in extreme
#      cases of wasting large amounts of memory below the
#      start address). this minimum value is made available
#      in variable mxlen by a system routine, sysmx.
#      alternatively sysmx may indicate that a
#      default may be used in which dynamic is placed
#      at the lowest possible address following static.
#
#      the following global work cells define the location and
#      length of the dynamic area.
#
#      dnamb                 start of dynamic area
#      dnamp                 next available location
#      dname                 last available location + 1
#
#      dnamb is always higher than state since the alost
#      procedure maintains some expansion space above state.
#      *** dnamb must never be permitted to have a value less
#      than that in mxlen ***
#
#      space in the dynamic region is allocated by the alloc
#      procedure. the dynamic region may be used by system
#      procedures provided that all the rules are obeyed.
#      some of the rules are subtle so it is preferable for
#      osint to manage its own memory needs. spitbol procs
#      obey rules to ensure that no action can cause a garbage
#      collection except at such times as contents of xl, xr
#      and the stack are +clean+ (see comment before utility
#      procedures and in gbcol for more detail). note
#      that calls of alost may cause garbage collection (shift
#      of memory to free space). spitbol procs which call
#      system routines assume that they cannot precipitate
#      collection and this must be respected.
                            #} ejc
        .eject
#
#      register usage
#      --------------
#
#      (cp)                  code pointer register. used to
#                            hold a pointer to the current
#                            location in the interpretive pseudo
#                            code (i.e. ptr into a cdblk).
#
#      (xl,xr)               general index registers. usually
#                            used to hold pointers to blocks in
#                            dynamic storage. an important
#                            restriction is that the value in
#                            xl must be collectable for
#                            a garbage collect call. a value
#                            is collectable if it either points
#                            outside the dynamic area, or if it
#                            points to the start of a block in
#                            the dynamic area.
#
#      (xs)                  stack pointer. used to point to
#                            the stack front. the stack may
#                            build up or down and is used
#                            to stack subroutine return points
#                            and other recursively saved data.
#
#      (xt)                  an alternative name for xl during
#                            its use in accessing stacked items.
#
#      (wa,wb,wc)            general work registers. cannot be
#                            used for indexing, but may hold
#                            various types of data.
#
#      (ia)                  used for all signed integer
#                            arithmetic, both that used by the
#                            translator and that arising from
#                            use of snobol4 arithmetic operators
#
#      (ra)                  real accumulator. used for all
#                            floating point arithmetic.
                            #} ejc
        .eject
#
#      spitbol conditional assembly symbols
#      ------------------------------------
#
#      in the spitbol translator, the following conditional
#      assembly symbols are referred to. to incorporate the
#      features referred to, the minimal source should be
#      prefaced by suitable conditional assembly symbol
#      definitions.
#      in all cases it is permissible to default the definitions
#      in which case the additional features will be omitted
#      from the target code.
#
#      .caex                 define to allow up arrow for expon.
#      .caht                 define to include horizontal tab
#      .casl                 define to include 26 shifted lettrs
#      .cavt                 define to include vertical tab
#      .cbyt                 define for statistics in bytes
#      .ccmc                 define to include syscm function
#      .ccmk                 define to include compare keyword
#      .cepp                 define if entrys have odd parity
#      .cera                 define to include sysea function
#      .cexp                 define if spitbol pops sysex args
#      .cgbc                 define to include sysgc function
#      .cicc                 define to ignore bad control cards
#      .cinc                 define to add -include control card
#      .ciod                 define to not use default delimiter
#                              in processing 3rd arg of input()
#                              and output()
#      .cmth                 define to include math functions
#      .cnbf                 define to omit buffer extension
#      .cnbt                 define to omit batch initialisation
#      .cnci                 define to enable sysci routine
#      .cncr                 define to enable syscr routine
#      .cnex                 define to omit exit() code.
#      .cnld                 define to omit load() code.
#      .cnlf                 define to add file type for load()
#      .cnpf                 define to omit profile stuff
#      .cnra                 define to omit all real arithmetic
#      .cnsc                 define to no numeric-string compare
#      .cnsr                 define to omit sort, rsort
#      .cpol                 define if interface polling desired
#      .crel                 define to include reloc routines
#      .crpp                 define if returns have odd parity
#      .cs16                 define to initialize stlim to 32767
#      .cs32                 define to init stlim to 2147483647
#                            omit to take default of 50000
#      .csax                 define if sysax is to be called
#      .csed                 define to use sediment in gbcol
#      .csfn                 define to track source file names
#      .csln                 define if line number in code block
#      .csn5                 define to pad stmt nos to 5 chars
#      .csn6                 define to pad stmt nos to 6 chars
#      .csn8                 define to pad stmt nos to 8 chars
#      .csou                 define if output, terminal to sysou
#      .ctet                 define to table entry trace wanted
#      .ctmd                 define if systm unit is decisecond
#      .cucf                 define to include cfp$u
#      .cuej                 define to suppress needless ejects
#      .culk                 define to include &l/ucase keywords
#      .culc                 define to include &case (lc names)
#                            if cucl defined, must support
#                            minimal op flc wreg that folds
#                            argument to upper case
#      .cust                 define to include set() code
#
#                            conditional options
#                            since .undef not allowed if symbol
#                            not defined, a full comment line
#                            indicates symbol initially not
#                            defined.
#
#      .cbyt                 define for statistics in bytes
#      .ccmc                 define to include syscm function
#      .ccmk                 define to include compare keyword
#      .cepp                 define if entrys have odd parity
#      .cera                 define to include sysea function
#      .cexp                 define if spitbol pops sysex args
#      .cicc                 define to ignore bad control cards
#      .cinc                 define to add -include control card
#                            in processing 3rd arg of input()
#                            and output()
#      .cmth                 define to include math functions
#      .cnci                 define to enable sysci routine
#      .cncr                 define to enable syscr routine
#      .cnex                 define to omit exit() code.
#      .cnlf                 define to add file type to load()
#      .cnpf                 define to omit profile stuff
#      .cnra                 define to omit all real arithmetic
#      .cnsc                 define if no numeric-string compare
#      .cnsr                 define to omit sort, rsort
#      .cpol                 define if interface polling desired
#      .crel                 define to include reloc routines
#      .crpp                 define if returns have odd parity
#      .cs16                 define to initialize stlim to 32767
#      .cs32                 define to init stlim to 2147483647
#      .csed                 define to use sediment in gbcol
#      .csfn                 define to track source file names
#      .csln                 define if line number in code block
#      .csn5                 define to pad stmt nos to 5 chars
#      .csn6                 define to pad stmt nos to 6 chars
#      .csou                 define if output, terminal to sysou
#      .ctmd                 define if systm unit is decisecond
#
#      force definition of .ccmk if .ccmc is defined
#
                            #} ttl s p i t b o l -- procedures section
        .sbttl "s p i t b o l -- procedures section"
#
#      this section starts with descriptions of the operating
#      system dependent procedures which are used by the spitbol
#      translator. all such procedures have five letter names
#      beginning with sys. they are listed in alphabetical
#      order.
#      all procedures have a  specification consisting of a
#      model call, preceded by a possibly empty list of register
#      contents giving parameters available to the procedure and
#      followed by a possibly empty list of register contents
#      required on return from the call or which may have had
#      their contents destroyed. only those registers explicitly
#      mentioned in the list after the call may have their
#      values changed.
#      the segment of code providing the external procedures is
#      conveniently referred to as osint (operating system
#      interface). the sysxx procedures it contains provide
#      facilities not usually available as primitives in
#      assembly languages. for particular target machines,
#      implementors may choose for some minimal opcodes which
#      do not have reasonably direct translations, to use calls
#      of additional procedures which they provide in osint.
#      e.g. mwb or trc might be translated as jsr sysmb,
#      jsr systc in some implementations.
#
#      in the descriptions, reference is made to --blk
#      formats (-- = a pair of letters). see the spitbol
#      definitions section for detailed descriptions of all
#      such block formats except fcblk for which sysfc should
#      be consulted.
#
#      section 0 contains inp,inr specifications of internal
#      procedures,routines. this gives a single pass translator
#      information making it easy to generate alternative calls
#      in the translation of jsr-s for procedures of different
#      types if this proves necessary.
#
                            #start of procedures section} sec
        cseg_
        .global sec01
sec01:
                            #} ejc
        .eject
#
#      sysax -- after execution
#
        .extern sysax:near  #define external entry point} exp
#
#      if the conditional assembly symbol .csax is defined,
#      this routine is called immediately after execution and
#      before printing of execution statistics or dump output.
#      purpose of call is for implementor to determine and
#      if the call is not required it will be omitted if .csax
#      is undefined. in this case sysax need not be coded.
#
#      jsr  sysax            call after execution
                            #} ejc
        .eject
#
#      sysbs -- backspace file
#
        .extern sysbs:near  #define external entry point} exp
#
#      sysbs is used to implement the snobol4 function backspace
#      if the conditional assembly symbol .cbsp is defined.
#      the meaning is system dependent.  in general, backspace
#      repositions the file one record closer to the beginning
#      of file, such that a subsequent read or write will
#      operate on the previous record.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  backspace argument (scblk ptr)
#      jsr  sysbs            call to backspace
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if backspace not allowed
#      ppm  loc              return here if i/o error
#      (wa,wb)               destroyed
#
#      the second error return is used for files for which
#      backspace is not permitted. for example, it may be expected
#      files on character devices are in this category.
                            #} ejc
        .eject
#
#      sysbx -- before execution
#
        .extern sysbx:near  #define external entry point} exp
#
#      called after initial spitbol compilation and before
#      commencing execution in case osint needs
#      to assign files or perform other necessary services.
#      osint may also choose to send a message to online
#      terminal (if any) indicating that execution is starting.
#
#      jsr  sysbx            call before execution starts
                            #} ejc
        .eject
#
#      sysdc -- date check
#
        .extern sysdc:near  #define external entry point} exp
#
#      sysdc is called to check that the expiry date for a trial
#      version of spitbol is unexpired.
#
#      jsr  sysdc            call to check date
#      return only if date is ok
                            #} ejc
        .eject
#
#      sysdm  -- dump core
#
        .extern sysdm:near  #define external entry point} exp
#
#      sysdm is called by a spitbol program call of dump(n) with
#      n ge 4.  its purpose is to provide a core dump.
#      n could hold an encoding of the start adrs for dump and
#      amount to be dumped e.g.  n = 256*a + s , s = start adrs
#      in kilowords,  a = kilowords to dump
#
#      (xr)                  parameter n of call dump(n)
#      jsr  sysdm            call to enter routine
                            #} ejc
        .eject
#
#      sysdt -- get current date
#
        .extern sysdt:near  #define external entry point} exp
#
#      sysdt is used to obtain the current date. the date is
#      returned as a character string in any format appropriate
#      to the operating system in use. it may also contain the
#      current time of day. sysdt is used to implement the
#      snobol4 function date().
#
#      (xr)                  parameter n of call date(n)
#      jsr  sysdt            call to get date
#      (xl)                  pointer to block containing date
#
#      the format of the block is like an scblk except that
#      the first word need not be set. the result is copied
#      into spitbol dynamic memory on return.
                            #} ejc
        .eject
#
#      sysea -- inform osint of compilation and runtime errors
#
        .extern sysea:near  #define external entry point} exp
#
#      provides means for interface to take special actions on
#      errors
#
#      (wa)                  error code
#      (wb)                  line number
#      (wc)                  column number
#      (xr)                  system stage
#      (xl)                  file name (scblk)
#      jsr  sysea            call to sysea function
#      ppm  loc              suppress printing of error message
#      (xr)                  message to print (scblk) or 0
#
#      sysea may not return if interface chooses to retain
#      control.  closing files via the fcb chain will be the
#      responsibility of the interface.
#
#      all registers preserved
                            #} ejc
        .eject
#
#      sysef -- eject file
#
        .extern sysef:near  #define external entry point} exp
#
#      sysef is used to write a page eject to a named file. it
#      may only be used for files where this concept makes
#      sense. note that sysef is not normally used for the
#      standard output file (see sysep).
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  eject argument (scblk ptr)
#      jsr  sysef            call to eject file
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if inappropriate file
#      ppm  loc              return here if i/o error
                            #} ejc
        .eject
#
#      sysej -- end of job
#
        .extern sysej:near  #define external entry point} exp
#
#      sysej is called once at the end of execution to
#      terminate the run. the significance of the abend and
#      code values is system dependent. in general, the code
#      value should be made available for testing, and the
#      abend value should cause some post-mortem action such as
#      a dump. note that sysej does not return to its caller.
#      see sysxi for details of fcblk chain
#
#      (wa)                  value of abend keyword
#      (wb)                  value of code keyword
#      (xl)                  o or ptr to head of fcblk chain
#      jsr  sysej            call to end job
#
#      the following special values are used as codes in (wb)
#      999  execution suppressed
#      998  standard output file full or unavailable in a sysxi
#           load module. in these cases (wa) contains the number
#           of the statement causing premature termination.
                            #} ejc
        .eject
#
#      sysem -- get error message text
#
        .extern sysem:near  #define external entry point} exp
#
#      sysem is used to obtain the text of err, erb calls in the
#      source program given the error code number. it is allowed
#      to return a null string if this facility is unavailable.
#
#      (wa)                  error code number
#      jsr  sysem            call to get text
#      (xr)                  text of message
#
#      the returned value is a pointer to a block in scblk
#      format except that the first word need not be set. the
#      string is copied into dynamic memory on return.
#      if the null string is returned either because sysem does
#      not provide error message texts or because wa is out of
#      range, spitbol will print the string stored in errtext
#      keyword.
                            #} ejc
        .eject
#
#      sysen -- endfile
#
        .extern sysen:near  #define external entry point} exp
#
#      sysen is used to implement the snobol4 function endfile.
#      the meaning is system dependent. in general, endfile
#      implies that no further i/o operations will be performed,
#      but does not guarantee this to be the case. the file
#      should be closed after the call, a subsequent read
#      or write may reopen the file at the start or it may be
#      necessary to reopen the file via sysio.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  endfile argument (scblk ptr)
#      jsr  sysen            call to endfile
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if endfile not allowed
#      ppm  loc              return here if i/o error
#      (wa,wb)               destroyed
#
#      the second error return is used for files for which
#      endfile is not permitted. for example, it may be expected
#      that the standard input and output files are in this
#      category.
                            #} ejc
        .eject
#
#      sysep -- eject printer page
#
        .extern sysep:near  #define external entry point} exp
#
#      sysep is called to perform a page eject on the standard
#      printer output file (corresponding to syspr output).
#
#      jsr  sysep            call to eject printer output
                            #} ejc
        .eject
#
#      sysex -- call external function
#
        .extern sysex:near  #define external entry point} exp
#
#      sysex is called to pass control to an external function
#      previously loaded with a call to sysld.
#
#      (xs)                  pointer to arguments on stack
#      (xl)                  pointer to control block (efblk)
#      (wa)                  number of arguments on stack
#      jsr  sysex            call to pass control to function
#      ppm  loc              return here if function call fails
#      ppm  loc              return here if insufficient memory
#      ppm  loc              return here if bad argument type
#      (xr)                  result returned
#
#      the arguments are stored on the stack with
#      the last argument at 0(xs). on return, xs
#      is popped past the arguments.
#
#      the form of the arguments as passed is that used in the
#      spitbol translator (see definitions and data structures
#      section). the control block format is also described
#      (under efblk) in this section.
#
#      there are two ways of returning a result.
#
#      1)   return a pointer to a block in dynamic storage. this
#           block must be in exactly correct format, including
#           the first word. only functions written with intimate
#           knowledge of the system will return in this way.
#
#      2)   string, integer and real results may be returned by
#           pointing to a pseudo-block outside dynamic memory.
#           this block is in icblk, rcblk or scblk format except
#           that the first word will be overwritten
#           by a type word on return and so need not
#           be correctly set. such a result is
#           copied into main storage before proceeding.
#           unconverted results may similarly be returned in a
#           pseudo-block which is in correct format including
#           type word recognisable by garbage collector since
#           block is copied into dynamic memory.
                            #} ejc
        .eject
#
#      sysfc -- file control block routine
#
        .extern sysfc:near  #define external entry point} exp
#
#      see also sysio
#      input and output have 3 arguments referred to as shown
#           input(variable name,file arg1,file arg2)
#           output(variable name,file arg1,file arg2)
#      file arg1 may be an integer or string used to identify
#      an i/o channel. it is converted to a string for checking.
#      the exact significance of file arg2
#      is not rigorously prescribed but to improve portability,
#      the scheme described in the spitbol user manual
#      should be adopted when possible. the preferred form is
#      a string $f$,r$r$,c$c$,i$i$,...,z$z$  where
#      $f$ is an optional file name which is placed first.
#       remaining items may be omitted or included in any order.
#      $r$ is maximum record length
#      $c$ is a carriage control character or character string
#      $i$ is some form of channel identification used in the
#         absence of $f$ to associate the variable
#         with a file allocated dynamically by jcl commands at
#         spitbol load time.
#      ,...,z$z$ are additional fields.
#      if , (comma) cannot be used as a delimiter, .ciod
#      should be defined to introduce by conditional assembly
#      another delimiter (see
#        iodel  equ  *
#      early in definitions section).
#      sysfc is called when a variable is input or output
#      associated to check file arg1 and file arg2 and
#      to  report whether an fcblk (file control
#      block) is necessary and if so what size it should be.
#      this makes it possible for spitbol rather than osint to
#      allocate such a block in dynamic memory if required
#      or alternatively in static memory.
#      the significance of an fcblk , if one is requested, is
#      entirely up to the system interface. the only restriction
#      is that if the fcblk should appear to lie in dynamic
#      memory, pointers to it should be proper pointers to
#      the start of a recognisable and garbage collectable
#      block (this condition will be met if sysfc requests
#      spitbol to provide an fcblk).
#      an option is provided for osint to return a pointer in
#      xl to an fcblk which it privately allocated. this ptr
#      will be made available when i/o occurs later.
#      private fcblks may have arbitrary contents and spitbol
#      stores nothing in them.
                            #} ejc
        .eject
#      the requested size for an fcblk in dynamic memory
#      should allow a 2 word overhead for block type and
#      length fields. information subsequently stored in the
#      remaining words may be arbitrary if an xnblk (external
#      non-relocatable block) is requested. if the request is
#      for an xrblk (external relocatable block) the
#      contents of words should be collectable (i.e. any
#      apparent pointers into dynamic should be genuine block
#      pointers). these restrictions do not apply if an fcblk
#      is allocated outside dynamic or is not allocated at all.
#      if an fcblk is requested, its fields will be initialised
#      to zero before entry to sysio with the exception of
#      words 0 and 1 in which the block type and length
#      fields are placed for fcblks in dynamic memory only.
#      for the possible use of sysej and sysxi, if fcblks
#      are used, a chain is built so that they may all be
#      found - see sysxi for details.
#      if both file arg1 and file arg2 are null, calls of sysfc
#      and sysio are omitted.
#      if file arg1 is null (standard input/output file), sysfc
#      is called to check non-null file arg2 but any request
#      for an fcblk will be ignored, since spitbol handles the
#      standard files specially and cannot readily keep fcblk
#      pointers for them.
#      filearg1 is type checked by spitbol so further checking
#      may be unneccessary in many implementations.
#      file arg2 is passed so that sysfc may analyse and
#      check it. however to assist in this, spitbol also passes
#      on the stack the components of this argument with
#      file name, $f$ (otherwise null) extracted and stacked
#      first.
#      the other fields, if any, are extracted as substrings,
#      pointers to them are stacked and a count of all items
#      stacked is placed in wc. if an fcblk was earlier
#      allocated and pointed to via file arg1, sysfc is also
#      passed a pointer to this fcblk.
#
#      (xl)                  file arg1 scblk ptr (2nd arg)
#      (xr)                  filearg2 (3rd arg) or null
#      -(xs)...-(xs)         scblks for $f$,$r$,$c$,...
#      (wc)                  no. of stacked scblks above
#      (wa)                  existing file arg1 fcblk ptr or 0
#      (wb)                  0/3 for input/output assocn
#      jsr  sysfc            call to check need for fcblk
#      ppm  loc              invalid file argument
#      ppm  loc              fcblk already in use
#      (xs)                  popped (wc) times
#      (wa non zero)         byte size of requested fcblk
#      (wa=0,xl non zero)    private fcblk ptr in xl
#      (wa=xl=0)             no fcblk wanted, no private fcblk
#      (wc)                  0/1/2 request alloc of xrblk/xnblk
#                            /static block for use as fcblk
#      (wb)                  destroyed
                            #} ejc
        .eject
#
#      sysgc -- inform interface of garbage collections
#
        .extern sysgc:near  #define external entry point} exp
#
#      provides means for interface to take special actions
#      prior to and after a garbage collection.
#
#      possible usages-
#      1. provide visible screen icon of garbage collection
#         in progress
#      2. inform virtual memory manager to ignore page access
#         patterns during garbage collection.  such accesses
#         typically destroy the page working set accumulated
#         by the program.
#      3. inform virtual memory manager that contents of memory
#         freed by garbage collection can be discarded.
#
#      (xr)                  non-zero if beginning gc
#                            =0 if completing gc
#      (wa)                  dnamb=start of dynamic area
#      (wb)                  dnamp=next available location
#      (wc)                  dname=last available location + 1
#      jsr  sysgc            call to sysgc function
#      all registers preserved
                            #} ejc
        .eject
#
#      syshs -- give access to host computer features
#
        .extern syshs:near  #define external entry point} exp
#
#      provides means for implementing special features
#      on different host computers. the only defined entry is
#      that where all arguments are null in which case syshs
#      returns an scblk containing name of computer,
#      name of operating system and name of site separated by
#      colons. the scblk need not have a correct first field
#      as this is supplied on copying string to dynamic memory.
#      spitbol does no argument checking but does provide a
#      single error return for arguments checked as erroneous
#      by osint. it also provides a single execution error
#      return. if these are inadequate, use may be made of the
#      minimal error section direct as described in minimal
#      documentation, section 10.
#      several non-error returns are provided. the first
#      corresponds to the defined entry or, for implementation
#      defined entries, any string may be returned. the others
#      permit respectively,  return a null result, return with a
#      result to be stacked which is pointed at by xr, and a
#      return causing spitbol statement failure. if a returned
#      result is in dynamic memory it must obey garbage
#      collector rules. the only results copied on return
#      are strings returned via ppm loc3 return.
#
#      (wa)                  argument 1
#      (xl)                  argument 2
#      (xr)                  argument 3
#      (wb)                  argument 4
#      (wc)                  argument 5
#      jsr  syshs            call to get host information
#      ppm  loc1             erroneous arg
#      ppm  loc2             execution error
#      ppm  loc3             scblk ptr in xl or 0 if unavailable
#      ppm  loc4             return a null result
#      ppm  loc5             return result in xr
#      ppm  loc6             cause statement failure
#      ppm  loc7             return string at xl, length wa
#      ppm  loc8             return copy of result in xr
                            #} ejc
        .eject
#
#      sysid -- return system identification
#
        .extern sysid:near  #define external entry point} exp
#
#      this routine should return strings to head the standard
#      printer output. the first string will be appended to
#      a heading line of the form
#           macro spitbol version v.v
#      supplied by spitbol itself. v.v are digits giving the
#      major version number and generally at least a minor
#      version number relating to osint should be supplied to
#      give say
#           macro spitbol version v.v(m.m)
#      the second string should identify at least the machine
#      and operating system.  preferably it should include
#      the date and time of the run.
#      optionally the strings may include site name of the
#      the implementor and/or machine on which run takes place,
#      unique site or copy number and other information as
#      appropriate without making it so long as to be a
#      nuisance to users.
#      the first words of the scblks pointed at need not be
#      correctly set.
#
#      jsr  sysid            call for system identification
#      (xr)                  scblk ptr for addition to header
#      (xl)                  scblk ptr for second header
                            #} ejc
        .eject
#
#      sysif -- switch to new include file
#
        .extern sysif:near  #define external entry point} exp
#
#      sysif is used for include file processing, both to inform
#      the interface when a new include file is desired, and
#      when the end of file of an include file has been reached
#      and it is desired to return to reading from the previous
#      nested file.
#
#      it is the responsibility of sysif to remember the file
#      access path to the present input file before switching to
#      the new include file.
#
#      (xl)                  ptr to scblk or zero
#      (xr)                  ptr to vacant scblk of length cswin
#                            (xr not used if xl is zero)
#      jsr  sysif            call to change files
#      ppm  loc              unable to open file
#      (xr)                  scblk with full path name of file
#                            (xr not used if input xl is zero)
#
#      register xl points to an scblk containing the name of the
#      include file to which the interface should switch.  data
#      is fetched from the file upon the next call to sysrd.
#
#      sysif may have the ability to search multiple libraries
#      for the include file named in (xl).  it is therefore
#      required that the full path name of the file where the
#      file was finally located be returned in (xr).  it is this
#      name that is recorded along with the source statements,
#      and will accompany subsequent error messages.
#
#      register xl is zero to mark conclusion of use of an
#      include file.
                            #} ejc
        .eject
#
#      sysil -- get input record length
#
        .extern sysil:near  #define external entry point} exp
#
#      sysil is used to get the length of the next input record
#      from a file previously input associated with a sysio
#      call. the length returned is used to establish a buffer
#      for a subsequent sysin call.  sysil also indicates to the
#      caller if this is a binary or text file.
#
#      (wa)                  ptr to fcblk or zero
#      jsr  sysil            call to get record length
#      (wa)                  length or zero if file closed
#      (wc)                  zero if binary, non-zero if text
#
#      no harm is done if the value returned is too long since
#      unused space will be reclaimed after the sysin call.
#
#      note that it is the sysil call (not the sysio call) which
#      causes the file to be opened as required for the first
#      record input from the file.
                            #} ejc
        .eject
#
#      sysin -- read input record
#
        .extern sysin:near  #define external entry point} exp
#
#      sysin is used to read a record from the file which was
#      referenced in a prior call to sysil (i.e. these calls
#      always occur in pairs). the buffer provided is an
#      scblk for a string of length set from the sysil call.
#      if the actual length read is less than this, the length
#      field of the scblk must be modified before returning
#      unless buffer is right padded with zeroes.
#      it is also permissible to take any of the alternative
#      returns after scblk length has been modified.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  pointer to buffer (scblk ptr)
#      jsr  sysin            call to read record
#      ppm  loc              endfile or no i/p file after sysxi
#      ppm  loc              return here if i/o error
#      ppm  loc              return here if record format error
#      (wa,wb,wc)            destroyed
                            #} ejc
        .eject
#
#      sysio -- input/output file association
#
        .extern sysio:near  #define external entry point} exp
#
#      see also sysfc.
#      sysio is called in response to a snobol4 input or output
#      function call except when file arg1 and file arg2
#      are both null.
#      its call always follows immediately after a call
#      of sysfc. if sysfc requested allocation
#      of an fcblk, its address will be in wa.
#      for input files, non-zero values of $r$ should be
#      copied to wc for use in allocating input buffers. if $r$
#      is defaulted or not implemented, wc should be zeroised.
#      once a file has been opened, subsequent input(),output()
#      calls in which the second argument is identical with that
#      in a previous call, merely associate the additional
#      variable name (first argument) to the file and do not
#      result in re-opening the file.
#      in subsequent associated accesses to the file a pointer
#      to any fcblk allocated will be made available.
#
#      (xl)                  file arg1 scblk ptr (2nd arg)
#      (xr)                  file arg2 scblk ptr (3rd arg)
#      (wa)                  fcblk ptr (0 if none)
#      (wb)                  0 for input, 3 for output
#      jsr  sysio            call to associate file
#      ppm  loc              return here if file does not exist
#      ppm  loc              return if input/output not allowed
#      (xl)                  fcblk pointer (0 if none)
#      (wc)                  0 (for default) or max record lngth
#      (wa,wb)               destroyed
#
#      the second error return is used if the file named exists
#      but input/output from the file is not allowed. for
#      example, the standard output file may be in this category
#      as regards input association.
                            #} ejc
        .eject
#
#      sysld -- load external function
#
        .extern sysld:near  #define external entry point} exp
#
#      sysld is called in response to the use of the snobol4
#      load function. the named function is loaded (whatever
#      this means), and a pointer is returned. the pointer will
#      be used on subsequent calls to the function (see sysex).
#
#      (xr)                  pointer to function name (scblk)
#      (xl)                  pointer to library name (scblk)
#      jsr  sysld            call to load function
#      ppm  loc              return here if func does not exist
#      ppm  loc              return here if i/o error
#      ppm  loc              return here if insufficient memory
#      (xr)                  pointer to loaded code
#
#      the significance of the pointer returned is up to the
#      system interface routine. the only restriction is that
#      if the pointer is within dynamic storage, it must be
#      a proper block pointer.
                            #} ejc
        .eject
#
#      sysmm -- get more memory
#
        .extern sysmm:near  #define external entry point} exp
#
#      sysmm is called in an attempt to allocate more dynamic
#      memory. this memory must be allocated contiguously with
#      the current dynamic data area.
#
#      the amount allocated is up to the system to decide. any
#      value is acceptable including zero if allocation is
#      impossible.
#
#      jsr  sysmm            call to get more memory
#      (xr)                  number of additional words obtained
                            #} ejc
        .eject
#
#      sysmx -- supply mxlen
#
        .extern sysmx:near  #define external entry point} exp
#
#      because of the method of garbage collection, no spitbol
#      object is allowed to occupy more bytes of memory than
#      the integer giving the lowest address of dynamic
#      (garbage collectable) memory. mxlen is the name used to
#      refer to this maximum length of an object and for most
#      users of most implementations, provided dynamic memory
#      starts at an address of at least a few thousand words,
#      there is no problem.
#      if the default starting address is less than say 10000 or
#      20000, then a load time option should be provided where a
#      user can request that he be able to create larger
#      objects. this routine informs spitbol of this request if
#      any. the value returned is either an integer
#      representing the desired value of mxlen (and hence the
#      minimum dynamic store address which may result in
#      non-use of some store) or zero if a default is acceptable
#      in which mxlen is set to the lowest address allocated
#      to dynamic store before compilation starts.
#      if a non-zero value is returned, this is used for keyword
#      maxlngth. otherwise the initial low address of dynamic
#      memory is used for this keyword.
#
#      jsr  sysmx            call to get mxlen
#      (wa)                  either mxlen or 0 for default
                            #} ejc
        .eject
#
#      sysou -- output record
#
        .extern sysou:near  #define external entry point} exp
#
#      sysou is used to write a record to a file previously
#      associated with a sysio call.
#
#      (wa)                  ptr to fcblk
#                            or 0 for terminal or 1 for output
#      (xr)                  record to be written (scblk)
#      jsr  sysou            call to output record
#      ppm  loc              file full or no file after sysxi
#      ppm  loc              return here if i/o error
#      (wa,wb,wc)            destroyed
#
#      note that it is the sysou call (not the sysio call) which
#      causes the file to be opened as required for the first
#      record output to the file.
                            #} ejc
        .eject
#
#      syspi -- print on interactive channel
#
        .extern syspi:near  #define external entry point} exp
#
#      if spitbol is run from an online terminal, osint can
#      request that messages such as copies of compilation
#      errors be sent to the terminal (see syspp). if relevant
#      reply was made by syspp then syspi is called to send such
#      messages to the interactive channel.
#      syspi is also used for sending output to the terminal
#      through the special variable name, terminal.
#
#      (xr)                  ptr to line buffer (scblk)
#      (wa)                  line length
#      jsr  syspi            call to print line
#      ppm  loc              failure return
#      (wa,wb)               destroyed
                            #} ejc
        .eject
#
#      syspl -- provide interactive control of spitbol
#
        .extern syspl:near  #define external entry point} exp
#
#      provides means for interface to take special actions,
#      such as interrupting execution, breakpointing, stepping,
#      and expression evaluation.  these last three options are
#      not presently implemented by the code calling syspl.
#
#
#      (wa)                  opcode as follows-
#                            =0 poll to allow osint to interrupt
#                            =1 breakpoint hit
#                            =2 completion of statement stepping
#                            =3 expression evaluation result
#      (wb)                  statement number
#      r$fcb                 o or ptr to head of fcblk chain
#      jsr  syspl            call to syspl function
#      ppm  loc              user interruption
#      ppm  loc              step one statement
#      ppm  loc              evaluate expression
#      ---                   resume execution
#                            (wa) = new polling interval
#
                            #} ejc
        .eject
#
#      syspp -- obtain print parameters
#
        .extern syspp:near  #define external entry point} exp
#
#      syspp is called once during compilation to obtain
#      parameters required for correct printed output format
#      and to select other options. it may also be called again
#      after sysxi when a load module is resumed. in this
#      case the value returned in wa may be less than or equal
#      to that returned in initial call but may not be
#      greater.
#      the information returned is -
#      1.   line length in chars for standard print file
#      2.   no of lines/page. 0 is preferable for a non-paged
#           device (e.g. online terminal) in which case listing
#           page throws are suppressed and page headers
#           resulting from -title,-stitl lines are kept short.
#      3.   an initial -nolist option to suppress listing unless
#           the program contains an explicit -list.
#      4.   options to suppress listing of compilation and/or
#           execution stats (useful for established programs) -
#           combined with 3. gives possibility of listing
#           file never being opened.
#      5.   option to have copies of errors sent to an
#           interactive channel in addition to standard printer.
#      6.   option to keep page headers short (e.g. if listing
#           to an online terminal).
#      7.   an option to choose extended or compact listing
#           format. in the former a page eject and in the latter
#           a few line feeds precede the printing of each
#           of-- listing, compilation statistics, execution
#           output and execution statistics.
#      8.   an option to suppress execution as though a
#           -noexecute card were supplied.
#      9.   an option to request that name /terminal/  be pre-
#           associated to an online terminal via syspi and sysri
#      10.  an intermediate (standard) listing option requiring
#           that page ejects occur in source listings. redundant
#           if extended option chosen but partially extends
#           compact option.
#      11.  option to suppress sysid identification.
#
#      jsr  syspp            call to get print parameters
#      (wa)                  print line length in chars
#      (wb)                  number of lines/page
#      (wc)                  bits value ...mlkjihgfedcba where
#                            a = 1 to send error copy to int.ch.
#                            b = 1 means std printer is int. ch.
#                            c = 1 for -nolist option
#                            d = 1 to suppress compiln. stats
#
#                            e = 1 to suppress execn. stats
#                            f = 1/0 for extnded/compact listing
#                            g = 1 for -noexecute
#                            h = 1 pre-associate /terminal/
#
#                            i = 1 for standard listing option.
#                            j = 1 suppresses listing header
#                            k = 1 for -print
#                            l = 1 for -noerrors
#
#                            m = 1 for -case 1
                            #} ejc
        .eject
#
#      syspr -- print line on standard output file
#
        .extern syspr:near  #define external entry point} exp
#
#      syspr is used to print a single line on the standard
#      output file.
#
#      (xr)                  pointer to line buffer (scblk)
#      (wa)                  line length
#      jsr  syspr            call to print line
#      ppm  loc              too much o/p or no file after sysxi
#      (wa,wb)               destroyed
#
#      the buffer pointed to is the length obtained from the
#      syspp call and is filled out with trailing blanks. the
#      value in wa is the actual line length which may be less
#      than the maximum line length possible. there is no space
#      control associated with the line, all lines are printed
#      single spaced. note that null lines (wa=0) are possible
#      in which case a blank line is to be printed.
#
#      the error exit is used for systems which limit the amount
#      of printed output. if possible, printing should be
#      permitted after this condition has been signalled once to
#      allow for dump and other diagnostic information.
#      assuming this to be possible, spitbol may make more syspr
#      calls. if the error return occurs another time, execution
#      is terminated by a call of sysej with ending code 998.
                            #} ejc
        .eject
#
#      sysrd -- read record from standard input file
#
        .extern sysrd:near  #define external entry point} exp
#
#      sysrd is used to read a record from the standard input
#      file. the buffer provided is an scblk for a string the
#      length of which in characters is given in wc, this
#      corresponding to the maximum length of string which
#      spitbol is prepared to receive. at compile time it
#      corresponds to xxx in the most recent -inxxx card
#      (default 72) and at execution time to the most recent
#      ,r$r$ (record length) in the third arg of an input()
#      statement for the standard input file (default 80).
#      if fewer than (wc) characters are read, the length
#      field of the scblk must be adjusted before returning
#      unless the buffer is right padded with zeroes.
#      it is also permissible to take the alternative return
#      after such an adjustment has been made.
#      spitbol may continue to make calls after an endfile
#      return so this routine should be prepared to make
#      repeated endfile returns.
#
#      (xr)                  pointer to buffer (scblk ptr)
#      (wc)                  length of buffer in characters
#      jsr  sysrd            call to read line
#      ppm  loc              endfile or no i/p file after sysxi
#                            or input file name change.  if
#                            the former, scblk length is zero.
#                            if input file name change, length
#                            is non-zero. caller should re-issue
#                            sysrd to obtain input record.
#      (wa,wb,wc)            destroyed
                            #} ejc
        .eject
#
#      sysri -- read record from interactive channel
#
        .extern sysri:near  #define external entry point} exp
#
#      reads a record from online terminal for spitbol variable,
#      terminal. if online terminal is unavailable then code the
#      endfile return only.
#      the buffer provided is of length 258 characters. sysri
#      should replace the count in the second word of the scblk
#      by the actual character count unless buffer is right
#      padded with zeroes.
#      it is also permissible to take the alternative
#      return after adjusting the count.
#      the end of file return may be used if this makes
#      sense on the target machine (e.g. if there is an
#      eof character.)
#
#      (xr)                  ptr to 258 char buffer (scblk ptr)
#      jsr  sysri            call to read line from terminal
#      ppm  loc              end of file return
#      (wa,wb,wc)            may be destroyed
                            #} ejc
        .eject
#
#      sysrw -- rewind file
#
        .extern sysrw:near  #define external entry point} exp
#
#      sysrw is used to rewind a file i.e. reposition the file
#      at the start before the first record. the file should be
#      closed and the next read or write call will open the
#      file at the start.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  rewind arg (scblk ptr)
#      jsr  sysrw            call to rewind file
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if rewind not allowed
#      ppm  loc              return here if i/o error
                            #} ejc
        .eject
#
#      sysst -- set file pointer
#
        .extern sysst:near  #define external entry point} exp
#
#      sysst is called to change the position of a file
#      pointer. this is accomplished in a system dependent
#      manner, and thus the 2nd and 3rd arguments are passed
#      unconverted.
#
#      (wa)                  fcblk pointer
#      (wb)                  2nd argument
#      (wc)                  3rd argument
#      jsr  sysst            call to set file pointer
#      ppm  loc              return here if invalid 2nd arg
#      ppm  loc              return here if invalid 3rd arg
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if set not allowed
#      ppm  loc              return here if i/o error
#
                            #} ejc
        .eject
#
#      systm -- get execution time so far
#
        .extern systm:near  #define external entry point} exp
#
#      systm is used to obtain the amount of execution time
#      used so far since spitbol was given control. the units
#      are described as milliseconds in the spitbol output, but
#      the exact meaning is system dependent. where appropriate,
#      this value should relate to processor rather than clock
#      timing values.
#      if the symbol .ctmd is defined, the units are described
#      as deciseconds (0.1 second).
#
#      jsr  systm            call to get timer value
#      (ia)                  time so far in milliseconds
#                            (deciseconds if .ctmd defined)
                            #} ejc
        .eject
#
#      systt -- trace toggle
#
        .extern systt:near  #define external entry point} exp
#
#      called by spitbol function trace() with no args to
#      toggle the system trace switch.  this permits tracing of
#      labels in spitbol code to be turned on or off.
#
#      jsr  systt            call to toggle trace switch
                            #} ejc
        .eject
#
#      sysul -- unload external function
#
        .extern sysul:near  #define external entry point} exp
#
#      sysul is used to unload a function previously
#      loaded with a call to sysld.
#
#      (xr)                  ptr to control block (efblk)
#      jsr  sysul            call to unload function
#
#      the function cannot be called following a sysul call
#      until another sysld call is made for the same function.
#
#      the efblk contains the function code pointer and also a
#      pointer to the vrblk containing the function name (see
#      definitions and data structures section).
                            #} ejc
        .eject
#
#      sysxi -- exit to produce load module
#
        .extern sysxi:near  #define external entry point} exp
#
#      when sysxi is called, xl contains either a string pointer
#      or zero. in the former case, the string gives the
#      character name of a program. the intention is that
#      spitbol execution should be terminated forthwith and
#      the named program loaded and executed. this type of chain
#      execution is very system dependent and implementors may
#      choose to omit it or find it impossible to provide.
#      if (xl) is zero,ia contains one of the following integers
#
#      -1, -2, -3, -4
#           create if possible a load module containing only the
#           impure area of memory which needs to be loaded with
#           a compatible pure segment for subsequent executions.
#           version numbers to check compatibility should be
#           kept in both segments and checked on loading.
#           to assist with this check, (xr) on entry is a
#           pointer to an scblk containing the spitbol major
#           version number v.v (see sysid).  the file thus
#           created is called a save file.
#
#      0    if possible, return control to job control
#           command level. the effect if available will be
#           system dependent.
#
#      +1, +2, +3, +4
#           create if possible a load module from all of
#           memory. it should be possible to load and execute
#           this module directly.
#
#      in the case of saved load modules, the status of open
#      files is not preserved and implementors may choose to
#      offer means of attaching files before execution of load
#      modules starts or leave it to the user to include
#      suitable input(), output() calls in his program.
#      sysxi should make a note that no i/o channels,
#      including standard files, have files attached so that
#      calls of sysin, sysou, syspr, sysrd should fail unless
#      new associations are made for the load module.
#      at least in the case of the standard output file, it is
#      recommended that either the user be required to attach
#      a file or that a default file is attached, since the
#      problem of error messages generated by the load module
#      is otherwise severe. as a last resort, if spitbol
#      attempts to write to the standard output file and gets a
#      reply indicating that such ouput is unacceptable it stops
#      by using an entry to sysej with ending code 998.
#      as described below, passing of some arguments makes it
#      clear that load module will use a standard output file.
#
#      if use is made of fcblks for i/o association, spitbol
#      builds a chain so that those in use may be found in sysxi
#      and sysej. the nodes are 4 words long. third word
#      contains link to next node or 0, fourth word contains
#      fcblk pointer.
                            #} ejc
        .eject
#
#      sysxi (continued)
#
#      (xl)                  zero or scblk ptr to first argument
#      (xr)                  ptr to v.v scblk
#      (ia)                  signed integer argument
#      (wa)                  scblk ptr to second argument
#      (wb)                  0 or ptr to head of fcblk chain
#      jsr  sysxi            call to exit
#      ppm  loc              requested action not possible
#      ppm  loc              action caused irrecoverable error
#      (wb,wc,ia,xr,xl,cp)   should be preserved over call
#      (wa)                  0 in all cases except sucessful
#                            performance of exit(4) or exit(-4),
#                            in which case 1 should be returned.
#
#      loading and running the load module or returning from
#      jcl command level causes execution to resume at the point
#      after the error returns which follow the call of sysxi.
#      the value passed as exit argument is used to indicate
#      options required on resumption of load module.
#      +1 or -1 require that on resumption, sysid and syspp be
#      called and a heading printed on the standard output file.
#      +2 or -2 indicate that syspp will be called but not sysid
#      and no heading will be put on standard output file.
#      above options have the obvious implication that a
#      standard o/p file must be provided for the load module.
#      +3, +4, -3 or -4 indicate calls of neither sysid nor
#      syspp and no heading will be placed on standard output
#      file.
#      +4 or -4 indicate that execution is to continue after
#      creation of the save file or load module, although all
#      files will be closed by the sysxi action.  this permits
#      the user to checkpoint long-running programs while
#      continuing execution.
#
#      no return from sysxi is possible if another program
#      is loaded and entered.
                            #} ejc
        .eject
#
#      introduce the internal procedures.
#
                            #} ejc
        .eject
                            #} ejc
        .eject
#
#      introduce the internal routines
#
                            #} ttl s p i t b o l -- definitions and data structures
        .sbttl "s p i t b o l -- definitions and data structures"
#      this section contains all symbol definitions and also
#      pictures of all data structures used in the system.
#
                            #start of definitions section} sec
        csegend_
        dseg_
        .global sec02
sec02:
#
#      definitions of machine parameters
#
#      the minimal translator should supply appropriate values
#      for the particular target machine for all the
#      equ  *
#      definitions given at the start of this section.
#      note that even if conditional assembly is used to omit
#      some feature (e.g. real arithmetic) a full set of cfp$-
#      values must be supplied. use dummy values if genuine
#      ones are not needed.
#
cfp_a   =    256            #number of characters in alphabet} equ 256
#
cfp_b   =    4              #bytes/word addressing factor} equ 4
#
cfp_c   =    4              #number of characters per word} equ 4
#
cfp_f   =    8              #offset in bytes to chars in} equ 8
#                            scblk. see scblk format.
#
cfp_i   =    1              #number of words in integer constant} equ 1
#
cfp_m   =    2147483647     #max positive integer in one word} equ 2147483647
#
cfp_n   =    32             #number of bits in one word} equ 32
#
#      the following definitions require the supply of either
#      a single parameter if real arithmetic is omitted or
#      three parameters if real arithmetic is included.
#
#
cfp_r   =    2              #number of words in real constant} equ 2
#
cfp_s   =    9              #number of sig digs for real output} equ 9
#
cfp_x   =    3              #max digits in real exponent} equ 3
#
mxdgs   =    cfp_s+cfp_x    #max digits in real number} equ cfp_s+cfp_x
#
#
#      max space for real (for +0.e+) needs five more places
#
nstmx   =    mxdgs+5        #max space for real} equ mxdgs+5
#
#      the following definition for cfp$u supplies a realistic
#      upper bound on the size of the alphabet.  cfp$u is used
#      to save space in the scane bsw-iff-esw table and to ease
#      translation storage requirements.
#
cfp_u   =    128            #realistic upper bound on alphabet} equ 128
                            #} ejc
        .eject
#
#      environment parameters
#
#      the spitbol program is essentially independent of
#      the definitions of these parameters. however, the
#      efficiency of the system may be affected. consequently,
#      these parameters may require tuning for a given version
#      the values given in comments have been successfully used.
#
#      e$srs is the number of words to reserve at the end of
#      storage for end of run processing. it should be
#      set as small as possible without causing memory overflow
#      in critical situations (e.g. memory overflow termination)
#      and should thus reserve sufficient space at least for
#      an scblk containing say 30 characters.
#
e_srs   =    100            #30 words} equ 100
#
#      e$sts is the number of words grabbed in a chunk when
#      storage is allocated in the static region. the minimum
#      permitted value is 256/cfp$b. larger values will lead
#      to increased efficiency at the cost of wasting memory.
#
e_sts   =    1000           #500 words} equ 1000
#
#      e$cbs is the size of code block allocated initially and
#      the expansion increment if overflow occurs. if this value
#      is too small or too large, excessive garbage collections
#      will occur during compilation and memory may be lost
#      in the case of a too large value.
#
e_cbs   =    500            #500 words} equ 500
#
#      e$hnb is the number of bucket headers in the variable
#      hash table. it should always be odd. larger values will
#      speed up compilation and indirect references at the
#      expense of additional storage for the hash table itself.
#
e_hnb   =    257            #127 bucket headers} equ 257
#
#      e$hnw is the maximum number of words of a string
#      name which participate in the string hash algorithm.
#      larger values give a better hash at the expense of taking
#      longer to compute the hash. there is some optimal value.
#
e_hnw   =    6              #6 words} equ 6
#
#      e$fsp.  if the amount of free space left after a garbage
#      collection is small compared to the total amount of space
#      in use garbage collector thrashing is likely to occur as
#      this space is used up.  e$fsp is a measure of the
#      minimum percentage of dynamic memory left as free space
#      before the system routine sysmm is called to try to
#      obtain more memory.
#
e_fsp   =    15             #15 percent} equ 15
#
#      e$sed.  if the amount of free space left in the sediment
#      after a garbage collection is a significant fraction of
#      the new sediment size, the sediment is marked for
#      collection on the next call to the garbage collector.
#
e_sed   =    25             #25 percent} equ 25
                            #} ejc
        .eject
#
#      definitions of codes for letters
#
ch_la   =    65             #letter a} equ 65
ch_lb   =    66             #letter b} equ 66
ch_lc   =    67             #letter c} equ 67
ch_ld   =    68             #letter d} equ 68
ch_le   =    69             #letter e} equ 69
ch_lf   =    70             #letter f} equ 70
ch_lg   =    71             #letter g} equ 71
ch_lh   =    72             #letter h} equ 72
ch_li   =    73             #letter i} equ 73
ch_lj   =    74             #letter j} equ 74
ch_lk   =    75             #letter k} equ 75
ch_ll   =    76             #letter l} equ 76
ch_lm   =    77             #letter m} equ 77
ch_ln   =    78             #letter n} equ 78
ch_lo   =    79             #letter o} equ 79
ch_lp   =    80             #letter p} equ 80
ch_lq   =    81             #letter q} equ 81
ch_lr   =    82             #letter r} equ 82
ch_ls   =    83             #letter s} equ 83
ch_lt   =    84             #letter t} equ 84
ch_lu   =    85             #letter u} equ 85
ch_lv   =    86             #letter v} equ 86
ch_lw   =    87             #letter w} equ 87
ch_lx   =    88             #letter x} equ 88
ch_ly   =    89             #letter y} equ 89
ch_l_   =    90             #letter z} equ 90
#
#      definitions of codes for digits
#
ch_d0   =    48             #digit 0} equ 48
ch_d1   =    49             #digit 1} equ 49
ch_d2   =    50             #digit 2} equ 50
ch_d3   =    51             #digit 3} equ 51
ch_d4   =    52             #digit 4} equ 52
ch_d5   =    53             #digit 5} equ 53
ch_d6   =    54             #digit 6} equ 54
ch_d7   =    55             #digit 7} equ 55
ch_d8   =    56             #digit 8} equ 56
ch_d9   =    57             #digit 9} equ 57
                            #} ejc
        .eject
#
#      definitions of codes for special characters
#
#      the names of these characters are related to their
#      original representation in the ebcdic set corresponding
#      to the description in standard snobol4 manuals and texts.
#
ch_am   =    38             #keyword operator (ampersand)} equ 38
ch_as   =    42             #multiplication symbol (asterisk)} equ 42
ch_at   =    64             #cursor position operator (at)} equ 64
ch_bb   =    60             #left array bracket (less than)} equ 60
ch_bl   =    32             #blank} equ 32
ch_br   =    124            #alternation operator (vertical bar)} equ 124
ch_cl   =    58             #goto symbol (colon)} equ 58
ch_cm   =    44             #comma} equ 44
ch_dl   =    36             #indirection operator (dollar)} equ 36
ch_dt   =    46             #name operator (dot)} equ 46
ch_dq   =    34             #double quote} equ 34
ch_eq   =    61             #equal sign} equ 61
ch_ex   =    33             #exponentiation operator (exclm)} equ 33
ch_mn   =    45             #minus sign / hyphen} equ 45
ch_nm   =    35             #number sign} equ 35
ch_nt   =    126            #negation operator (not)} equ 126
ch_pc   =    37             #percent} equ 37
ch_pl   =    43             #plus sign} equ 43
ch_pp   =    40             #left parenthesis} equ 40
ch_rb   =    62             #right array bracket (grtr than)} equ 62
ch_rp   =    41             #right parenthesis} equ 41
ch_qu   =    63             #interrogation operator (question)} equ 63
ch_sl   =    47             #slash} equ 47
ch_sm   =    59             #semicolon} equ 59
ch_sq   =    39             #single quote} equ 39
ch_un   =    95             #special identifier char (underline)} equ 95
ch_ob   =    91             #opening bracket} equ 91
ch_cb   =    93             #closing bracket} equ 93
                            #} ejc
        .eject
#
#      remaining chars are optional additions to the standards.
#
#      tab characters - syntactically equivalent to blank
#
ch_ht   =    9              #horizontal tab} equ 9
#
#      up arrow same as exclamation mark for exponentiation
#
ch_ey   =    94             #up arrow} equ 94
#
#      lower case or shifted case alphabetic chars
#
ch__a   =    97             #shifted a} equ 97
ch__b   =    98             #shifted b} equ 98
ch__c   =    99             #shifted c} equ 99
ch__d   =    100            #shifted d} equ 100
ch__e   =    101            #shifted e} equ 101
ch__f   =    102            #shifted f} equ 102
ch__g   =    103            #shifted g} equ 103
ch__h   =    104            #shifted h} equ 104
ch__i   =    105            #shifted i} equ 105
ch__j   =    106            #shifted j} equ 106
ch__k   =    107            #shifted k} equ 107
ch__l   =    108            #shifted l} equ 108
ch__m   =    109            #shifted m} equ 109
ch__n   =    110            #shifted n} equ 110
ch__o   =    111            #shifted o} equ 111
ch__p   =    112            #shifted p} equ 112
ch__q   =    113            #shifted q} equ 113
ch__r   =    114            #shifted r} equ 114
ch__s   =    115            #shifted s} equ 115
ch__t   =    116            #shifted t} equ 116
ch__u   =    117            #shifted u} equ 117
ch__v   =    118            #shifted v} equ 118
ch__w   =    119            #shifted w} equ 119
ch__x   =    120            #shifted x} equ 120
ch__y   =    121            #shifted y} equ 121
ch___   =    122            #shifted z} equ 122
#      if a delimiter other than ch$cm must be used in
#      the third argument of input(),output() then .ciod should
#      be defined and a parameter supplied for iodel.
#
iodel   =    32             #} equ 32
                            #} ejc
        .eject
#
#      data block formats and definitions
#
#      the following sections describe the detailed format of
#      all possible data blocks in static and dynamic memory.
#
#      every block has a name of the form xxblk where xx is a
#      unique two character identifier. the first word of every
#      block must contain a pointer to a program location in the
#      interpretor which is immediately preceded by an address
#      constant containing the value bl$xx where xx is the block
#      identifier. this provides a uniform mechanism for
#      distinguishing between the various block types.
#
#      in some cases, the contents of the first word is constant
#      for a given block type and merely serves as a pointer
#      to the identifying address constant. however, in other
#      cases there are several possibilities for the first
#      word in which case each of the several program entry
#      points must be preceded by the appropriate constant.
#
#      in each block, some of the fields are relocatable. this
#      means that they may contain a pointer to another block
#      in the dynamic area. (to be more precise, if they contain
#      a pointer within the dynamic area, then it is a pointer
#      to a block). such fields must be modified by the garbage
#      collector (procedure gbcol) whenever blocks are compacted
#      in the dynamic region. the garbage collector (actually
#      procedure gbcpf) requires that all such relocatable
#      fields in a block must be contiguous.
                            #} ejc
        .eject
#
#      the description format uses the following scheme.
#
#      1)   block title and two character identifier
#
#      2)   description of basic use of block and indication
#           of circumstances under which it is constructed.
#
#      3)   picture of the block format. in these pictures low
#           memory addresses are at the top of the page. fixed
#           length fields are surrounded by i (letter i). fields
#           which are fixed length but whose length is dependent
#           on a configuration parameter are surrounded by *
#           (asterisk). variable length fields are surrounded
#           by / (slash).
#
#      4)   definition of symbolic offsets to fields in
#           block and of the size of the block if fixed length
#           or of the size of the fixed length fields if the
#           block is variable length.
#           note that some routines such as gbcpf assume
#           certain offsets are equal. the definitions
#           given here enforce this.  make changes to
#           them only with due care.
#
#      definitions of common offsets
#
offs1   =    1              #} equ 1
offs2   =    2              #} equ 2
offs3   =    3              #} equ 3
#
#      5)   detailed comments on the significance and formats
#           of the various fields.
#
#      the order is alphabetical by identification code.
                            #} ejc
        .eject
#
#      definitions of block codes
#
#      this table provides a unique identification code for
#      each separate block type. the first word of a block in
#      the dynamic area always contains the address of a program
#      entry point. the block code is used as the entry point id
#      the order of these codes dictates the order of the table
#      used by the datatype function (scnmt in the constant sec)
#
#      block codes for accessible datatypes
#
#      note that real and buffer types are always included, even
#      if they are conditionally excluded elsewhere.  this main-
#      tains block type codes across all versions of spitbol,
#      providing consistancy for external functions.  but note
#      that the bcblk is out of alphabetic order, placed at the
#      end of the list so as not to change the block type
#      ordering in use in existing external functions.
#
bl_ar   =    0              #arblk     array} equ 0
bl_cd   =    bl_ar+1        #cdblk     code} equ bl_ar+1
bl_ex   =    bl_cd+1        #exblk     expression} equ bl_cd+1
bl_ic   =    bl_ex+1        #icblk     integer} equ bl_ex+1
bl_nm   =    bl_ic+1        #nmblk     name} equ bl_ic+1
bl_p0   =    bl_nm+1        #p0blk     pattern} equ bl_nm+1
bl_p1   =    bl_p0+1        #p1blk     pattern} equ bl_p0+1
bl_p2   =    bl_p1+1        #p2blk     pattern} equ bl_p1+1
bl_rc   =    bl_p2+1        #rcblk     real} equ bl_p2+1
bl_sc   =    bl_rc+1        #scblk     string} equ bl_rc+1
bl_se   =    bl_sc+1        #seblk     expression} equ bl_sc+1
bl_tb   =    bl_se+1        #tbblk     table} equ bl_se+1
bl_vc   =    bl_tb+1        #vcblk     array} equ bl_tb+1
bl_xn   =    bl_vc+1        #xnblk     external} equ bl_vc+1
bl_xr   =    bl_xn+1        #xrblk     external} equ bl_xn+1
bl_bc   =    bl_xr+1        #bcblk     buffer} equ bl_xr+1
bl_pd   =    bl_bc+1        #pdblk     program defined datatype} equ bl_bc+1
#
bl__d   =    bl_pd+1        #number of block codes for data} equ bl_pd+1
#
#      other block codes
#
bl_tr   =    bl_pd+1        #trblk} equ bl_pd+1
bl_bf   =    bl_tr+1        #bfblk} equ bl_tr+1
bl_cc   =    bl_bf+1        #ccblk} equ bl_bf+1
bl_cm   =    bl_cc+1        #cmblk} equ bl_cc+1
bl_ct   =    bl_cm+1        #ctblk} equ bl_cm+1
bl_df   =    bl_ct+1        #dfblk} equ bl_ct+1
bl_ef   =    bl_df+1        #efblk} equ bl_df+1
bl_ev   =    bl_ef+1        #evblk} equ bl_ef+1
bl_ff   =    bl_ev+1        #ffblk} equ bl_ev+1
bl_kv   =    bl_ff+1        #kvblk} equ bl_ff+1
bl_pf   =    bl_kv+1        #pfblk} equ bl_kv+1
bl_te   =    bl_pf+1        #teblk} equ bl_pf+1
#
bl__i   =    0              #default identification code} equ 0
bl__t   =    bl_tr+1        #code for data or trace block} equ bl_tr+1
bl___   =    bl_te+1        #number of block codes} equ bl_te+1
                            #} ejc
        .eject
#
#      field references
#
#      references to the fields of data blocks are symbolic
#      (i.e. use the symbolic offsets) with the following
#      exceptions.
#
#      1)   references to the first word are usually not
#           symbolic since they use the (x) operand format.
#
#      2)   the code which constructs a block is often not
#           symbolic and should be changed if the corresponding
#           block format is modified.
#
#      3)   the plc and psc instructions imply an offset
#           corresponding to the definition of cfp$f.
#
#      4)   there are non-symbolic references (easily changed)
#           in the garbage collector (procedures gbcpf, blkln).
#
#      5)   the fields idval, fargs appear in several blocks
#           and any changes must be made in parallel to all
#           blocks containing the fields. the actual references
#           to these fields are symbolic with the above
#           listed exceptions.
#
#      6)   several spots in the code assume that the
#           definitions of the fields vrval, teval, trnxt are
#           the same (these are sections of code which search
#           out along a trblk chain from a variable).
#
#      7)   references to the fields of an array block in the
#           array reference routine arref are non-symbolic.
#
#      apart from the exceptions listed, references are symbolic
#      as far as possible and modifying the order or number
#      of fields will not require changes.
                            #} ejc
        .eject
#
#      common fields for function blocks
#
#      blocks which represent callable functions have two
#      common fields at the start of the block as follows.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           /                                    /
#           /       rest of function block       /
#           /                                    /
#           +------------------------------------+
#
fcode   =    0              #pointer to code for function} equ 0
fargs   =    1              #number of arguments} equ 1
#
#      fcode is a pointer to the location in the interpretor
#      program which processes this type of function call.
#
#      fargs is the expected number of arguments. the actual
#      number of arguments is adjusted to this amount by
#      deleting extra arguments or supplying trailing nulls
#      for missing ones before transferring though fcode.
#      a value of 999 may be used in this field to indicate a
#      variable number of arguments (see svblk field svnar).
#
#      the block types which follow this scheme are.
#
#      ffblk                 field function
#      dfblk                 datatype function
#      pfblk                 program defined function
#      efblk                 external loaded function
                            #} ejc
        .eject
#
#      identification field
#
#
#      id   field
#
#      certain program accessible objects (those which contain
#      other data values and can be copied) are given a unique
#      identification number (see exsid). this id value is an
#      address integer value which is always stored in word two.
#
idval   =    1              #id value field} equ 1
#
#      the blocks containing an idval field are.
#
#      arblk                 array
#      pdblk                 program defined datatype
#      tbblk                 table
#      vcblk                 vector block (array)
#
#      note that a zero idval means that the block is only
#      half built and should not be dumped (see dumpr).
                            #} ejc
        .eject
#
#      array block (arblk)
#
#      an array block represents an array value other than one
#      with one dimension whose lower bound is one (see vcblk).
#      an arblk is built with a call to the functions convert
#      (s$cnv) or array (s$arr).
#
#           +------------------------------------+
#           i                artyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                arlen               i
#           +------------------------------------+
#           i                arofs               i
#           +------------------------------------+
#           i                arndm               i
#           +------------------------------------+
#           *                arlbd               *
#           +------------------------------------+
#           *                ardim               *
#           +------------------------------------+
#           *                                    *
#           * above 2 flds repeated for each dim *
#           *                                    *
#           +------------------------------------+
#           i                arpro               i
#           +------------------------------------+
#           /                                    /
#           /                arvls               /
#           /                                    /
#           +------------------------------------+
                            #} ejc
        .eject
#
#      array block (continued)
#
artyp   =    0              #pointer to dummy routine b_art} equ 0
arlen   =    idval+1        #length of arblk in bytes} equ idval+1
arofs   =    arlen+1        #offset in arblk to arpro field} equ arlen+1
arndm   =    arofs+1        #number of dimensions} equ arofs+1
arlbd   =    arndm+1        #low bound (first subscript)} equ arndm+1
ardim   =    arlbd+cfp_i    #dimension (first subscript)} equ arlbd+cfp_i
arlb2   =    ardim+cfp_i    #low bound (second subscript)} equ ardim+cfp_i
ardm2   =    arlb2+cfp_i    #dimension (second subscript)} equ arlb2+cfp_i
arpro   =    ardim+cfp_i    #array prototype (one dimension)} equ ardim+cfp_i
arvls   =    arpro+1        #start of values (one dimension)} equ arpro+1
arpr2   =    ardm2+cfp_i    #array prototype (two dimensions)} equ ardm2+cfp_i
arvl2   =    arpr2+1        #start of values (two dimensions)} equ arpr2+1
arsi_   =    arlbd          #number of standard fields in block} equ arlbd
ardms   =    arlb2-arlbd    #size of info for one set of bounds} equ arlb2-arlbd
#
#      the bounds and dimension fields are signed integer
#      values and each occupy cfp$i words in the arblk.
#
#      the length of an arblk in bytes may not exceed mxlen.
#      this is required to keep name offsets garbage collectable
#
#      the actual values are arranged in row-wise order and
#      can contain a data pointer or a pointer to a trblk.
                            #} ejc
        .eject
#
#      code construction block (ccblk)
#
#      at any one moment there is at most one ccblk into
#      which the compiler is currently storing code (cdwrd).
#
#           +------------------------------------+
#           i                cctyp               i
#           +------------------------------------+
#           i                cclen               i
#           +------------------------------------+
#           i                ccsln               i
#           +------------------------------------+
#           i                ccuse               i
#           +------------------------------------+
#           /                                    /
#           /                cccod               /
#           /                                    /
#           +------------------------------------+
#
cctyp   =    0              #pointer to dummy routine b_cct} equ 0
cclen   =    cctyp+1        #length of ccblk in bytes} equ cctyp+1
ccsln   =    cclen+1        #source line number} equ cclen+1
ccuse   =    ccsln+1        #offset past last used word (bytes)} equ ccsln+1
cccod   =    ccuse+1        #start of generated code in block} equ ccuse+1
#
#      the reason that the ccblk is a separate block type from
#      the usual cdblk is that the garbage collector must
#      only process those fields which have been set (see gbcpf)
                            #} ejc
        .eject
#
#      code block (cdblk)
#
#      a code block is built for each statement compiled during
#      the initial compilation or by subsequent calls to code.
#
#           +------------------------------------+
#           i                cdjmp               i
#           +------------------------------------+
#           i                cdstm               i
#           +------------------------------------+
#           i                cdsln               i
#           +------------------------------------+
#           i                cdlen               i
#           +------------------------------------+
#           i                cdfal               i
#           +------------------------------------+
#           /                                    /
#           /                cdcod               /
#           /                                    /
#           +------------------------------------+
#
cdjmp   =    0              #ptr to routine to execute statement} equ 0
cdstm   =    cdjmp+1        #statement number} equ cdjmp+1
cdsln   =    cdstm+1        #source line number} equ cdstm+1
cdlen   =    cdsln+1        #length of cdblk in bytes} equ cdsln+1
cdfal   =    cdlen+1        #failure exit (see below)} equ cdlen+1
cdcod   =    cdfal+1        #executable pseudo-code} equ cdfal+1
cdsi_   =    cdcod          #number of standard fields in cdblk} equ cdcod
#
#      cdstm is the statement number of the current statement.
#
#      cdjmp, cdfal are set as follows.
#
#      1)   if the failure exit is the next statement
#
#           cdjmp = b$cds
#           cdfal = ptr to cdblk for next statement
#
#      2)   if the failure exit is a simple label name
#
#           cdjmp = b$cds
#           cdfal is a ptr to the vrtra field of the vrblk
#
#      3)   if there is no failure exit (-nofail mode)
#
#           cdjmp = b$cds
#           cdfal = o$unf
#
#      4)   if the failure exit is complex or direct
#
#           cdjmp = b$cdc
#           cdfal is the offset to the o$gof word
                            #} ejc
        .eject
#
#      code block (continued)
#
#      cdcod is the start of the actual code. first we describe
#      the code generated for an expression. in an expression,
#      elements are fetched by name or by value. for example,
#      the binary equal operator fetches its left argument
#      by name and its right argument by value. these two
#      cases generate quite different code and are described
#      separately. first we consider the code by value case.
#
#      generation of code by value for expressions elements.
#
#      expression            pointer to exblk or seblk
#
#      integer constant      pointer to icblk
#
#      null constant         pointer to nulls
#
#      pattern               (resulting from preevaluation)
#                            =o$lpt
#                            pointer to p0blk,p1blk or p2blk
#
#      real constant         pointer to rcblk
#
#      string constant       pointer to scblk
#
#      variable              pointer to vrget field of vrblk
#
#      addition              value code for left operand
#                            value code for right operand
#                            =o$add
#
#      affirmation           value code for operand
#                            =o$aff
#
#      alternation           value code for left operand
#                            value code for right operand
#                            =o$alt
#
#      array reference       (case of one subscript)
#                            value code for array operand
#                            value code for subscript operand
#                            =o$aov
#
#                            (case of more than one subscript)
#                            value code for array operand
#                            value code for first subscript
#                            value code for second subscript
#                            ...
#                            value code for last subscript
#                            =o$amv
#                            number of subscripts
                            #} ejc
        .eject
#
#      code block (continued)
#
#      assignment            (to natural variable)
#                            value code for right operand
#                            pointer to vrsto field of vrblk
#
#                            (to any other variable)
#                            name code for left operand
#                            value code for right operand
#                            =o$ass
#
#      compile error         =o$cer
#
#
#      complementation       value code for operand
#                            =o$com
#
#      concatenation         (case of pred func left operand)
#                            value code for left operand
#                            =o$pop
#                            value code for right operand
#
#                            (all other cases)
#                            value code for left operand
#                            value code for right operand
#                            =o$cnc
#
#      cursor assignment     name code for operand
#                            =o$cas
#
#      division              value code for left operand
#                            value code for right operand
#                            =o$dvd
#
#      exponentiation        value code for left operand
#                            value code for right operand
#                            =o$exp
#
#      function call         (case of call to system function)
#                            value code for first argument
#                            value code for second argument
#                            ...
#                            value code for last argument
#                            pointer to svfnc field of svblk
#
                            #} ejc
        .eject
#
#      code block (continued)
#
#      function call         (case of non-system function 1 arg)
#                            value code for argument
#                            =o$fns
#                            pointer to vrblk for function
#
#                            (non-system function, gt 1 arg)
#                            value code for first argument
#                            value code for second argument
#                            ...
#                            value code for last argument
#                            =o$fnc
#                            number of arguments
#                            pointer to vrblk for function
#
#      immediate assignment  value code for left operand
#                            name code for right operand
#                            =o$ima
#
#      indirection           value code for operand
#                            =o$inv
#
#      interrogation         value code for operand
#                            =o$int
#
#      keyword reference     name code for operand
#                            =o$kwv
#
#      multiplication        value code for left operand
#                            value code for right operand
#                            =o$mlt
#
#      name reference        (natural variable case)
#                            pointer to nmblk for name
#
#                            (all other cases)
#                            name code for operand
#                            =o$nam
#
#      negation              =o$nta
#                            cdblk offset of o$ntc word
#                            value code for operand
#                            =o$ntb
#                            =o$ntc
                            #} ejc
        .eject
#
#      code block (continued)
#
#      pattern assignment    value code for left operand
#                            name code for right operand
#                            =o$pas
#
#      pattern match         value code for left operand
#                            value code for right operand
#                            =o$pmv
#
#      pattern replacement   name code for subject
#                            value code for pattern
#                            =o$pmn
#                            value code for replacement
#                            =o$rpl
#
#      selection             (for first alternative)
#                            =o$sla
#                            cdblk offset to next o$slc word
#                            value code for first alternative
#                            =o$slb
#                            cdblk offset past alternatives
#
#                            (for subsequent alternatives)
#                            =o$slc
#                            cdblk offset to next o$slc,o$sld
#                            value code for alternative
#                            =o$slb
#                            offset in cdblk past alternatives
#
#                            (for last alternative)
#                            =o$sld
#                            value code for last alternative
#
#      subtraction           value code for left operand
#                            value code for right operand
#                            =o$sub
                            #} ejc
        .eject
#
#      code block (continued)
#
#      generation of code by name for expression elements.
#
#      variable              =o$lvn
#                            pointer to vrblk
#
#      expression            (case of *natural variable)
#                            =o$lvn
#                            pointer to vrblk
#
#                            (all other cases)
#                            =o$lex
#                            pointer to exblk
#
#
#      array reference       (case of one subscript)
#                            value code for array operand
#                            value code for subscript operand
#                            =o$aon
#
#                            (case of more than one subscript)
#                            value code for array operand
#                            value code for first subscript
#                            value code for second subscript
#                            ...
#                            value code for last subscript
#                            =o$amn
#                            number of subscripts
#
#      compile error         =o$cer
#
#      function call         (same code as for value call)
#                            =o$fne
#
#      indirection           value code for operand
#                            =o$inn
#
#      keyword reference     name code for operand
#                            =o$kwn
#
#      any other operand is an error in a name position
#
#      note that in this description, =o$xxx refers to the
#      generation of a word containing the address of another
#      word which contains the entry point address o$xxx.
                            #} ejc
        .eject
#
#      code block (continued)
#
#      now we consider the overall structure of the code block
#      for a statement with possible goto fields.
#
#      first comes the code for the statement body.
#      the statement body is an expression to be evaluated
#      by value although the value is not actually required.
#      normal value code is generated for the body of the
#      statement except in the case of a pattern match by
#      value, in which case the following is generated.
#
#                            value code for left operand
#                            value code for right operand
#                            =o$pms
#
#      next we have the code for the success goto. there are
#      several cases as follows.
#
#      1)   no success goto  ptr to cdblk for next statement
#
#      2)   simple label     ptr to vrtra field of vrblk
#
#      3)   complex goto     (code by name for goto operand)
#                            =o$goc
#
#      4)   direct goto      (code by value for goto operand)
#                            =o$god
#
#      following this we generate code for the failure goto if
#      it is direct or if it is complex, simple failure gotos
#      having been handled by an appropriate setting of the
#      cdfal field of the cdblk. the generated code is one
#      of the following.
#
#      1)   complex fgoto    =o$fif
#                            =o$gof
#                            name code for goto operand
#                            =o$goc
#
#      2)   direct fgoto     =o$fif
#                            =o$gof
#                            value code for goto operand
#                            =o$god
#
#      an optimization occurs if the success and failure gotos
#      are identical and either complex or direct. in this case,
#      no code is generated for the success goto and control
#      is allowed to fall into the failure goto on success.
                            #} ejc
        .eject
#
#      compiler block (cmblk)
#
#      a compiler block (cmblk) is built by expan to represent
#      one node of a tree structured expression representation.
#
#           +------------------------------------+
#           i                cmidn               i
#           +------------------------------------+
#           i                cmlen               i
#           +------------------------------------+
#           i                cmtyp               i
#           +------------------------------------+
#           i                cmopn               i
#           +------------------------------------+
#           /           cmvls or cmrop           /
#           /                                    /
#           /                cmlop               /
#           /                                    /
#           +------------------------------------+
#
cmidn   =    0              #pointer to dummy routine b_cmt} equ 0
cmlen   =    cmidn+1        #length of cmblk in bytes} equ cmidn+1
cmtyp   =    cmlen+1        #type (c_xxx, see list below)} equ cmlen+1
cmopn   =    cmtyp+1        #operand pointer (see below)} equ cmtyp+1
cmvls   =    cmopn+1        #operand value pointers (see below)} equ cmopn+1
cmrop   =    cmvls          #right (only) operator operand} equ cmvls
cmlop   =    cmvls+1        #left operator operand} equ cmvls+1
cmsi_   =    cmvls          #number of standard fields in cmblk} equ cmvls
cmus_   =    cmsi_+1        #size of unary operator cmblk} equ cmsi_+1
cmbs_   =    cmsi_+2        #size of binary operator cmblk} equ cmsi_+2
cmar1   =    cmvls+1        #array subscript pointers} equ cmvls+1
#
#      the cmopn and cmvls fields are set as follows
#
#      array reference       cmopn = ptr to array operand
#                            cmvls = ptrs to subscript operands
#
#      function call         cmopn = ptr to vrblk for function
#                            cmvls = ptrs to argument operands
#
#      selection             cmopn = zero
#                            cmvls = ptrs to alternate operands
#
#      unary operator        cmopn = ptr to operator dvblk
#                            cmrop = ptr to operand
#
#      binary operator       cmopn = ptr to operator dvblk
#                            cmrop = ptr to right operand
#                            cmlop = ptr to left operand
                            #} ejc
        .eject
#
#      cmtyp is set to indicate the type of expression element
#      as shown by the following table of definitions.
#
c_arr   =    0              #array reference} equ 0
c_fnc   =    c_arr+1        #function call} equ c_arr+1
c_def   =    c_fnc+1        #deferred expression (unary *)} equ c_fnc+1
c_ind   =    c_def+1        #indirection (unary _)} equ c_def+1
c_key   =    c_ind+1        #keyword reference (unary ampersand)} equ c_ind+1
c_ubo   =    c_key+1        #undefined binary operator} equ c_key+1
c_uuo   =    c_ubo+1        #undefined unary operator} equ c_ubo+1
c_uo_   =    c_uuo+1        #test value (=c_uuo+1=c_ubo+2)} equ c_uuo+1
c__nm   =    c_uuo+1        #number of codes for name operands} equ c_uuo+1
#
#      the remaining types indicate expression elements which
#      can only be evaluated by value (not by name).
#
c_bvl   =    c_uuo+1        #binary op with value operands} equ c_uuo+1
c_uvl   =    c_bvl+1        #unary operator with value operand} equ c_bvl+1
c_alt   =    c_uvl+1        #alternation (binary bar)} equ c_uvl+1
c_cnc   =    c_alt+1        #concatenation} equ c_alt+1
c_cnp   =    c_cnc+1        #concatenation, not pattern match} equ c_cnc+1
c_unm   =    c_cnp+1        #unary op with name operand} equ c_cnp+1
c_bvn   =    c_unm+1        #binary op (operands by value, name)} equ c_unm+1
c_ass   =    c_bvn+1        #assignment} equ c_bvn+1
c_int   =    c_ass+1        #interrogation} equ c_ass+1
c_neg   =    c_int+1        #negation (unary not)} equ c_int+1
c_sel   =    c_neg+1        #selection} equ c_neg+1
c_pmt   =    c_sel+1        #pattern match} equ c_sel+1
#
c_pr_   =    c_bvn          #last preevaluable code} equ c_bvn
c__nv   =    c_pmt+1        #number of different cmblk types} equ c_pmt+1
                            #} ejc
        .eject
#
#      character table block (ctblk)
#
#      a character table block is used to hold logical character
#      tables for use with any,notany,span,break,breakx
#      patterns. each character table can be used to store
#      cfp$n distinct tables as bit columns. a bit column
#      allocated for each argument of more than one character
#      in length to one of the above listed pattern primitives.
#
#           +------------------------------------+
#           i                cttyp               i
#           +------------------------------------+
#           *                                    *
#           *                                    *
#           *                ctchs               *
#           *                                    *
#           *                                    *
#           +------------------------------------+
#
cttyp   =    0              #pointer to dummy routine b_ctt} equ 0
ctchs   =    cttyp+1        #start of character table words} equ cttyp+1
ctsi_   =    ctchs+cfp_a    #number of words in ctblk} equ ctchs+cfp_a
#
#      ctchs is cfp$a words long and consists of a one word
#      bit string value for each possible character in the
#      internal alphabet. each of the cfp$n possible bits in
#      a bitstring is used to form a column of bit indicators.
#      a bit is set on if the character is in the table and off
#      if the character is not present.
                            #} ejc
        .eject
#
#      datatype function block (dfblk)
#
#      a datatype function is used to control the construction
#      of a program defined datatype object. a call to the
#      system function data builds a dfblk for the datatype name
#
#      note that these blocks are built in static because pdblk
#      length is got from dflen field.  if dfblk was in dynamic
#      store this would cause trouble during pass two of garbage
#      collection.  scblk referred to by dfnam field is also put
#      in static so that there are no reloc. fields. this cuts
#      garbage collection task appreciably for pdblks which are
#      likely to be present in large numbers.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                dflen               i
#           +------------------------------------+
#           i                dfpdl               i
#           +------------------------------------+
#           i                dfnam               i
#           +------------------------------------+
#           /                                    /
#           /                dffld               /
#           /                                    /
#           +------------------------------------+
#
dflen   =    fargs+1        #length of dfblk in bytes} equ fargs+1
dfpdl   =    dflen+1        #length of corresponding pdblk} equ dflen+1
dfnam   =    dfpdl+1        #pointer to scblk for datatype name} equ dfpdl+1
dffld   =    dfnam+1        #start of vrblk ptrs for field names} equ dfnam+1
dfflb   =    dffld-1        #offset behind dffld for field func} equ dffld-1
dfsi_   =    dffld          #number of standard fields in dfblk} equ dffld
#
#      the fcode field points to the routine b$dfc
#
#      fargs (the number of arguments) is the number of fields.
                            #} ejc
        .eject
#
#      dope vector block (dvblk)
#
#      a dope vector is assembled for each possible operator in
#      the snobol4 language as part of the constant section.
#
#           +------------------------------------+
#           i                dvopn               i
#           +------------------------------------+
#           i                dvtyp               i
#           +------------------------------------+
#           i                dvlpr               i
#           +------------------------------------+
#           i                dvrpr               i
#           +------------------------------------+
#
dvopn   =    0              #entry address (ptr to o_xxx)} equ 0
dvtyp   =    dvopn+1        #type code (c_xxx, see cmblk)} equ dvopn+1
dvlpr   =    dvtyp+1        #left precedence (llxxx, see below)} equ dvtyp+1
dvrpr   =    dvlpr+1        #right precedence (rrxxx, see below)} equ dvlpr+1
dvus_   =    dvlpr+1        #size of unary operator dv} equ dvlpr+1
dvbs_   =    dvrpr+1        #size of binary operator dv} equ dvrpr+1
dvubs   =    dvus_+dvbs_    #size of unop + binop (see scane)} equ dvus_+dvbs_
#
#      the contents of the dvtyp field is copied into the cmtyp
#      field of the cmblk for the operator if it is used.
#
#      the cmopn field of an operator cmblk points to the dvblk
#      itself, providing the required entry address pointer ptr.
#
#      for normally undefined operators, the dvopn (and cmopn)
#      fields contain a word offset from r$uba of the function
#      block pointer for the operator (instead of o$xxx ptr).
#      for certain special operators, the dvopn field is not
#      required at all and is assembled as zero.
#
#      the left precedence is used in comparing an operator to
#      the left of some other operator. it therefore governs the
#      precedence of the operator towards its right operand.
#
#      the right precedence is used in comparing an operator to
#      the right of some other operator. it therefore governs
#      the precedence of the operator towards its left operand.
#
#      higher precedence values correspond to a tighter binding
#      capability. thus we have the left precedence lower
#      (higher) than the right precedence for right (left)
#      associative binary operators.
#
#      the left precedence of unary operators is set to an
#      arbitrary high value. the right value is not required and
#      consequently the dvrpr field is omitted for unary ops.
                            #} ejc
        .eject
#
#      table of operator precedence values
#
rrass   =    10             #right     equal} equ 10
llass   =    00             #left      equal} equ 00
rrpmt   =    20             #right     question mark} equ 20
llpmt   =    30             #left      question mark} equ 30
rramp   =    40             #right     ampersand} equ 40
llamp   =    50             #left      ampersand} equ 50
rralt   =    70             #right     vertical bar} equ 70
llalt   =    60             #left      vertical bar} equ 60
rrcnc   =    90             #right     blank} equ 90
llcnc   =    80             #left      blank} equ 80
rrats   =    110            #right     at} equ 110
llats   =    100            #left      at} equ 100
rrplm   =    120            #right     plus, minus} equ 120
llplm   =    130            #left      plus, minus} equ 130
rrnum   =    140            #right     number} equ 140
llnum   =    150            #left      number} equ 150
rrdvd   =    160            #right     slash} equ 160
lldvd   =    170            #left      slash} equ 170
rrmlt   =    180            #right     asterisk} equ 180
llmlt   =    190            #left      asterisk} equ 190
rrpct   =    200            #right     percent} equ 200
llpct   =    210            #left      percent} equ 210
rrexp   =    230            #right     exclamation} equ 230
llexp   =    220            #left      exclamation} equ 220
rrdld   =    240            #right     dollar, dot} equ 240
lldld   =    250            #left      dollar, dot} equ 250
rrnot   =    270            #right     not} equ 270
llnot   =    260            #left      not} equ 260
lluno   =    999            #left      all unary operators} equ 999
#
#      precedences are the same as in btl snobol4 with the
#      following exceptions.
#
#      1)   binary question mark is lowered and made left assoc-
#           iative to reflect its new use for pattern matching.
#
#      2)   alternation and concatenation are made right
#           associative for greater efficiency in pattern
#           construction and matching respectively. this change
#           is transparent to the snobol4 programmer.
#
#      3)   the equal sign has been added as a low precedence
#           operator which is right associative to reflect its
#           more general usage in this version of snobol4.
                            #} ejc
        .eject
#
#      external function block (efblk)
#
#      an external function block is used to control the calling
#      of an external function. it is built by a call to load.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                eflen               i
#           +------------------------------------+
#           i                efuse               i
#           +------------------------------------+
#           i                efcod               i
#           +------------------------------------+
#           i                efvar               i
#           +------------------------------------+
#           i                efrsl               i
#           +------------------------------------+
#           /                                    /
#           /                eftar               /
#           /                                    /
#           +------------------------------------+
#
eflen   =    fargs+1        #length of efblk in bytes} equ fargs+1
efuse   =    eflen+1        #use count (for opsyn)} equ eflen+1
efcod   =    efuse+1        #ptr to code (from sysld)} equ efuse+1
efvar   =    efcod+1        #ptr to associated vrblk} equ efcod+1
efrsl   =    efvar+1        #result type (see below)} equ efvar+1
eftar   =    efrsl+1        #argument types (see below)} equ efrsl+1
efsi_   =    eftar          #number of standard fields in efblk} equ eftar
#
#      the fcode field points to the routine b$efc.
#
#      efuse is used to keep track of multiple use when opsyn
#      is employed. the function is automatically unloaded
#      when there are no more references to the function.
#
#      efrsl and eftar are type codes as follows.
#
#           0                type is unconverted
#           1                type is string
#           2                type is integer
#           3                type is real
#           4                type is file
                            #} ejc
        .eject
#
#      expression variable block (evblk)
#
#      in this version of spitbol, an expression can be used in
#      any position which would normally expect a name (for
#      example on the left side of equals or as the right
#      argument of binary dot). this corresponds to the creation
#      of a pseudo-variable which is represented by a pointer to
#      an expression variable block as follows.
#
#           +------------------------------------+
#           i                evtyp               i
#           +------------------------------------+
#           i                evexp               i
#           +------------------------------------+
#           i                evvar               i
#           +------------------------------------+
#
evtyp   =    0              #pointer to dummy routine b_evt} equ 0
evexp   =    evtyp+1        #pointer to exblk for expression} equ evtyp+1
evvar   =    evexp+1        #pointer to trbev dummy trblk} equ evexp+1
evsi_   =    evvar+1        #size of evblk} equ evvar+1
#
#      the name of an expression variable is represented by a
#      base pointer to the evblk and an offset of evvar. this
#      value appears to be trapped by the dummy trbev block.
#
#      note that there is no need to allow for the case of an
#      expression variable which references an seblk since a
#      variable which is of the form *var is equivalent to var.
                            #} ejc
        .eject
#
#      expression block (exblk)
#
#      an expression block is built for each expression
#      referenced in a program or created by eval or convert
#      during execution of a program.
#
#           +------------------------------------+
#           i                extyp               i
#           +------------------------------------+
#           i                exstm               i
#           +------------------------------------+
#           i                exsln               i
#           +------------------------------------+
#           i                exlen               i
#           +------------------------------------+
#           i                exflc               i
#           +------------------------------------+
#           /                                    /
#           /                excod               /
#           /                                    /
#           +------------------------------------+
#
extyp   =    0              #ptr to routine b_exl to load expr} equ 0
exstm   =    cdstm          #stores stmnt no. during evaluation} equ cdstm
exsln   =    exstm+1        #stores line no. during evaluation} equ exstm+1
exlen   =    exsln+1        #length of exblk in bytes} equ exsln+1
exflc   =    exlen+1        #failure code (=o_fex)} equ exlen+1
excod   =    exflc+1        #pseudo-code for expression} equ exflc+1
exsi_   =    excod          #number of standard fields in exblk} equ excod
#
#      there are two cases for excod depending on whether the
#      expression can be evaluated by name (see description
#      of cdblk for details of code for expressions).
#
#      if the expression can be evaluated by name we have.
#
#                            (code for expr by name)
#                            =o$rnm
#
#      if the expression can only be evaluated by value.
#
#                            (code for expr by value)
#                            =o$rvl
                            #} ejc
        .eject
#
#      field function block (ffblk)
#
#      a field function block is used to control the selection
#      of a field from a program defined datatype block.
#      a call to data creates an ffblk for each field.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                ffdfp               i
#           +------------------------------------+
#           i                ffnxt               i
#           +------------------------------------+
#           i                ffofs               i
#           +------------------------------------+
#
ffdfp   =    fargs+1        #pointer to associated dfblk} equ fargs+1
ffnxt   =    ffdfp+1        #ptr to next ffblk on chain or zero} equ ffdfp+1
ffofs   =    ffnxt+1        #offset (bytes) to field in pdblk} equ ffnxt+1
ffsi_   =    ffofs+1        #size of ffblk in words} equ ffofs+1
#
#      the fcode field points to the routine b$ffc.
#
#      fargs always contains one.
#
#      ffdfp is used to verify that the correct program defined
#      datatype is being accessed by this call.
#      ffdfp is non-reloc. because dfblk is in static
#
#      ffofs is used to select the appropriate field. note that
#      it is an actual offset (not a field number)
#
#      ffnxt is used to point to the next ffblk of the same name
#      in the case where there are several fields of the same
#      name for different datatypes. zero marks the end of chain
                            #} ejc
        .eject
#
#      integer constant block (icblk)
#
#      an icblk is created for every integer referenced or
#      created by a program. note however that certain internal
#      integer values are stored as addresses (e.g. the length
#      field in a string constant block)
#
#           +------------------------------------+
#           i                icget               i
#           +------------------------------------+
#           *                icval               *
#           +------------------------------------+
#
icget   =    0              #ptr to routine b_icl to load int} equ 0
icval   =    icget+1        #integer value} equ icget+1
icsi_   =    icval+cfp_i    #size of icblk} equ icval+cfp_i
#
#      the length of the icval field is cfp$i.
                            #} ejc
        .eject
#
#      keyword variable block (kvblk)
#
#      a kvblk is used to represent a keyword pseudo-variable.
#      a kvblk is built for each keyword reference (kwnam).
#
#           +------------------------------------+
#           i                kvtyp               i
#           +------------------------------------+
#           i                kvvar               i
#           +------------------------------------+
#           i                kvnum               i
#           +------------------------------------+
#
kvtyp   =    0              #pointer to dummy routine b_kvt} equ 0
kvvar   =    kvtyp+1        #pointer to dummy block trbkv} equ kvtyp+1
kvnum   =    kvvar+1        #keyword number} equ kvvar+1
kvsi_   =    kvnum+1        #size of kvblk} equ kvnum+1
#
#      the name of a keyword variable is represented by a
#      base pointer to the kvblk and an offset of kvvar. the
#      value appears to be trapped by the pointer to trbkv.
                            #} ejc
        .eject
#
#      name block (nmblk)
#
#      a name block is used wherever a name must be stored as
#      a value following use of the unary dot operator.
#
#           +------------------------------------+
#           i                nmtyp               i
#           +------------------------------------+
#           i                nmbas               i
#           +------------------------------------+
#           i                nmofs               i
#           +------------------------------------+
#
nmtyp   =    0              #ptr to routine b_nml to load name} equ 0
nmbas   =    nmtyp+1        #base pointer for variable} equ nmtyp+1
nmofs   =    nmbas+1        #offset for variable} equ nmbas+1
nmsi_   =    nmofs+1        #size of nmblk} equ nmofs+1
#
#      the actual field representing the contents of the name
#      is found nmofs bytes past the address in nmbas.
#
#      the name is split into base and offset form to avoid
#      creation of a pointer into the middle of a block which
#      could not be handled properly by the garbage collector.
#
#      a name may be built for any variable (see section on
#      representations of variables) this includes the
#      cases of pseudo-variables.
                            #} ejc
        .eject
#
#      pattern block, no parameters (p0blk)
#
#      a p0blk is used to represent pattern nodes which do
#      not require the use of any parameter values.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#
pcode   =    0              #ptr to match routine (p_xxx)} equ 0
pthen   =    pcode+1        #pointer to subsequent node} equ pcode+1
pasi_   =    pthen+1        #size of p0blk} equ pthen+1
#
#      pthen points to the pattern block for the subsequent
#      node to be matched. this is a pointer to the pattern
#      block ndnth if there is no subsequent (end of pattern)
#
#      pcode is a pointer to the match routine for the node.
                            #} ejc
        .eject
#
#      pattern block (one parameter)
#
#      a p1blk is used to represent pattern nodes which
#      require one parameter value.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#           i                parm1               i
#           +------------------------------------+
#
parm1   =    pthen+1        #first parameter value} equ pthen+1
pbsi_   =    parm1+1        #size of p1blk in words} equ parm1+1
#
#      see p0blk for definitions of pcode, pthen
#
#      parm1 contains a parameter value used in matching the
#      node. for example, in a len pattern, it is the integer
#      argument to len. the details of the use of the parameter
#      field are included in the description of the individual
#      match routines. parm1 is always an address pointer which
#      is processed by the garbage collector.
                            #} ejc
        .eject
#
#      pattern block (two parameters)
#
#      a p2blk is used to represent pattern nodes which
#      require two parameter values.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#           i                parm1               i
#           +------------------------------------+
#           i                parm2               i
#           +------------------------------------+
#
parm2   =    parm1+1        #second parameter value} equ parm1+1
pcsi_   =    parm2+1        #size of p2blk in words} equ parm2+1
#
#      see p1blk for definitions of pcode, pthen, parm1
#
#      parm2 is a parameter which performs the same sort of
#      function as parm1 (see description of p1blk).
#
#      parm2 is a non-relocatable field and is not
#      processed by the garbage collector. accordingly, it may
#      not contain a pointer to a block in dynamic memory.
                            #} ejc
        .eject
#
#      program-defined datatype block
#
#      a pdblk represents the data item formed by a call to a
#      datatype function as defined by the system function data.
#
#           +------------------------------------+
#           i                pdtyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                pddfp               i
#           +------------------------------------+
#           /                                    /
#           /                pdfld               /
#           /                                    /
#           +------------------------------------+
#
pdtyp   =    0              #ptr to dummy routine b_pdt} equ 0
pddfp   =    idval+1        #ptr to associated dfblk} equ idval+1
pdfld   =    pddfp+1        #start of field value pointers} equ pddfp+1
pdfof   =    dffld-pdfld    #difference in offset to field ptrs} equ dffld-pdfld
pdsi_   =    pdfld          #size of standard fields in pdblk} equ pdfld
pddfs   =    dfsi_-pdsi_    #difference in dfblk, pdblk sizes} equ dfsi_-pdsi_
#
#      the pddfp pointer may be used to determine the datatype
#      and the names of the fields if required. the dfblk also
#      contains the length of the pdblk in bytes (field dfpdl).
#      pddfp is non-reloc. because dfblk is in static
#
#      pdfld values are stored in order from left to right.
#      they contain values or pointers to trblk chains.
                            #} ejc
        .eject
#
#      program defined function block (pfblk)
#
#      a pfblk is created for each call to the define function
#      and a pointer to the pfblk placed in the proper vrblk.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                pflen               i
#           +------------------------------------+
#           i                pfvbl               i
#           +------------------------------------+
#           i                pfnlo               i
#           +------------------------------------+
#           i                pfcod               i
#           +------------------------------------+
#           i                pfctr               i
#           +------------------------------------+
#           i                pfrtr               i
#           +------------------------------------+
#           /                                    /
#           /                pfarg               /
#           /                                    /
#           +------------------------------------+
#
pflen   =    fargs+1        #length of pfblk in bytes} equ fargs+1
pfvbl   =    pflen+1        #pointer to vrblk for function name} equ pflen+1
pfnlo   =    pfvbl+1        #number of locals} equ pfvbl+1
pfcod   =    pfnlo+1        #ptr to vrblk for entry label} equ pfnlo+1
pfctr   =    pfcod+1        #trblk ptr if call traced else 0} equ pfcod+1
pfrtr   =    pfctr+1        #trblk ptr if return traced else 0} equ pfctr+1
pfarg   =    pfrtr+1        #vrblk ptrs for arguments and locals} equ pfrtr+1
pfagb   =    pfarg-1        #offset behind pfarg for arg, local} equ pfarg-1
pfsi_   =    pfarg          #number of standard fields in pfblk} equ pfarg
#
#      the fcode field points to the routine b$pfc.
#
#      pfarg is stored in the following order.
#
#           arguments (left to right)
#           locals (left to right)
                            #} ejc
        .eject
#
#      real constant block (rcblk)
#
#      an rcblk is created for every real referenced or
#      created by a program.
#
#           +------------------------------------+
#           i                rcget               i
#           +------------------------------------+
#           *                rcval               *
#           +------------------------------------+
#
rcget   =    0              #ptr to routine b_rcl to load real} equ 0
rcval   =    rcget+1        #real value} equ rcget+1
rcsi_   =    rcval+cfp_r    #size of rcblk} equ rcval+cfp_r
#
#      the length of the rcval field is cfp$r.
                            #} ejc
        .eject
#
#      string constant block (scblk)
#
#      an scblk is built for every string referenced or created
#      by a program.
#
#           +------------------------------------+
#           i                scget               i
#           +------------------------------------+
#           i                sclen               i
#           +------------------------------------+
#           /                                    /
#           /                schar               /
#           /                                    /
#           +------------------------------------+
#
scget   =    0              #ptr to routine b_scl to load string} equ 0
sclen   =    scget+1        #length of string in characters} equ scget+1
schar   =    sclen+1        #characters of string} equ sclen+1
scsi_   =    schar          #size of standard fields in scblk} equ schar
#
#      the characters of the string are stored left justified.
#      the final word is padded on the right with zeros.
#      (i.e. the character whose internal code is zero).
#
#      the value of sclen may not exceed mxlen. this ensures
#      that character offsets (e.g. the pattern match cursor)
#      can be correctly processed by the garbage collector.
#
#      note that the offset to the characters of the string
#      is given in bytes by cfp$f and that this value is
#      automatically allowed for in plc, psc.
#      note that for a spitbol scblk, the value of cfp$f
#      is given by cfp$b*schar.
                            #} ejc
        .eject
#
#      simple expression block (seblk)
#
#      an seblk is used to represent an expression of the form
#      *(natural variable). all other expressions are exblks.
#
#           +------------------------------------+
#           i                setyp               i
#           +------------------------------------+
#           i                sevar               i
#           +------------------------------------+
#
setyp   =    0              #ptr to routine b_sel to load expr} equ 0
sevar   =    setyp+1        #ptr to vrblk for variable} equ setyp+1
sesi_   =    sevar+1        #length of seblk in words} equ sevar+1
                            #} ejc
        .eject
#
#      standard variable block (svblk)
#
#      an svblk is assembled in the constant section for each
#      variable which satisfies one of the following conditions.
#
#      1)   it is the name of a system function
#      2)   it has an initial value
#      3)   it has a keyword association
#      4)   it has a standard i/o association
#      6)   it has a standard label association
#
#      if vrblks are constructed for any of these variables,
#      then the vrsvp field points to the svblk (see vrblk)
#
#           +------------------------------------+
#           i                svbit               i
#           +------------------------------------+
#           i                svlen               i
#           +------------------------------------+
#           /                svchs               /
#           +------------------------------------+
#           i                svknm               i
#           +------------------------------------+
#           i                svfnc               i
#           +------------------------------------+
#           i                svnar               i
#           +------------------------------------+
#           i                svlbl               i
#           +------------------------------------+
#           i                svval               i
#           +------------------------------------+
                            #} ejc
        .eject
#
#      standard variable block (continued)
#
svbit   =    0              #bit string indicating attributes} equ 0
svlen   =    1              #(=sclen) length of name in chars} equ 1
svchs   =    2              #(=schar) characters of name} equ 2
svsi_   =    2              #number of standard fields in svblk} equ 2
svpre   =    1              #set if preevaluation permitted} equ 1
svffc   =    svpre+svpre    #set on if fast call permitted} equ svpre+svpre
svckw   =    svffc+svffc    #set on if keyword value constant} equ svffc+svffc
svprd   =    svckw+svckw    #set on if predicate function} equ svckw+svckw
svnbt   =    4              #number of bits to right of svknm} equ 4
svknm   =    svprd+svprd    #set on if keyword association} equ svprd+svprd
svfnc   =    svknm+svknm    #set on if system function} equ svknm+svknm
svnar   =    svfnc+svfnc    #set on if system function} equ svfnc+svfnc
svlbl   =    svnar+svnar    #set on if system label} equ svnar+svnar
svval   =    svlbl+svlbl    #set on if predefined value} equ svlbl+svlbl
#
#      note that the last five bits correspond in order
#      to the fields which are present (see procedure gtnvr).
#
#      the following definitions are used in the svblk table
#
svfnf   =    svfnc+svnar    #function with no fast call} equ svfnc+svnar
svfnn   =    svfnf+svffc    #function with fast call, no preeval} equ svfnf+svffc
svfnp   =    svfnn+svpre    #function allowing preevaluation} equ svfnn+svpre
svfpr   =    svfnn+svprd    #predicate function} equ svfnn+svprd
svfnk   =    svfnn+svknm    #no preeval func + keyword} equ svfnn+svknm
svkwv   =    svknm+svval    #keyword + value} equ svknm+svval
svkwc   =    svckw+svknm    #keyword with constant value} equ svckw+svknm
svkvc   =    svkwv+svckw    #constant keyword + value} equ svkwv+svckw
svkvl   =    svkvc+svlbl    #constant keyword + value + label} equ svkvc+svlbl
svfpk   =    svfnp+svkvc    #preeval fcn + const keywd + val} equ svfnp+svkvc
#
#      the svpre bit allows the compiler to preevaluate a call
#      to the associated system function if all the arguments
#      are themselves constants. functions in this category
#      must have no side effects and must never cause failure.
#      the call may generate an error condition.
#
#      the svffc bit allows the compiler to generate the special
#      fast call after adjusting the number of arguments. only
#      the item and apply functions fall outside this category.
#
#      the svckw bit is set if the associated keyword value is
#      a constant, thus allowing preevaluation for a value call.
#
#      the svprd bit is set on for all predicate functions to
#      enable the special concatenation code optimization.
                            #} ejc
        .eject
#
#      svblk (continued)
#
#      svknm                 keyword number
#
#           svknm is present only for a standard keyword assoc.
#           it contains a keyword number as defined by the
#           keyword number table given later on.
#
#      svfnc                 system function pointer
#
#           svfnc is present only for a system function assoc.
#           it is a pointer to the actual code for the system
#           function. the generated code for a fast call is a
#           pointer to the svfnc field of the svblk for the
#           function. the vrfnc field of the vrblk points to
#           this same field, in which case, it serves as the
#           fcode field for the function call.
#
#      svnar                 number of function arguments
#
#           svnar is present only for a system function assoc.
#           it is the number of arguments required for a call
#           to the system function. the compiler uses this
#           value to adjust the number of arguments in a fast
#           call and in the case of a function called through
#           the vrfnc field of the vrblk, the svnar field
#           serves as the fargs field for o$fnc. a special
#           case occurs if this value is set to 999. this is
#           used to indicate that the function has a variable
#           number of arguments and causes o$fnc to pass control
#           without adjusting the argument count. the only
#           predefined functions using this are apply and item.
#
#      svlbl                 system label pointer
#
#           svlbl is present only for a standard label assoc.
#           it is a pointer to a system label routine (l$xxx).
#           the vrlbl field of the corresponding vrblk points to
#           the svlbl field of the svblk.
#
#      svval                 system value pointer
#
#           svval is present only for a standard value.
#           it is a pointer to the pattern node (ndxxx) which
#           is the standard initial value of the variable.
#           this value is copied to the vrval field of the vrblk
                            #} ejc
        .eject
#
#      svblk (continued)
#
#      keyword number table
#
#      the following table gives symbolic names for keyword
#      numbers. these values are stored in the svknm field of
#      svblks and in the kvnum field of kvblks. see also
#      procedures asign, acess and kwnam.
#
#      unprotected keywords with one word integer values
#
k_abe   =    0              #abend} equ 0
k_anc   =    k_abe+cfp_b    #anchor} equ k_abe+cfp_b
k_cas   =    k_anc+cfp_b    #case} equ k_anc+cfp_b
k_cod   =    k_cas+cfp_b    #code} equ k_cas+cfp_b
k_com   =    k_cod+cfp_b    #compare} equ k_cod+cfp_b
k_dmp   =    k_com+cfp_b    #dump} equ k_com+cfp_b
k_erl   =    k_dmp+cfp_b    #errlimit} equ k_dmp+cfp_b
k_ert   =    k_erl+cfp_b    #errtype} equ k_erl+cfp_b
k_ftr   =    k_ert+cfp_b    #ftrace} equ k_ert+cfp_b
k_fls   =    k_ftr+cfp_b    #fullscan} equ k_ftr+cfp_b
k_inp   =    k_fls+cfp_b    #input} equ k_fls+cfp_b
k_mxl   =    k_inp+cfp_b    #maxlength} equ k_inp+cfp_b
k_oup   =    k_mxl+cfp_b    #output} equ k_mxl+cfp_b
k_pfl   =    k_oup+cfp_b    #profile} equ k_oup+cfp_b
k_tra   =    k_pfl+cfp_b    #trace} equ k_pfl+cfp_b
k_trm   =    k_tra+cfp_b    #trim} equ k_tra+cfp_b
#
#      protected keywords with one word integer values
#
k_fnc   =    k_trm+cfp_b    #fnclevel} equ k_trm+cfp_b
k_lst   =    k_fnc+cfp_b    #lastno} equ k_fnc+cfp_b
k_lln   =    k_lst+cfp_b    #lastline} equ k_lst+cfp_b
k_lin   =    k_lln+cfp_b    #line} equ k_lln+cfp_b
k_stn   =    k_lin+cfp_b    #stno} equ k_lin+cfp_b
#
#      keywords with constant pattern values
#
k_abo   =    k_stn+cfp_b    #abort} equ k_stn+cfp_b
k_arb   =    k_abo+pasi_    #arb} equ k_abo+pasi_
k_bal   =    k_arb+pasi_    #bal} equ k_arb+pasi_
k_fal   =    k_bal+pasi_    #fail} equ k_bal+pasi_
k_fen   =    k_fal+pasi_    #fence} equ k_fal+pasi_
k_rem   =    k_fen+pasi_    #rem} equ k_fen+pasi_
k_suc   =    k_rem+pasi_    #succeed} equ k_rem+pasi_
                            #} ejc
        .eject
#
#      keyword number table (continued)
#
#      special keywords
#
k_alp   =    k_suc+1        #alphabet} equ k_suc+1
k_rtn   =    k_alp+1        #rtntype} equ k_alp+1
k_stc   =    k_rtn+1        #stcount} equ k_rtn+1
k_etx   =    k_stc+1        #errtext} equ k_stc+1
k_fil   =    k_etx+1        #file} equ k_etx+1
k_lfl   =    k_fil+1        #lastfile} equ k_fil+1
k_stl   =    k_lfl+1        #stlimit} equ k_lfl+1
k_lcs   =    k_stl+1        #lcase} equ k_stl+1
k_ucs   =    k_lcs+1        #ucase} equ k_lcs+1
#
#      relative offsets of special keywords
#
k__al   =    k_alp-k_alp    #alphabet} equ k_alp-k_alp
k__rt   =    k_rtn-k_alp    #rtntype} equ k_rtn-k_alp
k__sc   =    k_stc-k_alp    #stcount} equ k_stc-k_alp
k__et   =    k_etx-k_alp    #errtext} equ k_etx-k_alp
k__fl   =    k_fil-k_alp    #file} equ k_fil-k_alp
k__lf   =    k_lfl-k_alp    #lastfile} equ k_lfl-k_alp
k__sl   =    k_stl-k_alp    #stlimit} equ k_stl-k_alp
k__lc   =    k_lcs-k_alp    #lcase} equ k_lcs-k_alp
k__uc   =    k_ucs-k_alp    #ucase} equ k_ucs-k_alp
k__n_   =    k__uc+1        #number of special cases} equ k__uc+1
#
#      symbols used in asign and acess procedures
#
k_p__   =    k_fnc          #first protected keyword} equ k_fnc
k_v__   =    k_abo          #first keyword with constant value} equ k_abo
k_s__   =    k_alp          #first keyword with special acess} equ k_alp
                            #} ejc
        .eject
#
#      format of a table block (tbblk)
#
#      a table block is used to represent a table value.
#      it is built by a call to the table or convert functions.
#
#           +------------------------------------+
#           i                tbtyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                tblen               i
#           +------------------------------------+
#           i                tbinv               i
#           +------------------------------------+
#           /                                    /
#           /                tbbuk               /
#           /                                    /
#           +------------------------------------+
#
tbtyp   =    0              #pointer to dummy routine b_tbt} equ 0
tblen   =    offs2          #length of tbblk in bytes} equ offs2
tbinv   =    offs3          #default initial lookup value} equ offs3
tbbuk   =    tbinv+1        #start of hash bucket pointers} equ tbinv+1
tbsi_   =    tbbuk          #size of standard fields in tbblk} equ tbbuk
tbnbk   =    11             #default no. of buckets} equ 11
#
#      the table block is a hash table which points to chains
#      of table element blocks representing the elements
#      in the table which hash into the same bucket.
#
#      tbbuk entries either point to the first teblk on the
#      chain or they point to the tbblk itself to indicate the
#      end of the chain.
                            #} ejc
        .eject
#
#      table element block (teblk)
#
#      a table element is used to represent a single entry in
#      a table (see description of tbblk format for hash table)
#
#           +------------------------------------+
#           i                tetyp               i
#           +------------------------------------+
#           i                tesub               i
#           +------------------------------------+
#           i                teval               i
#           +------------------------------------+
#           i                tenxt               i
#           +------------------------------------+
#
tetyp   =    0              #pointer to dummy routine b_tet} equ 0
tesub   =    tetyp+1        #subscript value} equ tetyp+1
teval   =    tesub+1        #(=vrval) table element value} equ tesub+1
tenxt   =    teval+1        #link to next teblk} equ teval+1
#      see s$cnv where relation is assumed with tenxt and tbbuk
tesi_   =    tenxt+1        #size of teblk in words} equ tenxt+1
#
#      tenxt points to the next teblk on the hash chain from the
#      tbbuk chain for this hash index. at the end of the chain,
#      tenxt points back to the start of the tbblk.
#
#      teval contains a data pointer or a trblk pointer.
#
#      tesub contains a data pointer.
                            #} ejc
        .eject
#
#      trap block (trblk)
#
#      a trap block is used to represent a trace or input or
#      output association in response to a call to the trace
#      input or output system functions. see below for details
#
#           +------------------------------------+
#           i                tridn               i
#           +------------------------------------+
#           i                trtyp               i
#           +------------------------------------+
#           i  trval or trlbl or trnxt or trkvr  i
#           +------------------------------------+
#           i       trtag or trter or trtrf      i
#           +------------------------------------+
#           i            trfnc or trfpt          i
#           +------------------------------------+
#
tridn   =    0              #pointer to dummy routine b_trt} equ 0
trtyp   =    tridn+1        #trap type code} equ tridn+1
trval   =    trtyp+1        #value of trapped variable (=vrval)} equ trtyp+1
trnxt   =    trval          #ptr to next trblk on trblk chain} equ trval
trlbl   =    trval          #ptr to actual label (traced label)} equ trval
trkvr   =    trval          #vrblk pointer for keyword trace} equ trval
trtag   =    trval+1        #trace tag} equ trval+1
trter   =    trtag          #ptr to terminal vrblk or null} equ trtag
trtrf   =    trtag          #ptr to trblk holding fcblk ptr} equ trtag
trfnc   =    trtag+1        #trace function vrblk (zero if none)} equ trtag+1
trfpt   =    trfnc          #fcblk ptr for sysio} equ trfnc
trsi_   =    trfnc+1        #number of words in trblk} equ trfnc+1
#
trtin   =    0              #trace type for input association} equ 0
trtac   =    trtin+1        #trace type for access trace} equ trtin+1
trtvl   =    trtac+1        #trace type for value trace} equ trtac+1
trtou   =    trtvl+1        #trace type for output association} equ trtvl+1
trtfc   =    trtou+1        #trace type for fcblk identification} equ trtou+1
                            #} ejc
        .eject
#
#      trap block (continued)
#
#      variable input association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtin
#           trnxt points to next trblk or trval has variable val
#           trter is a pointer to svblk if association is
#           for input, terminal, else it is null.
#           trtrf points to the trap block which in turn points
#           to an fcblk used for i/o association.
#           trfpt is the fcblk ptr returned by sysio.
#
#      variable access trace association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtac
#           trnxt points to next trblk or trval has variable val
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      variable value trace association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtvl
#           trnxt points to next trblk or trval has variable val
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
                            #} ejc
        .eject
#      trap block (continued)
#
#      variable output association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtou
#           trnxt points to next trblk or trval has variable val
#           trter is a pointer to svblk if association is
#           for output, terminal, else it is null.
#           trtrf points to the trap block which in turn points
#           to an fcblk used for i/o association.
#           trfpt is the fcblk ptr returned by sysio.
#
#      function call trace
#
#           the pfctr field of the corresponding pfblk is set
#           to point to a trblk.
#
#           trtyp is set to trtin
#           trnxt is zero
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      function return trace
#
#           the pfrtr field of the corresponding pfblk is set
#           to point to a trblk
#
#           trtyp is set to trtin
#           trnxt is zero
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      label trace
#
#           the vrlbl of the vrblk for the label is
#           changed to point to a trblk and the vrtra field is
#           set to b$vrt to activate the check.
#
#           trtyp is set to trtin
#           trlbl points to the actual label (cdblk) value
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
                            #} ejc
        .eject
#
#      trap block (continued)
#
#      keyword trace
#
#           keywords which can be traced possess a unique
#           location which is zero if there is no trace and
#           points to a trblk if there is a trace. the locations
#           are as follows.
#
#           r$ert            errtype
#           r$fnc            fnclevel
#           r$stc            stcount
#
#           the format of the trblk is as follows.
#
#           trtyp is set to trtin
#           trkvr is a pointer to the vrblk for the keyword
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      input/output file arg1 trap block
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case of
#           a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv. this trap block is used
#           to hold a pointer to the fcblk which an
#           implementation may request to hold information
#           about a file.
#
#           trtyp is set to trtfc
#           trnext points to next trblk or trval is variable val
#           trfnm is 0
#           trfpt is the fcblk pointer.
#
#      note that when multiple traps are set on a variable
#      the order is in ascending value of trtyp field.
#
#      input association (if present)
#      access trace (if present)
#      value trace (if present)
#      output association (if present)
#
#      the actual value of the variable is stored in the trval
#      field of the last trblk on the chain.
#
#      this implementation does not permit trace or i/o
#      associations to any of the pseudo-variables.
                            #} ejc
        .eject
#
#      vector block (vcblk)
#
#      a vcblk is used to represent an array value which has
#      one dimension whose lower bound is one. all other arrays
#      are represented by arblks. a vcblk is created by the
#      system function array (s$arr) when passed an integer arg.
#
#           +------------------------------------+
#           i                vctyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                vclen               i
#           +------------------------------------+
#           i                vcvls               i
#           +------------------------------------+
#
vctyp   =    0              #pointer to dummy routine b_vct} equ 0
vclen   =    offs2          #length of vcblk in bytes} equ offs2
vcvls   =    offs3          #start of vector values} equ offs3
vcsi_   =    vcvls          #size of standard fields in vcblk} equ vcvls
vcvlb   =    vcvls-1        #offset one word behind vcvls} equ vcvls-1
vctbd   =    tbsi_-vcsi_    #difference in sizes - see prtvl} equ tbsi_-vcsi_
#
#      vcvls are either data pointers or trblk pointers
#
#      the dimension can be deduced from vclen.
                            #} ejc
        .eject
#
#      variable block (vrblk)
#
#      a variable block is built in the static memory area
#      for every variable referenced or created by a program.
#      the order of fields is assumed in the model vrblk stnvr.
#
#      note that since these blocks only occur in the static
#      region, it is permissible to point to any word in
#      the block and this is used to provide three distinct
#      access points from the generated code as follows.
#
#      1)   point to vrget (first word of vrblk) to load the
#           value of the variable onto the main stack.
#
#      2)   point to vrsto (second word of vrblk) to store the
#           top stack element as the value of the variable.
#
#      3)   point to vrtra (fourth word of vrblk) to jump to
#           the label associated with the variable name.
#
#           +------------------------------------+
#           i                vrget               i
#           +------------------------------------+
#           i                vrsto               i
#           +------------------------------------+
#           i                vrval               i
#           +------------------------------------+
#           i                vrtra               i
#           +------------------------------------+
#           i                vrlbl               i
#           +------------------------------------+
#           i                vrfnc               i
#           +------------------------------------+
#           i                vrnxt               i
#           +------------------------------------+
#           i                vrlen               i
#           +------------------------------------+
#           /                                    /
#           /            vrchs = vrsvp           /
#           /                                    /
#           +------------------------------------+
                            #} ejc
        .eject
#
#      variable block (continued)
#
vrget   =    0              #pointer to routine to load value} equ 0
vrsto   =    vrget+1        #pointer to routine to store value} equ vrget+1
vrval   =    vrsto+1        #variable value} equ vrsto+1
vrvlo   =    vrval-vrsto    #offset to value from store field} equ vrval-vrsto
vrtra   =    vrval+1        #pointer to routine to jump to label} equ vrval+1
vrlbl   =    vrtra+1        #pointer to code for label} equ vrtra+1
vrlbo   =    vrlbl-vrtra    #offset to label from transfer field} equ vrlbl-vrtra
vrfnc   =    vrlbl+1        #pointer to function block} equ vrlbl+1
vrnxt   =    vrfnc+1        #pointer to next vrblk on hash chain} equ vrfnc+1
vrlen   =    vrnxt+1        #length of name (or zero)} equ vrnxt+1
vrchs   =    vrlen+1        #characters of name (vrlen gt 0)} equ vrlen+1
vrsvp   =    vrlen+1        #ptr to svblk (vrlen eq 0)} equ vrlen+1
vrsi_   =    vrchs+1        #number of standard fields in vrblk} equ vrchs+1
vrsof   =    vrlen-sclen    #offset to dummy scblk for name} equ vrlen-sclen
vrsvo   =    vrsvp-vrsof    #pseudo-offset to vrsvp field} equ vrsvp-vrsof
#
#      vrget = b$vrl if not input associated or access traced
#      vrget = b$vra if input associated or access traced
#
#      vrsto = b$vrs if not output associated or value traced
#      vrsto = b$vrv if output associated or value traced
#      vrsto = b$vre if value is protected pattern value
#
#      vrval points to the appropriate value unless the
#      variable is i/o/trace associated in which case, vrval
#      points to an appropriate trblk (trap block) chain.
#
#      vrtra = b$vrg if the label is not traced
#      vrtra = b$vrt if the label is traced
#
#      vrlbl points to a cdblk if there is a label
#      vrlbl points to the svblk svlbl field for a system label
#      vrlbl points to stndl for an undefined label
#      vrlbl points to a trblk if the label is traced
#
#      vrfnc points to a ffblk for a field function
#      vrfnc points to a dfblk for a datatype function
#      vrfnc points to a pfblk for a program defined function
#      vrfnc points to a efblk for an external loaded function
#      vrfnc points to svfnc (svblk) for a system function
#      vrfnc points to stndf if the function is undefined
#
#      vrnxt points to the next vrblk on this chain unless
#      this is the end of the chain in which case it is zero.
#
#      vrlen is the name length for a non-system variable.
#      vrlen is zero for a system variable.
#
#      vrchs is the name (ljrz) if vrlen is non-zero.
#      vrsvp is a ptr to the svblk if vrlen is zero.
                            #} ejc
        .eject
#
#      format of a non-relocatable external block (xnblk)
#
#      an xnblk is a block representing an unknown (external)
#      data value. the block contains no pointers to other
#      relocatable blocks. an xnblk is used by external function
#      processing or possibly for system i/o routines etc.
#      the macro-system itself does not use xnblks.
#      this type of block may be used as a file control block.
#      see sysfc,sysin,sysou,s$inp,s$oup for details.
#
#           +------------------------------------+
#           i                xntyp               i
#           +------------------------------------+
#           i                xnlen               i
#           +------------------------------------+
#           /                                    /
#           /                xndta               /
#           /                                    /
#           +------------------------------------+
#
xntyp   =    0              #pointer to dummy routine b_xnt} equ 0
xnlen   =    xntyp+1        #length of xnblk in bytes} equ xntyp+1
xndta   =    xnlen+1        #data words} equ xnlen+1
xnsi_   =    xndta          #size of standard fields in xnblk} equ xndta
#
#      note that the term non-relocatable refers to the contents
#      and not the block itself. an xnblk can be moved around if
#      it is built in the dynamic memory area.
                            #} ejc
        .eject
#
#      relocatable external block (xrblk)
#
#      an xrblk is a block representing an unknown (external)
#      data value. the data area in this block consists only
#      of address values and any addresses pointing into the
#      dynamic memory area must point to the start of other
#      data blocks. see also description of xnblk.
#      this type of block may be used as a file control block.
#      see sysfc,sysin,sysou,s$inp,s$oup for details.
#
#           +------------------------------------+
#           i                xrtyp               i
#           +------------------------------------+
#           i                xrlen               i
#           +------------------------------------+
#           /                                    /
#           /                xrptr               /
#           /                                    /
#           +------------------------------------+
#
xrtyp   =    0              #pointer to dummy routine b_xrt} equ 0
xrlen   =    xrtyp+1        #length of xrblk in bytes} equ xrtyp+1
xrptr   =    xrlen+1        #start of address pointers} equ xrlen+1
xrsi_   =    xrptr          #size of standard fields in xrblk} equ xrptr
                            #} ejc
        .eject
#
#      s$cnv (convert) function switch constants.  the values
#      are tied to the order of the entries in the svctb table
#      and hence to the branch table in s$cnv.
#
cnvst   =    8              #max standard type code for convert} equ 8
cnvrt   =    cnvst+1        #convert code for reals} equ cnvst+1
cnvbt   =    cnvrt          #no buffers - same as real code} equ cnvrt
cnvtt   =    cnvbt+1        #bsw code for convert} equ cnvbt+1
#
#      input image length
#
iniln   =    1024           #default image length for compiler} equ 1024
inils   =    1024           #image length if -sequ in effect} equ 1024
#
ionmb   =    2              #name base used for iochn in sysio} equ 2
ionmo   =    4              #name offset used for iochn in sysio} equ 4
#
#      minimum value for keyword maxlngth
#      should be larger than iniln
#
mnlen   =    1024           #min value allowed keyword maxlngth} equ 1024
mxern   =    329            #err num inadequate startup memory} equ 329
#
#      in general, meaningful mnemonics should be used for
#      offsets. however for small integers used often in
#      literals the following general definitions are provided.
#
num01   =    1              #} equ 1
num02   =    2              #} equ 2
num03   =    3              #} equ 3
num04   =    4              #} equ 4
num05   =    5              #} equ 5
num06   =    6              #} equ 6
num07   =    7              #} equ 7
num08   =    8              #} equ 8
num09   =    9              #} equ 9
num10   =    10             #} equ 10
nm320   =    320            #} equ 320
nm321   =    321            #} equ 321
nini8   =    998            #} equ 998
nini9   =    999            #} equ 999
thsnd   =    1000           #} equ 1000
                            #} ejc
        .eject
#
#      numbers of undefined spitbol operators
#
opbun   =    5              #no. of binary undefined ops} equ 5
opuun   =    6              #no of unary undefined ops} equ 6
#
#      offsets used in prtsn, prtmi and acess
#
prsnf   =    13             #offset used in prtsn} equ 13
prtmf   =    21             #offset to col 21 (prtmi)} equ 21
rilen   =    1024           #buffer length for sysri} equ 1024
#
#      codes for stages of processing
#
stgic   =    0              #initial compile} equ 0
stgxc   =    stgic+1        #execution compile (code)} equ stgic+1
stgev   =    stgxc+1        #expression eval during execution} equ stgxc+1
stgxt   =    stgev+1        #execution time} equ stgev+1
stgce   =    stgxt+1        #initial compile after end line} equ stgxt+1
stgxe   =    stgce+1        #exec. compile after end line} equ stgce+1
stgnd   =    stgce-stgic    #difference in stage after end} equ stgce-stgic
stgee   =    stgxe+1        #eval evaluating expression} equ stgxe+1
stgno   =    stgee+1        #number of codes} equ stgee+1
                            #} ejc
        .eject
#
#
#      statement number pad count for listr
#
stnpd   =    8              #statement no. pad count} equ 8
#
#      syntax type codes
#
#      these codes are returned from the scane procedure.
#
#      they are spaced 3 apart for the benefit of expan.
#
t_uop   =    0              #unary operator} equ 0
t_lpr   =    t_uop+3        #left paren} equ t_uop+3
t_lbr   =    t_lpr+3        #left bracket} equ t_lpr+3
t_cma   =    t_lbr+3        #comma} equ t_lbr+3
t_fnc   =    t_cma+3        #function call} equ t_cma+3
t_var   =    t_fnc+3        #variable} equ t_fnc+3
t_con   =    t_var+3        #constant} equ t_var+3
t_bop   =    t_con+3        #binary operator} equ t_con+3
t_rpr   =    t_bop+3        #right paren} equ t_bop+3
t_rbr   =    t_rpr+3        #right bracket} equ t_rpr+3
t_col   =    t_rbr+3        #colon} equ t_rbr+3
t_smc   =    t_col+3        #semi-colon} equ t_col+3
#
#      the following definitions are used only in the goto field
#
t_fgo   =    t_smc+1        #failure goto} equ t_smc+1
t_sgo   =    t_fgo+1        #success goto} equ t_fgo+1
#
#      the above codes are grouped so that codes for elements
#      which can legitimately immediately precede a unary
#      operator come first to facilitate operator syntax check.
#
t_uok   =    t_fnc          #last code ok before unary operator} equ t_fnc
                            #} ejc
        .eject
#
#      definitions of values for expan jump table
#
t_uo0   =    t_uop+0        #unary operator, state zero} equ t_uop+0
t_uo1   =    t_uop+1        #unary operator, state one} equ t_uop+1
t_uo2   =    t_uop+2        #unary operator, state two} equ t_uop+2
t_lp0   =    t_lpr+0        #left paren, state zero} equ t_lpr+0
t_lp1   =    t_lpr+1        #left paren, state one} equ t_lpr+1
t_lp2   =    t_lpr+2        #left paren, state two} equ t_lpr+2
t_lb0   =    t_lbr+0        #left bracket, state zero} equ t_lbr+0
t_lb1   =    t_lbr+1        #left bracket, state one} equ t_lbr+1
t_lb2   =    t_lbr+2        #left bracket, state two} equ t_lbr+2
t_cm0   =    t_cma+0        #comma, state zero} equ t_cma+0
t_cm1   =    t_cma+1        #comma, state one} equ t_cma+1
t_cm2   =    t_cma+2        #comma, state two} equ t_cma+2
t_fn0   =    t_fnc+0        #function call, state zero} equ t_fnc+0
t_fn1   =    t_fnc+1        #function call, state one} equ t_fnc+1
t_fn2   =    t_fnc+2        #function call, state two} equ t_fnc+2
t_va0   =    t_var+0        #variable, state zero} equ t_var+0
t_va1   =    t_var+1        #variable, state one} equ t_var+1
t_va2   =    t_var+2        #variable, state two} equ t_var+2
t_co0   =    t_con+0        #constant, state zero} equ t_con+0
t_co1   =    t_con+1        #constant, state one} equ t_con+1
t_co2   =    t_con+2        #constant, state two} equ t_con+2
t_bo0   =    t_bop+0        #binary operator, state zero} equ t_bop+0
t_bo1   =    t_bop+1        #binary operator, state one} equ t_bop+1
t_bo2   =    t_bop+2        #binary operator, state two} equ t_bop+2
t_rp0   =    t_rpr+0        #right paren, state zero} equ t_rpr+0
t_rp1   =    t_rpr+1        #right paren, state one} equ t_rpr+1
t_rp2   =    t_rpr+2        #right paren, state two} equ t_rpr+2
t_rb0   =    t_rbr+0        #right bracket, state zero} equ t_rbr+0
t_rb1   =    t_rbr+1        #right bracket, state one} equ t_rbr+1
t_rb2   =    t_rbr+2        #right bracket, state two} equ t_rbr+2
t_cl0   =    t_col+0        #colon, state zero} equ t_col+0
t_cl1   =    t_col+1        #colon, state one} equ t_col+1
t_cl2   =    t_col+2        #colon, state two} equ t_col+2
t_sm0   =    t_smc+0        #semicolon, state zero} equ t_smc+0
t_sm1   =    t_smc+1        #semicolon, state one} equ t_smc+1
t_sm2   =    t_smc+2        #semicolon, state two} equ t_smc+2
#
t_nes   =    t_sm2+1        #number of entries in branch table} equ t_sm2+1
                            #} ejc
        .eject
#
#       definition of offsets used in control card processing
#
cc_ca   =    0              #-case} equ 0
cc_do   =    cc_ca+1        #-double} equ cc_ca+1
cc_co   =    cc_do+1        #-compare} equ cc_do+1
cc_du   =    cc_co+1        #-dump} equ cc_co+1
cc_cp   =    cc_du+1        #-copy} equ cc_du+1
cc_ej   =    cc_cp+1        #-eject} equ cc_cp+1
cc_er   =    cc_ej+1        #-errors} equ cc_ej+1
cc_ex   =    cc_er+1        #-execute} equ cc_er+1
cc_fa   =    cc_ex+1        #-fail} equ cc_ex+1
cc_in   =    cc_fa+1        #-include} equ cc_fa+1
cc_ln   =    cc_in+1        #-line} equ cc_in+1
cc_li   =    cc_ln+1        #-list} equ cc_ln+1
cc_nr   =    cc_li+1        #-noerrors} equ cc_li+1
cc_nx   =    cc_nr+1        #-noexecute} equ cc_nr+1
cc_nf   =    cc_nx+1        #-nofail} equ cc_nx+1
cc_nl   =    cc_nf+1        #-nolist} equ cc_nf+1
cc_no   =    cc_nl+1        #-noopt} equ cc_nl+1
cc_np   =    cc_no+1        #-noprint} equ cc_no+1
cc_op   =    cc_np+1        #-optimise} equ cc_np+1
cc_pr   =    cc_op+1        #-print} equ cc_op+1
cc_si   =    cc_pr+1        #-single} equ cc_pr+1
cc_sp   =    cc_si+1        #-space} equ cc_si+1
cc_st   =    cc_sp+1        #-stitl} equ cc_sp+1
cc_ti   =    cc_st+1        #-title} equ cc_st+1
cc_tr   =    cc_ti+1        #-trace} equ cc_ti+1
cc_nc   =    cc_tr+1        #number of control cards} equ cc_tr+1
ccnoc   =    4              #no. of chars included in match} equ 4
ccofs   =    7              #offset to start of title/subtitle} equ 7
ccinm   =    9              #max depth of include file nesting} equ 9
                            #} ejc
        .eject
#
#      definitions of stack offsets used in cmpil procedure
#
#      see description at start of cmpil procedure for details
#      of use of these locations on the stack.
#
cmstm   =    0              #tree for statement body} equ 0
cmsgo   =    cmstm+1        #tree for success goto} equ cmstm+1
cmfgo   =    cmsgo+1        #tree for fail goto} equ cmsgo+1
cmcgo   =    cmfgo+1        #conditional goto flag} equ cmfgo+1
cmpcd   =    cmcgo+1        #previous cdblk pointer} equ cmcgo+1
cmffp   =    cmpcd+1        #failure fill in flag for previous} equ cmpcd+1
cmffc   =    cmffp+1        #failure fill in flag for current} equ cmffp+1
cmsop   =    cmffc+1        #success fill in offset for previous} equ cmffc+1
cmsoc   =    cmsop+1        #success fill in offset for current} equ cmsop+1
cmlbl   =    cmsoc+1        #ptr to vrblk for current label} equ cmsoc+1
cmtra   =    cmlbl+1        #ptr to entry cdblk} equ cmlbl+1
#
cmnen   =    cmtra+1        #count of stack entries for cmpil} equ cmtra+1
#
#      a few constants used by the profiler
pfpd1   =    8              #pad positions ...} equ 8
pfpd2   =    20             #... for profile ...} equ 20
pfpd3   =    32             #... printout} equ 32
pf_i2   =    cfp_i+cfp_i    #size of table entry (2 ints)} equ cfp_i+cfp_i
                            #} ejc
        .eject
#
#      definition of limits and adjustments that are built by
#      relcr for use by the routines that relocate pointers
#      after a save file is reloaded.  see reloc etc. for usage.
#
#      a block of information is built that is used in
#      relocating pointers.  there are rnsi$ instances
#      of a rssi$ word structure.  each instance corresponds
#      to one of the regions that a pointer might point into.
#
#      each structure takes the form:
#
#           +------------------------------------+
#           i    address past end of section     i
#           +------------------------------------+
#           i  adjustment from old to new adrs   i
#           +------------------------------------+
#           i    address of start of section     i
#           +------------------------------------+
#
#      the instances are ordered thusly:
#
#           +------------------------------------+
#           i           dynamic storage          i
#           +------------------------------------+
#           i           static storage           i
#           +------------------------------------+
#           i       working section globals      i
#           +------------------------------------+
#           i          constant section          i
#           +------------------------------------+
#           i            code section            i
#           +------------------------------------+
#
#      symbolic names for these locations as offsets from
#      the first entry are provided here.
#
#      definitions within a section
#
rlend   =    0              #end} equ 0
rladj   =    rlend+1        #adjustment} equ rlend+1
rlstr   =    rladj+1        #start} equ rladj+1
rssi_   =    rlstr+1        #size of section} equ rlstr+1
rnsi_   =    5              #number of structures} equ 5
#
#      overall definitions of all structures
#
rldye   =    0              #dynamic region end} equ 0
rldya   =    rldye+1        #dynamic region adjustment} equ rldye+1
rldys   =    rldya+1        #dynamic region start} equ rldya+1
rlste   =    rldys+1        #static region end} equ rldys+1
rlsta   =    rlste+1        #static region adjustment} equ rlste+1
rlsts   =    rlsta+1        #static region start} equ rlsta+1
rlwke   =    rlsts+1        #working section globals end} equ rlsts+1
rlwka   =    rlwke+1        #working section globals adjustment} equ rlwke+1
rlwks   =    rlwka+1        #working section globals start} equ rlwka+1
rlcne   =    rlwks+1        #constants section end} equ rlwks+1
rlcna   =    rlcne+1        #constants section adjustment} equ rlcne+1
rlcns   =    rlcna+1        #constants section start} equ rlcna+1
rlcde   =    rlcns+1        #code section end} equ rlcns+1
rlcda   =    rlcde+1        #code section adjustment} equ rlcde+1
rlcds   =    rlcda+1        #code section start} equ rlcda+1
rlsi_   =    rlcds+1        #number of fields in structure} equ rlcds+1
#
                            #} ttl s p i t b o l -- constant section
        .sbttl "s p i t b o l -- constant section"
#
#      this section consists entirely of assembled constants.
#
#      all label names are five letters. the order is
#      approximately alphabetical, but in some cases (always
#      documented), constants must be placed in some special
#      order which must not be disturbed.
#
#      it must also be remembered that there is a requirement
#      for no forward references which also disturbs the
#      alphabetical order in some cases.
#
                            #start of constant section} sec
        dsegend_
        dseg_
        .global sec03
sec03:
#
#      start of constant section
#
c_aaa:  .long 0             #first location of constant section} dac 0
#
#      free store percentage (used by alloc)
#
alfsp:  .long e_fsp         #free store percentage} dac e_fsp
#
#      bit constants for general use
#
bits0:  .long 0             #all zero bits} dbc 0
bits1:  .long 1             #one bit in low order position} dbc 1
bits2:  .long 2             #bit in position 2} dbc 2
bits3:  .long 4             #bit in position 3} dbc 4
bits4:  .long 8             #bit in position 4} dbc 8
bits5:  .long 16            #bit in position 5} dbc 16
bits6:  .long 32            #bit in position 6} dbc 32
bits7:  .long 64            #bit in position 7} dbc 64
bits8:  .long 128           #bit in position 8} dbc 128
bits9:  .long 256           #bit in position 9} dbc 256
bit10:  .long 512           #bit in position 10} dbc 512
bit11:  .long 1024          #bit in position 11} dbc 1024
bit12:  .long 2048          #bit in position 12} dbc 2048
bitsm:  .long cfp_m         #mask for max integer} dbc cfp_m
#
#      bit constants for svblk (svbit field) tests
#
btfnc:  .long svfnc         #bit to test for function} dbc svfnc
btknm:  .long svknm         #bit to test for keyword number} dbc svknm
btlbl:  .long svlbl         #bit to test for label} dbc svlbl
btffc:  .long svffc         #bit to test for fast call} dbc svffc
btckw:  .long svckw         #bit to test for constant keyword} dbc svckw
btkwv:  .long svkwv         #bits to test for keword with value} dbc svkwv
btprd:  .long svprd         #bit to test for predicate function} dbc svprd
btpre:  .long svpre         #bit to test for preevaluation} dbc svpre
btval:  .long svval         #bit to test for value} dbc svval
                            #} ejc
        .eject
#
#      list of names used for control card processing
#
ccnms:  .ascii "case"       #} dtc /case/
        .ascii "doub"       #} dtc /doub/
        .ascii "comp"       #} dtc /comp/
        .ascii "dump"       #} dtc /dump/
        .ascii "copy"       #} dtc /copy/
        .ascii "ejec"       #} dtc /ejec/
        .ascii "erro"       #} dtc /erro/
        .ascii "exec"       #} dtc /exec/
        .ascii "fail"       #} dtc /fail/
        .ascii "incl"       #} dtc /incl/
        .ascii "line"       #} dtc /line/
        .ascii "list"       #} dtc /list/
        .ascii "noer"       #} dtc /noer/
        .ascii "noex"       #} dtc /noex/
        .ascii "nofa"       #} dtc /nofa/
        .ascii "noli"       #} dtc /noli/
        .ascii "noop"       #} dtc /noop/
        .ascii "nopr"       #} dtc /nopr/
        .ascii "opti"       #} dtc /opti/
        .ascii "prin"       #} dtc /prin/
        .ascii "sing"       #} dtc /sing/
        .ascii "spac"       #} dtc /spac/
        .ascii "stit"       #} dtc /stit/
        .ascii "titl"       #} dtc /titl/
        .ascii "trac"       #} dtc /trac/
#
#      header messages for dumpr procedure (scblk format)
#
dmhdk:  .long b_scl         #dump of keyword values} dac b_scl
        .long 22            #} dac 22
        .ascii "dump of keyword values\x00\x00" #} dtc /dump of keyword values/
#
dmhdv:  .long b_scl         #dump of natural variables} dac b_scl
        .long 25            #} dac 25
        .ascii "dump of natural variables\x00\x00\x00" #} dtc /dump of natural variables/
                            #} ejc
        .eject
#
#      message text for compilation statistics
#
encm1:  .long b_scl         #} dac b_scl
        .long 19            #} dac 19
        .ascii "memory used (bytes)\x00" #} dtc /memory used (bytes)/
#
encm2:  .long b_scl         #} dac b_scl
        .long 19            #} dac 19
        .ascii "memory left (bytes)\x00" #} dtc /memory left (bytes)/
#
encm3:  .long b_scl         #} dac b_scl
        .long 11            #} dac 11
        .ascii "comp errors\x00" #} dtc /comp errors/
#
encm4:  .long b_scl         #} dac b_scl
        .long 20            #} dac 20
        .ascii "comp time (millisec)" #} dtc /comp time (millisec)/
#
encm5:  .long b_scl         #execution suppressed} dac b_scl
        .long 20            #} dac 20
        .ascii "execution suppressed" #} dtc /execution suppressed/
#
#      string constant for abnormal end
#
endab:  .long b_scl         #} dac b_scl
        .long 12            #} dac 12
        .ascii "abnormal end" #} dtc /abnormal end/
                            #} ejc
        .eject
#
#      memory overflow during initialisation
#
endmo:  .long b_scl         #} dac b_scl
endml:  .long 15            #} dac 15
        .ascii "memory overflow\x00" #} dtc /memory overflow/
#
#      string constant for message issued by l$end
#
endms:  .long b_scl         #} dac b_scl
        .long 10            #} dac 10
        .ascii "normal end\x00\x00" #} dtc /normal end/
#
#      fail message for stack fail section
#
endso:  .long b_scl         #stack overflow in garbage collector} dac b_scl
        .long 36            #} dac 36
        .ascii "stack overflow in garbage collection" #} dtc /stack overflow in garbage collection/
#
#      string constant for time up
#
endtu:  .long b_scl         #} dac b_scl
        .long 15            #} dac 15
        .ascii "error - time up\x00" #} dtc /error - time up/
                            #} ejc
        .eject
#
#      string constant for error message (error section)
#
ermms:  .long b_scl         #error} dac b_scl
        .long 5             #} dac 5
        .ascii "error\x00\x00\x00" #} dtc /error/
#
ermns:  .long b_scl         #string / -- /} dac b_scl
        .long 4             #} dac 4
        .ascii " -- "       #} dtc / -- /
#
#      string constant for page numbering
#
lstms:  .long b_scl         #page} dac b_scl
        .long 5             #} dac 5
        .ascii "page \x00\x00\x00" #} dtc /page /
#
#      listing header message
#
headr:  .long b_scl         #} dac b_scl
        .long 25            #} dac 25
        .ascii "macro spitbol version 3.8\x00\x00\x00" #} dtc /macro spitbol version 3.8/
#
headv:  .long b_scl         #for exit() version no. check} dac b_scl
        .long 5             #} dac 5
        .ascii "3.8.2\x00\x00\x00" #} dtc /3.8.2/
#      free store percentage (used by gbcol)
#
gbsdp:  .long e_sed         #sediment percentage} dac e_sed
#
#      integer constants for general use
#      icbld optimisation uses the first three.
#
int_r:  .long b_icl         #} dac b_icl
intv0:  .long +0            #0} dic +0
inton:  .long b_icl         #} dac b_icl
intv1:  .long +1            #1} dic +1
inttw:  .long b_icl         #} dac b_icl
intv2:  .long +2            #2} dic +2
intvt:  .long +10           #10} dic +10
intvh:  .long +100          #100} dic +100
intth:  .long +1000         #1000} dic +1000
#
#      table used in icbld optimisation
#
intab:  .long int_r         #pointer to 0} dac int_r
        .long inton         #pointer to 1} dac inton
        .long inttw         #pointer to 2} dac inttw
                            #} ejc
        .eject
#
#      special pattern nodes. the following pattern nodes
#      consist simply of a pcode pointer, see match routines
#      (p$xxx) for full details of their use and format).
#
ndabb:  .long p_abb         #arbno} dac p_abb
ndabd:  .long p_abd         #arbno} dac p_abd
ndarc:  .long p_arc         #arb} dac p_arc
ndexb:  .long p_exb         #expression} dac p_exb
ndfnb:  .long p_fnb         #fence()} dac p_fnb
ndfnd:  .long p_fnd         #fence()} dac p_fnd
ndexc:  .long p_exc         #expression} dac p_exc
ndimb:  .long p_imb         #immediate assignment} dac p_imb
ndimd:  .long p_imd         #immediate assignment} dac p_imd
ndnth:  .long p_nth         #pattern end (null pattern)} dac p_nth
ndpab:  .long p_pab         #pattern assignment} dac p_pab
ndpad:  .long p_pad         #pattern assignment} dac p_pad
nduna:  .long p_una         #anchor point movement} dac p_una
#
#      keyword constant pattern nodes. the following nodes are
#      used as the values of pattern keywords and the initial
#      values of the corresponding natural variables. all
#      nodes are in p0blk format and the order is tied to the
#      definitions of corresponding k$xxx symbols.
#
ndabo:  .long p_abo         #abort} dac p_abo
        .long ndnth         #} dac ndnth
ndarb:  .long p_arb         #arb} dac p_arb
        .long ndnth         #} dac ndnth
ndbal:  .long p_bal         #bal} dac p_bal
        .long ndnth         #} dac ndnth
ndfal:  .long p_fal         #fail} dac p_fal
        .long ndnth         #} dac ndnth
ndfen:  .long p_fen         #fence} dac p_fen
        .long ndnth         #} dac ndnth
ndrem:  .long p_rem         #rem} dac p_rem
        .long ndnth         #} dac ndnth
ndsuc:  .long p_suc         #succeed} dac p_suc
        .long ndnth         #} dac ndnth
#
#      null string. all null values point to this string. the
#      svchs field contains a blank to provide for easy default
#      processing in trace, stoptr, lpad and rpad.
#      nullw contains 10 blanks which ensures an all blank word
#      but for very exceptional machines.
#
nulls:  .long b_scl         #null string value} dac b_scl
        .long 0             #sclen = 0} dac 0
nullw:  .ascii "          \x00\x00" #} dtc /          /
#
#
#      constant strings for lcase and ucase keywords
#
lcase:  .long b_scl         #} dac b_scl
        .long 26            #} dac 26
        .ascii "abcdefghijklmnopqrstuvwxyz\x00\x00" #} dtc /abcdefghijklmnopqrstuvwxyz/
#
ucase:  .long b_scl         #} dac b_scl
        .long 26            #} dac 26
        .ascii "abcdefghijklmnopqrstuvwxyz\x00\x00" #} dtc /abcdefghijklmnopqrstuvwxyz/
                            #} ejc
        .eject
#
#      operator dope vectors (see dvblk format)
#
opdvc:  .long o_cnc         #concatenation} dac o_cnc
        .long c_cnc         #} dac c_cnc
        .long llcnc         #} dac llcnc
        .long rrcnc         #} dac rrcnc
#
#      opdvs is used when scanning below the top level to
#      insure that the concatenation will not be later
#      mistaken for pattern matching
#
opdvp:  .long o_cnc         #concatenation - not pattern match} dac o_cnc
        .long c_cnp         #} dac c_cnp
        .long llcnc         #} dac llcnc
        .long rrcnc         #} dac rrcnc
#
#      note that the order of the remaining entries is tied to
#      the order of the coding in the scane procedure.
#
opdvs:  .long o_ass         #assignment} dac o_ass
        .long c_ass         #} dac c_ass
        .long llass         #} dac llass
        .long rrass         #} dac rrass
#
        .long 6             #unary equal} dac 6
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_pmv         #pattern match} dac o_pmv
        .long c_pmt         #} dac c_pmt
        .long llpmt         #} dac llpmt
        .long rrpmt         #} dac rrpmt
#
        .long o_int         #interrogation} dac o_int
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
        .long 1             #binary ampersand} dac 1
        .long c_ubo         #} dac c_ubo
        .long llamp         #} dac llamp
        .long rramp         #} dac rramp
#
        .long o_kwv         #keyword reference} dac o_kwv
        .long c_key         #} dac c_key
        .long lluno         #} dac lluno
#
        .long o_alt         #alternation} dac o_alt
        .long c_alt         #} dac c_alt
        .long llalt         #} dac llalt
        .long rralt         #} dac rralt
                            #} ejc
        .eject
#
#      operator dope vectors (continued)
#
        .long 5             #unary vertical bar} dac 5
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long 0             #binary at} dac 0
        .long c_ubo         #} dac c_ubo
        .long llats         #} dac llats
        .long rrats         #} dac rrats
#
        .long o_cas         #cursor assignment} dac o_cas
        .long c_unm         #} dac c_unm
        .long lluno         #} dac lluno
#
        .long 2             #binary number sign} dac 2
        .long c_ubo         #} dac c_ubo
        .long llnum         #} dac llnum
        .long rrnum         #} dac rrnum
#
        .long 7             #unary number sign} dac 7
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_dvd         #division} dac o_dvd
        .long c_bvl         #} dac c_bvl
        .long lldvd         #} dac lldvd
        .long rrdvd         #} dac rrdvd
#
        .long 9             #unary slash} dac 9
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_mlt         #multiplication} dac o_mlt
        .long c_bvl         #} dac c_bvl
        .long llmlt         #} dac llmlt
        .long rrmlt         #} dac rrmlt
                            #} ejc
        .eject
#
#      operator dope vectors (continued)
#
        .long 0             #deferred expression} dac 0
        .long c_def         #} dac c_def
        .long lluno         #} dac lluno
#
        .long 3             #binary percent} dac 3
        .long c_ubo         #} dac c_ubo
        .long llpct         #} dac llpct
        .long rrpct         #} dac rrpct
#
        .long 8             #unary percent} dac 8
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_exp         #exponentiation} dac o_exp
        .long c_bvl         #} dac c_bvl
        .long llexp         #} dac llexp
        .long rrexp         #} dac rrexp
#
        .long 10            #unary exclamation} dac 10
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_ima         #immediate assignment} dac o_ima
        .long c_bvn         #} dac c_bvn
        .long lldld         #} dac lldld
        .long rrdld         #} dac rrdld
#
        .long o_inv         #indirection} dac o_inv
        .long c_ind         #} dac c_ind
        .long lluno         #} dac lluno
#
        .long 4             #binary not} dac 4
        .long c_ubo         #} dac c_ubo
        .long llnot         #} dac llnot
        .long rrnot         #} dac rrnot
#
        .long 0             #negation} dac 0
        .long c_neg         #} dac c_neg
        .long lluno         #} dac lluno
                            #} ejc
        .eject
#
#      operator dope vectors (continued)
#
        .long o_sub         #subtraction} dac o_sub
        .long c_bvl         #} dac c_bvl
        .long llplm         #} dac llplm
        .long rrplm         #} dac rrplm
#
        .long o_com         #complementation} dac o_com
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
        .long o_add         #addition} dac o_add
        .long c_bvl         #} dac c_bvl
        .long llplm         #} dac llplm
        .long rrplm         #} dac rrplm
#
        .long o_aff         #affirmation} dac o_aff
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
        .long o_pas         #pattern assignment} dac o_pas
        .long c_bvn         #} dac c_bvn
        .long lldld         #} dac lldld
        .long rrdld         #} dac rrdld
#
        .long o_nam         #name reference} dac o_nam
        .long c_unm         #} dac c_unm
        .long lluno         #} dac lluno
#
#      special dvs for goto operators (see procedure scngf)
#
opdvd:  .long o_god         #direct goto} dac o_god
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
opdvn:  .long o_goc         #complex normal goto} dac o_goc
        .long c_unm         #} dac c_unm
        .long lluno         #} dac lluno
                            #} ejc
        .eject
#
#      operator entry address pointers, used in code
#
oamn_:  .long o_amn         #array ref (multi-subs by value)} dac o_amn
oamv_:  .long o_amv         #array ref (multi-subs by value)} dac o_amv
oaon_:  .long o_aon         #array ref (one sub by name)} dac o_aon
oaov_:  .long o_aov         #array ref (one sub by value)} dac o_aov
ocer_:  .long o_cer         #compilation error} dac o_cer
ofex_:  .long o_fex         #failure in expression evaluation} dac o_fex
ofif_:  .long o_fif         #failure during goto evaluation} dac o_fif
ofnc_:  .long o_fnc         #function call (more than one arg)} dac o_fnc
ofne_:  .long o_fne         #function name error} dac o_fne
ofns_:  .long o_fns         #function call (single argument)} dac o_fns
ogof_:  .long o_gof         #set goto failure trap} dac o_gof
oinn_:  .long o_inn         #indirection by name} dac o_inn
okwn_:  .long o_kwn         #keyword reference by name} dac o_kwn
olex_:  .long o_lex         #load expression by name} dac o_lex
olpt_:  .long o_lpt         #load pattern} dac o_lpt
olvn_:  .long o_lvn         #load variable name} dac o_lvn
onta_:  .long o_nta         #negation, first entry} dac o_nta
ontb_:  .long o_ntb         #negation, second entry} dac o_ntb
ontc_:  .long o_ntc         #negation, third entry} dac o_ntc
opmn_:  .long o_pmn         #pattern match by name} dac o_pmn
opms_:  .long o_pms         #pattern match (statement)} dac o_pms
opop_:  .long o_pop         #pop top stack item} dac o_pop
ornm_:  .long o_rnm         #return name from expression} dac o_rnm
orpl_:  .long o_rpl         #pattern replacement} dac o_rpl
orvl_:  .long o_rvl         #return value from expression} dac o_rvl
osla_:  .long o_sla         #selection, first entry} dac o_sla
oslb_:  .long o_slb         #selection, second entry} dac o_slb
oslc_:  .long o_slc         #selection, third entry} dac o_slc
osld_:  .long o_sld         #selection, fourth entry} dac o_sld
ostp_:  .long o_stp         #stop execution} dac o_stp
ounf_:  .long o_unf         #unexpected failure} dac o_unf
                            #} ejc
        .eject
#
#      table of names of undefined binary operators for opsyn
#
opsnb:  .long ch_at         #at} dac ch_at
        .long ch_am         #ampersand} dac ch_am
        .long ch_nm         #number} dac ch_nm
        .long ch_pc         #percent} dac ch_pc
        .long ch_nt         #not} dac ch_nt
#
#      table of names of undefined unary operators for opsyn
#
opnsu:  .long ch_br         #vertical bar} dac ch_br
        .long ch_eq         #equal} dac ch_eq
        .long ch_nm         #number} dac ch_nm
        .long ch_pc         #percent} dac ch_pc
        .long ch_sl         #slash} dac ch_sl
        .long ch_ex         #exclamation} dac ch_ex
#
#      address const containing profile table entry size
#
pfi2a:  .long pf_i2         #} dac pf_i2
#
#      profiler message strings
#
pfms1:  .long b_scl         #} dac b_scl
        .long 15            #} dac 15
        .ascii "program profile\x00" #} dtc /program profile/
pfms2:  .long b_scl         #} dac b_scl
        .long 42            #} dac 42
        .ascii "stmt    number of     -- execution time --\x00\x00" #} dtc /stmt    number of     -- execution time --/
pfms3:  .long b_scl         #} dac b_scl
        .long 47            #} dac 47
        .ascii "number  executions  total(msec) per excn(mcsec)\x00" #} dtc /number  executions  total(msec) per excn(mcsec)/
#
#
#      real constants for general use. note that the constants
#      starting at reav1 form a powers of ten table (used in
#      gtnum and gtstg)
#
        .balign 4           #0.0} drc +0.0
reav0:  .double 0e0.0
        .balign 4           #0.1} drc +0.1
reap1:  .double 0e0.1
        .balign 4           #0.5} drc +0.5
reap5:  .double 0e0.5
        .balign 4           #10**0} drc +1.0
reav1:  .double 0e1.0
        .balign 4           #10**1} drc +1.0e+1
reavt:  .double 0e1.0e+1
        .balign 4           #10**2} drc +1.0e+2
        .double 0e1.0e+2
        .balign 4           #10**3} drc +1.0e+3
        .double 0e1.0e+3
        .balign 4           #10**4} drc +1.0e+4
        .double 0e1.0e+4
        .balign 4           #10**5} drc +1.0e+5
        .double 0e1.0e+5
        .balign 4           #10**6} drc +1.0e+6
        .double 0e1.0e+6
        .balign 4           #10**7} drc +1.0e+7
        .double 0e1.0e+7
        .balign 4           #10**8} drc +1.0e+8
        .double 0e1.0e+8
        .balign 4           #10**9} drc +1.0e+9
        .double 0e1.0e+9
        .balign 4           #10**10} drc +1.0e+10
reatt:  .double 0e1.0e+10
                            #} ejc
        .eject
#
#      string constants (scblk format) for dtype procedure
#
scarr:  .long b_scl         #array} dac b_scl
        .long 5             #} dac 5
        .ascii "array\x00\x00\x00" #} dtc /array/
#
sccod:  .long b_scl         #code} dac b_scl
        .long 4             #} dac 4
        .ascii "code"       #} dtc /code/
#
scexp:  .long b_scl         #expression} dac b_scl
        .long 10            #} dac 10
        .ascii "expression\x00\x00" #} dtc /expression/
#
scext:  .long b_scl         #external} dac b_scl
        .long 8             #} dac 8
        .ascii "external"   #} dtc /external/
#
scint:  .long b_scl         #integer} dac b_scl
        .long 7             #} dac 7
        .ascii "integer\x00" #} dtc /integer/
#
scnam:  .long b_scl         #name} dac b_scl
        .long 4             #} dac 4
        .ascii "name"       #} dtc /name/
#
scnum:  .long b_scl         #numeric} dac b_scl
        .long 7             #} dac 7
        .ascii "numeric\x00" #} dtc /numeric/
#
scpat:  .long b_scl         #pattern} dac b_scl
        .long 7             #} dac 7
        .ascii "pattern\x00" #} dtc /pattern/
#
screa:  .long b_scl         #real} dac b_scl
        .long 4             #} dac 4
        .ascii "real"       #} dtc /real/
#
scstr:  .long b_scl         #string} dac b_scl
        .long 6             #} dac 6
        .ascii "string\x00\x00" #} dtc /string/
#
sctab:  .long b_scl         #table} dac b_scl
        .long 5             #} dac 5
        .ascii "table\x00\x00\x00" #} dtc /table/
scfil:  .long b_scl         #file (for extended load arguments)} dac b_scl
        .long 4             #} dac 4
        .ascii "file"       #} dtc /file/
                            #} ejc
        .eject
#
#      string constants (scblk format) for kvrtn (see retrn)
#
scfrt:  .long b_scl         #freturn} dac b_scl
        .long 7             #} dac 7
        .ascii "freturn\x00" #} dtc /freturn/
#
scnrt:  .long b_scl         #nreturn} dac b_scl
        .long 7             #} dac 7
        .ascii "nreturn\x00" #} dtc /nreturn/
#
scrtn:  .long b_scl         #return} dac b_scl
        .long 6             #} dac 6
        .ascii "return\x00\x00" #} dtc /return/
#
#      datatype name table for dtype procedure. the order of
#      these entries is tied to the b$xxx definitions for blocks
#
#      note that slots for buffer and real data types are filled
#      even if these data types are conditionalized out of the
#      implementation.  this is done so that the block numbering
#      at bl$ar etc. remains constant in all versions.
#
scnmt:  .long scarr         #arblk     array} dac scarr
        .long sccod         #cdblk     code} dac sccod
        .long scexp         #exblk     expression} dac scexp
        .long scint         #icblk     integer} dac scint
        .long scnam         #nmblk     name} dac scnam
        .long scpat         #p0blk     pattern} dac scpat
        .long scpat         #p1blk     pattern} dac scpat
        .long scpat         #p2blk     pattern} dac scpat
        .long screa         #rcblk     real} dac screa
        .long scstr         #scblk     string} dac scstr
        .long scexp         #seblk     expression} dac scexp
        .long sctab         #tbblk     table} dac sctab
        .long scarr         #vcblk     array} dac scarr
        .long scext         #xnblk     external} dac scext
        .long scext         #xrblk     external} dac scext
        .long nulls         #bfblk     no buffer in this version} dac nulls
#
#      string constant for real zero
#
scre0:  .long b_scl         #} dac b_scl
        .long 2             #} dac 2
        .ascii "0.\x00\x00" #} dtc /0./
                            #} ejc
        .eject
#
#      used to re-initialise kvstl
#
stlim:  .long +2147483647   #default statement limit} dic +2147483647
#
#      dummy function block used for undefined functions
#
stndf:  .long o_fun         #ptr to undefined function err call} dac o_fun
        .long 0             #dummy fargs count for call circuit} dac 0
#
#      dummy code block used for undefined labels
#
stndl:  .long l_und         #code ptr points to undefined lbl} dac l_und
#
#      dummy operator block used for undefined operators
#
stndo:  .long o_oun         #ptr to undefined operator err call} dac o_oun
        .long 0             #dummy fargs count for call circuit} dac 0
#
#      standard variable block. this block is used to initialize
#      the first seven fields of a newly constructed vrblk.
#      its format is tied to the vrblk definitions (see gtnvr).
#
stnvr:  .long b_vrl         #vrget} dac b_vrl
        .long b_vrs         #vrsto} dac b_vrs
        .long nulls         #vrval} dac nulls
        .long b_vrg         #vrtra} dac b_vrg
        .long stndl         #vrlbl} dac stndl
        .long stndf         #vrfnc} dac stndf
        .long 0             #vrnxt} dac 0
                            #} ejc
        .eject
#
#      messages used in end of run processing (stopr)
#
stpm1:  .long b_scl         #in statement} dac b_scl
        .long 12            #} dac 12
        .ascii "in statement" #} dtc /in statement/
#
stpm2:  .long b_scl         #} dac b_scl
        .long 14            #} dac 14
        .ascii "stmts executed\x00\x00" #} dtc /stmts executed/
#
stpm3:  .long b_scl         #} dac b_scl
        .long 19            #} dac 19
        .ascii "run time (millisec)\x00" #} dtc /run time (millisec)/
#
stpm4:  .long b_scl         #} dac b_scl
        .long 12            #} dac 12
        .ascii "mcsec / stmt" #} dtc _mcsec / stmt_
#
stpm5:  .long b_scl         #} dac b_scl
        .long 13            #} dac 13
        .ascii "regenerations\x00\x00\x00" #} dtc /regenerations/
#
stpm6:  .long b_scl         #in line} dac b_scl
        .long 7             #} dac 7
        .ascii "in line\x00" #} dtc /in line/
#
stpm7:  .long b_scl         #in file} dac b_scl
        .long 7             #} dac 7
        .ascii "in file\x00" #} dtc /in file/
#
#      chars for /tu/ ending code
#
strtu:  .ascii "tu\x00\x00" #} dtc /tu/
#
#      table used by convert function to check datatype name
#      the entries are ordered to correspond to branch table
#      in s$cnv
#
svctb:  .long scstr         #string} dac scstr
        .long scint         #integer} dac scint
        .long scnam         #name} dac scnam
        .long scpat         #pattern} dac scpat
        .long scarr         #array} dac scarr
        .long sctab         #table} dac sctab
        .long scexp         #expression} dac scexp
        .long sccod         #code} dac sccod
        .long scnum         #numeric} dac scnum
        .long screa         #real} dac screa
        .long 0             #zero marks end of list} dac 0
                            #} ejc
        .eject
#
#      messages (scblk format) used by trace procedures
#
#
tmasb:  .long b_scl         #asterisks for trace statement no} dac b_scl
        .long 13            #} dac 13
        .ascii "************ \x00\x00\x00" #} dtc /************ /
#
tmbeb:  .long b_scl         #blank-equal-blank} dac b_scl
        .long 3             #} dac 3
        .ascii " = \x00"    #} dtc / = /
#
#      dummy trblk for expression variable
#
trbev:  .long b_trt         #dummy trblk} dac b_trt
#
#      dummy trblk for keyword variable
#
trbkv:  .long b_trt         #dummy trblk} dac b_trt
#
#      dummy code block to return control to trxeq procedure
#
trxdr:  .long o_txr         #block points to return routine} dac o_txr
trxdc:  .long trxdr         #pointer to block} dac trxdr
                            #} ejc
        .eject
#
#      standard variable blocks
#
#      see svblk format for full details of the format. the
#      vrblks are ordered by length and within each length the
#      order is alphabetical by name of the variable.
#
v_eqf:  .long svfpr         #eq} dbc svfpr
        .long 2             #} dac 2
        .ascii "eq\x00\x00" #} dtc /eq/
        .long s_eqf         #} dac s_eqf
        .long 2             #} dac 2
#
v_gef:  .long svfpr         #ge} dbc svfpr
        .long 2             #} dac 2
        .ascii "ge\x00\x00" #} dtc /ge/
        .long s_gef         #} dac s_gef
        .long 2             #} dac 2
#
v_gtf:  .long svfpr         #gt} dbc svfpr
        .long 2             #} dac 2
        .ascii "gt\x00\x00" #} dtc /gt/
        .long s_gtf         #} dac s_gtf
        .long 2             #} dac 2
#
v_lef:  .long svfpr         #le} dbc svfpr
        .long 2             #} dac 2
        .ascii "le\x00\x00" #} dtc /le/
        .long s_lef         #} dac s_lef
        .long 2             #} dac 2
#
v_lnf:  .long svfnp         #ln} dbc svfnp
        .long 2             #} dac 2
        .ascii "ln\x00\x00" #} dtc /ln/
        .long s_lnf         #} dac s_lnf
        .long 1             #} dac 1
#
v_ltf:  .long svfpr         #lt} dbc svfpr
        .long 2             #} dac 2
        .ascii "lt\x00\x00" #} dtc /lt/
        .long s_ltf         #} dac s_ltf
        .long 2             #} dac 2
#
v_nef:  .long svfpr         #ne} dbc svfpr
        .long 2             #} dac 2
        .ascii "ne\x00\x00" #} dtc /ne/
        .long s_nef         #} dac s_nef
        .long 2             #} dac 2
#
v_any:  .long svfnp         #any} dbc svfnp
        .long 3             #} dac 3
        .ascii "any\x00"    #} dtc /any/
        .long s_any         #} dac s_any
        .long 1             #} dac 1
#
v_arb:  .long svkvc         #arb} dbc svkvc
        .long 3             #} dac 3
        .ascii "arb\x00"    #} dtc /arb/
        .long k_arb         #} dac k_arb
        .long ndarb         #} dac ndarb
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_arg:  .long svfnn         #arg} dbc svfnn
        .long 3             #} dac 3
        .ascii "arg\x00"    #} dtc /arg/
        .long s_arg         #} dac s_arg
        .long 2             #} dac 2
#
v_bal:  .long svkvc         #bal} dbc svkvc
        .long 3             #} dac 3
        .ascii "bal\x00"    #} dtc /bal/
        .long k_bal         #} dac k_bal
        .long ndbal         #} dac ndbal
#
v_cos:  .long svfnp         #cos} dbc svfnp
        .long 3             #} dac 3
        .ascii "cos\x00"    #} dtc /cos/
        .long s_cos         #} dac s_cos
        .long 1             #} dac 1
#
v_end:  .long svlbl         #end} dbc svlbl
        .long 3             #} dac 3
        .ascii "end\x00"    #} dtc /end/
        .long l_end         #} dac l_end
#
v_exp:  .long svfnp         #exp} dbc svfnp
        .long 3             #} dac 3
        .ascii "exp\x00"    #} dtc /exp/
        .long s_exp         #} dac s_exp
        .long 1             #} dac 1
#
v_len:  .long svfnp         #len} dbc svfnp
        .long 3             #} dac 3
        .ascii "len\x00"    #} dtc /len/
        .long s_len         #} dac s_len
        .long 1             #} dac 1
#
v_leq:  .long svfpr         #leq} dbc svfpr
        .long 3             #} dac 3
        .ascii "leq\x00"    #} dtc /leq/
        .long s_leq         #} dac s_leq
        .long 2             #} dac 2
#
v_lge:  .long svfpr         #lge} dbc svfpr
        .long 3             #} dac 3
        .ascii "lge\x00"    #} dtc /lge/
        .long s_lge         #} dac s_lge
        .long 2             #} dac 2
#
v_lgt:  .long svfpr         #lgt} dbc svfpr
        .long 3             #} dac 3
        .ascii "lgt\x00"    #} dtc /lgt/
        .long s_lgt         #} dac s_lgt
        .long 2             #} dac 2
#
v_lle:  .long svfpr         #lle} dbc svfpr
        .long 3             #} dac 3
        .ascii "lle\x00"    #} dtc /lle/
        .long s_lle         #} dac s_lle
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_llt:  .long svfpr         #llt} dbc svfpr
        .long 3             #} dac 3
        .ascii "llt\x00"    #} dtc /llt/
        .long s_llt         #} dac s_llt
        .long 2             #} dac 2
#
v_lne:  .long svfpr         #lne} dbc svfpr
        .long 3             #} dac 3
        .ascii "lne\x00"    #} dtc /lne/
        .long s_lne         #} dac s_lne
        .long 2             #} dac 2
#
v_pos:  .long svfnp         #pos} dbc svfnp
        .long 3             #} dac 3
        .ascii "pos\x00"    #} dtc /pos/
        .long s_pos         #} dac s_pos
        .long 1             #} dac 1
#
v_rem:  .long svkvc         #rem} dbc svkvc
        .long 3             #} dac 3
        .ascii "rem\x00"    #} dtc /rem/
        .long k_rem         #} dac k_rem
        .long ndrem         #} dac ndrem
#
v_set:  .long svfnn         #set} dbc svfnn
        .long 3             #} dac 3
        .ascii "set\x00"    #} dtc /set/
        .long s_set         #} dac s_set
        .long 3             #} dac 3
#
v_sin:  .long svfnp         #sin} dbc svfnp
        .long 3             #} dac 3
        .ascii "sin\x00"    #} dtc /sin/
        .long s_sin         #} dac s_sin
        .long 1             #} dac 1
#
v_tab:  .long svfnp         #tab} dbc svfnp
        .long 3             #} dac 3
        .ascii "tab\x00"    #} dtc /tab/
        .long s_tab         #} dac s_tab
        .long 1             #} dac 1
#
v_tan:  .long svfnp         #tan} dbc svfnp
        .long 3             #} dac 3
        .ascii "tan\x00"    #} dtc /tan/
        .long s_tan         #} dac s_tan
        .long 1             #} dac 1
#
v_atn:  .long svfnp         #atan} dbc svfnp
        .long 4             #} dac 4
        .ascii "atan"       #} dtc /atan/
        .long s_atn         #} dac s_atn
        .long 1             #} dac 1
#
v_cas:  .long svknm         #case} dbc svknm
        .long 4             #} dac 4
        .ascii "case"       #} dtc /case/
        .long k_cas         #} dac k_cas
#
v_chr:  .long svfnp         #char} dbc svfnp
        .long 4             #} dac 4
        .ascii "char"       #} dtc /char/
        .long s_chr         #} dac s_chr
        .long 1             #} dac 1
#
#
v_chp:  .long svfnp         #chop} dbc svfnp
        .long 4             #} dac 4
        .ascii "chop"       #} dtc /chop/
        .long s_chp         #} dac s_chp
        .long 1             #} dac 1
v_cod:  .long svfnk         #code} dbc svfnk
        .long 4             #} dac 4
        .ascii "code"       #} dtc /code/
        .long k_cod         #} dac k_cod
        .long s_cod         #} dac s_cod
        .long 1             #} dac 1
#
v_cop:  .long svfnn         #copy} dbc svfnn
        .long 4             #} dac 4
        .ascii "copy"       #} dtc /copy/
        .long s_cop         #} dac s_cop
        .long 1             #} dac 1
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_dat:  .long svfnn         #data} dbc svfnn
        .long 4             #} dac 4
        .ascii "data"       #} dtc /data/
        .long s_dat         #} dac s_dat
        .long 1             #} dac 1
#
v_dte:  .long svfnn         #date} dbc svfnn
        .long 4             #} dac 4
        .ascii "date"       #} dtc /date/
        .long s_dte         #} dac s_dte
        .long 1             #} dac 1
#
v_dmp:  .long svfnk         #dump} dbc svfnk
        .long 4             #} dac 4
        .ascii "dump"       #} dtc /dump/
        .long k_dmp         #} dac k_dmp
        .long s_dmp         #} dac s_dmp
        .long 1             #} dac 1
#
v_dup:  .long svfnn         #dupl} dbc svfnn
        .long 4             #} dac 4
        .ascii "dupl"       #} dtc /dupl/
        .long s_dup         #} dac s_dup
        .long 2             #} dac 2
#
v_evl:  .long svfnn         #eval} dbc svfnn
        .long 4             #} dac 4
        .ascii "eval"       #} dtc /eval/
        .long s_evl         #} dac s_evl
        .long 1             #} dac 1
#
v_ext:  .long svfnn         #exit} dbc svfnn
        .long 4             #} dac 4
        .ascii "exit"       #} dtc /exit/
        .long s_ext         #} dac s_ext
        .long 2             #} dac 2
#
v_fal:  .long svkvc         #fail} dbc svkvc
        .long 4             #} dac 4
        .ascii "fail"       #} dtc /fail/
        .long k_fal         #} dac k_fal
        .long ndfal         #} dac ndfal
#
v_fil:  .long svknm         #file} dbc svknm
        .long 4             #} dac 4
        .ascii "file"       #} dtc /file/
        .long k_fil         #} dac k_fil
#
v_hst:  .long svfnn         #host} dbc svfnn
        .long 4             #} dac 4
        .ascii "host"       #} dtc /host/
        .long s_hst         #} dac s_hst
        .long 5             #} dac 5
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_itm:  .long svfnf         #item} dbc svfnf
        .long 4             #} dac 4
        .ascii "item"       #} dtc /item/
        .long s_itm         #} dac s_itm
        .long 999           #} dac 999
#
v_lin:  .long svknm         #line} dbc svknm
        .long 4             #} dac 4
        .ascii "line"       #} dtc /line/
        .long k_lin         #} dac k_lin
#
v_lod:  .long svfnn         #load} dbc svfnn
        .long 4             #} dac 4
        .ascii "load"       #} dtc /load/
        .long s_lod         #} dac s_lod
        .long 2             #} dac 2
#
v_lpd:  .long svfnp         #lpad} dbc svfnp
        .long 4             #} dac 4
        .ascii "lpad"       #} dtc /lpad/
        .long s_lpd         #} dac s_lpd
        .long 3             #} dac 3
#
v_rpd:  .long svfnp         #rpad} dbc svfnp
        .long 4             #} dac 4
        .ascii "rpad"       #} dtc /rpad/
        .long s_rpd         #} dac s_rpd
        .long 3             #} dac 3
#
v_rps:  .long svfnp         #rpos} dbc svfnp
        .long 4             #} dac 4
        .ascii "rpos"       #} dtc /rpos/
        .long s_rps         #} dac s_rps
        .long 1             #} dac 1
#
v_rtb:  .long svfnp         #rtab} dbc svfnp
        .long 4             #} dac 4
        .ascii "rtab"       #} dtc /rtab/
        .long s_rtb         #} dac s_rtb
        .long 1             #} dac 1
#
v_si_:  .long svfnp         #size} dbc svfnp
        .long 4             #} dac 4
        .ascii "size"       #} dtc /size/
        .long s_si_         #} dac s_si_
        .long 1             #} dac 1
#
#
v_srt:  .long svfnn         #sort} dbc svfnn
        .long 4             #} dac 4
        .ascii "sort"       #} dtc /sort/
        .long s_srt         #} dac s_srt
        .long 2             #} dac 2
v_spn:  .long svfnp         #span} dbc svfnp
        .long 4             #} dac 4
        .ascii "span"       #} dtc /span/
        .long s_spn         #} dac s_spn
        .long 1             #} dac 1
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
#
v_sqr:  .long svfnp         #sqrt} dbc svfnp
        .long 4             #} dac 4
        .ascii "sqrt"       #} dtc /sqrt/
        .long s_sqr         #} dac s_sqr
        .long 1             #} dac 1
v_stn:  .long svknm         #stno} dbc svknm
        .long 4             #} dac 4
        .ascii "stno"       #} dtc /stno/
        .long k_stn         #} dac k_stn
#
v_tim:  .long svfnn         #time} dbc svfnn
        .long 4             #} dac 4
        .ascii "time"       #} dtc /time/
        .long s_tim         #} dac s_tim
        .long 0             #} dac 0
#
v_trm:  .long svfnk         #trim} dbc svfnk
        .long 4             #} dac 4
        .ascii "trim"       #} dtc /trim/
        .long k_trm         #} dac k_trm
        .long s_trm         #} dac s_trm
        .long 1             #} dac 1
#
v_abe:  .long svknm         #abend} dbc svknm
        .long 5             #} dac 5
        .ascii "abend\x00\x00\x00" #} dtc /abend/
        .long k_abe         #} dac k_abe
#
v_abo:  .long svkvl         #abort} dbc svkvl
        .long 5             #} dac 5
        .ascii "abort\x00\x00\x00" #} dtc /abort/
        .long k_abo         #} dac k_abo
        .long l_abo         #} dac l_abo
        .long ndabo         #} dac ndabo
#
v_app:  .long svfnf         #apply} dbc svfnf
        .long 5             #} dac 5
        .ascii "apply\x00\x00\x00" #} dtc /apply/
        .long s_app         #} dac s_app
        .long 999           #} dac 999
#
v_abn:  .long svfnp         #arbno} dbc svfnp
        .long 5             #} dac 5
        .ascii "arbno\x00\x00\x00" #} dtc /arbno/
        .long s_abn         #} dac s_abn
        .long 1             #} dac 1
#
v_arr:  .long svfnn         #array} dbc svfnn
        .long 5             #} dac 5
        .ascii "array\x00\x00\x00" #} dtc /array/
        .long s_arr         #} dac s_arr
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_brk:  .long svfnp         #break} dbc svfnp
        .long 5             #} dac 5
        .ascii "break\x00\x00\x00" #} dtc /break/
        .long s_brk         #} dac s_brk
        .long 1             #} dac 1
#
v_clr:  .long svfnn         #clear} dbc svfnn
        .long 5             #} dac 5
        .ascii "clear\x00\x00\x00" #} dtc /clear/
        .long s_clr         #} dac s_clr
        .long 1             #} dac 1
#
v_ejc:  .long svfnn         #eject} dbc svfnn
        .long 5             #} dac 5
        .ascii "eject\x00\x00\x00" #} dtc /eject/
        .long s_ejc         #} dac s_ejc
        .long 1             #} dac 1
#
v_fen:  .long svfpk         #fence} dbc svfpk
        .long 5             #} dac 5
        .ascii "fence\x00\x00\x00" #} dtc /fence/
        .long k_fen         #} dac k_fen
        .long s_fnc         #} dac s_fnc
        .long 1             #} dac 1
        .long ndfen         #} dac ndfen
#
v_fld:  .long svfnn         #field} dbc svfnn
        .long 5             #} dac 5
        .ascii "field\x00\x00\x00" #} dtc /field/
        .long s_fld         #} dac s_fld
        .long 2             #} dac 2
#
v_idn:  .long svfpr         #ident} dbc svfpr
        .long 5             #} dac 5
        .ascii "ident\x00\x00\x00" #} dtc /ident/
        .long s_idn         #} dac s_idn
        .long 2             #} dac 2
#
v_inp:  .long svfnk         #input} dbc svfnk
        .long 5             #} dac 5
        .ascii "input\x00\x00\x00" #} dtc /input/
        .long k_inp         #} dac k_inp
        .long s_inp         #} dac s_inp
        .long 3             #} dac 3
#
v_lcs:  .long svkwc         #lcase} dbc svkwc
        .long 5             #} dac 5
        .ascii "lcase\x00\x00\x00" #} dtc /lcase/
        .long k_lcs         #} dac k_lcs
#
v_loc:  .long svfnn         #local} dbc svfnn
        .long 5             #} dac 5
        .ascii "local\x00\x00\x00" #} dtc /local/
        .long s_loc         #} dac s_loc
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_ops:  .long svfnn         #opsyn} dbc svfnn
        .long 5             #} dac 5
        .ascii "opsyn\x00\x00\x00" #} dtc /opsyn/
        .long s_ops         #} dac s_ops
        .long 3             #} dac 3
#
v_rmd:  .long svfnp         #remdr} dbc svfnp
        .long 5             #} dac 5
        .ascii "remdr\x00\x00\x00" #} dtc /remdr/
        .long s_rmd         #} dac s_rmd
        .long 2             #} dac 2
#
v_rsr:  .long svfnn         #rsort} dbc svfnn
        .long 5             #} dac 5
        .ascii "rsort\x00\x00\x00" #} dtc /rsort/
        .long s_rsr         #} dac s_rsr
        .long 2             #} dac 2
#
v_tbl:  .long svfnn         #table} dbc svfnn
        .long 5             #} dac 5
        .ascii "table\x00\x00\x00" #} dtc /table/
        .long s_tbl         #} dac s_tbl
        .long 3             #} dac 3
#
v_tra:  .long svfnk         #trace} dbc svfnk
        .long 5             #} dac 5
        .ascii "trace\x00\x00\x00" #} dtc /trace/
        .long k_tra         #} dac k_tra
        .long s_tra         #} dac s_tra
        .long 4             #} dac 4
#
v_ucs:  .long svkwc         #ucase} dbc svkwc
        .long 5             #} dac 5
        .ascii "ucase\x00\x00\x00" #} dtc /ucase/
        .long k_ucs         #} dac k_ucs
#
v_anc:  .long svknm         #anchor} dbc svknm
        .long 6             #} dac 6
        .ascii "anchor\x00\x00" #} dtc /anchor/
        .long k_anc         #} dac k_anc
#
v_bkx:  .long svfnp         #breakx} dbc svfnp
        .long 6             #} dac 6
        .ascii "breakx\x00\x00" #} dtc /breakx/
        .long s_bkx         #} dac s_bkx
        .long 1             #} dac 1
#
#
v_def:  .long svfnn         #define} dbc svfnn
        .long 6             #} dac 6
        .ascii "define\x00\x00" #} dtc /define/
        .long s_def         #} dac s_def
        .long 2             #} dac 2
#
v_det:  .long svfnn         #detach} dbc svfnn
        .long 6             #} dac 6
        .ascii "detach\x00\x00" #} dtc /detach/
        .long s_det         #} dac s_det
        .long 1             #} dac 1
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_dif:  .long svfpr         #differ} dbc svfpr
        .long 6             #} dac 6
        .ascii "differ\x00\x00" #} dtc /differ/
        .long s_dif         #} dac s_dif
        .long 2             #} dac 2
#
v_ftr:  .long svknm         #ftrace} dbc svknm
        .long 6             #} dac 6
        .ascii "ftrace\x00\x00" #} dtc /ftrace/
        .long k_ftr         #} dac k_ftr
#
v_lst:  .long svknm         #lastno} dbc svknm
        .long 6             #} dac 6
        .ascii "lastno\x00\x00" #} dtc /lastno/
        .long k_lst         #} dac k_lst
#
v_nay:  .long svfnp         #notany} dbc svfnp
        .long 6             #} dac 6
        .ascii "notany\x00\x00" #} dtc /notany/
        .long s_nay         #} dac s_nay
        .long 1             #} dac 1
#
v_oup:  .long svfnk         #output} dbc svfnk
        .long 6             #} dac 6
        .ascii "output\x00\x00" #} dtc /output/
        .long k_oup         #} dac k_oup
        .long s_oup         #} dac s_oup
        .long 3             #} dac 3
#
v_ret:  .long svlbl         #return} dbc svlbl
        .long 6             #} dac 6
        .ascii "return\x00\x00" #} dtc /return/
        .long l_rtn         #} dac l_rtn
#
v_rew:  .long svfnn         #rewind} dbc svfnn
        .long 6             #} dac 6
        .ascii "rewind\x00\x00" #} dtc /rewind/
        .long s_rew         #} dac s_rew
        .long 1             #} dac 1
#
v_stt:  .long svfnn         #stoptr} dbc svfnn
        .long 6             #} dac 6
        .ascii "stoptr\x00\x00" #} dtc /stoptr/
        .long s_stt         #} dac s_stt
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_sub:  .long svfnn         #substr} dbc svfnn
        .long 6             #} dac 6
        .ascii "substr\x00\x00" #} dtc /substr/
        .long s_sub         #} dac s_sub
        .long 3             #} dac 3
#
v_unl:  .long svfnn         #unload} dbc svfnn
        .long 6             #} dac 6
        .ascii "unload\x00\x00" #} dtc /unload/
        .long s_unl         #} dac s_unl
        .long 1             #} dac 1
#
v_col:  .long svfnn         #collect} dbc svfnn
        .long 7             #} dac 7
        .ascii "collect\x00" #} dtc /collect/
        .long s_col         #} dac s_col
        .long 1             #} dac 1
#
v_com:  .long svknm         #compare} dbc svknm
        .long 7             #} dac 7
        .ascii "compare\x00" #} dtc /compare/
        .long k_com         #} dac k_com
#
v_cnv:  .long svfnn         #convert} dbc svfnn
        .long 7             #} dac 7
        .ascii "convert\x00" #} dtc /convert/
        .long s_cnv         #} dac s_cnv
        .long 2             #} dac 2
#
v_enf:  .long svfnn         #endfile} dbc svfnn
        .long 7             #} dac 7
        .ascii "endfile\x00" #} dtc /endfile/
        .long s_enf         #} dac s_enf
        .long 1             #} dac 1
#
v_etx:  .long svknm         #errtext} dbc svknm
        .long 7             #} dac 7
        .ascii "errtext\x00" #} dtc /errtext/
        .long k_etx         #} dac k_etx
#
v_ert:  .long svknm         #errtype} dbc svknm
        .long 7             #} dac 7
        .ascii "errtype\x00" #} dtc /errtype/
        .long k_ert         #} dac k_ert
#
v_frt:  .long svlbl         #freturn} dbc svlbl
        .long 7             #} dac 7
        .ascii "freturn\x00" #} dtc /freturn/
        .long l_frt         #} dac l_frt
#
v_int:  .long svfpr         #integer} dbc svfpr
        .long 7             #} dac 7
        .ascii "integer\x00" #} dtc /integer/
        .long s_int         #} dac s_int
        .long 1             #} dac 1
#
v_nrt:  .long svlbl         #nreturn} dbc svlbl
        .long 7             #} dac 7
        .ascii "nreturn\x00" #} dtc /nreturn/
        .long l_nrt         #} dac l_nrt
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
#
v_pfl:  .long svknm         #profile} dbc svknm
        .long 7             #} dac 7
        .ascii "profile\x00" #} dtc /profile/
        .long k_pfl         #} dac k_pfl
#
v_rpl:  .long svfnp         #replace} dbc svfnp
        .long 7             #} dac 7
        .ascii "replace\x00" #} dtc /replace/
        .long s_rpl         #} dac s_rpl
        .long 3             #} dac 3
#
v_rvs:  .long svfnp         #reverse} dbc svfnp
        .long 7             #} dac 7
        .ascii "reverse\x00" #} dtc /reverse/
        .long s_rvs         #} dac s_rvs
        .long 1             #} dac 1
#
v_rtn:  .long svknm         #rtntype} dbc svknm
        .long 7             #} dac 7
        .ascii "rtntype\x00" #} dtc /rtntype/
        .long k_rtn         #} dac k_rtn
#
v_stx:  .long svfnn         #setexit} dbc svfnn
        .long 7             #} dac 7
        .ascii "setexit\x00" #} dtc /setexit/
        .long s_stx         #} dac s_stx
        .long 1             #} dac 1
#
v_stc:  .long svknm         #stcount} dbc svknm
        .long 7             #} dac 7
        .ascii "stcount\x00" #} dtc /stcount/
        .long k_stc         #} dac k_stc
#
v_stl:  .long svknm         #stlimit} dbc svknm
        .long 7             #} dac 7
        .ascii "stlimit\x00" #} dtc /stlimit/
        .long k_stl         #} dac k_stl
#
v_suc:  .long svkvc         #succeed} dbc svkvc
        .long 7             #} dac 7
        .ascii "succeed\x00" #} dtc /succeed/
        .long k_suc         #} dac k_suc
        .long ndsuc         #} dac ndsuc
#
v_alp:  .long svkwc         #alphabet} dbc svkwc
        .long 8             #} dac 8
        .ascii "alphabet"   #} dtc /alphabet/
        .long k_alp         #} dac k_alp
#
v_cnt:  .long svlbl         #continue} dbc svlbl
        .long 8             #} dac 8
        .ascii "continue"   #} dtc /continue/
        .long l_cnt         #} dac l_cnt
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_dtp:  .long svfnp         #datatype} dbc svfnp
        .long 8             #} dac 8
        .ascii "datatype"   #} dtc /datatype/
        .long s_dtp         #} dac s_dtp
        .long 1             #} dac 1
#
v_erl:  .long svknm         #errlimit} dbc svknm
        .long 8             #} dac 8
        .ascii "errlimit"   #} dtc /errlimit/
        .long k_erl         #} dac k_erl
#
v_fnc:  .long svknm         #fnclevel} dbc svknm
        .long 8             #} dac 8
        .ascii "fnclevel"   #} dtc /fnclevel/
        .long k_fnc         #} dac k_fnc
#
v_fls:  .long svknm         #fullscan} dbc svknm
        .long 8             #} dac 8
        .ascii "fullscan"   #} dtc /fullscan/
        .long k_fls         #} dac k_fls
#
v_lfl:  .long svknm         #lastfile} dbc svknm
        .long 8             #} dac 8
        .ascii "lastfile"   #} dtc /lastfile/
        .long k_lfl         #} dac k_lfl
#
v_lln:  .long svknm         #lastline} dbc svknm
        .long 8             #} dac 8
        .ascii "lastline"   #} dtc /lastline/
        .long k_lln         #} dac k_lln
#
v_mxl:  .long svknm         #maxlngth} dbc svknm
        .long 8             #} dac 8
        .ascii "maxlngth"   #} dtc /maxlngth/
        .long k_mxl         #} dac k_mxl
#
v_ter:  .long 0             #terminal} dbc 0
        .long 8             #} dac 8
        .ascii "terminal"   #} dtc /terminal/
        .long 0             #} dac 0
#
v_bsp:  .long svfnn         #backspace} dbc svfnn
        .long 9             #} dac 9
        .ascii "backspace\x00\x00\x00" #} dtc /backspace/
        .long s_bsp         #} dac s_bsp
        .long 1             #} dac 1
#
v_pro:  .long svfnn         #prototype} dbc svfnn
        .long 9             #} dac 9
        .ascii "prototype\x00\x00\x00" #} dtc /prototype/
        .long s_pro         #} dac s_pro
        .long 1             #} dac 1
#
v_scn:  .long svlbl         #scontinue} dbc svlbl
        .long 9             #} dac 9
        .ascii "scontinue\x00\x00\x00" #} dtc /scontinue/
        .long l_scn         #} dac l_scn
#
        .long 0             #dummy entry to end list} dbc 0
        .long 10            #length gt 9 (scontinue)} dac 10
                            #} ejc
        .eject
#
#      list of svblk pointers for keywords to be dumped. the
#      list is in the order which appears on the dump output.
#
vdmkw:  .long v_anc         #anchor} dac v_anc
        .long v_cas         #ccase} dac v_cas
        .long v_cod         #code} dac v_cod
        .long 1             #compare not printed} dac 1
        .long v_dmp         #dump} dac v_dmp
        .long v_erl         #errlimit} dac v_erl
        .long v_etx         #errtext} dac v_etx
        .long v_ert         #errtype} dac v_ert
        .long v_fil         #file} dac v_fil
        .long v_fnc         #fnclevel} dac v_fnc
        .long v_ftr         #ftrace} dac v_ftr
        .long v_fls         #fullscan} dac v_fls
        .long v_inp         #input} dac v_inp
        .long v_lfl         #lastfile} dac v_lfl
        .long v_lln         #lastline} dac v_lln
        .long v_lst         #lastno} dac v_lst
        .long v_lin         #line} dac v_lin
        .long v_mxl         #maxlength} dac v_mxl
        .long v_oup         #output} dac v_oup
        .long v_pfl         #profile} dac v_pfl
        .long v_rtn         #rtntype} dac v_rtn
        .long v_stc         #stcount} dac v_stc
        .long v_stl         #stlimit} dac v_stl
        .long v_stn         #stno} dac v_stn
        .long v_tra         #trace} dac v_tra
        .long v_trm         #trim} dac v_trm
        .long 0             #end of list} dac 0
#
#      table used by gtnvr to search svblk lists
#
vsrch:  .long 0             #dummy entry to get proper indexing} dac 0
        .long v_eqf         #start of 1 char variables (none)} dac v_eqf
        .long v_eqf         #start of 2 char variables} dac v_eqf
        .long v_any         #start of 3 char variables} dac v_any
        .long v_atn         #start of 4 char variables} dac v_atn
        .long v_abe         #start of 5 char variables} dac v_abe
        .long v_anc         #start of 6 char variables} dac v_anc
        .long v_col         #start of 7 char variables} dac v_col
        .long v_alp         #start of 8 char variables} dac v_alp
        .long v_bsp         #start of 9 char variables} dac v_bsp
#
#      last location in constant section
#
c_yyy:  .long 0             #last location in constant section} dac 0
                            #} ttl s p i t b o l -- working storage section
        .sbttl "s p i t b o l -- working storage section"
#
#      the working storage section contains areas which are
#      changed during execution of the program. the value
#      assembled is the initial value before execution starts.
#
#      all these areas are fixed length areas. variable length
#      data is stored in the static or dynamic regions of the
#      allocated data areas.
#
#      the values in this area are described either as work
#      areas or as global values. a work area is used in an
#      ephemeral manner and the value is not saved from one
#      entry into a routine to another. a global value is a
#      less temporary location whose value is saved from one
#      call to another.
#
#      w$aaa marks the start of the working section whilst
#      w$yyy marks its end.  g$aaa marks the division between
#      temporary and global values.
#
#      global values are further subdivided to facilitate
#      processing by the garbage collector. r$aaa through
#      r$yyy are global values that may point into dynamic
#      storage and hence must be relocated after each garbage
#      collection.  they also serve as root pointers to all
#      allocated data that must be preserved.  pointers between
#      a$aaa and r$aaa may point into code, static storage,
#      or mark the limits of dynamic memory.  these pointers
#      must be adjusted when the working section is saved to a
#      file and subsequently reloaded at a different address.
#
#      a general part of the approach in this program is not
#      to overlap work areas between procedures even though a
#      small amount of space could be saved. such overlap is
#      considered a source of program errors and decreases the
#      information left behind after a system crash of any kind.
#
#      the names of these locations are labels with five letter
#      (a-y,$) names. as far as possible the order is kept
#      alphabetical by these names but in some cases there
#      are slight departures caused by other order requirements.
#
#      unless otherwise documented, the order of work areas
#      does not affect the execution of the spitbol program.
#
                            #start of working storage section} sec
        .global esec03
esec03:
        dsegend_
        dseg_
        .global sec04
sec04:
                            #} ejc
        .eject
#
#      this area is not cleared by initial code
#
cmlab:  .long b_scl         #string used to check label legality} dac b_scl
        .long 2             #} dac 2
        .ascii "  \x00\x00" #} dtc /  /
#
#      label to mark start of work area
#
w_aaa:  .long 0             #} dac 0
#
#      work areas for acess procedure
#
actrm:  .long 0             #trim indicator} dac 0
#
#      work areas for alloc procedure
#
aldyn:  .long 0             #amount of dynamic store} dac 0
allia:  .long +0            #dump edx} dic +0
allsv:  .long 0             #save ebx in alloc} dac 0
#
#      work areas for alost procedure
#
alsta:  .long 0             #save ecx in alost} dac 0
#
#      work areas for array function (s$arr)
#
arcdm:  .long 0             #count dimensions} dac 0
arnel:  .long +0            #count elements} dic +0
arptr:  .long 0             #offset ptr into arblk} dac 0
arsvl:  .long +0            #save integer low bound} dic +0
                            #} ejc
        .eject
#
#      work areas for arref routine
#
arfsi:  .long +0            #save current evolving subscript} dic +0
arfxs:  .long 0             #save base stack pointer} dac 0
#
#      work areas for b$efc block routine
#
befof:  .long 0             #save offset ptr into efblk} dac 0
#
#      work areas for b$pfc block routine
#
bpfpf:  .long 0             #save pfblk pointer} dac 0
bpfsv:  .long 0             #save old function value} dac 0
bpfxt:  .long 0             #pointer to stacked arguments} dac 0
#
#      work area for collect function (s$col)
#
clsvi:  .long +0            #save integer argument} dic +0
#
#      work areas value for cncrd
#
cnscc:  .long 0             #pointer to control card string} dac 0
cnswc:  .long 0             #word count} dac 0
cnr_t:  .long 0             #pointer to r_ttl or r_stl} dac 0
#
#      work areas for convert function (s$cnv)
#
cnvtp:  .long 0             #save ptr into scvtb} dac 0
#
#      work areas for data function (s$dat)
#
datdv:  .long 0             #save vrblk ptr for datatype name} dac 0
datxs:  .long 0             #save initial stack pointer} dac 0
#
#      work areas for define function (s$def)
#
deflb:  .long 0             #save vrblk ptr for label} dac 0
defna:  .long 0             #count function arguments} dac 0
defvr:  .long 0             #save vrblk ptr for function name} dac 0
defxs:  .long 0             #save initial stack pointer} dac 0
#
#      work areas for dumpr procedure
#
dmarg:  .long 0             #dump argument} dac 0
dmpsa:  .long 0             #preserve ecx over prtvl call} dac 0
dmpsb:  .long 0             #preserve ebx over syscm call} dac 0
dmpsv:  .long 0             #general scratch save} dac 0
dmvch:  .long 0             #chain pointer for variable blocks} dac 0
dmpch:  .long 0             #save sorted vrblk chain pointer} dac 0
dmpkb:  .long 0             #dummy kvblk for use in dumpr} dac 0
dmpkt:  .long 0             #kvvar trblk ptr (must follow dmpkb)} dac 0
dmpkn:  .long 0             #keyword number (must follow dmpkt)} dac 0
#
#      work area for dtach
#
dtcnb:  .long 0             #name base} dac 0
dtcnm:  .long 0             #name ptr} dac 0
#
#      work areas for dupl function (s$dup)
#
dupsi:  .long +0            #store integer string length} dic +0
#
#      work area for endfile (s$enf)
#
enfch:  .long 0             #for iochn chain head} dac 0
                            #} ejc
        .eject
#
#      work areas for ertex
#
ertwa:  .long 0             #save ecx} dac 0
ertwb:  .long 0             #save ebx} dac 0
#
#      work areas for evali
#
evlin:  .long 0             #dummy pattern block pcode} dac 0
evlis:  .long 0             #then node (must follow evlin)} dac 0
evliv:  .long 0             #value of parm1 (must follow evlis)} dac 0
evlio:  .long 0             #ptr to original node} dac 0
evlif:  .long 0             #flag for simple/complex argument} dac 0
#
#      work area for expan
#
expsv:  .long 0             #save op dope vector pointer} dac 0
#
#      work areas for gbcol procedure
#
gbcfl:  .long 0             #garbage collector active flag} dac 0
gbclm:  .long 0             #pointer to last move block (pass 3)} dac 0
gbcnm:  .long 0             #dummy first move block} dac 0
gbcns:  .long 0             #rest of dummy block (follows gbcnm)} dac 0
gbcia:  .long +0            #dump edx} dic +0
gbcsd:  .long 0             #first address beyond sediment} dac 0
gbcsf:  .long 0             #free space within sediment} dac 0
gbsva:  .long 0             #save ecx} dac 0
gbsvb:  .long 0             #save ebx} dac 0
gbsvc:  .long 0             #save edx} dac 0
#
#      work areas for gtnvr procedure
#
gnvhe:  .long 0             #ptr to end of hash chain} dac 0
gnvnw:  .long 0             #number of words in string name} dac 0
gnvsa:  .long 0             #save ecx} dac 0
gnvsb:  .long 0             #save ebx} dac 0
gnvsp:  .long 0             #pointer into vsrch table} dac 0
gnvst:  .long 0             #pointer to chars of string} dac 0
#
#      work areas for gtarr
#
gtawa:  .long 0             #save ecx} dac 0
#
#      work areas for gtint
#
gtina:  .long 0             #save ecx} dac 0
gtinb:  .long 0             #save ebx} dac 0
                            #} ejc
        .eject
#
#      work areas for gtnum procedure
#
gtnnf:  .long 0             #zero/nonzero for result +/-} dac 0
gtnsi:  .long +0            #general integer save} dic +0
gtndf:  .long 0             #0/1 for dec point so far no/yes} dac 0
gtnes:  .long 0             #zero/nonzero exponent +/-} dac 0
gtnex:  .long +0            #real exponent} dic +0
gtnsc:  .long 0             #scale (places after point)} dac 0
        .balign 4           #general real save} drc +0.0
gtnsr:  .double 0e0.0
gtnrd:  .long 0             #flag for ok real number} dac 0
#
#      work areas for gtpat procedure
#
gtpsb:  .long 0             #save ebx} dac 0
#
#      work areas for gtstg procedure
#
gtssf:  .long 0             #0/1 for result +/-} dac 0
gtsvc:  .long 0             #save edx} dac 0
gtsvb:  .long 0             #save ebx} dac 0
gtses:  .long 0             #char + or - for exponent +/-} dac 0
        .balign 4           #general real save} drc +0.0
gtsrs:  .double 0e0.0
#
#      work areas for gtvar procedure
#
gtvrc:  .long 0             #save edx} dac 0
#
#      work areas for ioput
#
ioptt:  .long 0             #type of association} dac 0
#
#      work areas for load function
#
lodfn:  .long 0             #pointer to vrblk for func name} dac 0
lodna:  .long 0             #count number of arguments} dac 0
#
#      work area for profiler
#
pfsvw:  .long 0             #to save a w-reg} dac 0
#
#      work areas for prtnm procedure
#
prnsi:  .long +0            #scratch integer loc} dic +0
#
#      work areas for prtsn procedure
#
prsna:  .long 0             #save ecx} dac 0
#
#      work areas for prtst procedure
#
prsva:  .long 0             #save ecx} dac 0
prsvb:  .long 0             #save ebx} dac 0
prsvc:  .long 0             #save char counter} dac 0
#
#      work area for prtnl
#
prtsa:  .long 0             #save ecx} dac 0
prtsb:  .long 0             #save ebx} dac 0
#
#      work area for prtvl
#
prvsi:  .long 0             #save idval} dac 0
#
#      work areas for pattern match routines
#
psave:  .long 0             #temporary save for current node ptr} dac 0
psavc:  .long 0             #save cursor in p_spn, p_str} dac 0
#
#      work area for relaj routine
#
rlals:  .long 0             #ptr to list of bounds and adjusts} dac 0
#
#      work area for reldn routine
#
rldcd:  .long 0             #save code adjustment} dac 0
rldst:  .long 0             #save static adjustment} dac 0
rldls:  .long 0             #save list pointer} dac 0
#
#      work areas for retrn routine
#
rtnbp:  .long 0             #to save a block pointer} dac 0
rtnfv:  .long 0             #new function value (result)} dac 0
rtnsv:  .long 0             #old function value (saved value)} dac 0
#
#      work areas for substr function (s$sub)
#
sbssv:  .long 0             #save third argument} dac 0
#
#      work areas for scan procedure
#
scnsa:  .long 0             #save ecx} dac 0
scnsb:  .long 0             #save ebx} dac 0
scnsc:  .long 0             #save edx} dac 0
scnof:  .long 0             #save offset} dac 0
                            #} ejc
        .eject
#
#      work area used by sorta, sortc, sortf, sorth
#
srtdf:  .long 0             #datatype field name} dac 0
srtfd:  .long 0             #found dfblk address} dac 0
srtff:  .long 0             #found field name} dac 0
srtfo:  .long 0             #offset to field name} dac 0
srtnr:  .long 0             #number of rows} dac 0
srtof:  .long 0             #offset within row to sort key} dac 0
srtrt:  .long 0             #root offset} dac 0
srts1:  .long 0             #save offset 1} dac 0
srts2:  .long 0             #save offset 2} dac 0
srtsc:  .long 0             #save edx} dac 0
srtsf:  .long 0             #sort array first row offset} dac 0
srtsn:  .long 0             #save n} dac 0
srtso:  .long 0             #offset to a(0)} dac 0
srtsr:  .long 0             #0, non-zero for sort, rsort} dac 0
srtst:  .long 0             #stride from one row to next} dac 0
srtwc:  .long 0             #dump edx} dac 0
#
#      work areas for stopr routine
#
stpsi:  .long +0            #save value of stcount} dic +0
stpti:  .long +0            #save time elapsed} dic +0
#
#      work areas for tfind procedure
#
tfnsi:  .long +0            #number of headers} dic +0
#
#      work areas for xscan procedure
#
xscrt:  .long 0             #save return code} dac 0
xscwb:  .long 0             #save register ebx} dac 0
#
#      start of global values in working section
#
g_aaa:  .long 0             #} dac 0
#
#      global value for alloc procedure
#
alfsf:  .long +0            #factor in free store pcntage check} dic +0
#
#      global values for cmpil procedure
#
cmerc:  .long 0             #count of initial compile errors} dac 0
cmpln:  .long 0             #line number of first line of stmt} dac 0
cmpxs:  .long 0             #save stack ptr in case of errors} dac 0
cmpsn:  .long 1             #number of next statement to compile} dac 1
#
#      global values for cncrd
#
cnsil:  .long 0             #save scnil during include process.} dac 0
cnind:  .long 0             #current include file nest level} dac 0
cnspt:  .long 0             #save scnpt during include process.} dac 0
cnttl:  .long 0             #flag for -title, -stitl} dac 0
#
#      global flag for suppression of compilation statistics.
#
cpsts:  .long 0             #suppress comp. stats if non zero} dac 0
#
#      global values for control card switches
#
cswdb:  .long 0             #0/1 for -single/-double} dac 0
cswer:  .long 0             #0/1 for -errors/-noerrors} dac 0
cswex:  .long 0             #0/1 for -execute/-noexecute} dac 0
cswfl:  .long 1             #0/1 for -nofail/-fail} dac 1
cswin:  .long iniln         #xxx for -inxxx} dac iniln
cswls:  .long 1             #0/1 for -nolist/-list} dac 1
cswno:  .long 0             #0/1 for -optimise/-noopt} dac 0
cswpr:  .long 0             #0/1 for -noprint/-print} dac 0
#
#      global location used by patst procedure
#
ctmsk:  .long 0             #last bit position used in r_ctp} dbc 0
curid:  .long 0             #current id value} dac 0
                            #} ejc
        .eject
#
#      global value for cdwrd procedure
#
cwcof:  .long 0             #next word offset in current ccblk} dac 0
#
#      global locations for dynamic storage pointers
#
dnams:  .long 0             #size of sediment in baus} dac 0
#
#      global area for error processing.
#
erich:  .long 0             #copy error reports to int.chan if 1} dac 0
erlst:  .long 0             #for listr when errors go to int.ch.} dac 0
errft:  .long 0             #fatal error flag} dac 0
errsp:  .long 0             #error suppression flag} dac 0
#
#      global flag for suppression of execution stats
#
exsts:  .long 0             #suppress exec stats if set} dac 0
#
#      global values for exfal and return
#
flprt:  .long 0             #location of fail offset for return} dac 0
flptr:  .long 0             #location of failure offset on stack} dac 0
#
#      global location to count garbage collections (gbcol)
#
gbsed:  .long +0            #factor in sediment pcntage check} dic +0
gbcnt:  .long 0             #count of garbage collections} dac 0
#
#      global value for gtcod and gtexp
#
gtcef:  .long 0             #save fail ptr in case of error} dac 0
#
#      global locations for gtstg procedure
#
        .balign 4           #rounding factor 0.5*10**-cfp_s} drc +0.0
gtsrn:  .double 0e0.0
        .balign 4           #scaling value 10**cfp_s} drc +0.0
gtssc:  .double 0e0.0
gtswk:  .long 0             #ptr to work area for gtstg} dac 0
#
#      global flag for header printing
#
headp:  .long 0             #header printed flag} dac 0
#
#      global values for variable hash table
#
hshnb:  .long +0            #number of hash buckets} dic +0
#
#      global areas for init
#
initr:  .long 0             #save terminal flag} dac 0
                            #} ejc
        .eject
#
#      global values for keyword values which are stored as one
#      word integers. these values must be assembled in the
#      following order (as dictated by k$xxx definition values).
#
kvabe:  .long 0             #abend} dac 0
kvanc:  .long 0             #anchor} dac 0
kvcas:  .long 0             #case} dac 0
kvcod:  .long 0             #code} dac 0
kvcom:  .long 0             #compare} dac 0
kvdmp:  .long 0             #dump} dac 0
kverl:  .long 0             #errlimit} dac 0
kvert:  .long 0             #errtype} dac 0
kvftr:  .long 0             #ftrace} dac 0
kvfls:  .long 1             #fullscan} dac 1
kvinp:  .long 1             #input} dac 1
kvmxl:  .long 5000          #maxlength} dac 5000
kvoup:  .long 1             #output} dac 1
kvpfl:  .long 0             #profile} dac 0
kvtra:  .long 0             #trace} dac 0
kvtrm:  .long 0             #trim} dac 0
kvfnc:  .long 0             #fnclevel} dac 0
kvlst:  .long 0             #lastno} dac 0
kvlln:  .long 0             #lastline} dac 0
kvlin:  .long 0             #line} dac 0
kvstn:  .long 0             #stno} dac 0
#
#      global values for other keywords
#
kvalp:  .long 0             #alphabet} dac 0
kvrtn:  .long nulls         #rtntype (scblk pointer)} dac nulls
kvstl:  .long +2147483647   #stlimit} dic +2147483647
kvstc:  .long +2147483647   #stcount (counts down from stlimit)} dic +2147483647
#
#      global values for listr procedure
#
lstid:  .long 0             #include depth of current image} dac 0
lstlc:  .long 0             #count lines on source list page} dac 0
lstnp:  .long 0             #max number of lines on page} dac 0
lstpf:  .long 1             #set nonzero if current image listed} dac 1
lstpg:  .long 0             #current source list page number} dac 0
lstpo:  .long 0             #offset to   page nnn   message} dac 0
lstsn:  .long 0             #remember last stmnum listed} dac 0
#
#      global maximum size of spitbol objects
#
mxlen:  .long 0             #initialised by sysmx call} dac 0
#
#      global execution control variable
#
noxeq:  .long 0             #set non-zero to inhibit execution} dac 0
#
#      global profiler values locations
#
pfdmp:  .long 0             #set non-0 if &profile set non-0} dac 0
pffnc:  .long 0             #set non-0 if funct just entered} dac 0
pfstm:  .long +0            #to store starting time of stmt} dic +0
pfetm:  .long +0            #to store ending time of stmt} dic +0
pfnte:  .long 0             #nr of table entries} dac 0
pfste:  .long +0            #gets int rep of table entry size} dic +0
#
                            #} ejc
        .eject
#
#      global values used in pattern match routines
#
pmdfl:  .long 0             #pattern assignment flag} dac 0
pmhbs:  .long 0             #history stack base pointer} dac 0
pmssl:  .long 0             #length of subject string in chars} dac 0
#
#      global values for interface polling (syspl)
#
polcs:  .long 1             #poll interval start value} dac 1
polct:  .long 1             #poll interval counter} dac 1
#
#      global flags used for standard file listing options
#
prich:  .long 0             #printer on interactive channel} dac 0
prstd:  .long 0             #tested by prtpg} dac 0
prsto:  .long 0             #standard listing option flag} dac 0
#
#      global values for print procedures
#
prbuf:  .long 0             #ptr to print bfr in static} dac 0
precl:  .long 0             #extended/compact listing flag} dac 0
prlen:  .long 0             #length of print buffer in chars} dac 0
prlnw:  .long 0             #length of print buffer in words} dac 0
profs:  .long 0             #offset to next location in prbuf} dac 0
prtef:  .long 0             #endfile flag} dac 0
                            #} ejc
        .eject
#
#      global area for readr
#
rdcln:  .long 0             #current statement line number} dac 0
rdnln:  .long 0             #next statement line number} dac 0
#
#      global amount of memory reserved for end of execution
#
rsmem:  .long 0             #reserve memory} dac 0
#
#      global area for stmgo counters
#
stmcs:  .long 1             #counter startup value} dac 1
stmct:  .long 1             #counter active value} dac 1
#
#      adjustable global values
#
#      all the pointers in this section can point to the
#      dynamic or the static region.
#      when a save file is reloaded, these pointers must
#      be adjusted if static or dynamic memory is now
#      at a different address.  see routine reloc for
#      additional information.
#
#      some values cannot be move here because of adjacency
#      constraints.  they are handled specially by reloc et al.
#      these values are kvrtn,
#
#      values gtswk, kvalp, and prbuf are reinitialized by
#      procedure insta, and do not need to appear here.
#
#      values flprt, flptr, gtcef, and stbas point into the
#      stack and are explicitly adjusted by osint's restart
#      procedure.
#
a_aaa:  .long 0             #start of adjustable values} dac 0
cmpss:  .long 0             #save subroutine stack ptr} dac 0
dnamb:  .long 0             #start of dynamic area} dac 0
dnamp:  .long 0             #next available loc in dynamic area} dac 0
dname:  .long 0             #end of available dynamic area} dac 0
hshtb:  .long 0             #pointer to start of vrblk hash tabl} dac 0
hshte:  .long 0             #pointer past end of vrblk hash tabl} dac 0
iniss:  .long 0             #save subroutine stack ptr} dac 0
pftbl:  .long 0             #gets adrs of (imag) table base} dac 0
prnmv:  .long 0             #vrblk ptr from last name search} dac 0
statb:  .long 0             #start of static area} dac 0
state:  .long 0             #end of static area} dac 0
stxvr:  .long nulls         #vrblk pointer or null} dac nulls
#
#      relocatable global values
#
#      all the pointers in this section can point to blocks in
#      the dynamic storage area and must be relocated by the
#      garbage collector. they are identified by r$xxx names.
#
r_aaa:  .long 0             #start of relocatable values} dac 0
r_arf:  .long 0             #array block pointer for arref} dac 0
r_ccb:  .long 0             #ptr to ccblk being built (cdwrd)} dac 0
r_cim:  .long 0             #ptr to current compiler input str} dac 0
r_cmp:  .long 0             #copy of r_cim used in cmpil} dac 0
r_cni:  .long 0             #ptr to next compiler input string} dac 0
r_cnt:  .long 0             #cdblk pointer for setexit continue} dac 0
r_cod:  .long 0             #pointer to current cdblk or exblk} dac 0
r_ctp:  .long 0             #ptr to current ctblk for patst} dac 0
r_cts:  .long 0             #ptr to last string scanned by patst} dac 0
r_ert:  .long 0             #trblk pointer for errtype trace} dac 0
r_etx:  .long nulls         #pointer to errtext string} dac nulls
r_exs:  .long 0             #= save esi in expdm} dac 0
r_fcb:  .long 0             #fcblk chain head} dac 0
r_fnc:  .long 0             #trblk pointer for fnclevel trace} dac 0
r_gtc:  .long 0             #keep code ptr for gtcod,gtexp} dac 0
r_ici:  .long 0             #saved r_cim during include process.} dac 0
r_ifa:  .long 0             #array of file names by incl. depth} dac 0
r_ifl:  .long 0             #array of line nums by include depth} dac 0
r_ifn:  .long 0             #last include file name} dac 0
r_inc:  .long 0             #table of include file names seen} dac 0
r_io1:  .long 0             #file arg1 for ioput} dac 0
r_io2:  .long 0             #file arg2 for ioput} dac 0
r_iof:  .long 0             #fcblk ptr or 0} dac 0
r_ion:  .long 0             #name base ptr} dac 0
r_iop:  .long 0             #predecessor block ptr for ioput} dac 0
r_iot:  .long 0             #trblk ptr for ioput} dac 0
r_pms:  .long 0             #subject string ptr in pattern match} dac 0
r_ra2:  .long 0             #replace second argument last time} dac 0
r_ra3:  .long 0             #replace third argument last time} dac 0
r_rpt:  .long 0             #ptr to ctblk replace table last usd} dac 0
r_scp:  .long 0             #save pointer from last scane call} dac 0
r_sfc:  .long nulls         #current source file name} dac nulls
r_sfn:  .long 0             #ptr to source file name table} dac 0
r_sxl:  .long 0             #preserve esi in sortc} dac 0
r_sxr:  .long 0             #preserve edi in sorta/sortc} dac 0
r_stc:  .long 0             #trblk pointer for stcount trace} dac 0
r_stl:  .long 0             #source listing sub-title} dac 0
r_sxc:  .long 0             #code (cdblk) ptr for setexit trap} dac 0
r_ttl:  .long nulls         #source listing title} dac nulls
r_xsc:  .long 0             #string pointer for xscan} dac 0
                            #} ejc
        .eject
#
#      the remaining pointers in this list are used to point
#      to function blocks for normally undefined operators.
#
r_uba:  .long stndo         #binary at} dac stndo
r_ubm:  .long stndo         #binary ampersand} dac stndo
r_ubn:  .long stndo         #binary number sign} dac stndo
r_ubp:  .long stndo         #binary percent} dac stndo
r_ubt:  .long stndo         #binary not} dac stndo
r_uub:  .long stndo         #unary vertical bar} dac stndo
r_uue:  .long stndo         #unary equal} dac stndo
r_uun:  .long stndo         #unary number sign} dac stndo
r_uup:  .long stndo         #unary percent} dac stndo
r_uus:  .long stndo         #unary slash} dac stndo
r_uux:  .long stndo         #unary exclamation} dac stndo
r_yyy:  .long 0             #last relocatable location} dac 0
#
#      global locations used in scan procedure
#
scnbl:  .long 0             #set non-zero if scanned past blanks} dac 0
scncc:  .long 0             #non-zero to scan control card name} dac 0
scngo:  .long 0             #set non-zero to scan goto field} dac 0
scnil:  .long 0             #length of current input image} dac 0
scnpt:  .long 0             #pointer to next location in r_cim} dac 0
scnrs:  .long 0             #set non-zero to signal rescan} dac 0
scnse:  .long 0             #start of current element} dac 0
scntp:  .long 0             #save syntax type from last call} dac 0
#
#      global value for indicating stage (see error section)
#
stage:  .long 0             #initial value = initial compile} dac 0
                            #} ejc
        .eject
#
#      global stack pointer
#
stbas:  .long 0             #pointer past stack base} dac 0
#
#      global values for setexit function (s$stx)
#
stxoc:  .long 0             #code pointer offset} dac 0
stxof:  .long 0             #failure offset} dac 0
#
#      global value for time keeping
#
timsx:  .long +0            #time at start of execution} dic +0
timup:  .long 0             #set when time up occurs} dac 0
#
#      global values for xscan and xscni procedures
#
xsofs:  .long 0             #offset to current location in r_xsc} dac 0
#
#      label to mark end of working section
#
w_yyy:  .long 0             #} dac 0
                            #} ttl s p i t b o l -- minimal code
        .sbttl "s p i t b o l -- minimal code"
                            #start of program section} sec
        .global esec04
esec04:
prc_:   .fill 19,4,0
        .global lowspmin
lowspmin: .long 0
        .global end_min_data
end_min_data:
        dsegend_
        cseg_
        .global sec05
sec05:
        .balign 2           #mark start of code} ent bl__i
        .byte bl__i
s_aaa:
                            #} ttl s p i t b o l -- relocation
        .sbttl "s p i t b o l -- relocation"
#
#      relocation
#      the following section provides services to osint to
#      relocate portions of the workspace.  it is used when
#      a saved memory image must be restarted at a different
#      location.
#
#      relaj -- relocate a list of pointers
#
#      (wa)                  ptr past last pointer of list
#      (wb)                  ptr to first pointer of list
#      (xl)                  list of boundaries and adjustments
#      jsr  relaj            call to process list of pointers
#      (wb)                  destroyed
#
relaj:                      #entry point} prc e 0
        .global relaj
        push edi            #save edi} mov xr -(xs)
        push ecx            #save ecx} mov wa -(xs)
        mov  dword ptr rlals,esi #save ptr to list of bounds} mov xl rlals
        mov  edi,ebx        #ptr to first pointer to process} mov wb xr
#
#      merge here to check if done
#
rlaj0:  mov  esi,dword ptr rlals #restore esi} mov rlals xl
        cmp  edi,dword ptr [esp] #proceed if more to do} bne xr (xs) rlaj1
        jne  short rlaj1 # (jump shortened)
        pop  ecx            #restore ecx} mov (xs)+ wa
        pop  edi            #restore edi} mov (xs)+ xr
        ret                 #return to caller} exi
#
#      merge here to process next pointer on list
#
rlaj1:  mov  ecx,dword ptr [edi] #load next pointer on list} mov (xr) wa
        mov  ebx,rnsi_      #number of sections of adjusters} lct wb =rnsi_
#
#      merge here to process next section of stack list
#
rlaj2:  cmp  ecx,dword ptr (4*rlend)[esi] #ok if past end of section} bgt wa rlend(xl) rlaj3
        ja   short rlaj3 # (jump shortened)
        cmp  ecx,dword ptr (4*rlstr)[esi] #or if before start of section} blt wa rlstr(xl) rlaj3
        jb   short rlaj3 # (jump shortened)
        add  ecx,dword ptr (4*rladj)[esi] #within section, add adjustment} add rladj(xl) wa
        mov  dword ptr [edi],ecx #return updated ptr to memory} mov wa (xr)
        jmp  short rlaj4          #done with this pointer} brn rlaj4 # (jump shortened)
#
#      here if not within section
#
rlaj3:  add  esi,4*rssi_    #advance to next section} add *rssi_ xl
        dec  ebx            #jump if more to go} bct wb rlaj2
        jnz  rlaj2
#
#      here when finished processing one pointer
#
rlaj4:  add  edi,4          #increment to next ptr on list} ica xr
        jmp  rlaj0          #jump to check  for completion} brn rlaj0
                            #end procedure relaj} enp
                            #} ejc
        .eject
#
#      relcr -- create relocation info after save file reload
#
#      (wa)                  original s$aaa code section adr
#      (wb)                  original c$aaa constant section adr
#      (wc)                  original g$aaa working section adr
#      (xr)                  ptr to start of static region
#      (cp)                  ptr to start of dynamic region
#      (xl)                  ptr to area to receive information
#      jsr  relcr            create relocation information
#      (wa,wb,wc,xr)         destroyed
#
#      a block of information is built at (xl) that is used
#      in relocating pointers.  there are rnsi$ instances
#      of a rssi$ word structure.  each instance corresponds
#      to one of the regions that a pointer might point into.
#      the layout of this structure is shown in the definitions
#      section, together with symbolic definitions of the
#      entries as offsets from xl.
#
relcr:                      #entry point} prc e 0
        .global relcr
        add  esi,4*rlsi_    #point past build area} add *rlsi_ xl
        lea  esi,[esi-4]    #save original code address} mov wa -(xl)
        mov  dword ptr [esi],ecx
        mov  ecx,offset s_aaa #compute adjustment} mov =s_aaa wa
        sub  ecx,dword ptr [esi] #as new s_aaa minus original s_aaa} sub (xl) wa
        lea  esi,[esi-4]    #save code adjustment} mov wa -(xl)
        mov  dword ptr [esi],ecx
        mov  ecx,offset s_yyy #end of target code section} mov =s_yyy wa
        sub  ecx,offset s_aaa #length of code section} sub =s_aaa wa
        add  ecx,dword ptr (4*num01)[esi] #plus original start address} add num01(xl) wa
        lea  esi,[esi-4]    #end of original code section} mov wa -(xl)
        mov  dword ptr [esi],ecx
        lea  esi,[esi-4]    #save constant section address} mov wb -(xl)
        mov  dword ptr [esi],ebx
        mov  ebx,offset c_aaa #start of constants section} mov =c_aaa wb
        mov  ecx,offset c_yyy #end of constants section} mov =c_yyy wa
        sub  ecx,ebx        #length of constants section} sub wb wa
        sub  ebx,dword ptr [esi] #new c_aaa minus original c_aaa} sub (xl) wb
        lea  esi,[esi-4]    #save constant adjustment} mov wb -(xl)
        mov  dword ptr [esi],ebx
        add  ecx,dword ptr (4*num01)[esi] #length plus original start adr} add num01(xl) wa
        lea  esi,[esi-4]    #save as end of original constants} mov wa -(xl)
        mov  dword ptr [esi],ecx
        lea  esi,[esi-4]    #save working globals address} mov wc -(xl)
        mov  dword ptr [esi],edx
        mov  edx,offset g_aaa #start of working globals section} mov =g_aaa wc
        mov  ecx,offset w_yyy #end of working section} mov =w_yyy wa
        sub  ecx,edx        #length of working globals} sub wc wa
        sub  edx,dword ptr [esi] #new g_aaa minus original g_aaa} sub (xl) wc
        lea  esi,[esi-4]    #save working globals adjustment} mov wc -(xl)
        mov  dword ptr [esi],edx
        add  ecx,dword ptr (4*num01)[esi] #length plus original start adr} add num01(xl) wa
        lea  esi,[esi-4]    #save as end of working globals} mov wa -(xl)
        mov  dword ptr [esi],ecx
        mov  ebx,dword ptr statb #old start of static region} mov statb wb
        lea  esi,[esi-4]    #save} mov wb -(xl)
        mov  dword ptr [esi],ebx
        sub  edi,ebx        #compute adjustment} sub wb xr
        lea  esi,[esi-4]    #save new statb minus old statb} mov xr -(xl)
        mov  dword ptr [esi],edi
        lea  esi,[esi-4]    #old end of static region} mov state -(xl)
        mov  eax,dword ptr state
        mov  dword ptr [esi],eax
        mov  ebx,dword ptr dnamb #old start of dynamic region} mov dnamb wb
        lea  esi,[esi-4]    #save} mov wb -(xl)
        mov  dword ptr [esi],ebx
        mov  ecx,ebp        #new start of dynamic} scp wa
        sub  ecx,ebx        #compute adjustment} sub wb wa
        lea  esi,[esi-4]    #save new dnamb minus old dnamb} mov wa -(xl)
        mov  dword ptr [esi],ecx
        mov  edx,dword ptr dnamp #old end of dynamic region in use} mov dnamp wc
        lea  esi,[esi-4]    #save as end of old dynamic region} mov wc -(xl)
        mov  dword ptr [esi],edx
        ret                 #} exi
                            #} enp
                            #} ejc
        .eject
#
#      reldn -- relocate pointers in the dynamic region
#
#      (xl)                  list of boundaries and adjustments
#      (xr)                  ptr to first location to process
#      (wc)                  ptr past last location to process
#      jsr  reldn            call to process blocks in dynamic
#      (wa,wb,wc,xr)         destroyed
#
#      processes all blocks in the dynamic region.  within a
#      block, pointers to the code section, constant section,
#      working globals section, static region, and dynamic
#      region are relocated as needed.
#
reldn:                      #entry point} prc e 0
        .global reldn
        mov  eax,dword ptr (4*rlcda)[esi] #save code adjustment} mov rlcda(xl) rldcd
        mov  dword ptr rldcd,eax
        mov  eax,dword ptr (4*rlsta)[esi] #save static adjustment} mov rlsta(xl) rldst
        mov  dword ptr rldst,eax
        mov  dword ptr rldls,esi #save list pointer} mov xl rldls
#
#      merge here to process the next block in dynamic
#
rld01:  mov  eax,dword ptr rldcd #adjust block type word} add rldcd (xr)
        add  dword ptr [edi],eax
        mov  esi,dword ptr [edi] #load block type word} mov (xr) xl
        movzx esi,byte ptr [esi-1] #load entry point id (bl_xx)} lei xl
#
#      block type switch. note that blocks with no relocatable
#      fields just return to rld05 to continue to next block.
#
#      note that dfblks do not appear in dynamic, only in static.
#      ccblks and cmblks are not live when a save file is
#      created, and can be skipped.
#
#      further note:  static blocks other than vrblks discovered
#      while scanning dynamic must be adjusted at this time.
#      see processing of ffblk for example.
#
                            #} ejc
        .eject
#
#      reldn (continued)
#
        jmp  dword ptr l0001[esi*4] #switch on block type} bsw xl bl___
        dseg_
l0001:
        .long rld03         #arblk} iff bl_ar rld03
        .long rld07         #cdblk} iff bl_cd rld07
        .long rld10         #exblk} iff bl_ex rld10
        .long rld05         #icblk} iff bl_ic rld05
        .long rld13         #nmblk} iff bl_nm rld13
        .long rld13         #p0blk} iff bl_p0 rld13
        .long rld14         #p1blk} iff bl_p1 rld14
        .long rld14         #p2blk} iff bl_p2 rld14
        .long rld05         #rcblk} iff bl_rc rld05
        .long rld05         #scblk} iff bl_sc rld05
        .long rld13         #seblk} iff bl_se rld13
        .long rld17         #tbblk} iff bl_tb rld17
        .long rld17         #vcblk} iff bl_vc rld17
        .long rld05         #xnblk} iff bl_xn rld05
        .long rld20         #xrblk} iff bl_xr rld20
        .long rld05         #bcblk - dummy to fill out iffs} iff bl_bc rld05
        .long rld15         #pdblk} iff bl_pd rld15
        .long rld19         #trblk} iff bl_tr rld19
        .long rld05         #bfblk} iff bl_bf rld05
        .long rld05         #ccblk} iff bl_cc rld05
        .long rld05         #cmblk} iff bl_cm rld05
        .long rld05         #ctblk} iff bl_ct rld05
        .long rld05         #dfblk} iff bl_df rld05
        .long rld08         #efblk} iff bl_ef rld08
        .long rld09         #evblk} iff bl_ev rld09
        .long rld11         #ffblk} iff bl_ff rld11
        .long rld13         #kvblk} iff bl_kv rld13
        .long rld16         #pfblk} iff bl_pf rld16
        .long rld18         #teblk} iff bl_te rld18
        dsegend_            #end of jump table} esw
        cseg_
#
#      arblk
#
rld03:  mov  ecx,dword ptr (4*arlen)[edi] #load length} mov arlen(xr) wa
        mov  ebx,dword ptr (4*arofs)[edi] #set offset to 1st reloc fld (arpro)} mov arofs(xr) wb
#
#      merge here to process pointers in a block
#
#      (xr)                  ptr to current block
#      (wc)                  ptr past last location to process
#      (wa)                  length (reloc flds + flds at start)
#      (wb)                  offset to first reloc field
#
rld04:  add  ecx,edi        #point past last reloc field} add xr wa
        add  ebx,edi        #point to first reloc field} add xr wb
        mov  esi,dword ptr rldls #point to list of bounds} mov rldls xl
        call relaj          #adjust pointers} jsr relaj
                            #} ejc
        .eject
#
#      reldn (continued)
#
#
#      merge here to advance to next block
#
#      (xr)                  ptr to current block
#      (wc)                  ptr past last location to process
#
rld05:  mov  ecx,dword ptr [edi] #block type word} mov (xr) wa
        call blkln          #get length of block} jsr blkln
        add  edi,ecx        #point to next block} add wa xr
        cmp  edi,edx        #continue if more to process} blt xr wc rld01
        jb   rld01
        mov  esi,dword ptr rldls #restore esi} mov rldls xl
        ret                 #return to caller if done} exi
#
#      cdblk
#
rld07:  mov  ecx,dword ptr (4*cdlen)[edi] #load length} mov cdlen(xr) wa
        mov  ebx,4*cdfal    #set offset} mov *cdfal wb
        cmp  dword ptr [edi],offset b_cdc #jump back if not complex goto} bne (xr) =b_cdc rld04
        jne  rld04
        mov  ebx,4*cdcod    #do not process cdfal word} mov *cdcod wb
        jmp  rld04          #jump back} brn rld04
#
#      efblk
#
#      if the efcod word points to an xnblk, the xnblk type
#      word will not be adjusted.  since this is implementation
#      dependent, we will not worry about it.
#
rld08:  mov  ecx,4*efrsl    #set length} mov *efrsl wa
        mov  ebx,4*efcod    #and offset} mov *efcod wb
        jmp  rld04          #all set} brn rld04
#
#      evblk
#
rld09:  mov  ecx,4*offs3    #point past third field} mov *offs3 wa
        mov  ebx,4*evexp    #set offset} mov *evexp wb
        jmp  rld04          #all set} brn rld04
#
#      exblk
#
rld10:  mov  ecx,dword ptr (4*exlen)[edi] #load length} mov exlen(xr) wa
        mov  ebx,4*exflc    #set offset} mov *exflc wb
        jmp  rld04          #jump back} brn rld04
                            #} ejc
        .eject
#
#      reldn (continued)
#
#
#      ffblk
#
#      this block contains a ptr to a dfblk in the static rgn.
#      because there are multiple ffblks pointing to the same
#      dfblk (one for each field name), we only process the
#      dfblk when we encounter the ffblk for the first field.
#      the dfblk in turn contains a pointer to an scblk within
#      static.
#
rld11:  cmp  dword ptr (4*ffofs)[edi],4*pdfld #skip dfblk if not first field} bne ffofs(xr) *pdfld rld12
        jne  short rld12 # (jump shortened)
        push edi            #save edi} mov xr -(xs)
        mov  edi,dword ptr (4*ffdfp)[edi] #load old ptr to dfblk} mov ffdfp(xr) xr
        add  edi,dword ptr rldst #current location of dfblk} add rldst xr
        mov  eax,dword ptr rldcd #adjust dfblk type word} add rldcd (xr)
        add  dword ptr [edi],eax
        mov  ecx,dword ptr (4*dflen)[edi] #length of dfblk} mov dflen(xr) wa
        mov  ebx,4*dfnam    #offset to dfnam field} mov *dfnam wb
        add  ecx,edi        #point past last reloc field} add xr wa
        add  ebx,edi        #point to first reloc field} add xr wb
        mov  esi,dword ptr rldls #point to list of bounds} mov rldls xl
        call relaj          #adjust pointers} jsr relaj
        mov  edi,dword ptr (4*dfnam)[edi] #pointer to static scblk} mov dfnam(xr) xr
        mov  eax,dword ptr rldcd #adjust scblk type word} add rldcd (xr)
        add  dword ptr [edi],eax
        pop  edi            #restore ffblk pointer} mov (xs)+ xr
#
#      ffblk (continued)
#
#      merge here to set up for adjustment of ptrs in ffblk
#
rld12:  mov  ecx,4*ffofs    #set length} mov *ffofs wa
        mov  ebx,4*ffdfp    #set offset} mov *ffdfp wb
        jmp  rld04          #all set} brn rld04
#
#      kvblk, nmblk, p0blk, seblk
#
rld13:  mov  ecx,4*offs2    #point past second field} mov *offs2 wa
        mov  ebx,4*offs1    #offset is one (only reloc fld is 2)} mov *offs1 wb
        jmp  rld04          #all set} brn rld04
#
#      p1blk, p2blk
#
#      in p2blks, parm2 contains either a bit mask or the
#      name offset of a variable.  it never requires relocation.
#
rld14:  mov  ecx,4*parm2    #length (parm2 is non-relocatable)} mov *parm2 wa
        mov  ebx,4*pthen    #set offset} mov *pthen wb
        jmp  rld04          #all set} brn rld04
#
#      pdblk
#
#      note that the dfblk pointed to by this pdblk was
#      processed when the ffblk was encountered.  because
#      the data function will be called before any records are
#      defined, the ffblk is encountered before any
#      corresponding pdblk.
#
rld15:  mov  esi,dword ptr (4*pddfp)[edi] #load ptr to dfblk} mov pddfp(xr) xl
        add  esi,dword ptr rldst #adjust for static relocation} add rldst xl
        mov  ecx,dword ptr (4*dfpdl)[esi] #get pdblk length} mov dfpdl(xl) wa
        mov  ebx,4*pddfp    #set offset} mov *pddfp wb
        jmp  rld04          #all set} brn rld04
                            #} ejc
        .eject
#
#      reldn (continued)
#
#
#      pfblk
#
rld16:  mov  eax,dword ptr rldst #adjust non-contiguous field} add rldst pfvbl(xr)
        add  dword ptr (4*pfvbl)[edi],eax
        mov  ecx,dword ptr (4*pflen)[edi] #get pfblk length} mov pflen(xr) wa
        mov  ebx,4*pfcod    #offset to first reloc} mov *pfcod wb
        jmp  rld04          #all set} brn rld04
#
#      tbblk, vcblk
#
rld17:  mov  ecx,dword ptr (4*offs2)[edi] #load length} mov offs2(xr) wa
        mov  ebx,4*offs3    #set offset} mov *offs3 wb
        jmp  rld04          #jump back} brn rld04
#
#      teblk
#
rld18:  mov  ecx,4*tesi_    #set length} mov *tesi_ wa
        mov  ebx,4*tesub    #and offset} mov *tesub wb
        jmp  rld04          #all set} brn rld04
#
#      trblk
#
rld19:  mov  ecx,4*trsi_    #set length} mov *trsi_ wa
        mov  ebx,4*trval    #and offset} mov *trval wb
        jmp  rld04          #all set} brn rld04
#
#      xrblk
#
rld20:  mov  ecx,dword ptr (4*xrlen)[edi] #load length} mov xrlen(xr) wa
        mov  ebx,4*xrptr    #set offset} mov *xrptr wb
        jmp  rld04          #jump back} brn rld04
                            #end procedure reldn} enp
                            #} ejc
        .eject
#
#      reloc -- relocate storage after save file reload
#
#      (xl)                  list of boundaries and adjustments
#      jsr  reloc            relocate all pointers
#      (wa,wb,wc,xr)         destroyed
#
#      the list of boundaries and adjustments pointed to by
#      register xl is created by a call to relcr, which should
#      be consulted for information on its structure.
#
reloc:                      #entry point} prc e 0
        .global reloc
        mov  edi,dword ptr (4*rldys)[esi] #old start of dynamic} mov rldys(xl) xr
        mov  edx,dword ptr (4*rldye)[esi] #old end of dynamic} mov rldye(xl) wc
        add  edi,dword ptr (4*rldya)[esi] #create new start of dynamic} add rldya(xl) xr
        add  edx,dword ptr (4*rldya)[esi] #create new end of dynamic} add rldya(xl) wc
        call reldn          #relocate pointers in dynamic} jsr reldn
        call relws          #relocate pointers in working sect} jsr relws
        call relst          #relocate pointers in static} jsr relst
        ret                 #return to caller} exi
                            #end procedure reloc} enp
                            #} ejc
        .eject
#
#      relst -- relocate pointers in the static region
#
#      (xl)                  list of boundaries and adjustments
#      jsr  relst            call to process blocks in static
#      (wa,wb,wc,xr)         destroyed
#
#      only vrblks on the hash chain and any profile block are
#      processed.  other static blocks (dfblks) are processed
#      during processing of dynamic blocks.
#
#      global work locations will be processed at this point,
#      so pointers there can be relied upon.
#
relst:                      #entry point} prc e 0
        .global relst
        mov  edi,dword ptr pftbl #profile table} mov pftbl xr
        or   edi,edi        #branch if no table allocated} bze xr rls01
        jz   short rls01 # (jump shortened)
        mov  eax,dword ptr (4*rlcda)[esi] #adjust block type word} add rlcda(xl) (xr)
        add  dword ptr [edi],eax
#
#      here after dealing with profiler
#
rls01:  mov  edx,dword ptr hshtb #point to start of hash table} mov hshtb wc
        mov  ebx,edx        #point to first hash bucket} mov wc wb
        mov  ecx,dword ptr hshte #point beyond hash table} mov hshte wa
        call relaj          #adjust bucket pointers} jsr relaj
#
#      loop through slots in hash table
#
rls02:  cmp  edx,dword ptr hshte #done if none left} beq wc hshte rls05
        je   short rls05 # (jump shortened)
        mov  edi,edx        #else copy slot pointer} mov wc xr
        add  edx,4          #bump slot pointer} ica wc
        sub  edi,4*vrnxt    #set offset to merge into loop} sub *vrnxt xr
#
#      loop through vrblks on one hash chain
#
rls03:  mov  edi,dword ptr (4*vrnxt)[edi] #point to next vrblk on chain} mov vrnxt(xr) xr
        or   edi,edi        #jump for next bucket if chain end} bze xr rls02
        jz   rls02
        mov  ecx,4*vrlen    #offset of first loc past ptr fields} mov *vrlen wa
        mov  ebx,4*vrget    #offset of first location in vrblk} mov *vrget wb
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #jump if not system variable} bnz vrlen(xr) rls04
        jnz  short rls04 # (jump shortened)
        mov  ecx,4*vrsi_    #offset to include vrsvp field} mov *vrsi_ wa
#
#      merge here to process fields of vrblk
#
rls04:  add  ecx,edi        #create end ptr} add xr wa
        add  ebx,edi        #create start ptr} add xr wb
        call relaj          #adjust pointers in vrblk} jsr relaj
        jmp  rls03          #check for another vrblk on chain} brn rls03
#
#      here when all vrblks processed
#
rls05:  ret                 #return to caller} exi
                            #end procedure relst} enp
                            #} ejc
        .eject
#
#      relws -- relocate pointers in the working section
#
#      (xl)                  list of boundaries and adjustments
#      jsr  relws            call to process working section
#      (wa,wb,wc,xr)         destroyed
#
#      pointers between a$aaa and r$yyy are examined and
#      adjusted if necessary.  the pointer kvrtn is also
#      adjusted although it lies outside this range.
#      dname is explicitly adjusted because the limits
#      on dynamic region in stack are to the area actively
#      in use (between dnamb and dnamp), and dname is outside
#      this range.
#
relws:                      #entry point} prc e 0
        .global relws
        mov  ebx,offset a_aaa #point to start of adjustables} mov =a_aaa wb
        mov  ecx,offset r_yyy #point to end of adjustables} mov =r_yyy wa
        call relaj          #relocate adjustable pointers} jsr relaj
        mov  eax,dword ptr (4*rldya)[esi] #adjust ptr missed by relaj} add rldya(xl) dname
        add  dword ptr dname,eax
        mov  ebx,offset kvrtn #case of kvrtn} mov =kvrtn wb
        mov  ecx,ebx        #handled specially} mov wb wa
        add  ecx,4          #one value to adjust} ica wa
        call relaj          #adjust kvrtn} jsr relaj
        ret                 #return to caller} exi
                            #end procedure relws} enp
                            #} ttl s p i t b o l -- initialization
        .sbttl "s p i t b o l -- initialization"
#
#      initialisation
#      the following section receives control from the system
#      at the start of a run with the registers set as follows.
#
#      (wa)                  initial stack pointer
#      (xr)                  points to first word of data area
#      (xl)                  points to last word of data area
#
start:                      #entry point} prc e 0
        .global start
        mov  esp,ecx        #discard return} mov wa xs
        call systm          #initialise timer} jsr systm
        mov  dword ptr timsx,edx #store time} sti timsx
        mov  dword ptr statb,edi #start address of static} mov xr statb
        mov  dword ptr rsmem,4*e_srs #reserve memory} mov *e_srs rsmem
        mov  dword ptr stbas,esp #store stack base} mov xs stbas
                            #save s-r stack ptr} sss iniss
#
#      now convert free store percentage to a suitable factor
#      for easy testing in alloc routine.
#
        mov  edx,dword ptr intvh #get 100} ldi intvh
        mov  eax,dword ptr alfsp #form 100 / alfsp} dvi alfsp
        call dvi_
        mov  dword ptr alfsf,edx #store the factor} sti alfsf
#
#      now convert free sediment percentage to a suitable factor
#      for easy testing in gbcol routine.
#
        mov  edx,dword ptr intvh #get 100} ldi intvh
        mov  eax,dword ptr gbsdp #form 100 / gbsdp} dvi gbsdp
        call dvi_
        mov  dword ptr gbsed,edx #store the factor} sti gbsed
#
#      initialize values for real conversion routine
#
        mov  ebx,cfp_s      #load counter for significant digits} lct wb =cfp_s
        mov  eax,offset dword ptr reav1 #load 1.0} ldr reav1
        call ldr_
#
#      loop to compute 10**(max number significant digits)
#
ini03:  mov  eax,offset dword ptr reavt #* 10.0} mlr reavt
        call mlr_
        dec  ebx            #loop till done} bct wb ini03
        jnz  ini03
        mov  eax,offset dword ptr gtssc #store 10**(max sig digits)} str gtssc
        call str_
        mov  eax,offset dword ptr reap5 #load 0.5} ldr reap5
        call ldr_
        mov  eax,offset dword ptr gtssc #compute 0.5*10**(max sig digits)} dvr gtssc
        call dvr_
        mov  eax,offset dword ptr gtsrn #store as rounding bias} str gtsrn
        call str_
        xor  edx,edx        #set to read parameters} zer wc
        call prpar          #read them} jsr prpar
                            #} ejc
        .eject
#
#      now compute starting address for dynamic store and if
#      necessary request more memory.
#
        sub  esi,4*e_srs    #allow for reserve memory} sub *e_srs xl
        mov  ecx,dword ptr prlen #get print buffer length} mov prlen wa
        add  ecx,cfp_a      #add no. of chars in alphabet} add =cfp_a wa
        add  ecx,nstmx      #add chars for gtstg bfr} add =nstmx wa
        add  ecx,3+4*8      #convert to bytes, allowing a margin} ctb wa 8
        and  ecx,-4
        mov  edi,dword ptr statb #point to static base} mov statb xr
        add  edi,ecx        #increment for above buffers} add wa xr
        add  edi,4*e_hnb    #increment for hash table} add *e_hnb xr
        add  edi,4*e_sts    #bump for initial static block} add *e_sts xr
        call sysmx          #get mxlen} jsr sysmx
        mov  dword ptr kvmxl,ecx #provisionally store as maxlngth} mov wa kvmxl
        mov  dword ptr mxlen,ecx #and as mxlen} mov wa mxlen
        cmp  edi,ecx        #skip if static hi exceeds mxlen} bgt xr wa ini06
        ja   short ini06 # (jump shortened)
        add  ecx,3+4*1      #round up and make bigger than mxlen} ctb wa 1
        and  ecx,-4
        mov  edi,ecx        #use it instead} mov wa xr
#
#      here to store values which mark initial division
#      of data area into static and dynamic
#
ini06:  mov  dword ptr dnamb,edi #dynamic base adrs} mov xr dnamb
        mov  dword ptr dnamp,edi #dynamic ptr} mov xr dnamp
        or   ecx,ecx        #skip if non-zero mxlen} bnz wa ini07
        jnz  short ini07 # (jump shortened)
        sub  edi,4          #point a word in front} dca xr
        mov  dword ptr kvmxl,edi #use as maxlngth} mov xr kvmxl
        mov  dword ptr mxlen,edi #and as mxlen} mov xr mxlen
                            #} ejc
        .eject
#
#      loop here if necessary till enough memory obtained
#      so that dname is above dnamb
#
ini07:  mov  dword ptr dname,esi #store dynamic end address} mov xl dname
        cmp  dword ptr dnamb,esi #skip if high enough} blt dnamb xl ini09
        jb   ini09
        call sysmm          #request more memory} jsr sysmm
        sal  edi,2          #get as baus (sgd05)} wtb xr
        add  esi,edi        #bump by amount obtained} add xr xl
        or   edi,edi        #try again} bnz xr ini07
        jnz  ini07
        mov  ecx,mxern      #insufficient memory for maxlength} mov =mxern wa
        xor  ebx,ebx        #no column number info} zer wb
        xor  edx,edx        #no line number info} zer wc
        mov  edi,stgic      #initial compile stage} mov =stgic xr
        mov  esi,offset nulls #no file name} mov =nulls xl
        call sysea          #advise of error} jsr sysea
        .short ini08-dffnc  #cant use error logic yet} ppm ini08
        jmp  short ini08          #force termination} brn ini08 # (jump shortened)
#
#      insert text for error 329 in error message table
#
        call err_1          #} erb 329 requested maxlngth too large
        .byte 73
ini08:  mov  edi,offset endmo #point to failure message} mov =endmo xr
        mov  ecx,dword ptr endml #message length} mov endml wa
        call syspr          #print it (prtst not yet usable)} jsr syspr
        .short err_-299-dffnc #should not fail} ppm
        xor  esi,esi        #no fcb chain yet} zer xl
        mov  ebx,num10      #set special code value} mov =num10 wb
        call sysej          #pack up (stopr not yet usable)} jsr sysej
#
#      initialise structures at start of static region
#
ini09:  mov  edi,dword ptr statb #point to static again} mov statb xr
        call insta          #initialize static} jsr insta
#
#      initialize number of hash headers
#
        mov  ecx,e_hnb      #get number of hash headers} mov =e_hnb wa
        mov  edx,ecx        #convert to integer} mti wa
        mov  dword ptr hshnb,edx #store for use by gtnvr procedure} sti hshnb
        mov  dword ptr hshtb,edi #pointer to hash table} mov xr hshtb
#
#      loop to clear hash table
#
ini11:  xor  eax,eax        #blank a word} zer (xr)+
        stosd
        loop ini11          #loop} bct wa ini11
        mov  dword ptr hshte,edi #end of hash table adrs is kept} mov xr hshte
        mov  dword ptr state,edi #store static end address} mov xr state
#
#      init table to map statement numbers to source file names
#
        mov  edx,num01      #table will have only one bucket} mov =num01 wc
        mov  esi,offset nulls #default table value} mov =nulls xl
        mov  dword ptr r_sfc,esi #current source file name} mov xl r_sfc
        call tmake          #create table} jsr tmake
        mov  dword ptr r_sfn,edi #save ptr to table} mov xr r_sfn
#
#      initialize table to detect duplicate include file names
#
        mov  edx,num01      #table will have only one bucket} mov =num01 wc
        mov  esi,offset nulls #default table value} mov =nulls xl
        call tmake          #create table} jsr tmake
        mov  dword ptr r_inc,edi #save ptr to table} mov xr r_inc
#
#      initialize array to hold names of nested include files
#
        mov  ecx,ccinm      #maximum nesting level} mov =ccinm wa
        mov  esi,offset nulls #null string default value} mov =nulls xl
        call vmake          #create array} jsr vmake
        .short err_-299-dffnc #} ppm
        mov  dword ptr r_ifa,edi #save ptr to array} mov xr r_ifa
#
#      init array to hold line numbers of nested include files
#
        mov  ecx,ccinm      #maximum nesting level} mov =ccinm wa
        mov  esi,offset inton #integer one default value} mov =inton xl
        call vmake          #create array} jsr vmake
        .short err_-299-dffnc #} ppm
        mov  dword ptr r_ifl,edi #save ptr to array} mov xr r_ifl
#
#      initialize variable blocks for input and output
#
        mov  esi,offset v_inp #point to string /input/} mov =v_inp xl
        mov  ebx,trtin      #trblk type for input} mov =trtin wb
        call inout          #perform input association} jsr inout
        mov  esi,offset v_oup #point to string /output/} mov =v_oup xl
        mov  ebx,trtou      #trblk type for output} mov =trtou wb
        call inout          #perform output association} jsr inout
        mov  edx,dword ptr initr #terminal flag} mov initr wc
        or   edx,edx        #skip if no terminal} bze wc ini13
        jz   short ini13 # (jump shortened)
        call prpar          #associate terminal} jsr prpar
                            #} ejc
        .eject
#
#      check for expiry date
#
ini13:  call sysdc          #call date check} jsr sysdc
        mov  dword ptr flptr,esp #in case stack overflows in compiler} mov xs flptr
#
#      now compile source input code
#
        call cmpil          #call compiler} jsr cmpil
        mov  dword ptr r_cod,edi #set ptr to first code block} mov xr r_cod
        mov  dword ptr r_ttl,offset nulls #forget title} mov =nulls r_ttl
        mov  dword ptr r_stl,offset nulls #forget sub-title} mov =nulls r_stl
        xor  eax,eax        #forget compiler input image} zer r_cim
        mov  dword ptr r_cim,eax
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        xor  eax,eax        #in case end occurred with include} zer cnind
        mov  dword ptr cnind,eax
        xor  eax,eax        #listing include depth} zer lstid
        mov  dword ptr lstid,eax
        xor  esi,esi        #clear dud value} zer xl
        xor  ebx,ebx        #dont shift dynamic store up} zer wb
        xor  eax,eax        #collect sediment too} zer dnams
        mov  dword ptr dnams,eax
        call gbcol          #clear garbage left from compile} jsr gbcol
        mov  dword ptr dnams,edi #record new sediment size} mov xr dnams
        cmp  dword ptr dword ptr cpsts,0 #skip if no listing of comp stats} bnz cpsts inix0
        jnz  inix0
        call prtpg          #eject page} jsr prtpg
#
#      print compile statistics
#
        call prtmm          #print memory usage} jsr prtmm
        mov  edx,dword ptr cmerc #get count of errors as integer} mti cmerc
        mov  edi,offset encm3 #point to /compile errors/} mov =encm3 xr
        call prtmi          #print it} jsr prtmi
        mov  edx,dword ptr gbcnt #garbage collection count} mti gbcnt
        sub  edx,dword ptr intv1 #adjust for unavoidable collect} sbi intv1
        mov  edi,offset stpm5 #point to /storage regenerations/} mov =stpm5 xr
        call prtmi          #print gbcol count} jsr prtmi
        call systm          #get time} jsr systm
        sub  edx,dword ptr timsx #get compilation time} sbi timsx
        mov  edi,offset encm4 #point to compilation time (msec)/} mov =encm4 xr
        call prtmi          #print message} jsr prtmi
        add  dword ptr lstlc,num05 #bump line count} add =num05 lstlc
        cmp  dword ptr dword ptr headp,0 #no eject if nothing printed} bze headp inix0
        jz   short inix0 # (jump shortened)
        call prtpg          #eject printer} jsr prtpg
                            #} ejc
        .eject
#
#      prepare now to start execution
#
#      set default input record length
#
inix0:  cmp  dword ptr cswin,iniln #skip if not default -in72 used} bgt cswin =iniln inix1
        ja   short inix1 # (jump shortened)
        mov  dword ptr cswin,inils #else use default record length} mov =inils cswin
#
#      reset timer
#
inix1:  call systm          #get time again} jsr systm
        mov  dword ptr timsx,edx #store for end run processing} sti timsx
        xor  eax,eax        #initialise collect count} zer gbcnt
        mov  dword ptr gbcnt,eax
        call sysbx          #call before starting execution} jsr sysbx
        mov  eax,dword ptr cswex #add -noexecute flag} add cswex noxeq
        add  dword ptr noxeq,eax
        cmp  dword ptr dword ptr noxeq,0 #jump if execution suppressed} bnz noxeq inix2
        jnz  short inix2 # (jump shortened)
#
#      merge when listing file set for execution.  also
#      merge here when restarting a save file or load module.
#
iniy0:  mov  dword ptr headp,esp #mark headers out regardless} mnz headp
        push 0              #set failure location on stack} zer -(xs)
        mov  dword ptr flptr,esp #save ptr to failure offset word} mov xs flptr
        mov  edi,dword ptr r_cod #load ptr to entry code block} mov r_cod xr
        mov  dword ptr stage,stgxt #set stage for execute time} mov =stgxt stage
        mov  dword ptr polcs,num01 #reset interface polling interval} mov =num01 polcs
        mov  dword ptr polct,num01 #reset interface polling interval} mov =num01 polct
        mov  eax,dword ptr cmpsn #copy stmts compiled count in case} mov cmpsn pfnte
        mov  dword ptr pfnte,eax
        mov  eax,dword ptr kvpfl #start profiling if &profile set} mov kvpfl pfdmp
        mov  dword ptr pfdmp,eax
        call systm          #time yet again} jsr systm
        mov  dword ptr pfstm,edx #} sti pfstm
        call stgcc          #compute stmgo countdown counters} jsr stgcc
        jmp  dword ptr [edi] #start xeq with first statement} bri (xr)
#
#      here if execution is suppressed
#
inix2:  xor  ecx,ecx        #set abend value to zero} zer wa
        mov  ebx,nini9      #set special code value} mov =nini9 wb
        xor  esi,esi        #no fcb chain} zer xl
        call sysej          #end of job, exit to system} jsr sysej
                            #end procedure start} enp
#
#      here from osint to restart a save file or load module.
#
rstrt:                      #entry point} prc e 0
        .global rstrt
        mov  esp,dword ptr stbas #discard return} mov stbas xs
        xor  esi,esi        #clear esi} zer xl
        jmp  iniy0          #resume execution} brn iniy0
                            #end procedure rstrt} enp
                            #} ttl s p i t b o l -- snobol4 operator routines
        .sbttl "s p i t b o l -- snobol4 operator routines"
#
#      this section includes all routines which can be accessed
#      directly from the generated code except system functions.
#
#      all routines in this section start with a label of the
#      form o$xxx where xxx is three letters. the generated code
#      contains a pointer to the appropriate entry label.
#
#      since the general form of the generated code consists of
#      pointers to blocks whose first word is the address of the
#      actual entry point label (o$xxx).
#
#      these routines are in alphabetical order by their
#      entry label names (i.e. by the xxx of the o$xxx name)
#
#      these routines receive control as follows
#
#      (cp)                  pointer to next code word
#      (xs)                  current stack pointer
                            #} ejc
        .eject
#
#      binary plus (addition)
#
        .balign 2           #entry point} ent
        nop
o_add:
        call arith          #fetch arithmetic operands} jsr arith
        .short err_-1-dffnc #} err 001 addition left operand is not numeric
        .short err_-2-dffnc #} err 002 addition right operand is not numeric
        .short oadd1-dffnc  #jump if real operands} ppm oadd1
#
#      here to add two integers
#
        add  edx,dword ptr (4*icval)[esi] #add right operand to left} adi icval(xl)
        jno  exint          #return integer if no overflow} ino exint
        call err_0          #} erb 003 addition caused integer overflow
        .byte 3
#
#      here to add two reals
#
oadd1:  lea  eax,dword ptr (4*rcval)[esi] #add right operand to left} adr rcval(xl)
        call adr_
        call ovr_           #return real if no overflow} rno exrea
        jno  exrea
        call err_1          #} erb 261 addition caused real overflow
        .byte 5
                            #} ejc
        .eject
#
#      unary plus (affirmation)
#
        .balign 2           #entry point} ent
        nop
o_aff:
        pop  edi            #load operand} mov (xs)+ xr
        call gtnum          #convert to numeric} jsr gtnum
        .short err_-4-dffnc #} err 004 affirmation operand is not numeric
        push edi            #result if converted to numeric} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      binary bar (alternation)
#
        .balign 2           #entry point} ent
        nop
o_alt:
        pop  edi            #load right operand} mov (xs)+ xr
        call gtpat          #convert to pattern} jsr gtpat
        .short err_-5-dffnc #} err 005 alternation right operand is not pattern
#
#      merge here from special (left alternation) case
#
oalt1:  mov  ebx,offset p_alt #set pcode for alternative node} mov =p_alt wb
        call pbild          #build alternative node} jsr pbild
        mov  esi,edi        #save address of alternative node} mov xr xl
        pop  edi            #load left operand} mov (xs)+ xr
        call gtpat          #convert to pattern} jsr gtpat
        .short err_-6-dffnc #} err 006 alternation left operand is not pattern
        cmp  edi,offset p_alt #jump if left arg is alternation} beq xr =p_alt oalt2
        je   short oalt2 # (jump shortened)
        mov  dword ptr (4*pthen)[esi],edi #set left operand as successor} mov xr pthen(xl)
        push esi            #stack result} mov xl -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      come here if left argument is itself an alternation
#
#      the result is more efficient if we make the replacement
#
#      (a / b) / c = a / (b / c)
#
oalt2:  mov  eax,dword ptr (4*parm1)[edi] #build the (b / c) node} mov parm1(xr) pthen(xl)
        mov  dword ptr (4*pthen)[esi],eax
        push dword ptr (4*pthen)[edi] #set a as new left arg} mov pthen(xr) -(xs)
        mov  edi,esi        #set (b / c) as new right arg} mov xl xr
        jmp  oalt1          #merge back to build a / (b / c)} brn oalt1
                            #} ejc
        .eject
#
#      array reference (multiple subscripts, by name)
#
        .balign 2           #entry point} ent
        nop
o_amn:
        mov  edi,[ebp]      #load number of subscripts} lcw xr
        add  ebp,4
        mov  ebx,edi        #set flag for by name} mov xr wb
        jmp  arref          #jump to array reference routine} brn arref
                            #} ejc
        .eject
#
#      array reference (multiple subscripts, by value)
#
        .balign 2           #entry point} ent
        nop
o_amv:
        mov  edi,[ebp]      #load number of subscripts} lcw xr
        add  ebp,4
        xor  ebx,ebx        #set flag for by value} zer wb
        jmp  arref          #jump to array reference routine} brn arref
                            #} ejc
        .eject
#
#      array reference (one subscript, by name)
#
        .balign 2           #entry point} ent
        nop
o_aon:
        mov  edi,dword ptr [esp] #load subscript value} mov (xs) xr
        mov  esi,dword ptr (4*num01)[esp] #load array value} mov num01(xs) xl
        mov  ecx,dword ptr [esi] #load first word of array operand} mov (xl) wa
        cmp  ecx,offset b_vct #jump if vector reference} beq wa =b_vct oaon2
        je   short oaon2 # (jump shortened)
        cmp  ecx,offset b_tbt #jump if table reference} beq wa =b_tbt oaon3
        je   short oaon3 # (jump shortened)
#
#      here to use central array reference routine
#
oaon1:  mov  edi,num01      #set number of subscripts to one} mov =num01 xr
        mov  ebx,edi        #set flag for by name} mov xr wb
        jmp  arref          #jump to array reference routine} brn arref
#
#      here if we have a vector reference
#
oaon2:  cmp  dword ptr [edi],offset b_icl #use long routine if not integer} bne (xr) =b_icl oaon1
        jne  oaon1
        mov  edx,dword ptr (4*icval)[edi] #load integer subscript value} ldi icval(xr)
        or   edx,edx        #copy as address int, fail if ovflo} mfi wa exfal
        js   exfal
        mov  ecx,edx
        or   ecx,ecx        #fail if zero} bze wa exfal
        jz   exfal
        add  ecx,vcvlb      #compute offset in words} add =vcvlb wa
        sal  ecx,2          #convert to bytes} wtb wa
        mov  dword ptr [esp],ecx #complete name on stack} mov wa (xs)
        cmp  ecx,dword ptr (4*vclen)[esi] #exit if subscript not too large} blt wa vclen(xl) oaon4
        jb   short oaon4 # (jump shortened)
        jmp  exfal          #else fail} brn exfal
#
#      here for table reference
#
oaon3:  mov  ebx,esp        #set flag for name reference} mnz wb
        call tfind          #locate/create table element} jsr tfind
        .short exfal-dffnc  #fail if access fails} ppm exfal
        mov  dword ptr (4*num01)[esp],esi #store name base on stack} mov xl num01(xs)
        mov  dword ptr [esp],ecx #store name offset on stack} mov wa (xs)
#
#      here to exit with result on stack
#
oaon4:  mov  edi,[ebp]      #result on stack, get code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      array reference (one subscript, by value)
#
        .balign 2           #entry point} ent
        nop
o_aov:
        pop  edi            #load subscript value} mov (xs)+ xr
        pop  esi            #load array value} mov (xs)+ xl
        mov  ecx,dword ptr [esi] #load first word of array operand} mov (xl) wa
        cmp  ecx,offset b_vct #jump if vector reference} beq wa =b_vct oaov2
        je   short oaov2 # (jump shortened)
        cmp  ecx,offset b_tbt #jump if table reference} beq wa =b_tbt oaov3
        je   oaov3
#
#      here to use central array reference routine
#
oaov1:  push esi            #restack array value} mov xl -(xs)
        push edi            #restack subscript} mov xr -(xs)
        mov  edi,num01      #set number of subscripts to one} mov =num01 xr
        xor  ebx,ebx        #set flag for value call} zer wb
        jmp  arref          #jump to array reference routine} brn arref
#
#      here if we have a vector reference
#
oaov2:  cmp  dword ptr [edi],offset b_icl #use long routine if not integer} bne (xr) =b_icl oaov1
        jne  oaov1
        mov  edx,dword ptr (4*icval)[edi] #load integer subscript value} ldi icval(xr)
        or   edx,edx        #move as one word int, fail if ovflo} mfi wa exfal
        js   exfal
        mov  ecx,edx
        or   ecx,ecx        #fail if zero} bze wa exfal
        jz   exfal
        add  ecx,vcvlb      #compute offset in words} add =vcvlb wa
        sal  ecx,2          #convert to bytes} wtb wa
        cmp  ecx,dword ptr (4*vclen)[esi] #fail if subscript too large} bge wa vclen(xl) exfal
        jae  exfal
        call acess          #access value} jsr acess
        .short exfal-dffnc  #fail if access fails} ppm exfal
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      here for table reference by value
#
oaov3:  xor  ebx,ebx        #set flag for value reference} zer wb
        call tfind          #call table search routine} jsr tfind
        .short exfal-dffnc  #fail if access fails} ppm exfal
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      assignment
#
        .balign 2           #entry point} ent
        nop
o_ass:
#
#      o$rpl (pattern replacement) merges here
#
oass0:  pop  ebx            #load value to be assigned} mov (xs)+ wb
        pop  ecx            #load name offset} mov (xs)+ wa
        mov  esi,dword ptr [esp] #load name base} mov (xs) xl
        mov  dword ptr [esp],ebx #store assigned value as result} mov wb (xs)
        call asign          #perform assignment} jsr asign
        .short exfal-dffnc  #fail if assignment fails} ppm exfal
        mov  edi,[ebp]      #result on stack, get code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      compilation error
#
        .balign 2           #entry point} ent
        nop
o_cer:
        call err_0          #} erb 007 compilation error encountered during execution
        .byte 7
                            #} ejc
        .eject
#
#      unary at (cursor assignment)
#
        .balign 2           #entry point} ent
        nop
o_cas:
        pop  edx            #load name offset (parm2)} mov (xs)+ wc
        pop  edi            #load name base (parm1)} mov (xs)+ xr
        mov  ebx,offset p_cas #set pcode for cursor assignment} mov =p_cas wb
        call pbild          #build node} jsr pbild
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      concatenation
#
        .balign 2           #entry point} ent
        nop
o_cnc:
        mov  edi,dword ptr [esp] #load right argument} mov (xs) xr
        cmp  edi,offset nulls #jump if right arg is null} beq xr =nulls ocnc3
        je   ocnc3
        mov  esi,dword ptr (4*1)[esp] #load left argument} mov 1(xs) xl
        cmp  esi,offset nulls #jump if left argument is null} beq xl =nulls ocnc4
        je   ocnc4
        mov  ecx,offset b_scl #get constant to test for string} mov =b_scl wa
        cmp  ecx,dword ptr [esi] #jump if left arg not a string} bne wa (xl) ocnc2
        jne  ocnc2
        cmp  ecx,dword ptr [edi] #jump if right arg not a string} bne wa (xr) ocnc2
        jne  ocnc2
#
#      merge here to concatenate two strings
#
ocnc1:  mov  ecx,dword ptr (4*sclen)[esi] #load left argument length} mov sclen(xl) wa
        add  ecx,dword ptr (4*sclen)[edi] #compute result length} add sclen(xr) wa
        call alocs          #allocate scblk for result} jsr alocs
        mov  dword ptr (4*1)[esp],edi #store result ptr over left argument} mov xr 1(xs)
        add  edi,cfp_f      #prepare to store chars of result} psc xr
        mov  ecx,dword ptr (4*sclen)[esi] #get number of chars in left arg} mov sclen(xl) wa
        add  esi,cfp_f      #prepare to load left arg chars} plc xl
        shrd eax,ecx,1      #move characters of left argument} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        pop  esi            #load right arg pointer, pop stack} mov (xs)+ xl
        mov  ecx,dword ptr (4*sclen)[esi] #load number of chars in right arg} mov sclen(xl) wa
        add  esi,cfp_f      #prepare to load right arg chars} plc xl
        shrd eax,ecx,1      #move characters of right argument} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        xor  esi,esi        #clear garbage value in esi} zer xl
        mov  edi,[ebp]      #result on stack, get code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      come here if arguments are not both strings
#
ocnc2:  call gtstg          #convert right arg to string} jsr gtstg
        .short ocnc5-dffnc  #jump if right arg is not string} ppm ocnc5
        mov  esi,edi        #save right arg ptr} mov xr xl
        call gtstg          #convert left arg to string} jsr gtstg
        .short ocnc6-dffnc  #jump if left arg is not a string} ppm ocnc6
        push edi            #stack left argument} mov xr -(xs)
        push esi            #stack right argument} mov xl -(xs)
        mov  esi,edi        #move left arg to proper reg} mov xr xl
        mov  edi,dword ptr [esp] #move right arg to proper reg} mov (xs) xr
        jmp  ocnc1          #merge back to concatenate strings} brn ocnc1
                            #} ejc
        .eject
#
#      concatenation (continued)
#
#      come here for null right argument
#
ocnc3:  add  esp,4          #remove right arg from stack} ica xs
        mov  edi,[ebp]      #left argument on stack} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      here for null left argument
#
ocnc4:  add  esp,4          #unstack one argument} ica xs
        mov  dword ptr [esp],edi #store right argument} mov xr (xs)
        mov  edi,[ebp]      #result on stack, get code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      here if right argument is not a string
#
ocnc5:  mov  esi,edi        #move right argument ptr} mov xr xl
        pop  edi            #load left arg pointer} mov (xs)+ xr
#
#      merge here when left argument is not a string
#
ocnc6:  call gtpat          #convert left arg to pattern} jsr gtpat
        .short err_-8-dffnc #} err 008 concatenation left operand is not a string or pattern
        push edi            #save result on stack} mov xr -(xs)
        mov  edi,esi        #point to right operand} mov xl xr
        call gtpat          #convert to pattern} jsr gtpat
        .short err_-9-dffnc #} err 009 concatenation right operand is not a string or pattern
        mov  esi,edi        #move for pconc} mov xr xl
        pop  edi            #reload left operand ptr} mov (xs)+ xr
        call pconc          #concatenate patterns} jsr pconc
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      complementation
#
        .balign 2           #entry point} ent
        nop
o_com:
        pop  edi            #load operand} mov (xs)+ xr
        mov  ecx,dword ptr [edi] #load type word} mov (xr) wa
#
#      merge back here after conversion
#
ocom1:  cmp  ecx,offset b_icl #jump if integer} beq wa =b_icl ocom2
        je   short ocom2 # (jump shortened)
        cmp  ecx,offset b_rcl #jump if real} beq wa =b_rcl ocom3
        je   short ocom3 # (jump shortened)
        call gtnum          #else convert to numeric} jsr gtnum
        .short err_-10-dffnc #} err 010 negation operand is not numeric
        jmp  ocom1          #back to check cases} brn ocom1
#
#      here to complement integer
#
ocom2:  mov  edx,dword ptr (4*icval)[edi] #load integer value} ldi icval(xr)
        neg  edx            #negate} ngi
        jno  exint          #return integer if no overflow} ino exint
        call err_0          #} erb 011 negation caused integer overflow
        .byte 11
#
#      here to complement real
#
ocom3:  lea  eax,dword ptr (4*rcval)[edi] #load real value} ldr rcval(xr)
        call ldr_
        call ngr_           #negate} ngr
        jmp  exrea          #return real result} brn exrea
                            #} ejc
        .eject
#
#      binary slash (division)
#
        .balign 2           #entry point} ent
        nop
o_dvd:
        call arith          #fetch arithmetic operands} jsr arith
        .short err_-12-dffnc #} err 012 division left operand is not numeric
        .short err_-13-dffnc #} err 013 division right operand is not numeric
        .short odvd2-dffnc  #jump if real operands} ppm odvd2
#
#      here to divide two integers
#
        mov  eax,dword ptr (4*icval)[esi] #divide left operand by right} dvi icval(xl)
        call dvi_
        jno  exint          #result ok if no overflow} ino exint
        call err_0          #} erb 014 division caused integer overflow
        .byte 14
#
#      here to divide two reals
#
odvd2:  lea  eax,dword ptr (4*rcval)[esi] #divide left operand by right} dvr rcval(xl)
        call dvr_
        call ovr_           #return real if no overflow} rno exrea
        jno  exrea
        call err_1          #} erb 262 division caused real overflow
        .byte 6
                            #} ejc
        .eject
#
#      exponentiation
#
        .balign 2           #entry point} ent
        nop
o_exp:
        pop  edi            #load exponent} mov (xs)+ xr
        call gtnum          #convert to number} jsr gtnum
        .short err_-15-dffnc #} err 015 exponentiation right operand is not numeric
        mov  esi,edi        #move exponent to esi} mov xr xl
        pop  edi            #load base} mov (xs)+ xr
        call gtnum          #convert to numeric} jsr gtnum
        .short err_-16-dffnc #} err 016 exponentiation left operand is not numeric
        cmp  dword ptr [esi],offset b_rcl #jump if real exponent} beq (xl) =b_rcl oexp7
        je   oexp7
        mov  edx,dword ptr (4*icval)[esi] #load exponent} ldi icval(xl)
        or   edx,edx        #jump if negative exponent} ilt oex12
        jl   oex12
        cmp  ecx,offset b_rcl #jump if base is real} beq wa =b_rcl oexp3
        je   oexp3
#
#      here to exponentiate an integer base and integer exponent
#
        or   edx,edx        #convert exponent to 1 word integer} mfi wa oexp2
        js   short oexp2 # (jump shortened)
        mov  ecx,edx
        mov  edx,dword ptr (4*icval)[edi] #load base as initial value} ldi icval(xr)
        or   ecx,ecx        #jump into loop if non-zero exponent} bnz wa oexp1
        jnz  short oexp1 # (jump shortened)
        or   edx,edx        #error if 0**0} ieq oexp4
        je   oexp4
        mov  edx,dword ptr intv1 #nonzero**0} ldi intv1
        jmp  exint          #give one as result for nonzero**0} brn exint
#
#      loop to perform exponentiation
#
oex13:  imul edx,dword ptr (4*icval)[edi] #multiply by base} mli icval(xr)
        jo   short oexp2          #jump if overflow} iov oexp2 # (jump shortened)
oexp1:  loop oex13          #loop if more to go} bct wa oex13
        jmp  exint          #else return integer result} brn exint
#
#      here if integer overflow
#
oexp2:  call err_0          #} erb 017 exponentiation caused integer overflow
        .byte 17
                            #} ejc
        .eject
#
#      exponentiation (continued)
#
#      here to exponentiate a real to an integer power
#
oexp3:  or   edx,edx        #convert exponent to one word} mfi wa oexp6
        js   oexp6
        mov  ecx,edx
        lea  eax,dword ptr (4*rcval)[edi] #load base as initial value} ldr rcval(xr)
        call ldr_
        or   ecx,ecx        #jump into loop if non-zero exponent} bnz wa oexp5
        jnz  short oexp5 # (jump shortened)
        call cpr_           #error if 0.0**0} req oexp4
        je   short oexp4 # (jump shortened)
        mov  eax,offset dword ptr reav1 #nonzero**0} ldr reav1
        call ldr_
        jmp  exrea          #return 1.0 if nonzero**zero} brn exrea
#
#      here for error of 0**0 or 0.0**0
#
oexp4:  call err_0          #} erb 018 exponentiation result is undefined
        .byte 18
#
#      loop to perform exponentiation
#
oex14:  lea  eax,dword ptr (4*rcval)[edi] #multiply by base} mlr rcval(xr)
        call mlr_
        call ovr_           #jump if overflow} rov oexp6
        jo   short oexp6 # (jump shortened)
oexp5:  loop oex14          #loop till computation complete} bct wa oex14
        jmp  exrea          #then return real result} brn exrea
#
#      here if real overflow
#
oexp6:  call err_1          #} erb 266 exponentiation caused real overflow
        .byte 10
#
#      here with real exponent in (xl), numeric base in (xr)
#
oexp7:  cmp  dword ptr [edi],offset b_rcl #jump if base real} beq (xr) =b_rcl oexp8
        je   short oexp8 # (jump shortened)
        mov  edx,dword ptr (4*icval)[edi] #load integer base} ldi icval(xr)
        call itr_           #convert to real} itr
        call rcbld          #create real in (edi)} jsr rcbld
#
#      here with real exponent in (xl)
#      numeric base in (xr) and ra
#
oexp8:  xor  ebx,ebx        #set positive result flag} zer wb
        lea  eax,dword ptr (4*rcval)[edi] #load base to ra} ldr rcval(xr)
        call ldr_
        call cpr_           #jump if base non-zero} rne oexp9
        jne  short oexp9 # (jump shortened)
        lea  eax,dword ptr (4*rcval)[esi] #base is zero.  check exponent} ldr rcval(xl)
        call ldr_
        call cpr_           #jump if 0.0 ** 0.0} req oexp4
        je   oexp4
        mov  eax,offset dword ptr reav0 #0.0 to non-zero exponent yields 0.0} ldr reav0
        call ldr_
        jmp  exrea          #return zero result} brn exrea
#
#      here with non-zero base in (xr) and ra, exponent in (xl)
#
#      a negative base is allowed if the exponent is integral.
#
oexp9:  call cpr_           #jump if base gt 0.0} rgt oex10
        jg   short oex10 # (jump shortened)
        call ngr_           #make base positive} ngr
        call rcbld          #create positive base in (edi)} jsr rcbld
        lea  eax,dword ptr (4*rcval)[esi] #examine exponent} ldr rcval(xl)
        call ldr_
        call chp_           #chop to integral value} chp
        call rti_           #convert to integer, br if too large} rti oexp6
        jc   oexp6
        lea  eax,dword ptr (4*rcval)[esi] #chop(exponent) - exponent} sbr rcval(xl)
        call sbr_
        call cpr_           #non-integral power with neg base} rne oex11
        jne  short oex11 # (jump shortened)
        mov  ebx,edx        #record even/odd exponent} mfi wb
        and  ebx,dword ptr bits1 #odd exponent yields negative result} anb bits1 wb
        lea  eax,dword ptr (4*rcval)[edi] #restore base to ra} ldr rcval(xr)
        call ldr_
#
#      here with positive base in ra and (xr), exponent in (xl)
#
oex10:  call lnf_           #log of base} lnf
        call ovr_           #too large} rov oexp6
        jo   oexp6
        lea  eax,dword ptr (4*rcval)[esi] #times exponent} mlr rcval(xl)
        call mlr_
        call ovr_           #too large} rov oexp6
        jo   oexp6
        call etx_           #e ** (exponent * ln(base))} etx
        call ovr_           #too large} rov oexp6
        jo   oexp6
        or   ebx,ebx        #if no sign fixup required} bze wb exrea
        jz   exrea
        call ngr_           #negative result needed} ngr
        jmp  exrea          #} brn exrea
#
#      here for non-integral exponent with negative base
#
oex11:  call err_1          #} erb 311 exponentiation of negative base to non-integral power
        .byte 55
#
#      here with negative integer exponent in ia
#
oex12:  push edi            #stack base} mov xr -(xs)
        call itr_           #convert to real exponent} itr
        call rcbld          #real negative exponent in (edi)} jsr rcbld
        mov  esi,edi        #put exponent in esi} mov xr xl
        pop  edi            #restore base value} mov (xs)+ xr
        jmp  oexp7          #process real exponent} brn oexp7
                            #} ejc
        .eject
#
#      failure in expression evaluation
#
#      this entry point is used if the evaluation of an
#      expression, initiated by the evalx procedure, fails.
#      control is returned to an appropriate point in evalx.
#
        .balign 2           #entry point} ent
        nop
o_fex:
        jmp  evlx6          #jump to failure loc in evalx} brn evlx6
                            #} ejc
        .eject
#
#      failure during evaluation of a complex or direct goto
#
        .balign 2           #entry point} ent
        nop
o_fif:
        call err_0          #} erb 020 goto evaluation failure
        .byte 20
                            #} ejc
        .eject
#
#      function call (more than one argument)
#
        .balign 2           #entry point} ent
        nop
o_fnc:
        mov  ecx,[ebp]      #load number of arguments} lcw wa
        add  ebp,4
        mov  edi,[ebp]      #load function vrblk pointer} lcw xr
        add  ebp,4
        mov  esi,dword ptr (4*vrfnc)[edi] #load function pointer} mov vrfnc(xr) xl
        cmp  ecx,dword ptr (4*fargs)[esi] #use central routine if wrong num} bne wa fargs(xl) cfunc
        jne  cfunc
        jmp  dword ptr [esi] #jump to function if arg count ok} bri (xl)
                            #} ejc
        .eject
#
#      function name error
#
        .balign 2           #entry point} ent
        nop
o_fne:
        mov  ecx,[ebp]      #get next code word} lcw wa
        add  ebp,4
        cmp  ecx,offset ornm_ #fail if not evaluating expression} bne wa =ornm_ ofne1
        jne  short ofne1 # (jump shortened)
        cmp  dword ptr dword ptr (4*num02)[esp],0 #ok if expr. was wanted by value} bze num02(xs) evlx3
        jz   evlx3
#
#      here for error
#
ofne1:  call err_0          #} erb 021 function called by name returned a value
        .byte 21
                            #} ejc
        .eject
#
#      function call (single argument)
#
        .balign 2           #entry point} ent
        nop
o_fns:
        mov  edi,[ebp]      #load function vrblk pointer} lcw xr
        add  ebp,4
        mov  ecx,num01      #set number of arguments to one} mov =num01 wa
        mov  esi,dword ptr (4*vrfnc)[edi] #load function pointer} mov vrfnc(xr) xl
        cmp  ecx,dword ptr (4*fargs)[esi] #use central routine if wrong num} bne wa fargs(xl) cfunc
        jne  cfunc
        jmp  dword ptr [esi] #jump to function if arg count ok} bri (xl)
                            #} ejc
        .eject
#      call to undefined function
#
        .balign 2           #entry point} ent
        nop
o_fun:
        call err_0          #} erb 022 undefined function called
        .byte 22
                            #} ejc
        .eject
#
#      execute complex goto
#
        .balign 2           #entry point} ent
        nop
o_goc:
        mov  edi,dword ptr (4*num01)[esp] #load name base pointer} mov num01(xs) xr
        cmp  edi,dword ptr state #jump if not natural variable} bhi xr state ogoc1
        ja   short ogoc1 # (jump shortened)
        add  edi,4*vrtra    #else point to vrtra field} add *vrtra xr
        jmp  dword ptr [edi] #and jump through it} bri (xr)
#
#      here if goto operand is not natural variable
#
ogoc1:  call err_0          #} erb 023 goto operand is not a natural variable
        .byte 23
                            #} ejc
        .eject
#
#      execute direct goto
#
        .balign 2           #entry point} ent
        nop
o_god:
        mov  edi,dword ptr [esp] #load operand} mov (xs) xr
        mov  ecx,dword ptr [edi] #load first word} mov (xr) wa
        cmp  ecx,offset b_cds #jump if code block to code routine} beq wa =b_cds bcds0
        je   bcds0
        cmp  ecx,offset b_cdc #jump if code block to code routine} beq wa =b_cdc bcdc0
        je   bcdc0
        call err_0          #} erb 024 goto operand in direct goto is not code
        .byte 24
                            #} ejc
        .eject
#
#      set goto failure trap
#
#      this routine is executed at the start of a complex or
#      direct failure goto to trap a subsequent fail (see exfal)
#
        .balign 2           #entry point} ent
        nop
o_gof:
        mov  edi,dword ptr flptr #point to fail offset on stack} mov flptr xr
        add  dword ptr [edi],4 #point failure to o_fif word} ica (xr)
        add  ebp,4          #point to next code word} icp
        mov  edi,[ebp]      #fetch next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      binary dollar (immediate assignment)
#
#      the pattern built by binary dollar is a compound pattern.
#      see description at start of pattern match section for
#      details of the structure which is constructed.
#
        .balign 2           #entry point} ent
        nop
o_ima:
        mov  ebx,offset p_imc #set pcode for last node} mov =p_imc wb
        pop  edx            #pop name offset (parm2)} mov (xs)+ wc
        pop  edi            #pop name base (parm1)} mov (xs)+ xr
        call pbild          #build p_imc node} jsr pbild
        mov  esi,edi        #save ptr to node} mov xr xl
        mov  edi,dword ptr [esp] #load left argument} mov (xs) xr
        call gtpat          #convert to pattern} jsr gtpat
        .short err_-25-dffnc #} err 025 immediate assignment left operand is not pattern
        mov  dword ptr [esp],edi #save ptr to left operand pattern} mov xr (xs)
        mov  ebx,offset p_ima #set pcode for first node} mov =p_ima wb
        call pbild          #build p_ima node} jsr pbild
        pop  dword ptr (4*pthen)[edi] #set left operand as p_ima successor} mov (xs)+ pthen(xr)
        call pconc          #concatenate to form final pattern} jsr pconc
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      indirection (by name)
#
        .balign 2           #entry point} ent
        nop
o_inn:
        mov  ebx,esp        #set flag for result by name} mnz wb
        jmp  indir          #jump to common routine} brn indir
                            #} ejc
        .eject
#
#      interrogation
#
        .balign 2           #entry point} ent
        nop
o_int:
        mov  dword ptr [esp],offset nulls #replace operand with null} mov =nulls (xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      indirection (by value)
#
        .balign 2           #entry point} ent
        nop
o_inv:
        xor  ebx,ebx        #set flag for by value} zer wb
        jmp  indir          #jump to common routine} brn indir
                            #} ejc
        .eject
#
#      keyword reference (by name)
#
        .balign 2           #entry point} ent
        nop
o_kwn:
        call kwnam          #get keyword name} jsr kwnam
        jmp  exnam          #exit with result name} brn exnam
                            #} ejc
        .eject
#
#      keyword reference (by value)
#
        .balign 2           #entry point} ent
        nop
o_kwv:
        call kwnam          #get keyword name} jsr kwnam
        mov  dword ptr dnamp,edi #delete kvblk} mov xr dnamp
        call acess          #access value} jsr acess
        .short exnul-dffnc  #dummy (unused) failure return} ppm exnul
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      load expression by name
#
        .balign 2           #entry point} ent
        nop
o_lex:
        mov  ecx,4*evsi_    #set size of evblk} mov *evsi_ wa
        call alloc          #allocate space for evblk} jsr alloc
        mov  dword ptr [edi],offset b_evt #set type word} mov =b_evt (xr)
        mov  dword ptr (4*evvar)[edi],offset trbev #set dummy trblk pointer} mov =trbev evvar(xr)
        mov  ecx,[ebp]      #load exblk pointer} lcw wa
        add  ebp,4
        mov  dword ptr (4*evexp)[edi],ecx #set exblk pointer} mov wa evexp(xr)
        mov  esi,edi        #move name base to proper reg} mov xr xl
        mov  ecx,4*evvar    #set name offset = zero} mov *evvar wa
        jmp  exnam          #exit with name in (esi,ecx)} brn exnam
                            #} ejc
        .eject
#
#      load pattern value
#
        .balign 2           #entry point} ent
        nop
o_lpt:
        mov  edi,[ebp]      #load pattern pointer} lcw xr
        add  ebp,4
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      load variable name
#
        .balign 2           #entry point} ent
        nop
o_lvn:
        mov  ecx,[ebp]      #load vrblk pointer} lcw wa
        add  ebp,4
        push ecx            #stack vrblk ptr (name base)} mov wa -(xs)
        push 4*vrval        #stack name offset} mov *vrval -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      binary asterisk (multiplication)
#
        .balign 2           #entry point} ent
        nop
o_mlt:
        call arith          #fetch arithmetic operands} jsr arith
        .short err_-26-dffnc #} err 026 multiplication left operand is not numeric
        .short err_-27-dffnc #} err 027 multiplication right operand is not numeric
        .short omlt1-dffnc  #jump if real operands} ppm omlt1
#
#      here to multiply two integers
#
        imul edx,dword ptr (4*icval)[esi] #multiply left operand by right} mli icval(xl)
        jno  exint          #return integer if no overflow} ino exint
        call err_0          #} erb 028 multiplication caused integer overflow
        .byte 28
#
#      here to multiply two reals
#
omlt1:  lea  eax,dword ptr (4*rcval)[esi] #multiply left operand by right} mlr rcval(xl)
        call mlr_
        call ovr_           #return real if no overflow} rno exrea
        jno  exrea
        call err_1          #} erb 263 multiplication caused real overflow
        .byte 7
                            #} ejc
        .eject
#
#      name reference
#
        .balign 2           #entry point} ent
        nop
o_nam:
        mov  ecx,4*nmsi_    #set length of nmblk} mov *nmsi_ wa
        call alloc          #allocate nmblk} jsr alloc
        mov  dword ptr [edi],offset b_nml #set name block code} mov =b_nml (xr)
        pop  dword ptr (4*nmofs)[edi] #set name offset from operand} mov (xs)+ nmofs(xr)
        pop  dword ptr (4*nmbas)[edi] #set name base from operand} mov (xs)+ nmbas(xr)
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      negation
#
#      initial entry
#
        .balign 2           #entry point} ent
        nop
o_nta:
        mov  ecx,[ebp]      #load new failure offset} lcw wa
        add  ebp,4
        push dword ptr flptr #stack old failure pointer} mov flptr -(xs)
        push ecx            #stack new failure offset} mov wa -(xs)
        mov  dword ptr flptr,esp #set new failure pointer} mov xs flptr
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      entry after successful evaluation of operand
#
        .balign 2           #entry point} ent
        nop
o_ntb:
        mov  eax,dword ptr (4*num02)[esp] #restore old failure pointer} mov num02(xs) flptr
        mov  dword ptr flptr,eax
        jmp  exfal          #and fail} brn exfal
#
#      entry for failure during operand evaluation
#
        .balign 2           #entry point} ent
        nop
o_ntc:
        add  esp,4          #pop failure offset} ica xs
        pop  dword ptr flptr #restore old failure pointer} mov (xs)+ flptr
        jmp  exnul          #exit giving null result} brn exnul
                            #} ejc
        .eject
#
#      use of undefined operator
#
        .balign 2           #entry point} ent
        nop
o_oun:
        call err_0          #} erb 029 undefined operator referenced
        .byte 29
                            #} ejc
        .eject
#
#      binary dot (pattern assignment)
#
#      the pattern built by binary dot is a compound pattern.
#      see description at start of pattern match section for
#      details of the structure which is constructed.
#
        .balign 2           #entry point} ent
        nop
o_pas:
        mov  ebx,offset p_pac #load pcode for p_pac node} mov =p_pac wb
        pop  edx            #load name offset (parm2)} mov (xs)+ wc
        pop  edi            #load name base (parm1)} mov (xs)+ xr
        call pbild          #build p_pac node} jsr pbild
        mov  esi,edi        #save ptr to node} mov xr xl
        mov  edi,dword ptr [esp] #load left operand} mov (xs) xr
        call gtpat          #convert to pattern} jsr gtpat
        .short err_-30-dffnc #} err 030 pattern assignment left operand is not pattern
        mov  dword ptr [esp],edi #save ptr to left operand pattern} mov xr (xs)
        mov  ebx,offset p_paa #set pcode for p_paa node} mov =p_paa wb
        call pbild          #build p_paa node} jsr pbild
        pop  dword ptr (4*pthen)[edi] #set left operand as p_paa successor} mov (xs)+ pthen(xr)
        call pconc          #concatenate to form final pattern} jsr pconc
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      pattern match (by name, for replacement)
#
        .balign 2           #entry point} ent
        nop
o_pmn:
        xor  ebx,ebx        #set type code for match by name} zer wb
        jmp  match          #jump to routine to start match} brn match
                            #} ejc
        .eject
#
#      pattern match (statement)
#
#      o$pms is used in place of o$pmv when the pattern match
#      occurs at the outer (statement) level since in this
#      case the substring value need not be constructed.
#
        .balign 2           #entry point} ent
        nop
o_pms:
        mov  ebx,num02      #set flag for statement to match} mov =num02 wb
        jmp  match          #jump to routine to start match} brn match
                            #} ejc
        .eject
#
#      pattern match (by value)
#
        .balign 2           #entry point} ent
        nop
o_pmv:
        mov  ebx,num01      #set type code for value match} mov =num01 wb
        jmp  match          #jump to routine to start match} brn match
                            #} ejc
        .eject
#
#      pop top item on stack
#
        .balign 2           #entry point} ent
        nop
o_pop:
        add  esp,4          #pop top stack entry} ica xs
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      terminate execution (code compiled for end statement)
#
        .balign 2           #entry point} ent
        nop
o_stp:
        jmp  lend0          #jump to end circuit} brn lend0
                            #} ejc
        .eject
#
#      return name from expression
#      this entry points is used if the evaluation of an
#      expression, initiated by the evalx procedure, returns
#      a name. control is returned to the proper point in evalx.
#
        .balign 2           #entry point} ent
        nop
o_rnm:
        jmp  evlx4          #return to evalx procedure} brn evlx4
                            #} ejc
        .eject
#
#      pattern replacement
#
#      when this routine gets control, the following stack
#      entries have been made (see end of match routine p$nth)
#
#                            subject name base
#                            subject name offset
#                            initial cursor value
#                            final cursor value
#                            subject string pointer
#      (xs) ---------------- replacement value
#
        .balign 2           #entry point} ent
        nop
o_rpl:
        call gtstg          #convert replacement val to string} jsr gtstg
        .short err_-31-dffnc #} err 031 pattern replacement right operand is not a string
#
#      get result length and allocate result scblk
#
        mov  esi,dword ptr [esp] #load subject string pointer} mov (xs) xl
        add  ecx,dword ptr (4*sclen)[esi] #add subject string length} add sclen(xl) wa
        add  ecx,dword ptr (4*num02)[esp] #add starting cursor} add num02(xs) wa
        sub  ecx,dword ptr (4*num01)[esp] #minus final cursor = total length} sub num01(xs) wa
#        or   ecx,ecx        #jump if result is null} bze wa orpl3  (optimized)
        jz   orpl3
        push edi            #restack replacement string} mov xr -(xs)
        call alocs          #allocate scblk for result} jsr alocs
        mov  ecx,dword ptr (4*num03)[esp] #get initial cursor (part 1 len)} mov num03(xs) wa
        mov  dword ptr (4*num03)[esp],edi #stack result pointer} mov xr num03(xs)
        add  edi,cfp_f      #point to characters of result} psc xr
#
#      move part 1 (start of subject) to result
#
        or   ecx,ecx        #jump if first part is null} bze wa orpl1
        jz   short orpl1 # (jump shortened)
        mov  esi,dword ptr (4*num01)[esp] #else point to subject string} mov num01(xs) xl
        add  esi,cfp_f      #point to subject string chars} plc xl
        shrd eax,ecx,1      #move first part to result} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
                            #} ejc
        .eject
#      pattern replacement (continued)
#
#      now move in replacement value
#
orpl1:  pop  esi            #load replacement string, pop} mov (xs)+ xl
        mov  ecx,dword ptr (4*sclen)[esi] #load length} mov sclen(xl) wa
        or   ecx,ecx        #jump if null replacement} bze wa orpl2
        jz   short orpl2 # (jump shortened)
        add  esi,cfp_f      #else point to chars of replacement} plc xl
        shrd eax,ecx,1      #move in chars (part 2)} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
#
#      now move in remainder of string (part 3)
#
orpl2:  pop  esi            #load subject string pointer, pop} mov (xs)+ xl
        pop  edx            #load final cursor, pop} mov (xs)+ wc
        mov  ecx,dword ptr (4*sclen)[esi] #load subject string length} mov sclen(xl) wa
        sub  ecx,edx        #minus final cursor = part 3 length} sub wc wa
#        or   ecx,ecx        #jump to assign if part 3 is null} bze wa oass0  (optimized)
        jz   oass0
        lea  esi,[cfp_f+esi+edx] #else point to last part of string} plc xl wc
        shrd eax,ecx,1      #move part 3 to result} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        jmp  oass0          #jump to perform assignment} brn oass0
#
#      here if result is null
#
orpl3:  add  esp,4*num02    #pop subject str ptr, final cursor} add *num02 xs
        mov  dword ptr [esp],offset nulls #set null result} mov =nulls (xs)
        jmp  oass0          #jump to assign null value} brn oass0
                            #} ejc
        .eject
#
#      return value from expression
#
#      this entry points is used if the evaluation of an
#      expression, initiated by the evalx procedure, returns
#      a value. control is returned to the proper point in evalx
#
        .balign 2           #entry point} ent
        nop
o_rvl:
        jmp  evlx3          #return to evalx procedure} brn evlx3
                            #} ejc
        .eject
#
#      selection
#
#      initial entry
#
        .balign 2           #entry point} ent
        nop
o_sla:
        mov  ecx,[ebp]      #load new failure offset} lcw wa
        add  ebp,4
        push dword ptr flptr #stack old failure pointer} mov flptr -(xs)
        push ecx            #stack new failure offset} mov wa -(xs)
        mov  dword ptr flptr,esp #set new failure pointer} mov xs flptr
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      entry after successful evaluation of alternative
#
        .balign 2           #entry point} ent
        nop
o_slb:
        pop  edi            #load result} mov (xs)+ xr
        add  esp,4          #pop fail offset} ica xs
        mov  eax,dword ptr [esp] #restore old failure pointer} mov (xs) flptr
        mov  dword ptr flptr,eax
        mov  dword ptr [esp],edi #restack result} mov xr (xs)
        mov  ecx,[ebp]      #load new code offset} lcw wa
        add  ebp,4
        add  ecx,dword ptr r_cod #point to absolute code location} add r_cod wa
        mov  ebp,ecx        #set new code pointer} lcp wa
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      entry at start of subsequent alternatives
#
        .balign 2           #entry point} ent
        nop
o_slc:
        mov  ecx,[ebp]      #load new fail offset} lcw wa
        add  ebp,4
        mov  dword ptr [esp],ecx #store new fail offset} mov wa (xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      entry at start of last alternative
#
        .balign 2           #entry point} ent
        nop
o_sld:
        add  esp,4          #pop failure offset} ica xs
        pop  dword ptr flptr #restore old failure pointer} mov (xs)+ flptr
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      binary minus (subtraction)
#
        .balign 2           #entry point} ent
        nop
o_sub:
        call arith          #fetch arithmetic operands} jsr arith
        .short err_-32-dffnc #} err 032 subtraction left operand is not numeric
        .short err_-33-dffnc #} err 033 subtraction right operand is not numeric
        .short osub1-dffnc  #jump if real operands} ppm osub1
#
#      here to subtract two integers
#
        sub  edx,dword ptr (4*icval)[esi] #subtract right operand from left} sbi icval(xl)
        jno  exint          #return integer if no overflow} ino exint
        call err_0          #} erb 034 subtraction caused integer overflow
        .byte 34
#
#      here to subtract two reals
#
osub1:  lea  eax,dword ptr (4*rcval)[esi] #subtract right operand from left} sbr rcval(xl)
        call sbr_
        call ovr_           #return real if no overflow} rno exrea
        jno  exrea
        call err_1          #} erb 264 subtraction caused real overflow
        .byte 8
                            #} ejc
        .eject
#
#      dummy operator to return control to trxeq procedure
#
        .balign 2           #entry point} ent
        nop
o_txr:
        jmp  trxq1          #jump into trxeq procedure} brn trxq1
                            #} ejc
        .eject
#
#      unexpected failure
#
#      note that if a setexit trap is operating then
#      transfer to system label continue
#      will result in looping here.  difficult to avoid except
#      with a considerable overhead which is not worthwhile or
#      else by a technique such as setting kverl to zero.
#
        .balign 2           #entry point} ent
        nop
o_unf:
        call err_0          #} erb 035 unexpected failure in -nofail mode
        .byte 35
                            #} ttl s p i t b o l -- block action routines
        .sbttl "s p i t b o l -- block action routines"
#
#      the first word of every block in dynamic storage and the
#      vrget, vrsto and vrtra fields of a vrblk contain a
#      pointer to an entry point in the program. all such entry
#      points are in the following section except those for
#      pattern blocks which are in the pattern matching segment
#      later on (labels of the form p$xxx), and dope vectors
#      (d$xxx) which are in the dope vector section following
#      the pattern routines (dope vectors are used for cmblks).
#
#      the entry points in this section have labels of the
#      form b$xxy where xx is the two character block type for
#      the corresponding block and y is any letter.
#
#      in some cases, the pointers serve no other purpose than
#      to identify the block type. in this case the routine
#      is never executed and thus no code is assembled.
#
#      for each of these entry points corresponding to a block
#      an entry point identification is assembled (bl$xx).
#
#      the exact entry conditions depend on the manner in
#      which the routine is accessed and are documented with
#      the individual routines as required.
#
#      the order of these routines is alphabetical with the
#      following exceptions.
#
#      the routines for seblk and exblk entries occur first so
#      that expressions can be quickly identified from the fact
#      that their routines lie before the symbol b$e$$.
#
#      these are immediately followed by the routine for a trblk
#      so that the test against the symbol b$t$$ checks for
#      trapped values or expression values (see procedure evalp)
#
#      the pattern routines lie after this section so that
#      patterns are identified with routines starting at or
#      after the initial instruction in these routines (p$aaa).
#
#      the symbol b$aaa defines the first location for block
#      routines and the symbol p$yyy (at the end of the pattern
#      match routines section) defines the last such entry point
#
        .balign 2           #entry point of first block routine} ent bl__i
        .byte bl__i
b_aaa:
                            #} ejc
        .eject
#
#      exblk
#
#      the routine for an exblk loads the expression onto
#      the stack as a value.
#
#      (xr)                  pointer to exblk
#
        .balign 2           #entry point (exblk)} ent bl_ex
        .byte bl_ex
b_exl:
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      seblk
#
#      the routine for seblk is accessed from the generated
#      code to load the expression value onto the stack.
#
        .balign 2           #entry point (seblk)} ent bl_se
        .byte bl_se
b_sel:
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      define symbol which marks end of entries for expressions
#
        .balign 2           #entry point} ent bl__i
        .byte bl__i
b_e__:
                            #} ejc
        .eject
#
#      trblk
#
#      the routine for a trblk is never executed
#
        .balign 2           #entry point (trblk)} ent bl_tr
        .byte bl_tr
b_trt:
#
#      define symbol marking end of trap and expression blocks
#
        .balign 2           #end of trblk,seblk,exblk entries} ent bl__i
        .byte bl__i
b_t__:
                            #} ejc
        .eject
#
#      arblk
#
#      the routine for arblk is never executed
#
        .balign 2           #entry point (arblk)} ent bl_ar
        .byte bl_ar
b_art:
                            #} ejc
        .eject
#
#      bcblk
#
#      the routine for a bcblk is never executed
#
#      (xr)                  pointer to bcblk
#
        .balign 2           #entry point (bcblk)} ent bl_bc
        .byte bl_bc
b_bct:
                            #} ejc
        .eject
#
#      bfblk
#
#      the routine for a bfblk is never executed
#
#      (xr)                  pointer to bfblk
#
        .balign 2           #entry point (bfblk)} ent bl_bf
        .byte bl_bf
b_bft:
                            #} ejc
        .eject
#
#      ccblk
#
#      the routine for ccblk is never entered
#
        .balign 2           #entry point (ccblk)} ent bl_cc
        .byte bl_cc
b_cct:
                            #} ejc
        .eject
#
#      cdblk
#
#      the cdblk routines are executed from the generated code.
#      there are two cases depending on the form of cdfal.
#
#      entry for complex failure code at cdfal
#
#      (xr)                  pointer to cdblk
#
        .balign 2           #entry point (cdblk)} ent bl_cd
        .byte bl_cd
b_cdc:
bcdc0:  mov  esp,dword ptr flptr #pop garbage off stack} mov flptr xs
        mov  eax,dword ptr (4*cdfal)[edi] #set failure offset} mov cdfal(xr) (xs)
        mov  dword ptr [esp],eax
        jmp  stmgo          #enter stmt} brn stmgo
                            #} ejc
        .eject
#
#      cdblk (continued)
#
#      entry for simple failure code at cdfal
#
#      (xr)                  pointer to cdblk
#
        .balign 2           #entry point (cdblk)} ent bl_cd
        .byte bl_cd
b_cds:
bcds0:  mov  esp,dword ptr flptr #pop garbage off stack} mov flptr xs
        mov  dword ptr [esp],4*cdfal #set failure offset} mov *cdfal (xs)
        jmp  stmgo          #enter stmt} brn stmgo
                            #} ejc
        .eject
#
#      cmblk
#
#      the routine for a cmblk is never executed
#
        .balign 2           #entry point (cmblk)} ent bl_cm
        .byte bl_cm
b_cmt:
                            #} ejc
        .eject
#
#      ctblk
#
#      the routine for a ctblk is never executed
#
        .balign 2           #entry point (ctblk)} ent bl_ct
        .byte bl_ct
b_ctt:
                            #} ejc
        .eject
#
#      dfblk
#
#      the routine for a dfblk is accessed from the o$fnc entry
#      to call a datatype function and build a pdblk.
#
#      (xl)                  pointer to dfblk
#
        .balign 2           #entry point} ent bl_df
        .byte bl_df
b_dfc:
        mov  ecx,dword ptr (4*dfpdl)[esi] #load length of pdblk} mov dfpdl(xl) wa
        call alloc          #allocate pdblk} jsr alloc
        mov  dword ptr [edi],offset b_pdt #store type word} mov =b_pdt (xr)
        mov  dword ptr (4*pddfp)[edi],esi #store dfblk pointer} mov xl pddfp(xr)
        mov  edx,edi        #save pointer to pdblk} mov xr wc
        add  edi,ecx        #point past pdblk} add wa xr
        mov  ecx,dword ptr (4*fargs)[esi] #set to count fields} lct wa fargs(xl)
#
#      loop to acquire field values from stack
#
bdfc1:  lea  edi,[edi-4]    #move a field value} mov (xs)+ -(xr)
        pop  dword ptr [edi]
        loop bdfc1          #loop till all moved} bct wa bdfc1
        mov  edi,edx        #recall pointer to pdblk} mov wc xr
        jmp  exsid          #exit setting id field} brn exsid
                            #} ejc
        .eject
#
#      efblk
#
#      the routine for an efblk is passed control form the o$fnc
#      entry to call an external function.
#
#      (xl)                  pointer to efblk
#
        .balign 2           #entry point (efblk)} ent bl_ef
        .byte bl_ef
b_efc:
        mov  edx,dword ptr (4*fargs)[esi] #load number of arguments} mov fargs(xl) wc
        sal  edx,2          #convert to offset} wtb wc
        push esi            #save pointer to efblk} mov xl -(xs)
        mov  esi,esp        #copy pointer to arguments} mov xs xt
#
#      loop to convert arguments
#
befc1:  add  esi,4          #point to next entry} ica xt
        mov  edi,dword ptr [esp] #load pointer to efblk} mov (xs) xr
        sub  edx,4          #decrement eftar offset} dca wc
        add  edi,edx        #point to next eftar entry} add wc xr
        mov  edi,dword ptr (4*eftar)[edi] #load eftar entry} mov eftar(xr) xr
        jmp  dword ptr l0002[edi*4] #switch on type} bsw xr 5
        dseg_
l0002:
        .long befc7         #no conversion needed} iff 0 befc7
        .long befc2         #string} iff 1 befc2
        .long befc3         #integer} iff 2 befc3
        .long befc4         #real} iff 3 befc4
        .long beff1         #file} iff 4 beff1
        dsegend_            #end of switch on type} esw
        cseg_
#
#      here to convert to file
#
beff1:  push esi            #save entry pointer} mov xt -(xs)
        mov  dword ptr befof,edx #save offset} mov wc befof
        push dword ptr [esi] #stack arg pointer} mov (xt) -(xs)
        call iofcb          #convert to fcb} jsr iofcb
        .short err_-298-dffnc #} err 298 external function argument is not file
        .short err_-298-dffnc #} err 298 external function argument is not file
        .short err_-298-dffnc #} err 298 external function argument is not file
        mov  edi,ecx        #point to fcb} mov wa xr
        pop  esi            #reload entry pointer} mov (xs)+ xt
        jmp  befc5          #jump to merge} brn befc5
#
#      here to convert to string
#
befc2:  push dword ptr [esi] #stack arg ptr} mov (xt) -(xs)
        call gtstg          #convert argument to string} jsr gtstg
        .short err_-39-dffnc #} err 039 external function argument is not a string
        jmp  short befc6          #jump to merge} brn befc6 # (jump shortened)
                            #} ejc
        .eject
#
#      efblk (continued)
#
#      here to convert an integer
#
befc3:  mov  edi,dword ptr [esi] #load next argument} mov (xt) xr
        mov  dword ptr befof,edx #save offset} mov wc befof
        call gtint          #convert to integer} jsr gtint
        .short err_-40-dffnc #} err 040 external function argument is not integer
        jmp  short befc5          #merge with real case} brn befc5 # (jump shortened)
#
#      here to convert a real
#
befc4:  mov  edi,dword ptr [esi] #load next argument} mov (xt) xr
        mov  dword ptr befof,edx #save offset} mov wc befof
        call gtrea          #convert to real} jsr gtrea
        .short err_-265-dffnc #} err 265 external function argument is not real
#
#      integer case merges here
#
befc5:  mov  edx,dword ptr befof #restore offset} mov befof wc
#
#      string merges here
#
befc6:  mov  dword ptr [esi],edi #store converted result} mov xr (xt)
#
#      no conversion merges here
#
befc7:  or   edx,edx        #loop back if more to go} bnz wc befc1
        jnz  befc1
#
#      here after converting all the arguments
#
        pop  esi            #restore efblk pointer} mov (xs)+ xl
        mov  ecx,dword ptr (4*fargs)[esi] #get number of args} mov fargs(xl) wa
        call sysex          #call routine to call external fnc} jsr sysex
        .short exfal-dffnc  #fail if failure} ppm exfal
        .short err_-327-dffnc #} err 327 calling external function - not found
        .short err_-326-dffnc #} err 326 calling external function - bad argument type
        sal  ecx,2          #convert number of args to bytes} wtb wa
        add  esp,ecx        #remove arguments from stack} add wa xs
                            #} ejc
        .eject
#
#      efblk (continued)
#
#      return here with result in xr
#
#      first defend against non-standard null string returned
#
        mov  ebx,dword ptr (4*efrsl)[esi] #get result type id} mov efrsl(xl) wb
        or   ebx,ebx        #branch if not unconverted} bnz wb befa8
        jnz  short befa8 # (jump shortened)
        cmp  dword ptr [edi],offset b_scl #jump if not a string} bne (xr) =b_scl befc8
        jne  short befc8 # (jump shortened)
        cmp  dword ptr dword ptr (4*sclen)[edi],0 #return null if null} bze sclen(xr) exnul
        jz   exnul
#
#      here if converted result to check for null string
#
befa8:  cmp  ebx,num01      #jump if not a string} bne wb =num01 befc8
        jne  short befc8 # (jump shortened)
        cmp  dword ptr dword ptr (4*sclen)[edi],0 #return null if null} bze sclen(xr) exnul
        jz   exnul
#
#      return if result is in dynamic storage
#
befc8:  cmp  edi,dword ptr dnamb #jump if not in dynamic storage} blt xr dnamb befc9
        jb   short befc9 # (jump shortened)
        cmp  edi,dword ptr dnamp #return result if already dynamic} ble xr dnamp exixr
        jbe  exixr
#
#      here we copy a result into the dynamic region
#
befc9:  mov  ecx,dword ptr [edi] #get possible type word} mov (xr) wa
        or   ebx,ebx        #jump if unconverted result} bze wb bef11
        jz   short bef11 # (jump shortened)
        mov  ecx,offset b_scl #string} mov =b_scl wa
        cmp  ebx,num01      #yes jump} beq wb =num01 bef10
        je   short bef10 # (jump shortened)
        mov  ecx,offset b_icl #integer} mov =b_icl wa
        cmp  ebx,num02      #yes jump} beq wb =num02 bef10
        je   short bef10 # (jump shortened)
        mov  ecx,offset b_rcl #real} mov =b_rcl wa
#
#      store type word in result
#
bef10:  mov  dword ptr [edi],ecx #stored before copying to dynamic} mov wa (xr)
#
#      merge for unconverted result
#
bef11:  cmp  dword ptr [edi],offset b_scl #branch if string result} beq (xr) =b_scl bef12
        je   short bef12 # (jump shortened)
        call blkln          #get length of block} jsr blkln
        mov  esi,edi        #copy address of old block} mov xr xl
        call alloc          #allocate dynamic block same size} jsr alloc
        push edi            #set pointer to new block as result} mov xr -(xs)
        shr  ecx,2          #copy old block to dynamic block} mvw
        rep  movsd
        xor  esi,esi        #clear garbage value} zer xl
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      here to return a string result that was not in dynamic.
#      cannot use the simple word copy above because it will not
#      guarantee zero padding in the last word.
#
bef12:  mov  esi,edi        #save source string pointer} mov xr xl
        mov  ecx,dword ptr (4*sclen)[edi] #fetch string length} mov sclen(xr) wa
        or   ecx,ecx        #return null string if length zero} bze wa exnul
        jz   exnul
        call alocs          #allocate space for string} jsr alocs
        push edi            #save as result pointer} mov xr -(xs)
        add  edi,cfp_f      #prepare to store chars of result} psc xr
        add  esi,cfp_f      #point to chars in source string} plc xl
        mov  ecx,edx        #number of characters to copy} mov wc wa
        shrd eax,ecx,1      #move characters to result string} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        xor  esi,esi        #clear garbage value} zer xl
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      evblk
#
#      the routine for an evblk is never executed
#
        .balign 2           #entry point (evblk)} ent bl_ev
        .byte bl_ev
b_evt:
                            #} ejc
        .eject
#
#      ffblk
#
#      the routine for an ffblk is executed from the o$fnc entry
#      to call a field function and extract a field value/name.
#
#      (xl)                  pointer to ffblk
#
        .balign 2           #entry point (ffblk)} ent bl_ff
        .byte bl_ff
b_ffc:
        mov  edi,esi        #copy ffblk pointer} mov xl xr
        mov  edx,[ebp]      #load next code word} lcw wc
        add  ebp,4
        mov  esi,dword ptr [esp] #load pdblk pointer} mov (xs) xl
        cmp  dword ptr [esi],offset b_pdt #jump if not pdblk at all} bne (xl) =b_pdt bffc2
        jne  short bffc2 # (jump shortened)
        mov  ecx,dword ptr (4*pddfp)[esi] #load dfblk pointer from pdblk} mov pddfp(xl) wa
#
#      loop to find correct ffblk for this pdblk
#
bffc1:  cmp  ecx,dword ptr (4*ffdfp)[edi] #jump if this is the correct ffblk} beq wa ffdfp(xr) bffc3
        je   short bffc3 # (jump shortened)
        mov  edi,dword ptr (4*ffnxt)[edi] #else link to next ffblk on chain} mov ffnxt(xr) xr
        or   edi,edi        #loop back if another entry to check} bnz xr bffc1
        jnz  bffc1
#
#      here for bad argument
#
bffc2:  call err_0          #} erb 041 field function argument is wrong datatype
        .byte 41
                            #} ejc
        .eject
#
#      ffblk (continued)
#
#      here after locating correct ffblk
#
bffc3:  mov  ecx,dword ptr (4*ffofs)[edi] #load field offset} mov ffofs(xr) wa
        cmp  edx,offset ofne_ #jump if called by name} beq wc =ofne_ bffc5
        je   short bffc5 # (jump shortened)
        add  esi,ecx        #else point to value field} add wa xl
        mov  edi,dword ptr [esi] #load value} mov (xl) xr
        cmp  dword ptr [edi],offset b_trt #jump if not trapped} bne (xr) =b_trt bffc4
        jne  short bffc4 # (jump shortened)
        sub  esi,ecx        #else restore name base,offset} sub wa xl
        mov  dword ptr [esp],edx #save next code word over pdblk ptr} mov wc (xs)
        call acess          #access value} jsr acess
        .short exfal-dffnc  #fail if access fails} ppm exfal
        mov  edx,dword ptr [esp] #restore next code word} mov (xs) wc
#
#      here after getting value in (xr), xl is garbage
#
bffc4:  mov  dword ptr [esp],edi #store value on stack (over pdblk)} mov xr (xs)
        mov  edi,edx        #copy next code word} mov wc xr
        mov  esi,dword ptr [edi] #load entry address} mov (xr) xl
        jmp  esi            #jump to routine for next code word} bri xl
#
#      here if called by name
#
bffc5:  push ecx            #store name offset (base is set)} mov wa -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      icblk
#
#      the routine for icblk is executed from the generated
#      code to load an integer value onto the stack.
#
#      (xr)                  pointer to icblk
#
        .balign 2           #entry point (icblk)} ent bl_ic
        .byte bl_ic
b_icl:
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      kvblk
#
#      the routine for a kvblk is never executed.
#
        .balign 2           #entry point (kvblk)} ent bl_kv
        .byte bl_kv
b_kvt:
                            #} ejc
        .eject
#
#      nmblk
#
#      the routine for a nmblk is executed from the generated
#      code for the case of loading a name onto the stack
#      where the name is that of a natural variable which can
#      be preevaluated at compile time.
#
#      (xr)                  pointer to nmblk
#
        .balign 2           #entry point (nmblk)} ent bl_nm
        .byte bl_nm
b_nml:
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      pdblk
#
#      the routine for a pdblk is never executed
#
        .balign 2           #entry point (pdblk)} ent bl_pd
        .byte bl_pd
b_pdt:
                            #} ejc
        .eject
#
#      pfblk
#
#      the routine for a pfblk is executed from the entry o$fnc
#      to call a program defined function.
#
#      (xl)                  pointer to pfblk
#
#      the following stack entries are made before passing
#      control to the program defined function.
#
#                            saved value of first argument
#                            .
#                            saved value of last argument
#                            saved value of first local
#                            .
#                            saved value of last local
#                            saved value of function name
#                            saved code block ptr (r$cod)
#                            saved code pointer (-r$cod)
#                            saved value of flprt
#                            saved value of flptr
#                            pointer to pfblk
#      flptr --------------- zero (to be overwritten with offs)
#
        .balign 2           #entry point (pfblk)} ent bl_pf
        .byte bl_pf
b_pfc:
        mov  dword ptr bpfpf,esi #save pfblk ptr (need not be reloc)} mov xl bpfpf
        mov  edi,esi        #copy for the moment} mov xl xr
        mov  esi,dword ptr (4*pfvbl)[edi] #point to vrblk for function} mov pfvbl(xr) xl
#
#      loop to find old value of function
#
bpf01:  mov  ebx,esi        #save pointer} mov xl wb
        mov  esi,dword ptr (4*vrval)[esi] #load value} mov vrval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop if trblk} beq (xl) =b_trt bpf01
        je   bpf01
#
#      set value to null and save old function value
#
        mov  dword ptr bpfsv,esi #save old value} mov xl bpfsv
        mov  esi,ebx        #point back to block with value} mov wb xl
        mov  dword ptr (4*vrval)[esi],offset nulls #set value to null} mov =nulls vrval(xl)
        mov  ecx,dword ptr (4*fargs)[edi] #load number of arguments} mov fargs(xr) wa
        add  edi,4*pfarg    #point to pfarg entries} add *pfarg xr
        or   ecx,ecx        #jump if no arguments} bze wa bpf04
        jz   bpf04
        mov  esi,esp        #ptr to last arg} mov xs xt
        sal  ecx,2          #convert no. of args to bytes offset} wtb wa
        add  esi,ecx        #point before first arg} add wa xt
        mov  dword ptr bpfxt,esi #remember arg pointer} mov xt bpfxt
                            #} ejc
        .eject
#
#      pfblk (continued)
#
#      loop to save old argument values and set new ones
#
bpf02:  mov  esi,dword ptr [edi] #load vrblk ptr for next argument} mov (xr)+ xl
        lea  edi,[edi+4]
#
#      loop through possible trblk chain to find value
#
bpf03:  mov  edx,esi        #save pointer} mov xl wc
        mov  esi,dword ptr (4*vrval)[esi] #load next value} mov vrval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop back if trblk} beq (xl) =b_trt bpf03
        je   bpf03
#
#      save old value and get new value
#
        mov  ecx,esi        #keep old value} mov xl wa
        mov  esi,dword ptr bpfxt #point before next stacked arg} mov bpfxt xt
        lea  esi,[esi-4]    #load argument (new value)} mov -(xt) wb
        mov  ebx,dword ptr [esi]
        mov  dword ptr [esi],ecx #save old value} mov wa (xt)
        mov  dword ptr bpfxt,esi #keep arg ptr for next time} mov xt bpfxt
        mov  esi,edx        #point back to block with value} mov wc xl
        mov  dword ptr (4*vrval)[esi],ebx #set new value} mov wb vrval(xl)
        cmp  esp,dword ptr bpfxt #loop if not all done} bne xs bpfxt bpf02
        jne  bpf02
#
#      now process locals
#
bpf04:  mov  esi,dword ptr bpfpf #restore pfblk pointer} mov bpfpf xl
        mov  ecx,dword ptr (4*pfnlo)[esi] #load number of locals} mov pfnlo(xl) wa
        or   ecx,ecx        #jump if no locals} bze wa bpf07
        jz   bpf07
        mov  ebx,offset nulls #get null constant} mov =nulls wb
#
#      loop to process locals
#
bpf05:  mov  esi,dword ptr [edi] #load vrblk ptr for next local} mov (xr)+ xl
        lea  edi,[edi+4]
#
#      loop through possible trblk chain to find value
#
bpf06:  mov  edx,esi        #save pointer} mov xl wc
        mov  esi,dword ptr (4*vrval)[esi] #load next value} mov vrval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop back if trblk} beq (xl) =b_trt bpf06
        je   bpf06
#
#      save old value and set null as new value
#
        push esi            #stack old value} mov xl -(xs)
        mov  esi,edx        #point back to block with value} mov wc xl
        mov  dword ptr (4*vrval)[esi],ebx #set null as new value} mov wb vrval(xl)
        loop bpf05          #loop till all locals processed} bct wa bpf05
                            #} ejc
        .eject
#
#      pfblk (continued)
#
#      here after processing arguments and locals
#
bpf07:  xor  edi,edi        #zero reg edi in case} zer xr
        cmp  dword ptr dword ptr kvpfl,0 #skip if profiling is off} bze kvpfl bpf7c
        jz   short bpf7c # (jump shortened)
        cmp  dword ptr kvpfl,num02 #branch on type of profile} beq kvpfl =num02 bpf7a
        je   short bpf7a # (jump shortened)
#
#      here if &profile = 1
#
        call systm          #get current time} jsr systm
        mov  dword ptr pfetm,edx #save for a sec} sti pfetm
        sub  edx,dword ptr pfstm #find time used by caller} sbi pfstm
        call icbld          #build into an icblk} jsr icbld
        mov  edx,dword ptr pfetm #reload current time} ldi pfetm
        jmp  short bpf7b          #merge} brn bpf7b # (jump shortened)
#
#       here if &profile = 2
#
bpf7a:  mov  edx,dword ptr pfstm #get start time of calling stmt} ldi pfstm
        call icbld          #assemble an icblk round it} jsr icbld
        call systm          #get now time} jsr systm
#
#      both types of profile merge here
#
bpf7b:  mov  dword ptr pfstm,edx #set start time of 1st func stmt} sti pfstm
        mov  dword ptr pffnc,esp #flag function entry} mnz pffnc
#
#      no profiling merges here
#
bpf7c:  push edi            #stack icblk ptr (or zero)} mov xr -(xs)
        mov  ecx,dword ptr r_cod #load old code block pointer} mov r_cod wa
        mov  ebx,ebp        #get code pointer} scp wb
        sub  ebx,ecx        #make code pointer into offset} sub wa wb
        mov  esi,dword ptr bpfpf #recall pfblk pointer} mov bpfpf xl
        push dword ptr bpfsv #stack old value of function name} mov bpfsv -(xs)
        push ecx            #stack code block pointer} mov wa -(xs)
        push ebx            #stack code offset} mov wb -(xs)
        push dword ptr flprt #stack old flprt} mov flprt -(xs)
        push dword ptr flptr #stack old failure pointer} mov flptr -(xs)
        push esi            #stack pointer to pfblk} mov xl -(xs)
        push 0              #dummy zero entry for fail return} zer -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        mov  dword ptr flptr,esp #set new fail return value} mov xs flptr
        mov  dword ptr flprt,esp #set new flprt} mov xs flprt
        mov  ecx,dword ptr kvtra #load trace value} mov kvtra wa
        add  ecx,dword ptr kvftr #add ftrace value} add kvftr wa
#        or   ecx,ecx        #jump if tracing possible} bnz wa bpf09  (optimized)
        jnz  short bpf09 # (jump shortened)
        inc  dword ptr kvfnc #else bump fnclevel} icv kvfnc
#
#      here to actually jump to function
#
bpf08:  mov  edi,dword ptr (4*pfcod)[esi] #point to vrblk of entry label} mov pfcod(xl) xr
        mov  edi,dword ptr (4*vrlbl)[edi] #point to target code} mov vrlbl(xr) xr
        cmp  edi,offset stndl #test for undefined label} beq xr =stndl bpf17
        je   bpf17
        cmp  dword ptr [edi],offset b_trt #jump if not trapped} bne (xr) =b_trt bpf8a
        jne  short bpf8a # (jump shortened)
        mov  edi,dword ptr (4*trlbl)[edi] #else load ptr to real label code} mov trlbl(xr) xr
bpf8a:  jmp  dword ptr [edi] #off to execute function} bri (xr)
#
#      here if tracing is possible
#
bpf09:  mov  edi,dword ptr (4*pfctr)[esi] #load possible call trace trblk} mov pfctr(xl) xr
        mov  esi,dword ptr (4*pfvbl)[esi] #load vrblk pointer for function} mov pfvbl(xl) xl
        mov  ecx,4*vrval    #set name offset for variable} mov *vrval wa
        cmp  dword ptr dword ptr kvtra,0 #jump if trace mode is off} bze kvtra bpf10
        jz   short bpf10 # (jump shortened)
        or   edi,edi        #or if there is no call trace} bze xr bpf10
        jz   short bpf10 # (jump shortened)
#
#      here if call traced
#
        dec  dword ptr kvtra #decrement trace count} dcv kvtra
        cmp  dword ptr dword ptr (4*trfnc)[edi],0 #jump if print trace} bze trfnc(xr) bpf11
        jz   short bpf11 # (jump shortened)
        call trxeq          #execute function type trace} jsr trxeq
                            #} ejc
        .eject
#
#      pfblk (continued)
#
#      here to test for ftrace trace
#
bpf10:  cmp  dword ptr dword ptr kvftr,0 #jump if ftrace is off} bze kvftr bpf16
        jz   bpf16
        dec  dword ptr kvftr #else decrement ftrace} dcv kvftr
#
#      here for print trace
#
bpf11:  call prtsn          #print statement number} jsr prtsn
        call prtnm          #print function name} jsr prtnm
        mov  ecx,ch_pp      #load left paren} mov =ch_pp wa
        call prtch          #print left paren} jsr prtch
        mov  esi,dword ptr (4*num01)[esp] #recover pfblk pointer} mov num01(xs) xl
        cmp  dword ptr dword ptr (4*fargs)[esi],0 #skip if no arguments} bze fargs(xl) bpf15
        jz   bpf15
        xor  ebx,ebx        #else set argument counter} zer wb
        jmp  short bpf13          #jump into loop} brn bpf13 # (jump shortened)
#
#      loop to print argument values
#
bpf12:  mov  ecx,ch_cm      #load comma} mov =ch_cm wa
        call prtch          #print to separate from last arg} jsr prtch
#
#      merge here first time (no comma required)
#
bpf13:  mov  dword ptr [esp],ebx #save arg ctr (over failoffs is ok)} mov wb (xs)
        sal  ebx,2          #convert to byte offset} wtb wb
        add  esi,ebx        #point to next argument pointer} add wb xl
        mov  edi,dword ptr (4*pfarg)[esi] #load next argument vrblk ptr} mov pfarg(xl) xr
        sub  esi,ebx        #restore pfblk pointer} sub wb xl
        mov  edi,dword ptr (4*vrval)[edi] #load next value} mov vrval(xr) xr
        call prtvl          #print argument value} jsr prtvl
                            #} ejc
        .eject
#
#      here after dealing with one argument
#
        mov  ebx,dword ptr [esp] #restore argument counter} mov (xs) wb
        inc  ebx            #increment argument counter} icv wb
        cmp  ebx,dword ptr (4*fargs)[esi] #loop if more to print} blt wb fargs(xl) bpf12
        jb   bpf12
#
#      merge here in no args case to print paren
#
bpf15:  mov  ecx,ch_rp      #load right paren} mov =ch_rp wa
        call prtch          #print to terminate output} jsr prtch
        call prtnl          #terminate print line} jsr prtnl
#
#      merge here to exit with test for fnclevel trace
#
bpf16:  inc  dword ptr kvfnc #increment fnclevel} icv kvfnc
        mov  esi,dword ptr r_fnc #load ptr to possible trblk} mov r_fnc xl
        call ktrex          #call keyword trace routine} jsr ktrex
#
#      call function after trace tests complete
#
        mov  esi,dword ptr (4*num01)[esp] #restore pfblk pointer} mov num01(xs) xl
        jmp  bpf08          #jump back to execute function} brn bpf08
#
#      here if calling a function whose entry label is undefined
#
bpf17:  mov  eax,dword ptr (4*num02)[esp] #reset so exfal can return to evalx} mov num02(xs) flptr
        mov  dword ptr flptr,eax
        call err_1          #} erb 286 function call to undefined entry label
        .byte 30
                            #} ejc
        .eject
#
#      rcblk
#
#      the routine for an rcblk is executed from the generated
#      code to load a real value onto the stack.
#
#      (xr)                  pointer to rcblk
#
        .balign 2           #entry point (rcblk)} ent bl_rc
        .byte bl_rc
b_rcl:
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      scblk
#
#      the routine for an scblk is executed from the generated
#      code to load a string value onto the stack.
#
#      (xr)                  pointer to scblk
#
        .balign 2           #entry point (scblk)} ent bl_sc
        .byte bl_sc
b_scl:
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      tbblk
#
#      the routine for a tbblk is never executed
#
        .balign 2           #entry point (tbblk)} ent bl_tb
        .byte bl_tb
b_tbt:
                            #} ejc
        .eject
#
#      teblk
#
#      the routine for a teblk is never executed
#
        .balign 2           #entry point (teblk)} ent bl_te
        .byte bl_te
b_tet:
                            #} ejc
        .eject
#
#      vcblk
#
#      the routine for a vcblk is never executed
#
        .balign 2           #entry point (vcblk)} ent bl_vc
        .byte bl_vc
b_vct:
                            #} ejc
        .eject
#
#      vrblk
#
#      the vrblk routines are executed from the generated code.
#      there are six entries for vrblk covering various cases
#
        .balign 2           #mark start of vrblk entry points} ent bl__i
        .byte bl__i
b_vr_:
#
#      entry for vrget (trapped case). this routine is called
#      from the generated code to load the value of a variable.
#      this entry point is used if an access trace or input
#      association is currently active.
#
#      (xr)                  pointer to vrget field of vrblk
#
        .balign 2           #entry point} ent bl__i
        .byte bl__i
b_vra:
        mov  esi,edi        #copy name base (vrget = 0)} mov xr xl
        mov  ecx,4*vrval    #set name offset} mov *vrval wa
        call acess          #access value} jsr acess
        .short exfal-dffnc  #fail if access fails} ppm exfal
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrsto (error case. this routine is called from
#      the executed code for an attempt to modify the value
#      of a protected (pattern valued) natural variable.
#
        .balign 2           #entry point} ent
        nop
b_vre:
        call err_0          #} erb 042 attempt to change value of protected variable
        .byte 42
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrtra (untrapped case). this routine is called
#      from the executed code to transfer to a label.
#
#      (xr)                  pointer to vrtra field of vrblk
#
        .balign 2           #entry point} ent
        nop
b_vrg:
        mov  edi,dword ptr (4*vrlbo)[edi] #load code pointer} mov vrlbo(xr) xr
        mov  esi,dword ptr [edi] #load entry address} mov (xr) xl
        jmp  esi            #jump to routine for next code word} bri xl
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrget (untrapped case). this routine is called
#      from the generated code to load the value of a variable.
#
#      (xr)                  points to vrget field of vrblk
#
        .balign 2           #entry point} ent
        nop
b_vrl:
        push dword ptr (4*vrval)[edi] #load value onto stack (vrget = 0)} mov vrval(xr) -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrsto (untrapped case). this routine is called
#      from the generated code to store the value of a variable.
#
#      (xr)                  pointer to vrsto field of vrblk
#
        .balign 2           #entry point} ent
        nop
b_vrs:
        mov  eax,dword ptr [esp] #store value, leave on stack} mov (xs) vrvlo(xr)
        mov  dword ptr (4*vrvlo)[edi],eax
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      vrtra (trapped case). this routine is called from the
#      generated code to transfer to a label when a label
#      trace is currently active.
#
        .balign 2           #entry point} ent
        nop
b_vrt:
        sub  edi,4*vrtra    #point back to start of vrblk} sub *vrtra xr
        mov  esi,edi        #copy vrblk pointer} mov xr xl
        mov  ecx,4*vrval    #set name offset} mov *vrval wa
        mov  edi,dword ptr (4*vrlbl)[esi] #load pointer to trblk} mov vrlbl(xl) xr
        cmp  dword ptr dword ptr kvtra,0 #jump if trace is off} bze kvtra bvrt2
        jz   short bvrt2 # (jump shortened)
        dec  dword ptr kvtra #else decrement trace count} dcv kvtra
        cmp  dword ptr dword ptr (4*trfnc)[edi],0 #jump if print trace case} bze trfnc(xr) bvrt1
        jz   short bvrt1 # (jump shortened)
        call trxeq          #else execute full trace} jsr trxeq
        jmp  short bvrt2          #merge to jump to label} brn bvrt2 # (jump shortened)
#
#      here for print trace -- print colon ( label name )
#
bvrt1:  call prtsn          #print statement number} jsr prtsn
        mov  edi,esi        #copy vrblk pointer} mov xl xr
        mov  ecx,ch_cl      #colon} mov =ch_cl wa
        call prtch          #print it} jsr prtch
        mov  ecx,ch_pp      #left paren} mov =ch_pp wa
        call prtch          #print it} jsr prtch
        call prtvn          #print label name} jsr prtvn
        mov  ecx,ch_rp      #right paren} mov =ch_rp wa
        call prtch          #print it} jsr prtch
        call prtnl          #terminate line} jsr prtnl
        mov  edi,dword ptr (4*vrlbl)[esi] #point back to trblk} mov vrlbl(xl) xr
#
#      merge here to jump to label
#
bvrt2:  mov  edi,dword ptr (4*trlbl)[edi] #load pointer to actual code} mov trlbl(xr) xr
        jmp  dword ptr [edi] #execute statement at label} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrsto (trapped case). this routine is called
#      from the generated code to store the value of a variable.
#      this entry is used when a value trace or output
#      association is currently active.
#
#      (xr)                  pointer to vrsto field of vrblk
#
        .balign 2           #entry point} ent
        nop
b_vrv:
        mov  ebx,dword ptr [esp] #load value (leave copy on stack)} mov (xs) wb
        sub  edi,4*vrsto    #point to vrblk} sub *vrsto xr
        mov  esi,edi        #copy vrblk pointer} mov xr xl
        mov  ecx,4*vrval    #set offset} mov *vrval wa
        call asign          #call assignment routine} jsr asign
        .short exfal-dffnc  #fail if assignment fails} ppm exfal
        mov  edi,[ebp]      #else get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      xnblk
#
#      the routine for an xnblk is never executed
#
        .balign 2           #entry point (xnblk)} ent bl_xn
        .byte bl_xn
b_xnt:
                            #} ejc
        .eject
#
#      xrblk
#
#      the routine for an xrblk is never executed
#
        .balign 2           #entry point (xrblk)} ent bl_xr
        .byte bl_xr
b_xrt:
#
#      mark entry address past last block action routine
#
        .balign 2           #last block routine entry point} ent bl__i
        .byte bl__i
b_yyy:
                            #} ttl s p i t b o l -- pattern matching routines
        .sbttl "s p i t b o l -- pattern matching routines"
#
#      the following section consists of the pattern matching
#      routines. all pattern nodes contain a pointer (pcode)
#      to one of the routines in this section (p$xxx).
#
#      note that this section follows the b$xxx routines to
#      enable a fast test for the pattern datatype.
#
        .balign 2           #entry to mark first pattern} ent bl__i
        .byte bl__i
p_aaa:
#
#
#      the entry conditions to the match routine are as follows
#      (see o$pmn, o$pmv, o$pms and procedure match).
#
#      stack contents.
#
#                            name base (o$pmn only)
#                            name offset (o$pmn only)
#                            type (0-o$pmn, 1-o$pmv, 2-o$pms)
#      pmhbs --------------- initial cursor (zero)
#                            initial node pointer
#      xs ------------------ =ndabo (anchored), =nduna (unanch)
#
#      register values.
#
#           (xs)             set as shown in stack diagram
#           (xr)             pointer to initial pattern node
#           (wb)             initial cursor (zero)
#
#      global pattern values
#
#           r$pms            pointer to subject string scblk
#           pmssl            length of subject string in chars
#           pmdfl            dot flag, initially zero
#           pmhbs            set as shown in stack diagram
#
#      control is passed by branching through the pcode
#      field of the initial pattern node (bri (xr)).
                            #} ejc
        .eject
#
#      description of algorithm
#
#      a pattern structure is represented as a linked graph
#      of nodes with the following structure.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#           i                parm1               i
#           +------------------------------------+
#           i                parm2               i
#           +------------------------------------+
#
#      pcode is a pointer to the routine which will perform
#      the match of this particular node type.
#
#      pthen is a pointer to the successor node. i.e. the node
#      to be matched if the attempt to match this node succeeds.
#      if this is the last node of the pattern pthen points
#      to the dummy node ndnth which initiates pattern exit.
#
#      parm1, parm2 are parameters whose use varies with the
#      particular node. they are only present if required.
#
#      alternatives are handled with the special alternative
#      node whose parameter points to the node to be matched
#      if there is a failure on the successor path.
#
#      the following example illustrates the manner in which
#      the structure is built up. the pattern is
#
#      (a / b / c) (d / e)   where / is alternation
#
#      in the diagram, the node marked + represents an
#      alternative node and the dotted line from a + node
#      represents the parameter pointer to the alternative.
#
#      +---+     +---+     +---+     +---+
#      i + i-----i a i-----i + i-----i d i-----
#      +---+     +---+  i  +---+     +---+
#        .              i    .
#        .              i    .
#      +---+     +---+  i  +---+
#      i + i-----i b i--i  i e i-----
#      +---+     +---+  i  +---+
#        .              i
#        .              i
#      +---+            i
#      i c i------------i
#      +---+
                            #} ejc
        .eject
#
#      during the match, the registers are used as follows.
#
#      (xr)                  points to the current node
#      (xl)                  scratch
#      (xs)                  main stack pointer
#      (wb)                  cursor (number of chars matched)
#      (wa,wc)               scratch
#
#      to keep track of alternatives, the main stack is used as
#      a history stack and contains two word entries.
#
#      word 1                saved cursor value
#      word 2                node to match on failure
#
#      when a failure occurs, the most recent entry on this
#      stack is popped off to restore the cursor and point
#      to the node to be matched as an alternative. the entry
#      at the bottom of the stack points to the following
#      special nodes depending on the scan mode.
#
#      anchored mode         the bottom entry points to the
#                            special node ndabo which causes an
#                            abort. the cursor value stored
#                            with this entry is always zero.
#
#      unanchored mode       the bottom entry points to the
#                            special node nduna which moves the
#                            anchor point and restarts the match
#                            the cursor saved with this entry
#                            is the number of characters which
#                            lie before the initial anchor point
#                            (i.e. the number of anchor moves).
#                            this entry is three words long and
#                            also contains the initial pattern.
#
#      entries are made on this history stack by alternative
#      nodes and by some special compound patterns as described
#      later on. the following global locations are used during
#      pattern matching.
#
#      r$pms                 pointer to subject string
#      pmssl                 length of subject string
#      pmdfl                 flag set non-zero for dot patterns
#      pmhbs                 base ptr for current history stack
#
#      the following exit points are available to match routines
#
#      succp                 success in matching current node
#      failp                 failure in matching current node
                            #} ejc
        .eject
#
#      compound patterns
#
#      some patterns have implicit alternatives and their
#      representation in the pattern structure consists of a
#      linked set of nodes as indicated by these diagrams.
#
#      as before, the + represents an alternative node and
#      the dotted line from a + node is the parameter pointer
#      to the alternative pattern.
#
#      arb
#      ---
#
#           +---+            this node (p$arb) matches null
#           i b i-----       and stacks cursor, successor ptr,
#           +---+            cursor (copy) and a ptr to ndarc.
#
#
#
#
#      bal
#      ---
#
#           +---+            the p$bal node scans a balanced
#           i b i-----       string and then stacks a pointer
#           +---+            to itself on the history stack.
                            #} ejc
        .eject
#
#      compound pattern structures (continued)
#
#
#      arbno
#      -----
#
#           +---+            this alternative node matches null
#      +----i + i-----       the first time and stacks a pointer
#      i    +---+            to the argument pattern x.
#      i      .
#      i      .
#      i    +---+            node (p$aba) to stack cursor
#      i    i a i            and history stack base ptr.
#      i    +---+
#      i      i
#      i      i
#      i    +---+            this is the argument pattern. as
#      i    i x i            indicated, the successor of the
#      i    +---+            pattern is the p$abc node
#      i      i
#      i      i
#      i    +---+            this node (p$abc) pops pmhbs,
#      +----i c i            stacks old pmhbs and ptr to ndabd
#           +---+            (unless optimization has occurred)
#
#      structure and execution of this pattern resemble those of
#      recursive pattern matching and immediate assignment.
#      the alternative node at the head of the structure matches
#      null initially but on subsequent failure ensures attempt
#      to match the argument.  before the argument is matched
#      p$aba stacks the cursor, pmhbs and a ptr to p$abb.  if
#      the argument cant be matched , p$abb removes this special
#      stack entry and fails.
#      if argument is matched , p$abc restores the outer pmhbs
#      value (saved by p$aba) .  then if the argument has left
#      alternatives on stack it stacks the inner value of pmhbs
#      and a ptr to ndabd. if argument left nothing on the stack
#      it optimises by removing items stacked by p$aba.  finally
#      a check is made that argument matched more than the null
#      string (check is intended to prevent useless looping).
#      if so the successor is again the alternative node at the
#      head of the structure , ensuring a possible extra attempt
#      to match the arg if necessary.  if not , the successor to
#      alternative is taken so as to terminate the loop.  p$abd
#      restores inner pmhbs ptr and fails , thus trying to match
#      alternatives left by the arbno argument.
                            #} ejc
        .eject
#
#      compound pattern structures (continued)
#
#      breakx
#      ------
#
#           +---+            this node is a break node for
#      +----i b i            the argument to breakx, identical
#      i    +---+            to an ordinary break node.
#      i      i
#      i      i
#      i    +---+            this alternative node stacks a
#      i    i + i-----       pointer to the breakx node to
#      i    +---+            allow for subsequent failure
#      i      .
#      i      .
#      i    +---+            this is the breakx node itself. it
#      +----i x i            matches one character and then
#           +---+            proceeds back to the break node.
#
#
#
#
#      fence
#      -----
#
#           +---+            the fence node matches null and
#           i f i-----       stacks a pointer to node ndabo to
#           +---+            abort on a subsequent rematch
#
#
#
#
#      succeed
#      -------
#
#           +---+            the node for succeed matches null
#           i s i-----       and stacks a pointer to itself
#           +---+            to repeat the match on a failure.
                            #} ejc
        .eject
#
#      compound patterns (continued)
#
#      binary dot (pattern assignment)
#      -------------------------------
#
#           +---+            this node (p$paa) saves the current
#           i a i            cursor and a pointer to the
#           +---+            special node ndpab on the stack.
#             i
#             i
#           +---+            this is the structure for the
#           i x i            pattern left argument of the
#           +---+            pattern assignment call.
#             i
#             i
#           +---+            this node (p$pac) saves the cursor,
#           i c i-----       a ptr to itself, the cursor (copy)
#           +---+            and a ptr to ndpad on the stack.
#
#
#      the function of the match routine for ndpab (p$pab)
#      is simply to unstack itself and fail back onto the stack.
#
#      the match routine for p$pac also sets the global pattern
#      flag pmdfl non-zero to indicate that pattern assignments
#      may have occured in the pattern match
#
#      if pmdfl is set at the end of the match (see p$nth), the
#      history stack is scanned for matching ndpab-ndpad pairs
#      and the corresponding pattern assignments are executed.
#
#      the function of the match routine for ndpad (p$pad)
#      is simply to remove its entry from the stack and fail.
#      this includes removing the special node pointer stored
#      in addition to the standard two entries on the stack.
                            #} ejc
        .eject
#
#      compount pattern structures (continued)
#
#      fence (function)
#      ----------------
#
#           +---+            this node (p$fna) saves the
#           i a i            current history stack and a
#           +---+            pointer to ndfnb on the stack.
#             i
#             i
#           +---+            this is the pattern structure
#           i x i            given as the argument to the
#           +---+            fence function.
#             i
#             i
#           +---+            this node p$fnc restores the outer
#           i c i            history stack ptr saved in p$fna,
#           +---+            and stacks the inner stack base
#                            ptr and a pointer to ndfnd on the
#                            stack.
#
#      ndfnb (f$fnb) simply is the failure exit for pattern
#      argument failure, and it pops itself and fails onto the
#      stack.
#
#      the match routine p$fnc allows for an optimization when
#      the fence pattern leaves no alternatives.  in this case,
#      the ndfnb entry is popped, and the match continues.
#
#      ndfnd (p$fnd) is entered when the pattern fails after
#      going through a non-optimized p$fnc, and it pops the
#      stack back past the innter stack base created by p$fna
                            #} ejc
        .eject
#
#      compound patterns (continued)
#
#      expression patterns (recursive pattern matches)
#      -----------------------------------------------
#
#      initial entry for a pattern node is to the routine p$exa.
#      if the evaluated result of the expression is itself a
#      pattern, then the following steps are taken to arrange
#      for proper recursive processing.
#
#      1)   a pointer to the current node (the p$exa node) is
#           stored on the history stack with a dummy cursor.
#
#      2)   a special history stack entry is made in which the
#           node pointer points to ndexb, and the cursor value
#           is the saved value of pmhbs on entry to this node.
#           the match routine for ndexb (p$exb) restores pmhbs
#           from this cursor entry, pops off the p$exa node
#           pointer and fails.
#
#      3)   the resulting history stack pointer is saved in
#           pmhbs to establish a new level of history stack.
#
#      after matching a pattern, the end of match routine gets
#      control (p$nth). this routine proceeds as follows.
#
#      1)   load the current value of pmhbs and recognize the
#           outer level case by the fact that the associated
#           cursor in this case is the pattern match type code
#           which is less than 3. terminate the match in this
#           case and continue execution of the program.
#
#      2)   otherwise make a special history stack entry in
#           which the node pointer points to the special node
#           ndexc and the cursor is the current value of pmhbs.
#           the match routine for ndexc (p$exc) resets pmhbs to
#           this (inner) value and and then fails.
#
#      3)   using the history stack entry made on starting the
#           expression (accessible with the current value of
#           pmhbs), restore the p$exa node pointer and the old
#           pmhbs setting. take the successor and continue.
#
#      an optimization is possible if the expression pattern
#      makes no entries on the history stack. in this case,
#      instead of building the p$exc node in step 2, it is more
#      efficient to simply pop off the p$exb entry and its
#      associated node pointer. the effect is the same.
                            #} ejc
        .eject
#
#      compound patterns (continued)
#
#      binary dollar (immediate assignment)
#      ------------------------------------
#
#           +---+            this node (p$ima) stacks the cursor
#           i a i            pmhbs and a ptr to ndimb and resets
#           +---+            the stack ptr pmhbs.
#             i
#             i
#           +---+            this is the left structure for the
#           i x i            pattern left argument of the
#           +---+            immediate assignment call.
#             i
#             i
#           +---+            this node (p$imc) performs the
#           i c i-----       assignment, pops pmhbs and stacks
#           +---+            the old pmhbs and a ptr to ndimd.
#
#
#      the structure and execution of this pattern are similar
#      to those of the recursive expression pattern matching.
#
#      the match routine for ndimb (p$imb) restores the outer
#      level value of pmhbs, unstacks the saved cursor and fails
#
#      the match routine p$imc uses the current value of pmhbs
#      to locate the p$imb entry. this entry is used to make
#      the assignment and restore the outer level value of
#      pmhbs. finally, the inner level value of pmhbs and a
#      pointer to the special node ndimd are stacked.
#
#      the match routine for ndimd (p$imd) restores the inner
#      level value of pmhbs and fails back into the stack.
#
#      an optimization occurs if the inner pattern makes no
#      entries on the history stack. in this case, p$imc pops
#      the p$imb entry instead of making a p$imd entry.
                            #} ejc
        .eject
#
#      arbno
#
#      see compound patterns section for stucture and
#      algorithm for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_aba:
        push ebx            #stack cursor} mov wb -(xs)
        push edi            #stack dummy node ptr} mov xr -(xs)
        push dword ptr pmhbs #stack old stack base ptr} mov pmhbs -(xs)
        push offset ndabb   #stack ptr to node ndabb} mov =ndabb -(xs)
        mov  dword ptr pmhbs,esp #store new stack base ptr} mov xs pmhbs
        jmp  succp          #succeed} brn succp
                            #} ejc
        .eject
#
#      arbno (remove p$aba special stack entry)
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_abb:
        mov  dword ptr pmhbs,ebx #restore history stack base ptr} mov wb pmhbs
        jmp  flpop          #fail and pop dummy node ptr} brn flpop
                            #} ejc
        .eject
#
#      arbno (check if arg matched null string)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_abc:
        mov  esi,dword ptr pmhbs #keep p_abb stack base} mov pmhbs xt
        mov  ecx,dword ptr (4*num03)[esi] #load initial cursor} mov num03(xt) wa
        mov  eax,dword ptr (4*num01)[esi] #restore outer stack base ptr} mov num01(xt) pmhbs
        mov  dword ptr pmhbs,eax
        cmp  esi,esp        #jump if no history stack entries} beq xt xs pabc1
        je   short pabc1 # (jump shortened)
        push esi            #else save inner pmhbs entry} mov xt -(xs)
        push offset ndabd   #stack ptr to special node ndabd} mov =ndabd -(xs)
        jmp  short pabc2          #merge} brn pabc2 # (jump shortened)
#
#      optimise case of no extra entries on stack from arbno arg
#
pabc1:  add  esp,4*num04    #remove ndabb entry and cursor} add *num04 xs
#
#      merge to check for matching of null string
#
pabc2:  cmp  ecx,ebx        #allow further attempt if non-null} bne wa wb succp
        jne  succp
        mov  edi,dword ptr (4*pthen)[edi] #bypass alternative node so as to ...} mov pthen(xr) xr
        jmp  succp          #... refuse further match attempts} brn succp
                            #} ejc
        .eject
#
#      arbno (try for alternatives in arbno argument)
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_abd:
        mov  dword ptr pmhbs,ebx #restore inner stack base ptr} mov wb pmhbs
        jmp  failp          #and fail} brn failp
                            #} ejc
        .eject
#
#      abort
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_abo:
        jmp  exfal          #signal statement failure} brn exfal
                            #} ejc
        .eject
#
#      alternation
#
#      parm1                 alternative node
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_alt:
        push ebx            #stack cursor} mov wb -(xs)
        push dword ptr (4*parm1)[edi] #stack pointer to alternative} mov parm1(xr) -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        jmp  succp          #if all ok, then succeed} brn succp
                            #} ejc
        .eject
#
#      any (one character argument) (1-char string also)
#
#      parm1                 character argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_ans:
        cmp  ebx,dword ptr pmssl #fail if no chars left} beq wb pmssl failp
        je   failp
        mov  esi,dword ptr r_pms #else point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character} plc xl wb
        movzx ecx,byte ptr [esi] #load current character} lch wa (xl)
        cmp  ecx,dword ptr (4*parm1)[edi] #fail if no match} bne wa parm1(xr) failp
        jne  failp
        inc  ebx            #else bump cursor} icv wb
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      any (multi-character argument case)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit in ctblk
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_any:
#
#      expression argument case merges here
#
pany1:  cmp  ebx,dword ptr pmssl #fail if no characters left} beq wb pmssl failp
        je   failp
        mov  esi,dword ptr r_pms #else point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #get char ptr to current character} plc xl wb
        movzx ecx,byte ptr [esi] #load current character} lch wa (xl)
        mov  esi,dword ptr (4*parm1)[edi] #point to ctblk} mov parm1(xr) xl
        sal  ecx,2          #change to byte offset} wtb wa
        add  esi,ecx        #point to entry in ctblk} add wa xl
        mov  ecx,dword ptr (4*ctchs)[esi] #load word from ctblk} mov ctchs(xl) wa
        and  ecx,dword ptr (4*parm2)[edi] #and with selected bit} anb parm2(xr) wa
#        or   ecx,ecx        #fail if no match} zrb wa failp  (optimized)
        jz   failp
        inc  ebx            #else bump cursor} icv wb
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      any (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_ayd:
        call evals          #evaluate string argument} jsr evals
        .short err_-43-dffnc #} err 043 any evaluated argument is not a string
        .short failp-dffnc  #fail if evaluation failure} ppm failp
        .short pany1-dffnc  #merge multi-char case if ok} ppm pany1
                            #} ejc
        .eject
#
#      p$arb                 initial arb match
#
#      no parameters
#
#      the p$arb node is part of a compound pattern structure
#      for an arb pattern (see description of compound patterns)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_arb:
        mov  edi,dword ptr (4*pthen)[edi] #load successor pointer} mov pthen(xr) xr
        push ebx            #stack dummy cursor} mov wb -(xs)
        push edi            #stack successor pointer} mov xr -(xs)
        push ebx            #stack cursor} mov wb -(xs)
        push offset ndarc   #stack ptr to special node ndarc} mov =ndarc -(xs)
        jmp  dword ptr [edi] #execute next node matching null} bri (xr)
                            #} ejc
        .eject
#
#      p$arc                 extend arb match
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_arc:
        cmp  ebx,dword ptr pmssl #fail and pop stack to successor} beq wb pmssl flpop
        je   flpop
        inc  ebx            #else bump cursor} icv wb
        push ebx            #stack updated cursor} mov wb -(xs)
        push edi            #restack pointer to ndarc node} mov xr -(xs)
        mov  edi,dword ptr (4*num02)[esp] #load successor pointer} mov num02(xs) xr
        jmp  dword ptr [edi] #off to reexecute successor node} bri (xr)
                            #} ejc
        .eject
#
#      bal
#
#      no parameters
#
#      the p$bal node is part of the compound structure built
#      for bal (see section on compound patterns).
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_bal:
        xor  edx,edx        #zero parentheses level counter} zer wc
        mov  esi,dword ptr r_pms #point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character} plc xl wb
        jmp  short pbal2          #jump into scan loop} brn pbal2 # (jump shortened)
#
#      loop to scan out characters
#
pbal1:  movzx ecx,byte ptr [esi] #load next character, bump pointer} lch wa (xl)+
        inc  esi
        inc  ebx            #push cursor for character} icv wb
        cmp  ecx,ch_pp      #jump if left paren} beq wa =ch_pp pbal3
        je   short pbal3 # (jump shortened)
        cmp  ecx,ch_rp      #jump if right paren} beq wa =ch_rp pbal4
        je   short pbal4 # (jump shortened)
        or   edx,edx        #else succeed if at outer level} bze wc pbal5
        jz   short pbal5 # (jump shortened)
#
#      here after processing one character
#
pbal2:  cmp  ebx,dword ptr pmssl #loop back unless end of string} bne wb pmssl pbal1
        jne  pbal1
        jmp  failp          #in which case, fail} brn failp
#
#      here on left paren
#
pbal3:  inc  edx            #bump paren level} icv wc
        jmp  pbal2          #loop back to check end of string} brn pbal2
#
#      here for right paren
#
pbal4:  or   edx,edx        #fail if no matching left paren} bze wc failp
        jz   failp
        dec  edx            #else decrement level counter} dcv wc
#        or   edx,edx        #loop back if not at outer level} bnz wc pbal2  (optimized)
        jnz  pbal2
#
#      here after successfully scanning a balanced string
#
pbal5:  push ebx            #stack cursor} mov wb -(xs)
        push edi            #stack ptr to bal node for extend} mov xr -(xs)
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      break (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_bkd:
        call evals          #evaluate string expression} jsr evals
        .short err_-44-dffnc #} err 044 break evaluated argument is not a string
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short pbrk1-dffnc  #merge with multi-char case if ok} ppm pbrk1
                            #} ejc
        .eject
#
#      break (one character argument)
#
#      parm1                 character argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_bks:
        mov  edx,dword ptr pmssl #get subject string length} mov pmssl wc
        sub  edx,ebx        #get number of characters left} sub wb wc
#        or   edx,edx        #fail if no characters left} bze wc failp  (optimized)
        jz   failp
        mov  esi,dword ptr r_pms #point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character} plc xl wb
#
#      loop to scan till break character found
#
pbks1:  movzx ecx,byte ptr [esi] #load next char, bump pointer} lch wa (xl)+
        inc  esi
        cmp  ecx,dword ptr (4*parm1)[edi] #succeed if break character found} beq wa parm1(xr) succp
        je   succp
        inc  ebx            #else push cursor} icv wb
        dec  edx            #loop back if more to go} bct wc pbks1
        jnz  pbks1
        jmp  failp          #fail if end of string, no break chr} brn failp
                            #} ejc
        .eject
#
#      break (multi-character argument)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit column
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_brk:
#
#      expression argument merges here
#
pbrk1:  mov  edx,dword ptr pmssl #load subject string length} mov pmssl wc
        sub  edx,ebx        #get number of characters left} sub wb wc
#        or   edx,edx        #fail if no characters left} bze wc failp  (optimized)
        jz   failp
        mov  esi,dword ptr r_pms #else point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character} plc xl wb
        mov  dword ptr psave,edi #save node pointer} mov xr psave
#
#      loop to search for break character
#
pbrk2:  movzx ecx,byte ptr [esi] #load next char, bump pointer} lch wa (xl)+
        inc  esi
        mov  edi,dword ptr (4*parm1)[edi] #load pointer to ctblk} mov parm1(xr) xr
        sal  ecx,2          #convert to byte offset} wtb wa
        add  edi,ecx        #point to ctblk entry} add wa xr
        mov  ecx,dword ptr (4*ctchs)[edi] #load ctblk word} mov ctchs(xr) wa
        mov  edi,dword ptr psave #restore node pointer} mov psave xr
        and  ecx,dword ptr (4*parm2)[edi] #and with selected bit} anb parm2(xr) wa
#        or   ecx,ecx        #succeed if break character found} nzb wa succp  (optimized)
        jnz  succp
        inc  ebx            #else push cursor} icv wb
        dec  edx            #loop back unless end of string} bct wc pbrk2
        jnz  pbrk2
        jmp  failp          #fail if end of string, no break chr} brn failp
                            #} ejc
        .eject
#
#      breakx (extension)
#
#      this is the entry which causes an extension of a breakx
#      match when failure occurs. see section on compound
#      patterns for full details of breakx matching.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_bkx:
        inc  ebx            #step cursor past previous break chr} icv wb
        jmp  succp          #succeed to rematch break} brn succp
                            #} ejc
        .eject
#
#      breakx (expression argument)
#
#      see section on compound patterns for full structure of
#      breakx pattern. the actual character matching uses a
#      break node. however, the entry for the expression
#      argument case is separated to get proper error messages.
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_bxd:
        call evals          #evaluate string argument} jsr evals
        .short err_-45-dffnc #} err 045 breakx evaluated argument is not a string
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short pbrk1-dffnc  #merge with break if all ok} ppm pbrk1
                            #} ejc
        .eject
#
#      cursor assignment
#
#      parm1                 name base
#      parm2                 name offset
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_cas:
        push edi            #save node pointer} mov xr -(xs)
        push ebx            #save cursor} mov wb -(xs)
        mov  esi,dword ptr (4*parm1)[edi] #load name base} mov parm1(xr) xl
        mov  edx,ebx        #load cursor as integer} mti wb
        mov  ebx,dword ptr (4*parm2)[edi] #load name offset} mov parm2(xr) wb
        call icbld          #get icblk for cursor value} jsr icbld
        mov  ecx,ebx        #move name offset} mov wb wa
        mov  ebx,edi        #move value to assign} mov xr wb
        call asinp          #perform assignment} jsr asinp
        .short flpop-dffnc  #fail on assignment failure} ppm flpop
        pop  ebx            #else restore cursor} mov (xs)+ wb
        pop  edi            #restore node pointer} mov (xs)+ xr
        jmp  succp          #and succeed matching null} brn succp
                            #} ejc
        .eject
#
#      expression node (p$exa, initial entry)
#
#      see compound patterns description for the structure and
#      algorithms for handling expression nodes.
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_exa:
        call evalp          #evaluate expression} jsr evalp
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        cmp  ecx,offset p_aaa #jump if result is not a pattern} blo wa =p_aaa pexa1
        jb   short pexa1 # (jump shortened)
#
#      here if result of expression is a pattern
#
        push ebx            #stack dummy cursor} mov wb -(xs)
        push edi            #stack ptr to p_exa node} mov xr -(xs)
        push dword ptr pmhbs #stack history stack base ptr} mov pmhbs -(xs)
        push offset ndexb   #stack ptr to special node ndexb} mov =ndexb -(xs)
        mov  dword ptr pmhbs,esp #store new stack base pointer} mov xs pmhbs
        mov  edi,esi        #copy node pointer} mov xl xr
        jmp  dword ptr [edi] #match first node in expression pat} bri (xr)
#
#      here if result of expression is not a pattern
#
pexa1:  cmp  ecx,offset b_scl #jump if it is already a string} beq wa =b_scl pexa2
        je   short pexa2 # (jump shortened)
        push esi            #else stack result} mov xl -(xs)
        mov  esi,edi        #save node pointer} mov xr xl
        call gtstg          #convert result to string} jsr gtstg
        .short err_-46-dffnc #} err 046 expression does not evaluate to pattern
        mov  edx,edi        #copy string pointer} mov xr wc
        mov  edi,esi        #restore node pointer} mov xl xr
        mov  esi,edx        #copy string pointer again} mov wc xl
#
#      merge here with string pointer in xl
#
pexa2:  cmp  dword ptr dword ptr (4*sclen)[esi],0 #just succeed if null string} bze sclen(xl) succp
        jz   succp
        jmp  pstr1          #else merge with string circuit} brn pstr1
                            #} ejc
        .eject
#
#      expression node (p$exb, remove ndexb entry)
#
#      see compound patterns description for the structure and
#      algorithms for handling expression nodes.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_exb:
        mov  dword ptr pmhbs,ebx #restore outer level stack pointer} mov wb pmhbs
        jmp  flpop          #fail and pop p_exa node ptr} brn flpop
                            #} ejc
        .eject
#
#      expression node (p$exc, remove ndexc entry)
#
#      see compound patterns description for the structure and
#      algorithms for handling expression nodes.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_exc:
        mov  dword ptr pmhbs,ebx #restore inner stack base pointer} mov wb pmhbs
        jmp  failp          #and fail into expr pattern alternvs} brn failp
                            #} ejc
        .eject
#
#      fail
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fal:
        jmp  failp          #just signal failure} brn failp
                            #} ejc
        .eject
#
#      fence
#
#      see compound patterns section for the structure and
#      algorithm for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fen:
        push ebx            #stack dummy cursor} mov wb -(xs)
        push offset ndabo   #stack ptr to abort node} mov =ndabo -(xs)
        jmp  succp          #and succeed matching null} brn succp
                            #} ejc
        .eject
#
#      fence (function)
#
#      see compound patterns comments at start of this section
#      for details of scheme
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fna:
        push dword ptr pmhbs #stack current history stack base} mov pmhbs -(xs)
        push offset ndfnb   #stack indir ptr to p_fnb (failure)} mov =ndfnb -(xs)
        mov  dword ptr pmhbs,esp #begin new history stack} mov xs pmhbs
        jmp  succp          #succeed} brn succp
                            #} ejc
        .eject
#
#      fence (function) (reset history stack and fail)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fnb:
        mov  dword ptr pmhbs,ebx #restore outer pmhbs stack base} mov wb pmhbs
        jmp  failp          #...and fail} brn failp
                            #} ejc
        .eject
#
#      fence (function) (make fence trap entry on stack)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fnc:
        mov  esi,dword ptr pmhbs #get inner stack base ptr} mov pmhbs xt
        mov  eax,dword ptr (4*num01)[esi] #restore outer stack base} mov num01(xt) pmhbs
        mov  dword ptr pmhbs,eax
        cmp  esi,esp        #optimize if no alternatives} beq xt xs pfnc1
        je   short pfnc1 # (jump shortened)
        push esi            #else stack inner stack base} mov xt -(xs)
        push offset ndfnd   #stack ptr to ndfnd} mov =ndfnd -(xs)
        jmp  succp          #succeed} brn succp
#
#      here when fence function left nothing on the stack
#
pfnc1:  add  esp,4*num02    #pop off p_fnb entry} add *num02 xs
        jmp  succp          #succeed} brn succp
                            #} ejc
        .eject
#
#      fence (function) (skip past alternatives on failure)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fnd:
        mov  esp,ebx        #pop stack to fence() history base} mov wb xs
        jmp  flpop          #pop base entry and fail} brn flpop
                            #} ejc
        .eject
#
#      immediate assignment (initial entry, save current cursor)
#
#      see compound patterns description for details of the
#      structure and algorithm for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_ima:
        push ebx            #stack cursor} mov wb -(xs)
        push edi            #stack dummy node pointer} mov xr -(xs)
        push dword ptr pmhbs #stack old stack base pointer} mov pmhbs -(xs)
        push offset ndimb   #stack ptr to special node ndimb} mov =ndimb -(xs)
        mov  dword ptr pmhbs,esp #store new stack base pointer} mov xs pmhbs
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      immediate assignment (remove cursor mark entry)
#
#      see compound patterns description for details of the
#      structure and algorithms for matching this node type.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_imb:
        mov  dword ptr pmhbs,ebx #restore history stack base ptr} mov wb pmhbs
        jmp  flpop          #fail and pop dummy node ptr} brn flpop
                            #} ejc
        .eject
#
#      immediate assignment (perform actual assignment)
#
#      see compound patterns description for details of the
#      structure and algorithms for matching this node type.
#
#      parm1                 name base of variable
#      parm2                 name offset of variable
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_imc:
        mov  esi,dword ptr pmhbs #load pointer to p_imb entry} mov pmhbs xt
        mov  ecx,ebx        #copy final cursor} mov wb wa
        mov  ebx,dword ptr (4*num03)[esi] #load initial cursor} mov num03(xt) wb
        mov  eax,dword ptr (4*num01)[esi] #restore outer stack base pointer} mov num01(xt) pmhbs
        mov  dword ptr pmhbs,eax
        cmp  esi,esp        #jump if no history stack entries} beq xt xs pimc1
        je   short pimc1 # (jump shortened)
        push esi            #else save inner pmhbs pointer} mov xt -(xs)
        push offset ndimd   #and a ptr to special node ndimd} mov =ndimd -(xs)
        jmp  short pimc2          #merge} brn pimc2 # (jump shortened)
#
#      here if no entries made on history stack
#
pimc1:  add  esp,4*num04    #remove ndimb entry and cursor} add *num04 xs
#
#      merge here to perform assignment
#
pimc2:  push ecx            #save current (final) cursor} mov wa -(xs)
        push edi            #save current node pointer} mov xr -(xs)
        mov  esi,dword ptr r_pms #point to subject string} mov r_pms xl
        sub  ecx,ebx        #compute substring length} sub wb wa
        call sbstr          #build substring} jsr sbstr
        mov  ebx,edi        #move result} mov xr wb
        mov  edi,dword ptr [esp] #reload node pointer} mov (xs) xr
        mov  esi,dword ptr (4*parm1)[edi] #load name base} mov parm1(xr) xl
        mov  ecx,dword ptr (4*parm2)[edi] #load name offset} mov parm2(xr) wa
        call asinp          #perform assignment} jsr asinp
        .short flpop-dffnc  #fail if assignment fails} ppm flpop
        pop  edi            #else restore node pointer} mov (xs)+ xr
        pop  ebx            #restore cursor} mov (xs)+ wb
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      immediate assignment (remove ndimd entry on failure)
#
#      see compound patterns description for details of the
#      structure and algorithms for matching this node type.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_imd:
        mov  dword ptr pmhbs,ebx #restore inner stack base pointer} mov wb pmhbs
        jmp  failp          #and fail} brn failp
                            #} ejc
        .eject
#
#      len (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_len:
#
#      expression argument case merges here
#
plen1:  add  ebx,dword ptr (4*parm1)[edi] #push cursor indicated amount} add parm1(xr) wb
        cmp  ebx,dword ptr pmssl #succeed if not off end} ble wb pmssl succp
        jbe  succp
        jmp  failp          #else fail} brn failp
                            #} ejc
        .eject
#
#      len (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_lnd:
        call evali          #evaluate integer argument} jsr evali
        .short err_-47-dffnc #} err 047 len evaluated argument is not integer
        .short err_-48-dffnc #} err 048 len evaluated argument is negative or too large
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short plen1-dffnc  #merge with normal circuit if ok} ppm plen1
                            #} ejc
        .eject
#
#      notany (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_nad:
        call evals          #evaluate string argument} jsr evals
        .short err_-49-dffnc #} err 049 notany evaluated argument is not a string
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short pnay1-dffnc  #merge with multi-char case if ok} ppm pnay1
                            #} ejc
        .eject
#
#      notany (one character argument)
#
#      parm1                 character argument
#
        .balign 2           #entry point} ent bl_p1
        .byte bl_p1
p_nas:
        cmp  ebx,dword ptr pmssl #fail if no chars left} beq wb pmssl failp
        je   failp
        mov  esi,dword ptr r_pms #else point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character in strin} plc xl wb
        movzx ecx,byte ptr [esi] #load current character} lch wa (xl)
        cmp  ecx,dword ptr (4*parm1)[edi] #fail if match} beq wa parm1(xr) failp
        je   failp
        inc  ebx            #else bump cursor} icv wb
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      notany (multi-character string argument)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit column
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_nay:
#
#      expression argument case merges here
#
pnay1:  cmp  ebx,dword ptr pmssl #fail if no characters left} beq wb pmssl failp
        je   failp
        mov  esi,dword ptr r_pms #else point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character} plc xl wb
        movzx ecx,byte ptr [esi] #load current character} lch wa (xl)
        sal  ecx,2          #convert to byte offset} wtb wa
        mov  esi,dword ptr (4*parm1)[edi] #load pointer to ctblk} mov parm1(xr) xl
        add  esi,ecx        #point to entry in ctblk} add wa xl
        mov  ecx,dword ptr (4*ctchs)[esi] #load entry from ctblk} mov ctchs(xl) wa
        and  ecx,dword ptr (4*parm2)[edi] #and with selected bit} anb parm2(xr) wa
#        or   ecx,ecx        #fail if character is matched} nzb wa failp  (optimized)
        jnz  failp
        inc  ebx            #else bump cursor} icv wb
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      end of pattern match
#
#      this routine is entered on successful completion.
#      see description of expression patterns in compound
#      pattern section for handling of recursion in matching.
#
#      this pattern also results from an attempt to convert the
#      null string to a pattern via convert()
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk (dummy)} ent bl_p0
        .byte bl_p0
p_nth:
        mov  esi,dword ptr pmhbs #load pointer to base of stack} mov pmhbs xt
        mov  ecx,dword ptr (4*num01)[esi] #load saved pmhbs (or pattern type)} mov num01(xt) wa
        cmp  ecx,num02      #jump if outer level (pattern type)} ble wa =num02 pnth2
        jbe  short pnth2 # (jump shortened)
#
#      here we are at the end of matching an expression pattern
#
        mov  dword ptr pmhbs,ecx #restore outer stack base pointer} mov wa pmhbs
        mov  edi,dword ptr (4*num02)[esi] #restore pointer to p_exa node} mov num02(xt) xr
        cmp  esi,esp        #jump if no history stack entries} beq xt xs pnth1
        je   short pnth1 # (jump shortened)
        push esi            #else stack inner stack base ptr} mov xt -(xs)
        push offset ndexc   #stack ptr to special node ndexc} mov =ndexc -(xs)
        jmp  succp          #and succeed} brn succp
#
#      here if no history stack entries during pattern
#
pnth1:  add  esp,4*num04    #remove p_exb entry and node ptr} add *num04 xs
        jmp  succp          #and succeed} brn succp
#
#      here if end of match at outer level
#
pnth2:  mov  dword ptr pmssl,ebx #save final cursor in safe place} mov wb pmssl
        cmp  dword ptr dword ptr pmdfl,0 #jump if no pattern assignments} bze pmdfl pnth6
        jz   pnth6
                            #} ejc
        .eject
#
#      end of pattern match (continued)
#
#      now we must perform pattern assignments. this is done by
#      scanning the history stack for matching ndpab-ndpad pairs
#
pnth3:  sub  esi,4          #point past cursor entry} dca xt
        lea  esi,[esi-4]    #load node pointer} mov -(xt) wa
        mov  ecx,dword ptr [esi]
        cmp  ecx,offset ndpad #jump if ndpad entry} beq wa =ndpad pnth4
        je   short pnth4 # (jump shortened)
        cmp  ecx,offset ndpab #jump if not ndpab entry} bne wa =ndpab pnth5
        jne  pnth5
#
#      here for ndpab entry, stack initial cursor
#      note that there must be more entries on the stack.
#
        push dword ptr (4*num01)[esi] #stack initial cursor} mov num01(xt) -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        jmp  pnth3          #loop back if ok} brn pnth3
#
#      here for ndpad entry. the starting cursor from the
#      matching ndpad entry is now the top stack entry.
#
pnth4:  mov  ecx,dword ptr (4*num01)[esi] #load final cursor} mov num01(xt) wa
        mov  ebx,dword ptr [esp] #load initial cursor from stack} mov (xs) wb
        mov  dword ptr [esp],esi #save history stack scan ptr} mov xt (xs)
        sub  ecx,ebx        #compute length of string} sub wb wa
#
#      build substring and perform assignment
#
        mov  esi,dword ptr r_pms #point to subject string} mov r_pms xl
        call sbstr          #construct substring} jsr sbstr
        mov  ebx,edi        #copy substring pointer} mov xr wb
        mov  esi,dword ptr [esp] #reload history stack scan ptr} mov (xs) xt
        mov  esi,dword ptr (4*num02)[esi] #load pointer to p_pac node with nam} mov num02(xt) xl
        mov  ecx,dword ptr (4*parm2)[esi] #load name offset} mov parm2(xl) wa
        mov  esi,dword ptr (4*parm1)[esi] #load name base} mov parm1(xl) xl
        call asinp          #perform assignment} jsr asinp
        .short exfal-dffnc  #match fails if name eval fails} ppm exfal
        pop  esi            #else restore history stack ptr} mov (xs)+ xt
                            #} ejc
        .eject
#
#      end of pattern match (continued)
#
#      here check for end of entries
#
pnth5:  cmp  esi,esp        #loop if more entries to scan} bne xt xs pnth3
        jne  pnth3
#
#      here after dealing with pattern assignments
#
pnth6:  mov  esp,dword ptr pmhbs #wipe out history stack} mov pmhbs xs
        pop  ebx            #load initial cursor} mov (xs)+ wb
        pop  edx            #load match type code} mov (xs)+ wc
        mov  ecx,dword ptr pmssl #load final cursor value} mov pmssl wa
        mov  esi,dword ptr r_pms #point to subject string} mov r_pms xl
        xor  eax,eax        #clear subject string ptr for gbcol} zer r_pms
        mov  dword ptr r_pms,eax
        or   edx,edx        #jump if call by name} bze wc pnth7
        jz   short pnth7 # (jump shortened)
        cmp  edx,num02      #exit if statement level call} beq wc =num02 pnth9
        je   short pnth9 # (jump shortened)
#
#      here we have a call by value, build substring
#
        sub  ecx,ebx        #compute length of string} sub wb wa
        call sbstr          #build substring} jsr sbstr
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      here for call by name, make stack entries for o$rpl
#
pnth7:  push ebx            #stack initial cursor} mov wb -(xs)
        push ecx            #stack final cursor} mov wa -(xs)
#
#      here with xl pointing to scblk or bcblk
#
pnth8:  push esi            #stack subject pointer} mov xl -(xs)
#
#      here to obey next code word
#
pnth9:  mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      pos (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_pos:
#
#      optimize pos if it is the first pattern element,
#      unanchored mode, cursor is zero and pos argument
#      is not beyond end of string.  force cursor position
#      and number of unanchored moves.
#
#      this optimization is performed invisible provided
#      the argument is either a simple integer or an
#      expression that is an untraced variable (that is,
#      it has no side effects that would be lost by short-
#      circuiting the normal logic of failing and moving the
#      unanchored starting point.)
#
#      pos (integer argument)
#
#      parm1                 integer argument
#
        cmp  ebx,dword ptr (4*parm1)[edi] #succeed if at right location} beq wb parm1(xr) succp
        je   succp
        or   ebx,ebx        #don't look further if cursor not 0} bnz wb failp
        jnz  failp
        mov  esi,dword ptr pmhbs #get history stack base ptr} mov pmhbs xt
        lea  esi,[esi-4]    #fail if pos is not first node} bne xr -(xt) failp
        cmp  edi,dword ptr [esi]
        jne  failp
#
#      expression argument circuit merges here
#
ppos2:  lea  esi,[esi-4]    #fail if not unanchored mode} bne -(xt) =nduna failp
        cmp  dword ptr [esi],offset nduna
        jne  failp
        mov  ebx,dword ptr (4*parm1)[edi] #get desired cursor position} mov parm1(xr) wb
        cmp  ebx,dword ptr pmssl #abort if off end} bgt wb pmssl exfal
        ja   exfal
        mov  dword ptr (4*num02)[esi],ebx #fake number of unanchored moves} mov wb num02(xt)
        jmp  succp          #continue match with adjusted cursor} brn succp
                            #} ejc
        .eject
#
#      pos (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_psd:
        call evali          #evaluate integer argument} jsr evali
        .short err_-50-dffnc #} err 050 pos evaluated argument is not integer
        .short err_-51-dffnc #} err 051 pos evaluated argument is negative or too large
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short ppos1-dffnc  #process expression case} ppm ppos1
#
ppos1:  cmp  ebx,dword ptr (4*parm1)[edi] #succeed if at right location} beq wb parm1(xr) succp
        je   succp
        or   ebx,ebx        #don't look further if cursor not 0} bnz wb failp
        jnz  failp
        cmp  dword ptr dword ptr evlif,0 #fail if complex argument} bnz evlif failp
        jnz  failp
        mov  esi,dword ptr pmhbs #get history stack base ptr} mov pmhbs xt
        mov  ecx,dword ptr evlio #get original node ptr} mov evlio wa
        lea  esi,[esi-4]    #fail if pos is not first node} bne wa -(xt) failp
        cmp  ecx,dword ptr [esi]
        jne  failp
        jmp  ppos2          #merge with integer argument code} brn ppos2
                            #} ejc
        .eject
#
#      pattern assignment (initial entry, save cursor)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_paa:
        push ebx            #stack initial cursor} mov wb -(xs)
        push offset ndpab   #stack ptr to ndpab special node} mov =ndpab -(xs)
        jmp  succp          #and succeed matching null} brn succp
                            #} ejc
        .eject
#
#      pattern assignment (remove saved cursor)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        nop
p_pab:
        jmp  failp          #just fail (entry is already popped)} brn failp
                            #} ejc
        .eject
#
#      pattern assignment (end of match, make assign entry)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      parm1                 name base of variable
#      parm2                 name offset of variable
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_pac:
        push ebx            #stack dummy cursor value} mov wb -(xs)
        push edi            #stack pointer to p_pac node} mov xr -(xs)
        push ebx            #stack final cursor} mov wb -(xs)
        push offset ndpad   #stack ptr to special ndpad node} mov =ndpad -(xs)
        mov  dword ptr pmdfl,esp #set dot flag non-zero} mnz pmdfl
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      pattern assignment (remove assign entry)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      no parameters (dummy node)
#
        .balign 2           #entry point} ent
        nop
p_pad:
        jmp  flpop          #fail and remove p_pac node} brn flpop
                            #} ejc
        .eject
#
#      rem
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_rem:
        mov  ebx,dword ptr pmssl #point cursor to end of string} mov pmssl wb
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      rpos (expression argument)
#
#      optimize rpos if it is the first pattern element,
#      unanchored mode, cursor is zero and rpos argument
#      is not beyond end of string.  force cursor position
#      and number of unanchored moves.
#
#      this optimization is performed invisibly provided
#      the argument is either a simple integer or an
#      expression that is an untraced variable (that is,
#      it has no side effects that would be lost by short-
#      circuiting the normal logic of failing and moving the
#      unanchored starting point).
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rpd:
        call evali          #evaluate integer argument} jsr evali
        .short err_-52-dffnc #} err 052 rpos evaluated argument is not integer
        .short err_-53-dffnc #} err 053 rpos evaluated argument is negative or too large
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short prps1-dffnc  #merge with normal case if ok} ppm prps1
#
prps1:  mov  edx,dword ptr pmssl #get length of string} mov pmssl wc
        sub  edx,ebx        #get number of characters remaining} sub wb wc
        cmp  edx,dword ptr (4*parm1)[edi] #succeed if at right location} beq wc parm1(xr) succp
        je   succp
        or   ebx,ebx        #don't look further if cursor not 0} bnz wb failp
        jnz  failp
        cmp  dword ptr dword ptr evlif,0 #fail if complex argument} bnz evlif failp
        jnz  failp
        mov  esi,dword ptr pmhbs #get history stack base ptr} mov pmhbs xt
        mov  ecx,dword ptr evlio #get original node ptr} mov evlio wa
        lea  esi,[esi-4]    #fail if pos is not first node} bne wa -(xt) failp
        cmp  ecx,dword ptr [esi]
        jne  failp
        jmp  prps2          #merge with integer arg code} brn prps2
                            #} ejc
        .eject
#
#      rpos (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rps:
#
#      rpos (integer argument)
#
#      parm1                 integer argument
#
        mov  edx,dword ptr pmssl #get length of string} mov pmssl wc
        sub  edx,ebx        #get number of characters remaining} sub wb wc
        cmp  edx,dword ptr (4*parm1)[edi] #succeed if at right location} beq wc parm1(xr) succp
        je   succp
        or   ebx,ebx        #don't look further if cursor not 0} bnz wb failp
        jnz  failp
        mov  esi,dword ptr pmhbs #get history stack base ptr} mov pmhbs xt
        lea  esi,[esi-4]    #fail if rpos is not first node} bne xr -(xt) failp
        cmp  edi,dword ptr [esi]
        jne  failp
#
#      expression argument merges here
#
prps2:  lea  esi,[esi-4]    #fail if not unanchored mode} bne -(xt) =nduna failp
        cmp  dword ptr [esi],offset nduna
        jne  failp
        mov  ebx,dword ptr pmssl #point to end of string} mov pmssl wb
        cmp  ebx,dword ptr (4*parm1)[edi] #fail if string not long enough} blt wb parm1(xr) failp
        jb   failp
        sub  ebx,dword ptr (4*parm1)[edi] #else set new cursor} sub parm1(xr) wb
        mov  dword ptr (4*num02)[esi],ebx #fake number of unanchored moves} mov wb num02(xt)
        jmp  succp          #continue match with adjusted cursor} brn succp
                            #} ejc
        .eject
#
#      rtab (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rtb:
#
#      expression argument case merges here
#
prtb1:  mov  edx,ebx        #save initial cursor} mov wb wc
        mov  ebx,dword ptr pmssl #point to end of string} mov pmssl wb
        cmp  ebx,dword ptr (4*parm1)[edi] #fail if string not long enough} blt wb parm1(xr) failp
        jb   failp
        sub  ebx,dword ptr (4*parm1)[edi] #else set new cursor} sub parm1(xr) wb
        cmp  ebx,edx        #and succeed if not too far already} bge wb wc succp
        jae  succp
        jmp  failp          #in which case, fail} brn failp
                            #} ejc
        .eject
#
#      rtab (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rtd:
        call evali          #evaluate integer argument} jsr evali
        .short err_-54-dffnc #} err 054 rtab evaluated argument is not integer
        .short err_-55-dffnc #} err 055 rtab evaluated argument is negative or too large
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short prtb1-dffnc  #merge with normal case if success} ppm prtb1
                            #} ejc
        .eject
#
#      span (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_spd:
        call evals          #evaluate string argument} jsr evals
        .short err_-56-dffnc #} err 056 span evaluated argument is not a string
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short pspn1-dffnc  #merge with multi-char case if ok} ppm pspn1
                            #} ejc
        .eject
#
#      span (multi-character argument case)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit column
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_spn:
#
#      expression argument case merges here
#
pspn1:  mov  edx,dword ptr pmssl #copy subject string length} mov pmssl wc
        sub  edx,ebx        #calculate number of characters left} sub wb wc
#        or   edx,edx        #fail if no characters left} bze wc failp  (optimized)
        jz   failp
        mov  esi,dword ptr r_pms #point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character} plc xl wb
        mov  dword ptr psavc,ebx #save initial cursor} mov wb psavc
        mov  dword ptr psave,edi #save node pointer} mov xr psave
#
#      loop to scan matching characters
#
pspn2:  movzx ecx,byte ptr [esi] #load next character, bump pointer} lch wa (xl)+
        inc  esi
        sal  ecx,2          #convert to byte offset} wtb wa
        mov  edi,dword ptr (4*parm1)[edi] #point to ctblk} mov parm1(xr) xr
        add  edi,ecx        #point to ctblk entry} add wa xr
        mov  ecx,dword ptr (4*ctchs)[edi] #load ctblk entry} mov ctchs(xr) wa
        mov  edi,dword ptr psave #restore node pointer} mov psave xr
        and  ecx,dword ptr (4*parm2)[edi] #and with selected bit} anb parm2(xr) wa
#        or   ecx,ecx        #jump if no match} zrb wa pspn3  (optimized)
        jz   short pspn3 # (jump shortened)
        inc  ebx            #else push cursor} icv wb
        dec  edx            #loop back unless end of string} bct wc pspn2
        jnz  pspn2
#
#      here after scanning matching characters
#
pspn3:  cmp  ebx,dword ptr psavc #succeed if chars matched} bne wb psavc succp
        jne  succp
        jmp  failp          #else fail if null string matched} brn failp
                            #} ejc
        .eject
#
#      span (one character argument)
#
#      parm1                 character argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_sps:
        mov  edx,dword ptr pmssl #get subject string length} mov pmssl wc
        sub  edx,ebx        #calculate number of characters left} sub wb wc
#        or   edx,edx        #fail if no characters left} bze wc failp  (optimized)
        jz   failp
        mov  esi,dword ptr r_pms #else point to subject string} mov r_pms xl
        lea  esi,[cfp_f+esi+ebx] #point to current character} plc xl wb
        mov  dword ptr psavc,ebx #save initial cursor} mov wb psavc
#
#      loop to scan matching characters
#
psps1:  movzx ecx,byte ptr [esi] #load next character, bump pointer} lch wa (xl)+
        inc  esi
        cmp  ecx,dword ptr (4*parm1)[edi] #jump if no match} bne wa parm1(xr) psps2
        jne  short psps2 # (jump shortened)
        inc  ebx            #else push cursor} icv wb
        dec  edx            #and loop unless end of string} bct wc psps1
        jnz  psps1
#
#      here after scanning matching characters
#
psps2:  cmp  ebx,dword ptr psavc #succeed if chars matched} bne wb psavc succp
        jne  succp
        jmp  failp          #fail if null string matched} brn failp
                            #} ejc
        .eject
#
#      multi-character string
#
#      note that one character strings use the circuit for
#      one character any arguments (p$an1).
#
#      parm1                 pointer to scblk for string arg
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_str:
        mov  esi,dword ptr (4*parm1)[edi] #get pointer to string} mov parm1(xr) xl
#
#      merge here after evaluating expression with string value
#
pstr1:  mov  dword ptr psave,edi #save node pointer} mov xr psave
        mov  edi,dword ptr r_pms #load subject string pointer} mov r_pms xr
        lea  edi,[cfp_f+edi+ebx] #point to current character} plc xr wb
        add  ebx,dword ptr (4*sclen)[esi] #compute new cursor position} add sclen(xl) wb
        cmp  ebx,dword ptr pmssl #fail if past end of string} bgt wb pmssl failp
        ja   failp
        mov  dword ptr psavc,ebx #save updated cursor} mov wb psavc
        mov  ecx,dword ptr (4*sclen)[esi] #get number of chars to compare} mov sclen(xl) wa
        add  esi,cfp_f      #point to chars of test string} plc xl
        repe cmpsb          #compare, fail if not equal} cmc failp failp
        mov  esi,0
        mov  edi,esi
        jnz  failp
        mov  edi,dword ptr psave #if all matched, restore node ptr} mov psave xr
        mov  ebx,dword ptr psavc #restore updated cursor} mov psavc wb
        jmp  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      succeed
#
#      see section on compound patterns for details of the
#      structure and algorithms for matching this node type
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_suc:
        push ebx            #stack cursor} mov wb -(xs)
        push edi            #stack pointer to this node} mov xr -(xs)
        jmp  succp          #succeed matching null} brn succp
                            #} ejc
        .eject
#
#      tab (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_tab:
#
#      expression argument case merges here
#
ptab1:  cmp  ebx,dword ptr (4*parm1)[edi] #fail if too far already} bgt wb parm1(xr) failp
        ja   failp
        mov  ebx,dword ptr (4*parm1)[edi] #else set new cursor position} mov parm1(xr) wb
        cmp  ebx,dword ptr pmssl #succeed if not off end} ble wb pmssl succp
        jbe  succp
        jmp  failp          #else fail} brn failp
                            #} ejc
        .eject
#
#      tab (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_tbd:
        call evali          #evaluate integer argument} jsr evali
        .short err_-57-dffnc #} err 057 tab evaluated argument is not integer
        .short err_-58-dffnc #} err 058 tab evaluated argument is negative or too large
        .short failp-dffnc  #fail if evaluation fails} ppm failp
        .short ptab1-dffnc  #merge with normal case if ok} ppm ptab1
                            #} ejc
        .eject
#
#      anchor movement
#
#      no parameters (dummy node)
#
        .balign 2           #entry point} ent
        nop
p_una:
        mov  edi,ebx        #copy initial pattern node pointer} mov wb xr
        mov  ebx,dword ptr [esp] #get initial cursor} mov (xs) wb
        cmp  ebx,dword ptr pmssl #match fails if at end of string} beq wb pmssl exfal
        je   exfal
        inc  ebx            #else increment cursor} icv wb
        mov  dword ptr [esp],ebx #store incremented cursor} mov wb (xs)
        push edi            #restack initial node ptr} mov xr -(xs)
        push offset nduna   #restack unanchored node} mov =nduna -(xs)
        jmp  dword ptr [edi] #rematch first node} bri (xr)
                            #} ejc
        .eject
#
#      end of pattern match routines
#
#      the following entry point marks the end of the pattern
#      matching routines and also the end of the entry points
#      referenced from the first word of blocks in dynamic store
#
        .balign 2           #mark last entry in pattern section} ent bl__i
        .byte bl__i
p_yyy:
                            #} ttl s p i t b o l -- snobol4 built-in label routines
        .sbttl "s p i t b o l -- snobol4 built-in label routines"
#
#      the following section contains the routines for labels
#      which have a predefined meaning in snobol4.
#
#      control is passed directly to the label name entry point.
#
#      entry names are of the form l$xxx where xxx is the three
#      letter variable name identifier.
#
#      entries are in alphabetical order
                            #} ejc
        .eject
#
#      abort
#
        .balign 2           #entry point} ent
        nop
l_abo:
#
#      merge here if execution terminates in error
#
labo1:  mov  ecx,dword ptr kvert #load error code} mov kvert wa
        or   ecx,ecx        #jump if no error has occured} bze wa labo3
        jz   short labo3 # (jump shortened)
        call sysax          #call after execution proc} jsr sysax
        mov  edx,dword ptr kvstn #current statement} mov kvstn wc
        call filnm          #obtain file name for this statement} jsr filnm
        mov  edi,dword ptr r_cod #current code block} mov r_cod xr
        mov  edx,dword ptr (4*cdsln)[edi] #line number} mov cdsln(xr) wc
        xor  ebx,ebx        #column number} zer wb
        mov  edi,dword ptr stage #} mov stage xr
        call sysea          #advise system of error} jsr sysea
        .short stpr4-dffnc  #if system does not want print} ppm stpr4
        call prtpg          #else eject printer} jsr prtpg
        or   edi,edi        #did sysea request print} bze xr labo2
        jz   short labo2 # (jump shortened)
        call prtst          #print text from sysea} jsr prtst
labo2:  call ermsg          #print error message} jsr ermsg
        xor  edi,edi        #indicate no message to print} zer xr
        jmp  stopr          #jump to routine to stop run} brn stopr
#
#      here if no error had occured
#
labo3:  call err_0          #} erb 036 goto abort with no preceding error
        .byte 36
                            #} ejc
        .eject
#
#      continue
#
        .balign 2           #entry point} ent
        nop
l_cnt:
#
#      merge here after execution error
#
lcnt1:  mov  edi,dword ptr r_cnt #load continuation code block ptr} mov r_cnt xr
        or   edi,edi        #jump if no previous error} bze xr lcnt3
        jz   short lcnt3 # (jump shortened)
        xor  eax,eax        #clear flag} zer r_cnt
        mov  dword ptr r_cnt,eax
        mov  dword ptr r_cod,edi #else store as new code block ptr} mov xr r_cod
        cmp  dword ptr [edi],offset b_cdc #jump if not complex go} bne (xr) =b_cdc lcnt2
        jne  short lcnt2 # (jump shortened)
        mov  ecx,dword ptr stxoc #get offset of error} mov stxoc wa
        cmp  ecx,dword ptr stxof #jump if error in goto evaluation} bge wa stxof lcnt4
        jae  short lcnt4 # (jump shortened)
#
#      here if error did not occur in complex failure goto
#
lcnt2:  add  edi,dword ptr stxof #add failure offset} add stxof xr
        mov  ebp,edi        #load code pointer} lcp xr
        mov  esp,dword ptr flptr #reset stack pointer} mov flptr xs
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      here if no previous error
#
lcnt3:  inc  dword ptr errft #fatal error} icv errft
        call err_0          #} erb 037 goto continue with no preceding error
        .byte 37
#
#      here if error in evaluation of failure goto.
#      cannot continue back to failure goto!
#
lcnt4:  inc  dword ptr errft #fatal error} icv errft
        call err_1          #} erb 332 goto continue with error in failure goto
        .byte 76
                            #} ejc
        .eject
#
#      end
#
        .balign 2           #entry point} ent
        nop
l_end:
#
#      merge here from end code circuit
#
lend0:  mov  edi,offset endms #point to message /normal term.../} mov =endms xr
        jmp  stopr          #jump to routine to stop run} brn stopr
                            #} ejc
        .eject
#
#      freturn
#
        .balign 2           #entry point} ent
        nop
l_frt:
        mov  ecx,offset scfrt #point to string /freturn/} mov =scfrt wa
        jmp  retrn          #jump to common return routine} brn retrn
                            #} ejc
        .eject
#
#      nreturn
#
        .balign 2           #entry point} ent
        nop
l_nrt:
        mov  ecx,offset scnrt #point to string /nreturn/} mov =scnrt wa
        jmp  retrn          #jump to common return routine} brn retrn
                            #} ejc
        .eject
#
#      return
#
        .balign 2           #entry point} ent
        nop
l_rtn:
        mov  ecx,offset scrtn #point to string /return/} mov =scrtn wa
        jmp  retrn          #jump to common return routine} brn retrn
                            #} ejc
        .eject
#
#      scontinue
#
        .balign 2           #entry point} ent
        nop
l_scn:
        mov  edi,dword ptr r_cnt #load continuation code block ptr} mov r_cnt xr
        or   edi,edi        #jump if no previous error} bze xr lscn2
        jz   short lscn2 # (jump shortened)
        xor  eax,eax        #clear flag} zer r_cnt
        mov  dword ptr r_cnt,eax
        cmp  dword ptr kvert,nm320 #error must be user interrupt} bne kvert =nm320 lscn1
        jne  short lscn1 # (jump shortened)
        cmp  dword ptr kvert,nm321 #detect scontinue loop} beq kvert =nm321 lscn2
        je   short lscn2 # (jump shortened)
        mov  dword ptr r_cod,edi #else store as new code block ptr} mov xr r_cod
        add  edi,dword ptr stxoc #add resume offset} add stxoc xr
        mov  ebp,edi        #load code pointer} lcp xr
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      here if no user interrupt
#
lscn1:  inc  dword ptr errft #fatal error} icv errft
        call err_1          #} erb 331 goto scontinue with no user interrupt
        .byte 75
#
#      here if in scontinue loop or if no previous error
#
lscn2:  inc  dword ptr errft #fatal error} icv errft
        call err_1          #} erb 321 goto scontinue with no preceding error
        .byte 65
                            #} ejc
        .eject
#
#      undefined label
#
        .balign 2           #entry point} ent
        nop
l_und:
        call err_0          #} erb 038 goto undefined label
        .byte 38
                            #} ttl s p i t b o l -- predefined snobol4 functions
        .sbttl "s p i t b o l -- predefined snobol4 functions"
#
#      the following section contains coding for functions
#      which are predefined and available at the snobol level.
#
#      these routines receive control directly from the code or
#      indirectly through the o$fnc, o$fns or cfunc routines.
#      in both cases the conditions on entry are as follows
#
#      the arguments are on the stack. the number of arguments
#      has been adjusted to correspond to the svblk svnar field.
#
#      in certain functions the direct call is not permitted
#      and in these instances we also have.
#
#      (wa)                  actual number of arguments in call
#
#      control returns by placing the function result value on
#      on the stack and continuing execution with the next
#      word from the generated code.
#
#      the names of the entry points of these functions are of
#      the form s$xxx where xxx is the three letter code for
#      the system variable name. the functions are in order
#      alphabetically by their entry names.
                            #} ejc
        .eject
#
#      any
#
        .balign 2           #entry point} ent
        nop
s_any:
        mov  ebx,offset p_ans #set pcode for single char case} mov =p_ans wb
        mov  esi,offset p_any #pcode for multi-char case} mov =p_any xl
        mov  edx,offset p_ayd #pcode for expression case} mov =p_ayd wc
        call patst          #call common routine to build node} jsr patst
        .short err_-59-dffnc #} err 059 any argument is not a string or expression
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      apply
#
#      apply does not permit the direct (fast) call so that
#      wa contains the actual number of arguments passed.
#
        .balign 2           #entry point} ent
        nop
s_app:
        or   ecx,ecx        #jump if no arguments} bze wa sapp3
        jz   sapp3
        dec  ecx            #else get applied func arg count} dcv wa
        mov  ebx,ecx        #copy} mov wa wb
        sal  ebx,2          #convert to bytes} wtb wb
        mov  esi,esp        #copy stack pointer} mov xs xt
        add  esi,ebx        #point to function argument on stack} add wb xt
        mov  edi,dword ptr [esi] #load function ptr (apply 1st arg)} mov (xt) xr
        or   ecx,ecx        #jump if no args for applied func} bze wa sapp2
        jz   short sapp2 # (jump shortened)
        mov  ebx,ecx        #else set counter for loop} lct wb wa
#
#      loop to move arguments up on stack
#
sapp1:  sub  esi,4          #point to next argument} dca xt
        mov  eax,dword ptr [esi] #move argument up} mov (xt) num01(xt)
        mov  dword ptr (4*num01)[esi],eax
        dec  ebx            #loop till all moved} bct wb sapp1
        jnz  sapp1
#
#      merge here to call function (wa = number of arguments)
#
sapp2:  add  esp,4          #adjust stack ptr for apply 1st arg} ica xs
        call gtnvr          #get variable block addr for func} jsr gtnvr
        .short sapp3-dffnc  #jump if not natural variable} ppm sapp3
        mov  esi,dword ptr (4*vrfnc)[edi] #else point to function block} mov vrfnc(xr) xl
        jmp  cfunc          #go call applied function} brn cfunc
#
#      here for invalid first argument
#
sapp3:  call err_0          #} erb 060 apply first arg is not natural variable name
        .byte 60
                            #} ejc
        .eject
#
#      arbno
#
#      arbno builds a compound pattern. see description at
#      start of pattern matching section for structure formed.
#
        .balign 2           #entry point} ent
        nop
s_abn:
        xor  edi,edi        #set parm1 = 0 for the moment} zer xr
        mov  ebx,offset p_alt #set pcode for alternative node} mov =p_alt wb
        call pbild          #build alternative node} jsr pbild
        mov  esi,edi        #save ptr to alternative pattern} mov xr xl
        mov  ebx,offset p_abc #pcode for p_abc} mov =p_abc wb
        xor  edi,edi        #p0blk} zer xr
        call pbild          #build p_abc node} jsr pbild
        mov  dword ptr (4*pthen)[edi],esi #put alternative node as successor} mov xl pthen(xr)
        mov  ecx,esi        #remember alternative node pointer} mov xl wa
        mov  esi,edi        #copy p_abc node ptr} mov xr xl
        mov  edi,dword ptr [esp] #load arbno argument} mov (xs) xr
        mov  dword ptr [esp],ecx #stack alternative node pointer} mov wa (xs)
        call gtpat          #get arbno argument as pattern} jsr gtpat
        .short err_-61-dffnc #} err 061 arbno argument is not pattern
        call pconc          #concat arg with p_abc node} jsr pconc
        mov  esi,edi        #remember ptr to concd patterns} mov xr xl
        mov  ebx,offset p_aba #pcode for p_aba} mov =p_aba wb
        xor  edi,edi        #p0blk} zer xr
        call pbild          #build p_aba node} jsr pbild
        mov  dword ptr (4*pthen)[edi],esi #concatenate nodes} mov xl pthen(xr)
        mov  esi,dword ptr [esp] #recall ptr to alternative node} mov (xs) xl
        mov  dword ptr (4*parm1)[esi],edi #point alternative back to argument} mov xr parm1(xl)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      arg
#
        .balign 2           #entry point} ent
        nop
s_arg:
        call gtsmi          #get second arg as small integer} jsr gtsmi
        .short err_-62-dffnc #} err 062 arg second argument is not integer
        .short exfal-dffnc  #fail if out of range or negative} ppm exfal
        mov  ecx,edi        #save argument number} mov xr wa
        pop  edi            #load first argument} mov (xs)+ xr
        call gtnvr          #locate vrblk} jsr gtnvr
        .short sarg1-dffnc  #jump if not natural variable} ppm sarg1
        mov  edi,dword ptr (4*vrfnc)[edi] #else load function block pointer} mov vrfnc(xr) xr
        cmp  dword ptr [edi],offset b_pfc #jump if not program defined} bne (xr) =b_pfc sarg1
        jne  short sarg1 # (jump shortened)
        or   ecx,ecx        #fail if arg number is zero} bze wa exfal
        jz   exfal
        cmp  ecx,dword ptr (4*fargs)[edi] #fail if arg number is too large} bgt wa fargs(xr) exfal
        ja   exfal
        sal  ecx,2          #else convert to byte offset} wtb wa
        add  edi,ecx        #point to argument selected} add wa xr
        mov  edi,dword ptr (4*pfagb)[edi] #load argument vrblk pointer} mov pfagb(xr) xr
        jmp  exvnm          #exit to build nmblk} brn exvnm
#
#      here if 1st argument is bad
#
sarg1:  call err_0          #} erb 063 arg first argument is not program function name
        .byte 63
                            #} ejc
        .eject
#
#      array
#
        .balign 2           #entry point} ent
        nop
s_arr:
        pop  esi            #load initial element value} mov (xs)+ xl
        pop  edi            #load first argument} mov (xs)+ xr
        call gtint          #convert first arg to integer} jsr gtint
        .short sar02-dffnc  #jump if not integer} ppm sar02
#
#      here for integer first argument, build vcblk
#
        mov  edx,dword ptr (4*icval)[edi] #load integer value} ldi icval(xr)
        or   edx,edx        #jump if zero or neg (bad dimension)} ile sar10
        jle  sar10
        or   edx,edx        #else convert to one word, test ovfl} mfi wa sar11
        js   sar11
        mov  ecx,edx
        call vmake          #create vector} jsr vmake
        .short sar11-dffnc  #fail if too large} ppm sar11
        jmp  exsid          #exit setting idval} brn exsid
                            #} ejc
        .eject
#
#      array (continued)
#
#      here if first argument is not an integer
#
sar02:  push edi            #replace argument on stack} mov xr -(xs)
        call xscni          #initialize scan of first argument} jsr xscni
        .short err_-64-dffnc #} err 064 array first argument is not integer or string
        .short exnul-dffnc  #dummy (unused) null string exit} ppm exnul
        push dword ptr r_xsc #save prototype pointer} mov r_xsc -(xs)
        push esi            #save default value} mov xl -(xs)
        xor  eax,eax        #zero count of dimensions} zer arcdm
        mov  dword ptr arcdm,eax
        xor  eax,eax        #zero offset to indicate pass one} zer arptr
        mov  dword ptr arptr,eax
        mov  edx,dword ptr intv1 #load integer one} ldi intv1
        mov  dword ptr arnel,edx #initialize element count} sti arnel
#
#      the following code is executed twice. the first time
#      (arptr eq 0), it is used to count the number of elements
#      and number of dimensions. the second time (arptr gt 0) is
#      used to actually fill in the dim,lbd fields of the arblk.
#
sar03:  mov  edx,dword ptr intv1 #load one as default low bound} ldi intv1
        mov  dword ptr arsvl,edx #save as low bound} sti arsvl
        mov  edx,ch_cl      #set delimiter one = colon} mov =ch_cl wc
        mov  esi,ch_cm      #set delimiter two = comma} mov =ch_cm xl
        xor  ecx,ecx        #retain blanks in prototype} zer wa
        call xscan          #scan next bound} jsr xscan
        cmp  ecx,num01      #jump if not colon} bne wa =num01 sar04
        jne  short sar04 # (jump shortened)
#
#      here we have a colon ending a low bound
#
        call gtint          #convert low bound} jsr gtint
        .short err_-65-dffnc #} err 065 array first argument lower bound is not integer
        mov  edx,dword ptr (4*icval)[edi] #load value of low bound} ldi icval(xr)
        mov  dword ptr arsvl,edx #store low bound value} sti arsvl
        mov  edx,ch_cm      #set delimiter one = comma} mov =ch_cm wc
        mov  esi,edx        #and delimiter two = comma} mov wc xl
        xor  ecx,ecx        #retain blanks in prototype} zer wa
        call xscan          #scan high bound} jsr xscan
                            #} ejc
        .eject
#
#      array (continued)
#
#      merge here to process upper bound
#
sar04:  call gtint          #convert high bound to integer} jsr gtint
        .short err_-66-dffnc #} err 066 array first argument upper bound is not integer
        mov  edx,dword ptr (4*icval)[edi] #get high bound} ldi icval(xr)
        sub  edx,dword ptr arsvl #subtract lower bound} sbi arsvl
        jo   sar10          #bad dimension if overflow} iov sar10
        or   edx,edx        #bad dimension if negative} ilt sar10
        jl   sar10
        add  edx,dword ptr intv1 #add 1 to get dimension} adi intv1
        jo   sar10          #bad dimension if overflow} iov sar10
        mov  esi,dword ptr arptr #load offset (also pass indicator)} mov arptr xl
        or   esi,esi        #jump if first pass} bze xl sar05
        jz   short sar05 # (jump shortened)
#
#      here in second pass to store lbd and dim in arblk
#
        add  esi,dword ptr [esp] #point to current location in arblk} add (xs) xl
        mov  dword ptr (4*cfp_i)[esi],edx #store dimension} sti cfp_i(xl)
        mov  edx,dword ptr arsvl #load low bound} ldi arsvl
        mov  dword ptr [esi],edx #store low bound} sti (xl)
        add  dword ptr arptr,4*ardms #bump offset to next bounds} add *ardms arptr
        jmp  short sar06          #jump to check for end of bounds} brn sar06 # (jump shortened)
#
#      here in pass 1
#
sar05:  inc  dword ptr arcdm #bump dimension count} icv arcdm
        imul edx,dword ptr arnel #multiply dimension by count so far} mli arnel
        jo   sar11          #too large if overflow} iov sar11
        mov  dword ptr arnel,edx #else store updated element count} sti arnel
#
#      merge here after processing one set of bounds
#
sar06:  or   ecx,ecx        #loop back unless end of bounds} bnz wa sar03
        jnz  sar03
        cmp  dword ptr dword ptr arptr,0 #jump if end of pass 2} bnz arptr sar09
        jnz  sar09
                            #} ejc
        .eject
#
#      array (continued)
#
#      here at end of pass one, build arblk
#
        mov  edx,dword ptr arnel #get number of elements} ldi arnel
        or   edx,edx        #get as addr integer, test ovflo} mfi wb sar11
        js   sar11
        mov  ebx,edx
        sal  ebx,2          #else convert to length in bytes} wtb wb
        mov  ecx,4*arsi_    #set size of standard fields} mov *arsi_ wa
        mov  edx,dword ptr arcdm #set dimension count to control loop} lct wc arcdm
#
#      loop to allow space for dimensions
#
sar07:  add  ecx,4*ardms    #allow space for one set of bounds} add *ardms wa
        dec  edx            #loop back till all accounted for} bct wc sar07
        jnz  sar07
        mov  esi,ecx        #save size (=arofs)} mov wa xl
#
#      now allocate space for arblk
#
        add  ecx,ebx        #add space for elements} add wb wa
        add  ecx,4          #allow for arpro prototype field} ica wa
        cmp  ecx,dword ptr mxlen #fail if too large} bgt wa mxlen sar11
        ja   sar11
        call alloc          #else allocate arblk} jsr alloc
        mov  ebx,dword ptr [esp] #load default value} mov (xs) wb
        mov  dword ptr [esp],edi #save arblk pointer} mov xr (xs)
        mov  edx,ecx        #save length in bytes} mov wa wc
        shr  ecx,2          #convert length back to words} btw wa
#
#      loop to clear entire arblk to default value
#
sar08:  mov  eax,ebx        #set one word} mov wb (xr)+
        stosd
        loop sar08          #loop till all set} bct wa sar08
                            #} ejc
        .eject
#
#      array (continued)
#
#      now set initial fields of arblk
#
        pop  edi            #reload arblk pointer} mov (xs)+ xr
        mov  ebx,dword ptr [esp] #load prototype} mov (xs) wb
        mov  dword ptr [edi],offset b_art #set type word} mov =b_art (xr)
        mov  dword ptr (4*arlen)[edi],edx #store length in bytes} mov wc arlen(xr)
        xor  eax,eax        #zero id till we get it built} zer idval(xr)
        mov  dword ptr (4*idval)[edi],eax
        mov  dword ptr (4*arofs)[edi],esi #set prototype field ptr} mov xl arofs(xr)
        mov  eax,dword ptr arcdm #set number of dimensions} mov arcdm arndm(xr)
        mov  dword ptr (4*arndm)[edi],eax
        mov  edx,edi        #save arblk pointer} mov xr wc
        add  edi,esi        #point to prototype field} add xl xr
        mov  dword ptr [edi],ebx #store prototype ptr in arblk} mov wb (xr)
        mov  dword ptr arptr,4*arlbd #set offset for pass 2 bounds scan} mov *arlbd arptr
        mov  dword ptr r_xsc,ebx #reset string pointer for xscan} mov wb r_xsc
        mov  dword ptr [esp],edx #store arblk pointer on stack} mov wc (xs)
        xor  eax,eax        #reset offset ptr to start of string} zer xsofs
        mov  dword ptr xsofs,eax
        jmp  sar03          #jump back to rescan bounds} brn sar03
#
#      here after filling in bounds information (end pass two)
#
sar09:  pop  edi            #reload pointer to arblk} mov (xs)+ xr
        jmp  exsid          #exit setting idval} brn exsid
#
#      here for bad dimension
#
sar10:  call err_0          #} erb 067 array dimension is zero, negative or out of range
        .byte 67
#
#      here if array is too large
#
sar11:  call err_0          #} erb 068 array size exceeds maximum permitted
        .byte 68
                            #} ejc
        .eject
#
#      atan
#
        .balign 2           #entry point} ent
        nop
s_atn:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-301-dffnc #} err 301 atan argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call atn_           #take arctangent} atn
        jmp  exrea          #overflow, out of range not possible} brn exrea
                            #} ejc
        .eject
                            #} ejc
        .eject
#
#      backspace
#
        .balign 2           #entry point} ent
        nop
s_bsp:
        call iofcb          #call fcblk routine} jsr iofcb
        .short err_-316-dffnc #} err 316 backspace argument is not a suitable name
        .short err_-316-dffnc #} err 316 backspace argument is not a suitable name
        .short err_-317-dffnc #} err 317 backspace file does not exist
        call sysbs          #call backspace file function} jsr sysbs
        .short err_-317-dffnc #} err 317 backspace file does not exist
        .short err_-318-dffnc #} err 318 backspace file does not permit backspace
        .short err_-319-dffnc #} err 319 backspace caused non-recoverable error
        jmp  exnul          #return null as result} brn exnul
                            #} ejc
        .eject
#
#      break
#
        .balign 2           #entry point} ent
        nop
s_brk:
        mov  ebx,offset p_bks #set pcode for single char case} mov =p_bks wb
        mov  esi,offset p_brk #pcode for multi-char case} mov =p_brk xl
        mov  edx,offset p_bkd #pcode for expression case} mov =p_bkd wc
        call patst          #call common routine to build node} jsr patst
        .short err_-69-dffnc #} err 069 break argument is not a string or expression
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      breakx
#
#      breakx is a compound pattern. see description at start
#      of pattern matching section for structure formed.
#
        .balign 2           #entry point} ent
        nop
s_bkx:
        mov  ebx,offset p_bks #pcode for single char argument} mov =p_bks wb
        mov  esi,offset p_brk #pcode for multi-char argument} mov =p_brk xl
        mov  edx,offset p_bxd #pcode for expression case} mov =p_bxd wc
        call patst          #call common routine to build node} jsr patst
        .short err_-70-dffnc #} err 070 breakx argument is not a string or expression
#
#      now hook breakx node on at front end
#
        push edi            #save ptr to break node} mov xr -(xs)
        mov  ebx,offset p_bkx #set pcode for breakx node} mov =p_bkx wb
        call pbild          #build it} jsr pbild
        mov  eax,dword ptr [esp] #set break node as successor} mov (xs) pthen(xr)
        mov  dword ptr (4*pthen)[edi],eax
        mov  ebx,offset p_alt #set pcode for alternation node} mov =p_alt wb
        call pbild          #build (parm1=alt=breakx node)} jsr pbild
        mov  ecx,edi        #save ptr to alternation node} mov xr wa
        mov  edi,dword ptr [esp] #point to break node} mov (xs) xr
        mov  dword ptr (4*pthen)[edi],ecx #set alternate node as successor} mov wa pthen(xr)
        mov  edi,[ebp]      #result on stack} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      char
#
        .balign 2           #entry point} ent
        nop
s_chr:
        call gtsmi          #convert arg to integer} jsr gtsmi
        .short err_-281-dffnc #} err 281 char argument not integer
        .short schr1-dffnc  #too big error exit} ppm schr1
        cmp  edx,cfp_a      #see if out of range of host set} bge wc =cfp_a schr1
        jae  short schr1 # (jump shortened)
        mov  ecx,num01      #if not set scblk allocation} mov =num01 wa
        mov  ebx,edx        #save char code} mov wc wb
        call alocs          #allocate 1 bau scblk} jsr alocs
        mov  esi,edi        #copy scblk pointer} mov xr xl
        add  esi,cfp_f      #get set to stuff char} psc xl
        mov  [esi],bl       #stuff it} sch wb (xl)
        xor  esi,esi        #clear slop in esi} zer xl
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      here if char argument is out of range
#
schr1:  call err_1          #} erb 282 char argument not in range
        .byte 26
                            #} ejc
        .eject
#
#      chop
#
        .balign 2           #entry point} ent
        nop
s_chp:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-302-dffnc #} err 302 chop argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call chp_           #truncate to integer valued real} chp
        jmp  exrea          #no overflow possible} brn exrea
                            #} ejc
        .eject
#
#      clear
#
        .balign 2           #entry point} ent
        nop
s_clr:
        call xscni          #initialize to scan argument} jsr xscni
        .short err_-71-dffnc #} err 071 clear argument is not a string
        .short sclr2-dffnc  #jump if null} ppm sclr2
#
#      loop to scan out names in first argument. variables in
#      the list are flagged by setting vrget of vrblk to zero.
#
sclr1:  mov  edx,ch_cm      #set delimiter one = comma} mov =ch_cm wc
        mov  esi,edx        #delimiter two = comma} mov wc xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan next variable name} jsr xscan
        call gtnvr          #locate vrblk} jsr gtnvr
        .short err_-72-dffnc #} err 072 clear argument has null variable name
        xor  eax,eax        #else flag by zeroing vrget field} zer vrget(xr)
        mov  dword ptr (4*vrget)[edi],eax
        or   ecx,ecx        #loop back if stopped by comma} bnz wa sclr1
        jnz  sclr1
#
#      here after flagging variables in argument list
#
sclr2:  mov  ebx,dword ptr hshtb #point to start of hash table} mov hshtb wb
#
#      loop through slots in hash table
#
sclr3:  cmp  ebx,dword ptr hshte #exit returning null if none left} beq wb hshte exnul
        je   exnul
        mov  edi,ebx        #else copy slot pointer} mov wb xr
        add  ebx,4          #bump slot pointer} ica wb
        sub  edi,4*vrnxt    #set offset to merge into loop} sub *vrnxt xr
#
#      loop through vrblks on one hash chain
#
sclr4:  mov  edi,dword ptr (4*vrnxt)[edi] #point to next vrblk on chain} mov vrnxt(xr) xr
        or   edi,edi        #jump for next bucket if chain end} bze xr sclr3
        jz   sclr3
        cmp  dword ptr dword ptr (4*vrget)[edi],0 #jump if not flagged} bnz vrget(xr) sclr5
        jnz  short sclr5 # (jump shortened)
                            #} ejc
        .eject
#
#      clear (continued)
#
#      here for flagged variable, do not set value to null
#
        call setvr          #for flagged var, restore vrget} jsr setvr
        jmp  sclr4          #and loop back for next vrblk} brn sclr4
#
#      here to set value of a variable to null
#      protected variables (arb, etc) are exempt
#
sclr5:  cmp  dword ptr (4*vrsto)[edi],offset b_vre #check for protected variable} beq vrsto(xr) =b_vre sclr4
        je   sclr4
        mov  esi,edi        #copy vrblk pointer} mov xr xl
#
#      loop to locate value at end of possible trblk chain
#
sclr6:  mov  ecx,esi        #save block pointer} mov xl wa
        mov  esi,dword ptr (4*vrval)[esi] #load next value field} mov vrval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop back if trapped} beq (xl) =b_trt sclr6
        je   sclr6
#
#      now store the null value
#
        mov  esi,ecx        #restore block pointer} mov wa xl
        mov  dword ptr (4*vrval)[esi],offset nulls #store null constant value} mov =nulls vrval(xl)
        jmp  sclr4          #loop back for next vrblk} brn sclr4
                            #} ejc
        .eject
#
#      code
#
        .balign 2           #entry point} ent
        nop
s_cod:
        pop  edi            #load argument} mov (xs)+ xr
        call gtcod          #convert to code} jsr gtcod
        .short exfal-dffnc  #fail if conversion is impossible} ppm exfal
        push edi            #stack result} mov xr -(xs)
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      collect
#
        .balign 2           #entry point} ent
        nop
s_col:
        pop  edi            #load argument} mov (xs)+ xr
        call gtint          #convert to integer} jsr gtint
        .short err_-73-dffnc #} err 073 collect argument is not integer
        mov  edx,dword ptr (4*icval)[edi] #load collect argument} ldi icval(xr)
        mov  dword ptr clsvi,edx #save collect argument} sti clsvi
        xor  ebx,ebx        #set no move up} zer wb
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        xor  eax,eax        #collect sediment too} zer dnams
        mov  dword ptr dnams,eax
        call gbcol          #perform garbage collection} jsr gbcol
        mov  dword ptr dnams,edi #record new sediment size} mov xr dnams
        mov  ecx,dword ptr dname #point to end of memory} mov dname wa
        sub  ecx,dword ptr dnamp #subtract next location} sub dnamp wa
        shr  ecx,2          #convert bytes to words} btw wa
        mov  edx,ecx        #convert words available as integer} mti wa
        sub  edx,dword ptr clsvi #subtract argument} sbi clsvi
        jo   exfal          #fail if overflow} iov exfal
        or   edx,edx        #fail if not enough} ilt exfal
        jl   exfal
        add  edx,dword ptr clsvi #else recompute available} adi clsvi
        jmp  exint          #and exit with integer result} brn exint
                            #} ejc
        .eject
#
#      convert
#
        .balign 2           #entry point} ent
        nop
s_cnv:
        call gtstg          #convert second argument to string} jsr gtstg
        .short scv29-dffnc  #error if second argument not string} ppm scv29
        or   ecx,ecx        #or if null string} bze wa scv29
        jz   scv29
        call flstg          #fold lower case to upper case} jsr flstg
        mov  esi,dword ptr [esp] #load first argument} mov (xs) xl
        cmp  dword ptr [esi],offset b_pdt #jump if not program defined} bne (xl) =b_pdt scv01
        jne  short scv01 # (jump shortened)
#
#      here for program defined datatype
#
        mov  esi,dword ptr (4*pddfp)[esi] #point to dfblk} mov pddfp(xl) xl
        mov  esi,dword ptr (4*dfnam)[esi] #load datatype name} mov dfnam(xl) xl
        call ident          #compare with second arg} jsr ident
        .short exits-dffnc  #exit if ident with arg as result} ppm exits
        jmp  exfal          #else fail} brn exfal
#
#      here if not program defined datatype
#
scv01:  push edi            #save string argument} mov xr -(xs)
        mov  esi,offset svctb #point to table of names to compare} mov =svctb xl
        xor  ebx,ebx        #initialize counter} zer wb
        mov  edx,ecx        #save length of argument string} mov wa wc
#
#      loop through table entries
#
scv02:  lodsd               #load next table entry, bump pointer} mov (xl)+ xr
        mov  edi,eax
        or   edi,edi        #fail if zero marking end of list} bze xr exfal
        jz   exfal
        cmp  edx,dword ptr (4*sclen)[edi] #jump if wrong length} bne wc sclen(xr) scv05
        jne  scv05
        mov  dword ptr cnvtp,esi #else store table pointer} mov xl cnvtp
        add  edi,cfp_f      #point to chars of table entry} plc xr
        mov  esi,dword ptr [esp] #load pointer to string argument} mov (xs) xl
        add  esi,cfp_f      #point to chars of string arg} plc xl
        mov  ecx,edx        #set number of chars to compare} mov wc wa
        repe cmpsb          #compare, jump if no match} cmc scv04 scv04
        mov  esi,0
        mov  edi,esi
        jnz  scv04
                            #} ejc
        .eject
#
#      convert (continued)
#
#      here we have a match
#
scv03:  mov  esi,ebx        #copy entry number} mov wb xl
        add  esp,4          #pop string arg off stack} ica xs
        pop  edi            #load first argument} mov (xs)+ xr
        jmp  dword ptr l0003[esi*4] #jump to appropriate routine} bsw xl cnvtt
        dseg_
l0003:
        .long scv06         #string} iff 0 scv06
        .long scv07         #integer} iff 1 scv07
        .long scv09         #name} iff 2 scv09
        .long scv10         #pattern} iff 3 scv10
        .long scv11         #array} iff 4 scv11
        .long scv19         #table} iff 5 scv19
        .long scv25         #expression} iff 6 scv25
        .long scv26         #code} iff 7 scv26
        .long scv27         #numeric} iff 8 scv27
        .long scv08         #real} iff cnvrt scv08
        dsegend_            #end of switch table} esw
        cseg_
#
#      here if no match with table entry
#
scv04:  mov  esi,dword ptr cnvtp #restore table pointer, merge} mov cnvtp xl
#
#      merge here if lengths did not match
#
scv05:  inc  ebx            #bump entry number} icv wb
        jmp  scv02          #loop back to check next entry} brn scv02
#
#      here to convert to string
#
scv06:  push edi            #replace string argument on stack} mov xr -(xs)
        call gtstg          #convert to string} jsr gtstg
        .short exfal-dffnc  #fail if conversion not possible} ppm exfal
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      convert (continued)
#
#      here to convert to integer
#
scv07:  call gtint          #convert to integer} jsr gtint
        .short exfal-dffnc  #fail if conversion not possible} ppm exfal
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      here to convert to real
#
scv08:  call gtrea          #convert to real} jsr gtrea
        .short exfal-dffnc  #fail if conversion not possible} ppm exfal
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      here to convert to name
#
scv09:  cmp  dword ptr [edi],offset b_nml #return if already a name} beq (xr) =b_nml exixr
        je   exixr
        call gtnvr          #else try string to name convert} jsr gtnvr
        .short exfal-dffnc  #fail if conversion not possible} ppm exfal
        jmp  exvnm          #else exit building nmblk for vrblk} brn exvnm
#
#      here to convert to pattern
#
scv10:  call gtpat          #convert to pattern} jsr gtpat
        .short exfal-dffnc  #fail if conversion not possible} ppm exfal
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      convert to array
#
#      if the first argument is a table, then we go through
#      an intermediate array of addresses that is sorted to
#      provide a result ordered by time of entry in the
#      original table.  see c3.762.
#
scv11:  push edi            #save argument on stack} mov xr -(xs)
        xor  ecx,ecx        #use table chain block addresses} zer wa
        call gtarr          #get an array} jsr gtarr
        .short exfal-dffnc  #fail if empty table} ppm exfal
        .short exfal-dffnc  #fail if not convertible} ppm exfal
        pop  esi            #reload original arg} mov (xs)+ xl
        cmp  dword ptr [esi],offset b_tbt #exit if original not a table} bne (xl) =b_tbt exsid
        jne  exsid
        push edi            #sort the intermediate array} mov xr -(xs)
        push offset nulls   #on first column} mov =nulls -(xs)
        xor  ecx,ecx        #sort ascending} zer wa
        call sorta          #do sort} jsr sorta
        .short exfal-dffnc  #if sort fails, so shall we} ppm exfal
        mov  ebx,edi        #save array result} mov xr wb
        mov  edx,dword ptr (4*ardim)[edi] #load dim 1 (number of elements)} ldi ardim(xr)
        mov  ecx,edx        #get as one word integer} mfi wa
        add  edi,4*arvl2    #point to first element in array} add *arvl2 xr
#
#      here for each row of this 2-column array
#
scv12:  mov  esi,dword ptr [edi] #get teblk address} mov (xr) xl
        mov  eax,dword ptr (4*tesub)[esi] #replace with subscript} mov tesub(xl) (xr)+
        stosd
        mov  eax,dword ptr (4*teval)[esi] #replace with value} mov teval(xl) (xr)+
        stosd
        loop scv12          #loop till all copied over} bct wa scv12
        mov  edi,ebx        #retrieve array address} mov wb xr
        jmp  exsid          #exit setting id field} brn exsid
#
#      convert to table
#
scv19:  mov  ecx,dword ptr [edi] #load first word of block} mov (xr) wa
        push edi            #replace arblk pointer on stack} mov xr -(xs)
        cmp  ecx,offset b_tbt #return arg if already a table} beq wa =b_tbt exits
        je   exits
        cmp  ecx,offset b_art #else fail if not an array} bne wa =b_art exfal
        jne  exfal
                            #} ejc
        .eject
#
#      convert (continued)
#
#      here to convert an array to table
#
        cmp  dword ptr (4*arndm)[edi],num02 #fail if not 2-dim array} bne arndm(xr) =num02 exfal
        jne  exfal
        mov  edx,dword ptr (4*ardm2)[edi] #load dim 2} ldi ardm2(xr)
        sub  edx,dword ptr intv2 #subtract 2 to compare} sbi intv2
#        or   edx,edx        #fail if dim2 not 2} ine exfal   (optimized)
        jne  exfal
#
#      here we have an arblk of the right shape
#
        mov  edx,dword ptr (4*ardim)[edi] #load dim 1 (number of elements)} ldi ardim(xr)
        mov  ecx,edx        #get as one word integer} mfi wa
        mov  ebx,ecx        #copy to control loop} lct wb wa
        add  ecx,tbsi_      #add space for standard fields} add =tbsi_ wa
        sal  ecx,2          #convert length to bytes} wtb wa
        call alloc          #allocate space for tbblk} jsr alloc
        mov  edx,edi        #copy tbblk pointer} mov xr wc
        push edi            #save tbblk pointer} mov xr -(xs)
        mov  eax,offset b_tbt #store type word} mov =b_tbt (xr)+
        stosd
        xor  eax,eax        #store zero for idval for now} zer (xr)+
        stosd
        mov  eax,ecx        #store length} mov wa (xr)+
        stosd
        mov  eax,offset nulls #null initial lookup value} mov =nulls (xr)+
        stosd
#
#      loop to initialize bucket ptrs to point to table
#
scv20:  mov  eax,edx        #set bucket ptr to point to tbblk} mov wc (xr)+
        stosd
        dec  ebx            #loop till all initialized} bct wb scv20
        jnz  scv20
        mov  ebx,4*arvl2    #set offset to first arblk element} mov *arvl2 wb
#
#      loop to copy elements from array to table
#
scv21:  mov  esi,dword ptr (4*num01)[esp] #point to arblk} mov num01(xs) xl
        cmp  ebx,dword ptr (4*arlen)[esi] #jump if all moved} beq wb arlen(xl) scv24
        je   short scv24 # (jump shortened)
        add  esi,ebx        #else point to current location} add wb xl
        add  ebx,4*num02    #bump offset} add *num02 wb
        mov  edi,dword ptr [esi] #load subscript name} mov (xl) xr
        sub  esi,4          #adjust ptr to merge (trval=1+1)} dca xl
                            #} ejc
        .eject
#
#      convert (continued)
#
#      loop to chase down trblk chain for value
#
scv22:  mov  esi,dword ptr (4*trval)[esi] #point to next value} mov trval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop back if trapped} beq (xl) =b_trt scv22
        je   scv22
#
#      here with name in xr, value in xl
#
scv23:  push esi            #stack value} mov xl -(xs)
        mov  esi,dword ptr (4*num01)[esp] #load tbblk pointer} mov num01(xs) xl
        call tfind          #build teblk (note ebx gt 0 by name)} jsr tfind
        .short exfal-dffnc  #fail if acess fails} ppm exfal
        pop  dword ptr (4*teval)[esi] #store value in teblk} mov (xs)+ teval(xl)
        jmp  scv21          #loop back for next element} brn scv21
#
#      here after moving all elements to tbblk
#
scv24:  pop  edi            #load tbblk pointer} mov (xs)+ xr
        add  esp,4          #pop arblk pointer} ica xs
        jmp  exsid          #exit setting idval} brn exsid
#
#      convert to expression
#
scv25:  xor  ebx,ebx        #by value} zer wb
        call gtexp          #convert to expression} jsr gtexp
        .short exfal-dffnc  #fail if conversion not possible} ppm exfal
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      convert to code
#
scv26:  call gtcod          #convert to code} jsr gtcod
        .short exfal-dffnc  #fail if conversion is not possible} ppm exfal
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      convert to numeric
#
scv27:  call gtnum          #convert to numeric} jsr gtnum
        .short exfal-dffnc  #fail if unconvertible} ppm exfal
scv31:  push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      second argument not string or null
#
scv29:  call err_0          #} erb 074 convert second argument is not a string
        .byte 74
#
#      copy
#
        .balign 2           #entry point} ent
        nop
s_cop:
        call copyb          #copy the block} jsr copyb
        .short exits-dffnc  #return if no idval field} ppm exits
        jmp  exsid          #exit setting id value} brn exsid
                            #} ejc
        .eject
#
#      cos
#
        .balign 2           #entry point} ent
        nop
s_cos:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-303-dffnc #} err 303 cos argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call cos_           #take cosine} cos
        call ovr_           #if no overflow, return result in ra} rno exrea
        jno  exrea
        call err_1          #} erb 322 cos argument is out of range
        .byte 66
                            #} ejc
        .eject
#
#      data
#
        .balign 2           #entry point} ent
        nop
s_dat:
        call xscni          #prepare to scan argument} jsr xscni
        .short err_-75-dffnc #} err 075 data argument is not a string
        .short err_-76-dffnc #} err 076 data argument is null
#
#      scan out datatype name
#
        mov  edx,ch_pp      #delimiter one = left paren} mov =ch_pp wc
        mov  esi,edx        #delimiter two = left paren} mov wc xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan datatype name} jsr xscan
        or   ecx,ecx        #skip if left paren found} bnz wa sdat1
        jnz  short sdat1 # (jump shortened)
        call err_0          #} erb 077 data argument is missing a left paren
        .byte 77
#
#      here after scanning datatype name
#
sdat1:  mov  ecx,dword ptr (4*sclen)[edi] #get length} mov sclen(xr) wa
        or   ecx,ecx        #avoid folding if null string} bze wa sdt1a
        jz   short sdt1a # (jump shortened)
        call flstg          #fold lower case to upper case} jsr flstg
sdt1a:  mov  esi,edi        #save name ptr} mov xr xl
        mov  ecx,dword ptr (4*sclen)[edi] #get length} mov sclen(xr) wa
        add  ecx,3+4*scsi_  #compute space needed} ctb wa scsi_
        and  ecx,-4
        call alost          #request static store for name} jsr alost
        push edi            #save datatype name} mov xr -(xs)
        shr  ecx,2          #copy name to static} mvw
        rep  movsd
        mov  edi,dword ptr [esp] #get name ptr} mov (xs) xr
        xor  esi,esi        #scrub dud register} zer xl
        call gtnvr          #locate vrblk for datatype name} jsr gtnvr
        .short err_-78-dffnc #} err 078 data argument has null datatype name
        mov  dword ptr datdv,edi #save vrblk pointer for datatype} mov xr datdv
        mov  dword ptr datxs,esp #store starting stack value} mov xs datxs
        xor  ebx,ebx        #zero count of field names} zer wb
#
#      loop to scan field names and stack vrblk pointers
#
sdat2:  mov  edx,ch_rp      #delimiter one = right paren} mov =ch_rp wc
        mov  esi,ch_cm      #delimiter two = comma} mov =ch_cm xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan next field name} jsr xscan
        or   ecx,ecx        #jump if delimiter found} bnz wa sdat3
        jnz  short sdat3 # (jump shortened)
        call err_0          #} erb 079 data argument is missing a right paren
        .byte 79
#
#      here after scanning out one field name
#
sdat3:  call gtnvr          #locate vrblk for field name} jsr gtnvr
        .short err_-80-dffnc #} err 080 data argument has null field name
        push edi            #stack vrblk pointer} mov xr -(xs)
        inc  ebx            #increment counter} icv wb
        cmp  ecx,num02      #loop back if stopped by comma} beq wa =num02 sdat2
        je   sdat2
                            #} ejc
        .eject
#
#      data (continued)
#
#      now build the dfblk
#
        mov  ecx,dfsi_      #set size of dfblk standard fields} mov =dfsi_ wa
        add  ecx,ebx        #add number of fields} add wb wa
        sal  ecx,2          #convert length to bytes} wtb wa
        mov  edx,ebx        #preserve no. of fields} mov wb wc
        call alost          #allocate space for dfblk} jsr alost
        mov  ebx,edx        #get no of fields} mov wc wb
        mov  esi,dword ptr datxs #point to start of stack} mov datxs xt
        mov  edx,dword ptr [esi] #load datatype name} mov (xt) wc
        mov  dword ptr [esi],edi #save dfblk pointer on stack} mov xr (xt)
        mov  eax,offset b_dfc #store type word} mov =b_dfc (xr)+
        stosd
        mov  eax,ebx        #store number of fields (fargs)} mov wb (xr)+
        stosd
        mov  eax,ecx        #store length (dflen)} mov wa (xr)+
        stosd
        sub  ecx,4*pddfs    #compute pdblk length (for dfpdl)} sub *pddfs wa
        mov  eax,ecx        #store pdblk length (dfpdl)} mov wa (xr)+
        stosd
        mov  eax,edx        #store datatype name (dfnam)} mov wc (xr)+
        stosd
        mov  edx,ebx        #copy number of fields} lct wc wb
#
#      loop to move field name vrblk pointers to dfblk
#
sdat4:  lea  esi,[esi-4]    #move one field name vrblk pointer} mov -(xt) (xr)+
        mov  eax,dword ptr [esi]
        stosd
        dec  edx            #loop till all moved} bct wc sdat4
        jnz  sdat4
#
#      now define the datatype function
#
        mov  edx,ecx        #copy length of pdblk for later loop} mov wa wc
        mov  edi,dword ptr datdv #point to vrblk} mov datdv xr
        mov  esi,dword ptr datxs #point back on stack} mov datxs xt
        mov  esi,dword ptr [esi] #load dfblk pointer} mov (xt) xl
        call dffnc          #define function} jsr dffnc
                            #} ejc
        .eject
#
#      data (continued)
#
#      loop to build ffblks
#
#
#      notice that the ffblks are constructed in reverse order
#      so that the required offsets can be obtained from
#      successive decrementation of the pdblk length (in wc).
#
sdat5:  mov  ecx,4*ffsi_    #set length of ffblk} mov *ffsi_ wa
        call alloc          #allocate space for ffblk} jsr alloc
        mov  dword ptr [edi],offset b_ffc #set type word} mov =b_ffc (xr)
        mov  dword ptr (4*fargs)[edi],num01 #store fargs (always one)} mov =num01 fargs(xr)
        mov  esi,dword ptr datxs #point back on stack} mov datxs xt
        mov  eax,dword ptr [esi] #copy dfblk ptr to ffblk} mov (xt) ffdfp(xr)
        mov  dword ptr (4*ffdfp)[edi],eax
        sub  edx,4          #decrement old dfpdl to get next ofs} dca wc
        mov  dword ptr (4*ffofs)[edi],edx #set offset to this field} mov wc ffofs(xr)
        xor  eax,eax        #tentatively set zero forward ptr} zer ffnxt(xr)
        mov  dword ptr (4*ffnxt)[edi],eax
        mov  esi,edi        #copy ffblk pointer for dffnc} mov xr xl
        mov  edi,dword ptr [esp] #load vrblk pointer for field} mov (xs) xr
        mov  edi,dword ptr (4*vrfnc)[edi] #load current function pointer} mov vrfnc(xr) xr
        cmp  dword ptr [edi],offset b_ffc #skip if not currently a field func} bne (xr) =b_ffc sdat6
        jne  short sdat6 # (jump shortened)
#
#      here we must chain an old ffblk ptr to preserve it in the
#      case of multiple field functions with the same name
#
        mov  dword ptr (4*ffnxt)[esi],edi #link new ffblk to previous chain} mov xr ffnxt(xl)
#
#      merge here to define field function
#
sdat6:  pop  edi            #load vrblk pointer} mov (xs)+ xr
        call dffnc          #define field function} jsr dffnc
        cmp  esp,dword ptr datxs #loop back till all done} bne xs datxs sdat5
        jne  sdat5
        add  esp,4          #pop dfblk pointer} ica xs
        jmp  exnul          #return with null result} brn exnul
                            #} ejc
        .eject
#
#      datatype
#
        .balign 2           #entry point} ent
        nop
s_dtp:
        pop  edi            #load argument} mov (xs)+ xr
        call dtype          #get datatype} jsr dtype
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      date
#
        .balign 2           #entry point} ent
        nop
s_dte:
        pop  edi            #load argument} mov (xs)+ xr
        call gtint          #convert to an integer} jsr gtint
        .short err_-330-dffnc #} err 330 date argument is not integer
        call sysdt          #call system date routine} jsr sysdt
        mov  ecx,dword ptr (4*num01)[esi] #load length for sbstr} mov num01(xl) wa
        or   ecx,ecx        #return null if length is zero} bze wa exnul
        jz   exnul
        xor  ebx,ebx        #set zero offset} zer wb
        call sbstr          #use sbstr to build scblk} jsr sbstr
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      define
#
        .balign 2           #entry point} ent
        nop
s_def:
        pop  edi            #load second argument} mov (xs)+ xr
        xor  eax,eax        #zero label pointer in case null} zer deflb
        mov  dword ptr deflb,eax
        cmp  edi,offset nulls #jump if null second argument} beq xr =nulls sdf01
        je   short sdf01 # (jump shortened)
        call gtnvr          #else find vrblk for label} jsr gtnvr
        .short sdf12-dffnc  #jump if not a variable name} ppm sdf12
        mov  dword ptr deflb,edi #else set specified entry} mov xr deflb
#
#      scan function name
#
sdf01:  call xscni          #prepare to scan first argument} jsr xscni
        .short err_-81-dffnc #} err 081 define first argument is not a string
        .short err_-82-dffnc #} err 082 define first argument is null
        mov  edx,ch_pp      #delimiter one = left paren} mov =ch_pp wc
        mov  esi,edx        #delimiter two = left paren} mov wc xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan out function name} jsr xscan
        or   ecx,ecx        #jump if left paren found} bnz wa sdf02
        jnz  short sdf02 # (jump shortened)
        call err_0          #} erb 083 define first argument is missing a left paren
        .byte 83
#
#      here after scanning out function name
#
sdf02:  call gtnvr          #get variable name} jsr gtnvr
        .short err_-84-dffnc #} err 084 define first argument has null function name
        mov  dword ptr defvr,edi #save vrblk pointer for function nam} mov xr defvr
        xor  ebx,ebx        #zero count of arguments} zer wb
        mov  dword ptr defxs,esp #save initial stack pointer} mov xs defxs
        cmp  dword ptr dword ptr deflb,0 #jump if second argument given} bnz deflb sdf03
        jnz  short sdf03 # (jump shortened)
        mov  dword ptr deflb,edi #else default is function name} mov xr deflb
#
#      loop to scan argument names and stack vrblk pointers
#
sdf03:  mov  edx,ch_rp      #delimiter one = right paren} mov =ch_rp wc
        mov  esi,ch_cm      #delimiter two = comma} mov =ch_cm xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan out next argument name} jsr xscan
        or   ecx,ecx        #skip if delimiter found} bnz wa sdf04
        jnz  short sdf04 # (jump shortened)
        call err_0          #} erb 085 null arg name or missing ) in define first arg.
        .byte 85
                            #} ejc
        .eject
#
#      define (continued)
#
#      here after scanning an argument name
#
sdf04:  cmp  edi,offset nulls #skip if non-null} bne xr =nulls sdf05
        jne  short sdf05 # (jump shortened)
        or   ebx,ebx        #ignore null if case of no arguments} bze wb sdf06
        jz   short sdf06 # (jump shortened)
#
#      here after dealing with the case of no arguments
#
sdf05:  call gtnvr          #get vrblk pointer} jsr gtnvr
        .short sdf03-dffnc  #loop back to ignore null name} ppm sdf03
        push edi            #stack argument vrblk pointer} mov xr -(xs)
        inc  ebx            #increment counter} icv wb
        cmp  ecx,num02      #loop back if stopped by a comma} beq wa =num02 sdf03
        je   sdf03
#
#      here after scanning out function argument names
#
sdf06:  mov  dword ptr defna,ebx #save number of arguments} mov wb defna
        xor  ebx,ebx        #zero count of locals} zer wb
#
#      loop to scan local names and stack vrblk pointers
#
sdf07:  mov  edx,ch_cm      #set delimiter one = comma} mov =ch_cm wc
        mov  esi,edx        #set delimiter two = comma} mov wc xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan out next local name} jsr xscan
        cmp  edi,offset nulls #skip if non-null} bne xr =nulls sdf08
        jne  short sdf08 # (jump shortened)
        or   ecx,ecx        #exit scan if end of string} bze wa sdf09
        jz   short sdf09 # (jump shortened)
#
#      here after scanning out a local name
#
sdf08:  call gtnvr          #get vrblk pointer} jsr gtnvr
        .short sdf07-dffnc  #loop back to ignore null name} ppm sdf07
        inc  ebx            #if ok, increment count} icv wb
        push edi            #stack vrblk pointer} mov xr -(xs)
        or   ecx,ecx        #loop back if stopped by a comma} bnz wa sdf07
        jnz  sdf07
                            #} ejc
        .eject
#
#      define (continued)
#
#      here after scanning locals, build pfblk
#
sdf09:  mov  ecx,ebx        #copy count of locals} mov wb wa
        add  ecx,dword ptr defna #add number of arguments} add defna wa
        mov  edx,ecx        #set sum args+locals as loop count} mov wa wc
        add  ecx,pfsi_      #add space for standard fields} add =pfsi_ wa
        sal  ecx,2          #convert length to bytes} wtb wa
        call alloc          #allocate space for pfblk} jsr alloc
        mov  esi,edi        #save pointer to pfblk} mov xr xl
        mov  eax,offset b_pfc #store first word} mov =b_pfc (xr)+
        stosd
        mov  eax,dword ptr defna #store number of arguments} mov defna (xr)+
        stosd
        mov  eax,ecx        #store length (pflen)} mov wa (xr)+
        stosd
        mov  eax,dword ptr defvr #store vrblk ptr for function name} mov defvr (xr)+
        stosd
        mov  eax,ebx        #store number of locals} mov wb (xr)+
        stosd
        xor  eax,eax        #deal with label later} zer (xr)+
        stosd
        xor  eax,eax        #zero pfctr} zer (xr)+
        stosd
        xor  eax,eax        #zero pfrtr} zer (xr)+
        stosd
        or   edx,edx        #skip if no args or locals} bze wc sdf11
        jz   short sdf11 # (jump shortened)
        mov  ecx,esi        #keep pfblk pointer} mov xl wa
        mov  esi,dword ptr defxs #point before arguments} mov defxs xt
#
#      loop to move locals and args to pfblk
#
sdf10:  lea  esi,[esi-4]    #store one entry and bump pointers} mov -(xt) (xr)+
        mov  eax,dword ptr [esi]
        stosd
        dec  edx            #loop till all stored} bct wc sdf10
        jnz  sdf10
        mov  esi,ecx        #recover pfblk pointer} mov wa xl
                            #} ejc
        .eject
#
#      define (continued)
#
#      now deal with label
#
sdf11:  mov  esp,dword ptr defxs #pop stack} mov defxs xs
        mov  eax,dword ptr deflb #store label vrblk in pfblk} mov deflb pfcod(xl)
        mov  dword ptr (4*pfcod)[esi],eax
        mov  edi,dword ptr defvr #point back to vrblk for function} mov defvr xr
        call dffnc          #define function} jsr dffnc
        jmp  exnul          #and exit returning null} brn exnul
#
#      here for erroneous label
#
sdf12:  call err_0          #} erb 086 define function entry point is not defined label
        .byte 86
                            #} ejc
        .eject
#
#      detach
#
        .balign 2           #entry point} ent
        nop
s_det:
        pop  edi            #load argument} mov (xs)+ xr
        call gtvar          #locate variable} jsr gtvar
        .short err_-87-dffnc #} err 087 detach argument is not appropriate name
        call dtach          #detach i/o association from name} jsr dtach
        jmp  exnul          #return null result} brn exnul
                            #} ejc
        .eject
#
#      differ
#
        .balign 2           #entry point} ent
        nop
s_dif:
        pop  edi            #load second argument} mov (xs)+ xr
        pop  esi            #load first argument} mov (xs)+ xl
        call ident          #call ident comparison routine} jsr ident
        .short exfal-dffnc  #fail if ident} ppm exfal
        jmp  exnul          #return null if differ} brn exnul
                            #} ejc
        .eject
#
#      dump
#
        .balign 2           #entry point} ent
        nop
s_dmp:
        call gtsmi          #load dump arg as small integer} jsr gtsmi
        .short err_-88-dffnc #} err 088 dump argument is not integer
        .short err_-89-dffnc #} err 089 dump argument is negative or too large
        call dumpr          #else call dump routine} jsr dumpr
        jmp  exnul          #and return null as result} brn exnul
                            #} ejc
        .eject
#
#      dupl
#
        .balign 2           #entry point} ent
        nop
s_dup:
        call gtsmi          #get second argument as small integr} jsr gtsmi
        .short err_-90-dffnc #} err 090 dupl second argument is not integer
        .short sdup7-dffnc  #jump if negative or too big} ppm sdup7
        mov  ebx,edi        #save duplication factor} mov xr wb
        call gtstg          #get first arg as string} jsr gtstg
        .short sdup4-dffnc  #jump if not a string} ppm sdup4
#
#      here for case of duplication of a string
#
        mov  edx,ecx        #acquire length as integer} mti wa
        mov  dword ptr dupsi,edx #save for the moment} sti dupsi
        mov  edx,ebx        #get duplication factor as integer} mti wb
        imul edx,dword ptr dupsi #form product} mli dupsi
        jo   sdup3          #jump if overflow} iov sdup3
        or   edx,edx        #return null if result length = 0} ieq exnul
        je   exnul
        or   edx,edx        #get as addr integer, check ovflo} mfi wa sdup3
        js   sdup3
        mov  ecx,edx
#
#      merge here with result length in wa
#
sdup1:  mov  esi,edi        #save string pointer} mov xr xl
        call alocs          #allocate space for string} jsr alocs
        push edi            #save as result pointer} mov xr -(xs)
        mov  edx,esi        #save pointer to argument string} mov xl wc
        add  edi,cfp_f      #prepare to store chars of result} psc xr
#
#      loop through duplications
#
sdup2:  mov  esi,edx        #point back to argument string} mov wc xl
        mov  ecx,dword ptr (4*sclen)[esi] #get number of characters} mov sclen(xl) wa
        add  esi,cfp_f      #point to chars in argument string} plc xl
        shrd eax,ecx,1      #move characters to result string} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        dec  ebx            #loop till all duplications done} bct wb sdup2
        jnz  sdup2
        xor  esi,esi        #clear garbage value} zer xl
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      dupl (continued)
#
#      here if too large, set max length and let alocs catch it
#
sdup3:  mov  ecx,dword ptr dname #set impossible length for alocs} mov dname wa
        jmp  sdup1          #merge back} brn sdup1
#
#      here if not a string
#
sdup4:  call gtpat          #convert argument to pattern} jsr gtpat
        .short err_-91-dffnc #} err 091 dupl first argument is not a string or pattern
#
#      here to duplicate a pattern argument
#
        push edi            #store pattern on stack} mov xr -(xs)
        mov  edi,offset ndnth #start off with null pattern} mov =ndnth xr
        or   ebx,ebx        #null pattern is result if dupfac=0} bze wb sdup6
        jz   short sdup6 # (jump shortened)
        push ebx            #preserve loop count} mov wb -(xs)
#
#      loop to duplicate by successive concatenation
#
sdup5:  mov  esi,edi        #copy current value as right argumnt} mov xr xl
        mov  edi,dword ptr (4*num01)[esp] #get a new copy of left} mov num01(xs) xr
        call pconc          #concatenate} jsr pconc
        dec  dword ptr [esp] #count down} dcv (xs)
        cmp  dword ptr dword ptr [esp],0 #loop} bnz (xs) sdup5
        jnz  sdup5
        add  esp,4          #pop loop count} ica xs
#
#      here to exit after constructing pattern
#
sdup6:  mov  dword ptr [esp],edi #store result on stack} mov xr (xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
#
#      fail if second arg is out of range
#
sdup7:  add  esp,4          #pop first argument} ica xs
        jmp  exfal          #fail} brn exfal
                            #} ejc
        .eject
#
#      eject
#
        .balign 2           #entry point} ent
        nop
s_ejc:
        call iofcb          #call fcblk routine} jsr iofcb
        .short err_-92-dffnc #} err 092 eject argument is not a suitable name
        .short sejc1-dffnc  #null argument} ppm sejc1
        .short err_-93-dffnc #} err 093 eject file does not exist
        call sysef          #call eject file function} jsr sysef
        .short err_-93-dffnc #} err 093 eject file does not exist
        .short err_-94-dffnc #} err 094 eject file does not permit page eject
        .short err_-95-dffnc #} err 095 eject caused non-recoverable output error
        jmp  exnul          #return null as result} brn exnul
#
#      here to eject standard output file
#
sejc1:  call sysep          #call routine to eject printer} jsr sysep
        jmp  exnul          #exit with null result} brn exnul
                            #} ejc
        .eject
#
#      endfile
#
        .balign 2           #entry point} ent
        nop
s_enf:
        call iofcb          #call fcblk routine} jsr iofcb
        .short err_-96-dffnc #} err 096 endfile argument is not a suitable name
        .short err_-97-dffnc #} err 097 endfile argument is null
        .short err_-98-dffnc #} err 098 endfile file does not exist
        call sysen          #call endfile routine} jsr sysen
        .short err_-98-dffnc #} err 098 endfile file does not exist
        .short err_-99-dffnc #} err 099 endfile file does not permit endfile
        .short err_-100-dffnc #} err 100 endfile caused non-recoverable output error
        mov  ebx,esi        #remember vrblk ptr from iofcb call} mov xl wb
        mov  edi,esi        #copy pointer} mov xl xr
#
#      loop to find trtrf block
#
senf1:  mov  esi,edi        #remember previous entry} mov xr xl
        mov  edi,dword ptr (4*trval)[edi] #chain along} mov trval(xr) xr
        cmp  dword ptr [edi],offset b_trt #skip out if chain end} bne (xr) =b_trt exnul
        jne  exnul
        cmp  dword ptr (4*trtyp)[edi],trtfc #loop if not found} bne trtyp(xr) =trtfc senf1
        jne  senf1
        mov  eax,dword ptr (4*trval)[edi] #remove trtrf} mov trval(xr) trval(xl)
        mov  dword ptr (4*trval)[esi],eax
        mov  eax,dword ptr (4*trtrf)[edi] #point to head of iochn} mov trtrf(xr) enfch
        mov  dword ptr enfch,eax
        mov  edx,dword ptr (4*trfpt)[edi] #point to fcblk} mov trfpt(xr) wc
        mov  edi,ebx        #filearg1 vrblk from iofcb} mov wb xr
        call setvr          #reset it} jsr setvr
        mov  esi,offset r_fcb #ptr to head of fcblk chain} mov =r_fcb xl
        sub  esi,4*num02    #adjust ready to enter loop} sub *num02 xl
#
#      find fcblk
#
senf2:  mov  edi,esi        #copy ptr} mov xl xr
        mov  esi,dword ptr (4*num02)[esi] #get next link} mov num02(xl) xl
        or   esi,esi        #stop if chain end} bze xl senf4
        jz   short senf4 # (jump shortened)
        cmp  dword ptr (4*num03)[esi],edx #jump if fcblk found} beq num03(xl) wc senf3
        je   short senf3 # (jump shortened)
        jmp  senf2          #loop} brn senf2
#
#      remove fcblk
#
senf3:  mov  eax,dword ptr (4*num02)[esi] #delete fcblk from chain} mov num02(xl) num02(xr)
        mov  dword ptr (4*num02)[edi],eax
#
#      loop which detaches all vbls on iochn chain
#
senf4:  mov  esi,dword ptr enfch #get chain head} mov enfch xl
        or   esi,esi        #finished if chain end} bze xl exnul
        jz   exnul
        mov  eax,dword ptr (4*trtrf)[esi] #chain along} mov trtrf(xl) enfch
        mov  dword ptr enfch,eax
        mov  ecx,dword ptr (4*ionmo)[esi] #name offset} mov ionmo(xl) wa
        mov  esi,dword ptr (4*ionmb)[esi] #name base} mov ionmb(xl) xl
        call dtach          #detach name} jsr dtach
        jmp  senf4          #loop till done} brn senf4
                            #} ejc
        .eject
#
#      eq
#
        .balign 2           #entry point} ent
        nop
s_eqf:
        call acomp          #call arithmetic comparison routine} jsr acomp
        .short err_-101-dffnc #} err 101 eq first argument is not numeric
        .short err_-102-dffnc #} err 102 eq second argument is not numeric
        .short exfal-dffnc  #fail if lt} ppm exfal
        .short exnul-dffnc  #return null if eq} ppm exnul
        .short exfal-dffnc  #fail if gt} ppm exfal
                            #} ejc
        .eject
#
#      eval
#
        .balign 2           #entry point} ent
        nop
s_evl:
        pop  edi            #load argument} mov (xs)+ xr
        mov  edx,[ebp]      #load next code word} lcw wc
        add  ebp,4
        cmp  edx,offset ofne_ #jump if called by value} bne wc =ofne_ sevl1
        jne  short sevl1 # (jump shortened)
        mov  esi,ebp        #copy code pointer} scp xl
        mov  ecx,dword ptr [esi] #get next code word} mov (xl) wa
        cmp  ecx,offset ornm_ #by name unless expression} bne wa =ornm_ sevl2
        jne  short sevl2 # (jump shortened)
        cmp  dword ptr dword ptr (4*num01)[esp],0 #jump if by name} bnz num01(xs) sevl2
        jnz  short sevl2 # (jump shortened)
#
#      here if called by value
#
sevl1:  xor  ebx,ebx        #set flag for by value} zer wb
        push edx            #save code word} mov wc -(xs)
        call gtexp          #convert to expression} jsr gtexp
        .short err_-103-dffnc #} err 103 eval argument is not expression
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        xor  ebx,ebx        #set flag for by value} zer wb
        call evalx          #evaluate expression by value} jsr evalx
        .short exfal-dffnc  #fail if evaluation fails} ppm exfal
        mov  esi,edi        #copy result} mov xr xl
        mov  edi,dword ptr [esp] #reload next code word} mov (xs) xr
        mov  dword ptr [esp],esi #stack result} mov xl (xs)
        jmp  dword ptr [edi] #jump to execute next code word} bri (xr)
#
#      here if called by name
#
sevl2:  mov  ebx,num01      #set flag for by name} mov =num01 wb
        call gtexp          #convert to expression} jsr gtexp
        .short err_-103-dffnc #} err 103 eval argument is not expression
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        mov  ebx,num01      #set flag for by name} mov =num01 wb
        call evalx          #evaluate expression by name} jsr evalx
        .short exfal-dffnc  #fail if evaluation fails} ppm exfal
        jmp  exnam          #exit with name} brn exnam
                            #} ejc
        .eject
#
#      exit
#
        .balign 2           #entry point} ent
        nop
s_ext:
        xor  ebx,ebx        #clear amount of static shift} zer wb
        xor  eax,eax        #forget interim code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        xor  eax,eax        #collect sediment too} zer dnams
        mov  dword ptr dnams,eax
        call gbcol          #compact memory by collecting} jsr gbcol
        mov  dword ptr dnams,edi #record new sediment size} mov xr dnams
        call gtstg          #} jsr gtstg
        .short err_-288-dffnc #} err 288 exit second argument is not a string
        mov  esi,edi        #copy second arg string pointer} mov xr xl
        call gtstg          #convert arg to string} jsr gtstg
        .short err_-104-dffnc #} err 104 exit first argument is not suitable integer or string
        push esi            #save second argument} mov xl -(xs)
        mov  esi,edi        #copy first arg string ptr} mov xr xl
        call gtint          #check it is integer} jsr gtint
        .short sext1-dffnc  #skip if unconvertible} ppm sext1
        xor  esi,esi        #note it is integer} zer xl
        mov  edx,dword ptr (4*icval)[edi] #get integer arg} ldi icval(xr)
#
#      merge to call osint exit routine
#
sext1:  mov  ebx,dword ptr r_fcb #get fcblk chain header} mov r_fcb wb
        mov  edi,offset headv #point to v.v string} mov =headv xr
        pop  ecx            #provide second argument scblk} mov (xs)+ wa
        call sysxi          #call external routine} jsr sysxi
        .short err_-105-dffnc #} err 105 exit action not available in this implementation
        .short err_-106-dffnc #} err 106 exit action caused irrecoverable error
        or   edx,edx        #return if argument 0} ieq exnul
        je   exnul
        or   edx,edx        #skip if positive} igt sext2
        jg   short sext2 # (jump shortened)
        neg  edx            #make positive} ngi
#
#      check for option respecification
#
#      sysxi returns 0 in wa when a file has been resumed,
#      1 when this is a continuation of an exit(4) or exit(-4)
#      action.
#
sext2:                      #get value in work reg} mfi wc
        add  ecx,edx        #prepare to test for continue} add wc wa
        cmp  ecx,num05      #continued execution if 4 plus 1} beq wa =num05 sext5
        je   sext5
        xor  eax,eax        #resuming execution so reset} zer gbcnt
        mov  dword ptr gbcnt,eax
        cmp  edx,num03      #skip if was 3 or 4} bge wc =num03 sext3
        jae  short sext3 # (jump shortened)
        push edx            #save value} mov wc -(xs)
        xor  edx,edx        #set to read options} zer wc
        call prpar          #read syspp options} jsr prpar
        pop  edx            #restore value} mov (xs)+ wc
#
#      deal with header option (fiddled by prpar)
#
sext3:  mov  dword ptr headp,esp #assume no headers} mnz headp
        cmp  edx,num01      #skip if not 1} bne wc =num01 sext4
        jne  short sext4 # (jump shortened)
        xor  eax,eax        #request header printing} zer headp
        mov  dword ptr headp,eax
#
#      almost ready to resume running
#
sext4:  call systm          #get execution time start (sgd11)} jsr systm
        mov  dword ptr timsx,edx #save as initial time} sti timsx
        mov  edx,dword ptr kvstc #reset to ensure ...} ldi kvstc
        mov  dword ptr kvstl,edx #... correct execution stats} sti kvstl
        call stgcc          #recompute countdown counters} jsr stgcc
        jmp  exnul          #resume execution} brn exnul
#
#      here after exit(4) or exit(-4) -- create save file
#      or load module and continue execution.
#
#      return integer 1 to signal the continuation of the
#      original execution.
#
sext5:  mov  edi,offset inton #integer one} mov =inton xr
        jmp  exixr          #return as result} brn exixr
                            #} ejc
        .eject
#
#      exp
#
        .balign 2           #entry point} ent
        nop
s_exp:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-304-dffnc #} err 304 exp argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call etx_           #take exponential} etx
        call ovr_           #if no overflow, return result in ra} rno exrea
        jno  exrea
        call err_1          #} erb 305 exp produced real overflow
        .byte 49
                            #} ejc
        .eject
#
#      field
#
        .balign 2           #entry point} ent
        nop
s_fld:
        call gtsmi          #get second argument (field number)} jsr gtsmi
        .short err_-107-dffnc #} err 107 field second argument is not integer
        .short exfal-dffnc  #fail if out of range} ppm exfal
        mov  ebx,edi        #else save integer value} mov xr wb
        pop  edi            #load first argument} mov (xs)+ xr
        call gtnvr          #point to vrblk} jsr gtnvr
        .short sfld1-dffnc  #jump (error) if not variable name} ppm sfld1
        mov  edi,dword ptr (4*vrfnc)[edi] #else point to function block} mov vrfnc(xr) xr
        cmp  dword ptr [edi],offset b_dfc #error if not datatype function} bne (xr) =b_dfc sfld1
        jne  short sfld1 # (jump shortened)
#
#      here if first argument is a datatype function name
#
        or   ebx,ebx        #fail if argument number is zero} bze wb exfal
        jz   exfal
        cmp  ebx,dword ptr (4*fargs)[edi] #fail if too large} bgt wb fargs(xr) exfal
        ja   exfal
        sal  ebx,2          #else convert to byte offset} wtb wb
        add  edi,ebx        #point to field name} add wb xr
        mov  edi,dword ptr (4*dfflb)[edi] #load vrblk pointer} mov dfflb(xr) xr
        jmp  exvnm          #exit to build nmblk} brn exvnm
#
#      here for bad first argument
#
sfld1:  call err_0          #} erb 108 field first argument is not datatype name
        .byte 108
                            #} ejc
        .eject
#
#      fence
#
        .balign 2           #entry point} ent
        nop
s_fnc:
        mov  ebx,offset p_fnc #set pcode for p_fnc} mov =p_fnc wb
        xor  edi,edi        #p0blk} zer xr
        call pbild          #build p_fnc node} jsr pbild
        mov  esi,edi        #save pointer to it} mov xr xl
        pop  edi            #get argument} mov (xs)+ xr
        call gtpat          #convert to pattern} jsr gtpat
        .short err_-259-dffnc #} err 259 fence argument is not pattern
        call pconc          #concatenate to p_fnc node} jsr pconc
        mov  esi,edi        #save ptr to concatenated pattern} mov xr xl
        mov  ebx,offset p_fna #set for p_fna pcode} mov =p_fna wb
        xor  edi,edi        #p0blk} zer xr
        call pbild          #construct p_fna node} jsr pbild
        mov  dword ptr (4*pthen)[edi],esi #set pattern as pthen} mov xl pthen(xr)
        push edi            #set as result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      ge
#
        .balign 2           #entry point} ent
        nop
s_gef:
        call acomp          #call arithmetic comparison routine} jsr acomp
        .short err_-109-dffnc #} err 109 ge first argument is not numeric
        .short err_-110-dffnc #} err 110 ge second argument is not numeric
        .short exfal-dffnc  #fail if lt} ppm exfal
        .short exnul-dffnc  #return null if eq} ppm exnul
        .short exnul-dffnc  #return null if gt} ppm exnul
                            #} ejc
        .eject
#
#      gt
#
        .balign 2           #entry point} ent
        nop
s_gtf:
        call acomp          #call arithmetic comparison routine} jsr acomp
        .short err_-111-dffnc #} err 111 gt first argument is not numeric
        .short err_-112-dffnc #} err 112 gt second argument is not numeric
        .short exfal-dffnc  #fail if lt} ppm exfal
        .short exfal-dffnc  #fail if eq} ppm exfal
        .short exnul-dffnc  #return null if gt} ppm exnul
                            #} ejc
        .eject
#
#      host
#
        .balign 2           #entry point} ent
        nop
s_hst:
        pop  edx            #get fifth arg} mov (xs)+ wc
        pop  ebx            #get fourth arg} mov (xs)+ wb
        pop  edi            #get third arg} mov (xs)+ xr
        pop  esi            #get second arg} mov (xs)+ xl
        pop  ecx            #get first arg} mov (xs)+ wa
        call syshs          #enter syshs routine} jsr syshs
        .short err_-254-dffnc #} err 254 erroneous argument for host
        .short err_-255-dffnc #} err 255 error during execution of host
        .short shst1-dffnc  #store host string} ppm shst1
        .short exnul-dffnc  #return null result} ppm exnul
        .short exixr-dffnc  #return edi} ppm exixr
        .short exfal-dffnc  #fail return} ppm exfal
        .short shst3-dffnc  #store actual string} ppm shst3
        .short shst4-dffnc  #return copy of edi} ppm shst4
#
#      return host string
#
shst1:  or   esi,esi        #null string if syshs uncooperative} bze xl exnul
        jz   exnul
        mov  ecx,dword ptr (4*sclen)[esi] #length} mov sclen(xl) wa
        xor  ebx,ebx        #zero offset} zer wb
#
#      copy string and return
#
shst2:  call sbstr          #build copy of string} jsr sbstr
        push edi            #stack the result} mov xr -(xs)
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      return actual string pointed to by xl
#
shst3:  xor  ebx,ebx        #treat esi like an scblk ptr} zer wb
        sub  ebx,cfp_f      #by creating a negative offset} sub =cfp_f wb
        jmp  shst2          #join to copy string} brn shst2
#
#      return copy of block pointed to by xr
#
shst4:  push edi            #stack results} mov xr -(xs)
        call copyb          #make copy of block} jsr copyb
        .short exits-dffnc  #if not an aggregate structure} ppm exits
        jmp  exsid          #set current id value otherwise} brn exsid
                            #} ejc
        .eject
#
#      ident
#
        .balign 2           #entry point} ent
        nop
s_idn:
        pop  edi            #load second argument} mov (xs)+ xr
        pop  esi            #load first argument} mov (xs)+ xl
        call ident          #call ident comparison routine} jsr ident
        .short exnul-dffnc  #return null if ident} ppm exnul
        jmp  exfal          #fail if differ} brn exfal
                            #} ejc
        .eject
#
#      input
#
        .balign 2           #entry point} ent
        nop
s_inp:
        xor  ebx,ebx        #input flag} zer wb
        call ioput          #call input/output assoc. routine} jsr ioput
        .short err_-113-dffnc #} err 113 input third argument is not a string
        .short err_-114-dffnc #} err 114 inappropriate second argument for input
        .short err_-115-dffnc #} err 115 inappropriate first argument for input
        .short err_-116-dffnc #} err 116 inappropriate file specification for input
        .short exfal-dffnc  #fail if file does not exist} ppm exfal
        .short err_-117-dffnc #} err 117 input file cannot be read
        .short err_-289-dffnc #} err 289 input channel currently in use
        jmp  exnul          #return null string} brn exnul
                            #} ejc
        .eject
#
#      integer
#
        .balign 2           #entry point} ent
        nop
s_int:
        pop  edi            #load argument} mov (xs)+ xr
        call gtnum          #convert to numeric} jsr gtnum
        .short exfal-dffnc  #fail if non-numeric} ppm exfal
        cmp  ecx,offset b_icl #return null if integer} beq wa =b_icl exnul
        je   exnul
        jmp  exfal          #fail if real} brn exfal
                            #} ejc
        .eject
#
#      item
#
#      item does not permit the direct (fast) call so that
#      wa contains the actual number of arguments passed.
#
        .balign 2           #entry point} ent
        nop
s_itm:
#
#      deal with case of no args
#
        or   ecx,ecx        #jump if at least one arg} bnz wa sitm1
        jnz  short sitm1 # (jump shortened)
        push offset nulls   #else supply garbage null arg} mov =nulls -(xs)
        mov  ecx,num01      #and fix argument count} mov =num01 wa
#
#      check for name/value cases
#
sitm1:  mov  edi,ebp        #get current code pointer} scp xr
        mov  esi,dword ptr [edi] #load next code word} mov (xr) xl
        dec  ecx            #get number of subscripts} dcv wa
        mov  edi,ecx        #copy for arref} mov wa xr
        cmp  esi,offset ofne_ #jump if called by name} beq xl =ofne_ sitm2
        je   short sitm2 # (jump shortened)
#
#      here if called by value
#
        xor  ebx,ebx        #set code for call by value} zer wb
        jmp  arref          #off to array reference routine} brn arref
#
#      here for call by name
#
sitm2:  mov  ebx,esp        #set code for call by name} mnz wb
        mov  ecx,[ebp]      #load and ignore ofne_ call} lcw wa
        add  ebp,4
        jmp  arref          #off to array reference routine} brn arref
                            #} ejc
        .eject
#
#      le
#
        .balign 2           #entry point} ent
        nop
s_lef:
        call acomp          #call arithmetic comparison routine} jsr acomp
        .short err_-118-dffnc #} err 118 le first argument is not numeric
        .short err_-119-dffnc #} err 119 le second argument is not numeric
        .short exnul-dffnc  #return null if lt} ppm exnul
        .short exnul-dffnc  #return null if eq} ppm exnul
        .short exfal-dffnc  #fail if gt} ppm exfal
                            #} ejc
        .eject
#
#      len
#
        .balign 2           #entry point} ent
        nop
s_len:
        mov  ebx,offset p_len #set pcode for integer arg case} mov =p_len wb
        mov  ecx,offset p_lnd #set pcode for expr arg case} mov =p_lnd wa
        call patin          #call common routine to build node} jsr patin
        .short err_-120-dffnc #} err 120 len argument is not integer or expression
        .short err_-121-dffnc #} err 121 len argument is negative or too large
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      leq
#
        .balign 2           #entry point} ent
        nop
s_leq:
        call lcomp          #call string comparison routine} jsr lcomp
        .short err_-122-dffnc #} err 122 leq first argument is not a string
        .short err_-123-dffnc #} err 123 leq second argument is not a string
        .short exfal-dffnc  #fail if llt} ppm exfal
        .short exnul-dffnc  #return null if leq} ppm exnul
        .short exfal-dffnc  #fail if lgt} ppm exfal
                            #} ejc
        .eject
#
#      lge
#
        .balign 2           #entry point} ent
        nop
s_lge:
        call lcomp          #call string comparison routine} jsr lcomp
        .short err_-124-dffnc #} err 124 lge first argument is not a string
        .short err_-125-dffnc #} err 125 lge second argument is not a string
        .short exfal-dffnc  #fail if llt} ppm exfal
        .short exnul-dffnc  #return null if leq} ppm exnul
        .short exnul-dffnc  #return null if lgt} ppm exnul
                            #} ejc
        .eject
#
#      lgt
#
        .balign 2           #entry point} ent
        nop
s_lgt:
        call lcomp          #call string comparison routine} jsr lcomp
        .short err_-126-dffnc #} err 126 lgt first argument is not a string
        .short err_-127-dffnc #} err 127 lgt second argument is not a string
        .short exfal-dffnc  #fail if llt} ppm exfal
        .short exfal-dffnc  #fail if leq} ppm exfal
        .short exnul-dffnc  #return null if lgt} ppm exnul
                            #} ejc
        .eject
#
#      lle
#
        .balign 2           #entry point} ent
        nop
s_lle:
        call lcomp          #call string comparison routine} jsr lcomp
        .short err_-128-dffnc #} err 128 lle first argument is not a string
        .short err_-129-dffnc #} err 129 lle second argument is not a string
        .short exnul-dffnc  #return null if llt} ppm exnul
        .short exnul-dffnc  #return null if leq} ppm exnul
        .short exfal-dffnc  #fail if lgt} ppm exfal
                            #} ejc
        .eject
#
#      llt
#
        .balign 2           #entry point} ent
        nop
s_llt:
        call lcomp          #call string comparison routine} jsr lcomp
        .short err_-130-dffnc #} err 130 llt first argument is not a string
        .short err_-131-dffnc #} err 131 llt second argument is not a string
        .short exnul-dffnc  #return null if llt} ppm exnul
        .short exfal-dffnc  #fail if leq} ppm exfal
        .short exfal-dffnc  #fail if lgt} ppm exfal
                            #} ejc
        .eject
#
#      lne
#
        .balign 2           #entry point} ent
        nop
s_lne:
        call lcomp          #call string comparison routine} jsr lcomp
        .short err_-132-dffnc #} err 132 lne first argument is not a string
        .short err_-133-dffnc #} err 133 lne second argument is not a string
        .short exnul-dffnc  #return null if llt} ppm exnul
        .short exfal-dffnc  #fail if leq} ppm exfal
        .short exnul-dffnc  #return null if lgt} ppm exnul
                            #} ejc
        .eject
#
#      ln
#
        .balign 2           #entry point} ent
        nop
s_lnf:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-306-dffnc #} err 306 ln argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call cpr_           #overflow if argument is 0} req slnf1
        je   short slnf1 # (jump shortened)
        call cpr_           #error if argument less than 0} rlt slnf2
        jl   short slnf2 # (jump shortened)
        call lnf_           #take natural logarithm} lnf
        call ovr_           #if no overflow, return result in ra} rno exrea
        jno  exrea
slnf1:  call err_1          #} erb 307 ln produced real overflow
        .byte 51
#
#      here for bad argument
#
slnf2:  call err_1          #} erb 315 ln argument negative
        .byte 59
                            #} ejc
        .eject
#
#      local
#
        .balign 2           #entry point} ent
        nop
s_loc:
        call gtsmi          #get second argument (local number)} jsr gtsmi
        .short err_-134-dffnc #} err 134 local second argument is not integer
        .short exfal-dffnc  #fail if out of range} ppm exfal
        mov  ebx,edi        #save local number} mov xr wb
        pop  edi            #load first argument} mov (xs)+ xr
        call gtnvr          #point to vrblk} jsr gtnvr
        .short sloc1-dffnc  #jump if not variable name} ppm sloc1
        mov  edi,dword ptr (4*vrfnc)[edi] #else load function pointer} mov vrfnc(xr) xr
        cmp  dword ptr [edi],offset b_pfc #jump if not program defined} bne (xr) =b_pfc sloc1
        jne  short sloc1 # (jump shortened)
#
#      here if we have a program defined function name
#
        or   ebx,ebx        #fail if second arg is zero} bze wb exfal
        jz   exfal
        cmp  ebx,dword ptr (4*pfnlo)[edi] #or too large} bgt wb pfnlo(xr) exfal
        ja   exfal
        add  ebx,dword ptr (4*fargs)[edi] #else adjust offset to include args} add fargs(xr) wb
        sal  ebx,2          #convert to bytes} wtb wb
        add  edi,ebx        #point to local pointer} add wb xr
        mov  edi,dword ptr (4*pfagb)[edi] #load vrblk pointer} mov pfagb(xr) xr
        jmp  exvnm          #exit building nmblk} brn exvnm
#
#      here if first argument is no good
#
sloc1:  call err_0          #} erb 135 local first arg is not a program function name
        .byte 135
                            #} ejc
        .eject
#
#      load
#
        .balign 2           #entry point} ent
        nop
s_lod:
        call gtstg          #load library name} jsr gtstg
        .short err_-136-dffnc #} err 136 load second argument is not a string
        mov  esi,edi        #save library name} mov xr xl
        call xscni          #prepare to scan first argument} jsr xscni
        .short err_-137-dffnc #} err 137 load first argument is not a string
        .short err_-138-dffnc #} err 138 load first argument is null
        push esi            #stack library name} mov xl -(xs)
        mov  edx,ch_pp      #set delimiter one = left paren} mov =ch_pp wc
        mov  esi,edx        #set delimiter two = left paren} mov wc xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan function name} jsr xscan
        push edi            #save ptr to function name} mov xr -(xs)
        or   ecx,ecx        #jump if left paren found} bnz wa slod1
        jnz  short slod1 # (jump shortened)
        call err_0          #} erb 139 load first argument is missing a left paren
        .byte 139
#
#      here after successfully scanning function name
#
slod1:  call gtnvr          #locate vrblk} jsr gtnvr
        .short err_-140-dffnc #} err 140 load first argument has null function name
        mov  dword ptr lodfn,edi #save vrblk pointer} mov xr lodfn
        xor  eax,eax        #zero count of arguments} zer lodna
        mov  dword ptr lodna,eax
#
#      loop to scan argument datatype names
#
slod2:  mov  edx,ch_rp      #delimiter one is right paren} mov =ch_rp wc
        mov  esi,ch_cm      #delimiter two is comma} mov =ch_cm xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan next argument name} jsr xscan
        inc  dword ptr lodna #bump argument count} icv lodna
        or   ecx,ecx        #jump if ok delimiter was found} bnz wa slod3
        jnz  short slod3 # (jump shortened)
        call err_0          #} erb 141 load first argument is missing a right paren
        .byte 141
                            #} ejc
        .eject
#
#      load (continued)
#
#      come here to analyze the datatype pointer in (xr). this
#      code is used both for arguments (wa=1,2) and for the
#      result datatype (with wa set to zero).
#
slod3:  mov  ebx,ecx        #save scan mode} mov wa wb
        mov  ecx,dword ptr (4*sclen)[edi] #datatype length} mov sclen(xr) wa
        or   ecx,ecx        #bypass if null string} bze wa sld3a
        jz   short sld3a # (jump shortened)
        call flstg          #fold to upper case} jsr flstg
sld3a:  mov  ecx,ebx        #restore scan mode} mov wb wa
        push edi            #stack datatype name pointer} mov xr -(xs)
        mov  ebx,num01      #set string code in case} mov =num01 wb
        mov  esi,offset scstr #point to /string/} mov =scstr xl
        call ident          #check for match} jsr ident
        .short slod4-dffnc  #jump if match} ppm slod4
        mov  edi,dword ptr [esp] #else reload name} mov (xs) xr
        add  ebx,ebx        #set code for integer (2)} add wb wb
        mov  esi,offset scint #point to /integer/} mov =scint xl
        call ident          #check for match} jsr ident
        .short slod4-dffnc  #jump if match} ppm slod4
        mov  edi,dword ptr [esp] #else reload string pointer} mov (xs) xr
        inc  ebx            #set code for real (3)} icv wb
        mov  esi,offset screa #point to /real/} mov =screa xl
        call ident          #check for match} jsr ident
        .short slod4-dffnc  #jump if match} ppm slod4
        mov  edi,dword ptr [esp] #reload string pointer} mov (xs) xr
        inc  ebx            #code for file (4, or 3 if no reals)} icv wb
        mov  esi,offset scfil #point to /file/} mov =scfil xl
        call ident          #check for match} jsr ident
        .short slod4-dffnc  #jump if match} ppm slod4
        xor  ebx,ebx        #else get code for no convert} zer wb
#
#      merge here with proper datatype code in wb
#
slod4:  mov  dword ptr [esp],ebx #store code on stack} mov wb (xs)
        cmp  ecx,num02      #loop back if arg stopped by comma} beq wa =num02 slod2
        je   slod2
        or   ecx,ecx        #jump if that was the result type} bze wa slod5
        jz   short slod5 # (jump shortened)
#
#      here we scan out the result type (arg stopped by ) )
#
        mov  edx,dword ptr mxlen #set dummy (impossible) delimiter 1} mov mxlen wc
        mov  esi,edx        #and delimiter two} mov wc xl
        mov  ecx,esp        #skip/trim blanks in prototype} mnz wa
        call xscan          #scan result name} jsr xscan
        xor  ecx,ecx        #set code for processing result} zer wa
        jmp  slod3          #jump back to process result name} brn slod3
                            #} ejc
        .eject
#
#      load (continued)
#
#      here after processing all args and result
#
slod5:  mov  ecx,dword ptr lodna #get number of arguments} mov lodna wa
        mov  edx,ecx        #copy for later} mov wa wc
        sal  ecx,2          #convert length to bytes} wtb wa
        add  ecx,4*efsi_    #add space for standard fields} add *efsi_ wa
        call alloc          #allocate efblk} jsr alloc
        mov  dword ptr [edi],offset b_efc #set type word} mov =b_efc (xr)
        mov  dword ptr (4*fargs)[edi],edx #set number of arguments} mov wc fargs(xr)
        xor  eax,eax        #set use count (dffnc will set to 1)} zer efuse(xr)
        mov  dword ptr (4*efuse)[edi],eax
        xor  eax,eax        #zero code pointer for now} zer efcod(xr)
        mov  dword ptr (4*efcod)[edi],eax
        pop  dword ptr (4*efrsl)[edi] #store result type code} mov (xs)+ efrsl(xr)
        mov  eax,dword ptr lodfn #store function vrblk pointer} mov lodfn efvar(xr)
        mov  dword ptr (4*efvar)[edi],eax
        mov  dword ptr (4*eflen)[edi],ecx #store efblk length} mov wa eflen(xr)
        mov  ebx,edi        #save efblk pointer} mov xr wb
        add  edi,ecx        #point past end of efblk} add wa xr
#
#      loop to set argument type codes from stack
#
slod6:  lea  edi,[edi-4]    #store one type code from stack} mov (xs)+ -(xr)
        pop  dword ptr [edi]
        dec  edx            #loop till all stored} bct wc slod6
        jnz  slod6
#
#      now load the external function and perform definition
#
        pop  edi            #load function string name} mov (xs)+ xr
        mov  ecx,dword ptr (4*sclen)[edi] #function name length} mov sclen(xr) wa
        call flstg          #fold to upper case} jsr flstg
        mov  esi,dword ptr [esp] #load library name} mov (xs) xl
        mov  dword ptr [esp],ebx #store efblk pointer} mov wb (xs)
        call sysld          #call function to load external func} jsr sysld
        .short err_-142-dffnc #} err 142 load function does not exist
        .short err_-143-dffnc #} err 143 load function caused input error during load
        .short err_-328-dffnc #} err 328 load function - insufficient memory
        pop  esi            #recall efblk pointer} mov (xs)+ xl
        mov  dword ptr (4*efcod)[esi],edi #store code pointer} mov xr efcod(xl)
        mov  edi,dword ptr lodfn #point to vrblk for function} mov lodfn xr
        call dffnc          #perform function definition} jsr dffnc
        jmp  exnul          #return null result} brn exnul
                            #} ejc
        .eject
#
#      lpad
#
        .balign 2           #entry point} ent
        nop
s_lpd:
        call gtstg          #get pad character} jsr gtstg
        .short err_-144-dffnc #} err 144 lpad third argument is not a string
        add  edi,cfp_f      #point to character (null is blank)} plc xr
        movzx ebx,byte ptr [edi] #load pad character} lch wb (xr)
        call gtsmi          #get pad length} jsr gtsmi
        .short err_-145-dffnc #} err 145 lpad second argument is not integer
        .short slpd4-dffnc  #skip if negative or large} ppm slpd4
#
#      merge to check first arg
#
slpd1:  call gtstg          #get first argument (string to pad)} jsr gtstg
        .short err_-146-dffnc #} err 146 lpad first argument is not a string
        cmp  ecx,edx        #return 1st arg if too long to pad} bge wa wc exixr
        jae  exixr
        mov  esi,edi        #else move ptr to string to pad} mov xr xl
#
#      now we are ready for the pad
#
#      (xl)                  pointer to string to pad
#      (wb)                  pad character
#      (wc)                  length to pad string to
#
        mov  ecx,edx        #copy length} mov wc wa
        call alocs          #allocate scblk for new string} jsr alocs
        push edi            #save as result} mov xr -(xs)
        mov  ecx,dword ptr (4*sclen)[esi] #load length of argument} mov sclen(xl) wa
        sub  edx,ecx        #calculate number of pad characters} sub wa wc
        add  edi,cfp_f      #point to chars in result string} psc xr
#
#      loop to perform pad
#
slpd2:  mov  al,bl          #store pad character, bump ptr} sch wb (xr)+
        stosb
        dec  edx            #loop till all pad chars stored} bct wc slpd2
        jnz  slpd2
#
#      now copy string
#
        or   ecx,ecx        #exit if null string} bze wa slpd3
        jz   short slpd3 # (jump shortened)
        add  esi,cfp_f      #else point to chars in argument} plc xl
        shrd eax,ecx,1      #move characters to result string} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        xor  esi,esi        #clear garbage esi} zer xl
#
#      here to exit with result on stack
#
slpd3:  mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      here if 2nd arg is negative or large
#
slpd4:  xor  edx,edx        #zero pad count} zer wc
        jmp  slpd1          #merge} brn slpd1
                            #} ejc
        .eject
#
#      lt
#
        .balign 2           #entry point} ent
        nop
s_ltf:
        call acomp          #call arithmetic comparison routine} jsr acomp
        .short err_-147-dffnc #} err 147 lt first argument is not numeric
        .short err_-148-dffnc #} err 148 lt second argument is not numeric
        .short exnul-dffnc  #return null if lt} ppm exnul
        .short exfal-dffnc  #fail if eq} ppm exfal
        .short exfal-dffnc  #fail if gt} ppm exfal
                            #} ejc
        .eject
#
#      ne
#
        .balign 2           #entry point} ent
        nop
s_nef:
        call acomp          #call arithmetic comparison routine} jsr acomp
        .short err_-149-dffnc #} err 149 ne first argument is not numeric
        .short err_-150-dffnc #} err 150 ne second argument is not numeric
        .short exnul-dffnc  #return null if lt} ppm exnul
        .short exfal-dffnc  #fail if eq} ppm exfal
        .short exnul-dffnc  #return null if gt} ppm exnul
                            #} ejc
        .eject
#
#      notany
#
        .balign 2           #entry point} ent
        nop
s_nay:
        mov  ebx,offset p_nas #set pcode for single char arg} mov =p_nas wb
        mov  esi,offset p_nay #pcode for multi-char arg} mov =p_nay xl
        mov  edx,offset p_nad #set pcode for expr arg} mov =p_nad wc
        call patst          #call common routine to build node} jsr patst
        .short err_-151-dffnc #} err 151 notany argument is not a string or expression
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      opsyn
#
        .balign 2           #entry point} ent
        nop
s_ops:
        call gtsmi          #load third argument} jsr gtsmi
        .short err_-152-dffnc #} err 152 opsyn third argument is not integer
        .short err_-153-dffnc #} err 153 opsyn third argument is negative or too large
        mov  ebx,edx        #if ok, save third argumnet} mov wc wb
        pop  edi            #load second argument} mov (xs)+ xr
        call gtnvr          #locate variable block} jsr gtnvr
        .short err_-154-dffnc #} err 154 opsyn second arg is not natural variable name
        mov  esi,dword ptr (4*vrfnc)[edi] #if ok, load function block pointer} mov vrfnc(xr) xl
        or   ebx,ebx        #jump if operator opsyn case} bnz wb sops2
        jnz  short sops2 # (jump shortened)
#
#      here for function opsyn (third arg zero)
#
        pop  edi            #load first argument} mov (xs)+ xr
        call gtnvr          #get vrblk pointer} jsr gtnvr
        .short err_-155-dffnc #} err 155 opsyn first arg is not natural variable name
#
#      merge here to perform function definition
#
sops1:  call dffnc          #call function definer} jsr dffnc
        jmp  exnul          #exit with null result} brn exnul
#
#      here for operator opsyn (third arg non-zero)
#
sops2:  call gtstg          #get operator name} jsr gtstg
        .short sops5-dffnc  #jump if not string} ppm sops5
        cmp  ecx,num01      #error if not one char long} bne wa =num01 sops5
        jne  sops5
        add  edi,cfp_f      #else point to character} plc xr
        movzx edx,byte ptr [edi] #load character name} lch wc (xr)
                            #} ejc
        .eject
#
#      opsyn (continued)
#
#      now set to search for matching unary or binary operator
#      name as appropriate. note that there are =opbun undefined
#      binary operators and =opuun undefined unary operators.
#
        mov  ecx,offset r_uub #point to unop pointers in case} mov =r_uub wa
        mov  edi,offset opnsu #point to names of unary operators} mov =opnsu xr
        add  ebx,opbun      #add no. of undefined binary ops} add =opbun wb
        cmp  ebx,opuun      #jump if unop (third arg was 1)} beq wb =opuun sops3
        je   short sops3 # (jump shortened)
        mov  ecx,offset r_uba #else point to binary operator ptrs} mov =r_uba wa
        mov  edi,offset opsnb #point to names of binary operators} mov =opsnb xr
        mov  ebx,opbun      #set number of undefined binops} mov =opbun wb
#
#      merge here to check list (wb = number to check)
#
sops3:                      #set counter to control loop} lct wb wb
#
#      loop to search for name match
#
sops4:  cmp  edx,dword ptr [edi] #jump if names match} beq wc (xr) sops6
        je   short sops6 # (jump shortened)
        add  ecx,4          #else push pointer to function ptr} ica wa
        add  edi,4          #bump pointer} ica xr
        dec  ebx            #loop back till all checked} bct wb sops4
        jnz  sops4
#
#      here if bad operator name
#
sops5:  call err_0          #} erb 156 opsyn first arg is not correct operator name
        .byte 156
#
#      come here on finding a match in the operator name table
#
sops6:  mov  edi,ecx        #copy pointer to function block ptr} mov wa xr
        sub  edi,4*vrfnc    #make it look like dummy vrblk} sub *vrfnc xr
        jmp  sops1          #merge back to define operator} brn sops1
                            #} ejc
        .eject
#
#      output
#
        .balign 2           #entry point} ent
        nop
s_oup:
        mov  ebx,num03      #output flag} mov =num03 wb
        call ioput          #call input/output assoc. routine} jsr ioput
        .short err_-157-dffnc #} err 157 output third argument is not a string
        .short err_-158-dffnc #} err 158 inappropriate second argument for output
        .short err_-159-dffnc #} err 159 inappropriate first argument for output
        .short err_-160-dffnc #} err 160 inappropriate file specification for output
        .short exfal-dffnc  #fail if file does not exist} ppm exfal
        .short err_-161-dffnc #} err 161 output file cannot be written to
        .short err_-290-dffnc #} err 290 output channel currently in use
        jmp  exnul          #return null string} brn exnul
                            #} ejc
        .eject
#
#      pos
#
        .balign 2           #entry point} ent
        nop
s_pos:
        mov  ebx,offset p_pos #set pcode for integer arg case} mov =p_pos wb
        mov  ecx,offset p_psd #set pcode for expression arg case} mov =p_psd wa
        call patin          #call common routine to build node} jsr patin
        .short err_-162-dffnc #} err 162 pos argument is not integer or expression
        .short err_-163-dffnc #} err 163 pos argument is negative or too large
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      prototype
#
        .balign 2           #entry point} ent
        nop
s_pro:
        pop  edi            #load argument} mov (xs)+ xr
        mov  ebx,dword ptr (4*tblen)[edi] #length if table, vector (=vclen)} mov tblen(xr) wb
        shr  ebx,2          #convert to words} btw wb
        mov  ecx,dword ptr [edi] #load type word of argument block} mov (xr) wa
        cmp  ecx,offset b_art #jump if array} beq wa =b_art spro4
        je   short spro4 # (jump shortened)
        cmp  ecx,offset b_tbt #jump if table} beq wa =b_tbt spro1
        je   short spro1 # (jump shortened)
        cmp  ecx,offset b_vct #jump if vector} beq wa =b_vct spro3
        je   short spro3 # (jump shortened)
        call err_0          #} erb 164 prototype argument is not valid object
        .byte 164
#
#      here for table
#
spro1:  sub  ebx,tbsi_      #subtract standard fields} sub =tbsi_ wb
#
#      merge for vector
#
spro2:  mov  edx,ebx        #convert to integer} mti wb
        jmp  exint          #exit with integer result} brn exint
#
#      here for vector
#
spro3:  sub  ebx,vcsi_      #subtract standard fields} sub =vcsi_ wb
        jmp  spro2          #merge} brn spro2
#
#      here for array
#
spro4:  add  edi,dword ptr (4*arofs)[edi] #point to prototype field} add arofs(xr) xr
        mov  edi,dword ptr [edi] #load prototype} mov (xr) xr
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      remdr
#
        .balign 2           #entry point} ent
        nop
s_rmd:
        call arith          #get two integers or two reals} jsr arith
        .short err_-166-dffnc #} err 166 remdr first argument is not numeric
        .short err_-165-dffnc #} err 165 remdr second argument is not numeric
        .short srm06-dffnc  #if real} ppm srm06
#
#      both arguments integer
#
        xor  ebx,ebx        #set positive flag} zer wb
        mov  edx,dword ptr (4*icval)[edi] #load left argument value} ldi icval(xr)
        or   edx,edx        #jump if positive} ige srm01
        jge  short srm01 # (jump shortened)
        mov  ebx,esp        #set negative flag} mnz wb
srm01:  mov  eax,dword ptr (4*icval)[esi] #get remainder} rmi icval(xl)
        call rmi_
        jo   short srm05          #error if overflow} iov srm05 # (jump shortened)
#
#      make sign of result match sign of first argument
#
        or   ebx,ebx        #if result should be positive} bze wb srm03
        jz   short srm03 # (jump shortened)
        or   edx,edx        #if should be negative, and is} ile exint
        jle  exint
srm02:  neg  edx            #adjust sign of result} ngi
        jmp  exint          #return result} brn exint
srm03:  or   edx,edx        #should be pos, and result negative} ilt srm02
        jl   srm02
        jmp  exint          #should be positive, and is} brn exint
#
#      fail first argument
#
srm04:  call err_0          #} erb 166 remdr first argument is not numeric
        .byte 166
#
#      fail if overflow
#
srm05:  call err_0          #} erb 167 remdr caused integer overflow
        .byte 167
#
#      here with 1st argument in (xr), 2nd in (xl), both real
#
#      result = n1 - chop(n1/n2)*n2
#
srm06:  xor  ebx,ebx        #set positive flag} zer wb
        lea  eax,dword ptr (4*rcval)[edi] #load left argument value} ldr rcval(xr)
        call ldr_
        call cpr_           #jump if positive} rge srm07
        jge  short srm07 # (jump shortened)
        mov  ebx,esp        #set negative flag} mnz wb
srm07:  lea  eax,dword ptr (4*rcval)[esi] #compute n1/n2} dvr rcval(xl)
        call dvr_
        call ovr_           #jump if overflow} rov srm10
        jo   short srm10 # (jump shortened)
        call chp_           #chop result} chp
        lea  eax,dword ptr (4*rcval)[esi] #times n2} mlr rcval(xl)
        call mlr_
        lea  eax,dword ptr (4*rcval)[edi] #compute difference} sbr rcval(xr)
        call sbr_
#
#      make sign of result match sign of first argument
#      -result is in ra at this point
#
        or   ebx,ebx        #if result should be positive} bze wb srm09
        jz   short srm09 # (jump shortened)
        call cpr_           #if should be negative, and is} rle exrea
        jle  exrea
srm08:  call ngr_           #adjust sign of result} ngr
        jmp  exrea          #return result} brn exrea
srm09:  call cpr_           #should be pos, and result negative} rlt srm08
        jl   srm08
        jmp  exrea          #should be positive, and is} brn exrea
#
#      fail if overflow
#
srm10:  call err_1          #} erb 312 remdr caused real overflow
        .byte 56
                            #} ejc
        .eject
#
#      replace
#
#      the actual replace operation uses an scblk whose cfp$a
#      chars contain the translated versions of all the chars.
#      the table pointer is remembered from call to call and
#      the table is only built when the arguments change.
#
#      we also perform an optimization gleaned from spitbol 370.
#      if the second argument is &alphabet, there is no need to
#      to build a replace table.  the third argument can be
#      used directly as the replace table.
#
        .balign 2           #entry point} ent
        nop
s_rpl:
        call gtstg          #load third argument as string} jsr gtstg
        .short err_-168-dffnc #} err 168 replace third argument is not a string
        mov  esi,edi        #save third arg ptr} mov xr xl
        call gtstg          #get second argument} jsr gtstg
        .short err_-169-dffnc #} err 169 replace second argument is not a string
#
#      check to see if this is the same table as last time
#
        cmp  edi,dword ptr r_ra2 #jump if 2nd argument different} bne xr r_ra2 srpl1
        jne  short srpl1 # (jump shortened)
        cmp  esi,dword ptr r_ra3 #jump if args same as last time} beq xl r_ra3 srpl4
        je   srpl4
#
#      here we build a new replace table (note wa = 2nd arg len)
#
srpl1:  mov  ebx,dword ptr (4*sclen)[esi] #load 3rd argument length} mov sclen(xl) wb
        cmp  ecx,ebx        #jump if arguments not same length} bne wa wb srpl6
        jne  srpl6
        cmp  edi,dword ptr kvalp #jump if 2nd arg is alphabet string} beq xr kvalp srpl5
        je   srpl5
        or   ebx,ebx        #jump if null 2nd argument} bze wb srpl6
        jz   srpl6
        mov  dword ptr r_ra3,esi #save third arg for next time in} mov xl r_ra3
        mov  dword ptr r_ra2,edi #save second arg for next time in} mov xr r_ra2
        mov  esi,dword ptr kvalp #point to alphabet string} mov kvalp xl
        mov  ecx,dword ptr (4*sclen)[esi] #load alphabet scblk length} mov sclen(xl) wa
        mov  edi,dword ptr r_rpt #point to current table (if any)} mov r_rpt xr
        or   edi,edi        #jump if we already have a table} bnz xr srpl2
        jnz  short srpl2 # (jump shortened)
#
#      here we allocate a new table
#
        call alocs          #allocate new table} jsr alocs
        mov  ecx,edx        #keep scblk length} mov wc wa
        mov  dword ptr r_rpt,edi #save table pointer for next time} mov xr r_rpt
#
#      merge here with pointer to new table block in (xr)
#
srpl2:  add  ecx,3+4*scsi_  #compute length of scblk} ctb wa scsi_
        and  ecx,-4
        shr  ecx,2          #copy to get initial table values} mvw
        rep  movsd
                            #} ejc
        .eject
#
#      replace (continued)
#
#      now we must plug selected entries as required. note that
#      we are short of index registers for the following loop.
#      hence the need to repeatedly re-initialise char ptr xl
#
        mov  esi,dword ptr r_ra2 #point to second argument} mov r_ra2 xl
        xor  edx,edx        #zero char offset} zer wc
        mov  edi,dword ptr r_ra3 #point to 3rd arg} mov r_ra3 xr
        add  edi,cfp_f      #get char ptr for 3rd arg} plc xr
#
#      loop to plug chars
#
srpl3:  mov  esi,dword ptr r_ra2 #point to 2nd arg} mov r_ra2 xl
        lea  esi,[cfp_f+esi+edx] #point to next char} plc xl wc
        inc  edx            #increment offset} icv wc
        movzx ecx,byte ptr [esi] #get next char} lch wa (xl)
        mov  esi,dword ptr r_rpt #point to translate table} mov r_rpt xl
        lea  esi,[cfp_f+esi+ecx] #convert char to offset into table} psc xl wa
        movzx ecx,byte ptr [edi] #get translated char} lch wa (xr)+
        inc  edi
        mov  [esi],cl       #store in table} sch wa (xl)
        dec  ebx            #loop till done} bct wb srpl3
        jnz  srpl3
                            #} ejc
        .eject
#
#      replace (continued)
#
#      here to use r$rpt as replace table.
#
srpl4:  mov  esi,dword ptr r_rpt #replace table to use} mov r_rpt xl
#
#      here to perform translate using table in xl.
#
srpl5:  call gtstg          #get first argument} jsr gtstg
        .short err_-170-dffnc #} err 170 replace first argument is not a string
        or   ecx,ecx        #return null if null argument} bze wa exnul
        jz   exnul
        push esi            #stack replace table to use} mov xl -(xs)
        mov  esi,edi        #copy pointer} mov xr xl
        mov  edx,ecx        #save length} mov wa wc
        add  ecx,3+4*schar  #get scblk length} ctb wa schar
        and  ecx,-4
        call alloc          #allocate space for copy} jsr alloc
        mov  ebx,edi        #save address of copy} mov xr wb
        shr  ecx,2          #move scblk contents to copy} mvw
        rep  movsd
        pop  edi            #unstack replace table} mov (xs)+ xr
        add  edi,cfp_f      #point to chars of table} plc xr
        mov  esi,ebx        #point to string to translate} mov wb xl
        add  esi,cfp_f      #point to chars of string} plc xl
        mov  ecx,edx        #set number of chars to translate} mov wc wa
        xchg esi,edi        #perform translation} trc
l0004:  movzx eax,byte ptr [edi]
        mov  al,[esi+eax]
        stosb
        loop l0004
        xor  esi,esi
        xor  edi,edi
srpl8:  push ebx            #stack result} mov wb -(xs)
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      error point
#
srpl6:  call err_0          #} erb 171 null or unequally long 2nd, 3rd args to replace
        .byte 171
                            #} ejc
        .eject
#
#      rewind
#
        .balign 2           #entry point} ent
        nop
s_rew:
        call iofcb          #call fcblk routine} jsr iofcb
        .short err_-172-dffnc #} err 172 rewind argument is not a suitable name
        .short err_-173-dffnc #} err 173 rewind argument is null
        .short err_-174-dffnc #} err 174 rewind file does not exist
        call sysrw          #call system rewind function} jsr sysrw
        .short err_-174-dffnc #} err 174 rewind file does not exist
        .short err_-175-dffnc #} err 175 rewind file does not permit rewind
        .short err_-176-dffnc #} err 176 rewind caused non-recoverable error
        jmp  exnul          #exit with null result if no error} brn exnul
                            #} ejc
        .eject
#
#      reverse
#
        .balign 2           #entry point} ent
        nop
s_rvs:
        call gtstg          #load string argument} jsr gtstg
        .short err_-177-dffnc #} err 177 reverse argument is not a string
        or   ecx,ecx        #return argument if null} bze wa exixr
        jz   exixr
        mov  esi,edi        #else save pointer to string arg} mov xr xl
        call alocs          #allocate space for new scblk} jsr alocs
        push edi            #store scblk ptr on stack as result} mov xr -(xs)
        add  edi,cfp_f      #prepare to store in new scblk} psc xr
        lea  esi,[cfp_f+esi+edx] #point past last char in argument} plc xl wc
#
#      loop to move chars in reverse order
#
srvs1:  dec  esi            #load next char from argument} lch wb -(xl)
        movzx ebx,byte ptr [esi]
        mov  al,bl          #store in result} sch wb (xr)+
        stosb
        dec  edx            #loop till all moved} bct wc srvs1
        jnz  srvs1
#
#      here when complete to execute next code word
#
srvs4:                      #complete store characters} csc xr
        xor  esi,esi        #clear garbage esi} zer xl
srvs2:  mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      rpad
#
        .balign 2           #entry point} ent
        nop
s_rpd:
        call gtstg          #get pad character} jsr gtstg
        .short err_-178-dffnc #} err 178 rpad third argument is not a string
        add  edi,cfp_f      #point to character (null is blank)} plc xr
        movzx ebx,byte ptr [edi] #load pad character} lch wb (xr)
        call gtsmi          #get pad length} jsr gtsmi
        .short err_-179-dffnc #} err 179 rpad second argument is not integer
        .short srpd3-dffnc  #skip if negative or large} ppm srpd3
#
#      merge to check first arg.
#
srpd1:  call gtstg          #get first argument (string to pad)} jsr gtstg
        .short err_-180-dffnc #} err 180 rpad first argument is not a string
        cmp  ecx,edx        #return 1st arg if too long to pad} bge wa wc exixr
        jae  exixr
        mov  esi,edi        #else move ptr to string to pad} mov xr xl
#
#      now we are ready for the pad
#
#      (xl)                  pointer to string to pad
#      (wb)                  pad character
#      (wc)                  length to pad string to
#
        mov  ecx,edx        #copy length} mov wc wa
        call alocs          #allocate scblk for new string} jsr alocs
        push edi            #save as result} mov xr -(xs)
        mov  ecx,dword ptr (4*sclen)[esi] #load length of argument} mov sclen(xl) wa
        sub  edx,ecx        #calculate number of pad characters} sub wa wc
        add  edi,cfp_f      #point to chars in result string} psc xr
#
#      copy argument string
#
        or   ecx,ecx        #jump if argument is null} bze wa srpd2
        jz   short srpd2 # (jump shortened)
        add  esi,cfp_f      #else point to argument chars} plc xl
        shrd eax,ecx,1      #move characters to result string} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        xor  esi,esi        #clear garbage esi} zer xl
#
#      loop to supply pad characters
#
srpd2:  mov  al,bl          #store pad character, bump ptr} sch wb (xr)+
        stosb
        dec  edx            #loop till all pad chars stored} bct wc srpd2
        jnz  srpd2
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      here if 2nd arg is negative or large
#
srpd3:  xor  edx,edx        #zero pad count} zer wc
        jmp  srpd1          #merge} brn srpd1
                            #} ejc
        .eject
#
#      rtab
#
        .balign 2           #entry point} ent
        nop
s_rtb:
        mov  ebx,offset p_rtb #set pcode for integer arg case} mov =p_rtb wb
        mov  ecx,offset p_rtd #set pcode for expression arg case} mov =p_rtd wa
        call patin          #call common routine to build node} jsr patin
        .short err_-181-dffnc #} err 181 rtab argument is not integer or expression
        .short err_-182-dffnc #} err 182 rtab argument is negative or too large
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      set
#
        .balign 2           #entry point} ent
        nop
s_set:
        pop  dword ptr r_io2 #save third arg (whence)} mov (xs)+ r_io2
        pop  dword ptr r_io1 #save second arg (offset)} mov (xs)+ r_io1
        call iofcb          #call fcblk routine} jsr iofcb
        .short err_-291-dffnc #} err 291 set first argument is not a suitable name
        .short err_-292-dffnc #} err 292 set first argument is null
        .short err_-295-dffnc #} err 295 set file does not exist
        mov  ebx,dword ptr r_io1 #load second arg} mov r_io1 wb
        mov  edx,dword ptr r_io2 #load third arg} mov r_io2 wc
        call sysst          #call system set routine} jsr sysst
        .short err_-293-dffnc #} err 293 inappropriate second argument to set
        .short err_-294-dffnc #} err 294 inappropriate third argument to set
        .short err_-295-dffnc #} err 295 set file does not exist
        .short err_-296-dffnc #} err 296 set file does not permit setting file pointer
        .short err_-297-dffnc #} err 297 set caused non-recoverable i/o error
        jmp  exint          #otherwise return position} brn exint
                            #} ejc
        .eject
#
#      tab
#
        .balign 2           #entry point} ent
        nop
s_tab:
        mov  ebx,offset p_tab #set pcode for integer arg case} mov =p_tab wb
        mov  ecx,offset p_tbd #set pcode for expression arg case} mov =p_tbd wa
        call patin          #call common routine to build node} jsr patin
        .short err_-183-dffnc #} err 183 tab argument is not integer or expression
        .short err_-184-dffnc #} err 184 tab argument is negative or too large
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      rpos
#
        .balign 2           #entry point} ent
        nop
s_rps:
        mov  ebx,offset p_rps #set pcode for integer arg case} mov =p_rps wb
        mov  ecx,offset p_rpd #set pcode for expression arg case} mov =p_rpd wa
        call patin          #call common routine to build node} jsr patin
        .short err_-185-dffnc #} err 185 rpos argument is not integer or expression
        .short err_-186-dffnc #} err 186 rpos argument is negative or too large
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      rsort
#
        .balign 2           #entry point} ent
        nop
s_rsr:
        mov  ecx,esp        #mark as rsort} mnz wa
        call sorta          #call sort routine} jsr sorta
        .short exfal-dffnc  #if conversion fails, so shall we} ppm exfal
        jmp  exsid          #return, setting idval} brn exsid
                            #} ejc
        .eject
#
#      setexit
#
        .balign 2           #entry point} ent
        nop
s_stx:
        pop  edi            #load argument} mov (xs)+ xr
        mov  ecx,dword ptr stxvr #load old vrblk pointer} mov stxvr wa
        xor  esi,esi        #load zero in case null arg} zer xl
        cmp  edi,offset nulls #jump if null argument (reset call)} beq xr =nulls sstx1
        je   short sstx1 # (jump shortened)
        call gtnvr          #else get specified vrblk} jsr gtnvr
        .short sstx2-dffnc  #jump if not natural variable} ppm sstx2
        mov  esi,dword ptr (4*vrlbl)[edi] #else load label} mov vrlbl(xr) xl
        cmp  esi,offset stndl #jump if label is not defined} beq xl =stndl sstx2
        je   short sstx2 # (jump shortened)
        cmp  dword ptr [esi],offset b_trt #jump if not trapped} bne (xl) =b_trt sstx1
        jne  short sstx1 # (jump shortened)
        mov  esi,dword ptr (4*trlbl)[esi] #else load ptr to real label code} mov trlbl(xl) xl
#
#      here to set/reset setexit trap
#
sstx1:  mov  dword ptr stxvr,edi #store new vrblk pointer (or null)} mov xr stxvr
        mov  dword ptr r_sxc,esi #store new code ptr (or zero)} mov xl r_sxc
        cmp  ecx,offset nulls #return null if null result} beq wa =nulls exnul
        je   exnul
        mov  edi,ecx        #else copy vrblk pointer} mov wa xr
        jmp  exvnm          #and return building nmblk} brn exvnm
#
#      here if bad argument
#
sstx2:  call err_0          #} erb 187 setexit argument is not label name or null
        .byte 187
#
#      sin
#
        .balign 2           #entry point} ent
        nop
s_sin:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-308-dffnc #} err 308 sin argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call sin_           #take sine} sin
        call ovr_           #if no overflow, return result in ra} rno exrea
        jno  exrea
        call err_1          #} erb 323 sin argument is out of range
        .byte 67
                            #} ejc
        .eject
#
#      sqrt
#
        .balign 2           #entry point} ent
        nop
s_sqr:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-313-dffnc #} err 313 sqrt argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call cpr_           #negative number} rlt ssqr1
        jl   short ssqr1 # (jump shortened)
        call sqr_           #take square root} sqr
        jmp  exrea          #no overflow possible, result in ra} brn exrea
#
#      here if bad argument
#
ssqr1:  call err_1          #} erb 314 sqrt argument negative
        .byte 58
                            #} ejc
        .eject
                            #} ejc
        .eject
#
#      sort
#
        .balign 2           #entry point} ent
        nop
s_srt:
        xor  ecx,ecx        #mark as sort} zer wa
        call sorta          #call sort routine} jsr sorta
        .short exfal-dffnc  #if conversion fails, so shall we} ppm exfal
        jmp  exsid          #return, setting idval} brn exsid
                            #} ejc
        .eject
#
#      span
#
        .balign 2           #entry point} ent
        nop
s_spn:
        mov  ebx,offset p_sps #set pcode for single char arg} mov =p_sps wb
        mov  esi,offset p_spn #set pcode for multi-char arg} mov =p_spn xl
        mov  edx,offset p_spd #set pcode for expression arg} mov =p_spd wc
        call patst          #call common routine to build node} jsr patst
        .short err_-188-dffnc #} err 188 span argument is not a string or expression
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      size
#
        .balign 2           #entry point} ent
        nop
s_si_:
        call gtstg          #load string argument} jsr gtstg
        .short err_-189-dffnc #} err 189 size argument is not a string
#
#      merge with bfblk or scblk ptr in xr.  wa has length.
#
        mov  edx,ecx        #load length as integer} mti wa
        jmp  exint          #exit with integer result} brn exint
                            #} ejc
        .eject
#
#      stoptr
#
        .balign 2           #entry point} ent
        nop
s_stt:
        xor  esi,esi        #indicate stoptr case} zer xl
        call trace          #call trace procedure} jsr trace
        .short err_-190-dffnc #} err 190 stoptr first argument is not appropriate name
        .short err_-191-dffnc #} err 191 stoptr second argument is not trace type
        jmp  exnul          #return null} brn exnul
                            #} ejc
        .eject
#
#      substr
#
        .balign 2           #entry point} ent
        nop
s_sub:
        call gtsmi          #load third argument} jsr gtsmi
        .short err_-192-dffnc #} err 192 substr third argument is not integer
        .short exfal-dffnc  #jump if negative or too large} ppm exfal
        mov  dword ptr sbssv,edi #save third argument} mov xr sbssv
        call gtsmi          #load second argument} jsr gtsmi
        .short err_-193-dffnc #} err 193 substr second argument is not integer
        .short exfal-dffnc  #jump if out of range} ppm exfal
        mov  edx,edi        #save second argument} mov xr wc
        or   edx,edx        #jump if second argument zero} bze wc exfal
        jz   exfal
        dec  edx            #else decrement for ones origin} dcv wc
        call gtstg          #load first argument} jsr gtstg
        .short err_-194-dffnc #} err 194 substr first argument is not a string
#
#      merge with bfblk or scblk ptr in xr.  wa has length
#
        mov  ebx,edx        #copy second arg to ebx} mov wc wb
        mov  edx,dword ptr sbssv #reload third argument} mov sbssv wc
        or   edx,edx        #skip if third arg given} bnz wc ssub2
        jnz  short ssub2 # (jump shortened)
        mov  edx,ecx        #else get string length} mov wa wc
        cmp  ebx,edx        #fail if improper} bgt wb wc exfal
        ja   exfal
        sub  edx,ebx        #reduce by offset to start} sub wb wc
#
#      merge
#
ssub2:  mov  esi,ecx        #save string length} mov wa xl
        mov  ecx,edx        #set length of substring} mov wc wa
        add  edx,ebx        #add 2nd arg to 3rd arg} add wb wc
        cmp  edx,esi        #jump if improper substring} bgt wc xl exfal
        ja   exfal
        mov  esi,edi        #copy pointer to first arg} mov xr xl
        call sbstr          #build substring} jsr sbstr
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      table
#
        .balign 2           #entry point} ent
        nop
s_tbl:
        pop  esi            #get initial lookup value} mov (xs)+ xl
        add  esp,4          #pop second argument} ica xs
        call gtsmi          #load argument} jsr gtsmi
        .short err_-195-dffnc #} err 195 table argument is not integer
        .short err_-196-dffnc #} err 196 table argument is out of range
        or   edx,edx        #jump if non-zero} bnz wc stbl1
        jnz  short stbl1 # (jump shortened)
        mov  edx,tbnbk      #else supply default value} mov =tbnbk wc
#
#      merge here with number of headers in wc
#
stbl1:  call tmake          #make table} jsr tmake
        jmp  exsid          #exit setting idval} brn exsid
                            #} ejc
        .eject
#
#      tan
#
        .balign 2           #entry point} ent
        nop
s_tan:
        pop  edi            #get argument} mov (xs)+ xr
        call gtrea          #convert to real} jsr gtrea
        .short err_-309-dffnc #} err 309 tan argument not numeric
        lea  eax,dword ptr (4*rcval)[edi] #load accumulator with argument} ldr rcval(xr)
        call ldr_
        call tan_           #take tangent} tan
        call ovr_           #if no overflow, return result in ra} rno exrea
        jno  exrea
        call err_1          #} erb 310 tan produced real overflow or argument is out of range
        .byte 54
                            #} ejc
        .eject
#
#      time
#
        .balign 2           #entry point} ent
        nop
s_tim:
        call systm          #get timer value} jsr systm
        sub  edx,dword ptr timsx #subtract starting time} sbi timsx
        jmp  exint          #exit with integer value} brn exint
                            #} ejc
        .eject
#
#      trace
#
        .balign 2           #entry point} ent
        nop
s_tra:
        cmp  dword ptr (4*num03)[esp],offset nulls #jump if first argument is null} beq num03(xs) =nulls str02
        je   short str02 # (jump shortened)
        pop  edi            #load fourth argument} mov (xs)+ xr
        xor  esi,esi        #tentatively set zero pointer} zer xl
        cmp  edi,offset nulls #jump if 4th argument is null} beq xr =nulls str01
        je   short str01 # (jump shortened)
        call gtnvr          #else point to vrblk} jsr gtnvr
        .short str03-dffnc  #jump if not variable name} ppm str03
        mov  esi,edi        #else save vrblk in trfnc} mov xr xl
#
#      here with vrblk or zero in xl
#
str01:  pop  edi            #load third argument (tag)} mov (xs)+ xr
        xor  ebx,ebx        #set zero as trtyp value for now} zer wb
        call trbld          #build trblk for trace call} jsr trbld
        mov  esi,edi        #move trblk pointer for trace} mov xr xl
        call trace          #call trace procedure} jsr trace
        .short err_-198-dffnc #} err 198 trace first argument is not appropriate name
        .short err_-199-dffnc #} err 199 trace second argument is not trace type
        jmp  exnul          #return null} brn exnul
#
#      here to call system trace toggle routine
#
str02:  call systt          #call it} jsr systt
        add  esp,4*num04    #pop trace arguments} add *num04 xs
        jmp  exnul          #return} brn exnul
#
#      here for bad fourth argument
#
str03:  call err_0          #} erb 197 trace fourth arg is not function name or null
        .byte 197
                            #} ejc
        .eject
#
#      trim
#
        .balign 2           #entry point} ent
        nop
s_trm:
        call gtstg          #load argument as string} jsr gtstg
        .short err_-200-dffnc #} err 200 trim argument is not a string
        or   ecx,ecx        #return null if argument is null} bze wa exnul
        jz   exnul
        mov  esi,edi        #copy string pointer} mov xr xl
        add  ecx,3+4*schar  #get block length} ctb wa schar
        and  ecx,-4
        call alloc          #allocate copy same size} jsr alloc
        mov  ebx,edi        #save pointer to copy} mov xr wb
        shr  ecx,2          #copy old string block to new} mvw
        rep  movsd
        mov  edi,ebx        #restore ptr to new block} mov wb xr
        call trimr          #trim blanks (ebx is non-zero)} jsr trimr
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      unload
#
        .balign 2           #entry point} ent
        nop
s_unl:
        pop  edi            #load argument} mov (xs)+ xr
        call gtnvr          #point to vrblk} jsr gtnvr
        .short err_-201-dffnc #} err 201 unload argument is not natural variable name
        mov  esi,offset stndf #get ptr to undefined function} mov =stndf xl
        call dffnc          #undefine named function} jsr dffnc
        jmp  exnul          #return null as result} brn exnul
                            #} ttl s p i t b o l -- utility routines
        .sbttl "s p i t b o l -- utility routines"
#
#      the following section contains utility routines used for
#      various purposes throughout the system. these differ
#      from the procedures in the utility procedures section in
#      they are not in procedure form and they do not return
#      to their callers. they are accessed with a branch type
#      instruction after setting the registers to appropriate
#      parameter values.
#
#      the register values required for each routine are
#      documented at the start of each routine. registers not
#      mentioned may contain any values except that xr,xl
#      can only contain proper collectable pointers.
#
#      some of these routines will tolerate garbage pointers
#      in xl,xr on entry. this is always documented and in
#      each case, the routine clears these garbage values before
#      exiting after completing its task.
#
#      the routines have names consisting of five letters
#      and are assembled in alphabetical order.
                            #} ejc
        .eject
#      arref -- array reference
#
#      (xl)                  may be non-collectable
#      (xr)                  number of subscripts
#      (wb)                  set zero/nonzero for value/name
#                            the value in wb must be collectable
#      stack                 subscripts and array operand
#      brn  arref            jump to call function
#
#      arref continues by executing the next code word with
#      the result name or value placed on top of the stack.
#      to deal with the problem of accessing subscripts in the
#      order of stacking, xl is used as a subscript pointer
#      working below the stack pointer.
#
arref:                      #} rtn
        .global arref
        mov  ecx,edi        #copy number of subscripts} mov xr wa
        mov  esi,esp        #point to stack front} mov xs xt
        sal  edi,2          #convert to byte offset} wtb xr
        add  esi,edi        #point to array operand on stack} add xr xt
        add  esi,4          #final value for stack popping} ica xt
        mov  dword ptr arfxs,esi #keep for later} mov xt arfxs
        lea  esi,[esi-4]    #load array operand pointer} mov -(xt) xr
        mov  edi,dword ptr [esi]
        mov  dword ptr r_arf,edi #keep array pointer} mov xr r_arf
        mov  edi,esi        #save pointer to subscripts} mov xt xr
        mov  esi,dword ptr r_arf #point esi to possible vcblk or tbblk} mov r_arf xl
        mov  edx,dword ptr [esi] #load first word} mov (xl) wc
        cmp  edx,offset b_art #jump if arblk} beq wc =b_art arf01
        je   short arf01 # (jump shortened)
        cmp  edx,offset b_vct #jump if vcblk} beq wc =b_vct arf07
        je   arf07
        cmp  edx,offset b_tbt #jump if tbblk} beq wc =b_tbt arf10
        je   arf10
        call err_0          #} erb 235 subscripted operand is not table or array
        .byte 235
#
#      here for array (arblk)
#
arf01:  cmp  ecx,dword ptr (4*arndm)[esi] #jump if wrong number of dims} bne wa arndm(xl) arf09
        jne  arf09
        mov  edx,dword ptr intv0 #get initial subscript of zero} ldi intv0
        mov  esi,edi        #point before subscripts} mov xr xt
        xor  ecx,ecx        #initial offset to bounds} zer wa
        jmp  short arf03          #jump into loop} brn arf03 # (jump shortened)
#
#      loop to compute subscripts by multiplications
#
arf02:  imul edx,dword ptr (4*ardm2)[edi] #multiply total by next dimension} mli ardm2(xr)
#
#      merge here first time
#
arf03:  lea  esi,[esi-4]    #load next subscript} mov -(xt) xr
        mov  edi,dword ptr [esi]
        mov  dword ptr arfsi,edx #save current subscript} sti arfsi
        mov  edx,dword ptr (4*icval)[edi] #load integer value in case} ldi icval(xr)
        cmp  dword ptr [edi],offset b_icl #jump if it was an integer} beq (xr) =b_icl arf04
        je   short arf04 # (jump shortened)
                            #} ejc
        .eject
#
#      arref (continued)
#
#
        call gtint          #convert to integer} jsr gtint
        .short arf12-dffnc  #jump if not integer} ppm arf12
        mov  edx,dword ptr (4*icval)[edi] #if ok, load integer value} ldi icval(xr)
#
#      here with integer subscript in (ia)
#
arf04:  mov  edi,dword ptr r_arf #point to array} mov r_arf xr
        add  edi,ecx        #offset to next bounds} add wa xr
        sub  edx,dword ptr (4*arlbd)[edi] #subtract low bound to compare} sbi arlbd(xr)
        jo   arf13          #out of range fail if overflow} iov arf13
        or   edx,edx        #out of range fail if too small} ilt arf13
        jl   arf13
        sub  edx,dword ptr (4*ardim)[edi] #subtract dimension} sbi ardim(xr)
#        or   edx,edx        #out of range fail if too large} ige arf13   (optimized)
        jge  arf13
        add  edx,dword ptr (4*ardim)[edi] #else restore subscript offset} adi ardim(xr)
        add  edx,dword ptr arfsi #add to current total} adi arfsi
        add  ecx,4*ardms    #point to next bounds} add *ardms wa
        cmp  esi,esp        #loop back if more to go} bne xt xs arf02
        jne  arf02
#
#      here with integer subscript computed
#
        mov  ecx,edx        #get as one word integer} mfi wa
        sal  ecx,2          #convert to offset} wtb wa
        mov  esi,dword ptr r_arf #point to arblk} mov r_arf xl
        add  ecx,dword ptr (4*arofs)[esi] #add offset past bounds} add arofs(xl) wa
        add  ecx,4          #adjust for arpro field} ica wa
        or   ebx,ebx        #exit with name if name call} bnz wb arf08
        jnz  arf08
#
#      merge here to get value for value call
#
arf05:  call acess          #get value} jsr acess
        .short arf13-dffnc  #fail if acess fails} ppm arf13
#
#      return value
#
arf06:  mov  esp,dword ptr arfxs #pop stack entries} mov arfxs xs
        xor  eax,eax        #finished with array pointer} zer r_arf
        mov  dword ptr r_arf,eax
        push edi            #stack result} mov xr -(xs)
        mov  edi,[ebp]      #get next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      arref (continued)
#
#      here for vector
#
arf07:  cmp  ecx,num01      #error if more than 1 subscript} bne wa =num01 arf09
        jne  short arf09 # (jump shortened)
        mov  edi,dword ptr [esp] #else load subscript} mov (xs) xr
        call gtint          #convert to integer} jsr gtint
        .short arf12-dffnc  #error if not integer} ppm arf12
        mov  edx,dword ptr (4*icval)[edi] #else load integer value} ldi icval(xr)
        sub  edx,dword ptr intv1 #subtract for ones offset} sbi intv1
#        or   edx,edx        #get subscript as one word} mfi wa arf13  (optimized)
        js   arf13
        mov  ecx,edx
        add  ecx,vcvls      #add offset for standard fields} add =vcvls wa
        sal  ecx,2          #convert offset to bytes} wtb wa
        cmp  ecx,dword ptr (4*vclen)[esi] #fail if out of range subscript} bge wa vclen(xl) arf13
        jae  arf13
        or   ebx,ebx        #back to get value if value call} bze wb arf05
        jz   arf05
#
#      return name
#
arf08:  mov  esp,dword ptr arfxs #pop stack entries} mov arfxs xs
        xor  eax,eax        #finished with array pointer} zer r_arf
        mov  dword ptr r_arf,eax
        jmp  exnam          #else exit with name} brn exnam
#
#      here if subscript count is wrong
#
arf09:  call err_0          #} erb 236 array referenced with wrong number of subscripts
        .byte 236
#
#      table
#
arf10:  cmp  ecx,num01      #error if more than 1 subscript} bne wa =num01 arf11
        jne  short arf11 # (jump shortened)
        mov  edi,dword ptr [esp] #else load subscript} mov (xs) xr
        call tfind          #call table search routine} jsr tfind
        .short arf13-dffnc  #fail if failed} ppm arf13
        or   ebx,ebx        #exit with name if name call} bnz wb arf08
        jnz  arf08
        jmp  arf06          #else exit with value} brn arf06
#
#      here for bad table reference
#
arf11:  call err_0          #} erb 237 table referenced with more than one subscript
        .byte 237
#
#      here for bad subscript
#
arf12:  call err_0          #} erb 238 array subscript is not integer
        .byte 238
#
#      here to signal failure
#
arf13:  xor  eax,eax        #finished with array pointer} zer r_arf
        mov  dword ptr r_arf,eax
        jmp  exfal          #fail} brn exfal
                            #} ejc
        .eject
#
#      cfunc -- call a function
#
#      cfunc is used to call a snobol level function. it is
#      used by the apply function (s$app), the function
#      trace routine (trxeq) and the main function call entry
#      (o$fnc, o$fns). in the latter cases, cfunc is used only
#      if the number of arguments is incorrect.
#
#      (xl)                  pointer to function block
#      (wa)                  actual number of arguments
#      (xs)                  points to stacked arguments
#      brn  cfunc            jump to call function
#
#      cfunc continues by executing the function
#
cfunc:                      #} rtn
        .global cfunc
        cmp  ecx,dword ptr (4*fargs)[esi] #jump if too few arguments} blt wa fargs(xl) cfnc1
        jb   short cfnc1 # (jump shortened)
        cmp  ecx,dword ptr (4*fargs)[esi] #jump if correct number of args} beq wa fargs(xl) cfnc3
        je   short cfnc3 # (jump shortened)
#
#      here if too many arguments supplied, pop them off
#
        mov  ebx,ecx        #copy actual number} mov wa wb
        sub  ebx,dword ptr (4*fargs)[esi] #get number of extra args} sub fargs(xl) wb
        sal  ebx,2          #convert to bytes} wtb wb
        add  esp,ebx        #pop off unwanted arguments} add wb xs
        jmp  short cfnc3          #jump to go off to function} brn cfnc3 # (jump shortened)
#
#      here if too few arguments
#
cfnc1:  mov  ebx,dword ptr (4*fargs)[esi] #load required number of arguments} mov fargs(xl) wb
        cmp  ebx,nini9      #jump if case of var num of args} beq wb =nini9 cfnc3
        je   short cfnc3 # (jump shortened)
        sub  ebx,ecx        #calculate number missing} sub wa wb
#
#      loop to supply extra null arguments
#
cfnc2:  push offset nulls   #stack a null argument} mov =nulls -(xs)
        dec  ebx            #loop till proper number stacked} bct wb cfnc2
        jnz  cfnc2
#
#      merge here to jump to function
#
cfnc3:  jmp  dword ptr [esi] #jump through fcode field} bri (xl)
                            #} ejc
        .eject
#
#      exfal -- exit signalling snobol failure
#
#      (xl,xr)               may be non-collectable
#      brn  exfal            jump to fail
#
#      exfal continues by executing the appropriate fail goto
#
exfal:                      #} rtn
        .global exfal
        mov  esp,dword ptr flptr #pop stack} mov flptr xs
        mov  edi,dword ptr [esp] #load failure offset} mov (xs) xr
        add  edi,dword ptr r_cod #point to failure code location} add r_cod xr
        mov  ebp,edi        #set code pointer} lcp xr
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        mov  esi,dword ptr [edi] #load entry address} mov (xr) xl
        jmp  esi            #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      exint -- exit with integer result
#
#      (xl,xr)               may be non-collectable
#      (ia)                  integer value
#      brn  exint            jump to exit with integer
#
#      exint continues by executing the next code word
#      which it does by falling through to exixr
#
exint:                      #} rtn
        .global exint
        xor  esi,esi        #clear dud value} zer xl
        call icbld          #build icblk} jsr icbld
                            #} ejc
        .eject
#      exixr -- exit with result in (xr)
#
#      (xr)                  result
#      (xl)                  may be non-collectable
#      brn  exixr            jump to exit with result in (xr)
#
#      exixr continues by executing the next code word
#      which it does by falling through to exits.
exixr:                      #} rtn
        .global exixr
#
        push edi            #stack result} mov xr -(xs)
#
#
#      exits -- exit with result if any stacked
#
#      (xr,xl)               may be non-collectable
#
#      brn  exits            enter exits routine
#
exits:                      #} rtn
        .global exits
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        mov  esi,dword ptr [edi] #load entry address} mov (xr) xl
        jmp  esi            #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      exnam -- exit with name in (xl,wa)
#
#      (xl)                  name base
#      (wa)                  name offset
#      (xr)                  may be non-collectable
#      brn  exnam            jump to exit with name in (xl,wa)
#
#      exnam continues by executing the next code word
#
exnam:                      #} rtn
        .global exnam
        push esi            #stack name base} mov xl -(xs)
        push ecx            #stack name offset} mov wa -(xs)
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      exnul -- exit with null result
#
#      (xl,xr)               may be non-collectable
#      brn  exnul            jump to exit with null value
#
#      exnul continues by executing the next code word
#
exnul:                      #} rtn
        .global exnul
        push offset nulls   #stack null value} mov =nulls -(xs)
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        mov  esi,dword ptr [edi] #load entry address} mov (xr) xl
        jmp  esi            #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      exrea -- exit with real result
#
#      (xl,xr)               may be non-collectable
#      (ra)                  real value
#      brn  exrea            jump to exit with real value
#
#      exrea continues by executing the next code word
#
exrea:                      #} rtn
        .global exrea
        xor  esi,esi        #clear dud value} zer xl
        call rcbld          #build rcblk} jsr rcbld
        jmp  exixr          #jump to exit with result in edi} brn exixr
                            #} ejc
        .eject
#
#      exsid -- exit setting id field
#
#      exsid is used to exit after building any of the following
#      blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.
#
#      (xr)                  ptr to block with idval field
#      (xl)                  may be non-collectable
#      brn  exsid            jump to exit after setting id field
#
#      exsid continues by executing the next code word
#
exsid:                      #} rtn
        .global exsid
        mov  ecx,dword ptr curid #load current id value} mov curid wa
        cmp  ecx,cfp_m      #jump if no overflow} bne wa =cfp_m exsi1
        jne  short exsi1 # (jump shortened)
        xor  ecx,ecx        #else reset for wraparound} zer wa
#
#      here with old idval in wa
#
exsi1:  inc  ecx            #bump id value} icv wa
        mov  dword ptr curid,ecx #store for next time} mov wa curid
        mov  dword ptr (4*idval)[edi],ecx #store id value} mov wa idval(xr)
        jmp  exixr          #exit with result in (edi)} brn exixr
                            #} ejc
        .eject
#
#      exvnm -- exit with name of variable
#
#      exvnm exits after stacking a value which is a nmblk
#      referencing the name of a given natural variable.
#
#      (xr)                  vrblk pointer
#      (xl)                  may be non-collectable
#      brn  exvnm            exit with vrblk pointer in xr
#
exvnm:                      #} rtn
        .global exvnm
        mov  esi,edi        #copy name base pointer} mov xr xl
        mov  ecx,4*nmsi_    #set size of nmblk} mov *nmsi_ wa
        call alloc          #allocate nmblk} jsr alloc
        mov  dword ptr [edi],offset b_nml #store type word} mov =b_nml (xr)
        mov  dword ptr (4*nmbas)[edi],esi #store name base} mov xl nmbas(xr)
        mov  dword ptr (4*nmofs)[edi],4*vrval #store name offset} mov *vrval nmofs(xr)
        jmp  exixr          #exit with result in edi} brn exixr
                            #} ejc
        .eject
#
#      flpop -- fail and pop in pattern matching
#
#      flpop pops the node and cursor on the stack and then
#      drops through into failp to cause pattern failure
#
#      (xl,xr)               may be non-collectable
#      brn  flpop            jump to fail and pop stack
#
flpop:                      #} rtn
        .global flpop
        add  esp,4*num02    #pop two entries off stack} add *num02 xs
                            #} ejc
        .eject
#
#      failp -- failure in matching pattern node
#
#      failp is used after failing to match a pattern node.
#      see pattern match routines for details of use.
#
#      (xl,xr)               may be non-collectable
#      brn  failp            signal failure to match
#
#      failp continues by matching an alternative from the stack
#
failp:                      #} rtn
        .global failp
        pop  edi            #load alternative node pointer} mov (xs)+ xr
        pop  ebx            #restore old cursor} mov (xs)+ wb
        mov  esi,dword ptr [edi] #load pcode entry pointer} mov (xr) xl
        jmp  esi            #jump to execute code for node} bri xl
                            #} ejc
        .eject
#
#      indir -- compute indirect reference
#
#      (wb)                  nonzero/zero for by name/value
#      brn  indir            jump to get indirect ref on stack
#
#      indir continues by executing the next code word
#
indir:                      #} rtn
        .global indir
        pop  edi            #load argument} mov (xs)+ xr
        cmp  dword ptr [edi],offset b_nml #jump if a name} beq (xr) =b_nml indr2
        je   short indr2 # (jump shortened)
        call gtnvr          #else convert to variable} jsr gtnvr
        .short err_-239-dffnc #} err 239 indirection operand is not name
        or   ebx,ebx        #skip if by value} bze wb indr1
        jz   short indr1 # (jump shortened)
        push edi            #else stack vrblk ptr} mov xr -(xs)
        push 4*vrval        #stack name offset} mov *vrval -(xs)
        mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        mov  esi,dword ptr [edi] #load entry address} mov (xr) xl
        jmp  esi            #jump to execute next code word} bri xl
#
#      here to get value of natural variable
#
indr1:  jmp  dword ptr [edi] #jump through vrget field of vrblk} bri (xr)
#
#      here if operand is a name
#
indr2:  mov  esi,dword ptr (4*nmbas)[edi] #load name base} mov nmbas(xr) xl
        mov  ecx,dword ptr (4*nmofs)[edi] #load name offset} mov nmofs(xr) wa
        or   ebx,ebx        #exit if called by name} bnz wb exnam
        jnz  exnam
        call acess          #else get value first} jsr acess
        .short exfal-dffnc  #fail if access fails} ppm exfal
        jmp  exixr          #else return with value in edi} brn exixr
                            #} ejc
        .eject
#
#      match -- initiate pattern match
#
#      (wb)                  match type code
#      brn  match            jump to initiate pattern match
#
#      match continues by executing the pattern match. see
#      pattern match routines (p$xxx) for full details.
#
match:                      #} rtn
        .global match
        pop  edi            #load pattern operand} mov (xs)+ xr
        call gtpat          #convert to pattern} jsr gtpat
        .short err_-240-dffnc #} err 240 pattern match right operand is not pattern
        mov  esi,edi        #if ok, save pattern pointer} mov xr xl
        or   ebx,ebx        #jump if not match by name} bnz wb mtch1
        jnz  short mtch1 # (jump shortened)
        mov  ecx,dword ptr [esp] #else load name offset} mov (xs) wa
        push esi            #save pattern pointer} mov xl -(xs)
        mov  esi,dword ptr (4*num02)[esp] #load name base} mov num02(xs) xl
        call acess          #access subject value} jsr acess
        .short exfal-dffnc  #fail if access fails} ppm exfal
        mov  esi,dword ptr [esp] #restore pattern pointer} mov (xs) xl
        mov  dword ptr [esp],edi #stack subject string val for merge} mov xr (xs)
        xor  ebx,ebx        #restore type code} zer wb
#
#      merge here with subject value on stack
#
mtch1:  call gtstg          #convert subject to string} jsr gtstg
        .short err_-241-dffnc #} err 241 pattern match left operand is not a string
        push ebx            #stack match type code} mov wb -(xs)
        mov  dword ptr r_pms,edi #if ok, store subject string pointer} mov xr r_pms
        mov  dword ptr pmssl,ecx #and length} mov wa pmssl
        push 0              #stack initial cursor (zero)} zer -(xs)
        xor  ebx,ebx        #set initial cursor} zer wb
        mov  dword ptr pmhbs,esp #set history stack base ptr} mov xs pmhbs
        xor  eax,eax        #reset pattern assignment flag} zer pmdfl
        mov  dword ptr pmdfl,eax
        mov  edi,esi        #set initial node pointer} mov xl xr
        cmp  dword ptr dword ptr kvanc,0 #jump if anchored} bnz kvanc mtch2
        jnz  short mtch2 # (jump shortened)
#
#      here for unanchored
#
        push edi            #stack initial node pointer} mov xr -(xs)
        push offset nduna   #stack pointer to anchor move node} mov =nduna -(xs)
        jmp  dword ptr [edi] #start match of first node} bri (xr)
#
#      here in anchored mode
#
mtch2:  push 0              #dummy cursor value} zer -(xs)
        push offset ndabo   #stack pointer to abort node} mov =ndabo -(xs)
        jmp  dword ptr [edi] #start match of first node} bri (xr)
                            #} ejc
        .eject
#
#      retrn -- return from function
#
#      (wa)                  string pointer for return type
#      brn  retrn            jump to return from (snobol) func
#
#      retrn continues by executing the code at the return point
#      the stack is cleaned of any garbage left by other
#      routines which may have altered flptr since function
#      entry by using flprt, reserved for use only by
#      function call and return.
#
retrn:                      #} rtn
        .global retrn
        cmp  dword ptr dword ptr kvfnc,0 #jump if not level zero} bnz kvfnc rtn01
        jnz  short rtn01 # (jump shortened)
        call err_0          #} erb 242 function return from level zero
        .byte 242
#
#      here if not level zero return
#
rtn01:  mov  esp,dword ptr flprt #pop stack} mov flprt xs
        add  esp,4          #remove failure offset} ica xs
        pop  edi            #pop pfblk pointer} mov (xs)+ xr
        pop  dword ptr flptr #pop failure pointer} mov (xs)+ flptr
        pop  dword ptr flprt #pop old flprt} mov (xs)+ flprt
        pop  ebx            #pop code pointer offset} mov (xs)+ wb
        pop  edx            #pop old code block pointer} mov (xs)+ wc
        add  ebx,edx        #make old code pointer absolute} add wc wb
        mov  ebp,ebx        #restore old code pointer} lcp wb
        mov  dword ptr r_cod,edx #restore old code block pointer} mov wc r_cod
        dec  dword ptr kvfnc #decrement function level} dcv kvfnc
        mov  ebx,dword ptr kvtra #load trace} mov kvtra wb
        add  ebx,dword ptr kvftr #add ftrace} add kvftr wb
#        or   ebx,ebx        #jump if no tracing possible} bze wb rtn06  (optimized)
        jz   rtn06
#
#      here if there may be a trace
#
        push ecx            #save function return type} mov wa -(xs)
        push edi            #save pfblk pointer} mov xr -(xs)
        mov  dword ptr kvrtn,ecx #set rtntype for trace function} mov wa kvrtn
        mov  esi,dword ptr r_fnc #load fnclevel trblk ptr (if any)} mov r_fnc xl
        call ktrex          #execute possible fnclevel trace} jsr ktrex
        mov  esi,dword ptr (4*pfvbl)[edi] #load vrblk ptr (sgd13)} mov pfvbl(xr) xl
        cmp  dword ptr dword ptr kvtra,0 #jump if trace is off} bze kvtra rtn02
        jz   short rtn02 # (jump shortened)
        mov  edi,dword ptr (4*pfrtr)[edi] #else load return trace trblk ptr} mov pfrtr(xr) xr
        or   edi,edi        #jump if not return traced} bze xr rtn02
        jz   short rtn02 # (jump shortened)
        dec  dword ptr kvtra #else decrement trace count} dcv kvtra
        cmp  dword ptr dword ptr (4*trfnc)[edi],0 #jump if print trace} bze trfnc(xr) rtn03
        jz   short rtn03 # (jump shortened)
        mov  ecx,4*vrval    #else set name offset} mov *vrval wa
        mov  eax,dword ptr (4*num01)[esp] #make sure rtntype is set right} mov num01(xs) kvrtn
        mov  dword ptr kvrtn,eax
        call trxeq          #execute full trace} jsr trxeq
                            #} ejc
        .eject
#
#      retrn (continued)
#
#      here to test for ftrace
#
rtn02:  cmp  dword ptr dword ptr kvftr,0 #jump if ftrace is off} bze kvftr rtn05
        jz   rtn05
        dec  dword ptr kvftr #else decrement ftrace} dcv kvftr
#
#      here for print trace of function return
#
rtn03:  call prtsn          #print statement number} jsr prtsn
        mov  edi,dword ptr (4*num01)[esp] #load return type} mov num01(xs) xr
        call prtst          #print it} jsr prtst
        mov  ecx,ch_bl      #load blank} mov =ch_bl wa
        call prtch          #print it} jsr prtch
        mov  esi,dword ptr (4*0)[esp] #load pfblk ptr} mov 0(xs) xl
        mov  esi,dword ptr (4*pfvbl)[esi] #load function vrblk ptr} mov pfvbl(xl) xl
        mov  ecx,4*vrval    #set vrblk name offset} mov *vrval wa
        cmp  edi,offset scfrt #jump if not freturn case} bne xr =scfrt rtn04
        jne  short rtn04 # (jump shortened)
#
#      for freturn, just print function name
#
        call prtnm          #print name} jsr prtnm
        call prtnl          #terminate print line} jsr prtnl
        jmp  short rtn05          #merge} brn rtn05 # (jump shortened)
#
#      here for return or nreturn, print function name = value
#
rtn04:  call prtnv          #print name = value} jsr prtnv
#
#      here after completing trace
#
rtn05:  pop  edi            #pop pfblk pointer} mov (xs)+ xr
        pop  ecx            #pop return type string} mov (xs)+ wa
#
#      merge here if no trace required
#
rtn06:  mov  dword ptr kvrtn,ecx #set rtntype keyword} mov wa kvrtn
        mov  esi,dword ptr (4*pfvbl)[edi] #load pointer to fn vrblk} mov pfvbl(xr) xl
                            #} ejc
        .eject
#      retrn (continued)
#
#      get value of function
#
rtn07:  mov  dword ptr rtnbp,esi #save block pointer} mov xl rtnbp
        mov  esi,dword ptr (4*vrval)[esi] #load value} mov vrval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop back if trapped} beq (xl) =b_trt rtn07
        je   rtn07
        mov  dword ptr rtnfv,esi #else save function result value} mov xl rtnfv
        pop  dword ptr rtnsv #save original function value} mov (xs)+ rtnsv
        pop  esi            #pop saved pointer} mov (xs)+ xl
        or   esi,esi        #no action if none} bze xl rtn7c
        jz   short rtn7c # (jump shortened)
        cmp  dword ptr dword ptr kvpfl,0 #jump if no profiling} bze kvpfl rtn7c
        jz   short rtn7c # (jump shortened)
        call prflu          #else profile last func stmt} jsr prflu
        cmp  dword ptr kvpfl,num02 #branch on value of profile keywd} beq kvpfl =num02 rtn7a
        je   short rtn7a # (jump shortened)
#
#      here if &profile = 1. start time must be frigged to
#      appear earlier than it actually is, by amount used before
#      the call.
#
        mov  edx,dword ptr pfstm #load current time} ldi pfstm
        sub  edx,dword ptr (4*icval)[esi] #frig by subtracting saved amount} sbi icval(xl)
        jmp  short rtn7b          #and merge} brn rtn7b # (jump shortened)
#
#      here if &profile = 2
#
rtn7a:  mov  edx,dword ptr (4*icval)[esi] #load saved time} ldi icval(xl)
#
#      both profile types merge here
#
rtn7b:  mov  dword ptr pfstm,edx #store back correct start time} sti pfstm
#
#      merge here if no profiling
#
rtn7c:  mov  ebx,dword ptr (4*fargs)[edi] #get number of args} mov fargs(xr) wb
        add  ebx,dword ptr (4*pfnlo)[edi] #add number of locals} add pfnlo(xr) wb
#        or   ebx,ebx        #jump if no args/locals} bze wb rtn10  (optimized)
        jz   short rtn10 # (jump shortened)
        add  edi,dword ptr (4*pflen)[edi] #and point to end of pfblk} add pflen(xr) xr
#
#      loop to restore functions and locals
#
rtn08:  lea  edi,[edi-4]    #load next vrblk pointer} mov -(xr) xl
        mov  esi,dword ptr [edi]
#
#      loop to find value block
#
rtn09:  mov  ecx,esi        #save block pointer} mov xl wa
        mov  esi,dword ptr (4*vrval)[esi] #load pointer to next value} mov vrval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop back if trapped} beq (xl) =b_trt rtn09
        je   rtn09
        mov  esi,ecx        #else restore last block pointer} mov wa xl
        pop  dword ptr (4*vrval)[esi] #restore old variable value} mov (xs)+ vrval(xl)
        dec  ebx            #loop till all processed} bct wb rtn08
        jnz  rtn08
#
#      now restore function value and exit
#
rtn10:  mov  esi,dword ptr rtnbp #restore ptr to last function block} mov rtnbp xl
        mov  eax,dword ptr rtnsv #restore old function value} mov rtnsv vrval(xl)
        mov  dword ptr (4*vrval)[esi],eax
        mov  edi,dword ptr rtnfv #reload function result} mov rtnfv xr
        mov  esi,dword ptr r_cod #point to new code block} mov r_cod xl
        mov  eax,dword ptr kvstn #set lastno from stno} mov kvstn kvlst
        mov  dword ptr kvlst,eax
        mov  eax,dword ptr (4*cdstm)[esi] #reset proper stno value} mov cdstm(xl) kvstn
        mov  dword ptr kvstn,eax
        mov  eax,dword ptr kvlin #set lastline from line} mov kvlin kvlln
        mov  dword ptr kvlln,eax
        mov  eax,dword ptr (4*cdsln)[esi] #reset proper line value} mov cdsln(xl) kvlin
        mov  dword ptr kvlin,eax
        mov  ecx,dword ptr kvrtn #load return type} mov kvrtn wa
        cmp  ecx,offset scrtn #exit with result in edi if return} beq wa =scrtn exixr
        je   exixr
        cmp  ecx,offset scfrt #fail if freturn} beq wa =scfrt exfal
        je   exfal
                            #} ejc
        .eject
#
#      retrn (continued)
#
#      here for nreturn
#
        cmp  dword ptr [edi],offset b_nml #jump if is a name} beq (xr) =b_nml rtn11
        je   short rtn11 # (jump shortened)
        call gtnvr          #else try convert to variable name} jsr gtnvr
        .short err_-243-dffnc #} err 243 function result in nreturn is not name
        mov  esi,edi        #if ok, copy vrblk (name base) ptr} mov xr xl
        mov  ecx,4*vrval    #set name offset} mov *vrval wa
        jmp  short rtn12          #and merge} brn rtn12 # (jump shortened)
#
#      here if returned result is a name
#
rtn11:  mov  esi,dword ptr (4*nmbas)[edi] #load name base} mov nmbas(xr) xl
        mov  ecx,dword ptr (4*nmofs)[edi] #load name offset} mov nmofs(xr) wa
#
#      merge here with returned name in (xl,wa)
#
rtn12:  mov  edi,esi        #preserve esi} mov xl xr
        mov  ebx,[ebp]      #load next word} lcw wb
        add  ebp,4
        mov  esi,edi        #restore esi} mov xr xl
        cmp  ebx,offset ofne_ #exit if called by name} beq wb =ofne_ exnam
        je   exnam
        push ebx            #else save code word} mov wb -(xs)
        call acess          #get value} jsr acess
        .short exfal-dffnc  #fail if access fails} ppm exfal
        mov  esi,edi        #if ok, copy result} mov xr xl
        mov  edi,dword ptr [esp] #reload next code word} mov (xs) xr
        mov  dword ptr [esp],esi #store result on stack} mov xl (xs)
        mov  esi,dword ptr [edi] #load routine address} mov (xr) xl
        jmp  esi            #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      stcov -- signal statement counter overflow
#
#      brn  stcov            jump to signal statement count oflo
#
#      permit up to 10 more statements to be obeyed so that
#      setexit trap can regain control.
#      stcov continues by issuing the error message
#
stcov:                      #} rtn
        .global stcov
        inc  dword ptr errft #fatal error} icv errft
        mov  edx,dword ptr intvt #get 10} ldi intvt
        add  edx,dword ptr kvstl #add to former limit} adi kvstl
        mov  dword ptr kvstl,edx #store as new stlimit} sti kvstl
        mov  edx,dword ptr intvt #get 10} ldi intvt
        mov  dword ptr kvstc,edx #set as new count} sti kvstc
        call stgcc          #recompute countdown counters} jsr stgcc
        call err_0          #} erb 244 statement count exceeds value of stlimit keyword
        .byte 244
                            #} ejc
        .eject
#
#      stmgo -- start execution of new statement
#
#      (xr)                  pointer to cdblk for new statement
#      brn  stmgo            jump to execute new statement
#
#      stmgo continues by executing the next statement
#
stmgo:                      #} rtn
        .global stmgo
        mov  dword ptr r_cod,edi #set new code block pointer} mov xr r_cod
        dec  dword ptr stmct #see if time to check something} dcv stmct
        cmp  dword ptr dword ptr stmct,0 #jump if so} bze stmct stgo2
        jz   short stgo2 # (jump shortened)
        mov  eax,dword ptr kvstn #set lastno} mov kvstn kvlst
        mov  dword ptr kvlst,eax
        mov  eax,dword ptr (4*cdstm)[edi] #set stno} mov cdstm(xr) kvstn
        mov  dword ptr kvstn,eax
        mov  eax,dword ptr kvlin #set lastline} mov kvlin kvlln
        mov  dword ptr kvlln,eax
        mov  eax,dword ptr (4*cdsln)[edi] #set line} mov cdsln(xr) kvlin
        mov  dword ptr kvlin,eax
        add  edi,4*cdcod    #point to first code word} add *cdcod xr
        mov  ebp,edi        #set code pointer} lcp xr
#
#      here to execute first code word of statement
#
stgo1:  mov  edi,[ebp]      #load next code word} lcw xr
        add  ebp,4
        xor  esi,esi        #clear garbage esi} zer xl
        jmp  dword ptr [edi] #execute it} bri (xr)
#
#      check profiling, polling, stlimit, statement tracing
#
stgo2:  cmp  dword ptr dword ptr kvpfl,0 #skip if no profiling} bze kvpfl stgo3
        jz   short stgo3 # (jump shortened)
        call prflu          #else profile the statement in kvstn} jsr prflu
#
#      here when finished with profiling
#
stgo3:  mov  eax,dword ptr kvstn #set lastno} mov kvstn kvlst
        mov  dword ptr kvlst,eax
        mov  eax,dword ptr (4*cdstm)[edi] #set stno} mov cdstm(xr) kvstn
        mov  dword ptr kvstn,eax
        mov  eax,dword ptr kvlin #set lastline} mov kvlin kvlln
        mov  dword ptr kvlln,eax
        mov  eax,dword ptr (4*cdsln)[edi] #set line} mov cdsln(xr) kvlin
        mov  dword ptr kvlin,eax
        add  edi,4*cdcod    #point to first code word} add *cdcod xr
        mov  ebp,edi        #set code pointer} lcp xr
#
#      here to check for polling
#
        push dword ptr stmcs #save present count start on stack} mov stmcs -(xs)
        dec  dword ptr polct #poll interval within stmct} dcv polct
        cmp  dword ptr dword ptr polct,0 #jump if not poll time yet} bnz polct stgo4
        jnz  short stgo4 # (jump shortened)
        xor  ecx,ecx        #=0 for poll} zer wa
        mov  ebx,dword ptr kvstn #statement number} mov kvstn wb
        mov  esi,edi        #make collectable} mov xr xl
        call syspl          #allow interactive access} jsr syspl
        .short err_-320-dffnc #} err 320 user interrupt
        .short err_-299-dffnc #single step} ppm
        .short err_-299-dffnc #expression evaluation} ppm
        mov  edi,esi        #restore code block pointer} mov xl xr
        mov  dword ptr polcs,ecx #poll interval start value} mov wa polcs
        call stgcc          #recompute counter values} jsr stgcc
#
#      check statement limit
#
stgo4:  mov  edx,dword ptr kvstc #get stmt count} ldi kvstc
        or   edx,edx        #omit counting if negative} ilt stgo5
        jl   short stgo5 # (jump shortened)
        pop  edx            #reload start value of counter} mti (xs)+
        neg  edx            #negate} ngi
        add  edx,dword ptr kvstc #stmt count minus counter} adi kvstc
        mov  dword ptr kvstc,edx #replace it} sti kvstc
        or   edx,edx        #fail if stlimit reached} ile stcov
        jle  stcov
        cmp  dword ptr dword ptr r_stc,0 #jump if no statement trace} bze r_stc stgo5
        jz   short stgo5 # (jump shortened)
        xor  edi,edi        #clear garbage value in edi} zer xr
        mov  esi,dword ptr r_stc #load pointer to stcount trblk} mov r_stc xl
        call ktrex          #execute keyword trace} jsr ktrex
#
#      reset stmgo counter
#
stgo5:  mov  eax,dword ptr stmcs #reset counter} mov stmcs stmct
        mov  dword ptr stmct,eax
        jmp  stgo1          #fetch next code word} brn stgo1
                            #} ejc
        .eject
#
#      stopr -- terminate run
#
#      (xr)                  points to ending message
#      brn stopr             jump to terminate run
#
#      terminate run and print statistics.  on entry xr points
#      to ending message or is zero if message  printed already.
#
stopr:                      #} rtn
        .global stopr
        or   edi,edi        #skip if sysax already called} bze xr stpra
        jz   short stpra # (jump shortened)
        call sysax          #call after execution proc} jsr sysax
stpra:  mov  eax,dword ptr rsmem #use the reserve memory} add rsmem dname
        add  dword ptr dname,eax
        cmp  edi,offset endms #skip if not normal end message} bne xr =endms stpr0
        jne  short stpr0 # (jump shortened)
        cmp  dword ptr dword ptr exsts,0 #skip if exec stats suppressed} bnz exsts stpr3
        jnz  stpr3
        xor  eax,eax        #clear errors to int.ch. flag} zer erich
        mov  dword ptr erich,eax
#
#      look to see if an ending message is supplied
#
stpr0:  call prtpg          #eject printer} jsr prtpg
        or   edi,edi        #skip if no message} bze xr stpr1
        jz   short stpr1 # (jump shortened)
        call prtst          #print message} jsr prtst
#
#      merge here if no message to print
#
stpr1:  call prtis          #print blank line} jsr prtis
        cmp  dword ptr dword ptr gbcfl,0 #if in garbage collection, skip} bnz gbcfl stpr5
        jnz  short stpr5 # (jump shortened)
        mov  edi,offset stpm7 #point to message /in file xxx/} mov =stpm7 xr
        call prtst          #print it} jsr prtst
        mov  dword ptr profs,prtmf #set column offset} mov =prtmf profs
        mov  edx,dword ptr kvstn #get statement number} mov kvstn wc
        call filnm          #get file name} jsr filnm
        mov  edi,esi        #prepare to print} mov xl xr
        call prtst          #print file name} jsr prtst
        call prtis          #print to interactive channel} jsr prtis
        mov  edi,dword ptr r_cod #get code pointer} mov r_cod xr
        mov  edx,dword ptr (4*cdsln)[edi] #get source line number} mti cdsln(xr)
        mov  edi,offset stpm6 #point to message /in line xxx/} mov =stpm6 xr
        call prtmx          #print it} jsr prtmx
stpr5:  mov  edx,dword ptr kvstn #get statement number} mti kvstn
        mov  edi,offset stpm1 #point to message /in statement xxx/} mov =stpm1 xr
        call prtmx          #print it} jsr prtmx
        call systm          #get current time} jsr systm
        sub  edx,dword ptr timsx #minus start time = elapsed exec tim} sbi timsx
        mov  dword ptr stpti,edx #save for later} sti stpti
        mov  edi,offset stpm3 #point to msg /execution time msec /} mov =stpm3 xr
        call prtmx          #print it} jsr prtmx
        mov  edx,dword ptr kvstl #get statement limit} ldi kvstl
        or   edx,edx        #skip if negative} ilt stpr2
        jl   short stpr2 # (jump shortened)
        sub  edx,dword ptr kvstc #minus counter = course count} sbi kvstc
        mov  dword ptr stpsi,edx #save} sti stpsi
        mov  ecx,dword ptr stmcs #refine with counter start value} mov stmcs wa
        sub  ecx,dword ptr stmct #minus current counter} sub stmct wa
        mov  edx,ecx        #convert to integer} mti wa
        add  edx,dword ptr stpsi #add in course count} adi stpsi
        mov  dword ptr stpsi,edx #save} sti stpsi
        mov  edi,offset stpm2 #point to message /stmts executed/} mov =stpm2 xr
        call prtmx          #print it} jsr prtmx
        mov  edx,dword ptr stpti #reload elapsed time} ldi stpti
        imul edx,dword ptr intth #*1000 (microsecs)} mli intth
        jo   short stpr2          #jump if we cannot compute} iov stpr2 # (jump shortened)
        mov  eax,dword ptr stpsi #divide by statement count} dvi stpsi
        call dvi_
        jo   short stpr2          #jump if overflow} iov stpr2 # (jump shortened)
        mov  edi,offset stpm4 #point to msg (mcsec per statement /} mov =stpm4 xr
        call prtmx          #print it} jsr prtmx
                            #} ejc
        .eject
#
#      stopr (continued)
#
#      merge to skip message (overflow or negative stlimit)
#
stpr2:  mov  edx,dword ptr gbcnt #load count of collections} mti gbcnt
        mov  edi,offset stpm5 #point to message /regenerations /} mov =stpm5 xr
        call prtmx          #print it} jsr prtmx
        call prtmm          #print memory usage} jsr prtmm
        call prtis          #one more blank for luck} jsr prtis
#
#      check if dump requested
#
stpr3:  call prflr          #print profile if wanted} jsr prflr
#
        mov  edi,dword ptr kvdmp #load dump keyword} mov kvdmp xr
        call dumpr          #execute dump if requested} jsr dumpr
        mov  esi,dword ptr r_fcb #get fcblk chain head} mov r_fcb xl
        mov  ecx,dword ptr kvabe #load abend value} mov kvabe wa
        mov  ebx,dword ptr kvcod #load code value} mov kvcod wb
        call sysej          #exit to system} jsr sysej
#
#      here after sysea call and suppressing error msg print
#
stpr4:                      #} rtn
        .global stpr4
        mov  eax,dword ptr rsmem #use the reserve memory} add rsmem dname
        add  dword ptr dname,eax
        cmp  dword ptr dword ptr exsts,0 #if execution stats requested} bze exsts stpr1
        jz   stpr1
        jmp  stpr3          #check if dump or profile needed} brn stpr3
                            #} ejc
        .eject
#
#      succp -- signal successful match of a pattern node
#
#      see pattern match routines for details
#
#      (xr)                  current node
#      (wb)                  current cursor
#      (xl)                  may be non-collectable
#      brn  succp            signal successful pattern match
#
#      succp continues by matching the successor node
#
succp:                      #} rtn
        .global succp
        mov  edi,dword ptr (4*pthen)[edi] #load successor node} mov pthen(xr) xr
        mov  esi,dword ptr [edi] #load node code entry address} mov (xr) xl
        jmp  esi            #jump to match successor node} bri xl
                            #} ejc
        .eject
#
#      sysab -- print /abnormal end/ and terminate
#
sysab:                      #} rtn
        .global sysab
        mov  edi,offset endab #point to message} mov =endab xr
        mov  dword ptr kvabe,num01 #set abend flag} mov =num01 kvabe
        call prtnl          #skip to new line} jsr prtnl
        jmp  stopr          #jump to pack up} brn stopr
                            #} ejc
        .eject
#
#      systu -- print /time up/ and terminate
#
systu:                      #} rtn
        .global systu
        mov  edi,offset endtu #point to message} mov =endtu xr
        mov  ecx,dword ptr strtu #get chars /tu/} mov strtu wa
        mov  dword ptr kvcod,ecx #put in kvcod} mov wa kvcod
        mov  ecx,dword ptr timup #check state of timeup switch} mov timup wa
        mov  dword ptr timup,esp #set switch} mnz timup
        or   ecx,ecx        #stop run if already set} bnz wa stopr
        jnz  stopr
        call err_0          #} erb 245 translation/execution time expired
        .byte 245
                            #} ttl s p i t b o l -- utility procedures
        .sbttl "s p i t b o l -- utility procedures"
#
#      the following section contains procedures which are
#      used for various purposes throughout the system.
#
#      each procedure is preceded by a description of the
#      calling sequence. usually the arguments are in registers
#      but arguments can also occur on the stack and as
#      parameters assembled after the jsr instruction.
#
#      the following considerations apply to these descriptions.
#
#      1)   the stack pointer (xs) is not changed unless the
#           change is explicitly documented in the call.
#
#      2)   registers whose entry values are not mentioned
#           may contain any value except that xl,xr may only
#           contain proper (collectable) pointer values.
#           this condition on means that the called routine
#           may if it chooses preserve xl,xr by stacking.
#
#      3)   registers not mentioned on exit contain the same
#           values as they did on entry except that values in
#           xr,xl may have been relocated by the collector.
#
#      4)   registers which are destroyed on exit may contain
#           any value except that values in xl,xr are proper
#           (collectable) pointers.
#
#      5)   the code pointer register points to the current
#           code location on entry and is unchanged on exit.
#
#      in the above description, a collectable pointer is one
#      which either points outside the dynamic region or
#      points to the start of a block in the dynamic region.
#
#      in those cases where the calling sequence contains
#      parameters which are used as alternate return points,
#      these parameters may be replaced by error codes
#      assembled with the err instruction. this will result
#      in the posting of the error if the return is taken.
#
#      the procedures all have names consisting of five letters
#      and are in alphabetical order by their names.
                            #} ejc
        .eject
#
#      acess - access variable value with trace/input checks
#
#      acess loads the value of a variable. trace and input
#      associations are tested for and executed as required.
#      acess also handles the special cases of pseudo-variables.
#
#      (xl)                  variable name base
#      (wa)                  variable name offset
#      jsr  acess            call to access value
#      ppm  loc              transfer loc if access failure
#      (xr)                  variable value
#      (wa,wb,wc)            destroyed
#      (xl,ra)               destroyed
#
#      failure can occur if an input association causes an end
#      of file condition or if the evaluation of an expression
#      associated with an expression variable fails.
#
acess:                      #entry point (recursive)} prc r 1
        .global acess
        mov  edi,esi        #copy name base} mov xl xr
        add  edi,ecx        #point to variable location} add wa xr
        mov  edi,dword ptr [edi] #load variable value} mov (xr) xr
#
#      loop here to check for successive trblks
#
acs02:  cmp  dword ptr [edi],offset b_trt #jump if not trapped} bne (xr) =b_trt acs18
        jne  acs18
#
#      here if trapped
#
        cmp  edi,offset trbkv #jump if keyword variable} beq xr =trbkv acs12
        je   acs12
        cmp  edi,offset trbev #jump if not expression variable} bne xr =trbev acs05
        jne  short acs05 # (jump shortened)
#
#      here for expression variable, evaluate variable
#
        mov  edi,dword ptr (4*evexp)[esi] #load expression pointer} mov evexp(xl) xr
        xor  ebx,ebx        #evaluate by value} zer wb
        call evalx          #evaluate expression} jsr evalx
        .short acs04-dffnc  #jump if evaluation failure} ppm acs04
        jmp  acs02          #check value for more trblks} brn acs02
                            #} ejc
        .eject
#
#      acess (continued)
#
#      here on reading end of file
#
acs03:  add  esp,4*num03    #pop trblk ptr, name base and offset} add *num03 xs
        mov  dword ptr dnamp,edi #pop unused scblk} mov xr dnamp
#
#      merge here when evaluation of expression fails
#
acs04:  pop  eax            #take alternate (failure) return} exi 1
        jmp  exi__1
#
#      here if not keyword or expression variable
#
acs05:  mov  ebx,dword ptr (4*trtyp)[edi] #load trap type code} mov trtyp(xr) wb
        or   ebx,ebx        #jump if not input association} bnz wb acs10
        jnz  acs10
        cmp  dword ptr dword ptr kvinp,0 #ignore input assoc if input is off} bze kvinp acs09
        jz   acs09
#
#      here for input association
#
        push esi            #stack name base} mov xl -(xs)
        push ecx            #stack name offset} mov wa -(xs)
        push edi            #stack trblk pointer} mov xr -(xs)
        mov  eax,dword ptr kvtrm #temp to hold trim keyword} mov kvtrm actrm
        mov  dword ptr actrm,eax
        mov  esi,dword ptr (4*trfpt)[edi] #get file ctrl blk ptr or zero} mov trfpt(xr) xl
        or   esi,esi        #jump if not standard input file} bnz xl acs06
        jnz  short acs06 # (jump shortened)
        cmp  dword ptr (4*trter)[edi],offset v_ter #jump if terminal} beq trter(xr) =v_ter acs21
        je   acs21
#
#      here to read from standard input file
#
        mov  ecx,dword ptr cswin #length for read buffer} mov cswin wa
        call alocs          #build string of appropriate length} jsr alocs
        call sysrd          #read next standard input image} jsr sysrd
        .short acs03-dffnc  #jump to fail exit if end of file} ppm acs03
        jmp  short acs07          #else merge with other file case} brn acs07 # (jump shortened)
#
#      here for input from other than standard input file
#
acs06:  mov  ecx,esi        #fcblk ptr} mov xl wa
        call sysil          #get input record max length (to ecx)} jsr sysil
        or   edx,edx        #jump if not binary file} bnz wc acs6a
        jnz  short acs6a # (jump shortened)
        mov  dword ptr actrm,edx #disable trim for binary file} mov wc actrm
acs6a:  call alocs          #allocate string of correct size} jsr alocs
        mov  ecx,esi        #fcblk ptr} mov xl wa
        call sysin          #call system input routine} jsr sysin
        .short acs03-dffnc  #jump to fail exit if end of file} ppm acs03
        .short acs22-dffnc  #error} ppm acs22
        .short acs23-dffnc  #error} ppm acs23
                            #} ejc
        .eject
#
#      acess (continued)
#
#      merge here after obtaining input record
#
acs07:  mov  ebx,dword ptr actrm #load trim indicator} mov actrm wb
        call trimr          #trim record as required} jsr trimr
        mov  ebx,edi        #copy result pointer} mov xr wb
        mov  edi,dword ptr [esp] #reload pointer to trblk} mov (xs) xr
#
#      loop to chase to end of trblk chain and store value
#
acs08:  mov  esi,edi        #save pointer to this trblk} mov xr xl
        mov  edi,dword ptr (4*trnxt)[edi] #load forward pointer} mov trnxt(xr) xr
        cmp  dword ptr [edi],offset b_trt #loop if this is another trblk} beq (xr) =b_trt acs08
        je   acs08
        mov  dword ptr (4*trnxt)[esi],ebx #else store result at end of chain} mov wb trnxt(xl)
        pop  edi            #restore initial trblk pointer} mov (xs)+ xr
        pop  ecx            #restore name offset} mov (xs)+ wa
        pop  esi            #restore name base pointer} mov (xs)+ xl
#
#      come here to move to next trblk
#
acs09:  mov  edi,dword ptr (4*trnxt)[edi] #load forward ptr to next value} mov trnxt(xr) xr
        jmp  acs02          #back to check if trapped} brn acs02
#
#      here to check for access trace trblk
#
acs10:  cmp  ebx,trtac      #loop back if not access trace} bne wb =trtac acs09
        jne  acs09
        cmp  dword ptr dword ptr kvtra,0 #ignore access trace if trace off} bze kvtra acs09
        jz   acs09
        dec  dword ptr kvtra #else decrement trace count} dcv kvtra
        cmp  dword ptr dword ptr (4*trfnc)[edi],0 #jump if print trace} bze trfnc(xr) acs11
        jz   short acs11 # (jump shortened)
                            #} ejc
        .eject
#
#      acess (continued)
#
#      here for full function trace
#
        call trxeq          #call routine to execute trace} jsr trxeq
        jmp  acs09          #jump for next trblk} brn acs09
#
#      here for case of print trace
#
acs11:  call prtsn          #print statement number} jsr prtsn
        call prtnv          #print name = value} jsr prtnv
        jmp  acs09          #jump back for next trblk} brn acs09
#
#      here for keyword variable
#
acs12:  mov  edi,dword ptr (4*kvnum)[esi] #load keyword number} mov kvnum(xl) xr
        cmp  edi,k_v__      #jump if not one word value} bge xr =k_v__ acs14
        jae  short acs14 # (jump shortened)
        mov  edx,kvabe[edi] #else load value as integer} mti kvabe(xr)
#
#      common exit with keyword value as integer in (ia)
#
acs13:  call icbld          #build icblk} jsr icbld
        jmp  acs18          #jump to exit} brn acs18
#
#      here if not one word keyword value
#
acs14:  cmp  edi,k_s__      #jump if special case} bge xr =k_s__ acs15
        jae  short acs15 # (jump shortened)
        sub  edi,k_v__      #else get offset} sub =k_v__ xr
        sal  edi,2          #convert to byte offset} wtb xr
        add  edi,offset ndabo #point to pattern value} add =ndabo xr
        jmp  acs18          #jump to exit} brn acs18
#
#      here if special keyword case
#
acs15:  mov  esi,dword ptr kvrtn #load rtntype in case} mov kvrtn xl
        mov  edx,dword ptr kvstl #load stlimit in case} ldi kvstl
        sub  edi,k_s__      #get case number} sub =k_s__ xr
        jmp  dword ptr l0005[edi*4] #switch on keyword number} bsw xr k__n_
        dseg_
l0005:
        .long acs16         #jump if alphabet} iff k__al acs16
        .long acs17         #rtntype} iff k__rt acs17
        .long acs19         #stcount} iff k__sc acs19
        .long acs20         #errtext} iff k__et acs20
        .long acs26         #file} iff k__fl acs26
        .long acs27         #lastfile} iff k__lf acs27
        .long acs13         #stlimit} iff k__sl acs13
        .long acs24         #lcase} iff k__lc acs24
        .long acs25         #ucase} iff k__uc acs25
        dsegend_            #end switch on keyword number} esw
        cseg_
                            #} ejc
        .eject
#
#      acess (continued)
#
#      lcase
#
acs24:  mov  edi,offset lcase #load pointer to lcase string} mov =lcase xr
        jmp  acs18          #common return} brn acs18
#
#      ucase
#
acs25:  mov  edi,offset ucase #load pointer to ucase string} mov =ucase xr
        jmp  short acs18          #common return} brn acs18 # (jump shortened)
#
#      file
#
acs26:  mov  edx,dword ptr kvstn #load current stmt number} mov kvstn wc
        jmp  short acs28          #merge to obtain file name} brn acs28 # (jump shortened)
#
#      lastfile
#
acs27:  mov  edx,dword ptr kvlst #load last stmt number} mov kvlst wc
#
#      merge here to map statement number in wc to file name
#
acs28:  call filnm          #obtain file name for this stmt} jsr filnm
        jmp  short acs17          #merge to return string in esi} brn acs17 # (jump shortened)
#      alphabet
#
acs16:  mov  esi,dword ptr kvalp #load pointer to alphabet string} mov kvalp xl
#
#      rtntype merges here
#
acs17:  mov  edi,esi        #copy string ptr to proper reg} mov xl xr
#
#      common return point
#
acs18:  pop  eax            #return to acess caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here for stcount (ia has stlimit)
#
acs19:  or   edx,edx        #if counting suppressed} ilt acs29
        jl   short acs29 # (jump shortened)
        mov  ecx,dword ptr stmcs #refine with counter start value} mov stmcs wa
        sub  ecx,dword ptr stmct #minus current counter} sub stmct wa
        mov  edx,ecx        #convert to integer} mti wa
        add  edx,dword ptr kvstl #add stlimit} adi kvstl
acs29:  sub  edx,dword ptr kvstc #stcount = limit - left} sbi kvstc
        jmp  acs13          #merge back with integer result} brn acs13
#
#      errtext
#
acs20:  mov  edi,dword ptr r_etx #get errtext string} mov r_etx xr
        jmp  acs18          #merge with result} brn acs18
#
#      here to read a record from terminal
#
acs21:  mov  ecx,rilen      #buffer length} mov =rilen wa
        call alocs          #allocate buffer} jsr alocs
        call sysri          #read record} jsr sysri
        .short acs03-dffnc  #endfile} ppm acs03
        jmp  acs07          #merge with record read} brn acs07
#
#      error returns
#
acs22:  mov  dword ptr dnamp,edi #pop unused scblk} mov xr dnamp
        call err_0          #} erb 202 input from file caused non-recoverable error
        .byte 202
#
acs23:  mov  dword ptr dnamp,edi #pop unused scblk} mov xr dnamp
        call err_0          #} erb 203 input file record has incorrect format
        .byte 203
                            #end procedure acess} enp
                            #} ejc
        .eject
#
#      acomp -- compare two arithmetic values
#
#      1(xs)                 first argument
#      0(xs)                 second argument
#      jsr  acomp            call to compare values
#      ppm  loc              transfer loc if arg1 is non-numeric
#      ppm  loc              transfer loc if arg2 is non-numeric
#      ppm  loc              transfer loc for arg1 lt arg2
#      ppm  loc              transfer loc for arg1 eq arg2
#      ppm  loc              transfer loc for arg1 gt arg2
#      (normal return is never given)
#      (wa,wb,wc,ia,ra)      destroyed
#      (xl,xr)               destroyed
#
acomp:                      #entry point} prc n 5
        .global acomp
        pop  prc_+0
        call arith          #load arithmetic operands} jsr arith
        .short acmp7-dffnc  #jump if first arg non-numeric} ppm acmp7
        .short acmp8-dffnc  #jump if second arg non-numeric} ppm acmp8
        .short acmp4-dffnc  #jump if real arguments} ppm acmp4
#
#      here for integer arguments
#
        sub  edx,dword ptr (4*icval)[esi] #subtract to compare} sbi icval(xl)
        jo   short acmp3          #jump if overflow} iov acmp3 # (jump shortened)
        or   edx,edx        #else jump if arg1 lt arg2} ilt acmp5
        jl   acmp5
        or   edx,edx        #jump if arg1 eq arg2} ieq acmp2
        je   short acmp2 # (jump shortened)
#
#      here if arg1 gt arg2
#
acmp1:  mov  eax,prc_+0     #take gt exit} exi 5
        jmp  exi__5
#
#      here if arg1 eq arg2
#
acmp2:  mov  eax,prc_+0     #take eq exit} exi 4
        jmp  exi__4
                            #} ejc
        .eject
#
#      acomp (continued)
#
#      here for integer overflow on subtract
#
acmp3:  mov  edx,dword ptr (4*icval)[esi] #load second argument} ldi icval(xl)
        or   edx,edx        #gt if negative} ilt acmp1
        jl   acmp1
        jmp  short acmp5          #else lt} brn acmp5 # (jump shortened)
#
#      here for real operands
#
acmp4:  lea  eax,dword ptr (4*rcval)[esi] #subtract to compare} sbr rcval(xl)
        call sbr_
        call ovr_           #jump if overflow} rov acmp6
        jo   short acmp6 # (jump shortened)
        call cpr_           #else jump if arg1 gt} rgt acmp1
        jg   acmp1
        call cpr_           #jump if arg1 eq arg2} req acmp2
        je   acmp2
#
#      here if arg1 lt arg2
#
acmp5:  mov  eax,prc_+0     #take lt exit} exi 3
        jmp  exi__3
#
#      here if overflow on real subtraction
#
acmp6:  lea  eax,dword ptr (4*rcval)[esi] #reload arg2} ldr rcval(xl)
        call ldr_
        call cpr_           #gt if negative} rlt acmp1
        jl   acmp1
        jmp  acmp5          #else lt} brn acmp5
#
#      here if arg1 non-numeric
#
acmp7:  mov  eax,prc_+0     #take error exit} exi 1
        jmp  exi__1
#
#      here if arg2 non-numeric
#
acmp8:  mov  eax,prc_+0     #take error exit} exi 2
        jmp  exi__2
                            #end procedure acomp} enp
                            #} ejc
        .eject
#
#      alloc                 allocate block of dynamic storage
#
#      (wa)                  length required in bytes
#      jsr  alloc            call to allocate block
#      (xr)                  pointer to allocated block
#
#      a possible alternative to aov ... and following stmt is -
#      mov  dname,xr .  sub  wa,xr .  blo xr,dnamp,aloc2 .
#      mov  dnamp,xr .  add  wa,xr
#
alloc:                      #entry point} prc e 0
        .global alloc
#
#      common exit point
#
aloc1:  mov  edi,dword ptr dnamp #point to next available loc} mov dnamp xr
        add  edi,ecx        #point past allocated block} aov wa xr aloc2
        jc   short aloc2 # (jump shortened)
        cmp  edi,dword ptr dname #jump if not enough room} bgt xr dname aloc2
        ja   short aloc2 # (jump shortened)
        mov  dword ptr dnamp,edi #store new pointer} mov xr dnamp
        sub  edi,ecx        #point back to start of allocated bk} sub wa xr
        ret                 #return to caller} exi
#
#      here if insufficient room, try a garbage collection
#
aloc2:  mov  dword ptr allsv,ebx #save ebx} mov wb allsv
alc2a:  xor  ebx,ebx        #set no upward move for gbcol} zer wb
        call gbcol          #garbage collect} jsr gbcol
        mov  ebx,edi        #remember new sediment size} mov xr wb
#
#      see if room after gbcol or sysmm call
#
aloc3:  mov  edi,dword ptr dnamp #point to first available loc} mov dnamp xr
        add  edi,ecx        #point past new block} aov wa xr alc3a
        jc   short alc3a # (jump shortened)
        cmp  edi,dword ptr dname #jump if there is room now} blo xr dname aloc4
        jb   aloc4
#
#      failed again, see if we can get more core
#
alc3a:  call sysmm          #try to get more memory} jsr sysmm
        sal  edi,2          #convert to baus (sgd05)} wtb xr
        add  dword ptr dname,edi #bump ptr by amount obtained} add xr dname
        or   edi,edi        #jump if got more core} bnz xr aloc3
        jnz  aloc3
        cmp  dword ptr dword ptr dnams,0 #jump if there was no sediment} bze dnams alc3b
        jz   short alc3b # (jump shortened)
        xor  eax,eax        #try collecting the sediment} zer dnams
        mov  dword ptr dnams,eax
        jmp  alc2a          #} brn alc2a
#
#      sysmm failed and there was no sediment to collect
#
alc3b:  mov  eax,dword ptr rsmem #get the reserve memory} add rsmem dname
        add  dword ptr dname,eax
        xor  eax,eax        #only permissible once} zer rsmem
        mov  dword ptr rsmem,eax
        inc  dword ptr errft #fatal error} icv errft
        call err_0          #} erb 204 memory overflow
        .byte 204
                            #} ejc
        .eject
#
#      here after successful garbage collection
#
aloc4:  mov  dword ptr allia,edx #save edx} sti allia
        mov  dword ptr dnams,ebx #record new sediment size} mov wb dnams
        mov  ebx,dword ptr dname #get dynamic end adrs} mov dname wb
        sub  ebx,dword ptr dnamp #compute free store} sub dnamp wb
        shr  ebx,2          #convert bytes to words} btw wb
        mov  edx,ebx        #put free store in edx} mti wb
        imul edx,dword ptr alfsf #multiply by free store factor} mli alfsf
        jo   short aloc5          #jump if overflowed} iov aloc5 # (jump shortened)
        mov  ebx,dword ptr dname #dynamic end adrs} mov dname wb
        sub  ebx,dword ptr dnamb #compute total amount of dynamic} sub dnamb wb
        shr  ebx,2          #convert to words} btw wb
        mov  dword ptr aldyn,ebx #store it} mov wb aldyn
        sub  edx,dword ptr aldyn #subtract from scaled up free store} sbi aldyn
#        or   edx,edx        #jump if sufficient free store} igt aloc5   (optimized)
        jg   short aloc5 # (jump shortened)
        call sysmm          #try to get more store} jsr sysmm
        sal  edi,2          #convert to baus (sgd05)} wtb xr
        add  dword ptr dname,edi #adjust dynamic end adrs} add xr dname
#
#      merge to restore ia and wb
#
aloc5:  mov  edx,dword ptr allia #recover edx} ldi allia
        mov  ebx,dword ptr allsv #restore ebx} mov allsv wb
        jmp  aloc1          #jump back to exit} brn aloc1
                            #end procedure alloc} enp
                            #} ejc
        .eject
#
#      alocs -- allocate string block
#
#      alocs is used to build a frame for a string block into
#      which the actual characters are placed by the caller.
#      all strings are created with a call to alocs (the
#      exceptions occur in trimr and s$rpl procedures).
#
#      (wa)                  length of string to be allocated
#      jsr  alocs            call to allocate scblk
#      (xr)                  pointer to resulting scblk
#      (wa)                  destroyed
#      (wc)                  character count (entry value of wa)
#
#      the resulting scblk has the type word and the length
#      filled in and the last word is cleared to zero characters
#      to ensure correct right padding of the final word.
#
alocs:                      #entry point} prc e 0
        .global alocs
        cmp  ecx,dword ptr kvmxl #jump if length exceeds maxlength} bgt wa kvmxl alcs2
        ja   alcs2
        mov  edx,ecx        #else copy length} mov wa wc
        add  ecx,3+4*scsi_  #compute length of scblk in bytes} ctb wa scsi_
        and  ecx,-4
        mov  edi,dword ptr dnamp #point to next available location} mov dnamp xr
        add  edi,ecx        #point past block} aov wa xr alcs0
        jc   short alcs0 # (jump shortened)
        cmp  edi,dword ptr dname #jump if there is room} blo xr dname alcs1
        jb   short alcs1 # (jump shortened)
#
#      insufficient memory
#
alcs0:  xor  edi,edi        #else clear garbage edi value} zer xr
        call alloc          #and use standard allocator} jsr alloc
        add  edi,ecx        #point past end of block to merge} add wa xr
#
#      merge here with xr pointing beyond new block
#
alcs1:  mov  dword ptr dnamp,edi #set updated storage pointer} mov xr dnamp
        lea  edi,[edi-4]    #store zero chars in last word} zer -(xr)
        xor  eax,eax
        mov  dword ptr [edi],eax
        sub  ecx,4          #decrement length} dca wa
        sub  edi,ecx        #point back to start of block} sub wa xr
        mov  dword ptr [edi],offset b_scl #set type word} mov =b_scl (xr)
        mov  dword ptr (4*sclen)[edi],edx #store length in chars} mov wc sclen(xr)
        ret                 #return to alocs caller} exi
#
#      come here if string is too long
#
alcs2:  call err_0          #} erb 205 string length exceeds value of maxlngth keyword
        .byte 205
                            #end procedure alocs} enp
                            #} ejc
        .eject
#
#      alost -- allocate space in static region
#
#      (wa)                  length required in bytes
#      jsr  alost            call to allocate space
#      (xr)                  pointer to allocated block
#      (wb)                  destroyed
#
#      note that the coding ensures that the resulting value
#      of state is always less than dnamb. this fact is used
#      in testing a variable name for being in the static region
#
alost:                      #entry point} prc e 0
        .global alost
#
#      merge back here after allocating new chunk
#
alst1:  mov  edi,dword ptr state #point to current end of area} mov state xr
        add  edi,ecx        #point beyond proposed block} aov wa xr alst2
        jc   short alst2 # (jump shortened)
        cmp  edi,dword ptr dnamb #jump if overlap with dynamic area} bge xr dnamb alst2
        jae  short alst2 # (jump shortened)
        mov  dword ptr state,edi #else store new pointer} mov xr state
        sub  edi,ecx        #point back to start of block} sub wa xr
        ret                 #return to alost caller} exi
#
#      here if no room, prepare to move dynamic storage up
#
alst2:  mov  dword ptr alsta,ecx #save ecx} mov wa alsta
        cmp  ecx,4*e_sts    #skip if requested chunk is large} bge wa *e_sts alst3
        jae  short alst3 # (jump shortened)
        mov  ecx,4*e_sts    #else set to get large enough chunk} mov *e_sts wa
#
#      here with amount to move up in wa
#
alst3:  call alloc          #allocate block to ensure room} jsr alloc
        mov  dword ptr dnamp,edi #and delete it} mov xr dnamp
        mov  ebx,ecx        #copy move up amount} mov wa wb
        call gbcol          #call gbcol to move dynamic area up} jsr gbcol
        mov  dword ptr dnams,edi #remember new sediment size} mov xr dnams
        mov  ecx,dword ptr alsta #restore ecx} mov alsta wa
        jmp  alst1          #loop back to try again} brn alst1
                            #end procedure alost} enp
                            #} ejc
        .eject
#
#      arith -- fetch arithmetic operands
#
#      arith is used by functions and operators which expect
#      two numeric arguments (operands) which must both be
#      integer or both be real. arith fetches two arguments from
#      the stack and performs any necessary conversions.
#
#      1(xs)                 first argument (left operand)
#      0(xs)                 second argument (right operand)
#      jsr  arith            call to fetch numeric arguments
#      ppm  loc              transfer loc for opnd 1 non-numeric
#      ppm  loc              transfer loc for opnd 2 non-numeric
#      ppm  loc              transfer loc for real operands
#
#      for integer args, control returns past the parameters
#
#      (ia)                  left operand value
#      (xr)                  ptr to icblk for left operand
#      (xl)                  ptr to icblk for right operand
#      (xs)                  popped twice
#      (wa,wb,ra)            destroyed
#
#      for real arguments, control returns to the location
#      specified by the third parameter.
#
#      (ra)                  left operand value
#      (xr)                  ptr to rcblk for left operand
#      (xl)                  ptr to rcblk for right operand
#      (wa,wb,wc)            destroyed
#      (xs)                  popped twice
                            #} ejc
        .eject
#
#      arith (continued)
#
#      entry point
#
arith:                      #entry point} prc n 3
        .global arith
        pop  prc_+4
        pop  esi            #load right operand} mov (xs)+ xl
        pop  edi            #load left operand} mov (xs)+ xr
        mov  ecx,dword ptr [esi] #get right operand type word} mov (xl) wa
        cmp  ecx,offset b_icl #jump if integer} beq wa =b_icl arth1
        je   short arth1 # (jump shortened)
        cmp  ecx,offset b_rcl #jump if real} beq wa =b_rcl arth4
        je   arth4
        push edi            #else replace left arg on stack} mov xr -(xs)
        mov  edi,esi        #copy left arg pointer} mov xl xr
        call gtnum          #convert to numeric} jsr gtnum
        .short arth6-dffnc  #jump if unconvertible} ppm arth6
        mov  esi,edi        #else copy converted result} mov xr xl
        mov  ecx,dword ptr [esi] #get right operand type word} mov (xl) wa
        pop  edi            #reload left argument} mov (xs)+ xr
        cmp  ecx,offset b_rcl #jump if right arg is real} beq wa =b_rcl arth4
        je   arth4
#
#      here if right arg is an integer
#
arth1:  cmp  dword ptr [edi],offset b_icl #jump if left arg not integer} bne (xr) =b_icl arth3
        jne  short arth3 # (jump shortened)
#
#      exit for integer case
#
arth2:  mov  edx,dword ptr (4*icval)[edi] #load left operand value} ldi icval(xr)
        mov  eax,prc_+4     #return to arith caller} exi
        lea  eax,[eax+6]
        jmp  eax
#
#      here for right operand integer, left operand not
#
arth3:  call gtnum          #convert left arg to numeric} jsr gtnum
        .short arth7-dffnc  #jump if not convertible} ppm arth7
        cmp  ecx,offset b_icl #jump back if integer-integer} beq wa =b_icl arth2
        je   arth2
#
#      here we must convert real-integer to real-real
#
        push edi            #put left arg back on stack} mov xr -(xs)
        mov  edx,dword ptr (4*icval)[esi] #load right argument value} ldi icval(xl)
        call itr_           #convert to real} itr
        call rcbld          #get real block for right arg, merge} jsr rcbld
        mov  esi,edi        #copy right arg ptr} mov xr xl
        pop  edi            #load left argument} mov (xs)+ xr
        jmp  short arth5          #merge for real-real case} brn arth5 # (jump shortened)
                            #} ejc
        .eject
#
#      arith (continued)
#
#      here if right argument is real
#
arth4:  cmp  dword ptr [edi],offset b_rcl #jump if left arg real} beq (xr) =b_rcl arth5
        je   short arth5 # (jump shortened)
        call gtrea          #else convert to real} jsr gtrea
        .short arth7-dffnc  #error if unconvertible} ppm arth7
#
#      here for real-real
#
arth5:  lea  eax,dword ptr (4*rcval)[edi] #load left operand value} ldr rcval(xr)
        call ldr_
        mov  eax,prc_+4     #take real-real exit} exi 3
        jmp  exi__3
#
#      here for error converting right argument
#
arth6:  add  esp,4          #pop unwanted left arg} ica xs
        mov  eax,prc_+4     #take appropriate error exit} exi 2
        jmp  exi__2
#
#      here for error converting left operand
#
arth7:  mov  eax,prc_+4     #take appropriate error return} exi 1
        jmp  exi__1
                            #end procedure arith} enp
                            #} ejc
        .eject
#
#      asign -- perform assignment
#
#      asign performs the assignment of a value to a variable
#      with appropriate checks for output associations and
#      value trace associations which are executed as required.
#      asign also handles the special cases of assignment to
#      pattern and expression variables.
#
#      (wb)                  value to be assigned
#      (xl)                  base pointer for variable
#      (wa)                  offset for variable
#      jsr  asign            call to assign value to variable
#      ppm  loc              transfer loc for failure
#      (xr,xl,wa,wb,wc)      destroyed
#      (ra)                  destroyed
#
#      failure occurs if the evaluation of an expression
#      associated with an expression variable fails.
#
asign:                      #entry point (recursive)} prc r 1
        .global asign
#
#      merge back here to assign result to expression variable.
#
asg01:  add  esi,ecx        #point to variable value} add wa xl
        mov  edi,dword ptr [esi] #load variable value} mov (xl) xr
        cmp  dword ptr [edi],offset b_trt #jump if trapped} beq (xr) =b_trt asg02
        je   short asg02 # (jump shortened)
        mov  dword ptr [esi],ebx #else perform assignment} mov wb (xl)
        xor  esi,esi        #clear garbage value in esi} zer xl
        pop  eax            #and return to asign caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here if value is trapped
#
asg02:  sub  esi,ecx        #restore name base} sub wa xl
        cmp  edi,offset trbkv #jump if keyword variable} beq xr =trbkv asg14
        je   asg14
        cmp  edi,offset trbev #jump if not expression variable} bne xr =trbev asg04
        jne  short asg04 # (jump shortened)
#
#      here for assignment to expression variable
#
        mov  edi,dword ptr (4*evexp)[esi] #point to expression} mov evexp(xl) xr
        push ebx            #store value to assign on stack} mov wb -(xs)
        mov  ebx,num01      #set for evaluation by name} mov =num01 wb
        call evalx          #evaluate expression by name} jsr evalx
        .short asg03-dffnc  #jump if evaluation fails} ppm asg03
        pop  ebx            #else reload value to assign} mov (xs)+ wb
        jmp  asg01          #loop back to perform assignment} brn asg01
                            #} ejc
        .eject
#
#      asign (continued)
#
#      here for failure during expression evaluation
#
asg03:  add  esp,4          #remove stacked value entry} ica xs
        pop  eax            #take failure exit} exi 1
        jmp  exi__1
#
#      here if not keyword or expression variable
#
asg04:  push edi            #save ptr to first trblk} mov xr -(xs)
#
#      loop to chase down trblk chain and assign value at end
#
asg05:  mov  edx,edi        #save ptr to this trblk} mov xr wc
        mov  edi,dword ptr (4*trnxt)[edi] #point to next trblk} mov trnxt(xr) xr
        cmp  dword ptr [edi],offset b_trt #loop back if another trblk} beq (xr) =b_trt asg05
        je   asg05
        mov  edi,edx        #else point back to last trblk} mov wc xr
        mov  dword ptr (4*trval)[edi],ebx #store value at end of chain} mov wb trval(xr)
        pop  edi            #restore ptr to first trblk} mov (xs)+ xr
#
#      loop to process trblk entries on chain
#
asg06:  mov  ebx,dword ptr (4*trtyp)[edi] #load type code of trblk} mov trtyp(xr) wb
        cmp  ebx,trtvl      #jump if value trace} beq wb =trtvl asg08
        je   short asg08 # (jump shortened)
        cmp  ebx,trtou      #jump if output association} beq wb =trtou asg10
        je   asg10
#
#      here to move to next trblk on chain
#
asg07:  mov  edi,dword ptr (4*trnxt)[edi] #point to next trblk on chain} mov trnxt(xr) xr
        cmp  dword ptr [edi],offset b_trt #loop back if another trblk} beq (xr) =b_trt asg06
        je   asg06
        pop  eax            #else end of chain, return to caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here to process value trace
#
asg08:  cmp  dword ptr dword ptr kvtra,0 #ignore value trace if trace off} bze kvtra asg07
        jz   asg07
        dec  dword ptr kvtra #else decrement trace count} dcv kvtra
        cmp  dword ptr dword ptr (4*trfnc)[edi],0 #jump if print trace} bze trfnc(xr) asg09
        jz   short asg09 # (jump shortened)
        call trxeq          #else execute function trace} jsr trxeq
        jmp  asg07          #and loop back} brn asg07
                            #} ejc
        .eject
#
#      asign (continued)
#
#      here for print trace
#
asg09:  call prtsn          #print statement number} jsr prtsn
        call prtnv          #print name = value} jsr prtnv
        jmp  asg07          #loop back for next trblk} brn asg07
#
#      here for output association
#
asg10:  cmp  dword ptr dword ptr kvoup,0 #ignore output assoc if output off} bze kvoup asg07
        jz   asg07
asg1b:  mov  esi,edi        #copy trblk pointer} mov xr xl
        mov  edi,dword ptr (4*trnxt)[edi] #point to next trblk} mov trnxt(xr) xr
        cmp  dword ptr [edi],offset b_trt #loop back if another trblk} beq (xr) =b_trt asg1b
        je   asg1b
        mov  edi,esi        #else point back to last trblk} mov xl xr
        push dword ptr (4*trval)[edi] #stack value to output} mov trval(xr) -(xs)
        call gtstg          #convert to string} jsr gtstg
        .short asg12-dffnc  #get datatype name if unconvertible} ppm asg12
#
#      merge with string or buffer to output in xr
#
asg11:  mov  ecx,dword ptr (4*trfpt)[esi] #fcblk ptr} mov trfpt(xl) wa
        or   ecx,ecx        #jump if standard output file} bze wa asg13
        jz   short asg13 # (jump shortened)
#
#      here for output to file
#
asg1a:  call sysou          #call system output routine} jsr sysou
        .short err_-206-dffnc #} err 206 output caused file overflow
        .short err_-207-dffnc #} err 207 output caused non-recoverable error
        pop  eax            #else all done, return to caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      if not printable, get datatype name instead
#
asg12:  call dtype          #call datatype routine} jsr dtype
        jmp  asg11          #merge} brn asg11
#
#      here to print a string to standard output or terminal
#
asg13:  cmp  dword ptr (4*trter)[esi],offset v_ter #jump if terminal output} beq trter(xl) =v_ter asg1a
        je   asg1a
        inc  ecx            #signal standard output} icv wa
        jmp  asg1a          #use sysou to perform output} brn asg1a
                            #} ejc
        .eject
#
#      asign (continued)
#
#      here for keyword assignment
#
asg14:  mov  esi,dword ptr (4*kvnum)[esi] #load keyword number} mov kvnum(xl) xl
        cmp  esi,k_etx      #jump if errtext} beq xl =k_etx asg19
        je   asg19
        mov  edi,ebx        #copy value to be assigned} mov wb xr
        call gtint          #convert to integer} jsr gtint
        .short err_-208-dffnc #} err 208 keyword value assigned is not integer
        mov  edx,dword ptr (4*icval)[edi] #else load value} ldi icval(xr)
        cmp  esi,k_stl      #jump if special case of stlimit} beq xl =k_stl asg16
        je   asg16
        or   edx,edx        #else get addr integer, test ovflow} mfi wa asg18
        js   asg18
        mov  ecx,edx
        cmp  ecx,dword ptr mxlen #fail if too large} bgt wa mxlen asg18
        ja   asg18
        cmp  esi,k_ert      #jump if special case of errtype} beq xl =k_ert asg17
        je   asg17
        cmp  esi,k_pfl      #jump if special case of profile} beq xl =k_pfl asg21
        je   asg21
        cmp  esi,k_mxl      #jump if special case of maxlngth} beq xl =k_mxl asg24
        je   asg24
        cmp  esi,k_fls      #jump if special case of fullscan} beq xl =k_fls asg26
        je   asg26
        cmp  esi,k_p__      #jump unless protected} blt xl =k_p__ asg15
        jb   short asg15 # (jump shortened)
        call err_0          #} erb 209 keyword in assignment is protected
        .byte 209
#
#      here to do assignment if not protected
#
asg15:  mov  kvabe[esi],ecx #store new value} mov wa kvabe(xl)
        pop  eax            #return to asign caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here for special case of stlimit
#
#      since stcount is maintained as (stlimit-stcount)
#      it is also necessary to modify stcount appropriately.
#
asg16:  sub  edx,dword ptr kvstl #subtract old limit} sbi kvstl
        add  edx,dword ptr kvstc #add old counter} adi kvstc
        mov  dword ptr kvstc,edx #store course counter value} sti kvstc
        mov  edx,dword ptr kvstl #check if counting suppressed} ldi kvstl
        or   edx,edx        #do not refine if so} ilt asg25
        jl   short asg25 # (jump shortened)
        mov  ecx,dword ptr stmcs #refine with counter breakout} mov stmcs wa
        sub  ecx,dword ptr stmct #values} sub stmct wa
        mov  edx,ecx        #convert to integer} mti wa
        neg  edx            #current-start value} ngi
        add  edx,dword ptr kvstc #add in course counter value} adi kvstc
        mov  dword ptr kvstc,edx #save refined value} sti kvstc
asg25:  mov  edx,dword ptr (4*icval)[edi] #reload new limit value} ldi icval(xr)
        mov  dword ptr kvstl,edx #store new limit value} sti kvstl
        call stgcc          #recompute countdown counters} jsr stgcc
        pop  eax            #return to asign caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here for special case of errtype
#
asg17:  cmp  ecx,nini9      #ok to signal if in range} ble wa =nini9 error
        jbe  error
#
#      here if value assigned is out of range
#
asg18:  call err_0          #} erb 210 keyword value assigned is negative or too large
        .byte 210
#
#      here for special case of errtext
#
asg19:  push ebx            #stack value} mov wb -(xs)
        call gtstg          #convert to string} jsr gtstg
        .short err_-211-dffnc #} err 211 value assigned to keyword errtext not a string
        mov  dword ptr r_etx,edi #make assignment} mov xr r_etx
        pop  eax            #return to caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here for keyword profile
#
asg21:  cmp  ecx,num02      #moan if not 0,1, or 2} bgt wa =num02 asg18
        ja   asg18
        or   ecx,ecx        #just assign if zero} bze wa asg15
        jz   asg15
        cmp  dword ptr dword ptr pfdmp,0 #branch if first assignment} bze pfdmp asg22
        jz   short asg22 # (jump shortened)
        cmp  ecx,dword ptr pfdmp #also if same value as before} beq wa pfdmp asg23
        je   short asg23 # (jump shortened)
        call err_1          #} erb 268 inconsistent value assigned to keyword profile
        .byte 12
#
asg22:  mov  dword ptr pfdmp,ecx #note value on first assignment} mov wa pfdmp
asg23:  mov  dword ptr kvpfl,ecx #store new value} mov wa kvpfl
        call stgcc          #recompute countdown counts} jsr stgcc
        call systm          #get the time} jsr systm
        mov  dword ptr pfstm,edx #fudge some kind of start time} sti pfstm
        pop  eax            #return to asign caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here for keyword maxlngth
#
asg24:  cmp  ecx,mnlen      #if acceptable value} bge wa =mnlen asg15
        jae  asg15
        call err_1          #} erb 287 value assigned to keyword maxlngth is too small
        .byte 31
#
#      here for keyword fullscan
#
asg26:  or   ecx,ecx        #if acceptable value} bnz wa asg15
        jnz  asg15
        call err_1          #} erb 274 value assigned to keyword fullscan is zero
        .byte 18
#
                            #end procedure asign} enp
                            #} ejc
        .eject
#
#      asinp -- assign during pattern match
#
#      asinp is like asign and has a similar calling sequence
#      and effect. the difference is that the global pattern
#      variables are saved and restored if required.
#
#      (xl)                  base pointer for variable
#      (wa)                  offset for variable
#      (wb)                  value to be assigned
#      jsr  asinp            call to assign value to variable
#      ppm  loc              transfer loc if failure
#      (xr,xl)               destroyed
#      (wa,wb,wc,ra)         destroyed
#
asinp:                      #entry point, recursive} prc r 1
        .global asinp
        add  esi,ecx        #point to variable} add wa xl
        mov  edi,dword ptr [esi] #load current contents} mov (xl) xr
        cmp  dword ptr [edi],offset b_trt #jump if trapped} beq (xr) =b_trt asnp1
        je   short asnp1 # (jump shortened)
        mov  dword ptr [esi],ebx #else perform assignment} mov wb (xl)
        xor  esi,esi        #clear garbage value in esi} zer xl
        pop  eax            #return to asinp caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here if variable is trapped
#
asnp1:  sub  esi,ecx        #restore base pointer} sub wa xl
        push dword ptr pmssl #stack subject string length} mov pmssl -(xs)
        push dword ptr pmhbs #stack history stack base ptr} mov pmhbs -(xs)
        push dword ptr r_pms #stack subject string pointer} mov r_pms -(xs)
        push dword ptr pmdfl #stack dot flag} mov pmdfl -(xs)
        call asign          #call full-blown assignment routine} jsr asign
        .short asnp2-dffnc  #jump if failure} ppm asnp2
        pop  dword ptr pmdfl #restore dot flag} mov (xs)+ pmdfl
        pop  dword ptr r_pms #restore subject string pointer} mov (xs)+ r_pms
        pop  dword ptr pmhbs #restore history stack base pointer} mov (xs)+ pmhbs
        pop  dword ptr pmssl #restore subject string length} mov (xs)+ pmssl
        pop  eax            #return to asinp caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here if failure in asign call
#
asnp2:  pop  dword ptr pmdfl #restore dot flag} mov (xs)+ pmdfl
        pop  dword ptr r_pms #restore subject string pointer} mov (xs)+ r_pms
        pop  dword ptr pmhbs #restore history stack base pointer} mov (xs)+ pmhbs
        pop  dword ptr pmssl #restore subject string length} mov (xs)+ pmssl
        pop  eax            #take failure exit} exi 1
        jmp  exi__1
                            #end procedure asinp} enp
                            #} ejc
        .eject
#
#      blkln -- determine length of block
#
#      blkln determines the length of a block in dynamic store.
#
#      (wa)                  first word of block
#      (xr)                  pointer to block
#      jsr  blkln            call to get block length
#      (wa)                  length of block in bytes
#      (xl)                  destroyed
#
#      blkln is used by the garbage collector and is not
#      permitted to call gbcol directly or indirectly.
#
#      the first word stored in the block (i.e. at xr) may
#      be anything, but the contents of wa must be correct.
#
blkln:                      #entry point} prc e 0
        .global blkln
        mov  esi,ecx        #copy first word} mov wa xl
        movzx esi,byte ptr [esi-1] #get entry id (bl_xx)} lei xl
        cmp  esi,bl___      #switch on block type} bsw xl bl___ bln00
        jge  bln00
        jmp  dword ptr l0006[esi*4]
        dseg_
l0006:
        .long bln01         #arblk} iff bl_ar bln01
        .long bln12         #cdblk} iff bl_cd bln12
        .long bln12         #exblk} iff bl_ex bln12
        .long bln07         #icblk} iff bl_ic bln07
        .long bln03         #nmblk} iff bl_nm bln03
        .long bln02         #p0blk} iff bl_p0 bln02
        .long bln03         #p1blk} iff bl_p1 bln03
        .long bln04         #p2blk} iff bl_p2 bln04
        .long bln09         #rcblk} iff bl_rc bln09
        .long bln10         #scblk} iff bl_sc bln10
        .long bln02         #seblk} iff bl_se bln02
        .long bln01         #tbblk} iff bl_tb bln01
        .long bln01         #vcblk} iff bl_vc bln01
        .long bln00         #} iff 13 bln00
        .long bln00         #} iff 14 bln00
        .long bln00         #} iff 15 bln00
        .long bln08         #pdblk} iff bl_pd bln08
        .long bln05         #trblk} iff bl_tr bln05
        .long bln00         #} iff 18 bln00
        .long bln00         #} iff 19 bln00
        .long bln00         #} iff 20 bln00
        .long bln06         #ctblk} iff bl_ct bln06
        .long bln01         #dfblk} iff bl_df bln01
        .long bln01         #efblk} iff bl_ef bln01
        .long bln03         #evblk} iff bl_ev bln03
        .long bln05         #ffblk} iff bl_ff bln05
        .long bln03         #kvblk} iff bl_kv bln03
        .long bln01         #pfblk} iff bl_pf bln01
        .long bln04         #teblk} iff bl_te bln04
        dsegend_            #end of jump table on block type} esw
        cseg_
                            #} ejc
        .eject
#
#      blkln (continued)
#
#      here for blocks with length in second word
#
bln00:  mov  ecx,dword ptr (4*num01)[edi] #load length} mov num01(xr) wa
        ret                 #return to blkln caller} exi
#
#      here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)
#
bln01:  mov  ecx,dword ptr (4*num02)[edi] #load length from third word} mov num02(xr) wa
        ret                 #return to blkln caller} exi
#
#      here for two word blocks (p0,se)
#
bln02:  mov  ecx,4*num02    #load length (two words)} mov *num02 wa
        ret                 #return to blkln caller} exi
#
#      here for three word blocks (nm,p1,ev,kv)
#
bln03:  mov  ecx,4*num03    #load length (three words)} mov *num03 wa
        ret                 #return to blkln caller} exi
#
#      here for four word blocks (p2,te,bc)
#
bln04:  mov  ecx,4*num04    #load length (four words)} mov *num04 wa
        ret                 #return to blkln caller} exi
#
#      here for five word blocks (ff,tr)
#
bln05:  mov  ecx,4*num05    #load length} mov *num05 wa
        ret                 #return to blkln caller} exi
                            #} ejc
        .eject
#
#      blkln (continued)
#
#      here for ctblk
#
bln06:  mov  ecx,4*ctsi_    #set size of ctblk} mov *ctsi_ wa
        ret                 #return to blkln caller} exi
#
#      here for icblk
#
bln07:  mov  ecx,4*icsi_    #set size of icblk} mov *icsi_ wa
        ret                 #return to blkln caller} exi
#
#      here for pdblk
#
bln08:  mov  esi,dword ptr (4*pddfp)[edi] #point to dfblk} mov pddfp(xr) xl
        mov  ecx,dword ptr (4*dfpdl)[esi] #load pdblk length from dfblk} mov dfpdl(xl) wa
        ret                 #return to blkln caller} exi
#
#      here for rcblk
#
bln09:  mov  ecx,4*rcsi_    #set size of rcblk} mov *rcsi_ wa
        ret                 #return to blkln caller} exi
#
#      here for scblk
#
bln10:  mov  ecx,dword ptr (4*sclen)[edi] #load length in characters} mov sclen(xr) wa
        add  ecx,3+4*scsi_  #calculate length in bytes} ctb wa scsi_
        and  ecx,-4
        ret                 #return to blkln caller} exi
#
#      here for length in fourth word (cd,ex)
#
bln12:  mov  ecx,dword ptr (4*num03)[edi] #load length from cdlen/exlen} mov num03(xr) wa
        ret                 #return to blkln caller} exi
                            #end procedure blkln} enp
                            #} ejc
        .eject
#
#      copyb -- copy a block
#
#      (xs)                  block to be copied
#      jsr  copyb            call to copy block
#      ppm  loc              return if block has no idval field
#                            normal return if idval field
#      (xr)                  copy of block
#      (xs)                  popped
#      (xl,wa,wb,wc)         destroyed
#
copyb:                      #entry point} prc n 1
        .global copyb
        pop  prc_+8
        mov  edi,dword ptr [esp] #load argument} mov (xs) xr
        cmp  edi,offset nulls #return argument if it is null} beq xr =nulls cop10
        je   cop10
        mov  ecx,dword ptr [edi] #else load type word} mov (xr) wa
        mov  ebx,ecx        #copy type word} mov wa wb
        call blkln          #get length of argument block} jsr blkln
        mov  esi,edi        #copy pointer} mov xr xl
        call alloc          #allocate block of same size} jsr alloc
        mov  dword ptr [esp],edi #store pointer to copy} mov xr (xs)
        shr  ecx,2          #copy contents of old block to new} mvw
        rep  movsd
        xor  esi,esi        #clear garbage esi} zer xl
        mov  edi,dword ptr [esp] #reload pointer to start of copy} mov (xs) xr
        cmp  ebx,offset b_tbt #jump if table} beq wb =b_tbt cop05
        je   cop05
        cmp  ebx,offset b_vct #jump if vector} beq wb =b_vct cop01
        je   short cop01 # (jump shortened)
        cmp  ebx,offset b_pdt #jump if program defined} beq wb =b_pdt cop01
        je   short cop01 # (jump shortened)
        cmp  ebx,offset b_art #return copy if not array} bne wb =b_art cop10
        jne  cop10
#
#      here for array (arblk)
#
        add  edi,dword ptr (4*arofs)[edi] #point to prototype field} add arofs(xr) xr
        jmp  short cop02          #jump to merge} brn cop02 # (jump shortened)
#
#      here for vector, program defined
#
cop01:  add  edi,4*pdfld    #point to pdfld = vcvls} add *pdfld xr
#
#      merge here for arblk, vcblk, pdblk to delete trap
#      blocks from all value fields (the copy is untrapped)
#
cop02:  mov  esi,dword ptr [edi] #load next pointer} mov (xr) xl
#
#      loop to get value at end of trblk chain
#
cop03:  cmp  dword ptr [esi],offset b_trt #jump if not trapped} bne (xl) =b_trt cop04
        jne  short cop04 # (jump shortened)
        mov  esi,dword ptr (4*trval)[esi] #else point to next value} mov trval(xl) xl
        jmp  cop03          #and loop back} brn cop03
                            #} ejc
        .eject
#
#      copyb (continued)
#
#      here with untrapped value in xl
#
cop04:  mov  eax,esi        #store real value, bump pointer} mov xl (xr)+
        stosd
        cmp  edi,dword ptr dnamp #loop back if more to go} bne xr dnamp cop02
        jne  cop02
        jmp  cop09          #else jump to exit} brn cop09
#
#      here to copy a table
#
cop05:  xor  eax,eax        #zero id to stop dump blowing up} zer idval(xr)
        mov  dword ptr (4*idval)[edi],eax
        mov  ecx,4*tesi_    #set size of teblk} mov *tesi_ wa
        mov  edx,4*tbbuk    #set initial offset} mov *tbbuk wc
#
#      loop through buckets in table
#
cop06:  mov  edi,dword ptr [esp] #load table pointer} mov (xs) xr
        cmp  edx,dword ptr (4*tblen)[edi] #jump to exit if all done} beq wc tblen(xr) cop09
        je   cop09
        mov  ebx,edx        #else copy offset} mov wc wb
        sub  ebx,4*tenxt    #subtract link offset to merge} sub *tenxt wb
        add  edi,ebx        #next bucket header less link offset} add wb xr
        add  edx,4          #bump offset} ica wc
#
#      loop through teblks on one chain
#
cop07:  mov  esi,dword ptr (4*tenxt)[edi] #load pointer to next teblk} mov tenxt(xr) xl
        mov  eax,dword ptr [esp] #set end of chain pointer in case} mov (xs) tenxt(xr)
        mov  dword ptr (4*tenxt)[edi],eax
        cmp  dword ptr [esi],offset b_tbt #back for next bucket if chain end} beq (xl) =b_tbt cop06
        je   cop06
        sub  edi,ebx        #point to head of previous block} sub wb xr
        push edi            #stack ptr to previous block} mov xr -(xs)
        mov  ecx,4*tesi_    #set size of teblk} mov *tesi_ wa
        call alloc          #allocate new teblk} jsr alloc
        push edi            #stack ptr to new teblk} mov xr -(xs)
        shr  ecx,2          #copy old teblk to new teblk} mvw
        rep  movsd
        pop  edi            #restore pointer to new teblk} mov (xs)+ xr
        pop  esi            #restore pointer to previous block} mov (xs)+ xl
        add  esi,ebx        #add offset back in} add wb xl
        mov  dword ptr (4*tenxt)[esi],edi #link new block to previous} mov xr tenxt(xl)
        mov  esi,edi        #copy pointer to new block} mov xr xl
#
#      loop to set real value after removing trap chain
#
cop08:  mov  esi,dword ptr (4*teval)[esi] #load value} mov teval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop back if trapped} beq (xl) =b_trt cop08
        je   cop08
        mov  dword ptr (4*teval)[edi],esi #store untrapped value in teblk} mov xl teval(xr)
        xor  ebx,ebx        #zero offset within teblk} zer wb
        jmp  cop07          #back for next teblk} brn cop07
#
#      common exit point
#
cop09:  pop  edi            #load pointer to block} mov (xs)+ xr
        mov  eax,prc_+8     #return} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      alternative return
#
cop10:  mov  eax,prc_+8     #return} exi 1
        jmp  exi__1
                            #} ejc
        .eject
                            #end procedure copyb} enp
#
#      cdgcg -- generate code for complex goto
#
#      used by cmpil to process complex goto tree
#
#      (wb)                  must be collectable
#      (xr)                  expression pointer
#      jsr  cdgcg            call to generate complex goto
#      (xl,xr,wa)            destroyed
#
cdgcg:                      #entry point} prc e 0
        .global cdgcg
        mov  esi,dword ptr (4*cmopn)[edi] #get unary goto operator} mov cmopn(xr) xl
        mov  edi,dword ptr (4*cmrop)[edi] #point to goto operand} mov cmrop(xr) xr
        cmp  esi,offset opdvd #jump if direct goto} beq xl =opdvd cdgc2
        je   short cdgc2 # (jump shortened)
        call cdgnm          #generate opnd by name if not direct} jsr cdgnm
#
#      return point
#
cdgc1:  mov  ecx,esi        #goto operator} mov xl wa
        call cdwrd          #generate it} jsr cdwrd
        ret                 #return to caller} exi
#
#      direct goto
#
cdgc2:  call cdgvl          #generate operand by value} jsr cdgvl
        jmp  cdgc1          #merge to return} brn cdgc1
                            #end procedure cdgcg} enp
                            #} ejc
        .eject
#
#      cdgex -- build expression block
#
#      cdgex is passed a pointer to an expression tree (see
#      expan) and returns an expression (seblk or exblk).
#
#      (wa)                  0 if by value, 1 if by name
#      (wc)                  some collectable value
#      (wb)                  integer in range 0 le x le mxlen
#      (xl)                  ptr to expression tree
#      jsr  cdgex            call to build expression
#      (xr)                  ptr to seblk or exblk
#      (xl,wa,wb)            destroyed
#
cdgex:                      #entry point, recursive} prc r 0
        .global cdgex
        cmp  dword ptr [esi],offset b_vr_ #jump if not variable} blo (xl) =b_vr_ cdgx1
        jb   short cdgx1 # (jump shortened)
#
#      here for natural variable, build seblk
#
        mov  ecx,4*sesi_    #set size of seblk} mov *sesi_ wa
        call alloc          #allocate space for seblk} jsr alloc
        mov  dword ptr [edi],offset b_sel #set type word} mov =b_sel (xr)
        mov  dword ptr (4*sevar)[edi],esi #store vrblk pointer} mov xl sevar(xr)
        ret                 #return to cdgex caller} exi
#
#      here if not variable, build exblk
#
cdgx1:  mov  edi,esi        #copy tree pointer} mov xl xr
        push edx            #save edx} mov wc -(xs)
        mov  esi,dword ptr cwcof #save current offset} mov cwcof xl
        or   ecx,ecx        #jump if by value} bze wa cdgx2
        jz   short cdgx2 # (jump shortened)
        mov  ecx,dword ptr [edi] #get type word} mov (xr) wa
        cmp  ecx,offset b_cmt #call by value if not cmblk} bne wa =b_cmt cdgx2
        jne  short cdgx2 # (jump shortened)
        cmp  dword ptr (4*cmtyp)[edi],c__nm #jump if cmblk only by value} bge cmtyp(xr) =c__nm cdgx2
        jae  short cdgx2 # (jump shortened)
                            #} ejc
        .eject
#
#      cdgex (continued)
#
#      here if expression can be evaluated by name
#
        call cdgnm          #generate code by name} jsr cdgnm
        mov  ecx,offset ornm_ #load return by name word} mov =ornm_ wa
        jmp  short cdgx3          #merge with value case} brn cdgx3 # (jump shortened)
#
#      here if expression can only be evaluated by value
#
cdgx2:  call cdgvl          #generate code by value} jsr cdgvl
        mov  ecx,offset orvl_ #load return by value word} mov =orvl_ wa
#
#      merge here to construct exblk
#
cdgx3:  call cdwrd          #generate return word} jsr cdwrd
        call exbld          #build exblk} jsr exbld
        pop  edx            #restore edx} mov (xs)+ wc
        ret                 #return to cdgex caller} exi
                            #end procedure cdgex} enp
                            #} ejc
        .eject
#
#      cdgnm -- generate code by name
#
#      cdgnm is called during the compilation process to
#      generate code by name for an expression. see cdblk
#      description for details of code generated. the input
#      to cdgnm is an expression tree as generated by expan.
#
#      cdgnm is a recursive procedure which proceeds by making
#      recursive calls to generate code for operands.
#
#      (wb)                  integer in range 0 le n le dnamb
#      (xr)                  ptr to tree generated by expan
#      (wc)                  constant flag (see below)
#      jsr  cdgnm            call to generate code by name
#      (xr,wa)               destroyed
#      (wc)                  set non-zero if non-constant
#
#      wc is set to a non-zero (collectable) value if the
#      expression for which code is generated cannot be
#      evaluated at compile time, otherwise wc is unchanged.
#
#      the code is generated in the current ccblk (see cdwrd).
#
cdgnm:                      #entry point, recursive} prc r 0
        .global cdgnm
        push esi            #save entry esi} mov xl -(xs)
        push ebx            #save entry ebx} mov wb -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        mov  ecx,dword ptr [edi] #load type word} mov (xr) wa
        cmp  ecx,offset b_cmt #jump if cmblk} beq wa =b_cmt cgn04
        je   cgn04
        cmp  ecx,offset b_vr_ #jump if simple variable} bhi wa =b_vr_ cgn02
        ja   short cgn02 # (jump shortened)
#
#      merge here for operand yielding value (e.g. constant)
#
cgn01:  call err_0          #} erb 212 syntax error: value used where name is required
        .byte 212
#
#      here for natural variable reference
#
cgn02:  mov  ecx,offset olvn_ #load variable load call} mov =olvn_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  ecx,edi        #copy vrblk pointer} mov xr wa
        call cdwrd          #generate vrblk pointer} jsr cdwrd
                            #} ejc
        .eject
#
#      cdgnm (continued)
#
#      here to exit with wc set correctly
#
cgn03:  pop  ebx            #restore entry ebx} mov (xs)+ wb
        pop  esi            #restore entry esi} mov (xs)+ xl
        ret                 #return to cdgnm caller} exi
#
#      here for cmblk
#
cgn04:  mov  esi,edi        #copy cmblk pointer} mov xr xl
        mov  edi,dword ptr (4*cmtyp)[edi] #load cmblk type} mov cmtyp(xr) xr
        cmp  edi,c__nm      #error if not name operand} bge xr =c__nm cgn01
        jae  cgn01
        jmp  dword ptr l0007[edi*4] #else switch on type} bsw xr c__nm
        dseg_
l0007:
        .long cgn05         #array reference} iff c_arr cgn05
        .long cgn08         #function call} iff c_fnc cgn08
        .long cgn09         #deferred expression} iff c_def cgn09
        .long cgn10         #indirect reference} iff c_ind cgn10
        .long cgn11         #keyword reference} iff c_key cgn11
        .long cgn08         #undefined binary op} iff c_ubo cgn08
        .long cgn08         #undefined unary op} iff c_uuo cgn08
        dsegend_            #end switch on cmblk type} esw
        cseg_
#
#      here to generate code for array reference
#
cgn05:  mov  ebx,4*cmopn    #point to array operand} mov *cmopn wb
#
#      loop to generate code for array operand and subscripts
#
cgn06:  call cmgen          #generate code for next operand} jsr cmgen
        mov  edx,dword ptr (4*cmlen)[esi] #load length of cmblk} mov cmlen(xl) wc
        cmp  ebx,edx        #loop till all generated} blt wb wc cgn06
        jb   cgn06
#
#      generate appropriate array call
#
        mov  ecx,offset oaon_ #load one-subscript case call} mov =oaon_ wa
        cmp  edx,4*cmar1    #jump to exit if one subscript case} beq wc *cmar1 cgn07
        je   short cgn07 # (jump shortened)
        mov  ecx,offset oamn_ #else load multi-subscript case call} mov =oamn_ wa
        call cdwrd          #generate call} jsr cdwrd
        mov  ecx,edx        #copy cmblk length} mov wc wa
        shr  ecx,2          #convert to words} btw wa
        sub  ecx,cmvls      #calculate number of subscripts} sub =cmvls wa
                            #} ejc
        .eject
#
#      cdgnm (continued)
#
#      here to exit generating word (non-constant)
#
cgn07:  mov  edx,esp        #set result non-constant} mnz wc
        call cdwrd          #generate word} jsr cdwrd
        jmp  cgn03          #back to exit} brn cgn03
#
#      here to generate code for functions and undefined oprs
#
cgn08:  mov  edi,esi        #copy cmblk pointer} mov xl xr
        call cdgvl          #gen code by value for call} jsr cdgvl
        mov  ecx,offset ofne_ #get extra call for by name} mov =ofne_ wa
        jmp  cgn07          #back to generate and exit} brn cgn07
#
#      here to generate code for defered expression
#
cgn09:  mov  edi,dword ptr (4*cmrop)[esi] #check if variable} mov cmrop(xl) xr
        cmp  dword ptr [edi],offset b_vr_ #treat *variable as simple var} bhi (xr) =b_vr_ cgn02
        ja   cgn02
        mov  esi,edi        #copy ptr to expression tree} mov xr xl
        mov  ecx,num01      #return name} mov =num01 wa
        call cdgex          #else build exblk} jsr cdgex
        mov  ecx,offset olex_ #set call to load expr by name} mov =olex_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  ecx,edi        #copy exblk pointer} mov xr wa
        call cdwrd          #generate exblk pointer} jsr cdwrd
        jmp  cgn03          #back to exit} brn cgn03
#
#      here to generate code for indirect reference
#
cgn10:  mov  edi,dword ptr (4*cmrop)[esi] #get operand} mov cmrop(xl) xr
        call cdgvl          #generate code by value for it} jsr cdgvl
        mov  ecx,offset oinn_ #load call for indirect by name} mov =oinn_ wa
        jmp  short cgn12          #merge} brn cgn12 # (jump shortened)
#
#      here to generate code for keyword reference
#
cgn11:  mov  edi,dword ptr (4*cmrop)[esi] #get operand} mov cmrop(xl) xr
        call cdgnm          #generate code by name for it} jsr cdgnm
        mov  ecx,offset okwn_ #load call for keyword by name} mov =okwn_ wa
#
#      keyword, indirect merge here
#
cgn12:  call cdwrd          #generate code for operator} jsr cdwrd
        jmp  cgn03          #exit} brn cgn03
                            #end procedure cdgnm} enp
                            #} ejc
        .eject
#
#      cdgvl -- generate code by value
#
#      cdgvl is called during the compilation process to
#      generate code by value for an expression. see cdblk
#      description for details of the code generated. the input
#      to cdgvl is an expression tree as generated by expan.
#
#      cdgvl is a recursive procedure which proceeds by making
#      recursive calls to generate code for operands.
#
#      (wb)                  integer in range 0 le n le dnamb
#      (xr)                  ptr to tree generated by expan
#      (wc)                  constant flag (see below)
#      jsr  cdgvl            call to generate code by value
#      (xr,wa)               destroyed
#      (wc)                  set non-zero if non-constant
#
#      wc is set to a non-zero (collectable) value if the
#      expression for which code is generated cannot be
#      evaluated at compile time, otherwise wc is unchanged.
#
#      if wc is non-zero on entry, then preevaluation is not
#      allowed regardless of the nature of the operand.
#
#      the code is generated in the current ccblk (see cdwrd).
#
cdgvl:                      #entry point, recursive} prc r 0
        .global cdgvl
        mov  ecx,dword ptr [edi] #load type word} mov (xr) wa
        cmp  ecx,offset b_cmt #jump if cmblk} beq wa =b_cmt cgv01
        je   cgv01
        cmp  ecx,offset b_vra #jump if icblk, rcblk, scblk} blt wa =b_vra cgv00
        jb   short cgv00 # (jump shortened)
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #jump if not system variable} bnz vrlen(xr) cgvl0
        jnz  short cgvl0 # (jump shortened)
        push edi            #stack edi} mov xr -(xs)
        mov  edi,dword ptr (4*vrsvp)[edi] #point to svblk} mov vrsvp(xr) xr
        mov  ecx,dword ptr (4*svbit)[edi] #get svblk property bits} mov svbit(xr) wa
        pop  edi            #recover edi} mov (xs)+ xr
        and  ecx,dword ptr btkwv #check if constant keyword value} anb btkwv wa
        cmp  ecx,dword ptr btkwv #jump if constant keyword value} beq wa btkwv cgv00
        je   short cgv00 # (jump shortened)
#
#      here for variable value reference
#
cgvl0:  mov  edx,esp        #indicate non-constant value} mnz wc
#
#      merge here for simple constant (icblk,rcblk,scblk)
#      and for variables corresponding to constant keywords.
#
cgv00:  mov  ecx,edi        #copy ptr to var or constant} mov xr wa
        call cdwrd          #generate as code word} jsr cdwrd
        ret                 #return to caller} exi
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here for tree node (cmblk)
#
cgv01:  push ebx            #save entry ebx} mov wb -(xs)
        push esi            #save entry esi} mov xl -(xs)
        push edx            #save entry constant flag} mov wc -(xs)
        push dword ptr cwcof #save initial code offset} mov cwcof -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
#
#      prepare to generate code for cmblk. wc is set to the
#      value of cswno (zero if -optimise, 1 if -noopt) to
#      start with and is reset non-zero for any non-constant
#      code generated. if it is still zero after generating all
#      the cmblk code, then its value is computed as the result.
#
        mov  esi,edi        #copy cmblk pointer} mov xr xl
        mov  edi,dword ptr (4*cmtyp)[edi] #load cmblk type} mov cmtyp(xr) xr
        mov  edx,dword ptr cswno #reset constant flag} mov cswno wc
        cmp  edi,c_pr_      #jump if not predicate value} ble xr =c_pr_ cgv02
        jbe  short cgv02 # (jump shortened)
        mov  edx,esp        #else force non-constant case} mnz wc
#
#      here with wc set appropriately
#
cgv02:  jmp  dword ptr l0008[edi*4] #switch to appropriate generator} bsw xr c__nv
        dseg_
l0008:
        .long cgv03         #array reference} iff c_arr cgv03
        .long cgv05         #function call} iff c_fnc cgv05
        .long cgv14         #deferred expression} iff c_def cgv14
        .long cgv31         #indirect reference} iff c_ind cgv31
        .long cgv27         #keyword reference} iff c_key cgv27
        .long cgv29         #undefined binop} iff c_ubo cgv29
        .long cgv30         #undefined unop} iff c_uuo cgv30
        .long cgv18         #binops with val opds} iff c_bvl cgv18
        .long cgv19         #unops with valu opnd} iff c_uvl cgv19
        .long cgv18         #alternation} iff c_alt cgv18
        .long cgv24         #concatenation} iff c_cnc cgv24
        .long cgv24         #concatenation (not pattern match)} iff c_cnp cgv24
        .long cgv27         #unops with name opnd} iff c_unm cgv27
        .long cgv26         #binary _ and .} iff c_bvn cgv26
        .long cgv21         #assignment} iff c_ass cgv21
        .long cgv31         #interrogation} iff c_int cgv31
        .long cgv28         #negation} iff c_neg cgv28
        .long cgv15         #selection} iff c_sel cgv15
        .long cgv18         #pattern match} iff c_pmt cgv18
        dsegend_            #end switch on cmblk type} esw
        cseg_
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here to generate code for array reference
#
cgv03:  mov  ebx,4*cmopn    #set offset to array operand} mov *cmopn wb
#
#      loop to generate code for array operand and subscripts
#
cgv04:  call cmgen          #gen value code for next operand} jsr cmgen
        mov  edx,dword ptr (4*cmlen)[esi] #load cmblk length} mov cmlen(xl) wc
        cmp  ebx,edx        #loop back if more to go} blt wb wc cgv04
        jb   cgv04
#
#      generate call to appropriate array reference routine
#
        mov  ecx,offset oaov_ #set one subscript call in case} mov =oaov_ wa
        cmp  edx,4*cmar1    #jump to exit if 1-sub case} beq wc *cmar1 cgv32
        je   cgv32
        mov  ecx,offset oamv_ #else set call for multi-subscripts} mov =oamv_ wa
        call cdwrd          #generate call} jsr cdwrd
        mov  ecx,edx        #copy length of cmblk} mov wc wa
        sub  ecx,4*cmvls    #subtract standard length} sub *cmvls wa
        shr  ecx,2          #get number of words} btw wa
        jmp  cgv32          #jump to generate subscript count} brn cgv32
#
#      here to generate code for function call
#
cgv05:  mov  ebx,4*cmvls    #set offset to first argument} mov *cmvls wb
#
#      loop to generate code for arguments
#
cgv06:  cmp  ebx,dword ptr (4*cmlen)[esi] #jump if all generated} beq wb cmlen(xl) cgv07
        je   short cgv07 # (jump shortened)
        call cmgen          #else gen value code for next arg} jsr cmgen
        jmp  cgv06          #back to generate next argument} brn cgv06
#
#      here to generate actual function call
#
cgv07:  sub  ebx,4*cmvls    #get number of arg ptrs (bytes)} sub *cmvls wb
        shr  ebx,2          #convert bytes to words} btw wb
        mov  edi,dword ptr (4*cmopn)[esi] #load function vrblk pointer} mov cmopn(xl) xr
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #jump if not system function} bnz vrlen(xr) cgv12
        jnz  cgv12
        mov  esi,dword ptr (4*vrsvp)[edi] #load svblk ptr if system var} mov vrsvp(xr) xl
        mov  ecx,dword ptr (4*svbit)[esi] #load bit mask} mov svbit(xl) wa
        and  ecx,dword ptr btffc #test for fast function call allowed} anb btffc wa
#        or   ecx,ecx        #jump if not} zrb wa cgv12  (optimized)
        jz   cgv12
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here if fast function call is allowed
#
        mov  ecx,dword ptr (4*svbit)[esi] #reload bit indicators} mov svbit(xl) wa
        and  ecx,dword ptr btpre #test for preevaluation ok} anb btpre wa
#        or   ecx,ecx        #jump if preevaluation permitted} nzb wa cgv08  (optimized)
        jnz  short cgv08 # (jump shortened)
        mov  edx,esp        #else set result non-constant} mnz wc
#
#      test for correct number of args for fast call
#
cgv08:  mov  esi,dword ptr (4*vrfnc)[edi] #load ptr to svfnc field} mov vrfnc(xr) xl
        mov  ecx,dword ptr (4*fargs)[esi] #load svnar field value} mov fargs(xl) wa
        cmp  ecx,ebx        #jump if argument count is correct} beq wa wb cgv11
        je   short cgv11 # (jump shortened)
        cmp  ecx,ebx        #jump if too few arguments given} bhi wa wb cgv09
        ja   short cgv09 # (jump shortened)
#
#      here if too many arguments, prepare to generate o$pops
#
        sub  ebx,ecx        #get number of extra args} sub wa wb
        mov  ecx,offset opop_ #set pop call} mov =opop_ wa
        jmp  short cgv10          #jump to common loop} brn cgv10 # (jump shortened)
#
#      here if too few arguments, prepare to generate nulls
#
cgv09:  sub  ecx,ebx        #get number of missing arguments} sub wb wa
        mov  ebx,ecx        #load as count to control loop} lct wb wa
        mov  ecx,offset nulls #load ptr to null constant} mov =nulls wa
#
#      loop to generate calls to fix argument count
#
cgv10:  call cdwrd          #generate one call} jsr cdwrd
        dec  ebx            #loop till all generated} bct wb cgv10
        jnz  cgv10
#
#      here after adjusting arg count as required
#
cgv11:  mov  ecx,esi        #copy pointer to svfnc field} mov xl wa
        jmp  cgv36          #jump to generate call} brn cgv36
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      come here if fast call is not permitted
#
cgv12:  mov  ecx,offset ofns_ #set one arg call in case} mov =ofns_ wa
        cmp  ebx,num01      #jump if one arg case} beq wb =num01 cgv13
        je   short cgv13 # (jump shortened)
        mov  ecx,offset ofnc_ #else load call for more than 1 arg} mov =ofnc_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  ecx,ebx        #copy argument count} mov wb wa
#
#      one arg case merges here
#
cgv13:  call cdwrd          #generate =o_fns or arg count} jsr cdwrd
        mov  ecx,edi        #copy vrblk pointer} mov xr wa
        jmp  cgv32          #jump to generate vrblk ptr} brn cgv32
#
#      here for deferred expression
#
cgv14:  mov  esi,dword ptr (4*cmrop)[esi] #point to expression tree} mov cmrop(xl) xl
        xor  ecx,ecx        #return value} zer wa
        call cdgex          #build exblk or seblk} jsr cdgex
        mov  ecx,edi        #copy block ptr} mov xr wa
        call cdwrd          #generate ptr to exblk or seblk} jsr cdwrd
        jmp  cgv34          #jump to exit, constant test} brn cgv34
#
#      here to generate code for selection
#
cgv15:  push 0              #zero ptr to chain of forward jumps} zer -(xs)
        push 0              #zero ptr to prev o_slc forward ptr} zer -(xs)
        mov  ebx,4*cmvls    #point to first alternative} mov *cmvls wb
        mov  ecx,offset osla_ #set initial code word} mov =osla_ wa
#
#      0(xs)                 is the offset to the previous word
#                            which requires filling in with an
#                            offset to the following o$slc,o$sld
#
#      1(xs)                 is the head of a chain of offset
#                            pointers indicating those locations
#                            to be filled with offsets past
#                            the end of all the alternatives
#
cgv16:  call cdwrd          #generate o_slc (o_sla first time)} jsr cdwrd
        mov  eax,dword ptr cwcof #set current loc as ptr to fill in} mov cwcof (xs)
        mov  dword ptr [esp],eax
        call cdwrd          #generate garbage word there for now} jsr cdwrd
        call cmgen          #gen value code for alternative} jsr cmgen
        mov  ecx,offset oslb_ #load o_slb pointer} mov =oslb_ wa
        call cdwrd          #generate o_slb call} jsr cdwrd
        mov  ecx,dword ptr (4*num01)[esp] #load old chain ptr} mov num01(xs) wa
        mov  eax,dword ptr cwcof #set current loc as new chain head} mov cwcof num01(xs)
        mov  dword ptr (4*num01)[esp],eax
        call cdwrd          #generate forward chain link} jsr cdwrd
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      now to fill in the skip offset to o$slc,o$sld
#
        mov  edi,dword ptr [esp] #load offset to word to plug} mov (xs) xr
        add  edi,dword ptr r_ccb #point to actual location to plug} add r_ccb xr
        mov  eax,dword ptr cwcof #plug proper offset in} mov cwcof (xr)
        mov  dword ptr [edi],eax
        mov  ecx,offset oslc_ #load o_slc ptr for next alternative} mov =oslc_ wa
        mov  edi,ebx        #copy offset (destroy garbage edi)} mov wb xr
        add  edi,4          #bump extra time for test} ica xr
        cmp  edi,dword ptr (4*cmlen)[esi] #loop back if not last alternative} blt xr cmlen(xl) cgv16
        jb   cgv16
#
#      here to generate code for last alternative
#
        mov  ecx,offset osld_ #get header call} mov =osld_ wa
        call cdwrd          #generate o_sld call} jsr cdwrd
        call cmgen          #generate code for last alternative} jsr cmgen
        add  esp,4          #pop offset ptr} ica xs
        pop  edi            #load chain ptr} mov (xs)+ xr
#
#      loop to plug offsets past structure
#
cgv17:  add  edi,dword ptr r_ccb #make next ptr absolute} add r_ccb xr
        mov  ecx,dword ptr [edi] #load forward ptr} mov (xr) wa
        mov  eax,dword ptr cwcof #plug required offset} mov cwcof (xr)
        mov  dword ptr [edi],eax
        mov  edi,ecx        #copy forward ptr} mov wa xr
        or   ecx,ecx        #loop back if more to go} bnz wa cgv17
        jnz  cgv17
        jmp  cgv33          #else jump to exit (not constant)} brn cgv33
#
#      here for binary ops with value operands
#
cgv18:  mov  edi,dword ptr (4*cmlop)[esi] #load left operand pointer} mov cmlop(xl) xr
        call cdgvl          #gen value code for left operand} jsr cdgvl
#
#      here for unary ops with value operand (binops merge)
#
cgv19:  mov  edi,dword ptr (4*cmrop)[esi] #load right (only) operand ptr} mov cmrop(xl) xr
        call cdgvl          #gen code by value} jsr cdgvl
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      merge here to generate operator call from cmopn field
#
cgv20:  mov  ecx,dword ptr (4*cmopn)[esi] #load operator call pointer} mov cmopn(xl) wa
        jmp  cgv36          #jump to generate it with cons test} brn cgv36
#
#      here for assignment
#
cgv21:  mov  edi,dword ptr (4*cmlop)[esi] #load left operand pointer} mov cmlop(xl) xr
        cmp  dword ptr [edi],offset b_vr_ #jump if not variable} blo (xr) =b_vr_ cgv22
        jb   short cgv22 # (jump shortened)
#
#      here for assignment to simple variable
#
        mov  edi,dword ptr (4*cmrop)[esi] #load right operand ptr} mov cmrop(xl) xr
        call cdgvl          #generate code by value} jsr cdgvl
        mov  ecx,dword ptr (4*cmlop)[esi] #reload left operand vrblk ptr} mov cmlop(xl) wa
        add  ecx,4*vrsto    #point to vrsto field} add *vrsto wa
        jmp  cgv32          #jump to generate store ptr} brn cgv32
#
#      here if not simple variable assignment
#
cgv22:  call expap          #test for pattern match on left side} jsr expap
        .short cgv23-dffnc  #jump if not pattern match} ppm cgv23
#
#      here for pattern replacement
#
        mov  eax,dword ptr (4*cmrop)[edi] #save pattern ptr in safe place} mov cmrop(xr) cmlop(xl)
        mov  dword ptr (4*cmlop)[esi],eax
        mov  edi,dword ptr (4*cmlop)[edi] #load subject ptr} mov cmlop(xr) xr
        call cdgnm          #gen code by name for subject} jsr cdgnm
        mov  edi,dword ptr (4*cmlop)[esi] #load pattern ptr} mov cmlop(xl) xr
        call cdgvl          #gen code by value for pattern} jsr cdgvl
        mov  ecx,offset opmn_ #load match by name call} mov =opmn_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  edi,dword ptr (4*cmrop)[esi] #load replacement value ptr} mov cmrop(xl) xr
        call cdgvl          #gen code by value} jsr cdgvl
        mov  ecx,offset orpl_ #load replace call} mov =orpl_ wa
        jmp  cgv32          #jump to gen and exit (not constant)} brn cgv32
#
#      here for assignment to complex variable
#
cgv23:  mov  edx,esp        #inhibit pre-evaluation} mnz wc
        call cdgnm          #gen code by name for left side} jsr cdgnm
        jmp  cgv31          #merge with unop circuit} brn cgv31
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here for concatenation
#
cgv24:  mov  edi,dword ptr (4*cmlop)[esi] #load left operand ptr} mov cmlop(xl) xr
        cmp  dword ptr [edi],offset b_cmt #ordinary binop if not cmblk} bne (xr) =b_cmt cgv18
        jne  cgv18
        mov  ebx,dword ptr (4*cmtyp)[edi] #load cmblk type code} mov cmtyp(xr) wb
        cmp  ebx,c_int      #special case if interrogation} beq wb =c_int cgv25
        je   short cgv25 # (jump shortened)
        cmp  ebx,c_neg      #or negation} beq wb =c_neg cgv25
        je   short cgv25 # (jump shortened)
        cmp  ebx,c_fnc      #else ordinary binop if not function} bne wb =c_fnc cgv18
        jne  cgv18
        mov  edi,dword ptr (4*cmopn)[edi] #else load function vrblk ptr} mov cmopn(xr) xr
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #ordinary binop if not system var} bnz vrlen(xr) cgv18
        jnz  cgv18
        mov  edi,dword ptr (4*vrsvp)[edi] #else point to svblk} mov vrsvp(xr) xr
        mov  ecx,dword ptr (4*svbit)[edi] #load bit indicators} mov svbit(xr) wa
        and  ecx,dword ptr btprd #test for predicate function} anb btprd wa
#        or   ecx,ecx        #ordinary binop if not} zrb wa cgv18  (optimized)
        jz   cgv18
#
#      here if left arg of concatenation is predicate function
#
cgv25:  mov  edi,dword ptr (4*cmlop)[esi] #reload left arg} mov cmlop(xl) xr
        call cdgvl          #gen code by value} jsr cdgvl
        mov  ecx,offset opop_ #load pop call} mov =opop_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  edi,dword ptr (4*cmrop)[esi] #load right operand} mov cmrop(xl) xr
        call cdgvl          #gen code by value as result code} jsr cdgvl
        jmp  cgv33          #exit (not constant)} brn cgv33
#
#      here to generate code for pattern, immediate assignment
#
cgv26:  mov  edi,dword ptr (4*cmlop)[esi] #load left operand} mov cmlop(xl) xr
        call cdgvl          #gen code by value, merge} jsr cdgvl
#
#      here for unops with arg by name (binary $ . merge)
#
cgv27:  mov  edi,dword ptr (4*cmrop)[esi] #load right operand ptr} mov cmrop(xl) xr
        call cdgnm          #gen code by name for right arg} jsr cdgnm
        mov  edi,dword ptr (4*cmopn)[esi] #get operator code word} mov cmopn(xl) xr
        cmp  dword ptr [edi],offset o_kwv #gen call unless keyword value} bne (xr) =o_kwv cgv20
        jne  cgv20
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here for keyword by value. this is constant only if
#      the operand is one of the special system variables with
#      the svckw bit set to indicate a constant keyword value.
#      note that the only constant operand by name is a variable
#
        or   edx,edx        #gen call if non-constant (not var)} bnz wc cgv20
        jnz  cgv20
        mov  edx,esp        #else set non-constant in case} mnz wc
        mov  edi,dword ptr (4*cmrop)[esi] #load ptr to operand vrblk} mov cmrop(xl) xr
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #gen (non-constant) if not sys var} bnz vrlen(xr) cgv20
        jnz  cgv20
        mov  edi,dword ptr (4*vrsvp)[edi] #else load ptr to svblk} mov vrsvp(xr) xr
        mov  ecx,dword ptr (4*svbit)[edi] #load bit mask} mov svbit(xr) wa
        and  ecx,dword ptr btckw #test for constant keyword} anb btckw wa
#        or   ecx,ecx        #go gen if not constant} zrb wa cgv20  (optimized)
        jz   cgv20
        xor  edx,edx        #else set result constant} zer wc
        jmp  cgv20          #and jump back to generate call} brn cgv20
#
#      here to generate code for negation
#
cgv28:  mov  ecx,offset onta_ #get initial word} mov =onta_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  ebx,dword ptr cwcof #save next offset} mov cwcof wb
        call cdwrd          #generate gunk word for now} jsr cdwrd
        mov  edi,dword ptr (4*cmrop)[esi] #load right operand ptr} mov cmrop(xl) xr
        call cdgvl          #gen code by value} jsr cdgvl
        mov  ecx,offset ontb_ #load end of evaluation call} mov =ontb_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  edi,ebx        #copy offset to word to plug} mov wb xr
        add  edi,dword ptr r_ccb #point to actual word to plug} add r_ccb xr
        mov  eax,dword ptr cwcof #plug word with current offset} mov cwcof (xr)
        mov  dword ptr [edi],eax
        mov  ecx,offset ontc_ #load final call} mov =ontc_ wa
        jmp  cgv32          #jump to generate it (not constant)} brn cgv32
#
#      here to generate code for undefined binary operator
#
cgv29:  mov  edi,dword ptr (4*cmlop)[esi] #load left operand ptr} mov cmlop(xl) xr
        call cdgvl          #generate code by value} jsr cdgvl
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here to generate code for undefined unary operator
#
cgv30:  mov  ebx,c_uo_      #set unop code + 1} mov =c_uo_ wb
        sub  ebx,dword ptr (4*cmtyp)[esi] #set number of args (1 or 2)} sub cmtyp(xl) wb
#
#      merge here for undefined operators
#
        mov  edi,dword ptr (4*cmrop)[esi] #load right (only) operand pointer} mov cmrop(xl) xr
        call cdgvl          #gen value code for right operand} jsr cdgvl
        mov  edi,dword ptr (4*cmopn)[esi] #load pointer to operator dv} mov cmopn(xl) xr
        mov  edi,dword ptr (4*dvopn)[edi] #load pointer offset} mov dvopn(xr) xr
        sal  edi,2          #convert word offset to bytes} wtb xr
        add  edi,offset r_uba #point to proper function ptr} add =r_uba xr
        sub  edi,4*vrfnc    #set standard function offset} sub *vrfnc xr
        jmp  cgv12          #merge with function call circuit} brn cgv12
#
#      here to generate code for interrogation, indirection
#
cgv31:  mov  edx,esp        #set non constant} mnz wc
        jmp  cgv19          #merge} brn cgv19
#
#      here to exit generating a word, result not constant
#
cgv32:  call cdwrd          #generate word, merge} jsr cdwrd
#
#      here to exit with no word generated, not constant
#
cgv33:  mov  edx,esp        #indicate result is not constant} mnz wc
#
#      common exit point
#
cgv34:  add  esp,4          #pop initial code offset} ica xs
        pop  ecx            #restore old constant flag} mov (xs)+ wa
        pop  esi            #restore entry esi} mov (xs)+ xl
        pop  ebx            #restore entry ebx} mov (xs)+ wb
        or   edx,edx        #jump if not constant} bnz wc cgv35
        jnz  short cgv35 # (jump shortened)
        mov  edx,ecx        #else restore entry constant flag} mov wa wc
#
#      here to return after dealing with wc setting
#
cgv35:  ret                 #return to cdgvl caller} exi
#
#      exit here to generate word and test for constant
#
cgv36:  call cdwrd          #generate word} jsr cdwrd
        or   edx,edx        #jump to exit if not constant} bnz wc cgv34
        jnz  cgv34
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here to preevaluate constant sub-expression
#
        mov  ecx,offset orvl_ #load call to return value} mov =orvl_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  esi,dword ptr [esp] #load initial code offset} mov (xs) xl
        call exbld          #build exblk for expression} jsr exbld
        xor  ebx,ebx        #set to evaluate by value} zer wb
        call evalx          #evaluate expression} jsr evalx
        .short err_-299-dffnc #should not fail} ppm
        mov  ecx,dword ptr [edi] #load type word of result} mov (xr) wa
        cmp  ecx,offset p_aaa #jump if not pattern} blo wa =p_aaa cgv37
        jb   short cgv37 # (jump shortened)
        mov  ecx,offset olpt_ #else load special pattern load call} mov =olpt_ wa
        call cdwrd          #generate it} jsr cdwrd
#
#      merge here to generate pointer to resulting constant
#
cgv37:  mov  ecx,edi        #copy constant pointer} mov xr wa
        call cdwrd          #generate ptr} jsr cdwrd
        xor  edx,edx        #set result constant} zer wc
        jmp  cgv34          #jump back to exit} brn cgv34
                            #end procedure cdgvl} enp
                            #} ejc
        .eject
#
#      cdwrd -- generate one word of code
#
#      cdwrd writes one word into the current code block under
#      construction. a new, larger, block is allocated if there
#      is insufficient room in the current block. cdwrd ensures
#      that there are at least four words left in the block
#      after entering the new word. this guarantees that any
#      extra space at the end can be split off as a ccblk.
#
#      (wa)                  word to be generated
#      jsr  cdwrd            call to generate word
#
cdwrd:                      #entry point} prc e 0
        .global cdwrd
        push edi            #save entry edi} mov xr -(xs)
        push ecx            #save code word to be generated} mov wa -(xs)
#
#      merge back here after allocating larger block
#
cdwd1:  mov  edi,dword ptr r_ccb #load ptr to ccblk being built} mov r_ccb xr
        or   edi,edi        #jump if block allocated} bnz xr cdwd2
        jnz  short cdwd2 # (jump shortened)
#
#      here we allocate an entirely fresh block
#
        mov  ecx,4*e_cbs    #load initial length} mov *e_cbs wa
        call alloc          #allocate ccblk} jsr alloc
        mov  dword ptr [edi],offset b_cct #store type word} mov =b_cct (xr)
        mov  dword ptr cwcof,4*cccod #set initial offset} mov *cccod cwcof
        mov  dword ptr (4*cclen)[edi],ecx #store block length} mov wa cclen(xr)
        xor  eax,eax        #zero line number} zer ccsln(xr)
        mov  dword ptr (4*ccsln)[edi],eax
        mov  dword ptr r_ccb,edi #store ptr to new block} mov xr r_ccb
#
#      here we have a block we can use
#
cdwd2:  mov  ecx,dword ptr cwcof #load current offset} mov cwcof wa
        add  ecx,4*num05    #adjust for test (five words)} add *num05 wa
        cmp  ecx,dword ptr (4*cclen)[edi] #jump if room in this block} blo wa cclen(xr) cdwd4
        jb   cdwd4
#
#      here if no room in current block
#
        cmp  ecx,dword ptr mxlen #jump if already at max size} bge wa mxlen cdwd5
        jae  cdwd5
        add  ecx,4*e_cbs    #else get new size} add *e_cbs wa
        push esi            #save entry esi} mov xl -(xs)
        mov  esi,edi        #copy pointer} mov xr xl
        cmp  ecx,dword ptr mxlen #jump if not too large} blt wa mxlen cdwd3
        jb   short cdwd3 # (jump shortened)
        mov  ecx,dword ptr mxlen #else reset to max allowed size} mov mxlen wa
                            #} ejc
        .eject
#
#      cdwrd (continued)
#
#      here with new block size in wa
#
cdwd3:  call alloc          #allocate new block} jsr alloc
        mov  dword ptr r_ccb,edi #store pointer to new block} mov xr r_ccb
        mov  eax,offset b_cct #store type word in new block} mov =b_cct (xr)+
        stosd
        mov  eax,ecx        #store block length} mov wa (xr)+
        stosd
        mov  eax,dword ptr (4*ccsln)[esi] #copy source line number word} mov ccsln(xl) (xr)+
        stosd
        add  esi,4*ccuse    #point to ccuse,cccod fields in old} add *ccuse xl
        mov  ecx,dword ptr [esi] #load ccuse value} mov (xl) wa
        shr  ecx,2          #copy useful words from old block} mvw
        rep  movsd
        pop  esi            #restore esi} mov (xs)+ xl
        jmp  cdwd1          #merge back to try again} brn cdwd1
#
#      here with room in current block
#
cdwd4:  mov  ecx,dword ptr cwcof #load current offset} mov cwcof wa
        add  ecx,4          #get new offset} ica wa
        mov  dword ptr cwcof,ecx #store new offset} mov wa cwcof
        mov  dword ptr (4*ccuse)[edi],ecx #store in ccblk for gbcol} mov wa ccuse(xr)
        sub  ecx,4          #restore ptr to this word} dca wa
        add  edi,ecx        #point to current entry} add wa xr
        pop  ecx            #reload word to generate} mov (xs)+ wa
        mov  dword ptr [edi],ecx #store word in block} mov wa (xr)
        pop  edi            #restore entry edi} mov (xs)+ xr
        ret                 #return to caller} exi
#
#      here if compiled code is too long for cdblk
#
cdwd5:  call err_0          #} erb 213 syntax error: statement is too complicated.
        .byte 213
                            #end procedure cdwrd} enp
                            #} ejc
        .eject
#
#      cmgen -- generate code for cmblk ptr
#
#      cmgen is a subsidiary procedure used to generate value
#      code for a cmblk ptr from the main code generators.
#
#      (xl)                  cmblk pointer
#      (wb)                  offset to pointer in cmblk
#      jsr  cmgen            call to generate code
#      (xr,wa)               destroyed
#      (wb)                  bumped by one word
#
cmgen:                      #entry point, recursive} prc r 0
        .global cmgen
        mov  edi,esi        #copy cmblk pointer} mov xl xr
        add  edi,ebx        #point to cmblk pointer} add wb xr
        mov  edi,dword ptr [edi] #load cmblk pointer} mov (xr) xr
        call cdgvl          #generate code by value} jsr cdgvl
        add  ebx,4          #bump offset} ica wb
        ret                 #return to caller} exi
                            #end procedure cmgen} enp
                            #} ejc
        .eject
#
#      cmpil (compile source code)
#
#      cmpil is used to convert snobol4 source code to internal
#      form (see cdblk format). it is used both for the initial
#      compile and at run time by the code and convert functions
#      this procedure has control for the entire duration of
#      initial compilation. an error in any procedure called
#      during compilation will lead first to the error section
#      and ultimately back here for resumed compilation. the
#      re-entry points after an error are specially labelled -
#
#      cmpce                 resume after control card error
#      cmple                 resume after label error
#      cmpse                 resume after statement error
#
#      jsr  cmpil            call to compile code
#      (xr)                  ptr to cdblk for entry statement
#      (xl,wa,wb,wc,ra)      destroyed
#
#      the following global variables are referenced
#
#      cmpln                 line number of first line of
#                            statement to be compiled
#
#      cmpsn                 number of next statement
#                            to be compiled.
#
#      cswxx                 control card switch values are
#                            changed when relevant control
#                            cards are met.
#
#      cwcof                 offset to next word in code block
#                            being built (see cdwrd).
#
#      lstsn                 number of statement most recently
#                            compiled (initially set to zero).
#
#      r$cim                 current (initial) compiler image
#                            (zero for initial compile call)
#
#      r$cni                 used to point to following image.
#                            (see readr procedure).
#
#      scngo                 goto switch for scane procedure
#
#      scnil                 length of current image excluding
#                            characters removed by -input.
#
#      scnpt                 current scan offset, see scane.
#
#      scnrs                 rescan switch for scane procedure.
#
#      scnse                 offset (in r$cim) of most recently
#                            scanned element. set zero if not
#                            currently scanning items
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      stage               stgic  initial compile in progress
#                          stgxc  code/convert compile
#                          stgev  building exblk for eval
#                          stgxt  execute time (outside compile)
#                          stgce  initial compile after end line
#                          stgxe  execute compile after end line
#
#      cmpil also uses a fixed number of locations on the
#      main stack as follows. (the definitions of the actual
#      offsets are in the definitions section).
#
#      cmstm(xs)             pointer to expan tree for body of
#                            statement (see expan procedure).
#
#      cmsgo(xs)             pointer to tree representation of
#                            success goto (see procedure scngo)
#                            zero if no success goto is given
#
#      cmfgo(xs)             like cmsgo for failure goto.
#
#      cmcgo(xs)             set non-zero only if there is a
#                            conditional goto. used for -fail,
#                            -nofail code generation.
#
#      cmpcd(xs)             pointer to cdblk for previous
#                            statement. zero for 1st statement.
#
#      cmffp(xs)             set non-zero if cdfal in previous
#                            cdblk needs filling with forward
#                            pointer, else set to zero.
#
#      cmffc(xs)             same as cmffp for current cdblk
#
#      cmsop(xs)             offset to word in previous cdblk
#                            to be filled in with forward ptr
#                            to next cdblk for success goto.
#                            zero if no fill in is required.
#
#      cmsoc(xs)             same as cmsop for current cdblk.
#
#      cmlbl(xs)             pointer to vrblk for label of
#                            current statement. zero if no label
#
#      cmtra(xs)             pointer to cdblk for entry stmnt.
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      entry point
#
cmpil:                      #entry point} prc e 0
        .global cmpil
        mov  ebx,cmnen      #set number of stack work locations} lct wb =cmnen
#
#      loop to initialize stack working locations
#
cmp00:  push 0              #store a zero, make one entry} zer -(xs)
        dec  ebx            #loop back until all set} bct wb cmp00
        jnz  cmp00
        mov  dword ptr cmpxs,esp #save stack pointer for error sec} mov xs cmpxs
                            #save s-r stack pointer if any} sss cmpss
#
#      loop through statements
#
cmp01:  mov  ebx,dword ptr scnpt #set scan pointer offset} mov scnpt wb
        mov  dword ptr scnse,ebx #set start of element location} mov wb scnse
        mov  ecx,offset ocer_ #point to compile error call} mov =ocer_ wa
        call cdwrd          #generate as temporary cdfal} jsr cdwrd
        cmp  ebx,dword ptr scnil #jump if chars left on this image} blt wb scnil cmp04
        jb   cmp04
#
#      loop here after comment or control card
#      also special entry after control card error
#
cmpce:  xor  edi,edi        #clear possible garbage edi value} zer xr
        cmp  dword ptr dword ptr cnind,0 #if within include file} bnz cnind cmpc2
        jnz  short cmpc2 # (jump shortened)
        cmp  dword ptr stage,stgic #skip unless initial compile} bne stage =stgic cmp02
        jne  short cmp02 # (jump shortened)
cmpc2:  call readr          #read next input image} jsr readr
        or   edi,edi        #jump if no input available} bze xr cmp09
        jz   cmp09
        call nexts          #acquire next source image} jsr nexts
        mov  eax,dword ptr cmpsn #store stmt no for use by listr} mov cmpsn lstsn
        mov  dword ptr lstsn,eax
        mov  eax,dword ptr rdcln #store line number at start of stmt} mov rdcln cmpln
        mov  dword ptr cmpln,eax
        xor  eax,eax        #reset scan pointer} zer scnpt
        mov  dword ptr scnpt,eax
        jmp  cmp04          #go process image} brn cmp04
#
#      for execute time compile, permit embedded control cards
#      and comments (by skipping to next semi-colon)
#
cmp02:  mov  edi,dword ptr r_cim #get current image} mov r_cim xr
        mov  ebx,dword ptr scnpt #get current offset} mov scnpt wb
        lea  edi,[cfp_f+edi+ebx] #prepare to get chars} plc xr wb
#
#      skip to semi-colon
#
cmp03:  mov  eax,dword ptr scnpt #end loop if end of image} bge scnpt scnil cmp09
        cmp  eax,dword ptr scnil
        jae  cmp09
        movzx edx,byte ptr [edi] #get char} lch wc (xr)+
        inc  edi
        inc  dword ptr scnpt #advance offset} icv scnpt
        cmp  edx,ch_sm      #loop if not semi-colon} bne wc =ch_sm cmp03
        jne  cmp03
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here with image available to scan. note that if the input
#      string is null, then everything is ok since null is
#      actually assembled as a word of blanks.
#
cmp04:  mov  edi,dword ptr r_cim #point to current image} mov r_cim xr
        mov  ebx,dword ptr scnpt #load current offset} mov scnpt wb
        mov  ecx,ebx        #copy for label scan} mov wb wa
        lea  edi,[cfp_f+edi+ebx] #point to first character} plc xr wb
        movzx edx,byte ptr [edi] #load first character} lch wc (xr)+
        inc  edi
        cmp  edx,ch_sm      #no label if semicolon} beq wc =ch_sm cmp12
        je   cmp12
        cmp  edx,ch_as      #loop back if comment card} beq wc =ch_as cmpce
        je   cmpce
        cmp  edx,ch_mn      #jump if control card} beq wc =ch_mn cmp32
        je   cmp32
        mov  eax,dword ptr r_cim #about to destroy r_cim} mov r_cim r_cmp
        mov  dword ptr r_cmp,eax
        mov  esi,offset cmlab #point to label work string} mov =cmlab xl
        mov  dword ptr r_cim,esi #scane is to scan work string} mov xl r_cim
        add  esi,cfp_f      #point to first character position} psc xl
        mov  [esi],dl       #store char just loaded} sch wc (xl)+
        inc  esi
        mov  edx,ch_sm      #get a semicolon} mov =ch_sm wc
        mov  [esi],dl       #store after first char} sch wc (xl)
        xor  esi,esi        #clear pointer} zer xl
        xor  eax,eax        #start at first character} zer scnpt
        mov  dword ptr scnpt,eax
        push dword ptr scnil #preserve image length} mov scnil -(xs)
        mov  dword ptr scnil,num02 #read 2 chars at most} mov =num02 scnil
        call scane          #scan first char for type} jsr scane
        pop  dword ptr scnil #restore image length} mov (xs)+ scnil
        mov  edx,esi        #note return code} mov xl wc
        mov  esi,dword ptr r_cmp #get old r_cim} mov r_cmp xl
        mov  dword ptr r_cim,esi #put it back} mov xl r_cim
        mov  dword ptr scnpt,ebx #reinstate offset} mov wb scnpt
        cmp  dword ptr dword ptr scnbl,0 #blank seen - cant be label} bnz scnbl cmp12
        jnz  cmp12
        mov  edi,esi        #point to current image} mov xl xr
        lea  edi,[cfp_f+edi+ebx] #point to first char again} plc xr wb
        cmp  edx,t_var      #ok if letter} beq wc =t_var cmp06
        je   short cmp06 # (jump shortened)
        cmp  edx,t_con      #ok if digit} beq wc =t_con cmp06
        je   short cmp06 # (jump shortened)
#
#      drop in or jump from error section if scane failed
#
cmple:  mov  eax,dword ptr r_cmp #point to bad line} mov r_cmp r_cim
        mov  dword ptr r_cim,eax
        call err_0          #} erb 214 bad label or misplaced continuation line
        .byte 214
#
#      loop to scan label
#
cmp05:  cmp  edx,ch_sm      #skip if semicolon} beq wc =ch_sm cmp07
        je   short cmp07 # (jump shortened)
        inc  ecx            #bump offset} icv wa
        cmp  ecx,dword ptr scnil #jump if end of image (label end)} beq wa scnil cmp07
        je   short cmp07 # (jump shortened)
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      enter loop at this point
#
cmp06:  movzx edx,byte ptr [edi] #else load next character} lch wc (xr)+
        inc  edi
        cmp  edx,ch_ht      #jump if horizontal tab} beq wc =ch_ht cmp07
        je   short cmp07 # (jump shortened)
        cmp  edx,ch_bl      #loop back if non-blank} bne wc =ch_bl cmp05
        jne  cmp05
#
#      here after scanning out label
#
cmp07:  mov  dword ptr scnpt,ecx #save updated scan offset} mov wa scnpt
        sub  ecx,ebx        #get length of label} sub wb wa
#        or   ecx,ecx        #skip if label length zero} bze wa cmp12  (optimized)
        jz   cmp12
        xor  edi,edi        #clear garbage edi value} zer xr
        call sbstr          #build scblk for label name} jsr sbstr
        call gtnvr          #locate/contruct vrblk} jsr gtnvr
        .short err_-299-dffnc #dummy (impossible) error return} ppm
        mov  dword ptr (4*cmlbl)[esp],edi #store label pointer} mov xr cmlbl(xs)
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #jump if not system label} bnz vrlen(xr) cmp11
        jnz  cmp11
        cmp  dword ptr (4*vrsvp)[edi],offset v_end #jump if not end label} bne vrsvp(xr) =v_end cmp11
        jne  cmp11
#
#      here for end label scanned out
#
        add  dword ptr stage,stgnd #adjust stage appropriately} add =stgnd stage
        call scane          #scan out next element} jsr scane
        cmp  esi,t_smc      #jump if end of image} beq xl =t_smc cmp10
        je   cmp10
        cmp  esi,t_var      #else error if not variable} bne xl =t_var cmp08
        jne  short cmp08 # (jump shortened)
#
#      here check for valid initial transfer
#
        cmp  dword ptr (4*vrlbl)[edi],offset stndl #jump if not defined (error)} beq vrlbl(xr) =stndl cmp08
        je   short cmp08 # (jump shortened)
        mov  eax,dword ptr (4*vrlbl)[edi] #else set initial entry pointer} mov vrlbl(xr) cmtra(xs)
        mov  dword ptr (4*cmtra)[esp],eax
        call scane          #scan next element} jsr scane
        cmp  esi,t_smc      #jump if ok (end of image)} beq xl =t_smc cmp10
        je   short cmp10 # (jump shortened)
#
#      here for bad transfer label
#
cmp08:  call err_0          #} erb 215 syntax error: undefined or erroneous entry label
        .byte 215
#
#      here for end of input (no end label detected)
#
cmp09:  xor  edi,edi        #clear garbage edi value} zer xr
        add  dword ptr stage,stgnd #adjust stage appropriately} add =stgnd stage
        cmp  dword ptr stage,stgxe #jump if code call (ok)} beq stage =stgxe cmp10
        je   short cmp10 # (jump shortened)
        call err_0          #} erb 216 syntax error: missing end line
        .byte 216
#
#      here after processing end line (merge here on end error)
#
cmp10:  mov  ecx,offset ostp_ #set stop call pointer} mov =ostp_ wa
        call cdwrd          #generate as statement call} jsr cdwrd
        jmp  cmpse          #jump to generate as failure} brn cmpse
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here after processing label other than end
#
cmp11:  cmp  dword ptr stage,stgic #jump if code call - redef. ok} bne stage =stgic cmp12
        jne  short cmp12 # (jump shortened)
        cmp  dword ptr (4*vrlbl)[edi],offset stndl #else check for redefinition} beq vrlbl(xr) =stndl cmp12
        je   short cmp12 # (jump shortened)
        xor  eax,eax        #leave first label decln undisturbed} zer cmlbl(xs)
        mov  dword ptr (4*cmlbl)[esp],eax
        call err_0          #} erb 217 syntax error: duplicate label
        .byte 217
#
#      here after dealing with label
#      null statements and statements just containing a
#      constant subject are optimized out by resetting the
#      current ccblk to empty.
#
cmp12:  xor  ebx,ebx        #set flag for statement body} zer wb
        call expan          #get tree for statement body} jsr expan
        mov  dword ptr (4*cmstm)[esp],edi #store for later use} mov xr cmstm(xs)
        xor  eax,eax        #clear success goto pointer} zer cmsgo(xs)
        mov  dword ptr (4*cmsgo)[esp],eax
        xor  eax,eax        #clear failure goto pointer} zer cmfgo(xs)
        mov  dword ptr (4*cmfgo)[esp],eax
        xor  eax,eax        #clear conditional goto flag} zer cmcgo(xs)
        mov  dword ptr (4*cmcgo)[esp],eax
        call scane          #scan next element} jsr scane
        cmp  esi,t_col      #jump if colon (goto)} beq xl =t_col cmp13
        je   short cmp13 # (jump shortened)
        cmp  dword ptr dword ptr cswno,0 #jump if not optimizing} bnz cswno cmp18
        jnz  cmp18
        cmp  dword ptr dword ptr (4*cmlbl)[esp],0 #jump if label present} bnz cmlbl(xs) cmp18
        jnz  cmp18
        mov  edi,dword ptr (4*cmstm)[esp] #load tree ptr for statement body} mov cmstm(xs) xr
        mov  ecx,dword ptr [edi] #load type word} mov (xr) wa
        cmp  ecx,offset b_cmt #jump if cmblk} beq wa =b_cmt cmp18
        je   cmp18
        cmp  ecx,offset b_vra #jump if not icblk, scblk, or rcblk} bge wa =b_vra cmp18
        jae  cmp18
        mov  esi,dword ptr r_ccb #load ptr to ccblk} mov r_ccb xl
        mov  dword ptr (4*ccuse)[esi],4*cccod #reset use offset in ccblk} mov *cccod ccuse(xl)
        mov  dword ptr cwcof,4*cccod #and in global} mov *cccod cwcof
        inc  dword ptr cmpsn #bump statement number} icv cmpsn
        jmp  cmp01          #generate no code for statement} brn cmp01
#
#      loop to process goto fields
#
cmp13:  mov  dword ptr scngo,esp #set goto flag} mnz scngo
        call scane          #scan next element} jsr scane
        cmp  esi,t_smc      #jump if no fields left} beq xl =t_smc cmp31
        je   cmp31
        cmp  esi,t_sgo      #jump if s for success goto} beq xl =t_sgo cmp14
        je   short cmp14 # (jump shortened)
        cmp  esi,t_fgo      #jump if f for failure goto} beq xl =t_fgo cmp16
        je   short cmp16 # (jump shortened)
#
#      here for unconditional goto (i.e. not f or s)
#
        mov  dword ptr scnrs,esp #set to rescan element not f,s} mnz scnrs
        call scngf          #scan out goto field} jsr scngf
        cmp  dword ptr dword ptr (4*cmfgo)[esp],0 #error if fgoto already} bnz cmfgo(xs) cmp17
        jnz  cmp17
        mov  dword ptr (4*cmfgo)[esp],edi #else set as fgoto} mov xr cmfgo(xs)
        jmp  short cmp15          #merge with sgoto circuit} brn cmp15 # (jump shortened)
#
#      here for success goto
#
cmp14:  call scngf          #scan success goto field} jsr scngf
        mov  dword ptr (4*cmcgo)[esp],num01 #set conditional goto flag} mov =num01 cmcgo(xs)
#
#      uncontional goto merges here
#
cmp15:  cmp  dword ptr dword ptr (4*cmsgo)[esp],0 #error if sgoto already given} bnz cmsgo(xs) cmp17
        jnz  short cmp17 # (jump shortened)
        mov  dword ptr (4*cmsgo)[esp],edi #else set sgoto} mov xr cmsgo(xs)
        jmp  cmp13          #loop back for next goto field} brn cmp13
#
#      here for failure goto
#
cmp16:  call scngf          #scan goto field} jsr scngf
        mov  dword ptr (4*cmcgo)[esp],num01 #set conditonal goto flag} mov =num01 cmcgo(xs)
        cmp  dword ptr dword ptr (4*cmfgo)[esp],0 #error if fgoto already given} bnz cmfgo(xs) cmp17
        jnz  short cmp17 # (jump shortened)
        mov  dword ptr (4*cmfgo)[esp],edi #else store fgoto pointer} mov xr cmfgo(xs)
        jmp  cmp13          #loop back for next field} brn cmp13
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here for duplicated goto field
#
cmp17:  call err_0          #} erb 218 syntax error: duplicated goto field
        .byte 218
#
#      here to generate code
#
cmp18:  xor  eax,eax        #stop positional error flags} zer scnse
        mov  dword ptr scnse,eax
        mov  edi,dword ptr (4*cmstm)[esp] #load tree ptr for statement body} mov cmstm(xs) xr
        xor  ebx,ebx        #collectable value for ebx for cdgvl} zer wb
        xor  edx,edx        #reset constant flag for cdgvl} zer wc
        call expap          #test for pattern match} jsr expap
        .short cmp19-dffnc  #jump if not pattern match} ppm cmp19
        mov  dword ptr (4*cmopn)[edi],offset opms_ #else set pattern match pointer} mov =opms_ cmopn(xr)
        mov  dword ptr (4*cmtyp)[edi],c_pmt #} mov =c_pmt cmtyp(xr)
#
#      here after dealing with special pattern match case
#
cmp19:  call cdgvl          #generate code for body of statement} jsr cdgvl
        mov  edi,dword ptr (4*cmsgo)[esp] #load sgoto pointer} mov cmsgo(xs) xr
        mov  ecx,edi        #copy it} mov xr wa
        or   edi,edi        #jump if no success goto} bze xr cmp21
        jz   short cmp21 # (jump shortened)
        xor  eax,eax        #clear success offset fillin ptr} zer cmsoc(xs)
        mov  dword ptr (4*cmsoc)[esp],eax
        cmp  edi,dword ptr state #jump if complex goto} bhi xr state cmp20
        ja   short cmp20 # (jump shortened)
#
#      here for simple success goto (label)
#
        add  ecx,4*vrtra    #point to vrtra field as required} add *vrtra wa
        call cdwrd          #generate success goto} jsr cdwrd
        jmp  short cmp22          #jump to deal with fgoto} brn cmp22 # (jump shortened)
#
#      here for complex success goto
#
cmp20:  cmp  edi,dword ptr (4*cmfgo)[esp] #no code if same as fgoto} beq xr cmfgo(xs) cmp22
        je   short cmp22 # (jump shortened)
        xor  ebx,ebx        #else set ok value for cdgvl in ebx} zer wb
        call cdgcg          #generate code for success goto} jsr cdgcg
        jmp  short cmp22          #jump to deal with fgoto} brn cmp22 # (jump shortened)
#
#      here for no success goto
#
cmp21:  mov  eax,dword ptr cwcof #set success fill in offset} mov cwcof cmsoc(xs)
        mov  dword ptr (4*cmsoc)[esp],eax
        mov  ecx,offset ocer_ #point to compile error call} mov =ocer_ wa
        call cdwrd          #generate as temporary value} jsr cdwrd
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here to deal with failure goto
#
cmp22:  mov  edi,dword ptr (4*cmfgo)[esp] #load failure goto pointer} mov cmfgo(xs) xr
        mov  ecx,edi        #copy it} mov xr wa
        xor  eax,eax        #set no fill in required yet} zer cmffc(xs)
        mov  dword ptr (4*cmffc)[esp],eax
        or   edi,edi        #jump if no failure goto given} bze xr cmp23
        jz   short cmp23 # (jump shortened)
        add  ecx,4*vrtra    #point to vrtra field in case} add *vrtra wa
        cmp  edi,dword ptr state #jump to gen if simple fgoto} blo xr state cmpse
        jb   short cmpse # (jump shortened)
#
#      here for complex failure goto
#
        mov  ebx,dword ptr cwcof #save offset to o_gof call} mov cwcof wb
        mov  ecx,offset ogof_ #point to failure goto call} mov =ogof_ wa
        call cdwrd          #generate} jsr cdwrd
        mov  ecx,offset ofif_ #point to fail in fail word} mov =ofif_ wa
        call cdwrd          #generate} jsr cdwrd
        call cdgcg          #generate code for failure goto} jsr cdgcg
        mov  ecx,ebx        #copy offset to o_gof for cdfal} mov wb wa
        mov  ebx,offset b_cdc #set complex case cdtyp} mov =b_cdc wb
        jmp  cmp25          #jump to build cdblk} brn cmp25
#
#      here if no failure goto given
#
cmp23:  mov  ecx,offset ounf_ #load unexpected failure call in cas} mov =ounf_ wa
        mov  edx,dword ptr cswfl #get -nofail flag} mov cswfl wc
        or   edx,dword ptr (4*cmcgo)[esp] #check if conditional goto} orb cmcgo(xs) wc
#        or   edx,edx        #jump if -nofail and no cond. goto} zrb wc cmpse  (optimized)
        jz   short cmpse # (jump shortened)
        mov  dword ptr (4*cmffc)[esp],esp #else set fill in flag} mnz cmffc(xs)
        mov  ecx,offset ocer_ #and set compile error for temporary} mov =ocer_ wa
#
#      merge here with cdfal value in wa, simple cdblk
#      also special entry after statement error
#
cmpse:  mov  ebx,offset b_cds #set cdtyp for simple case} mov =b_cds wb
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      merge here to build cdblk
#
#      (wa)                  cdfal value to be generated
#      (wb)                  cdtyp value to be generated
#
#      at this stage, we chop off an appropriate chunk of the
#      current ccblk and convert it into a cdblk. the remainder
#      of the ccblk is reformatted to be the new ccblk.
#
cmp25:  mov  edi,dword ptr r_ccb #point to ccblk} mov r_ccb xr
        mov  esi,dword ptr (4*cmlbl)[esp] #get possible label pointer} mov cmlbl(xs) xl
        or   esi,esi        #skip if no label} bze xl cmp26
        jz   short cmp26 # (jump shortened)
        xor  eax,eax        #clear flag for next statement} zer cmlbl(xs)
        mov  dword ptr (4*cmlbl)[esp],eax
        mov  dword ptr (4*vrlbl)[esi],edi #put cdblk ptr in vrblk label field} mov xr vrlbl(xl)
#
#      merge after doing label
#
cmp26:  mov  dword ptr [edi],ebx #set type word for new cdblk} mov wb (xr)
        mov  dword ptr (4*cdfal)[edi],ecx #set failure word} mov wa cdfal(xr)
        mov  esi,edi        #copy pointer to ccblk} mov xr xl
        mov  ebx,dword ptr (4*ccuse)[edi] #load length gen (= new cdlen)} mov ccuse(xr) wb
        mov  edx,dword ptr (4*cclen)[edi] #load total ccblk length} mov cclen(xr) wc
        add  esi,ebx        #point past cdblk} add wb xl
        sub  edx,ebx        #get length left for chop off} sub wb wc
        mov  dword ptr [esi],offset b_cct #set type code for new ccblk at end} mov =b_cct (xl)
        mov  dword ptr (4*ccuse)[esi],4*cccod #set initial code offset} mov *cccod ccuse(xl)
        mov  dword ptr cwcof,4*cccod #reinitialise cwcof} mov *cccod cwcof
        mov  dword ptr (4*cclen)[esi],edx #set new length} mov wc cclen(xl)
        mov  dword ptr r_ccb,esi #set new ccblk pointer} mov xl r_ccb
        xor  eax,eax        #initialize new line number} zer ccsln(xl)
        mov  dword ptr (4*ccsln)[esi],eax
        mov  eax,dword ptr cmpln #set line number in old block} mov cmpln cdsln(xr)
        mov  dword ptr (4*cdsln)[edi],eax
        mov  eax,dword ptr cmpsn #set statement number} mov cmpsn cdstm(xr)
        mov  dword ptr (4*cdstm)[edi],eax
        inc  dword ptr cmpsn #bump statement number} icv cmpsn
#
#      set pointers in previous code block as required
#
        mov  esi,dword ptr (4*cmpcd)[esp] #load ptr to previous cdblk} mov cmpcd(xs) xl
        cmp  dword ptr dword ptr (4*cmffp)[esp],0 #jump if no failure fill in required} bze cmffp(xs) cmp27
        jz   short cmp27 # (jump shortened)
        mov  dword ptr (4*cdfal)[esi],edi #else set failure ptr in previous} mov xr cdfal(xl)
#
#      here to deal with success forward pointer
#
cmp27:  mov  ecx,dword ptr (4*cmsop)[esp] #load success offset} mov cmsop(xs) wa
        or   ecx,ecx        #jump if no fill in required} bze wa cmp28
        jz   short cmp28 # (jump shortened)
        add  esi,ecx        #else point to fill in location} add wa xl
        mov  dword ptr [esi],edi #store forward pointer} mov xr (xl)
        xor  esi,esi        #clear garbage esi value} zer xl
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      now set fill in pointers for this statement
#
cmp28:  mov  eax,dword ptr (4*cmffc)[esp] #copy failure fill in flag} mov cmffc(xs) cmffp(xs)
        mov  dword ptr (4*cmffp)[esp],eax
        mov  eax,dword ptr (4*cmsoc)[esp] #copy success fill in offset} mov cmsoc(xs) cmsop(xs)
        mov  dword ptr (4*cmsop)[esp],eax
        mov  dword ptr (4*cmpcd)[esp],edi #save ptr to this cdblk} mov xr cmpcd(xs)
        cmp  dword ptr dword ptr (4*cmtra)[esp],0 #jump if initial entry already set} bnz cmtra(xs) cmp29
        jnz  short cmp29 # (jump shortened)
        mov  dword ptr (4*cmtra)[esp],edi #else set ptr here as default} mov xr cmtra(xs)
#
#      here after compiling one statement
#
cmp29:  cmp  dword ptr stage,stgce #jump if not end line just done} blt stage =stgce cmp01
        jb   cmp01
        cmp  dword ptr dword ptr cswls,0 #skip if -nolist} bze cswls cmp30
        jz   short cmp30 # (jump shortened)
        call listr          #list last line} jsr listr
#
#      return
#
cmp30:  mov  edi,dword ptr (4*cmtra)[esp] #load initial entry cdblk pointer} mov cmtra(xs) xr
        add  esp,4*cmnen    #pop work locations off stack} add *cmnen xs
        ret                 #and return to cmpil caller} exi
#
#      here at end of goto field
#
cmp31:  mov  ebx,dword ptr (4*cmfgo)[esp] #get fail goto} mov cmfgo(xs) wb
        or   ebx,dword ptr (4*cmsgo)[esp] #or in success goto} orb cmsgo(xs) wb
#        or   ebx,ebx        #ok if non-null field} bnz wb cmp18  (optimized)
        jnz  cmp18
        call err_0          #} erb 219 syntax error: empty goto field
        .byte 219
#
#      control card found
#
cmp32:  inc  ebx            #point past ch_mn} icv wb
        call cncrd          #process control card} jsr cncrd
        xor  eax,eax        #clear start of element loc.} zer scnse
        mov  dword ptr scnse,eax
        jmp  cmpce          #loop for next statement} brn cmpce
                            #end procedure cmpil} enp
                            #} ejc
        .eject
#
#      cncrd -- control card processor
#
#      called to deal with control cards
#
#      r$cim                 points to current image
#      (wb)                  offset to 1st char of control card
#      jsr  cncrd            call to process control cards
#      (xl,xr,wa,wb,wc,ia)   destroyed
#
cncrd:                      #entry point} prc e 0
        .global cncrd
        mov  dword ptr scnpt,ebx #offset for control card scan} mov wb scnpt
        mov  ecx,ccnoc      #number of chars for comparison} mov =ccnoc wa
        add  ecx,3+4*0      #convert to word count} ctw wa 0
        shr  ecx,2
        mov  dword ptr cnswc,ecx #save word count} mov wa cnswc
#
#      loop here if more than one control card
#
cnc01:  mov  eax,dword ptr scnpt #return if end of image} bge scnpt scnil cnc09
        cmp  eax,dword ptr scnil
        jae  cnc09
        mov  edi,dword ptr r_cim #point to image} mov r_cim xr
        add  edi,cfp_f      #char ptr for first char} plc xr scnpt
        add  edi,dword ptr scnpt
        movzx ecx,byte ptr [edi] #get first char} lch wa (xr)+
        inc  edi
        cmp  cl,'a'         #fold to upper case} flc wa
        jb   short l0009
        cmp  cl,'z'
        ja   short l0009
        sub  cl,32
l0009:
        cmp  ecx,ch_li      #special case of -inxxx} beq wa =ch_li cnc07
        je   cnc07
cnc0a:  mov  dword ptr scncc,esp #set flag for scane} mnz scncc
        call scane          #scan card name} jsr scane
        xor  eax,eax        #clear scane flag} zer scncc
        mov  dword ptr scncc,eax
        or   esi,esi        #fail unless control card name} bnz xl cnc06
        jnz  cnc06
        mov  ecx,ccnoc      #no. of chars to be compared} mov =ccnoc wa
        cmp  dword ptr (4*sclen)[edi],ecx #fail if too few chars} blt sclen(xr) wa cnc08
        jb   cnc08
        mov  esi,edi        #point to control card name} mov xr xl
        xor  ebx,ebx        #zero offset for substring} zer wb
        call sbstr          #extract substring for comparison} jsr sbstr
        mov  ecx,dword ptr (4*sclen)[edi] #reload length} mov sclen(xr) wa
        call flstg          #fold to upper case} jsr flstg
        mov  dword ptr cnscc,edi #keep control card substring ptr} mov xr cnscc
        mov  edi,offset ccnms #point to list of standard names} mov =ccnms xr
        xor  ebx,ebx        #initialise name offset} zer wb
        mov  edx,cc_nc      #number of standard names} lct wc =cc_nc
#
#      try to match name
#
cnc02:  mov  esi,dword ptr cnscc #point to name} mov cnscc xl
        mov  ecx,dword ptr cnswc #counter for inner loop} lct wa cnswc
        jmp  short cnc04          #jump into loop} brn cnc04 # (jump shortened)
#
#      inner loop to match card name chars
#
cnc03:  add  edi,4          #bump standard names ptr} ica xr
        add  esi,4          #bump name pointer} ica xl
#
#      here to initiate the loop
#
cnc04:  mov  eax,dword ptr (4*schar)[esi] #comp. up to cfp_c chars at once} cne schar(xl) (xr) cnc05
        cmp  eax,dword ptr [edi]
        jnz  cnc05
        loop cnc03          #loop if more words to compare} bct wa cnc03
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      matched - branch on card offset
#
        mov  esi,ebx        #get name offset} mov wb xl
        cmp  esi,cc_nc      #switch} bsw xl cc_nc cnc08
        jge  cnc08
        jmp  dword ptr l0010[esi*4]
        dseg_
l0010:
        .long cnc37         #-case} iff cc_ca cnc37
        .long cnc10         #-double} iff cc_do cnc10
        .long cnc08         #} iff 2 cnc08
        .long cnc11         #-dump} iff cc_du cnc11
        .long cnc41         #-copy} iff cc_cp cnc41
        .long cnc12         #-eject} iff cc_ej cnc12
        .long cnc13         #-errors} iff cc_er cnc13
        .long cnc14         #-execute} iff cc_ex cnc14
        .long cnc15         #-fail} iff cc_fa cnc15
        .long cnc41         #-include} iff cc_in cnc41
        .long cnc44         #-line} iff cc_ln cnc44
        .long cnc16         #-list} iff cc_li cnc16
        .long cnc17         #-noerrors} iff cc_nr cnc17
        .long cnc18         #-noexecute} iff cc_nx cnc18
        .long cnc19         #-nofail} iff cc_nf cnc19
        .long cnc20         #-nolist} iff cc_nl cnc20
        .long cnc21         #-noopt} iff cc_no cnc21
        .long cnc22         #-noprint} iff cc_np cnc22
        .long cnc24         #-optimise} iff cc_op cnc24
        .long cnc25         #-print} iff cc_pr cnc25
        .long cnc27         #-single} iff cc_si cnc27
        .long cnc28         #-space} iff cc_sp cnc28
        .long cnc31         #-stitle} iff cc_st cnc31
        .long cnc32         #-title} iff cc_ti cnc32
        .long cnc36         #-trace} iff cc_tr cnc36
        dsegend_            #end switch} esw
        cseg_
#
#      not matched yet. align std names ptr and try again
#
cnc05:  add  edi,4          #bump standard names ptr} ica xr
        loop cnc05          #loop} bct wa cnc05
        inc  ebx            #bump names offset} icv wb
        dec  edx            #continue if more names} bct wc cnc02
        jnz  cnc02
        jmp  cnc08          #ignore unrecognized control card} brn cnc08
#
#      invalid control card name
#
cnc06:  call err_0          #} erb 247 invalid control statement
        .byte 247
#
#      special processing for -inxxx
#
cnc07:  movzx ecx,byte ptr [edi] #get next char} lch wa (xr)+
        inc  edi
        cmp  cl,'a'         #fold to upper case} flc wa
        jb   short l0011
        cmp  cl,'z'
        ja   short l0011
        sub  cl,32
l0011:
        cmp  ecx,ch_ln      #if not letter n} bne wa =ch_ln cnc0a
        jne  cnc0a
        movzx ecx,byte ptr [edi] #get third char} lch wa (xr)
        cmp  ecx,ch_d0      #if not digit} blt wa =ch_d0 cnc0a
        jb   cnc0a
        cmp  ecx,ch_d9      #if not digit} bgt wa =ch_d9 cnc0a
        ja   cnc0a
        add  dword ptr scnpt,num02 #bump offset past -in} add =num02 scnpt
        call scane          #scan integer after -in} jsr scane
        push edi            #stack scanned item} mov xr -(xs)
        call gtsmi          #check if integer} jsr gtsmi
        .short cnc06-dffnc  #fail if not integer} ppm cnc06
        .short cnc06-dffnc  #fail if negative or large} ppm cnc06
        mov  dword ptr cswin,edi #keep integer} mov xr cswin
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      check for more control cards before returning
#
cnc08:  mov  ecx,dword ptr scnpt #preserve in case xeq time compile} mov scnpt wa
        call scane          #look for comma} jsr scane
        cmp  esi,t_cma      #loop if comma found} beq xl =t_cma cnc01
        je   cnc01
        mov  dword ptr scnpt,ecx #restore scnpt in case xeq time} mov wa scnpt
#
#      return point
#
cnc09:  ret                 #return} exi
#
#      -double
#
cnc10:  mov  dword ptr cswdb,esp #set switch} mnz cswdb
        jmp  cnc08          #merge} brn cnc08
#
#      -dump
#      this is used for system debugging . it has the effect of
#      producing a core dump at compilation time
#
cnc11:  call sysdm          #call dumper} jsr sysdm
        jmp  cnc09          #finished} brn cnc09
#
#      -eject
#
cnc12:  cmp  dword ptr dword ptr cswls,0 #return if -nolist} bze cswls cnc09
        jz   cnc09
        call prtps          #eject} jsr prtps
        call listt          #list title} jsr listt
        jmp  cnc09          #finished} brn cnc09
#
#      -errors
#
cnc13:  xor  eax,eax        #clear switch} zer cswer
        mov  dword ptr cswer,eax
        jmp  cnc08          #merge} brn cnc08
#
#      -execute
#
cnc14:  xor  eax,eax        #clear switch} zer cswex
        mov  dword ptr cswex,eax
        jmp  cnc08          #merge} brn cnc08
#
#      -fail
#
cnc15:  mov  dword ptr cswfl,esp #set switch} mnz cswfl
        jmp  cnc08          #merge} brn cnc08
#
#      -list
#
cnc16:  mov  dword ptr cswls,esp #set switch} mnz cswls
        cmp  dword ptr stage,stgic #done if compile time} beq stage =stgic cnc08
        je   cnc08
#
#      list code line if execute time compile
#
        xor  eax,eax        #permit listing} zer lstpf
        mov  dword ptr lstpf,eax
        call listr          #list line} jsr listr
        jmp  cnc08          #merge} brn cnc08
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      -noerrors
#
cnc17:  mov  dword ptr cswer,esp #set switch} mnz cswer
        jmp  cnc08          #merge} brn cnc08
#
#      -noexecute
#
cnc18:  mov  dword ptr cswex,esp #set switch} mnz cswex
        jmp  cnc08          #merge} brn cnc08
#
#      -nofail
#
cnc19:  xor  eax,eax        #clear switch} zer cswfl
        mov  dword ptr cswfl,eax
        jmp  cnc08          #merge} brn cnc08
#
#      -nolist
#
cnc20:  xor  eax,eax        #clear switch} zer cswls
        mov  dword ptr cswls,eax
        jmp  cnc08          #merge} brn cnc08
#
#      -nooptimise
#
cnc21:  mov  dword ptr cswno,esp #set switch} mnz cswno
        jmp  cnc08          #merge} brn cnc08
#
#      -noprint
#
cnc22:  xor  eax,eax        #clear switch} zer cswpr
        mov  dword ptr cswpr,eax
        jmp  cnc08          #merge} brn cnc08
#
#      -optimise
#
cnc24:  xor  eax,eax        #clear switch} zer cswno
        mov  dword ptr cswno,eax
        jmp  cnc08          #merge} brn cnc08
#
#      -print
#
cnc25:  mov  dword ptr cswpr,esp #set switch} mnz cswpr
        jmp  cnc08          #merge} brn cnc08
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      -single
#
cnc27:  xor  eax,eax        #clear switch} zer cswdb
        mov  dword ptr cswdb,eax
        jmp  cnc08          #merge} brn cnc08
#
#      -space
#
cnc28:  cmp  dword ptr dword ptr cswls,0 #return if -nolist} bze cswls cnc09
        jz   cnc09
        call scane          #scan integer after -space} jsr scane
        mov  edx,num01      #1 space in case} mov =num01 wc
        cmp  edi,t_smc      #jump if no integer} beq xr =t_smc cnc29
        je   short cnc29 # (jump shortened)
        push edi            #stack it} mov xr -(xs)
        call gtsmi          #check integer} jsr gtsmi
        .short cnc06-dffnc  #fail if not integer} ppm cnc06
        .short cnc06-dffnc  #fail if negative or large} ppm cnc06
        or   edx,edx        #jump if non zero} bnz wc cnc29
        jnz  short cnc29 # (jump shortened)
        mov  edx,num01      #else 1 space} mov =num01 wc
#
#      merge with count of lines to skip
#
cnc29:  add  dword ptr lstlc,edx #bump line count} add wc lstlc
        mov  eax,dword ptr lstlc #jump if fits on page} blt lstlc lstnp cnc30
        cmp  eax,dword ptr lstnp
        jb   short cnc30 # (jump shortened)
        call prtps          #eject} jsr prtps
        call listt          #list title} jsr listt
        jmp  cnc09          #merge} brn cnc09
#
#      skip lines
#
cnc30:  call prtnl          #print a blank} jsr prtnl
        dec  edx            #loop} bct wc cnc30
        jnz  cnc30
        jmp  cnc09          #merge} brn cnc09
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      -stitl
#
cnc31:  mov  dword ptr cnr_t,offset r_stl #ptr to r_stl} mov =r_stl cnr_t
        jmp  short cnc33          #merge} brn cnc33 # (jump shortened)
#
#      -title
#
cnc32:  mov  dword ptr r_stl,offset nulls #clear subtitle} mov =nulls r_stl
        mov  dword ptr cnr_t,offset r_ttl #ptr to r_ttl} mov =r_ttl cnr_t
#
#      common processing for -title, -stitl
#
cnc33:  mov  edi,offset nulls #null in case needed} mov =nulls xr
        mov  dword ptr cnttl,esp #set flag for next listr call} mnz cnttl
        mov  ebx,ccofs      #offset to title/subtitle} mov =ccofs wb
        mov  ecx,dword ptr scnil #input image length} mov scnil wa
        cmp  ecx,ebx        #jump if no chars left} blo wa wb cnc34
        jb   short cnc34 # (jump shortened)
        sub  ecx,ebx        #no of chars to extract} sub wb wa
        mov  esi,dword ptr r_cim #point to image} mov r_cim xl
        call sbstr          #get title/subtitle} jsr sbstr
#
#      store title/subtitle
#
cnc34:  mov  esi,dword ptr cnr_t #point to storage location} mov cnr_t xl
        mov  dword ptr [esi],edi #store title/subtitle} mov xr (xl)
        cmp  esi,offset r_stl #return if stitl} beq xl =r_stl cnc09
        je   cnc09
        cmp  dword ptr dword ptr precl,0 #return if extended listing} bnz precl cnc09
        jnz  cnc09
        cmp  dword ptr dword ptr prich,0 #return if regular printer} bze prich cnc09
        jz   cnc09
        mov  esi,dword ptr (4*sclen)[edi] #get length of title} mov sclen(xr) xl
        mov  ecx,esi        #copy it} mov xl wa
        or   esi,esi        #jump if null} bze xl cnc35
        jz   short cnc35 # (jump shortened)
        add  esi,num10      #increment} add =num10 xl
        cmp  esi,dword ptr prlen #use default lstp0 val if too long} bhi xl prlen cnc09
        ja   cnc09
        add  ecx,num04      #point just past title} add =num04 wa
#
#      store offset to page nn message for short title
#
cnc35:  mov  dword ptr lstpo,ecx #store offset} mov wa lstpo
        jmp  cnc09          #return} brn cnc09
#
#      -trace
#      provided for system debugging.  toggles the system label
#      trace switch at compile time
#
cnc36:  call systt          #toggle switch} jsr systt
        jmp  cnc08          #merge} brn cnc08
#
#      -case
#      sets value of kvcas so that names are folded or not
#      during compilation.
#
cnc37:  call scane          #scan integer after -case} jsr scane
        xor  edx,edx        #get 0 in case none there} zer wc
        cmp  esi,t_smc      #skip if no integer} beq xl =t_smc cnc38
        je   short cnc38 # (jump shortened)
        push edi            #stack it} mov xr -(xs)
        call gtsmi          #check integer} jsr gtsmi
        .short cnc06-dffnc  #fail if not integer} ppm cnc06
        .short cnc06-dffnc  #fail if negative or too large} ppm cnc06
cnc38:  mov  dword ptr kvcas,edx #store new case value} mov wc kvcas
        jmp  cnc09          #merge} brn cnc09
#
#      -include
#
cnc41:  mov  dword ptr scncc,esp #set flag for scane} mnz scncc
        call scane          #scan quoted file name} jsr scane
        xor  eax,eax        #clear scane flag} zer scncc
        mov  dword ptr scncc,eax
        cmp  esi,t_con      #if not constant} bne xl =t_con cnc06
        jne  cnc06
        cmp  dword ptr [edi],offset b_scl #if not string constant} bne (xr) =b_scl cnc06
        jne  cnc06
        mov  dword ptr r_ifn,edi #save file name} mov xr r_ifn
        mov  esi,dword ptr r_inc #examine include file name table} mov r_inc xl
        xor  ebx,ebx        #lookup by value} zer wb
        call tfind          #do lookup} jsr tfind
        .short err_-299-dffnc #never fails} ppm
        cmp  edi,offset inton #ignore if already in table} beq xr =inton cnc09
        je   cnc09
        mov  ebx,esp        #set for trim} mnz wb
        mov  edi,dword ptr r_ifn #file name} mov r_ifn xr
        call trimr          #remove trailing blanks} jsr trimr
        mov  esi,dword ptr r_inc #include file name table} mov r_inc xl
        mov  ebx,esp        #lookup by name this time} mnz wb
        call tfind          #do lookup} jsr tfind
        .short err_-299-dffnc #never fails} ppm
        mov  dword ptr (4*teval)[esi],offset inton #make table value integer 1} mov =inton teval(xl)
        inc  dword ptr cnind #increase nesting level} icv cnind
        mov  ecx,dword ptr cnind #load new nest level} mov cnind wa
        cmp  ecx,ccinm      #fail if excessive nesting} bgt wa =ccinm cnc42
        ja   cnc42
#
#      record the name and line number of the current input file
#
        mov  esi,dword ptr r_ifa #array of nested file names} mov r_ifa xl
        add  ecx,vcvlb      #compute offset in words} add =vcvlb wa
        sal  ecx,2          #convert to bytes} wtb wa
        add  esi,ecx        #point to element} add wa xl
        mov  eax,dword ptr r_sfc #record current file name} mov r_sfc (xl)
        mov  dword ptr [esi],eax
        mov  esi,ecx        #preserve nesting byte offset} mov wa xl
        mov  edx,dword ptr rdnln #fetch source line number as integer} mti rdnln
        call icbld          #convert to icblk} jsr icbld
        add  esi,dword ptr r_ifl #entry in nested line number array} add r_ifl xl
        mov  dword ptr [esi],edi #record in array} mov xr (xl)
#
#      here to switch to include file named in r$ifn
#
        mov  ecx,dword ptr cswin #max read length} mov cswin wa
        mov  esi,dword ptr r_ifn #include file name} mov r_ifn xl
        call alocs          #get buffer for complete file name} jsr alocs
        call sysif          #open include file} jsr sysif
        .short cnc43-dffnc  #could not open} ppm cnc43
#
#      make note of the complete file name for error messages
#
        xor  ebx,ebx        #do not trim trailing blanks} zer wb
        call trimr          #adjust scblk for actual length} jsr trimr
        mov  dword ptr r_sfc,edi #save ptr to file name} mov xr r_sfc
        mov  edx,dword ptr cmpsn #current statement as integer} mti cmpsn
        call icbld          #build icblk for stmt number} jsr icbld
        mov  esi,dword ptr r_sfn #file name table} mov r_sfn xl
        mov  ebx,esp        #lookup statement number by name} mnz wb
        call tfind          #allocate new teblk} jsr tfind
        .short err_-299-dffnc #always possible to allocate block} ppm
        mov  eax,dword ptr r_sfc #record file name as entry value} mov r_sfc teval(xl)
        mov  dword ptr (4*teval)[esi],eax
        xor  eax,eax        #restart line counter for new file} zer rdnln
        mov  dword ptr rdnln,eax
        cmp  dword ptr stage,stgic #if initial compile} beq stage =stgic cnc09
        je   cnc09
        cmp  dword ptr cnind,num01 #if not first execute-time nesting} bne cnind =num01 cnc09
        jne  cnc09
#
#      here for -include during execute-time compile
#
        mov  eax,dword ptr r_cim #remember code argument string} mov r_cim r_ici
        mov  dword ptr r_ici,eax
        mov  eax,dword ptr scnpt #save position in string} mov scnpt cnspt
        mov  dword ptr cnspt,eax
        mov  eax,dword ptr scnil #and length of string} mov scnil cnsil
        mov  dword ptr cnsil,eax
        jmp  cnc09          #all done, merge} brn cnc09
#
#      here for excessive include file nesting
#
cnc42:  call err_1          #} erb 284 excessively nested include files
        .byte 28
#
#      here if include file could not be opened
#
cnc43:  mov  dword ptr dnamp,edi #release allocated scblk} mov xr dnamp
        call err_1          #} erb 285 include file cannot be opened
        .byte 29
#
#
#      -line n filename
#
cnc44:  call scane          #scan integer after -line} jsr scane
        cmp  esi,t_con      #jump if no line number} bne xl =t_con cnc06
        jne  cnc06
        cmp  dword ptr [edi],offset b_icl #jump if not integer} bne (xr) =b_icl cnc06
        jne  cnc06
        mov  edx,dword ptr (4*icval)[edi] #fetch integer line number} ldi icval(xr)
        or   edx,edx        #error if negative or zero} ile cnc06
        jle  cnc06
        cmp  dword ptr stage,stgic #skip if initial compile} beq stage =stgic cnc45
        je   short cnc45 # (jump shortened)
        mov  dword ptr cmpln,edx #set directly for other compiles} mfi cmpln
        jmp  short cnc46          #no need to set rdnln} brn cnc46 # (jump shortened)
cnc45:  sub  edx,dword ptr intv1 #adjust number by one} sbi intv1
        mov  dword ptr rdnln,edx #save line number} mfi rdnln
cnc46:  mov  dword ptr scncc,esp #set flag for scane} mnz scncc
        call scane          #scan quoted file name} jsr scane
        xor  eax,eax        #clear scane flag} zer scncc
        mov  dword ptr scncc,eax
        cmp  esi,t_smc      #done if no file name} beq xl =t_smc cnc47
        je   short cnc47 # (jump shortened)
        cmp  esi,t_con      #error if not constant} bne xl =t_con cnc06
        jne  cnc06
        cmp  dword ptr [edi],offset b_scl #if not string constant} bne (xr) =b_scl cnc06
        jne  cnc06
        call newfn          #record new file name} jsr newfn
        jmp  cnc09          #merge} brn cnc09
#
#      here if file name not present
#
cnc47:  dec  dword ptr scnpt #set to rescan the terminator} dcv scnpt
        jmp  cnc09          #merge} brn cnc09
                            #end procedure cncrd} enp
                            #} ejc
        .eject
#
#      dffnc -- define function
#
#      dffnc is called whenever a new function is assigned to
#      a variable. it deals with external function use counts.
#
#      (xr)                  pointer to vrblk
#      (xl)                  pointer to new function block
#      jsr  dffnc            call to define function
#      (wa,wb)               destroyed
#
dffnc:                      #entry point} prc e 0
        .global dffnc
        cmp  dword ptr [esi],offset b_efc #skip if new function not external} bne (xl) =b_efc dffn1
        jne  short dffn1 # (jump shortened)
        inc  dword ptr (4*efuse)[esi] #else increment its use count} icv efuse(xl)
#
#      here after dealing with new function use count
#
dffn1:  mov  ecx,edi        #save vrblk pointer} mov xr wa
        mov  edi,dword ptr (4*vrfnc)[edi] #load old function pointer} mov vrfnc(xr) xr
        cmp  dword ptr [edi],offset b_efc #jump if old function not external} bne (xr) =b_efc dffn2
        jne  short dffn2 # (jump shortened)
        mov  ebx,dword ptr (4*efuse)[edi] #else get use count} mov efuse(xr) wb
        dec  ebx            #decrement} dcv wb
        mov  dword ptr (4*efuse)[edi],ebx #store decremented value} mov wb efuse(xr)
        or   ebx,ebx        #jump if use count still non-zero} bnz wb dffn2
        jnz  short dffn2 # (jump shortened)
        call sysul          #else call system unload function} jsr sysul
#
#      here after dealing with old function use count
#
dffn2:  mov  edi,ecx        #restore vrblk pointer} mov wa xr
        mov  ecx,esi        #copy function block ptr} mov xl wa
        cmp  edi,offset r_yyy #skip checks if opsyn op definition} blt xr =r_yyy dffn3
        jb   short dffn3 # (jump shortened)
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #jump if not system variable} bnz vrlen(xr) dffn3
        jnz  short dffn3 # (jump shortened)
#
#      for system variable, check for illegal redefinition
#
        mov  esi,dword ptr (4*vrsvp)[edi] #point to svblk} mov vrsvp(xr) xl
        mov  ebx,dword ptr (4*svbit)[esi] #load bit indicators} mov svbit(xl) wb
        and  ebx,dword ptr btfnc #is it a system function} anb btfnc wb
#        or   ebx,ebx        #redef ok if not} zrb wb dffn3  (optimized)
        jz   short dffn3 # (jump shortened)
        call err_0          #} erb 248 attempted redefinition of system function
        .byte 248
#
#      here if redefinition is permitted
#
dffn3:  mov  dword ptr (4*vrfnc)[edi],ecx #store new function pointer} mov wa vrfnc(xr)
        mov  esi,ecx        #restore function block pointer} mov wa xl
        ret                 #return to dffnc caller} exi
                            #end procedure dffnc} enp
                            #} ejc
        .eject
#
#      dtach -- detach i/o associated names
#
#      detaches trblks from i/o associated variables, removes
#      entry from iochn chain attached to filearg1 vrblk and may
#      remove vrblk access and store traps.
#      input, output, terminal are handled specially.
#
#      (xl)                  i/o assoc. vbl name base ptr
#      (wa)                  offset to name
#      jsr  dtach            call for detach operation
#      (xl,xr,wa,wb,wc)      destroyed
#
dtach:                      #entry point} prc e 0
        .global dtach
        mov  dword ptr dtcnb,esi #store name base (gbcol not called)} mov xl dtcnb
        add  esi,ecx        #point to name location} add wa xl
        mov  dword ptr dtcnm,esi #store it} mov xl dtcnm
#
#      loop to search for i/o trblk
#
dtch1:  mov  edi,esi        #copy name pointer} mov xl xr
#
#      continue after block deletion
#
dtch2:  mov  esi,dword ptr [esi] #point to next value} mov (xl) xl
        cmp  dword ptr [esi],offset b_trt #jump at chain end} bne (xl) =b_trt dtch6
        jne  dtch6
        mov  ecx,dword ptr (4*trtyp)[esi] #get trap block type} mov trtyp(xl) wa
        cmp  ecx,trtin      #jump if input} beq wa =trtin dtch3
        je   short dtch3 # (jump shortened)
        cmp  ecx,trtou      #jump if output} beq wa =trtou dtch3
        je   short dtch3 # (jump shortened)
        add  esi,4*trnxt    #point to next link} add *trnxt xl
        jmp  dtch1          #loop} brn dtch1
#
#      delete an old association
#
dtch3:  mov  eax,dword ptr (4*trval)[esi] #delete trblk} mov trval(xl) (xr)
        mov  dword ptr [edi],eax
        mov  ecx,esi        #dump esi ...} mov xl wa
        mov  ebx,edi        #... and edi} mov xr wb
        mov  esi,dword ptr (4*trtrf)[esi] #point to trtrf trap block} mov trtrf(xl) xl
        or   esi,esi        #jump if no iochn} bze xl dtch5
        jz   short dtch5 # (jump shortened)
        cmp  dword ptr [esi],offset b_trt #jump if input, output, terminal} bne (xl) =b_trt dtch5
        jne  short dtch5 # (jump shortened)
#
#      loop to search iochn chain for name ptr
#
dtch4:  mov  edi,esi        #remember link ptr} mov xl xr
        mov  esi,dword ptr (4*trtrf)[esi] #point to next link} mov trtrf(xl) xl
        or   esi,esi        #jump if end of chain} bze xl dtch5
        jz   short dtch5 # (jump shortened)
        mov  edx,dword ptr (4*ionmb)[esi] #get name base} mov ionmb(xl) wc
        add  edx,dword ptr (4*ionmo)[esi] #add offset} add ionmo(xl) wc
        cmp  edx,dword ptr dtcnm #loop if no match} bne wc dtcnm dtch4
        jne  dtch4
        mov  eax,dword ptr (4*trtrf)[esi] #remove name from chain} mov trtrf(xl) trtrf(xr)
        mov  dword ptr (4*trtrf)[edi],eax
                            #} ejc
        .eject
#
#      dtach (continued)
#
#      prepare to resume i/o trblk scan
#
dtch5:  mov  esi,ecx        #recover esi ...} mov wa xl
        mov  edi,ebx        #... and edi} mov wb xr
        add  esi,4*trval    #point to value field} add *trval xl
        jmp  dtch2          #continue} brn dtch2
#
#      exit point
#
dtch6:  mov  edi,dword ptr dtcnb #possible vrblk ptr} mov dtcnb xr
        call setvr          #reset vrblk if necessary} jsr setvr
        ret                 #return} exi
                            #end procedure dtach} enp
                            #} ejc
        .eject
#
#      dtype -- get datatype name
#
#      (xr)                  object whose datatype is required
#      jsr  dtype            call to get datatype
#      (xr)                  result datatype
#
dtype:                      #entry point} prc e 0
        .global dtype
        cmp  dword ptr [edi],offset b_pdt #jump if prog.defined} beq (xr) =b_pdt dtyp1
        je   short dtyp1 # (jump shortened)
        mov  edi,dword ptr [edi] #load type word} mov (xr) xr
        movzx edi,byte ptr [edi-1] #get entry point id (block code)} lei xr
        sal  edi,2          #convert to byte offset} wtb xr
        mov  edi,scnmt[edi] #load table entry} mov scnmt(xr) xr
        ret                 #exit to dtype caller} exi
#
#      here if program defined
#
dtyp1:  mov  edi,dword ptr (4*pddfp)[edi] #point to dfblk} mov pddfp(xr) xr
        mov  edi,dword ptr (4*dfnam)[edi] #get datatype name from dfblk} mov dfnam(xr) xr
        ret                 #return to dtype caller} exi
                            #end procedure dtype} enp
                            #} ejc
        .eject
#
#      dumpr -- print dump of storage
#
#      (xr)                  dump argument (see below)
#      jsr  dumpr            call to print dump
#      (xr,xl)               destroyed
#      (wa,wb,wc,ra)         destroyed
#
#      the dump argument has the following significance
#
#      dmarg = 0             no dump printed
#      dmarg = 1             partial dump (nat vars, keywords)
#      dmarg = 2             full dump (arrays, tables, etc.)
#      dmarg = 3             full dump + null variables
#      dmarg ge 4            core dump
#
#      since dumpr scrambles store, it is not permissible to
#      collect in mid-dump. hence a collect is done initially
#      and then if store runs out an error message is produced.
#
dumpr:                      #entry point} prc e 0
        .global dumpr
        or   edi,edi        #skip dump if argument is zero} bze xr dmp28
        jz   dmp28
        cmp  edi,num03      #jump if core dump required} bgt xr =num03 dmp29
        ja   dmp29
        xor  esi,esi        #clear esi} zer xl
        xor  ebx,ebx        #zero move offset} zer wb
        mov  dword ptr dmarg,edi #save dump argument} mov xr dmarg
        xor  eax,eax        #collect sediment too} zer dnams
        mov  dword ptr dnams,eax
        call gbcol          #collect garbage} jsr gbcol
        call prtpg          #eject printer} jsr prtpg
        mov  edi,offset dmhdv #point to heading for variables} mov =dmhdv xr
        call prtst          #print it} jsr prtst
        call prtnl          #terminate print line} jsr prtnl
        call prtnl          #and print a blank line} jsr prtnl
#
#      first all natural variable blocks (vrblk) whose values
#      are non-null are linked in lexical order using dmvch as
#      the chain head and chaining through the vrget fields.
#      note that this scrambles store if the process is
#      interrupted before completion e.g. by exceeding time  or
#      print limits. since the subsequent core dumps and
#      failures if execution is resumed are very confusing, the
#      execution time error routine checks for this event and
#      attempts an unscramble. similar precautions should be
#      observed if translate time dumping is implemented.
#
        xor  eax,eax        #set null chain to start} zer dmvch
        mov  dword ptr dmvch,eax
        mov  ecx,dword ptr hshtb #point to hash table} mov hshtb wa
#
#      loop through headers in hash table
#
dmp00:  mov  edi,ecx        #copy hash bucket pointer} mov wa xr
        add  ecx,4          #bump pointer} ica wa
        sub  edi,4*vrnxt    #set offset to merge} sub *vrnxt xr
#
#      loop through vrblks on one chain
#
dmp01:  mov  edi,dword ptr (4*vrnxt)[edi] #point to next vrblk on chain} mov vrnxt(xr) xr
        or   edi,edi        #jump if end of this hash chain} bze xr dmp09
        jz   dmp09
        mov  esi,edi        #else copy vrblk pointer} mov xr xl
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      loop to find value and skip if null
#
dmp02:  mov  esi,dword ptr (4*vrval)[esi] #load value} mov vrval(xl) xl
        cmp  dword ptr dmarg,num03 #skip null value check if dump(3)} beq dmarg =num03 dmp2a
        je   short dmp2a # (jump shortened)
        cmp  esi,offset nulls #loop for next vrblk if null value} beq xl =nulls dmp01
        je   dmp01
dmp2a:  cmp  dword ptr [esi],offset b_trt #loop back if value is trapped} beq (xl) =b_trt dmp02
        je   dmp02
#
#      non-null value, prepare to search chain
#
        mov  edx,edi        #save vrblk pointer} mov xr wc
        add  edi,4*vrsof    #adjust ptr to be like scblk ptr} add *vrsof xr
        cmp  dword ptr dword ptr (4*sclen)[edi],0 #jump if non-system variable} bnz sclen(xr) dmp03
        jnz  short dmp03 # (jump shortened)
        mov  edi,dword ptr (4*vrsvo)[edi] #else load ptr to name in svblk} mov vrsvo(xr) xr
#
#      here with name pointer for new block in xr
#
dmp03:  mov  ebx,edi        #save pointer to chars} mov xr wb
        mov  dword ptr dmpsv,ecx #save hash bucket pointer} mov wa dmpsv
        mov  ecx,offset dmvch #point to chain head} mov =dmvch wa
#
#      loop to search chain for correct insertion point
#
dmp04:  mov  dword ptr dmpch,ecx #save chain pointer} mov wa dmpch
        mov  esi,ecx        #copy it} mov wa xl
        mov  edi,dword ptr [esi] #load pointer to next entry} mov (xl) xr
        or   edi,edi        #jump if end of chain to insert} bze xr dmp08
        jz   dmp08
        add  edi,4*vrsof    #else get name ptr for chained vrblk} add *vrsof xr
        cmp  dword ptr dword ptr (4*sclen)[edi],0 #jump if not system variable} bnz sclen(xr) dmp05
        jnz  short dmp05 # (jump shortened)
        mov  edi,dword ptr (4*vrsvo)[edi] #else point to name in svblk} mov vrsvo(xr) xr
#
#      here prepare to compare the names
#
#      (wa)                  scratch
#      (wb)                  pointer to string of entering vrblk
#      (wc)                  pointer to entering vrblk
#      (xr)                  pointer to string of current block
#      (xl)                  scratch
#
dmp05:  mov  esi,ebx        #point to entering vrblk string} mov wb xl
        mov  ecx,dword ptr (4*sclen)[esi] #load its length} mov sclen(xl) wa
        add  esi,cfp_f      #point to chars of entering string} plc xl
        cmp  ecx,dword ptr (4*sclen)[edi] #jump if entering length high} bhi wa sclen(xr) dmp06
        ja   short dmp06 # (jump shortened)
        add  edi,cfp_f      #else point to chars of old string} plc xr
        repe cmpsb          #compare, insert if new is llt old} cmc dmp08 dmp07
        mov  esi,0
        mov  edi,esi
        ja   short dmp07 # (jump shortened)
        jb   short dmp08 # (jump shortened)
        jmp  short dmp08          #or if leq (we had shorter length)} brn dmp08 # (jump shortened)
#
#      here when new length is longer than old length
#
dmp06:  mov  ecx,dword ptr (4*sclen)[edi] #load shorter length} mov sclen(xr) wa
        add  edi,cfp_f      #point to chars of old string} plc xr
        repe cmpsb          #compare, insert if new one low} cmc dmp08 dmp07
        mov  esi,0
        mov  edi,esi
        ja   short dmp07 # (jump shortened)
        jb   short dmp08 # (jump shortened)
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      here we move out on the chain
#
dmp07:  mov  esi,dword ptr dmpch #copy chain pointer} mov dmpch xl
        mov  ecx,dword ptr [esi] #move to next entry on chain} mov (xl) wa
        jmp  dmp04          #loop back} brn dmp04
#
#      here after locating the proper insertion point
#
dmp08:  mov  esi,dword ptr dmpch #copy chain pointer} mov dmpch xl
        mov  ecx,dword ptr dmpsv #restore hash bucket pointer} mov dmpsv wa
        mov  edi,edx        #restore vrblk pointer} mov wc xr
        mov  eax,dword ptr [esi] #link vrblk to rest of chain} mov (xl) vrget(xr)
        mov  dword ptr (4*vrget)[edi],eax
        mov  dword ptr [esi],edi #link vrblk into current chain loc} mov xr (xl)
        jmp  dmp01          #loop back for next vrblk} brn dmp01
#
#      here after processing all vrblks on one chain
#
dmp09:  cmp  ecx,dword ptr hshte #loop back if more buckets to go} bne wa hshte dmp00
        jne  dmp00
#
#      loop to generate dump of natural variable values
#
dmp10:  mov  edi,dword ptr dmvch #load pointer to next entry on chain} mov dmvch xr
        or   edi,edi        #jump if end of chain} bze xr dmp11
        jz   short dmp11 # (jump shortened)
        mov  eax,dword ptr [edi] #else update chain ptr to next entry} mov (xr) dmvch
        mov  dword ptr dmvch,eax
        call setvr          #restore vrget field} jsr setvr
        mov  esi,edi        #copy vrblk pointer (name base)} mov xr xl
        mov  ecx,4*vrval    #set offset for vrblk name} mov *vrval wa
        call prtnv          #print name = value} jsr prtnv
        jmp  dmp10          #loop back till all printed} brn dmp10
#
#      prepare to print keywords
#
dmp11:  call prtnl          #print blank line} jsr prtnl
        call prtnl          #and another} jsr prtnl
        mov  edi,offset dmhdk #point to keyword heading} mov =dmhdk xr
        call prtst          #print heading} jsr prtst
        call prtnl          #end line} jsr prtnl
        call prtnl          #print one blank line} jsr prtnl
        mov  esi,offset vdmkw #point to list of keyword svblk ptrs} mov =vdmkw xl
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      loop to dump keyword values
#
dmp12:  lodsd               #load next svblk ptr from table} mov (xl)+ xr
        mov  edi,eax
        or   edi,edi        #jump if end of list} bze xr dmp13
        jz   dmp13
        cmp  edi,num01      #&compare ignored if not implemented} beq xr =num01 dmp12
        je   dmp12
        mov  ecx,ch_am      #load ampersand} mov =ch_am wa
        call prtch          #print ampersand} jsr prtch
        call prtst          #print keyword name} jsr prtst
        mov  ecx,dword ptr (4*svlen)[edi] #load name length from svblk} mov svlen(xr) wa
        add  ecx,3+4*svchs  #get length of name} ctb wa svchs
        and  ecx,-4
        add  edi,ecx        #point to svknm field} add wa xr
        mov  eax,dword ptr [edi] #store in dummy kvblk} mov (xr) dmpkn
        mov  dword ptr dmpkn,eax
        mov  edi,offset tmbeb #point to blank-equal-blank} mov =tmbeb xr
        call prtst          #print it} jsr prtst
        mov  dword ptr dmpsv,esi #save table pointer} mov xl dmpsv
        mov  esi,offset dmpkb #point to dummy kvblk} mov =dmpkb xl
        mov  dword ptr [esi],offset b_kvt #build type word} mov =b_kvt (xl)
        mov  dword ptr (4*kvvar)[esi],offset trbkv #build ptr to dummy trace block} mov =trbkv kvvar(xl)
        mov  ecx,4*kvvar    #set zero offset} mov *kvvar wa
        call acess          #get keyword value} jsr acess
        .short err_-299-dffnc #failure is impossible} ppm
        call prtvl          #print keyword value} jsr prtvl
        call prtnl          #terminate print line} jsr prtnl
        mov  esi,dword ptr dmpsv #restore table pointer} mov dmpsv xl
        jmp  dmp12          #loop back till all printed} brn dmp12
#
#      here after completing partial dump
#
dmp13:  cmp  dword ptr dmarg,num01 #exit if partial dump complete} beq dmarg =num01 dmp27
        je   dmp27
        mov  edi,dword ptr dnamb #else point to first dynamic block} mov dnamb xr
#
#      loop through blocks in dynamic storage
#
dmp14:  cmp  edi,dword ptr dnamp #jump if end of used region} beq xr dnamp dmp27
        je   dmp27
        mov  ecx,dword ptr [edi] #else load first word of block} mov (xr) wa
        cmp  ecx,offset b_vct #jump if vector} beq wa =b_vct dmp16
        je   short dmp16 # (jump shortened)
        cmp  ecx,offset b_art #jump if array} beq wa =b_art dmp17
        je   short dmp17 # (jump shortened)
        cmp  ecx,offset b_pdt #jump if program defined} beq wa =b_pdt dmp18
        je   short dmp18 # (jump shortened)
        cmp  ecx,offset b_tbt #jump if table} beq wa =b_tbt dmp19
        je   dmp19
#
#      merge here to move to next block
#
dmp15:  call blkln          #get length of block} jsr blkln
        add  edi,ecx        #point past this block} add wa xr
        jmp  dmp14          #loop back for next block} brn dmp14
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      here for vector
#
dmp16:  mov  ebx,4*vcvls    #set offset to first value} mov *vcvls wb
        jmp  short dmp19          #jump to merge} brn dmp19 # (jump shortened)
#
#      here for array
#
dmp17:  mov  ebx,dword ptr (4*arofs)[edi] #set offset to arpro field} mov arofs(xr) wb
        add  ebx,4          #bump to get offset to values} ica wb
        jmp  short dmp19          #jump to merge} brn dmp19 # (jump shortened)
#
#      here for program defined
#
dmp18:  mov  ebx,4*pdfld    #point to values, merge} mov *pdfld wb
#
#      here for table (others merge)
#
dmp19:  cmp  dword ptr dword ptr (4*idval)[edi],0 #ignore block if zero id value} bze idval(xr) dmp15
        jz   dmp15
        call blkln          #else get block length} jsr blkln
        mov  esi,edi        #copy block pointer} mov xr xl
        mov  dword ptr dmpsv,ecx #save length} mov wa dmpsv
        mov  ecx,ebx        #copy offset to first value} mov wb wa
        call prtnl          #print blank line} jsr prtnl
        mov  dword ptr dmpsa,ecx #preserve offset} mov wa dmpsa
        call prtvl          #print block value (for title)} jsr prtvl
        mov  ecx,dword ptr dmpsa #recover offset} mov dmpsa wa
        call prtnl          #end print line} jsr prtnl
        cmp  dword ptr [edi],offset b_tbt #jump if table} beq (xr) =b_tbt dmp22
        je   dmp22
        sub  ecx,4          #point before first word} dca wa
#
#      loop to print contents of array, vector, or program def
#
dmp20:  mov  edi,esi        #copy block pointer} mov xl xr
        add  ecx,4          #bump offset} ica wa
        add  edi,ecx        #point to next value} add wa xr
        cmp  ecx,dword ptr dmpsv #exit if end (edi past block)} beq wa dmpsv dmp14
        je   dmp14
        sub  edi,4*vrval    #subtract offset to merge into loop} sub *vrval xr
#
#      loop to find value and ignore nulls
#
dmp21:  mov  edi,dword ptr (4*vrval)[edi] #load next value} mov vrval(xr) xr
        cmp  dword ptr dmarg,num03 #skip null value check if dump(3)} beq dmarg =num03 dmp2b
        je   short dmp2b # (jump shortened)
        cmp  edi,offset nulls #loop back if null value} beq xr =nulls dmp20
        je   dmp20
dmp2b:  cmp  dword ptr [edi],offset b_trt #loop back if trapped} beq (xr) =b_trt dmp21
        je   dmp21
        call prtnv          #else print name = value} jsr prtnv
        jmp  dmp20          #loop back for next field} brn dmp20
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      here to dump a table
#
dmp22:  mov  edx,4*tbbuk    #set offset to first bucket} mov *tbbuk wc
        mov  ecx,4*teval    #set name offset for all teblks} mov *teval wa
#
#      loop through table buckets
#
dmp23:  push esi            #save tbblk pointer} mov xl -(xs)
        add  esi,edx        #point to next bucket header} add wc xl
        add  edx,4          #bump bucket offset} ica wc
        sub  esi,4*tenxt    #subtract offset to merge into loop} sub *tenxt xl
#
#      loop to process teblks on one chain
#
dmp24:  mov  esi,dword ptr (4*tenxt)[esi] #point to next teblk} mov tenxt(xl) xl
        cmp  esi,dword ptr [esp] #jump if end of chain} beq xl (xs) dmp26
        je   short dmp26 # (jump shortened)
        mov  edi,esi        #else copy teblk pointer} mov xl xr
#
#      loop to find value and ignore if null
#
dmp25:  mov  edi,dword ptr (4*teval)[edi] #load next value} mov teval(xr) xr
        cmp  edi,offset nulls #ignore if null value} beq xr =nulls dmp24
        je   dmp24
        cmp  dword ptr [edi],offset b_trt #loop back if trapped} beq (xr) =b_trt dmp25
        je   dmp25
        mov  dword ptr dmpsv,edx #else save offset pointer} mov wc dmpsv
        call prtnv          #print name = value} jsr prtnv
        mov  edx,dword ptr dmpsv #reload offset} mov dmpsv wc
        jmp  dmp24          #loop back for next teblk} brn dmp24
#
#      here to move to next hash chain
#
dmp26:  pop  esi            #restore tbblk pointer} mov (xs)+ xl
        cmp  edx,dword ptr (4*tblen)[esi] #loop back if more buckets to go} bne wc tblen(xl) dmp23
        jne  dmp23
        mov  edi,esi        #else copy table pointer} mov xl xr
        add  edi,edx        #point to following block} add wc xr
        jmp  dmp14          #loop back to process next block} brn dmp14
#
#      here after completing dump
#
dmp27:  call prtpg          #eject printer} jsr prtpg
#
#      merge here if no dump given (dmarg=0)
#
dmp28:  ret                 #return to dump caller} exi
#
#      call system core dump routine
#
dmp29:  call sysdm          #call it} jsr sysdm
        jmp  dmp28          #return} brn dmp28
                            #end procedure dumpr} enp
                            #} ejc
        .eject
#
#      ermsg -- print error code and error message
#
#      kvert                 error code
#      jsr  ermsg            call to print message
#      (xr,xl,wa,wb,wc,ia)   destroyed
#
ermsg:                      #entry point} prc e 0
        .global ermsg
        mov  ecx,dword ptr kvert #load error code} mov kvert wa
        mov  edi,offset ermms #point to error message /error/} mov =ermms xr
        call prtst          #print it} jsr prtst
        call ertex          #get error message text} jsr ertex
        add  ecx,thsnd      #bump error code for print} add =thsnd wa
        mov  edx,ecx        #fail code in int acc} mti wa
        mov  ebx,dword ptr profs #save current buffer position} mov profs wb
        call prtin          #print code (now have error1xxx)} jsr prtin
        mov  esi,dword ptr prbuf #point to print buffer} mov prbuf xl
        lea  esi,[cfp_f+esi+ebx] #point to the 1} psc xl wb
        mov  ecx,ch_bl      #load a blank} mov =ch_bl wa
        mov  [esi],cl       #store blank over 1 (error xxx)} sch wa (xl)
        xor  esi,esi        #clear garbage pointer in esi} zer xl
        mov  ecx,edi        #keep error text} mov xr wa
        mov  edi,offset ermns #point to / -- /} mov =ermns xr
        call prtst          #print it} jsr prtst
        mov  edi,ecx        #get error text again} mov wa xr
        call prtst          #print error message text} jsr prtst
        call prtis          #print line} jsr prtis
        call prtis          #print blank line} jsr prtis
        ret                 #return to ermsg caller} exi
                            #end procedure ermsg} enp
                            #} ejc
        .eject
#
#      ertex -- get error message text
#
#      (wa)                  error code
#      jsr  ertex            call to get error text
#      (xr)                  ptr to error text in dynamic
#      (r$etx)               copy of ptr to error text
#      (xl,wc,ia)            destroyed
#
ertex:                      #entry point} prc e 0
        .global ertex
        mov  dword ptr ertwa,ecx #save ecx} mov wa ertwa
        mov  dword ptr ertwb,ebx #save ebx} mov wb ertwb
        call sysem          #get failure message text} jsr sysem
        mov  esi,edi        #copy pointer to it} mov xr xl
        mov  ecx,dword ptr (4*sclen)[edi] #get length of string} mov sclen(xr) wa
        or   ecx,ecx        #jump if null} bze wa ert02
        jz   short ert02 # (jump shortened)
        xor  ebx,ebx        #offset of zero} zer wb
        call sbstr          #copy into dynamic store} jsr sbstr
        mov  dword ptr r_etx,edi #store for relocation} mov xr r_etx
#
#      return
#
ert01:  mov  ebx,dword ptr ertwb #restore ebx} mov ertwb wb
        mov  ecx,dword ptr ertwa #restore ecx} mov ertwa wa
        ret                 #return to caller} exi
#
#      return errtext contents instead of null
#
ert02:  mov  edi,dword ptr r_etx #get errtext} mov r_etx xr
        jmp  ert01          #return} brn ert01
                            #} enp
                            #} ejc
        .eject
#
#      evali -- evaluate integer argument
#
#      evali is used by pattern primitives len,tab,rtab,pos,rpos
#      when their argument is an expression value.
#
#      (xr)                  node pointer
#      (wb)                  cursor
#      jsr  evali            call to evaluate integer
#      ppm  loc              transfer loc for non-integer arg
#      ppm  loc              transfer loc for out of range arg
#      ppm  loc              transfer loc for evaluation failure
#      ppm  loc              transfer loc for successful eval
#      (the normal return is never taken)
#      (xr)                  ptr to node with integer argument
#      (wc,xl,ra)            destroyed
#
#      on return, the node pointed to has the integer argument
#      in parm1 and the proper successor pointer in pthen.
#      this allows merging with the normal (integer arg) case.
#
evali:                      #entry point (recursive)} prc r 4
        .global evali
        call evalp          #evaluate expression} jsr evalp
        .short evli1-dffnc  #jump on failure} ppm evli1
        push esi            #stack result for gtsmi} mov xl -(xs)
        mov  esi,dword ptr (4*pthen)[edi] #load successor pointer} mov pthen(xr) xl
        mov  dword ptr evlio,edi #save original node pointer} mov xr evlio
        mov  dword ptr evlif,edx #zero if simple argument} mov wc evlif
        call gtsmi          #convert arg to small integer} jsr gtsmi
        .short evli2-dffnc  #jump if not integer} ppm evli2
        .short evli3-dffnc  #jump if out of range} ppm evli3
        mov  dword ptr evliv,edi #store result in special dummy node} mov xr evliv
        mov  edi,offset evlin #point to dummy node with result} mov =evlin xr
        mov  dword ptr [edi],offset p_len #dummy pattern block pcode} mov =p_len (xr)
        mov  dword ptr (4*pthen)[edi],esi #store successor pointer} mov xl pthen(xr)
        pop  eax            #take successful exit} exi 4
        jmp  exi__4
#
#      here if evaluation fails
#
evli1:  pop  eax            #take failure return} exi 3
        jmp  exi__3
#
#      here if argument is not integer
#
evli2:  pop  eax            #take non-integer error exit} exi 1
        jmp  exi__1
#
#      here if argument is out of range
#
evli3:  pop  eax            #take out-of-range error exit} exi 2
        jmp  exi__2
                            #end procedure evali} enp
                            #} ejc
        .eject
#
#      evalp -- evaluate expression during pattern match
#
#      evalp is used to evaluate an expression (by value) during
#      a pattern match. the effect is like evalx, but pattern
#      variables are stacked and restored if necessary.
#
#      evalp also differs from evalx in that if the result is
#      an expression it is reevaluated. this occurs repeatedly.
#
#      to support optimization of pos and rpos, evalp uses wc
#      to signal the caller for the case of a simple vrblk
#      that is not an expression and is not trapped.  because
#      this case cannot have any side effects, optimization is
#      possible.
#
#      (xr)                  node pointer
#      (wb)                  pattern match cursor
#      jsr  evalp            call to evaluate expression
#      ppm  loc              transfer loc if evaluation fails
#      (xl)                  result
#      (wa)                  first word of result block
#      (wc)                  zero if simple vrblk, else non-zero
#      (xr,wb)               destroyed (failure case only)
#      (ra)                  destroyed
#
#      the expression pointer is stored in parm1 of the node
#
#      control returns to failp on failure of evaluation
#
evalp:                      #entry point (recursive)} prc r 1
        .global evalp
        mov  esi,dword ptr (4*parm1)[edi] #load expression pointer} mov parm1(xr) xl
        cmp  dword ptr [esi],offset b_exl #jump if exblk case} beq (xl) =b_exl evlp1
        je   short evlp1 # (jump shortened)
#
#      here for case of seblk
#
#      we can give a fast return if the value of the vrblk is
#      not an expression and is not trapped.
#
        mov  esi,dword ptr (4*sevar)[esi] #load vrblk pointer} mov sevar(xl) xl
        mov  esi,dword ptr (4*vrval)[esi] #load value of vrblk} mov vrval(xl) xl
        mov  ecx,dword ptr [esi] #load first word of value} mov (xl) wa
        cmp  ecx,offset b_t__ #jump if not seblk, trblk or exblk} bhi wa =b_t__ evlp3
        ja   evlp3
#
#      here for exblk or seblk with expr value or trapped value
#
evlp1:  cmp  esp,lowspmin   #check for stack space} chk
        jb   sec06
        push edi            #stack node pointer} mov xr -(xs)
        push ebx            #stack cursor} mov wb -(xs)
        push dword ptr r_pms #stack subject string pointer} mov r_pms -(xs)
        push dword ptr pmssl #stack subject string length} mov pmssl -(xs)
        push dword ptr pmdfl #stack dot flag} mov pmdfl -(xs)
        push dword ptr pmhbs #stack history stack base pointer} mov pmhbs -(xs)
        mov  edi,dword ptr (4*parm1)[edi] #load expression pointer} mov parm1(xr) xr
                            #} ejc
        .eject
#
#      evalp (continued)
#
#      loop back here to reevaluate expression result
#
evlp2:  xor  ebx,ebx        #set flag for by value} zer wb
        call evalx          #evaluate expression} jsr evalx
        .short evlp4-dffnc  #jump on failure} ppm evlp4
        mov  ecx,dword ptr [edi] #else load first word of value} mov (xr) wa
        cmp  ecx,offset b_e__ #loop back to reevaluate expression} blo wa =b_e__ evlp2
        jb   evlp2
#
#      here to restore pattern values after successful eval
#
        mov  esi,edi        #copy result pointer} mov xr xl
        pop  dword ptr pmhbs #restore history stack base pointer} mov (xs)+ pmhbs
        pop  dword ptr pmdfl #restore dot flag} mov (xs)+ pmdfl
        pop  dword ptr pmssl #restore subject string length} mov (xs)+ pmssl
        pop  dword ptr r_pms #restore subject string pointer} mov (xs)+ r_pms
        pop  ebx            #restore cursor} mov (xs)+ wb
        pop  edi            #restore node pointer} mov (xs)+ xr
        mov  edx,edi        #non-zero for simple vrblk} mov xr wc
        pop  eax            #return to evalp caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here to return after simple vrblk case
#
evlp3:  xor  edx,edx        #simple vrblk, no side effects} zer wc
        pop  eax            #return to evalp caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here for failure during evaluation
#
evlp4:  pop  dword ptr pmhbs #restore history stack base pointer} mov (xs)+ pmhbs
        pop  dword ptr pmdfl #restore dot flag} mov (xs)+ pmdfl
        pop  dword ptr pmssl #restore subject string length} mov (xs)+ pmssl
        pop  dword ptr r_pms #restore subject string pointer} mov (xs)+ r_pms
        add  esp,4*num02    #remove node ptr, cursor} add *num02 xs
        pop  eax            #take failure exit} exi 1
        jmp  exi__1
                            #end procedure evalp} enp
                            #} ejc
        .eject
#
#      evals -- evaluate string argument
#
#      evals is used by span, any, notany, break, breakx when
#      they are passed an expression argument.
#
#      (xr)                  node pointer
#      (wb)                  cursor
#      jsr  evals            call to evaluate string
#      ppm  loc              transfer loc for non-string arg
#      ppm  loc              transfer loc for evaluation failure
#      ppm  loc              transfer loc for successful eval
#      (the normal return is never taken)
#      (xr)                  ptr to node with parms set
#      (xl,wc,ra)            destroyed
#
#      on return, the node pointed to has a character table
#      pointer in parm1 and a bit mask in parm2. the proper
#      successor is stored in pthen of this node. thus it is
#      ok for merging with the normal (multi-char string) case.
#
evals:                      #entry point (recursive)} prc r 3
        .global evals
        call evalp          #evaluate expression} jsr evalp
        .short evls1-dffnc  #jump if evaluation fails} ppm evls1
        push dword ptr (4*pthen)[edi] #save successor pointer} mov pthen(xr) -(xs)
        push ebx            #save cursor} mov wb -(xs)
        push esi            #stack result ptr for patst} mov xl -(xs)
        xor  ebx,ebx        #dummy pcode for one char string} zer wb
        xor  edx,edx        #dummy pcode for expression arg} zer wc
        mov  esi,offset p_brk #appropriate pcode for our use} mov =p_brk xl
        call patst          #call routine to build node} jsr patst
        .short evls2-dffnc  #jump if not string} ppm evls2
        pop  ebx            #restore cursor} mov (xs)+ wb
        pop  dword ptr (4*pthen)[edi] #store successor pointer} mov (xs)+ pthen(xr)
        pop  eax            #take success return} exi 3
        jmp  exi__3
#
#      here if evaluation fails
#
evls1:  pop  eax            #take failure return} exi 2
        jmp  exi__2
#
#      here if argument is not string
#
evls2:  add  esp,4*num02    #pop successor and cursor} add *num02 xs
        pop  eax            #take non-string error exit} exi 1
        jmp  exi__1
                            #end procedure evals} enp
                            #} ejc
        .eject
#
#      evalx -- evaluate expression
#
#      evalx is called to evaluate an expression
#
#      (xr)                  pointer to exblk or seblk
#      (wb)                  0 if by value, 1 if by name
#      jsr  evalx            call to evaluate expression
#      ppm  loc              transfer loc if evaluation fails
#      (xr)                  result if called by value
#      (xl,wa)               result name base,offset if by name
#      (xr)                  destroyed (name case only)
#      (xl,wa)               destroyed (value case only)
#      (wb,wc,ra)            destroyed
#
evalx:                      #entry point, recursive} prc r 1
        .global evalx
        cmp  dword ptr [edi],offset b_exl #jump if exblk case} beq (xr) =b_exl evlx2
        je   evlx2
#
#      here for seblk
#
        mov  esi,dword ptr (4*sevar)[edi] #load vrblk pointer (name base)} mov sevar(xr) xl
        mov  ecx,4*vrval    #set name offset} mov *vrval wa
        or   ebx,ebx        #jump if called by name} bnz wb evlx1
        jnz  short evlx1 # (jump shortened)
        call acess          #call routine to access value} jsr acess
        .short evlx9-dffnc  #jump if failure on access} ppm evlx9
#
#      merge here to exit for seblk case
#
evlx1:  pop  eax            #return to evalx caller} exi
        lea  eax,[eax+2]
        jmp  eax
                            #} ejc
        .eject
#
#      evalx (continued)
#
#      here for full expression (exblk) case
#
#      if an error occurs in the expression code at execution
#      time, control is passed via error section to exfal
#      without returning to this routine.
#      the following entries are made on the stack before
#      giving control to the expression code
#
#                            evalx return point
#                            saved value of r$cod
#                            code pointer (-r$cod)
#                            saved value of flptr
#                            0 if by value, 1 if by name
#      flptr --------------- *exflc, fail offset in exblk
#
evlx2:  mov  edx,ebp        #get code pointer} scp wc
        mov  ecx,dword ptr r_cod #load code block pointer} mov r_cod wa
        sub  edx,ecx        #get code pointer as offset} sub wa wc
        push ecx            #stack old code block pointer} mov wa -(xs)
        push edx            #stack relative code offset} mov wc -(xs)
        push dword ptr flptr #stack old failure pointer} mov flptr -(xs)
        push ebx            #stack name/value indicator} mov wb -(xs)
        push 4*exflc        #stack new fail offset} mov *exflc -(xs)
        mov  eax,dword ptr flptr #keep in case of error} mov flptr gtcef
        mov  dword ptr gtcef,eax
        mov  eax,dword ptr r_cod #keep code block pointer similarly} mov r_cod r_gtc
        mov  dword ptr r_gtc,eax
        mov  dword ptr flptr,esp #set new failure pointer} mov xs flptr
        mov  dword ptr r_cod,edi #set new code block pointer} mov xr r_cod
        mov  eax,dword ptr kvstn #remember stmnt number} mov kvstn exstm(xr)
        mov  dword ptr (4*exstm)[edi],eax
        add  edi,4*excod    #point to first code word} add *excod xr
        mov  ebp,edi        #set code pointer} lcp xr
        cmp  dword ptr stage,stgxt #jump if not execution time} bne stage =stgxt evlx0
        jne  short evlx0 # (jump shortened)
        mov  dword ptr stage,stgee #evaluating expression} mov =stgee stage
#
#      here to execute first code word of expression
#
evlx0:  xor  esi,esi        #clear garbage esi} zer xl
        mov  edi,[ebp]      #load first code word} lcw xr
        add  ebp,4
        jmp  dword ptr [edi] #execute it} bri (xr)
                            #} ejc
        .eject
#
#      evalx (continued)
#
#      come here if successful return by value (see o$rvl)
#
evlx3:  pop  edi            #load value} mov (xs)+ xr
        cmp  dword ptr dword ptr (4*num01)[esp],0 #jump if called by value} bze num01(xs) evlx5
        jz   short evlx5 # (jump shortened)
        call err_0          #} erb 249 expression evaluated by name returned value
        .byte 249
#
#      here for expression returning by name (see o$rnm)
#
evlx4:  pop  ecx            #load name offset} mov (xs)+ wa
        pop  esi            #load name base} mov (xs)+ xl
        cmp  dword ptr dword ptr (4*num01)[esp],0 #jump if called by name} bnz num01(xs) evlx5
        jnz  short evlx5 # (jump shortened)
        call acess          #else access value first} jsr acess
        .short evlx6-dffnc  #jump if failure during access} ppm evlx6
#
#      here after loading correct result into xr or xl,wa
#
evlx5:  xor  ebx,ebx        #note successful} zer wb
        jmp  short evlx7          #merge} brn evlx7 # (jump shortened)
#
#      here for failure in expression evaluation (see o$fex)
#
evlx6:  mov  ebx,esp        #note unsuccessful} mnz wb
#
#      restore environment
#
evlx7:  cmp  dword ptr stage,stgee #skip if was not previously esi} bne stage =stgee evlx8
        jne  short evlx8 # (jump shortened)
        mov  dword ptr stage,stgxt #execute time} mov =stgxt stage
#
#      merge with stage set up
#
evlx8:  add  esp,4*num02    #pop name/value indicator, *exfal} add *num02 xs
        pop  dword ptr flptr #restore old failure pointer} mov (xs)+ flptr
        pop  edx            #load code offset} mov (xs)+ wc
        add  edx,dword ptr [esp] #make code pointer absolute} add (xs) wc
        pop  dword ptr r_cod #restore old code block pointer} mov (xs)+ r_cod
        mov  ebp,edx        #restore old code pointer} lcp wc
        or   ebx,ebx        #jump for successful return} bze wb evlx1
        jz   evlx1
#
#      merge here for failure in seblk case
#
evlx9:  pop  eax            #take failure exit} exi 1
        jmp  exi__1
                            #end of procedure evalx} enp
                            #} ejc
        .eject
#
#      exbld -- build exblk
#
#      exbld is used to build an expression block from the
#      code compiled most recently in the current ccblk.
#
#      (xl)                  offset in ccblk to start of code
#      (wb)                  integer in range 0 le n le mxlen
#      jsr  exbld            call to build exblk
#      (xr)                  ptr to constructed exblk
#      (wa,wb,xl)            destroyed
#
exbld:                      #entry point} prc e 0
        .global exbld
        mov  ecx,esi        #copy offset to start of code} mov xl wa
        sub  ecx,4*excod    #calc reduction in offset in exblk} sub *excod wa
        push ecx            #stack for later} mov wa -(xs)
        mov  ecx,dword ptr cwcof #load final offset} mov cwcof wa
        sub  ecx,esi        #compute length of code} sub xl wa
        add  ecx,4*exsi_    #add space for standard fields} add *exsi_ wa
        call alloc          #allocate space for exblk} jsr alloc
        push edi            #save pointer to exblk} mov xr -(xs)
        mov  dword ptr (4*extyp)[edi],offset b_exl #store type word} mov =b_exl extyp(xr)
        xor  eax,eax        #zeroise stmnt number field} zer exstm(xr)
        mov  dword ptr (4*exstm)[edi],eax
        mov  eax,dword ptr cmpln #set line number field} mov cmpln exsln(xr)
        mov  dword ptr (4*exsln)[edi],eax
        mov  dword ptr (4*exlen)[edi],ecx #store length} mov wa exlen(xr)
        mov  dword ptr (4*exflc)[edi],offset ofex_ #store failure word} mov =ofex_ exflc(xr)
        add  edi,4*exsi_    #set edi for mvw} add *exsi_ xr
        mov  dword ptr cwcof,esi #reset offset to start of code} mov xl cwcof
        add  esi,dword ptr r_ccb #point to start of code} add r_ccb xl
        sub  ecx,4*exsi_    #length of code to move} sub *exsi_ wa
        push ecx            #stack length of code} mov wa -(xs)
        shr  ecx,2          #move code to exblk} mvw
        rep  movsd
        pop  ecx            #get length of code} mov (xs)+ wa
        shr  ecx,2          #convert byte count to word count} btw wa
        mov  esi,dword ptr [esp] #copy exblk ptr, dont unstack} mov (xs) xl
        add  esi,4*excod    #point to code itself} add *excod xl
        mov  ebx,dword ptr (4*num01)[esp] #get reduction in offset} mov num01(xs) wb
#
#      this loop searches for negation and selection code so
#      that the offsets computed whilst code was in code block
#      can be transformed to reduced values applicable in an
#      exblk.
#
exbl1:  lodsd               #get next code word} mov (xl)+ xr
        mov  edi,eax
        cmp  edi,offset osla_ #jump if selection found} beq xr =osla_ exbl3
        je   short exbl3 # (jump shortened)
        cmp  edi,offset onta_ #jump if negation found} beq xr =onta_ exbl3
        je   short exbl3 # (jump shortened)
        loop exbl1          #loop to end of code} bct wa exbl1
#
#      no selection found or merge to exit on termination
#
exbl2:  pop  edi            #pop exblk ptr into edi} mov (xs)+ xr
        pop  esi            #pop reduction constant} mov (xs)+ xl
        ret                 #return to caller} exi
                            #} ejc
        .eject
#
#      exbld (continued)
#
#      selection or negation found
#      reduce the offsets as needed. offsets occur in words
#      following code words -
#           =onta$, =osla$, =oslb$, =oslc$
#
exbl3:  sub  dword ptr [esi],ebx #adjust offset} sub wb (xl)+
        lea  esi,[esi+4]
        loop exbl4          #decrement count} bct wa exbl4
#
exbl4:  loop exbl5          #decrement count} bct wa exbl5
#
#      continue search for more offsets
#
exbl5:  lodsd               #get next code word} mov (xl)+ xr
        mov  edi,eax
        cmp  edi,offset osla_ #jump if offset found} beq xr =osla_ exbl3
        je   exbl3
        cmp  edi,offset oslb_ #jump if offset found} beq xr =oslb_ exbl3
        je   exbl3
        cmp  edi,offset oslc_ #jump if offset found} beq xr =oslc_ exbl3
        je   exbl3
        cmp  edi,offset onta_ #jump if offset found} beq xr =onta_ exbl3
        je   exbl3
        loop exbl5          #loop} bct wa exbl5
        jmp  exbl2          #merge to return} brn exbl2
                            #end procedure exbld} enp
                            #} ejc
        .eject
#
#      expan -- analyze expression
#
#      the expression analyzer (expan) procedure is used to scan
#      an expression and convert it into a tree representation.
#      see the description of cmblk in the structures section
#      for detailed format of tree blocks.
#
#      the analyzer uses a simple precedence scheme in which
#      operands and operators are placed on a single stack
#      and condensations are made when low precedence operators
#      are stacked after a higher precedence operator. a global
#      variable (in wb) keeps track of the level as follows.
#
#      0    scanning outer level of statement or expression
#      1    scanning outer level of normal goto
#      2    scanning outer level of direct goto
#      3    scanning inside array brackets
#      4    scanning inside grouping parentheses
#      5    scanning inside function parentheses
#
#      this variable is saved on the stack on encountering a
#      grouping and restored at the end of the grouping.
#
#      another global variable (in wc) counts the number of
#      items at one grouping level and is incremented for each
#      comma encountered. it is stacked with the level indicator
#
#      the scan is controlled by a three state finite machine.
#      a global variable stored in wa is the current state.
#
#      wa=0                  nothing scanned at this level
#      wa=1                  operand expected
#      wa=2                  operator expected
#
#      (wb)                  call type (see below)
#      jsr  expan            call to analyze expression
#      (xr)                  pointer to resulting tree
#      (xl,wa,wb,wc,ra)      destroyed
#
#      the entry value of wb indicates the call type as follows.
#
#      0    scanning either the main body of a statement or the
#           text of an expression (from eval call). valid
#           terminators are colon, semicolon. the rescan flag is
#           set to return the terminator on the next scane call.
#
#      1    scanning a normal goto. the only valid
#           terminator is a right paren.
#
#      2    scanning a direct goto. the only valid
#           terminator is a right bracket.
                            #} ejc
        .eject
#
#      expan (continued)
#
#      entry point
#
expan:                      #entry point} prc e 0
        .global expan
        push 0              #set top of stack indicator} zer -(xs)
        xor  ecx,ecx        #set initial state to zero} zer wa
        xor  edx,edx        #zero counter value} zer wc
#
#      loop here for successive entries
#
exp01:  call scane          #scan next element} jsr scane
        add  esi,ecx        #add state to syntax code} add wa xl
        jmp  dword ptr l0012[esi*4] #switch on element type/state} bsw xl t_nes
        dseg_
l0012:
        .long exp27         #unop, s=0} iff t_uo0 exp27
        .long exp27         #unop, s=1} iff t_uo1 exp27
        .long exp04         #unop, s=2} iff t_uo2 exp04
        .long exp06         #left paren, s=0} iff t_lp0 exp06
        .long exp06         #left paren, s=1} iff t_lp1 exp06
        .long exp04         #left paren, s=2} iff t_lp2 exp04
        .long exp08         #left brkt, s=0} iff t_lb0 exp08
        .long exp08         #left brkt, s=1} iff t_lb1 exp08
        .long exp09         #left brkt, s=2} iff t_lb2 exp09
        .long exp02         #comma, s=0} iff t_cm0 exp02
        .long exp05         #comma, s=1} iff t_cm1 exp05
        .long exp11         #comma, s=2} iff t_cm2 exp11
        .long exp10         #function, s=0} iff t_fn0 exp10
        .long exp10         #function, s=1} iff t_fn1 exp10
        .long exp04         #function, s=2} iff t_fn2 exp04
        .long exp03         #variable, s=0} iff t_va0 exp03
        .long exp03         #variable, state one} iff t_va1 exp03
        .long exp04         #variable, s=2} iff t_va2 exp04
        .long exp03         #constant, s=0} iff t_co0 exp03
        .long exp03         #constant, s=1} iff t_co1 exp03
        .long exp04         #constant, s=2} iff t_co2 exp04
        .long exp05         #binop, s=0} iff t_bo0 exp05
        .long exp05         #binop, s=1} iff t_bo1 exp05
        .long exp26         #binop, s=2} iff t_bo2 exp26
        .long exp02         #right paren, s=0} iff t_rp0 exp02
        .long exp05         #right paren, s=1} iff t_rp1 exp05
        .long exp12         #right paren, s=2} iff t_rp2 exp12
        .long exp02         #right brkt, s=0} iff t_rb0 exp02
        .long exp05         #right brkt, s=1} iff t_rb1 exp05
        .long exp18         #right brkt, s=2} iff t_rb2 exp18
        .long exp02         #colon, s=0} iff t_cl0 exp02
        .long exp05         #colon, s=1} iff t_cl1 exp05
        .long exp19         #colon, s=2} iff t_cl2 exp19
        .long exp02         #semicolon, s=0} iff t_sm0 exp02
        .long exp05         #semicolon, s=1} iff t_sm1 exp05
        .long exp19         #semicolon, s=2} iff t_sm2 exp19
        dsegend_            #end switch on element type/state} esw
        cseg_
                            #} ejc
        .eject
#
#      expan (continued)
#
#      here for rbr,rpr,col,smc,cma in state 0
#
#      set to rescan the terminator encountered and create
#      a null constant (case of omitted null)
#
exp02:  mov  dword ptr scnrs,esp #set to rescan element} mnz scnrs
        mov  edi,offset nulls #point to null, merge} mov =nulls xr
#
#      here for var or con in states 0,1
#
#      stack the variable/constant and set state=2
#
exp03:  push edi            #stack pointer to operand} mov xr -(xs)
        mov  ecx,num02      #set state 2} mov =num02 wa
        jmp  exp01          #jump for next element} brn exp01
#
#      here for var,con,lpr,fnc,uop in state 2
#
#      we rescan the element and create a concatenation operator
#      this is the case of the blank concatenation operator.
#
exp04:  mov  dword ptr scnrs,esp #set to rescan element} mnz scnrs
        mov  edi,offset opdvc #point to concat operator dv} mov =opdvc xr
        or   ebx,ebx        #ok if at top level} bze wb exp4a
        jz   short exp4a # (jump shortened)
        mov  edi,offset opdvp #else point to unmistakable concat.} mov =opdvp xr
#
#      merge here when xr set up with proper concatenation dvblk
#
exp4a:  cmp  dword ptr dword ptr scnbl,0 #merge bop if blanks, else error} bnz scnbl exp26
        jnz  exp26
#      dcv  scnse            adjust start of element location
        call err_0          #} erb 220 syntax error: missing operator
        .byte 220
#
#      here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)
#
#      this is an erronous contruction
#
#exp05 dcv  scnse            adjust start of element location
exp05:  call err_0          #} erb 221 syntax error: missing operand
        .byte 221
#
#      here for lpr (s=0,1)
#
exp06:  mov  esi,num04      #set new level indicator} mov =num04 xl
        xor  edi,edi        #set zero value for cmopn} zer xr
                            #} ejc
        .eject
#
#      expan (continued)
#
#      merge here to store old level on stack and start new one
#
exp07:  push edi            #stack cmopn value} mov xr -(xs)
        push edx            #stack old counter} mov wc -(xs)
        push ebx            #stack old level indicator} mov wb -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        xor  ecx,ecx        #set new state to zero} zer wa
        mov  ebx,esi        #set new level indicator} mov xl wb
        mov  edx,num01      #initialize new counter} mov =num01 wc
        jmp  exp01          #jump to scan next element} brn exp01
#
#      here for lbr (s=0,1)
#
#      this is an illegal use of left bracket
#
exp08:  call err_0          #} erb 222 syntax error: invalid use of left bracket
        .byte 222
#
#      here for lbr (s=2)
#
#      set new level and start to scan subscripts
#
exp09:  pop  edi            #load array ptr for cmopn} mov (xs)+ xr
        mov  esi,num03      #set new level indicator} mov =num03 xl
        jmp  exp07          #jump to stack old and start new} brn exp07
#
#      here for fnc (s=0,1)
#
#      stack old level and start to scan arguments
#
exp10:  mov  esi,num05      #set new lev indic (edi=vrblk=cmopn)} mov =num05 xl
        jmp  exp07          #jump to stack old and start new} brn exp07
#
#      here for cma (s=2)
#
#      increment argument count and continue
#
exp11:  inc  edx            #increment counter} icv wc
        call expdm          #dump operators at this level} jsr expdm
        push 0              #set new level for parameter} zer -(xs)
        xor  ecx,ecx        #set new state} zer wa
        cmp  ebx,num02      #loop back unless outer level} bgt wb =num02 exp01
        ja   exp01
        call err_0          #} erb 223 syntax error: invalid use of comma
        .byte 223
                            #} ejc
        .eject
#
#      expan (continued)
#
#      here for rpr (s=2)
#
#      at outer level in a normal goto this is a terminator
#      otherwise it must terminate a function or grouping
#
exp12:  cmp  ebx,num01      #end of normal goto} beq wb =num01 exp20
        je   exp20
        cmp  ebx,num05      #end of function arguments} beq wb =num05 exp13
        je   short exp13 # (jump shortened)
        cmp  ebx,num04      #end of grouping / selection} beq wb =num04 exp14
        je   short exp14 # (jump shortened)
        call err_0          #} erb 224 syntax error: unbalanced right parenthesis
        .byte 224
#
#      here at end of function arguments
#
exp13:  mov  esi,c_fnc      #set cmtyp value for function} mov =c_fnc xl
        jmp  short exp15          #jump to build cmblk} brn exp15 # (jump shortened)
#
#      here for end of grouping
#
exp14:  cmp  edx,num01      #jump if end of grouping} beq wc =num01 exp17
        je   exp17
        mov  esi,c_sel      #else set cmtyp for selection} mov =c_sel xl
#
#      merge here to build cmblk for level just scanned and
#      to pop up to the previous scan level before continuing.
#
exp15:  call expdm          #dump operators at this level} jsr expdm
        mov  ecx,edx        #copy count} mov wc wa
        add  ecx,cmvls      #add for standard fields at start} add =cmvls wa
        sal  ecx,2          #convert length to bytes} wtb wa
        call alloc          #allocate space for cmblk} jsr alloc
        mov  dword ptr [edi],offset b_cmt #store type code for cmblk} mov =b_cmt (xr)
        mov  dword ptr (4*cmtyp)[edi],esi #store cmblk node type indicator} mov xl cmtyp(xr)
        mov  dword ptr (4*cmlen)[edi],ecx #store length} mov wa cmlen(xr)
        add  edi,ecx        #point past end of block} add wa xr
#
#      loop to move remaining words to cmblk
#
exp16:  lea  edi,[edi-4]    #move one operand ptr from stack} mov (xs)+ -(xr)
        pop  dword ptr [edi]
        pop  ebx            #pop to old level indicator} mov (xs)+ wb
        dec  edx            #loop till all moved} bct wc exp16
        jnz  exp16
                            #} ejc
        .eject
#
#      expan (continued)
#
#      complete cmblk and stack pointer to it on stack
#
        sub  edi,4*cmvls    #point back to start of block} sub *cmvls xr
        pop  edx            #restore old counter} mov (xs)+ wc
        mov  eax,dword ptr [esp] #store operand ptr in cmblk} mov (xs) cmopn(xr)
        mov  dword ptr (4*cmopn)[edi],eax
        mov  dword ptr [esp],edi #stack cmblk pointer} mov xr (xs)
        mov  ecx,num02      #set new state} mov =num02 wa
        jmp  exp01          #back for next element} brn exp01
#
#      here at end of a parenthesized expression
#
exp17:  call expdm          #dump operators at this level} jsr expdm
        pop  edi            #restore edi} mov (xs)+ xr
        pop  ebx            #restore outer level} mov (xs)+ wb
        pop  edx            #restore outer count} mov (xs)+ wc
        mov  dword ptr [esp],edi #store opnd over unused cmopn val} mov xr (xs)
        mov  ecx,num02      #set new state} mov =num02 wa
        jmp  exp01          #back for next ele8ent} brn exp01
#
#      here for rbr (s=2)
#
#      at outer level in a direct goto, this is a terminator.
#      otherwise it must terminate a subscript list.
#
exp18:  mov  esi,c_arr      #set cmtyp for array reference} mov =c_arr xl
        cmp  ebx,num03      #jump to build cmblk if end arrayref} beq wb =num03 exp15
        je   exp15
        cmp  ebx,num02      #jump if end of direct goto} beq wb =num02 exp20
        je   exp20
        call err_0          #} erb 225 syntax error: unbalanced right bracket
        .byte 225
                            #} ejc
        .eject
#
#      expan (continued)
#
#      here for col,smc (s=2)
#
#      error unless terminating statement body at outer level
#
exp19:  mov  dword ptr scnrs,esp #rescan terminator} mnz scnrs
        mov  esi,ebx        #copy level indicator} mov wb xl
        jmp  dword ptr l0013[esi*4] #switch on level indicator} bsw xl 6
        dseg_
l0013:
        .long exp20         #normal outer level} iff 0 exp20
        .long exp22         #fail if normal goto} iff 1 exp22
        .long exp23         #fail if direct goto} iff 2 exp23
        .long exp24         #fail array brackets} iff 3 exp24
        .long exp21         #fail if in grouping} iff 4 exp21
        .long exp21         #fail function args} iff 5 exp21
        dsegend_            #end switch on level} esw
        cseg_
#
#      here at normal end of expression
#
exp20:  call expdm          #dump remaining operators} jsr expdm
        pop  edi            #load tree pointer} mov (xs)+ xr
        add  esp,4          #pop off bottom of stack marker} ica xs
        ret                 #return to expan caller} exi
#
#      missing right paren
#
exp21:  call err_0          #} erb 226 syntax error: missing right paren
        .byte 226
#
#      missing right paren in goto field
#
exp22:  call err_0          #} erb 227 syntax error: right paren missing from goto
        .byte 227
#
#      missing bracket in goto
#
exp23:  call err_0          #} erb 228 syntax error: right bracket missing from goto
        .byte 228
#
#      missing array bracket
#
exp24:  call err_0          #} erb 229 syntax error: missing right array bracket
        .byte 229
                            #} ejc
        .eject
#
#      expan (continued)
#
#      loop here when an operator causes an operator dump
#
exp25:  mov  dword ptr expsv,edi #} mov xr expsv
        call expop          #pop one operator} jsr expop
        mov  edi,dword ptr expsv #restore op dv pointer and merge} mov expsv xr
#
#      here for bop (s=2)
#
#      remove operators (condense) from stack until no more
#      left at this level or top one has lower precedence.
#      loop here till this condition is met.
#
exp26:  mov  esi,dword ptr (4*num01)[esp] #load operator dvptr from stack} mov num01(xs) xl
        cmp  esi,num05      #jump if bottom of stack level} ble xl =num05 exp27
        jbe  short exp27 # (jump shortened)
        mov  eax,dword ptr (4*dvrpr)[edi] #else pop if new prec is lo} blt dvrpr(xr) dvlpr(xl) exp25
        cmp  eax,dword ptr (4*dvlpr)[esi]
        jb   exp25
#
#      here for uop (s=0,1)
#
#      binary operator merges after precedence check
#
#      the operator dv is stored on the stack and the scan
#      continues after setting the scan state to one.
#
exp27:  push edi            #stack operator dvptr on stack} mov xr -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        mov  ecx,num01      #set new state} mov =num01 wa
        cmp  edi,offset opdvs #back for next element unless =} bne xr =opdvs exp01
        jne  exp01
#
#      here for special case of binary =. the syntax allows a
#      null right argument for this operator to be left
#      out. accordingly we reset to state zero to get proper
#      action on a terminator (supply a null constant).
#
        xor  ecx,ecx        #set state zero} zer wa
        jmp  exp01          #jump for next element} brn exp01
                            #end procedure expan} enp
                            #} ejc
        .eject
#
#      expap -- test for pattern match tree
#
#      expap is passed an expression tree to determine if it
#      is a pattern match. the following are recogized as
#      matches in the context of this call.
#
#      1)   an explicit use of binary question mark
#      2)   a concatenation
#      3)   an alternation whose left operand is a concatenation
#
#      (xr)                  ptr to expan tree
#      jsr  expap            call to test for pattern match
#      ppm  loc              transfer loc if not a pattern match
#      (wa)                  destroyed
#      (xr)                  unchanged (if not match)
#      (xr)                  ptr to binary operator blk if match
#
expap:                      #entry point} prc e 1
        .global expap
        push esi            #save esi} mov xl -(xs)
        cmp  dword ptr [edi],offset b_cmt #no match if not complex} bne (xr) =b_cmt expp2
        jne  expp2
        mov  ecx,dword ptr (4*cmtyp)[edi] #else load type code} mov cmtyp(xr) wa
        cmp  ecx,c_cnc      #concatenation is a match} beq wa =c_cnc expp1
        je   short expp1 # (jump shortened)
        cmp  ecx,c_pmt      #binary question mark is a match} beq wa =c_pmt expp1
        je   short expp1 # (jump shortened)
        cmp  ecx,c_alt      #else not match unless alternation} bne wa =c_alt expp2
        jne  short expp2 # (jump shortened)
#
#      here for alternation. change (a b) / c to a qm (b / c)
#
        mov  esi,dword ptr (4*cmlop)[edi] #load left operand pointer} mov cmlop(xr) xl
        cmp  dword ptr [esi],offset b_cmt #not match if left opnd not complex} bne (xl) =b_cmt expp2
        jne  short expp2 # (jump shortened)
        cmp  dword ptr (4*cmtyp)[esi],c_cnc #not match if left op not conc} bne cmtyp(xl) =c_cnc expp2
        jne  short expp2 # (jump shortened)
        mov  eax,dword ptr (4*cmrop)[esi] #edi points to (b / c)} mov cmrop(xl) cmlop(xr)
        mov  dword ptr (4*cmlop)[edi],eax
        mov  dword ptr (4*cmrop)[esi],edi #set esi opnds to a, (b / c)} mov xr cmrop(xl)
        mov  edi,esi        #point to this altered node} mov xl xr
#
#      exit here for pattern match
#
expp1:  pop  esi            #restore entry esi} mov (xs)+ xl
        pop  eax            #give pattern match return} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      exit here if not pattern match
#
expp2:  pop  esi            #restore entry esi} mov (xs)+ xl
        pop  eax            #give non-match return} exi 1
        jmp  exi__1
                            #end procedure expap} enp
                            #} ejc
        .eject
#
#      expdm -- dump operators at current level (for expan)
#
#      expdm uses expop to condense all operators at this syntax
#      level. the stack bottom is recognized from the level
#      value which is saved on the top of the stack.
#
#      jsr  expdm            call to dump operators
#      (xs)                  popped as required
#      (xr,wa)               destroyed
#
expdm:                      #entry point} prc n 0
        .global expdm
        pop  prc_+12
        mov  dword ptr r_exs,esi #save esi value} mov xl r_exs
#
#      loop to dump operators
#
exdm1:  cmp  dword ptr (4*num01)[esp],num05 #jump if stack bottom (saved level} ble num01(xs) =num05 exdm2
        jbe  short exdm2 # (jump shortened)
        call expop          #else pop one operator} jsr expop
        jmp  exdm1          #and loop back} brn exdm1
#
#      here after popping all operators
#
exdm2:  mov  esi,dword ptr r_exs #restore esi} mov r_exs xl
        xor  eax,eax        #release save location} zer r_exs
        mov  dword ptr r_exs,eax
        jmp  [prc_+12]      #return to expdm caller} exi
                            #end procedure expdm} enp
                            #} ejc
        .eject
#
#      expop-- pop operator (for expan)
#
#      expop is used by the expan routine to condense one
#      operator from the top of the syntax stack. an appropriate
#      cmblk is built for the operator (unary or binary) and a
#      pointer to this cmblk is stacked.
#
#      expop is also used by scngf (goto field scan) procedure
#
#      jsr  expop            call to pop operator
#      (xs)                  popped appropriately
#      (xr,xl,wa)            destroyed
#
expop:                      #entry point} prc n 0
        .global expop
        pop  prc_+16
        mov  edi,dword ptr (4*num01)[esp] #load operator dv pointer} mov num01(xs) xr
        cmp  dword ptr (4*dvlpr)[edi],lluno #jump if unary} beq dvlpr(xr) =lluno expo2
        je   short expo2 # (jump shortened)
#
#      here for binary operator
#
        mov  ecx,4*cmbs_    #set size of binary operator cmblk} mov *cmbs_ wa
        call alloc          #allocate space for cmblk} jsr alloc
        pop  dword ptr (4*cmrop)[edi] #pop and store right operand ptr} mov (xs)+ cmrop(xr)
        pop  esi            #pop and load operator dv ptr} mov (xs)+ xl
        mov  eax,dword ptr [esp] #store left operand pointer} mov (xs) cmlop(xr)
        mov  dword ptr (4*cmlop)[edi],eax
#
#      common exit point
#
expo1:  mov  dword ptr [edi],offset b_cmt #store type code for cmblk} mov =b_cmt (xr)
        mov  eax,dword ptr (4*dvtyp)[esi] #store cmblk node type code} mov dvtyp(xl) cmtyp(xr)
        mov  dword ptr (4*cmtyp)[edi],eax
        mov  dword ptr (4*cmopn)[edi],esi #store dvptr (=ptr to dac o_xxx)} mov xl cmopn(xr)
        mov  dword ptr (4*cmlen)[edi],ecx #store cmblk length} mov wa cmlen(xr)
        mov  dword ptr [esp],edi #store resulting node ptr on stack} mov xr (xs)
        jmp  [prc_+16]      #return to expop caller} exi
#
#      here for unary operator
#
expo2:  mov  ecx,4*cmus_    #set size of unary operator cmblk} mov *cmus_ wa
        call alloc          #allocate space for cmblk} jsr alloc
        pop  dword ptr (4*cmrop)[edi] #pop and store operand pointer} mov (xs)+ cmrop(xr)
        mov  esi,dword ptr [esp] #load operator dv pointer} mov (xs) xl
        jmp  expo1          #merge back to exit} brn expo1
                            #end procedure expop} enp
                            #} ejc
        .eject
#
#      filnm -- obtain file name from statement number
#
#      filnm takes a statement number and examines the file name
#      table pointed to by r$sfn to find the name of the file
#      containing the given statement.  table entries are
#      arranged in order of ascending statement number (there
#      is only one hash bucket in this table).  elements are
#      added to the table each time there is a change in
#      file name, recording the then current statement number.
#
#      to find the file name, the linked list of teblks is
#      scanned for an element containing a subscript (statement
#      number) greater than the argument statement number, or
#      the end of chain.  when this condition is met, the
#      previous teblk contains the desired file name as its
#      value entry.
#
#      (wc)                  statement number
#      jsr  filnm            call to obtain file name
#      (xl)                  file name (scblk)
#      (ia)                  destroyed
#
filnm:                      #entry point} prc e 0
        .global filnm
        push ebx            #preserve ebx} mov wb -(xs)
        or   edx,edx        #return nulls if stno is zero} bze wc filn3
        jz   filn3
        mov  esi,dword ptr r_sfn #file name table} mov r_sfn xl
        or   esi,esi        #if no table} bze xl filn3
        jz   filn3
        mov  ebx,dword ptr (4*tbbuk)[esi] #get bucket entry} mov tbbuk(xl) wb
        cmp  ebx,dword ptr r_sfn #jump if no teblks on chain} beq wb r_sfn filn3
        je   filn3
        push edi            #preserve edi} mov xr -(xs)
        mov  edi,ebx        #previous block pointer} mov wb xr
        push edx            #preserve stmt number} mov wc -(xs)
#
#      loop through teblks on hash chain
#
filn1:  mov  esi,edi        #next element to examine} mov xr xl
        mov  edi,dword ptr (4*tesub)[esi] #load subscript value (an icblk)} mov tesub(xl) xr
        mov  edx,dword ptr (4*icval)[edi] #load the statement number} ldi icval(xr)
                            #convert to address constant} mfi wc
        cmp  dword ptr [esp],edx #compare arg with teblk stmt number} blt (xs) wc filn2
        jb   short filn2 # (jump shortened)
#
#      here if desired stmt number is ge teblk stmt number
#
        mov  ebx,esi        #save previous entry pointer} mov xl wb
        mov  edi,dword ptr (4*tenxt)[esi] #point to next teblk on chain} mov tenxt(xl) xr
        cmp  edi,dword ptr r_sfn #jump if there is one} bne xr r_sfn filn1
        jne  filn1
#
#      here if chain exhausted or desired block found.
#
filn2:  mov  esi,ebx        #previous teblk} mov wb xl
        mov  esi,dword ptr (4*teval)[esi] #get ptr to file name scblk} mov teval(xl) xl
        pop  edx            #restore stmt number} mov (xs)+ wc
        pop  edi            #restore edi} mov (xs)+ xr
        pop  ebx            #restore ebx} mov (xs)+ wb
        ret                 #} exi
#
#      no table or no table entries
#
filn3:  pop  ebx            #restore ebx} mov (xs)+ wb
        mov  esi,offset nulls #return null string} mov =nulls xl
        ret                 #} exi
                            #} enp
                            #} ejc
        .eject
#
#
#      flstg -- fold string to upper case
#
#      flstg folds a character string containing lower case
#      characcters to one containing upper case characters.
#      folding is only done if &case (kvcas) is not zero.
#
#      (xr)                  string argument
#      (wa)                  length of string
#      jsr  flstg            call to fold string
#      (xr)                  result string (possibly original)
#      (wc)                  destroyed
#
flstg:                      #entry point} prc e 0
        .global flstg
        cmp  dword ptr dword ptr kvcas,0 #skip if &case is 0} bze kvcas fst99
        jz   fst99
        push esi            #save esi across call} mov xl -(xs)
        push edi            #save original scblk ptr} mov xr -(xs)
        call alocs          #allocate new string block} jsr alocs
        mov  esi,dword ptr [esp] #point to original scblk} mov (xs) xl
        push edi            #save pointer to new scblk} mov xr -(xs)
        add  esi,cfp_f      #point to original chars} plc xl
        add  edi,cfp_f      #point to new chars} psc xr
        push 0              #init did fold flag} zer -(xs)
fst01:  movzx ecx,byte ptr [esi] #load character} lch wa (xl)+
        inc  esi
        cmp  ecx,ch__a      #skip if less than lc a} blt wa =ch__a fst02
        jb   short fst02 # (jump shortened)
        cmp  ecx,ch___      #skip if greater than lc z} bgt wa =ch___ fst02
        ja   short fst02 # (jump shortened)
        cmp  cl,'a'         #fold character to upper case} flc wa
        jb   short l0014
        cmp  cl,'z'
        ja   short l0014
        sub  cl,32
l0014:
        mov  dword ptr [esp],esp #set did fold character flag} mnz (xs)
fst02:  mov  al,cl          #store (possibly folded) character} sch wa (xr)+
        stosb
        dec  edx            #loop thru entire string} bct wc fst01
        jnz  fst01
        pop  edi            #see if any change} mov (xs)+ xr
        or   edi,edi        #skip if folding done (no change)} bnz xr fst10
        jnz  short fst10 # (jump shortened)
        pop  dword ptr dnamp #do not need new scblk} mov (xs)+ dnamp
        pop  edi            #return original scblk} mov (xs)+ xr
        jmp  short fst20          #merge below} brn fst20 # (jump shortened)
fst10:  pop  edi            #return new scblk} mov (xs)+ xr
        add  esp,4          #throw away original scblk pointer} ica xs
fst20:  mov  ecx,dword ptr (4*sclen)[edi] #reload string length} mov sclen(xr) wa
        pop  esi            #restore esi} mov (xs)+ xl
fst99:  ret                 #return} exi
                            #} enp
                            #} ejc
        .eject
#
#      gbcol -- perform garbage collection
#
#      gbcol performs a garbage collection on the dynamic region
#      all blocks which are no longer in use are eliminated
#      by moving blocks which are in use down and resetting
#      dnamp, the pointer to the next available location.
#
#      (wb)                  move offset (see below)
#      jsr  gbcol            call to collect garbage
#      (xr)                  sediment size after collection
#
#      the following conditions must be met at the time when
#      gbcol is called.
#
#      1)   all pointers to blocks in the dynamic area must be
#           accessible to the garbage collector. this means
#           that they must occur in one of the following.
#
#           a)               main stack, with current top
#                            element being indicated by xs
#
#           b)               in relocatable fields of vrblks.
#
#           c)               in register xl at the time of call
#
#           e)               in the special region of working
#                            storage where names begin with r$.
#
#      2)   all pointers must point to the start of blocks with
#           the sole exception of the contents of the code
#           pointer register which points into the r$cod block.
#
#      3)   no location which appears to contain a pointer
#           into the dynamic region may occur unless it is in
#           fact a pointer to the start of the block. however
#           pointers outside this area may occur and will
#           not be changed by the garbage collector.
#           it is especially important to make sure that xl
#           does not contain a garbage value from some process
#           carried out before the call to the collector.
#
#      gbcol has the capability of moving the final compacted
#      result up in memory (with addresses adjusted accordingly)
#      this is used to add space to the static region. the
#      entry value of wb is the number of bytes to move up.
#      the caller must guarantee that there is enough room.
#      furthermore the value in wb if it is non-zero, must be at
#      least 256 so that the mwb instruction conditions are met.
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      the algorithm, which is a modification of the lisp-2
#      garbage collector devised by r.dewar and k.belcher
#      takes three passes as follows.
#
#      1)   all pointers in memory are scanned and blocks in use
#           determined from this scan. note that this procedure
#           is recursive and uses the main stack for linkage.
#           the marking process is thus similar to that used in
#           a standard lisp collector. however the method of
#           actually marking the blocks is different.
#
#           the first field of a block normally contains a
#           code entry point pointer. such an entry pointer
#           can be distinguished from the address of any pointer
#           to be processed by the collector. during garbage
#           collection, this word is used to build a back chain
#           of pointers through fields which point to the block.
#           the end of the chain is marked by the occurence
#           of the word which used to be in the first word of
#           the block. this backchain serves both as a mark
#           indicating that the block is in use and as a list of
#           references for the relocation phase.
#
#      2)   storage is scanned sequentially to discover which
#           blocks are currently in use as indicated by the
#           presence of a backchain. two pointers are maintained
#           one scans through looking at each block. the other
#           is incremented only for blocks found to be in use.
#           in this way, the eventual location of each block can
#           be determined without actually moving any blocks.
#           as each block which is in use is processed, the back
#           chain is used to reset all pointers which point to
#           this block to contain its new address, i.e. the
#           address it will occupy after the blocks are moved.
#           the first word of the block, taken from the end of
#           the chain is restored at this point.
#
#           during pass 2, the collector builds blocks which
#           describe the regions of storage which are to be
#           moved in the third pass. there is one descriptor for
#           each contiguous set of good blocks. the descriptor
#           is built just behind the block to be moved and
#           contains a pointer to the next block and the number
#           of words to be moved.
#
#      3)   in the third and final pass, the move descriptor
#           blocks built in pass two are used to actually move
#           the blocks down to the bottom of the dynamic region.
#           the collection is then complete and the next
#           available location pointer is reset.
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      the garbage collector also recognizes the concept of
#      sediment.  sediment is defined as long-lived objects
#      which percipitate to the bottom of dynamic storage.
#      moving these objects during repeated collections is
#      inefficient.  it also contributes to thrashing on
#      systems with virtual memory.  in a typical worst-case
#      situation, there may be several megabytes of live objects
#      in the sediment, and only a few dead objects in need of
#      collection.  without recognising sediment, the standard
#      collector would move those megabytes of objects downward
#      to squeeze out the dead objects.  this type of move
#      would result in excessive thrasing for very little memory
#      gain.
#
#      scanning of blocks in the sediment cannot be avoided
#      entirely, because these blocks may contain pointers to
#      live objects above the sediment.  however, sediment
#      blocks need not be linked to a back chain as described
#      in pass one above.  since these blocks will not be moved,
#      pointers to them do not need to be adjusted.  eliminating
#      unnecessary back chain links increases locality of
#      reference, improving virtual memory performance.
#
#      because back chains are used to mark blocks whose con-
#      tents have been processed, a different marking system
#      is needed for blocks in the sediment.  since block type
#      words point to odd-parity entry addresses, merely incre-
#      menting the type word serves to mark the block as pro-
#      cessed.  during pass three, the type words are decre-
#      mented to restore them to their original value.
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#
#      the variable dnams contains the number of bytes of memory
#      currently in the sediment.  setting dnams to zero will
#      eliminate the sediment and force it to be included in a
#      full garbage collection.  gbcol returns a suggested new
#      value for dnams (usually dnamp-dnamb) in xr which the
#      caller can store in dnams if it wishes to maintain the
#      sediment.  that is, data remaining after a garbage
#      collection is considered to be sediment.  if one accepts
#      the common lore that most objects are either very short-
#      or very long-lived, then this naive setting of dnams
#      probably includes some short-lived objects toward the end
#      of the sediment.
#
#      knowing when to reset dnams to zero to collect the sedi-
#      ment is not precisely known.  we force it to zero prior
#      to producing a dump, when gbcol is invoked by collect()
#      (so that the sediment is invisible to the user), when
#      sysmm is unable to obtain additional memory, and when
#      gbcol is called to relocate the dynamic area up in memory
#      (to make room for enlarging the static area).  if there
#      are no other reset situations, this leads to the inexo-
#      rable growth of the sediment, possible forcing a modest
#      program to begin to use virtual memory that it otherwise
#      would not.
#
#      as we scan sediment blocks in pass three, we maintain
#      aggregate counts of the amount of dead and live storage,
#      which is used to decide when to reset dnams.  when the
#      ratio of free storage found in the sediment to total
#      sediment size exceeds a threshold, the sediment is marked
#      for collection on the next gbcol call.
#
                            #} ejc
        .eject
#
#      gbcol (continued)
#
gbcol:                      #entry point} prc e 0
        .global gbcol
        cmp  dword ptr dword ptr dmvch,0 #fail if in mid-dump} bnz dmvch gbc14
        jnz  gbc14
        mov  dword ptr gbcfl,esp #note gbcol entered} mnz gbcfl
        mov  dword ptr gbsva,ecx #save entry ecx} mov wa gbsva
        mov  dword ptr gbsvb,ebx #save entry ebx} mov wb gbsvb
        mov  dword ptr gbsvc,edx #save entry edx} mov wc gbsvc
        push esi            #save entry esi} mov xl -(xs)
        mov  ecx,ebp        #get code pointer value} scp wa
        sub  ecx,dword ptr r_cod #make relative} sub r_cod wa
        mov  ebp,ecx        #and restore} lcp wa
        or   ebx,ebx        #check there is no move offset} bze wb gbc0a
        jz   short gbc0a # (jump shortened)
        xor  eax,eax        #collect sediment if must move it} zer dnams
        mov  dword ptr dnams,eax
gbc0a:  mov  ecx,dword ptr dnamb #start of dynamic area} mov dnamb wa
        add  ecx,dword ptr dnams #size of sediment} add dnams wa
        mov  dword ptr gbcsd,ecx #first location past sediment} mov wa gbcsd
#
#      inform sysgc that collection to commence
#
        mov  edi,esp        #non-zero flags start of collection} mnz xr
        mov  ecx,dword ptr dnamb #start of dynamic area} mov dnamb wa
        mov  ebx,dword ptr dnamp #next available location} mov dnamp wb
        mov  edx,dword ptr dname #last available location + 1} mov dname wc
        call sysgc          #inform of collection} jsr sysgc
#
#      process stack entries
#
        mov  edi,esp        #point to stack front} mov xs xr
        mov  esi,dword ptr stbas #point past end of stack} mov stbas xl
        cmp  esi,edi        #ok if d-stack} bge xl xr gbc00
        jae  short gbc00 # (jump shortened)
        mov  edi,esi        #reverse if ...} mov xl xr
        mov  esi,esp        #... u-stack} mov xs xl
#
#      process the stack
#
gbc00:  call gbcpf          #process pointers on stack} jsr gbcpf
#
#      process special work locations
#
        mov  edi,offset r_aaa #point to start of relocatable locs} mov =r_aaa xr
        mov  esi,offset r_yyy #point past end of relocatable locs} mov =r_yyy xl
        call gbcpf          #process work fields} jsr gbcpf
#
#      prepare to process variable blocks
#
        mov  ecx,dword ptr hshtb #point to first hash slot pointer} mov hshtb wa
#
#      loop through hash slots
#
gbc01:  mov  esi,ecx        #point to next slot} mov wa xl
        add  ecx,4          #bump bucket pointer} ica wa
        mov  dword ptr gbcnm,ecx #save bucket pointer} mov wa gbcnm
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      loop through variables on one hash chain
#
gbc02:  mov  edi,dword ptr [esi] #load ptr to next vrblk} mov (xl) xr
        or   edi,edi        #jump if end of chain} bze xr gbc03
        jz   short gbc03 # (jump shortened)
        mov  esi,edi        #else copy vrblk pointer} mov xr xl
        add  edi,4*vrval    #point to first reloc fld} add *vrval xr
        add  esi,4*vrnxt    #point past last (and to link ptr)} add *vrnxt xl
        call gbcpf          #process reloc fields in vrblk} jsr gbcpf
        jmp  gbc02          #loop back for next block} brn gbc02
#
#      here at end of one hash chain
#
gbc03:  mov  ecx,dword ptr gbcnm #restore bucket pointer} mov gbcnm wa
        cmp  ecx,dword ptr hshte #loop back if more buckets to go} bne wa hshte gbc01
        jne  gbc01
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      now we are ready to start pass two. registers are used
#      as follows in pass two.
#
#      (xr)                  scans through all blocks
#      (wc)                  pointer to eventual location
#
#      the move description blocks built in this pass have
#      the following format.
#
#      word 1                pointer to next move block,
#                            zero if end of chain of blocks
#
#      word 2                length of blocks to be moved in
#                            bytes. set to the address of the
#                            first byte while actually scanning
#                            the blocks.
#
#      the first entry on this chain is a special entry
#      consisting of the two words gbcnm and gbcns. after
#      building the chain of move descriptors, gbcnm points to
#      the first real move block, and gbcns is the length of
#      blocks in use at the start of storage which need not
#      be moved since they are in the correct position.
#
        mov  edi,dword ptr dnamb #point to first block} mov dnamb xr
        xor  ebx,ebx        #accumulate size of dead blocks} zer wb
gbc04:  cmp  edi,dword ptr gbcsd #jump if end of sediment} beq xr gbcsd gbc4c
        je   short gbc4c # (jump shortened)
        mov  ecx,dword ptr [edi] #else get first word} mov (xr) wa
        test cl,1           #jump if entry pointer (unused)} bod wa gbc4b
        jne  short gbc4b # (jump shortened)
        dec  ecx            #restore entry pointer} dcv wa
        mov  dword ptr [edi],ecx #restore first word} mov wa (xr)
        call blkln          #get length of this block} jsr blkln
        add  edi,ecx        #bump actual pointer} add wa xr
        jmp  gbc04          #continue scan through sediment} brn gbc04
#
#      here for unused sediment block
#
gbc4b:  call blkln          #get length of this block} jsr blkln
        add  edi,ecx        #bump actual pointer} add wa xr
        add  ebx,ecx        #count size of unused blocks} add wa wb
        jmp  gbc04          #continue scan through sediment} brn gbc04
#
#      here at end of sediment.  remember size of free blocks
#      within the sediment.  this will be used later to decide
#      how to set the sediment size returned to caller.
#
#      then scan rest of dynamic area above sediment.
#
#      (wb) = aggregate size of free blocks in sediment
#      (xr) = first location past sediment
#
gbc4c:  mov  dword ptr gbcsf,ebx #size of sediment free space} mov wb gbcsf
        mov  edx,edi        #set as first eventual location} mov xr wc
        add  edx,dword ptr gbsvb #add offset for eventual move up} add gbsvb wc
        xor  eax,eax        #clear initial forward pointer} zer gbcnm
        mov  dword ptr gbcnm,eax
        mov  dword ptr gbclm,offset gbcnm #initialize ptr to last move block} mov =gbcnm gbclm
        mov  dword ptr gbcns,edi #initialize first address} mov xr gbcns
#
#      loop through a series of blocks in use
#
gbc05:  cmp  edi,dword ptr dnamp #jump if end of used region} beq xr dnamp gbc07
        je   short gbc07 # (jump shortened)
        mov  ecx,dword ptr [edi] #else get first word} mov (xr) wa
        test cl,1           #jump if entry pointer (unused)} bod wa gbc07
        jne  short gbc07 # (jump shortened)
#
#      here for block in use, loop to relocate references
#
gbc06:  mov  esi,ecx        #copy pointer} mov wa xl
        mov  ecx,dword ptr [esi] #load forward pointer} mov (xl) wa
        mov  dword ptr [esi],edx #relocate reference} mov wc (xl)
        test cl,1           #loop back if not end of chain} bev wa gbc06
        je   gbc06
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      at end of chain, restore first word and bump past
#
        mov  dword ptr [edi],ecx #restore first word} mov wa (xr)
        call blkln          #get length of this block} jsr blkln
        add  edi,ecx        #bump actual pointer} add wa xr
        add  edx,ecx        #bump eventual pointer} add wa wc
        jmp  gbc05          #loop back for next block} brn gbc05
#
#      here at end of a series of blocks in use
#
gbc07:  mov  ecx,edi        #copy pointer past last block} mov xr wa
        mov  esi,dword ptr gbclm #point to previous move block} mov gbclm xl
        sub  ecx,dword ptr (4*num01)[esi] #subtract starting address} sub num01(xl) wa
        mov  dword ptr (4*num01)[esi],ecx #store length of block to be moved} mov wa num01(xl)
#
#      loop through a series of blocks not in use
#
gbc08:  cmp  edi,dword ptr dnamp #jump if end of used region} beq xr dnamp gbc10
        je   gbc10
        mov  ecx,dword ptr [edi] #else load first word of next block} mov (xr) wa
        test cl,1           #jump if in use} bev wa gbc09
        je   short gbc09 # (jump shortened)
        call blkln          #else get length of next block} jsr blkln
        add  edi,ecx        #push pointer} add wa xr
        jmp  gbc08          #and loop back} brn gbc08
#
#      here for a block in use after processing a series of
#      blocks which were not in use, build new move block.
#
gbc09:  sub  edi,4*num02    #point 2 words behind for move block} sub *num02 xr
        mov  esi,dword ptr gbclm #point to previous move block} mov gbclm xl
        mov  dword ptr [esi],edi #set forward ptr in previous block} mov xr (xl)
        xor  eax,eax        #zero forward ptr of new block} zer (xr)
        mov  dword ptr [edi],eax
        mov  dword ptr gbclm,edi #remember address of this block} mov xr gbclm
        mov  esi,edi        #copy ptr to move block} mov xr xl
        add  edi,4*num02    #point back to block in use} add *num02 xr
        mov  dword ptr (4*num01)[esi],edi #store starting address} mov xr num01(xl)
        jmp  gbc06          #jump to process block in use} brn gbc06
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      here for pass three -- actually move the blocks down
#
#      (xl)                  pointer to old location
#      (xr)                  pointer to new location
#
gbc10:  mov  edi,dword ptr gbcsd #point to storage above sediment} mov gbcsd xr
        add  edi,dword ptr gbcns #bump past unmoved blocks at start} add gbcns xr
#
#      loop through move descriptors
#
gbc11:  mov  esi,dword ptr gbcnm #point to next move block} mov gbcnm xl
        or   esi,esi        #jump if end of chain} bze xl gbc12
        jz   short gbc12 # (jump shortened)
        lodsd               #move pointer down chain} mov (xl)+ gbcnm
        mov  dword ptr gbcnm,eax
        lodsd               #get length to move} mov (xl)+ wa
        mov  ecx,eax
        shr  ecx,2          #perform move} mvw
        rep  movsd
        jmp  gbc11          #loop back} brn gbc11
#
#      now test for move up
#
gbc12:  mov  dword ptr dnamp,edi #set next available loc ptr} mov xr dnamp
        mov  ebx,dword ptr gbsvb #reload move offset} mov gbsvb wb
        or   ebx,ebx        #jump if no move required} bze wb gbc13
        jz   short gbc13 # (jump shortened)
        mov  esi,edi        #else copy old top of core} mov xr xl
        add  edi,ebx        #point to new top of core} add wb xr
        mov  dword ptr dnamp,edi #save new top of core pointer} mov xr dnamp
        mov  ecx,esi        #copy old top} mov xl wa
        sub  ecx,dword ptr dnamb #minus old bottom = length} sub dnamb wa
        add  dword ptr dnamb,ebx #bump bottom to get new value} add wb dnamb
        shr  ecx,2          #perform move (backwards)} mwb
        std
        lea  esi,[esi-4]
        lea  edi,[edi-4]
        rep  movsd
        cld
#
#      merge here to exit
#
gbc13:  xor  edi,edi        #clear garbage value in edi} zer xr
        mov  dword ptr gbcfl,edi #note exit from gbcol} mov xr gbcfl
        mov  ecx,dword ptr dnamb #start of dynamic area} mov dnamb wa
        mov  ebx,dword ptr dnamp #next available location} mov dnamp wb
        mov  edx,dword ptr dname #last available location + 1} mov dname wc
        call sysgc          #inform sysgc of completion} jsr sysgc
#
#      decide whether to mark sediment for collection next time.
#      this is done by examining the ratio of previous sediment
#      free space to the new sediment size.
#
        mov  dword ptr gbcia,edx #save edx} sti gbcia
        xor  edi,edi        #presume no sediment will remain} zer xr
        mov  ebx,dword ptr gbcsf #free space in sediment} mov gbcsf wb
        shr  ebx,2          #convert bytes to words} btw wb
        mov  edx,ebx        #put sediment free store in edx} mti wb
        imul edx,dword ptr gbsed #multiply by sediment factor} mli gbsed
        jo   short gb13a          #jump if overflowed} iov gb13a # (jump shortened)
        mov  ebx,dword ptr dnamp #end of dynamic area in use} mov dnamp wb
        sub  ebx,dword ptr dnamb #minus start is sediment remaining} sub dnamb wb
        shr  ebx,2          #convert to words} btw wb
        mov  dword ptr gbcsf,ebx #store it} mov wb gbcsf
        sub  edx,dword ptr gbcsf #subtract from scaled up free store} sbi gbcsf
#        or   edx,edx        #jump if large free store in sedimnt} igt gb13a   (optimized)
        jg   short gb13a # (jump shortened)
        mov  edi,dword ptr dnamp #below threshold, return sediment} mov dnamp xr
        sub  edi,dword ptr dnamb #for use by caller} sub dnamb xr
gb13a:  mov  edx,dword ptr gbcia #restore edx} ldi gbcia
        mov  ecx,dword ptr gbsva #restore ecx} mov gbsva wa
        mov  ebx,dword ptr gbsvb #restore ebx} mov gbsvb wb
        mov  edx,ebp        #get code pointer} scp wc
        add  edx,dword ptr r_cod #make absolute again} add r_cod wc
        mov  ebp,edx        #and replace absolute value} lcp wc
        mov  edx,dword ptr gbsvc #restore edx} mov gbsvc wc
        pop  esi            #restore entry esi} mov (xs)+ xl
        inc  dword ptr gbcnt #increment count of collections} icv gbcnt
        ret                 #exit to gbcol caller} exi
#
#      garbage collection not allowed whilst dumping
#
gbc14:  inc  dword ptr errft #fatal error} icv errft
        call err_0          #} erb 250 insufficient memory to complete dump
        .byte 250
                            #end procedure gbcol} enp
                            #} ejc
        .eject
#
#      gbcpf -- process fields for garbage collector
#
#      this procedure is used by the garbage collector to
#      process fields in pass one. see gbcol for full details.
#
#      (xr)                  ptr to first location to process
#      (xl)                  ptr past last location to process
#      jsr  gbcpf            call to process fields
#      (xr,wa,wb,wc,ia)      destroyed
#
#      note that although this procedure uses a recursive
#      approach, it controls its own stack and is not recursive.
#
gbcpf:                      #entry point} prc e 0
        .global gbcpf
        push 0              #set zero to mark bottom of stack} zer -(xs)
        push esi            #save end pointer} mov xl -(xs)
#
#      merge here to go down a level and start a new loop
#
#      1(xs)                 next lvl field ptr (0 at outer lvl)
#      0(xs)                 ptr past last field to process
#      (xr)                  ptr to first field to process
#
#      loop to process successive fields
#
gpf01:  mov  esi,dword ptr [edi] #load field contents} mov (xr) xl
        mov  edx,edi        #save field pointer} mov xr wc
        cmp  esi,dword ptr dnamb #jump if not ptr into dynamic area} blt xl dnamb gpf2a
        jb   short gpf2a # (jump shortened)
        cmp  esi,dword ptr dnamp #jump if not ptr into dynamic area} bge xl dnamp gpf2a
        jae  short gpf2a # (jump shortened)
#
#      here we have a ptr to a block in the dynamic area.
#      link this field onto the reference backchain.
#
        mov  ecx,dword ptr [esi] #load ptr to chain (or entry ptr)} mov (xl) wa
        cmp  esi,dword ptr gbcsd #do not chain if within sediment} blt xl gbcsd gpf1a
        jb   short gpf1a # (jump shortened)
        mov  dword ptr [esi],edi #set this field as new head of chain} mov xr (xl)
        mov  dword ptr [edi],ecx #set forward pointer} mov wa (xr)
#
#      now see if this block has been processed before
#
gpf1a:  test cl,1           #jump if not already processed} bod wa gpf03
        jne  gpf03
#
#      here to restore pointer in xr to field just processed
#
gpf02:  mov  edi,edx        #restore field pointer} mov wc xr
#
#      here to move to next field
#
gpf2a:  add  edi,4          #bump to next field} ica xr
        cmp  edi,dword ptr [esp] #loop back if more to go} bne xr (xs) gpf01
        jne  gpf01
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      here we pop up a level after finishing a block
#
        pop  esi            #restore pointer past end} mov (xs)+ xl
        pop  edi            #restore block pointer} mov (xs)+ xr
        or   edi,edi        #continue loop unless outer levl} bnz xr gpf2a
        jnz  gpf2a
        ret                 #return to caller if outer level} exi
#
#      here to process an active block which has not been done
#
#
#      since sediment blocks are not marked by putting them on
#      the back chain, they must be explicitly marked in another
#      manner.  if odd parity entry points are present, mark by
#      temporarily converting to even parity.  if odd parity not
#      available, the entry point is adjusted by the value in
#      gbcmk.
#
gpf03:  cmp  esi,dword ptr gbcsd #if not within sediment} bge xl gbcsd gpf3a
        jae  short gpf3a # (jump shortened)
        inc  dword ptr [esi] #mark by making entry point even} icv (xl)
gpf3a:  mov  edi,esi        #copy block pointer} mov xl xr
        mov  esi,ecx        #copy first word of block} mov wa xl
        movzx esi,byte ptr [esi-1] #load entry point id (bl_xx)} lei xl
#
#      block type switch. note that blocks with no relocatable
#      fields just return to gpf02 here to continue to next fld.
#
        jmp  dword ptr l0015[esi*4] #switch on block type} bsw xl bl___
        dseg_
l0015:
        .long gpf06         #arblk} iff bl_ar gpf06
        .long gpf19         #cdblk} iff bl_cd gpf19
        .long gpf17         #exblk} iff bl_ex gpf17
        .long gpf02         #icblk} iff bl_ic gpf02
        .long gpf10         #nmblk} iff bl_nm gpf10
        .long gpf10         #p0blk} iff bl_p0 gpf10
        .long gpf12         #p1blk} iff bl_p1 gpf12
        .long gpf12         #p2blk} iff bl_p2 gpf12
        .long gpf02         #rcblk} iff bl_rc gpf02
        .long gpf02         #scblk} iff bl_sc gpf02
        .long gpf02         #seblk} iff bl_se gpf02
        .long gpf08         #tbblk} iff bl_tb gpf08
        .long gpf08         #vcblk} iff bl_vc gpf08
        .long gpf02         #xnblk} iff bl_xn gpf02
        .long gpf09         #xrblk} iff bl_xr gpf09
        .long gpf02         #bcblk - dummy to fill out iffs} iff bl_bc gpf02
        .long gpf13         #pdblk} iff bl_pd gpf13
        .long gpf16         #trblk} iff bl_tr gpf16
        .long gpf02         #bfblk} iff bl_bf gpf02
        .long gpf07         #ccblk} iff bl_cc gpf07
        .long gpf04         #cmblk} iff bl_cm gpf04
        .long gpf02         #ctblk} iff bl_ct gpf02
        .long gpf02         #dfblk} iff bl_df gpf02
        .long gpf02         #efblk} iff bl_ef gpf02
        .long gpf10         #evblk} iff bl_ev gpf10
        .long gpf11         #ffblk} iff bl_ff gpf11
        .long gpf02         #kvblk} iff bl_kv gpf02
        .long gpf14         #pfblk} iff bl_pf gpf14
        .long gpf15         #teblk} iff bl_te gpf15
        dsegend_            #end of jump table} esw
        cseg_
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      cmblk
#
gpf04:  mov  ecx,dword ptr (4*cmlen)[edi] #load length} mov cmlen(xr) wa
        mov  ebx,4*cmtyp    #set offset} mov *cmtyp wb
#
#      here to push down to new level
#
#      (wc)                  field ptr at previous level
#      (xr)                  ptr to new block
#      (wa)                  length (reloc flds + flds at start)
#      (wb)                  offset to first reloc field
#
gpf05:  add  ecx,edi        #point past last reloc field} add xr wa
        add  edi,ebx        #point to first reloc field} add wb xr
        push edx            #stack old field pointer} mov wc -(xs)
        push ecx            #stack new limit pointer} mov wa -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        jmp  gpf01          #if ok, back to process} brn gpf01
#
#      arblk
#
gpf06:  mov  ecx,dword ptr (4*arlen)[edi] #load length} mov arlen(xr) wa
        mov  ebx,dword ptr (4*arofs)[edi] #set offset to 1st reloc fld (arpro)} mov arofs(xr) wb
        jmp  gpf05          #all set} brn gpf05
#
#      ccblk
#
gpf07:  mov  ecx,dword ptr (4*ccuse)[edi] #set length in use} mov ccuse(xr) wa
        mov  ebx,4*ccuse    #1st word (make sure at least one)} mov *ccuse wb
        jmp  gpf05          #all set} brn gpf05
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      cdblk
#
gpf19:  mov  ecx,dword ptr (4*cdlen)[edi] #load length} mov cdlen(xr) wa
        mov  ebx,4*cdfal    #set offset} mov *cdfal wb
        jmp  gpf05          #jump back} brn gpf05
#
#      tbblk, vcblk
#
gpf08:  mov  ecx,dword ptr (4*offs2)[edi] #load length} mov offs2(xr) wa
        mov  ebx,4*offs3    #set offset} mov *offs3 wb
        jmp  gpf05          #jump back} brn gpf05
#
#      xrblk
#
gpf09:  mov  ecx,dword ptr (4*xrlen)[edi] #load length} mov xrlen(xr) wa
        mov  ebx,4*xrptr    #set offset} mov *xrptr wb
        jmp  gpf05          #jump back} brn gpf05
#
#      evblk, nmblk, p0blk
#
gpf10:  mov  ecx,4*offs2    #point past second field} mov *offs2 wa
        mov  ebx,4*offs1    #offset is one (only reloc fld is 2)} mov *offs1 wb
        jmp  gpf05          #all set} brn gpf05
#
#      ffblk
#
gpf11:  mov  ecx,4*ffofs    #set length} mov *ffofs wa
        mov  ebx,4*ffnxt    #set offset} mov *ffnxt wb
        jmp  gpf05          #all set} brn gpf05
#
#      p1blk, p2blk
#
gpf12:  mov  ecx,4*parm2    #length (parm2 is non-relocatable)} mov *parm2 wa
        mov  ebx,4*pthen    #set offset} mov *pthen wb
        jmp  gpf05          #all set} brn gpf05
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      pdblk
#
gpf13:  mov  esi,dword ptr (4*pddfp)[edi] #load ptr to dfblk} mov pddfp(xr) xl
        mov  ecx,dword ptr (4*dfpdl)[esi] #get pdblk length} mov dfpdl(xl) wa
        mov  ebx,4*pdfld    #set offset} mov *pdfld wb
        jmp  gpf05          #all set} brn gpf05
#
#      pfblk
#
gpf14:  mov  ecx,4*pfarg    #length past last reloc} mov *pfarg wa
        mov  ebx,4*pfcod    #offset to first reloc} mov *pfcod wb
        jmp  gpf05          #all set} brn gpf05
#
#      teblk
#
gpf15:  mov  ecx,4*tesi_    #set length} mov *tesi_ wa
        mov  ebx,4*tesub    #and offset} mov *tesub wb
        jmp  gpf05          #all set} brn gpf05
#
#      trblk
#
gpf16:  mov  ecx,4*trsi_    #set length} mov *trsi_ wa
        mov  ebx,4*trval    #and offset} mov *trval wb
        jmp  gpf05          #all set} brn gpf05
#
#      exblk
#
gpf17:  mov  ecx,dword ptr (4*exlen)[edi] #load length} mov exlen(xr) wa
        mov  ebx,4*exflc    #set offset} mov *exflc wb
        jmp  gpf05          #jump back} brn gpf05
                            #end procedure gbcpf} enp
                            #} ejc
        .eject
#
#      gtarr -- get array
#
#      gtarr is passed an object and returns an array if possibl
#
#      (xr)                  value to be converted
#      (wa)                  0 to place table addresses in array
#                            non-zero for keys/values in array
#      jsr  gtarr            call to get array
#      ppm  loc              transfer loc for all null table
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  resulting array
#      (xl,wa,wb,wc)         destroyed
#
gtarr:                      #entry point} prc e 2
        .global gtarr
        mov  dword ptr gtawa,ecx #save ecx indicator} mov wa gtawa
        mov  ecx,dword ptr [edi] #load type word} mov (xr) wa
        cmp  ecx,offset b_art #exit if already an array} beq wa =b_art gtar8
        je   gtar8
        cmp  ecx,offset b_vct #exit if already an array} beq wa =b_vct gtar8
        je   gtar8
        cmp  ecx,offset b_tbt #else fail if not a table (sgd02)} bne wa =b_tbt gta9a
        jne  gta9a
#
#      here we convert a table to an array
#
        push edi            #replace tbblk pointer on stack} mov xr -(xs)
        xor  edi,edi        #signal first pass} zer xr
        xor  ebx,ebx        #zero non-null element count} zer wb
#
#      the following code is executed twice. on the first pass,
#      signalled by xr=0, the number of non-null elements in
#      the table is counted in wb. in the second pass, where
#      xr is a pointer into the arblk, the name and value are
#      entered into the current arblk location provided gtawa
#      is non-zero.  if gtawa is zero, the address of the teblk
#      is entered into the arblk twice (c3.762).
#
gtar1:  mov  esi,dword ptr [esp] #point to table} mov (xs) xl
        add  esi,dword ptr (4*tblen)[esi] #point past last bucket} add tblen(xl) xl
        sub  esi,4*tbbuk    #set first bucket offset} sub *tbbuk xl
        mov  ecx,esi        #copy adjusted pointer} mov xl wa
#
#      loop through buckets in table block
#      next three lines of code rely on tenxt having a value
#      1 less than tbbuk.
#
gtar2:  mov  esi,ecx        #copy bucket pointer} mov wa xl
        sub  ecx,4          #decrement bucket pointer} dca wa
#
#      loop through teblks on one bucket chain
#
gtar3:  mov  esi,dword ptr (4*tenxt)[esi] #point to next teblk} mov tenxt(xl) xl
        cmp  esi,dword ptr [esp] #jump if chain end (tbblk ptr)} beq xl (xs) gtar6
        je   gtar6
        mov  dword ptr cnvtp,esi #else save teblk pointer} mov xl cnvtp
#
#      loop to find value down trblk chain
#
gtar4:  mov  esi,dword ptr (4*teval)[esi] #load value} mov teval(xl) xl
        cmp  dword ptr [esi],offset b_trt #loop till value found} beq (xl) =b_trt gtar4
        je   gtar4
        mov  edx,esi        #copy value} mov xl wc
        mov  esi,dword ptr cnvtp #restore teblk pointer} mov cnvtp xl
                            #} ejc
        .eject
#
#      gtarr (continued)
#
#      now check for null and test cases
#
        cmp  edx,offset nulls #loop back to ignore null value} beq wc =nulls gtar3
        je   gtar3
        or   edi,edi        #jump if second pass} bnz xr gtar5
        jnz  short gtar5 # (jump shortened)
        inc  ebx            #for the first pass, bump count} icv wb
        jmp  gtar3          #and loop back for next teblk} brn gtar3
#
#      here in second pass
#
gtar5:  cmp  dword ptr dword ptr gtawa,0 #jump if address wanted} bze gtawa gta5a
        jz   short gta5a # (jump shortened)
        mov  eax,dword ptr (4*tesub)[esi] #store subscript name} mov tesub(xl) (xr)+
        stosd
        mov  eax,edx        #store value in arblk} mov wc (xr)+
        stosd
        jmp  gtar3          #loop back for next teblk} brn gtar3
#
#      here to record teblk address in arblk.  this allows
#      a sort routine to sort by ascending address.
#
gta5a:  mov  eax,esi        #store teblk address in name} mov xl (xr)+
        stosd
        mov  eax,esi        #and value slots} mov xl (xr)+
        stosd
        jmp  gtar3          #loop back for next teblk} brn gtar3
#
#      here after scanning teblks on one chain
#
gtar6:  cmp  ecx,dword ptr [esp] #loop back if more buckets to go} bne wa (xs) gtar2
        jne  gtar2
        or   edi,edi        #else jump if second pass} bnz xr gtar7
        jnz  gtar7
#
#      here after counting non-null elements
#
        or   ebx,ebx        #fail if no non-null elements} bze wb gtar9
        jz   gtar9
        mov  ecx,ebx        #else copy count} mov wb wa
        add  ecx,ebx        #double (two words/element)} add wb wa
        add  ecx,arvl2      #add space for standard fields} add =arvl2 wa
        sal  ecx,2          #convert length to bytes} wtb wa
        cmp  ecx,dword ptr mxlen #error if too long for array} bgt wa mxlen gta9b
        ja   gta9b
        call alloc          #else allocate space for arblk} jsr alloc
        mov  dword ptr [edi],offset b_art #store type word} mov =b_art (xr)
        xor  eax,eax        #zero id for the moment} zer idval(xr)
        mov  dword ptr (4*idval)[edi],eax
        mov  dword ptr (4*arlen)[edi],ecx #store length} mov wa arlen(xr)
        mov  dword ptr (4*arndm)[edi],num02 #set dimensions = 2} mov =num02 arndm(xr)
        mov  edx,dword ptr intv1 #get integer one} ldi intv1
        mov  dword ptr (4*arlbd)[edi],edx #store as lbd 1} sti arlbd(xr)
        mov  dword ptr (4*arlb2)[edi],edx #store as lbd 2} sti arlb2(xr)
        mov  edx,dword ptr intv2 #load integer two} ldi intv2
        mov  dword ptr (4*ardm2)[edi],edx #store as dim 2} sti ardm2(xr)
        mov  edx,ebx        #get element count as integer} mti wb
        mov  dword ptr (4*ardim)[edi],edx #store as dim 1} sti ardim(xr)
        xor  eax,eax        #zero prototype field for now} zer arpr2(xr)
        mov  dword ptr (4*arpr2)[edi],eax
        mov  dword ptr (4*arofs)[edi],4*arpr2 #set offset field (signal pass 2)} mov *arpr2 arofs(xr)
        mov  ebx,edi        #save arblk pointer} mov xr wb
        add  edi,4*arvl2    #point to first element location} add *arvl2 xr
        jmp  gtar1          #jump back to fill in elements} brn gtar1
                            #} ejc
        .eject
#
#      gtarr (continued)
#
#      here after filling in element values
#
gtar7:  mov  edi,ebx        #restore arblk pointer} mov wb xr
        mov  dword ptr [esp],ebx #store as result} mov wb (xs)
#
#      now we need the array prototype which is of the form nn,2
#      this is obtained by building the string for nn02 and
#      changing the zero to a comma before storing it.
#
        mov  edx,dword ptr (4*ardim)[edi] #get number of elements (nn)} ldi ardim(xr)
        imul edx,dword ptr intvh #multiply by 100} mli intvh
        add  edx,dword ptr intv2 #add 2 (nn02)} adi intv2
        call icbld          #build integer} jsr icbld
        push edi            #store ptr for gtstg} mov xr -(xs)
        call gtstg          #convert to string} jsr gtstg
        .short err_-299-dffnc #convert fail is impossible} ppm
        mov  esi,edi        #copy string pointer} mov xr xl
        pop  edi            #reload arblk pointer} mov (xs)+ xr
        mov  dword ptr (4*arpr2)[edi],esi #store prototype ptr (nn02)} mov xl arpr2(xr)
        sub  ecx,num02      #adjust length to point to zero} sub =num02 wa
        lea  esi,[cfp_f+esi+ecx] #point to zero} psc xl wa
        mov  ebx,ch_cm      #load a comma} mov =ch_cm wb
        mov  [esi],bl       #store a comma over the zero} sch wb (xl)
#
#      normal return
#
gtar8:  pop  eax            #return to caller} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      null table non-conversion return
#
gtar9:  pop  edi            #restore stack for conv err (sgd02)} mov (xs)+ xr
        pop  eax            #return} exi 1
        jmp  exi__1
#
#      impossible conversion return
#
gta9a:  pop  eax            #return} exi 2
        jmp  exi__2
#
#      array size too large
#
gta9b:  call err_1          #} erb 260 conversion array size exceeds maximum permitted
        .byte 4
                            #procedure gtarr} enp
                            #} ejc
        .eject
#
#      gtcod -- convert to code
#
#      (xr)                  object to be converted
#      jsr  gtcod            call to convert to code
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to resulting cdblk
#      (xl,wa,wb,wc,ra)      destroyed
#
#      if a spitbol error occurs during compilation or pre-
#      evaluation, control is passed via error section to exfal
#      without returning to this routine.
#
gtcod:                      #entry point} prc e 1
        .global gtcod
        cmp  dword ptr [edi],offset b_cds #jump if already code} beq (xr) =b_cds gtcd1
        je   gtcd1
        cmp  dword ptr [edi],offset b_cdc #jump if already code} beq (xr) =b_cdc gtcd1
        je   short gtcd1 # (jump shortened)
#
#      here we must generate a cdblk by compilation
#
        push edi            #stack argument for gtstg} mov xr -(xs)
        call gtstg          #convert argument to string} jsr gtstg
        .short gtcd2-dffnc  #jump if non-convertible} ppm gtcd2
        mov  eax,dword ptr flptr #save fail ptr in case of error} mov flptr gtcef
        mov  dword ptr gtcef,eax
        mov  eax,dword ptr r_cod #also save code ptr} mov r_cod r_gtc
        mov  dword ptr r_gtc,eax
        mov  dword ptr r_cim,edi #else set image pointer} mov xr r_cim
        mov  dword ptr scnil,ecx #set image length} mov wa scnil
        xor  eax,eax        #set scan pointer} zer scnpt
        mov  dword ptr scnpt,eax
        mov  dword ptr stage,stgxc #set stage for execute compile} mov =stgxc stage
        mov  eax,dword ptr cmpsn #in case listr called} mov cmpsn lstsn
        mov  dword ptr lstsn,eax
        inc  dword ptr cmpln #bump line number} icv cmpln
        call cmpil          #compile string} jsr cmpil
        mov  dword ptr stage,stgxt #reset stage for execute time} mov =stgxt stage
        xor  eax,eax        #clear image} zer r_cim
        mov  dword ptr r_cim,eax
#
#      merge here if no convert required
#
gtcd1:  pop  eax            #give normal gtcod return} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here if unconvertible
#
gtcd2:  pop  eax            #give error return} exi 1
        jmp  exi__1
                            #end procedure gtcod} enp
                            #} ejc
        .eject
#
#      gtexp -- convert to expression
#
#      (wb)                  0 if by value, 1 if by name
#      (xr)                  input value to be converted
#      jsr  gtexp            call to convert to expression
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to result exblk or seblk
#      (xl,wa,wb,wc,ra)      destroyed
#
#      if a spitbol error occurs during compilation or pre-
#      evaluation, control is passed via error section to exfal
#      without returning to this routine.
#
gtexp:                      #entry point} prc e 1
        .global gtexp
        cmp  dword ptr [edi],offset b_e__ #jump if already an expression} blo (xr) =b_e__ gtex1
        jb   gtex1
        push edi            #store argument for gtstg} mov xr -(xs)
        call gtstg          #convert argument to string} jsr gtstg
        .short gtex2-dffnc  #jump if unconvertible} ppm gtex2
#
#      check the last character of the string for colon or
#      semicolon.  these characters can legitimately end an
#      expression in open code, so expan will not detect them
#      as errors, but they are invalid as terminators for a
#      string that is being converted to expression form.
#
        mov  esi,edi        #copy input string pointer} mov xr xl
        lea  esi,[cfp_f+esi+ecx] #point one past the string end} plc xl wa
        dec  esi            #fetch the last character} lch xl -(xl)
        movzx esi,byte ptr [esi]
        cmp  esi,ch_cl      #error if it is a semicolon} beq xl =ch_cl gtex2
        je   gtex2
        cmp  esi,ch_sm      #or if it is a colon} beq xl =ch_sm gtex2
        je   gtex2
#
#      here we convert a string by compilation
#
        mov  dword ptr r_cim,edi #set input image pointer} mov xr r_cim
        xor  eax,eax        #set scan pointer} zer scnpt
        mov  dword ptr scnpt,eax
        mov  dword ptr scnil,ecx #set input image length} mov wa scnil
        push ebx            #save value/name flag} mov wb -(xs)
        xor  ebx,ebx        #set code for normal scan} zer wb
        mov  eax,dword ptr flptr #save fail ptr in case of error} mov flptr gtcef
        mov  dword ptr gtcef,eax
        mov  eax,dword ptr r_cod #also save code ptr} mov r_cod r_gtc
        mov  dword ptr r_gtc,eax
        mov  dword ptr stage,stgev #adjust stage for compile} mov =stgev stage
        mov  dword ptr scntp,t_uok #indicate unary operator acceptable} mov =t_uok scntp
        call expan          #build tree for expression} jsr expan
        xor  eax,eax        #reset rescan flag} zer scnrs
        mov  dword ptr scnrs,eax
        pop  ecx            #restore value/name flag} mov (xs)+ wa
        mov  eax,dword ptr scnpt #error if not end of image} bne scnpt scnil gtex2
        cmp  eax,dword ptr scnil
        jne  short gtex2 # (jump shortened)
        xor  ebx,ebx        #set ok value for cdgex call} zer wb
        mov  esi,edi        #copy tree pointer} mov xr xl
        call cdgex          #build expression block} jsr cdgex
        xor  eax,eax        #clear pointer} zer r_cim
        mov  dword ptr r_cim,eax
        mov  dword ptr stage,stgxt #restore stage for execute time} mov =stgxt stage
#
#      merge here if no conversion required
#
gtex1:  pop  eax            #return to gtexp caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here if unconvertible
#
gtex2:  pop  eax            #take error exit} exi 1
        jmp  exi__1
                            #end procedure gtexp} enp
                            #} ejc
        .eject
#
#      gtint -- get integer value
#
#      gtint is passed an object and returns an integer after
#      performing any necessary conversions.
#
#      (xr)                  value to be converted
#      jsr  gtint            call to convert to integer
#      ppm  loc              transfer loc for convert impossible
#      (xr)                  resulting integer
#      (wc,ra)               destroyed
#      (wa,wb)               destroyed (only on conversion err)
#      (xr)                  unchanged (on convert error)
#
gtint:                      #entry point} prc e 1
        .global gtint
        cmp  dword ptr [edi],offset b_icl #jump if already an integer} beq (xr) =b_icl gtin2
        je   short gtin2 # (jump shortened)
        mov  dword ptr gtina,ecx #else save ecx} mov wa gtina
        mov  dword ptr gtinb,ebx #save ebx} mov wb gtinb
        call gtnum          #convert to numeric} jsr gtnum
        .short gtin3-dffnc  #jump if unconvertible} ppm gtin3
        cmp  ecx,offset b_icl #jump if integer} beq wa =b_icl gtin1
        je   short gtin1 # (jump shortened)
#
#      here we convert a real to integer
#
        lea  eax,dword ptr (4*rcval)[edi] #load real value} ldr rcval(xr)
        call ldr_
        call rti_           #convert to integer (err if ovflow)} rti gtin3
        jc   short gtin3 # (jump shortened)
        call icbld          #if ok build icblk} jsr icbld
#
#      here after successful conversion to integer
#
gtin1:  mov  ecx,dword ptr gtina #restore ecx} mov gtina wa
        mov  ebx,dword ptr gtinb #restore ebx} mov gtinb wb
#
#      common exit point
#
gtin2:  pop  eax            #return to gtint caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here on conversion error
#
gtin3:  pop  eax            #take convert error exit} exi 1
        jmp  exi__1
                            #end procedure gtint} enp
                            #} ejc
        .eject
#
#      gtnum -- get numeric value
#
#      gtnum is given an object and returns either an integer
#      or a real, performing any necessary conversions.
#
#      (xr)                  object to be converted
#      jsr  gtnum            call to convert to numeric
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to result (int or real)
#      (wa)                  first word of result block
#      (wb,wc,ra)            destroyed
#      (xr)                  unchanged (on convert error)
#
gtnum:                      #entry point} prc e 1
        .global gtnum
        mov  ecx,dword ptr [edi] #load first word of block} mov (xr) wa
        cmp  ecx,offset b_icl #jump if integer (no conversion)} beq wa =b_icl gtn34
        je   gtn34
        cmp  ecx,offset b_rcl #jump if real (no conversion)} beq wa =b_rcl gtn34
        je   gtn34
#
#      at this point the only possibility is to convert a string
#      to an integer or real as appropriate.
#
        push edi            #stack argument in case convert err} mov xr -(xs)
        push edi            #stack argument for gtstg} mov xr -(xs)
        call gtstg          #convert argument to string} jsr gtstg
        .short gtn36-dffnc  #jump if unconvertible} ppm gtn36
#
#      initialize numeric conversion
#
        mov  edx,dword ptr intv0 #initialize integer result to zero} ldi intv0
        or   ecx,ecx        #jump to exit with zero if null} bze wa gtn32
        jz   gtn32
        xor  eax,eax        #tentatively indicate result +} zer gtnnf
        mov  dword ptr gtnnf,eax
        mov  dword ptr gtnex,edx #initialise exponent to zero} sti gtnex
        xor  eax,eax        #zero scale in case real} zer gtnsc
        mov  dword ptr gtnsc,eax
        xor  eax,eax        #reset flag for dec point found} zer gtndf
        mov  dword ptr gtndf,eax
        xor  eax,eax        #reset flag for digits found} zer gtnrd
        mov  dword ptr gtnrd,eax
        mov  eax,offset dword ptr reav0 #zero real accum in case real} ldr reav0
        call ldr_
        add  edi,cfp_f      #point to argument characters} plc xr
#
#      merge back here after ignoring leading blank
#
gtn01:  movzx ebx,byte ptr [edi] #load first character} lch wb (xr)+
        inc  edi
        cmp  ebx,ch_d0      #jump if not digit} blt wb =ch_d0 gtn02
        jb   short gtn02 # (jump shortened)
        cmp  ebx,ch_d9      #jump if first char is a digit} ble wb =ch_d9 gtn06
        jbe  gtn06
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here if first digit is non-digit
#
gtn02:  cmp  ebx,ch_bl      #jump if non-blank} bne wb =ch_bl gtn03
        jne  short gtn03 # (jump shortened)
gtna2:  loop gtn01          #else decr count and loop back} bct wa gtn01
        jmp  gtn07          #jump to return zero if all blanks} brn gtn07
#
#      here for first character non-blank, non-digit
#
gtn03:  cmp  ebx,ch_pl      #jump if plus sign} beq wb =ch_pl gtn04
        je   short gtn04 # (jump shortened)
        cmp  ebx,ch_ht      #horizontal tab equiv to blank} beq wb =ch_ht gtna2
        je   gtna2
        cmp  ebx,ch_mn      #jump if not minus (may be real)} bne wb =ch_mn gtn12
        jne  gtn12
        mov  dword ptr gtnnf,esp #if minus sign, set negative flag} mnz gtnnf
#
#      merge here after processing sign
#
gtn04:  loop gtn05          #jump if chars left} bct wa gtn05
        jmp  gtn36          #else error} brn gtn36
#
#      loop to fetch characters of an integer
#
gtn05:  movzx ebx,byte ptr [edi] #load next character} lch wb (xr)+
        inc  edi
        cmp  ebx,ch_d0      #jump if not a digit} blt wb =ch_d0 gtn08
        jb   gtn08
        cmp  ebx,ch_d9      #jump if not a digit} bgt wb =ch_d9 gtn08
        ja   gtn08
#
#      merge here for first digit
#
gtn06:  mov  dword ptr gtnsi,edx #save current value} sti gtnsi
        imul edx,10         #current*10-(new dig) jump if ovflow} cvm gtn35
        jo   gtn35
        sub  ebx,ch_d0
        sub  edx,ebx
        jo   gtn35
        mov  dword ptr gtnrd,esp #set digit read flag} mnz gtnrd
        loop gtn05          #else loop back if more chars} bct wa gtn05
#
#      here to exit with converted integer value
#
gtn07:  cmp  dword ptr dword ptr gtnnf,0 #jump if negative (all set)} bnz gtnnf gtn32
        jnz  gtn32
        neg  edx            #else negate} ngi
        jno  gtn32          #jump if no overflow} ino gtn32
        jmp  gtn36          #else signal error} brn gtn36
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here for a non-digit character while attempting to
#      convert an integer, check for trailing blanks or real.
#
gtn08:  cmp  ebx,ch_bl      #jump if a blank} beq wb =ch_bl gtna9
        je   short gtna9 # (jump shortened)
        cmp  ebx,ch_ht      #jump if horizontal tab} beq wb =ch_ht gtna9
        je   short gtna9 # (jump shortened)
        call itr_           #else convert integer to real} itr
        call ngr_           #negate to get positive value} ngr
        jmp  gtn12          #jump to try for real} brn gtn12
#
#      here we scan out blanks to end of string
#
gtn09:  movzx ebx,byte ptr [edi] #get next char} lch wb (xr)+
        inc  edi
        cmp  ebx,ch_ht      #jump if horizontal tab} beq wb =ch_ht gtna9
        je   short gtna9 # (jump shortened)
        cmp  ebx,ch_bl      #error if non-blank} bne wb =ch_bl gtn36
        jne  gtn36
gtna9:  loop gtn09          #loop back if more chars to check} bct wa gtn09
        jmp  gtn07          #return integer if all blanks} brn gtn07
#
#      loop to collect mantissa of real
#
gtn10:  movzx ebx,byte ptr [edi] #load next character} lch wb (xr)+
        inc  edi
        cmp  ebx,ch_d0      #jump if non-numeric} blt wb =ch_d0 gtn12
        jb   gtn12
        cmp  ebx,ch_d9      #jump if non-numeric} bgt wb =ch_d9 gtn12
        ja   short gtn12 # (jump shortened)
#
#      merge here to collect first real digit
#
gtn11:  sub  ebx,ch_d0      #convert digit to number} sub =ch_d0 wb
        mov  eax,offset dword ptr reavt #multiply real by 10.0} mlr reavt
        call mlr_
        call ovr_           #convert error if overflow} rov gtn36
        jo   gtn36
        mov  eax,offset dword ptr gtnsr #save result} str gtnsr
        call str_
        mov  edx,ebx        #get new digit as integer} mti wb
        call itr_           #convert new digit to real} itr
        mov  eax,offset dword ptr gtnsr #add to get new total} adr gtnsr
        call adr_
        mov  eax,dword ptr gtndf #increment scale if after dec point} add gtndf gtnsc
        add  dword ptr gtnsc,eax
        mov  dword ptr gtnrd,esp #set digit found flag} mnz gtnrd
        loop gtn10          #loop back if more chars} bct wa gtn10
        jmp  gtn22          #else jump to scale} brn gtn22
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here if non-digit found while collecting a real
#
gtn12:  cmp  ebx,ch_dt      #jump if not dec point} bne wb =ch_dt gtn13
        jne  short gtn13 # (jump shortened)
        cmp  dword ptr dword ptr gtndf,0 #if dec point, error if one already} bnz gtndf gtn36
        jnz  gtn36
        mov  dword ptr gtndf,num01 #else set flag for dec point} mov =num01 gtndf
        loop gtn10          #loop back if more chars} bct wa gtn10
        jmp  gtn22          #else jump to scale} brn gtn22
#
#      here if not decimal point
#
gtn13:  cmp  ebx,ch_le      #jump if e for exponent} beq wb =ch_le gtn15
        je   short gtn15 # (jump shortened)
        cmp  ebx,ch_ld      #jump if d for exponent} beq wb =ch_ld gtn15
        je   short gtn15 # (jump shortened)
        cmp  ebx,ch__e      #jump if e for exponent} beq wb =ch__e gtn15
        je   short gtn15 # (jump shortened)
        cmp  ebx,ch__d      #jump if d for exponent} beq wb =ch__d gtn15
        je   short gtn15 # (jump shortened)
#
#      here check for trailing blanks
#
gtn14:  cmp  ebx,ch_bl      #jump if blank} beq wb =ch_bl gtnb4
        je   short gtnb4 # (jump shortened)
        cmp  ebx,ch_ht      #jump if horizontal tab} beq wb =ch_ht gtnb4
        je   short gtnb4 # (jump shortened)
        jmp  gtn36          #error if non-blank} brn gtn36
#
gtnb4:  movzx ebx,byte ptr [edi] #get next character} lch wb (xr)+
        inc  edi
        loop gtn14          #loop back to check if more} bct wa gtn14
        jmp  gtn22          #else jump to scale} brn gtn22
#
#      here to read and process an exponent
#
gtn15:  xor  eax,eax        #set exponent sign positive} zer gtnes
        mov  dword ptr gtnes,eax
        mov  edx,dword ptr intv0 #initialize exponent to zero} ldi intv0
        mov  dword ptr gtndf,esp #reset no dec point indication} mnz gtndf
        loop gtn16          #jump skipping past e or d} bct wa gtn16
        jmp  gtn36          #error if null exponent} brn gtn36
#
#      check for exponent sign
#
gtn16:  movzx ebx,byte ptr [edi] #load first exponent character} lch wb (xr)+
        inc  edi
        cmp  ebx,ch_pl      #jump if plus sign} beq wb =ch_pl gtn17
        je   short gtn17 # (jump shortened)
        cmp  ebx,ch_mn      #else jump if not minus sign} bne wb =ch_mn gtn19
        jne  short gtn19 # (jump shortened)
        mov  dword ptr gtnes,esp #set sign negative if minus sign} mnz gtnes
#
#      merge here after processing exponent sign
#
gtn17:  loop gtn18          #jump if chars left} bct wa gtn18
        jmp  gtn36          #else error} brn gtn36
#
#      loop to convert exponent digits
#
gtn18:  movzx ebx,byte ptr [edi] #load next character} lch wb (xr)+
        inc  edi
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      merge here for first exponent digit
#
gtn19:  cmp  ebx,ch_d0      #jump if not digit} blt wb =ch_d0 gtn20
        jb   short gtn20 # (jump shortened)
        cmp  ebx,ch_d9      #jump if not digit} bgt wb =ch_d9 gtn20
        ja   short gtn20 # (jump shortened)
        imul edx,10         #else current*10, subtract new digit} cvm gtn36
        jo   gtn36
        sub  ebx,ch_d0
        sub  edx,ebx
        jo   gtn36
        loop gtn18          #loop back if more chars} bct wa gtn18
        jmp  short gtn21          #jump if exponent field is exhausted} brn gtn21 # (jump shortened)
#
#      here to check for trailing blanks after exponent
#
gtn20:  cmp  ebx,ch_bl      #jump if blank} beq wb =ch_bl gtnc0
        je   short gtnc0 # (jump shortened)
        cmp  ebx,ch_ht      #jump if horizontal tab} beq wb =ch_ht gtnc0
        je   short gtnc0 # (jump shortened)
        jmp  gtn36          #error if non-blank} brn gtn36
#
gtnc0:  movzx ebx,byte ptr [edi] #get next character} lch wb (xr)+
        inc  edi
        loop gtn20          #loop back till all blanks scanned} bct wa gtn20
#
#      merge here after collecting exponent
#
gtn21:  mov  dword ptr gtnex,edx #save collected exponent} sti gtnex
        cmp  dword ptr dword ptr gtnes,0 #jump if it was negative} bnz gtnes gtn22
        jnz  short gtn22 # (jump shortened)
        neg  edx            #else complement} ngi
        jo   gtn36          #error if overflow} iov gtn36
        mov  dword ptr gtnex,edx #and store positive exponent} sti gtnex
#
#      merge here with exponent (0 if none given)
#
gtn22:  cmp  dword ptr dword ptr gtnrd,0 #error if not digits collected} bze gtnrd gtn36
        jz   gtn36
        cmp  dword ptr dword ptr gtndf,0 #error if no exponent or dec point} bze gtndf gtn36
        jz   gtn36
        mov  edx,dword ptr gtnsc #else load scale as integer} mti gtnsc
        sub  edx,dword ptr gtnex #subtract exponent} sbi gtnex
        jo   gtn36          #error if overflow} iov gtn36
        or   edx,edx        #jump if we must scale up} ilt gtn26
        jl   gtn26
#
#      here we have a negative exponent, so scale down
#
        or   edx,edx        #load scale factor, err if ovflow} mfi wa gtn36
        js   gtn36
        mov  ecx,edx
#
#      loop to scale down in steps of 10**10
#
gtn23:  cmp  ecx,num10      #jump if 10 or less to go} ble wa =num10 gtn24
        jbe  short gtn24 # (jump shortened)
        mov  eax,offset dword ptr reatt #else divide by 10**10} dvr reatt
        call dvr_
        sub  ecx,num10      #decrement scale} sub =num10 wa
        jmp  gtn23          #and loop back} brn gtn23
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here scale rest of way from powers of ten table
#
gtn24:  or   ecx,ecx        #jump if scaled} bze wa gtn30
        jz   gtn30
        mov  ebx,cfp_r      #else get indexing factor} lct wb =cfp_r
        mov  edi,offset reav1 #point to powers of ten table} mov =reav1 xr
        sal  ecx,2          #convert remaining scale to byte ofs} wtb wa
#
#      loop to point to powers of ten table entry
#
gtn25:  add  edi,ecx        #bump pointer} add wa xr
        dec  ebx            #once for each value word} bct wb gtn25
        jnz  gtn25
        lea  eax,dword ptr [edi] #scale down as required} dvr (xr)
        call dvr_
        jmp  gtn30          #and jump} brn gtn30
#
#      come here to scale result up (positive exponent)
#
gtn26:  neg  edx            #get absolute value of exponent} ngi
        jo   gtn36          #error if overflow} iov gtn36
        or   edx,edx        #acquire scale, error if ovflow} mfi wa gtn36
        js   gtn36
        mov  ecx,edx
#
#      loop to scale up in steps of 10**10
#
gtn27:  cmp  ecx,num10      #jump if 10 or less to go} ble wa =num10 gtn28
        jbe  short gtn28 # (jump shortened)
        mov  eax,offset dword ptr reatt #else multiply by 10**10} mlr reatt
        call mlr_
        call ovr_           #error if overflow} rov gtn36
        jo   gtn36
        sub  ecx,num10      #else decrement scale} sub =num10 wa
        jmp  gtn27          #and loop back} brn gtn27
#
#      here to scale up rest of way with table
#
gtn28:  or   ecx,ecx        #jump if scaled} bze wa gtn30
        jz   short gtn30 # (jump shortened)
        mov  ebx,cfp_r      #else get indexing factor} lct wb =cfp_r
        mov  edi,offset reav1 #point to powers of ten table} mov =reav1 xr
        sal  ecx,2          #convert remaining scale to byte ofs} wtb wa
#
#      loop to point to proper entry in powers of ten table
#
gtn29:  add  edi,ecx        #bump pointer} add wa xr
        dec  ebx            #once for each word in value} bct wb gtn29
        jnz  gtn29
        lea  eax,dword ptr [edi] #scale up} mlr (xr)
        call mlr_
        call ovr_           #error if overflow} rov gtn36
        jo   gtn36
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here with real value scaled and ready except for sign
#
gtn30:  cmp  dword ptr dword ptr gtnnf,0 #jump if positive} bze gtnnf gtn31
        jz   short gtn31 # (jump shortened)
        call ngr_           #else negate} ngr
#
#      here with properly signed real value in (ra)
#
gtn31:  call rcbld          #build real block} jsr rcbld
        jmp  short gtn33          #merge to exit} brn gtn33 # (jump shortened)
#
#      here with properly signed integer value in (ia)
#
gtn32:  call icbld          #build icblk} jsr icbld
#
#      real merges here
#
gtn33:  mov  ecx,dword ptr [edi] #load first word of result block} mov (xr) wa
        add  esp,4          #pop argument off stack} ica xs
#
#      common exit point
#
gtn34:  pop  eax            #return to gtnum caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      come here if overflow occurs during collection of integer
#      have to restore wb which cvm may have destroyed.
#
gtn35:  dec  edi            #reload current character} lch wb -(xr)
        movzx ebx,byte ptr [edi]
        movzx ebx,byte ptr [edi] #bump character pointer} lch wb (xr)+
        inc  edi
        mov  edx,dword ptr gtnsi #reload integer so far} ldi gtnsi
        call itr_           #convert to real} itr
        call ngr_           #make value positive} ngr
        jmp  gtn11          #merge with real circuit} brn gtn11
#
#      here for unconvertible to string or conversion error
#
gtn36:  pop  edi            #reload original argument} mov (xs)+ xr
        pop  eax            #take convert-error exit} exi 1
        jmp  exi__1
                            #end procedure gtnum} enp
                            #} ejc
        .eject
#
#      gtnvr -- convert to natural variable
#
#      gtnvr locates a variable block (vrblk) given either an
#      appropriate name (nmblk) or a non-null string (scblk).
#
#      (xr)                  argument
#      jsr  gtnvr            call to convert to natural variable
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to vrblk
#      (wa,wb)               destroyed (conversion error only)
#      (wc)                  destroyed
#
gtnvr:                      #entry point} prc e 1
        .global gtnvr
        cmp  dword ptr [edi],offset b_nml #jump if not name} bne (xr) =b_nml gnv02
        jne  short gnv02 # (jump shortened)
        mov  edi,dword ptr (4*nmbas)[edi] #else load name base if name} mov nmbas(xr) xr
        cmp  edi,dword ptr state #skip if vrblk (in static region)} blo xr state gnv07
        jb   gnv07
#
#      common error exit
#
gnv01:  pop  eax            #take convert-error exit} exi 1
        jmp  exi__1
#
#      here if not name
#
gnv02:  mov  dword ptr gnvsa,ecx #save ecx} mov wa gnvsa
        mov  dword ptr gnvsb,ebx #save ebx} mov wb gnvsb
        push edi            #stack argument for gtstg} mov xr -(xs)
        call gtstg          #convert argument to string} jsr gtstg
        .short gnv01-dffnc  #jump if conversion error} ppm gnv01
        or   ecx,ecx        #null string is an error} bze wa gnv01
        jz   gnv01
        call flstg          #fold lower case to upper case} jsr flstg
        push esi            #save esi} mov xl -(xs)
        push edi            #stack string ptr for later} mov xr -(xs)
        mov  ebx,edi        #copy string pointer} mov xr wb
        add  ebx,4*schar    #point to characters of string} add *schar wb
        mov  dword ptr gnvst,ebx #save pointer to characters} mov wb gnvst
        mov  ebx,ecx        #copy length} mov wa wb
        add  ebx,3+4*0      #get number of words in name} ctw wb 0
        shr  ebx,2
        mov  dword ptr gnvnw,ebx #save for later} mov wb gnvnw
        call hashs          #compute hash index for string} jsr hashs
        mov  eax,dword ptr hshnb #compute hash offset by taking mod} rmi hshnb
        call rmi_
                            #get as offset} mfi wc
        sal  edx,2          #convert offset to bytes} wtb wc
        add  edx,dword ptr hshtb #point to proper hash chain} add hshtb wc
        sub  edx,4*vrnxt    #subtract offset to merge into loop} sub *vrnxt wc
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      loop to search hash chain
#
gnv03:  mov  esi,edx        #copy hash chain pointer} mov wc xl
        mov  esi,dword ptr (4*vrnxt)[esi] #point to next vrblk on chain} mov vrnxt(xl) xl
        or   esi,esi        #jump if end of chain} bze xl gnv08
        jz   gnv08
        mov  edx,esi        #save pointer to this vrblk} mov xl wc
        cmp  dword ptr dword ptr (4*vrlen)[esi],0 #jump if not system variable} bnz vrlen(xl) gnv04
        jnz  short gnv04 # (jump shortened)
        mov  esi,dword ptr (4*vrsvp)[esi] #else point to svblk} mov vrsvp(xl) xl
        sub  esi,4*vrsof    #adjust offset for merge} sub *vrsof xl
#
#      merge here with string ptr (like vrblk) in xl
#
gnv04:  cmp  ecx,dword ptr (4*vrlen)[esi] #back for next vrblk if lengths ne} bne wa vrlen(xl) gnv03
        jne  gnv03
        add  esi,4*vrchs    #else point to chars of chain entry} add *vrchs xl
        mov  ebx,dword ptr gnvnw #get word counter to control loop} lct wb gnvnw
        mov  edi,dword ptr gnvst #point to chars of new name} mov gnvst xr
#
#      loop to compare characters of the two names
#
gnv05:  mov  eax,dword ptr [edi] #jump if no match for next vrblk} cne (xr) (xl) gnv03
        cmp  eax,dword ptr [esi]
        jnz  gnv03
        add  edi,4          #bump new name pointer} ica xr
        add  esi,4          #bump vrblk in chain name pointer} ica xl
        dec  ebx            #else loop till all compared} bct wb gnv05
        jnz  gnv05
        mov  edi,edx        #we have found a match, get vrblk} mov wc xr
#
#      exit point after finding vrblk or building new one
#
gnv06:  mov  ecx,dword ptr gnvsa #restore ecx} mov gnvsa wa
        mov  ebx,dword ptr gnvsb #restore ebx} mov gnvsb wb
        add  esp,4          #pop string pointer} ica xs
        pop  esi            #restore esi} mov (xs)+ xl
#
#      common exit point
#
gnv07:  pop  eax            #return to gtnvr caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      not found, prepare to search system variable table
#
gnv08:  xor  edi,edi        #clear garbage edi pointer} zer xr
        mov  dword ptr gnvhe,edx #save ptr to end of hash chain} mov wc gnvhe
        cmp  ecx,num09      #cannot be system var if length gt 9} bgt wa =num09 gnv14
        ja   gnv14
        mov  esi,ecx        #else copy length} mov wa xl
        sal  esi,2          #convert to byte offset} wtb xl
        mov  esi,vsrch[esi] #point to first svblk of this length} mov vsrch(xl) xl
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      loop to search entries in standard variable table
#
gnv09:  mov  dword ptr gnvsp,esi #save table pointer} mov xl gnvsp
        lodsd               #load svbit bit string} mov (xl)+ wc
        mov  edx,eax
        lodsd               #load length from table entry} mov (xl)+ wb
        mov  ebx,eax
        cmp  ecx,ebx        #jump if end of right length entries} bne wa wb gnv14
        jne  gnv14
        mov  ebx,dword ptr gnvnw #get word counter to control loop} lct wb gnvnw
        mov  edi,dword ptr gnvst #point to chars of new name} mov gnvst xr
#
#      loop to check for matching names
#
gnv10:  mov  eax,dword ptr [edi] #jump if name mismatch} cne (xr) (xl) gnv11
        cmp  eax,dword ptr [esi]
        jnz  short gnv11 # (jump shortened)
        add  edi,4          #else bump new name pointer} ica xr
        add  esi,4          #bump svblk pointer} ica xl
        dec  ebx            #else loop until all checked} bct wb gnv10
        jnz  gnv10
#
#      here we have a match in the standard variable table
#
        xor  edx,edx        #set vrlen value zero} zer wc
        mov  ecx,4*vrsi_    #set standard size} mov *vrsi_ wa
        jmp  gnv15          #jump to build vrblk} brn gnv15
#
#      here if no match with table entry in svblks table
#
gnv11:  add  esi,4          #bump past word of chars} ica xl
        dec  ebx            #loop back if more to go} bct wb gnv11
        jnz  gnv11
        shr  edx,svnbt      #remove uninteresting bits} rsh wc svnbt
#
#      loop to bump table ptr for each flagged word
#
gnv12:  mov  ebx,dword ptr bits1 #load bit to test} mov bits1 wb
        and  ebx,edx        #test for word present} anb wc wb
#        or   ebx,ebx        #jump if not present} zrb wb gnv13  (optimized)
        jz   short gnv13 # (jump shortened)
        add  esi,4          #else bump table pointer} ica xl
#
#      here after dealing with one word (one bit)
#
gnv13:  shr  edx,1          #remove bit already processed} rsh wc 1
#        or   edx,edx        #loop back if more bits to test} nzb wc gnv12  (optimized)
        jnz  gnv12
        jmp  gnv09          #else loop back for next svblk} brn gnv09
#
#      here if not system variable
#
gnv14:  mov  edx,ecx        #copy vrlen value} mov wa wc
        mov  ecx,vrchs      #load standard size -chars} mov =vrchs wa
        add  ecx,dword ptr gnvnw #adjust for chars of name} add gnvnw wa
        sal  ecx,2          #convert length to bytes} wtb wa
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      merge here to build vrblk
#
gnv15:  call alost          #allocate space for vrblk (static)} jsr alost
        mov  ebx,edi        #save vrblk pointer} mov xr wb
        mov  esi,offset stnvr #point to model variable block} mov =stnvr xl
        mov  ecx,4*vrlen    #set length of standard fields} mov *vrlen wa
        shr  ecx,2          #set initial fields of new block} mvw
        rep  movsd
        mov  esi,dword ptr gnvhe #load pointer to end of hash chain} mov gnvhe xl
        mov  dword ptr (4*vrnxt)[esi],ebx #add new block to end of chain} mov wb vrnxt(xl)
        mov  eax,edx        #set vrlen field, bump ptr} mov wc (xr)+
        stosd
        mov  ecx,dword ptr gnvnw #get length in words} mov gnvnw wa
        sal  ecx,2          #convert to length in bytes} wtb wa
        or   edx,edx        #jump if system variable} bze wc gnv16
        jz   short gnv16 # (jump shortened)
#
#      here for non-system variable -- set chars of name
#
        mov  esi,dword ptr [esp] #point back to string name} mov (xs) xl
        add  esi,4*schar    #point to chars of name} add *schar xl
        shr  ecx,2          #move characters into place} mvw
        rep  movsd
        mov  edi,ebx        #restore vrblk pointer} mov wb xr
        jmp  gnv06          #jump back to exit} brn gnv06
#
#      here for system variable case to fill in fields where
#      necessary from the fields present in the svblk.
#
gnv16:  mov  esi,dword ptr gnvsp #load pointer to svblk} mov gnvsp xl
        mov  dword ptr [edi],esi #set svblk ptr in vrblk} mov xl (xr)
        mov  edi,ebx        #restore vrblk pointer} mov wb xr
        mov  ebx,dword ptr (4*svbit)[esi] #load bit indicators} mov svbit(xl) wb
        add  esi,4*svchs    #point to characters of name} add *svchs xl
        add  esi,ecx        #point past characters} add wa xl
#
#      skip past keyword number (svknm) if present
#
        mov  edx,dword ptr btknm #load test bit} mov btknm wc
        and  edx,ebx        #and to test} anb wb wc
#        or   edx,edx        #jump if no keyword number} zrb wc gnv17  (optimized)
        jz   short gnv17 # (jump shortened)
        add  esi,4          #else bump pointer} ica xl
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      here test for function (svfnc and svnar)
#
gnv17:  mov  edx,dword ptr btfnc #get test bit} mov btfnc wc
        and  edx,ebx        #and to test} anb wb wc
#        or   edx,edx        #skip if no system function} zrb wc gnv18  (optimized)
        jz   short gnv18 # (jump shortened)
        mov  dword ptr (4*vrfnc)[edi],esi #else point vrfnc to svfnc field} mov xl vrfnc(xr)
        add  esi,4*num02    #and bump past svfnc, svnar fields} add *num02 xl
#
#      now test for label (svlbl)
#
gnv18:  mov  edx,dword ptr btlbl #get test bit} mov btlbl wc
        and  edx,ebx        #and to test} anb wb wc
#        or   edx,edx        #jump if bit is off (no system labl)} zrb wc gnv19  (optimized)
        jz   short gnv19 # (jump shortened)
        mov  dword ptr (4*vrlbl)[edi],esi #else point vrlbl to svlbl field} mov xl vrlbl(xr)
        add  esi,4          #bump past svlbl field} ica xl
#
#      now test for value (svval)
#
gnv19:  mov  edx,dword ptr btval #load test bit} mov btval wc
        and  edx,ebx        #and to test} anb wb wc
#        or   edx,edx        #all done if no value} zrb wc gnv06  (optimized)
        jz   gnv06
        mov  eax,dword ptr [esi] #else set initial value} mov (xl) vrval(xr)
        mov  dword ptr (4*vrval)[edi],eax
        mov  dword ptr (4*vrsto)[edi],offset b_vre #set error store access} mov =b_vre vrsto(xr)
        jmp  gnv06          #merge back to exit to caller} brn gnv06
                            #end procedure gtnvr} enp
                            #} ejc
        .eject
#
#      gtpat -- get pattern
#
#      gtpat is passed an object in (xr) and returns a
#      pattern after performing any necessary conversions
#
#      (xr)                  input argument
#      jsr  gtpat            call to convert to pattern
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  resulting pattern
#      (wa)                  destroyed
#      (wb)                  destroyed (only on convert error)
#      (xr)                  unchanged (only on convert error)
#
gtpat:                      #entry point} prc e 1
        .global gtpat
        cmp  dword ptr [edi],offset p_aaa #jump if pattern already} bhi (xr) =p_aaa gtpt5
        ja   gtpt5
#
#      here if not pattern, try for string
#
        mov  dword ptr gtpsb,ebx #save ebx} mov wb gtpsb
        push edi            #stack argument for gtstg} mov xr -(xs)
        call gtstg          #convert argument to string} jsr gtstg
        .short gtpt2-dffnc  #jump if impossible} ppm gtpt2
#
#      here we have a string
#
        or   ecx,ecx        #jump if non-null} bnz wa gtpt1
        jnz  short gtpt1 # (jump shortened)
#
#      here for null string. generate pointer to null pattern.
#
        mov  edi,offset ndnth #point to nothen node} mov =ndnth xr
        jmp  gtpt4          #jump to exit} brn gtpt4
                            #} ejc
        .eject
#
#      gtpat (continued)
#
#      here for non-null string
#
gtpt1:  mov  ebx,offset p_str #load pcode for multi-char string} mov =p_str wb
        cmp  ecx,num01      #jump if multi-char string} bne wa =num01 gtpt3
        jne  short gtpt3 # (jump shortened)
#
#      here for one character string, share one character any
#
        add  edi,cfp_f      #point to character} plc xr
        movzx ecx,byte ptr [edi] #load character} lch wa (xr)
        mov  edi,ecx        #set as parm1} mov wa xr
        mov  ebx,offset p_ans #point to pcode for 1-char any} mov =p_ans wb
        jmp  short gtpt3          #jump to build node} brn gtpt3 # (jump shortened)
#
#      here if argument is not convertible to string
#
gtpt2:  mov  ebx,offset p_exa #set pcode for expression in case} mov =p_exa wb
        cmp  dword ptr [edi],offset b_e__ #jump to build node if expression} blo (xr) =b_e__ gtpt3
        jb   short gtpt3 # (jump shortened)
#
#      here we have an error (conversion impossible)
#
        pop  eax            #take convert error exit} exi 1
        jmp  exi__1
#
#      merge here to build node for string or expression
#
gtpt3:  call pbild          #call routine to build pattern node} jsr pbild
#
#      common exit after successful conversion
#
gtpt4:  mov  ebx,dword ptr gtpsb #restore ebx} mov gtpsb wb
#
#      merge here to exit if no conversion required
#
gtpt5:  pop  eax            #return to gtpat caller} exi
        lea  eax,[eax+2]
        jmp  eax
                            #end procedure gtpat} enp
                            #} ejc
        .eject
#
#      gtrea -- get real value
#
#      gtrea is passed an object and returns a real value
#      performing any necessary conversions.
#
#      (xr)                  object to be converted
#      jsr  gtrea            call to convert object to real
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to resulting real
#      (wa,wb,wc,ra)         destroyed
#      (xr)                  unchanged (convert error only)
#
gtrea:                      #entry point} prc e 1
        .global gtrea
        mov  ecx,dword ptr [edi] #get first word of block} mov (xr) wa
        cmp  ecx,offset b_rcl #jump if real} beq wa =b_rcl gtre2
        je   short gtre2 # (jump shortened)
        call gtnum          #else convert argument to numeric} jsr gtnum
        .short gtre3-dffnc  #jump if unconvertible} ppm gtre3
        cmp  ecx,offset b_rcl #jump if real was returned} beq wa =b_rcl gtre2
        je   short gtre2 # (jump shortened)
#
#      here for case of an integer to convert to real
#
gtre1:  mov  edx,dword ptr (4*icval)[edi] #load integer} ldi icval(xr)
        call itr_           #convert to real} itr
        call rcbld          #build rcblk} jsr rcbld
#
#      exit with real
#
gtre2:  pop  eax            #return to gtrea caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here on conversion error
#
gtre3:  pop  eax            #take convert error exit} exi 1
        jmp  exi__1
                            #end procedure gtrea} enp
                            #} ejc
        .eject
#
#      gtsmi -- get small integer
#
#      gtsmi is passed a snobol object and returns an address
#      integer in the range (0 le n le dnamb). such a value can
#      only be derived from an integer in the appropriate range.
#      small integers never appear as snobol values. however,
#      they are used internally for a variety of purposes.
#
#      -(xs)                 argument to convert (on stack)
#      jsr  gtsmi            call to convert to small integer
#      ppm  loc              transfer loc for not integer
#      ppm  loc              transfer loc for lt 0, gt dnamb
#      (xr,wc)               resulting small int (two copies)
#      (xs)                  popped
#      (ra)                  destroyed
#      (wa,wb)               destroyed (on convert error only)
#      (xr)                  input arg (convert error only)
#
gtsmi:                      #entry point} prc n 2
        .global gtsmi
        pop  prc_+20
        pop  edi            #load argument} mov (xs)+ xr
        cmp  dword ptr [edi],offset b_icl #skip if already an integer} beq (xr) =b_icl gtsm1
        je   short gtsm1 # (jump shortened)
#
#      here if not an integer
#
        call gtint          #convert argument to integer} jsr gtint
        .short gtsm2-dffnc  #jump if convert is impossible} ppm gtsm2
#
#      merge here with integer
#
gtsm1:  mov  edx,dword ptr (4*icval)[edi] #load integer value} ldi icval(xr)
        or   edx,edx        #move as one word, jump if ovflow} mfi wc gtsm3
        js   short gtsm3 # (jump shortened)
        cmp  edx,dword ptr mxlen #or if too large} bgt wc mxlen gtsm3
        ja   short gtsm3 # (jump shortened)
        mov  edi,edx        #copy result to edi} mov wc xr
        mov  eax,prc_+20    #return to gtsmi caller} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      here if unconvertible to integer
#
gtsm2:  mov  eax,prc_+20    #take non-integer error exit} exi 1
        jmp  exi__1
#
#      here if out of range
#
gtsm3:  mov  eax,prc_+20    #take out-of-range error exit} exi 2
        jmp  exi__2
                            #end procedure gtsmi} enp
                            #} ejc
        .eject
#
#      gtstg -- get string
#
#      gtstg is passed an object and returns a string with
#      any necessary conversions performed.
#
#      -(xs)                 input argument (on stack)
#      jsr  gtstg            call to convert to string
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to resulting string
#      (wa)                  length of string in characters
#      (xs)                  popped
#      (ra)                  destroyed
#      (xr)                  input arg (convert error only)
#
gtstg:                      #entry point} prc n 1
        .global gtstg
        pop  prc_+24
        pop  edi            #load argument, pop stack} mov (xs)+ xr
        cmp  dword ptr [edi],offset b_scl #jump if already a string} beq (xr) =b_scl gts30
        je   gts30
#
#      here if not a string already
#
gts01:  push edi            #restack argument in case error} mov xr -(xs)
        push esi            #save esi} mov xl -(xs)
        mov  dword ptr gtsvb,ebx #save ebx} mov wb gtsvb
        mov  dword ptr gtsvc,edx #save edx} mov wc gtsvc
        mov  ecx,dword ptr [edi] #load first word of block} mov (xr) wa
        cmp  ecx,offset b_icl #jump to convert integer} beq wa =b_icl gts05
        je   gts05
        cmp  ecx,offset b_rcl #jump to convert real} beq wa =b_rcl gts10
        je   gts10
        cmp  ecx,offset b_nml #jump to convert name} beq wa =b_nml gts03
        je   short gts03 # (jump shortened)
#
#      here on conversion error
#
gts02:  pop  esi            #restore esi} mov (xs)+ xl
        pop  edi            #reload input argument} mov (xs)+ xr
        mov  eax,prc_+24    #take convert error exit} exi 1
        jmp  exi__1
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      here to convert a name (only possible if natural var)
#
gts03:  mov  esi,dword ptr (4*nmbas)[edi] #load name base} mov nmbas(xr) xl
        cmp  esi,dword ptr state #error if not natural var (static)} bhi xl state gts02
        ja   gts02
        add  esi,4*vrsof    #else point to possible string name} add *vrsof xl
        mov  ecx,dword ptr (4*sclen)[esi] #load length} mov sclen(xl) wa
        or   ecx,ecx        #jump if not system variable} bnz wa gts04
        jnz  short gts04 # (jump shortened)
        mov  esi,dword ptr (4*vrsvo)[esi] #else point to svblk} mov vrsvo(xl) xl
        mov  ecx,dword ptr (4*svlen)[esi] #and load name length} mov svlen(xl) wa
#
#      merge here with string in xr, length in wa
#
gts04:  xor  ebx,ebx        #set offset to zero} zer wb
        call sbstr          #use sbstr to copy string} jsr sbstr
        jmp  gts29          #jump to exit} brn gts29
#
#      come here to convert an integer
#
gts05:  mov  edx,dword ptr (4*icval)[edi] #load integer value} ldi icval(xr)
        mov  dword ptr gtssf,num01 #set sign flag negative} mov =num01 gtssf
        or   edx,edx        #skip if integer is negative} ilt gts06
        jl   short gts06 # (jump shortened)
        neg  edx            #else negate integer} ngi
        xor  eax,eax        #and reset negative flag} zer gtssf
        mov  dword ptr gtssf,eax
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      here with sign flag set and sign forced negative as
#      required by the cvd instruction.
#
gts06:  mov  edi,dword ptr gtswk #point to result work area} mov gtswk xr
        mov  ebx,nstmx      #initialize counter to max length} mov =nstmx wb
        lea  edi,[cfp_f+edi+ebx] #prepare to store (right-left)} psc xr wb
#
#      loop to convert digits into work area
#
gts07:  call cvd_           #convert one digit into ecx} cvd
        dec  edi            #store in work area} sch wa -(xr)
        mov  [edi],cl
        dec  ebx            #decrement counter} dcv wb
        or   edx,edx        #loop if more digits to go} ine gts07
        jne  gts07
#
#      merge here after converting integer or real into work
#      area. wb is set to nstmx - (number of chars in result).
#
gts08:  mov  ecx,nstmx      #get max number of characters} mov =nstmx wa
        sub  ecx,ebx        #compute length of result} sub wb wa
        mov  esi,ecx        #remember length for move later on} mov wa xl
        add  ecx,dword ptr gtssf #add one for negative sign if needed} add gtssf wa
        call alocs          #allocate string for result} jsr alocs
        mov  edx,edi        #save result pointer for the moment} mov xr wc
        add  edi,cfp_f      #point to chars of result block} psc xr
        cmp  dword ptr dword ptr gtssf,0 #skip if positive} bze gtssf gts09
        jz   short gts09 # (jump shortened)
        mov  ecx,ch_mn      #else load negative sign} mov =ch_mn wa
        mov  al,cl          #and store it} sch wa (xr)+
        stosb
#
#      here after dealing with sign
#
gts09:  mov  ecx,esi        #recall length to move} mov xl wa
        mov  esi,dword ptr gtswk #point to result work area} mov gtswk xl
        lea  esi,[cfp_f+esi+ebx] #point to first result character} plc xl wb
        shrd eax,ecx,1      #move chars to result string} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        mov  edi,edx        #restore result pointer} mov wc xr
        jmp  gts29          #jump to exit} brn gts29
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      here to convert a real
#
gts10:  lea  eax,dword ptr (4*rcval)[edi] #load real} ldr rcval(xr)
        call ldr_
        xor  eax,eax        #reset negative flag} zer gtssf
        mov  dword ptr gtssf,eax
        call cpr_           #skip if zero} req gts31
        je   gts31
        call cpr_           #jump if real is positive} rge gts11
        jge  short gts11 # (jump shortened)
        mov  dword ptr gtssf,num01 #else set negative flag} mov =num01 gtssf
        call ngr_           #and get absolute value of real} ngr
#
#      now scale the real to the range (0.1 le x lt 1.0)
#
gts11:  mov  edx,dword ptr intv0 #initialize exponent to zero} ldi intv0
#
#      loop to scale up in steps of 10**10
#
gts12:  mov  eax,offset dword ptr gtsrs #save real value} str gtsrs
        call str_
        mov  eax,offset dword ptr reap1 #subtract 0.1 to compare} sbr reap1
        call sbr_
        call cpr_           #jump if scale up not required} rge gts13
        jge  short gts13 # (jump shortened)
        mov  eax,offset dword ptr gtsrs #else reload value} ldr gtsrs
        call ldr_
        mov  eax,offset dword ptr reatt #multiply by 10**10} mlr reatt
        call mlr_
        sub  edx,dword ptr intvt #decrement exponent by 10} sbi intvt
        jmp  gts12          #loop back to test again} brn gts12
#
#      test for scale down required
#
gts13:  mov  eax,offset dword ptr gtsrs #reload value} ldr gtsrs
        call ldr_
        mov  eax,offset dword ptr reav1 #subtract 1.0} sbr reav1
        call sbr_
        call cpr_           #jump if no scale down required} rlt gts17
        jl   gts17
        mov  eax,offset dword ptr gtsrs #else reload value} ldr gtsrs
        call ldr_
#
#      loop to scale down in steps of 10**10
#
gts14:  mov  eax,offset dword ptr reatt #subtract 10**10 to compare} sbr reatt
        call sbr_
        call cpr_           #jump if large step not required} rlt gts15
        jl   short gts15 # (jump shortened)
        mov  eax,offset dword ptr gtsrs #else restore value} ldr gtsrs
        call ldr_
        mov  eax,offset dword ptr reatt #divide by 10**10} dvr reatt
        call dvr_
        mov  eax,offset dword ptr gtsrs #store new value} str gtsrs
        call str_
        add  edx,dword ptr intvt #increment exponent by 10} adi intvt
        jmp  gts14          #loop back} brn gts14
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      at this point we have (1.0 le x lt 10**10)
#      complete scaling with powers of ten table
#
gts15:  mov  edi,offset reav1 #point to powers of ten table} mov =reav1 xr
#
#      loop to locate correct entry in table
#
gts16:  mov  eax,offset dword ptr gtsrs #reload value} ldr gtsrs
        call ldr_
        add  edx,dword ptr intv1 #increment exponent} adi intv1
        add  edi,4*cfp_r    #point to next entry in table} add *cfp_r xr
        lea  eax,dword ptr [edi] #subtract it to compare} sbr (xr)
        call sbr_
        call cpr_           #loop till we find a larger entry} rge gts16
        jge  gts16
        mov  eax,offset dword ptr gtsrs #then reload the value} ldr gtsrs
        call ldr_
        lea  eax,dword ptr [edi] #and complete scaling} dvr (xr)
        call dvr_
        mov  eax,offset dword ptr gtsrs #store value} str gtsrs
        call str_
#
#      we are now scaled, so round by adding 0.5 * 10**(-cfp$s)
#
gts17:  mov  eax,offset dword ptr gtsrs #get value again} ldr gtsrs
        call ldr_
        mov  eax,offset dword ptr gtsrn #add rounding factor} adr gtsrn
        call adr_
        mov  eax,offset dword ptr gtsrs #store result} str gtsrs
        call str_
#
#      the rounding operation may have pushed us up past
#      1.0 again, so check one more time.
#
        mov  eax,offset dword ptr reav1 #subtract 1.0 to compare} sbr reav1
        call sbr_
        call cpr_           #skip if ok} rlt gts18
        jl   short gts18 # (jump shortened)
        add  edx,dword ptr intv1 #else increment exponent} adi intv1
        mov  eax,offset dword ptr gtsrs #reload value} ldr gtsrs
        call ldr_
        mov  eax,offset dword ptr reavt #divide by 10.0 to rescale} dvr reavt
        call dvr_
        jmp  gts19          #jump to merge} brn gts19
#
#      here if rounding did not muck up scaling
#
gts18:  mov  eax,offset dword ptr gtsrs #reload rounded value} ldr gtsrs
        call ldr_
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      now we have completed the scaling as follows
#
#      (ia)                  signed exponent
#      (ra)                  scaled real (absolute value)
#
#      if the exponent is negative or greater than cfp$s, then
#      we convert the number in the form.
#
#      (neg sign) 0 . (cpf$s digits) e (exp sign) (exp digits)
#
#      if the exponent is positive and less than or equal to
#      cfp$s, the number is converted in the form.
#
#      (neg sign) (exponent digits) . (cfp$s-exponent digits)
#
#      in both cases, the formats obtained from the above
#      rules are modified by deleting trailing zeros after the
#      decimal point. there are no leading zeros in the exponent
#      and the exponent sign is always present.
#
gts19:  mov  esi,cfp_s      #set num dec digits = cfp_s} mov =cfp_s xl
        mov  dword ptr gtses,ch_mn #set exponent sign negative} mov =ch_mn gtses
        or   edx,edx        #all set if exponent is negative} ilt gts21
        jl   short gts21 # (jump shortened)
        mov  ecx,edx        #else fetch exponent} mfi wa
        cmp  ecx,cfp_s      #skip if we can use special format} ble wa =cfp_s gts20
        jbe  short gts20 # (jump shortened)
        mov  edx,ecx        #else restore exponent} mti wa
        neg  edx            #set negative for cvd} ngi
        mov  dword ptr gtses,ch_pl #set plus sign for exponent sign} mov =ch_pl gtses
        jmp  short gts21          #jump to generate exponent} brn gts21 # (jump shortened)
#
#      here if we can use the format without an exponent
#
gts20:  sub  esi,ecx        #compute digits after decimal point} sub wa xl
        mov  edx,dword ptr intv0 #reset exponent to zero} ldi intv0
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      merge here as follows
#
#      (ia)                  exponent absolute value
#      gtses                 character for exponent sign
#      (ra)                  positive fraction
#      (xl)                  number of digits after dec point
#
gts21:  mov  edi,dword ptr gtswk #point to work area} mov gtswk xr
        mov  ebx,nstmx      #set character ctr to max length} mov =nstmx wb
        lea  edi,[cfp_f+edi+ebx] #prepare to store (right to left)} psc xr wb
        or   edx,edx        #skip exponent if it is zero} ieq gts23
        je   short gts23 # (jump shortened)
#
#      loop to generate digits of exponent
#
gts22:  call cvd_           #convert a digit into ecx} cvd
        dec  edi            #store in work area} sch wa -(xr)
        mov  [edi],cl
        dec  ebx            #decrement counter} dcv wb
        or   edx,edx        #loop back if more digits to go} ine gts22
        jne  gts22
#
#      here generate exponent sign and e
#
        mov  ecx,dword ptr gtses #load exponent sign} mov gtses wa
        dec  edi            #store in work area} sch wa -(xr)
        mov  [edi],cl
        mov  ecx,ch_le      #get character letter e} mov =ch_le wa
        dec  edi            #store in work area} sch wa -(xr)
        mov  [edi],cl
        sub  ebx,num02      #decrement counter for sign and e} sub =num02 wb
#
#      here to generate the fraction
#
gts23:  mov  eax,offset dword ptr gtssc #convert real to integer (10**cfp_s)} mlr gtssc
        call mlr_
        call rti_           #get integer (overflow impossible)} rti
        neg  edx            #negate as required by cvd} ngi
#
#      loop to suppress trailing zeros
#
gts24:  or   esi,esi        #jump if no digits left to do} bze xl gts27
        jz   short gts27 # (jump shortened)
        call cvd_           #else convert one digit} cvd
        cmp  ecx,ch_d0      #jump if not a zero} bne wa =ch_d0 gts26
        jne  short gts26 # (jump shortened)
        dec  esi            #decrement counter} dcv xl
        jmp  gts24          #loop back for next digit} brn gts24
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      loop to generate digits after decimal point
#
gts25:  call cvd_           #convert a digit into ecx} cvd
#
#      merge here first time
#
gts26:  dec  edi            #store digit} sch wa -(xr)
        mov  [edi],cl
        dec  ebx            #decrement counter} dcv wb
        dec  esi            #decrement counter} dcv xl
#        or   esi,esi        #loop back if more to go} bnz xl gts25  (optimized)
        jnz  gts25
#
#      here generate the decimal point
#
gts27:  mov  ecx,ch_dt      #load decimal point} mov =ch_dt wa
        dec  edi            #store in work area} sch wa -(xr)
        mov  [edi],cl
        dec  ebx            #decrement counter} dcv wb
#
#      here generate the digits before the decimal point
#
gts28:  call cvd_           #convert a digit into ecx} cvd
        dec  edi            #store in work area} sch wa -(xr)
        mov  [edi],cl
        dec  ebx            #decrement counter} dcv wb
        or   edx,edx        #loop back if more to go} ine gts28
        jne  gts28
        jmp  gts08          #else jump back to exit} brn gts08
#
#      exit point after successful conversion
#
gts29:  pop  esi            #restore esi} mov (xs)+ xl
        add  esp,4          #pop argument} ica xs
        mov  ebx,dword ptr gtsvb #restore ebx} mov gtsvb wb
        mov  edx,dword ptr gtsvc #restore edx} mov gtsvc wc
#
#      merge here if no conversion required
#
gts30:  mov  ecx,dword ptr (4*sclen)[edi] #load string length} mov sclen(xr) wa
        mov  eax,prc_+24    #return to caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here to return string for real zero
#
gts31:  mov  esi,offset scre0 #point to string} mov =scre0 xl
        mov  ecx,num02      #2 chars} mov =num02 wa
        xor  ebx,ebx        #zero offset} zer wb
        call sbstr          #copy string} jsr sbstr
        jmp  gts29          #return} brn gts29
                            #end procedure gtstg} enp
                            #} ejc
        .eject
#
#      gtvar -- get variable for i/o/trace association
#
#      gtvar is used to point to an actual variable location
#      for the detach,input,output,trace,stoptr system functions
#
#      (xr)                  argument to function
#      jsr  gtvar            call to locate variable pointer
#      ppm  loc              transfer loc if not ok variable
#      (xl,wa)               name base,offset of variable
#      (xr,ra)               destroyed
#      (wb,wc)               destroyed (convert error only)
#      (xr)                  input arg (convert error only)
#
gtvar:                      #entry point} prc e 1
        .global gtvar
        cmp  dword ptr [edi],offset b_nml #jump if not a name} bne (xr) =b_nml gtvr2
        jne  short gtvr2 # (jump shortened)
        mov  ecx,dword ptr (4*nmofs)[edi] #else load name offset} mov nmofs(xr) wa
        mov  esi,dword ptr (4*nmbas)[edi] #load name base} mov nmbas(xr) xl
        cmp  dword ptr [esi],offset b_evt #error if expression variable} beq (xl) =b_evt gtvr1
        je   short gtvr1 # (jump shortened)
        cmp  dword ptr [esi],offset b_kvt #all ok if not keyword variable} bne (xl) =b_kvt gtvr3
        jne  short gtvr3 # (jump shortened)
#
#      here on conversion error
#
gtvr1:  pop  eax            #take convert error exit} exi 1
        jmp  exi__1
#
#      here if not a name, try convert to natural variable
#
gtvr2:  mov  dword ptr gtvrc,edx #save edx} mov wc gtvrc
        call gtnvr          #locate vrblk if possible} jsr gtnvr
        .short gtvr1-dffnc  #jump if convert error} ppm gtvr1
        mov  esi,edi        #else copy vrblk name base} mov xr xl
        mov  ecx,4*vrval    #and set offset} mov *vrval wa
        mov  edx,dword ptr gtvrc #restore edx} mov gtvrc wc
#
#      here for name obtained
#
gtvr3:  cmp  esi,dword ptr state #all ok if not natural variable} bhi xl state gtvr4
        ja   short gtvr4 # (jump shortened)
        cmp  dword ptr (4*vrsto)[esi],offset b_vre #error if protected variable} beq vrsto(xl) =b_vre gtvr1
        je   gtvr1
#
#      common exit point
#
gtvr4:  pop  eax            #return to caller} exi
        lea  eax,[eax+2]
        jmp  eax
                            #end procedure gtvar} enp
                            #} ejc
        .eject
#
#      hashs -- compute hash index for string
#
#      hashs is used to convert a string to a unique integer
#      value. the resulting hash value is a positive integer
#      in the range 0 to cfp$m
#
#      (xr)                  string to be hashed
#      jsr  hashs            call to hash string
#      (ia)                  hash value
#      (xr,wb,wc)            destroyed
#
#      the hash function used is as follows.
#
#      start with the length of the string (sgd07)
#
#      take the first e$hnw words of the characters from
#      the string or all the words if fewer than e$hnw.
#
#      compute the exclusive or of all these words treating
#      them as one word bit string values.
#
#      move the result as an integer with the mti instruction.
#
hashs:                      #entry point} prc e 0
        .global hashs
        mov  edx,dword ptr (4*sclen)[edi] #load string length in characters} mov sclen(xr) wc
        mov  ebx,edx        #initialize with length} mov wc wb
        or   edx,edx        #jump if null string} bze wc hshs3
        jz   short hshs3 # (jump shortened)
        xchg bl,bh          #correct byte ordering if necessary} zgb wb
        rol  ebx,16
        xchg bl,bh
        add  edx,3+4*0      #get number of words of chars} ctw wc 0
        shr  edx,2
        add  edi,4*schar    #point to characters of string} add *schar xr
        cmp  edx,e_hnw      #use whole string if short} blo wc =e_hnw hshs1
        jb   short hshs1 # (jump shortened)
        mov  edx,e_hnw      #else set to involve first e_hnw wds} mov =e_hnw wc
#
#      here with count of words to check in wc
#
hshs1:                      #set counter to control loop} lct wc wc
#
#      loop to compute exclusive or
#
hshs2:  xor  ebx,dword ptr [edi] #exclusive or next word of chars} xob (xr)+ wb
        lea  edi,[edi+4]
        dec  edx            #loop till all processed} bct wc hshs2
        jnz  hshs2
#
#      merge here with exclusive or in wb
#
hshs3:  xchg bl,bh          #zeroise undefined bits} zgb wb
        rol  ebx,16
        xchg bl,bh
        and  ebx,dword ptr bitsm #ensure in range 0 to cfp_m} anb bitsm wb
        mov  edx,ebx        #move result as integer} mti wb
        xor  edi,edi        #clear garbage value in edi} zer xr
        ret                 #return to hashs caller} exi
                            #end procedure hashs} enp
                            #} ejc
        .eject
#
#      icbld -- build integer block
#
#      (ia)                  integer value for icblk
#      jsr  icbld            call to build integer block
#      (xr)                  pointer to result icblk
#      (wa)                  destroyed
#
icbld:                      #entry point} prc e 0
        .global icbld
        or   edx,edx        #copy small integers} mfi xr icbl1
        js   short icbl1 # (jump shortened)
        mov  edi,edx
        cmp  edi,num02      #jump if 0,1 or 2} ble xr =num02 icbl3
        jbe  short icbl3 # (jump shortened)
#
#      construct icblk
#
icbl1:  mov  edi,dword ptr dnamp #load pointer to next available loc} mov dnamp xr
        add  edi,4*icsi_    #point past new icblk} add *icsi_ xr
        cmp  edi,dword ptr dname #jump if there is room} blo xr dname icbl2
        jb   short icbl2 # (jump shortened)
        mov  ecx,4*icsi_    #else load length of icblk} mov *icsi_ wa
        call alloc          #use standard allocator to get block} jsr alloc
        add  edi,ecx        #point past block to merge} add wa xr
#
#      merge here with xr pointing past the block obtained
#
icbl2:  mov  dword ptr dnamp,edi #set new pointer} mov xr dnamp
        sub  edi,4*icsi_    #point back to start of block} sub *icsi_ xr
        mov  dword ptr [edi],offset b_icl #store type word} mov =b_icl (xr)
        mov  dword ptr (4*icval)[edi],edx #store integer value in icblk} sti icval(xr)
        ret                 #return to icbld caller} exi
#
#      optimise by not building icblks for small integers
#
icbl3:  sal  edi,2          #convert integer to offset} wtb xr
        mov  edi,intab[edi] #point to pre-built icblk} mov intab(xr) xr
        ret                 #return} exi
                            #end procedure icbld} enp
                            #} ejc
        .eject
#
#      ident -- compare two values
#
#      ident compares two values in the sense of the ident
#      differ functions available at the snobol level.
#
#      (xr)                  first argument
#      (xl)                  second argument
#      jsr  ident            call to compare arguments
#      ppm  loc              transfer loc if ident
#      (normal return if differ)
#      (xr,xl,wc,ra)         destroyed
#
ident:                      #entry point} prc e 1
        .global ident
        cmp  edi,esi        #jump if same pointer (ident)} beq xr xl iden7
        je   iden7
        mov  edx,dword ptr [edi] #else load arg 1 type word} mov (xr) wc
        cmp  edx,dword ptr [esi] #differ if arg 2 type word differ} bne wc (xl) iden1
        jne  short iden1 # (jump shortened)
        cmp  edx,offset b_scl #jump if strings} beq wc =b_scl iden2
        je   short iden2 # (jump shortened)
        cmp  edx,offset b_icl #jump if integers} beq wc =b_icl iden4
        je   iden4
        cmp  edx,offset b_rcl #jump if reals} beq wc =b_rcl iden5
        je   iden5
        cmp  edx,offset b_nml #jump if names} beq wc =b_nml iden6
        je   iden6
#
#      for all other datatypes, must be differ if xr ne xl
#
#      merge here for differ
#
iden1:  pop  eax            #take differ exit} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here for strings, ident only if lengths and chars same
#
iden2:  mov  edx,dword ptr (4*sclen)[edi] #load arg 1 length} mov sclen(xr) wc
        cmp  edx,dword ptr (4*sclen)[esi] #differ if lengths differ} bne wc sclen(xl) iden1
        jne  iden1
#
#      buffer and string comparisons merge here
#
idn2a:  add  edi,4*schar    #point to chars of arg 1} add *schar xr
        add  esi,4*schar    #point to chars of arg 2} add *schar xl
        add  edx,3+4*0      #get number of words in strings} ctw wc 0
        shr  edx,2
#
#      loop to compare characters. note that wc cannot be zero
#      since all null strings point to nulls and give xl=xr.
#
iden3:  mov  eax,dword ptr [edi] #differ if chars do not match} cne (xr) (xl) iden8
        cmp  eax,dword ptr [esi]
        jnz  iden8
        add  edi,4          #else bump arg one pointer} ica xr
        add  esi,4          #bump arg two pointer} ica xl
        dec  edx            #loop back till all checked} bct wc iden3
        jnz  iden3
                            #} ejc
        .eject
#
#      ident (continued)
#
#      here to exit for case of two ident strings
#
        xor  esi,esi        #clear garbage value in esi} zer xl
        xor  edi,edi        #clear garbage value in edi} zer xr
        pop  eax            #take ident exit} exi 1
        jmp  exi__1
#
#      here for integers, ident if same values
#
iden4:  mov  edx,dword ptr (4*icval)[edi] #load arg 1} ldi icval(xr)
        sub  edx,dword ptr (4*icval)[esi] #subtract arg 2 to compare} sbi icval(xl)
        jo   iden1          #differ if overflow} iov iden1
        or   edx,edx        #differ if result is not zero} ine iden1
        jne  iden1
        pop  eax            #take ident exit} exi 1
        jmp  exi__1
#
#      here for reals, ident if same values
#
iden5:  lea  eax,dword ptr (4*rcval)[edi] #load arg 1} ldr rcval(xr)
        call ldr_
        lea  eax,dword ptr (4*rcval)[esi] #subtract arg 2 to compare} sbr rcval(xl)
        call sbr_
        call ovr_           #differ if overflow} rov iden1
        jo   iden1
        call cpr_           #differ if result is not zero} rne iden1
        jne  iden1
        pop  eax            #take ident exit} exi 1
        jmp  exi__1
#
#      here for names, ident if bases and offsets same
#
iden6:  mov  eax,dword ptr (4*nmofs)[edi] #differ if different offset} bne nmofs(xr) nmofs(xl) iden1
        cmp  eax,dword ptr (4*nmofs)[esi]
        jne  iden1
        mov  eax,dword ptr (4*nmbas)[edi] #differ if different base} bne nmbas(xr) nmbas(xl) iden1
        cmp  eax,dword ptr (4*nmbas)[esi]
        jne  iden1
#
#      merge here to signal ident for identical pointers
#
iden7:  pop  eax            #take ident exit} exi 1
        jmp  exi__1
#
#      here for differ strings
#
iden8:  xor  edi,edi        #clear garbage ptr in edi} zer xr
        xor  esi,esi        #clear garbage ptr in esi} zer xl
        pop  eax            #return to caller (differ)} exi
        lea  eax,[eax+2]
        jmp  eax
                            #end procedure ident} enp
                            #} ejc
        .eject
#
#      inout - used to initialise input and output variables
#
#      (xl)                  pointer to vbl name string
#      (wb)                  trblk type
#      jsr  inout            call to perform initialisation
#      (xl)                  vrblk ptr
#      (xr)                  trblk ptr
#      (wa,wc)               destroyed
#
#      note that trter (= trtrf) field of standard i/o variables
#      points to corresponding svblk not to a trblk as is the
#      case for ordinary variables.
#
inout:                      #entry point} prc e 0
        .global inout
        push ebx            #stack trblk type} mov wb -(xs)
        mov  ecx,dword ptr (4*sclen)[esi] #get name length} mov sclen(xl) wa
        xor  ebx,ebx        #point to start of name} zer wb
        call sbstr          #build a proper scblk} jsr sbstr
        call gtnvr          #build vrblk} jsr gtnvr
        .short err_-299-dffnc #no error return} ppm
        mov  edx,edi        #save vrblk pointer} mov xr wc
        pop  ebx            #get trter field} mov (xs)+ wb
        xor  esi,esi        #zero trfpt} zer xl
        call trbld          #build trblk} jsr trbld
        mov  esi,edx        #recall vrblk pointer} mov wc xl
        mov  eax,dword ptr (4*vrsvp)[esi] #store svblk pointer} mov vrsvp(xl) trter(xr)
        mov  dword ptr (4*trter)[edi],eax
        mov  dword ptr (4*vrval)[esi],edi #store trblk ptr in vrblk} mov xr vrval(xl)
        mov  dword ptr (4*vrget)[esi],offset b_vra #set trapped access} mov =b_vra vrget(xl)
        mov  dword ptr (4*vrsto)[esi],offset b_vrv #set trapped store} mov =b_vrv vrsto(xl)
        ret                 #return to caller} exi
                            #end procedure inout} enp
                            #} ejc
        .eject
#
#      insta - used to initialize structures in static region
#
#      (xr)                  pointer to starting static location
#      jsr  insta            call to initialize static structure
#      (xr)                  ptr to next free static location
#      (wa,wb,wc)            destroyed
#
#      note that this procedure establishes the pointers
#      prbuf, gtswk, and kvalp.
#
insta:                      #entry point} prc e 0
        .global insta
#
#      initialize print buffer with blank words
#
        mov  edx,dword ptr prlen #no. of chars in print bfr} mov prlen wc
        mov  dword ptr prbuf,edi #print bfr is put at static start} mov xr prbuf
        mov  eax,offset b_scl #store string type code} mov =b_scl (xr)+
        stosd
        mov  eax,edx        #and string length} mov wc (xr)+
        stosd
        add  edx,3+4*0      #get number of words in buffer} ctw wc 0
        shr  edx,2
        mov  dword ptr prlnw,edx #store for buffer clear} mov wc prlnw
#
#      loop to clear buffer
#
inst1:  mov  eax,dword ptr nullw #store blank} mov nullw (xr)+
        stosd
        dec  edx            #loop} bct wc inst1
        jnz  inst1
#
#      allocate work area for gtstg conversion procedure
#
        mov  ecx,nstmx      #get max num chars in output number} mov =nstmx wa
        add  ecx,3+4*scsi_  #no of bytes needed} ctb wa scsi_
        and  ecx,-4
        mov  dword ptr gtswk,edi #store bfr adrs} mov xr gtswk
        add  edi,ecx        #bump for work bfr} add wa xr
#
#      build alphabet string for alphabet keyword and replace
#
        mov  dword ptr kvalp,edi #save alphabet pointer} mov xr kvalp
        mov  dword ptr [edi],offset b_scl #string blk type} mov =b_scl (xr)
        mov  edx,cfp_a      #no of chars in alphabet} mov =cfp_a wc
        mov  dword ptr (4*sclen)[edi],edx #store as string length} mov wc sclen(xr)
        mov  ebx,edx        #copy char count} mov wc wb
        add  ebx,3+4*scsi_  #no. of bytes needed} ctb wb scsi_
        and  ebx,-4
        add  ebx,edi        #current end address for static} add xr wb
        mov  ecx,ebx        #save adrs past alphabet string} mov wb wa
        add  edi,cfp_f      #point to chars of string} psc xr
        xor  ebx,ebx        #set initial character value} zer wb
#
#      loop to enter character codes in order
#
inst2:  mov  al,bl          #store next code} sch wb (xr)+
        stosb
        inc  ebx            #bump code value} icv wb
        dec  edx            #loop till all stored} bct wc inst2
        jnz  inst2
        mov  edi,ecx        #return current static ptr} mov wa xr
        ret                 #return to caller} exi
                            #end procedure insta} enp
                            #} ejc
        .eject
#
#      iofcb -- get input/output fcblk pointer
#
#      used by endfile, eject and rewind to find the fcblk
#      (if any) corresponding to their argument.
#
#      -(xs)                 argument
#      jsr  iofcb            call to find fcblk
#      ppm  loc              arg is an unsuitable name
#      ppm  loc              arg is null string
#      ppm  loc              arg file not found
#      (xs)                  popped
#      (xl)                  ptr to filearg1 vrblk
#      (xr)                  argument
#      (wa)                  fcblk ptr or 0
#      (wb,wc)               destroyed
#
iofcb:                      #entry point} prc n 3
        .global iofcb
        pop  prc_+28
        call gtstg          #get arg as string} jsr gtstg
        .short iofc2-dffnc  #fail} ppm iofc2
        mov  esi,edi        #copy string ptr} mov xr xl
        call gtnvr          #get as natural variable} jsr gtnvr
        .short iofc3-dffnc  #fail if null} ppm iofc3
        mov  ebx,esi        #copy string pointer again} mov xl wb
        mov  esi,edi        #copy vrblk ptr for return} mov xr xl
        xor  ecx,ecx        #in case no trblk found} zer wa
#
#      loop to find file arg1 trblk
#
iofc1:  mov  edi,dword ptr (4*vrval)[edi] #get possible trblk ptr} mov vrval(xr) xr
        cmp  dword ptr [edi],offset b_trt #fail if end of chain} bne (xr) =b_trt iofc4
        jne  short iofc4 # (jump shortened)
        cmp  dword ptr (4*trtyp)[edi],trtfc #loop if not file arg trblk} bne trtyp(xr) =trtfc iofc1
        jne  iofc1
        mov  ecx,dword ptr (4*trfpt)[edi] #get fcblk ptr} mov trfpt(xr) wa
        mov  edi,ebx        #copy arg} mov wb xr
        mov  eax,prc_+28    #return} exi
        lea  eax,[eax+6]
        jmp  eax
#
#      fail return
#
iofc2:  mov  eax,prc_+28    #fail} exi 1
        jmp  exi__1
#
#      null arg
#
iofc3:  mov  eax,prc_+28    #null arg return} exi 2
        jmp  exi__2
#
#      file not found
#
iofc4:  mov  eax,prc_+28    #file not found return} exi 3
        jmp  exi__3
                            #end procedure iofcb} enp
                            #} ejc
        .eject
#
#      ioppf -- process filearg2 for ioput
#
#      (r$xsc)               filearg2 ptr
#      jsr  ioppf            call to process filearg2
#      (xl)                  filearg1 ptr
#      (xr)                  file arg2 ptr
#      -(xs)...-(xs)         fields extracted from filearg2
#      (wc)                  no. of fields extracted
#      (wb)                  input/output flag
#      (wa)                  fcblk ptr or 0
#
ioppf:                      #entry point} prc n 0
        .global ioppf
        pop  prc_+32
        xor  ebx,ebx        #to count fields extracted} zer wb
#
#      loop to extract fields
#
iopp1:  mov  esi,iodel      #get delimiter} mov =iodel xl
        mov  edx,esi        #copy it} mov xl wc
        xor  ecx,ecx        #retain leading blanks in filearg2} zer wa
        call xscan          #get next field} jsr xscan
        push edi            #stack it} mov xr -(xs)
        inc  ebx            #increment count} icv wb
        or   ecx,ecx        #loop} bnz wa iopp1
        jnz  iopp1
        mov  edx,ebx        #count of fields} mov wb wc
        mov  ebx,dword ptr ioptt #i/o marker} mov ioptt wb
        mov  ecx,dword ptr r_iof #fcblk ptr or 0} mov r_iof wa
        mov  edi,dword ptr r_io2 #file arg2 ptr} mov r_io2 xr
        mov  esi,dword ptr r_io1 #filearg1} mov r_io1 xl
        jmp  [prc_+32]      #return} exi
                            #end procedure ioppf} enp
                            #} ejc
        .eject
#
#      ioput -- routine used by input and output
#
#      ioput sets up input/output  associations. it builds
#      such trace and file control blocks as are necessary and
#      calls sysfc,sysio to perform checks on the
#      arguments and to open the files.
#
#         +-----------+   +---------------+       +-----------+
#      +-.i           i   i               i------.i   =b$xrt  i
#      i  +-----------+   +---------------+       +-----------+
#      i  /           /        (r$fcb)            i    *4     i
#      i  /           /                           +-----------+
#      i  +-----------+   +---------------+       i           i-
#      i  i   name    +--.i    =b$trt     i       +-----------+
#      i  /           /   +---------------+       i           i
#      i   (first arg)    i =trtin/=trtou i       +-----------+
#      i                  +---------------+             i
#      i                  i     value     i             i
#      i                  +---------------+             i
#      i                  i(trtrf) 0   or i--+          i
#      i                  +---------------+  i          i
#      i                  i(trfpt) 0   or i----+        i
#      i                  +---------------+  i i        i
#      i                     (i/o trblk)     i i        i
#      i  +-----------+                      i i        i
#      i  i           i                      i i        i
#      i  +-----------+                      i i        i
#      i  i           i                      i i        i
#      i  +-----------+   +---------------+  i i        i
#      i  i           +--.i    =b$trt     i.-+ i        i
#      i  +-----------+   +---------------+    i        i
#      i  /           /   i    =trtfc     i    i        i
#      i  /           /   +---------------+    i        i
#      i    (filearg1     i     value     i    i        i
#      i         vrblk)   +---------------+    i        i
#      i                  i(trtrf) 0   or i--+ i        .
#      i                  +---------------+  i .  +-----------+
#      i                  i(trfpt) 0   or i------./   fcblk   /
#      i                  +---------------+  i    +-----------+
#      i                       (trtrf)       i
#      i                                     i
#      i                                     i
#      i                  +---------------+  i
#      i                  i    =b$xrt     i.-+
#      i                  +---------------+
#      i                  i      *5       i
#      i                  +---------------+
#      +------------------i               i
#                         +---------------+       +-----------+
#                         i(trtrf) o   or i------.i  =b$xrt   i
#                         +---------------+       +-----------+
#                         i  name offset  i       i    etc    i
#                         +---------------+
#                           (iochn - chain of name pointers)
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      no additional trap blocks are used for standard input/out
#      files. otherwise an i/o trap block is attached to second
#      arg (filearg1) vrblk. see diagram above for details of
#      the structure built.
#
#      -(xs)                 1st arg (vbl to be associated)
#      -(xs)                 2nd arg (file arg1)
#      -(xs)                 3rd arg (file arg2)
#      (wb)                  0 for input, 3 for output assoc.
#      jsr  ioput            call for input/output association
#      ppm  loc              3rd arg not a string
#      ppm  loc              2nd arg not a suitable name
#      ppm  loc              1st arg not a suitable name
#      ppm  loc              inappropriate file spec for i/o
#      ppm  loc              i/o file does not exist
#      ppm  loc              i/o file cannot be read/written
#      ppm  loc              i/o fcblk currently in use
#      (xs)                  popped
#      (xl,xr,wa,wb,wc)      destroyed
#
ioput:                      #entry point} prc n 7
        .global ioput
        pop  prc_+36
        xor  eax,eax        #in case no trtrf block used} zer r_iot
        mov  dword ptr r_iot,eax
        xor  eax,eax        #in case no fcblk alocated} zer r_iof
        mov  dword ptr r_iof,eax
        xor  eax,eax        #in case sysio fails} zer r_iop
        mov  dword ptr r_iop,eax
        mov  dword ptr ioptt,ebx #store i/o trace type} mov wb ioptt
        call xscni          #prepare to scan filearg2} jsr xscni
        .short iop13-dffnc  #fail} ppm iop13
        .short iopa0-dffnc  #null file arg2} ppm iopa0
#
iopa0:  mov  dword ptr r_io2,edi #keep file arg2} mov xr r_io2
        mov  esi,ecx        #copy length} mov wa xl
        call gtstg          #convert filearg1 to string} jsr gtstg
        .short iop14-dffnc  #fail} ppm iop14
        mov  dword ptr r_io1,edi #keep filearg1 ptr} mov xr r_io1
        call gtnvr          #convert to natural variable} jsr gtnvr
        .short iop00-dffnc  #jump if null} ppm iop00
        jmp  iop04          #jump to process non-null args} brn iop04
#
#      null filearg1
#
iop00:  or   esi,esi        #skip if both args null} bze xl iop01
        jz   short iop01 # (jump shortened)
        call ioppf          #process filearg2} jsr ioppf
        call sysfc          #call for filearg2 check} jsr sysfc
        .short iop16-dffnc  #fail} ppm iop16
        .short iop26-dffnc  #fail} ppm iop26
        jmp  iop11          #complete file association} brn iop11
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      here with 0 or fcblk ptr in (xl)
#
iop01:  mov  ebx,dword ptr ioptt #get trace type} mov ioptt wb
        mov  edi,dword ptr r_iot #get 0 or trtrf ptr} mov r_iot xr
        call trbld          #build trblk} jsr trbld
        mov  edx,edi        #copy trblk pointer} mov xr wc
        pop  edi            #get variable from stack} mov (xs)+ xr
        push edx            #make trblk collectable} mov wc -(xs)
        call gtvar          #point to variable} jsr gtvar
        .short iop15-dffnc  #fail} ppm iop15
        pop  edx            #recover trblk pointer} mov (xs)+ wc
        mov  dword ptr r_ion,esi #save name pointer} mov xl r_ion
        mov  edi,esi        #copy name pointer} mov xl xr
        add  edi,ecx        #point to variable} add wa xr
        sub  edi,4*vrval    #subtract offset,merge into loop} sub *vrval xr
#
#      loop to end of trblk chain if any
#
iop02:  mov  esi,edi        #copy blk ptr} mov xr xl
        mov  edi,dword ptr (4*vrval)[edi] #load ptr to next trblk} mov vrval(xr) xr
        cmp  dword ptr [edi],offset b_trt #jump if not trapped} bne (xr) =b_trt iop03
        jne  short iop03 # (jump shortened)
        mov  eax,dword ptr (4*trtyp)[edi] #loop if not same assocn} bne trtyp(xr) ioptt iop02
        cmp  eax,dword ptr ioptt
        jne  iop02
        mov  edi,dword ptr (4*trnxt)[edi] #get value and delete old trblk} mov trnxt(xr) xr
#
#      ioput (continued)
#
#      store new association
#
iop03:  mov  dword ptr (4*vrval)[esi],edx #link to this trblk} mov wc vrval(xl)
        mov  esi,edx        #copy pointer} mov wc xl
        mov  dword ptr (4*trnxt)[esi],edi #store value in trblk} mov xr trnxt(xl)
        mov  edi,dword ptr r_ion #restore possible vrblk pointer} mov r_ion xr
        mov  ebx,ecx        #keep offset to name} mov wa wb
        call setvr          #if vrblk, set vrget,vrsto} jsr setvr
        mov  edi,dword ptr r_iot #get 0 or trtrf ptr} mov r_iot xr
        or   edi,edi        #jump if trtrf block exists} bnz xr iop19
        jnz  iop19
        mov  eax,prc_+36    #return to caller} exi
        lea  eax,[eax+14]
        jmp  eax
#
#      non standard file
#      see if an fcblk has already been allocated.
#
iop04:  xor  ecx,ecx        #in case no fcblk found} zer wa
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      search possible trblk chain to pick up the fcblk
#
iop05:  mov  ebx,edi        #remember blk ptr} mov xr wb
        mov  edi,dword ptr (4*vrval)[edi] #chain along} mov vrval(xr) xr
        cmp  dword ptr [edi],offset b_trt #jump if end of trblk chain} bne (xr) =b_trt iop06
        jne  short iop06 # (jump shortened)
        cmp  dword ptr (4*trtyp)[edi],trtfc #loop if more to go} bne trtyp(xr) =trtfc iop05
        jne  iop05
        mov  dword ptr r_iot,edi #point to file arg1 trblk} mov xr r_iot
        mov  ecx,dword ptr (4*trfpt)[edi] #get fcblk ptr from trblk} mov trfpt(xr) wa
#
#      wa = 0 or fcblk ptr
#      wb = ptr to preceding blk to which any trtrf block
#           for file arg1 must be chained.
#
iop06:  mov  dword ptr r_iof,ecx #keep possible fcblk ptr} mov wa r_iof
        mov  dword ptr r_iop,ebx #keep preceding blk ptr} mov wb r_iop
        call ioppf          #process filearg2} jsr ioppf
        call sysfc          #see if fcblk required} jsr sysfc
        .short iop16-dffnc  #fail} ppm iop16
        .short iop26-dffnc  #fail} ppm iop26
        or   ecx,ecx        #skip if no new fcblk wanted} bze wa iop12
        jz   iop12
        cmp  edx,num02      #jump if fcblk in dynamic} blt wc =num02 iop6a
        jb   short iop6a # (jump shortened)
        call alost          #get it in static} jsr alost
        jmp  short iop6b          #skip} brn iop6b # (jump shortened)
#
#      obtain fcblk in dynamic
#
iop6a:  call alloc          #get space for fcblk} jsr alloc
#
#      merge
#
iop6b:  mov  esi,edi        #point to fcblk} mov xr xl
        mov  ebx,ecx        #copy its length} mov wa wb
        shr  ebx,2          #get count as words (sgd apr80)} btw wb
#
#      clear fcblk
#
iop07:  xor  eax,eax        #clear a word} zer (xr)+
        stosd
        dec  ebx            #loop} bct wb iop07
        jnz  iop07
        cmp  edx,num02      #skip if in static - dont set fields} beq wc =num02 iop09
        je   short iop09 # (jump shortened)
        mov  dword ptr [esi],offset b_xnt #store xnblk code in case} mov =b_xnt (xl)
        mov  dword ptr (4*num01)[esi],ecx #store length} mov wa num01(xl)
        or   edx,edx        #jump if xnblk wanted} bnz wc iop09
        jnz  short iop09 # (jump shortened)
        mov  dword ptr [esi],offset b_xrt #xrblk code requested} mov =b_xrt (xl)
#
                            #} ejc
        .eject
#      ioput (continued)
#
#      complete fcblk initialisation
#
iop09:  mov  edi,dword ptr r_iot #get possible trblk ptr} mov r_iot xr
        mov  dword ptr r_iof,esi #store fcblk ptr} mov xl r_iof
        or   edi,edi        #jump if trblk already found} bnz xr iop10
        jnz  short iop10 # (jump shortened)
#
#      a new trblk is needed
#
        mov  ebx,trtfc      #trtyp for fcblk trap blk} mov =trtfc wb
        call trbld          #make the block} jsr trbld
        mov  dword ptr r_iot,edi #copy trtrf ptr} mov xr r_iot
        mov  esi,dword ptr r_iop #point to preceding blk} mov r_iop xl
        mov  eax,dword ptr (4*vrval)[esi] #copy value field to trblk} mov vrval(xl) vrval(xr)
        mov  dword ptr (4*vrval)[edi],eax
        mov  dword ptr (4*vrval)[esi],edi #link new trblk into chain} mov xr vrval(xl)
        mov  edi,esi        #point to predecessor blk} mov xl xr
        call setvr          #set trace intercepts} jsr setvr
        mov  edi,dword ptr (4*vrval)[edi] #recover trblk ptr} mov vrval(xr) xr
        jmp  short iop1a          #store fcblk ptr} brn iop1a # (jump shortened)
#
#      here if existing trblk
#
iop10:  xor  eax,eax        #do not release if sysio fails} zer r_iop
        mov  dword ptr r_iop,eax
#
#      xr is ptr to trblk, xl is fcblk ptr or 0
#
iop1a:  mov  eax,dword ptr r_iof #store fcblk ptr} mov r_iof trfpt(xr)
        mov  dword ptr (4*trfpt)[edi],eax
#
#      call sysio to complete file accessing
#
iop11:  mov  ecx,dword ptr r_iof #copy fcblk ptr or 0} mov r_iof wa
        mov  ebx,dword ptr ioptt #get input/output flag} mov ioptt wb
        mov  edi,dword ptr r_io2 #get file arg2} mov r_io2 xr
        mov  esi,dword ptr r_io1 #get file arg1} mov r_io1 xl
        call sysio          #associate to the file} jsr sysio
        .short iop17-dffnc  #fail} ppm iop17
        .short iop18-dffnc  #fail} ppm iop18
        cmp  dword ptr dword ptr r_iot,0 #not std input if non-null trtrf blk} bnz r_iot iop01
        jnz  iop01
        cmp  dword ptr dword ptr ioptt,0 #jump if output} bnz ioptt iop01
        jnz  iop01
        or   edx,edx        #no change to standard read length} bze wc iop01
        jz   iop01
        mov  dword ptr cswin,edx #store new read length for std file} mov wc cswin
        jmp  iop01          #merge to finish the task} brn iop01
#
#      sysfc may have returned a pointer to a private fcblk
#
iop12:  or   esi,esi        #jump if private fcblk} bnz xl iop09
        jnz  iop09
        jmp  iop11          #finish the association} brn iop11
#
#      failure returns
#
iop13:  mov  eax,prc_+36    #3rd arg not a string} exi 1
        jmp  exi__1
iop14:  mov  eax,prc_+36    #2nd arg unsuitable} exi 2
        jmp  exi__2
iop15:  add  esp,4          #discard trblk pointer} ica xs
        mov  eax,prc_+36    #1st arg unsuitable} exi 3
        jmp  exi__3
iop16:  mov  eax,prc_+36    #file spec wrong} exi 4
        jmp  exi__4
iop26:  mov  eax,prc_+36    #fcblk in use} exi 7
        jmp  exi__7
#
#      i/o file does not exist
#
iop17:  mov  edi,dword ptr r_iop #is there a trblk to release} mov r_iop xr
        or   edi,edi        #if not} bze xr iopa7
        jz   short iopa7 # (jump shortened)
        mov  esi,dword ptr (4*vrval)[edi] #point to trblk} mov vrval(xr) xl
        mov  eax,dword ptr (4*vrval)[esi] #unsplice it} mov vrval(xl) vrval(xr)
        mov  dword ptr (4*vrval)[edi],eax
        call setvr          #adjust trace intercepts} jsr setvr
iopa7:  mov  eax,prc_+36    #i/o file does not exist} exi 5
        jmp  exi__5
#
#      i/o file cannot be read/written
#
iop18:  mov  edi,dword ptr r_iop #is there a trblk to release} mov r_iop xr
        or   edi,edi        #if not} bze xr iopa7
        jz   iopa7
        mov  esi,dword ptr (4*vrval)[edi] #point to trblk} mov vrval(xr) xl
        mov  eax,dword ptr (4*vrval)[esi] #unsplice it} mov vrval(xl) vrval(xr)
        mov  dword ptr (4*vrval)[edi],eax
        call setvr          #adjust trace intercepts} jsr setvr
iopa8:  mov  eax,prc_+36    #i/o file cannot be read/written} exi 6
        jmp  exi__6
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      add to iochn chain of associated variables unless
#      already present.
#
iop19:  mov  edx,dword ptr r_ion #edx = name base, ebx = name offset} mov r_ion wc
#
#      search loop
#
iop20:  mov  edi,dword ptr (4*trtrf)[edi] #next link of chain} mov trtrf(xr) xr
        or   edi,edi        #not found} bze xr iop21
        jz   short iop21 # (jump shortened)
        cmp  edx,dword ptr (4*ionmb)[edi] #no match} bne wc ionmb(xr) iop20
        jne  iop20
        cmp  ebx,dword ptr (4*ionmo)[edi] #exit if matched} beq wb ionmo(xr) iop22
        je   short iop22 # (jump shortened)
        jmp  iop20          #loop} brn iop20
#
#      not found
#
iop21:  mov  ecx,4*num05    #space needed} mov *num05 wa
        call alloc          #get it} jsr alloc
        mov  dword ptr [edi],offset b_xrt #store xrblk code} mov =b_xrt (xr)
        mov  dword ptr (4*num01)[edi],ecx #store length} mov wa num01(xr)
        mov  dword ptr (4*ionmb)[edi],edx #store name base} mov wc ionmb(xr)
        mov  dword ptr (4*ionmo)[edi],ebx #store name offset} mov wb ionmo(xr)
        mov  esi,dword ptr r_iot #point to trtrf blk} mov r_iot xl
        mov  ecx,dword ptr (4*trtrf)[esi] #get ptr field contents} mov trtrf(xl) wa
        mov  dword ptr (4*trtrf)[esi],edi #store ptr to new block} mov xr trtrf(xl)
        mov  dword ptr (4*trtrf)[edi],ecx #complete the linking} mov wa trtrf(xr)
#
#      insert fcblk on fcblk chain for sysej, sysxi
#
iop22:  cmp  dword ptr dword ptr r_iof,0 #skip if no fcblk} bze r_iof iop25
        jz   short iop25 # (jump shortened)
        mov  esi,dword ptr r_fcb #ptr to head of existing chain} mov r_fcb xl
#
#      see if fcblk already on chain
#
iop23:  or   esi,esi        #not on if end of chain} bze xl iop24
        jz   short iop24 # (jump shortened)
        mov  eax,dword ptr (4*num03)[esi] #dont duplicate if find it} beq num03(xl) r_iof iop25
        cmp  eax,dword ptr r_iof
        je   short iop25 # (jump shortened)
        mov  esi,dword ptr (4*num02)[esi] #get next link} mov num02(xl) xl
        jmp  iop23          #loop} brn iop23
#
#      not found so add an entry for this fcblk
#
iop24:  mov  ecx,4*num04    #space needed} mov *num04 wa
        call alloc          #get it} jsr alloc
        mov  dword ptr [edi],offset b_xrt #store block code} mov =b_xrt (xr)
        mov  dword ptr (4*num01)[edi],ecx #store length} mov wa num01(xr)
        mov  eax,dword ptr r_fcb #store previous link in this node} mov r_fcb num02(xr)
        mov  dword ptr (4*num02)[edi],eax
        mov  eax,dword ptr r_iof #store fcblk ptr} mov r_iof num03(xr)
        mov  dword ptr (4*num03)[edi],eax
        mov  dword ptr r_fcb,edi #insert node into fcblk chain} mov xr r_fcb
#
#      return
#
iop25:  mov  eax,prc_+36    #return to caller} exi
        lea  eax,[eax+14]
        jmp  eax
                            #end procedure ioput} enp
                            #} ejc
        .eject
#
#      ktrex -- execute keyword trace
#
#      ktrex is used to execute a possible keyword trace. it
#      includes the test on trace and tests for trace active.
#
#      (xl)                  ptr to trblk (or 0 if untraced)
#      jsr  ktrex            call to execute keyword trace
#      (xl,wa,wb,wc)         destroyed
#      (ra)                  destroyed
#
ktrex:                      #entry point (recursive)} prc r 0
        .global ktrex
        or   esi,esi        #immediate exit if keyword untraced} bze xl ktrx3
        jz   ktrx3
        cmp  dword ptr dword ptr kvtra,0 #immediate exit if trace = 0} bze kvtra ktrx3
        jz   ktrx3
        dec  dword ptr kvtra #else decrement trace} dcv kvtra
        push edi            #save edi} mov xr -(xs)
        mov  edi,esi        #copy trblk pointer} mov xl xr
        mov  esi,dword ptr (4*trkvr)[edi] #load vrblk pointer (nmbas)} mov trkvr(xr) xl
        mov  ecx,4*vrval    #set name offset} mov *vrval wa
        cmp  dword ptr dword ptr (4*trfnc)[edi],0 #jump if print trace} bze trfnc(xr) ktrx1
        jz   short ktrx1 # (jump shortened)
        call trxeq          #else execute full trace} jsr trxeq
        jmp  short ktrx2          #and jump to exit} brn ktrx2 # (jump shortened)
#
#      here for print trace
#
ktrx1:  push esi            #stack vrblk ptr for kwnam} mov xl -(xs)
        push ecx            #stack offset for kwnam} mov wa -(xs)
        call prtsn          #print statement number} jsr prtsn
        mov  ecx,ch_am      #load ampersand} mov =ch_am wa
        call prtch          #print ampersand} jsr prtch
        call prtnm          #print keyword name} jsr prtnm
        mov  edi,offset tmbeb #point to blank-equal-blank} mov =tmbeb xr
        call prtst          #print blank-equal-blank} jsr prtst
        call kwnam          #get keyword pseudo-variable name} jsr kwnam
        mov  dword ptr dnamp,edi #reset ptr to delete kvblk} mov xr dnamp
        call acess          #get keyword value} jsr acess
        .short err_-299-dffnc #failure is impossible} ppm
        call prtvl          #print keyword value} jsr prtvl
        call prtnl          #terminate print line} jsr prtnl
#
#      here to exit after completing trace
#
ktrx2:  pop  edi            #restore entry edi} mov (xs)+ xr
#
#      merge here to exit if no trace required
#
ktrx3:  ret                 #return to ktrex caller} exi
                            #end procedure ktrex} enp
                            #} ejc
        .eject
#
#      kwnam -- get pseudo-variable name for keyword
#
#      1(xs)                 name base for vrblk
#      0(xs)                 offset (should be *vrval)
#      jsr  kwnam            call to get pseudo-variable name
#      (xs)                  popped twice
#      (xl,wa)               resulting pseudo-variable name
#      (xr,wa,wb)            destroyed
#
kwnam:                      #entry point} prc n 0
        .global kwnam
        pop  prc_+40
        add  esp,4          #ignore name offset} ica xs
        pop  edi            #load name base} mov (xs)+ xr
        cmp  edi,dword ptr state #jump if not natural variable name} bge xr state kwnm1
        jae  short kwnm1 # (jump shortened)
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #error if not system variable} bnz vrlen(xr) kwnm1
        jnz  short kwnm1 # (jump shortened)
        mov  edi,dword ptr (4*vrsvp)[edi] #else point to svblk} mov vrsvp(xr) xr
        mov  ecx,dword ptr (4*svbit)[edi] #load bit mask} mov svbit(xr) wa
        and  ecx,dword ptr btknm #and with keyword bit} anb btknm wa
#        or   ecx,ecx        #error if no keyword association} zrb wa kwnm1  (optimized)
        jz   short kwnm1 # (jump shortened)
        mov  ecx,dword ptr (4*svlen)[edi] #else load name length in characters} mov svlen(xr) wa
        add  ecx,3+4*svchs  #compute offset to field we want} ctb wa svchs
        and  ecx,-4
        add  edi,ecx        #point to svknm field} add wa xr
        mov  ebx,dword ptr [edi] #load svknm value} mov (xr) wb
        mov  ecx,4*kvsi_    #set size of kvblk} mov *kvsi_ wa
        call alloc          #allocate kvblk} jsr alloc
        mov  dword ptr [edi],offset b_kvt #store type word} mov =b_kvt (xr)
        mov  dword ptr (4*kvnum)[edi],ebx #store keyword number} mov wb kvnum(xr)
        mov  dword ptr (4*kvvar)[edi],offset trbkv #set dummy trblk pointer} mov =trbkv kvvar(xr)
        mov  esi,edi        #copy kvblk pointer} mov xr xl
        mov  ecx,4*kvvar    #set proper offset} mov *kvvar wa
        jmp  [prc_+40]      #return to kvnam caller} exi
#
#      here if not keyword name
#
kwnm1:  call err_0          #} erb 251 keyword operand is not name of defined keyword
        .byte 251
                            #end procedure kwnam} enp
                            #} ejc
        .eject
#
#      lcomp-- compare two strings lexically
#
#      1(xs)                 first argument
#      0(xs)                 second argument
#      jsr  lcomp            call to compare aruments
#      ppm  loc              transfer loc for arg1 not string
#      ppm  loc              transfer loc for arg2 not string
#      ppm  loc              transfer loc if arg1 llt arg2
#      ppm  loc              transfer loc if arg1 leq arg2
#      ppm  loc              transfer loc if arg1 lgt arg2
#      (the normal return is never taken)
#      (xs)                  popped twice
#      (xr,xl)               destroyed
#      (wa,wb,wc,ra)         destroyed
#
lcomp:                      #entry point} prc n 5
        .global lcomp
        pop  prc_+44
        call gtstg          #convert second arg to string} jsr gtstg
        .short lcmp6-dffnc  #jump if second arg not string} ppm lcmp6
        mov  esi,edi        #else save pointer} mov xr xl
        mov  edx,ecx        #and length} mov wa wc
        call gtstg          #convert first argument to string} jsr gtstg
        .short lcmp5-dffnc  #jump if not string} ppm lcmp5
        mov  ebx,ecx        #save arg 1 length} mov wa wb
        add  edi,cfp_f      #point to chars of arg 1} plc xr
        add  esi,cfp_f      #point to chars of arg 2} plc xl
        cmp  ecx,edx        #jump if arg 1 length is smaller} blo wa wc lcmp1
        jb   short lcmp1 # (jump shortened)
        mov  ecx,edx        #else set arg 2 length as smaller} mov wc wa
#
#      here with smaller length in (wa)
#
lcmp1:  or   ecx,ecx        #if null string, compare lengths} bze wa lcmp7
        jz   short lcmp7 # (jump shortened)
        repe cmpsb          #compare strings, jump if unequal} cmc lcmp4 lcmp3
        mov  esi,0
        mov  edi,esi
        ja   short lcmp3 # (jump shortened)
        jb   short lcmp4 # (jump shortened)
lcmp7:  cmp  ebx,edx        #if equal, jump if lengths unequal} bne wb wc lcmp2
        jne  short lcmp2 # (jump shortened)
        mov  eax,prc_+44    #else identical strings, leq exit} exi 4
        jmp  exi__4
                            #} ejc
        .eject
#
#      lcomp (continued)
#
#      here if initial strings identical, but lengths unequal
#
lcmp2:  cmp  ebx,edx        #jump if arg 1 length gt arg 2 leng} bhi wb wc lcmp4
        ja   short lcmp4 # (jump shortened)
#
#      here if first arg llt second arg
#
lcmp3:  mov  eax,prc_+44    #take llt exit} exi 3
        jmp  exi__3
#
#      here if first arg lgt second arg
#
lcmp4:  mov  eax,prc_+44    #take lgt exit} exi 5
        jmp  exi__5
#
#      here if first arg is not a string
#
lcmp5:  mov  eax,prc_+44    #take bad first arg exit} exi 1
        jmp  exi__1
#
#      here for second arg not a string
#
lcmp6:  mov  eax,prc_+44    #take bad second arg error exit} exi 2
        jmp  exi__2
                            #end procedure lcomp} enp
                            #} ejc
        .eject
#
#      listr -- list source line
#
#      listr is used to list a source line during the initial
#      compilation. it is called from scane and scanl.
#
#      jsr  listr            call to list line
#      (xr,xl,wa,wb,wc)      destroyed
#
#      global locations used by listr
#
#      cnttl                 flag for -title, -stitl
#
#      erlst                 if listing on account of an error
#
#      lstid                 include depth of current image
#
#      lstlc                 count lines on current page
#
#      lstnp                 max number of lines/page
#
#      lstpf                 set non-zero if the current source
#                            line has been listed, else zero.
#
#      lstpg                 compiler listing page number
#
#      lstsn                 set if stmnt num to be listed
#
#      r$cim                 pointer to current input line.
#
#      r$ttl                 title for source listing
#
#      r$stl                 ptr to sub-title string
#
#      entry point
#
listr:                      #entry point} prc e 0
        .global listr
        cmp  dword ptr dword ptr cnttl,0 #jump if -title or -stitl} bnz cnttl list5
        jnz  list5
        cmp  dword ptr dword ptr lstpf,0 #immediate exit if already listed} bnz lstpf list4
        jnz  list4
        mov  eax,dword ptr lstlc #jump if no room} bge lstlc lstnp list6
        cmp  eax,dword ptr lstnp
        jae  list6
#
#      here after printing title (if needed)
#
list0:  mov  edi,dword ptr r_cim #load pointer to current image} mov r_cim xr
        or   edi,edi        #jump if no image to print} bze xr list4
        jz   list4
        add  edi,cfp_f      #point to characters} plc xr
        movzx ecx,byte ptr [edi] #load first character} lch wa (xr)
        mov  edi,dword ptr lstsn #load statement number} mov lstsn xr
        or   edi,edi        #jump if no statement number} bze xr list2
        jz   short list2 # (jump shortened)
        mov  edx,edi        #else get stmnt number as integer} mti xr
        cmp  dword ptr stage,stgic #skip if execute time} bne stage =stgic list1
        jne  short list1 # (jump shortened)
        cmp  ecx,ch_as      #no stmnt number list if comment} beq wa =ch_as list2
        je   short list2 # (jump shortened)
        cmp  ecx,ch_mn      #no stmnt no. if control card} beq wa =ch_mn list2
        je   short list2 # (jump shortened)
#
#      print statement number
#
list1:  call prtin          #else print statement number} jsr prtin
        xor  eax,eax        #and clear for next time in} zer lstsn
        mov  dword ptr lstsn,eax
#
#      here to test for printing include depth
#
list2:  mov  edi,dword ptr lstid #include depth of image} mov lstid xr
        or   edi,edi        #if not from an include file} bze xr list8
        jz   short list8 # (jump shortened)
        mov  ecx,stnpd      #position for start of statement} mov =stnpd wa
        sub  ecx,num03      #position to place include depth} sub =num03 wa
        mov  dword ptr profs,ecx #set as starting position} mov wa profs
        mov  edx,edi        #include depth as integer} mti xr
        call prtin          #print include depth} jsr prtin
                            #} ejc
        .eject
#
#      listr (continued)
#
#      here after printing statement number and include depth
#
list8:  mov  dword ptr profs,stnpd #point past statement number} mov =stnpd profs
        mov  edi,dword ptr r_cim #load pointer to current image} mov r_cim xr
        call prtst          #print it} jsr prtst
        inc  dword ptr lstlc #bump line counter} icv lstlc
        cmp  dword ptr dword ptr erlst,0 #jump if error copy to int.ch.} bnz erlst list3
        jnz  short list3 # (jump shortened)
        call prtnl          #terminate line} jsr prtnl
        cmp  dword ptr dword ptr cswdb,0 #jump if -single mode} bze cswdb list3
        jz   short list3 # (jump shortened)
        call prtnl          #else add a blank line} jsr prtnl
        inc  dword ptr lstlc #and bump line counter} icv lstlc
#
#      here after printing source image
#
list3:  mov  dword ptr lstpf,esp #set flag for line printed} mnz lstpf
#
#      merge here to exit
#
list4:  ret                 #return to listr caller} exi
#
#      print title after -title or -stitl card
#
list5:  xor  eax,eax        #clear flag} zer cnttl
        mov  dword ptr cnttl,eax
#
#      eject to new page and list title
#
list6:  call prtps          #eject} jsr prtps
        cmp  dword ptr dword ptr prich,0 #skip if listing to regular printer} bze prich list7
        jz   short list7 # (jump shortened)
        cmp  dword ptr r_ttl,offset nulls #terminal listing omits null title} beq r_ttl =nulls list0
        je   list0
#
#      list title
#
list7:  call listt          #list title} jsr listt
        jmp  list0          #merge} brn list0
                            #end procedure listr} enp
                            #} ejc
        .eject
#
#      listt -- list title and subtitle
#
#      used during compilation to print page heading
#
#      jsr  listt            call to list title
#      (xr,wa)               destroyed
#
listt:                      #entry point} prc e 0
        .global listt
        mov  edi,dword ptr r_ttl #point to source listing title} mov r_ttl xr
        call prtst          #print title} jsr prtst
        mov  eax,dword ptr lstpo #set offset} mov lstpo profs
        mov  dword ptr profs,eax
        mov  edi,offset lstms #set page message} mov =lstms xr
        call prtst          #print page message} jsr prtst
        inc  dword ptr lstpg #bump page number} icv lstpg
        mov  edx,dword ptr lstpg #load page number as integer} mti lstpg
        call prtin          #print page number} jsr prtin
        call prtnl          #terminate title line} jsr prtnl
        add  dword ptr lstlc,num02 #count title line and blank line} add =num02 lstlc
#
#      print sub-title (if any)
#
        mov  edi,dword ptr r_stl #load pointer to sub-title} mov r_stl xr
        or   edi,edi        #jump if no sub-title} bze xr lstt1
        jz   short lstt1 # (jump shortened)
        call prtst          #else print sub-title} jsr prtst
        call prtnl          #terminate line} jsr prtnl
        inc  dword ptr lstlc #bump line count} icv lstlc
#
#      return point
#
lstt1:  call prtnl          #print a blank line} jsr prtnl
        ret                 #return to caller} exi
                            #end procedure listt} enp
                            #} ejc
        .eject
#
#      newfn -- record new source file name
#
#      newfn is used after switching to a new include file, or
#      after a -line statement which contains a file name.
#
#      (xr)                  file name scblk
#      jsr  newfn
#      (wa,wb,wc,xl,xr,ra)   destroyed
#
#      on return, the table that maps statement numbers to file
#      names has been updated to include this new file name and
#      the current statement number.  the entry is made only if
#      the file name had changed from its previous value.
#
newfn:                      #entry point} prc e 0
        .global newfn
        push edi            #save new name} mov xr -(xs)
        mov  esi,dword ptr r_sfc #load previous name} mov r_sfc xl
        call ident          #check for equality} jsr ident
        .short nwfn1-dffnc  #jump if identical} ppm nwfn1
        pop  edi            #different, restore name} mov (xs)+ xr
        mov  dword ptr r_sfc,edi #record current file name} mov xr r_sfc
        mov  ebx,dword ptr cmpsn #get current statement} mov cmpsn wb
        mov  edx,ebx        #convert to integer} mti wb
        call icbld          #build icblk for stmt number} jsr icbld
        mov  esi,dword ptr r_sfn #file name table} mov r_sfn xl
        mov  ebx,esp        #lookup statement number by name} mnz wb
        call tfind          #allocate new teblk} jsr tfind
        .short err_-299-dffnc #always possible to allocate block} ppm
        mov  eax,dword ptr r_sfc #record file name as entry value} mov r_sfc teval(xl)
        mov  dword ptr (4*teval)[esi],eax
        ret                 #} exi
#
#     here if new name and old name identical
#
nwfn1:  add  esp,4          #pop stack} ica xs
        ret                 #} exi
                            #} ejc
        .eject
#
#      nexts -- acquire next source image
#
#      nexts is used to acquire the next source image at compile
#      time. it assumes that a prior call to readr has input
#      a line image (see procedure readr). before the current
#      image is finally lost it may be listed here.
#
#      jsr  nexts            call to acquire next input line
#      (xr,xl,wa,wb,wc)      destroyed
#
#      global values affected
#
#      lstid                 include depth of next image
#
#      r$cni                 on input, next image. on
#                            exit reset to zero
#
#      r$cim                 on exit, set to point to image
#
#      rdcln                 current ln set from next line num
#
#      scnil                 input image length on exit
#
#      scnse                 reset to zero on exit
#
#      lstpf                 set on exit if line is listed
#
nexts:                      #entry point} prc e 0
        .global nexts
        cmp  dword ptr dword ptr cswls,0 #jump if -nolist} bze cswls nxts2
        jz   short nxts2 # (jump shortened)
        mov  edi,dword ptr r_cim #point to image} mov r_cim xr
        or   edi,edi        #jump if no image} bze xr nxts2
        jz   short nxts2 # (jump shortened)
        add  edi,cfp_f      #get char ptr} plc xr
        movzx ecx,byte ptr [edi] #get first char} lch wa (xr)
        cmp  ecx,ch_mn      #jump if not ctrl card} bne wa =ch_mn nxts1
        jne  short nxts1 # (jump shortened)
        cmp  dword ptr dword ptr cswpr,0 #jump if -noprint} bze cswpr nxts2
        jz   short nxts2 # (jump shortened)
#
#      here to call lister
#
nxts1:  call listr          #list line} jsr listr
#
#      here after possible listing
#
nxts2:  mov  edi,dword ptr r_cni #point to next image} mov r_cni xr
        mov  dword ptr r_cim,edi #set as next image} mov xr r_cim
        mov  eax,dword ptr rdnln #set as current line number} mov rdnln rdcln
        mov  dword ptr rdcln,eax
        mov  eax,dword ptr cnind #set as current include depth} mov cnind lstid
        mov  dword ptr lstid,eax
        xor  eax,eax        #clear next image pointer} zer r_cni
        mov  dword ptr r_cni,eax
        mov  ecx,dword ptr (4*sclen)[edi] #get input image length} mov sclen(xr) wa
        mov  ebx,dword ptr cswin #get max allowable length} mov cswin wb
        cmp  ecx,ebx        #skip if not too long} blo wa wb nxts3
        jb   short nxts3 # (jump shortened)
        mov  ecx,ebx        #else truncate} mov wb wa
#
#      here with length in (wa)
#
nxts3:  mov  dword ptr scnil,ecx #use as record length} mov wa scnil
        xor  eax,eax        #reset scnse} zer scnse
        mov  dword ptr scnse,eax
        xor  eax,eax        #set line not listed yet} zer lstpf
        mov  dword ptr lstpf,eax
        ret                 #return to nexts caller} exi
                            #end procedure nexts} enp
                            #} ejc
        .eject
#
#      patin -- pattern construction for len,pos,rpos,tab,rtab
#
#      these pattern types all generate a similar node type. so
#      the construction code is shared. see functions section
#      for actual entry points for these five functions.
#
#      (wa)                  pcode for expression arg case
#      (wb)                  pcode for integer arg case
#      jsr  patin            call to build pattern node
#      ppm  loc              transfer loc for not integer or exp
#      ppm  loc              transfer loc for int out of range
#      (xr)                  pointer to constructed node
#      (xl,wa,wb,wc,ia)      destroyed
#
patin:                      #entry point} prc n 2
        .global patin
        pop  prc_+48
        mov  esi,ecx        #preserve expression arg pcode} mov wa xl
        call gtsmi          #try to convert arg as small integer} jsr gtsmi
        .short ptin2-dffnc  #jump if not integer} ppm ptin2
        .short ptin3-dffnc  #jump if out of range} ppm ptin3
#
#      common successful exit point
#
ptin1:  call pbild          #build pattern node} jsr pbild
        mov  eax,prc_+48    #return to caller} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      here if argument is not an integer
#
ptin2:  mov  ebx,esi        #copy expr arg case pcode} mov xl wb
        cmp  dword ptr [edi],offset b_e__ #all ok if expression arg} blo (xr) =b_e__ ptin1
        jb   ptin1
        mov  eax,prc_+48    #else take error exit for wrong type} exi 1
        jmp  exi__1
#
#      here for error of out of range integer argument
#
ptin3:  mov  eax,prc_+48    #take out-of-range error exit} exi 2
        jmp  exi__2
                            #end procedure patin} enp
                            #} ejc
        .eject
#
#      patst -- pattern construction for any,notany,
#               break,span and breakx pattern functions.
#
#      these pattern functions build similar types of nodes and
#      the construction code is shared. see functions section
#      for actual entry points for these five pattern functions.
#
#      0(xs)                 string argument
#      (wb)                  pcode for one char argument
#      (xl)                  pcode for multi-char argument
#      (wc)                  pcode for expression argument
#      jsr  patst            call to build node
#      ppm  loc              if not string or expr (or null)
#      (xs)                  popped past string argument
#      (xr)                  pointer to constructed node
#      (xl)                  destroyed
#      (wa,wb,wc,ra)         destroyed
#
#      note that there is a special call to patst in the evals
#      procedure with a slightly different form. see evals
#      for details of the form of this call.
#
patst:                      #entry point} prc n 1
        .global patst
        pop  prc_+52
        call gtstg          #convert argument as string} jsr gtstg
        .short pats7-dffnc  #jump if not string} ppm pats7
        or   ecx,ecx        #jump if null string (catspaw)} bze wa pats7
        jz   pats7
        cmp  ecx,num01      #jump if not one char string} bne wa =num01 pats2
        jne  short pats2 # (jump shortened)
#
#      here for one char string case
#
        or   ebx,ebx        #treat as multi-char if evals call} bze wb pats2
        jz   short pats2 # (jump shortened)
        add  edi,cfp_f      #point to character} plc xr
        movzx edi,byte ptr [edi] #load character} lch xr (xr)
#
#      common exit point after successful construction
#
pats1:  call pbild          #call routine to build node} jsr pbild
        mov  eax,prc_+52    #return to patst caller} exi
        lea  eax,[eax+2]
        jmp  eax
                            #} ejc
        .eject
#
#      patst (continued)
#
#      here for multi-character string case
#
pats2:  push esi            #save multi-char pcode} mov xl -(xs)
        mov  edx,dword ptr ctmsk #load current mask bit} mov ctmsk wc
        cmp  edi,dword ptr r_cts #jump if same as last string c3.738} beq xr r_cts pats6
        je   pats6
        push edi            #save string pointer} mov xr -(xs)
        shl  edx,1          #shift to next position} lsh wc 1
#        or   edx,edx        #skip if position left in this tbl} nzb wc pats4  (optimized)
        jnz  short pats4 # (jump shortened)
#
#      here we must allocate a new character table
#
        mov  ecx,4*ctsi_    #set size of ctblk} mov *ctsi_ wa
        call alloc          #allocate ctblk} jsr alloc
        mov  dword ptr r_ctp,edi #store ptr to new ctblk} mov xr r_ctp
        mov  eax,offset b_ctt #store type code, bump ptr} mov =b_ctt (xr)+
        stosd
        mov  ebx,cfp_a      #set number of words to clear} lct wb =cfp_a
        mov  edx,dword ptr bits0 #load all zero bits} mov bits0 wc
#
#      loop to clear all bits in table to zeros
#
pats3:  mov  eax,edx        #move word of zero bits} mov wc (xr)+
        stosd
        dec  ebx            #loop till all cleared} bct wb pats3
        jnz  pats3
        mov  edx,dword ptr bits1 #set initial bit position} mov bits1 wc
#
#      merge here with bit position available
#
pats4:  mov  dword ptr ctmsk,edx #save parm2 (new bit position)} mov wc ctmsk
        pop  esi            #restore pointer to argument string} mov (xs)+ xl
        mov  dword ptr r_cts,esi #save for next time   c3.738} mov xl r_cts
        mov  ebx,dword ptr (4*sclen)[esi] #load string length} mov sclen(xl) wb
        or   ebx,ebx        #jump if null string case} bze wb pats6
        jz   short pats6 # (jump shortened)
        add  esi,cfp_f      #point to characters in argument} plc xl
                            #} ejc
        .eject
#
#      patst (continued)
#
#      loop to set bits in column of table
#
pats5:  movzx ecx,byte ptr [esi] #load next character} lch wa (xl)+
        inc  esi
        sal  ecx,2          #convert to byte offset} wtb wa
        mov  edi,dword ptr r_ctp #point to ctblk} mov r_ctp xr
        add  edi,ecx        #point to ctblk entry} add wa xr
        mov  ecx,edx        #copy bit mask} mov wc wa
        or   ecx,dword ptr (4*ctchs)[edi] #or in bits already set} orb ctchs(xr) wa
        mov  dword ptr (4*ctchs)[edi],ecx #store resulting bit string} mov wa ctchs(xr)
        dec  ebx            #loop till all bits set} bct wb pats5
        jnz  pats5
#
#      complete processing for multi-char string case
#
pats6:  mov  edi,dword ptr r_ctp #load ctblk ptr as parm1 for pbild} mov r_ctp xr
        xor  esi,esi        #clear garbage ptr in esi} zer xl
        pop  ebx            #load pcode for multi-char str case} mov (xs)+ wb
        jmp  pats1          #back to exit (edx=bitstring=parm2)} brn pats1
#
#      here if argument is not a string
#
#      note that the call from evals cannot pass an expression
#      since evalp always reevaluates expressions.
#
pats7:  mov  ebx,edx        #set pcode for expression argument} mov wc wb
        cmp  dword ptr [edi],offset b_e__ #jump to exit if expression arg} blo (xr) =b_e__ pats1
        jb   pats1
        mov  eax,prc_+52    #else take wrong type error exit} exi 1
        jmp  exi__1
                            #end procedure patst} enp
                            #} ejc
        .eject
#
#      pbild -- build pattern node
#
#      (xr)                  parm1 (only if required)
#      (wb)                  pcode for node
#      (wc)                  parm2 (only if required)
#      jsr  pbild            call to build node
#      (xr)                  pointer to constructed node
#      (wa)                  destroyed
#
pbild:                      #entry point} prc e 0
        .global pbild
        push edi            #stack possible parm1} mov xr -(xs)
        mov  edi,ebx        #copy pcode} mov wb xr
        movzx edi,byte ptr [edi-1] #load entry point id (bl_px)} lei xr
        cmp  edi,bl_p1      #jump if one parameter} beq xr =bl_p1 pbld1
        je   short pbld1 # (jump shortened)
        cmp  edi,bl_p0      #jump if no parameters} beq xr =bl_p0 pbld3
        je   short pbld3 # (jump shortened)
#
#      here for two parameter case
#
        mov  ecx,4*pcsi_    #set size of p2blk} mov *pcsi_ wa
        call alloc          #allocate block} jsr alloc
        mov  dword ptr (4*parm2)[edi],edx #store second parameter} mov wc parm2(xr)
        jmp  short pbld2          #merge with one parm case} brn pbld2 # (jump shortened)
#
#      here for one parameter case
#
pbld1:  mov  ecx,4*pbsi_    #set size of p1blk} mov *pbsi_ wa
        call alloc          #allocate node} jsr alloc
#
#      merge here from two parm case
#
pbld2:  mov  eax,dword ptr [esp] #store first parameter} mov (xs) parm1(xr)
        mov  dword ptr (4*parm1)[edi],eax
        jmp  short pbld4          #merge with no parameter case} brn pbld4 # (jump shortened)
#
#      here for case of no parameters
#
pbld3:  mov  ecx,4*pasi_    #set size of p0blk} mov *pasi_ wa
        call alloc          #allocate node} jsr alloc
#
#      merge here from other cases
#
pbld4:  mov  dword ptr [edi],ebx #store pcode} mov wb (xr)
        add  esp,4          #pop first parameter} ica xs
        mov  dword ptr (4*pthen)[edi],offset ndnth #set nothen successor pointer} mov =ndnth pthen(xr)
        ret                 #return to pbild caller} exi
                            #end procedure pbild} enp
                            #} ejc
        .eject
#
#      pconc -- concatenate two patterns
#
#      (xl)                  ptr to right pattern
#      (xr)                  ptr to left pattern
#      jsr  pconc            call to concatenate patterns
#      (xr)                  ptr to concatenated pattern
#      (xl,wa,wb,wc)         destroyed
#
#
#      to concatenate two patterns, all successors in the left
#      pattern which point to the nothen node must be changed to
#      point to the right pattern. however, this modification
#      must be performed on a copy of the left argument rather
#      than the left argument itself, since the left argument
#      may be pointed to by some other variable value.
#
#      accordingly, it is necessary to copy the left argument.
#      this is not a trivial process since we must avoid copying
#      nodes more than once and the pattern is a graph structure
#      the following algorithm is employed.
#
#      the stack is used to store a list of nodes which
#      have already been copied. the format of the entries on
#      this list consists of a two word block. the first word
#      is the old address and the second word is the address
#      of the copy. this list is searched by the pcopy
#      routine to avoid making duplicate copies. a trick is
#      used to accomplish the concatenation at the same time.
#      a special entry is made to start with on the stack. this
#      entry records that the nothen node has been copied
#      already and the address of its copy is the right pattern.
#      this automatically performs the correct replacements.
#
pconc:                      #entry point} prc e 0
        .global pconc
        push 0              #make room for one entry at bottom} zer -(xs)
        mov  edx,esp        #store pointer to start of list} mov xs wc
        push offset ndnth   #stack nothen node as old node} mov =ndnth -(xs)
        push esi            #store right arg as copy of nothen} mov xl -(xs)
        mov  esi,esp        #initialize pointer to stack entries} mov xs xt
        call pcopy          #copy first node of left arg} jsr pcopy
        mov  dword ptr (4*num02)[esi],ecx #store as result under list} mov wa num02(xt)
                            #} ejc
        .eject
#
#      pconc (continued)
#
#      the following loop scans entries in the list and makes
#      sure that their successors have been copied.
#
pcnc1:  cmp  esi,esp        #jump if all entries processed} beq xt xs pcnc2
        je   short pcnc2 # (jump shortened)
        lea  esi,[esi-4]    #else load next old address} mov -(xt) xr
        mov  edi,dword ptr [esi]
        mov  edi,dword ptr (4*pthen)[edi] #load pointer to successor} mov pthen(xr) xr
        call pcopy          #copy successor node} jsr pcopy
        lea  esi,[esi-4]    #load pointer to new node (copy)} mov -(xt) xr
        mov  edi,dword ptr [esi]
        mov  dword ptr (4*pthen)[edi],ecx #store ptr to new successor} mov wa pthen(xr)
#
#      now check for special case of alternation node where
#      parm1 points to a node and must be copied like pthen.
#
        cmp  dword ptr [edi],offset p_alt #loop back if not} bne (xr) =p_alt pcnc1
        jne  pcnc1
        mov  edi,dword ptr (4*parm1)[edi] #else load pointer to alternative} mov parm1(xr) xr
        call pcopy          #copy it} jsr pcopy
        mov  edi,dword ptr [esi] #restore ptr to new node} mov (xt) xr
        mov  dword ptr (4*parm1)[edi],ecx #store ptr to copied alternative} mov wa parm1(xr)
        jmp  pcnc1          #loop back for next entry} brn pcnc1
#
#      here at end of copy process
#
pcnc2:  mov  esp,edx        #restore stack pointer} mov wc xs
        pop  edi            #load pointer to copy} mov (xs)+ xr
        ret                 #return to pconc caller} exi
                            #end procedure pconc} enp
                            #} ejc
        .eject
#
#      pcopy -- copy a pattern node
#
#      pcopy is called from the pconc procedure to copy a single
#      pattern node. the copy is only carried out if the node
#      has not been copied already.
#
#      (xr)                  pointer to node to be copied
#      (xt)                  ptr to current loc in copy list
#      (wc)                  pointer to list of copied nodes
#      jsr  pcopy            call to copy a node
#      (wa)                  pointer to copy
#      (wb,xr)               destroyed
#
pcopy:                      #entry point} prc n 0
        .global pcopy
        pop  prc_+56
        mov  ebx,esi        #save esi} mov xt wb
        mov  esi,edx        #point to start of list} mov wc xt
#
#      loop to search list of nodes copied already
#
pcop1:  sub  esi,4          #point to next entry on list} dca xt
        cmp  edi,dword ptr [esi] #jump if match} beq xr (xt) pcop2
        je   short pcop2 # (jump shortened)
        sub  esi,4          #else skip over copied address} dca xt
        cmp  esi,esp        #loop back if more to test} bne xt xs pcop1
        jne  pcop1
#
#      here if not in list, perform copy
#
        mov  ecx,dword ptr [edi] #load first word of block} mov (xr) wa
        call blkln          #get length of block} jsr blkln
        mov  esi,edi        #save pointer to old node} mov xr xl
        call alloc          #allocate space for copy} jsr alloc
        push esi            #store old address on list} mov xl -(xs)
        push edi            #store new address on list} mov xr -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
        shr  ecx,2          #move words from old block to copy} mvw
        rep  movsd
        mov  ecx,dword ptr [esp] #load pointer to copy} mov (xs) wa
        jmp  short pcop3          #jump to exit} brn pcop3 # (jump shortened)
#
#      here if we find entry in list
#
pcop2:  lea  esi,[esi-4]    #load address of copy from list} mov -(xt) wa
        mov  ecx,dword ptr [esi]
#
#      common exit point
#
pcop3:  mov  esi,ebx        #restore esi} mov wb xt
        jmp  [prc_+56]      #return to pcopy caller} exi
                            #end procedure pcopy} enp
                            #} ejc
        .eject
#
#      prflr -- print profile
#      prflr is called to print the contents of the profile
#      table in a fairly readable tabular format.
#
#      jsr  prflr            call to print profile
#      (wa,ia)               destroyed
#
prflr:                      #} prc e 0
        .global prflr
        cmp  dword ptr dword ptr pfdmp,0 #no printing if no profiling done} bze pfdmp prfl4
        jz   prfl4
        push edi            #preserve entry edi} mov xr -(xs)
        mov  dword ptr pfsvw,ebx #and also ebx} mov wb pfsvw
        call prtpg          #eject} jsr prtpg
        mov  edi,offset pfms1 #load msg /program profile/} mov =pfms1 xr
        call prtst          #and print it} jsr prtst
        call prtnl          #followed by newline} jsr prtnl
        call prtnl          #and another} jsr prtnl
        mov  edi,offset pfms2 #point to first hdr} mov =pfms2 xr
        call prtst          #print it} jsr prtst
        call prtnl          #new line} jsr prtnl
        mov  edi,offset pfms3 #second hdr} mov =pfms3 xr
        call prtst          #print it} jsr prtst
        call prtnl          #new line} jsr prtnl
        call prtnl          #and another blank line} jsr prtnl
        xor  ebx,ebx        #initial stmt count} zer wb
        mov  edi,dword ptr pftbl #point to table origin} mov pftbl xr
        add  edi,4*xndta    #bias past xnblk header (sgd07)} add *xndta xr
#
#      loop here to print successive entries
#
prfl1:  inc  ebx            #bump stmt nr} icv wb
        mov  edx,dword ptr [edi] #load nr of executions} ldi (xr)
        or   edx,edx        #no printing if zero} ieq prfl3
        je   short prfl3 # (jump shortened)
        mov  dword ptr profs,pfpd1 #point where to print} mov =pfpd1 profs
        call prtin          #and print it} jsr prtin
        xor  eax,eax        #back to start of line} zer profs
        mov  dword ptr profs,eax
        mov  edx,ebx        #load stmt nr} mti wb
        call prtin          #print it there} jsr prtin
        mov  dword ptr profs,pfpd2 #and pad past count} mov =pfpd2 profs
        mov  edx,dword ptr (4*cfp_i)[edi] #load total exec time} ldi cfp_i(xr)
        call prtin          #print that too} jsr prtin
        mov  edx,dword ptr (4*cfp_i)[edi] #reload time} ldi cfp_i(xr)
        imul edx,dword ptr intth #convert to microsec} mli intth
        jo   short prfl2          #omit next bit if overflow} iov prfl2 # (jump shortened)
        mov  eax,dword ptr [edi] #divide by executions} dvi (xr)
        call dvi_
        mov  dword ptr profs,pfpd3 #pad last print} mov =pfpd3 profs
        call prtin          #and print mcsec/execn} jsr prtin
#
#      merge after printing time
#
prfl2:  call prtnl          #thats another line} jsr prtnl
#
#      here to go to next entry
#
prfl3:  add  edi,4*pf_i2    #bump index ptr (sgd07)} add *pf_i2 xr
        cmp  ebx,dword ptr pfnte #loop if more stmts} blt wb pfnte prfl1
        jb   prfl1
        pop  edi            #restore callers edi} mov (xs)+ xr
        mov  ebx,dword ptr pfsvw #and ebx too} mov pfsvw wb
#
#      here to exit
#
prfl4:  ret                 #return} exi
                            #end of prflr} enp
                            #} ejc
        .eject
#
#      prflu -- update an entry in the profile table
#
#      on entry, kvstn contains nr of stmt to profile
#
#      jsr  prflu            call to update entry
#      (ia)                  destroyed
#
prflu:                      #} prc e 0
        .global prflu
        cmp  dword ptr dword ptr pffnc,0 #skip if just entered function} bnz pffnc pflu4
        jnz  pflu4
        push edi            #preserve entry edi} mov xr -(xs)
        mov  dword ptr pfsvw,ecx #save ecx (sgd07)} mov wa pfsvw
        cmp  dword ptr dword ptr pftbl,0 #branch if table allocated} bnz pftbl pflu2
        jnz  pflu2
#
#      here if space for profile table not yet allocated.
#      calculate size needed, allocate a static xnblk, and
#      initialize it all to zero.
#      the time taken for this will be attributed to the current
#      statement (assignment to keywd profile), but since the
#      timing for this statement is up the pole anyway, this
#      doesnt really matter...
#
        sub  dword ptr pfnte,num01 #adjust for extra count (sgd07)} sub =num01 pfnte
        mov  edx,dword ptr pfi2a #convrt entry size to int} mti pfi2a
        mov  dword ptr pfste,edx #and store safely for later} sti pfste
        mov  edx,dword ptr pfnte #load table length as integer} mti pfnte
        imul edx,dword ptr pfste #multiply by entry size} mli pfste
        mov  ecx,edx        #get back address-style} mfi wa
        add  ecx,num02      #add on 2 word overhead} add =num02 wa
        sal  ecx,2          #convert the whole lot to bytes} wtb wa
        call alost          #gimme the space} jsr alost
        mov  dword ptr pftbl,edi #save block pointer} mov xr pftbl
        mov  eax,offset b_xnt #put block type and ...} mov =b_xnt (xr)+
        stosd
        mov  eax,ecx        #... length into header} mov wa (xr)+
        stosd
        mov  ecx,edx        #get back nr of wds in data area} mfi wa
#
#      loop here to zero the block data
#
pflu1:  xor  eax,eax        #blank a word} zer (xr)+
        stosd
        loop pflu1          #and alllllll the rest} bct wa pflu1
#
#      end of allocation. merge back into routine
#
pflu2:  mov  edx,dword ptr kvstn #load nr of stmt just ended} mti kvstn
        sub  edx,dword ptr intv1 #make into index offset} sbi intv1
        imul edx,dword ptr pfste #make offset of table entry} mli pfste
        mov  ecx,edx        #convert to address} mfi wa
        sal  ecx,2          #get as baus} wtb wa
        add  ecx,4*num02    #offset includes table header} add *num02 wa
        mov  edi,dword ptr pftbl #get table start} mov pftbl xr
        cmp  ecx,dword ptr (4*num01)[edi] #if out of table, skip it} bge wa num01(xr) pflu3
        jae  short pflu3 # (jump shortened)
        add  edi,ecx        #else point to entry} add wa xr
        mov  edx,dword ptr [edi] #get nr of executions so far} ldi (xr)
        add  edx,dword ptr intv1 #nudge up one} adi intv1
        mov  dword ptr [edi],edx #and put back} sti (xr)
        call systm          #get time now} jsr systm
        mov  dword ptr pfetm,edx #stash ending time} sti pfetm
        sub  edx,dword ptr pfstm #subtract start time} sbi pfstm
        add  edx,dword ptr (4*cfp_i)[edi] #add cumulative time so far} adi cfp_i(xr)
        mov  dword ptr (4*cfp_i)[edi],edx #and put back new total} sti cfp_i(xr)
        mov  edx,dword ptr pfetm #load end time of this stmt ...} ldi pfetm
        mov  dword ptr pfstm,edx #... which is start time of next} sti pfstm
#
#      merge here to exit
#
pflu3:  pop  edi            #restore callers edi} mov (xs)+ xr
        mov  ecx,dword ptr pfsvw #restore saved reg} mov pfsvw wa
        ret                 #and return} exi
#
#      here if profile is suppressed because a program defined
#      function is about to be entered, and so the current stmt
#      has not yet finished
#
pflu4:  xor  eax,eax        #reset the condition flag} zer pffnc
        mov  dword ptr pffnc,eax
        ret                 #and immediate return} exi
                            #end of procedure prflu} enp
                            #} ejc
        .eject
#
#      prpar - process print parameters
#
#      (wc)                  if nonzero associate terminal only
#      jsr  prpar            call to process print parameters
#      (xl,xr,wa,wb,wc)      destroyed
#
#      since memory allocation is undecided on initial call,
#      terminal cannot be associated. the entry with wc non-zero
#      is provided so a later call can be made to complete this.
#
prpar:                      #entry point} prc e 0
        .global prpar
        or   edx,edx        #jump to associate terminal} bnz wc prpa8
        jnz  prpa8
        call syspp          #get print parameters} jsr syspp
        or   ebx,ebx        #jump if lines/page specified} bnz wb prpa1
        jnz  short prpa1 # (jump shortened)
        mov  ebx,cfp_m      #else use a large value} mov =cfp_m wb
        shr  ebx,1          #but not too large} rsh wb 1
#
#      store line count/page
#
prpa1:  mov  dword ptr lstnp,ebx #store number of lines/page} mov wb lstnp
        mov  dword ptr lstlc,ebx #pretend page is full initially} mov wb lstlc
        xor  eax,eax        #clear page number} zer lstpg
        mov  dword ptr lstpg,eax
        mov  ebx,dword ptr prlen #get prior length if any} mov prlen wb
        or   ebx,ebx        #skip if no length} bze wb prpa2
        jz   short prpa2 # (jump shortened)
        cmp  ecx,ebx        #skip storing if too big} bgt wa wb prpa3
        ja   short prpa3 # (jump shortened)
#
#      store print buffer length
#
prpa2:  mov  dword ptr prlen,ecx #store value} mov wa prlen
#
#      process bits options
#
prpa3:  mov  ebx,dword ptr bits3 #bit 3 mask} mov bits3 wb
        and  ebx,edx        #get -nolist bit} anb wc wb
#        or   ebx,ebx        #skip if clear} zrb wb prpa4  (optimized)
        jz   short prpa4 # (jump shortened)
        xor  eax,eax        #set -nolist} zer cswls
        mov  dword ptr cswls,eax
#
#      check if fail reports goto interactive channel
#
prpa4:  mov  ebx,dword ptr bits1 #bit 1 mask} mov bits1 wb
        and  ebx,edx        #get bit} anb wc wb
        mov  dword ptr erich,ebx #store int. chan. error flag} mov wb erich
        mov  ebx,dword ptr bits2 #bit 2 mask} mov bits2 wb
        and  ebx,edx        #get bit} anb wc wb
        mov  dword ptr prich,ebx #flag for std printer on int. chan.} mov wb prich
        mov  ebx,dword ptr bits4 #bit 4 mask} mov bits4 wb
        and  ebx,edx        #get bit} anb wc wb
        mov  dword ptr cpsts,ebx #flag for compile stats suppressn.} mov wb cpsts
        mov  ebx,dword ptr bits5 #bit 5 mask} mov bits5 wb
        and  ebx,edx        #get bit} anb wc wb
        mov  dword ptr exsts,ebx #flag for exec stats suppression} mov wb exsts
                            #} ejc
        .eject
#
#      prpar (continued)
#
        mov  ebx,dword ptr bits6 #bit 6 mask} mov bits6 wb
        and  ebx,edx        #get bit} anb wc wb
        mov  dword ptr precl,ebx #extended/compact listing flag} mov wb precl
        sub  ecx,num08      #point 8 chars from line end} sub =num08 wa
        or   ebx,ebx        #jump if not extended} zrb wb prpa5
        jz   short prpa5 # (jump shortened)
        mov  dword ptr lstpo,ecx #store for listing page headings} mov wa lstpo
#
#       continue option processing
#
prpa5:  mov  ebx,dword ptr bits7 #bit 7 mask} mov bits7 wb
        and  ebx,edx        #get bit 7} anb wc wb
        mov  dword ptr cswex,ebx #set -noexecute if non-zero} mov wb cswex
        mov  ebx,dword ptr bit10 #bit 10 mask} mov bit10 wb
        and  ebx,edx        #get bit 10} anb wc wb
        mov  dword ptr headp,ebx #pretend printed to omit headers} mov wb headp
        mov  ebx,dword ptr bits9 #bit 9 mask} mov bits9 wb
        and  ebx,edx        #get bit 9} anb wc wb
        mov  dword ptr prsto,ebx #keep it as std listing option} mov wb prsto
        mov  ebx,edx        #copy flags} mov wc wb
        shr  ebx,12         #right justify bit 13} rsh wb 12
        and  ebx,dword ptr bits1 #get bit} anb bits1 wb
        mov  dword ptr kvcas,ebx #set -case} mov wb kvcas
        mov  ebx,dword ptr bit12 #bit 12 mask} mov bit12 wb
        and  ebx,edx        #get bit 12} anb wc wb
        mov  dword ptr cswer,ebx #keep it as errors/noerrors option} mov wb cswer
        or   ebx,ebx        #skip if clear} zrb wb prpa6
        jz   short prpa6 # (jump shortened)
        mov  ecx,dword ptr prlen #get print buffer length} mov prlen wa
        sub  ecx,num08      #point 8 chars from line end} sub =num08 wa
        mov  dword ptr lstpo,ecx #store page offset} mov wa lstpo
#
#      check for -print/-noprint
#
prpa6:  mov  ebx,dword ptr bit11 #bit 11 mask} mov bit11 wb
        and  ebx,edx        #get bit 11} anb wc wb
        mov  dword ptr cswpr,ebx #set -print if non-zero} mov wb cswpr
#
#      check for terminal
#
        and  edx,dword ptr bits8 #see if terminal to be activated} anb bits8 wc
#        or   edx,edx        #jump if terminal required} bnz wc prpa8  (optimized)
        jnz  short prpa8 # (jump shortened)
        cmp  dword ptr dword ptr initr,0 #jump if no terminal to detach} bze initr prpa9
        jz   short prpa9 # (jump shortened)
        mov  esi,offset v_ter #ptr to /terminal/} mov =v_ter xl
        call gtnvr          #get vrblk pointer} jsr gtnvr
        .short err_-299-dffnc #cant fail} ppm
        mov  dword ptr (4*vrval)[edi],offset nulls #clear value of terminal} mov =nulls vrval(xr)
        call setvr          #remove association} jsr setvr
        jmp  short prpa9          #return} brn prpa9 # (jump shortened)
#
#      associate terminal
#
prpa8:  mov  dword ptr initr,esp #note terminal associated} mnz initr
        cmp  dword ptr dword ptr dnamb,0 #cant if memory not organised} bze dnamb prpa9
        jz   short prpa9 # (jump shortened)
        mov  esi,offset v_ter #point to terminal string} mov =v_ter xl
        mov  ebx,trtou      #output trace type} mov =trtou wb
        call inout          #attach output trblk to vrblk} jsr inout
        push edi            #stack trblk ptr} mov xr -(xs)
        mov  esi,offset v_ter #point to terminal string} mov =v_ter xl
        mov  ebx,trtin      #input trace type} mov =trtin wb
        call inout          #attach input trace blk} jsr inout
        pop  dword ptr (4*vrval)[edi] #add output trblk to chain} mov (xs)+ vrval(xr)
#
#      return point
#
prpa9:  ret                 #return} exi
                            #end procedure prpar} enp
                            #} ejc
        .eject
#
#      prtch -- print a character
#
#      prtch is used to print a single character
#
#      (wa)                  character to be printed
#      jsr  prtch            call to print character
#
prtch:                      #entry point} prc e 0
        .global prtch
        push edi            #save edi} mov xr -(xs)
        mov  eax,dword ptr profs #jump if room in buffer} bne profs prlen prch1
        cmp  eax,dword ptr prlen
        jne  short prch1 # (jump shortened)
        call prtnl          #else print this line} jsr prtnl
#
#      here after making sure we have room
#
prch1:  mov  edi,dword ptr prbuf #point to print buffer} mov prbuf xr
        add  edi,cfp_f      #point to next character location} psc xr profs
        add  edi,dword ptr profs
        mov  [edi],cl       #store new character} sch wa (xr)
        inc  dword ptr profs #bump pointer} icv profs
        pop  edi            #restore entry edi} mov (xs)+ xr
        ret                 #return to prtch caller} exi
                            #end procedure prtch} enp
                            #} ejc
        .eject
#
#      prtic -- print to interactive channel
#
#      prtic is called to print the contents of the standard
#      print buffer to the interactive channel. it is only
#      called after prtst has set up the string for printing.
#      it does not clear the buffer.
#
#      jsr  prtic            call for print
#      (wa,wb)               destroyed
#
prtic:                      #entry point} prc e 0
        .global prtic
        push edi            #save edi} mov xr -(xs)
        mov  edi,dword ptr prbuf #point to buffer} mov prbuf xr
        mov  ecx,dword ptr profs #no of chars} mov profs wa
        call syspi          #print} jsr syspi
        .short prtc2-dffnc  #fail return} ppm prtc2
#
#      return
#
prtc1:  pop  edi            #restore edi} mov (xs)+ xr
        ret                 #return} exi
#
#      error occured
#
prtc2:  xor  eax,eax        #prevent looping} zer erich
        mov  dword ptr erich,eax
        call err_0          #} erb 252 error on printing to interactive channel
        .byte 252
        jmp  prtc1          #return} brn prtc1
                            #procedure prtic} enp
                            #} ejc
        .eject
#
#      prtis -- print to interactive and standard printer
#
#      prtis puts a line from the print buffer onto the
#      interactive channel (if any) and the standard printer.
#      it always prints to the standard printer but does
#      not duplicate lines if the standard printer is
#      interactive.  it clears down the print buffer.
#
#      jsr  prtis            call for printing
#      (wa,wb)               destroyed
#
prtis:                      #entry point} prc e 0
        .global prtis
        cmp  dword ptr dword ptr prich,0 #jump if standard printer is int.ch.} bnz prich prts1
        jnz  short prts1 # (jump shortened)
        cmp  dword ptr dword ptr erich,0 #skip if not doing int. error reps.} bze erich prts1
        jz   short prts1 # (jump shortened)
        call prtic          #print to interactive channel} jsr prtic
#
#      merge and exit
#
prts1:  call prtnl          #print to standard printer} jsr prtnl
        ret                 #return} exi
                            #end procedure prtis} enp
                            #} ejc
        .eject
#
#      prtin -- print an integer
#
#      prtin prints the integer value which is in the integer
#      accumulator. blocks built in dynamic storage
#      during this process are immediately deleted.
#
#      (ia)                  integer value to be printed
#      jsr  prtin            call to print integer
#      (ia,ra)               destroyed
#
prtin:                      #entry point} prc e 0
        .global prtin
        push edi            #save edi} mov xr -(xs)
        call icbld          #build integer block} jsr icbld
        cmp  edi,dword ptr dnamb #jump if icblk below dynamic} blo xr dnamb prti1
        jb   short prti1 # (jump shortened)
        cmp  edi,dword ptr dnamp #jump if above dynamic} bhi xr dnamp prti1
        ja   short prti1 # (jump shortened)
        mov  dword ptr dnamp,edi #immediately delete it} mov xr dnamp
#
#      delete icblk from dynamic store
#
prti1:  push edi            #stack ptr for gtstg} mov xr -(xs)
        call gtstg          #convert to string} jsr gtstg
        .short err_-299-dffnc #convert error is impossible} ppm
        mov  dword ptr dnamp,edi #reset pointer to delete scblk} mov xr dnamp
        call prtst          #print integer string} jsr prtst
        pop  edi            #restore entry edi} mov (xs)+ xr
        ret                 #return to prtin caller} exi
                            #end procedure prtin} enp
                            #} ejc
        .eject
#
#      prtmi -- print message and integer
#
#      prtmi is used to print messages together with an integer
#      value starting in column 15 (used by the routines at
#      the end of compilation).
#
#      jsr  prtmi            call to print message and integer
#
prtmi:                      #entry point} prc e 0
        .global prtmi
        call prtst          #print string message} jsr prtst
        mov  dword ptr profs,prtmf #set column offset} mov =prtmf profs
        call prtin          #print integer} jsr prtin
        call prtnl          #print line} jsr prtnl
        ret                 #return to prtmi caller} exi
                            #end procedure prtmi} enp
                            #} ejc
        .eject
#
#      prtmm -- print memory used and available
#
#      prtmm is used to provide memory usage information in
#      both the end-of-compile and end-of-run statistics.
#
#      jsr  prtmm            call to print memory stats
#
prtmm:                      #} prc e 0
        .global prtmm
        mov  ecx,dword ptr dnamp #next available loc} mov dnamp wa
        sub  ecx,dword ptr statb #minus start} sub statb wa
        mov  edx,ecx        #convert to integer} mti wa
        mov  edi,offset encm1 #point to /memory used (words)/} mov =encm1 xr
        call prtmi          #print message} jsr prtmi
        mov  ecx,dword ptr dname #end of memory} mov dname wa
        sub  ecx,dword ptr dnamp #minus next available loc} sub dnamp wa
        mov  edx,ecx        #convert to integer} mti wa
        mov  edi,offset encm2 #point to /memory available (words)/} mov =encm2 xr
        call prtmi          #print line} jsr prtmi
        ret                 #return to prtmm caller} exi
                            #end of procedure prtmm} enp
                            #} ejc
        .eject
#
#      prtmx  -- as prtmi with extra copy to interactive chan.
#
#      jsr  prtmx            call for printing
#      (wa,wb)               destroyed
#
prtmx:                      #entry point} prc e 0
        .global prtmx
        call prtst          #print string message} jsr prtst
        mov  dword ptr profs,prtmf #set column offset} mov =prtmf profs
        call prtin          #print integer} jsr prtin
        call prtis          #print line} jsr prtis
        ret                 #return} exi
                            #end procedure prtmx} enp
                            #} ejc
        .eject
#
#      prtnl -- print new line (end print line)
#
#      prtnl prints the contents of the print buffer, resets
#      the buffer to all blanks and resets the print pointer.
#
#      jsr  prtnl            call to print line
#
prtnl:                      #entry point} prc r 0
        .global prtnl
        cmp  dword ptr dword ptr headp,0 #were headers printed} bnz headp prnl0
        jnz  short prnl0 # (jump shortened)
        call prtps          #no - print them} jsr prtps
#
#      call syspr
#
prnl0:  push edi            #save entry edi} mov xr -(xs)
        mov  dword ptr prtsa,ecx #save ecx} mov wa prtsa
        mov  dword ptr prtsb,ebx #save ebx} mov wb prtsb
        mov  edi,dword ptr prbuf #load pointer to buffer} mov prbuf xr
        mov  ecx,dword ptr profs #load number of chars in buffer} mov profs wa
        call syspr          #call system print routine} jsr syspr
        .short prnl2-dffnc  #jump if failed} ppm prnl2
        mov  ecx,dword ptr prlnw #load length of buffer in words} lct wa prlnw
        add  edi,4*schar    #point to chars of buffer} add *schar xr
        mov  ebx,dword ptr nullw #get word of blanks} mov nullw wb
#
#      loop to blank buffer
#
prnl1:  mov  eax,ebx        #store word of blanks, bump ptr} mov wb (xr)+
        stosd
        loop prnl1          #loop till all blanked} bct wa prnl1
#
#      exit point
#
        mov  ebx,dword ptr prtsb #restore ebx} mov prtsb wb
        mov  ecx,dword ptr prtsa #restore ecx} mov prtsa wa
        pop  edi            #restore entry edi} mov (xs)+ xr
        xor  eax,eax        #reset print buffer pointer} zer profs
        mov  dword ptr profs,eax
        ret                 #return to prtnl caller} exi
#
#      file full or no output file for load module
#
prnl2:  cmp  dword ptr dword ptr prtef,0 #jump if not first time} bnz prtef prnl3
        jnz  short prnl3 # (jump shortened)
        mov  dword ptr prtef,esp #mark first occurrence} mnz prtef
        call err_0          #} erb 253 print limit exceeded on standard output channel
        .byte 253
#
#      stop at once
#
prnl3:  mov  ebx,nini8      #ending code} mov =nini8 wb
        mov  ecx,dword ptr kvstn #statement number} mov kvstn wa
        mov  esi,dword ptr r_fcb #get fcblk chain head} mov r_fcb xl
        call sysej          #stop} jsr sysej
                            #end procedure prtnl} enp
                            #} ejc
        .eject
#
#      prtnm -- print variable name
#
#      prtnm is used to print a character representation of the
#      name of a variable (not a value of datatype name)
#      names of pseudo-variables may not be passed to prtnm.
#
#      (xl)                  name base
#      (wa)                  name offset
#      jsr  prtnm            call to print name
#      (wb,wc,ra)            destroyed
#
prtnm:                      #entry point (recursive, see prtvl)} prc r 0
        .global prtnm
        push ecx            #save ecx (offset is collectable)} mov wa -(xs)
        push edi            #save entry edi} mov xr -(xs)
        push esi            #save name base} mov xl -(xs)
        cmp  esi,dword ptr state #jump if not natural variable} bhi xl state prn02
        ja   short prn02 # (jump shortened)
#
#      here for natural variable name, recognized by the fact
#      that the name base points into the static area.
#
        mov  edi,esi        #point to vrblk} mov xl xr
        call prtvn          #print name of variable} jsr prtvn
#
#      common exit point
#
prn01:  pop  esi            #restore name base} mov (xs)+ xl
        pop  edi            #restore entry value of edi} mov (xs)+ xr
        pop  ecx            #restore ecx} mov (xs)+ wa
        ret                 #return to prtnm caller} exi
#
#      here for case of non-natural variable
#
prn02:  mov  ebx,ecx        #copy name offset} mov wa wb
        cmp  dword ptr [esi],offset b_pdt #jump if array or table} bne (xl) =b_pdt prn03
        jne  short prn03 # (jump shortened)
#
#      for program defined datatype, prt fld name, left paren
#
        mov  edi,dword ptr (4*pddfp)[esi] #load pointer to dfblk} mov pddfp(xl) xr
        add  edi,ecx        #add name offset} add wa xr
        mov  edi,dword ptr (4*pdfof)[edi] #load vrblk pointer for field} mov pdfof(xr) xr
        call prtvn          #print field name} jsr prtvn
        mov  ecx,ch_pp      #load left paren} mov =ch_pp wa
        call prtch          #print character} jsr prtch
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      now we print an identifying name for the object if one
#      can be found. the following code searches for a natural
#      variable which contains this object as value. if such a
#      variable is found, its name is printed, else the value
#      of the object (as printed by prtvl) is used instead.
#
#      first we point to the parent tbblk if this is the case of
#      a table element. to do this, chase down the trnxt chain.
#
prn03:  cmp  dword ptr [esi],offset b_tet #jump if we got there (or not te)} bne (xl) =b_tet prn04
        jne  short prn04 # (jump shortened)
        mov  esi,dword ptr (4*tenxt)[esi] #else move out on chain} mov tenxt(xl) xl
        jmp  prn03          #and loop back} brn prn03
#
#      now we are ready for the search. to speed things up in
#      the case of calls from dump where the same name base
#      will occur repeatedly while dumping an array or table,
#      we remember the last vrblk pointer found in prnmv. so
#      first check to see if we have this one again.
#
prn04:  mov  edi,dword ptr prnmv #point to vrblk we found last time} mov prnmv xr
        mov  ecx,dword ptr hshtb #point to hash table in case not} mov hshtb wa
        jmp  short prn07          #jump into search for special check} brn prn07 # (jump shortened)
#
#      loop through hash slots
#
prn05:  mov  edi,ecx        #copy slot pointer} mov wa xr
        add  ecx,4          #bump slot pointer} ica wa
        sub  edi,4*vrnxt    #introduce standard vrblk offset} sub *vrnxt xr
#
#      loop through vrblks on one hash chain
#
prn06:  mov  edi,dword ptr (4*vrnxt)[edi] #point to next vrblk on hash chain} mov vrnxt(xr) xr
#
#      merge here first time to check block we found last time
#
prn07:  mov  edx,edi        #copy vrblk pointer} mov xr wc
        or   edx,edx        #jump if chain end (or prnmv zero)} bze wc prn09
        jz   short prn09 # (jump shortened)
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      loop to find value (chase down possible trblk chain)
#
prn08:  mov  edi,dword ptr (4*vrval)[edi] #load value} mov vrval(xr) xr
        cmp  dword ptr [edi],offset b_trt #loop if that was a trblk} beq (xr) =b_trt prn08
        je   prn08
#
#      now we have the value, is this the block we want
#
        cmp  edi,esi        #jump if this matches the name base} beq xr xl prn10
        je   short prn10 # (jump shortened)
        mov  edi,edx        #else point back to that vrblk} mov wc xr
        jmp  prn06          #and loop back} brn prn06
#
#      here to move to next hash slot
#
prn09:  cmp  ecx,dword ptr hshte #loop back if more to go} blt wa hshte prn05
        jb   prn05
        mov  edi,esi        #else not found, copy value pointer} mov xl xr
        call prtvl          #print value} jsr prtvl
        jmp  short prn11          #and merge ahead} brn prn11 # (jump shortened)
#
#      here when we find a matching entry
#
prn10:  mov  edi,edx        #copy vrblk pointer} mov wc xr
        mov  dword ptr prnmv,edi #save for next time in} mov xr prnmv
        call prtvn          #print variable name} jsr prtvn
#
#      merge here if no entry found
#
prn11:  mov  edx,dword ptr [esi] #load first word of name base} mov (xl) wc
        cmp  edx,offset b_pdt #jump if not program defined} bne wc =b_pdt prn13
        jne  short prn13 # (jump shortened)
#
#      for program defined datatype, add right paren and exit
#
        mov  ecx,ch_rp      #load right paren, merge} mov =ch_rp wa
#
#      merge here to print final right paren or bracket
#
prn12:  call prtch          #print final character} jsr prtch
        mov  ecx,ebx        #restore name offset} mov wb wa
        jmp  prn01          #merge back to exit} brn prn01
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      here for array or table
#
prn13:  mov  ecx,ch_bb      #load left bracket} mov =ch_bb wa
        call prtch          #and print it} jsr prtch
        mov  esi,dword ptr [esp] #restore block pointer} mov (xs) xl
        mov  edx,dword ptr [esi] #load type word again} mov (xl) wc
        cmp  edx,offset b_tet #jump if not table} bne wc =b_tet prn15
        jne  short prn15 # (jump shortened)
#
#      here for table, print subscript value
#
        mov  edi,dword ptr (4*tesub)[esi] #load subscript value} mov tesub(xl) xr
        mov  esi,ebx        #save name offset} mov wb xl
        call prtvl          #print subscript value} jsr prtvl
        mov  ebx,esi        #restore name offset} mov xl wb
#
#      merge here from array case to print right bracket
#
prn14:  mov  ecx,ch_rb      #load right bracket} mov =ch_rb wa
        jmp  prn12          #merge back to print it} brn prn12
#
#      here for array or vector, to print subscript(s)
#
prn15:  mov  ecx,ebx        #copy name offset} mov wb wa
        shr  ecx,2          #convert to words} btw wa
        cmp  edx,offset b_art #jump if arblk} beq wc =b_art prn16
        je   short prn16 # (jump shortened)
#
#      here for vector
#
        sub  ecx,vcvlb      #adjust for standard fields} sub =vcvlb wa
        mov  edx,ecx        #move to integer accum} mti wa
        call prtin          #print linear subscript} jsr prtin
        jmp  prn14          #merge back for right bracket} brn prn14
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      here for array. first calculate absolute subscript
#      offsets by successive divisions by the dimension values.
#      this must be done right to left since the elements are
#      stored row-wise. the subscripts are stacked as integers.
#
prn16:  mov  edx,dword ptr (4*arofs)[esi] #load length of bounds info} mov arofs(xl) wc
        add  edx,4          #adjust for arpro field} ica wc
        shr  edx,2          #convert to words} btw wc
        sub  ecx,edx        #get linear zero-origin subscript} sub wc wa
        mov  edx,ecx        #get integer value} mti wa
        mov  ecx,dword ptr (4*arndm)[esi] #set num of dimensions as loop count} lct wa arndm(xl)
        add  esi,dword ptr (4*arofs)[esi] #point past bounds information} add arofs(xl) xl
        sub  esi,4*arlbd    #set ok offset for proper ptr later} sub *arlbd xl
#
#      loop to stack subscript offsets
#
prn17:  sub  esi,4*ardms    #point to next set of bounds} sub *ardms xl
        mov  dword ptr prnsi,edx #save current offset} sti prnsi
        mov  eax,dword ptr (4*ardim)[esi] #get remainder on dividing by dimens} rmi ardim(xl)
        call rmi_
        push edx            #store on stack (one word)} mfi -(xs)
        mov  edx,dword ptr prnsi #reload argument} ldi prnsi
        mov  eax,dword ptr (4*ardim)[esi] #divide to get quotient} dvi ardim(xl)
        call dvi_
        loop prn17          #loop till all stacked} bct wa prn17
        xor  edi,edi        #set offset to first set of bounds} zer xr
        mov  ebx,dword ptr (4*arndm)[esi] #load count of dims to control loop} lct wb arndm(xl)
        jmp  short prn19          #jump into print loop} brn prn19 # (jump shortened)
#
#      loop to print subscripts from stack adjusting by adding
#      the appropriate low bound value from the arblk
#
prn18:  mov  ecx,ch_cm      #load a comma} mov =ch_cm wa
        call prtch          #print it} jsr prtch
#
#      merge here first time in (no comma required)
#
prn19:  pop  edx            #load subscript offset as integer} mti (xs)+
        add  esi,edi        #point to current lbd} add xr xl
        add  edx,dword ptr (4*arlbd)[esi] #add lbd to get signed subscript} adi arlbd(xl)
        sub  esi,edi        #point back to start of arblk} sub xr xl
        call prtin          #print subscript} jsr prtin
        add  edi,4*ardms    #bump offset to next bounds} add *ardms xr
        dec  ebx            #loop back till all printed} bct wb prn18
        jnz  prn18
        jmp  prn14          #merge back to print right bracket} brn prn14
                            #end procedure prtnm} enp
                            #} ejc
        .eject
#
#      prtnv -- print name value
#
#      prtnv is used by the trace and dump routines to print
#      a line of the form
#
#      name = value
#
#      note that the name involved can never be a pseudo-var
#
#      (xl)                  name base
#      (wa)                  name offset
#      jsr  prtnv            call to print name = value
#      (wb,wc,ra)            destroyed
#
prtnv:                      #entry point} prc e 0
        .global prtnv
        call prtnm          #print argument name} jsr prtnm
        push edi            #save entry edi} mov xr -(xs)
        push ecx            #save name offset (collectable)} mov wa -(xs)
        mov  edi,offset tmbeb #point to blank equal blank} mov =tmbeb xr
        call prtst          #print it} jsr prtst
        mov  edi,esi        #copy name base} mov xl xr
        add  edi,ecx        #point to value} add wa xr
        mov  edi,dword ptr [edi] #load value pointer} mov (xr) xr
        call prtvl          #print value} jsr prtvl
        call prtnl          #terminate line} jsr prtnl
        pop  ecx            #restore name offset} mov (xs)+ wa
        pop  edi            #restore entry edi} mov (xs)+ xr
        ret                 #return to caller} exi
                            #end procedure prtnv} enp
                            #} ejc
        .eject
#
#      prtpg  -- print a page throw
#
#      prints a page throw or a few blank lines on the standard
#      listing channel depending on the listing options chosen.
#
#      jsr  prtpg            call for page eject
#
prtpg:                      #entry point} prc e 0
        .global prtpg
        cmp  dword ptr stage,stgxt #jump if execution time} beq stage =stgxt prp01
        je   short prp01 # (jump shortened)
        cmp  dword ptr dword ptr lstlc,0 #return if top of page already} bze lstlc prp06
        jz   prp06
        xor  eax,eax        #clear line count} zer lstlc
        mov  dword ptr lstlc,eax
#
#      check type of listing
#
prp01:  push edi            #preserve edi} mov xr -(xs)
        cmp  dword ptr dword ptr prstd,0 #eject if flag set} bnz prstd prp02
        jnz  short prp02 # (jump shortened)
        cmp  dword ptr dword ptr prich,0 #jump if interactive listing channel} bnz prich prp03
        jnz  short prp03 # (jump shortened)
        cmp  dword ptr dword ptr precl,0 #jump if compact listing} bze precl prp03
        jz   short prp03 # (jump shortened)
#
#      perform an eject
#
prp02:  call sysep          #eject} jsr sysep
        jmp  short prp04          #merge} brn prp04 # (jump shortened)
#
#      compact or interactive channel listing. cant print
#      blanks until check made for headers printed and flag set.
#
#
prp03:  mov  edi,dword ptr headp #remember headp} mov headp xr
        mov  dword ptr headp,esp #set to avoid repeated prtpg calls} mnz headp
        call prtnl          #print blank line} jsr prtnl
        call prtnl          #print blank line} jsr prtnl
        call prtnl          #print blank line} jsr prtnl
        mov  dword ptr lstlc,num03 #count blank lines} mov =num03 lstlc
        mov  dword ptr headp,edi #restore header flag} mov xr headp
                            #} ejc
        .eject
#
#      prptg (continued)
#
#      print the heading
#
prp04:  cmp  dword ptr dword ptr headp,0 #jump if header listed} bnz headp prp05
        jnz  short prp05 # (jump shortened)
        mov  dword ptr headp,esp #mark headers printed} mnz headp
        push esi            #keep esi} mov xl -(xs)
        mov  edi,offset headr #point to listing header} mov =headr xr
        call prtst          #place it} jsr prtst
        call sysid          #get system identification} jsr sysid
        call prtst          #append extra chars} jsr prtst
        call prtnl          #print it} jsr prtnl
        mov  edi,esi        #extra header line} mov xl xr
        call prtst          #place it} jsr prtst
        call prtnl          #print it} jsr prtnl
        call prtnl          #print a blank} jsr prtnl
        call prtnl          #and another} jsr prtnl
        add  dword ptr lstlc,num04 #four header lines printed} add =num04 lstlc
        pop  esi            #restore esi} mov (xs)+ xl
#
#      merge if header not printed
#
prp05:  pop  edi            #restore edi} mov (xs)+ xr
#
#      return
#
prp06:  ret                 #return} exi
                            #end procedure prtpg} enp
                            #} ejc
        .eject
#
#      prtps - print page with test for standard listing option
#
#      if the standard listing option is selected, insist that
#      an eject be done
#
#      jsr  prtps            call for eject
#
prtps:                      #entry point} prc e 0
        .global prtps
        mov  eax,dword ptr prsto #copy option flag} mov prsto prstd
        mov  dword ptr prstd,eax
        call prtpg          #print page} jsr prtpg
        xor  eax,eax        #clear flag} zer prstd
        mov  dword ptr prstd,eax
        ret                 #return} exi
                            #end procedure prtps} enp
                            #} ejc
        .eject
#
#      prtsn -- print statement number
#
#      prtsn is used to initiate a print trace line by printing
#      asterisks and the current statement number. the actual
#      format of the output generated is.
#
#      ***nnnnn**** iii.....iiii
#
#      nnnnn is the statement number with leading zeros replaced
#      by asterisks (e.g. *******9****)
#
#      iii...iii represents a variable length output consisting
#      of a number of letter i characters equal to fnclevel.
#
#      jsr  prtsn            call to print statement number
#      (wc)                  destroyed
#
prtsn:                      #entry point} prc e 0
        .global prtsn
        push edi            #save entry edi} mov xr -(xs)
        mov  dword ptr prsna,ecx #save entry ecx} mov wa prsna
        mov  edi,offset tmasb #point to asterisks} mov =tmasb xr
        call prtst          #print asterisks} jsr prtst
        mov  dword ptr profs,num04 #point into middle of asterisks} mov =num04 profs
        mov  edx,dword ptr kvstn #load statement number as integer} mti kvstn
        call prtin          #print integer statement number} jsr prtin
        mov  dword ptr profs,prsnf #point past asterisks plus blank} mov =prsnf profs
        mov  edi,dword ptr kvfnc #get fnclevel} mov kvfnc xr
        mov  ecx,ch_li      #set letter i} mov =ch_li wa
#
#      loop to generate letter i fnclevel times
#
prsn1:  or   edi,edi        #jump if all set} bze xr prsn2
        jz   short prsn2 # (jump shortened)
        call prtch          #else print an i} jsr prtch
        dec  edi            #decrement counter} dcv xr
        jmp  prsn1          #loop back} brn prsn1
#
#      merge with all letter i characters generated
#
prsn2:  mov  ecx,ch_bl      #get blank} mov =ch_bl wa
        call prtch          #print blank} jsr prtch
        mov  ecx,dword ptr prsna #restore entry ecx} mov prsna wa
        pop  edi            #restore entry edi} mov (xs)+ xr
        ret                 #return to prtsn caller} exi
                            #end procedure prtsn} enp
                            #} ejc
        .eject
#
#      prtst -- print string
#
#      prtst places a string of characters in the print buffer
#
#      see prtnl for global locations used
#
#      note that the first word of the block (normally b$scl)
#      is not used and need not be set correctly (see prtvn)
#
#      (xr)                  string to be printed
#      jsr  prtst            call to print string
#      (profs)               updated past chars placed
#
prtst:                      #entry point} prc r 0
        .global prtst
        cmp  dword ptr dword ptr headp,0 #were headers printed} bnz headp prst0
        jnz  short prst0 # (jump shortened)
        call prtps          #no - print them} jsr prtps
#
#      call syspr
#
prst0:  mov  dword ptr prsva,ecx #save ecx} mov wa prsva
        mov  dword ptr prsvb,ebx #save ebx} mov wb prsvb
        xor  ebx,ebx        #set chars printed count to zero} zer wb
#
#      loop to print successive lines for long string
#
prst1:  mov  ecx,dword ptr (4*sclen)[edi] #load string length} mov sclen(xr) wa
        sub  ecx,ebx        #subtract count of chars already out} sub wb wa
#        or   ecx,ecx        #jump to exit if none left} bze wa prst4  (optimized)
        jz   prst4
        push esi            #else stack entry esi} mov xl -(xs)
        push edi            #save argument} mov xr -(xs)
        mov  esi,edi        #copy for eventual move} mov xr xl
        mov  edi,dword ptr prlen #load print buffer length} mov prlen xr
        sub  edi,dword ptr profs #get chars left in print buffer} sub profs xr
#        or   edi,edi        #skip if room left on this line} bnz xr prst2  (optimized)
        jnz  short prst2 # (jump shortened)
        call prtnl          #else print this line} jsr prtnl
        mov  edi,dword ptr prlen #and set full width available} mov prlen xr
                            #} ejc
        .eject
#
#      prtst (continued)
#
#      here with chars to print and some room in buffer
#
prst2:  cmp  ecx,edi        #jump if room for rest of string} blo wa xr prst3
        jb   short prst3 # (jump shortened)
        mov  ecx,edi        #else set to fill line} mov xr wa
#
#      merge here with character count in wa
#
prst3:  mov  edi,dword ptr prbuf #point to print buffer} mov prbuf xr
        lea  esi,[cfp_f+esi+ebx] #point to location in string} plc xl wb
        add  edi,cfp_f      #point to location in buffer} psc xr profs
        add  edi,dword ptr profs
        add  ebx,ecx        #bump string chars count} add wa wb
        add  dword ptr profs,ecx #bump buffer pointer} add wa profs
        mov  dword ptr prsvc,ebx #preserve char counter} mov wb prsvc
        shrd eax,ecx,1      #move characters to buffer} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        mov  ebx,dword ptr prsvc #recover char counter} mov prsvc wb
        pop  edi            #restore argument pointer} mov (xs)+ xr
        pop  esi            #restore entry esi} mov (xs)+ xl
        jmp  prst1          #loop back to test for more} brn prst1
#
#      here to exit after printing string
#
prst4:  mov  ebx,dword ptr prsvb #restore entry ebx} mov prsvb wb
        mov  ecx,dword ptr prsva #restore entry ecx} mov prsva wa
        ret                 #return to prtst caller} exi
                            #end procedure prtst} enp
                            #} ejc
        .eject
#
#      prttr -- print to terminal
#
#      called to print contents of standard print buffer to
#      online terminal. clears buffer down and resets profs.
#
#      jsr  prttr            call for print
#      (wa,wb)               destroyed
#
prttr:                      #entry point} prc e 0
        .global prttr
        push edi            #save edi} mov xr -(xs)
        call prtic          #print buffer contents} jsr prtic
        mov  edi,dword ptr prbuf #point to print bfr to clear it} mov prbuf xr
        mov  ecx,dword ptr prlnw #get buffer length} lct wa prlnw
        add  edi,4*schar    #point past scblk header} add *schar xr
        mov  ebx,dword ptr nullw #get blanks} mov nullw wb
#
#      loop to clear buffer
#
prtt1:  mov  eax,ebx        #clear a word} mov wb (xr)+
        stosd
        loop prtt1          #loop} bct wa prtt1
        xor  eax,eax        #reset profs} zer profs
        mov  dword ptr profs,eax
        pop  edi            #restore edi} mov (xs)+ xr
        ret                 #return} exi
                            #end procedure prttr} enp
                            #} ejc
        .eject
#
#      prtvl -- print a value
#
#      prtvl places an appropriate character representation of
#      a data value in the print buffer for dump/trace use.
#
#      (xr)                  value to be printed
#      jsr  prtvl            call to print value
#      (wa,wb,wc,ra)         destroyed
#
prtvl:                      #entry point, recursive} prc r 0
        .global prtvl
        push esi            #save entry esi} mov xl -(xs)
        push edi            #save argument} mov xr -(xs)
        cmp  esp,lowspmin   #check for stack overflow} chk
        jb   sec06
#
#      loop back here after finding a trap block (trblk)
#
prv01:  mov  eax,dword ptr (4*idval)[edi] #copy idval (if any)} mov idval(xr) prvsi
        mov  dword ptr prvsi,eax
        mov  esi,dword ptr [edi] #load first word of block} mov (xr) xl
        movzx esi,byte ptr [esi-1] #load entry point id} lei xl
        cmp  esi,bl__t      #switch on block type} bsw xl bl__t prv02
        jge  short prv02 # (jump shortened)
        jmp  dword ptr l0016[esi*4]
        dseg_
l0016:
        .long prv05         #arblk} iff bl_ar prv05
        .long prv02         #} iff 1 prv02
        .long prv02         #} iff 2 prv02
        .long prv08         #icblk} iff bl_ic prv08
        .long prv09         #nmblk} iff bl_nm prv09
        .long prv02         #} iff 5 prv02
        .long prv02         #} iff 6 prv02
        .long prv02         #} iff 7 prv02
        .long prv08         #rcblk} iff bl_rc prv08
        .long prv11         #scblk} iff bl_sc prv11
        .long prv12         #seblk} iff bl_se prv12
        .long prv13         #tbblk} iff bl_tb prv13
        .long prv13         #vcblk} iff bl_vc prv13
        .long prv02         #} iff 13 prv02
        .long prv02         #} iff 14 prv02
        .long prv02         #} iff 15 prv02
        .long prv10         #pdblk} iff bl_pd prv10
        .long prv04         #trblk} iff bl_tr prv04
        dsegend_            #end of switch on block type} esw
        cseg_
#
#      here for blocks for which we just print datatype name
#
prv02:  call dtype          #get datatype name} jsr dtype
        call prtst          #print datatype name} jsr prtst
#
#      common exit point
#
prv03:  pop  edi            #reload argument} mov (xs)+ xr
        pop  esi            #restore esi} mov (xs)+ xl
        ret                 #return to prtvl caller} exi
#
#      here for trblk
#
prv04:  mov  edi,dword ptr (4*trval)[edi] #load real value} mov trval(xr) xr
        jmp  prv01          #and loop back} brn prv01
                            #} ejc
        .eject
#
#      prtvl (continued)
#
#      here for array (arblk)
#
#      print array ( prototype ) blank number idval
#
prv05:  mov  esi,edi        #preserve argument} mov xr xl
        mov  edi,offset scarr #point to datatype name (array)} mov =scarr xr
        call prtst          #print it} jsr prtst
        mov  ecx,ch_pp      #load left paren} mov =ch_pp wa
        call prtch          #print left paren} jsr prtch
        add  esi,dword ptr (4*arofs)[esi] #point to prototype} add arofs(xl) xl
        mov  edi,dword ptr [esi] #load prototype} mov (xl) xr
        call prtst          #print prototype} jsr prtst
#
#      vcblk, tbblk, bcblk merge here for ) blank number idval
#
prv06:  mov  ecx,ch_rp      #load right paren} mov =ch_rp wa
        call prtch          #print right paren} jsr prtch
#
#      pdblk merges here to print blank number idval
#
prv07:  mov  ecx,ch_bl      #load blank} mov =ch_bl wa
        call prtch          #print it} jsr prtch
        mov  ecx,ch_nm      #load number sign} mov =ch_nm wa
        call prtch          #print it} jsr prtch
        mov  edx,dword ptr prvsi #get idval} mti prvsi
        call prtin          #print id number} jsr prtin
        jmp  prv03          #back to exit} brn prv03
#
#      here for integer (icblk), real (rcblk)
#
#      print character representation of value
#
prv08:  push edi            #stack argument for gtstg} mov xr -(xs)
        call gtstg          #convert to string} jsr gtstg
        .short err_-299-dffnc #error return is impossible} ppm
        call prtst          #print the string} jsr prtst
        mov  dword ptr dnamp,edi #delete garbage string from storage} mov xr dnamp
        jmp  prv03          #back to exit} brn prv03
                            #} ejc
        .eject
#
#      prtvl (continued)
#
#      name (nmblk)
#
#      for pseudo-variable, just print datatype name (name)
#      for all other names, print dot followed by name rep
#
prv09:  mov  esi,dword ptr (4*nmbas)[edi] #load name base} mov nmbas(xr) xl
        mov  ecx,dword ptr [esi] #load first word of block} mov (xl) wa
        cmp  ecx,offset b_kvt #just print name if keyword} beq wa =b_kvt prv02
        je   prv02
        cmp  ecx,offset b_evt #just print name if expression var} beq wa =b_evt prv02
        je   prv02
        mov  ecx,ch_dt      #else get dot} mov =ch_dt wa
        call prtch          #and print it} jsr prtch
        mov  ecx,dword ptr (4*nmofs)[edi] #load name offset} mov nmofs(xr) wa
        call prtnm          #print name} jsr prtnm
        jmp  prv03          #back to exit} brn prv03
#
#      program datatype (pdblk)
#
#      print datatype name ch$bl ch$nm idval
#
prv10:  call dtype          #get datatype name} jsr dtype
        call prtst          #print datatype name} jsr prtst
        jmp  prv07          #merge back to print id} brn prv07
#
#      here for string (scblk)
#
#      print quote string-characters quote
#
prv11:  mov  ecx,ch_sq      #load single quote} mov =ch_sq wa
        call prtch          #print quote} jsr prtch
        call prtst          #print string value} jsr prtst
        call prtch          #print another quote} jsr prtch
        jmp  prv03          #back to exit} brn prv03
                            #} ejc
        .eject
#
#      prtvl (continued)
#
#      here for simple expression (seblk)
#
#      print asterisk variable-name
#
prv12:  mov  ecx,ch_as      #load asterisk} mov =ch_as wa
        call prtch          #print asterisk} jsr prtch
        mov  edi,dword ptr (4*sevar)[edi] #load variable pointer} mov sevar(xr) xr
        call prtvn          #print variable name} jsr prtvn
        jmp  prv03          #jump back to exit} brn prv03
#
#      here for table (tbblk) and array (vcblk)
#
#      print datatype ( prototype ) blank number idval
#
prv13:  mov  esi,edi        #preserve argument} mov xr xl
        call dtype          #get datatype name} jsr dtype
        call prtst          #print datatype name} jsr prtst
        mov  ecx,ch_pp      #load left paren} mov =ch_pp wa
        call prtch          #print left paren} jsr prtch
        mov  ecx,dword ptr (4*tblen)[esi] #load length of block (=vclen)} mov tblen(xl) wa
        shr  ecx,2          #convert to word count} btw wa
        sub  ecx,tbsi_      #allow for standard fields} sub =tbsi_ wa
        cmp  dword ptr [esi],offset b_tbt #jump if table} beq (xl) =b_tbt prv14
        je   short prv14 # (jump shortened)
        add  ecx,vctbd      #for vcblk, adjust size} add =vctbd wa
#
#      print prototype
#
prv14:  mov  edx,ecx        #move as integer} mti wa
        call prtin          #print integer prototype} jsr prtin
        jmp  prv06          #merge back for rest} brn prv06
                            #end procedure prtvl} enp
                            #} ejc
        .eject
#
#      prtvn -- print natural variable name
#
#      prtvn prints the name of a natural variable
#
#      (xr)                  pointer to vrblk
#      jsr  prtvn            call to print variable name
#
prtvn:                      #entry point} prc e 0
        .global prtvn
        push edi            #stack vrblk pointer} mov xr -(xs)
        add  edi,4*vrsof    #point to possible string name} add *vrsof xr
        cmp  dword ptr dword ptr (4*sclen)[edi],0 #jump if not system variable} bnz sclen(xr) prvn1
        jnz  short prvn1 # (jump shortened)
        mov  edi,dword ptr (4*vrsvo)[edi] #point to svblk with name} mov vrsvo(xr) xr
#
#      merge here with dummy scblk pointer in xr
#
prvn1:  call prtst          #print string name of variable} jsr prtst
        pop  edi            #restore vrblk pointer} mov (xs)+ xr
        ret                 #return to prtvn caller} exi
                            #end procedure prtvn} enp
                            #} ejc
        .eject
#
#      rcbld -- build a real block
#
#      (ra)                  real value for rcblk
#      jsr  rcbld            call to build real block
#      (xr)                  pointer to result rcblk
#      (wa)                  destroyed
#
rcbld:                      #entry point} prc e 0
        .global rcbld
        mov  edi,dword ptr dnamp #load pointer to next available loc} mov dnamp xr
        add  edi,4*rcsi_    #point past new rcblk} add *rcsi_ xr
        cmp  edi,dword ptr dname #jump if there is room} blo xr dname rcbl1
        jb   short rcbl1 # (jump shortened)
        mov  ecx,4*rcsi_    #else load rcblk length} mov *rcsi_ wa
        call alloc          #use standard allocator to get block} jsr alloc
        add  edi,ecx        #point past block to merge} add wa xr
#
#      merge here with xr pointing past the block obtained
#
rcbl1:  mov  dword ptr dnamp,edi #set new pointer} mov xr dnamp
        sub  edi,4*rcsi_    #point back to start of block} sub *rcsi_ xr
        mov  dword ptr [edi],offset b_rcl #store type word} mov =b_rcl (xr)
        lea  eax,dword ptr (4*rcval)[edi] #store real value in rcblk} str rcval(xr)
        call str_
        ret                 #return to rcbld caller} exi
                            #end procedure rcbld} enp
                            #} ejc
        .eject
#
#      readr -- read next source image at compile time
#
#      readr is used to read the next source image. to process
#      continuation cards properly, the compiler must read one
#      line ahead. thus readr does not destroy the current image
#      see also the nexts routine which actually gets the image.
#
#      jsr  readr            call to read next image
#      (xr)                  ptr to next image (0 if none)
#      (r$cni)               copy of pointer
#      (wa,wb,wc,xl)         destroyed
#
readr:                      #entry point} prc e 0
        .global readr
        mov  edi,dword ptr r_cni #get ptr to next image} mov r_cni xr
        or   edi,edi        #exit if already read} bnz xr read3
        jnz  read3
        cmp  dword ptr dword ptr cnind,0 #if within include file} bnz cnind reada
        jnz  short reada # (jump shortened)
        cmp  dword ptr stage,stgic #exit if not initial compile} bne stage =stgic read3
        jne  read3
reada:  mov  ecx,dword ptr cswin #max read length} mov cswin wa
        xor  esi,esi        #clear any dud value in esi} zer xl
        call alocs          #allocate buffer} jsr alocs
        call sysrd          #read input image} jsr sysrd
        .short read4-dffnc  #jump if eof or new file name} ppm read4
        inc  dword ptr rdnln #increment next line number} icv rdnln
        dec  dword ptr polct #test if time to poll interface} dcv polct
        cmp  dword ptr dword ptr polct,0 #not yet} bnz polct read0
        jnz  short read0 # (jump shortened)
        xor  ecx,ecx        #=0 for poll} zer wa
        mov  ebx,dword ptr rdnln #line number} mov rdnln wb
        call syspl          #allow interactive access} jsr syspl
        .short err_-320-dffnc #} err 320 user interrupt
        .short err_-299-dffnc #single step} ppm
        .short err_-299-dffnc #expression evaluation} ppm
        mov  dword ptr polcs,ecx #new countdown start value} mov wa polcs
        mov  dword ptr polct,ecx #new counter value} mov wa polct
read0:  mov  eax,dword ptr (4*sclen)[edi] #use smaller of string lnth ...} ble sclen(xr) cswin read1
        cmp  eax,dword ptr cswin
        jbe  short read1 # (jump shortened)
        mov  eax,dword ptr cswin #... and xxx of -inxxx} mov cswin sclen(xr)
        mov  dword ptr (4*sclen)[edi],eax
#
#      perform the trim
#
read1:  mov  ebx,esp        #set trimr to perform trim} mnz wb
        call trimr          #trim trailing blanks} jsr trimr
#
#      merge here after read
#
read2:  mov  dword ptr r_cni,edi #store copy of pointer} mov xr r_cni
#
#      merge here if no read attempted
#
read3:  ret                 #return to readr caller} exi
#
#      here on end of file or new source file name.
#      if this is a new source file name, the r$sfn table will
#      be augmented with a new table entry consisting of the
#      current compiler statement number as subscript, and the
#      file name as value.
#
read4:  cmp  dword ptr dword ptr (4*sclen)[edi],0 #jump if true end of file} bze sclen(xr) read5
        jz   short read5 # (jump shortened)
        xor  ebx,ebx        #new source file name} zer wb
        mov  dword ptr rdnln,ebx #restart line counter for new file} mov wb rdnln
        call trimr          #remove unused space in block} jsr trimr
        call newfn          #record new file name} jsr newfn
        jmp  reada          #now reissue read for record data} brn reada
#
#      here on end of file
#
read5:  mov  dword ptr dnamp,edi #pop unused scblk} mov xr dnamp
        cmp  dword ptr dword ptr cnind,0 #jump if not within an include file} bze cnind read6
        jz   read6
        xor  esi,esi        #eof within include file} zer xl
        call sysif          #switch stream back to previous file} jsr sysif
        .short err_-299-dffnc #} ppm
        mov  ecx,dword ptr cnind #restore prev line number, file name} mov cnind wa
        add  ecx,vcvlb      #vector offset in words} add =vcvlb wa
        sal  ecx,2          #convert to bytes} wtb wa
        mov  edi,dword ptr r_ifa #file name array} mov r_ifa xr
        add  edi,ecx        #ptr to element} add wa xr
        mov  eax,dword ptr [edi] #change source file name} mov (xr) r_sfc
        mov  dword ptr r_sfc,eax
        mov  dword ptr [edi],offset nulls #release scblk} mov =nulls (xr)
        mov  edi,dword ptr r_ifl #line number array} mov r_ifl xr
        add  edi,ecx        #ptr to element} add wa xr
        mov  esi,dword ptr [edi] #icblk containing saved line number} mov (xr) xl
        mov  edx,dword ptr (4*icval)[esi] #line number integer} ldi icval(xl)
        mov  dword ptr rdnln,edx #change source line number} mfi rdnln
        mov  dword ptr [edi],offset inton #release icblk} mov =inton (xr)
        dec  dword ptr cnind #decrement nesting level} dcv cnind
        mov  ebx,dword ptr cmpsn #current statement number} mov cmpsn wb
        inc  ebx            #anticipate end of previous stmt} icv wb
        mov  edx,ebx        #convert to integer} mti wb
        call icbld          #build icblk for stmt number} jsr icbld
        mov  esi,dword ptr r_sfn #file name table} mov r_sfn xl
        mov  ebx,esp        #lookup statement number by name} mnz wb
        call tfind          #allocate new teblk} jsr tfind
        .short err_-299-dffnc #always possible to allocate block} ppm
        mov  eax,dword ptr r_sfc #record file name as entry value} mov r_sfc teval(xl)
        mov  dword ptr (4*teval)[esi],eax
        cmp  dword ptr stage,stgic #if initial compile, reissue read} beq stage =stgic reada
        je   reada
        cmp  dword ptr dword ptr cnind,0 #still reading from include file} bnz cnind reada
        jnz  reada
#
#      outer nesting of execute-time compile of -include
#      resume with any string remaining prior to -include.
#
        mov  esi,dword ptr r_ici #restore code argument string} mov r_ici xl
        xor  eax,eax        #release original string} zer r_ici
        mov  dword ptr r_ici,eax
        mov  ecx,dword ptr cnsil #get length of string} mov cnsil wa
        mov  ebx,dword ptr cnspt #offset of characters left} mov cnspt wb
        sub  ecx,ebx        #number of characters left} sub wb wa
        mov  dword ptr scnil,ecx #set new scan length} mov wa scnil
        xor  eax,eax        #scan from start of substring} zer scnpt
        mov  dword ptr scnpt,eax
        call sbstr          #create substring of remainder} jsr sbstr
        mov  dword ptr r_cim,edi #set scan image} mov xr r_cim
        jmp  read2          #return} brn read2
read6:  xor  edi,edi        #zero ptr as result} zer xr
        jmp  read2          #merge} brn read2
                            #end procedure readr} enp
                            #} ejc
        .eject
#
#      sbstr -- build a substring
#
#      (xl)                  ptr to scblk/bfblk with chars
#      (wa)                  number of chars in substring
#      (wb)                  offset to first char in scblk
#      jsr  sbstr            call to build substring
#      (xr)                  ptr to new scblk with substring
#      (xl)                  zero
#      (wa,wb,wc,xl,ia)      destroyed
#
#      note that sbstr is called with a dummy string pointer
#      (pointing into a vrblk or svblk) to copy the name of a
#      variable as a standard string value.
#
sbstr:                      #entry point} prc e 0
        .global sbstr
        or   ecx,ecx        #jump if null substring} bze wa sbst2
        jz   short sbst2 # (jump shortened)
        call alocs          #else allocate scblk} jsr alocs
        mov  ecx,edx        #move number of characters} mov wc wa
        mov  edx,edi        #save ptr to new scblk} mov xr wc
        lea  esi,[cfp_f+esi+ebx] #prepare to load chars from old blk} plc xl wb
        add  edi,cfp_f      #prepare to store chars in new blk} psc xr
        shrd eax,ecx,1      #move characters to new string} mvc
        shr  ecx,2
        rep  movsd
        adc  ecx,ecx
        rep  movsw
        shld ecx,eax,1
        rep  movsb
        mov  edi,edx        #then restore scblk pointer} mov wc xr
#
#      return point
#
sbst1:  xor  esi,esi        #clear garbage pointer in esi} zer xl
        ret                 #return to sbstr caller} exi
#
#      here for null substring
#
sbst2:  mov  edi,offset nulls #set null string as result} mov =nulls xr
        jmp  sbst1          #return} brn sbst1
                            #end procedure sbstr} enp
                            #} ejc
        .eject
#
#      stgcc -- compute counters for stmt startup testing
#
#      jsr  stgcc            call to recompute counters
#      (wa,wb)               destroyed
#
#      on exit, stmcs and stmct contain the counter value to
#      tested in stmgo.
#
#
stgcc:                      #} prc e 0
        .global stgcc
        mov  ecx,dword ptr polcs #assume no profiling or stcount tracing} mov polcs wa
        mov  ebx,num01      #poll each time polcs expires} mov =num01 wb
        mov  edx,dword ptr kvstl #get stmt limit} ldi kvstl
        cmp  dword ptr dword ptr kvpfl,0 #jump if profiling enabled} bnz kvpfl stgc1
        jnz  short stgc1 # (jump shortened)
        or   edx,edx        #no stcount tracing if negative} ilt stgc3
        jl   short stgc3 # (jump shortened)
        cmp  dword ptr dword ptr r_stc,0 #jump if not stcount tracing} bze r_stc stgc2
        jz   short stgc2 # (jump shortened)
#
#      here if profiling or if stcount tracing enabled
#
stgc1:  mov  ebx,ecx        #count polcs times within stmg} mov wa wb
        mov  ecx,num01      #break out of stmgo on each stmt} mov =num01 wa
        jmp  short stgc3          #} brn stgc3 # (jump shortened)
#
#      check that stmcs does not exceed kvstl
#
stgc2:  mov  edx,ecx        #breakout count start value} mti wa
        sub  edx,dword ptr kvstl #proposed stmcs minus stmt limit} sbi kvstl
#        or   edx,edx        #jump if stmt count does not limit} ile stgc3   (optimized)
        jle  short stgc3 # (jump shortened)
        mov  edx,dword ptr kvstl #stlimit limits breakcount count} ldi kvstl
        mov  ecx,edx        #use it instead} mfi wa
#
#      re-initialize counter
#
stgc3:  mov  dword ptr stmcs,ecx #update breakout count start value} mov wa stmcs
        mov  dword ptr stmct,ecx #reset breakout counter} mov wa stmct
        mov  dword ptr polct,ebx #} mov wb polct
        ret                 #} exi
                            #} ejc
        .eject
#
#      tfind -- locate table element
#
#      (xr)                  subscript value for element
#      (xl)                  pointer to table
#      (wb)                  zero by value, non-zero by name
#      jsr  tfind            call to locate element
#      ppm  loc              transfer location if access fails
#      (xr)                  element value (if by value)
#      (xr)                  destroyed (if by name)
#      (xl,wa)               teblk name (if by name)
#      (xl,wa)               destroyed (if by value)
#      (wc,ra)               destroyed
#
#      note that if a call by value specifies a non-existent
#      subscript, the default value is returned without building
#      a new teblk.
#
tfind:                      #entry point} prc e 1
        .global tfind
        push ebx            #save name/value indicator} mov wb -(xs)
        push edi            #save subscript value} mov xr -(xs)
        push esi            #save table pointer} mov xl -(xs)
        mov  ecx,dword ptr (4*tblen)[esi] #load length of tbblk} mov tblen(xl) wa
        shr  ecx,2          #convert to word count} btw wa
        sub  ecx,tbbuk      #get number of buckets} sub =tbbuk wa
        mov  edx,ecx        #convert to integer value} mti wa
        mov  dword ptr tfnsi,edx #save for later} sti tfnsi
        mov  esi,dword ptr [edi] #load first word of subscript} mov (xr) xl
        movzx esi,byte ptr [esi-1] #load block entry id (bl_xx)} lei xl
        cmp  esi,bl__d      #switch on block type} bsw xl bl__d tfn00
        jge  short tfn00 # (jump shortened)
        jmp  dword ptr l0017[esi*4]
        dseg_
l0017:
        .long tfn00         #} iff 0 tfn00
        .long tfn00         #} iff 1 tfn00
        .long tfn00         #} iff 2 tfn00
        .long tfn02         #jump if integer} iff bl_ic tfn02
        .long tfn04         #jump if name} iff bl_nm tfn04
        .long tfn03         #jump if pattern} iff bl_p0 tfn03
        .long tfn03         #jump if pattern} iff bl_p1 tfn03
        .long tfn03         #jump if pattern} iff bl_p2 tfn03
        .long tfn02         #real} iff bl_rc tfn02
        .long tfn05         #jump if string} iff bl_sc tfn05
        .long tfn00         #} iff 10 tfn00
        .long tfn00         #} iff 11 tfn00
        .long tfn00         #} iff 12 tfn00
        .long tfn00         #} iff 13 tfn00
        .long tfn00         #} iff 14 tfn00
        .long tfn00         #} iff 15 tfn00
        .long tfn00         #} iff 16 tfn00
        dsegend_            #end switch on block type} esw
        cseg_
#
#      here for blocks for which we use the second word of the
#      block as the hash source (see block formats for details).
#
tfn00:  mov  ecx,dword ptr (4*1)[edi] #load second word} mov 1(xr) wa
#
#      merge here with one word hash source in wa
#
tfn01:  mov  edx,ecx        #convert to integer} mti wa
        jmp  tfn06          #jump to merge} brn tfn06
                            #} ejc
        .eject
#
#      tfind (continued)
#
#      here for integer or real
#      possibility of overflow exist on twos complement
#      machine if hash source is most negative integer or is
#      a real having the same bit pattern.
#
#
tfn02:  mov  edx,dword ptr (4*1)[edi] #load value as hash source} ldi 1(xr)
        or   edx,edx        #ok if positive or zero} ige tfn06
        jge  short tfn06 # (jump shortened)
        neg  edx            #make positive} ngi
        jo   short tfn06          #clear possible overflow} iov tfn06 # (jump shortened)
        jmp  short tfn06          #merge} brn tfn06 # (jump shortened)
#
#      for pattern, use first word (pcode) as source
#
tfn03:  mov  ecx,dword ptr [edi] #load first word as hash source} mov (xr) wa
        jmp  tfn01          #merge back} brn tfn01
#
#      for name, use offset as hash source
#
tfn04:  mov  ecx,dword ptr (4*nmofs)[edi] #load offset as hash source} mov nmofs(xr) wa
        jmp  tfn01          #merge back} brn tfn01
#
#      here for string
#
tfn05:  call hashs          #call routine to compute hash} jsr hashs
#
#      merge here with hash source in (ia)
#
tfn06:  mov  eax,dword ptr tfnsi #compute hash index by remaindering} rmi tfnsi
        call rmi_
                            #get as one word integer} mfi wc
        sal  edx,2          #convert to byte offset} wtb wc
        mov  esi,dword ptr [esp] #get table ptr again} mov (xs) xl
        add  esi,edx        #point to proper bucket} add wc xl
        mov  edi,dword ptr (4*tbbuk)[esi] #load first teblk pointer} mov tbbuk(xl) xr
        cmp  edi,dword ptr [esp] #jump if no teblks on chain} beq xr (xs) tfn10
        je   tfn10
#
#      loop through teblks on hash chain
#
tfn07:  mov  ebx,edi        #save teblk pointer} mov xr wb
        mov  edi,dword ptr (4*tesub)[edi] #load subscript value} mov tesub(xr) xr
        mov  esi,dword ptr (4*1)[esp] #load input argument subscript val} mov 1(xs) xl
        call ident          #compare them} jsr ident
        .short tfn08-dffnc  #jump if equal (ident)} ppm tfn08
#
#      here if no match with that teblk
#
        mov  esi,ebx        #restore teblk pointer} mov wb xl
        mov  edi,dword ptr (4*tenxt)[esi] #point to next teblk on chain} mov tenxt(xl) xr
        cmp  edi,dword ptr [esp] #jump if there is one} bne xr (xs) tfn07
        jne  tfn07
#
#      here if no match with any teblk on chain
#
        mov  edx,4*tenxt    #set offset to link field (esi base)} mov *tenxt wc
        jmp  tfn11          #jump to merge} brn tfn11
                            #} ejc
        .eject
#
#      tfind (continued)
#
#      here we have found a matching element
#
tfn08:  mov  esi,ebx        #restore teblk pointer} mov wb xl
        mov  ecx,4*teval    #set teblk name offset} mov *teval wa
        mov  ebx,dword ptr (4*2)[esp] #restore name/value indicator} mov 2(xs) wb
        or   ebx,ebx        #jump if called by name} bnz wb tfn09
        jnz  short tfn09 # (jump shortened)
        call acess          #else get value} jsr acess
        .short tfn12-dffnc  #jump if reference fails} ppm tfn12
        xor  ebx,ebx        #restore name/value indicator} zer wb
#
#      common exit for entry found
#
tfn09:  add  esp,4*num03    #pop stack entries} add *num03 xs
        pop  eax            #return to tfind caller} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here if no teblks on the hash chain
#
tfn10:  add  edx,4*tbbuk    #get offset to bucket ptr} add *tbbuk wc
        mov  esi,dword ptr [esp] #set tbblk ptr as base} mov (xs) xl
#
#      merge here with (xl,wc) base,offset of final link
#
tfn11:  mov  edi,dword ptr [esp] #tbblk pointer} mov (xs) xr
        mov  edi,dword ptr (4*tbinv)[edi] #load default value in case} mov tbinv(xr) xr
        mov  ebx,dword ptr (4*2)[esp] #load name/value indicator} mov 2(xs) wb
        or   ebx,ebx        #exit with default if value call} bze wb tfn09
        jz   tfn09
        mov  ebx,edi        #copy default value} mov xr wb
#
#      here we must build a new teblk
#
        mov  ecx,4*tesi_    #set size of teblk} mov *tesi_ wa
        call alloc          #allocate teblk} jsr alloc
        add  esi,edx        #point to hash link} add wc xl
        mov  dword ptr [esi],edi #link new teblk at end of chain} mov xr (xl)
        mov  dword ptr [edi],offset b_tet #store type word} mov =b_tet (xr)
        mov  dword ptr (4*teval)[edi],ebx #set default as initial value} mov wb teval(xr)
        pop  dword ptr (4*tenxt)[edi] #set tbblk ptr to mark end of chain} mov (xs)+ tenxt(xr)
        pop  dword ptr (4*tesub)[edi] #store subscript value} mov (xs)+ tesub(xr)
        pop  ebx            #restore name/value indicator} mov (xs)+ wb
        mov  esi,edi        #copy teblk pointer (name base)} mov xr xl
        mov  ecx,4*teval    #set offset} mov *teval wa
        pop  eax            #return to caller with new teblk} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      acess fail return
#
tfn12:  pop  eax            #alternative return} exi 1
        jmp  exi__1
                            #end procedure tfind} enp
                            #} ejc
        .eject
#
#      tmake -- make new table
#
#      (xl)                  initial lookup value
#      (wc)                  number of buckets desired
#      jsr  tmake            call to make new table
#      (xr)                  new table
#      (wa,wb)               destroyed
#
tmake:                      #} prc e 0
        .global tmake
        mov  ecx,edx        #copy number of headers} mov wc wa
        add  ecx,tbsi_      #adjust for standard fields} add =tbsi_ wa
        sal  ecx,2          #convert length to bytes} wtb wa
        call alloc          #allocate space for tbblk} jsr alloc
        mov  ebx,edi        #copy pointer to tbblk} mov xr wb
        mov  eax,offset b_tbt #store type word} mov =b_tbt (xr)+
        stosd
        xor  eax,eax        #zero id for the moment} zer (xr)+
        stosd
        mov  eax,ecx        #store length (tblen)} mov wa (xr)+
        stosd
        mov  eax,esi        #store initial lookup value} mov xl (xr)+
        stosd
#
#      loop to initialize all bucket pointers
#
tma01:  mov  eax,ebx        #store tbblk ptr in bucket header} mov wb (xr)+
        stosd
        dec  edx            #loop till all stored} bct wc tma01
        jnz  tma01
        mov  edi,ebx        #recall pointer to tbblk} mov wb xr
        ret                 #} exi
                            #} enp
                            #} ejc
        .eject
#
#      vmake -- create a vector
#
#      (wa)                  number of elements in vector
#      (xl)                  default value for vector elements
#      jsr  vmake            call to create vector
#      ppm  loc              if vector too large
#
#      (xr)                  pointer to vcblk
#      (wa,wb,wc,xl)         destroyed
#
vmake:                      #entry point} prc e 1
        .global vmake
        mov  ebx,ecx        #copy elements for loop later on} lct wb wa
        add  ecx,vcsi_      #add space for standard fields} add =vcsi_ wa
        sal  ecx,2          #convert length to bytes} wtb wa
        cmp  ecx,dword ptr mxlen #fail if too large} bgt wa mxlen vmak2
        ja   short vmak2 # (jump shortened)
        call alloc          #allocate space for vcblk} jsr alloc
        mov  dword ptr [edi],offset b_vct #store type word} mov =b_vct (xr)
        xor  eax,eax        #initialize idval} zer idval(xr)
        mov  dword ptr (4*idval)[edi],eax
        mov  dword ptr (4*vclen)[edi],ecx #set length} mov wa vclen(xr)
        mov  edx,esi        #copy default value} mov xl wc
        mov  esi,edi        #copy vcblk pointer} mov xr xl
        add  esi,4*vcvls    #point to first element value} add *vcvls xl
#
#      loop to set vector elements to default value
#
vmak1:  mov  dword ptr [esi],edx #store one value} mov wc (xl)+
        lea  esi,[esi+4]
        dec  ebx            #loop till all stored} bct wb vmak1
        jnz  vmak1
        pop  eax            #success return} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      here if desired vector size too large
#
vmak2:  pop  eax            #fail return} exi 1
        jmp  exi__1
                            #} enp
                            #} ejc
        .eject
#
#      scane -- scan an element
#
#      scane is called at compile time (by expan ,cmpil,cncrd)
#      to scan one element from the input image.
#
#      (scncc)               non-zero if called from cncrd
#      jsr  scane            call to scan element
#      (xr)                  result pointer (see below)
#      (xl)                  syntax type code (t$xxx)
#
#      the following global locations are used.
#
#      r$cim                 pointer to string block (scblk)
#                            for current input image.
#
#      r$cni                 pointer to next input image string
#                            pointer (zero if none).
#
#      r$scp                 save pointer (exit xr) from last
#                            call in case rescan is set.
#
#      scnbl                 this location is set non-zero on
#                            exit if scane scanned past blanks
#                            before locating the current element
#                            the end of a line counts as blanks.
#
#      scncc                 cncrd sets this non-zero to scan
#                            control card names and clears it
#                            on return
#
#      scnil                 length of current input image
#
#      scngo                 if set non-zero on entry, f and s
#                            are returned as separate syntax
#                            types (not letters) (goto pro-
#                            cessing). scngo is reset on exit.
#
#      scnpt                 offset to current loc in r$cim
#
#      scnrs                 if set non-zero on entry, scane
#                            returns the same result as on the
#                            last call (rescan). scnrs is reset
#                            on exit from any call to scane.
#
#      scntp                 save syntax type from last
#                            call (in case rescan is set).
                            #} ejc
        .eject
#
#      scane (continued)
#
#
#
#      element scanned       xl        xr
#      ---------------       --        --
#
#      control card name     0         pointer to scblk for name
#
#      unary operator        t$uop     ptr to operator dvblk
#
#      left paren            t$lpr     t$lpr
#
#      left bracket          t$lbr     t$lbr
#
#      comma                 t$cma     t$cma
#
#      function call         t$fnc     ptr to function vrblk
#
#      variable              t$var     ptr to vrblk
#
#      string constant       t$con     ptr to scblk
#
#      integer constant      t$con     ptr to icblk
#
#      real constant         t$con     ptr to rcblk
#
#      binary operator       t$bop     ptr to operator dvblk
#
#      right paren           t$rpr     t$rpr
#
#      right bracket         t$rbr     t$rbr
#
#      colon                 t$col     t$col
#
#      semi-colon            t$smc     t$smc
#
#      f (scngo ne 0)        t$fgo     t$fgo
#
#      s (scngo ne 0)        t$sgo     t$sgo
                            #} ejc
        .eject
#
#      scane (continued)
#
#      entry point
#
scane:                      #entry point} prc e 0
        .global scane
        xor  eax,eax        #reset blanks flag} zer scnbl
        mov  dword ptr scnbl,eax
        mov  dword ptr scnsa,ecx #save ecx} mov wa scnsa
        mov  dword ptr scnsb,ebx #save ebx} mov wb scnsb
        mov  dword ptr scnsc,edx #save edx} mov wc scnsc
        cmp  dword ptr dword ptr scnrs,0 #jump if no rescan} bze scnrs scn03
        jz   scn03
#
#      here for rescan request
#
        mov  esi,dword ptr scntp #set previous returned scan type} mov scntp xl
        mov  edi,dword ptr r_scp #set previous returned pointer} mov r_scp xr
        xor  eax,eax        #reset rescan switch} zer scnrs
        mov  dword ptr scnrs,eax
        jmp  scn13          #jump to exit} brn scn13
#
#      come here to read new image to test for continuation
#
scn01:  call readr          #read next image} jsr readr
        mov  ebx,4*dvubs    #set ebx for not reading name} mov *dvubs wb
        or   edi,edi        #treat as semi-colon if none} bze xr scn30
        jz   scn30
        add  edi,cfp_f      #else point to first character} plc xr
        movzx edx,byte ptr [edi] #load first character} lch wc (xr)
        cmp  edx,ch_dt      #jump if dot for continuation} beq wc =ch_dt scn02
        je   short scn02 # (jump shortened)
        cmp  edx,ch_pl      #else treat as semicolon unless plus} bne wc =ch_pl scn30
        jne  scn30
#
#      here for continuation line
#
scn02:  call nexts          #acquire next source image} jsr nexts
        mov  dword ptr scnpt,num01 #set scan pointer past continuation} mov =num01 scnpt
        mov  dword ptr scnbl,esp #set blanks flag} mnz scnbl
                            #} ejc
        .eject
#
#      scane (continued)
#
#      merge here to scan next element on current line
#
scn03:  mov  ecx,dword ptr scnpt #load current offset} mov scnpt wa
        cmp  ecx,dword ptr scnil #check continuation if end} beq wa scnil scn01
        je   scn01
        mov  esi,dword ptr r_cim #point to current line} mov r_cim xl
        lea  esi,[cfp_f+esi+ecx] #point to current character} plc xl wa
        mov  dword ptr scnse,ecx #set start of element location} mov wa scnse
        mov  edx,offset opdvs #point to operator dv list} mov =opdvs wc
        mov  ebx,4*dvubs    #set constant for operator circuit} mov *dvubs wb
        jmp  short scn06          #start scanning} brn scn06 # (jump shortened)
#
#      loop here to ignore leading blanks and tabs
#
scn05:  or   ebx,ebx        #jump if trailing} bze wb scn10
        jz   scn10
        inc  dword ptr scnse #increment start of element} icv scnse
        cmp  ecx,dword ptr scnil #jump if end of image} beq wa scnil scn01
        je   scn01
        mov  dword ptr scnbl,esp #note blanks seen} mnz scnbl
#
#      the following jump is used repeatedly for scanning out
#      the characters of a numeric constant or variable name.
#      the registers are used as follows.
#
#      (xr)                  scratch
#      (xl)                  ptr to next character
#      (wa)                  current scan offset
#      (wb)                  *dvubs (0 if scanning name,const)
#      (wc)                  =opdvs (0 if scanning constant)
#
scn06:  movzx edi,byte ptr [esi] #get next character} lch xr (xl)+
        inc  esi
        inc  ecx            #bump scan offset} icv wa
        mov  dword ptr scnpt,ecx #store offset past char scanned} mov wa scnpt
        cmp  edi,cfp_u      #switch on scanned character} bsw xr cfp_u scn07
        jge  scn07
        jmp  dword ptr l0018[edi*4]
        dseg_
l0018:
#
#      switch table for switch on character
#
                            #} ejc
        .eject
#
#      scane (continued)
#
                            #} ejc
        .eject
#
#      scane (continued)
#
        .long scn07         #} iff 0 scn07
        .long scn07         #} iff 1 scn07
        .long scn07         #} iff 2 scn07
        .long scn07         #} iff 3 scn07
        .long scn07         #} iff 4 scn07
        .long scn07         #} iff 5 scn07
        .long scn07         #} iff 6 scn07
        .long scn07         #} iff 7 scn07
        .long scn07         #} iff 8 scn07
        .long scn05         #horizontal tab} iff ch_ht scn05
        .long scn07         #} iff 10 scn07
        .long scn07         #} iff 11 scn07
        .long scn07         #} iff 12 scn07
        .long scn07         #} iff 13 scn07
        .long scn07         #} iff 14 scn07
        .long scn07         #} iff 15 scn07
        .long scn07         #} iff 16 scn07
        .long scn07         #} iff 17 scn07
        .long scn07         #} iff 18 scn07
        .long scn07         #} iff 19 scn07
        .long scn07         #} iff 20 scn07
        .long scn07         #} iff 21 scn07
        .long scn07         #} iff 22 scn07
        .long scn07         #} iff 23 scn07
        .long scn07         #} iff 24 scn07
        .long scn07         #} iff 25 scn07
        .long scn07         #} iff 26 scn07
        .long scn07         #} iff 27 scn07
        .long scn07         #} iff 28 scn07
        .long scn07         #} iff 29 scn07
        .long scn07         #} iff 30 scn07
        .long scn07         #} iff 31 scn07
        .long scn05         #blank} iff ch_bl scn05
        .long scn37         #exclamation mark} iff ch_ex scn37
        .long scn17         #double quote} iff ch_dq scn17
        .long scn41         #number sign} iff ch_nm scn41
        .long scn36         #dollar} iff ch_dl scn36
        .long scn38         #percent} iff ch_pc scn38
        .long scn44         #ampersand} iff ch_am scn44
        .long scn16         #single quote} iff ch_sq scn16
        .long scn25         #left paren} iff ch_pp scn25
        .long scn26         #right paren} iff ch_rp scn26
        .long scn49         #asterisk} iff ch_as scn49
        .long scn33         #plus} iff ch_pl scn33
        .long scn31         #comma} iff ch_cm scn31
        .long scn34         #minus} iff ch_mn scn34
        .long scn32         #dot} iff ch_dt scn32
        .long scn40         #slash} iff ch_sl scn40
        .long scn08         #digit 0} iff ch_d0 scn08
        .long scn08         #digit 1} iff ch_d1 scn08
        .long scn08         #digit 2} iff ch_d2 scn08
        .long scn08         #digit 3} iff ch_d3 scn08
        .long scn08         #digit 4} iff ch_d4 scn08
        .long scn08         #digit 5} iff ch_d5 scn08
        .long scn08         #digit 6} iff ch_d6 scn08
        .long scn08         #digit 7} iff ch_d7 scn08
        .long scn08         #digit 8} iff ch_d8 scn08
        .long scn08         #digit 9} iff ch_d9 scn08
        .long scn29         #colon} iff ch_cl scn29
        .long scn30         #semi-colon} iff ch_sm scn30
        .long scn28         #left bracket} iff ch_bb scn28
        .long scn46         #equal} iff ch_eq scn46
        .long scn27         #right bracket} iff ch_rb scn27
        .long scn45         #question mark} iff ch_qu scn45
        .long scn42         #at} iff ch_at scn42
        .long scn09         #letter a} iff ch_la scn09
        .long scn09         #letter b} iff ch_lb scn09
        .long scn09         #letter c} iff ch_lc scn09
        .long scn09         #letter d} iff ch_ld scn09
        .long scn09         #letter e} iff ch_le scn09
        .long scn20         #letter f} iff ch_lf scn20
        .long scn09         #letter g} iff ch_lg scn09
        .long scn09         #letter h} iff ch_lh scn09
        .long scn09         #letter i} iff ch_li scn09
        .long scn09         #letter j} iff ch_lj scn09
        .long scn09         #letter k} iff ch_lk scn09
        .long scn09         #letter l} iff ch_ll scn09
        .long scn09         #letter m} iff ch_lm scn09
        .long scn09         #letter n} iff ch_ln scn09
        .long scn09         #letter o} iff ch_lo scn09
        .long scn09         #letter p} iff ch_lp scn09
        .long scn09         #letter q} iff ch_lq scn09
        .long scn09         #letter r} iff ch_lr scn09
        .long scn21         #letter s} iff ch_ls scn21
        .long scn09         #letter t} iff ch_lt scn09
        .long scn09         #letter u} iff ch_lu scn09
        .long scn09         #letter v} iff ch_lv scn09
        .long scn09         #letter w} iff ch_lw scn09
        .long scn09         #letter x} iff ch_lx scn09
        .long scn09         #letter y} iff ch_ly scn09
        .long scn09         #letter z} iff ch_l_ scn09
        .long scn28         #left bracket} iff ch_ob scn28
        .long scn07         #} iff 92 scn07
        .long scn27         #right bracket} iff ch_cb scn27
        .long scn37         #up arrow} iff ch_ey scn37
        .long scn24         #underline} iff ch_un scn24
        .long scn07         #} iff 96 scn07
        .long scn09         #shifted a} iff ch__a scn09
        .long scn09         #shifted b} iff ch__b scn09
        .long scn09         #shifted c} iff ch__c scn09
        .long scn09         #shifted d} iff ch__d scn09
        .long scn09         #shifted e} iff ch__e scn09
        .long scn20         #shifted f} iff ch__f scn20
        .long scn09         #shifted g} iff ch__g scn09
        .long scn09         #shifted h} iff ch__h scn09
        .long scn09         #shifted i} iff ch__i scn09
        .long scn09         #shifted j} iff ch__j scn09
        .long scn09         #shifted k} iff ch__k scn09
        .long scn09         #shifted l} iff ch__l scn09
        .long scn09         #shifted m} iff ch__m scn09
        .long scn09         #shifted n} iff ch__n scn09
        .long scn09         #shifted o} iff ch__o scn09
        .long scn09         #shifted p} iff ch__p scn09
        .long scn09         #shifted q} iff ch__q scn09
        .long scn09         #shifted r} iff ch__r scn09
        .long scn21         #shifted s} iff ch__s scn21
        .long scn09         #shifted t} iff ch__t scn09
        .long scn09         #shifted u} iff ch__u scn09
        .long scn09         #shifted v} iff ch__v scn09
        .long scn09         #shifted w} iff ch__w scn09
        .long scn09         #shifted x} iff ch__x scn09
        .long scn09         #shifted y} iff ch__y scn09
        .long scn09         #shifted z} iff ch___ scn09
        .long scn07         #} iff 123 scn07
        .long scn43         #vertical bar} iff ch_br scn43
        .long scn07         #} iff 125 scn07
        .long scn35         #not} iff ch_nt scn35
        .long scn07         #} iff 127 scn07
        dsegend_            #end switch on character} esw
        cseg_
#
#      here for illegal character (underline merges)
#
scn07:  or   ebx,ebx        #jump if scanning name or constant} bze wb scn10
        jz   short scn10 # (jump shortened)
        call err_0          #} erb 230 syntax error: illegal character
        .byte 230
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here for digits 0-9
#
scn08:  or   ebx,ebx        #keep scanning if name/constant} bze wb scn09
        jz   short scn09 # (jump shortened)
        xor  edx,edx        #else set flag for scanning constant} zer wc
#
#      here for letter. loop here when scanning name/constant
#
scn09:  cmp  ecx,dword ptr scnil #jump if end of image} beq wa scnil scn11
        je   short scn11 # (jump shortened)
        xor  ebx,ebx        #set flag for scanning name/const} zer wb
        jmp  scn06          #merge back to continue scan} brn scn06
#
#      come here for delimiter ending name or constant
#
scn10:  dec  ecx            #reset offset to point to delimiter} dcv wa
#
#      come here after finishing scan of name or constant
#
scn11:  mov  dword ptr scnpt,ecx #store updated scan offset} mov wa scnpt
        mov  ebx,dword ptr scnse #point to start of element} mov scnse wb
        sub  ecx,ebx        #get number of characters} sub wb wa
        mov  esi,dword ptr r_cim #point to line image} mov r_cim xl
        or   edx,edx        #jump if name} bnz wc scn15
        jnz  scn15
#
#      here after scanning out numeric constant
#
        call sbstr          #get string for constant} jsr sbstr
        mov  dword ptr dnamp,edi #delete from storage (not needed)} mov xr dnamp
        call gtnum          #convert to numeric} jsr gtnum
        .short scn14-dffnc  #jump if conversion failure} ppm scn14
#
#      merge here to exit with constant
#
scn12:  mov  esi,t_con      #set result type of constant} mov =t_con xl
                            #} ejc
        .eject
#
#      scane (continued)
#
#      common exit point (xr,xl) set
#
scn13:  mov  ecx,dword ptr scnsa #restore ecx} mov scnsa wa
        mov  ebx,dword ptr scnsb #restore ebx} mov scnsb wb
        mov  edx,dword ptr scnsc #restore edx} mov scnsc wc
        mov  dword ptr r_scp,edi #save edi in case rescan} mov xr r_scp
        mov  dword ptr scntp,esi #save esi in case rescan} mov xl scntp
        xor  eax,eax        #reset possible goto flag} zer scngo
        mov  dword ptr scngo,eax
        ret                 #return to scane caller} exi
#
#      here if conversion error on numeric item
#
scn14:  call err_0          #} erb 231 syntax error: invalid numeric item
        .byte 231
#
#      here after scanning out variable name
#
scn15:  call sbstr          #build string name of variable} jsr sbstr
        cmp  dword ptr dword ptr scncc,0 #return if cncrd call} bnz scncc scn13
        jnz  scn13
        call gtnvr          #locate/build vrblk} jsr gtnvr
        .short err_-299-dffnc #dummy (unused) error return} ppm
        mov  esi,t_var      #set type as variable} mov =t_var xl
        jmp  scn13          #back to exit} brn scn13
#
#      here for single quote (start of string constant)
#
scn16:  or   ebx,ebx        #terminator if scanning name or cnst} bze wb scn10
        jz   scn10
        mov  ebx,ch_sq      #set terminator as single quote} mov =ch_sq wb
        jmp  short scn18          #merge} brn scn18 # (jump shortened)
#
#      here for double quote (start of string constant)
#
scn17:  or   ebx,ebx        #terminator if scanning name or cnst} bze wb scn10
        jz   scn10
        mov  ebx,ch_dq      #set double quote terminator, merge} mov =ch_dq wb
#
#      loop to scan out string constant
#
scn18:  cmp  ecx,dword ptr scnil #error if end of image} beq wa scnil scn19
        je   short scn19 # (jump shortened)
        movzx edx,byte ptr [esi] #else load next character} lch wc (xl)+
        inc  esi
        inc  ecx            #bump offset} icv wa
        cmp  edx,ebx        #loop back if not terminator} bne wc wb scn18
        jne  scn18
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here after scanning out string constant
#
        mov  ebx,dword ptr scnpt #point to first character} mov scnpt wb
        mov  dword ptr scnpt,ecx #save offset past final quote} mov wa scnpt
        dec  ecx            #point back past last character} dcv wa
        sub  ecx,ebx        #get number of characters} sub wb wa
        mov  esi,dword ptr r_cim #point to input image} mov r_cim xl
        call sbstr          #build substring value} jsr sbstr
        jmp  scn12          #back to exit with constant result} brn scn12
#
#      here if no matching quote found
#
scn19:  mov  dword ptr scnpt,ecx #set updated scan pointer} mov wa scnpt
        call err_0          #} erb 232 syntax error: unmatched string quote
        .byte 232
#
#      here for f (possible failure goto)
#
scn20:  mov  edi,t_fgo      #set return code for fail goto} mov =t_fgo xr
        jmp  short scn22          #jump to merge} brn scn22 # (jump shortened)
#
#      here for s (possible success goto)
#
scn21:  mov  edi,t_sgo      #set success goto as return code} mov =t_sgo xr
#
#      special goto cases merge here
#
scn22:  cmp  dword ptr dword ptr scngo,0 #treat as normal letter if not goto} bze scngo scn09
        jz   scn09
#
#      merge here for special character exit
#
scn23:  or   ebx,ebx        #jump if end of name/constant} bze wb scn10
        jz   scn10
        mov  esi,edi        #else copy code} mov xr xl
        jmp  scn13          #and jump to exit} brn scn13
#
#      here for underline
#
scn24:  or   ebx,ebx        #part of name if scanning name} bze wb scn09
        jz   scn09
        jmp  scn07          #else illegal} brn scn07
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here for left paren
#
scn25:  mov  edi,t_lpr      #set left paren return code} mov =t_lpr xr
        or   ebx,ebx        #return left paren unless name} bnz wb scn23
        jnz  scn23
        or   edx,edx        #delimiter if scanning constant} bze wc scn10
        jz   scn10
#
#      here for left paren after name (function call)
#
        mov  ebx,dword ptr scnse #point to start of name} mov scnse wb
        mov  dword ptr scnpt,ecx #set pointer past left paren} mov wa scnpt
        dec  ecx            #point back past last char of name} dcv wa
        sub  ecx,ebx        #get name length} sub wb wa
        mov  esi,dword ptr r_cim #point to input image} mov r_cim xl
        call sbstr          #get string name for function} jsr sbstr
        call gtnvr          #locate/build vrblk} jsr gtnvr
        .short err_-299-dffnc #dummy (unused) error return} ppm
        mov  esi,t_fnc      #set code for function call} mov =t_fnc xl
        jmp  scn13          #back to exit} brn scn13
#
#      processing for special characters
#
scn26:  mov  edi,t_rpr      #right paren, set code} mov =t_rpr xr
        jmp  scn23          #take special character exit} brn scn23
#
scn27:  mov  edi,t_rbr      #right bracket, set code} mov =t_rbr xr
        jmp  scn23          #take special character exit} brn scn23
#
scn28:  mov  edi,t_lbr      #left bracket, set code} mov =t_lbr xr
        jmp  scn23          #take special character exit} brn scn23
#
scn29:  mov  edi,t_col      #colon, set code} mov =t_col xr
        jmp  scn23          #take special character exit} brn scn23
#
scn30:  mov  edi,t_smc      #semi-colon, set code} mov =t_smc xr
        jmp  scn23          #take special character exit} brn scn23
#
scn31:  mov  edi,t_cma      #comma, set code} mov =t_cma xr
        jmp  scn23          #take special character exit} brn scn23
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here for operators. on entry, wc points to the table of
#      operator dope vectors and wb is the increment to step
#      to the next pair (binary/unary) of dope vectors in the
#      list. on reaching scn46, the pointer has been adjusted to
#      point to the appropriate pair of dope vectors.
#      the first three entries are special since they can occur
#      as part of a variable name (.) or constant (.+-).
#
scn32:  or   ebx,ebx        #dot can be part of name or constant} bze wb scn09
        jz   scn09
        add  edx,ebx        #else bump pointer} add wb wc
#
scn33:  or   edx,edx        #plus can be part of constant} bze wc scn09
        jz   scn09
        or   ebx,ebx        #plus cannot be part of name} bze wb scn48
        jz   scn48
        add  edx,ebx        #else bump pointer} add wb wc
#
scn34:  or   edx,edx        #minus can be part of constant} bze wc scn09
        jz   scn09
        or   ebx,ebx        #minus cannot be part of name} bze wb scn48
        jz   scn48
        add  edx,ebx        #else bump pointer} add wb wc
#
scn35:  add  edx,ebx        #not} add wb wc
scn36:  add  edx,ebx        #dollar} add wb wc
scn37:  add  edx,ebx        #exclamation} add wb wc
scn38:  add  edx,ebx        #percent} add wb wc
scn39:  add  edx,ebx        #asterisk} add wb wc
scn40:  add  edx,ebx        #slash} add wb wc
scn41:  add  edx,ebx        #number sign} add wb wc
scn42:  add  edx,ebx        #at sign} add wb wc
scn43:  add  edx,ebx        #vertical bar} add wb wc
scn44:  add  edx,ebx        #ampersand} add wb wc
scn45:  add  edx,ebx        #question mark} add wb wc
#
#      all operators come here (equal merges directly)
#      (wc) points to the binary/unary pair of operator dvblks.
#
scn46:  or   ebx,ebx        #operator terminates name/constant} bze wb scn10
        jz   scn10
        mov  edi,edx        #else copy dv pointer} mov wc xr
        movzx edx,byte ptr [esi] #load next character} lch wc (xl)
        mov  esi,t_bop      #set binary op in case} mov =t_bop xl
        cmp  ecx,dword ptr scnil #should be binary if image end} beq wa scnil scn47
        je   scn47
        cmp  edx,ch_bl      #should be binary if followed by blk} beq wc =ch_bl scn47
        je   short scn47 # (jump shortened)
        cmp  edx,ch_ht      #jump if horizontal tab} beq wc =ch_ht scn47
        je   short scn47 # (jump shortened)
        cmp  edx,ch_sm      #semicolon can immediately follow =} beq wc =ch_sm scn47
        je   short scn47 # (jump shortened)
        cmp  edx,ch_cl      #colon can immediately follow =} beq wc =ch_cl scn47
        je   short scn47 # (jump shortened)
        cmp  edx,ch_rp      #right paren can immediately follow =} beq wc =ch_rp scn47
        je   short scn47 # (jump shortened)
        cmp  edx,ch_rb      #right bracket can immediately follow =} beq wc =ch_rb scn47
        je   short scn47 # (jump shortened)
        cmp  edx,ch_cb      #right bracket can immediately follow =} beq wc =ch_cb scn47
        je   short scn47 # (jump shortened)
#
#      here for unary operator
#
        add  edi,4*dvbs_    #point to dv for unary op} add *dvbs_ xr
        mov  esi,t_uop      #set type for unary operator} mov =t_uop xl
        cmp  dword ptr scntp,t_uok #ok unary if ok preceding element} ble scntp =t_uok scn13
        jbe  scn13
                            #} ejc
        .eject
#
#      scane (continued)
#
#      merge here to require preceding blanks
#
scn47:  cmp  dword ptr dword ptr scnbl,0 #all ok if preceding blanks, exit} bnz scnbl scn13
        jnz  scn13
#
#      fail operator in this position
#
scn48:  call err_0          #} erb 233 syntax error: invalid use of operator
        .byte 233
#
#      here for asterisk, could be ** substitute for exclamation
#
scn49:  or   ebx,ebx        #end of name if scanning name} bze wb scn10
        jz   scn10
        cmp  ecx,dword ptr scnil #not ** if * at image end} beq wa scnil scn39
        je   scn39
        mov  edi,ecx        #else save offset past first *} mov wa xr
        mov  dword ptr scnof,ecx #save another copy} mov wa scnof
        movzx ecx,byte ptr [esi] #load next character} lch wa (xl)+
        inc  esi
        cmp  ecx,ch_as      #not ** if next char not *} bne wa =ch_as scn50
        jne  short scn50 # (jump shortened)
        inc  edi            #else step offset past second *} icv xr
        cmp  edi,dword ptr scnil #ok exclam if end of image} beq xr scnil scn51
        je   short scn51 # (jump shortened)
        movzx ecx,byte ptr [esi] #else load next character} lch wa (xl)
        cmp  ecx,ch_bl      #exclamation if blank} beq wa =ch_bl scn51
        je   short scn51 # (jump shortened)
        cmp  ecx,ch_ht      #exclamation if horizontal tab} beq wa =ch_ht scn51
        je   short scn51 # (jump shortened)
#
#      unary *
#
scn50:  mov  ecx,dword ptr scnof #recover stored offset} mov scnof wa
        mov  esi,dword ptr r_cim #point to line again} mov r_cim xl
        lea  esi,[cfp_f+esi+ecx] #point to current char} plc xl wa
        jmp  scn39          #merge with unary *} brn scn39
#
#      here for ** as substitute for exclamation
#
scn51:  mov  dword ptr scnpt,edi #save scan pointer past 2nd *} mov xr scnpt
        mov  ecx,edi        #copy scan pointer} mov xr wa
        jmp  scn37          #merge with exclamation} brn scn37
                            #end procedure scane} enp
                            #} ejc
        .eject
#
#      scngf -- scan goto field
#
#      scngf is called from cmpil to scan and analyze a goto
#      field including the surrounding brackets or parentheses.
#      for a normal goto, the result returned is either a vrblk
#      pointer for a simple label operand, or a pointer to an
#      expression tree with a special outer unary operator
#      (o$goc). for a direct goto, the result returned is a
#      pointer to an expression tree with the special outer
#      unary operator o$god.
#
#      jsr  scngf            call to scan goto field
#      (xr)                  result (see above)
#      (xl,wa,wb,wc)         destroyed
#
scngf:                      #entry point} prc e 0
        .global scngf
        call scane          #scan initial element} jsr scane
        cmp  esi,t_lpr      #skip if left paren (normal goto)} beq xl =t_lpr scng1
        je   short scng1 # (jump shortened)
        cmp  esi,t_lbr      #skip if left bracket (direct goto)} beq xl =t_lbr scng2
        je   short scng2 # (jump shortened)
        call err_0          #} erb 234 syntax error: goto field incorrect
        .byte 234
#
#      here for left paren (normal goto)
#
scng1:  mov  ebx,num01      #set expan flag for normal goto} mov =num01 wb
        call expan          #analyze goto field} jsr expan
        mov  ecx,offset opdvn #point to opdv for complex goto} mov =opdvn wa
        cmp  edi,dword ptr statb #jump if not in static (sgd15)} ble xr statb scng3
        jbe  short scng3 # (jump shortened)
        cmp  edi,dword ptr state #jump to exit if simple label name} blo xr state scng4
        jb   short scng4 # (jump shortened)
        jmp  short scng3          #complex goto - merge} brn scng3 # (jump shortened)
#
#      here for left bracket (direct goto)
#
scng2:  mov  ebx,num02      #set expan flag for direct goto} mov =num02 wb
        call expan          #scan goto field} jsr expan
        mov  ecx,offset opdvd #set opdv pointer for direct goto} mov =opdvd wa
                            #} ejc
        .eject
#
#      scngf (continued)
#
#      merge here to build outer unary operator block
#
scng3:  push ecx            #stack operator dv pointer} mov wa -(xs)
        push edi            #stack pointer to expression tree} mov xr -(xs)
        call expop          #pop operator off} jsr expop
        pop  edi            #reload new expression tree pointer} mov (xs)+ xr
#
#      common exit point
#
scng4:  ret                 #return to caller} exi
                            #end procedure scngf} enp
                            #} ejc
        .eject
#
#      setvr -- set vrget,vrsto fields of vrblk
#
#      setvr sets the proper values in the vrget and vrsto
#      fields of a vrblk. it is called whenever trblks are
#      added or subtracted (trace,stoptr,input,output,detach)
#
#      (xr)                  pointer to vrblk
#      jsr  setvr            call to set fields
#      (xl,wa)               destroyed
#
#      note that setvr ignores the call if xr does not point
#      into the static region (i.e. is some other name base)
#
setvr:                      #entry point} prc e 0
        .global setvr
        cmp  edi,dword ptr state #exit if not natural variable} bhi xr state setv1
        ja   short setv1 # (jump shortened)
#
#      here if we have a vrblk
#
        mov  esi,edi        #copy vrblk pointer} mov xr xl
        mov  dword ptr (4*vrget)[edi],offset b_vrl #store normal get value} mov =b_vrl vrget(xr)
        cmp  dword ptr (4*vrsto)[edi],offset b_vre #skip if protected variable} beq vrsto(xr) =b_vre setv1
        je   short setv1 # (jump shortened)
        mov  dword ptr (4*vrsto)[edi],offset b_vrs #store normal store value} mov =b_vrs vrsto(xr)
        mov  esi,dword ptr (4*vrval)[esi] #point to next entry on chain} mov vrval(xl) xl
        cmp  dword ptr [esi],offset b_trt #jump if end of trblk chain} bne (xl) =b_trt setv1
        jne  short setv1 # (jump shortened)
        mov  dword ptr (4*vrget)[edi],offset b_vra #store trapped routine address} mov =b_vra vrget(xr)
        mov  dword ptr (4*vrsto)[edi],offset b_vrv #set trapped routine address} mov =b_vrv vrsto(xr)
#
#      merge here to exit to caller
#
setv1:  ret                 #return to setvr caller} exi
                            #end procedure setvr} enp
                            #} ejc
        .eject
#
#      sorta -- sort array
#
#      routine to sort an array or table on same basis as in
#      sitbol. a table is converted to an array, leaving two
#      dimensional arrays and vectors as cases to be considered.
#      whole rows of arrays are permuted according to the
#      ordering of the keys they contain, and the stride
#      referred to, is the the length of a row. it is one
#      for a vector.
#      the sort used is heapsort, fundamentals of data structure
#      horowitz and sahni, pitman 1977, page 347.
#      it is an order n*log(n) algorithm. in order
#      to make it stable, comparands may not compare equal. this
#      is achieved by sorting a copy array (referred to as the
#      sort array) containing at its high address end, byte
#      offsets to the rows to be sorted held in the original
#      array (referred to as the key array). sortc, the
#      comparison routine, accesses the keys through these
#      offsets and in the case of equality, resolves it by
#      comparing the offsets themselves. the sort permutes the
#      offsets which are then used in a final operation to copy
#      the actual items into the new array in sorted order.
#      references to zeroth item are to notional item
#      preceding first actual item.
#      reverse sorting for rsort is done by having the less than
#      test for keys effectively be replaced by a
#      greater than test.
#
#      1(xs)                 first arg - array or table
#      0(xs)                 2nd arg - index or pdtype name
#      (wa)                  0 , non-zero for sort , rsort
#      jsr  sorta            call to sort array
#      ppm  loc              transfer loc if table is empty
#      (xr)                  sorted array
#      (xl,wa,wb,wc)         destroyed
                            #} ejc
        .eject
#
#      sorta (continued)
#
sorta:                      #entry point} prc n 1
        .global sorta
        pop  prc_+60
        mov  dword ptr srtsr,ecx #sort/rsort indicator} mov wa srtsr
        mov  dword ptr srtst,4*num01 #default stride of 1} mov *num01 srtst
        xor  eax,eax        #default zero offset to sort key} zer srtof
        mov  dword ptr srtof,eax
        mov  dword ptr srtdf,offset nulls #clear datatype field name} mov =nulls srtdf
        pop  dword ptr r_sxr #unstack argument 2} mov (xs)+ r_sxr
        pop  edi            #get first argument} mov (xs)+ xr
        mov  ecx,esp        #use key/values of table entries} mnz wa
        call gtarr          #convert to array} jsr gtarr
        .short srt18-dffnc  #signal that table is empty} ppm srt18
        .short srt16-dffnc  #error if non-convertable} ppm srt16
        push edi            #stack ptr to resulting key array} mov xr -(xs)
        push edi            #another copy for copyb} mov xr -(xs)
        call copyb          #get copy array for sorting into} jsr copyb
        .short err_-299-dffnc #cant fail} ppm
        push edi            #stack pointer to sort array} mov xr -(xs)
        mov  edi,dword ptr r_sxr #get second arg} mov r_sxr xr
        mov  esi,dword ptr (4*num01)[esp] #get ptr to key array} mov num01(xs) xl
        cmp  dword ptr [esi],offset b_vct #jump if arblk} bne (xl) =b_vct srt02
        jne  short srt02 # (jump shortened)
        cmp  edi,offset nulls #jump if null second arg} beq xr =nulls srt01
        je   short srt01 # (jump shortened)
        call gtnvr          #get vrblk ptr for it} jsr gtnvr
        .short err_-257-dffnc #} err 257 erroneous 2nd arg in sort/rsort of vector
        mov  dword ptr srtdf,edi #store datatype field name vrblk} mov xr srtdf
#
#      compute n and offset to item a(0) in vector case
#
srt01:  mov  edx,4*vclen    #offset to a(0)} mov *vclen wc
        mov  ebx,4*vcvls    #offset to first item} mov *vcvls wb
        mov  ecx,dword ptr (4*vclen)[esi] #get block length} mov vclen(xl) wa
        sub  ecx,4*vcsi_    #get no. of entries, n (in bytes)} sub *vcsi_ wa
        jmp  srt04          #merge} brn srt04
#
#      here for array
#
srt02:  mov  edx,dword ptr (4*ardim)[esi] #get possible dimension} ldi ardim(xl)
        mov  ecx,edx        #convert to short integer} mfi wa
        sal  ecx,2          #further convert to baus} wtb wa
        mov  ebx,4*arvls    #offset to first value if one} mov *arvls wb
        mov  edx,4*arpro    #offset before values if one dim.} mov *arpro wc
        cmp  dword ptr (4*arndm)[esi],num01 #jump in fact if one dim.} beq arndm(xl) =num01 srt04
        je   srt04
        cmp  dword ptr (4*arndm)[esi],num02 #fail unless two dimens} bne arndm(xl) =num02 srt16
        jne  srt16
        mov  edx,dword ptr (4*arlb2)[esi] #get lower bound 2 as default} ldi arlb2(xl)
        cmp  edi,offset nulls #jump if default second arg} beq xr =nulls srt03
        je   short srt03 # (jump shortened)
        call gtint          #convert to integer} jsr gtint
        .short srt17-dffnc  #fail} ppm srt17
        mov  edx,dword ptr (4*icval)[edi] #get actual integer value} ldi icval(xr)
                            #} ejc
        .eject
#
#      sorta (continued)
#
#      here with sort column index in ia in array case
#
srt03:  sub  edx,dword ptr (4*arlb2)[esi] #subtract low bound} sbi arlb2(xl)
        jo   srt17          #fail if overflow} iov srt17
        or   edx,edx        #fail if below low bound} ilt srt17
        jl   srt17
        sub  edx,dword ptr (4*ardm2)[esi] #check against dimension} sbi ardm2(xl)
#        or   edx,edx        #fail if too large} ige srt17   (optimized)
        jge  srt17
        add  edx,dword ptr (4*ardm2)[esi] #restore value} adi ardm2(xl)
        mov  ecx,edx        #get as small integer} mfi wa
        sal  ecx,2          #offset within row to key} wtb wa
        mov  dword ptr srtof,ecx #keep offset} mov wa srtof
        mov  edx,dword ptr (4*ardm2)[esi] #second dimension is row length} ldi ardm2(xl)
        mov  ecx,edx        #convert to short integer} mfi wa
        mov  edi,ecx        #copy row length} mov wa xr
        sal  ecx,2          #convert to bytes} wtb wa
        mov  dword ptr srtst,ecx #store as stride} mov wa srtst
        mov  edx,dword ptr (4*ardim)[esi] #get number of rows} ldi ardim(xl)
        mov  ecx,edx        #as a short integer} mfi wa
        sal  ecx,2          #convert n to baus} wtb wa
        mov  edx,dword ptr (4*arlen)[esi] #offset past array end} mov arlen(xl) wc
        sub  edx,ecx        #adjust, giving space for n offsets} sub wa wc
        sub  edx,4          #point to a(0)} dca wc
        mov  ebx,dword ptr (4*arofs)[esi] #offset to word before first item} mov arofs(xl) wb
        add  ebx,4          #offset to first item} ica wb
#
#      separate pre-processing for arrays and vectors done.
#      to simplify later key comparisons, removal of any trblk
#      trap blocks from entries in key array is effected.
#
#      (xl) = 1(xs) = pointer to key array
#      (xs) = pointer to sort array
#      wa = number of items, n (converted to bytes).
#      wb = offset to first item of arrays.
#      wc = offset to a(0)
#
srt04:  cmp  ecx,4*num01    #return if only a single item} ble wa *num01 srt15
        jbe  srt15
        mov  dword ptr srtsn,ecx #store number of items (in baus)} mov wa srtsn
        mov  dword ptr srtso,edx #store offset to a(0)} mov wc srtso
        mov  edx,dword ptr (4*arlen)[esi] #length of array or vec (=vclen)} mov arlen(xl) wc
        add  edx,esi        #point past end of array or vector} add xl wc
        mov  dword ptr srtsf,ebx #store offset to first row} mov wb srtsf
        add  esi,ebx        #point to first item in key array} add wb xl
#
#      loop through array
#
srt05:  mov  edi,dword ptr [esi] #get an entry} mov (xl) xr
#
#      hunt along trblk chain
#
srt06:  cmp  dword ptr [edi],offset b_trt #jump out if not trblk} bne (xr) =b_trt srt07
        jne  short srt07 # (jump shortened)
        mov  edi,dword ptr (4*trval)[edi] #get value field} mov trval(xr) xr
        jmp  srt06          #loop} brn srt06
                            #} ejc
        .eject
#
#      sorta (continued)
#
#      xr is value from end of chain
#
srt07:  mov  dword ptr [esi],edi #store as array entry} mov xr (xl)+
        lea  esi,[esi+4]
        cmp  esi,edx        #loop if not done} blt xl wc srt05
        jb   srt05
        mov  esi,dword ptr [esp] #get adrs of sort array} mov (xs) xl
        mov  edi,dword ptr srtsf #initial offset to first key} mov srtsf xr
        mov  ebx,dword ptr srtst #get stride} mov srtst wb
        add  esi,dword ptr srtso #offset to a(0)} add srtso xl
        add  esi,4          #point to a(1)} ica xl
        mov  edx,dword ptr srtsn #get n} mov srtsn wc
        shr  edx,2          #convert from bytes} btw wc
        mov  dword ptr srtnr,edx #store as row count} mov wc srtnr
#
#      store key offsets at top of sort array
#
srt08:  mov  dword ptr [esi],edi #store an offset} mov xr (xl)+
        lea  esi,[esi+4]
        add  edi,ebx        #bump offset by stride} add wb xr
        dec  edx            #loop through rows} bct wc srt08
        jnz  srt08
#
#      perform the sort on offsets in sort array.
#
#      (srtsn)               number of items to sort, n (bytes)
#      (srtso)               offset to a(0)
#
srt09:  mov  ecx,dword ptr srtsn #get n} mov srtsn wa
        mov  edx,dword ptr srtnr #get number of rows} mov srtnr wc
        shr  edx,1          #i = n / 2 (edx=i, index into array)} rsh wc 1
        sal  edx,2          #convert back to bytes} wtb wc
#
#      loop to form initial heap
#
srt10:  call sorth          #sorth(i,n)} jsr sorth
        sub  edx,4          #i = i - 1} dca wc
#        or   edx,edx        #loop if i gt 0} bnz wc srt10  (optimized)
        jnz  srt10
        mov  edx,ecx        #i = n} mov wa wc
#
#      sorting loop. at this point, a(1) is the largest
#      item, since algorithm initialises it as, and then maintains
#      it as, root of tree.
#
srt11:  sub  edx,4          #i = i - 1 (n - 1 initially)} dca wc
#        or   edx,edx        #jump if done} bze wc srt12  (optimized)
        jz   short srt12 # (jump shortened)
        mov  edi,dword ptr [esp] #get sort array address} mov (xs) xr
        add  edi,dword ptr srtso #point to a(0)} add srtso xr
        mov  esi,edi        #a(0) address} mov xr xl
        add  esi,edx        #a(i) address} add wc xl
        mov  ebx,dword ptr (4*num01)[esi] #copy a(i+1)} mov num01(xl) wb
        mov  eax,dword ptr (4*num01)[edi] #move a(1) to a(i+1)} mov num01(xr) num01(xl)
        mov  dword ptr (4*num01)[esi],eax
        mov  dword ptr (4*num01)[edi],ebx #complete exchange of a(1), a(i+1)} mov wb num01(xr)
        mov  ecx,edx        #n = i for sorth} mov wc wa
        mov  edx,4*num01    #i = 1 for sorth} mov *num01 wc
        call sorth          #sorth(1,n)} jsr sorth
        mov  edx,ecx        #restore edx} mov wa wc
        jmp  srt11          #loop} brn srt11
                            #} ejc
        .eject
#
#      sorta (continued)
#
#      offsets have been permuted into required order by sort.
#      copy array elements over them.
#
srt12:  mov  edi,dword ptr [esp] #base adrs of key array} mov (xs) xr
        mov  edx,edi        #copy it} mov xr wc
        add  edx,dword ptr srtso #offset of a(0)} add srtso wc
        add  edi,dword ptr srtsf #adrs of first row of sort array} add srtsf xr
        mov  ebx,dword ptr srtst #get stride} mov srtst wb
#
#      copying loop for successive items. sorted offsets are
#      held at end of sort array.
#
srt13:  add  edx,4          #adrs of next of sorted offsets} ica wc
        mov  esi,edx        #copy it for access} mov wc xl
        mov  esi,dword ptr [esi] #get offset} mov (xl) xl
        add  esi,dword ptr (4*num01)[esp] #add key array base adrs} add num01(xs) xl
        mov  ecx,ebx        #get count of characters in row} mov wb wa
        shr  ecx,2          #copy a complete row} mvw
        rep  movsd
        dec  dword ptr srtnr #decrement row count} dcv srtnr
        cmp  dword ptr dword ptr srtnr,0 #repeat till all rows done} bnz srtnr srt13
        jnz  srt13
#
#      return point
#
srt15:  pop  edi            #pop result array ptr} mov (xs)+ xr
        add  esp,4          #pop key array ptr} ica xs
        xor  eax,eax        #clear junk} zer r_sxl
        mov  dword ptr r_sxl,eax
        xor  eax,eax        #clear junk} zer r_sxr
        mov  dword ptr r_sxr,eax
        mov  eax,prc_+60    #return} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      error point
#
srt16:  call err_1          #} erb 256 sort/rsort 1st arg not suitable array or table
        .byte 0
srt17:  call err_1          #} erb 258 sort/rsort 2nd arg out of range or non-integer
        .byte 2
#
#      return point if input table is empty
#
srt18:  mov  eax,prc_+60    #return indication of null table} exi 1
        jmp  exi__1
                            #end procudure sorta} enp
                            #} ejc
        .eject
#
#      sortc --  compare sort keys
#
#      compare two sort keys given their offsets. if
#      equal, compare key offsets to give stable sort.
#      note that if srtsr is non-zero (request for reverse
#      sort), the quoted returns are inverted.
#      for objects of differing datatypes, the entry point
#      identifications are compared.
#
#      (xl)                  base adrs for keys
#      (wa)                  offset to key 1 item
#      (wb)                  offset to key 2 item
#      (srtsr)               zero/non-zero for sort/rsort
#      (srtof)               offset within row to comparands
#      jsr  sortc            call to compare keys
#      ppm  loc              key1 less than key2
#                            normal return, key1 gt than key2
#      (xl,xr,wa,wb)         destroyed
#
sortc:                      #entry point} prc e 1
        .global sortc
        mov  dword ptr srts1,ecx #save offset 1} mov wa srts1
        mov  dword ptr srts2,ebx #save offset 2} mov wb srts2
        mov  dword ptr srtsc,edx #save edx} mov wc srtsc
        add  esi,dword ptr srtof #add offset to comparand field} add srtof xl
        mov  edi,esi        #copy base + offset} mov xl xr
        add  esi,ecx        #add key1 offset} add wa xl
        add  edi,ebx        #add key2 offset} add wb xr
        mov  esi,dword ptr [esi] #get key1} mov (xl) xl
        mov  edi,dword ptr [edi] #get key2} mov (xr) xr
        cmp  dword ptr srtdf,offset nulls #jump if datatype field name used} bne srtdf =nulls src12
        jne  src12
                            #} ejc
        .eject
#
#      sortc (continued)
#
#      merge after dealing with field name. try for strings.
#
src01:  mov  edx,dword ptr [esi] #get type code} mov (xl) wc
        cmp  edx,dword ptr [edi] #skip if not same datatype} bne wc (xr) src02
        jne  short src02 # (jump shortened)
        cmp  edx,offset b_scl #jump if both strings} beq wc =b_scl src09
        je   src09
        cmp  edx,offset b_icl #jump if both integers} beq wc =b_icl src14
        je   short src14 # (jump shortened)
#
#      datatypes different.  now try for numeric
#
src02:  mov  dword ptr r_sxl,esi #keep arg1} mov xl r_sxl
        mov  dword ptr r_sxr,edi #keep arg2} mov xr r_sxr
        cmp  edx,offset b_scl #do not allow conversion to number} beq wc =b_scl src11
        je   src11
        cmp  dword ptr [edi],offset b_scl #if either arg is a string} beq (xr) =b_scl src11
        je   src11
src14:  push esi            #stack} mov xl -(xs)
        push edi            #args} mov xr -(xs)
        call acomp          #compare objects} jsr acomp
        .short src10-dffnc  #not numeric} ppm src10
        .short src10-dffnc  #not numeric} ppm src10
        .short src03-dffnc  #key1 less} ppm src03
        .short src08-dffnc  #keys equal} ppm src08
        .short src05-dffnc  #key1 greater} ppm src05
#
#      return if key1 smaller (sort), greater (rsort)
#
src03:  cmp  dword ptr dword ptr srtsr,0 #jump if rsort} bnz srtsr src06
        jnz  short src06 # (jump shortened)
#
src04:  mov  edx,dword ptr srtsc #restore edx} mov srtsc wc
        pop  eax            #return} exi 1
        jmp  exi__1
#
#      return if key1 greater (sort), smaller (rsort)
#
src05:  cmp  dword ptr dword ptr srtsr,0 #jump if rsort} bnz srtsr src04
        jnz  src04
#
src06:  mov  edx,dword ptr srtsc #restore edx} mov srtsc wc
        pop  eax            #return} exi
        lea  eax,[eax+2]
        jmp  eax
#
#      keys are of same datatype
#
src07:  cmp  esi,edi        #item first created is less} blt xl xr src03
        jb   src03
        cmp  esi,edi        #addresses rise in order of creation} bgt xl xr src05
        ja   src05
#
#      drop through or merge for identical or equal objects
#
src08:  mov  eax,dword ptr srts1 #test offsets or key addrss instead} blt srts1 srts2 src04
        cmp  eax,dword ptr srts2
        jb   src04
        jmp  src06          #offset 1 greater} brn src06
                            #} ejc
        .eject
#
#      sortc (continued)
#
#      strings
#
src09:  push esi            #stack} mov xl -(xs)
        push edi            #args} mov xr -(xs)
        call lcomp          #compare objects} jsr lcomp
        .short err_-299-dffnc #cant} ppm
        .short err_-299-dffnc #fail} ppm
        .short src03-dffnc  #key1 less} ppm src03
        .short src08-dffnc  #keys equal} ppm src08
        .short src05-dffnc  #key1 greater} ppm src05
#
#      arithmetic comparison failed - recover args
#
src10:  mov  esi,dword ptr r_sxl #get arg1} mov r_sxl xl
        mov  edi,dword ptr r_sxr #get arg2} mov r_sxr xr
        mov  edx,dword ptr [esi] #get type of key1} mov (xl) wc
        cmp  edx,dword ptr [edi] #jump if keys of same type} beq wc (xr) src07
        je   src07
#
#      here to compare datatype ids
#
src11:  mov  esi,edx        #get block type word} mov wc xl
        mov  edi,dword ptr [edi] #get block type word} mov (xr) xr
        movzx esi,byte ptr [esi-1] #entry point id for key1} lei xl
        movzx edi,byte ptr [edi-1] #entry point id for key2} lei xr
        cmp  esi,edi        #jump if key1 gt key2} bgt xl xr src05
        ja   src05
        jmp  src03          #key1 lt key2} brn src03
#
#      datatype field name used
#
src12:  call sortf          #call routine to find field 1} jsr sortf
        push esi            #stack item pointer} mov xl -(xs)
        mov  esi,edi        #get key2} mov xr xl
        call sortf          #find field 2} jsr sortf
        mov  edi,esi        #place as key2} mov xl xr
        pop  esi            #recover key1} mov (xs)+ xl
        jmp  src01          #merge} brn src01
                            #procedure sortc} enp
                            #} ejc
        .eject
#
#      sortf -- find field for sortc
#
#      routine used by sortc to obtain item corresponding
#      to a given field name, if this exists, in a programmer
#      defined object passed as argument.
#      if such a match occurs, record is kept of datatype
#      name, field name and offset to field in order to
#      short-circuit later searches on same type. note that
#      dfblks are stored in static and hence cannot be moved.
#
#      (srtdf)               vrblk pointer of field name
#      (xl)                  possible pdblk pointer
#      jsr  sortf            call to search for field name
#      (xl)                  item found or original pdblk ptr
#      (wc)                  destroyed
#
sortf:                      #entry point} prc e 0
        .global sortf
        cmp  dword ptr [esi],offset b_pdt #return if not pdblk} bne (xl) =b_pdt srtf3
        jne  short srtf3 # (jump shortened)
        push edi            #keep edi} mov xr -(xs)
        mov  edi,dword ptr srtfd #get possible former dfblk ptr} mov srtfd xr
        or   edi,edi        #jump if not} bze xr srtf4
        jz   short srtf4 # (jump shortened)
        cmp  edi,dword ptr (4*pddfp)[esi] #jump if not right datatype} bne xr pddfp(xl) srtf4
        jne  short srtf4 # (jump shortened)
        mov  eax,dword ptr srtdf #jump if not right field name} bne srtdf srtff srtf4
        cmp  eax,dword ptr srtff
        jne  short srtf4 # (jump shortened)
        add  esi,dword ptr srtfo #add offset to required field} add srtfo xl
#
#      here with xl pointing to found field
#
srtf1:  mov  esi,dword ptr [esi] #get item from field} mov (xl) xl
#
#      return point
#
srtf2:  pop  edi            #restore edi} mov (xs)+ xr
#
srtf3:  ret                 #return} exi
                            #} ejc
        .eject
#
#      sortf (continued)
#
#      conduct a search
#
srtf4:  mov  edi,esi        #copy original pointer} mov xl xr
        mov  edi,dword ptr (4*pddfp)[edi] #point to dfblk} mov pddfp(xr) xr
        mov  dword ptr srtfd,edi #keep a copy} mov xr srtfd
        mov  edx,dword ptr (4*fargs)[edi] #get number of fields} mov fargs(xr) wc
        sal  edx,2          #convert to bytes} wtb wc
        add  edi,dword ptr (4*dflen)[edi] #point past last field} add dflen(xr) xr
#
#      loop to find name in pdfblk
#
srtf5:  sub  edx,4          #count down} dca wc
        sub  edi,4          #point in front} dca xr
        mov  eax,dword ptr [edi] #skip out if found} beq (xr) srtdf srtf6
        cmp  eax,dword ptr srtdf
        je   short srtf6 # (jump shortened)
        or   edx,edx        #loop} bnz wc srtf5
        jnz  srtf5
        jmp  srtf2          #return - not found} brn srtf2
#
#      found
#
srtf6:  mov  eax,dword ptr [edi] #keep field name ptr} mov (xr) srtff
        mov  dword ptr srtff,eax
        add  edx,4*pdfld    #add offset to first field} add *pdfld wc
        mov  dword ptr srtfo,edx #store as field offset} mov wc srtfo
        add  esi,edx        #point to field} add wc xl
        jmp  srtf1          #return} brn srtf1
                            #procedure sortf} enp
                            #} ejc
        .eject
#
#      sorth -- heap routine for sorta
#
#      this routine constructs a heap from elements of array, a.
#      in this application, the elements are offsets to keys in
#      a key array.
#
#      (xs)                  pointer to sort array base
#      1(xs)                 pointer to key array base
#      (wa)                  max array index, n (in bytes)
#      (wc)                  offset j in a to root (in *1 to *n)
#      jsr  sorth            call sorth(j,n) to make heap
#      (xl,xr,wb)            destroyed
#
sorth:                      #entry point} prc n 0
        .global sorth
        pop  prc_+64
        mov  dword ptr srtsn,ecx #save n} mov wa srtsn
        mov  dword ptr srtwc,edx #keep edx} mov wc srtwc
        mov  esi,dword ptr [esp] #sort array base adrs} mov (xs) xl
        add  esi,dword ptr srtso #add offset to a(0)} add srtso xl
        add  esi,edx        #point to a(j)} add wc xl
        mov  eax,dword ptr [esi] #get offset to root} mov (xl) srtrt
        mov  dword ptr srtrt,eax
        add  edx,edx        #double j - cant exceed n} add wc wc
#
#      loop to move down tree using doubled index j
#
srh01:  cmp  edx,dword ptr srtsn #done if j gt n} bgt wc srtsn srh03
        ja   srh03
        cmp  edx,dword ptr srtsn #skip if j equals n} beq wc srtsn srh02
        je   short srh02 # (jump shortened)
        mov  edi,dword ptr [esp] #sort array base adrs} mov (xs) xr
        mov  esi,dword ptr (4*num01)[esp] #key array base adrs} mov num01(xs) xl
        add  edi,dword ptr srtso #point to a(0)} add srtso xr
        add  edi,edx        #adrs of a(j)} add wc xr
        mov  ecx,dword ptr (4*num01)[edi] #get a(j+1)} mov num01(xr) wa
        mov  ebx,dword ptr [edi] #get a(j)} mov (xr) wb
#
#      compare sons. (wa) right son, (wb) left son
#
        call sortc          #compare keys - lt(a(j+1),a(j))} jsr sortc
        .short srh02-dffnc  #a(j+1) lt a(j)} ppm srh02
        add  edx,4          #point to greater son, a(j+1)} ica wc
                            #} ejc
        .eject
#
#      sorth (continued)
#
#      compare root with greater son
#
srh02:  mov  esi,dword ptr (4*num01)[esp] #key array base adrs} mov num01(xs) xl
        mov  edi,dword ptr [esp] #get sort array address} mov (xs) xr
        add  edi,dword ptr srtso #adrs of a(0)} add srtso xr
        mov  ebx,edi        #copy this adrs} mov xr wb
        add  edi,edx        #adrs of greater son, a(j)} add wc xr
        mov  ecx,dword ptr [edi] #get a(j)} mov (xr) wa
        mov  edi,ebx        #point back to a(0)} mov wb xr
        mov  ebx,dword ptr srtrt #get root} mov srtrt wb
        call sortc          #compare them - lt(a(j),root)} jsr sortc
        .short srh03-dffnc  #father exceeds sons - done} ppm srh03
        mov  edi,dword ptr [esp] #get sort array adrs} mov (xs) xr
        add  edi,dword ptr srtso #point to a(0)} add srtso xr
        mov  esi,edi        #copy it} mov xr xl
        mov  ecx,edx        #copy j} mov wc wa
        shr  edx,2          #convert to words} btw wc
        shr  edx,1          #get j/2} rsh wc 1
        sal  edx,2          #convert back to bytes} wtb wc
        add  esi,ecx        #point to a(j)} add wa xl
        add  edi,edx        #adrs of a(j/2)} add wc xr
        mov  eax,dword ptr [esi] #a(j/2) = a(j)} mov (xl) (xr)
        mov  dword ptr [edi],eax
        mov  edx,ecx        #recover j} mov wa wc
        add  edx,edx        #j = j*2. done if too big} aov wc wc srh03
        jc   short srh03 # (jump shortened)
        jmp  srh01          #loop} brn srh01
#
#      finish by copying root offset back into array
#
srh03:  shr  edx,2          #convert to words} btw wc
        shr  edx,1          #j = j/2} rsh wc 1
        sal  edx,2          #convert back to bytes} wtb wc
        mov  edi,dword ptr [esp] #sort array adrs} mov (xs) xr
        add  edi,dword ptr srtso #adrs of a(0)} add srtso xr
        add  edi,edx        #adrs of a(j/2)} add wc xr
        mov  eax,dword ptr srtrt #a(j/2) = root} mov srtrt (xr)
        mov  dword ptr [edi],eax
        mov  ecx,dword ptr srtsn #restore ecx} mov srtsn wa
        mov  edx,dword ptr srtwc #restore edx} mov srtwc wc
        jmp  [prc_+64]      #return} exi
                            #end procedure sorth} enp
                            #} ejc
        .eject
#
#      trace -- set/reset a trace association
#
#      this procedure is shared by trace and stoptr to
#      either initiate or stop a trace respectively.
#
#      (xl)                  trblk ptr (trace) or zero (stoptr)
#      1(xs)                 first argument (name)
#      0(xs)                 second argument (trace type)
#      jsr  trace            call to set/reset trace
#      ppm  loc              transfer loc if 1st arg is bad name
#      ppm  loc              transfer loc if 2nd arg is bad type
#      (xs)                  popped
#      (xl,xr,wa,wb,wc,ia)   destroyed
#
trace:                      #entry point} prc n 2
        .global trace
        pop  prc_+68
        call gtstg          #get trace type string} jsr gtstg
        .short trc15-dffnc  #jump if not string} ppm trc15
        add  edi,cfp_f      #else point to string} plc xr
        movzx ecx,byte ptr [edi] #load first character} lch wa (xr)
        cmp  cl,'a'         #fold to upper case} flc wa
        jb   short l0019
        cmp  cl,'z'
        ja   short l0019
        sub  cl,32
l0019:
        mov  edi,dword ptr [esp] #load name argument} mov (xs) xr
        mov  dword ptr [esp],esi #stack trblk ptr or zero} mov xl (xs)
        mov  edx,trtac      #set trtyp for access trace} mov =trtac wc
        cmp  ecx,ch_la      #jump if a (access)} beq wa =ch_la trc10
        je   trc10
        mov  edx,trtvl      #set trtyp for value trace} mov =trtvl wc
        cmp  ecx,ch_lv      #jump if v (value)} beq wa =ch_lv trc10
        je   trc10
        cmp  ecx,ch_bl      #jump if blank (value)} beq wa =ch_bl trc10
        je   trc10
#
#      here for l,k,f,c,r
#
        cmp  ecx,ch_lf      #jump if f (function)} beq wa =ch_lf trc01
        je   short trc01 # (jump shortened)
        cmp  ecx,ch_lr      #jump if r (return)} beq wa =ch_lr trc01
        je   short trc01 # (jump shortened)
        cmp  ecx,ch_ll      #jump if l (label)} beq wa =ch_ll trc03
        je   trc03
        cmp  ecx,ch_lk      #jump if k (keyword)} beq wa =ch_lk trc06
        je   trc06
        cmp  ecx,ch_lc      #else error if not c (call)} bne wa =ch_lc trc15
        jne  trc15
#
#      here for f,c,r
#
trc01:  call gtnvr          #point to vrblk for name} jsr gtnvr
        .short trc16-dffnc  #jump if bad name} ppm trc16
        add  esp,4          #pop stack} ica xs
        mov  edi,dword ptr (4*vrfnc)[edi] #point to function block} mov vrfnc(xr) xr
        cmp  dword ptr [edi],offset b_pfc #error if not program function} bne (xr) =b_pfc trc17
        jne  trc17
        cmp  ecx,ch_lr      #jump if r (return)} beq wa =ch_lr trc02
        je   short trc02 # (jump shortened)
                            #} ejc
        .eject
#
#      trace (continued)
#
#      here for f,c to set/reset call trace
#
        mov  dword ptr (4*pfctr)[edi],esi #set/reset call trace} mov xl pfctr(xr)
        cmp  ecx,ch_lc      #exit with null if c (call)} beq wa =ch_lc exnul
        je   exnul
#
#      here for f,r to set/reset return trace
#
trc02:  mov  dword ptr (4*pfrtr)[edi],esi #set/reset return trace} mov xl pfrtr(xr)
        mov  eax,prc_+68    #return} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      here for l to set/reset label trace
#
trc03:  call gtnvr          #point to vrblk} jsr gtnvr
        .short trc16-dffnc  #jump if bad name} ppm trc16
        mov  esi,dword ptr (4*vrlbl)[edi] #load label pointer} mov vrlbl(xr) xl
        cmp  dword ptr [esi],offset b_trt #jump if no old trace} bne (xl) =b_trt trc04
        jne  short trc04 # (jump shortened)
        mov  esi,dword ptr (4*trlbl)[esi] #else delete old trace association} mov trlbl(xl) xl
#
#      here with old label trace association deleted
#
trc04:  cmp  esi,offset stndl #error if undefined label} beq xl =stndl trc16
        je   trc16
        pop  ebx            #get trblk ptr again} mov (xs)+ wb
        or   ebx,ebx        #jump if stoptr case} bze wb trc05
        jz   short trc05 # (jump shortened)
        mov  dword ptr (4*vrlbl)[edi],ebx #else set new trblk pointer} mov wb vrlbl(xr)
        mov  dword ptr (4*vrtra)[edi],offset b_vrt #set label trace routine address} mov =b_vrt vrtra(xr)
        mov  edi,ebx        #copy trblk pointer} mov wb xr
        mov  dword ptr (4*trlbl)[edi],esi #store real label in trblk} mov xl trlbl(xr)
        mov  eax,prc_+68    #return} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      here for stoptr case for label
#
trc05:  mov  dword ptr (4*vrlbl)[edi],esi #store label ptr back in vrblk} mov xl vrlbl(xr)
        mov  dword ptr (4*vrtra)[edi],offset b_vrg #store normal transfer address} mov =b_vrg vrtra(xr)
        mov  eax,prc_+68    #return} exi
        lea  eax,[eax+4]
        jmp  eax
                            #} ejc
        .eject
#
#      trace (continued)
#
#      here for k (keyword)
#
trc06:  call gtnvr          #point to vrblk} jsr gtnvr
        .short trc16-dffnc  #error if not natural var} ppm trc16
        cmp  dword ptr dword ptr (4*vrlen)[edi],0 #error if not system var} bnz vrlen(xr) trc16
        jnz  trc16
        add  esp,4          #pop stack} ica xs
        or   esi,esi        #jump if stoptr case} bze xl trc07
        jz   short trc07 # (jump shortened)
        mov  dword ptr (4*trkvr)[esi],edi #store vrblk ptr in trblk for ktrex} mov xr trkvr(xl)
#
#      merge here with trblk set up in wb (or zero)
#
trc07:  mov  edi,dword ptr (4*vrsvp)[edi] #point to svblk} mov vrsvp(xr) xr
        cmp  edi,offset v_ert #jump if errtype} beq xr =v_ert trc08
        je   short trc08 # (jump shortened)
        cmp  edi,offset v_stc #jump if stcount} beq xr =v_stc trc09
        je   short trc09 # (jump shortened)
        cmp  edi,offset v_fnc #else error if not fnclevel} bne xr =v_fnc trc17
        jne  trc17
#
#      fnclevel
#
        mov  dword ptr r_fnc,esi #set/reset fnclevel trace} mov xl r_fnc
        mov  eax,prc_+68    #return} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      errtype
#
trc08:  mov  dword ptr r_ert,esi #set/reset errtype trace} mov xl r_ert
        mov  eax,prc_+68    #return} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      stcount
#
trc09:  mov  dword ptr r_stc,esi #set/reset stcount trace} mov xl r_stc
        call stgcc          #update countdown counters} jsr stgcc
        mov  eax,prc_+68    #return} exi
        lea  eax,[eax+4]
        jmp  eax
                            #} ejc
        .eject
#
#      trace (continued)
#
#      a,v merge here with trtyp value in wc
#
trc10:  call gtvar          #locate variable} jsr gtvar
        .short trc16-dffnc  #error if not appropriate name} ppm trc16
        pop  ebx            #get new trblk ptr again} mov (xs)+ wb
        add  ecx,esi        #point to variable location} add xl wa
        mov  edi,ecx        #copy variable pointer} mov wa xr
#
#      loop to search trblk chain
#
trc11:  mov  esi,dword ptr [edi] #point to next entry} mov (xr) xl
        cmp  dword ptr [esi],offset b_trt #jump if not trblk} bne (xl) =b_trt trc13
        jne  short trc13 # (jump shortened)
        cmp  edx,dword ptr (4*trtyp)[esi] #jump if too far out on chain} blt wc trtyp(xl) trc13
        jb   short trc13 # (jump shortened)
        cmp  edx,dword ptr (4*trtyp)[esi] #jump if this matches our type} beq wc trtyp(xl) trc12
        je   short trc12 # (jump shortened)
        add  esi,4*trnxt    #else point to link field} add *trnxt xl
        mov  edi,esi        #copy pointer} mov xl xr
        jmp  trc11          #and loop back} brn trc11
#
#      here to delete an old trblk of the type we were given
#
trc12:  mov  esi,dword ptr (4*trnxt)[esi] #get ptr to next block or value} mov trnxt(xl) xl
        mov  dword ptr [edi],esi #store to delete this trblk} mov xl (xr)
#
#      here after deleting any old association of this type
#
trc13:  or   ebx,ebx        #jump if stoptr case} bze wb trc14
        jz   short trc14 # (jump shortened)
        mov  dword ptr [edi],ebx #else link new trblk in} mov wb (xr)
        mov  edi,ebx        #copy trblk pointer} mov wb xr
        mov  dword ptr (4*trnxt)[edi],esi #store forward pointer} mov xl trnxt(xr)
        mov  dword ptr (4*trtyp)[edi],edx #store appropriate trap type code} mov wc trtyp(xr)
#
#      here to make sure vrget,vrsto are set properly
#
trc14:  mov  edi,ecx        #recall possible vrblk pointer} mov wa xr
        sub  edi,4*vrval    #point back to vrblk} sub *vrval xr
        call setvr          #set fields if vrblk} jsr setvr
        mov  eax,prc_+68    #return} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      here for bad trace type
#
trc15:  mov  eax,prc_+68    #take bad trace type error exit} exi 2
        jmp  exi__2
#
#      pop stack before failing
#
trc16:  add  esp,4          #pop stack} ica xs
#
#      here for bad name argument
#
trc17:  mov  eax,prc_+68    #take bad name error exit} exi 1
        jmp  exi__1
                            #end procedure trace} enp
                            #} ejc
        .eject
#
#      trbld -- build trblk
#
#      trblk is used by the input, output and trace functions
#      to construct a trblk (trap block)
#
#      (xr)                  trtag or trter
#      (xl)                  trfnc or trfpt
#      (wb)                  trtyp
#      jsr  trbld            call to build trblk
#      (xr)                  pointer to trblk
#      (wa)                  destroyed
#
trbld:                      #entry point} prc e 0
        .global trbld
        push edi            #stack trtag (or trfnm)} mov xr -(xs)
        mov  ecx,4*trsi_    #set size of trblk} mov *trsi_ wa
        call alloc          #allocate trblk} jsr alloc
        mov  dword ptr [edi],offset b_trt #store first word} mov =b_trt (xr)
        mov  dword ptr (4*trfnc)[edi],esi #store trfnc (or trfpt)} mov xl trfnc(xr)
        pop  dword ptr (4*trtag)[edi] #store trtag (or trfnm)} mov (xs)+ trtag(xr)
        mov  dword ptr (4*trtyp)[edi],ebx #store type} mov wb trtyp(xr)
        mov  dword ptr (4*trval)[edi],offset nulls #for now, a null value} mov =nulls trval(xr)
        ret                 #return to caller} exi
                            #end procedure trbld} enp
                            #} ejc
        .eject
#
#      trimr -- trim trailing blanks
#
#      trimr is passed a pointer to an scblk which must be the
#      last block in dynamic storage. trailing blanks are
#      trimmed off and the dynamic storage pointer reset to
#      the end of the (possibly) shortened block.
#
#      (wb)                  non-zero to trim trailing blanks
#      (xr)                  pointer to string to trim
#      jsr  trimr            call to trim string
#      (xr)                  pointer to trimmed string
#      (xl,wa,wb,wc)         destroyed
#
#      the call with wb zero still performs the end zero pad
#      and dnamp readjustment. it is used from acess if kvtrm=0.
#
trimr:                      #entry point} prc e 0
        .global trimr
        mov  esi,edi        #copy string pointer} mov xr xl
        mov  ecx,dword ptr (4*sclen)[edi] #load string length} mov sclen(xr) wa
        or   ecx,ecx        #jump if null input} bze wa trim2
        jz   short trim2 # (jump shortened)
        lea  esi,[cfp_f+esi+ecx] #else point past last character} plc xl wa
        or   ebx,ebx        #jump if no trim} bze wb trim3
        jz   short trim3 # (jump shortened)
        mov  edx,ch_bl      #load blank character} mov =ch_bl wc
#
#      loop through characters from right to left
#
trim0:  dec  esi            #load next character} lch wb -(xl)
        movzx ebx,byte ptr [esi]
        cmp  ebx,ch_ht      #jump if horizontal tab} beq wb =ch_ht trim1
        je   short trim1 # (jump shortened)
        cmp  ebx,edx        #jump if non-blank found} bne wb wc trim3
        jne  short trim3 # (jump shortened)
trim1:  dec  ecx            #else decrement character count} dcv wa
#        or   ecx,ecx        #loop back if more to check} bnz wa trim0  (optimized)
        jnz  trim0
#
#      here if result is null (null or all-blank input)
#
trim2:  mov  dword ptr dnamp,edi #wipe out input string block} mov xr dnamp
        mov  edi,offset nulls #load null result} mov =nulls xr
        jmp  short trim5          #merge to exit} brn trim5 # (jump shortened)
                            #} ejc
        .eject
#
#      trimr (continued)
#
#      here with non-blank found (merge for no trim)
#
trim3:  mov  dword ptr (4*sclen)[edi],ecx #set new length} mov wa sclen(xr)
        mov  esi,edi        #copy string pointer} mov xr xl
        lea  esi,[cfp_f+esi+ecx] #ready for storing blanks} psc xl wa
        add  ecx,3+4*schar  #get length of block in bytes} ctb wa schar
        and  ecx,-4
        add  ecx,edi        #point past new block} add xr wa
        mov  dword ptr dnamp,ecx #set new top of storage pointer} mov wa dnamp
        mov  ecx,cfp_c      #get count of chars in word} lct wa =cfp_c
        xor  edx,edx        #set zero char} zer wc
#
#      loop to zero pad last word of characters
#
trim4:  mov  [esi],dl       #store zero character} sch wc (xl)+
        inc  esi
        loop trim4          #loop back till all stored} bct wa trim4
#
#      common exit point
#
trim5:  xor  esi,esi        #clear garbage esi pointer} zer xl
        ret                 #return to caller} exi
                            #end procedure trimr} enp
                            #} ejc
        .eject
#
#      trxeq -- execute function type trace
#
#      trxeq is used to execute a trace when a fourth argument
#      has been supplied. trace has already been decremented.
#
#      (xr)                  pointer to trblk
#      (xl,wa)               name base,offset for variable
#      jsr  trxeq            call to execute trace
#      (wb,wc,ra)            destroyed
#
#      the following stack entries are made before passing
#      control to the trace function using the cfunc routine.
#
#                            trxeq return point word(s)
#                            saved value of trace keyword
#                            trblk pointer
#                            name base
#                            name offset
#                            saved value of r$cod
#                            saved code ptr (-r$cod)
#                            saved value of flptr
#      flptr --------------- zero (dummy fail offset)
#                            nmblk for variable name
#      xs ------------------ trace tag
#
#      r$cod and the code ptr are set to dummy values which
#      cause control to return to the trxeq procedure on success
#      or failure (trxeq ignores a failure condition).
#
trxeq:                      #entry point (recursive)} prc r 0
        .global trxeq
        mov  edx,dword ptr r_cod #load code block pointer} mov r_cod wc
        mov  ebx,ebp        #get current code pointer} scp wb
        sub  ebx,edx        #make code pointer into offset} sub wc wb
        push dword ptr kvtra #stack trace keyword value} mov kvtra -(xs)
        push edi            #stack trblk pointer} mov xr -(xs)
        push esi            #stack name base} mov xl -(xs)
        push ecx            #stack name offset} mov wa -(xs)
        push edx            #stack code block pointer} mov wc -(xs)
        push ebx            #stack code pointer offset} mov wb -(xs)
        push dword ptr flptr #stack old failure pointer} mov flptr -(xs)
        push 0              #set dummy fail offset} zer -(xs)
        mov  dword ptr flptr,esp #set new failure pointer} mov xs flptr
        xor  eax,eax        #reset trace keyword to zero} zer kvtra
        mov  dword ptr kvtra,eax
        mov  edx,offset trxdc #load new (dummy) code blk pointer} mov =trxdc wc
        mov  dword ptr r_cod,edx #set as code block pointer} mov wc r_cod
        mov  ebp,edx        #and new code pointer} lcp wc
                            #} ejc
        .eject
#
#      trxeq (continued)
#
#      now prepare arguments for function
#
        mov  ebx,ecx        #save name offset} mov wa wb
        mov  ecx,4*nmsi_    #load nmblk size} mov *nmsi_ wa
        call alloc          #allocate space for nmblk} jsr alloc
        mov  dword ptr [edi],offset b_nml #set type word} mov =b_nml (xr)
        mov  dword ptr (4*nmbas)[edi],esi #store name base} mov xl nmbas(xr)
        mov  dword ptr (4*nmofs)[edi],ebx #store name offset} mov wb nmofs(xr)
        mov  esi,dword ptr (4*6)[esp] #reload pointer to trblk} mov 6(xs) xl
        push edi            #stack nmblk pointer (1st argument)} mov xr -(xs)
        push dword ptr (4*trtag)[esi] #stack trace tag (2nd argument)} mov trtag(xl) -(xs)
        mov  esi,dword ptr (4*trfnc)[esi] #load trace vrblk pointer} mov trfnc(xl) xl
        mov  esi,dword ptr (4*vrfnc)[esi] #load trace function pointer} mov vrfnc(xl) xl
        cmp  esi,offset stndf #jump if not a defined function} beq xl =stndf trxq2
        je   short trxq2 # (jump shortened)
        mov  ecx,num02      #set number of arguments to two} mov =num02 wa
        jmp  cfunc          #jump to call function} brn cfunc
#
#      see o$txr for details of return to this point
#
trxq1:  mov  esp,dword ptr flptr #point back to our stack entries} mov flptr xs
        add  esp,4          #pop off garbage fail offset} ica xs
        pop  dword ptr flptr #restore old failure pointer} mov (xs)+ flptr
        pop  ebx            #reload code offset} mov (xs)+ wb
        pop  edx            #load old code base pointer} mov (xs)+ wc
        mov  edi,edx        #copy cdblk pointer} mov wc xr
        mov  eax,dword ptr (4*cdstm)[edi] #restore stmnt no} mov cdstm(xr) kvstn
        mov  dword ptr kvstn,eax
        pop  ecx            #reload name offset} mov (xs)+ wa
        pop  esi            #reload name base} mov (xs)+ xl
        pop  edi            #reload trblk pointer} mov (xs)+ xr
        pop  dword ptr kvtra #restore trace keyword value} mov (xs)+ kvtra
        add  ebx,edx        #recompute absolute code pointer} add wc wb
        mov  ebp,ebx        #restore code pointer} lcp wb
        mov  dword ptr r_cod,edx #and code block pointer} mov wc r_cod
        ret                 #return to trxeq caller} exi
#
#      here if the target function is not defined
#
trxq2:  call err_0          #} erb 197 trace fourth arg is not function name or null
        .byte 197
#
                            #end procedure trxeq} enp
                            #} ejc
        .eject
#
#      xscan -- execution function argument scan
#
#      xscan scans out one token in a prototype argument in
#      array,clear,data,define,load function calls. xscan
#      calls must be preceded by a call to the initialization
#      procedure xscni. the following variables are used.
#
#      r$xsc                 pointer to scblk for function arg
#      xsofs                 offset (num chars scanned so far)
#
#      (wa)                  non-zero to skip and trim blanks
#      (wc)                  delimiter one (ch$xx)
#      (xl)                  delimiter two (ch$xx)
#      jsr  xscan            call to scan next item
#      (xr)                  pointer to scblk for token scanned
#      (wa)                  completion code (see below)
#      (wc,xl)               destroyed
#
#      the scan starts from the current position and continues
#      until one of the following three conditions occurs.
#
#      1)   delimiter one is encountered  (wa set to 1)
#
#      2)   delimiter two encountered  (wa set to 2)
#
#      3)   end of string encountered  (wa set to 0)
#
#      the result is a string containing all characters scanned
#      up to but not including any delimiter character.
#      the pointer is left pointing past the delimiter.
#
#      if only one delimiter is to be detected, delimiter one
#      and delimiter two should be set to the same value.
#
#      in the case where the end of string is encountered, the
#      string includes all the characters to the end of the
#      string. no further calls can be made to xscan until
#      xscni is called to initialize a new argument scan
                            #} ejc
        .eject
#
#      xscan (continued)
#
xscan:                      #entry point} prc e 0
        .global xscan
        mov  dword ptr xscwb,ebx #preserve ebx} mov wb xscwb
        push ecx            #record blank skip flag} mov wa -(xs)
        push ecx            #and second copy} mov wa -(xs)
        mov  edi,dword ptr r_xsc #point to argument string} mov r_xsc xr
        mov  ecx,dword ptr (4*sclen)[edi] #load string length} mov sclen(xr) wa
        mov  ebx,dword ptr xsofs #load current offset} mov xsofs wb
        sub  ecx,ebx        #get number of remaining characters} sub wb wa
#        or   ecx,ecx        #jump if no characters left} bze wa xscn3  (optimized)
        jz   xscn3
        lea  edi,[cfp_f+edi+ebx] #point to current character} plc xr wb
#
#      loop to search for delimiter
#
xscn1:  movzx ebx,byte ptr [edi] #load next character} lch wb (xr)+
        inc  edi
        cmp  ebx,edx        #jump if delimiter one found} beq wb wc xscn4
        je   xscn4
        cmp  ebx,esi        #jump if delimiter two found} beq wb xl xscn5
        je   xscn5
        cmp  dword ptr dword ptr [esp],0 #jump if not skipping blanks} bze (xs) xscn2
        jz   short xscn2 # (jump shortened)
        inc  dword ptr xsofs #assume blank and delete it} icv xsofs
        cmp  ebx,ch_ht      #jump if horizontal tab} beq wb =ch_ht xscn2
        je   short xscn2 # (jump shortened)
        cmp  ebx,ch_bl      #jump if blank} beq wb =ch_bl xscn2
        je   short xscn2 # (jump shortened)
        dec  dword ptr xsofs #undelete non-blank character} dcv xsofs
        xor  eax,eax        #and discontinue blank checking} zer (xs)
        mov  dword ptr [esp],eax
#
#      here after performing any leading blank trimming.
#
xscn2:  dec  ecx            #decrement count of chars left} dcv wa
#        or   ecx,ecx        #loop back if more chars to go} bnz wa xscn1  (optimized)
        jnz  xscn1
#
#      here for runout
#
xscn3:  mov  esi,dword ptr r_xsc #point to string block} mov r_xsc xl
        mov  ecx,dword ptr (4*sclen)[esi] #get string length} mov sclen(xl) wa
        mov  ebx,dword ptr xsofs #load offset} mov xsofs wb
        sub  ecx,ebx        #get substring length} sub wb wa
        xor  eax,eax        #clear string ptr for collector} zer r_xsc
        mov  dword ptr r_xsc,eax
        xor  eax,eax        #set zero (runout) return code} zer xscrt
        mov  dword ptr xscrt,eax
        jmp  xscn7          #jump to exit} brn xscn7
                            #} ejc
        .eject
#
#      xscan (continued)
#
#      here if delimiter one found
#
xscn4:  mov  dword ptr xscrt,num01 #set return code} mov =num01 xscrt
        jmp  short xscn6          #jump to merge} brn xscn6 # (jump shortened)
#
#      here if delimiter two found
#
xscn5:  mov  dword ptr xscrt,num02 #set return code} mov =num02 xscrt
#
#      merge here after detecting a delimiter
#
xscn6:  mov  esi,dword ptr r_xsc #reload pointer to string} mov r_xsc xl
        mov  edx,dword ptr (4*sclen)[esi] #get original length of string} mov sclen(xl) wc
        sub  edx,ecx        #minus chars left = chars scanned} sub wa wc
        mov  ecx,edx        #move to reg for sbstr} mov wc wa
        mov  ebx,dword ptr xsofs #set offset} mov xsofs wb
        sub  ecx,ebx        #compute length for sbstr} sub wb wa
        inc  edx            #adjust new cursor past delimiter} icv wc
        mov  dword ptr xsofs,edx #store new offset} mov wc xsofs
#
#      common exit point
#
xscn7:  xor  edi,edi        #clear garbage character ptr in edi} zer xr
        call sbstr          #build sub-string} jsr sbstr
        add  esp,4          #remove copy of blank flag} ica xs
        pop  ebx            #original blank skip/trim flag} mov (xs)+ wb
        cmp  dword ptr dword ptr (4*sclen)[edi],0 #cannot trim the null string} bze sclen(xr) xscn8
        jz   short xscn8 # (jump shortened)
        call trimr          #trim trailing blanks if requested} jsr trimr
#
#      final exit point
#
xscn8:  mov  ecx,dword ptr xscrt #load return code} mov xscrt wa
        mov  ebx,dword ptr xscwb #restore ebx} mov xscwb wb
        ret                 #return to xscan caller} exi
                            #end procedure xscan} enp
                            #} ejc
        .eject
#
#      xscni -- execution function argument scan
#
#      xscni initializes the scan used for prototype arguments
#      in the clear, define, load, data, array functions. see
#      xscan for the procedure which is used after this call.
#
#      -(xs)                 argument to be scanned (on stack)
#      jsr  xscni            call to scan argument
#      ppm  loc              transfer loc if arg is not string
#      ppm  loc              transfer loc if argument is null
#      (xs)                  popped
#      (xr,r$xsc)            argument (scblk ptr)
#      (wa)                  argument length
#      (ia,ra)               destroyed
#
xscni:                      #entry point} prc n 2
        .global xscni
        pop  prc_+72
        call gtstg          #fetch argument as string} jsr gtstg
        .short xsci1-dffnc  #jump if not convertible} ppm xsci1
        mov  dword ptr r_xsc,edi #else store scblk ptr for xscan} mov xr r_xsc
        xor  eax,eax        #set offset to zero} zer xsofs
        mov  dword ptr xsofs,eax
        or   ecx,ecx        #jump if null string} bze wa xsci2
        jz   short xsci2 # (jump shortened)
        mov  eax,prc_+72    #return to xscni caller} exi
        lea  eax,[eax+4]
        jmp  eax
#
#      here if argument is not a string
#
xsci1:  mov  eax,prc_+72    #take not-string error exit} exi 1
        jmp  short exi__1 # (jump shortened)
#
#      here for null string
#
xsci2:  mov  eax,prc_+72    #take null-string error exit} exi 2
        jmp  short exi__2 # (jump shortened)
                            #end procedure xscni} enp
                            #} ttl s p i t b o l -- stack overflow section
        .sbttl "s p i t b o l -- stack overflow section"
#
#      control comes here if the main stack overflows
#
                            #start of stack overflow section} sec
exi__1: movsx eax,word ptr [eax+0]
        add  eax,offset dffnc
        push eax
        xor  eax,eax
        ret
exi__2: movsx eax,word ptr [eax+2]
        add  eax,offset dffnc
        push eax
        xor  eax,eax
        ret
exi__3: movsx eax,word ptr [eax+4]
        add  eax,offset dffnc
        push eax
        xor  eax,eax
        ret
exi__4: movsx eax,word ptr [eax+6]
        add  eax,offset dffnc
        push eax
        xor  eax,eax
        ret
exi__5: movsx eax,word ptr [eax+8]
        add  eax,offset dffnc
        push eax
        xor  eax,eax
        ret
exi__6: movsx eax,word ptr [eax+10]
        add  eax,offset dffnc
        push eax
        xor  eax,eax
        ret
exi__7: movsx eax,word ptr [eax+12]
        add  eax,offset dffnc
        push eax
        xor  eax,eax
        ret
        .global sec06
sec06:
#
        add  dword ptr errft,num04 #force conclusive fatal error} add =num04 errft
        mov  esp,dword ptr flptr #pop stack to avoid more fails} mov flptr xs
        cmp  dword ptr dword ptr gbcfl,0 #jump if garbage collecting} bnz gbcfl stak1
        jnz  short stak1 # (jump shortened)
        call err_0          #} erb 246 stack overflow
        .byte 246
#
#      no chance of recovery in mid garbage collection
#
stak1:  mov  edi,offset endso #point to message} mov =endso xr
        xor  eax,eax        #memory is undumpable} zer kvdmp
        mov  dword ptr kvdmp,eax
        jmp  stopr          #give up} brn stopr
                            #} ttl s p i t b o l -- error section
        .sbttl "s p i t b o l -- error section"
#
#      this section of code is entered whenever a procedure
#      return via an err parameter or an erb opcode is obeyed.
#
#      (wa)                  is the error code
#
#      the global variable stage indicates the point at which
#      the error occured as follows.
#
#      stage=stgic           error during initial compile
#
#      stage=stgxc           error during compile at execute
#                            time (code, convert function calls)
#
#      stage=stgev           error during compilation of
#                            expression at execution time
#                            (eval, convert function call).
#
#      stage=stgxt           error at execute time. compiler
#                            not active.
#
#      stage=stgce           error during initial compile after
#                            scanning out the end line.
#
#      stage=stgxe           error during compile at execute
#                            time after scanning end line.
#
#      stage=stgee           error during expression evaluation
#
                            #start of error section} sec
err_0:  pop  eax
        movzx eax,byte ptr [eax]
        jmp  short err_1a
err_1:  pop  eax
        movzx eax,byte ptr [eax]
        add  eax,256
err_1a: jmp  err_
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
        inc  eax
err_:   xchg ecx,eax
        .global sec07
sec07:
#
error:  cmp  dword ptr r_cim,offset cmlab #jump if error in scanning label} beq r_cim =cmlab cmple
        je   cmple
        mov  dword ptr kvert,ecx #save error code} mov wa kvert
        xor  eax,eax        #reset rescan switch for scane} zer scnrs
        mov  dword ptr scnrs,eax
        xor  eax,eax        #reset goto switch for scane} zer scngo
        mov  dword ptr scngo,eax
        mov  dword ptr polcs,num01 #reset poll count} mov =num01 polcs
        mov  dword ptr polct,num01 #reset poll count} mov =num01 polct
        mov  edi,dword ptr stage #load current stage} mov stage xr
        jmp  dword ptr l0020[edi*4] #jump to appropriate error circuit} bsw xr stgno
        dseg_
l0020:
        .long err01         #initial compile} iff stgic err01
        .long err04         #execute time compile} iff stgxc err04
        .long err04         #eval compiling expr.} iff stgev err04
        .long err05         #execute time} iff stgxt err05
        .long err01         #compile - after end} iff stgce err01
        .long err04         #xeq compile-past end} iff stgxe err04
        .long err04         #eval evaluating expr} iff stgee err04
        dsegend_            #end switch on error type} esw
        cseg_
                            #} ejc
        .eject
#
#      error during initial compile
#
#      the error message is printed as part of the compiler
#      output. this printout includes the offending line (if not
#      printed already) and an error flag under the appropriate
#      column as indicated by scnse unless scnse is set to zero.
#
#      after printing the message, the generated code is
#      modified to an error call and control is returned to
#      the cmpil procedure after resetting the stack pointer.
#
#      if the error occurs after the end line, control returns
#      in a slightly different manner to ensure proper cleanup.
#
err01:  mov  esp,dword ptr cmpxs #reset stack pointer} mov cmpxs xs
                            #restore s-r stack ptr for cmpil} ssl cmpss
        cmp  dword ptr dword ptr errsp,0 #jump if error suppress flag set} bnz errsp err03
        jnz  err03
        mov  edx,dword ptr cmpsn #current statement} mov cmpsn wc
        call filnm          #obtain file name for this statement} jsr filnm
        mov  ebx,dword ptr scnse #column number} mov scnse wb
        mov  edx,dword ptr rdcln #line number} mov rdcln wc
        mov  edi,dword ptr stage #} mov stage xr
        call sysea          #advise system of error} jsr sysea
        .short erra3-dffnc  #if system does not want print} ppm erra3
        push edi            #save any provided print message} mov xr -(xs)
        mov  eax,dword ptr erich #set flag for listr} mov erich erlst
        mov  dword ptr erlst,eax
        call listr          #list line} jsr listr
        call prtis          #terminate listing} jsr prtis
        xor  eax,eax        #clear listr flag} zer erlst
        mov  dword ptr erlst,eax
        mov  ecx,dword ptr scnse #load scan element offset} mov scnse wa
        or   ecx,ecx        #skip if not set} bze wa err02
        jz   err02
        mov  ebx,ecx        #loop counter} lct wb wa
        inc  ecx            #increase for ch_ex} icv wa
        mov  esi,dword ptr r_cim #point to bad statement} mov r_cim xl
        call alocs          #string block for error flag} jsr alocs
        mov  ecx,edi        #remember string ptr} mov xr wa
        add  edi,cfp_f      #ready for character storing} psc xr
        add  esi,cfp_f      #ready to get chars} plc xl
#
#      loop to replace all chars but tabs by blanks
#
erra1:  movzx edx,byte ptr [esi] #get next char} lch wc (xl)+
        inc  esi
        cmp  edx,ch_ht      #skip if tab} beq wc =ch_ht erra2
        je   short erra2 # (jump shortened)
        mov  edx,ch_bl      #get a blank} mov =ch_bl wc
                            #} ejc
        .eject
#
#      merge to store blank or tab in error line
#
erra2:  mov  al,dl          #store char} sch wc (xr)+
        stosb
        dec  ebx            #loop} bct wb erra1
        jnz  erra1
        mov  esi,ch_ex      #exclamation mark} mov =ch_ex xl
        mov  eax,esi        #store at end of error line} sch xl (xr)
        mov  [edi],al
        mov  dword ptr profs,stnpd #allow for statement number} mov =stnpd profs
        mov  edi,ecx        #point to error line} mov wa xr
        call prtst          #print error line} jsr prtst
#
#      here after placing error flag as required
#
err02:  call prtis          #print blank line} jsr prtis
        pop  edi            #restore any sysea message} mov (xs)+ xr
        or   edi,edi        #did sysea provide message to print} bze xr erra0
        jz   short erra0 # (jump shortened)
        call prtst          #print sysea message} jsr prtst
erra0:  call ermsg          #generate flag and error message} jsr ermsg
        add  dword ptr lstlc,num03 #bump page ctr for blank, error, blk} add =num03 lstlc
erra3:  xor  edi,edi        #in case of fatal error} zer xr
        cmp  dword ptr errft,num03 #pack up if several fatals} bhi errft =num03 stopr
        ja   stopr
#
#      count error, inhibit execution if required
#
        inc  dword ptr cmerc #bump error count} icv cmerc
        mov  eax,dword ptr cswer #inhibit xeq if -noerrors} add cswer noxeq
        add  dword ptr noxeq,eax
        cmp  dword ptr stage,stgic #special return if after end line} bne stage =stgic cmp10
        jne  cmp10
                            #} ejc
        .eject
#
#      loop to scan to end of statement
#
err03:  mov  edi,dword ptr r_cim #point to start of image} mov r_cim xr
        add  edi,cfp_f      #point to first char} plc xr
        movzx edi,byte ptr [edi] #get first char} lch xr (xr)
        cmp  edi,ch_mn      #jump if error in control card} beq xr =ch_mn cmpce
        je   cmpce
        xor  eax,eax        #clear rescan flag} zer scnrs
        mov  dword ptr scnrs,eax
        mov  dword ptr errsp,esp #set error suppress flag} mnz errsp
        call scane          #scan next element} jsr scane
        cmp  esi,t_smc      #loop back if not statement end} bne xl =t_smc err03
        jne  err03
        xor  eax,eax        #clear error suppress flag} zer errsp
        mov  dword ptr errsp,eax
#
#      generate error call in code and return to cmpil
#
        mov  dword ptr cwcof,4*cdcod #reset offset in ccblk} mov *cdcod cwcof
        mov  ecx,offset ocer_ #load compile error call} mov =ocer_ wa
        call cdwrd          #generate it} jsr cdwrd
        mov  eax,dword ptr cwcof #set success fill in offset} mov cwcof cmsoc(xs)
        mov  dword ptr (4*cmsoc)[esp],eax
        mov  dword ptr (4*cmffc)[esp],esp #set failure fill in flag} mnz cmffc(xs)
        call cdwrd          #generate succ. fill in word} jsr cdwrd
        jmp  cmpse          #merge to generate error as cdfal} brn cmpse
#
#      error during execute time compile or expression evaluatio
#
#      execute time compilation is initiated through gtcod or
#      gtexp which are called by compile, code or eval.
#      before causing statement failure through exfal it is
#      helpful to set keyword errtext and for generality
#      these errors may be handled by the setexit mechanism.
#
err04:  cmp  dword ptr errft,num03 #abort if too many fatal errors} bge errft =num03 labo1
        jae  labo1
        cmp  dword ptr kvert,nm320 #treat user interrupt specially} beq kvert =nm320 err06
        je   err06
        xor  eax,eax        #forget garbage code block} zer r_ccb
        mov  dword ptr r_ccb,eax
        mov  dword ptr cwcof,4*cccod #set initial offset (mbe catspaw)} mov *cccod cwcof
                            #restore main prog s-r stack ptr} ssl iniss
        call ertex          #get fail message text} jsr ertex
        sub  esp,4          #ensure stack ok on loop start} dca xs
#
#      pop stack until find flptr for most deeply nested prog.
#      defined function call or call of eval / code.
#
erra4:  add  esp,4          #pop stack} ica xs
        cmp  esp,dword ptr flprt #jump if prog defined fn call found} beq xs flprt errc4
        je   short errc4 # (jump shortened)
        cmp  esp,dword ptr gtcef #loop if not eval or code call yet} bne xs gtcef erra4
        jne  erra4
        mov  dword ptr stage,stgxt #re-set stage for execute} mov =stgxt stage
        mov  eax,dword ptr r_gtc #recover code ptr} mov r_gtc r_cod
        mov  dword ptr r_cod,eax
        mov  dword ptr flptr,esp #restore fail pointer} mov xs flptr
        xor  eax,eax        #forget possible image} zer r_cim
        mov  dword ptr r_cim,eax
        xor  eax,eax        #forget possible include} zer cnind
        mov  dword ptr cnind,eax
#
#      test errlimit
#
errb4:  cmp  dword ptr dword ptr kverl,0 #jump if errlimit non-zero} bnz kverl err07
        jnz  err07
        jmp  exfal          #fail} brn exfal
#
#      return from prog. defined function is outstanding
#
errc4:  mov  esp,dword ptr flptr #restore stack from flptr} mov flptr xs
        jmp  errb4          #merge} brn errb4
                            #} ejc
        .eject
#
#      error at execute time.
#
#      the action taken on an error is as follows.
#
#      if errlimit keyword is zero, an abort is signalled,
#      see coding for system label abort at l$abo.
#
#      otherwise, errlimit is decremented and an errtype trace
#      generated if required. control returns either via a jump
#      to continue (to take the failure exit) or a specified
#      setexit trap is executed and control passes to the trap.
#      if 3 or more fatal errors occur an abort is signalled
#      regardless of errlimit and setexit - looping is all too
#      probable otherwise. fatal errors include stack overflow
#      and exceeding stlimit.
#
err05:                      #restore main prog s-r stack ptr} ssl iniss
        cmp  dword ptr dword ptr dmvch,0 #jump if in mid-dump} bnz dmvch err08
        jnz  err08
#
#      merge here from err08 and err04 (error 320)
#
err06:  cmp  dword ptr dword ptr kverl,0 #abort if errlimit is zero} bze kverl labo1
        jz   labo1
        call ertex          #get fail message text} jsr ertex
#
#      merge from err04
#
err07:  cmp  dword ptr errft,num03 #abort if too many fatal errors} bge errft =num03 labo1
        jae  labo1
        dec  dword ptr kverl #decrement errlimit} dcv kverl
        mov  esi,dword ptr r_ert #load errtype trace pointer} mov r_ert xl
        call ktrex          #generate errtype trace if required} jsr ktrex
        mov  ecx,dword ptr r_cod #get current code block} mov r_cod wa
        mov  dword ptr r_cnt,ecx #set cdblk ptr for continuation} mov wa r_cnt
        mov  ebx,ebp        #current code pointer} scp wb
        sub  ebx,ecx        #offset within code block} sub wa wb
        mov  dword ptr stxoc,ebx #save code ptr offset for scontinue} mov wb stxoc
        mov  edi,dword ptr flptr #set ptr to failure offset} mov flptr xr
        mov  eax,dword ptr [edi] #save failure offset for continue} mov (xr) stxof
        mov  dword ptr stxof,eax
        mov  edi,dword ptr r_sxc #load setexit cdblk pointer} mov r_sxc xr
        or   edi,edi        #continue if no setexit trap} bze xr lcnt1
        jz   lcnt1
        xor  eax,eax        #else reset trap} zer r_sxc
        mov  dword ptr r_sxc,eax
        mov  dword ptr stxvr,offset nulls #reset setexit arg to null} mov =nulls stxvr
        mov  esi,dword ptr [edi] #load ptr to code block routine} mov (xr) xl
        jmp  esi            #execute first trap statement} bri xl
#
#      interrupted partly through a dump whilst store is in a
#      mess so do a tidy up operation. see dumpr for details.
#
err08:  mov  edi,dword ptr dmvch #chain head for affected vrblks} mov dmvch xr
        or   edi,edi        #done if zero} bze xr err06
        jz   err06
        mov  eax,dword ptr [edi] #set next link as chain head} mov (xr) dmvch
        mov  dword ptr dmvch,eax
        call setvr          #restore vrget field} jsr setvr
#
#      label to mark end of code
#
s_yyy:  jmp  err08          #loop through chain} brn err08
                            #} ttl s p i t b o l -- here endeth the code
        .sbttl "s p i t b o l -- here endeth the code"
#
#      end of assembly
#
        .end                #end macro-spitbol assembly} end
