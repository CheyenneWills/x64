/*
Copyright 1987-2012 Robert B. K. Dewar and Mark Emmer.

This file is part of Macro SPITBOL.

    Macro SPITBOL is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Macro SPITBOL is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Macro SPITBOL.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
        Globals.h       All OSINT globals are defined in this file.

        Define GLOBALS in the C module that wishes to have these
        variables defined.  All other modules will see them as externals.
 */
#include	"port.h"
/*
     Global data areas needed by compiler.
*/
int cmdcnt;		/*  command count */
int gblargc;		/*  argc from command line*/
char **gblargv;	/*  argv from command line */
char *uarg = 0;		/*  -u argument from command line*/

/*
    Information to be given to compiler
*/
uword lnsppage = PAGE_DEPTH;	/*  lines per page for listings */
uword pagewdth = PAGE_WIDTH;	/*  width of output line for listings */
long spitflag = DFLT_FLAGS;	/*  flags to be given to compiler */

/*
    Memory variables that control compiler's dynamic area and stack.
*/
uword memincb = CHUNK_B_SIZE;	/*  meminc converted to bytes */
uword databts = HEAP_SIZE * sizeof (word);	/*  max size in bytes of data area  */
char *basemem;		/*  base of dynamic memory */
char *topmem;		/*  current top of dynamic memory */
char *maxmem;		/*  maximum top of dynamic memory */
uword maxsize = OBJECT_SIZE * sizeof (word);	/*  maximum size element in dyn. memory */
uword stacksiz = STACK_SIZE;	/*  maximum size of stack in bytes*/
char *lowsp;		/*  lowest legal sp value */

/*
    Variables that describe access to standard input and output files.
*/
int inpcnt = 0;		/*  number of input files */
char **inpptr = 0;	/*  pointer to input file in argv array */
char *outptr;		/*  pointer to output listing file  */
char *sfn = 0;		/*  current source file name */
int readshell0 = 1;	/*  interlock default reading of fd 0 */
int first_record = 2;	/*  non-zero before first record read */
int executing = 0;	/*  non-zero during execution */
int originp = -1;		/*  dup of original fd 0  */
int curfile = 0;		/*  current file position (swcinp)*/
int errflag = 0;		/*  Nonzero if error in swcoup */
int origoup = 1;		/*  Dup of shell's std output (swcoup)  */
int oupState = 0;		/*  Current state of swcoup */
int nesting = 0;		/*  depth of include file nesting */
int dcdone;		/*  if zysdc has written headlines  */
int provide_name = 1;	/*  sysrd to deliver filename to caller */
char *pathptr;		/*  include file paths */

word bfblksize;
struct ioblk *save_iob;
word in_gbcol = 0;	/* record whether in GBCOL or not */
int mallocSys = 0;	/* Kludgy Intel interlock with malloc and free */
int first_time = -1;	/* Flag for systm.c */
long start_time;	/* record start-up time for systm.c */
char savexl;		/* used by syshs.c */
char savexr;
int inc_fd[INCLUDE_DEPTH];	/* used by sysif.c  */
int fd;		
FILEPOS inc_pos[INCLUDE_DEPTH];

word maxf = -1;		/* number of files specified this way -1 */

/*
        Structure to record i/o files specified on command line
        with /#=filename.
*/
#define Ncmdf   12

typedef struct
{
  word filenum;
  char *fileptr;
} CFile;
CFile cfiles[Ncmdf];	/* Array of structures to record info */

struct ioblk ttyiobin = 
       {0,    /* type word */ 
        IRECSIZ,                /* length */ 
        0,		/* filename */ 
        0,              /* process id */ 
        0,              /* tty BFBLK */ 
        STDERRFD,               /* file descriptor 2  */ 
        IO_INP+IO_OPN+IO_SYS+IO_CIN, /* flg1 */ 
        0,              /* flg2 */ 
        EOL1,           /* end of line char 1 */ 
        EOL2};		/* end of line char 2 */

struct ioblk ttyiobout = 
       {0,   /* type word */ 
        ORECSIZ,           /* length */ 
        0,                 /* filename */ 
        0,                 /* process id */ 
        0,                 /* tty BFBLK */ 
        STDERRFD,              /* file descriptor 2  */ 
        IO_OUP+IO_OPN+IO_SYS+IO_COT+IO_WRC, /* flg1 */ 
        0,                 /* flg2                             */ 
        EOL1,              /* end of line char 1 */ 
        EOL2};		   /* end of line char 2 */

struct ioblk inpiob = 
       {0,             /* type word */ 
        IRECSIZ,       /* length */ 
        0,             /* filename */ 
        0,             /* process id */ 
        0,             /* std input BFBLK */ 
        0,             /* file descriptor 0  */ 
        IO_INP+IO_OPN+IO_SYS,   /* flg1: */ 
        0,             /* flg2:*/ 
        EOL1,          /* end of line char 1 */ 
        EOL2 };	/* end of line char 2 */


struct ioblk oupiob = 
       {0,          /* type word */ 
        ORECSIZ,     /* length */ 
        0,           /* filename */ 
        0,           /* process id */ 
        0,           /* no BFBLK needed */ 
        1,           /* file descriptor 1 */ 
        IO_OUP+IO_OPN+IO_SYS+IO_WRC,  /* flg1: */ 
        0,           /* flg2: */ 
        EOL1,        /* end of line char 1 */ 
        EOL2 };	/* end of line char 2 */

char namebuf[256];
int save_fd0;		/* Hold current fd 0 for swcinp */

#if SAVEFILE
int expanding = 0;	/* non-zero if doing expansion */
int compressing = 0;	/* non-zero if doing expansion */
long extra = 0;
int bufcnt;
unsigned char *bufptr;
int bit_count;
unsigned long bit_buffer;
short int *code_value;	/* This is the code value array             */
short unsigned int *prefix_code;	/* This array holds the prefix codes  */
unsigned char *append_character;	/* This array holds the appended chars  */
unsigned char *decode_stack;	/* This array holds the decoded string  */
unsigned char *buffer;	/* Read/write buffer                                */
#endif /* SAVEFILE */

#if SAVEFILE | EXECFILE
int aoutfd;
FILEPOS fp;
#endif /* SAVEFILE | EXECFILE */

/*
    lmodstk is set when creating a load module.  On the subsequent
    execution of a load module, the presence of a non-zero value in
    lmodstk determines that the execution is indeed of a load module.

    For Intel DOS Extender, lmodstk provides the file position within
        the execution module where a save file begins.
*/
word * lmodstk;


/*
   Globals found in assembly language modules.

 */
extern int reg_size;
extern int hasfpu;
extern char cprtmsg[];
extern word reg_block;

#if ENGINE
/*
   Engine globals
 */
word lastError;
#endif /* ENGINE */
