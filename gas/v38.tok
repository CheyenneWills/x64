*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS FOR USE BY TOKEN.SPT
*      ---------------------------------------------------------
*
*      THIS FILE OF CONDITIONAL SYMBOLS WILL OVERRIDE THE CONDITIONAL
*      DEFINITIONS CONTAINED IN THE SPITBOL MINIMAL FILE.   IN ADDITION,
*      LINES BEGINNING WITH ">" ARE TREATED AS SPITBOL STATEMENTS AND
*      IMMEDIATELY EXECUTED.
*
*      FOR Linux SPITBOL-x86
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL NOT
*                            DEFINED, A FULL COMMENT LINE INDICATES
*                            SYMBOL INITIALLY NOT DEFINED.
*
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CENG                 DEFINE TO INCLUDE ENGINE FEATURES
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CRPP                 DEFINE IF RETURN POINTS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*      .CUSR                 DEFINE TO HAVE SET() USE REAL VALUES
*                             (MUST ALSO #DEFINE SETREAL 1 IN SYSTYPE.H)
*
{{TTL{27,L I C E N S E -- SOFTWARE LICENSE FOR THIS PROGRAM{{{{77
*
*     Copyright 1983-2012 Robert B. K. Dewar
*
*     This file is part of Macro SPITBOL.
*
*     Macro SPITBOL is free software: you can redistribute it and/or modify
*     it under the terms of the GNU General Public License as published by
*     the Free Software Foundation, either version 3 of the License, or
*     (at your option) any later version.
*
*     Macro SPITBOL is distributed in the hope that it will be useful,
*     but WITHOUT ANY WARRANTY; without even the implied warranty of
*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*     GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with Macro SPITBOL.  If not, see <http://www.gnu.org/licenses/>.
*
{{TTL{27,S P I T B O L -- NOTES TO IMPLEMENTORS{{{{96
*
*      M A C R O   S P I T B O L     V E R S I O N   3 . 8
*      ---------------------------------------------------
*
*      DATE OF RELEASE  -  JUNE 2012
*
*      VERSION 3.8 IS MAINTAINED BY
*           DR. DAVID SHIELDS
*           260 GARTH RD APT 3H4
*           SCARSDALE, NY 10583
*      E-MAIL - THEDAVESHIELDS AT GMAIL DOT COM
*
*      VERSION 3.7 WAS MAINTAINED BY
*           MARK EMMER
*           CATSPAW, INC.
*           P.O. BOX 1123
*           SALIDA, COLORADO 81021
*           U.S.A
*      E-MAIL - MARKE AT SNOBOL4 DOT COM
*
*      VERSIONS 2.6 THROUGH 3.4 WERE MAINTAINED BY
*           DR. A. P. MCCANN
*           DEPARTMENT OF COMPUTER STUDIES
*           UNIVERSITY OF LEEDS
*           LEEDS LS2 9JT
*           ENGLAND.
*
*      FROM 1979 THROUGH EARLY 1983 A NUMBER OF FIXES AND
*      ENHANCEMENTS WERE MADE BY STEVE DUFF AND ROBERT GOLDBERG.
*
*      TO ASSIST IMPLEMENTORS A REVISION HISTORY BASED ON
*      VERSION 2.7 IS BEING MAINTAINED.
*
{{TTL{27,S P I T B O L - REVISION HISTORY{{{{130
{{EJC{{{{{131
*      R E V I S I O N   H I S T O R Y
*      -------------------------------
*
*
*      VERSION 3.8 (JUNE 2012, DAVID SHIELDS)
*      --------------------------------------
*
*	       THIS VERSION IS VERY CLOSE TO V3.7, WITH THE
*              SAME FUNCTIONALITY.
*
*              THE SOURCE IS NOW MAINTAINED USING GIT, SO GOING FORWARD
*              THE DETAILED REVISION HISTORY WILL BE RECORDED IN THE GIT
*              COMMIT LOGS, NOT IN THIS FILE.
*
*      VERSION 3.6A TO 3.7 (NOVEMBER 1, 1991, MARK B. EMMER)
*      -----------------------------------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.701  ADD BTKWV AND REFINED TEST AT CDGVL+9 TO PREVENT
*              VARIABLE NAMES ALPHABET, LCASE, UCASE FROM BEING
*              PRE-EVALUATED BECAUSE OF THEIR ASSOCIATED
*              CONSTANT KEYWORDS.  THE CODE
*                 ALPHABET = "ABC"; OUTPUT = SIZE(ALPHABET)
*              RETURNED ZERO BECAUSE OF PRE-EVALUATION.
*      B3.702  DELAY BINDING TO FUNCTION BLOCK OF FOURTH
*              ARGUMENT TO TRACE FUNCTION.  THIS PERMITS THE
*              TRACE FUNCTION TO BE INVOKED BEFORE THE 4TH
*              ARGUMENT FUNCTION IS DEFINED.  ACCOMPLISHED BY
*              STORING A VRBLK POINTER IN TRFNC, AND FETCHING
*              ITS VRFNC ENTRY LATER, IN TRXEQ.
*      B3.703  REFERENCES TO KEYWORDS WITH CONSTANT PATTERN
*              VALUES (&ARB, &BAL, ETC.) DID NOT WORK.  A WTB
*              INSTRUCTION HAD BEEN OMITTED AT ACS14+2.
*      B3.704  IF A PROGRAM EMPLOYED THE CODE FUNCTION TO
*              REDEFINE A LABEL THAT WAS THE ENTRY LOCATION OF
*              A USER-DEFINED FUNCTION, THE FUNCTION WOULD
*              CONTINUE TO JUMP TO ITS OLD FUNCTION BODY.  PFCOD
*              IN PFBLK WAS POINTING DIRECTLY TO THE TARGET CODE
*              BLOCK, INSTEAD OF DOING SO INDIRECTLY THROUGH THE
*              VRBLK FOR THE ENTRY LABEL.
*      B3.705  THE TEST THAT REQUIRED A LABEL TO BE DEFINED
*              BEFORE IT COULD BE USED AS THE ENTRY OF A USER-
*              DEFINED FUNCTION HAS BEEN REMOVED.  FUNCTIONS
*              MAY BE DEFINED EVEN IF THE LABEL IS YET
*              UNDEFINED.
*      B3.706  AFTER A COMPILATION ERROR IN THE CODE FUNCTION,
*              THE EVAL FUNCTION PRODUCES SPURRIOUS ERRORS.  THE
*              CODE OFFSET CWCOF WAS NOT BEING RESET TO THE
*              BEGINNING OF CODE BLOCK.  ADD LINE AT ERR04+1 TO
*              ACCOMPLISH THIS RESET.
*      B3.707  INCONSISTANT TESTS WITH MXLEN CORRECTED.  SEVERAL
*              PLACES WERE TESTING WITH BGE INSTEAD OF BGT,
*              RESULTING IN SUCH ANOMALIES AS THE STATEMENT
*                 &MAXLNGTH = &MAXLNGTH
*              FAILING.  SINCE MXLEN IS GUARANTEED TO BE
*              STRICTLY LESS THAN DNAMB, IT IS PERMISSIBLE TO
*              CREATE OBJECTS OF SIZE MXLEN.  BGE CHANGED TO
*              BGT AT LOCATIONS
*                 S$ARR+14, SAR07+8, ALOBF+3, ASG14+8, GTAR6+10.
*      B3.708  EXIT(COMMAND STRING) WAS NOT LOADING PTR TO FCB
*              CHAIN INTO WB.  CORRECTED AT SEXT1.
*      B3.709  CHANGE PATST TO RETURN NON-STRING ERROR FOR NULL
*              ARGUMENT.  PREVIOUSLY, BREAK(), ANY(), ETC., WERE
*              SUCCEEDING, CONTRARY TO THE LANGUAGE DEFINITION.
*      B3.710  CONVERT FUNCTION WITH NULL SECOND ARGUMENT
*              CRASHED SYSTEM BY CALLING FLSTG WITH WA=0.  ADDED
*              TEST AT S$CNV, MOVED ERROR 74 TO SEPARATE ERB AT
*              SCV29.
*      B3.711  LEQ(,) CRASHED SYSTEM.  LCOMP DID NOT OBEY
*              MINIMAL ASSUMPTION THAT CMC OPCODE WILL ALWAYS
*              BE CALLED WITH WA .GT. 0.  ADDED TEST AT LCMP1.
*      B3.712  MODIFIED LINE AT SDF07+4 TO USE REGISTER WA
*              INSTEAD OF WB.  THIS CORRECTS PROBLEM OF DEFINE
*              FUNCTION WITH LOCAL VARIABLE LIST THAT BEGINS
*              WITH COMMA-  DEFINE("F(X),L1,L2")
*      B3.713  ERRONEOUS PLC ON UNINITIALISED R$CIM IN LISTR.
*      B3.714  ERRONEOUS CALL TO FLSTG POSSIBLE WITH NULL STRING
*              AT SDAT1.
*      B3.715  WHEN COPY FUNCTION USED WITH TABLE ARGUMENT, FIX
*              PROBLEM AT COP07.  WHEN COPYING FIRST TEBLK ON A
*              CHAIN, THE PSEUDO-PREVIOUS BLOCK POINTER IN XR
*              IS PUSHED ON THE STACK PRIOR TO CALLING ALLOC.
*              THIS IS NOT A VALID BLOCK POINTER, AS IT POINTS
*              WITHIN THE TBBLK.  IF THE SUBSEQUENT ALLOC
*              INVOKES GBCOL, THE HEAP BECOMES SCRAMBLED.
*              RECODED TO SAVE POINTER TO START OF BLOCK, PLUS
*              OFFSET IN WB.
*      B3.716  AT IOP01, IF GTVAR TRIGGERED GARBAGE COLLECTION
*              VIA ALOST, TRAP BLOCK IN WC WAS NOT COLLECTED.
*              SAVE WC ON STACK TO MAKE IT COLLECTABLE ACROSS
*              GTVAR CALL.
*      B3.717  AT ASG10, ALLOW CASE OF VARIABLE WITH MORE THAN
*              ONE TRBLK, AS HAPPENS WITH THE FOLLOWING STMT -
*              OUTPUT(.OUTPUT, .OUTPUT, FILENAME).
*      B3.718  AT SENF1, TRBLK CHAIN SEARCH WAS RELOADING CHAIN
*              HEAD, CAUSING INFINITE LOOP IF THE DESIRED TRBLK
*              WAS NOT THE FIRST ON CHAIN.  SYSTEM CRASHED WITH
*              TRACE(.V1) OUTPUT(.V2,.V1,FILE).
*      B3.719  PROTOTYPE STRINGS (DEFINE, LOAD, DATA, ETC.) WERE
*              ALLOWING BLANK CHARACTERS, PRODUCING BOGUS
*              VARIABLE NAMES.
*      B3.720  THE FACT THAT IOFCB DESTROYED REGISTER WC WAS NOT
*              DOCUMENTED.  B$EFC CONVERSION OF FILE ARGUMENT
*              NEVER WORKED BECAUSE WC AND XT WERE DESTROYED BY
*              CALL TO IOFCB.
*      B3.721  IOPUT LEFT A TRBLK ATTACHED TO FILEARG1 IF SYSIO
*              FAILED.  SUBSEQUENT USE OF THIS FILEARG1 VARIABLE
*              IN ANOTHER I/O CALL WOULD CRASH SYSTEM.
*      B3.722  ADD CHK AT EVLP1 TO CATCH RECURSIVE PATTERN ERROR.
*      B3.723  ALLOW -LINE TO WORK PROPERLY WITHIN CODE FUNCTION
*              BY SETTING CMPLN DIRECTLY IN CNC44.  IF FILE NAME
*              ABSENT, DECREMENT SCNPT TO RESCAN TERMINATOR.
*      B3.724  WHEN MXLEN EXCEEDS START OF DYNAMIC MEMORY, ROUND
*              IT UP TO MULTIPLE OF WORD SIZE PRIOR TO STORING
*              IN DNAMB AT INI06.
*      B3.725  PROVIDE RIGHT PADDING OF ZERO CHARACTERS TO ANY
*              STRING RETURNED BY AN EXTERNAL FUNCTION.
*      B3.726  RESET FLPTR AT BPF17 FOR UNDEFINED FUNCTION
*              WHEN EVALX IS EVALUATING AN EXPRESSION.
*      B3.727  MODIFY CODE AFTER READ5 FOR OUTER NESTING OF
*              AN EXECUTE-TIME COMPILE OF -INCLUDE STATEMENT.
*              CREATE A SUBSTRING OF REMAINDER OF ORIGINAL
*              CODE FUNCTION ARGUMENT STRING AND RETURN AS
*              RESULT OF READR FUNCTION
*      B3.728  THE DEFINITION OF THE AOV OPCODE IS CORRECTED.
*              FORMERLY THE DEFINITION SPECIFIED THAT THE BRANCH
*              WAS TO BE TAKEN IF THE RESULT OF THE ADDITION
*              EXCEEDED CFP$M, IMPLYING A TEST FOR OVERFLOW
*              FROM SIGNED ADDITION.
*              HOWEVER, ADDRESS ARITHMETIC MUST BE UNSIGNED TO
*              ALLOW FOR SYSTEMS WHERE THE HIGH ORDER ADDRESS
*              BIT IS SET.  THEREFORE, THE TEST MUST BE FOR
*              CARRY OUT OF THE HIGH ORDER BIT, IF THE RESULT
*              WOULD EXCEED CFP$L.
*      B3.729  A LABEL TRACE ON THE ENTRY LABEL FOR A FUNCTION
*              WAS UNDETECTED, RESULTING IN A TRANSFER TO
*              B$TRT AND SUBSEQUENT CRASH.  SEE BPF08 FOR FIX.
*      B3.730  POP FIRST ARGUMENT TO SUBSTR IF IT IS A BUFFER.
*      B3.731  PATTERN REPLACEMENT WITH BUFFER SUBJECT RETURNED
*              NULL STRING INSTEAD OF NEW SUBJECT VALUE.
*              CHANGED TO BEHAVE AS IF SUBJECT WAS A STRING.
*      B3.732  IF CONVERT FUNCTION WAS CALLED WITH A BUFFER
*              FIRST ARGUMENT AND "BUFFER" SECOND ARGUMENT,
*              IT WOULD CONVERT THE BUFFER TO A STRING, AND
*              THEN BACK TO A BUFFER.  THIS HAS BE CORRECTED
*              TO SIMPLY RETURN THE FIRST ARGUMENT AS THE
*              FUNCTION RESULT.
*      B3.733  DETECT EXTERNAL FUNCTION RETURNING A NULL STRING
*              UNCONVERTED RESULT AT BEF12, AND JUMP TO EXNUL.
*      B3.734  FIX PROBLEM AT INS04 WHEN INSERTING ZERO LENGTH
*              STRING INTO BUFFER.  DEFEND AGAINST INVOKING
*              MVC WITH A ZERO VALUE IN WA, WHICH WILL CAUSE
*              SOME IMPLEMENTATIONS TO WRAP THE COUNTER.
*      B3.735  ADD OVERFLOW TEST FOR COS AND SIN TO DETECT
*              OUT-OF-RANGE ARGUMENT.
*      B3.736  FIXED PROBLEM INTRODUCED WITH B3.727 NOT
*              RESTORING R$CIM, SCNPT AND SCNIL AFTER CREATING
*              SUBSTRING.
*      B3.737  FIXED TFIND TO PLACE DEFAULT VALUE IN NEWLY
*              ALLOCATED TEBLK.
*      B3.738  ADDED BL$P0 TO P$NTH ENTRY POINT.  THE EXPRESSION
*              DATATYPE(CONVERT("","PATTERN")) WOULD CRASH WHEN
*              THE DTYPE FUNCTION USES THE NON-EXISTANT TYPE
*              WORD PRECEDING P$NTH.
*      B3.739  BUG AT GTN35 IN THE CASE OF OVERFLOW DURING CVM.
*              WB CAN BE DESTROYED BY CVM ON SOME PLATFORMS.
*      B3.740  PROTECT SCONTINUE FROM USAGE IN OTHER THAN ERROR
*              320 CASE.
*      B3.741  PROTECT CONTINUE FROM USAGE FOLLOWING ERROR
*              EVALUATING COMPLEX FAILURE GOTO.
*
*
*      CHANGES
*      -------
*
*      C3.701  ADD .CULK CONDITIONAL TO INCLUDE &LCASE, &UCASE.
*      C3.702  ADD -LINE NN "FILENAME" CONTROL CARD.
*      C3.703  MOVE .CNLD CONDITIONAL UP IN ROUTINE DFFNC TO
*              OMIT ALL TESTS FOR B$EFC.
*      C3.704  ADD CONDITIONAL .CICC TO IGNORE UNRECOGNIZED
*              CONTROL CARDS.
*      C3.705  ADD CONDITIONAL .CNSC TO OMIT STRING TO NUMERIC
*              CONVERSION IN SORT.  THE PRESENCE OF THIS
*              CONVERSION MODE PRODUCES A SORT RESULT THAT IS
*              DEPENDENT UPON THE ORDER OF INPUT DATA.
*              FOR EXAMPLE, GIVEN INPUT DATA "2", 5, "10",
*              STRING COMPARISON YIELDS "10" LT "2", BUT STRING
*              TO INTEGER CONVERSION YIELDS "2" LT 5 LT "10".
*      C3.706  ADD SEVENTH RETURN FROM SYSHS THAT ALLOWS CALLEE
*              TO RETURN A STRING POINTER AND LENGTH.  THIS IS
*              DONE TO ELIMINATE THE NEED FOR THE CALLER TO HAVE
*              AN SCBLK BIG ENOUGH TO ACCOMMODATE LONG STRINGS.
*      C3.707  ADD EIGHTH RETURN FROM SYSHS TO FORCE COPY OF
*              BLOCK POINTED TO BY XR.
*      C3.708  MADE -COPY A SYNONYM FOR -INCLUDE.
*      C3.709  ADD CONDITIONAL .CBYT FOR STATISTICS DISPLAYED
*              IN BYTES RATHER THAN WORDS.
*      C3.710  DUMP NULL VALUED VARIABLES WHEN DUMP = 3.  CORE
*              DUMP PRODUCED FOR DUMP = 4.
*      C3.711  RESTRICT MINIMUM VALUE TO WHICH KEYWORD MAXLNGTH
*              CAN BE SET TO 1,024 VIA NEW VARIABLE MNLEN.
*      C3.712  ADD CONDITIONAL SYMBOL .CMTH FOR EXTENDED MATH
*              FUNCTIONS- ATAN, CHOP, COS, EXP, LN, SIN, SQRT,
*              TAN.  X**Y AND REMDR(X,Y) ARE EXTENDED TO INCLUDE
*              REALS.
*      C3.713  ADD BIT TO SYSPP TO SET -PRINT UPON ENTRY
*      C3.714  ADD CONDITIONAL .CSFN TO TRACK SOURCE FILE NAME
*              ASSOCIATED WITH EACH CODE BLOCK.
*      C3.715  ADD CONDITIONAL .CINC FOR -INCLUDE CONTROL CARD
*              FEATURE.  THE FORMAT OF THE CARD IS
*                 -INCLUDE "FILENAME"
*              INCLUDE CONTROL CARDS MAY BE USED DURING BOTH THE
*              INITIAL COMPILE AND EXECUTE-TIME COMPILE.  THE
*              FILENAME IS SAVED IN A TABLE, AND REDUNDANT
*              INCLUDES OF THAT FILE ARE IGNORED.
*      C3.716  ADD CONDITIONAL .CSLN TO INCLUDE SOURCE LINE
*              NUMBER IN CODE BLOCKS.  RELEASE CURRENT CCBLK
*              AFTER INITIAL COMPILE.
*      C3.717  CHANGED RILEN TO 258 (FROM 120) TO PROVIDE
*              UNIFORM INPUT LINE LENGTH WHEN READING FROM
*              TERMINAL OR INPUT.
*      C3.718  ADD ADDITIONAL EXIT TO IOFCB TO DISTINGUISH
*              ARGUMENT NOT CONVERTABLE TO STRING AND ARGUMENT
*              FILE NOT OPEN.
*      C3.719  ADD FOURTH AND FIFTH ARGUMENTS TO HOST FUNCTION.
*      C3.720  ADD &COMPARE KEYWORD TO CONTROL STRING
*              COMPARISONS.
*      C3.721  SETUP PFDMP AT INIY0 IN CASE OSINT FORCED
*              &PROFILE NON-ZERO.
*      C3.722  ADD CONDITIONAL SYMBOL .CAEX TO INCLUDE UP ARROW
*              AS SYNONYM FOR EXPONENTIATION.
*      C3.723  ADD CONDITIONAL .CCMC AND EXTERNAL FUNCTION SYSCM
*              TO PROVIDE STRING COMPARISON USING COLLATION
*              SEQUENCE OTHER THAN STRICT ORDERING OF CHARACTER
*              CODES (INTERNATIONAL COMPARES).
*      C3.724  ADD CONDITIONAL .CPOL AND EXTERNAL FUNCTION SYSPL
*              TO PROVIDE INTERACTIVE CONTROL OF SPITBOL
*              EXECUTION.
*      C3.725  ADD CONDITIONAL SYMBOL .CERA AND EXTERNAL
*              FUNCTION SYSEA TO PROVIDE ADVICE OF COMPILATION
*              AND RUNTIME ERRORS TO OSINT.
*      C3.726  ADD CMPLN, RDCLN, RDNLN TO TRACK SOURCE LINE
*              NUMBER.
*      C3.727  CONVERTED ERROR MESSAGES TO UPPER/LOWER CASE.
*      C3.728  ADD CONDITIONAL .CGBC TO EXTERNAL ROUTINE SYSGC.
*              CALLED AT THE START AND END OF GARBAGE COLLECTION
*              TO PERFORM ANY NEEDED NOTIFICATION TO OPERATING
*              SYSTEM OR USER.
*      C3.729  MODIFIED LAST LINE OF S$SET FROM EXNUL TO EXINT
*              SO SEEK CAN RETURN FINAL FILE POSITION AFTER
*              SEEK.
*      C3.730  PLACE MOV XR,(XS) AT S$RMD+4 TO ALLOW REAL SECOND
*              ARG TO REMDR.
*      C3.731  REMOVE REDUNDANT BGE XR,=CFP$U,SCN07 AT SCN06+4
*      C3.732  CHANGE DEFINITION OF CMC AND TRC SUCH THAT ONLY
*              XL MUST BE CLEARED AFTER OPERATION.  NOTE, THIS
*              CHANGE WAS SUBSEQUENTLY VOIDED.  CMC AND TRC MUST
*              CLEAR BOTH XL AND XR, BECAUSE UTILITY ROUTINES
*              MAY PRESERVE XL OR XR ON THE STACK, AND THE STACK
*              IS COLLECTABLE BY GBCOL.
*      C3.733  REMOVE MOST BRANCHES TO EXITS AND EXIXR.
*              INSTEAD, JUMP DIRECTLY TO NEXT CODE WORD.
*      C3.734  ADD ERROR 260 FOR ARRAY TOO LARGE IN GTARR.
*      C3.735  ADD CONDITIONAL .CS32 TO INITIALIZE STLIM TO
*              2147483647.
*      C3.736  ADD SECOND ARGUMENT TO EXIT FUNCTION, ALLOWING
*              USER TO SPECIFY FILE NAME OF LOAD MODULE BEING
*              WRITTEN.  IF OMITTED, OSINT WILL PROVIDE A
*              DEFAULT NAME.
*      C3.737  ADD CONDITIONAL .CSPR TO INCLUDE SPARE LOCATIONS
*              IN WORKING AREA.  THESE MAY BE USED IN LATER BUG
*              FIXES WITHOUT CHANGING THE SIZE OF THE WORKING
*              STORAGE AND OBSOLETING MODULES CREATED BY EXIT().
*              SUBSUENTLY REMOVED IN C3.767.
*      C3.738  ADD R$CTS TO REMEMBER LAST STRING USED TO BUILD
*              BIT COLUMN IN PATST.
*      C3.739  CHANGE FLSTG TO TYPE E PROCEDURE INSTEAD OF R.
*      C3.740  STANDARDIZE ON BIG-ENDIAN SYSTEMS.  AT THE
*              IMPLEMENTORS CHOICE, THE ZGB OPCODE CAN ALSO
*              PERFORM A BYTE SWAP IF NECESSARY TO ACHIEVE BIG-
*              ENDIAN BYTE ORDERING.  THIS IS DONE SO THAT
*              SYSTEMS WITH SIMILAR WORD LENGTHS WILL PRODUCE
*              THE SAME HASH CODE FOR STRINGS, AND HENCE THE
*              SAME ORDERING FOR TABLE ENTRIES.  THE HASHS
*              PROCEDURE HAS AN ADDITIONAL ZGB ADDED TO REORDER
*              THE LENGTH WORD.
*      C3.741  ADD CONDITIONAL .CSOU TO CAUSE ASSIGNMENTS TO
*              OUTPUT AND TERMINAL VARIABLES TO BE PROCESSED
*              THROUGH CALLS TO SYSOU RATHER THAN THROUGH
*              LISTING BUFFER.  DONE TO ELIMINATE SHORT RECORD
*              LENGTHS ENFORCED BY BUFFER SIZE.  A CODE OF 0 OR
*              1 IS PASSED TO SYSOU INSTEAD OF AN FCBLK.
*      C3.742  INCREASED INILN, INILS, RILEN TO 1024.
*      C3.743  ADD BIT TO SYSPP TO SET NOERRORS MODE.
*      C3.744  ADD .CCMK CONDITIONAL TO INCLUDE KEYWORD COMPARE
*              EVEN IF SYSCM IS NOT BEING INCLUDED.  DONE TO
*              PROVIDE IDENTICAL DATA REGIONS IN SYSTEMS THAT
*              IMPLEMENT SYSCM AND THOSE WHICH DO NOT, SO THAT
*              SAVE FILES CAN BE EXCHANGED IN THE NEXT RELEASE.
*      C3.745  ADD WC RETURN PARAMETER TO SYSIL TO ALLOW
*              INTERFACE TO INFORM SPITBOL IF FILE ABOUT TO BE
*              READ IS A BINARY FILE.  IF SO, NO BLANK TRIMMING
*              OCCURS.
*      C3.746  FOLD LOAD FUNCTION ARGUMENT TYPES TO UPPER CASE.
*      C3.747  ADD .CEXP CONDITIONAL TO HAVE SYSEX POP ITS
*              ARGUMENTS.
*      C3.748  IN STOPR, DO NOT ATTEMPT TO DISPLAY FILE NAME AND
*              LINE NUMBER IF STOPPING BECAUSE OF STACK OVERFLOW
*              DURING GARBAGE COLLECTION.  POINTERS TO FILE NAME
*              TABLE AND CODE BLOCK ARE WRONG.
*      C3.749  ADD BIT TO SYSPP TO SET CASE FOLDING MODE.
*      C3.750  ADD ADDITIONAL RETURN FROM SYSLD IF INSUFFICIENT
*              MEMORY TO LOAD/CALL EXTERNAL FUNCTION.
*      C3.751  ADD ADDITIONAL RETURNS FROM SYSEX IF INSUFFICIENT
*              MEMORY OR BAD ARGUMENT TYPE.
*      C3.752  IGNORE LEADING AND TRAILING BLANKS IN ARGUMENTS
*              WITHIN PROTOTYPE STRINGS TO CLEAR, DATA, DEFINE
*              AND LOAD.
*      C3.753  TEST FOR FATAL ERROR AT ERR04 AND ABORT IF SO.
*              FORCE TERMINATION ON STACK OVERFLOW BY SETTING
*              ERRFT TO 4 IN STACK OVERFLOW SECTION.
*      C3.754  RECODE COPY LOOP AT SRT14 TO EXCHANGE USAGE OF
*              REGISTERS XL AND XR.  THIS PERMITS USE OF THE
*              MVW ORDER INSTEAD OF THE EXPLICIT LOOP CODING
*              PREVIOUSLY EMPLOYED.
*      C3.755  ADD .CENG CONDITIONAL TO INCLUDE ROUTINES NEEDED
*              BY TEXT PROCESSING ENGINE. ADD ROUTINES ENEVS AND
*              ENGTS FOR USE BY ENGINE OR DEBUGGER.  COPY XR TO
*              XL AROUND CALL TO SYSPL TO ALLOW SYSPL TO
*              TRIGGER GARBAGE COLLECTION.
*      C3.756  ADD &FILE, &LASTFILE, &LINE, &LASTLINE KEYWORDS.
*              FOR NOW, LINE AND LASTLINE ARE MAINTAINED IN THE
*              SAME MANNER AS STNO AND LASTNO, WHICH ADDS OVER-
*              HEAD TO THE STATEMENT INITIALIZATION CODE.  A
*              POSSIBLE CHANGE IS TO CREATE A STMLN PROCEDURE
*              THAT MAPS STATEMENT NUMBERS TO LINE NUMBERS.
*              ONE SIMPLE STRATEGY WOULD BE TO SWEEP CODE BLOCKS
*              IN MEMORY LOOKING FOR THE STATEMENT NUMBER AND
*              EXTRACTING THE LINE NUMBER FROM THAT CODE BLOCK.
*              SUCH A PROCEDURE WOULD ALSO ALLOW LINE NUMBERS
*              (AND FILE NAMES) TO BE ADDED TO STATEMENT PROFILE
*              REPORTS.
*      C3.757  CHANGE SORT TO FAIL INSTEAD OF PRODUCING ERROR
*              MESSAGE IF ARGUMENT TABLE IS NULL.  CHANGE SORTA
*              TO RETURN FAILURE.  ADD ANOTHER RETURN TO GTARR
*              TO DISTINGUISH NULL TABLE FROM BAD ARGUMENT.
*      C3.758  CREATE PROCEDURE PRTMM TO DISPLAY MEMORY USAGE
*              STATISTICS, AND CALL IT WHEN PRODUCING END-OF-
*              RUN STATS.
*      C3.759  ADD LABEL SCONTINUE TO ALLOW SETEXIT TO RESUME
*              EXECUTION EXACTLY WHERE IT WAS INTERRUPTED.
*      C3.760  ADD SNOBOL4 BACKSPACE FUNCTION AND CONDITIONAL
*              .CBSP.
*      C3.761  ADD ADDITIONAL ARGUMENTS TO SYSGC TO ASSIST
*              VIRTUAL MEMORY MANAGERS.
*      C3.762  THE METHOD OF CONVERTING A TABLE TO AN ARRAY HAS
*              BEEN REVISED.  PREVIOUSLY, TABLE ELEMENTS WERE
*              COPIED TO THE RESULT ARRAY IN THE ORDER THEY WERE
*              ENCOUNTERED ALONG THE VARIOUS HASH CHAINS.  THIS
*              APPEARED TO THE USER AS A RANDOM ORDERING.  HOW-
*              EVER, SPITBOL/370 AS WELL AS SIL SNOBOL4 ORDERED
*              ARRAY ELEMENTS ACCORDING TO THEIR TIME OF ENTRY
*              INTO THE TABLE.  USER PROGRAMS THAT RELIED UPON
*              THIS BEHAVIOR MALFUNCTIONED WHEN PORTED TO MACRO
*              SPITBOL.
*              TO REMEDY THIS, THE CONVERSION IS PERFORMED IN
*              THREE STEPS:
*              1. CONVERT TABLE TO AN ARRAY PLACING THE ADDRESS
*                 OF EACH TEBLK IN THE ARRAY INSTEAD OF THE KEY
*                 AND VALUE.
*              2. SORT THE ARRAY OF ADDRESSES.  THIS ORDERS ELE-
*                 MENTS BY TIME OF CREATION (ASCENDING ADDRESS).
*              3. SCAN THE ARRAY, REPLACING ADDRESSES WITH THE
*                 KEY AND VALUE FROM THE REFERENCED TEBLK.
*              THE AFFECTED PORTIONS OF THE PROGRAM ARE AT S$CNV
*              AND IN GTARR, WHICH NOW ACCEPTS AN ADDITIONAL
*              ARGUMENT SPECIFYING WHETHER TO PLACE KEY/VALUES
*              IN THE ARRAY OR TEBLK ADDRESSES.
*      C3.763  IF CASE-FOLDING IS ACTIVE, FOLD THE FUNCTION NAME
*              PROVIDED TO THE LOAD() FUNCTION BEFORE PASSING IT
*              TO SYSLD.
*      C3.764  ADD SEDIMENT ALGORITHM TO GARBAGE COLLECTOR,
*              CONDITIONED ON .CSED.
*      C3.765  ADD OPTIMIZATION TO DISCARD NULL STATEMENTS AND
*              STATEMENTS WHICH JUST HAVE A CONSTANT SUBJECT
*              (SEE CODE AT CMP12).
*      C3.766  REARRANGED ORDER OF INITIAL OBJECTS IN STATIC
*              MEMORY SO THAT HASH TABLE IS THE LAST OF THE FOUR
*              OBJECT CREATED BY INITIALIZATION CODE.  THIS IS
*              DONE SO THAT THE PRINT BUFFER, GTS WORK AREA, AND
*              &ALPHABET KEYWORDS DO NOT NEED TO BE SAVED IN
*              ANY SAVE FILE CREATED BY OSINT.  ADDED ROUTINE TO
*              INITIALIZE THESE STRUCTURES.
*      C3.767  REMOVED .CSPR CONDITIONAL AND SPARE LOCATIONS.
*      C3.768  ADDED .CREL CONDITIONAL AND EXTENSIVE ROUTINES
*              (RELOC ET. AL.) TO PERFORM RELOCATION OF DATA
*              IN WORKING SECTION, STATIC REGION, AND DYNAMIC
*              REGION AFTER RELOAD OF A SAVED MEMORY IMAGE.
*              ROUTINES RELAJ, RELCR, AND RELOC ARE INVOKED
*              BY OSINT AFTER RELOADING A SAVE FILE.
*              IT IS NOW POSSIBLE TO RELOAD SUCH AN IMAGE EVEN
*              IF THE SPITBOL COMPILER AND ITS DATA STRUCTURES
*              ARE RELOADED TO OTHER ADDRESSES.  THE WORKING
*              SECTION HAS BEEN EXTENSIVELY REARRANGED TO
*              ACCOMMODATE THE RELOC PROCEDURE.
*      C3.769  ZERO R$CCB (INTERIM CCBLK PTR) IN COLLECT,
*              CONVERT, EVAL, AND EXIT FUNCTIONS TO RELEASE
*              UNNEEDED CCBLK MEMORY.
*      C3.770  ADD EXIT(4) AND EXIT(-4) TO ALLOW EXECUTION TO
*              CONTINUE AFTER WRITING SAVE FILE OR LOAD MODULE.
*              REVISED SYSXI INTERFACE TO DETECT CONTINUATION
*              AFTER PERFORMANCE OF EXIT(4) OR EXIT(-4) ACTION.
*      C3.771  CHANGE FILNM TO PRESERVE REGISTERS.
*      C3.772  ADDITION OF .CNCR AND SYSCR (REAL TO STRING
*              SYSTEM ROUTINE OPTION).
*      C3.773  MODIFIED REPLACE FUNCTION TO OPTIMIZE USAGE
*              WHEN SECOND ARGUMENT IS &ALPHABET.  IN THIS CASE,
*              THE THIRD ARGUMENT CAN BE USED AS THE TRANSLATE
*              TABLE DIRECTLY.
*      C3.774  MODIFIED CONDITIONALS FOR BUFFERS AND REALS SO
*              THAT THEIR RESPECTIVE BLOCK CODES ARE ALWAYS
*              PRESENT, EVEN IF THESE DATA TYPES ARE CONDITIONED
*              OUT.  THIS PROVIDES CONSISTENT BLOCK CODE
*              NUMBERING FOR EXTERNAL FUNCTIONS.
*      C3.775  MODIFIED ALOBF TO TEST STRING LENGTH AGAINST
*              KVMXL INSTEAD OF MXLEN.  ALSO, ALOBF WAS TESTING
*              TOTAL SIZE OF BFBLK, INSTEAD OF JUST STRING LEN.
*      C3.776  MOVE UTILITY ROUTINES SOURCE UP TO LIE BETWEEN
*              PREDEFINED SNOBOL FUNCTIONS (S$XXX) ROUTINES AND
*              UTILITY PROCEDURES.  THIS WAS DONE TO ASSIST
*              TRANSLATION ON PLATFORMS SUCH AS APPLE MACINTOSH
*              THAT USE 15-BIT OFFSETS TO STORE ERROR EXITS (PPM
*              BRANCHES).  OFFSETS TO LABELS LIKE EXFAL WERE
*              JUST TOO FAR AWAY.  SIMILARLY, FUNCTIONS TFIND,
*              TMAKE, AND VMAKE ARE LOCATED OUT OF ALPHABETIC
*              ORDER TO SATISFY THE MACINTOSH'S LIMITED RANGE
*              FOR SUBROUTINE CALLS.  MOVE BUILT-IN LABELS
*              BEYOND THE BLOCK AND PATTERN ROUTINES TO GET IT
*              WITHIN 32K OF THE ERROR ROUTINES.
*      C3.777  AT SCN46, ALLOW COLON, RIGHT PAREN AND RIGHT
*              BRACKET TO TERMINATE = OPERATOR WITH DEFAULT
*              NULL OPERAND.
*      C3.778  ADDED .CTET CONDITIONAL FOR TABLE ENTRY TRACE.
*      C3.779  INTRODUCE CFP$L, THE LARGEST UNSIGNED VALUE
*              THAT MAY BE STORED IN A ONE-WORD INTEGER.  THIS
*              IS DONE TO ACCOMMODATE MACHINES WHERE MEMORY
*              ADDRESSES HAVE THE HIGH-ORDER ADDRESS BIT SET.
*      C3.780  PERFORM REPLACE IN PLACE IF FIRST ARG IS BUFFER.
*      C3.781  PERFORM REVERSE IN PLACE IF FIRST ARG IS BUFFER.
*      C3.782  CHANGE SYSOU TO ACCEPT BUFFER AS WELL AS STRING
*              TO BE OUTPUT.  CHANGE CODE AT ASG11 TO PREVENT
*              CONVERSION OF BUFFER TO STRING.
*      C3.783  OPTIMIZE POS AND RPOS WHEN IT IS THE FIRST NODE
*              OF A PATTERN AND HAS EITHER AN INTEGER OR SIMPLE
*              EXPRESSION VARIABLE ARGUMENT.  IF UNANCHORED MODE
*              AND THE CURSOR IS ZERO, IT IS ADVANCED DIRECTLY
*              TO THE DESIRED CURSOR POSITION.
*      C3.784  PERFORM TRIM FUNCTION IN PLACE IF ARG IS BUFFER.
*      C3.785  ADD GTSTB PROCEDURE TO GET A STRING OR BUFFER
*              ARGUMENT FOR REPLACE, REVERSE, SIZE, TRIM, ETC.
*      C3.786  CHANGE LEQ, LGT, ETC. TO PERFORM COMPARISONS
*              WITHOUT CONVERTING BUFFER ARGUMENTS TO STRINGS.
*              THIS IS DONE BY CHANGING LCOMP TO ACCEPT BUFFER
*              ARGUMENT(S).  THIS ALSO AFFECTS SORT FUNCTION,
*              WHICH WILL COMPARE TWO BUFFERS AS STRINGS.
*      C3.787  CHANGE GTNUM TO USE CHARACTERS IN BUFFER WITHOUT
*              CONVERSION TO A STRING.  THIS IMPLIES THAT ACOMP
*              WILL PERFORM ARITHMETIC COMPARISONS OF BUFFERS
*              WITHOUT CONVERTING TO STRINGS FIRST.
*      C3.788  PERFORM COMPARISONS OF STRINGS AND BUFFERS IN
*              SORTC.
*      C3.789  CHANGE INSBF TO ALLOW INSERTION OF A BUFFER INTO
*              A BUFFER WITHOUT FIRST CONVERTING IT TO A STRING.
*              NOTE THAT THIS ONLY WORKS WHEN THE TWO BUFFERS
*              ARE NOT THE SAME.
*      C3.790  DOCUMENTATION CHANGE:  NOTE THAT ALL OF THE BLOCK
*              MOVE OPCODES SHOULD HAVE WA .GT. 0.  NOT ALL
*              IMPLEMENTATIONS AVOID MOVING OBJECTS WHEN WA IS
*              ZERO.
*      C3.791  CHANGE IDENT TO PROVIDE BUFFER/BUFFER AND
*              BUFFER/STRING COMPARISONS, TO ACCOMMODATE USERS
*              WHO PERFORM IDENT(BUF) TO CHECK FOR NULL STRING
*              IN BUFFER.
*      C3.792  ADDED FULLSCAN KEYWORD INITIALIZED TO ONE.  USER
*              MAY SET TO ANY NON-ZERO VALUE, WILL RECEIVE AN
*              ERROR MESSAGE IF ATTEMPTS TO SET TO ZERO, SINCE
*              QUICKSCAN MODE IS NOT SUPPORTED.
*      C3.793  REWROTE STATEMENT STARTUP CODE AT STMGO TO ONLY
*              PERFORM CHECKING OF PROFILING, STCOUNT TRACING,
*              AND STATEMENT COUNTING IF NECESSARY.
*      C3.794  ADD ADDITIONAL EXIT TO SYSFC AND IOPUT TO SIGNAL
*              THAT I/O CHANNEL (FCBLK) IS ALREADY IN USE.
*              ADDED ERROR MESSAGE NUMBERS 289 AND 290.
*      C3.795  ADDED OPTIONAL INTEGER ARGUMENT TO DATE FUNCTION
*              TO SPECIFY FORMAT OF DATE STRING RETURNED BY
*              SYSDT.
*
*
*      VERSION 3.6 TO 3.6A (OCT 83)
*      ---------------------------
*
*      CHANGES
*      -------
*
*      C3.617  ADD .CNLF. IF DEFINED, THEN ARGUMENTS TO EXTERNAL
*              FUNCTIONS MAY BE DECLARED TO HAVE TYPE FILE.
*              SUCH ARGUMENTS MUST HAVE BEEN USED AS SECOND
*              ARG TO INPUT() OR OUTPUT() AND A POINTER TO THE
*              FCB IS PASSED TO THE EXTERNAL FUNCTION.
*
*
*      VERSION 3.5 TO 3.6 (JUN 83)
*      ---------------------------
*
*      CODES USED TO IDENTIFY AUTHORS ARE (SGD) FOR DUFF,
*      (REG) FOR  GOLDBERG, AND (LDS) FOR SHIELDS.
*
*      BUGS FIXED
*      ----------
*      B3.601  (SGD) TO FIX MULTIPLE TRAP BLOCK PROBLEM IN ASIGN
*      B3.602  (SGD) PATCH IN GTARR TO FIX NULL CONVERT.
*      B3.603  (SGD) INSERTED MISSING WTB AFTER SYSMM CALLS.
*      B3.604  (SGD) USE STRING LENGTH IN HASHS.
*      B3.605  (SGD) FIXED SERIOUS PARSER PROBLEM
*              RELATING TO (X Y) ON LINE BEING VIEWED AS PATTERN
*              MATCH.  FIXED BY ADDITION OF NEW CMTYP VALUE
*              C$CNP (CONCATENATION - NOT PATTERN MATCH).
*      B3.606  (SGD) FIXED EXIT(N) RESPECIFICATION CODE
*              TO PROPERLY OBSERVE HEADER SEMANTICS ON RETURN.
*      B3.607  (SGD) BYPASS PRTPG CALL AT INITIALIZATION
*              FOLLOWING COMPILATION IF NO OUTPUT GENERATED.
*              THIS PREVENTS OUTPUT FILES CONSISTING OF THE
*              HEADERS AND A FEW BLANK LINES WHEN THERE IS NO
*              SOURCE LISTING AND NO COMPILATION STATS.
*              ALSO FIX TIMSX INITIALIZATION IN SAME CODE.
*      B3.608  (SGD) B$EFC CODE DID NOT CHECK FOR
*              UNCONVERTED RESULT RETURNING NULL STRING.
*      B3.609  (SGD) LOAD PFVBL FIELD IN RETRN FOR
*              RETURN TRACING. THIS WAS CAUSING BUG ON RETURN
*              TRACES THAT TRIED TO ACCESS THE VARIABLE NAME.
*      B3.610  (SGD) FIXED PROBLEM RELATING TO COMPILATION OF
*              GOTO FIELDS CONTAINING SMALL INTEGERS
*              (IN CONST SEC).
*      B3.611  (REG) PREVENT CLEAR() FROM CLOBBERING PROTECTED
*              VARIABLES AT LABEL SCLR5.
*      B3.612  (REG) FIXED GTEXP FROM ACCEPTING TRAILING
*              SEMICOLON OR COLON. THIS IS NOT A LEGAL WAY
*              TO END AN EXPRESSION.
*      B3.613  (REG) FIXED DIFFICULTIES WITH LISTINGS DURING
*              EXECUTION WHEN NO LISTING GENERATED DURING
*              COMPILATION. -LIST TO CODE() CAUSED BOMB.
*              FIX IS TO RESET R$TTL AND R$STL TO NULLS NOT 0
*              AFTER COMPILATION.
*              (LISTR AND LISTT EXPECT NULLS)
*              WHEN LISTING AND STATISTICS ROUTED TO DIFFERENT
*              FILE THAN EXECUTION OUTPUT, ERROR MESSAGE IS SENT
*              TO EXECUTION OUTPUT (AND GETS SEPARATED FROM
*              ... IN STATEMENT ... MSG). LABO1 CALLS SYSAX AND
*              STOPR DOES NOT CALL SYSAX IF ENTERED FROM LABO1.
*      B3.614  (LDS) FIX MISUSE OF WC JUST AFTER ASG10.
*      B3.615  (LDS) ADD COMMENT POINTING OUT SUSPICIOUS CODE
*              AFTER TFN02
*      B3.616  (LDS) FIX INCONSISTENT DECLARATION OF SORTH.
*      B3.617  (LDS) INSERT MISSING CONDITIONAL TESTS ON CNBF.
*      B3.618  (LDS) FIX SOME VIOLATIONS OF MINIMAL LANGUAGE
*              THAT HAD SLIPPED PAST SOME TRANSLATORS.
*      B3.619  (LDS) CORRECT ERROR INTRODUCED IN FIXING B3.614.
{{EJC{{{{{701
*      CHANGES
*      -------
*
*
*      C3.601  (SGD) ADDITION OF .CNCI AND SYSCI (INT TO STRING
*              SYSTEM ROUTINE OPTION)
*      C3.602  (REG) CHANGED INILN AND AND INILS TO 258
*      C3.603  (SGD) MERGED IN PROFILER PATCHES, REPAIRED CODE.
*      C3.604  (SGD) ADDED BUFFER TYPE AND SYMBOL CNBF
*      C3.605  (SGD) ADDED CHAR FUNCTION.  CHAR(N) RETURNS NTH
*              CHARACTER OF HOST MACHINE CHARACTER SET.
*      C3.606  (REG) ADDED CFP$U TO EASE TRANSLATION ON SMALLER
*              SYSTEMS - CONDITIONAL .CUCF
*      C3.607  (REG) ADDED LOWER CASE SUPPORT, CONDITIONAL .CULC
*      C3.608  (REG) ADDED SET I/O FUNCTION, CONDITIONAL .CUST
*      C3.609  (REG) CONDITIONALIZED PAGE EJECT AFTER CALL TO
*              SYSBX AND ADDED ANOTHER BEFORE CALL TO SYSBX,
*              SO THAT, IF DESIRED BY THE IMPLEMENTOR,
*              STANDARD OUTPUT WILL REFLECT ASSIGNMENTS MADE
*              BY EXECUTING PROGRAM ONLY.
*              CONDITIONAL .CUEJ CONTROLS - IF DEFINED THEN
*              EJECT IS BEFORE CALL TO SYSBX.
*      C3.610  (LDS) INTRODUCE .CTMD TO SUPPORT SYSTM THAT
*              REPORTS ELAPSED TIME IN DECISECONDS INSTEAD OF
*              MILLISECONDS.
*      C3.611  (LDS)  PROVIDE PLACE FOR .DEF OR .UND FOR EACH
*              CONDITIONAL  OPTION, SO THAT SETTINGS CAN BE
*              CHANGED WITHOUT CHANGING LINE NUMBERS.
*              CURRENT SETTINGS ARE FOR 808X TRANSLATION.
*      C3.612  (LDS) OBEY (NEW) RESTRICTION THAT OPERAND IN
*              CONDITIONAL BRANCH INSTRUCTION CANNOT HAVE FORM
*              (X)+ IN ORDER TO SIMPLIFY TRANSLATIONS FOR WHICH
*              POSTINCREMENT NOT READILY AVAILABLE.
*      C3.613  (REG,LDS) ADD OP
*                    FLC WREG
*              THAT FOLDS CHARACTER IN WREG TO UPPER CASE.
*              THIS OP IS USED ONLY IF .CULC IS DEFINED.
*              THIS CHANGE ALSO INVOLVES ADDITION OF KEYWORD
*              &CASE WHICH WHEN NONZERO (THE INITIAL SETTING)
*              CAUSES THE CASE FOLDING JUST DESCRIBED TO BE
*              DONE.
*      C3.614  (LDS) ADD OPTION .CS16 TO PERMIT INITIALIZATION
*              OF STATEMENT LIMIT VALUES TO 32767 FOR 16 BIT
*              MACHINES.
*      C3.615  (LDS) PERMIT RETURN POINT AND ENTRY POINT
*              ADDRESSES TO BE DISTINGUISHED BY THEIR PARITY
*              INSTEAD OF BY LYING WITHIN A CERTAIN RANGE
*              OF VALUES.  INTRODUCE CONDITIONAL SYMBOLS
*              .CRPP  RETURN POINTS HAVE ODD PARITY
*              .CEPP  ENTRY POINTS HAVE ODD PARITY
*      C3.616  (LDS) INTRODUCE NEW MINIMAL OPCODES TO BRANCH
*              ACCORDING TO PARITY,
*                BEV  OPN,PLBL  BRANCH IF ADDRESS EVEN
*                BOD  OPN,PLBL  BRANCH IF ADDRESS ODD
*              AN ADDRESS IS EVEN IF IT IS A MULTIPLE OF CFP$B.
{{EJC{{{{{757
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.601  (LDS) BRING MINIMAL MACHINE DESCRIPTION UP TO
*              DATE
*
{{EJC{{{{{764
*      VERSION 3.4 TO 3.5 (FEB 79)
*      ---------------------------
*
*
*      BUGS FIXED
*      ----------
*
*      B3.401  PRTST SHOULD BE DECLARED AS AN R TYPE PROCEDURE.
*      B3.402  TIMING ERROR IF SPITBOL FAILS IN DUMP.
*      B3.403  ERROR IN HANDLING OMITTED ARGS OF OPERATORS.
*      B3.404  TOO MANY LINES PUT ON FIRST PAGE OF LISTING.
*      B3.405  LEADING UNARY OPERATOR IN EVAL ERRONEOUSLY NEEDED
*              PRECEDING BLANK.
*      B3.406  IDENTIFYING NAME IN DUMP OF ARRAY OR TABLE VALUES
*              WAS OMITTED.
*      B3.407  EVAL UNABLE TO RETURN A DEFERRED EXPRESSION.
*      B3.408  ILLEGAL IF SETEXIT CODE BRANCHES TO RETURN.
*      B3.409  ILLEGAL ON DETACHING INPUT, OUTPUT, TERMINAL.
*
*      CHANGES
*      -------
*
*      C3.401  -SEQU AND -NOSE CONTROL CARDS REMOVED.
*      C3.402  OPTION PROVIDED TO SUPPRESS SYSTEM IDENTIFICATION
*              ON LISTING.
*      C3.403  DESCRIPTION OF SYSBX SLIGHTLY REVISED.
*      C3.404  PERMISSIBLE TO MODIFY SCBLK LENGTH BEFORE TAKING
*              ERROR RETURNS FROM SYSIN, SYSRD, SYSRI.
*      C3.405  CONDITIONAL .CNLD MAY BE DEFINED TO OMIT LOAD().
*      C3.406  CONDITIONAL .CNEX MAY BE DEFINED TO OMIT EXIT().
*      C3.407  TABLE NOW ACCEPTS A THIRD ARGUMENT SPECIFYING
*              DEFAULT INITIAL LOOKUP VALUE.
*      C3.408  ROUTINES SORT, RSORT FOR SORTING ARRAYS AND TABLE
*              INTRODUCED. SPECIFICATION IS AS IN SITBOL.
*              ROUTINES MAY BE OMITTED BY DEFINING .CNSR .
*      C3.409  ERROR IN CODE(), EVAL() CALL NOW CAUSES STATEMENT
*              FAILURE BUT ERRTEXT KEYWORD IS STILL SET.
*      C3.410  ARG TO CODE() MAY CONTAIN EMBEDDED CONTROL CARDS
*              AND COMMENT DELIMITED BY A SEMICOLON.
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.401  PURPOSE OF RESTRICTION 2 IN MINIMAL SECTION -6-
*              (OPERATIONS ON CHAR VALUES), ERRONEOUSLY STATED
*              TO BE FOR CMC, RATHER THAN FOR CEQ, CNE.
*              DESCRIPTIONS OF ABOVE OPCODES REVISED.
*      D3.402  DESCRIPTION OF ENT CLARIFIED.
*      D3.403  DESCRIPTIONS OF SEVERAL OPCODES REVISED TO REMOVE
*              TECHNICALLY INVALID LITERALS E.G. =0 , *1.
*      D3.405  RESTRICTED USE OF LETTER Z IN MINIMAL CLARIFIED.
*      D3.406  DIVIDE BY ZERO EXPLICITLY MENTIONED IN RELATION
*              TO OVERFLOW SETTING.
{{EJC{{{{{818
*      VERSION 3.3 TO 3.4 (OCT 78)
*      ---------------------------
*
*
*      BUGS FIXED
*      ----------
*
*      B3.301  ILLEGAL FOR ERRONEOUS EVAL() ARG.
*      B3.302  ADDRESS ARITHMETIC OVERFLOW IN ALLOC AND ALOCS.
*      B3.303  -EJECT AND -SPACE IGNORED -NOLIST OPTION.
*      B3.304  ERRONEOUS ARGUMENT SCAN IN LOAD().
*      B3.305  ERRONEOUS PLC ON UNINITIALISED R$CIM IN NEXTS.
*      B3.306  LDI USED INSTEAD OF MTI AFTER PRV07.
*      B3.307  MISUSE OF RMI AT ERRA2.
*      B3.308  MISUSE OF MTI IN HASHS.
*      B3.309  BUG IN -SEQU CARD SEQUENCE NUMBER CHECKING.
*      B3.310  STACK OVERFLOW ERROR MESSAGE NOT ALWAYS PRINTED.
*      B3.311  CORRUPT PROTOTYPE PRINT FOR TRACED ARRAYS.
*      B3.312  PATTERN FIRST ARG IN DUPL CAUSED ERROR.
*      B3.313  OMITTED CSC IN S$RPD, ERRONEOUS CSC IN CONVERT.
*      B3.314  MISPLACED BTW IN EXBLD.
*      B3.315  INCORRECT CODE IN HASHS.
*      B3.316  FAILURE OF LOAD TO SCAN INTEGER ARG.
*      B3.317  TABLE ACCESS WITH NEGATIVE INTEGER ARG. FAILED.
*      B3.318  ERROR IN RETURNING RESULT OF LOADED FUNCTION.
*      B3.319  =E$SRS USED AFTER INI01 INSTEAD OF *E$SRS.
*      B3.320  ERR USED INSTEAD OF ERB AFTER SYSTU
*      B3.321  LABEL COULD START WITH DISALLOWED CHARACTER.
*      B3.322  CONTINUE AFTER SETEXIT HAD BAD HEURISTIC.
{{EJC{{{{{848
*
*
*      CHANGES
*      -------
*
*      C3.301  SYSAX AND .CSAX INTRODUCED - SEE SYSAX
*              IN PROCEDURES SECTION.
*      C3.302  VARIABLE MXLEN INTRODUCED. CONTAINS THE MAXIMUM
*              SIZE OF A SPITBOL OBJECT AND IS NOT CHANGEABLE
*              AFTER INITIALISATION. MAY BE DEFAULTED OR SET
*              EXPLICITLY BY SYSMX.
*      C3.303  SYSHS RETURNS REVISED - SEE SYSHS.
*      C3.304  NEW MINIMAL OPCODE AOV TO FIX B3.302.
*      C3.305  INHIBIT STLIMIT CHECK IF STLIMIT MADE NEGATIVE.
*      C3.306  CFP$M IS REQUIRED TO BE OF FORM 2**N - 1.
*      C3.307  DUPL MADE TO CONFORM TO SIL SNOBOL4 STANDARD.
*      C3.308  LCH AND SCH ACTIONS MORE CLOSELY DEFINED.
*      C3.309  BATCH INITIALISATION CODE OMITTED IF CONDITIONAL
*              ASSEMBLY SYMBOL .CNBT (NO BATCH) DEFINED.
*      C3.310  (WA) CONTAINS ARGUMENT COUNT IN SYSEX CALL.
*      C3.311  SYSFC  MAY REQUEST ALLOCATION OF STATIC FCBLK.
*      C3.312  IF IA,WC OVERLAP, RESTRICTION PUT ON DUMPING/
*              RESTORING THESE REGISTERS.
*      C3.313  NEW LISTING OPTION INTERMEDIATE BETWEEN COMPACT
*              AND EXTENDED PROVIDED (SEE SYSPP).
*      C3.314  REVISION OF SYSXI INTERFACE TO PERMIT OPTIONS FOR
*              LOAD MODULE STANDARD O/P FILE (SEE SYSXI,SYSPP).
*      C3.315  LAST ARG OF SUBSTR MAY BE OMITTED - TREATED
*              AS REMAINDER OF STRING.
{{EJC{{{{{878
*      VERSION 3.2 TO 3.3 (JAN 78)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.201  ARRAY REFERENCE AND EXTERNAL FUNCTION LOAD
*              ROUTINES ILLEGALLY ACCESSED INFORMATION
*              BEYOND THE STACK FRONT.
*              SIMILAR FAULT IN UNANCHORED PATTERN MATCHING.
*      B3.202  DUMP(1) PRODUCED DUMP(2) TYPE OUTPUT.
*      B3.203  WTB CONVERSION OMITTED IN CODE FOLLOWING
*              INI01, INI02, EXBLD.
*      B3.204  INCORRECT FAIL RETURN FROM TFIND IN ARREF.
*      B3.205  ENDFILE DID NOT DETACH I/O ASSOCIATED VARIABLES.
*      B3.206  -SPACE WITH OMITTED ARG. FAILED
*      B3.207  LOOPED IF DUMP KEYWORD NON-ZERO AFTER STACK
*              OVERFLOW IN GARBAGE COLLECT FAILURE.
*      B3.208  FAILURE IN READING NUMBERS WITH TRAILING BLANKS.
*
*      CHANGES
*      -------
*
*      THE EXTENSIVE CHANGES MADE HERE MOSTLY RESULT FROM A
*      SNOBOL4 IMPLEMENTORS MEETING HELD AT NEW YORK UNIVERSITY
*      IN AUGUST 1977. THEY ARE AIMED AT
*           (1) HAVING SPITBOL CONFORM TO CERTAIN SNOBOL4
*           LANGUAGE STANDARDS  AND
*           (2) PRODUCING A STABLE DEFINITION OF MINIMAL BY
*           CARRYING OUT A FEW ESSENTIAL REVISIONS IN THE LIGHT
*           OF EXPERIENCE IN ITS USE.
*
*      CHANGES TO SPITBOL
*      ------------------
*
*      C3.201  DEFAULT VALUES FOR KEYWORDS TRIM AND ANCHOR ARE
*              ZERO. ON SYSTEMS WHERE RECORDS ARE CUSTOMARILY
*              HANDLED WITHOUT TRALING BLANKS, THERE IS NO
*              OBLIGATION TO SUPPLY SUCH BLANKS.
*      C3.202  DEFAULT VALUE OF -INXX CONTROL CARD IS -IN72.
{{EJC{{{{{919
*      C3.203  THE SECOND ARGUMENT OF INPUT AND OUTPUT IS
*              PERMITTED TO BE AN INTEGER AS IN SNOBOL4.
*              IN ADDITION INPUT(), OUTPUT() NOW GIVE A SNOBOL4
*              STATEMENT FAILURE IF SYSIO USES THE FILE NOT
*              FOUND RETURN.
*              THE THIRD ARGUMENT HAS A RECOMMENDED FORMAT AND
*              TO OVERRIDE ITS DEFAULT DELIMITER (,) A
*              CONDITIONAL ASSEMBLY SYMBOL, .CIOD, IS USED.
*              INTERFACES TO SYSEF,SYSEJ,SYFC,SYSIO,SYSRW
*              ARE REVISED.
*              WC MAY NOW BE USED TO RETURN FROM SYSIO, A MAX
*              RECORD LENGTH.
*      C3.204  A NEW CONFIGURATION PARAMETER CFP$F (SCBLK OFFSET
*              IS INTRODUCED. CFP$U IS REMOVED.
*      C3.205  IMPLEMENTATION AND VERSION IDENTIFICATION IS
*              REQUIRED - SEE SYSID.
*      C3.206  ROUTINE SYSMX RETURNS THE MAXIMUM LENGTH OF
*              SPITBOL OBJECTS (STRINGS ARRAYS ETC).  THIS
*              INFORMATION IS NOT NOW NEEDED AT TIME OF ENTRY TO
*              SPITBOL AND HENCE WC SHOULD BE ZERO ON ENTRY.
*      C3.207  A CONDITIONAL PARAMETER .CNRA PERMITS ASSEMBLY
*              OF A MORE COMPACT VERSION WITH NO REAL
*              ARITHMETIC CODE.
*      C3.208  TERMINAL IS A NEW PRE-ASSOCIATED VARIABLE
*              CAPABLE OF PERFORMING INPUT AND OUTPUT TO AN
*              ONLINE TERMINAL.
*              SYSRI IS A NEW ROUTINE USED IN THE IMPLEMENTATION
*              OF THIS. SEE ALSO SYSPP.
*      C3.209  THE ENVIRONMENT PARAMETERS E$--- ARE NOW
*              PROVIDED BY THE MINIMAL TRANSLATOR USING THE
*              REVISED   EQU  *   FORMAT (SEE C3.229 AND START
*              OF SPITBOL DEFINITIONS SECTION - SOME REORDERING
*              OF SYMBOLS HAS OCCURRED).
*      C3.210  THE INTERFACE OF SYSXI HAS BEEN SLIGHTLY REVISED.
*              UNAVAILABILITY OF I/O CHANNELS AFTER EXIT(1),
*              EXIT(-1) IS DOCUMENTED TOGETHER WITH ADDITIONAL
*              ERROR RETURN USAGE FOR SYSIN,SYSOU,SYSPR,SYSRD.
*      C3.211  SPITBOL ERROR CODES HAVE BEEN FROZEN - SEE C3.230
*      C3.212  THE UTILITY ROUTINES ARREF ETC. ARE NOW
*              INTRODUCED BY RTN STATEMENTS.
*      C3.213  SYSRL (RECORD LENGTH FOR STD INPUT FILE) IS
*              REMOVED. SINCE IMPLEMENTATION OF A GENERAL -INXXX
*              CONTROL CARD AND AN ABILITY TO SPECIFY MAX RECORD
*              LENGTH USING THE THIRD ARGUMENT OF INPUT, SYSRL
*              HAS BECOME REDUNDANT.
*      C3.214  SYSEJ AND SYSXI ARE NOW PASSED A CHAIN LINKING
*              ALL FCBLKS IN USE.
*      C3.215  A SPECIAL ENDING CODE IN SYSEJ IS USED WHEN
*              ATTEMPTS TO USE STANDARD OUTPUT CHANNEL FAIL.
*      C3.216  RESTRICTION C3.233 OBSERVED SO SIMPLIFYING
*              OPTIMISED TRANSLATION OF ENT WITH OMITTED VAL.
{{EJC{{{{{971
*
*      CHANGES TO MINIMAL
*      ------------------
*
*      C3.220  MINIMAL OPCODES DEC, DIM, INC, AND BMP
*              ARE WITHDRAWN AND REPLACED BY THE MORE CONSISTENT
*              SET DCA, DCV, ICA, ICV.
*      C3.221  CHS HAS BEEN REPLACED BY THE MORE GENERALLY
*              USEFUL ZGB (STILL LIKELY TO BE A NO-OP FOR MOST
*              IMPLEMENTATIONS HOWEVER).
*      C3.222  THE SET OF CHARACTER COMPARISONS HAS BEEN
*              REDUCED TO CEQ AND CNE TO EASE IMPLEMENTATION
*              PROBLEMS.
*      C3.223  OPCODE IRZ IS REMOVED AND DVI, RMI ORDERS ARE
*              REDEFINED TO CONFORM TO MORE COMMON USAGE.
*      C3.224  NEW OPCODES SSL AND SSS ARE DEFINED. THEIR USE
*              PERMITS RETURN LINKS FOR N TYPE PROCEDURES TO BE
*              PLACED ON A LOCAL STACK IF DESIRED.
*      C3.225  OPCODE MNZ COMPLEMENTS ZER. IT MOVES A NON-ZERO
*              FLAG TO ITS DESTINATION.
*      C3.226  FOR SOME MACHINES IT IS PREFERABLE FOR THE STACK
*              TO BUILD UP RATHER THAN DOWN. TO PERMIT THIS
*              WITHOUT NEED FOR MASSIVE CHANGES IN MINIMAL AND
*              RECODING OF EXISTING PROGRAMS, A SCHEME HAS BEEN
*              DEVISED IN WHICH AN ADDITIONAL REGISTER NAME, XT,
*              IS USED AS A SYNONYM FOR XL WHEN THIS REGISTER
*              IS INVOLVED IN STACK MANIPULATION- SEE SECTION 4.
*      C3.227  SECTION 0 OF A MINIMAL PROGRAM IS RENAMED THE
*              PROCEDURE SECTION. IT NOW CONTAINS, IN ADDITION
*              TO EXP, SPECIFICATIONS OF INTERNAL PROCEDURES
*              AND ROUTINES BY MEANS OF THE INP AND INR OPCODES.
*      C3.228  THE LITERAL OPERAND FORMATS =INT AND *INT HAVE
*              BEEN WITHDRAWN. =DLBL AND *DLBL MUST BE USED IN
*              THEIR STEAD.
*      C3.229  THE FORMAT
*              LABEL  EQU  *NN
*              USED TO SPECIFY VALUES SUPPLIED BY THE MINIMAL
*              TRANSLATOR FOR CHAR. CODES ETC. IS REPLACED BY
*              LABEL  EQU  *
*              WHERE THE ORDER IN WHICH THE DEFINITIONS ARE
*              SUPPLIED BY THE TRANSLATOR SHOULD MATCH THE
*              ORDER OF OCCURRENCE IN THE DEFINITIONS SECTION.
*      C3.230  THE FORMAT OF ERR,ERB OPCODES IS CHANGED TO
*              REQUIRE A NUMERIC OPERAND.
*      C3.231  THE RTN OPCODE IS USED TO INTRODUCE ROUTINES
*              (WHICH ARE QUITE DISTINCT FROM PROCEDURES).
*      C3.232  CONDITIONAL ASSEMBLY DIRECTIVES MAY BE NESTED.
*      C3.233  MINOR RESTRICTION PLACED ON THE OMISSION OF
*              VAL WITH THE ENT OPCODE.
{{EJC{{{{{1021
*      VERSION 3.1 TO 3.2 (AUG 77)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.101  ASTONISHING THIS WAS UNNOTICED FOR THREE YEARS.
*              BAD CODE FOR SNOBOL4 INTEGER DIVIDE, /, GAVE
*              WRONG RESULT FOR OPERANDS OF OPPOSITE SIGNS.
*              IMPLEMENTATIONS HAVE EITHER WRONGLY TRANSLATED
*              DVI AND GOT CORRECT RESULT OR CORRECTLY
*              TRANSLATED DVI AND GOT WRONG RESULT - LEEDS HAD
*              ONE OF EACH. SEE ALSO C3.106.
*              TEST PROGRAM NO. 1 NOW EXTENDED TO CHECK /
*              MORE THOROUGHLY.
*      B3.102  GARBAGE COLLECTION BUG IN SCANE
*
*      CHANGES
*      -------
*
*      C3.101  OPTION TO USE ADDITIONAL CHARACTERS CH$HT,CH$VT
*              (HORIZONTAL AND VERTICAL TAB) WITH SAME SYNTACTIC
*              SIGNIFICANCE AS CH$BL (BLANK).
*      C3.102  OPTION TO USE A SET OF SHIFTED CASE ALPHABETIC
*              CHARACTERS CH$$A ... CH$$$.
*      C3.103  CONDITIONAL ASSEMBLY FEATURES ARE INTRODUCED INTO
*              MINIMAL ON ACCOUNT OF THE ABOVE.
*              SEE MINIMAL DOCUMENTATION SECTION FOR DETAILS
*              OF ABOVE CHANGES.
*      C3.104  LCH AND SCH MAY USE AN X REGISTER FIRST
*              OPERAND AS ALTERNATIVE TO A W REGISTER.
*      C3.105  SPITBOL STATEMENT NUMBERS IN THE LISTING MAY
*              OPTIONALLY BE PADDED TO 6 OR 8 CHARS INSTEAD OF 5
*              BY DEFINING CONDITIONAL ASSEMBLY SYMBOLS
*              .CSN6 OR .CSN8 .
*      C3.106  TO FIX BUG 3.101. AT MODERATE COST,
*              OPCODE IRZ (BRANCH IF INTEGER DIVIDE REMAINDER
*              ZERO) INTRODUCED.
*      C3.107  TO HANDLE POSSIBLE MACHINE DEPENDENCY IN STRING
*              HASHING, CHS (COMPLETE HASHING OF STRING) OPCODE
*              IS INTRODUCED. PROBABLY A NO-OP ON MOST MACHINES
*              - NOT ON THE DEC10.
*      C3.108  PROCEDURES PATIN,TFIND,TRACE HAVE BEEN
*              MODIFIED TO CONFORM TO THE MINIMAL STANDARD
*              CALL AND RETURN REGIME.
*      C3.109  SYSFC INTERFACE REVISED SLIGHTLY TO PERMIT
*              OSINT TO RETURN A POINTER TO A PRIVATELY
*              ALLOCATED FCBLK WHICH SPITBOL WILL RETURN ON
*              SUBSEQUENT I/O - SEE SYSFC DOC.
*      C3.110  TO REMOVE INCONSISTENCIES IN CALLING SEQUENCES,
*              ALL SYS ROUTINES HAVING ACCESS TO A POSSIBLE
*              FCBLK HAVE FCBLK PTR OR ZERO IN REG. WA ON ENTRY.
*              CHANGE AFFECTS SYSEF, SYSEN, SYSIL, SYSIN,
*              SYSOU, SYSRW.
*      C3.111  SYSPP BIT ALLOCATED TO PROVIDE
*               -NOEXEC OPTION ON ENTRY TO SPITBOL.
{{EJC{{{{{1078
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.101  NEED TO PRESERVE REGISTERS IN SYSPI, SYSPR,
*              SYSRD CALLS WAS OVERSTATED.
{{EJC{{{{{1085
*      VERSION 3.0 TO 3.1 (MAR 77)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.001  REPLACE() COULD FAIL DURING PRE-EVALUATION.
*              SPITBOL NOW SIGNALS AN ERROR FOR NULL OR
*              UNEQUALLY LONG 2ND AND 3RD ARGUMENTS.
*      B3.002  NEGATIVE SECOND ARGUMENTS TO DUPL, LPAD, RPAD
*              CAUSED SPITBOL TO SIGNAL AN ERROR. NOW CAUSES
*              RETURN OF NULL STRING OR FIRST ARG RESPECTIVELY.
*      B3.003  BRN-S USED INSTEAD OF PPM-S IN S$SUB.
*      B3.004  ERR USED INSTEAD OF ERB AFTER CMP30.
*      B3.005  B$PFC, S$CNV, S$DEF, ARITH AND ARREF KEPT
*              INFORMATION ILLEGALLY ABOVE THE STACK TOP.
*      B3.006  PRE-EVALUATION OF CONSTANT PARTS OF
*              COMPLEX GOTOS WAS ERRONEOUS.
*      B3.007  INCORRECT HANDLING OF LABELS COMPILED BY CODE().
*      B3.008  THE SINGLE USE OF TRC (IN S$RPL) WAS NOT IN
*              ACCORD WITH ITS DEFINITION. SOME TRANSLATIONS OF
*              TRC MAY NEED REVISION NOW THAT THE USE
*              HAS BEEN BROUGHT INTO LINE WITH DEFINITION.
*
*      CHANGES
*      -------
*
*      A DEBATE ON A FEW WEAKNESSES IN MINIMAL DESIGN HAS
*      BEEN RESOLVED BY INTRODUCING 4 NEW OPCODES.
*
*      C3.001  NEW MINIMAL OPCODES BMP AND DIM INTRODUCED
*              TO AUGMENT INC AND DEC WHICH ARE APPLICABLE
*              ONLY TO ADDRESSES.
*      C3.002  THE OPCODE SZC (STORE ZERO CHARACTERS) HAD
*              A RESTRICTED APPLICABILITY. IT HAS BEEN
*              REPLACED BY THE MORE GENERAL ZER (ZEROISE).
*      C3.003  FCBLKS MAY BE OPTIONALLY ALLOCATED AS XRBLK-S OR
*              XNBLK-S  - SEE SYSFC FOR VITAL INFORMATION.
*      C3.004  CONTROL CARD PROCESSING HAS BEEN RECODED.
*              -INXXX ALLOWS SPECIFICATION OF STANDARD INPUT
*              FILE RECORD LENGTHS OTHER THAN 72 OR 80, SEE ALSO
*              SYSRL. -SEQU IS IGNORED UNLESS -IN80 IS IN EFFECT
*      C3.005  TO ENABLE EFFICIENT BUFFERING OF CHARS ON
*              MACHINES WITHOUT CHAR. HANDLING ORDERS, THE
*              CSC (COMPLETE STORE CHARACTERS) INSTRUCTION
*              IS INTRODUCED. CURRENT IMPLEMENTATIONS CAN
*              TRANSLATE IT AS A NO-OP IF IT IS OF NO BENEFIT.
*      C3.006  INTEGERS 0,1,2 ARE TREATED SPECIALLY.
*              ICBLKS IN STATIC ARE USED INSTEAD OF
*              ALLOCATING SPACE IN DYNAMIC.
{{EJC{{{{{1136
*
*      VERSION 2.7 (JUNE 76) TO 3.0 (JAN 77)
*      -------------------------------------
*
*      BUGS FIXED
*      ----------
*
*      B2.701  GOES ILLEGAL IF TIMED OUT DURING PROCESSING OF
*              DUMP() CALL.
*      B2.702  GOES ILLEGAL IF SPITBOL ERROR DETECTED IN ARGS OF
*              CODE() OR EVAL(). BUG FIXED SO THAT USER NOW GETS
*              A SPITBOL ERROR REPORT (TRAPPABLE BY SETEXIT)
*              BEFORE STATEMENT FAILURE.
*      B2.703  GOES ILLEGAL IN SOME CIRCUMSTANCES WHEN
*              MULTIPLE COMPILATION ERRORS OCCUR IN A STATEMENT
*      B2.704  GOES ILLEGAL IF GARBAGE COLLECTOR RUNS OUT OF
*              STACK SPACE.
*      B2.705  CONTROL CARD PROCESSING INCORRECT FOR CDC 6400.
*      B2.706  INCORRECT HANDLING OF MULTIPLE OCCURRENCES OF
*              CHARS IN REPLACE 2ND AND 3RD ARGS.
*      B2.707  STACK OVERFLOW IN PRE-EVALUATION OF REPLACE IN
*              CDC 6400 VERSION.
*      B2.708  AN EXPLICIT CALL OF SYSMW WAS CODED IN S$DAT
*              INSTEAD OF THE MVW OPCODE.
*      B2.709  CALL OF GARBAGE COLLECTOR WHILST DUMPING
*              CAUSED HAVOC.
*      B2.710  SIZE RESTRICTION ON SPITBOL OBJECTS (SIZE MUST BE
*              NUMERICALLY LESS THAN LOWEST DYNAMIC ADDRESS)
*              WAS NOT ENFORCED, WITH POTENTIAL FOR CATASTROPHE.
*      B2.711  DEFERRED EXPRESSIONS INVOLVING ALTERNATION OR
*              NEGATION WERE INCORRECTLY TRANSLATED.
*      B2.712  LISTING OF A COMPILATION ERROR AT THE END OF A
*              LONG LINE COULD CAUSE COMPILER TO GO ILLEGAL.
*      B2.713  INCORRECT -NOFAIL CODE WITH SUCCESS GOTO.
{{EJC{{{{{1171
*
*
*      CHANGES
*      -------
*
*      (IT IS NOT ANTICIPATED THAT MAJOR REVISIONS ON THIS
*      SCALE WILL BE FREQUENT).
*
*      C2.701  DEFAULT VALUE OF ANCHOR KEYWORD IS SET TO 1. THIS
*              CONFLICTS WITH SNOBOL4 PRACTICE BUT IS A
*              PREFERABLE DEFAULT FOR MOST APPLICATIONS.
*      C2.702  IF ERRTYPE IS OUT OF RANGE THE STRING IN KEYWORD
*              ERRTEXT IS PRINTED AS THE ERROR MESSAGE.
*      C2.703  IF STLIMIT IS EXCEEDED, UP TO 10 MORE STATEMENTS
*              MAY BE OBEYED TO PERMIT SETEXIT TRAP TO GAIN
*              CONTROL.
*      C2.704  THE CONCEPT OF AN INTERACTIVE CHANNEL IS
*              INTRODUCED FOR IMPLEMENTATIONS WHERE AN ONLINE
*              TERMINAL MAY BE USED FOR SPITBOL. THE STANDARD
*              PRINT FILE MAY BE SPECIFIED AS INTERACTIVE IN
*              WHICH CASE SHORTER TITLE LINES ARE OUTPUT.
*              ALTERNATIVELY COPIES OF COMPILATION AND
*              EXECUTION ERRORS ONLY MAY BE SENT TO THIS CHANNEL
*      C2.705  PRINTING OF COMPILATION STATISTICS MAY BE
*              SUPPRESSED.
*      C2.706  PRINTING OF EXECUTION STATISTICS MAY BE
*              SUPPRESSED.
*      C2.707  EXTENDED OR COMPACT LISTING FORMAT MAY BE
*              SELECTED.
*      C2.708  AN INITIAL -NOLIST OPTION MAY BE SPECIFIED
*              BEFORE COMPILATION STARTS.
*      C2.709  TO SPECIFY CHOICES IMPLIED BY C2.704 TO C2.708
*              SYSPP INTERFACE IS REVISED AND SYSPI IS DEFINED.
*      C2.710  COMPILATION AND EXECUTION TIME STATISTICS
*              MESSAGES HAVE BEEN SHORTENED.
*      C2.711  THE EXIT FUNCTION AS IN SITBOL IS INTRODUCED
*              TO PERMIT SAVING LOAD MODULES - SEE SYSXI, S$EXT.
*      C2.712  DIAGNOSTIC ROUTINES SYSGB AND SYSGD HAVE BEEN
*              REMOVED. THEY WERE USEFUL IN THE EARLY DEBUGGING
*              DAYS BUT HAVE FALLEN INTO DISUSE NOW.
*      C2.713  SZC MAY HAVE AN OPERAND OF TYPE OPN INSTEAD OF
*              TYPE OPW
*      C2.714  INPUT/OUTPUT ASSOCIATION INTERFACE HAS BEEN
*              REVISED. SYSIF,SYSOF HAVE BEEN CONSOLIDATED INTO
*              THE NEW SYSTEM ROUTINE, SYSIO, AND THE
*              SPECIFICATION OF SYSFC HAS BEEN SLIGHTLY CHANGED.
*      C2.715  CONFIGURATION PARAMETER MXLEN HAS BEEN WITHDRAWN
*              AND THE MAXIMUM SIZE OF A SPITBOL OBJECT WHICH
*              WAS FORMERLY FIXED AT SPITBOL COMPILE TIME BY
*              REFERENCE TO IT MAY NOW BE SPECIFIED AS A RUN
*              TIME OPTION BY PLACING A VALUE IN WC BEFORE ENTRY
*              TO SPITBOL. (SEE COMMENT ON DYNAMIC AREA IN
*              BASIC INFORMATION SECTION).
*      C2.716  A FUNCTION, HOST, IS INTRODUCED WHICH YIELDS
*              INFORMATION ABOUT THE HOST MACHINE - SEE SYSHS
*              AND S$HST.
{{EJC{{{{{1228
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D2.701  THE DESCRIPTION OF MVC HAS BEEN REVISED TO
*              REFLECT THE FACT THAT SOME SPITBOL CODE SEQUENCES
*              RELY ON MVC NOT DESTROYING WB. MINOR CHANGES
*              HAVE BEEN MADE TO MWB AND MVW DESCRIPTIONS TO
*              EMPHASISE SIMILARITIES IN THE IMPLICIT LOOPS OF
*              THESE ORDERS.
*      D2.702  DESCRIPTIONS OF DVI AND RMI HAVE BEEN CLARIFIED.
*      D2.703  IMPLEMENTATION OF RSX,LSX,CEQ,CGE,CGT,CHI,CLO,CLT
*              IS OPTIONAL AT PRESENT SINCE THEY ARE CURRENTLY
*              UNUSED. THEIR USE IN LATER VERSIONS IS NOT
*              EXCLUDED.
*      D2.704  IMPOSSIBILITY OF USING STACK FOR RETURN LINKS OF
*              N TYPE PROCEDURES IS EMPHASISED.
*      D2.705  NOTATION (XL),(WC) ETC IN LANGUAGE DESCRIPTION IS
*              CLARIFIED.
*      D2.706  DOCUMENTATION OF SYSFC, SYSIO HAS BEEN IMPROVED.
*      D2.707  OPCODE DESCRIPTIONS ARE CROSS REFERENCED FROM
*              THE ALPHABETICAL OPCODE LIST.
*      D2.708  GENERAL DESCRIPTION OF COMPILER HAS BEEN MOVED TO
*              THE START OF THE COMPILER PROPER.
*      D2.709  DEFINITIONS OF ENVIRONMENT PARAMETERS HAVE BEEN
*              PUT NEAR THE FRONT OF THE DEFINITIONS SECTION.
{{TTL{27,MINIMAL -- MACHINE INDEPENDENT MACRO ASSEMBLY LANG.{{{{1255
{{EJC{{{{{1256
*
*      THE FOLLOWING SECTIONS DESCRIBE THE IMPLEMENTATION
*      LANGUAGE ORIGINALLY DEVELOPED FOR SPITBOL BUT NOW MORE
*      WIDELY USED. MINIMAL IS AN ASSEMBLY LANGUAGE
*      FOR AN IDEALIZED MACHINE. THE FOLLOWING DESCRIBES THE
*      BASIC CHARACTERISTICS OF THIS MACHINE.
*
*      SECTION 1 - CONFIGURATION PARAMETERS
*
*      THERE ARE SEVERAL PARAMETERS WHICH MAY VARY WITH THE
*      TARGET MACHINE. THE MACRO-PROGRAM IS INDEPENDENT OF THE
*      ACTUAL DEFINITIONS OF THESE PARAMETERS.
*
*      THE DEFINITIONS OF THESE PARAMETERS ARE SUPPLIED BY
*      THE TRANSLATION PROGRAM TO MATCH THE TARGET MACHINE.
*
*      CFP$A                 NUMBER OF DISTINCT CHARACTERS IN
*                            INTERNAL ALPHABET IN THE RANGE
*                            64 LE CFP$A LE MXLEN.
*
*      CFP$B                 NUMBER OF BYTES IN A WORD WHERE A
*                            BYTE IS THE AMOUNT OF STORAGE
*                            ADDRESSED BY THE LEAST SIGNIFICANT
*                            ADDRESS BIT.
*
*      CFP$C                 NUMBER OF CHARACTERS WHICH CAN
*                            BE STORED IN A SINGLE WORD.
*
*      CFP$F                 BYTE OFFSET FROM START OF A STRING
*                            BLOCK TO THE FIRST CHARACTER.
*                            DEPENDS BOTH ON TARGET MACHINE AND
*                            STRING DATA STRUCTURE. SEE PLC, PSC
*
*      CFP$I                 NUMBER OF WORDS IN A SIGNED
*                            INTEGER CONSTANT
*
*      CFP$L                 THE LARGEST UNSIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N BUT NEED NOT BE.
*
*      CFP$M                 THE LARGEST POSITIVE SIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N-1 BUT NEED NOT BE.
*
*      CFP$N                 NUMBER OF BITS WHICH CAN BE STORED
*                            IN A ONE WORD BIT STRING.
*
*      CFP$R                 NUMBER OF WORDS IN A REAL CONSTANT
*
*      CFP$S                 NUMBER OF SIGNIFICANT DIGITS TO
*                            BE OUTPUT IN CONVERSION OF A REAL
*                            QUANTITY.
*                            THE INTEGER CONSISTING OF
*                            THIS NUMBER OF 9S MUST NOT BE TOO
*                            LARGE TO FIT IN THE INTEGER ACCUM.
*
*      CFP$U                 REALISTIC UPPER BOUND ON ALPHABET.
*
*
*      CFP$X                 NUMBER OF DIGITS IN REAL EXPONENT
{{EJC{{{{{1324
*
*      SECTION 2 - MEMORY
*
*      MEMORY IS ORGANIZED INTO WORDS WHICH EACH CONTAIN CFP$B
*      BYTES. FOR WORD MACHINES CFP$B, WHICH IS A CONFIGURATION
*      PARAMETER, MAY BE ONE IN WHICH CASE WORDS AND BYTES ARE
*      IDENTICAL. TO EACH WORD CORRESPONDS AN ADDRESS WHICH IS
*      A NON-NEGATIVE QUANTITY WHICH IS A MULTIPLE OF CFP$B.
*      DATA IS ORGANIZED INTO WORDS AS FOLLOWS.
*
*      1)   A SIGNED INTEGER VALUE OCCUPIES CFP$I CONSECUTIVE
*           WORDS (CFP$I IS A CONFIGURATION PARAMETER).
*           THE RANGE MAY INCLUDE MORE NEGATIVE NUMBERS THAN
*           POSITIVE (E.G. THE TWOS COMPLEMENT REPRESENTATION).
*
*      2)   A SIGNED REAL VALUE OCCUPIES CFP$R CONSECUTIVE
*           WORDS. (CFP$R IS A CONFIGURATION PARAMETER).
*
*      3)   CFP$C CHARACTERS MAY BE STORED IN A SINGLE WORD
*           (CFP$C IS A CONFIGURATION PARAMETER).
*
*      4)   A BIT STRING CONTAINING CFP$N BITS CAN BE STORED IN
*           A SINGLE WORD (CFP$N IS A CONFIGURATION PARAMETER).
*
*      5)   A WORD CAN CONTAIN A UNSIGNED INTEGER VALUE IN
*           THE RANGE (0 LE N LE CFP$L). THESE INTEGER VALUES
*           MAY REPRESENT ADDRESSES OF OTHER WORDS AND SOME OF
*           THE INSTRUCTIONS USE THIS FACT TO PROVIDE INDEXING
*           AND INDIRECTION FACILITIES.
*
*      6)   PROGRAM INSTRUCTIONS OCCUPY WORDS IN AN UNDEFINED
*           MANNER. DEPENDING ON THE ACTUAL IMPLEMENTATION,
*           INSTRUCTIONS MAY OCCUPY SEVERAL WORDS, OR PART OF
*           A WORD, OR EVEN BE SPLIT OVER WORD BOUNDARIES.
*
*      THE FOLLOWING REGIONS OF MEMORY ARE AVAILABLE TO THE
*      PROGRAM. EACH REGION CONSISTS OF A SERIES OF WORDS WITH
*      CONSECUTIVE ADDRESSES.
*
*      1)   CONSTANT SECTION           ASSEMBLED CONSTANTS
*      2)   WORKING STORAGE SECTION    ASSEMBLED WORK AREAS
*      3)   PROGRAM SECTION            ASSEMBLED INSTRUCTIONS
*      4)   STACK AREA                 ALLOCATED STACK AREA
*      5)   DATA AREA                  ALLOCATED DATA AREA
{{EJC{{{{{1369
*
*      SECTION 3 - REGISTERS
*
*      THERE ARE THREE INDEX REGISTERS CALLED XR,XL,XS. IN
*      ADDITION XL MAY SOMETIMES BE REFERRED TO BY THE ALIAS
*      OF XT - SEE SECTION 4. ANY OF THE ABOVE REGISTERS
*      MAY HOLD A POSITIVE UNSIGNED INTEGER IN THE RANGE
*      (0 LE N LE CFP$L). WHEN THE INDEX REGISTER IS USED FOR
*      INDEXING PURPOSES, THIS MUST BE AN APPROPRIATE ADDRESS.
*      XS IS SPECIAL IN THAT IT IS USED TO POINT TO THE TOP
*      ITEM OF A STACK IN MEMORY. THE STACK MAY BUILD UP OR
*      DOWN IN MEMORY.SINCE IT IS REQUIRED THAT XS POINTS TO THE
*      STACK TOP BUT ACCESS TO ITEMS BELOW THE TOP IS PERMITTED,
*      REGISTERS XS AND XT MAY BE USED WITH SUITABLE OFFSETS
*      TO INDEX STACKED ITEMS. ONLY XS AND XT MAY BE USED FOR
*      THIS PURPOSE SINCE THE DIRECTION OF THE OFFSET IS
*      TARGET MACHINE DEPENDENT. XT IS A SYNONYM FOR XL
*      WHICH THEREFORE CANNOT BE USED IN CODE SEQUENCES
*      REFERENCING XT.
*
*      THE STACK IS USED FOR S-R LINKAGE AND TEMPORARY
*      DATA STORAGE FOR WHICH THE STACK ARRANGEMENT IS SUITABLE.
*      XR,XL CAN ALSO CONTAIN A CHARACTER POINTER IN CONJUNCTION
*      WITH THE CHARACTER INSTRUCTIONS (SEE DESCRIPTION OF PLC).
{{EJC{{{{{1394
*
*      THERE ARE THREE WORK REGISTERS CALLED WA,WB,WC WHICH
*      CAN CONTAIN ANY DATA ITEM WHICH CAN BE STORED IN A
*      SINGLE MEMORY WORD. IN FACT, THE WORK REGISTERS ARE JUST
*      LIKE MEMORY LOCATIONS EXCEPT THAT THEY HAVE NO ADDRESSES
*      AND ARE REFERENCED IN A SPECIAL WAY BY THE INSTRUCTIONS.
*
*      NOTE THAT REGISTERS WA,WB HAVE SPECIAL USES IN CONNECTION
*      WITH THE CVD, CVM, MVC, MVW, MWB, CMC, TRC INSTRUCTIONS.
*
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE FOLLOWING RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*          RESTRICTION
*          -----------
*
*      IF IA AND WC OVERLAP THEN
*          STI  IASAV
*          LDI  IASAV
*      DOES NOT CHANGE WC, AND
*          MOV  WC,WCSAV
*          MOV  WCSAV,WC
*      DOES NOT CHANGE IA.
*
*
*
*      THERE IS AN INTEGER ACCUMULATOR (IA) WHICH IS CAPABLE OF
*      HOLDING A SIGNED INTEGER VALUE (CFP$I WORDS LONG).
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE ABOVE RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*
*
*      THERE IS A SINGLE REAL ACCUMULATOR (RA) WHICH CAN HOLD
*      ANY REAL VALUE AND IS COMPLETELY SEPARATE FROM ANY OF
*      THE OTHER REGISTERS OR PROGRAM ACCESSIBLE LOCATIONS.
*
*
*
*      THE CODE POINTER REGISTER (CP) IS A SPECIAL INDEX
*      REGISTER FOR USE IN IMPLEMENTATIONS OF INTERPRETORS.
*      IT IS USED TO CONTAIN A PSEUDO-CODE POINTER AND CAN
*      ONLY BE AFFECTED BY ICP, LCP, SCP AND LCW INSTRUCTIONS.
{{EJC{{{{{1444
*      SECTION 4 - THE STACK
*
*      THE FOLLOWING NOTES ARE TO GUIDE BOTH IMPLEMENTORS OF
*      SYSTEMS WRITTEN IN MINIMAL AND MINIMAL PROGRAMMERS IN
*      DEALING WITH STACK MANIPULATION. IMPLEMENTATION OF A
*      DOWNWARDS BUILDING STACK IS EASIEST AND IN GENERAL IS
*      TO BE PREFERRED, IN WHICH CASE IT IS MERELY NECESSARY TO
*      CONSIDER XT AS AN ALTERNATIVE NAME FOR XL.
*
*      THE MINIMAL VIRTUAL MACHINE INCLUDES A STACK AND HAS
*      OPERAND FORMATS -(XS) AND (XS)+ FOR PUSHING AND POPPING
*      ITEMS WITH AN IMPLICATION THAT THE STACK BUILDS DOWN IN
*      MEMORY (A D-STACK). HOWEVER ON SOME TARGET MACHINES IT IS
*      BETTER FOR THE STACK TO BUILD UP (A U-STACK).
*      A STACK ADDRESSED ONLY BY PUSH AND POP OPERATIONS CAN
*      BUILD IN EITHER DIRECTION WITH NO COMPLICATION BUT
*      SUCH A PURE SCHEME OF STACK ACCESS PROVES RESTRICTIVE.
*      HENCE IT IS PERMITTED TO ACCESS BURIED ITEMS USING AN
*      INTEGER OFFSET PAST THE INDEX REGISTER POINTING TO THE
*      STACK TOP. ON TARGET MACHINES THIS OFFSET WILL BE
*      POSITIVE/NEGATIVE FOR D-STACKS/U-STACKS AND THIS MUST
*      BE ALLOWED FOR IN THE TRANSLATION.
*      A FURTHER RESTRICTION IS THAT AT NO TIME MAY AN ITEM BE
*      PLACED ABOVE THE STACK TOP. FOR SOME OPERATIONS THIS
*      MAKES IT CONVENIENT TO ADVANCE THE STACK POINTER AND THEN
*      ADDRESS ITEMS BELOW IT USING A SECOND INDEX REGISTER.
*      THE PROBLEM OF SIGNED OFFSETS PAST SUCH A REGISTER THEN
*      ARISES. TO DISTINGUISH STACK OFFSETS, WHICH IN SOME
*      IMPLEMENTATIONS MAY BE NEGATIVE, FROM NON-STACK OFFSETS
*      WHICH ARE INVARIABLY POSITIVE, XT, AN ALIAS OR
*      SYNONYM FOR XL IS USED. FOR A U-STACK IMPLEMENTATION, THE
*      MINIMAL TRANSLATOR SHOULD NEGATE THE SIGN OF OFFSETS
*      APPLIED TO BOTH (XS) AND (XT).
*      PROGRAMMERS SHOULD NOTE THAT SINCE XT IS NOT A
*      SEPARATE REGISTER, XL SHOULD NOT BE USED IN CODE WHERE
*      XT IS REFERENCED. OTHER MODIFICATIONS NEEDED IN U-STACK
*      TRANSLATIONS ARE IN THE ADD, SUB, ICA, DCA OPCODES
*      APPLIED TO XS, XT. FOR EXAMPLE
*
*      MINIMAL           D-STACK TRANS.  U-STACK TRANS.
*
*      MOV  WA,-(XS)     SBI  XS,1       ADI  XS,1
*                        STO  WA,(XS)    STO  WA,(XS)
*      MOV  (XT)+,WC     LOD  WC,(XL)    LOD  WC,(XL)
*                        ADI  XL,1       SBI  XL,1
*      ADD  =SEVEN,XS    ADI  XS,7       SBI  XS,7
*      MOV  2(XT),WA     LOD  WA,2(XL)   LOD  WA,-2(XL)
*      ICA  XS           ADI  XS,1       SBI  XS,1
*
*      NOTE THAT FORMS SUCH AS
*      MOV  -(XS),WA
*      ADD  WA,(XS)+
*      ARE ILLEGAL, SINCE THEY ASSUME INFORMATION STORAGE
*      ABOVE THE STACK TOP.
{{EJC{{{{{1499
*      SECTION 5 - INTERNAL CHARACTER SET
*
*      THE INTERNAL CHARACTER SET IS REPRESENTED BY A SET OF
*      CONTIGUOUS CODES FROM 0 TO CFP$A-1. THE CODES FOR THE
*      DIGITS 0-9 MUST BE CONTIGUOUS AND IN SEQUENCE. OTHER
*      THAN THIS, THERE ARE NO RESTRAINTS.
*
*      THE FOLLOWING SYMBOLS ARE AUTOMATICALLY DEFINED TO HAVE
*      THE VALUE OF THE CORRESPONDING INTERNAL CHARACTER CODE.
*
*      CH$LA                 LETTER A
*      CH$LB                 LETTER B
*      .                     .
*      CH$L$                 LETTER Z
*
*      CH$D0                 DIGIT 0
*      .                     .
*      CH$D9                 DIGIT 9
*
*      CH$AM                 AMPERSAND
*      CH$AS                 ASTERISK
*      CH$AT                 AT
*      CH$BB                 LEFT BRACKET
*      CH$BL                 BLANK
*      CH$BR                 VERTICAL BAR
*      CH$CL                 COLON
*      CH$CM                 COMMA
*      CH$DL                 DOLLAR SIGN
*      CH$DT                 DOT (PERIOD)
*      CH$DQ                 DOUBLE QUOTE
*      CH$EQ                 EQUAL SIGN
*      CH$EX                 EXCLAMATION MARK
*      CH$MN                 MINUS
*      CH$NM                 NUMBER SIGN
*      CH$NT                 NOT
*      CH$PC                 PERCENT
*      CH$PL                 PLUS
*      CH$PP                 LEFT PAREN
*      CH$RB                 RIGHT BRACKET
*      CH$RP                 RIGHT PAREN
*      CH$QU                 QUESTION MARK
*      CH$SL                 SLASH
*      CH$SM                 SEMI-COLON
*      CH$SQ                 SINGLE QUOTE
*      CH$UN                 UNDERLINE
*
*      THE FOLLOWING OPTIONAL SYMBOLS ARE INCORPORATED
*      BY DEFINING THE CONDITIONAL ASSEMBLY SYMBOL NAMED.
*
*      26 SHIFTED LETTERS INCORPORATED BY DEFINING .CASL
*
*      CH$$A                 SHIFTED A
*      CH$$B                 SHIFTED B
*      .                     .
*      CH$$$                 SHIFTED Z
*
*      CH$HT                 HORIZONTAL TAB - DEFINE .CAHT
*      CH$VT                 VERTICAL TAB   - DEFINE .CAVT
*      CH$EY                 UP ARROW       - DEFINE .CAEX
{{EJC{{{{{1559
*
*      SECTION 6 - CONDITIONAL ASSEMBLY FEATURES
*
*      SOME FEATURES OF THE INTERPRETER ARE APPLICABLE TO ONLY
*      CERTAIN TARGET MACHINES. THEY MAY BE INCORPORATED OR
*      OMITTED BY USE OF CONDITIONAL ASSEMBLY. THE FULL
*      FORM OF A CONDITION IS -
*      .IF    CONDITIONAL ASSEMBLY SYMBOL    (CAS)
*      .THEN
*             MINIMAL STATEMENTS1   (MS1)
*      .ELSE
*             MINIMAL STATEMENTS2   (MS2)
*      .FI
*      THE FOLLOWING RULES APPLY
*      1.   THE DIRECTIVES .IF, .THEN, .ELSE, .FI MUST
*           START IN COLUMN 1.
*      2.   THE CONDITIONAL ASSEMBLY SYMBOL MUST START WITH A
*           DOT IN COLUMN 8 FOLLOWED BY 4 LETTERS OR DIGITS E.G.
*              .CA$1
*      3.   .THEN IS REDUNDANT AND MAY BE OMITTED IF WISHED.
*      4.   MS1, MS2 ARE ARBITRARY SEQUENCES OF MINIMAL
*           STATEMENTS EITHER OF WHICH MAY BE NULL OR MAY
*           CONTAIN FURTHER CONDITIONS.
*      5.   IF MS2 IS OMITTED, .ELSE MAY ALSO BE OMITTED.
*      6.   .FI IS REQUIRED.
*      7.   CONDITIONS MAY BE NESTED TO A DEPTH DETERMINED
*           BY THE TRANSLATOR (NOT LESS THAN 20, SAY).
*
*      SELECTION OF THE ALTERNATIVES MS1, MS2 IS BY MEANS OF THE
*      DEFINE AND UNDEFINE DIRECTIVES OF FORM -
*      .DEF   CAS
*      .UNDEF CAS
*      WHICH OBEY RULES 1. AND 2. ABOVE AND MAY OCCUR AT ANY
*      POINT IN A MINIMAL PROGRAM, INCLUDING WITHIN A CONDITION.
*      MULTIPLY DEFINING A SYMBOL IS AN ERROR.
*      UNDEFINING A SYMBOL WHICH IS NOT DEFINED IS NOT AN ERROR.
*
*      THE EFFECT IS THAT IF A SYMBOL IS CURRENTLY DEFINED,
*      THEN IN ANY CONDITION DEPENDING ON IT, MS1 WILL BE
*      PROCESSED AND MS2 OMITTED. CONVERSELY IF IT IS UNDEFINED,
*      MS1 WILL BE OMITTED AND MS2 PROCESSED.
*
*      NESTING OF CONDITIONS IS SUCH THAT CONDITIONS
*      IN A SECTION NOT SELECTED FOR PROCESSING MUST NOT BE
*      EVALUATED. NESTED CONDITIONS MUST REMEMBER THEIR
*      ENVIRONMENT WHILST BEING PROCESSED. EFFECTIVELY THIS
*      IMPLIES USE OF A SCHEME BASED ON A STACK WITH .IF, .FI
*      MATCHING BY THE CONDITION PROCESSOR OF THE TRANSLATOR.
{{EJC{{{{{1608
*
*      SECTION 7 - OPERAND FORMATS
*
*      THE FOLLOWING SECTION DESCRIBES THE VARIOUS POSSIBILITIES
*      FOR OPERANDS OF INSTRUCTIONS AND ASSEMBLY OPERATIONS.
*
*      01   INT              UNSIGNED INTEGER LE CFP$L
*      02   DLBL             SYMBOL DEFINED IN DEFINITIONS SEC
*      03   WLBL             LABEL IN WORKING STORAGE SECTION
*      04   CLBL             LABEL IN CONSTANT SECTION
*      05   ELBL             PROGRAM SECTION ENTRY LABEL
*      06   PLBL             PROGRAM SECTION LABEL (NON-ENTRY)
*      07   X                ONE OF THE THREE INDEX REGISTERS
*      08   W                ONE OF THE THREE WORK REGISTERS
*      09   (X)              LOCATION INDEXED BY X
*      10   (X)+             LIKE (X) BUT POST INCREMENT X
*      11   -(X)             LIKE (X) BUT PREDECREMENT X
*      12   INT(X)           LOCATION INT WORDS BEYOND ADDR IN X
*      13   DLBL(X)          LOCATION DLBL WORDS PAST ADDR IN X
*      14   CLBL(X)          LOCATION (X) BYTES BEYOND CLBL
*      15   WLBL(X)          LOCATION (X) BYTES BEYOND WLBL
*      16   INTEGER          SIGNED INTEGER (DIC)
*      17   REAL             SIGNED REAL (DRC)
*      18   =DLBL            LOCATION CONTAINING DAC DLBL
*      19   *DLBL            LOCATION CONTAINING DAC CFP$B*DLBL
*      20   =WLBL            LOCATION CONTAINING DAC WLBL
*      21   =CLBL            LOCATION CONTAINING DAC CLBL
*      22   =ELBL            LOCATION CONTAINING DAC ELBL
*      23   PNAM             PROCEDURE LABEL (ON PRC INSTRUC)
*      24   EQOP             OPERAND FOR EQU INSTRUCTION
*      25   PTYP             PROCEDURE TYPE (SEE PRC)
*      26   TEXT             ARBITRARY TEXT (ERB,ERR,TTL)
*      27   DTEXT            DELIMITED TEXT STRING (DTC)
*
*      THE NUMBERS IN THE ABOVE LIST ARE USED IN SUBSEQUENT
*      DESCRIPTION AND IN SOME OF THE MINIMAL TRANSLATORS.
{{EJC{{{{{1645
*
*      OPERAND FORMATS (CONTINUED)
*
*      THE FOLLOWING SPECIAL SYMBOLS REFER TO A COLLECTION OF
*      THE LISTED POSSIBILITIES
*
*      VAL  01,02                      PREDEFINED VALUE
*
*           VAL IS USED TO REFER TO A PREDEFINED ONE WORD
*           INTEGER VALUE IN THE RANGE 0 LE N LE CFP$L.
*
*      REG  07,08                      REGISTER
*
*           REG IS USED TO DESCRIBE AN OPERAND WHICH CAN BE
*           ANY OF THE REGISTERS (XL,XR,XS,XT,WA,WB,WC). SUCH
*           AN OPERAND CAN HOLD A ONE WORD INTEGER (ADDRESS).
*
*      OPC  09,10,11                   CHARACTER
*
*           OPC IS USED TO DESIGNATE A SPECIFIC CHARACTER
*           OPERAND FOR USE IN THE LCH AND SCH INSTRUCTIONS.
*           THE INDEX REGISTER REFERENCED MUST BE EITHER XR OR
*           XL (NOT XS,XT). SEE SECTION ON CHARACTER OPERATIONS.
*
*      OPS  03,04,09,12,13,14,15       MEMORY REFERENCE
*
*           OPS IS USED TO DESCRIBE AN OPERAND WHICH IS IN
*           MEMORY. THE OPERAND MAY BE ONE OR MORE WORDS LONG
*           DEPENDING ON THE DATA TYPE. IN THE CASE OF MULTIWORD
*           OPERANDS, THE ADDRESS GIVEN IS THE FIRST WORD.
*
*      OPW  AS FOR OPS + 08,10,11      FULL WORD
*
*           OPW IS USED TO REFER TO AN OPERAND WHOSE CAPACITY IS
*           THAT OF A FULL MEMORY WORD. OPW INCLUDES ALL THE
*           POSSIBILITIES FOR OPS (THE REFERENCED WORD IS USED)
*           PLUS THE USE OF ONE OF THE THREE WORK REGISTERS
*           (WA,WB,WC). IN ADDITION, THE FORMATS (X)+ AND -(X)
*           ALLOW INDEXED OPERATIONS IN WHICH THE INDEX REGISTER
*           IS POPPED BY ONE WORD AFTER THE REFERENCE (X)+,
*           OR PUSHED BY ONE WORD BEFORE THE REFERENCE -(X)
*           THESE LATTER TWO FORMATS PROVIDE A FACILITY FOR
*           MANIPULATION OF STACKS. THE FORMAT DOES NOT IMPLY
*           A PARTICULAR DIRECTION IN WHICH STACKS MUST BUILD -
*           IT IS USED FOR COMPACTNESS. NOTE THAT THERE IS A
*           RESTRICTION WHICH DISALLOWS AN INSTRUCTION TO USE
*           AN INDEX REGISTER IN ONE OF THESE FORMATS
*           IN SOME OTHER MANNER IN THE SAME INSTRUCTION.
*           E.G.   MOV  XL,(XL)+   IS ILLEGAL.
*           THE FORMATS -(X) AND (X)+ MAY ALSO BE USED IN
*           PRE-DECREMENTATION, POST-INCREMENTATION TO ACCESS
*           THE ADJACENT CHARACTER OF A STRING.
{{EJC{{{{{1698
*
*      OPERAND FORMATS (CONTINUED)
*
*      OPN  AS FOR OPW + 07            ONE WORD INTEGER
*
*           OPN IS USED TO REPRESENT AN OPERAND LOCATION WHICH
*           CAN CONTAIN A ONE WORD INTEGER (E.G. AN ADDRESS).
*           THIS INCLUDES ALL THE POSSIBILITIES FOR OPW PLUS
*           THE USE OF ONE OF THE INDEX REGISTERS (XL,XR,XT,
*           XS). THE RANGE OF INTEGER VALUES IS 0 LE N LE CFP$L.
*
*      OPV  AS FOR OPN + 18-22         ONE WORD INTEGER VALUE
*
*           OPV IS USED FOR AN OPERAND WHICH CAN YIELD A ONE
*           WORD INTEGER VALUE (E.G. AN ADDRESS). IT INCLUDES
*           ALL THE POSSIBILITIES FOR OPN (THE CURRENT VALUE OF
*           THE LOCATION IS USED) PLUS THE USE OF LITERALS. NOTE
*           THAT ALTHOUGH THE LITERAL FORMATS ARE DESCRIBED IN
*           TERMS OF A REFERENCE TO A LOCATION CONTAINING AN
*           ADDRESS CONSTANT, THIS LOCATION MAY NOT ACTUALLY
*           EXIST IN SOME IMPLEMENTATIONS SINCE ONLY THE VALUE
*           IS REQUIRED. A RESTRICTION IS PLACED ON LITERALS
*           WHICH MAY CONSIST ONLY OF DEFINED SYMBOLS AND
*           CERTAIN LABELS. CONSEQUENTLY SMALL INTEGERS TO BE
*           USED AS LITERALS MUST BE PRE-DEFINED, A DISCIPLINE
*           AIDING PROGRAM MAINTENANCE AND REVISION.
*
*      ADDR 01,02,03,04,05             ADDRESS
*
*           ADDR IS USED TO DESCRIBE AN EXPLICIT ADDRESS VALUE
*           (ONE WORD INTEGER VALUE) FOR USE WITH DAC.
*
*
*           ****************************************************
*           *   IN THE FOLLOWING DESCRIPTIONS THE USAGE --     *
*           *      (XL),(XR), ... ,(IA)                        *
*           *   IN THE DESCRIPTIVE TEXT SIGNIFIES THE          +
*           *   CONTENTS OF THE STATED REGISTER.               *
*           ****************************************************
{{EJC{{{{{1738
*
*      SECTION 8 - LIST OF INSTRUCTION MNEMONICS
*
*      THE FOLLOWING LIST INCLUDES ALL INSTRUCTION AND
*      ASSEMBLY OPERATION MNEMONICS IN ALPHABETICAL ORDER.
*      THE MNEMONICS ARE PRECEDED BY A NUMBER IDENTIFYING
*      THE FOLLOWING SECTION WHERE THE INSTRUCTION IS DESCRIBED.
*      A STAR (*) IS APPENDED TO THE MNEMONIC IF THE LAST
*      OPERAND MAY OPTIONALLY BE OMITTED.
*      SEE SECTION -15- FOR DETAILS OF STATEMENT FORMAT AND
*      COMMENT CONVENTIONS.
*
*       2.1  ADD  OPV,OPN      ADD ADDRESS
*       4.2  ADI  OPS          ADD INTEGER
*       5.3  ADR  OPS          ADD REAL
*       7.1  ANB  OPW,W        AND BIT STRING
*       2.17 AOV  OPV,OPN,PLBL ADD ADDRESS, FAIL IF OVERFLOW
*       5.16 ATN               ARCTANGENT OF REAL ACCUM
*       2.16 BCT  W,PLBL       BRANCH AND COUNT
*       2.5  BEQ  OPN,OPV,PLBL BRANCH IF ADDRESS EQUAL
*       2.18 BEV  OPN,PLBL     BRANCH IF ADDRESS EVEN
*       2.8  BGE  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER OR EQUL
*       2.7  BGT  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER
*       2.12 BHI  OPN,OPV,PLBL BRANCH IF ADDRESS HIGH
*       2.10 BLE  OPN,OPV,PLBL BRANCH IF ADDRESS LESS OR EQUAL
*       2.11 BLO  OPN,OPV,PLBL BRANCH IF ADDRESS LOW
*       2.9  BLT  OPN,OPV,PLBL BRANCH IF ADDRESS LESS THAN
*       2.6  BNE  OPN,OPV,PLBL BRANCH IF ADDRESS NOT EQUAL
*       2.13 BNZ  OPN,PLBL     BRANCH IF ADDRESS NON-ZERO
*       2.19 BOD  OPN,PLBL     BRANCH IF ADDRESS ODD
*       1.2  BRN  PLBL         BRANCH UNCONDITIONAL
*       1.7  BRI  OPN          BRANCH INDIRECT
*       1.3  BSW* X,VAL,PLBL   BRANCH ON SWITCH VALUE
*       8.2  BTW  REG          CONVERT BYTES TO WORDS
*       2.14 BZE  OPN,PLBL     BRANCH IF ADDRESS ZERO
*       6.6  CEQ  OPW,OPW,PLBL BRANCH IF CHARACTERS EQUAL
*      10.1  CHK               CHECK STACK OVERFLOW
*       5.17 CHP               INTEGER PORTION OF REAL ACCUM
*       7.4  CMB  W            COMPLEMENT BIT STRING
*       6.8  CMC  PLBL,PLBL    COMPARE CHARACTER STRINGS
*       6.7  CNE  OPW,OPW,PLBL BRANCH IF CHARACTERS NOT EQUAL
*       6.5  CSC  X            COMPLETE STORE CHARACTERS
*       5.18 COS               COSINE OF REAL ACCUM
*       8.8  CTB  W,VAL        CONVERT CHARACTER COUNT TO BYTES
*       8.7  CTW  W,VAL        CONVERT CHARACTER COUNT TO WORDS
*       8.10 CVD               CONVERT BY DIVISION
*       8.9  CVM  PLBL         CONVERT BY MULTIPLICATION
*      11.1  DAC  ADDR         DEFINE ADDRESS CONSTANT
*      11.5  DBC  VAL          DEFINE BIT STRING CONSTANT
*       2.4  DCA  OPN          DECREMENT ADDRESS BY ONE WORD
*       1.17 DCV  OPN          DECREMENT VALUE BY ONE
*      11.2  DIC  INTEGER      DEFINE INTEGER CONSTANT
{{EJC{{{{{1791
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*      11.3  DRC  REAL         DEFINE REAL CONSTANT
*      11.4  DTC  DTEXT        DEFINE TEXT (CHARACTER) CONSTANT
*       4.5  DVI  OPS          DIVIDE INTEGER
*       5.6  DVR  OPS          DIVIDE REAL
*      13.1  EJC               EJECT ASSEMBLY LISTING
*      14.2  END               END OF ASSEMBLY
*       1.13 ENP               DEFINE END OF PROCEDURE
*       1.6  ENT* VAL          DEFINE ENTRY POINT
*      12.1  EQU  EQOP         DEFINE SYMBOLIC VALUE
*       1.15 ERB  INT,TEXT     ASSEMBLE ERROR CODE AND BRANCH
*       1.14 ERR  INT,TEXT     ASSEMBLE ERROR CODE
*       1.5  ESW               END OF SWITCH LIST FOR BSW
*       5.19 ETX               E TO THE POWER IN THE REAL ACCUM
*       1.12 EXI* INT          EXIT FROM PROCEDURE
*      12.2  EXP               DEFINE EXTERNAL PROCEDURE
*       6.10 FLC  W            FOLD CHARACTER TO UPPER CASE
*       2.3  ICA  OPN          INCREMENT ADDRESS BY ONE WORD
*       3.4  ICP               INCREMENT CODE POINTER
*       1.16 ICV  OPN          INCREMENT VALUE BY ONE
*       4.11 IEQ  PLBL         JUMP IF INTEGER ZERO
*       1.4  IFF  VAL,PLBL     SPECIFY BRANCH FOR BSW
*       4.12 IGE  PLBL         JUMP IF INTEGER NON-NEGATIVE
*       4.13 IGT  PLBL         JUMP IF INTEGER POSITIVE
*       4.14 ILE  PLBL         JUMP IF INTEGER NEGATIVE OR ZERO
*       4.15 ILT  PLBL         JUMP IF INTEGER NEGATIVE
*       4.16 INE  PLBL         JUMP IF INTEGER NON-ZERO
*       4.9  INO  PLBL         JUMP IF NO INTEGER OVERFLOW
*      12.3  INP  PTYP,INT     INTERNAL PROCEDURE
*      12.4  INR               INTERNAL ROUTINE
*       4.10 IOV  PLBL         JUMP IF INTEGER OVERFLOW
*       8.5  ITR               CONVERT INTEGER TO REAL
*       1.9  JSR  PNAM         CALL PROCEDURE
*       6.3  LCH  REG,OPC      LOAD CHARACTER
*       2.15 LCT  W,OPV        LOAD COUNTER FOR LOOP
*       3.1  LCP  REG          LOAD CODE POINTER REGISTER
*       3.3  LCW  REG          LOAD NEXT CODE WORD
*       4.1  LDI  OPS          LOAD INTEGER
*       5.1  LDR  OPS          LOAD REAL
*       1.8  LEI  X            LOAD ENTRY POINT ID
*       5.20 LNF               NATURAL LOGORITHM OF REAL ACCUM
*       7.6  LSH  W,VAL        LEFT SHIFT BIT STRING
*       7.8  LSX  W,(X)        LEFT SHIFT INDEXED
*       9.4  MCB               MOVE CHARACTERSWORDS BACKWARDS
*       8.4  MFI* OPN,PLBL     CONVERT (IA) TO ADDRESS VALUE
*       4.3  MLI  OPS          MULTIPLY INTEGER
*       5.5  MLR  OPS          MULTIPLY REAL
*       1.19 MNZ  OPN          MOVE NON-ZERO
*       1.1  MOV  OPV,OPN      MOVE
*       8.3  MTI  OPN          MOVE ADDRESS VALUE TO (IA)
*       9.1  MVC               MOVE CHARACTERS
*       9.2  MVW               MOVE WORDS
*       9.3  MWB               MOVE WORDS BACKWARDS
*       4.8  NGI               NEGATE INTEGER
{{EJC{{{{{1848
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*       5.9  NGR               NEGATE REAL
*       7.9  NZB  W,PLBL       JUMP IF NOT ALL ZERO BITS
*       7.2  ORB  OPW,W        OR BIT STRINGS
*       6.1  PLC* X,OPV        PREPARE TO LOAD CHARACTERS
*       1.10 PPM* PLBL         PROVIDE PROCEDURE EXIT PARAMETER
*       1.11 PRC  PTYP,VAL     DEFINE START OF PROCEDURE
*       6.2  PSC* X,OPV        PREPARE TO STORE CHARACTERS
*       5.10 REQ  PLBL         JUMP IF REAL ZERO
*       5.11 RGE  PLBL         JUMP IF REAL POSITIVE OR ZERO
*       5.12 RGT  PLBL         JUMP IF REAL POSITIVE
*       5.13 RLE  PLBL         JUMP IF REAL NEGATIVE OR ZERO
*       5.14 RLT  PLBL         JUMP IF REAL NEGATIVE
*       4.6  RMI  OPS          REMAINDER INTEGER
*       5.15 RNE  PLBL         JUMP IF REAL NON-ZERO
*       5.8  RNO  PLBL         JUMP IF NO REAL OVERFLOW
*       5.7  ROV  PLBL         JUMP IF REAL OVERFLOW
*       7.5  RSH  W,VAL        RIGHT SHIFT BIT STRING
*       7.7  RSX  W,(X)        RIGHT SHIFT INDEXED
*       8.6  RTI* PLBL         CONVERT REAL TO INTEGER
*       1.22 RTN               DEFINE START OF ROUTINE
*       4.4  SBI  OPS          SUBTRACT INTEGER
*       5.4  SBR  OPS          SUBTRACT REALS
*       6.4  SCH  REG,OPC      STORE CHARACTER
*       3.2  SCP  REG          STORE CODE POINTER
*      14.1  SEC               DEFINE START OF ASSEMBLY SECTION
*       5.21 SIN               SINE OF REAL ACCUM
*       5.22 SQR               SQUARE ROOT OF REAL ACCUM
*       1.20 SSL  OPW          SUBROUTINE STACK LOAD
*       1.21 SSS  OPW          SUBROUTINE STACK STORE
*       4.7  STI  OPS          STORE INTEGER
*       5.2  STR  OPS          STORE REAL
*       2.2  SUB  OPV,OPN      SUBTRACT ADDRESS
*       5.23 TAN               TANGENT OF REAL ACCUM
*       6.9  TRC               TRANSLATE CHARACTER STRING
*      13.2  TTL  TEXT         SUPPLY ASSEMBLY TITLE
*       8.1  WTB  REG          CONVERT WORDS TO BYTES
*       7.3  XOB  OPW,W        EXCLUSIVE OR BIT STRINGS
*       1.18 ZER  OPN          ZEROISE INTEGER LOCATION
*       7.11 ZGB  OPN          ZEROISE GARBAGE BITS
*       7.10 ZRB  W,PLBL       JUMP IF ALL ZERO BITS
{{EJC{{{{{1892
*
*      SECTION 9 - MINIMAL INSTRUCTIONS
*
*      THE FOLLOWING DESCRIPTIONS ASSUME THE DEFINITIONS -
*
*      ZEROE  EQU  0
*      UNITY  EQU  1
*
*      -1-  BASIC INSTRUCTION SET
*
*      1.1  MOV  OPV,OPN     MOVE ONE WORD VALUE
*
*           MOV CAUSES THE VALUE OF OPERAND OPV TO BE SET AS
*           THE NEW CONTENTS OF OPERAND LOCATION OPN. IN THE
*           CASE WHERE OPN IS NOT AN INDEX REGISTER, ANY VALUE
*           WHICH CAN NORMALLY OCCUPY A MEMORY WORD (INCLUDING
*           A PART OF A MULTIWORD REAL OR INTEGER VALUE)
*           CAN BE TRANSFERRED USING MOV. IF THE TARGET LOCATION
*           OPN IS AN INDEX REGISTER, THEN OPV MUST SPECIFY AN
*           APPROPRIATE ONE WORD VALUE OR OPERAND CONTAINING
*           SUCH AN APPROPRIATE VALUE.
*
*      1.2  BRN  PLBL        UNCONDITIONAL BRANCH
*
*           BRN CAUSES CONTROL TO BE PASSED TO THE INDICATED
*           LABEL IN THE PROGRAM SECTION.
*
*      1.3  BSW  X,VAL,PLBL  BRANCH ON SWITCH VALUE
*      1.4  IFF  VAL,PLBL    PROVIDE BRANCH FOR SWITCH
*           IFF  VAL,PLBL     ...
*           ...
*           ...
*      1.5  ESW              END OF BRANCH SWITCH TABLE
*
*           BSW,IFF,ESW PROVIDE A CAPABILITY FOR A SWITCHED
*           BRANCH SIMILAR TO A FORTRAN COMPUTED GOTO. THE
*           VAL ON THE BSW INSTRUCTION IS THE MAXIMUM NUMBER
*           OF BRANCHES. THE VALUE IN X RANGES FROM ZERO UP TO
*           BUT NOT INCLUDING THIS MAXIMUM. EACH IFF PROVIDES A
*           BRANCH. VAL MUST BE LESS THAN THAT GIVEN ON THE BSW
*           AND CONTROL GOES TO PLBL IF THE VALUE IN X MATCHES.
*           IF THE VALUE IN X DOES NOT CORRESPOND TO ANY OF THE
*           IFF ENTRIES, THEN CONTROL PASSES TO THE PLBL ON THE
*           BSW. THIS PLBL OPERAND MAY BE OMITTED IF THERE ARE
*           NO VALUES MISSING FROM THE LIST.
*
*           IFF AND ESW MAY ONLY BE USED IN THIS CONTEXT.
*           EXECUTION OF BSW MAY DESTROY THE CONTENTS OF X.
*           THE IFF ENTRIES MAY BE IN ANY ORDER AND SINCE
*           A TRANSLATOR MAY THUS NEED TO STORE AND SORT THEM,
*           THE COMMENT FIELD IS RESTRICTED IN LENGTH (SEC 11).
{{EJC{{{{{1944
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.6  ENT  VAL         DEFINE PROGRAM ENTRY POINT
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE A PROGRAM ENTRY POINT WHICH CAN SUBSEQUENTLY
*           BE USED IN CONJUNCTION WITH THE BRI INSTRUCTION,
*           WHICH PROVIDES THE ONLY MEANS OF ENTERING THE
*           CODE. IT IS ILLEGAL TO FALL INTO CODE
*           IDENTIFIED BY AN ENTRY POINT. THE
*           ENTRY SYMBOL IS ASSIGNED AN ADDRESS WHICH NEED NOT
*           BE A MULTIPLE OF CFP$B BUT WHICH MUST BE IN THE
*           RANGE 0 LE CFP$L AND THE ADDRESS MUST NOT LIE WITHIN
*           THE ADDRESS RANGE OF THE ALLOCATED DATA AREA.
*           FURTHERMORE, ADDRESSES OF SUCCESSIVE ENTRY POINTS
*           MUST BE ASSIGNED IN SOME ASCENDING SEQUENCE SO
*           THAT THE ADDRESS COMPARISON INSTRUCTIONS CAN BE
*           USED TO TEST THE ORDER IN WHICH TWO ENTRY POINTS
*           OCCUR. THE SYMBOL VAL GIVES AN IDENTIFYING VALUE
*           TO THE ENTRY POINT WHICH CAN BE ACCESSED WITH THE
*           LEI INSTRUCTION.
*
*           NOTE - SUBJECT TO THE RESTRICTION BELOW, VAL MAY
*           BE OMITTED IF NO SUCH IDENTIFICATION IS NEEDED I.E.
*           IF NO LEI REFERENCES THE ENTRY POINT. FOR THIS
*           CASE, A TRANSLATION OPTIMISATION IS POSSIBLE IN
*           WHICH NO MEMORY NEED BE RESERVED FOR A NULL
*           IDENTIFICATION WHICH IS NEVER TO BE REFERENCED, BUT
*           ONLY PROVIDED THIS IS DONE SO AS NOT TO INTERFERE
*           WITH THE STRICTLY ASCENDING SEQUENCE OF ENTRY POINT
*           ADDRESSES. TO SIMPLIFY THIS OPTIMISATION FOR ALL
*           IMPLEMENTORS, THE FOLLOWING RESTRICTION IS OBSERVED
*                VAL MAY ONLY BE OMITTED IF THE ENTRY POINT IS
*                SEPARATED FROM A FOLLOWING ENTRY POINT BY A
*                NON-NULL MINIMAL CODE SEQUENCE.
*           ENTRY POINT ADDRESSES ARE ACCESSIBLE ONLY BY USE OF
*           LITERALS (=ELBL, SECTION 7) OR DAC CONSTANTS
*           (SECTION 8-11.1).
*
*      1.7  BRI  OPN         BRANCH INDIRECT
*
*           OPN CONTAINS THE ADDRESS OF A PROGRAM ENTRY POINT
*           (SEE ENT). CONTROL IS PASSED TO THE EXECUTABLE
*           CODE STARTING AT THE ENTRY POINT ADDRESS. OPN IS
*           LEFT UNCHANGED.
*
*      1.8  LEI  X           LOAD ENTRY POINT IDENTIFICATION
*
*           X CONTAINS THE ADDRESS OF AN ENTRY POINT FOR WHICH
*           AN IDENTIFYING VALUE WAS GIVEN ON THE THE ENT LINE.
*           LEI REPLACES THE CONTENTS OF X BY THIS VALUE.
{{EJC{{{{{1997
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.9  JSR  PNAM        CALL PROCEDURE PNAM
*      1.10 PPM  PLBL        PROVIDE EXIT PARAMETER
*           PPM  PLBL         ...
*           ...
*           PPM  PLBL         ...
*
*           JSR CAUSES CONTROL TO BE PASSED TO THE NAMED
*           PROCEDURE. PNAM IS THE LABEL ON A PRC STATEMENT
*           ELSEWHERE IN THE PROGRAM SECTION (SEE PRC)
*           OR HAS BEEN DEFINED USING AN EXP INSTRUCTION.
*           THE PPM EXIT PARAMETERS FOLLOWING THE CALL GIVE
*           NAMES OF PROGRAM LOCATIONS (PLBL-S) TO WHICH
*           ALTERNATIVE EXI RETURNS OF THE CALLED PROCEDURE MAY
*           PASS CONTROL. THEY MAY OPTIONALLY BE REPLACED BY
*           ERROR RETURNS (SEE ERR). THE NUMBER OF EXIT
*           PARAMETERS FOLLOWING A JSR MUST EQUAL THE INT IN THE
*           PROCEDURE DEFINITION. THE OPERAND OF PPM MAY BE
*           OMITTED IF THE CORRESPONDING EXI RETURN IS CERTAIN
*           NOT TO BE TAKEN.
*
*      1.11 PRC  PTYP,INT    DEFINE START OF PROCEDURE
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE THE NAME OF A PROCEDURE FOR USE WITH JSR.
*           A PROCEDURE IS A CONTIGUOUS SECTION OF INSTRUCTIONS
*           TO WHICH CONTROL MAY BE PASSED WITH A JSR
*           INSTRUCTION. THIS IS THE ONLY WAY IN WHICH THE
*           INSTRUCTIONS IN A PROCEDURE MAY BE EXECUTED. IT IS
*           NOT PERMITTED TO FALL INTO A PROCEDURE.
*           ALL PROCEDURES SHOULD BE NAMED IN SECTION 0
*           INP  STATEMENTS.
*
*           INT IS THE NUMBER OF EXIT PARAMETERS (PPM-S) TO
*           BE USED IN JSR CALLS.
*
*           THERE ARE THREE POSSIBILITIES FOR PTYP, EACH
*           CONSISTING OF A SINGLE LETTER AS FOLLOWS.
*
*           R                RECURSIVE
*
*           THE RETURN POINT (ONE OR MORE WORDS) IS STORED ON
*           THE STACK AS THOUGH ONE OR MORE MOV ...,-(XS)
*           INSTRUCTIONS WERE EXECUTED.
{{EJC{{{{{2044
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*           N                NON-RECURSIVE
*
*           THE RETURN POINT IS TO BE STORED EITHER
*           (1) IN A LOCAL STORAGE WORD ASSOCIATED
*           WITH THE PROCEDURE AND NOT DIRECTLY
*           AVAILABLE TO THE PROGRAM IN ANY OTHER MANNER OR
*           (2) ON A SUBROUTINE LINK STACK QUITE DISTINCT FROM
*           THE MINIMAL STACK ADDRESSED BY XS.
*           IT IS AN ERROR TO USE THE STACK FOR N-LINKS, SINCE
*           PROCEDURE PARAMETERS OR RESULTS MAY BE PASSED VIA
*           THE STACK.
*           IF METHOD (2) IS USED FOR LINKS, ERROR EXITS
*           (ERB,ERR) FROM A PROCEDURE WILL NECESSITATE LINK
*           STACK RESETTING. THE SSL AND SSS ORDERS PROVIDED
*           FOR THIS MAY BE REGARDED AS NO-OPS FOR
*           IMPLEMENTATIONS USING METHOD (1).
*
*           E                EITHER
*
*           THE RETURN POINT MAY BE STORED IN EITHER MANNER
*           ACCORDING TO EFFICIENCY REQUIREMENTS OF THE ACTUAL
*           PHYSICAL MACHINE USED FOR THE IMPLEMENTATION. NOTE
*           THAT PROGRAMMING OF E TYPE PROCEDURES MUST BE
*           INDEPENDENT OF THE ACTUAL IMPLEMENTATION.
*
*           THE ACTUAL FORM OF THE RETURN POINT IS UNDEFINED.
*           HOWEVER, EACH WORD STORED ON THE STACK FOR AN
*           R-TYPE CALL MUST MEET THE FOLLOWING REQUIREMENTS.
*
*           1)               IT CAN BE HANDLED AS AN ADDRESS
*                            AND PLACED IN AN INDEX REGISTER.
*
*           2)               WHEN USED AS AN OPERAND IN AN
*                            ADDRESS COMPARISON INSTRUCTION, IT
*                            MUST NOT APPEAR TO LIE WITHIN
*                            THE ALLOCATED DATA AREA.
*
*           3)               IT IS NOT REQUIRED TO APPEAR
*                            TO LIE WITHIN THE PROGRAM SECTION.
{{EJC{{{{{2087
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.12 EXI  INT         EXIT FROM PROCEDURE
*
*           THE PPM AND ERR PARAMETERS FOLLOWING A JSR ARE
*           NUMBERED STARTING FROM 1.  EXI  INT CAUSES CONTROL
*           TO BE RETURNED TO THE INT-TH SUCH PARAM. EXI 1 GIVES
*           CONTROL TO THE PLBL OF THE FIRST PPM AFTER THE JSR.
*           IF INT IS OMITTED, CONTROL IS PASSED BACK PAST THE
*           LAST EXIT PARAMETER (OR PAST THE JSR IF THERE ARE
*           NONE). FOR R AND E TYPE PROCEDURES, THE
*           STACK POINTER XS MUST BE SET TO ITS APPROPRIATE
*           ENTRY VALUE BEFORE EXECUTING AN EXI INSTRUCTION.
*           IN THIS CASE, EXI REMOVES RETURN POINTS FROM THE
*           STACK IF ANY ARE STORED THERE SO THAT THE STACK
*           POINTER IS RESTORED TO ITS CALLING VALUE.
*
*      1.13 ENP              DEFINE END OF PROCEDURE BODY
*
*           ENP DELIMITS A PROCEDURE BODY AND MAY NOT ACTUALLY
*           BE EXECUTED, HENCE IT MUST HAVE NO LABEL.
*
*      1.14 ERR  INT,TEXT    PROVIDE ERROR RETURN
*
*           ERR MAY REPLACE AN EXIT PARAMETER (PPM) IN
*           ANY PROCEDURE CALL. THE INT ARGUMENT IS A UNIQUE
*           ERROR CODE IN 0 TO 899.
*           THE TEXT SUPPLIED AS THE OTHER OPERAND IS
*           ARBITRARY TEXT IN THE FORTRAN CHARACTER SET AND
*           MAY BE USED IN CONSTRUCTING A FILE OF ERROR
*           MESSAGES FOR DOCUMENTING PURPOSES OR FOR BUILDING
*           A DIRECT ACCESS OR OTHER FILE OF MESSAGES TO BE
*           USED BY THE ERROR HANDLING CODE.
*           IN THE EVENT THAT AN EXI ATTEMPTS
*           TO RETURN CONTROL VIA AN EXIT PARAMETER TO
*           AN ERR, CONTROL IS INSTEAD PASSED TO THE FIRST
*           INSTRUCTION IN THE ERROR SECTION (WHICH FOLLOWS THE
*           PROGRAM SECTION) WITH THE ERROR CODE IN WA.
*
*      1.15 ERB  INT,TEXT    ERROR BRANCH
*
*           THIS INSTRUCTION RESEMBLES ERR EXCEPT THAT IT MAY
*           OCCUR AT ANY POINT WHERE A BRANCH IS PERMITTED.
*           IT EFFECTS A TRANSFER OF CONTROL TO THE ERROR
*           SECTION WITH THE ERROR CODE IN WA.
*
*      1.16 ICV  OPN         INCREMENT VALUE BY ONE
*
*           ICV INCREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   ADD  =UNITY,OPN
*
*      1.17 DCV  OPN         DECREMENT VALUE BY ONE
*
*           DCV DECREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   SUB  =UNITY,OPN
{{EJC{{{{{2144
*
*      BASIC INSTRUCTIONS (CONTINUED)
*
*      1.18 ZER  OPN         ZEROISE OPN
*
*           ZER IS EQUIVALENT TO  MOV  =ZEROE,OPN
*
*      1.19 MNZ  OPN         MOVE NON-ZERO TO OPN
*
*           ANY NON-ZERO COLLECTABLE VALUE MAY USED, FOR WHICH
*           THE OPCODES BNZ/BZE WILL BRANCH/FAIL TO BRANCH.
*
*      1.20 SSL  OPW         SUBROUTINE STACK LOAD
*
*      1.21 SSS  OPW         SUBROUTINE STACK STORE
*
*           THIS PAIR OF OPERATIONS IS PROVIDED TO MAKE POSSIBLE
*           THE USE OF A LOCAL STACK TO HOLD SUBROUTINE (S-R)
*           RETURN LINKS FOR N-TYPE PROCEDURES. SSS STORES THE
*           S-R STACK POINTER IN OPW AND SSL LOADS THE S-R
*           STACK POINTER FROM OPW. BY USING SSS IN THE MAIN
*           PROGRAM OR ON ENTRY TO A PROCEDURE WHICH SHOULD
*           REGAIN CONTROL ON OCCURRENCE OF AN ERR OR ERB AND BY
*           USE OF SSL IN THE ERROR PROCESSING SECTIONS THE
*           S-R STACK POINTER CAN BE RESTORED GIVING A LINK
*           STACK CLEANED UP READY FOR RESUMED EXECUTION.
*           THE FORM OF THE LINK STACK POINTER IS UNDEFINED IN
*           MINIMAL (IT IS LIKELY TO BE A PRIVATE REGISTER
*           KNOWN TO THE TRANSLATOR) AND THE ONLY REQUIREMENT
*           IS THAT IT SHOULD FIT INTO A SINGLE FULL WORD.
*           SSL AND SSS ARE NO-OPS IF A PRIVATE LINK STACK IS
*           NOT USED.
*
*      1.22 RTN              DEFINE START OF ROUTINE
*
*           A ROUTINE IS A CODE CHUNK USED FOR SIMILAR PURPOSES
*           TO A PROCEDURE. HOWEVER IT IS ENTERED BY ANY TYPE OF
*           CONDITIONAL OR UNCONDITIONAL BRANCH (NOT BY JSR). ON
*           TERMINATION IT PASSES CONTROL BY A BRANCH (OFTEN
*           BRI THROUGH A CODE WORD) OR EVEN PERMITS CONTROL
*           TO DROP THROUGH TO ANOTHER ROUTINE. NO RETURN LINK
*           EXISTS AND THE END OF A ROUTINE IS NOT MARKED BY
*           AN EXPLICIT OPCODE (COMPARE ENP).
*           ALL ROUTINES SHOULD BE NAMED IN SECTION 0
*           INR  STATEMENTS.
{{EJC{{{{{2190
*
*      -2-  OPERATIONS ON ONE WORD INTEGER VALUES (ADDRESSES)
*
*      2.1  ADD  OPV,OPN     ADDS OPV TO THE VALUE IN OPN AND
*                            STORES THE RESULT IN OPN. UNDEFINED
*                            IF THE RESULT EXCEEDS CFP$L.
*
*      2.2  SUB  OPV,OPN     SUBTRACTS OPV FROM OPN. STORES THE
*                            RESULT IN OPN. UNDEFINED IF THE
*                            RESULT IS NEGATIVE.
*
*      2.3  ICA  OPN         INCREMENT ADDRESS IN OPN
*                            EQUIVALENT TO ADD *UNITY,OPN
*
*      2.4  DCA  OPN         DECREMENT ADDRESS IN OPN
*                            EQUIVALENT TO SUB *UNITY,OPN
*
*      2.5  BEQ  OPN,OPV,PLBL BRANCH TO PLBL IF OPN EQ OPV
*      2.6  BNE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN NE OPV
*      2.7  BGT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GT OPV
*      2.8  BGE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GE OPV
*      2.9  BLT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LT OPV
*      2.10 BLE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LE OPV
*      2.11 BLO  OPN,OPV,PLBL EQUIVALENT TO BLT OR BLE
*      2.12 BHI  OPN,OPV,PLBL EQUIVALENT TO BGT OR BGE
*
*           THE ABOVE INSTRUCTIONS COMPARE TWO ADDRESS
*           VALUES AS UNSIGNED INTEGER VALUES.
*           THE BLO AND BHI INSTRUCTIONS ARE USED IN CASES WHERE
*           THE EQUAL CONDITION EITHER DOES NOT OCCUR OR CAN
*           RESULT EITHER IN A BRANCH OR NO BRANCH. THIS AVOIDS
*           INEFFICIENT TRANSLATIONS IN SOME IMPLEMENTATIONS.
*
*      2.13 BNZ  OPN,PLBL    EQUIVALENT TO BNE OPN,=ZEROE,PLBL
*
*      2.14 BZE  OPN,PLBL    EQUIVALENT TO BEQ OPN,=ZEROE,PLBL
*
*
*      2.15 LCT  W,OPV       LOAD COUNTER FOR BCT
*
*           LCT LOADS A COUNTER VALUE FOR USE WITH THE BCT
*           INSTRUCTION. THE VALUE IN OPV IS THE NUMBER OF LOOPS
*           TO BE EXECUTED. THE VALUE IN W AFTER THIS OPERATION
*           IS AN UNDEFINED ONE WORD INTEGER QUANTITY.
*
*      2.16 BCT  W,PLBL      BRANCH AND COUNT
*
*           BCT USES THE COUNTER VALUE IN W TO BRANCH THE
*           REQUIRED NUMBER OF TIMES AND THEN FINALLY TO FALL
*           THROUGH TO THE NEXT INSTRUCTION. BCT CAN ONLY BE
*           USED FOLLOWING AN APPROPRIATE LCT INSTRUCTION.
*           THE VALUE IN W AFTER EXECUTION OF BCT IS UNDEFINED.
*
*      2.17 AOV  OPV,OPN,PLBL ADD WITH CARRY TEST
*
*           ADDS OPV TO THE VALUE IN OPN AND STORES RESULT IN
*           OPN. BRANCHES TO PLBL IF RESULT EXCEEDS CFP$L
*           WITH RESULT IN OPN UNDEFINED. CF. ADD.
*
*      2.18 BEV  OPN,PLBL     BRANCH IF EVEN
*      2.19 BOD  OPN,PLBL     BRANCH IF ODD
*
*           THESE OPERATIONS ARE USED ONLY IF .CEPP OR .CRPP IS
*           DEFINED.  ON SOME IMPLEMENTATIONS, A MORE EFFICIENT
*           IMPLEMENTATION IS POSSIBLE BY NOTING THAT ADDRESS OF
*           BLOCKS MUST ALWAYS BE A MULTIPLE OF CFP$B. WE CALL
*           SUCH ADDRESSES EVEN.  THUS RETURN ADDRESS ON THE
*           STACK (.CRPP) AND ENTRY POINT ADDRESSES (.CEPP) CAN
*           BE DISTINGUISHED FROM BLOCK ADDRESSES IF THEY ARE
*           FORCED TO BE ODD (NOT A MULTIPLE OF CFP$B).
*           BEV AND BOD BRANCH ACCORDING AS OPERAND IS EVEN
*           OR ODD, RESPECTIVELY.
{{EJC{{{{{2263
*
*      -3-  OPERATIONS ON THE CODE POINTER REGISTER (CP)
*
*           THE CODE POINTER REGISTER PROVIDES A PSUEDO
*           INSTRUCTION COUNTER FOR USE IN AN INTERPRETOR. IT
*           MAY BE IMPLEMENTED AS A REAL REGISTER OR AS A
*           MEMORY LOCATION, BUT IN EITHER CASE IT IS SEPARATE
*           FROM ANY OTHER REGISTER. THE VALUE IN THE CODE
*           POINTER REGISTER IS ALWAYS A WORD ADDRESS (I.E.
*           A ONE WORD INTEGER WHICH IS A MULTIPLE OF CFP$B).
*
*      3.1  LCP  REG         LOAD CODE POINTER REGISTER
*                            THIS INSTRUCTION CAUSES THE CODE
*                            POINTER REGISTER TO BE SET FROM
*                            THE VALUE IN REG WHICH IS UNCHANGED
*
*      3.2  SCP  REG         STORE CODE POINTER REGISTER
*                            THIS INSTRUCTION LOADS THE CURRENT
*                            VALUE IN THE CODE POINTER REGISTER
*                            INTO REG. (CP) IS UNCHANGED.
*
*      3.3  LCW  REG         LOAD NEXT CODE WORD
*                            THIS INSTRUCTION CAUSES THE WORD
*                            POINTED TO BY CP TO BE LOADED INTO
*                            THE INDICATED REG. THE VALUE IN CP
*                            IS THEN INCREMENTED BY ONE WORD.
*                            EXECUTION OF LCW MAY DESTROY XL.
*
*      3.4  ICP              INCREMENT CP BY ONE WORD
*
*           ON MACHINES WITH MORE THAN THREE INDEX REGISTERS,
*           CP CAN BE TREATED SIMPLY AS AN INDEX REGISTER.
*           IN THIS CASE, THE FOLLOWING EQUIVALENCES APPLY.
*
*           LCP REG IS LIKE MOV REG,CP
*           SCP REG IS LIKE MOV CP,REG
*           LCW REG IS LIKE MOV (CP)+,REG
*           ICP     IS LIKE ICA CP
*
*           SINCE LCW IS ALLOWED TO DESTROY XL, THE FOLLOWING
*           IMPLEMENTATION USING A WORK LOCATION CP$$$ CAN
*           ALSO BE USED.
*
*           LCP  REG         MOV  REG,CP$$$
*
*           SCP  REG         MOV  CP$$$,REG
*
*           LCW  REG         MOV  CP$$$,XL
*                            MOV  (XL)+,REG
*                            MOV  XL,CP$$$
*
*           ICP              ICA  CP$$$
{{EJC{{{{{2316
*
*      -4-  OPERATIONS ON SIGNED INTEGER VALUES
*
*      4.1  LDI  OPS         LOAD INTEGER ACCUMULATOR FROM OPS
*      4.2  ADI  OPS         ADD OPS TO INTEGER ACCUMULATOR
*      4.3  MLI  OPS         MULTIPLY INTEGER ACCUMULATOR BY OPS
*      4.4  SBI  OPS         SUBTRACT OPS FROM INT ACCUMULATOR
*      4.5  DVI  OPS         DIVIDE INTEGER ACCUMULATOR BY OPS
*      4.6  RMI  OPS         SET INT ACCUM TO MOD(INTACC,OPS)
*      4.7  STI  OPS         STORE INTEGER ACCUMULATOR AT OPS
*      4.8  NGI              NEGATE THE VALUE IN THE INTEGER
*                            ACCUMULATOR (CHANGE ITS SIGN)
*
*           THE EQUATION SATISFIED BY OPERANDS AND RESULTS OF
*           DVI AND RMI IS
*                  DIV = QOT * OPS + REM          WHERE
*           DIV = DIVIDEND IN INTEGER ACCUMULATOR
*           QOT = QUOTIENT LEFT IN IA BY DIV
*           OPS = THE DIVISOR
*           REM = REMAINDER LEFT IN IA BY RMI
*           THE SIGN OF THE RESULT OF DVI IS + IF (IA) AND (OPS)
*           HAVE THE SAME SIGN AND IS - IF THEY HAVE OPPOSITE
*           SIGNS. THE SIGN OF (IA) IS ALWAYS USED AS THE SIGN
*           OF THE RESULT OF REM.
*           ASSUMING IN EACH CASE THAT IA CONTAINS THE NUMBER
*           SPECIFIED IN PARENTHESES AND THAT SEVEN AND MSEVN
*           HOLD +7 AND -7 RESP. THE ALGORITHM IS ILLUSTRATED
*           BELOW.
*           (IA = 13)
*           DVI  SEVEN       IA = 1
*           RMI  SEVEN       IA = 6
*           DVI  MSEVN       IA = -1
*           RMI  MSEVN       IA = 6
*           (IA = -13)
*           DVI  SEVEN       IA = -1
*           RMI  SEVEN       IA = -6
*           DVI  MSEVN       IA = 1
*           RMI  MSEVN       IA = -6
{{EJC{{{{{2355
*
*           THE ABOVE INSTRUCTIONS OPERATE ON A FULL RANGE OF
*           SIGNED INTEGER VALUES. WITH THE EXCEPTION OF LDI AND
*           STI, THESE INSTRUCTIONS MAY CAUSE INTEGER OVERFLOW
*           BY ATTEMPTING TO PRODUCE AN UNDEFINED OR OUT OF
*           RANGE RESULT IN WHICH CASE INTEGER OVERFLOW IS SET,
*           THE RESULT IN (IA) IS UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE IOV OR INO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      4.9  INO  PLBL        JUMP TO PLBL IF NO INTEGER OVERFLOW
*      4.10 IOV  PLBL        JUMP TO PLBL IF INTEGER OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE INTEGER
*           OVERFLOW (ADI, SBI, MLI, DVI, RMI, NGI) AND
*           TEST THE RESULT OF THE PRECEDING INSTRUCTION.
*           IOV AND INO MAY NOT HAVE LABELS.
*
*      4.11 IEQ  PLBL        JUMP TO PLBL IF (IA) EQ 0
*      4.12 IGE  PLBL        JUMP TO PLBL IF (IA) GE 0
*      4.13 IGT  PLBL        JUMP TO PLBL IF (IA) GT 0
*      4.14 ILE  PLBL        JUMP TO PLBL IF (IA) LE 0
*      4.15 ILT  PLBL        JUMP TO PLBL IF (IA) LT 0
*      4.16 INE  PLBL        JUMP TO PLBL IF (IA) NE 0
*
*           THE ABOVE CONDITIONAL JUMP INSTRUCTIONS DO
*           NOT CHANGE THE CONTENTS OF THE ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN IA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
{{EJC{{{{{2389
*
*      -5-  OPERATIONS ON REAL VALUES
*
*      5.1  LDR  OPS         LOAD REAL ACCUMULATOR FROM OPS
*      5.2  STR  OPS         STORE REAL ACCUMULATOR AT OPS
*      5.3  ADR  OPS         ADD OPS TO REAL ACCUMULATOR
*      5.4  SBR  OPS         SUBTRACT OPS FROM REAL ACCUMULATOR
*      5.5  MLR  OPS         MULTIPLY REAL ACCUMULATOR BY OPS
*      5.6  DVR  OPS         DIVIDE REAL ACCUMULATOR BY OPS
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS CAUSES
*           UNDERFLOW, THE RESULT YIELDED IS 0.0.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      5.7  ROV  PLBL        JUMP TO PLBL IF REAL OVERFLOW
*      5.8  RNO  PLBL        JUMP TO PLBL IF NO REAL OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE REAL
*           OVERFLOW (ADR,SBR,MLR,DVR).
*
*      5.9  NGR              NEGATE REAL ACCUM (CHANGE SIGN)
*
*      5.10 REQ  PLBL        JUMP TO PLBL IF (RA) EQ 0.0
*      5.11 RGE  PLBL        JUMP TO PLBL IF (RA) GE 0.0
*      5.12 RGT  PLBL        JUMP TO PLBL IF (RA) GT 0.0
*      5.13 RLE  PLBL        JUMP TO PLBL IF (RA) LE 0.0
*      5.14 RLT  PLBL        JUMP TO PLBL IF (RA) LT 0.0
*      5.15 RNE  PLBL        JUMP TO PLBL IF (RA) NE 0.0
*
*           THE ABOVE CONDITIONAL INSTRUCTIONS DO NOT AFFECT
*           THE VALUE STORED IN THE REAL ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN RA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
*
*      5.16 ATN              ARCTANGENT OF REAL ACCUM
*      5.17 CHP              INTEGER PORTION OF REAL ACCUM
*      5.18 COS              COSINE OF REAL ACCUM
*      5.19 ETX              E TO THE POWER IN THE REAL ACCUM
*      5.20 LNF              NATURAL LOGORITHM OF REAL ACCUM
*      5.21 SIN              SINE OF REAL ACCUM
*      5.22 SQR              SQUARE ROOT OF REAL ACCUM
*      5.23 TAN              TANGENT OF REAL ACCUM
*
*           THE ABOVE ORDERS OPERATE UPON THE REAL ACCUMULATOR,
*           AND REPLACE THE CONTENTS OF THE ACCUMULATOR WITH THE
*           RESULT.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
{{EJC{{{{{2452
*
*      -6-  OPERATIONS ON CHARACTER VALUES
*
*           CHARACTER OPERATIONS EMPLOY THE CONCEPT OF A
*           CHARACTER POINTER WHICH USES EITHER
*           INDEX REGISTER XR OR XL (NOT XS).
*
*           A CHARACTER POINTER POINTS TO A SPECIFIC CHARACTER
*           IN A STRING OF CHARACTERS STORED CFP$C CHARS TO A
*           WORD. THE ONLY OPERATIONS PERMITTED ON A CHARACTER
*           POINTER ARE LCH AND SCH. IN PARTICULAR, A CHARACTER
*           POINTER MAY NOT EVEN BE MOVED WITH MOV.
*
*              RESTRICTION 1.
*              --------------
*           IT IS IMPORTANT WHEN CODING IN MINIMAL TO ENSURE
*           THAT NO ACTION OCCURRING BETWEEN THE INITIAL USE OF
*           PLC OR PSC AND THE EVENTUAL CLEARING OF XL OR XR ON
*           COMPLETION OF CHARACTER OPERATIONS CAN INITIATE A
*           GARBAGE COLLECTION. THE LATTER OF COURSE COULD CAUSE
*           THE ADDRESSED CHARACTERS TO BE MOVED LEAVING THE
*           CHARACTER POINTERS POINTING TO RUBBISH.
*
*              RESTRICTION 2.
*              --------------
*           A FURTHER RESTRICTION TO BE OBSERVED IN CODE
*           HANDLING CHARACTER STRINGS, IS THAT STRINGS BUILT
*           DYNAMICALLY SHOULD BE RIGHT PADDED WITH ZERO
*           CHARACTERS TO A FULL WORD BOUNDARY TO PERMIT EASY
*           HASHING AND USE OF CEQ OR CNE IN TESTING STRINGS
*           FOR EQUALITY.
*
*      6.1  PLC  X,OPV       PREPARE CH PTR FOR LCH,CMC,MVC,TRC,
*                            MCB.
*
*      6.2  PSC  X,OPV       PREPARE CHAR. PTR FOR SCH,MVC,MCB.
*
*           OPV CAN BE OMITTED IF IT IS ZERO.
*           THE CHAR. INITIALLY ADDRESSED IS DETERMINED BY THE
*           WORD ADDRESS IN X AND THE INTEGER OFFSET OPV.
*           THERE IS AN AUTOMATIC IMPLIED OFFSET OF CFP$F BYTES.
*           CFP$F IS USED TO FORMALLY INTRODUCE INTO MINIMAL A
*           VALUE NEEDED IN TRANSLATING THESE OPCODES WHICH,
*           SINCE MINIMAL ITSELF DOES NOT PRESCRIBE A STRING
*           STRUCTURE IN DETAIL, DEPENDS ON THE CHOICE OF A DATA
*           STRUCTURE FOR STRINGS IN THE MINIMAL PROGRAM.
*           E.G. IF CFP$B = CFP$C = 3, CFP$F = 6, NUM01 = 1, XL
*           POINTS TO A SERIES OF 4 WORDS, ABC/DEF/GHI/JKL, THEN
*               PLC  XL,=NUM01
*           POINTS TO H.
{{EJC{{{{{2503
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.3  LCH  REG,OPC     LOAD CHARACTER INTO REG
*
*      6.4  SCH  REG,OPC     STORE CHARACTER FROM REG
*
*           THESE OPERATIONS ARE DEFINED SUCH THAT THE CHARACTER
*           IS RIGHT JUSTIFIED IN REGISTER REG WITH ZERO BITS TO
*           THE LEFT. AFTER LCH FOR EXAMPLE, IT IS LEGITIMATE
*           TO REGARD REG AS CONTAINING THE ORDINAL INTEGER
*           CORRESPONDING TO THE CHARACTER.
*
*           OPC IS ONE OF THE FOLLOWING THREE POSSIBILITIES.
*
*           (X)              THE CHARACTER POINTED TO BY THE
*                            CHARACTER POINTER IN X. THE
*                            CHARACTER POINTER IS NOT CHANGED.
*
*           (X)+             SAME CHARACTER AS (X) BUT THE
*                            CHARACTER POINTER IS INCREMENTED
*                            TO POINT TO THE NEXT CHARACTER
*                            FOLLOWING EXECUTION.
*
*           -(X)             THE CHARACTER POINTER IS DECRE-
*                            MENTED BEFORE ACCESSING THE
*                            CHARACTER SO THAT THE PREVIOUS
*                            CHARACTER IS REFERENCED.
*
*      6.5  CSC  X           COMPLETE STORE CHARACTERS
*
*           THIS INSTRUCTION MARKS COMPLETION OF A
*           PSC,SCH,SCH,...,SCH SEQUENCE INITIATED BY
*           A  PSC  X INSTRUCTION. NO MORE SCH INSTRUCTIONS
*           USING  X  SHOULD BE OBEYED UNTIL ANOTHER PSC IS
*           OBEYED. IT IS PROVIDED SOLELY AS AN EFFICIENCY AID
*           ON MACHINES WITHOUT CHARACTER ORDERS SINCE IT
*           PERMITS USE OF REGISTER BUFFERING OF CHARS IN SCH
*           SEQUENCES. WHERE CSC IS NOT A NO-OP, IT MUST OBSERVE
*           RESTRICTION 2. (E.G. IN SPITBOL, ALOCS ZEROISES THE
*           LAST WORD OF A STRING FRAME PRIOR TO SCH SEQUENCE
*           BEING STARTED SO CSC MUST NOT NULLIFY THIS ACTION.)
*
*           THE FOLLOWING INSTRUCTIONS ARE USED TO COMPARE
*           TWO WORDS CONTAINING CFP$C CHARACTERS.
*           COMPARISONS DISTINCT FROM BEQ,BNE ARE PROVIDED AS
*           ON SOME TARGET MACHINES, THE POSSIBILITY OF THE SIGN
*           BIT BEING SET MAY REQUIRE SPECIAL ACTION.
*           NOTE THAT RESTRICTION 2 ABOVE, EASES USE OF THESE
*           ORDERS IN TESTING COMPLETE STRINGS FOR EQUALITY,
*           SINCE WHOLE WORD TESTS ARE POSSIBLE.
*
*      6.6  CEQ  OPW,OPW,PLBL JUMP TO PLBL IF OPW EQ OPW
*      6.7  CNE  OPW,OPW,PLBL JUMP TO PLBL IF OPW NE OPW
{{EJC{{{{{2558
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.8  CMC  PLBL,PLBL   COMPARE CHARACTERS
*
*           CMC IS USED TO COMPARE TWO CHARACTER STRINGS. BEFORE
*           EXECUTING CMC, REGISTERS ARE SET UP AS FOLLOWS.
*           (XL)             CHARACTER PTR FOR FIRST STRING
*           (XR)             CHARACTER POINTER FOR SECOND STRING
*           (WA)             CHARACTER COUNT (MUST BE .GT. ZERO)
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           CONTROL PASSES TO FIRST PLBL IF THE FIRST STRING
*           IS LEXICALLY LESS THAN THE SECOND STRING, AND TO
*           THE SECOND PLBL IF THE FIRST STRING IS LEXICALLY
*           GREATER. CONTROL PASSES TO THE FOLLOWING INSTRUCTION
*           IF THE STRINGS ARE IDENTICAL. AFTER EXECUTING THIS
*           INSTRUCTION, THE VALUES OF XR AND XL ARE SET TO
*           ZERO AND THE VALUE IN (WA) IS UNDEFINED.
*           ARGUMENTS TO CMC MAY BE COMPLETE OR PARTIAL
*           STRINGS, SO MAKING OPTIMISATION TO USE WHOLE WORD
*           COMPARISONS DIFFICULT (DEPENDENT IN GENERAL ON
*           SHIFTS AND MASKING).
*
*      6.9  TRC              TRANSLATE CHARACTERS
*
*           TRC IS USED TO TRANSLATE A CHARACTER STRING USING A
*           SUPPLIED TRANSLATION TABLE. BEFORE EXECUTING TRC THE
*           REGISTERS ARE SET AS FOLLOWS.
*           (XL)             CHAR PTR TO STRING TO BE TRANSLATED
*           (XR)             CHAR PTR TO TRANSLATE TABLE
*           (WA)             LENGTH OF STRING TO BE TRANSLATED
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           THE TRANSLATE TABLE CONSISTS OF CFP$A CONTIGUOUS
*           CHARACTERS GIVING THE TRANSLATIONS OF THE CFP$A
*           CHARACTERS IN THE ALPHABET. ON COMPLETION, (XR) AND
*           (XL) ARE SET TO ZERO AND (WA) IS UNDEFINED.
*
*      6.10 FLC  W           FOLD CHARACTER TO UPPER CASE
*           FLC IS USED ONLY IF .CULC IS DEFINED. THE CHARACTER
*           CODE VALUE IN W IS TRANSLATED TO UPPER CASE IF IT
*           CORRESPONDS TO A LOWER CASE CHARACTER.
{{EJC{{{{{2600
*
*      -7-  OPERATIONS ON BIT STRING VALUES
*
*      7.1  ANB  OPW,W       AND BIT STRING VALUES
*      7.2  ORB  OPW,W       OR BIT STRING VALUES
*      7.3  XOB  OPW,W       EXCLUSIVE OR BIT STRING VALUES
*
*           IN THE ABOVE OPERATIONS, THE LOGICAL CONNECTIVE IS
*           APPLIED SEPARATELY TO EACH OF THE CFP$N BITS.
*           THE RESULT IS STORED IN THE SECOND OPERAND LOCATION.
*
*      7.4  CMB  W           COMPLEMENT ALL BITS IN OPW
*
*      7.5  RSH  W,VAL       RIGHT SHIFT BY VAL BITS
*      7.6  LSH  W,VAL       LEFT SHIFT BY VAL BITS
*      7.7  RSX  W,(X)       RIGHT SHIFT W NUMBER OF BITS IN X
*      7.8  LSX  W,(X)       LEFT SHIFT W NUMBER OF BITS IN X
*
*           THE ABOVE SHIFTS ARE LOGICAL SHIFTS IN WHICH BITS
*           SHIFTED OUT ARE LOST AND ZERO BITS SUPPLIED AS
*           REQUIRED. THE SHIFT COUNT IS IN THE RANGE 0-CFP$N.
*
*      7.9  NZB  W,PLBL      JUMP TO PLBL IF W IS NOT
*                            ALL ZERO BITS.
*
*      7.10 ZRB  W,PLBL      JUMP TO PLBL IF W IS ALL ZERO BITS
*
*      7.11 ZGB  OPN         ZEROISE GARBAGE BITS
*
*           OPN CONTAINS A BIT STRING REPRESENTING A WORD
*           OF CHARACTERS FROM A STRING OR SOME FUNCTION
*           FORMED FROM SUCH CHARACTERS (E.G. AS A RESULT OF
*           HASHING). ON A MACHINE WHERE THE WORD SIZE IS NOT A
*           MULTIPLE OF THE CHARACTER SIZE, SOME BITS IN REG MAY
*           BE UNDEFINED. THIS OPCODE REPLACES SUCH BITS BY THE
*           ZERO BIT. ZGB IS A NO-OP IF THE WORD SIZE IS A
*           MULTIPLE OF THE CHARACTER SIZE.
{{EJC{{{{{2638
*
*      -8-  CONVERSION INSTRUCTIONS
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN LENGTHS IN BYTES AND LENGTHS IN WORDS.
*
*      8.1  WTB  REG         CONVERT REG FROM WORDS TO BYTES.
*                            THAT IS, MULTIPLY BY CFP$B. THIS IS
*                            A NO-OP IF CFP$B IS ONE.
*
*      8.2  BTW  REG         CONVERT REG FROM BYTES TO WORDS
*                            BY DIVIDING REG BY CFP$B DISCARDING
*                            THE FRACTION. NO-OP IF CFP$B IS ONE
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           OF ONE WORD INTEGER VALUES (ADDRESSES) TO AND
*           FROM THE FULL SIGNED INTEGER FORMAT.
*
*      8.3  MTI  OPN         THE VALUE OF OPN (AN ADDRESS)
*                            IS MOVED AS A POSITIVE INTEGER
*                            TO THE INTEGER ACCUMULATOR.
*
*      8.4  MFI  OPN,PLBL    THE VALUE CURRENTLY STORED IN THE
*                            INTEGER ACCUMULATOR IS MOVED
*                            TO OPN AS AN ADDRESS IF IT IS IN
*                            THE RANGE 0 TO CFP$M INCLUSIVE.
*                            IF THE ACCUMULATOR VALUE IS
*                            OUTSIDE THIS RANGE, THEN THE RESULT
*                            IN OPN IS UNDEFINED AND CONTROL IS
*                            PASSED TO PLBL. MFI DESTROYS THE
*                            VALUE OF (IA) WHETHER OR NOT
*                            INTEGER OVERFLOW IS SIGNALLED.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN REAL VALUES AND INTEGER VALUES.
*
*      8.5  ITR              CONVERT INTEGER VALUE IN INTEGER
*                            ACCUMULATOR TO REAL AND STORE IN
*                            REAL ACCUMULATOR (MAY LOSE
*                            PRECISION IN SOME CASES)
*
*      8.6  RTI  PLBL        CONVERT THE REAL VALUE IN RA TO
*                            AN INTEGER AND PLACE RESULT IN IA.
*                            CONVERSION IS BY TRUNCATION OF THE
*                            FRACTION - NO ROUNDING OCCURS.
*                            JUMP TO PLBL IF OUT OF RANGE. (RA)
*                            IS NOT CHANGED IN EITHER CASE.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
{{EJC{{{{{2690
*
*      -8-  CONVERSION INSTRUCTIONS (CONTINUED)
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR COMPUTING
*           THE LENGTH OF STORAGE REQUIRED FOR A TEXT STRING.
*
*      8.7  CTW  W,VAL       THIS INSTRUCTION COMPUTES THE SUM
*                            (NUMBER OF WORDS REQUIRED TO STORE
*                            W CHARACTERS) + (VAL). THE SUM
*                            IS STORED IN W.
*                            FOR EXAMPLE, IF CFP$C IS 5, AND WA
*                            CONTAINS 32, THEN CTW WA,2
*                            GIVES A RESULT OF 9 IN WA.
*
*      8.8  CTB  W,VAL       CTB IS EXACTLY LIKE CTW EXCEPT THAT
*                            THE RESULT IS IN BYTES. IT HAS THE
*                            SAME EFFECT AS CTW W,VAL  WTB W
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           FROM INTEGERS TO AND FROM NUMERIC DIGIT CHARACTERS
*           FOR USE IN NUMERIC CONVERSION ROUTINES. THEY EMPLOY
*           NEGATIVE INTEGER VALUES TO ALLOW FOR PROPER
*           CONVERSION OF NUMBERS WHICH CANNOT BE COMPLEMENTED.
*
*      8.9  CVM  PLBL        CONVERT BY MULTIPLICATION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS MULTIPLIED BY 10. WB CONTAINS THE CHARACTER
*           CODE FOR A DIGIT. THE VALUE OF THIS DIGIT IS THEN
*           SUBTRACTED FROM THE RESULT. IF THE RESULT IS OUT OF
*           RANGE, THEN CONTROL IS PASSED TO PLBL WITH THE
*           RESULT IN (IA) UNDEFINED. EXECUTION OF CVM LEAVES
*           THE RESULT IN (WB) UNDEFINED.
*
*      8.10 CVD              CONVERT BY DIVISION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS DIVIDED BY 10. THE QUOTIENT (ZERO OR NEGATIVE)
*           IS REPLACED IN THE ACCUMULATOR. THE REMAINDER IS
*           CONVERTED TO THE CHARACTER CODE OF A DIGIT AND
*           PLACED IN WA. FOR EXAMPLE, AN OPERAND OF -523 GIVES
*           A QUOTIENT OF -52 AND A REMAINDER IN WA OF CH$D3.
{{EJC{{{{{2733
*
*      -9-  BLOCK MOVE INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED FOR TRANSFERRING
*      DATA FROM ONE AREA OF MEMORY TO ANOTHER IN BLOCKS.
*      THEY CAN BE IMPLEMENTED WITH THE INDICATED SERIES OF
*      OTHER MACRO-INSTRUCTIONS, BUT MORE EFFICIENT IMPLE-
*      MENTATIONS WILL BE POSSIBLE ON MOST MACHINES.
*
*      NOTE THAT IN THE EQUIVALENT CODE SEQUENCE SHOWN BELOW, A
*      ZERO VALUE IN WA WILL MOVE AT LEAST ONE ITEM, AND MAY
*      MAY WRAP THE COUNTER CAUSING A CORE DUMP IN SOME IMPLE-
*      MENTATIONS.  THUS WA SHOULD BE .GT. 0 PRIOR TO INVOKING
*      ANY OF THESE BLOCK MOVE INSTRUCTIONS.
*
*      9.1  MVC              MOVE CHARACTERS
*
*           BEFORE OBEYING THIS ORDER WA,XL,XR SHOULD HAVE BEEN
*           SET UP, THE LATTER TWO BY PLC, PSC RESP.
*           MVC IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,(XL)+
*                  SCH  WB,(XR)+
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THE CHARACTER POINTERS ARE BUMPED AS INDICATED
*           AND THE FINAL VALUE OF WA IS UNDEFINED.
*
*
*      9.2  MVW              MOVE WORDS
*
*           MVW IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPW  MOV  (XL)+,(XR)+
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPW
*
*           NOTE THAT THIS IMPLIES THAT THE VALUE IN WA IS THE
*           LENGTH IN BYTES WHICH IS A MULTIPLE OF CFP$B.
*           THE INITIAL ADDRESSES IN XR,XL ARE WORD ADDRESSES.
*           AS INDICATED, THE FINAL XR,XL VALUES POINT PAST THE
*           NEW AND OLD REGIONS OF MEMORY RESPECTIVELY.
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MVW.
*
*      9.3  MWB              MOVE WORDS BACKWARDS
*
*           MWB IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPB  MOV  -(XL),-(XR)
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MWB.
*
*      9.4  MCB              MOVE CHARACTERS BACKWARDS
*
*           MCB IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,-(XL)
*                  SCH  WB,-(XR)
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MCB.
{{EJC{{{{{2816
*
*      -10- OPERATIONS CONNECTED WITH THE STACK
*
*      THE STACK IS AN AREA IN MEMORY WHICH IS DEDICATED FOR USE
*      IN CONJUNCTION WITH THE STACK POINTER REGISTER (XS). AS
*      PREVIOUSLY DESCRIBED, IT IS USED BY THE JSR AND EXI
*      INSTRUCTIONS AND MAY BE USED FOR STORAGE OF ANY OTHER
*      DATA AS REQUIRED.
*
*      THE STACK BUILDS EITHER WAY IN MEMORY AND AN IMPORTANT
*      RESTRICTION IS THAT THE VALUE IN (XS) MUST BE THE ADDRESS
*      OF THE STACK FRONT AT ALL TIMES SINCE
*      SOME IMPLEMENTATIONS MAY RANDOMLY DESTROY STACK LOCATIONS
*      BEYOND (XS).
*
*      THE STARTING STACK BASE ADDRESS IS PASSED
*      IN (XS) AT THE START OF EXECUTION. DURING EXECUTION IT
*      IS NECESSARY TO MAKE SURE THAT THE STACK DOES NOT
*      OVERFLOW. THIS IS ACHIEVED BY EXECUTING THE FOLLOWING
*      INSTRUCTION PERIODICALLY.
*
*      10.1 CHK              CHECK STACK OVERFLOW
*
*      AFTER SUCCESSFULLY EXECUTING CHK, IT IS PERMISSIBLE TO
*      USE UP TO 100 ADDITIONAL WORDS BEFORE ISSUING ANOTHER CHK
*      THUS CHK NEED NOT BE ISSUED EVERY TIME THE STACK IS
*      EXPANDED. IN SOME IMPLEMENTATIONS, THE CHECKING MAY BE
*      AUTOMATIC AND CHK WILL HAVE NO EFFECT. FOLLOWING THE
*      ABOVE RULE MAKES SURE THAT THE PROGRAM WILL OPERATE
*      CORRECTLY IN IMPLEMENTATIONS WITH NO AUTOMATIC CHECK.
*
*      IF STACK OVERFLOW OCCURS (DETECTED EITHER AUTOMATICALLY
*      OR BY A CHK INSTRUCTION), THEN CONTROL IS PASSED TO THE
*      STACK OVERFLOW SECTION (SEE PROGRAM FORM). NOTE THAT THIS
*      TRANSFER MAY TAKE PLACE FOLLOWING ANY INSTRUCTION WHICH
*      STORES DATA AT A NEW LOCATION ON THE STACK.
*      AFTER STACK OVERFLOW, STACK IS ARBITRARILY POPPED
*      TO GIVE SOME SPACE IN WHICH THE ERROR PROCEDURE MAY
*      OPERATE. OTHERWISE A LOOP OF STACK OVERFLOWS MAY OCCUR.
{{EJC{{{{{2856
*
*      -11- DATA GENERATION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED TO GENERATE CONSTANT
*      VALUES IN THE CONSTANT SECTION AND ALSO TO ASSEMBLE
*      INITIAL VALUES IN THE WORKING STORAGE SECTION. THEY
*      MAY NOT APPEAR EXCEPT IN THESE TWO SECTIONS.
*
*      11.1 DAC  ADDR        ASSEMBLE ADDRESS CONSTANT.
*                            GENERATES ONE WORD CONTAINING THE
*                            SPECIFIED ONE WORD INTEGER
*                            VALUE (ADDRESS).
*
*      11.2 DIC  INTEGER     GENERATES AN INTEGER VALUE WHICH
*                            OCCUPIES CFP$I CONSECUTIVE WORDS.
*                            THE OPERAND IS A DIGIT STRING WITH
*                            A REQUIRED LEADING SIGN.
*
*      11.3 DRC  REAL        ASSEMBLES A REAL CONSTANT WHICH
*                            OCCUPIES CFP$R CONSECUTIVE WORDS.
*                            THE OPERAND FORM MUST OBEY THE
*                            RULES FOR A FORTRAN REAL CONSTANT
*                            WITH THE EXTRA REQUIREMENT THAT A
*                            LEADING SIGN BE PRESENT.
*
*      11.4 DTC  DTEXT       DEFINE TEXT CONSTANT. DTEXT
*                            IS STARTED AND ENDED WITH ANY
*                            CHARACTER NOT CONTAINED IN THE
*                            CHARACTERS TO BE ASSEMBLED. THE
*                            CONSTANT OCCUPIES CONSECUTIVE WORDS
*                            AS DICTATED BY THE CONFIGURATION
*                            PARAMETER CFP$C. ANY UNUSED CHARS
*                            IN THE LAST WORD ARE RIGHT FILLED
*                            WITH ZEROS (I.E. THE CHARACTER
*                            WHOSE INTERNAL CODE IS ZERO).
*                            THE STRING CONTAINS A SEQUENCE OF
*                            LETTERS, DIGITS, BLANKS AND ANY OF
*                            THE FOLLOWING SPECIAL CHARACTERS.
*                            =,$.(*)/+-
*                            NO OTHER CHARACTERS
*                            MAY BE USED IN A DTEXT OPERAND.
*
*      11.5 DBC  VAL         ASSEMBLE BIT STRING CONSTANT. THE
*                            OPERAND IS A POSITIVE INTEGER
*                            VALUE WHICH IS INTERPRETED IN
*                            BINARY, RIGHT JUSTIFIED AND LEFT
*                            FILLED WITH ZERO BITS. THUS 5 WOULD
*                            IMPLY THE BIT STRING VALUE 00...101.
{{EJC{{{{{2905
*
*      -12- SYMBOL DEFINITION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTION IS USED TO DEFINE SYMBOLS
*      IN THE DEFINITIONS SECTION. IT MAY NOT BE USED ELSEWHERE.
*
*      12.1 EQU  EQOP        DEFINE SYMBOL
*
*           THE SYMBOL WHICH APPEARS IN THE LABEL FIELD IS
*           DEFINED TO HAVE THE ABSOLUTE VALUE GIVEN
*           BY THE EQOP OPERAND. A GIVEN SYMBOL MAY BE DEFINED
*           ONLY ONCE IN THIS MANNER, AND ANY SYMBOLS OCCURING
*           IN EQOP MUST BE PREVIOUSLY DEFINED.
*
*           THE FOLLOWING ARE THE POSSIBILITIES FOR EQOP
*
*           VAL              THE INDICATED VALUE IS USED
*
*           VAL+VAL          THE SUM OF THE TWO VALUES IS USED.
*                            THIS SUM MUST NOT EXCEED CFP$M
*
*           VAL-VAL          THE DIFFERENCE BETWEEN THE TWO
*                            VALUES (MUST BE POSITIVE) IS USED.
*
*           *                THIS FORMAT DEFINES THE LABEL BY
*                            USING A VALUE SUPPLIED BY THE
*                            MINIMAL TRANSLATOR. VALUES ARE
*                            REQUIRED FOR THE
*           CFP$X            (CONFIGURATION PARAMETERS)
*           E$XXX            (ENVIRONMENT PARAMETERS)
*           CH$XX            (CHARACTER CODES).
*                            IN ORDER FOR A TRANSLATOR TO
*                            HANDLE THIS FORMAT CORRECTLY THE
*                            DEFINITIONS SECTION MUST BE
*                            CONSULTED FOR DETAILS OF REQUIRED
*                            SYMBOLS AS LISTED AT THE FRONT OF
*                            THE SECTION.
{{EJC{{{{{2943
*
*      SYMBOL DEFINITION INSTRUCTIONS (CONTINUED)
*
*      THE FOLLOWING INSTRUCTIONS MAY BE USED TO DEFINE SYMBOLS
*      IN THE PROCEDURE SECTION. THEY MAY NOT BE USED IN
*      ANY OTHER PART OF THE PROGRAM.
*
*      12.2 EXP              DEFINE EXTERNAL PROCEDURE
*
*           EXP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN EXTERNAL PROCEDURE WHICH CAN BE
*           REFERENCED IN A SUBSEQUENT JSR INSTRUCTION. THE
*           CODING FOR THE PROCEDURE IS EXTERNAL TO THE
*           CODING OF THE SOURCE PROGRAM IN THIS LANGUAGE.
*           THE CODE FOR EXTERNAL PROCEDURES MAY BE
*           REFERRED TO COLLECTIVELY AS THE OPERATING SYSTEM
*           INTERFACE, OR MORE BRIEFLY, OSINT, AND WILL
*           FREQUENTLY BE A SEPARATELY COMPILED SEGMENT OF CODE
*           LOADED WITH SPITBOL TO PRODUCE A COMPLETE SYSTEM.
*
*      12.3 INP  PTYP,INT    DEFINE INTERNAL PROCEDURE
*
*           INP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN INTERNAL PROCEDURE AND GIVES
*           ITS TYPE AND NUMBER OF EXIT PARAMETERS. THE LABEL
*           CAN BE REFERENCED IN JSR INSTRUCTIONS AND
*           IT MUST APPEAR LABELLING A PRC INSTRUCTION IN THE
*           PROGRAM SECTION.
*
*      12.4 INR              DEFINE INTERNAL ROUTINE
*
*           INR DEFINES THE SYMBOL APPEARING IN THE LABEL
*           FIELD TO BE THE NAME OF AN INTERNAL ROUTINE. THE
*           LABEL MAY BE REFERENCED IN ANY TYPE OF BRANCH ORDER
*           AND IT MUST APPEAR LABELLING A RTN INSTRUCTION IN
*           THE PROGRAM SECTION.
{{EJC{{{{{2980
*
*      -13- ASSEMBLY LISTING LAYOUT INSTRUCTIONS
*
*      13.1 EJC              EJECT TO NEXT PAGE
*
*      13.2 TTL  TEXT        SET NEW ASSEMBLY TITLE
*
*           TTL IMPLIES AN IMMEDIATE EJECT OF THE
*           ASSEMBLY LISTING TO PRINT THE NEW TITLE.
*
*           THE USE OF TTL AND EJC CARDS IS SUCH THAT THE
*           PROGRAM WILL LIST NEATLY IF THE PRINTER PRINTS
*           AS MANY AS 58 LINES PER PAGE. IN THE EVENT THAT
*           THE PRINTER DEPTH IS LESS THAN THIS, OR IF THE
*           LISTING CONTAINS INTERSPERSED LINES (SUCH AS ACTUAL
*           GENERATED CODE), THEN THE FORMAT MAY BE UPSET.
*
*           LINES STARTING WITH AN ASTERISK ARE COMMENT LINES
*           WHICH CAUSE NO CODE TO BE GENERATED AND MAY OCCUR
*           FREELY ANYWHERE IN THE PROGRAM. THE FORMAT FOR
*           COMMENT LINES IS GIVEN IN SECTION -15-.
{{EJC{{{{{3002
*
*      -14- PROGRAM FORM
*
*           THE PROGRAM CONSISTS OF SEPARATE SECTIONS SEPARATED
*           BY SEC OPERATIONS. THE SECTIONS MUST APPEAR IN THE
*           FOLLOWING SPECIFIED ORDER.
*
*      14.1 SEC              START OF PROCEDURE SECTION
*
*           (PROCEDURE SECTION)
*
*           SEC               START OF DEFINITIONS SECTION
*
*           (DEFINITIONS SECTION)
*
*           SEC               START OF CONSTANT STORAGE SECTION
*
*           (CONSTANT STORAGE SECTION)
*
*           SEC               START OF WORKING STORAGE SECTION
*
*           (WORKING STORAGE SECTION)
*
*           SEC               START OF PROGRAM SECTION
*
*           (PROGRAM SECTION)
*
*           SEC               START OF STACK OVERFLOW SECTION
*
*           (STACK OVERFLOW SECTION)
*
*           SEC               START OF ERROR SECTION
*
*           (ERROR SECTION)
*
*      14.2 END              END OF ASSEMBLY
{{EJC{{{{{3039
*
*      SECTION 10 - PROGRAM FORM
*
*      PROCEDURE SECTION
*
*           THE PROCEDURE SECTION CONTAINS ALL THE EXP
*           INSTRUCTIONS FOR EXTERNALLY AVAILABLE PROCEDURES
*           AND INP,INR OPCODES FOR INTERNAL PROCEDURES,ROUTINES
*           SO THAT A SINGLE PASS MINIMAL TRANSLATOR HAS ADVANCE
*           KNOWLEDGE OF PROCEDURE TYPES WHEN TRANSLATING CALLS.
*
*      DEFINITIONS SECTION
*
*           THE DEFINITIONS SECTION CONTAINS EQU INSTRUCTIONS
*           WHICH DEFINE SYMBOLS REFERENCED LATER ON IN THE
*           PROGRAM, CONSTANT AND WORK SECTIONS.
*
*      CONSTANT STORAGE SECTION
*
*           THE CONSTANT STORAGE SECTION CONSISTS ENTIRELY
*           OF CONSTANTS ASSEMBLED WITH THE DAC,DIC,DRC,DTC,DBC
*           ASSEMBLY OPERATIONS. THESE CONSTANTS CAN BE FREELY
*           REFERENCED BY THE PROGRAM INSTRUCTIONS.
*
*      WORKING STORAGE SECTION
*
*           THE WORKING STORAGE SECTION CONSISTS ENTIRELY OF
*           DAC,DIC,DRC,DBC,DTC INSTRUCTIONS TO DEFINE A FIXED
*           LENGTH WORK AREA. THE WORK LOCATIONS IN THIS AREA
*           CAN BE DIRECTLY REFERENCED IN PROGRAM INSTRUCTIONS.
*           THE AREA IS INITIALIZED IN ACCORDANCE WITH THE
*           VALUES ASSEMBLED IN THE INSTRUCTIONS.
*
*      PROGRAM SECTION
*
*           THE PROGRAM SECTION CONTAINS PROGRAM INSTRUCTIONS
*           AND ASSOCIATED OPERATIONS (SUCH AS PRC, ENP, ENT).
*           CONTROL IS PASSED TO THE FIRST INSTRUCTION IN THIS
*           SECTION WHEN EXECUTION IS INITIATED.
*
*      STACK OVERFLOW SECTION
*
*           THE STACK OVERFLOW SECTION CONTAINS INSTRUCTIONS
*           LIKE THE PROGRAM SECTION. CONTROL IS PASSED TO THE
*           FIRST INSTRUCTION IN THIS SECTION FOLLOWING THE
*           OCCURRENCE OF STACK OVERFLOW, SEE CHK INSTRUCTION.
*
*      ERROR SECTION
*
*           THE ERROR SECTION CONTAINS INSTRUCTIONS LIKE THE
*           PROGRAM SECTION. CONTROL IS PASSED TO THE FIRST
*           INSTRUCTION IN THIS SECTION WHEN A PROCEDURE EXIT
*           CORRESPONDS TO AN ERROR PARAMETER (SEE ERR)
*           OR WHEN AN ERB OPCODE IS OBEYED. THE ERROR CODE
*           MUST CLEAN UP THE MAIN STACK AND CATER FOR THE
*           POSSIBILITY THAT A SUBROUTINE STACK MAY NEED CLEAN
*           UP.
{{EJC{{{{{3097
*      OSINT
*
*           THOUGH NOT PART OF THE MINIMAL SOURCE, IT IS USEFUL
*           TO REFER TO THE COLLECTION OF INITIALISATION AND
*           EXP ROUTINES AS OSINT (OPERATING SYSTEM INTERFACE).
*           ERRORS OCCURRING WITHIN OSINT PROCEDURES ARE
*           USUALLY HANDLED BY MAKING AN ERROR RETURN. IF THIS
*           IS NOT FEASIBLE OR APPROPRIATE, OSINT MAY USE THE
*           MINIMAL ERROR SECTION TO REPORT ERRORS DIRECTLY BY
*           BRANCHING TO IT WITH A SUITABLE NUMERIC ERROR
*           CODE IN WA.
{{EJC{{{{{3109
*
*      SECTION 11 - STATEMENT FORMAT
*
*      ALL LABELS ARE EXACTLY FIVE CHARACTERS LONG AND START
*      WITH THREE LETTERS (ABCDEFGHIJKLMNOPQRSTUVWXY$) FOLLOWED
*      BY TWO LETTERS OR DIGITS.
*      THE LETTER Z MAY NOT BE USED IN MINIMAL SYMBOLS BUT $ IS
*      PERMITTED.
*      FOR IMPLEMENTATIONS WHERE $ MAY NOT APPEAR IN THE
*      TARGET CODE , A SIMPLE SUBSTITUTION OF Z FOR $
*      MAY THUS BE MADE WITHOUT RISK OF PRODUCING NON-UNIQUE
*      SYMBOLS.
*      THE LETTER Z IS HOWEVER PERMITTED IN OPCODE MNEMONICS AND
*      IN COMMENTS.
*
*      MINIMAL STATEMENTS ARE IN A FIXED FORMAT AS FOLLOWS.
*
*      COLS 1-5              LABEL IF ANY (ELSE BLANK)
*
*      COLS 6-7              ALWAYS BLANK
*
*      COLS 8-10             OPERATION MNEMONIC
*
*      COLS 11-12            BLANKS
*
*      COLS 13-28            OPERAND FIELD, TERMINATED BY A
*                            BLANK. MAY OCCASIONALLY
*                            EXTEND PAST COLUMN 28.
*
*      COLS 30-64            COMMENT. ALWAYS SEPARATED FROM THE
*                            OPERAND FIELD BY AT LEAST ONE BLANK
*                            MAY OCCASIONALLY START AFTER COLUMN
*                            30 IF THE OPERAND EXTENDS PAST 28.
*                            A SPECIAL EXCEPTION OCCURS FOR THE
*                            IFF INSTRUCTION, WHOSE COMMENT MAY
*                            BE ONLY 20 CHARACTERS LONG (30-49).
*
*      COLS 65 ON            UNUSED
*
*
*      COMMENT LINES HAVE THE FOLLOWING FORMAT
*
*      COL 1                 ASTERISK
*
*      COLS 2-7              BLANK
*
*      COLS 8-64             ARBITRARY TEXT, RESTRICTED TO THE
*                            FORTRAN CHARACTER SET.
*
*
*      THE FORTRAN CHARACTER SET IS A-Z 0-9 =,$.(*)-/+
{{EJC{{{{{3161
*
*      SECTION 12 - PROGRAM EXECUTION
*
*      EXECUTION OF THE PROGRAM BEGINS WITH THE FIRST
*      INSTRUCTION IN THE PROGRAM SECTION.
*
*      IN ADDITION TO THE FIXED LENGTH MEMORY REGIONS DEFINED
*      BY THE ASSEMBLY, THERE ARE TWO DYNAMICALLY ALLOCATED
*      MEMORY REGIONS AS FOLLOWS.
*
*      DATA AREA             THIS IS AN AREA AVAILABLE TO THE
*                            PROGRAM FOR GENERAL STORAGE OF DATA
*                            ANY DATA VALUE MAY BE STORED IN
*                            THIS AREA EXCEPT INSTRUCTIONS.
*                            IN SOME IMPLEMENTATIONS, IT MAY BE
*                            POSSIBLE TO INCREASE THE SIZE OF
*                            THIS AREA DYNAMICALLY BY ADDING
*                            WORDS AT THE TOP END WITH A CALL
*                            TO A SYSTEM PROCEDURE.
*
*      STACK AREA            THIS REGION OF MEMORY HOLDS
*                            THE STACK USED FOR SUBROUTINE CALLS
*                            AND OTHER STORAGE OF ONE WORD
*                            INTEGER VALUES (ADDRESSES). THIS
*                            IS THE STACK ASSOCIATED WITH
*                            INDEX REGISTER XS.
*
*      THE LOCATIONS AND SIZES OF THESE AREAS ARE SPECIFIED
*      BY THE VALUES IN THE REGISTERS AT THE START OF PROGRAM
*      EXECUTION AS FOLLOWS.
*
*      (XS)                  ADDRESS ONE PAST THE STACK BASE.
*                            E.G. IF XS IS 23456, A D-STACK WILL
*                            OCCUPY WORDS 23455,23454,...
*                            WHEREAS A U-STACK WILL OCCUPY
*                            23457,23458,...
*
*      (XR)                  ADDRESS OF THE FIRST WORD
*                            IN THE DATA AREA
*
*      (XL)                  ADDRESS OF THE LAST WORD IN THE
*                            DATA AREA.
*
*      (WA)                  INITIAL STACK POINTER
*
*      (WB,WC,IA,RA,CP)      ZERO
*
*      THERE IS NO EXPLICIT WAY TO TERMINATE THE EXECUTION OF A
*      PROGRAM. THIS FUNCTION IS PERFORMED BY AN APPROPRIATE
*      SYSTEM PROCEDURE REFERENCED WITH THE SYSEJ INSTRUCTION.
{{TTL{27,S P I T B O L  -- BASIC INFORMATION{{{{3212
{{EJC{{{{{3213
*
*      GENERAL STRUCTURE
*      -----------------
*
*      THIS PROGRAM IS A TRANSLATOR FOR A VERSION OF THE SNOBOL4
*      PROGRAMMING LANGUAGE. LANGUAGE DETAILS ARE CONTAINED IN
*      THE MANUAL MACRO SPITBOL BY DEWAR AND MCCANN, TECHNICAL
*      REPORT 90, UNIVERSITY OF LEEDS 1976.
*      THE IMPLEMENTATION IS DISCUSSED IN DEWAR AND MCCANN,
*      MACRO SPITBOL - A SNOBOL4 COMPILER, SOFTWARE PRACTICE AND
*      EXPERIENCE, 7, 95-113, 1977.
*      THE LANGUAGE IS AS IMPLEMENTED BY THE BTL TRANSLATOR
*      (GRISWOLD, POAGE AND POLONSKY, PRENTICE HALL, 1971)
*      WITH THE FOLLOWING PRINCIPAL EXCEPTIONS.
*
*      1)   REDEFINITION OF STANDARD SYSTEM FUNCTIONS AND
*           OPERATORS IS NOT PERMITTED.
*
*      2)   THE VALUE FUNCTION IS NOT PROVIDED.
*
*      3)   ACCESS TRACING IS PROVIDED IN ADDITION TO THE
*           OTHER STANDARD TRACE MODES.
*
*      4)   THE KEYWORD STFCOUNT IS NOT PROVIDED.
*
*      5)   THE KEYWORD FULLSCAN IS NOT PROVIDED AND ALL PATTERN
*           MATCHING TAKES PLACE IN FULLSCAN MODE (I.E. WITH NO
*           HEURISTICS APPLIED).
*
*      6)   A SERIES OF EXPRESSIONS SEPARATED BY COMMAS MAY
*           BE GROUPED WITHIN PARENTHESES TO PROVIDE A SELECTION
*           CAPABILITY. THE SEMANTICS ARE THAT THE SELECTION
*           ASSUMES THE VALUE OF THE FIRST EXPRESSION WITHIN IT
*           WHICH SUCCEEDS AS THEY ARE EVALUATED FROM THE LEFT.
*           IF NO EXPRESSION SUCCEEDS THE ENTIRE STATEMENT FAILS
*
*      7)   AN EXPLICIT PATTERN MATCHING OPERATOR IS PROVIDED.
*           THIS IS THE BINARY QUERY (SEE GIMPEL SIGPLAN OCT 74)
*
*      8)   THE ASSIGNMENT OPERATOR IS INTRODUCED AS IN THE
*           GIMPEL REFERENCE.
*
*      9)   THE EXIT FUNCTION IS PROVIDED FOR GENERATING LOAD
*           MODULES - CF. GIMPELS SITBOL.
*
*
*      THE METHOD USED IN THIS PROGRAM IS TO TRANSLATE THE
*      SOURCE CODE INTO AN INTERNAL PSEUDO-CODE (SEE FOLLOWING
*      SECTION). AN INTERPRETOR IS THEN USED TO EXECUTE THIS
*      GENERATED PSEUDO-CODE. THE NATURE OF THE SNOBOL4 LANGUAGE
*      IS SUCH THAT THE LATTER TASK IS MUCH MORE COMPLEX THAN
*      THE ACTUAL TRANSLATION PHASE. ACCORDINGLY, NEARLY ALL THE
*      CODE IN THE PROGRAM SECTION IS CONCERNED WITH THE ACTUAL
*      EXECUTION OF THE SNOBOL4 PROGRAM.
{{EJC{{{{{3268
*
*      INTERPRETIVE CODE FORMAT
*      ------------------------
*
*      THE INTERPRETIVE PSEUDO-CODE CONSISTS OF A SERIES OF
*      ADDRESS POINTERS. THE EXACT FORMAT OF THE CODE IS
*      DESCRIBED IN CONNECTION WITH THE CDBLK FORMAT. THE
*      PURPOSE OF THIS SECTION IS TO GIVE GENERAL INSIGHT INTO
*      THE INTERPRETIVE APPROACH INVOLVED.
*
*      THE BASIC FORM OF THE CODE IS RELATED TO REVERSE POLISH.
*      IN OTHER WORDS, THE OPERANDS PRECEDE THE OPERATORS WHICH
*      ARE ZERO ADDRESS OPERATORS. THERE ARE SOME EXCEPTIONS TO
*      THESE RULES, NOTABLY THE UNARY NOT OPERATOR AND THE
*      SELECTION CONSTRUCTION WHICH CLEARLY REQUIRE ADVANCE
*      KNOWLEDGE OF THE OPERATOR INVOLVED.
*
*      THE OPERANDS ARE MOVED TO THE TOP OF THE MAIN STACK AND
*      THE OPERATORS ARE APPLIED TO THE TOP STACK ENTRIES. LIKE
*      OTHER VERSIONS OF SPITBOL, THIS PROCESSOR DEPENDS ON
*      KNOWING WHETHER OPERANDS ARE REQUIRED BY NAME OR BY VALUE
*      AND MOVES THE APPROPRIATE OBJECT TO THE STACK. THUS NO
*      NAME/VALUE CHECKS ARE INCLUDED IN THE OPERATOR CIRCUITS.
*
*      THE ACTUAL POINTERS IN THE CODE POINT TO A BLOCK WHOSE
*      FIRST WORD IS THE ADDRESS OF THE INTERPRETOR ROUTINE
*      TO BE EXECUTED FOR THE CODE WORD.
*
*      IN THE CASE OF OPERATORS, THE POINTER IS TO A WORD WHICH
*      CONTAINS THE ADDRESS OF THE OPERATOR TO BE EXECUTED. IN
*      THE CASE OF OPERANDS SUCH AS CONSTANTS, THE POINTER IS TO
*      THE OPERAND ITSELF. ACCORDINGLY, ALL OPERANDS CONTAIN
*      A FIELD WHICH POINTS TO THE ROUTINE TO LOAD THE VALUE OF
*      THE OPERAND ONTO THE STACK. IN THE CASE OF A VARIABLE,
*      THERE ARE THREE SUCH POINTERS. ONE TO LOAD THE VALUE,
*      ONE TO STORE THE VALUE AND A THIRD TO JUMP TO THE LABEL.
*
*      THE HANDLING OF FAILURE RETURNS DESERVES SPECIAL COMMENT.
*      THE LOCATION FLPTR CONTAINS THE POINTER TO THE LOCATION
*      ON THE MAIN STACK WHICH CONTAINS THE FAILURE RETURN
*      WHICH IS IN THE FORM OF A BYTE OFFSET IN THE CURRENT
*      CODE BLOCK (CDBLK OR EXBLK). WHEN A FAILURE OCCURS, THE
*      STACK IS POPPED AS INDICATED BY THE SETTING OF FLPTR AND
*      CONTROL IS PASSED TO THE APPROPRIATE LOCATION IN THE
*      CURRENT CODE BLOCK WITH THE STACK POINTER POINTING TO THE
*      FAILURE OFFSET ON THE STACK AND FLPTR UNCHANGED.
{{EJC{{{{{3315
*
*      INTERNAL DATA REPRESENTATIONS
*      -----------------------------
*
*      REPRESENTATION OF VALUES
*
*      A VALUE IS REPRESENTED BY A POINTER TO A BLOCK WHICH
*      DESCRIBES THE TYPE AND PARTICULARS OF THE DATA VALUE.
*      IN GENERAL, A VARIABLE IS A LOCATION CONTAINING SUCH A
*      POINTER (ALTHOUGH IN THE CASE OF TRACE ASSOCIATIONS THIS
*      IS MODIFIED, SEE DESCRIPTION OF TRBLK).
*
*      THE FOLLOWING IS A LIST OF POSSIBLE DATATYPES SHOWING THE
*      TYPE OF BLOCK USED TO HOLD THE VALUE. THE DETAILS OF
*      EACH BLOCK FORMAT ARE GIVEN LATER.
*
*      DATATYPE              BLOCK TYPE
*      --------              ----------
*
*      ARRAY                 ARBLK OR VCBLK
*
*      CODE                  CDBLK
*
*      EXPRESSION            EXBLK OR SEBLK
*
*      INTEGER               ICBLK
*
*      NAME                  NMBLK
*
*      PATTERN               P0BLK OR P1BLK OR P2BLK
*
*      REAL                  RCBLK
*
*      STRING                SCBLK
*
*      TABLE                 TBBLK
*
*      PROGRAM DATATYPE      PDBLK
{{EJC{{{{{3354
*
*      REPRESENTATION OF VARIABLES
*      ---------------------------
*
*      DURING THE COURSE OF EVALUATING EXPRESSIONS, IT IS
*      NECESSARY TO GENERATE NAMES OF VARIABLES (FOR EXAMPLE
*      ON THE LEFT SIDE OF A BINARY EQUALS OPERATOR). THESE ARE
*      NOT TO BE CONFUSED WITH OBJECTS OF DATATYPE NAME WHICH
*      ARE IN FACT VALUES.
*
*      FROM A LOGICAL POINT OF VIEW, SUCH NAMES COULD BE SIMPLY
*      REPRESENTED BY A POINTER TO THE APPROPRIATE VALUE CELL.
*      HOWEVER IN THE CASE OF ARRAYS AND PROGRAM DEFINED
*      DATATYPES, THIS WOULD VIOLATE THE RULE THAT THERE MUST BE
*      NO POINTERS INTO THE MIDDLE OF A BLOCK IN DYNAMIC STORE.
*      ACCORDINGLY, A NAME IS ALWAYS REPRESENTED BY A BASE AND
*      OFFSET. THE BASE POINTS TO THE START OF THE BLOCK
*      CONTAINING THE VARIABLE VALUE AND THE OFFSET IS THE
*      OFFSET WITHIN THIS BLOCK IN BYTES. THUS THE ADDRESS
*      OF THE ACTUAL VARIABLE IS DETERMINED BY ADDING THE BASE
*      AND OFFSET VALUES.
*
*      THE FOLLOWING ARE THE INSTANCES OF VARIABLES REPRESENTED
*      IN THIS MANNER.
*
*      1)   NATURAL VARIABLE BASE IS PTR TO VRBLK
*                            OFFSET IS *VRVAL
*
*      2)   TABLE ELEMENT    BASE IS PTR TO TEBLK
*                            OFFSET IS *TEVAL
*
*      3)   ARRAY ELEMENT    BASE IS PTR TO ARBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      4)   VECTOR ELEMENT   BASE IS PTR TO VCBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      5)   PROG DEF DTP     BASE IS PTR TO PDBLK
*                            OFFSET IS OFFSET TO FIELD VALUE
*
*      IN ADDITION THERE ARE TWO CASES OF OBJECTS WHICH ARE
*      LIKE VARIABLES BUT CANNOT BE HANDLED IN THIS MANNER.
*      THESE ARE CALLED PSEUDO-VARIABLES AND ARE REPRESENTED
*      WITH A SPECIAL BASE POINTER AS FOLLOWS=
*
*      EXPRESSION VARIABLE   PTR TO EVBLK (SEE EVBLK)
*
*      KEYWORD VARIABLE      PTR TO KVBLK (SEE KVBLK)
*
*      PSEUDO-VARIABLES ARE HANDLED AS SPECIAL CASES BY THE
*      ACCESS PROCEDURE (ACESS) AND THE ASSIGNMENT PROCEDURE
*      (ASIGN). SEE THESE TWO PROCEDURES FOR DETAILS.
{{EJC{{{{{3407
*
*      ORGANIZATION OF DATA AREA
*      -------------------------
*
*      THE DATA AREA IS DIVIDED INTO TWO REGIONS.
*
*      STATIC AREA
*
*      THE STATIC AREA BUILDS UP FROM THE BOTTOM AND CONTAINS
*      DATA AREAS WHICH ARE ALLOCATED DYNAMICALLY BUT ARE NEVER
*      DELETED OR MOVED AROUND. THE MACRO-PROGRAM ITSELF
*      USES THE STATIC AREA FOR THE FOLLOWING.
*
*      1)   ALL VARIABLE BLOCKS (VRBLK).
*
*      2)   THE HASH TABLE FOR VARIABLE BLOCKS.
*
*      3)   MISCELLANEOUS BUFFERS AND WORK AREAS (SEE PROGRAM
*           INITIALIZATION SECTION).
*
*      IN ADDITION, THE SYSTEM PROCEDURES MAY USE THIS AREA FOR
*      INPUT/OUTPUT BUFFERS, EXTERNAL FUNCTIONS ETC. SPACE IN
*      THE STATIC REGION IS ALLOCATED BY CALLING PROCEDURE ALOST
*
*      THE FOLLOWING GLOBAL VARIABLES DEFINE THE CURRENT
*      LOCATION AND SIZE OF THE STATIC AREA.
*
*      STATB                 ADDRESS OF START OF STATIC AREA
*      STATE                 ADDRESS+1 OF LAST WORD IN AREA.
*
*      THE MINIMUM SIZE OF STATIC IS GIVEN APPROXIMATELY BY
*           12 + *E$HNB + *E$STS + SPACE FOR ALPHABET STRING
*           AND STANDARD PRINT BUFFER.
{{EJC{{{{{3441
*      DYNAMIC AREA
*
*      THE DYNAMIC AREA IS BUILT UPWARDS IN MEMORY AFTER THE
*      STATIC REGION. DATA IN THIS AREA MUST ALL BE IN STANDARD
*      BLOCK FORMATS SO THAT IT CAN BE PROCESSED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL). GBCOL COMPACTS BLOCKS DOWN
*      IN THIS REGION AS REQUIRED BY SPACE EXHAUSTION AND CAN
*      ALSO MOVE ALL BLOCKS UP TO ALLOW FOR EXPANSION OF THE
*      STATIC REGION.
*      WITH THE EXCEPTION OF TABLES AND ARRAYS, NO SPITBOL
*      OBJECT ONCE BUILT IN DYNAMIC MEMORY IS EVER SUBSEQUENTLY
*      MODIFIED. OBSERVING THIS RULE NECESSITATES A COPYING
*      ACTION DURING STRING AND PATTERN CONCATENATION.
*
*      GARBAGE COLLECTION IS FUNDAMENTAL TO THE ALLOCATION OF
*      SPACE FOR VALUES. SPITBOL USES A VERY EFFICIENT GARBAGE
*      COLLECTOR WHICH INSISTS THAT POINTERS INTO DYNAMIC STORE
*      SHOULD BE IDENTIFIABLE WITHOUT USE OF BIT TABLES,
*      MARKER BITS ETC. TO SATISFY THIS REQUIREMENT, DYNAMIC
*      MEMORY MUST NOT START AT TOO LOW AN ADDRESS AND LENGTHS
*      OF ARRAYS, TABLES, STRINGS, CODE AND EXPRESSION BLOCKS
*      MAY NOT EXCEED THE NUMERICAL VALUE OF THE LOWEST DYNAMIC
*      ADDRESS.
*
*      TO AVOID EITHER PENALIZING USERS WITH MODEST
*      REQUIREMENTS OR RESTRICTING THOSE WITH GREATER NEEDS ON
*      HOST SYSTEMS WHERE DYNAMIC MEMORY IS ALLOCATED IN LOW
*      ADDRESSES, THE MINIMUM DYNAMIC ADDRESS MAY BE SPECIFIED
*      SUFFICIENTLY HIGH TO PERMIT ARBITRARILY LARGE SPITBOL
*      OBJECTS TO BE CREATED (WITH THE POSSIBILITY IN EXTREME
*      CASES OF WASTING LARGE AMOUNTS OF MEMORY BELOW THE
*      START ADDRESS). THIS MINIMUM VALUE IS MADE AVAILABLE
*      IN VARIABLE MXLEN BY A SYSTEM ROUTINE, SYSMX.
*      ALTERNATIVELY SYSMX MAY INDICATE THAT A
*      DEFAULT MAY BE USED IN WHICH DYNAMIC IS PLACED
*      AT THE LOWEST POSSIBLE ADDRESS FOLLOWING STATIC.
*
*      THE FOLLOWING GLOBAL WORK CELLS DEFINE THE LOCATION AND
*      LENGTH OF THE DYNAMIC AREA.
*
*      DNAMB                 START OF DYNAMIC AREA
*      DNAMP                 NEXT AVAILABLE LOCATION
*      DNAME                 LAST AVAILABLE LOCATION + 1
*
*      DNAMB IS ALWAYS HIGHER THAN STATE SINCE THE ALOST
*      PROCEDURE MAINTAINS SOME EXPANSION SPACE ABOVE STATE.
*      *** DNAMB MUST NEVER BE PERMITTED TO HAVE A VALUE LESS
*      THAN THAT IN MXLEN ***
*
*      SPACE IN THE DYNAMIC REGION IS ALLOCATED BY THE ALLOC
*      PROCEDURE. THE DYNAMIC REGION MAY BE USED BY SYSTEM
*      PROCEDURES PROVIDED THAT ALL THE RULES ARE OBEYED.
*      SOME OF THE RULES ARE SUBTLE SO IT IS PREFERABLE FOR
*      OSINT TO MANAGE ITS OWN MEMORY NEEDS. SPITBOL PROCS
*      OBEY RULES TO ENSURE THAT NO ACTION CAN CAUSE A GARBAGE
*      COLLECTION EXCEPT AT SUCH TIMES AS CONTENTS OF XL, XR
*      AND THE STACK ARE +CLEAN+ (SEE COMMENT BEFORE UTILITY
*      PROCEDURES AND IN GBCOL FOR MORE DETAIL). NOTE
*      THAT CALLS OF ALOST MAY CAUSE GARBAGE COLLECTION (SHIFT
*      OF MEMORY TO FREE SPACE). SPITBOL PROCS WHICH CALL
*      SYSTEM ROUTINES ASSUME THAT THEY CANNOT PRECIPITATE
*      COLLECTION AND THIS MUST BE RESPECTED.
{{EJC{{{{{3504
*
*      REGISTER USAGE
*      --------------
*
*      (CP)                  CODE POINTER REGISTER. USED TO
*                            HOLD A POINTER TO THE CURRENT
*                            LOCATION IN THE INTERPRETIVE PSEUDO
*                            CODE (I.E. PTR INTO A CDBLK).
*
*      (XL,XR)               GENERAL INDEX REGISTERS. USUALLY
*                            USED TO HOLD POINTERS TO BLOCKS IN
*                            DYNAMIC STORAGE. AN IMPORTANT
*                            RESTRICTION IS THAT THE VALUE IN
*                            XL MUST BE COLLECTABLE FOR
*                            A GARBAGE COLLECT CALL. A VALUE
*                            IS COLLECTABLE IF IT EITHER POINTS
*                            OUTSIDE THE DYNAMIC AREA, OR IF IT
*                            POINTS TO THE START OF A BLOCK IN
*                            THE DYNAMIC AREA.
*
*      (XS)                  STACK POINTER. USED TO POINT TO
*                            THE STACK FRONT. THE STACK MAY
*                            BUILD UP OR DOWN AND IS USED
*                            TO STACK SUBROUTINE RETURN POINTS
*                            AND OTHER RECURSIVELY SAVED DATA.
*
*      (XT)                  AN ALTERNATIVE NAME FOR XL DURING
*                            ITS USE IN ACCESSING STACKED ITEMS.
*
*      (WA,WB,WC)            GENERAL WORK REGISTERS. CANNOT BE
*                            USED FOR INDEXING, BUT MAY HOLD
*                            VARIOUS TYPES OF DATA.
*
*      (IA)                  USED FOR ALL SIGNED INTEGER
*                            ARITHMETIC, BOTH THAT USED BY THE
*                            TRANSLATOR AND THAT ARISING FROM
*                            USE OF SNOBOL4 ARITHMETIC OPERATORS
*
*      (RA)                  REAL ACCUMULATOR. USED FOR ALL
*                            FLOATING POINT ARITHMETIC.
{{EJC{{{{{3545
*
*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS
*      ------------------------------------
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*      .CAEX                 DEFINE TO ALLOW UP ARROW FOR EXPON.
*      .CAHT                 DEFINE TO INCLUDE HORIZONTAL TAB
*      .CASL                 DEFINE TO INCLUDE 26 SHIFTED LETTRS
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CGBC                 DEFINE TO INCLUDE SYSGC FUNCTION
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*      .CIOD                 DEFINE TO NOT USE DEFAULT DELIMITER
*                              IN PROCESSING 3RD ARG OF INPUT()
*                              AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNBF                 DEFINE TO OMIT BUFFER EXTENSION
*      .CNBT                 DEFINE TO OMIT BATCH INITIALISATION
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE FOR LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE TO NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*                            OMIT TO TAKE DEFAULT OF 50000
*      .CSAX                 DEFINE IF SYSAX IS TO BE CALLED
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSN8                 DEFINE TO PAD STMT NOS TO 8 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTET                 DEFINE TO TABLE ENTRY TRACE WANTED
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*      .CUCF                 DEFINE TO INCLUDE CFP$U
*      .CUEJ                 DEFINE TO SUPPRESS NEEDLESS EJECTS
*      .CULK                 DEFINE TO INCLUDE &L/UCASE KEYWORDS
*      .CULC                 DEFINE TO INCLUDE &CASE (LC NAMES)
*                            IF CUCL DEFINED, MUST SUPPORT
*                            MINIMAL OP FLC WREG THAT FOLDS
*                            ARGUMENT TO UPPER CASE
*      .CUST                 DEFINE TO INCLUDE SET() CODE
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL
*                            NOT DEFINED, A FULL COMMENT LINE
*                            INDICATES SYMBOL INITIALLY NOT
*                            DEFINED.
*
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*                            IN PROCESSING 3RD ARG OF INPUT()
*                            AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE TO LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE IF NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*
*      FORCE DEFINITION OF .CCMK IF .CCMC IS DEFINED
*
{{TTL{27,S P I T B O L -- PROCEDURES SECTION{{{{3672
*
*      THIS SECTION STARTS WITH DESCRIPTIONS OF THE OPERATING
*      SYSTEM DEPENDENT PROCEDURES WHICH ARE USED BY THE SPITBOL
*      TRANSLATOR. ALL SUCH PROCEDURES HAVE FIVE LETTER NAMES
*      BEGINNING WITH SYS. THEY ARE LISTED IN ALPHABETICAL
*      ORDER.
*      ALL PROCEDURES HAVE A  SPECIFICATION CONSISTING OF A
*      MODEL CALL, PRECEDED BY A POSSIBLY EMPTY LIST OF REGISTER
*      CONTENTS GIVING PARAMETERS AVAILABLE TO THE PROCEDURE AND
*      FOLLOWED BY A POSSIBLY EMPTY LIST OF REGISTER CONTENTS
*      REQUIRED ON RETURN FROM THE CALL OR WHICH MAY HAVE HAD
*      THEIR CONTENTS DESTROYED. ONLY THOSE REGISTERS EXPLICITLY
*      MENTIONED IN THE LIST AFTER THE CALL MAY HAVE THEIR
*      VALUES CHANGED.
*      THE SEGMENT OF CODE PROVIDING THE EXTERNAL PROCEDURES IS
*      CONVENIENTLY REFERRED TO AS OSINT (OPERATING SYSTEM
*      INTERFACE). THE SYSXX PROCEDURES IT CONTAINS PROVIDE
*      FACILITIES NOT USUALLY AVAILABLE AS PRIMITIVES IN
*      ASSEMBLY LANGUAGES. FOR PARTICULAR TARGET MACHINES,
*      IMPLEMENTORS MAY CHOOSE FOR SOME MINIMAL OPCODES WHICH
*      DO NOT HAVE REASONABLY DIRECT TRANSLATIONS, TO USE CALLS
*      OF ADDITIONAL PROCEDURES WHICH THEY PROVIDE IN OSINT.
*      E.G. MWB OR TRC MIGHT BE TRANSLATED AS JSR SYSMB,
*      JSR SYSTC IN SOME IMPLEMENTATIONS.
*
*      IN THE DESCRIPTIONS, REFERENCE IS MADE TO --BLK
*      FORMATS (-- = A PAIR OF LETTERS). SEE THE SPITBOL
*      DEFINITIONS SECTION FOR DETAILED DESCRIPTIONS OF ALL
*      SUCH BLOCK FORMATS EXCEPT FCBLK FOR WHICH SYSFC SHOULD
*      BE CONSULTED.
*
*      SECTION 0 CONTAINS INP,INR SPECIFICATIONS OF INTERNAL
*      PROCEDURES,ROUTINES. THIS GIVES A SINGLE PASS TRANSLATOR
*      INFORMATION MAKING IT EASY TO GENERATE ALTERNATIVE CALLS
*      IN THE TRANSLATION OF JSR-S FOR PROCEDURES OF DIFFERENT
*      TYPES IF THIS PROVES NECESSARY.
*
{{SEC{{{{START OF PROCEDURES SECTION{3710
{{EJC{{{{{3712
*
*      SYSAX -- AFTER EXECUTION
*
{SYSAX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3716
*
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CSAX IS DEFINED,
*      THIS ROUTINE IS CALLED IMMEDIATELY AFTER EXECUTION AND
*      BEFORE PRINTING OF EXECUTION STATISTICS OR DUMP OUTPUT.
*      PURPOSE OF CALL IS FOR IMPLEMENTOR TO DETERMINE AND
*      IF THE CALL IS NOT REQUIRED IT WILL BE OMITTED IF .CSAX
*      IS UNDEFINED. IN THIS CASE SYSAX NEED NOT BE CODED.
*
*      JSR  SYSAX            CALL AFTER EXECUTION
{{EJC{{{{{3728
*
*      SYSBS -- BACKSPACE FILE
*
{SYSBS{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3733
*
*      SYSBS IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION BACKSPACE
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CBSP IS DEFINED.
*      THE MEANING IS SYSTEM DEPENDENT.  IN GENERAL, BACKSPACE
*      REPOSITIONS THE FILE ONE RECORD CLOSER TO THE BEGINNING
*      OF FILE, SUCH THAT A SUBSEQUENT READ OR WRITE WILL
*      OPERATE ON THE PREVIOUS RECORD.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  BACKSPACE ARGUMENT (SCBLK PTR)
*      JSR  SYSBS            CALL TO BACKSPACE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF BACKSPACE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      BACKSPACE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      FILES ON CHARACTER DEVICES ARE IN THIS CATEGORY.
{{EJC{{{{{3753
*
*      SYSBX -- BEFORE EXECUTION
*
{SYSBX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3758
*
*      CALLED AFTER INITIAL SPITBOL COMPILATION AND BEFORE
*      COMMENCING EXECUTION IN CASE OSINT NEEDS
*      TO ASSIGN FILES OR PERFORM OTHER NECESSARY SERVICES.
*      OSINT MAY ALSO CHOOSE TO SEND A MESSAGE TO ONLINE
*      TERMINAL (IF ANY) INDICATING THAT EXECUTION IS STARTING.
*
*      JSR  SYSBX            CALL BEFORE EXECUTION STARTS
{{EJC{{{{{3767
*
*      SYSDC -- DATE CHECK
*
{SYSDC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3861
*
*      SYSDC IS CALLED TO CHECK THAT THE EXPIRY DATE FOR A TRIAL
*      VERSION OF SPITBOL IS UNEXPIRED.
*
*      JSR  SYSDC            CALL TO CHECK DATE
*      RETURN ONLY IF DATE IS OK
{{EJC{{{{{3868
*
*      SYSDM  -- DUMP CORE
*
{SYSDM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3872
*
*      SYSDM IS CALLED BY A SPITBOL PROGRAM CALL OF DUMP(N) WITH
*      N GE 4.  ITS PURPOSE IS TO PROVIDE A CORE DUMP.
*      N COULD HOLD AN ENCODING OF THE START ADRS FOR DUMP AND
*      AMOUNT TO BE DUMPED E.G.  N = 256*A + S , S = START ADRS
*      IN KILOWORDS,  A = KILOWORDS TO DUMP
*
*      (XR)                  PARAMETER N OF CALL DUMP(N)
*      JSR  SYSDM            CALL TO ENTER ROUTINE
{{EJC{{{{{3882
*
*      SYSDT -- GET CURRENT DATE
*
{SYSDT{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3886
*
*      SYSDT IS USED TO OBTAIN THE CURRENT DATE. THE DATE IS
*      RETURNED AS A CHARACTER STRING IN ANY FORMAT APPROPRIATE
*      TO THE OPERATING SYSTEM IN USE. IT MAY ALSO CONTAIN THE
*      CURRENT TIME OF DAY. SYSDT IS USED TO IMPLEMENT THE
*      SNOBOL4 FUNCTION DATE().
*
*      (XR)                  PARAMETER N OF CALL DATE(N)
*      JSR  SYSDT            CALL TO GET DATE
*      (XL)                  POINTER TO BLOCK CONTAINING DATE
*
*      THE FORMAT OF THE BLOCK IS LIKE AN SCBLK EXCEPT THAT
*      THE FIRST WORD NEED NOT BE SET. THE RESULT IS COPIED
*      INTO SPITBOL DYNAMIC MEMORY ON RETURN.
{{EJC{{{{{3902
*
*      SYSEA -- INFORM OSINT OF COMPILATION AND RUNTIME ERRORS
*
{SYSEA{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3906
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS ON
*      ERRORS
*
*      (WA)                  ERROR CODE
*      (WB)                  LINE NUMBER
*      (WC)                  COLUMN NUMBER
*      (XR)                  SYSTEM STAGE
*      (XL)                  FILE NAME (SCBLK)
*      JSR  SYSEA            CALL TO SYSEA FUNCTION
*      PPM  LOC              SUPPRESS PRINTING OF ERROR MESSAGE
*      (XR)                  MESSAGE TO PRINT (SCBLK) OR 0
*
*      SYSEA MAY NOT RETURN IF INTERFACE CHOOSES TO RETAIN
*      CONTROL.  CLOSING FILES VIA THE FCB CHAIN WILL BE THE
*      RESPONSIBILITY OF THE INTERFACE.
*
*      ALL REGISTERS PRESERVED
{{EJC{{{{{3928
*
*      SYSEF -- EJECT FILE
*
{SYSEF{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3932
*
*      SYSEF IS USED TO WRITE A PAGE EJECT TO A NAMED FILE. IT
*      MAY ONLY BE USED FOR FILES WHERE THIS CONCEPT MAKES
*      SENSE. NOTE THAT SYSEF IS NOT NORMALLY USED FOR THE
*      STANDARD OUTPUT FILE (SEE SYSEP).
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  EJECT ARGUMENT (SCBLK PTR)
*      JSR  SYSEF            CALL TO EJECT FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF INAPPROPRIATE FILE
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{3945
*
*      SYSEJ -- END OF JOB
*
{SYSEJ{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3949
*
*      SYSEJ IS CALLED ONCE AT THE END OF EXECUTION TO
*      TERMINATE THE RUN. THE SIGNIFICANCE OF THE ABEND AND
*      CODE VALUES IS SYSTEM DEPENDENT. IN GENERAL, THE CODE
*      VALUE SHOULD BE MADE AVAILABLE FOR TESTING, AND THE
*      ABEND VALUE SHOULD CAUSE SOME POST-MORTEM ACTION SUCH AS
*      A DUMP. NOTE THAT SYSEJ DOES NOT RETURN TO ITS CALLER.
*      SEE SYSXI FOR DETAILS OF FCBLK CHAIN
*
*      (WA)                  VALUE OF ABEND KEYWORD
*      (WB)                  VALUE OF CODE KEYWORD
*      (XL)                  O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSEJ            CALL TO END JOB
*
*      THE FOLLOWING SPECIAL VALUES ARE USED AS CODES IN (WB)
*      999  EXECUTION SUPPRESSED
*      998  STANDARD OUTPUT FILE FULL OR UNAVAILABLE IN A SYSXI
*           LOAD MODULE. IN THESE CASES (WA) CONTAINS THE NUMBER
*           OF THE STATEMENT CAUSING PREMATURE TERMINATION.
{{EJC{{{{{3969
*
*      SYSEM -- GET ERROR MESSAGE TEXT
*
{SYSEM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3973
*
*      SYSEM IS USED TO OBTAIN THE TEXT OF ERR, ERB CALLS IN THE
*      SOURCE PROGRAM GIVEN THE ERROR CODE NUMBER. IT IS ALLOWED
*      TO RETURN A NULL STRING IF THIS FACILITY IS UNAVAILABLE.
*
*      (WA)                  ERROR CODE NUMBER
*      JSR  SYSEM            CALL TO GET TEXT
*      (XR)                  TEXT OF MESSAGE
*
*      THE RETURNED VALUE IS A POINTER TO A BLOCK IN SCBLK
*      FORMAT EXCEPT THAT THE FIRST WORD NEED NOT BE SET. THE
*      STRING IS COPIED INTO DYNAMIC MEMORY ON RETURN.
*      IF THE NULL STRING IS RETURNED EITHER BECAUSE SYSEM DOES
*      NOT PROVIDE ERROR MESSAGE TEXTS OR BECAUSE WA IS OUT OF
*      RANGE, SPITBOL WILL PRINT THE STRING STORED IN ERRTEXT
*      KEYWORD.
{{EJC{{{{{3990
*
*      SYSEN -- ENDFILE
*
{SYSEN{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3994
*
*      SYSEN IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION ENDFILE.
*      THE MEANING IS SYSTEM DEPENDENT. IN GENERAL, ENDFILE
*      IMPLIES THAT NO FURTHER I/O OPERATIONS WILL BE PERFORMED,
*      BUT DOES NOT GUARANTEE THIS TO BE THE CASE. THE FILE
*      SHOULD BE CLOSED AFTER THE CALL, A SUBSEQUENT READ
*      OR WRITE MAY REOPEN THE FILE AT THE START OR IT MAY BE
*      NECESSARY TO REOPEN THE FILE VIA SYSIO.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  ENDFILE ARGUMENT (SCBLK PTR)
*      JSR  SYSEN            CALL TO ENDFILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF ENDFILE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      ENDFILE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      THAT THE STANDARD INPUT AND OUTPUT FILES ARE IN THIS
*      CATEGORY.
{{EJC{{{{{4016
*
*      SYSEP -- EJECT PRINTER PAGE
*
{SYSEP{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4020
*
*      SYSEP IS CALLED TO PERFORM A PAGE EJECT ON THE STANDARD
*      PRINTER OUTPUT FILE (CORRESPONDING TO SYSPR OUTPUT).
*
*      JSR  SYSEP            CALL TO EJECT PRINTER OUTPUT
{{EJC{{{{{4026
*
*      SYSEX -- CALL EXTERNAL FUNCTION
*
{SYSEX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4030
*
*      SYSEX IS CALLED TO PASS CONTROL TO AN EXTERNAL FUNCTION
*      PREVIOUSLY LOADED WITH A CALL TO SYSLD.
*
*      (XS)                  POINTER TO ARGUMENTS ON STACK
*      (XL)                  POINTER TO CONTROL BLOCK (EFBLK)
*      (WA)                  NUMBER OF ARGUMENTS ON STACK
*      JSR  SYSEX            CALL TO PASS CONTROL TO FUNCTION
*      PPM  LOC              RETURN HERE IF FUNCTION CALL FAILS
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      PPM  LOC              RETURN HERE IF BAD ARGUMENT TYPE
*      (XR)                  RESULT RETURNED
*
*      THE ARGUMENTS ARE STORED ON THE STACK WITH
*      THE LAST ARGUMENT AT 0(XS). ON RETURN, XS
*      IS POPPED PAST THE ARGUMENTS.
*
*      THE FORM OF THE ARGUMENTS AS PASSED IS THAT USED IN THE
*      SPITBOL TRANSLATOR (SEE DEFINITIONS AND DATA STRUCTURES
*      SECTION). THE CONTROL BLOCK FORMAT IS ALSO DESCRIBED
*      (UNDER EFBLK) IN THIS SECTION.
*
*      THERE ARE TWO WAYS OF RETURNING A RESULT.
*
*      1)   RETURN A POINTER TO A BLOCK IN DYNAMIC STORAGE. THIS
*           BLOCK MUST BE IN EXACTLY CORRECT FORMAT, INCLUDING
*           THE FIRST WORD. ONLY FUNCTIONS WRITTEN WITH INTIMATE
*           KNOWLEDGE OF THE SYSTEM WILL RETURN IN THIS WAY.
*
*      2)   STRING, INTEGER AND REAL RESULTS MAY BE RETURNED BY
*           POINTING TO A PSEUDO-BLOCK OUTSIDE DYNAMIC MEMORY.
*           THIS BLOCK IS IN ICBLK, RCBLK OR SCBLK FORMAT EXCEPT
*           THAT THE FIRST WORD WILL BE OVERWRITTEN
*           BY A TYPE WORD ON RETURN AND SO NEED NOT
*           BE CORRECTLY SET. SUCH A RESULT IS
*           COPIED INTO MAIN STORAGE BEFORE PROCEEDING.
*           UNCONVERTED RESULTS MAY SIMILARLY BE RETURNED IN A
*           PSEUDO-BLOCK WHICH IS IN CORRECT FORMAT INCLUDING
*           TYPE WORD RECOGNISABLE BY GARBAGE COLLECTOR SINCE
*           BLOCK IS COPIED INTO DYNAMIC MEMORY.
{{EJC{{{{{4075
*
*      SYSFC -- FILE CONTROL BLOCK ROUTINE
*
{SYSFC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4079
*
*      SEE ALSO SYSIO
*      INPUT AND OUTPUT HAVE 3 ARGUMENTS REFERRED TO AS SHOWN
*           INPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*           OUTPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*      FILE ARG1 MAY BE AN INTEGER OR STRING USED TO IDENTIFY
*      AN I/O CHANNEL. IT IS CONVERTED TO A STRING FOR CHECKING.
*      THE EXACT SIGNIFICANCE OF FILE ARG2
*      IS NOT RIGOROUSLY PRESCRIBED BUT TO IMPROVE PORTABILITY,
*      THE SCHEME DESCRIBED IN THE SPITBOL USER MANUAL
*      SHOULD BE ADOPTED WHEN POSSIBLE. THE PREFERRED FORM IS
*      A STRING $F$,R$R$,C$C$,I$I$,...,Z$Z$  WHERE
*      $F$ IS AN OPTIONAL FILE NAME WHICH IS PLACED FIRST.
*       REMAINING ITEMS MAY BE OMITTED OR INCLUDED IN ANY ORDER.
*      $R$ IS MAXIMUM RECORD LENGTH
*      $C$ IS A CARRIAGE CONTROL CHARACTER OR CHARACTER STRING
*      $I$ IS SOME FORM OF CHANNEL IDENTIFICATION USED IN THE
*         ABSENCE OF $F$ TO ASSOCIATE THE VARIABLE
*         WITH A FILE ALLOCATED DYNAMICALLY BY JCL COMMANDS AT
*         SPITBOL LOAD TIME.
*      ,...,Z$Z$ ARE ADDITIONAL FIELDS.
*      IF , (COMMA) CANNOT BE USED AS A DELIMITER, .CIOD
*      SHOULD BE DEFINED TO INTRODUCE BY CONDITIONAL ASSEMBLY
*      ANOTHER DELIMITER (SEE
*        IODEL  EQU  *
*      EARLY IN DEFINITIONS SECTION).
*      SYSFC IS CALLED WHEN A VARIABLE IS INPUT OR OUTPUT
*      ASSOCIATED TO CHECK FILE ARG1 AND FILE ARG2 AND
*      TO  REPORT WHETHER AN FCBLK (FILE CONTROL
*      BLOCK) IS NECESSARY AND IF SO WHAT SIZE IT SHOULD BE.
*      THIS MAKES IT POSSIBLE FOR SPITBOL RATHER THAN OSINT TO
*      ALLOCATE SUCH A BLOCK IN DYNAMIC MEMORY IF REQUIRED
*      OR ALTERNATIVELY IN STATIC MEMORY.
*      THE SIGNIFICANCE OF AN FCBLK , IF ONE IS REQUESTED, IS
*      ENTIRELY UP TO THE SYSTEM INTERFACE. THE ONLY RESTRICTION
*      IS THAT IF THE FCBLK SHOULD APPEAR TO LIE IN DYNAMIC
*      MEMORY, POINTERS TO IT SHOULD BE PROPER POINTERS TO
*      THE START OF A RECOGNISABLE AND GARBAGE COLLECTABLE
*      BLOCK (THIS CONDITION WILL BE MET IF SYSFC REQUESTS
*      SPITBOL TO PROVIDE AN FCBLK).
*      AN OPTION IS PROVIDED FOR OSINT TO RETURN A POINTER IN
*      XL TO AN FCBLK WHICH IT PRIVATELY ALLOCATED. THIS PTR
*      WILL BE MADE AVAILABLE WHEN I/O OCCURS LATER.
*      PRIVATE FCBLKS MAY HAVE ARBITRARY CONTENTS AND SPITBOL
*      STORES NOTHING IN THEM.
{{EJC{{{{{4125
*      THE REQUESTED SIZE FOR AN FCBLK IN DYNAMIC MEMORY
*      SHOULD ALLOW A 2 WORD OVERHEAD FOR BLOCK TYPE AND
*      LENGTH FIELDS. INFORMATION SUBSEQUENTLY STORED IN THE
*      REMAINING WORDS MAY BE ARBITRARY IF AN XNBLK (EXTERNAL
*      NON-RELOCATABLE BLOCK) IS REQUESTED. IF THE REQUEST IS
*      FOR AN XRBLK (EXTERNAL RELOCATABLE BLOCK) THE
*      CONTENTS OF WORDS SHOULD BE COLLECTABLE (I.E. ANY
*      APPARENT POINTERS INTO DYNAMIC SHOULD BE GENUINE BLOCK
*      POINTERS). THESE RESTRICTIONS DO NOT APPLY IF AN FCBLK
*      IS ALLOCATED OUTSIDE DYNAMIC OR IS NOT ALLOCATED AT ALL.
*      IF AN FCBLK IS REQUESTED, ITS FIELDS WILL BE INITIALISED
*      TO ZERO BEFORE ENTRY TO SYSIO WITH THE EXCEPTION OF
*      WORDS 0 AND 1 IN WHICH THE BLOCK TYPE AND LENGTH
*      FIELDS ARE PLACED FOR FCBLKS IN DYNAMIC MEMORY ONLY.
*      FOR THE POSSIBLE USE OF SYSEJ AND SYSXI, IF FCBLKS
*      ARE USED, A CHAIN IS BUILT SO THAT THEY MAY ALL BE
*      FOUND - SEE SYSXI FOR DETAILS.
*      IF BOTH FILE ARG1 AND FILE ARG2 ARE NULL, CALLS OF SYSFC
*      AND SYSIO ARE OMITTED.
*      IF FILE ARG1 IS NULL (STANDARD INPUT/OUTPUT FILE), SYSFC
*      IS CALLED TO CHECK NON-NULL FILE ARG2 BUT ANY REQUEST
*      FOR AN FCBLK WILL BE IGNORED, SINCE SPITBOL HANDLES THE
*      STANDARD FILES SPECIALLY AND CANNOT READILY KEEP FCBLK
*      POINTERS FOR THEM.
*      FILEARG1 IS TYPE CHECKED BY SPITBOL SO FURTHER CHECKING
*      MAY BE UNNECCESSARY IN MANY IMPLEMENTATIONS.
*      FILE ARG2 IS PASSED SO THAT SYSFC MAY ANALYSE AND
*      CHECK IT. HOWEVER TO ASSIST IN THIS, SPITBOL ALSO PASSES
*      ON THE STACK THE COMPONENTS OF THIS ARGUMENT WITH
*      FILE NAME, $F$ (OTHERWISE NULL) EXTRACTED AND STACKED
*      FIRST.
*      THE OTHER FIELDS, IF ANY, ARE EXTRACTED AS SUBSTRINGS,
*      POINTERS TO THEM ARE STACKED AND A COUNT OF ALL ITEMS
*      STACKED IS PLACED IN WC. IF AN FCBLK WAS EARLIER
*      ALLOCATED AND POINTED TO VIA FILE ARG1, SYSFC IS ALSO
*      PASSED A POINTER TO THIS FCBLK.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILEARG2 (3RD ARG) OR NULL
*      -(XS)...-(XS)         SCBLKS FOR $F$,$R$,$C$,...
*      (WC)                  NO. OF STACKED SCBLKS ABOVE
*      (WA)                  EXISTING FILE ARG1 FCBLK PTR OR 0
*      (WB)                  0/3 FOR INPUT/OUTPUT ASSOCN
*      JSR  SYSFC            CALL TO CHECK NEED FOR FCBLK
*      PPM  LOC              INVALID FILE ARGUMENT
*      PPM  LOC              FCBLK ALREADY IN USE
*      (XS)                  POPPED (WC) TIMES
*      (WA NON ZERO)         BYTE SIZE OF REQUESTED FCBLK
*      (WA=0,XL NON ZERO)    PRIVATE FCBLK PTR IN XL
*      (WA=XL=0)             NO FCBLK WANTED, NO PRIVATE FCBLK
*      (WC)                  0/1/2 REQUEST ALLOC OF XRBLK/XNBLK
*                            /STATIC BLOCK FOR USE AS FCBLK
*      (WB)                  DESTROYED
{{EJC{{{{{4180
*
*      SYSGC -- INFORM INTERFACE OF GARBAGE COLLECTIONS
*
{SYSGC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4184
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS
*      PRIOR TO AND AFTER A GARBAGE COLLECTION.
*
*      POSSIBLE USAGES-
*      1. PROVIDE VISIBLE SCREEN ICON OF GARBAGE COLLECTION
*         IN PROGRESS
*      2. INFORM VIRTUAL MEMORY MANAGER TO IGNORE PAGE ACCESS
*         PATTERNS DURING GARBAGE COLLECTION.  SUCH ACCESSES
*         TYPICALLY DESTROY THE PAGE WORKING SET ACCUMULATED
*         BY THE PROGRAM.
*      3. INFORM VIRTUAL MEMORY MANAGER THAT CONTENTS OF MEMORY
*         FREED BY GARBAGE COLLECTION CAN BE DISCARDED.
*
*      (XR)                  NON-ZERO IF BEGINNING GC
*                            =0 IF COMPLETING GC
*      (WA)                  DNAMB=START OF DYNAMIC AREA
*      (WB)                  DNAMP=NEXT AVAILABLE LOCATION
*      (WC)                  DNAME=LAST AVAILABLE LOCATION + 1
*      JSR  SYSGC            CALL TO SYSGC FUNCTION
*      ALL REGISTERS PRESERVED
{{EJC{{{{{4208
*
*      SYSHS -- GIVE ACCESS TO HOST COMPUTER FEATURES
*
{SYSHS{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4212
*
*      PROVIDES MEANS FOR IMPLEMENTING SPECIAL FEATURES
*      ON DIFFERENT HOST COMPUTERS. THE ONLY DEFINED ENTRY IS
*      THAT WHERE ALL ARGUMENTS ARE NULL IN WHICH CASE SYSHS
*      RETURNS AN SCBLK CONTAINING NAME OF COMPUTER,
*      NAME OF OPERATING SYSTEM AND NAME OF SITE SEPARATED BY
*      COLONS. THE SCBLK NEED NOT HAVE A CORRECT FIRST FIELD
*      AS THIS IS SUPPLIED ON COPYING STRING TO DYNAMIC MEMORY.
*      SPITBOL DOES NO ARGUMENT CHECKING BUT DOES PROVIDE A
*      SINGLE ERROR RETURN FOR ARGUMENTS CHECKED AS ERRONEOUS
*      BY OSINT. IT ALSO PROVIDES A SINGLE EXECUTION ERROR
*      RETURN. IF THESE ARE INADEQUATE, USE MAY BE MADE OF THE
*      MINIMAL ERROR SECTION DIRECT AS DESCRIBED IN MINIMAL
*      DOCUMENTATION, SECTION 10.
*      SEVERAL NON-ERROR RETURNS ARE PROVIDED. THE FIRST
*      CORRESPONDS TO THE DEFINED ENTRY OR, FOR IMPLEMENTATION
*      DEFINED ENTRIES, ANY STRING MAY BE RETURNED. THE OTHERS
*      PERMIT RESPECTIVELY,  RETURN A NULL RESULT, RETURN WITH A
*      RESULT TO BE STACKED WHICH IS POINTED AT BY XR, AND A
*      RETURN CAUSING SPITBOL STATEMENT FAILURE. IF A RETURNED
*      RESULT IS IN DYNAMIC MEMORY IT MUST OBEY GARBAGE
*      COLLECTOR RULES. THE ONLY RESULTS COPIED ON RETURN
*      ARE STRINGS RETURNED VIA PPM LOC3 RETURN.
*
*      (WA)                  ARGUMENT 1
*      (XL)                  ARGUMENT 2
*      (XR)                  ARGUMENT 3
*      (WB)                  ARGUMENT 4
*      (WC)                  ARGUMENT 5
*      JSR  SYSHS            CALL TO GET HOST INFORMATION
*      PPM  LOC1             ERRONEOUS ARG
*      PPM  LOC2             EXECUTION ERROR
*      PPM  LOC3             SCBLK PTR IN XL OR 0 IF UNAVAILABLE
*      PPM  LOC4             RETURN A NULL RESULT
*      PPM  LOC5             RETURN RESULT IN XR
*      PPM  LOC6             CAUSE STATEMENT FAILURE
*      PPM  LOC7             RETURN STRING AT XL, LENGTH WA
*      PPM  LOC8             RETURN COPY OF RESULT IN XR
{{EJC{{{{{4251
*
*      SYSID -- RETURN SYSTEM IDENTIFICATION
*
{SYSID{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4255
*
*      THIS ROUTINE SHOULD RETURN STRINGS TO HEAD THE STANDARD
*      PRINTER OUTPUT. THE FIRST STRING WILL BE APPENDED TO
*      A HEADING LINE OF THE FORM
*           MACRO SPITBOL VERSION V.V
*      SUPPLIED BY SPITBOL ITSELF. V.V ARE DIGITS GIVING THE
*      MAJOR VERSION NUMBER AND GENERALLY AT LEAST A MINOR
*      VERSION NUMBER RELATING TO OSINT SHOULD BE SUPPLIED TO
*      GIVE SAY
*           MACRO SPITBOL VERSION V.V(M.M)
*      THE SECOND STRING SHOULD IDENTIFY AT LEAST THE MACHINE
*      AND OPERATING SYSTEM.  PREFERABLY IT SHOULD INCLUDE
*      THE DATE AND TIME OF THE RUN.
*      OPTIONALLY THE STRINGS MAY INCLUDE SITE NAME OF THE
*      THE IMPLEMENTOR AND/OR MACHINE ON WHICH RUN TAKES PLACE,
*      UNIQUE SITE OR COPY NUMBER AND OTHER INFORMATION AS
*      APPROPRIATE WITHOUT MAKING IT SO LONG AS TO BE A
*      NUISANCE TO USERS.
*      THE FIRST WORDS OF THE SCBLKS POINTED AT NEED NOT BE
*      CORRECTLY SET.
*
*      JSR  SYSID            CALL FOR SYSTEM IDENTIFICATION
*      (XR)                  SCBLK PTR FOR ADDITION TO HEADER
*      (XL)                  SCBLK PTR FOR SECOND HEADER
{{EJC{{{{{4280
*
*      SYSIF -- SWITCH TO NEW INCLUDE FILE
*
{SYSIF{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4285
*
*      SYSIF IS USED FOR INCLUDE FILE PROCESSING, BOTH TO INFORM
*      THE INTERFACE WHEN A NEW INCLUDE FILE IS DESIRED, AND
*      WHEN THE END OF FILE OF AN INCLUDE FILE HAS BEEN REACHED
*      AND IT IS DESIRED TO RETURN TO READING FROM THE PREVIOUS
*      NESTED FILE.
*
*      IT IS THE RESPONSIBILITY OF SYSIF TO REMEMBER THE FILE
*      ACCESS PATH TO THE PRESENT INPUT FILE BEFORE SWITCHING TO
*      THE NEW INCLUDE FILE.
*
*      (XL)                  PTR TO SCBLK OR ZERO
*      (XR)                  PTR TO VACANT SCBLK OF LENGTH CSWIN
*                            (XR NOT USED IF XL IS ZERO)
*      JSR  SYSIF            CALL TO CHANGE FILES
*      PPM  LOC              UNABLE TO OPEN FILE
*      (XR)                  SCBLK WITH FULL PATH NAME OF FILE
*                            (XR NOT USED IF INPUT XL IS ZERO)
*
*      REGISTER XL POINTS TO AN SCBLK CONTAINING THE NAME OF THE
*      INCLUDE FILE TO WHICH THE INTERFACE SHOULD SWITCH.  DATA
*      IS FETCHED FROM THE FILE UPON THE NEXT CALL TO SYSRD.
*
*      SYSIF MAY HAVE THE ABILITY TO SEARCH MULTIPLE LIBRARIES
*      FOR THE INCLUDE FILE NAMED IN (XL).  IT IS THEREFORE
*      REQUIRED THAT THE FULL PATH NAME OF THE FILE WHERE THE
*      FILE WAS FINALLY LOCATED BE RETURNED IN (XR).  IT IS THIS
*      NAME THAT IS RECORDED ALONG WITH THE SOURCE STATEMENTS,
*      AND WILL ACCOMPANY SUBSEQUENT ERROR MESSAGES.
*
*      REGISTER XL IS ZERO TO MARK CONCLUSION OF USE OF AN
*      INCLUDE FILE.
{{EJC{{{{{4318
*
*      SYSIL -- GET INPUT RECORD LENGTH
*
{SYSIL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4323
*
*      SYSIL IS USED TO GET THE LENGTH OF THE NEXT INPUT RECORD
*      FROM A FILE PREVIOUSLY INPUT ASSOCIATED WITH A SYSIO
*      CALL. THE LENGTH RETURNED IS USED TO ESTABLISH A BUFFER
*      FOR A SUBSEQUENT SYSIN CALL.  SYSIL ALSO INDICATES TO THE
*      CALLER IF THIS IS A BINARY OR TEXT FILE.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      JSR  SYSIL            CALL TO GET RECORD LENGTH
*      (WA)                  LENGTH OR ZERO IF FILE CLOSED
*      (WC)                  ZERO IF BINARY, NON-ZERO IF TEXT
*
*      NO HARM IS DONE IF THE VALUE RETURNED IS TOO LONG SINCE
*      UNUSED SPACE WILL BE RECLAIMED AFTER THE SYSIN CALL.
*
*      NOTE THAT IT IS THE SYSIL CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD INPUT FROM THE FILE.
{{EJC{{{{{4342
*
*      SYSIN -- READ INPUT RECORD
*
{SYSIN{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4346
*
*      SYSIN IS USED TO READ A RECORD FROM THE FILE WHICH WAS
*      REFERENCED IN A PRIOR CALL TO SYSIL (I.E. THESE CALLS
*      ALWAYS OCCUR IN PAIRS). THE BUFFER PROVIDED IS AN
*      SCBLK FOR A STRING OF LENGTH SET FROM THE SYSIL CALL.
*      IF THE ACTUAL LENGTH READ IS LESS THAN THIS, THE LENGTH
*      FIELD OF THE SCBLK MUST BE MODIFIED BEFORE RETURNING
*      UNLESS BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE ANY OF THE ALTERNATIVE
*      RETURNS AFTER SCBLK LENGTH HAS BEEN MODIFIED.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      JSR  SYSIN            CALL TO READ RECORD
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF RECORD FORMAT ERROR
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{4365
*
*      SYSIO -- INPUT/OUTPUT FILE ASSOCIATION
*
{SYSIO{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4369
*
*      SEE ALSO SYSFC.
*      SYSIO IS CALLED IN RESPONSE TO A SNOBOL4 INPUT OR OUTPUT
*      FUNCTION CALL EXCEPT WHEN FILE ARG1 AND FILE ARG2
*      ARE BOTH NULL.
*      ITS CALL ALWAYS FOLLOWS IMMEDIATELY AFTER A CALL
*      OF SYSFC. IF SYSFC REQUESTED ALLOCATION
*      OF AN FCBLK, ITS ADDRESS WILL BE IN WA.
*      FOR INPUT FILES, NON-ZERO VALUES OF $R$ SHOULD BE
*      COPIED TO WC FOR USE IN ALLOCATING INPUT BUFFERS. IF $R$
*      IS DEFAULTED OR NOT IMPLEMENTED, WC SHOULD BE ZEROISED.
*      ONCE A FILE HAS BEEN OPENED, SUBSEQUENT INPUT(),OUTPUT()
*      CALLS IN WHICH THE SECOND ARGUMENT IS IDENTICAL WITH THAT
*      IN A PREVIOUS CALL, MERELY ASSOCIATE THE ADDITIONAL
*      VARIABLE NAME (FIRST ARGUMENT) TO THE FILE AND DO NOT
*      RESULT IN RE-OPENING THE FILE.
*      IN SUBSEQUENT ASSOCIATED ACCESSES TO THE FILE A POINTER
*      TO ANY FCBLK ALLOCATED WILL BE MADE AVAILABLE.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILE ARG2 SCBLK PTR (3RD ARG)
*      (WA)                  FCBLK PTR (0 IF NONE)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT
*      JSR  SYSIO            CALL TO ASSOCIATE FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN IF INPUT/OUTPUT NOT ALLOWED
*      (XL)                  FCBLK POINTER (0 IF NONE)
*      (WC)                  0 (FOR DEFAULT) OR MAX RECORD LNGTH
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED IF THE FILE NAMED EXISTS
*      BUT INPUT/OUTPUT FROM THE FILE IS NOT ALLOWED. FOR
*      EXAMPLE, THE STANDARD OUTPUT FILE MAY BE IN THIS CATEGORY
*      AS REGARDS INPUT ASSOCIATION.
{{EJC{{{{{4404
*
*      SYSLD -- LOAD EXTERNAL FUNCTION
*
{SYSLD{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4408
*
*      SYSLD IS CALLED IN RESPONSE TO THE USE OF THE SNOBOL4
*      LOAD FUNCTION. THE NAMED FUNCTION IS LOADED (WHATEVER
*      THIS MEANS), AND A POINTER IS RETURNED. THE POINTER WILL
*      BE USED ON SUBSEQUENT CALLS TO THE FUNCTION (SEE SYSEX).
*
*      (XR)                  POINTER TO FUNCTION NAME (SCBLK)
*      (XL)                  POINTER TO LIBRARY NAME (SCBLK)
*      JSR  SYSLD            CALL TO LOAD FUNCTION
*      PPM  LOC              RETURN HERE IF FUNC DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      (XR)                  POINTER TO LOADED CODE
*
*      THE SIGNIFICANCE OF THE POINTER RETURNED IS UP TO THE
*      SYSTEM INTERFACE ROUTINE. THE ONLY RESTRICTION IS THAT
*      IF THE POINTER IS WITHIN DYNAMIC STORAGE, IT MUST BE
*      A PROPER BLOCK POINTER.
{{EJC{{{{{4427
*
*      SYSMM -- GET MORE MEMORY
*
{SYSMM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4431
*
*      SYSMM IS CALLED IN AN ATTEMPT TO ALLOCATE MORE DYNAMIC
*      MEMORY. THIS MEMORY MUST BE ALLOCATED CONTIGUOUSLY WITH
*      THE CURRENT DYNAMIC DATA AREA.
*
*      THE AMOUNT ALLOCATED IS UP TO THE SYSTEM TO DECIDE. ANY
*      VALUE IS ACCEPTABLE INCLUDING ZERO IF ALLOCATION IS
*      IMPOSSIBLE.
*
*      JSR  SYSMM            CALL TO GET MORE MEMORY
*      (XR)                  NUMBER OF ADDITIONAL WORDS OBTAINED
{{EJC{{{{{4443
*
*      SYSMX -- SUPPLY MXLEN
*
{SYSMX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4447
*
*      BECAUSE OF THE METHOD OF GARBAGE COLLECTION, NO SPITBOL
*      OBJECT IS ALLOWED TO OCCUPY MORE BYTES OF MEMORY THAN
*      THE INTEGER GIVING THE LOWEST ADDRESS OF DYNAMIC
*      (GARBAGE COLLECTABLE) MEMORY. MXLEN IS THE NAME USED TO
*      REFER TO THIS MAXIMUM LENGTH OF AN OBJECT AND FOR MOST
*      USERS OF MOST IMPLEMENTATIONS, PROVIDED DYNAMIC MEMORY
*      STARTS AT AN ADDRESS OF AT LEAST A FEW THOUSAND WORDS,
*      THERE IS NO PROBLEM.
*      IF THE DEFAULT STARTING ADDRESS IS LESS THAN SAY 10000 OR
*      20000, THEN A LOAD TIME OPTION SHOULD BE PROVIDED WHERE A
*      USER CAN REQUEST THAT HE BE ABLE TO CREATE LARGER
*      OBJECTS. THIS ROUTINE INFORMS SPITBOL OF THIS REQUEST IF
*      ANY. THE VALUE RETURNED IS EITHER AN INTEGER
*      REPRESENTING THE DESIRED VALUE OF MXLEN (AND HENCE THE
*      MINIMUM DYNAMIC STORE ADDRESS WHICH MAY RESULT IN
*      NON-USE OF SOME STORE) OR ZERO IF A DEFAULT IS ACCEPTABLE
*      IN WHICH MXLEN IS SET TO THE LOWEST ADDRESS ALLOCATED
*      TO DYNAMIC STORE BEFORE COMPILATION STARTS.
*      IF A NON-ZERO VALUE IS RETURNED, THIS IS USED FOR KEYWORD
*      MAXLNGTH. OTHERWISE THE INITIAL LOW ADDRESS OF DYNAMIC
*      MEMORY IS USED FOR THIS KEYWORD.
*
*      JSR  SYSMX            CALL TO GET MXLEN
*      (WA)                  EITHER MXLEN OR 0 FOR DEFAULT
{{EJC{{{{{4473
*
*      SYSOU -- OUTPUT RECORD
*
{SYSOU{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4477
*
*      SYSOU IS USED TO WRITE A RECORD TO A FILE PREVIOUSLY
*      ASSOCIATED WITH A SYSIO CALL.
*
*      (WA)                  PTR TO FCBLK
*                            OR 0 FOR TERMINAL OR 1 FOR OUTPUT
*      (XR)                  RECORD TO BE WRITTEN (SCBLK)
*      JSR  SYSOU            CALL TO OUTPUT RECORD
*      PPM  LOC              FILE FULL OR NO FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT IT IS THE SYSOU CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD OUTPUT TO THE FILE.
{{EJC{{{{{4499
*
*      SYSPI -- PRINT ON INTERACTIVE CHANNEL
*
{SYSPI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4503
*
*      IF SPITBOL IS RUN FROM AN ONLINE TERMINAL, OSINT CAN
*      REQUEST THAT MESSAGES SUCH AS COPIES OF COMPILATION
*      ERRORS BE SENT TO THE TERMINAL (SEE SYSPP). IF RELEVANT
*      REPLY WAS MADE BY SYSPP THEN SYSPI IS CALLED TO SEND SUCH
*      MESSAGES TO THE INTERACTIVE CHANNEL.
*      SYSPI IS ALSO USED FOR SENDING OUTPUT TO THE TERMINAL
*      THROUGH THE SPECIAL VARIABLE NAME, TERMINAL.
*
*      (XR)                  PTR TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPI            CALL TO PRINT LINE
*      PPM  LOC              FAILURE RETURN
*      (WA,WB)               DESTROYED
{{EJC{{{{{4519
*
*      SYSPL -- PROVIDE INTERACTIVE CONTROL OF SPITBOL
*
{SYSPL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4523
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS,
*      SUCH AS INTERRUPTING EXECUTION, BREAKPOINTING, STEPPING,
*      AND EXPRESSION EVALUATION.  THESE LAST THREE OPTIONS ARE
*      NOT PRESENTLY IMPLEMENTED BY THE CODE CALLING SYSPL.
*
*
*      (WA)                  OPCODE AS FOLLOWS-
*                            =0 POLL TO ALLOW OSINT TO INTERRUPT
*                            =1 BREAKPOINT HIT
*                            =2 COMPLETION OF STATEMENT STEPPING
*                            =3 EXPRESSION EVALUATION RESULT
*      (WB)                  STATEMENT NUMBER
*      R$FCB                 O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSPL            CALL TO SYSPL FUNCTION
*      PPM  LOC              USER INTERRUPTION
*      PPM  LOC              STEP ONE STATEMENT
*      PPM  LOC              EVALUATE EXPRESSION
*      ---                   RESUME EXECUTION
*                            (WA) = NEW POLLING INTERVAL
*
{{EJC{{{{{4546
*
*      SYSPP -- OBTAIN PRINT PARAMETERS
*
{SYSPP{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4550
*
*      SYSPP IS CALLED ONCE DURING COMPILATION TO OBTAIN
*      PARAMETERS REQUIRED FOR CORRECT PRINTED OUTPUT FORMAT
*      AND TO SELECT OTHER OPTIONS. IT MAY ALSO BE CALLED AGAIN
*      AFTER SYSXI WHEN A LOAD MODULE IS RESUMED. IN THIS
*      CASE THE VALUE RETURNED IN WA MAY BE LESS THAN OR EQUAL
*      TO THAT RETURNED IN INITIAL CALL BUT MAY NOT BE
*      GREATER.
*      THE INFORMATION RETURNED IS -
*      1.   LINE LENGTH IN CHARS FOR STANDARD PRINT FILE
*      2.   NO OF LINES/PAGE. 0 IS PREFERABLE FOR A NON-PAGED
*           DEVICE (E.G. ONLINE TERMINAL) IN WHICH CASE LISTING
*           PAGE THROWS ARE SUPPRESSED AND PAGE HEADERS
*           RESULTING FROM -TITLE,-STITL LINES ARE KEPT SHORT.
*      3.   AN INITIAL -NOLIST OPTION TO SUPPRESS LISTING UNLESS
*           THE PROGRAM CONTAINS AN EXPLICIT -LIST.
*      4.   OPTIONS TO SUPPRESS LISTING OF COMPILATION AND/OR
*           EXECUTION STATS (USEFUL FOR ESTABLISHED PROGRAMS) -
*           COMBINED WITH 3. GIVES POSSIBILITY OF LISTING
*           FILE NEVER BEING OPENED.
*      5.   OPTION TO HAVE COPIES OF ERRORS SENT TO AN
*           INTERACTIVE CHANNEL IN ADDITION TO STANDARD PRINTER.
*      6.   OPTION TO KEEP PAGE HEADERS SHORT (E.G. IF LISTING
*           TO AN ONLINE TERMINAL).
*      7.   AN OPTION TO CHOOSE EXTENDED OR COMPACT LISTING
*           FORMAT. IN THE FORMER A PAGE EJECT AND IN THE LATTER
*           A FEW LINE FEEDS PRECEDE THE PRINTING OF EACH
*           OF-- LISTING, COMPILATION STATISTICS, EXECUTION
*           OUTPUT AND EXECUTION STATISTICS.
*      8.   AN OPTION TO SUPPRESS EXECUTION AS THOUGH A
*           -NOEXECUTE CARD WERE SUPPLIED.
*      9.   AN OPTION TO REQUEST THAT NAME /TERMINAL/  BE PRE-
*           ASSOCIATED TO AN ONLINE TERMINAL VIA SYSPI AND SYSRI
*      10.  AN INTERMEDIATE (STANDARD) LISTING OPTION REQUIRING
*           THAT PAGE EJECTS OCCUR IN SOURCE LISTINGS. REDUNDANT
*           IF EXTENDED OPTION CHOSEN BUT PARTIALLY EXTENDS
*           COMPACT OPTION.
*      11.  OPTION TO SUPPRESS SYSID IDENTIFICATION.
*
*      JSR  SYSPP            CALL TO GET PRINT PARAMETERS
*      (WA)                  PRINT LINE LENGTH IN CHARS
*      (WB)                  NUMBER OF LINES/PAGE
*      (WC)                  BITS VALUE ...MLKJIHGFEDCBA WHERE
*                            A = 1 TO SEND ERROR COPY TO INT.CH.
*                            B = 1 MEANS STD PRINTER IS INT. CH.
*                            C = 1 FOR -NOLIST OPTION
*                            D = 1 TO SUPPRESS COMPILN. STATS
*
*                            E = 1 TO SUPPRESS EXECN. STATS
*                            F = 1/0 FOR EXTNDED/COMPACT LISTING
*                            G = 1 FOR -NOEXECUTE
*                            H = 1 PRE-ASSOCIATE /TERMINAL/
*
*                            I = 1 FOR STANDARD LISTING OPTION.
*                            J = 1 SUPPRESSES LISTING HEADER
*                            K = 1 FOR -PRINT
*                            L = 1 FOR -NOERRORS
*
*                            M = 1 FOR -CASE 1
{{EJC{{{{{4612
*
*      SYSPR -- PRINT LINE ON STANDARD OUTPUT FILE
*
{SYSPR{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4616
*
*      SYSPR IS USED TO PRINT A SINGLE LINE ON THE STANDARD
*      OUTPUT FILE.
*
*      (XR)                  POINTER TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPR            CALL TO PRINT LINE
*      PPM  LOC              TOO MUCH O/P OR NO FILE AFTER SYSXI
*      (WA,WB)               DESTROYED
*
*      THE BUFFER POINTED TO IS THE LENGTH OBTAINED FROM THE
*      SYSPP CALL AND IS FILLED OUT WITH TRAILING BLANKS. THE
*      VALUE IN WA IS THE ACTUAL LINE LENGTH WHICH MAY BE LESS
*      THAN THE MAXIMUM LINE LENGTH POSSIBLE. THERE IS NO SPACE
*      CONTROL ASSOCIATED WITH THE LINE, ALL LINES ARE PRINTED
*      SINGLE SPACED. NOTE THAT NULL LINES (WA=0) ARE POSSIBLE
*      IN WHICH CASE A BLANK LINE IS TO BE PRINTED.
*
*      THE ERROR EXIT IS USED FOR SYSTEMS WHICH LIMIT THE AMOUNT
*      OF PRINTED OUTPUT. IF POSSIBLE, PRINTING SHOULD BE
*      PERMITTED AFTER THIS CONDITION HAS BEEN SIGNALLED ONCE TO
*      ALLOW FOR DUMP AND OTHER DIAGNOSTIC INFORMATION.
*      ASSUMING THIS TO BE POSSIBLE, SPITBOL MAY MAKE MORE SYSPR
*      CALLS. IF THE ERROR RETURN OCCURS ANOTHER TIME, EXECUTION
*      IS TERMINATED BY A CALL OF SYSEJ WITH ENDING CODE 998.
{{EJC{{{{{4642
*
*      SYSRD -- READ RECORD FROM STANDARD INPUT FILE
*
{SYSRD{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4646
*
*      SYSRD IS USED TO READ A RECORD FROM THE STANDARD INPUT
*      FILE. THE BUFFER PROVIDED IS AN SCBLK FOR A STRING THE
*      LENGTH OF WHICH IN CHARACTERS IS GIVEN IN WC, THIS
*      CORRESPONDING TO THE MAXIMUM LENGTH OF STRING WHICH
*      SPITBOL IS PREPARED TO RECEIVE. AT COMPILE TIME IT
*      CORRESPONDS TO XXX IN THE MOST RECENT -INXXX CARD
*      (DEFAULT 72) AND AT EXECUTION TIME TO THE MOST RECENT
*      ,R$R$ (RECORD LENGTH) IN THE THIRD ARG OF AN INPUT()
*      STATEMENT FOR THE STANDARD INPUT FILE (DEFAULT 80).
*      IF FEWER THAN (WC) CHARACTERS ARE READ, THE LENGTH
*      FIELD OF THE SCBLK MUST BE ADJUSTED BEFORE RETURNING
*      UNLESS THE BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE RETURN
*      AFTER SUCH AN ADJUSTMENT HAS BEEN MADE.
*      SPITBOL MAY CONTINUE TO MAKE CALLS AFTER AN ENDFILE
*      RETURN SO THIS ROUTINE SHOULD BE PREPARED TO MAKE
*      REPEATED ENDFILE RETURNS.
*
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      (WC)                  LENGTH OF BUFFER IN CHARACTERS
*      JSR  SYSRD            CALL TO READ LINE
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*                            OR INPUT FILE NAME CHANGE.  IF
*                            THE FORMER, SCBLK LENGTH IS ZERO.
*                            IF INPUT FILE NAME CHANGE, LENGTH
*                            IS NON-ZERO. CALLER SHOULD RE-ISSUE
*                            SYSRD TO OBTAIN INPUT RECORD.
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{4678
*
*      SYSRI -- READ RECORD FROM INTERACTIVE CHANNEL
*
{SYSRI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4682
*
*      READS A RECORD FROM ONLINE TERMINAL FOR SPITBOL VARIABLE,
*      TERMINAL. IF ONLINE TERMINAL IS UNAVAILABLE THEN CODE THE
*      ENDFILE RETURN ONLY.
*      THE BUFFER PROVIDED IS OF LENGTH 258 CHARACTERS. SYSRI
*      SHOULD REPLACE THE COUNT IN THE SECOND WORD OF THE SCBLK
*      BY THE ACTUAL CHARACTER COUNT UNLESS BUFFER IS RIGHT
*      PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE
*      RETURN AFTER ADJUSTING THE COUNT.
*      THE END OF FILE RETURN MAY BE USED IF THIS MAKES
*      SENSE ON THE TARGET MACHINE (E.G. IF THERE IS AN
*      EOF CHARACTER.)
*
*      (XR)                  PTR TO 258 CHAR BUFFER (SCBLK PTR)
*      JSR  SYSRI            CALL TO READ LINE FROM TERMINAL
*      PPM  LOC              END OF FILE RETURN
*      (WA,WB,WC)            MAY BE DESTROYED
{{EJC{{{{{4701
*
*      SYSRW -- REWIND FILE
*
{SYSRW{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4705
*
*      SYSRW IS USED TO REWIND A FILE I.E. REPOSITION THE FILE
*      AT THE START BEFORE THE FIRST RECORD. THE FILE SHOULD BE
*      CLOSED AND THE NEXT READ OR WRITE CALL WILL OPEN THE
*      FILE AT THE START.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  REWIND ARG (SCBLK PTR)
*      JSR  SYSRW            CALL TO REWIND FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF REWIND NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{4718
*
*      SYSST -- SET FILE POINTER
*
{SYSST{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4723
*
*      SYSST IS CALLED TO CHANGE THE POSITION OF A FILE
*      POINTER. THIS IS ACCOMPLISHED IN A SYSTEM DEPENDENT
*      MANNER, AND THUS THE 2ND AND 3RD ARGUMENTS ARE PASSED
*      UNCONVERTED.
*
*      (WA)                  FCBLK POINTER
*      (WB)                  2ND ARGUMENT
*      (WC)                  3RD ARGUMENT
*      JSR  SYSST            CALL TO SET FILE POINTER
*      PPM  LOC              RETURN HERE IF INVALID 2ND ARG
*      PPM  LOC              RETURN HERE IF INVALID 3RD ARG
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF SET NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*
{{EJC{{{{{4740
*
*      SYSTM -- GET EXECUTION TIME SO FAR
*
{SYSTM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4745
*
*      SYSTM IS USED TO OBTAIN THE AMOUNT OF EXECUTION TIME
*      USED SO FAR SINCE SPITBOL WAS GIVEN CONTROL. THE UNITS
*      ARE DESCRIBED AS MILLISECONDS IN THE SPITBOL OUTPUT, BUT
*      THE EXACT MEANING IS SYSTEM DEPENDENT. WHERE APPROPRIATE,
*      THIS VALUE SHOULD RELATE TO PROCESSOR RATHER THAN CLOCK
*      TIMING VALUES.
*      IF THE SYMBOL .CTMD IS DEFINED, THE UNITS ARE DESCRIBED
*      AS DECISECONDS (0.1 SECOND).
*
*      JSR  SYSTM            CALL TO GET TIMER VALUE
*      (IA)                  TIME SO FAR IN MILLISECONDS
*                            (DECISECONDS IF .CTMD DEFINED)
{{EJC{{{{{4759
*
*      SYSTT -- TRACE TOGGLE
*
{SYSTT{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4763
*
*      CALLED BY SPITBOL FUNCTION TRACE() WITH NO ARGS TO
*      TOGGLE THE SYSTEM TRACE SWITCH.  THIS PERMITS TRACING OF
*      LABELS IN SPITBOL CODE TO BE TURNED ON OR OFF.
*
*      JSR  SYSTT            CALL TO TOGGLE TRACE SWITCH
{{EJC{{{{{4770
*
*      SYSUL -- UNLOAD EXTERNAL FUNCTION
*
{SYSUL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4774
*
*      SYSUL IS USED TO UNLOAD A FUNCTION PREVIOUSLY
*      LOADED WITH A CALL TO SYSLD.
*
*      (XR)                  PTR TO CONTROL BLOCK (EFBLK)
*      JSR  SYSUL            CALL TO UNLOAD FUNCTION
*
*      THE FUNCTION CANNOT BE CALLED FOLLOWING A SYSUL CALL
*      UNTIL ANOTHER SYSLD CALL IS MADE FOR THE SAME FUNCTION.
*
*      THE EFBLK CONTAINS THE FUNCTION CODE POINTER AND ALSO A
*      POINTER TO THE VRBLK CONTAINING THE FUNCTION NAME (SEE
*      DEFINITIONS AND DATA STRUCTURES SECTION).
{{EJC{{{{{4790
*
*      SYSXI -- EXIT TO PRODUCE LOAD MODULE
*
{SYSXI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4794
*
*      WHEN SYSXI IS CALLED, XL CONTAINS EITHER A STRING POINTER
*      OR ZERO. IN THE FORMER CASE, THE STRING GIVES THE
*      CHARACTER NAME OF A PROGRAM. THE INTENTION IS THAT
*      SPITBOL EXECUTION SHOULD BE TERMINATED FORTHWITH AND
*      THE NAMED PROGRAM LOADED AND EXECUTED. THIS TYPE OF CHAIN
*      EXECUTION IS VERY SYSTEM DEPENDENT AND IMPLEMENTORS MAY
*      CHOOSE TO OMIT IT OR FIND IT IMPOSSIBLE TO PROVIDE.
*      IF (XL) IS ZERO,IA CONTAINS ONE OF THE FOLLOWING INTEGERS
*
*      -1, -2, -3, -4
*           CREATE IF POSSIBLE A LOAD MODULE CONTAINING ONLY THE
*           IMPURE AREA OF MEMORY WHICH NEEDS TO BE LOADED WITH
*           A COMPATIBLE PURE SEGMENT FOR SUBSEQUENT EXECUTIONS.
*           VERSION NUMBERS TO CHECK COMPATIBILITY SHOULD BE
*           KEPT IN BOTH SEGMENTS AND CHECKED ON LOADING.
*           TO ASSIST WITH THIS CHECK, (XR) ON ENTRY IS A
*           POINTER TO AN SCBLK CONTAINING THE SPITBOL MAJOR
*           VERSION NUMBER V.V (SEE SYSID).  THE FILE THUS
*           CREATED IS CALLED A SAVE FILE.
*
*      0    IF POSSIBLE, RETURN CONTROL TO JOB CONTROL
*           COMMAND LEVEL. THE EFFECT IF AVAILABLE WILL BE
*           SYSTEM DEPENDENT.
*
*      +1, +2, +3, +4
*           CREATE IF POSSIBLE A LOAD MODULE FROM ALL OF
*           MEMORY. IT SHOULD BE POSSIBLE TO LOAD AND EXECUTE
*           THIS MODULE DIRECTLY.
*
*      IN THE CASE OF SAVED LOAD MODULES, THE STATUS OF OPEN
*      FILES IS NOT PRESERVED AND IMPLEMENTORS MAY CHOOSE TO
*      OFFER MEANS OF ATTACHING FILES BEFORE EXECUTION OF LOAD
*      MODULES STARTS OR LEAVE IT TO THE USER TO INCLUDE
*      SUITABLE INPUT(), OUTPUT() CALLS IN HIS PROGRAM.
*      SYSXI SHOULD MAKE A NOTE THAT NO I/O CHANNELS,
*      INCLUDING STANDARD FILES, HAVE FILES ATTACHED SO THAT
*      CALLS OF SYSIN, SYSOU, SYSPR, SYSRD SHOULD FAIL UNLESS
*      NEW ASSOCIATIONS ARE MADE FOR THE LOAD MODULE.
*      AT LEAST IN THE CASE OF THE STANDARD OUTPUT FILE, IT IS
*      RECOMMENDED THAT EITHER THE USER BE REQUIRED TO ATTACH
*      A FILE OR THAT A DEFAULT FILE IS ATTACHED, SINCE THE
*      PROBLEM OF ERROR MESSAGES GENERATED BY THE LOAD MODULE
*      IS OTHERWISE SEVERE. AS A LAST RESORT, IF SPITBOL
*      ATTEMPTS TO WRITE TO THE STANDARD OUTPUT FILE AND GETS A
*      REPLY INDICATING THAT SUCH OUPUT IS UNACCEPTABLE IT STOPS
*      BY USING AN ENTRY TO SYSEJ WITH ENDING CODE 998.
*      AS DESCRIBED BELOW, PASSING OF SOME ARGUMENTS MAKES IT
*      CLEAR THAT LOAD MODULE WILL USE A STANDARD OUTPUT FILE.
*
*      IF USE IS MADE OF FCBLKS FOR I/O ASSOCIATION, SPITBOL
*      BUILDS A CHAIN SO THAT THOSE IN USE MAY BE FOUND IN SYSXI
*      AND SYSEJ. THE NODES ARE 4 WORDS LONG. THIRD WORD
*      CONTAINS LINK TO NEXT NODE OR 0, FOURTH WORD CONTAINS
*      FCBLK POINTER.
{{EJC{{{{{4850
*
*      SYSXI (CONTINUED)
*
*      (XL)                  ZERO OR SCBLK PTR TO FIRST ARGUMENT
*      (XR)                  PTR TO V.V SCBLK
*      (IA)                  SIGNED INTEGER ARGUMENT
*      (WA)                  SCBLK PTR TO SECOND ARGUMENT
*      (WB)                  0 OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSXI            CALL TO EXIT
*      PPM  LOC              REQUESTED ACTION NOT POSSIBLE
*      PPM  LOC              ACTION CAUSED IRRECOVERABLE ERROR
*      (WB,WC,IA,XR,XL,CP)   SHOULD BE PRESERVED OVER CALL
*      (WA)                  0 IN ALL CASES EXCEPT SUCESSFUL
*                            PERFORMANCE OF EXIT(4) OR EXIT(-4),
*                            IN WHICH CASE 1 SHOULD BE RETURNED.
*
*      LOADING AND RUNNING THE LOAD MODULE OR RETURNING FROM
*      JCL COMMAND LEVEL CAUSES EXECUTION TO RESUME AT THE POINT
*      AFTER THE ERROR RETURNS WHICH FOLLOW THE CALL OF SYSXI.
*      THE VALUE PASSED AS EXIT ARGUMENT IS USED TO INDICATE
*      OPTIONS REQUIRED ON RESUMPTION OF LOAD MODULE.
*      +1 OR -1 REQUIRE THAT ON RESUMPTION, SYSID AND SYSPP BE
*      CALLED AND A HEADING PRINTED ON THE STANDARD OUTPUT FILE.
*      +2 OR -2 INDICATE THAT SYSPP WILL BE CALLED BUT NOT SYSID
*      AND NO HEADING WILL BE PUT ON STANDARD OUTPUT FILE.
*      ABOVE OPTIONS HAVE THE OBVIOUS IMPLICATION THAT A
*      STANDARD O/P FILE MUST BE PROVIDED FOR THE LOAD MODULE.
*      +3, +4, -3 OR -4 INDICATE CALLS OF NEITHER SYSID NOR
*      SYSPP AND NO HEADING WILL BE PLACED ON STANDARD OUTPUT
*      FILE.
*      +4 OR -4 INDICATE THAT EXECUTION IS TO CONTINUE AFTER
*      CREATION OF THE SAVE FILE OR LOAD MODULE, ALTHOUGH ALL
*      FILES WILL BE CLOSED BY THE SYSXI ACTION.  THIS PERMITS
*      THE USER TO CHECKPOINT LONG-RUNNING PROGRAMS WHILE
*      CONTINUING EXECUTION.
*
*      NO RETURN FROM SYSXI IS POSSIBLE IF ANOTHER PROGRAM
*      IS LOADED AND ENTERED.
{{EJC{{{{{4890
*
*      INTRODUCE THE INTERNAL PROCEDURES.
*
{ACESS{INP{25,R{1,1{{{4894
{ACOMP{INP{25,N{1,5{{{4895
{ALLOC{INP{25,E{1,0{{{4896
{ALOCS{INP{25,E{1,0{{{4901
{ALOST{INP{25,E{1,0{{{4902
{ARITH{INP{25,N{1,3{{{4910
{ASIGN{INP{25,R{1,1{{{4912
{ASINP{INP{25,R{1,1{{{4913
{BLKLN{INP{25,E{1,0{{{4914
{CDGCG{INP{25,E{1,0{{{4915
{CDGEX{INP{25,R{1,0{{{4916
{CDGNM{INP{25,R{1,0{{{4917
{CDGVL{INP{25,R{1,0{{{4918
{CDWRD{INP{25,E{1,0{{{4919
{CMGEN{INP{25,R{1,0{{{4920
{CMPIL{INP{25,E{1,0{{{4921
{CNCRD{INP{25,E{1,0{{{4922
{COPYB{INP{25,N{1,1{{{4923
{DFFNC{INP{25,E{1,0{{{4924
{DTACH{INP{25,E{1,0{{{4925
{DTYPE{INP{25,E{1,0{{{4926
{DUMPR{INP{25,E{1,0{{{4927
{ERMSG{INP{25,E{1,0{{{4932
{ERTEX{INP{25,E{1,0{{{4933
{EVALI{INP{25,R{1,4{{{4934
{EVALP{INP{25,R{1,1{{{4935
{EVALS{INP{25,R{1,3{{{4936
{EVALX{INP{25,R{1,1{{{4937
{EXBLD{INP{25,E{1,0{{{4938
{EXPAN{INP{25,E{1,0{{{4939
{EXPAP{INP{25,E{1,1{{{4940
{EXPDM{INP{25,N{1,0{{{4941
{EXPOP{INP{25,N{1,0{{{4942
{FILNM{INP{25,E{1,0{{{4944
{FLSTG{INP{25,E{1,0{{{4947
{GBCOL{INP{25,E{1,0{{{4949
{GBCPF{INP{25,E{1,0{{{4950
{GTARR{INP{25,E{1,2{{{4951
{{EJC{{{{{4952
{GTCOD{INP{25,E{1,1{{{4953
{GTEXP{INP{25,E{1,1{{{4954
{GTINT{INP{25,E{1,1{{{4955
{GTNUM{INP{25,E{1,1{{{4956
{GTNVR{INP{25,E{1,1{{{4957
{GTPAT{INP{25,E{1,1{{{4958
{GTREA{INP{25,E{1,1{{{4961
{GTSMI{INP{25,N{1,2{{{4963
{GTSTG{INP{25,N{1,1{{{4968
{GTVAR{INP{25,E{1,1{{{4969
{HASHS{INP{25,E{1,0{{{4970
{ICBLD{INP{25,E{1,0{{{4971
{IDENT{INP{25,E{1,1{{{4972
{INOUT{INP{25,E{1,0{{{4973
{INSTA{INP{25,E{1,0{{{4978
{IOFCB{INP{25,N{1,3{{{4979
{IOPPF{INP{25,N{1,0{{{4980
{IOPUT{INP{25,N{1,7{{{4981
{KTREX{INP{25,R{1,0{{{4982
{KWNAM{INP{25,N{1,0{{{4983
{LCOMP{INP{25,N{1,5{{{4984
{LISTR{INP{25,E{1,0{{{4985
{LISTT{INP{25,E{1,0{{{4986
{NEWFN{INP{25,E{1,0{{{4988
{NEXTS{INP{25,E{1,0{{{4990
{PATIN{INP{25,N{1,2{{{4991
{PATST{INP{25,N{1,1{{{4992
{PBILD{INP{25,E{1,0{{{4993
{PCONC{INP{25,E{1,0{{{4994
{PCOPY{INP{25,N{1,0{{{4995
{PRFLR{INP{25,E{1,0{{{4998
{PRFLU{INP{25,E{1,0{{{4999
{PRPAR{INP{25,E{1,0{{{5001
{PRTCH{INP{25,E{1,0{{{5002
{PRTIC{INP{25,E{1,0{{{5003
{PRTIS{INP{25,E{1,0{{{5004
{PRTIN{INP{25,E{1,0{{{5005
{PRTMI{INP{25,E{1,0{{{5006
{PRTMM{INP{25,E{1,0{{{5007
{PRTMX{INP{25,E{1,0{{{5008
{PRTNL{INP{25,R{1,0{{{5009
{PRTNM{INP{25,R{1,0{{{5010
{PRTNV{INP{25,E{1,0{{{5011
{PRTPG{INP{25,E{1,0{{{5012
{PRTPS{INP{25,E{1,0{{{5013
{PRTSN{INP{25,E{1,0{{{5014
{PRTST{INP{25,R{1,0{{{5015
{{EJC{{{{{5016
{PRTTR{INP{25,E{1,0{{{5017
{PRTVL{INP{25,R{1,0{{{5018
{PRTVN{INP{25,E{1,0{{{5019
{RCBLD{INP{25,E{1,0{{{5022
{READR{INP{25,E{1,0{{{5024
{RELAJ{INP{25,E{1,0{{{5026
{RELCR{INP{25,E{1,0{{{5027
{RELDN{INP{25,E{1,0{{{5028
{RELOC{INP{25,E{1,0{{{5029
{RELST{INP{25,E{1,0{{{5030
{RELWS{INP{25,E{1,0{{{5031
{RSTRT{INP{25,E{1,0{{{5033
{SBSTR{INP{25,E{1,0{{{5037
{SCANE{INP{25,E{1,0{{{5038
{SCNGF{INP{25,E{1,0{{{5039
{SETVR{INP{25,E{1,0{{{5040
{SORTA{INP{25,N{1,1{{{5043
{SORTC{INP{25,E{1,1{{{5044
{SORTF{INP{25,E{1,0{{{5045
{SORTH{INP{25,N{1,0{{{5046
{START{INP{25,E{1,0{{{5048
{STGCC{INP{25,E{1,0{{{5049
{TFIND{INP{25,E{1,1{{{5050
{TMAKE{INP{25,E{1,0{{{5051
{TRACE{INP{25,N{1,2{{{5052
{TRBLD{INP{25,E{1,0{{{5053
{TRIMR{INP{25,E{1,0{{{5054
{TRXEQ{INP{25,R{1,0{{{5055
{VMAKE{INP{25,E{1,1{{{5056
{XSCAN{INP{25,E{1,0{{{5057
{XSCNI{INP{25,N{1,2{{{5058
*
*      INTRODUCE THE INTERNAL ROUTINES
*
{ARREF{INR{{{{{5062
{CFUNC{INR{{{{{5063
{EXFAL{INR{{{{{5064
{EXINT{INR{{{{{5065
{EXITS{INR{{{{{5066
{EXIXR{INR{{{{{5067
{EXNAM{INR{{{{{5068
{EXNUL{INR{{{{{5069
{EXREA{INR{{{{{5072
{EXSID{INR{{{{{5074
{EXVNM{INR{{{{{5075
{FAILP{INR{{{{{5076
{FLPOP{INR{{{{{5077
{INDIR{INR{{{{{5078
{MATCH{INR{{{{{5079
{RETRN{INR{{{{{5080
{STCOV{INR{{{{{5081
{STMGO{INR{{{{{5082
{STOPR{INR{{{{{5083
{SUCCP{INR{{{{{5084
{SYSAB{INR{{{{{5085
{SYSTU{INR{{{{{5086
{{TTL{27,S P I T B O L -- DEFINITIONS AND DATA STRUCTURES{{{{5087
*      THIS SECTION CONTAINS ALL SYMBOL DEFINITIONS AND ALSO
*      PICTURES OF ALL DATA STRUCTURES USED IN THE SYSTEM.
*
{{SEC{{{{START OF DEFINITIONS SECTION{5091
*
*      DEFINITIONS OF MACHINE PARAMETERS
*
*      THE MINIMAL TRANSLATOR SHOULD SUPPLY APPROPRIATE VALUES
*      FOR THE PARTICULAR TARGET MACHINE FOR ALL THE
*      EQU  *
*      DEFINITIONS GIVEN AT THE START OF THIS SECTION.
*      NOTE THAT EVEN IF CONDITIONAL ASSEMBLY IS USED TO OMIT
*      SOME FEATURE (E.G. REAL ARITHMETIC) A FULL SET OF CFP$-
*      VALUES MUST BE SUPPLIED. USE DUMMY VALUES IF GENUINE
*      ONES ARE NOT NEEDED.
*
{CFP$A{EQU{24,256{{{NUMBER OF CHARACTERS IN ALPHABET{5104
*
{CFP$B{EQU{24,4{{{BYTES/WORD ADDRESSING FACTOR{5106
*
{CFP$C{EQU{24,4{{{NUMBER OF CHARACTERS PER WORD{5108
*
{CFP$F{EQU{24,8{{{OFFSET IN BYTES TO CHARS IN{5110
*                            SCBLK. SEE SCBLK FORMAT.
*
{CFP$I{EQU{24,1{{{NUMBER OF WORDS IN INTEGER CONSTANT{5113
*
{CFP$M{EQU{24,2147483647{{{MAX POSITIVE INTEGER IN ONE WORD{5115
*
{CFP$N{EQU{24,32{{{NUMBER OF BITS IN ONE WORD{5117
*
*      THE FOLLOWING DEFINITIONS REQUIRE THE SUPPLY OF EITHER
*      A SINGLE PARAMETER IF REAL ARITHMETIC IS OMITTED OR
*      THREE PARAMETERS IF REAL ARITHMETIC IS INCLUDED.
*
*
{CFP$R{EQU{24,2{{{NUMBER OF WORDS IN REAL CONSTANT{5127
*
{CFP$S{EQU{24,9{{{NUMBER OF SIG DIGS FOR REAL OUTPUT{5129
*
{CFP$X{EQU{24,3{{{MAX DIGITS IN REAL EXPONENT{5131
*
{MXDGS{EQU{24,CFP$S+CFP$X{{{MAX DIGITS IN REAL NUMBER{5142
*
*
*      MAX SPACE FOR REAL (FOR +0.E+) NEEDS FIVE MORE PLACES
*
{NSTMX{EQU{24,MXDGS+5{{{MAX SPACE FOR REAL{5147
*
*      THE FOLLOWING DEFINITION FOR CFP$U SUPPLIES A REALISTIC
*      UPPER BOUND ON THE SIZE OF THE ALPHABET.  CFP$U IS USED
*      TO SAVE SPACE IN THE SCANE BSW-IFF-ESW TABLE AND TO EASE
*      TRANSLATION STORAGE REQUIREMENTS.
*
{CFP$U{EQU{24,128{{{REALISTIC UPPER BOUND ON ALPHABET{5157
{{EJC{{{{{5159
*
*      ENVIRONMENT PARAMETERS
*
*      THE SPITBOL PROGRAM IS ESSENTIALLY INDEPENDENT OF
*      THE DEFINITIONS OF THESE PARAMETERS. HOWEVER, THE
*      EFFICIENCY OF THE SYSTEM MAY BE AFFECTED. CONSEQUENTLY,
*      THESE PARAMETERS MAY REQUIRE TUNING FOR A GIVEN VERSION
*      THE VALUES GIVEN IN COMMENTS HAVE BEEN SUCCESSFULLY USED.
*
*      E$SRS IS THE NUMBER OF WORDS TO RESERVE AT THE END OF
*      STORAGE FOR END OF RUN PROCESSING. IT SHOULD BE
*      SET AS SMALL AS POSSIBLE WITHOUT CAUSING MEMORY OVERFLOW
*      IN CRITICAL SITUATIONS (E.G. MEMORY OVERFLOW TERMINATION)
*      AND SHOULD THUS RESERVE SUFFICIENT SPACE AT LEAST FOR
*      AN SCBLK CONTAINING SAY 30 CHARACTERS.
*
{E$SRS{EQU{24,100{{{30 WORDS{5176
*
*      E$STS IS THE NUMBER OF WORDS GRABBED IN A CHUNK WHEN
*      STORAGE IS ALLOCATED IN THE STATIC REGION. THE MINIMUM
*      PERMITTED VALUE IS 256/CFP$B. LARGER VALUES WILL LEAD
*      TO INCREASED EFFICIENCY AT THE COST OF WASTING MEMORY.
*
{E$STS{EQU{24,1000{{{500 WORDS{5183
*
*      E$CBS IS THE SIZE OF CODE BLOCK ALLOCATED INITIALLY AND
*      THE EXPANSION INCREMENT IF OVERFLOW OCCURS. IF THIS VALUE
*      IS TOO SMALL OR TOO LARGE, EXCESSIVE GARBAGE COLLECTIONS
*      WILL OCCUR DURING COMPILATION AND MEMORY MAY BE LOST
*      IN THE CASE OF A TOO LARGE VALUE.
*
{E$CBS{EQU{24,500{{{500 WORDS{5191
*
*      E$HNB IS THE NUMBER OF BUCKET HEADERS IN THE VARIABLE
*      HASH TABLE. IT SHOULD ALWAYS BE ODD. LARGER VALUES WILL
*      SPEED UP COMPILATION AND INDIRECT REFERENCES AT THE
*      EXPENSE OF ADDITIONAL STORAGE FOR THE HASH TABLE ITSELF.
*
{E$HNB{EQU{24,257{{{127 BUCKET HEADERS{5198
*
*      E$HNW IS THE MAXIMUM NUMBER OF WORDS OF A STRING
*      NAME WHICH PARTICIPATE IN THE STRING HASH ALGORITHM.
*      LARGER VALUES GIVE A BETTER HASH AT THE EXPENSE OF TAKING
*      LONGER TO COMPUTE THE HASH. THERE IS SOME OPTIMAL VALUE.
*
{E$HNW{EQU{24,6{{{6 WORDS{5205
*
*      E$FSP.  IF THE AMOUNT OF FREE SPACE LEFT AFTER A GARBAGE
*      COLLECTION IS SMALL COMPARED TO THE TOTAL AMOUNT OF SPACE
*      IN USE GARBAGE COLLECTOR THRASHING IS LIKELY TO OCCUR AS
*      THIS SPACE IS USED UP.  E$FSP IS A MEASURE OF THE
*      MINIMUM PERCENTAGE OF DYNAMIC MEMORY LEFT AS FREE SPACE
*      BEFORE THE SYSTEM ROUTINE SYSMM IS CALLED TO TRY TO
*      OBTAIN MORE MEMORY.
*
{E$FSP{EQU{24,15{{{15 PERCENT{5215
*
*      E$SED.  IF THE AMOUNT OF FREE SPACE LEFT IN THE SEDIMENT
*      AFTER A GARBAGE COLLECTION IS A SIGNIFICANT FRACTION OF
*      THE NEW SEDIMENT SIZE, THE SEDIMENT IS MARKED FOR
*      COLLECTION ON THE NEXT CALL TO THE GARBAGE COLLECTOR.
*
{E$SED{EQU{24,25{{{25 PERCENT{5223
{{EJC{{{{{5225
*
*      DEFINITIONS OF CODES FOR LETTERS
*
{CH$LA{EQU{24,65{{{LETTER A{5229
{CH$LB{EQU{24,66{{{LETTER B{5230
{CH$LC{EQU{24,67{{{LETTER C{5231
{CH$LD{EQU{24,68{{{LETTER D{5232
{CH$LE{EQU{24,69{{{LETTER E{5233
{CH$LF{EQU{24,70{{{LETTER F{5234
{CH$LG{EQU{24,71{{{LETTER G{5235
{CH$LH{EQU{24,72{{{LETTER H{5236
{CH$LI{EQU{24,73{{{LETTER I{5237
{CH$LJ{EQU{24,74{{{LETTER J{5238
{CH$LK{EQU{24,75{{{LETTER K{5239
{CH$LL{EQU{24,76{{{LETTER L{5240
{CH$LM{EQU{24,77{{{LETTER M{5241
{CH$LN{EQU{24,78{{{LETTER N{5242
{CH$LO{EQU{24,79{{{LETTER O{5243
{CH$LP{EQU{24,80{{{LETTER P{5244
{CH$LQ{EQU{24,81{{{LETTER Q{5245
{CH$LR{EQU{24,82{{{LETTER R{5246
{CH$LS{EQU{24,83{{{LETTER S{5247
{CH$LT{EQU{24,84{{{LETTER T{5248
{CH$LU{EQU{24,85{{{LETTER U{5249
{CH$LV{EQU{24,86{{{LETTER V{5250
{CH$LW{EQU{24,87{{{LETTER W{5251
{CH$LX{EQU{24,88{{{LETTER X{5252
{CH$LY{EQU{24,89{{{LETTER Y{5253
{CH$L${EQU{24,90{{{LETTER Z{5254
*
*      DEFINITIONS OF CODES FOR DIGITS
*
{CH$D0{EQU{24,48{{{DIGIT 0{5258
{CH$D1{EQU{24,49{{{DIGIT 1{5259
{CH$D2{EQU{24,50{{{DIGIT 2{5260
{CH$D3{EQU{24,51{{{DIGIT 3{5261
{CH$D4{EQU{24,52{{{DIGIT 4{5262
{CH$D5{EQU{24,53{{{DIGIT 5{5263
{CH$D6{EQU{24,54{{{DIGIT 6{5264
{CH$D7{EQU{24,55{{{DIGIT 7{5265
{CH$D8{EQU{24,56{{{DIGIT 8{5266
{CH$D9{EQU{24,57{{{DIGIT 9{5267
{{EJC{{{{{5268
*
*      DEFINITIONS OF CODES FOR SPECIAL CHARACTERS
*
*      THE NAMES OF THESE CHARACTERS ARE RELATED TO THEIR
*      ORIGINAL REPRESENTATION IN THE EBCDIC SET CORRESPONDING
*      TO THE DESCRIPTION IN STANDARD SNOBOL4 MANUALS AND TEXTS.
*
{CH$AM{EQU{24,38{{{KEYWORD OPERATOR (AMPERSAND){5276
{CH$AS{EQU{24,42{{{MULTIPLICATION SYMBOL (ASTERISK){5277
{CH$AT{EQU{24,64{{{CURSOR POSITION OPERATOR (AT){5278
{CH$BB{EQU{24,60{{{LEFT ARRAY BRACKET (LESS THAN){5279
{CH$BL{EQU{24,32{{{BLANK{5280
{CH$BR{EQU{24,124{{{ALTERNATION OPERATOR (VERTICAL BAR){5281
{CH$CL{EQU{24,58{{{GOTO SYMBOL (COLON){5282
{CH$CM{EQU{24,44{{{COMMA{5283
{CH$DL{EQU{24,36{{{INDIRECTION OPERATOR (DOLLAR){5284
{CH$DT{EQU{24,46{{{NAME OPERATOR (DOT){5285
{CH$DQ{EQU{24,34{{{DOUBLE QUOTE{5286
{CH$EQ{EQU{24,61{{{EQUAL SIGN{5287
{CH$EX{EQU{24,33{{{EXPONENTIATION OPERATOR (EXCLM){5288
{CH$MN{EQU{24,45{{{MINUS SIGN / HYPHEN{5289
{CH$NM{EQU{24,35{{{NUMBER SIGN{5290
{CH$NT{EQU{24,126{{{NEGATION OPERATOR (NOT){5291
{CH$PC{EQU{24,37{{{PERCENT{5292
{CH$PL{EQU{24,43{{{PLUS SIGN{5293
{CH$PP{EQU{24,40{{{LEFT PARENTHESIS{5294
{CH$RB{EQU{24,62{{{RIGHT ARRAY BRACKET (GRTR THAN){5295
{CH$RP{EQU{24,41{{{RIGHT PARENTHESIS{5296
{CH$QU{EQU{24,63{{{INTERROGATION OPERATOR (QUESTION){5297
{CH$SL{EQU{24,47{{{SLASH{5298
{CH$SM{EQU{24,59{{{SEMICOLON{5299
{CH$SQ{EQU{24,39{{{SINGLE QUOTE{5300
{CH$UN{EQU{24,95{{{SPECIAL IDENTIFIER CHAR (UNDERLINE){5301
{CH$OB{EQU{24,91{{{OPENING BRACKET{5302
{CH$CB{EQU{24,93{{{CLOSING BRACKET{5303
{{EJC{{{{{5304
*
*      REMAINING CHARS ARE OPTIONAL ADDITIONS TO THE STANDARDS.
*
*      TAB CHARACTERS - SYNTACTICALLY EQUIVALENT TO BLANK
*
{CH$HT{EQU{24,9{{{HORIZONTAL TAB{5311
*
*      UP ARROW SAME AS EXCLAMATION MARK FOR EXPONENTIATION
*
{CH$EY{EQU{24,94{{{UP ARROW{5320
*
*      LOWER CASE OR SHIFTED CASE ALPHABETIC CHARS
*
{CH$$A{EQU{24,97{{{SHIFTED A{5326
{CH$$B{EQU{24,98{{{SHIFTED B{5327
{CH$$C{EQU{24,99{{{SHIFTED C{5328
{CH$$D{EQU{24,100{{{SHIFTED D{5329
{CH$$E{EQU{24,101{{{SHIFTED E{5330
{CH$$F{EQU{24,102{{{SHIFTED F{5331
{CH$$G{EQU{24,103{{{SHIFTED G{5332
{CH$$H{EQU{24,104{{{SHIFTED H{5333
{CH$$I{EQU{24,105{{{SHIFTED I{5334
{CH$$J{EQU{24,106{{{SHIFTED J{5335
{CH$$K{EQU{24,107{{{SHIFTED K{5336
{CH$$L{EQU{24,108{{{SHIFTED L{5337
{CH$$M{EQU{24,109{{{SHIFTED M{5338
{CH$$N{EQU{24,110{{{SHIFTED N{5339
{CH$$O{EQU{24,111{{{SHIFTED O{5340
{CH$$P{EQU{24,112{{{SHIFTED P{5341
{CH$$Q{EQU{24,113{{{SHIFTED Q{5342
{CH$$R{EQU{24,114{{{SHIFTED R{5343
{CH$$S{EQU{24,115{{{SHIFTED S{5344
{CH$$T{EQU{24,116{{{SHIFTED T{5345
{CH$$U{EQU{24,117{{{SHIFTED U{5346
{CH$$V{EQU{24,118{{{SHIFTED V{5347
{CH$$W{EQU{24,119{{{SHIFTED W{5348
{CH$$X{EQU{24,120{{{SHIFTED X{5349
{CH$$Y{EQU{24,121{{{SHIFTED Y{5350
{CH$$${EQU{24,122{{{SHIFTED Z{5351
*      IF A DELIMITER OTHER THAN CH$CM MUST BE USED IN
*      THE THIRD ARGUMENT OF INPUT(),OUTPUT() THEN .CIOD SHOULD
*      BE DEFINED AND A PARAMETER SUPPLIED FOR IODEL.
*
{IODEL{EQU{24,32{{{{5358
{{EJC{{{{{5362
*
*      DATA BLOCK FORMATS AND DEFINITIONS
*
*      THE FOLLOWING SECTIONS DESCRIBE THE DETAILED FORMAT OF
*      ALL POSSIBLE DATA BLOCKS IN STATIC AND DYNAMIC MEMORY.
*
*      EVERY BLOCK HAS A NAME OF THE FORM XXBLK WHERE XX IS A
*      UNIQUE TWO CHARACTER IDENTIFIER. THE FIRST WORD OF EVERY
*      BLOCK MUST CONTAIN A POINTER TO A PROGRAM LOCATION IN THE
*      INTERPRETOR WHICH IS IMMEDIATELY PRECEDED BY AN ADDRESS
*      CONSTANT CONTAINING THE VALUE BL$XX WHERE XX IS THE BLOCK
*      IDENTIFIER. THIS PROVIDES A UNIFORM MECHANISM FOR
*      DISTINGUISHING BETWEEN THE VARIOUS BLOCK TYPES.
*
*      IN SOME CASES, THE CONTENTS OF THE FIRST WORD IS CONSTANT
*      FOR A GIVEN BLOCK TYPE AND MERELY SERVES AS A POINTER
*      TO THE IDENTIFYING ADDRESS CONSTANT. HOWEVER, IN OTHER
*      CASES THERE ARE SEVERAL POSSIBILITIES FOR THE FIRST
*      WORD IN WHICH CASE EACH OF THE SEVERAL PROGRAM ENTRY
*      POINTS MUST BE PRECEDED BY THE APPROPRIATE CONSTANT.
*
*      IN EACH BLOCK, SOME OF THE FIELDS ARE RELOCATABLE. THIS
*      MEANS THAT THEY MAY CONTAIN A POINTER TO ANOTHER BLOCK
*      IN THE DYNAMIC AREA. (TO BE MORE PRECISE, IF THEY CONTAIN
*      A POINTER WITHIN THE DYNAMIC AREA, THEN IT IS A POINTER
*      TO A BLOCK). SUCH FIELDS MUST BE MODIFIED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL) WHENEVER BLOCKS ARE COMPACTED
*      IN THE DYNAMIC REGION. THE GARBAGE COLLECTOR (ACTUALLY
*      PROCEDURE GBCPF) REQUIRES THAT ALL SUCH RELOCATABLE
*      FIELDS IN A BLOCK MUST BE CONTIGUOUS.
{{EJC{{{{{5393
*
*      THE DESCRIPTION FORMAT USES THE FOLLOWING SCHEME.
*
*      1)   BLOCK TITLE AND TWO CHARACTER IDENTIFIER
*
*      2)   DESCRIPTION OF BASIC USE OF BLOCK AND INDICATION
*           OF CIRCUMSTANCES UNDER WHICH IT IS CONSTRUCTED.
*
*      3)   PICTURE OF THE BLOCK FORMAT. IN THESE PICTURES LOW
*           MEMORY ADDRESSES ARE AT THE TOP OF THE PAGE. FIXED
*           LENGTH FIELDS ARE SURROUNDED BY I (LETTER I). FIELDS
*           WHICH ARE FIXED LENGTH BUT WHOSE LENGTH IS DEPENDENT
*           ON A CONFIGURATION PARAMETER ARE SURROUNDED BY *
*           (ASTERISK). VARIABLE LENGTH FIELDS ARE SURROUNDED
*           BY / (SLASH).
*
*      4)   DEFINITION OF SYMBOLIC OFFSETS TO FIELDS IN
*           BLOCK AND OF THE SIZE OF THE BLOCK IF FIXED LENGTH
*           OR OF THE SIZE OF THE FIXED LENGTH FIELDS IF THE
*           BLOCK IS VARIABLE LENGTH.
*           NOTE THAT SOME ROUTINES SUCH AS GBCPF ASSUME
*           CERTAIN OFFSETS ARE EQUAL. THE DEFINITIONS
*           GIVEN HERE ENFORCE THIS.  MAKE CHANGES TO
*           THEM ONLY WITH DUE CARE.
*
*      DEFINITIONS OF COMMON OFFSETS
*
{OFFS1{EQU{24,1{{{{5421
{OFFS2{EQU{24,2{{{{5422
{OFFS3{EQU{24,3{{{{5423
*
*      5)   DETAILED COMMENTS ON THE SIGNIFICANCE AND FORMATS
*           OF THE VARIOUS FIELDS.
*
*      THE ORDER IS ALPHABETICAL BY IDENTIFICATION CODE.
{{EJC{{{{{5429
*
*      DEFINITIONS OF BLOCK CODES
*
*      THIS TABLE PROVIDES A UNIQUE IDENTIFICATION CODE FOR
*      EACH SEPARATE BLOCK TYPE. THE FIRST WORD OF A BLOCK IN
*      THE DYNAMIC AREA ALWAYS CONTAINS THE ADDRESS OF A PROGRAM
*      ENTRY POINT. THE BLOCK CODE IS USED AS THE ENTRY POINT ID
*      THE ORDER OF THESE CODES DICTATES THE ORDER OF THE TABLE
*      USED BY THE DATATYPE FUNCTION (SCNMT IN THE CONSTANT SEC)
*
*      BLOCK CODES FOR ACCESSIBLE DATATYPES
*
*      NOTE THAT REAL AND BUFFER TYPES ARE ALWAYS INCLUDED, EVEN
*      IF THEY ARE CONDITIONALLY EXCLUDED ELSEWHERE.  THIS MAIN-
*      TAINS BLOCK TYPE CODES ACROSS ALL VERSIONS OF SPITBOL,
*      PROVIDING CONSISTANCY FOR EXTERNAL FUNCTIONS.  BUT NOTE
*      THAT THE BCBLK IS OUT OF ALPHABETIC ORDER, PLACED AT THE
*      END OF THE LIST SO AS NOT TO CHANGE THE BLOCK TYPE
*      ORDERING IN USE IN EXISTING EXTERNAL FUNCTIONS.
*
{BL$AR{EQU{24,0{{{ARBLK     ARRAY{5450
{BL$CD{EQU{24,BL$AR+1{{{CDBLK     CODE{5451
{BL$EX{EQU{24,BL$CD+1{{{EXBLK     EXPRESSION{5452
{BL$IC{EQU{24,BL$EX+1{{{ICBLK     INTEGER{5453
{BL$NM{EQU{24,BL$IC+1{{{NMBLK     NAME{5454
{BL$P0{EQU{24,BL$NM+1{{{P0BLK     PATTERN{5455
{BL$P1{EQU{24,BL$P0+1{{{P1BLK     PATTERN{5456
{BL$P2{EQU{24,BL$P1+1{{{P2BLK     PATTERN{5457
{BL$RC{EQU{24,BL$P2+1{{{RCBLK     REAL{5458
{BL$SC{EQU{24,BL$RC+1{{{SCBLK     STRING{5459
{BL$SE{EQU{24,BL$SC+1{{{SEBLK     EXPRESSION{5460
{BL$TB{EQU{24,BL$SE+1{{{TBBLK     TABLE{5461
{BL$VC{EQU{24,BL$TB+1{{{VCBLK     ARRAY{5462
{BL$XN{EQU{24,BL$VC+1{{{XNBLK     EXTERNAL{5463
{BL$XR{EQU{24,BL$XN+1{{{XRBLK     EXTERNAL{5464
{BL$BC{EQU{24,BL$XR+1{{{BCBLK     BUFFER{5465
{BL$PD{EQU{24,BL$BC+1{{{PDBLK     PROGRAM DEFINED DATATYPE{5466
*
{BL$$D{EQU{24,BL$PD+1{{{NUMBER OF BLOCK CODES FOR DATA{5468
*
*      OTHER BLOCK CODES
*
{BL$TR{EQU{24,BL$PD+1{{{TRBLK{5472
{BL$BF{EQU{24,BL$TR+1{{{BFBLK{5473
{BL$CC{EQU{24,BL$BF+1{{{CCBLK{5474
{BL$CM{EQU{24,BL$CC+1{{{CMBLK{5475
{BL$CT{EQU{24,BL$CM+1{{{CTBLK{5476
{BL$DF{EQU{24,BL$CT+1{{{DFBLK{5477
{BL$EF{EQU{24,BL$DF+1{{{EFBLK{5478
{BL$EV{EQU{24,BL$EF+1{{{EVBLK{5479
{BL$FF{EQU{24,BL$EV+1{{{FFBLK{5480
{BL$KV{EQU{24,BL$FF+1{{{KVBLK{5481
{BL$PF{EQU{24,BL$KV+1{{{PFBLK{5482
{BL$TE{EQU{24,BL$PF+1{{{TEBLK{5483
*
{BL$$I{EQU{24,0{{{DEFAULT IDENTIFICATION CODE{5485
{BL$$T{EQU{24,BL$TR+1{{{CODE FOR DATA OR TRACE BLOCK{5486
{BL$$${EQU{24,BL$TE+1{{{NUMBER OF BLOCK CODES{5487
{{EJC{{{{{5488
*
*      FIELD REFERENCES
*
*      REFERENCES TO THE FIELDS OF DATA BLOCKS ARE SYMBOLIC
*      (I.E. USE THE SYMBOLIC OFFSETS) WITH THE FOLLOWING
*      EXCEPTIONS.
*
*      1)   REFERENCES TO THE FIRST WORD ARE USUALLY NOT
*           SYMBOLIC SINCE THEY USE THE (X) OPERAND FORMAT.
*
*      2)   THE CODE WHICH CONSTRUCTS A BLOCK IS OFTEN NOT
*           SYMBOLIC AND SHOULD BE CHANGED IF THE CORRESPONDING
*           BLOCK FORMAT IS MODIFIED.
*
*      3)   THE PLC AND PSC INSTRUCTIONS IMPLY AN OFFSET
*           CORRESPONDING TO THE DEFINITION OF CFP$F.
*
*      4)   THERE ARE NON-SYMBOLIC REFERENCES (EASILY CHANGED)
*           IN THE GARBAGE COLLECTOR (PROCEDURES GBCPF, BLKLN).
*
*      5)   THE FIELDS IDVAL, FARGS APPEAR IN SEVERAL BLOCKS
*           AND ANY CHANGES MUST BE MADE IN PARALLEL TO ALL
*           BLOCKS CONTAINING THE FIELDS. THE ACTUAL REFERENCES
*           TO THESE FIELDS ARE SYMBOLIC WITH THE ABOVE
*           LISTED EXCEPTIONS.
*
*      6)   SEVERAL SPOTS IN THE CODE ASSUME THAT THE
*           DEFINITIONS OF THE FIELDS VRVAL, TEVAL, TRNXT ARE
*           THE SAME (THESE ARE SECTIONS OF CODE WHICH SEARCH
*           OUT ALONG A TRBLK CHAIN FROM A VARIABLE).
*
*      7)   REFERENCES TO THE FIELDS OF AN ARRAY BLOCK IN THE
*           ARRAY REFERENCE ROUTINE ARREF ARE NON-SYMBOLIC.
*
*      APART FROM THE EXCEPTIONS LISTED, REFERENCES ARE SYMBOLIC
*      AS FAR AS POSSIBLE AND MODIFYING THE ORDER OR NUMBER
*      OF FIELDS WILL NOT REQUIRE CHANGES.
{{EJC{{{{{5526
*
*      COMMON FIELDS FOR FUNCTION BLOCKS
*
*      BLOCKS WHICH REPRESENT CALLABLE FUNCTIONS HAVE TWO
*      COMMON FIELDS AT THE START OF THE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           /                                    /
*           /       REST OF FUNCTION BLOCK       /
*           /                                    /
*           +------------------------------------+
*
{FCODE{EQU{24,0{{{POINTER TO CODE FOR FUNCTION{5543
{FARGS{EQU{24,1{{{NUMBER OF ARGUMENTS{5544
*
*      FCODE IS A POINTER TO THE LOCATION IN THE INTERPRETOR
*      PROGRAM WHICH PROCESSES THIS TYPE OF FUNCTION CALL.
*
*      FARGS IS THE EXPECTED NUMBER OF ARGUMENTS. THE ACTUAL
*      NUMBER OF ARGUMENTS IS ADJUSTED TO THIS AMOUNT BY
*      DELETING EXTRA ARGUMENTS OR SUPPLYING TRAILING NULLS
*      FOR MISSING ONES BEFORE TRANSFERRING THOUGH FCODE.
*      A VALUE OF 999 MAY BE USED IN THIS FIELD TO INDICATE A
*      VARIABLE NUMBER OF ARGUMENTS (SEE SVBLK FIELD SVNAR).
*
*      THE BLOCK TYPES WHICH FOLLOW THIS SCHEME ARE.
*
*      FFBLK                 FIELD FUNCTION
*      DFBLK                 DATATYPE FUNCTION
*      PFBLK                 PROGRAM DEFINED FUNCTION
*      EFBLK                 EXTERNAL LOADED FUNCTION
{{EJC{{{{{5562
*
*      IDENTIFICATION FIELD
*
*
*      ID   FIELD
*
*      CERTAIN PROGRAM ACCESSIBLE OBJECTS (THOSE WHICH CONTAIN
*      OTHER DATA VALUES AND CAN BE COPIED) ARE GIVEN A UNIQUE
*      IDENTIFICATION NUMBER (SEE EXSID). THIS ID VALUE IS AN
*      ADDRESS INTEGER VALUE WHICH IS ALWAYS STORED IN WORD TWO.
*
{IDVAL{EQU{24,1{{{ID VALUE FIELD{5574
*
*      THE BLOCKS CONTAINING AN IDVAL FIELD ARE.
*
*      ARBLK                 ARRAY
*      PDBLK                 PROGRAM DEFINED DATATYPE
*      TBBLK                 TABLE
*      VCBLK                 VECTOR BLOCK (ARRAY)
*
*      NOTE THAT A ZERO IDVAL MEANS THAT THE BLOCK IS ONLY
*      HALF BUILT AND SHOULD NOT BE DUMPED (SEE DUMPR).
{{EJC{{{{{5589
*
*      ARRAY BLOCK (ARBLK)
*
*      AN ARRAY BLOCK REPRESENTS AN ARRAY VALUE OTHER THAN ONE
*      WITH ONE DIMENSION WHOSE LOWER BOUND IS ONE (SEE VCBLK).
*      AN ARBLK IS BUILT WITH A CALL TO THE FUNCTIONS CONVERT
*      (S$CNV) OR ARRAY (S$ARR).
*
*           +------------------------------------+
*           I                ARTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                ARLEN               I
*           +------------------------------------+
*           I                AROFS               I
*           +------------------------------------+
*           I                ARNDM               I
*           +------------------------------------+
*           *                ARLBD               *
*           +------------------------------------+
*           *                ARDIM               *
*           +------------------------------------+
*           *                                    *
*           * ABOVE 2 FLDS REPEATED FOR EACH DIM *
*           *                                    *
*           +------------------------------------+
*           I                ARPRO               I
*           +------------------------------------+
*           /                                    /
*           /                ARVLS               /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{5623
*
*      ARRAY BLOCK (CONTINUED)
*
{ARTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$ART{5627
{ARLEN{EQU{24,IDVAL+1{{{LENGTH OF ARBLK IN BYTES{5628
{AROFS{EQU{24,ARLEN+1{{{OFFSET IN ARBLK TO ARPRO FIELD{5629
{ARNDM{EQU{24,AROFS+1{{{NUMBER OF DIMENSIONS{5630
{ARLBD{EQU{24,ARNDM+1{{{LOW BOUND (FIRST SUBSCRIPT){5631
{ARDIM{EQU{24,ARLBD+CFP$I{{{DIMENSION (FIRST SUBSCRIPT){5632
{ARLB2{EQU{24,ARDIM+CFP$I{{{LOW BOUND (SECOND SUBSCRIPT){5633
{ARDM2{EQU{24,ARLB2+CFP$I{{{DIMENSION (SECOND SUBSCRIPT){5634
{ARPRO{EQU{24,ARDIM+CFP$I{{{ARRAY PROTOTYPE (ONE DIMENSION){5635
{ARVLS{EQU{24,ARPRO+1{{{START OF VALUES (ONE DIMENSION){5636
{ARPR2{EQU{24,ARDM2+CFP$I{{{ARRAY PROTOTYPE (TWO DIMENSIONS){5637
{ARVL2{EQU{24,ARPR2+1{{{START OF VALUES (TWO DIMENSIONS){5638
{ARSI${EQU{24,ARLBD{{{NUMBER OF STANDARD FIELDS IN BLOCK{5639
{ARDMS{EQU{24,ARLB2-ARLBD{{{SIZE OF INFO FOR ONE SET OF BOUNDS{5640
*
*      THE BOUNDS AND DIMENSION FIELDS ARE SIGNED INTEGER
*      VALUES AND EACH OCCUPY CFP$I WORDS IN THE ARBLK.
*
*      THE LENGTH OF AN ARBLK IN BYTES MAY NOT EXCEED MXLEN.
*      THIS IS REQUIRED TO KEEP NAME OFFSETS GARBAGE COLLECTABLE
*
*      THE ACTUAL VALUES ARE ARRANGED IN ROW-WISE ORDER AND
*      CAN CONTAIN A DATA POINTER OR A POINTER TO A TRBLK.
{{EJC{{{{{5726
*
*      CODE CONSTRUCTION BLOCK (CCBLK)
*
*      AT ANY ONE MOMENT THERE IS AT MOST ONE CCBLK INTO
*      WHICH THE COMPILER IS CURRENTLY STORING CODE (CDWRD).
*
*           +------------------------------------+
*           I                CCTYP               I
*           +------------------------------------+
*           I                CCLEN               I
*           +------------------------------------+
*           I                CCSLN               I
*           +------------------------------------+
*           I                CCUSE               I
*           +------------------------------------+
*           /                                    /
*           /                CCCOD               /
*           /                                    /
*           +------------------------------------+
*
{CCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CCT{5749
{CCLEN{EQU{24,CCTYP+1{{{LENGTH OF CCBLK IN BYTES{5750
{CCSLN{EQU{24,CCLEN+1{{{SOURCE LINE NUMBER{5752
{CCUSE{EQU{24,CCSLN+1{{{OFFSET PAST LAST USED WORD (BYTES){5753
{CCCOD{EQU{24,CCUSE+1{{{START OF GENERATED CODE IN BLOCK{5757
*
*      THE REASON THAT THE CCBLK IS A SEPARATE BLOCK TYPE FROM
*      THE USUAL CDBLK IS THAT THE GARBAGE COLLECTOR MUST
*      ONLY PROCESS THOSE FIELDS WHICH HAVE BEEN SET (SEE GBCPF)
{{EJC{{{{{5762
*
*      CODE BLOCK (CDBLK)
*
*      A CODE BLOCK IS BUILT FOR EACH STATEMENT COMPILED DURING
*      THE INITIAL COMPILATION OR BY SUBSEQUENT CALLS TO CODE.
*
*           +------------------------------------+
*           I                CDJMP               I
*           +------------------------------------+
*           I                CDSTM               I
*           +------------------------------------+
*           I                CDSLN               I
*           +------------------------------------+
*           I                CDLEN               I
*           +------------------------------------+
*           I                CDFAL               I
*           +------------------------------------+
*           /                                    /
*           /                CDCOD               /
*           /                                    /
*           +------------------------------------+
*
{CDJMP{EQU{24,0{{{PTR TO ROUTINE TO EXECUTE STATEMENT{5787
{CDSTM{EQU{24,CDJMP+1{{{STATEMENT NUMBER{5788
{CDSLN{EQU{24,CDSTM+1{{{SOURCE LINE NUMBER{5790
{CDLEN{EQU{24,CDSLN+1{{{LENGTH OF CDBLK IN BYTES{5791
{CDFAL{EQU{24,CDLEN+1{{{FAILURE EXIT (SEE BELOW){5792
{CDCOD{EQU{24,CDFAL+1{{{EXECUTABLE PSEUDO-CODE{5797
{CDSI${EQU{24,CDCOD{{{NUMBER OF STANDARD FIELDS IN CDBLK{5798
*
*      CDSTM IS THE STATEMENT NUMBER OF THE CURRENT STATEMENT.
*
*      CDJMP, CDFAL ARE SET AS FOLLOWS.
*
*      1)   IF THE FAILURE EXIT IS THE NEXT STATEMENT
*
*           CDJMP = B$CDS
*           CDFAL = PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   IF THE FAILURE EXIT IS A SIMPLE LABEL NAME
*
*           CDJMP = B$CDS
*           CDFAL IS A PTR TO THE VRTRA FIELD OF THE VRBLK
*
*      3)   IF THERE IS NO FAILURE EXIT (-NOFAIL MODE)
*
*           CDJMP = B$CDS
*           CDFAL = O$UNF
*
*      4)   IF THE FAILURE EXIT IS COMPLEX OR DIRECT
*
*           CDJMP = B$CDC
*           CDFAL IS THE OFFSET TO THE O$GOF WORD
{{EJC{{{{{5823
*
*      CODE BLOCK (CONTINUED)
*
*      CDCOD IS THE START OF THE ACTUAL CODE. FIRST WE DESCRIBE
*      THE CODE GENERATED FOR AN EXPRESSION. IN AN EXPRESSION,
*      ELEMENTS ARE FETCHED BY NAME OR BY VALUE. FOR EXAMPLE,
*      THE BINARY EQUAL OPERATOR FETCHES ITS LEFT ARGUMENT
*      BY NAME AND ITS RIGHT ARGUMENT BY VALUE. THESE TWO
*      CASES GENERATE QUITE DIFFERENT CODE AND ARE DESCRIBED
*      SEPARATELY. FIRST WE CONSIDER THE CODE BY VALUE CASE.
*
*      GENERATION OF CODE BY VALUE FOR EXPRESSIONS ELEMENTS.
*
*      EXPRESSION            POINTER TO EXBLK OR SEBLK
*
*      INTEGER CONSTANT      POINTER TO ICBLK
*
*      NULL CONSTANT         POINTER TO NULLS
*
*      PATTERN               (RESULTING FROM PREEVALUATION)
*                            =O$LPT
*                            POINTER TO P0BLK,P1BLK OR P2BLK
*
*      REAL CONSTANT         POINTER TO RCBLK
*
*      STRING CONSTANT       POINTER TO SCBLK
*
*      VARIABLE              POINTER TO VRGET FIELD OF VRBLK
*
*      ADDITION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ADD
*
*      AFFIRMATION           VALUE CODE FOR OPERAND
*                            =O$AFF
*
*      ALTERNATION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ALT
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O$AOV
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O$AMV
*                            NUMBER OF SUBSCRIPTS
{{EJC{{{{{5877
*
*      CODE BLOCK (CONTINUED)
*
*      ASSIGNMENT            (TO NATURAL VARIABLE)
*                            VALUE CODE FOR RIGHT OPERAND
*                            POINTER TO VRSTO FIELD OF VRBLK
*
*                            (TO ANY OTHER VARIABLE)
*                            NAME CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ASS
*
*      COMPILE ERROR         =O$CER
*
*
*      COMPLEMENTATION       VALUE CODE FOR OPERAND
*                            =O$COM
*
*      CONCATENATION         (CASE OF PRED FUNC LEFT OPERAND)
*                            VALUE CODE FOR LEFT OPERAND
*                            =O$POP
*                            VALUE CODE FOR RIGHT OPERAND
*
*                            (ALL OTHER CASES)
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$CNC
*
*      CURSOR ASSIGNMENT     NAME CODE FOR OPERAND
*                            =O$CAS
*
*      DIVISION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$DVD
*
*      EXPONENTIATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$EXP
*
*      FUNCTION CALL         (CASE OF CALL TO SYSTEM FUNCTION)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            POINTER TO SVFNC FIELD OF SVBLK
*
{{EJC{{{{{5924
*
*      CODE BLOCK (CONTINUED)
*
*      FUNCTION CALL         (CASE OF NON-SYSTEM FUNCTION 1 ARG)
*                            VALUE CODE FOR ARGUMENT
*                            =O$FNS
*                            POINTER TO VRBLK FOR FUNCTION
*
*                            (NON-SYSTEM FUNCTION, GT 1 ARG)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            =O$FNC
*                            NUMBER OF ARGUMENTS
*                            POINTER TO VRBLK FOR FUNCTION
*
*      IMMEDIATE ASSIGNMENT  VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O$IMA
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O$INV
*
*      INTERROGATION         VALUE CODE FOR OPERAND
*                            =O$INT
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O$KWV
*
*      MULTIPLICATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$MLT
*
*      NAME REFERENCE        (NATURAL VARIABLE CASE)
*                            POINTER TO NMBLK FOR NAME
*
*                            (ALL OTHER CASES)
*                            NAME CODE FOR OPERAND
*                            =O$NAM
*
*      NEGATION              =O$NTA
*                            CDBLK OFFSET OF O$NTC WORD
*                            VALUE CODE FOR OPERAND
*                            =O$NTB
*                            =O$NTC
{{EJC{{{{{5971
*
*      CODE BLOCK (CONTINUED)
*
*      PATTERN ASSIGNMENT    VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O$PAS
*
*      PATTERN MATCH         VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$PMV
*
*      PATTERN REPLACEMENT   NAME CODE FOR SUBJECT
*                            VALUE CODE FOR PATTERN
*                            =O$PMN
*                            VALUE CODE FOR REPLACEMENT
*                            =O$RPL
*
*      SELECTION             (FOR FIRST ALTERNATIVE)
*                            =O$SLA
*                            CDBLK OFFSET TO NEXT O$SLC WORD
*                            VALUE CODE FOR FIRST ALTERNATIVE
*                            =O$SLB
*                            CDBLK OFFSET PAST ALTERNATIVES
*
*                            (FOR SUBSEQUENT ALTERNATIVES)
*                            =O$SLC
*                            CDBLK OFFSET TO NEXT O$SLC,O$SLD
*                            VALUE CODE FOR ALTERNATIVE
*                            =O$SLB
*                            OFFSET IN CDBLK PAST ALTERNATIVES
*
*                            (FOR LAST ALTERNATIVE)
*                            =O$SLD
*                            VALUE CODE FOR LAST ALTERNATIVE
*
*      SUBTRACTION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$SUB
{{EJC{{{{{6010
*
*      CODE BLOCK (CONTINUED)
*
*      GENERATION OF CODE BY NAME FOR EXPRESSION ELEMENTS.
*
*      VARIABLE              =O$LVN
*                            POINTER TO VRBLK
*
*      EXPRESSION            (CASE OF *NATURAL VARIABLE)
*                            =O$LVN
*                            POINTER TO VRBLK
*
*                            (ALL OTHER CASES)
*                            =O$LEX
*                            POINTER TO EXBLK
*
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O$AON
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O$AMN
*                            NUMBER OF SUBSCRIPTS
*
*      COMPILE ERROR         =O$CER
*
*      FUNCTION CALL         (SAME CODE AS FOR VALUE CALL)
*                            =O$FNE
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O$INN
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O$KWN
*
*      ANY OTHER OPERAND IS AN ERROR IN A NAME POSITION
*
*      NOTE THAT IN THIS DESCRIPTION, =O$XXX REFERS TO THE
*      GENERATION OF A WORD CONTAINING THE ADDRESS OF ANOTHER
*      WORD WHICH CONTAINS THE ENTRY POINT ADDRESS O$XXX.
{{EJC{{{{{6058
*
*      CODE BLOCK (CONTINUED)
*
*      NOW WE CONSIDER THE OVERALL STRUCTURE OF THE CODE BLOCK
*      FOR A STATEMENT WITH POSSIBLE GOTO FIELDS.
*
*      FIRST COMES THE CODE FOR THE STATEMENT BODY.
*      THE STATEMENT BODY IS AN EXPRESSION TO BE EVALUATED
*      BY VALUE ALTHOUGH THE VALUE IS NOT ACTUALLY REQUIRED.
*      NORMAL VALUE CODE IS GENERATED FOR THE BODY OF THE
*      STATEMENT EXCEPT IN THE CASE OF A PATTERN MATCH BY
*      VALUE, IN WHICH CASE THE FOLLOWING IS GENERATED.
*
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$PMS
*
*      NEXT WE HAVE THE CODE FOR THE SUCCESS GOTO. THERE ARE
*      SEVERAL CASES AS FOLLOWS.
*
*      1)   NO SUCCESS GOTO  PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   SIMPLE LABEL     PTR TO VRTRA FIELD OF VRBLK
*
*      3)   COMPLEX GOTO     (CODE BY NAME FOR GOTO OPERAND)
*                            =O$GOC
*
*      4)   DIRECT GOTO      (CODE BY VALUE FOR GOTO OPERAND)
*                            =O$GOD
*
*      FOLLOWING THIS WE GENERATE CODE FOR THE FAILURE GOTO IF
*      IT IS DIRECT OR IF IT IS COMPLEX, SIMPLE FAILURE GOTOS
*      HAVING BEEN HANDLED BY AN APPROPRIATE SETTING OF THE
*      CDFAL FIELD OF THE CDBLK. THE GENERATED CODE IS ONE
*      OF THE FOLLOWING.
*
*      1)   COMPLEX FGOTO    =O$FIF
*                            =O$GOF
*                            NAME CODE FOR GOTO OPERAND
*                            =O$GOC
*
*      2)   DIRECT FGOTO     =O$FIF
*                            =O$GOF
*                            VALUE CODE FOR GOTO OPERAND
*                            =O$GOD
*
*      AN OPTIMIZATION OCCURS IF THE SUCCESS AND FAILURE GOTOS
*      ARE IDENTICAL AND EITHER COMPLEX OR DIRECT. IN THIS CASE,
*      NO CODE IS GENERATED FOR THE SUCCESS GOTO AND CONTROL
*      IS ALLOWED TO FALL INTO THE FAILURE GOTO ON SUCCESS.
{{EJC{{{{{6109
*
*      COMPILER BLOCK (CMBLK)
*
*      A COMPILER BLOCK (CMBLK) IS BUILT BY EXPAN TO REPRESENT
*      ONE NODE OF A TREE STRUCTURED EXPRESSION REPRESENTATION.
*
*           +------------------------------------+
*           I                CMIDN               I
*           +------------------------------------+
*           I                CMLEN               I
*           +------------------------------------+
*           I                CMTYP               I
*           +------------------------------------+
*           I                CMOPN               I
*           +------------------------------------+
*           /           CMVLS OR CMROP           /
*           /                                    /
*           /                CMLOP               /
*           /                                    /
*           +------------------------------------+
*
{CMIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CMT{6131
{CMLEN{EQU{24,CMIDN+1{{{LENGTH OF CMBLK IN BYTES{6132
{CMTYP{EQU{24,CMLEN+1{{{TYPE (C$XXX, SEE LIST BELOW){6133
{CMOPN{EQU{24,CMTYP+1{{{OPERAND POINTER (SEE BELOW){6134
{CMVLS{EQU{24,CMOPN+1{{{OPERAND VALUE POINTERS (SEE BELOW){6135
{CMROP{EQU{24,CMVLS{{{RIGHT (ONLY) OPERATOR OPERAND{6136
{CMLOP{EQU{24,CMVLS+1{{{LEFT OPERATOR OPERAND{6137
{CMSI${EQU{24,CMVLS{{{NUMBER OF STANDARD FIELDS IN CMBLK{6138
{CMUS${EQU{24,CMSI$+1{{{SIZE OF UNARY OPERATOR CMBLK{6139
{CMBS${EQU{24,CMSI$+2{{{SIZE OF BINARY OPERATOR CMBLK{6140
{CMAR1{EQU{24,CMVLS+1{{{ARRAY SUBSCRIPT POINTERS{6141
*
*      THE CMOPN AND CMVLS FIELDS ARE SET AS FOLLOWS
*
*      ARRAY REFERENCE       CMOPN = PTR TO ARRAY OPERAND
*                            CMVLS = PTRS TO SUBSCRIPT OPERANDS
*
*      FUNCTION CALL         CMOPN = PTR TO VRBLK FOR FUNCTION
*                            CMVLS = PTRS TO ARGUMENT OPERANDS
*
*      SELECTION             CMOPN = ZERO
*                            CMVLS = PTRS TO ALTERNATE OPERANDS
*
*      UNARY OPERATOR        CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO OPERAND
*
*      BINARY OPERATOR       CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO RIGHT OPERAND
*                            CMLOP = PTR TO LEFT OPERAND
{{EJC{{{{{6160
*
*      CMTYP IS SET TO INDICATE THE TYPE OF EXPRESSION ELEMENT
*      AS SHOWN BY THE FOLLOWING TABLE OF DEFINITIONS.
*
{C$ARR{EQU{24,0{{{ARRAY REFERENCE{6165
{C$FNC{EQU{24,C$ARR+1{{{FUNCTION CALL{6166
{C$DEF{EQU{24,C$FNC+1{{{DEFERRED EXPRESSION (UNARY *){6167
{C$IND{EQU{24,C$DEF+1{{{INDIRECTION (UNARY $){6168
{C$KEY{EQU{24,C$IND+1{{{KEYWORD REFERENCE (UNARY AMPERSAND){6169
{C$UBO{EQU{24,C$KEY+1{{{UNDEFINED BINARY OPERATOR{6170
{C$UUO{EQU{24,C$UBO+1{{{UNDEFINED UNARY OPERATOR{6171
{C$UO${EQU{24,C$UUO+1{{{TEST VALUE (=C$UUO+1=C$UBO+2){6172
{C$$NM{EQU{24,C$UUO+1{{{NUMBER OF CODES FOR NAME OPERANDS{6173
*
*      THE REMAINING TYPES INDICATE EXPRESSION ELEMENTS WHICH
*      CAN ONLY BE EVALUATED BY VALUE (NOT BY NAME).
*
{C$BVL{EQU{24,C$UUO+1{{{BINARY OP WITH VALUE OPERANDS{6178
{C$UVL{EQU{24,C$BVL+1{{{UNARY OPERATOR WITH VALUE OPERAND{6179
{C$ALT{EQU{24,C$UVL+1{{{ALTERNATION (BINARY BAR){6180
{C$CNC{EQU{24,C$ALT+1{{{CONCATENATION{6181
{C$CNP{EQU{24,C$CNC+1{{{CONCATENATION, NOT PATTERN MATCH{6182
{C$UNM{EQU{24,C$CNP+1{{{UNARY OP WITH NAME OPERAND{6183
{C$BVN{EQU{24,C$UNM+1{{{BINARY OP (OPERANDS BY VALUE, NAME){6184
{C$ASS{EQU{24,C$BVN+1{{{ASSIGNMENT{6185
{C$INT{EQU{24,C$ASS+1{{{INTERROGATION{6186
{C$NEG{EQU{24,C$INT+1{{{NEGATION (UNARY NOT){6187
{C$SEL{EQU{24,C$NEG+1{{{SELECTION{6188
{C$PMT{EQU{24,C$SEL+1{{{PATTERN MATCH{6189
*
{C$PR${EQU{24,C$BVN{{{LAST PREEVALUABLE CODE{6191
{C$$NV{EQU{24,C$PMT+1{{{NUMBER OF DIFFERENT CMBLK TYPES{6192
{{EJC{{{{{6193
*
*      CHARACTER TABLE BLOCK (CTBLK)
*
*      A CHARACTER TABLE BLOCK IS USED TO HOLD LOGICAL CHARACTER
*      TABLES FOR USE WITH ANY,NOTANY,SPAN,BREAK,BREAKX
*      PATTERNS. EACH CHARACTER TABLE CAN BE USED TO STORE
*      CFP$N DISTINCT TABLES AS BIT COLUMNS. A BIT COLUMN
*      ALLOCATED FOR EACH ARGUMENT OF MORE THAN ONE CHARACTER
*      IN LENGTH TO ONE OF THE ABOVE LISTED PATTERN PRIMITIVES.
*
*           +------------------------------------+
*           I                CTTYP               I
*           +------------------------------------+
*           *                                    *
*           *                                    *
*           *                CTCHS               *
*           *                                    *
*           *                                    *
*           +------------------------------------+
*
{CTTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CTT{6214
{CTCHS{EQU{24,CTTYP+1{{{START OF CHARACTER TABLE WORDS{6215
{CTSI${EQU{24,CTCHS+CFP$A{{{NUMBER OF WORDS IN CTBLK{6216
*
*      CTCHS IS CFP$A WORDS LONG AND CONSISTS OF A ONE WORD
*      BIT STRING VALUE FOR EACH POSSIBLE CHARACTER IN THE
*      INTERNAL ALPHABET. EACH OF THE CFP$N POSSIBLE BITS IN
*      A BITSTRING IS USED TO FORM A COLUMN OF BIT INDICATORS.
*      A BIT IS SET ON IF THE CHARACTER IS IN THE TABLE AND OFF
*      IF THE CHARACTER IS NOT PRESENT.
{{EJC{{{{{6224
*
*      DATATYPE FUNCTION BLOCK (DFBLK)
*
*      A DATATYPE FUNCTION IS USED TO CONTROL THE CONSTRUCTION
*      OF A PROGRAM DEFINED DATATYPE OBJECT. A CALL TO THE
*      SYSTEM FUNCTION DATA BUILDS A DFBLK FOR THE DATATYPE NAME
*
*      NOTE THAT THESE BLOCKS ARE BUILT IN STATIC BECAUSE PDBLK
*      LENGTH IS GOT FROM DFLEN FIELD.  IF DFBLK WAS IN DYNAMIC
*      STORE THIS WOULD CAUSE TROUBLE DURING PASS TWO OF GARBAGE
*      COLLECTION.  SCBLK REFERRED TO BY DFNAM FIELD IS ALSO PUT
*      IN STATIC SO THAT THERE ARE NO RELOC. FIELDS. THIS CUTS
*      GARBAGE COLLECTION TASK APPRECIABLY FOR PDBLKS WHICH ARE
*      LIKELY TO BE PRESENT IN LARGE NUMBERS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                DFLEN               I
*           +------------------------------------+
*           I                DFPDL               I
*           +------------------------------------+
*           I                DFNAM               I
*           +------------------------------------+
*           /                                    /
*           /                DFFLD               /
*           /                                    /
*           +------------------------------------+
*
{DFLEN{EQU{24,FARGS+1{{{LENGTH OF DFBLK IN BYTES{6256
{DFPDL{EQU{24,DFLEN+1{{{LENGTH OF CORRESPONDING PDBLK{6257
{DFNAM{EQU{24,DFPDL+1{{{POINTER TO SCBLK FOR DATATYPE NAME{6258
{DFFLD{EQU{24,DFNAM+1{{{START OF VRBLK PTRS FOR FIELD NAMES{6259
{DFFLB{EQU{24,DFFLD-1{{{OFFSET BEHIND DFFLD FOR FIELD FUNC{6260
{DFSI${EQU{24,DFFLD{{{NUMBER OF STANDARD FIELDS IN DFBLK{6261
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$DFC
*
*      FARGS (THE NUMBER OF ARGUMENTS) IS THE NUMBER OF FIELDS.
{{EJC{{{{{6266
*
*      DOPE VECTOR BLOCK (DVBLK)
*
*      A DOPE VECTOR IS ASSEMBLED FOR EACH POSSIBLE OPERATOR IN
*      THE SNOBOL4 LANGUAGE AS PART OF THE CONSTANT SECTION.
*
*           +------------------------------------+
*           I                DVOPN               I
*           +------------------------------------+
*           I                DVTYP               I
*           +------------------------------------+
*           I                DVLPR               I
*           +------------------------------------+
*           I                DVRPR               I
*           +------------------------------------+
*
{DVOPN{EQU{24,0{{{ENTRY ADDRESS (PTR TO O$XXX){6283
{DVTYP{EQU{24,DVOPN+1{{{TYPE CODE (C$XXX, SEE CMBLK){6284
{DVLPR{EQU{24,DVTYP+1{{{LEFT PRECEDENCE (LLXXX, SEE BELOW){6285
{DVRPR{EQU{24,DVLPR+1{{{RIGHT PRECEDENCE (RRXXX, SEE BELOW){6286
{DVUS${EQU{24,DVLPR+1{{{SIZE OF UNARY OPERATOR DV{6287
{DVBS${EQU{24,DVRPR+1{{{SIZE OF BINARY OPERATOR DV{6288
{DVUBS{EQU{24,DVUS$+DVBS${{{SIZE OF UNOP + BINOP (SEE SCANE){6289
*
*      THE CONTENTS OF THE DVTYP FIELD IS COPIED INTO THE CMTYP
*      FIELD OF THE CMBLK FOR THE OPERATOR IF IT IS USED.
*
*      THE CMOPN FIELD OF AN OPERATOR CMBLK POINTS TO THE DVBLK
*      ITSELF, PROVIDING THE REQUIRED ENTRY ADDRESS POINTER PTR.
*
*      FOR NORMALLY UNDEFINED OPERATORS, THE DVOPN (AND CMOPN)
*      FIELDS CONTAIN A WORD OFFSET FROM R$UBA OF THE FUNCTION
*      BLOCK POINTER FOR THE OPERATOR (INSTEAD OF O$XXX PTR).
*      FOR CERTAIN SPECIAL OPERATORS, THE DVOPN FIELD IS NOT
*      REQUIRED AT ALL AND IS ASSEMBLED AS ZERO.
*
*      THE LEFT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE LEFT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS THE
*      PRECEDENCE OF THE OPERATOR TOWARDS ITS RIGHT OPERAND.
*
*      THE RIGHT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE RIGHT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS
*      THE PRECEDENCE OF THE OPERATOR TOWARDS ITS LEFT OPERAND.
*
*      HIGHER PRECEDENCE VALUES CORRESPOND TO A TIGHTER BINDING
*      CAPABILITY. THUS WE HAVE THE LEFT PRECEDENCE LOWER
*      (HIGHER) THAN THE RIGHT PRECEDENCE FOR RIGHT (LEFT)
*      ASSOCIATIVE BINARY OPERATORS.
*
*      THE LEFT PRECEDENCE OF UNARY OPERATORS IS SET TO AN
*      ARBITRARY HIGH VALUE. THE RIGHT VALUE IS NOT REQUIRED AND
*      CONSEQUENTLY THE DVRPR FIELD IS OMITTED FOR UNARY OPS.
{{EJC{{{{{6319
*
*      TABLE OF OPERATOR PRECEDENCE VALUES
*
{RRASS{EQU{24,10{{{RIGHT     EQUAL{6323
{LLASS{EQU{24,00{{{LEFT      EQUAL{6324
{RRPMT{EQU{24,20{{{RIGHT     QUESTION MARK{6325
{LLPMT{EQU{24,30{{{LEFT      QUESTION MARK{6326
{RRAMP{EQU{24,40{{{RIGHT     AMPERSAND{6327
{LLAMP{EQU{24,50{{{LEFT      AMPERSAND{6328
{RRALT{EQU{24,70{{{RIGHT     VERTICAL BAR{6329
{LLALT{EQU{24,60{{{LEFT      VERTICAL BAR{6330
{RRCNC{EQU{24,90{{{RIGHT     BLANK{6331
{LLCNC{EQU{24,80{{{LEFT      BLANK{6332
{RRATS{EQU{24,110{{{RIGHT     AT{6333
{LLATS{EQU{24,100{{{LEFT      AT{6334
{RRPLM{EQU{24,120{{{RIGHT     PLUS, MINUS{6335
{LLPLM{EQU{24,130{{{LEFT      PLUS, MINUS{6336
{RRNUM{EQU{24,140{{{RIGHT     NUMBER{6337
{LLNUM{EQU{24,150{{{LEFT      NUMBER{6338
{RRDVD{EQU{24,160{{{RIGHT     SLASH{6339
{LLDVD{EQU{24,170{{{LEFT      SLASH{6340
{RRMLT{EQU{24,180{{{RIGHT     ASTERISK{6341
{LLMLT{EQU{24,190{{{LEFT      ASTERISK{6342
{RRPCT{EQU{24,200{{{RIGHT     PERCENT{6343
{LLPCT{EQU{24,210{{{LEFT      PERCENT{6344
{RREXP{EQU{24,230{{{RIGHT     EXCLAMATION{6345
{LLEXP{EQU{24,220{{{LEFT      EXCLAMATION{6346
{RRDLD{EQU{24,240{{{RIGHT     DOLLAR, DOT{6347
{LLDLD{EQU{24,250{{{LEFT      DOLLAR, DOT{6348
{RRNOT{EQU{24,270{{{RIGHT     NOT{6349
{LLNOT{EQU{24,260{{{LEFT      NOT{6350
{LLUNO{EQU{24,999{{{LEFT      ALL UNARY OPERATORS{6351
*
*      PRECEDENCES ARE THE SAME AS IN BTL SNOBOL4 WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      1)   BINARY QUESTION MARK IS LOWERED AND MADE LEFT ASSOC-
*           IATIVE TO REFLECT ITS NEW USE FOR PATTERN MATCHING.
*
*      2)   ALTERNATION AND CONCATENATION ARE MADE RIGHT
*           ASSOCIATIVE FOR GREATER EFFICIENCY IN PATTERN
*           CONSTRUCTION AND MATCHING RESPECTIVELY. THIS CHANGE
*           IS TRANSPARENT TO THE SNOBOL4 PROGRAMMER.
*
*      3)   THE EQUAL SIGN HAS BEEN ADDED AS A LOW PRECEDENCE
*           OPERATOR WHICH IS RIGHT ASSOCIATIVE TO REFLECT ITS
*           MORE GENERAL USAGE IN THIS VERSION OF SNOBOL4.
{{EJC{{{{{6367
*
*      EXTERNAL FUNCTION BLOCK (EFBLK)
*
*      AN EXTERNAL FUNCTION BLOCK IS USED TO CONTROL THE CALLING
*      OF AN EXTERNAL FUNCTION. IT IS BUILT BY A CALL TO LOAD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                EFLEN               I
*           +------------------------------------+
*           I                EFUSE               I
*           +------------------------------------+
*           I                EFCOD               I
*           +------------------------------------+
*           I                EFVAR               I
*           +------------------------------------+
*           I                EFRSL               I
*           +------------------------------------+
*           /                                    /
*           /                EFTAR               /
*           /                                    /
*           +------------------------------------+
*
{EFLEN{EQU{24,FARGS+1{{{LENGTH OF EFBLK IN BYTES{6394
{EFUSE{EQU{24,EFLEN+1{{{USE COUNT (FOR OPSYN){6395
{EFCOD{EQU{24,EFUSE+1{{{PTR TO CODE (FROM SYSLD){6396
{EFVAR{EQU{24,EFCOD+1{{{PTR TO ASSOCIATED VRBLK{6397
{EFRSL{EQU{24,EFVAR+1{{{RESULT TYPE (SEE BELOW){6398
{EFTAR{EQU{24,EFRSL+1{{{ARGUMENT TYPES (SEE BELOW){6399
{EFSI${EQU{24,EFTAR{{{NUMBER OF STANDARD FIELDS IN EFBLK{6400
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$EFC.
*
*      EFUSE IS USED TO KEEP TRACK OF MULTIPLE USE WHEN OPSYN
*      IS EMPLOYED. THE FUNCTION IS AUTOMATICALLY UNLOADED
*      WHEN THERE ARE NO MORE REFERENCES TO THE FUNCTION.
*
*      EFRSL AND EFTAR ARE TYPE CODES AS FOLLOWS.
*
*           0                TYPE IS UNCONVERTED
*           1                TYPE IS STRING
*           2                TYPE IS INTEGER
*           3                TYPE IS REAL
*           4                TYPE IS FILE
{{EJC{{{{{6423
*
*      EXPRESSION VARIABLE BLOCK (EVBLK)
*
*      IN THIS VERSION OF SPITBOL, AN EXPRESSION CAN BE USED IN
*      ANY POSITION WHICH WOULD NORMALLY EXPECT A NAME (FOR
*      EXAMPLE ON THE LEFT SIDE OF EQUALS OR AS THE RIGHT
*      ARGUMENT OF BINARY DOT). THIS CORRESPONDS TO THE CREATION
*      OF A PSEUDO-VARIABLE WHICH IS REPRESENTED BY A POINTER TO
*      AN EXPRESSION VARIABLE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                EVTYP               I
*           +------------------------------------+
*           I                EVEXP               I
*           +------------------------------------+
*           I                EVVAR               I
*           +------------------------------------+
*
{EVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$EVT{6442
{EVEXP{EQU{24,EVTYP+1{{{POINTER TO EXBLK FOR EXPRESSION{6443
{EVVAR{EQU{24,EVEXP+1{{{POINTER TO TRBEV DUMMY TRBLK{6444
{EVSI${EQU{24,EVVAR+1{{{SIZE OF EVBLK{6445
*
*      THE NAME OF AN EXPRESSION VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE EVBLK AND AN OFFSET OF EVVAR. THIS
*      VALUE APPEARS TO BE TRAPPED BY THE DUMMY TRBEV BLOCK.
*
*      NOTE THAT THERE IS NO NEED TO ALLOW FOR THE CASE OF AN
*      EXPRESSION VARIABLE WHICH REFERENCES AN SEBLK SINCE A
*      VARIABLE WHICH IS OF THE FORM *VAR IS EQUIVALENT TO VAR.
{{EJC{{{{{6454
*
*      EXPRESSION BLOCK (EXBLK)
*
*      AN EXPRESSION BLOCK IS BUILT FOR EACH EXPRESSION
*      REFERENCED IN A PROGRAM OR CREATED BY EVAL OR CONVERT
*      DURING EXECUTION OF A PROGRAM.
*
*           +------------------------------------+
*           I                EXTYP               I
*           +------------------------------------+
*           I                EXSTM               I
*           +------------------------------------+
*           I                EXSLN               I
*           +------------------------------------+
*           I                EXLEN               I
*           +------------------------------------+
*           I                EXFLC               I
*           +------------------------------------+
*           /                                    /
*           /                EXCOD               /
*           /                                    /
*           +------------------------------------+
*
{EXTYP{EQU{24,0{{{PTR TO ROUTINE B$EXL TO LOAD EXPR{6480
{EXSTM{EQU{24,CDSTM{{{STORES STMNT NO. DURING EVALUATION{6481
{EXSLN{EQU{24,EXSTM+1{{{STORES LINE NO. DURING EVALUATION{6483
{EXLEN{EQU{24,EXSLN+1{{{LENGTH OF EXBLK IN BYTES{6484
{EXFLC{EQU{24,EXLEN+1{{{FAILURE CODE (=O$FEX){6488
{EXCOD{EQU{24,EXFLC+1{{{PSEUDO-CODE FOR EXPRESSION{6489
{EXSI${EQU{24,EXCOD{{{NUMBER OF STANDARD FIELDS IN EXBLK{6490
*
*      THERE ARE TWO CASES FOR EXCOD DEPENDING ON WHETHER THE
*      EXPRESSION CAN BE EVALUATED BY NAME (SEE DESCRIPTION
*      OF CDBLK FOR DETAILS OF CODE FOR EXPRESSIONS).
*
*      IF THE EXPRESSION CAN BE EVALUATED BY NAME WE HAVE.
*
*                            (CODE FOR EXPR BY NAME)
*                            =O$RNM
*
*      IF THE EXPRESSION CAN ONLY BE EVALUATED BY VALUE.
*
*                            (CODE FOR EXPR BY VALUE)
*                            =O$RVL
{{EJC{{{{{6505
*
*      FIELD FUNCTION BLOCK (FFBLK)
*
*      A FIELD FUNCTION BLOCK IS USED TO CONTROL THE SELECTION
*      OF A FIELD FROM A PROGRAM DEFINED DATATYPE BLOCK.
*      A CALL TO DATA CREATES AN FFBLK FOR EACH FIELD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                FFDFP               I
*           +------------------------------------+
*           I                FFNXT               I
*           +------------------------------------+
*           I                FFOFS               I
*           +------------------------------------+
*
{FFDFP{EQU{24,FARGS+1{{{POINTER TO ASSOCIATED DFBLK{6525
{FFNXT{EQU{24,FFDFP+1{{{PTR TO NEXT FFBLK ON CHAIN OR ZERO{6526
{FFOFS{EQU{24,FFNXT+1{{{OFFSET (BYTES) TO FIELD IN PDBLK{6527
{FFSI${EQU{24,FFOFS+1{{{SIZE OF FFBLK IN WORDS{6528
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$FFC.
*
*      FARGS ALWAYS CONTAINS ONE.
*
*      FFDFP IS USED TO VERIFY THAT THE CORRECT PROGRAM DEFINED
*      DATATYPE IS BEING ACCESSED BY THIS CALL.
*      FFDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      FFOFS IS USED TO SELECT THE APPROPRIATE FIELD. NOTE THAT
*      IT IS AN ACTUAL OFFSET (NOT A FIELD NUMBER)
*
*      FFNXT IS USED TO POINT TO THE NEXT FFBLK OF THE SAME NAME
*      IN THE CASE WHERE THERE ARE SEVERAL FIELDS OF THE SAME
*      NAME FOR DIFFERENT DATATYPES. ZERO MARKS THE END OF CHAIN
{{EJC{{{{{6544
*
*      INTEGER CONSTANT BLOCK (ICBLK)
*
*      AN ICBLK IS CREATED FOR EVERY INTEGER REFERENCED OR
*      CREATED BY A PROGRAM. NOTE HOWEVER THAT CERTAIN INTERNAL
*      INTEGER VALUES ARE STORED AS ADDRESSES (E.G. THE LENGTH
*      FIELD IN A STRING CONSTANT BLOCK)
*
*           +------------------------------------+
*           I                ICGET               I
*           +------------------------------------+
*           *                ICVAL               *
*           +------------------------------------+
*
{ICGET{EQU{24,0{{{PTR TO ROUTINE B$ICL TO LOAD INT{6559
{ICVAL{EQU{24,ICGET+1{{{INTEGER VALUE{6560
{ICSI${EQU{24,ICVAL+CFP$I{{{SIZE OF ICBLK{6561
*
*      THE LENGTH OF THE ICVAL FIELD IS CFP$I.
{{EJC{{{{{6564
*
*      KEYWORD VARIABLE BLOCK (KVBLK)
*
*      A KVBLK IS USED TO REPRESENT A KEYWORD PSEUDO-VARIABLE.
*      A KVBLK IS BUILT FOR EACH KEYWORD REFERENCE (KWNAM).
*
*           +------------------------------------+
*           I                KVTYP               I
*           +------------------------------------+
*           I                KVVAR               I
*           +------------------------------------+
*           I                KVNUM               I
*           +------------------------------------+
*
{KVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$KVT{6579
{KVVAR{EQU{24,KVTYP+1{{{POINTER TO DUMMY BLOCK TRBKV{6580
{KVNUM{EQU{24,KVVAR+1{{{KEYWORD NUMBER{6581
{KVSI${EQU{24,KVNUM+1{{{SIZE OF KVBLK{6582
*
*      THE NAME OF A KEYWORD VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE KVBLK AND AN OFFSET OF KVVAR. THE
*      VALUE APPEARS TO BE TRAPPED BY THE POINTER TO TRBKV.
{{EJC{{{{{6587
*
*      NAME BLOCK (NMBLK)
*
*      A NAME BLOCK IS USED WHEREVER A NAME MUST BE STORED AS
*      A VALUE FOLLOWING USE OF THE UNARY DOT OPERATOR.
*
*           +------------------------------------+
*           I                NMTYP               I
*           +------------------------------------+
*           I                NMBAS               I
*           +------------------------------------+
*           I                NMOFS               I
*           +------------------------------------+
*
{NMTYP{EQU{24,0{{{PTR TO ROUTINE B$NML TO LOAD NAME{6602
{NMBAS{EQU{24,NMTYP+1{{{BASE POINTER FOR VARIABLE{6603
{NMOFS{EQU{24,NMBAS+1{{{OFFSET FOR VARIABLE{6604
{NMSI${EQU{24,NMOFS+1{{{SIZE OF NMBLK{6605
*
*      THE ACTUAL FIELD REPRESENTING THE CONTENTS OF THE NAME
*      IS FOUND NMOFS BYTES PAST THE ADDRESS IN NMBAS.
*
*      THE NAME IS SPLIT INTO BASE AND OFFSET FORM TO AVOID
*      CREATION OF A POINTER INTO THE MIDDLE OF A BLOCK WHICH
*      COULD NOT BE HANDLED PROPERLY BY THE GARBAGE COLLECTOR.
*
*      A NAME MAY BE BUILT FOR ANY VARIABLE (SEE SECTION ON
*      REPRESENTATIONS OF VARIABLES) THIS INCLUDES THE
*      CASES OF PSEUDO-VARIABLES.
{{EJC{{{{{6617
*
*      PATTERN BLOCK, NO PARAMETERS (P0BLK)
*
*      A P0BLK IS USED TO REPRESENT PATTERN NODES WHICH DO
*      NOT REQUIRE THE USE OF ANY PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*
{PCODE{EQU{24,0{{{PTR TO MATCH ROUTINE (P$XXX){6630
{PTHEN{EQU{24,PCODE+1{{{POINTER TO SUBSEQUENT NODE{6631
{PASI${EQU{24,PTHEN+1{{{SIZE OF P0BLK{6632
*
*      PTHEN POINTS TO THE PATTERN BLOCK FOR THE SUBSEQUENT
*      NODE TO BE MATCHED. THIS IS A POINTER TO THE PATTERN
*      BLOCK NDNTH IF THERE IS NO SUBSEQUENT (END OF PATTERN)
*
*      PCODE IS A POINTER TO THE MATCH ROUTINE FOR THE NODE.
{{EJC{{{{{6639
*
*      PATTERN BLOCK (ONE PARAMETER)
*
*      A P1BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE ONE PARAMETER VALUE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*
{PARM1{EQU{24,PTHEN+1{{{FIRST PARAMETER VALUE{6654
{PBSI${EQU{24,PARM1+1{{{SIZE OF P1BLK IN WORDS{6655
*
*      SEE P0BLK FOR DEFINITIONS OF PCODE, PTHEN
*
*      PARM1 CONTAINS A PARAMETER VALUE USED IN MATCHING THE
*      NODE. FOR EXAMPLE, IN A LEN PATTERN, IT IS THE INTEGER
*      ARGUMENT TO LEN. THE DETAILS OF THE USE OF THE PARAMETER
*      FIELD ARE INCLUDED IN THE DESCRIPTION OF THE INDIVIDUAL
*      MATCH ROUTINES. PARM1 IS ALWAYS AN ADDRESS POINTER WHICH
*      IS PROCESSED BY THE GARBAGE COLLECTOR.
{{EJC{{{{{6665
*
*      PATTERN BLOCK (TWO PARAMETERS)
*
*      A P2BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE TWO PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
{PARM2{EQU{24,PARM1+1{{{SECOND PARAMETER VALUE{6682
{PCSI${EQU{24,PARM2+1{{{SIZE OF P2BLK IN WORDS{6683
*
*      SEE P1BLK FOR DEFINITIONS OF PCODE, PTHEN, PARM1
*
*      PARM2 IS A PARAMETER WHICH PERFORMS THE SAME SORT OF
*      FUNCTION AS PARM1 (SEE DESCRIPTION OF P1BLK).
*
*      PARM2 IS A NON-RELOCATABLE FIELD AND IS NOT
*      PROCESSED BY THE GARBAGE COLLECTOR. ACCORDINGLY, IT MAY
*      NOT CONTAIN A POINTER TO A BLOCK IN DYNAMIC MEMORY.
{{EJC{{{{{6693
*
*      PROGRAM-DEFINED DATATYPE BLOCK
*
*      A PDBLK REPRESENTS THE DATA ITEM FORMED BY A CALL TO A
*      DATATYPE FUNCTION AS DEFINED BY THE SYSTEM FUNCTION DATA.
*
*           +------------------------------------+
*           I                PDTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                PDDFP               I
*           +------------------------------------+
*           /                                    /
*           /                PDFLD               /
*           /                                    /
*           +------------------------------------+
*
{PDTYP{EQU{24,0{{{PTR TO DUMMY ROUTINE B$PDT{6712
{PDDFP{EQU{24,IDVAL+1{{{PTR TO ASSOCIATED DFBLK{6713
{PDFLD{EQU{24,PDDFP+1{{{START OF FIELD VALUE POINTERS{6714
{PDFOF{EQU{24,DFFLD-PDFLD{{{DIFFERENCE IN OFFSET TO FIELD PTRS{6715
{PDSI${EQU{24,PDFLD{{{SIZE OF STANDARD FIELDS IN PDBLK{6716
{PDDFS{EQU{24,DFSI$-PDSI${{{DIFFERENCE IN DFBLK, PDBLK SIZES{6717
*
*      THE PDDFP POINTER MAY BE USED TO DETERMINE THE DATATYPE
*      AND THE NAMES OF THE FIELDS IF REQUIRED. THE DFBLK ALSO
*      CONTAINS THE LENGTH OF THE PDBLK IN BYTES (FIELD DFPDL).
*      PDDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      PDFLD VALUES ARE STORED IN ORDER FROM LEFT TO RIGHT.
*      THEY CONTAIN VALUES OR POINTERS TO TRBLK CHAINS.
{{EJC{{{{{6726
*
*      PROGRAM DEFINED FUNCTION BLOCK (PFBLK)
*
*      A PFBLK IS CREATED FOR EACH CALL TO THE DEFINE FUNCTION
*      AND A POINTER TO THE PFBLK PLACED IN THE PROPER VRBLK.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                PFLEN               I
*           +------------------------------------+
*           I                PFVBL               I
*           +------------------------------------+
*           I                PFNLO               I
*           +------------------------------------+
*           I                PFCOD               I
*           +------------------------------------+
*           I                PFCTR               I
*           +------------------------------------+
*           I                PFRTR               I
*           +------------------------------------+
*           /                                    /
*           /                PFARG               /
*           /                                    /
*           +------------------------------------+
*
{PFLEN{EQU{24,FARGS+1{{{LENGTH OF PFBLK IN BYTES{6755
{PFVBL{EQU{24,PFLEN+1{{{POINTER TO VRBLK FOR FUNCTION NAME{6756
{PFNLO{EQU{24,PFVBL+1{{{NUMBER OF LOCALS{6757
{PFCOD{EQU{24,PFNLO+1{{{PTR TO VRBLK FOR ENTRY LABEL{6758
{PFCTR{EQU{24,PFCOD+1{{{TRBLK PTR IF CALL TRACED ELSE 0{6759
{PFRTR{EQU{24,PFCTR+1{{{TRBLK PTR IF RETURN TRACED ELSE 0{6760
{PFARG{EQU{24,PFRTR+1{{{VRBLK PTRS FOR ARGUMENTS AND LOCALS{6761
{PFAGB{EQU{24,PFARG-1{{{OFFSET BEHIND PFARG FOR ARG, LOCAL{6762
{PFSI${EQU{24,PFARG{{{NUMBER OF STANDARD FIELDS IN PFBLK{6763
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$PFC.
*
*      PFARG IS STORED IN THE FOLLOWING ORDER.
*
*           ARGUMENTS (LEFT TO RIGHT)
*           LOCALS (LEFT TO RIGHT)
{{EJC{{{{{6773
*
*      REAL CONSTANT BLOCK (RCBLK)
*
*      AN RCBLK IS CREATED FOR EVERY REAL REFERENCED OR
*      CREATED BY A PROGRAM.
*
*           +------------------------------------+
*           I                RCGET               I
*           +------------------------------------+
*           *                RCVAL               *
*           +------------------------------------+
*
{RCGET{EQU{24,0{{{PTR TO ROUTINE B$RCL TO LOAD REAL{6786
{RCVAL{EQU{24,RCGET+1{{{REAL VALUE{6787
{RCSI${EQU{24,RCVAL+CFP$R{{{SIZE OF RCBLK{6788
*
*      THE LENGTH OF THE RCVAL FIELD IS CFP$R.
{{EJC{{{{{6792
*
*      STRING CONSTANT BLOCK (SCBLK)
*
*      AN SCBLK IS BUILT FOR EVERY STRING REFERENCED OR CREATED
*      BY A PROGRAM.
*
*           +------------------------------------+
*           I                SCGET               I
*           +------------------------------------+
*           I                SCLEN               I
*           +------------------------------------+
*           /                                    /
*           /                SCHAR               /
*           /                                    /
*           +------------------------------------+
*
{SCGET{EQU{24,0{{{PTR TO ROUTINE B$SCL TO LOAD STRING{6809
{SCLEN{EQU{24,SCGET+1{{{LENGTH OF STRING IN CHARACTERS{6810
{SCHAR{EQU{24,SCLEN+1{{{CHARACTERS OF STRING{6811
{SCSI${EQU{24,SCHAR{{{SIZE OF STANDARD FIELDS IN SCBLK{6812
*
*      THE CHARACTERS OF THE STRING ARE STORED LEFT JUSTIFIED.
*      THE FINAL WORD IS PADDED ON THE RIGHT WITH ZEROS.
*      (I.E. THE CHARACTER WHOSE INTERNAL CODE IS ZERO).
*
*      THE VALUE OF SCLEN MAY NOT EXCEED MXLEN. THIS ENSURES
*      THAT CHARACTER OFFSETS (E.G. THE PATTERN MATCH CURSOR)
*      CAN BE CORRECTLY PROCESSED BY THE GARBAGE COLLECTOR.
*
*      NOTE THAT THE OFFSET TO THE CHARACTERS OF THE STRING
*      IS GIVEN IN BYTES BY CFP$F AND THAT THIS VALUE IS
*      AUTOMATICALLY ALLOWED FOR IN PLC, PSC.
*      NOTE THAT FOR A SPITBOL SCBLK, THE VALUE OF CFP$F
*      IS GIVEN BY CFP$B*SCHAR.
{{EJC{{{{{6827
*
*      SIMPLE EXPRESSION BLOCK (SEBLK)
*
*      AN SEBLK IS USED TO REPRESENT AN EXPRESSION OF THE FORM
*      *(NATURAL VARIABLE). ALL OTHER EXPRESSIONS ARE EXBLKS.
*
*           +------------------------------------+
*           I                SETYP               I
*           +------------------------------------+
*           I                SEVAR               I
*           +------------------------------------+
*
{SETYP{EQU{24,0{{{PTR TO ROUTINE B$SEL TO LOAD EXPR{6840
{SEVAR{EQU{24,SETYP+1{{{PTR TO VRBLK FOR VARIABLE{6841
{SESI${EQU{24,SEVAR+1{{{LENGTH OF SEBLK IN WORDS{6842
{{EJC{{{{{6843
*
*      STANDARD VARIABLE BLOCK (SVBLK)
*
*      AN SVBLK IS ASSEMBLED IN THE CONSTANT SECTION FOR EACH
*      VARIABLE WHICH SATISFIES ONE OF THE FOLLOWING CONDITIONS.
*
*      1)   IT IS THE NAME OF A SYSTEM FUNCTION
*      2)   IT HAS AN INITIAL VALUE
*      3)   IT HAS A KEYWORD ASSOCIATION
*      4)   IT HAS A STANDARD I/O ASSOCIATION
*      6)   IT HAS A STANDARD LABEL ASSOCIATION
*
*      IF VRBLKS ARE CONSTRUCTED FOR ANY OF THESE VARIABLES,
*      THEN THE VRSVP FIELD POINTS TO THE SVBLK (SEE VRBLK)
*
*           +------------------------------------+
*           I                SVBIT               I
*           +------------------------------------+
*           I                SVLEN               I
*           +------------------------------------+
*           /                SVCHS               /
*           +------------------------------------+
*           I                SVKNM               I
*           +------------------------------------+
*           I                SVFNC               I
*           +------------------------------------+
*           I                SVNAR               I
*           +------------------------------------+
*           I                SVLBL               I
*           +------------------------------------+
*           I                SVVAL               I
*           +------------------------------------+
{{EJC{{{{{6876
*
*      STANDARD VARIABLE BLOCK (CONTINUED)
*
{SVBIT{EQU{24,0{{{BIT STRING INDICATING ATTRIBUTES{6880
{SVLEN{EQU{24,1{{{(=SCLEN) LENGTH OF NAME IN CHARS{6881
{SVCHS{EQU{24,2{{{(=SCHAR) CHARACTERS OF NAME{6882
{SVSI${EQU{24,2{{{NUMBER OF STANDARD FIELDS IN SVBLK{6883
{SVPRE{EQU{24,1{{{SET IF PREEVALUATION PERMITTED{6884
{SVFFC{EQU{24,SVPRE+SVPRE{{{SET ON IF FAST CALL PERMITTED{6885
{SVCKW{EQU{24,SVFFC+SVFFC{{{SET ON IF KEYWORD VALUE CONSTANT{6886
{SVPRD{EQU{24,SVCKW+SVCKW{{{SET ON IF PREDICATE FUNCTION{6887
{SVNBT{EQU{24,4{{{NUMBER OF BITS TO RIGHT OF SVKNM{6888
{SVKNM{EQU{24,SVPRD+SVPRD{{{SET ON IF KEYWORD ASSOCIATION{6889
{SVFNC{EQU{24,SVKNM+SVKNM{{{SET ON IF SYSTEM FUNCTION{6890
{SVNAR{EQU{24,SVFNC+SVFNC{{{SET ON IF SYSTEM FUNCTION{6891
{SVLBL{EQU{24,SVNAR+SVNAR{{{SET ON IF SYSTEM LABEL{6892
{SVVAL{EQU{24,SVLBL+SVLBL{{{SET ON IF PREDEFINED VALUE{6893
*
*      NOTE THAT THE LAST FIVE BITS CORRESPOND IN ORDER
*      TO THE FIELDS WHICH ARE PRESENT (SEE PROCEDURE GTNVR).
*
*      THE FOLLOWING DEFINITIONS ARE USED IN THE SVBLK TABLE
*
{SVFNF{EQU{24,SVFNC+SVNAR{{{FUNCTION WITH NO FAST CALL{6900
{SVFNN{EQU{24,SVFNF+SVFFC{{{FUNCTION WITH FAST CALL, NO PREEVAL{6901
{SVFNP{EQU{24,SVFNN+SVPRE{{{FUNCTION ALLOWING PREEVALUATION{6902
{SVFPR{EQU{24,SVFNN+SVPRD{{{PREDICATE FUNCTION{6903
{SVFNK{EQU{24,SVFNN+SVKNM{{{NO PREEVAL FUNC + KEYWORD{6904
{SVKWV{EQU{24,SVKNM+SVVAL{{{KEYWORD + VALUE{6905
{SVKWC{EQU{24,SVCKW+SVKNM{{{KEYWORD WITH CONSTANT VALUE{6906
{SVKVC{EQU{24,SVKWV+SVCKW{{{CONSTANT KEYWORD + VALUE{6907
{SVKVL{EQU{24,SVKVC+SVLBL{{{CONSTANT KEYWORD + VALUE + LABEL{6908
{SVFPK{EQU{24,SVFNP+SVKVC{{{PREEVAL FCN + CONST KEYWD + VAL{6909
*
*      THE SVPRE BIT ALLOWS THE COMPILER TO PREEVALUATE A CALL
*      TO THE ASSOCIATED SYSTEM FUNCTION IF ALL THE ARGUMENTS
*      ARE THEMSELVES CONSTANTS. FUNCTIONS IN THIS CATEGORY
*      MUST HAVE NO SIDE EFFECTS AND MUST NEVER CAUSE FAILURE.
*      THE CALL MAY GENERATE AN ERROR CONDITION.
*
*      THE SVFFC BIT ALLOWS THE COMPILER TO GENERATE THE SPECIAL
*      FAST CALL AFTER ADJUSTING THE NUMBER OF ARGUMENTS. ONLY
*      THE ITEM AND APPLY FUNCTIONS FALL OUTSIDE THIS CATEGORY.
*
*      THE SVCKW BIT IS SET IF THE ASSOCIATED KEYWORD VALUE IS
*      A CONSTANT, THUS ALLOWING PREEVALUATION FOR A VALUE CALL.
*
*      THE SVPRD BIT IS SET ON FOR ALL PREDICATE FUNCTIONS TO
*      ENABLE THE SPECIAL CONCATENATION CODE OPTIMIZATION.
{{EJC{{{{{6926
*
*      SVBLK (CONTINUED)
*
*      SVKNM                 KEYWORD NUMBER
*
*           SVKNM IS PRESENT ONLY FOR A STANDARD KEYWORD ASSOC.
*           IT CONTAINS A KEYWORD NUMBER AS DEFINED BY THE
*           KEYWORD NUMBER TABLE GIVEN LATER ON.
*
*      SVFNC                 SYSTEM FUNCTION POINTER
*
*           SVFNC IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS A POINTER TO THE ACTUAL CODE FOR THE SYSTEM
*           FUNCTION. THE GENERATED CODE FOR A FAST CALL IS A
*           POINTER TO THE SVFNC FIELD OF THE SVBLK FOR THE
*           FUNCTION. THE VRFNC FIELD OF THE VRBLK POINTS TO
*           THIS SAME FIELD, IN WHICH CASE, IT SERVES AS THE
*           FCODE FIELD FOR THE FUNCTION CALL.
*
*      SVNAR                 NUMBER OF FUNCTION ARGUMENTS
*
*           SVNAR IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS THE NUMBER OF ARGUMENTS REQUIRED FOR A CALL
*           TO THE SYSTEM FUNCTION. THE COMPILER USES THIS
*           VALUE TO ADJUST THE NUMBER OF ARGUMENTS IN A FAST
*           CALL AND IN THE CASE OF A FUNCTION CALLED THROUGH
*           THE VRFNC FIELD OF THE VRBLK, THE SVNAR FIELD
*           SERVES AS THE FARGS FIELD FOR O$FNC. A SPECIAL
*           CASE OCCURS IF THIS VALUE IS SET TO 999. THIS IS
*           USED TO INDICATE THAT THE FUNCTION HAS A VARIABLE
*           NUMBER OF ARGUMENTS AND CAUSES O$FNC TO PASS CONTROL
*           WITHOUT ADJUSTING THE ARGUMENT COUNT. THE ONLY
*           PREDEFINED FUNCTIONS USING THIS ARE APPLY AND ITEM.
*
*      SVLBL                 SYSTEM LABEL POINTER
*
*           SVLBL IS PRESENT ONLY FOR A STANDARD LABEL ASSOC.
*           IT IS A POINTER TO A SYSTEM LABEL ROUTINE (L$XXX).
*           THE VRLBL FIELD OF THE CORRESPONDING VRBLK POINTS TO
*           THE SVLBL FIELD OF THE SVBLK.
*
*      SVVAL                 SYSTEM VALUE POINTER
*
*           SVVAL IS PRESENT ONLY FOR A STANDARD VALUE.
*           IT IS A POINTER TO THE PATTERN NODE (NDXXX) WHICH
*           IS THE STANDARD INITIAL VALUE OF THE VARIABLE.
*           THIS VALUE IS COPIED TO THE VRVAL FIELD OF THE VRBLK
{{EJC{{{{{6974
*
*      SVBLK (CONTINUED)
*
*      KEYWORD NUMBER TABLE
*
*      THE FOLLOWING TABLE GIVES SYMBOLIC NAMES FOR KEYWORD
*      NUMBERS. THESE VALUES ARE STORED IN THE SVKNM FIELD OF
*      SVBLKS AND IN THE KVNUM FIELD OF KVBLKS. SEE ALSO
*      PROCEDURES ASIGN, ACESS AND KWNAM.
*
*      UNPROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K$ABE{EQU{24,0{{{ABEND{6987
{K$ANC{EQU{24,K$ABE+CFP$B{{{ANCHOR{6988
{K$CAS{EQU{24,K$ANC+CFP$B{{{CASE{6990
{K$COD{EQU{24,K$CAS+CFP$B{{{CODE{6991
{K$COM{EQU{24,K$COD+CFP$B{{{COMPARE{6996
{K$DMP{EQU{24,K$COM+CFP$B{{{DUMP{6997
{K$ERL{EQU{24,K$DMP+CFP$B{{{ERRLIMIT{7001
{K$ERT{EQU{24,K$ERL+CFP$B{{{ERRTYPE{7002
{K$FTR{EQU{24,K$ERT+CFP$B{{{FTRACE{7003
{K$FLS{EQU{24,K$FTR+CFP$B{{{FULLSCAN{7004
{K$INP{EQU{24,K$FLS+CFP$B{{{INPUT{7005
{K$MXL{EQU{24,K$INP+CFP$B{{{MAXLENGTH{7006
{K$OUP{EQU{24,K$MXL+CFP$B{{{OUTPUT{7007
{K$PFL{EQU{24,K$OUP+CFP$B{{{PROFILE{7011
{K$TRA{EQU{24,K$PFL+CFP$B{{{TRACE{7012
{K$TRM{EQU{24,K$TRA+CFP$B{{{TRIM{7014
*
*      PROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K$FNC{EQU{24,K$TRM+CFP$B{{{FNCLEVEL{7018
{K$LST{EQU{24,K$FNC+CFP$B{{{LASTNO{7019
{K$LLN{EQU{24,K$LST+CFP$B{{{LASTLINE{7021
{K$LIN{EQU{24,K$LLN+CFP$B{{{LINE{7022
{K$STN{EQU{24,K$LIN+CFP$B{{{STNO{7023
*
*      KEYWORDS WITH CONSTANT PATTERN VALUES
*
{K$ABO{EQU{24,K$STN+CFP$B{{{ABORT{7030
{K$ARB{EQU{24,K$ABO+PASI${{{ARB{7031
{K$BAL{EQU{24,K$ARB+PASI${{{BAL{7032
{K$FAL{EQU{24,K$BAL+PASI${{{FAIL{7033
{K$FEN{EQU{24,K$FAL+PASI${{{FENCE{7034
{K$REM{EQU{24,K$FEN+PASI${{{REM{7035
{K$SUC{EQU{24,K$REM+PASI${{{SUCCEED{7036
{{EJC{{{{{7037
*
*      KEYWORD NUMBER TABLE (CONTINUED)
*
*      SPECIAL KEYWORDS
*
{K$ALP{EQU{24,K$SUC+1{{{ALPHABET{7043
{K$RTN{EQU{24,K$ALP+1{{{RTNTYPE{7044
{K$STC{EQU{24,K$RTN+1{{{STCOUNT{7045
{K$ETX{EQU{24,K$STC+1{{{ERRTEXT{7046
{K$FIL{EQU{24,K$ETX+1{{{FILE{7048
{K$LFL{EQU{24,K$FIL+1{{{LASTFILE{7049
{K$STL{EQU{24,K$LFL+1{{{STLIMIT{7050
{K$LCS{EQU{24,K$STL+1{{{LCASE{7055
{K$UCS{EQU{24,K$LCS+1{{{UCASE{7056
*
*      RELATIVE OFFSETS OF SPECIAL KEYWORDS
*
{K$$AL{EQU{24,K$ALP-K$ALP{{{ALPHABET{7061
{K$$RT{EQU{24,K$RTN-K$ALP{{{RTNTYPE{7062
{K$$SC{EQU{24,K$STC-K$ALP{{{STCOUNT{7063
{K$$ET{EQU{24,K$ETX-K$ALP{{{ERRTEXT{7064
{K$$FL{EQU{24,K$FIL-K$ALP{{{FILE{7066
{K$$LF{EQU{24,K$LFL-K$ALP{{{LASTFILE{7067
{K$$SL{EQU{24,K$STL-K$ALP{{{STLIMIT{7069
{K$$LC{EQU{24,K$LCS-K$ALP{{{LCASE{7071
{K$$UC{EQU{24,K$UCS-K$ALP{{{UCASE{7072
{K$$N${EQU{24,K$$UC+1{{{NUMBER OF SPECIAL CASES{7073
*
*      SYMBOLS USED IN ASIGN AND ACESS PROCEDURES
*
{K$P$${EQU{24,K$FNC{{{FIRST PROTECTED KEYWORD{7080
{K$V$${EQU{24,K$ABO{{{FIRST KEYWORD WITH CONSTANT VALUE{7081
{K$S$${EQU{24,K$ALP{{{FIRST KEYWORD WITH SPECIAL ACESS{7082
{{EJC{{{{{7083
*
*      FORMAT OF A TABLE BLOCK (TBBLK)
*
*      A TABLE BLOCK IS USED TO REPRESENT A TABLE VALUE.
*      IT IS BUILT BY A CALL TO THE TABLE OR CONVERT FUNCTIONS.
*
*           +------------------------------------+
*           I                TBTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                TBLEN               I
*           +------------------------------------+
*           I                TBINV               I
*           +------------------------------------+
*           /                                    /
*           /                TBBUK               /
*           /                                    /
*           +------------------------------------+
*
{TBTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TBT{7104
{TBLEN{EQU{24,OFFS2{{{LENGTH OF TBBLK IN BYTES{7105
{TBINV{EQU{24,OFFS3{{{DEFAULT INITIAL LOOKUP VALUE{7106
{TBBUK{EQU{24,TBINV+1{{{START OF HASH BUCKET POINTERS{7107
{TBSI${EQU{24,TBBUK{{{SIZE OF STANDARD FIELDS IN TBBLK{7108
{TBNBK{EQU{24,11{{{DEFAULT NO. OF BUCKETS{7109
*
*      THE TABLE BLOCK IS A HASH TABLE WHICH POINTS TO CHAINS
*      OF TABLE ELEMENT BLOCKS REPRESENTING THE ELEMENTS
*      IN THE TABLE WHICH HASH INTO THE SAME BUCKET.
*
*      TBBUK ENTRIES EITHER POINT TO THE FIRST TEBLK ON THE
*      CHAIN OR THEY POINT TO THE TBBLK ITSELF TO INDICATE THE
*      END OF THE CHAIN.
{{EJC{{{{{7118
*
*      TABLE ELEMENT BLOCK (TEBLK)
*
*      A TABLE ELEMENT IS USED TO REPRESENT A SINGLE ENTRY IN
*      A TABLE (SEE DESCRIPTION OF TBBLK FORMAT FOR HASH TABLE)
*
*           +------------------------------------+
*           I                TETYP               I
*           +------------------------------------+
*           I                TESUB               I
*           +------------------------------------+
*           I                TEVAL               I
*           +------------------------------------+
*           I                TENXT               I
*           +------------------------------------+
*
{TETYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TET{7135
{TESUB{EQU{24,TETYP+1{{{SUBSCRIPT VALUE{7136
{TEVAL{EQU{24,TESUB+1{{{(=VRVAL) TABLE ELEMENT VALUE{7137
{TENXT{EQU{24,TEVAL+1{{{LINK TO NEXT TEBLK{7138
*      SEE S$CNV WHERE RELATION IS ASSUMED WITH TENXT AND TBBUK
{TESI${EQU{24,TENXT+1{{{SIZE OF TEBLK IN WORDS{7140
*
*      TENXT POINTS TO THE NEXT TEBLK ON THE HASH CHAIN FROM THE
*      TBBUK CHAIN FOR THIS HASH INDEX. AT THE END OF THE CHAIN,
*      TENXT POINTS BACK TO THE START OF THE TBBLK.
*
*      TEVAL CONTAINS A DATA POINTER OR A TRBLK POINTER.
*
*      TESUB CONTAINS A DATA POINTER.
{{EJC{{{{{7149
*
*      TRAP BLOCK (TRBLK)
*
*      A TRAP BLOCK IS USED TO REPRESENT A TRACE OR INPUT OR
*      OUTPUT ASSOCIATION IN RESPONSE TO A CALL TO THE TRACE
*      INPUT OR OUTPUT SYSTEM FUNCTIONS. SEE BELOW FOR DETAILS
*
*           +------------------------------------+
*           I                TRIDN               I
*           +------------------------------------+
*           I                TRTYP               I
*           +------------------------------------+
*           I  TRVAL OR TRLBL OR TRNXT OR TRKVR  I
*           +------------------------------------+
*           I       TRTAG OR TRTER OR TRTRF      I
*           +------------------------------------+
*           I            TRFNC OR TRFPT          I
*           +------------------------------------+
*
{TRIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TRT{7169
{TRTYP{EQU{24,TRIDN+1{{{TRAP TYPE CODE{7170
{TRVAL{EQU{24,TRTYP+1{{{VALUE OF TRAPPED VARIABLE (=VRVAL){7171
{TRNXT{EQU{24,TRVAL{{{PTR TO NEXT TRBLK ON TRBLK CHAIN{7172
{TRLBL{EQU{24,TRVAL{{{PTR TO ACTUAL LABEL (TRACED LABEL){7173
{TRKVR{EQU{24,TRVAL{{{VRBLK POINTER FOR KEYWORD TRACE{7174
{TRTAG{EQU{24,TRVAL+1{{{TRACE TAG{7175
{TRTER{EQU{24,TRTAG{{{PTR TO TERMINAL VRBLK OR NULL{7176
{TRTRF{EQU{24,TRTAG{{{PTR TO TRBLK HOLDING FCBLK PTR{7177
{TRFNC{EQU{24,TRTAG+1{{{TRACE FUNCTION VRBLK (ZERO IF NONE){7178
{TRFPT{EQU{24,TRFNC{{{FCBLK PTR FOR SYSIO{7179
{TRSI${EQU{24,TRFNC+1{{{NUMBER OF WORDS IN TRBLK{7180
*
{TRTIN{EQU{24,0{{{TRACE TYPE FOR INPUT ASSOCIATION{7182
{TRTAC{EQU{24,TRTIN+1{{{TRACE TYPE FOR ACCESS TRACE{7183
{TRTVL{EQU{24,TRTAC+1{{{TRACE TYPE FOR VALUE TRACE{7184
{TRTOU{EQU{24,TRTVL+1{{{TRACE TYPE FOR OUTPUT ASSOCIATION{7185
{TRTFC{EQU{24,TRTOU+1{{{TRACE TYPE FOR FCBLK IDENTIFICATION{7186
{{EJC{{{{{7187
*
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE INPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR INPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      VARIABLE ACCESS TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTAC
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      VARIABLE VALUE TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTVL
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{7229
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE OUTPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTOU
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR OUTPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      FUNCTION CALL TRACE
*
*           THE PFCTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      FUNCTION RETURN TRACE
*
*           THE PFRTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      LABEL TRACE
*
*           THE VRLBL OF THE VRBLK FOR THE LABEL IS
*           CHANGED TO POINT TO A TRBLK AND THE VRTRA FIELD IS
*           SET TO B$VRT TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRLBL POINTS TO THE ACTUAL LABEL (CDBLK) VALUE
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{7277
*
*      TRAP BLOCK (CONTINUED)
*
*      KEYWORD TRACE
*
*           KEYWORDS WHICH CAN BE TRACED POSSESS A UNIQUE
*           LOCATION WHICH IS ZERO IF THERE IS NO TRACE AND
*           POINTS TO A TRBLK IF THERE IS A TRACE. THE LOCATIONS
*           ARE AS FOLLOWS.
*
*           R$ERT            ERRTYPE
*           R$FNC            FNCLEVEL
*           R$STC            STCOUNT
*
*           THE FORMAT OF THE TRBLK IS AS FOLLOWS.
*
*           TRTYP IS SET TO TRTIN
*           TRKVR IS A POINTER TO THE VRBLK FOR THE KEYWORD
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      INPUT/OUTPUT FILE ARG1 TRAP BLOCK
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE OF
*           A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV. THIS TRAP BLOCK IS USED
*           TO HOLD A POINTER TO THE FCBLK WHICH AN
*           IMPLEMENTATION MAY REQUEST TO HOLD INFORMATION
*           ABOUT A FILE.
*
*           TRTYP IS SET TO TRTFC
*           TRNEXT POINTS TO NEXT TRBLK OR TRVAL IS VARIABLE VAL
*           TRFNM IS 0
*           TRFPT IS THE FCBLK POINTER.
*
*      NOTE THAT WHEN MULTIPLE TRAPS ARE SET ON A VARIABLE
*      THE ORDER IS IN ASCENDING VALUE OF TRTYP FIELD.
*
*      INPUT ASSOCIATION (IF PRESENT)
*      ACCESS TRACE (IF PRESENT)
*      VALUE TRACE (IF PRESENT)
*      OUTPUT ASSOCIATION (IF PRESENT)
*
*      THE ACTUAL VALUE OF THE VARIABLE IS STORED IN THE TRVAL
*      FIELD OF THE LAST TRBLK ON THE CHAIN.
*
*      THIS IMPLEMENTATION DOES NOT PERMIT TRACE OR I/O
*      ASSOCIATIONS TO ANY OF THE PSEUDO-VARIABLES.
{{EJC{{{{{7327
*
*      VECTOR BLOCK (VCBLK)
*
*      A VCBLK IS USED TO REPRESENT AN ARRAY VALUE WHICH HAS
*      ONE DIMENSION WHOSE LOWER BOUND IS ONE. ALL OTHER ARRAYS
*      ARE REPRESENTED BY ARBLKS. A VCBLK IS CREATED BY THE
*      SYSTEM FUNCTION ARRAY (S$ARR) WHEN PASSED AN INTEGER ARG.
*
*           +------------------------------------+
*           I                VCTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                VCLEN               I
*           +------------------------------------+
*           I                VCVLS               I
*           +------------------------------------+
*
{VCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$VCT{7346
{VCLEN{EQU{24,OFFS2{{{LENGTH OF VCBLK IN BYTES{7347
{VCVLS{EQU{24,OFFS3{{{START OF VECTOR VALUES{7348
{VCSI${EQU{24,VCVLS{{{SIZE OF STANDARD FIELDS IN VCBLK{7349
{VCVLB{EQU{24,VCVLS-1{{{OFFSET ONE WORD BEHIND VCVLS{7350
{VCTBD{EQU{24,TBSI$-VCSI${{{DIFFERENCE IN SIZES - SEE PRTVL{7351
*
*      VCVLS ARE EITHER DATA POINTERS OR TRBLK POINTERS
*
*      THE DIMENSION CAN BE DEDUCED FROM VCLEN.
{{EJC{{{{{7356
*
*      VARIABLE BLOCK (VRBLK)
*
*      A VARIABLE BLOCK IS BUILT IN THE STATIC MEMORY AREA
*      FOR EVERY VARIABLE REFERENCED OR CREATED BY A PROGRAM.
*      THE ORDER OF FIELDS IS ASSUMED IN THE MODEL VRBLK STNVR.
*
*      NOTE THAT SINCE THESE BLOCKS ONLY OCCUR IN THE STATIC
*      REGION, IT IS PERMISSIBLE TO POINT TO ANY WORD IN
*      THE BLOCK AND THIS IS USED TO PROVIDE THREE DISTINCT
*      ACCESS POINTS FROM THE GENERATED CODE AS FOLLOWS.
*
*      1)   POINT TO VRGET (FIRST WORD OF VRBLK) TO LOAD THE
*           VALUE OF THE VARIABLE ONTO THE MAIN STACK.
*
*      2)   POINT TO VRSTO (SECOND WORD OF VRBLK) TO STORE THE
*           TOP STACK ELEMENT AS THE VALUE OF THE VARIABLE.
*
*      3)   POINT TO VRTRA (FOURTH WORD OF VRBLK) TO JUMP TO
*           THE LABEL ASSOCIATED WITH THE VARIABLE NAME.
*
*           +------------------------------------+
*           I                VRGET               I
*           +------------------------------------+
*           I                VRSTO               I
*           +------------------------------------+
*           I                VRVAL               I
*           +------------------------------------+
*           I                VRTRA               I
*           +------------------------------------+
*           I                VRLBL               I
*           +------------------------------------+
*           I                VRFNC               I
*           +------------------------------------+
*           I                VRNXT               I
*           +------------------------------------+
*           I                VRLEN               I
*           +------------------------------------+
*           /                                    /
*           /            VRCHS = VRSVP           /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{7399
*
*      VARIABLE BLOCK (CONTINUED)
*
{VRGET{EQU{24,0{{{POINTER TO ROUTINE TO LOAD VALUE{7403
{VRSTO{EQU{24,VRGET+1{{{POINTER TO ROUTINE TO STORE VALUE{7404
{VRVAL{EQU{24,VRSTO+1{{{VARIABLE VALUE{7405
{VRVLO{EQU{24,VRVAL-VRSTO{{{OFFSET TO VALUE FROM STORE FIELD{7406
{VRTRA{EQU{24,VRVAL+1{{{POINTER TO ROUTINE TO JUMP TO LABEL{7407
{VRLBL{EQU{24,VRTRA+1{{{POINTER TO CODE FOR LABEL{7408
{VRLBO{EQU{24,VRLBL-VRTRA{{{OFFSET TO LABEL FROM TRANSFER FIELD{7409
{VRFNC{EQU{24,VRLBL+1{{{POINTER TO FUNCTION BLOCK{7410
{VRNXT{EQU{24,VRFNC+1{{{POINTER TO NEXT VRBLK ON HASH CHAIN{7411
{VRLEN{EQU{24,VRNXT+1{{{LENGTH OF NAME (OR ZERO){7412
{VRCHS{EQU{24,VRLEN+1{{{CHARACTERS OF NAME (VRLEN GT 0){7413
{VRSVP{EQU{24,VRLEN+1{{{PTR TO SVBLK (VRLEN EQ 0){7414
{VRSI${EQU{24,VRCHS+1{{{NUMBER OF STANDARD FIELDS IN VRBLK{7415
{VRSOF{EQU{24,VRLEN-SCLEN{{{OFFSET TO DUMMY SCBLK FOR NAME{7416
{VRSVO{EQU{24,VRSVP-VRSOF{{{PSEUDO-OFFSET TO VRSVP FIELD{7417
*
*      VRGET = B$VRL IF NOT INPUT ASSOCIATED OR ACCESS TRACED
*      VRGET = B$VRA IF INPUT ASSOCIATED OR ACCESS TRACED
*
*      VRSTO = B$VRS IF NOT OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B$VRV IF OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B$VRE IF VALUE IS PROTECTED PATTERN VALUE
*
*      VRVAL POINTS TO THE APPROPRIATE VALUE UNLESS THE
*      VARIABLE IS I/O/TRACE ASSOCIATED IN WHICH CASE, VRVAL
*      POINTS TO AN APPROPRIATE TRBLK (TRAP BLOCK) CHAIN.
*
*      VRTRA = B$VRG IF THE LABEL IS NOT TRACED
*      VRTRA = B$VRT IF THE LABEL IS TRACED
*
*      VRLBL POINTS TO A CDBLK IF THERE IS A LABEL
*      VRLBL POINTS TO THE SVBLK SVLBL FIELD FOR A SYSTEM LABEL
*      VRLBL POINTS TO STNDL FOR AN UNDEFINED LABEL
*      VRLBL POINTS TO A TRBLK IF THE LABEL IS TRACED
*
*      VRFNC POINTS TO A FFBLK FOR A FIELD FUNCTION
*      VRFNC POINTS TO A DFBLK FOR A DATATYPE FUNCTION
*      VRFNC POINTS TO A PFBLK FOR A PROGRAM DEFINED FUNCTION
*      VRFNC POINTS TO A EFBLK FOR AN EXTERNAL LOADED FUNCTION
*      VRFNC POINTS TO SVFNC (SVBLK) FOR A SYSTEM FUNCTION
*      VRFNC POINTS TO STNDF IF THE FUNCTION IS UNDEFINED
*
*      VRNXT POINTS TO THE NEXT VRBLK ON THIS CHAIN UNLESS
*      THIS IS THE END OF THE CHAIN IN WHICH CASE IT IS ZERO.
*
*      VRLEN IS THE NAME LENGTH FOR A NON-SYSTEM VARIABLE.
*      VRLEN IS ZERO FOR A SYSTEM VARIABLE.
*
*      VRCHS IS THE NAME (LJRZ) IF VRLEN IS NON-ZERO.
*      VRSVP IS A PTR TO THE SVBLK IF VRLEN IS ZERO.
{{EJC{{{{{7453
*
*      FORMAT OF A NON-RELOCATABLE EXTERNAL BLOCK (XNBLK)
*
*      AN XNBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE BLOCK CONTAINS NO POINTERS TO OTHER
*      RELOCATABLE BLOCKS. AN XNBLK IS USED BY EXTERNAL FUNCTION
*      PROCESSING OR POSSIBLY FOR SYSTEM I/O ROUTINES ETC.
*      THE MACRO-SYSTEM ITSELF DOES NOT USE XNBLKS.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XNTYP               I
*           +------------------------------------+
*           I                XNLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XNDTA               /
*           /                                    /
*           +------------------------------------+
*
{XNTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$XNT{7475
{XNLEN{EQU{24,XNTYP+1{{{LENGTH OF XNBLK IN BYTES{7476
{XNDTA{EQU{24,XNLEN+1{{{DATA WORDS{7477
{XNSI${EQU{24,XNDTA{{{SIZE OF STANDARD FIELDS IN XNBLK{7478
*
*      NOTE THAT THE TERM NON-RELOCATABLE REFERS TO THE CONTENTS
*      AND NOT THE BLOCK ITSELF. AN XNBLK CAN BE MOVED AROUND IF
*      IT IS BUILT IN THE DYNAMIC MEMORY AREA.
{{EJC{{{{{7483
*
*      RELOCATABLE EXTERNAL BLOCK (XRBLK)
*
*      AN XRBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE DATA AREA IN THIS BLOCK CONSISTS ONLY
*      OF ADDRESS VALUES AND ANY ADDRESSES POINTING INTO THE
*      DYNAMIC MEMORY AREA MUST POINT TO THE START OF OTHER
*      DATA BLOCKS. SEE ALSO DESCRIPTION OF XNBLK.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XRTYP               I
*           +------------------------------------+
*           I                XRLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XRPTR               /
*           /                                    /
*           +------------------------------------+
*
{XRTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$XRT{7505
{XRLEN{EQU{24,XRTYP+1{{{LENGTH OF XRBLK IN BYTES{7506
{XRPTR{EQU{24,XRLEN+1{{{START OF ADDRESS POINTERS{7507
{XRSI${EQU{24,XRPTR{{{SIZE OF STANDARD FIELDS IN XRBLK{7508
{{EJC{{{{{7509
*
*      S$CNV (CONVERT) FUNCTION SWITCH CONSTANTS.  THE VALUES
*      ARE TIED TO THE ORDER OF THE ENTRIES IN THE SVCTB TABLE
*      AND HENCE TO THE BRANCH TABLE IN S$CNV.
*
{CNVST{EQU{24,8{{{MAX STANDARD TYPE CODE FOR CONVERT{7515
{CNVRT{EQU{24,CNVST+1{{{CONVERT CODE FOR REALS{7519
{CNVBT{EQU{24,CNVRT{{{NO BUFFERS - SAME AS REAL CODE{7522
{CNVTT{EQU{24,CNVBT+1{{{BSW CODE FOR CONVERT{7526
*
*      INPUT IMAGE LENGTH
*
{INILN{EQU{24,1024{{{DEFAULT IMAGE LENGTH FOR COMPILER{7530
{INILS{EQU{24,1024{{{IMAGE LENGTH IF -SEQU IN EFFECT{7531
*
{IONMB{EQU{24,2{{{NAME BASE USED FOR IOCHN IN SYSIO{7533
{IONMO{EQU{24,4{{{NAME OFFSET USED FOR IOCHN IN SYSIO{7534
*
*      MINIMUM VALUE FOR KEYWORD MAXLNGTH
*      SHOULD BE LARGER THAN INILN
*
{MNLEN{EQU{24,1024{{{MIN VALUE ALLOWED KEYWORD MAXLNGTH{7539
{MXERN{EQU{24,329{{{ERR NUM INADEQUATE STARTUP MEMORY{7540
*
*      IN GENERAL, MEANINGFUL MNEMONICS SHOULD BE USED FOR
*      OFFSETS. HOWEVER FOR SMALL INTEGERS USED OFTEN IN
*      LITERALS THE FOLLOWING GENERAL DEFINITIONS ARE PROVIDED.
*
{NUM01{EQU{24,1{{{{7546
{NUM02{EQU{24,2{{{{7547
{NUM03{EQU{24,3{{{{7548
{NUM04{EQU{24,4{{{{7549
{NUM05{EQU{24,5{{{{7550
{NUM06{EQU{24,6{{{{7551
{NUM07{EQU{24,7{{{{7552
{NUM08{EQU{24,8{{{{7553
{NUM09{EQU{24,9{{{{7554
{NUM10{EQU{24,10{{{{7555
{NM320{EQU{24,320{{{{7556
{NM321{EQU{24,321{{{{7557
{NINI8{EQU{24,998{{{{7558
{NINI9{EQU{24,999{{{{7559
{THSND{EQU{24,1000{{{{7560
{{EJC{{{{{7561
*
*      NUMBERS OF UNDEFINED SPITBOL OPERATORS
*
{OPBUN{EQU{24,5{{{NO. OF BINARY UNDEFINED OPS{7565
{OPUUN{EQU{24,6{{{NO OF UNARY UNDEFINED OPS{7566
*
*      OFFSETS USED IN PRTSN, PRTMI AND ACESS
*
{PRSNF{EQU{24,13{{{OFFSET USED IN PRTSN{7570
{PRTMF{EQU{24,21{{{OFFSET TO COL 21 (PRTMI){7571
{RILEN{EQU{24,1024{{{BUFFER LENGTH FOR SYSRI{7572
*
*      CODES FOR STAGES OF PROCESSING
*
{STGIC{EQU{24,0{{{INITIAL COMPILE{7576
{STGXC{EQU{24,STGIC+1{{{EXECUTION COMPILE (CODE){7577
{STGEV{EQU{24,STGXC+1{{{EXPRESSION EVAL DURING EXECUTION{7578
{STGXT{EQU{24,STGEV+1{{{EXECUTION TIME{7579
{STGCE{EQU{24,STGXT+1{{{INITIAL COMPILE AFTER END LINE{7580
{STGXE{EQU{24,STGCE+1{{{EXEC. COMPILE AFTER END LINE{7581
{STGND{EQU{24,STGCE-STGIC{{{DIFFERENCE IN STAGE AFTER END{7582
{STGEE{EQU{24,STGXE+1{{{EVAL EVALUATING EXPRESSION{7583
{STGNO{EQU{24,STGEE+1{{{NUMBER OF CODES{7584
{{EJC{{{{{7585
*
*
*      STATEMENT NUMBER PAD COUNT FOR LISTR
*
{STNPD{EQU{24,8{{{STATEMENT NO. PAD COUNT{7594
*
*      SYNTAX TYPE CODES
*
*      THESE CODES ARE RETURNED FROM THE SCANE PROCEDURE.
*
*      THEY ARE SPACED 3 APART FOR THE BENEFIT OF EXPAN.
*
{T$UOP{EQU{24,0{{{UNARY OPERATOR{7606
{T$LPR{EQU{24,T$UOP+3{{{LEFT PAREN{7607
{T$LBR{EQU{24,T$LPR+3{{{LEFT BRACKET{7608
{T$CMA{EQU{24,T$LBR+3{{{COMMA{7609
{T$FNC{EQU{24,T$CMA+3{{{FUNCTION CALL{7610
{T$VAR{EQU{24,T$FNC+3{{{VARIABLE{7611
{T$CON{EQU{24,T$VAR+3{{{CONSTANT{7612
{T$BOP{EQU{24,T$CON+3{{{BINARY OPERATOR{7613
{T$RPR{EQU{24,T$BOP+3{{{RIGHT PAREN{7614
{T$RBR{EQU{24,T$RPR+3{{{RIGHT BRACKET{7615
{T$COL{EQU{24,T$RBR+3{{{COLON{7616
{T$SMC{EQU{24,T$COL+3{{{SEMI-COLON{7617
*
*      THE FOLLOWING DEFINITIONS ARE USED ONLY IN THE GOTO FIELD
*
{T$FGO{EQU{24,T$SMC+1{{{FAILURE GOTO{7621
{T$SGO{EQU{24,T$FGO+1{{{SUCCESS GOTO{7622
*
*      THE ABOVE CODES ARE GROUPED SO THAT CODES FOR ELEMENTS
*      WHICH CAN LEGITIMATELY IMMEDIATELY PRECEDE A UNARY
*      OPERATOR COME FIRST TO FACILITATE OPERATOR SYNTAX CHECK.
*
{T$UOK{EQU{24,T$FNC{{{LAST CODE OK BEFORE UNARY OPERATOR{7628
{{EJC{{{{{7629
*
*      DEFINITIONS OF VALUES FOR EXPAN JUMP TABLE
*
{T$UO0{EQU{24,T$UOP+0{{{UNARY OPERATOR, STATE ZERO{7633
{T$UO1{EQU{24,T$UOP+1{{{UNARY OPERATOR, STATE ONE{7634
{T$UO2{EQU{24,T$UOP+2{{{UNARY OPERATOR, STATE TWO{7635
{T$LP0{EQU{24,T$LPR+0{{{LEFT PAREN, STATE ZERO{7636
{T$LP1{EQU{24,T$LPR+1{{{LEFT PAREN, STATE ONE{7637
{T$LP2{EQU{24,T$LPR+2{{{LEFT PAREN, STATE TWO{7638
{T$LB0{EQU{24,T$LBR+0{{{LEFT BRACKET, STATE ZERO{7639
{T$LB1{EQU{24,T$LBR+1{{{LEFT BRACKET, STATE ONE{7640
{T$LB2{EQU{24,T$LBR+2{{{LEFT BRACKET, STATE TWO{7641
{T$CM0{EQU{24,T$CMA+0{{{COMMA, STATE ZERO{7642
{T$CM1{EQU{24,T$CMA+1{{{COMMA, STATE ONE{7643
{T$CM2{EQU{24,T$CMA+2{{{COMMA, STATE TWO{7644
{T$FN0{EQU{24,T$FNC+0{{{FUNCTION CALL, STATE ZERO{7645
{T$FN1{EQU{24,T$FNC+1{{{FUNCTION CALL, STATE ONE{7646
{T$FN2{EQU{24,T$FNC+2{{{FUNCTION CALL, STATE TWO{7647
{T$VA0{EQU{24,T$VAR+0{{{VARIABLE, STATE ZERO{7648
{T$VA1{EQU{24,T$VAR+1{{{VARIABLE, STATE ONE{7649
{T$VA2{EQU{24,T$VAR+2{{{VARIABLE, STATE TWO{7650
{T$CO0{EQU{24,T$CON+0{{{CONSTANT, STATE ZERO{7651
{T$CO1{EQU{24,T$CON+1{{{CONSTANT, STATE ONE{7652
{T$CO2{EQU{24,T$CON+2{{{CONSTANT, STATE TWO{7653
{T$BO0{EQU{24,T$BOP+0{{{BINARY OPERATOR, STATE ZERO{7654
{T$BO1{EQU{24,T$BOP+1{{{BINARY OPERATOR, STATE ONE{7655
{T$BO2{EQU{24,T$BOP+2{{{BINARY OPERATOR, STATE TWO{7656
{T$RP0{EQU{24,T$RPR+0{{{RIGHT PAREN, STATE ZERO{7657
{T$RP1{EQU{24,T$RPR+1{{{RIGHT PAREN, STATE ONE{7658
{T$RP2{EQU{24,T$RPR+2{{{RIGHT PAREN, STATE TWO{7659
{T$RB0{EQU{24,T$RBR+0{{{RIGHT BRACKET, STATE ZERO{7660
{T$RB1{EQU{24,T$RBR+1{{{RIGHT BRACKET, STATE ONE{7661
{T$RB2{EQU{24,T$RBR+2{{{RIGHT BRACKET, STATE TWO{7662
{T$CL0{EQU{24,T$COL+0{{{COLON, STATE ZERO{7663
{T$CL1{EQU{24,T$COL+1{{{COLON, STATE ONE{7664
{T$CL2{EQU{24,T$COL+2{{{COLON, STATE TWO{7665
{T$SM0{EQU{24,T$SMC+0{{{SEMICOLON, STATE ZERO{7666
{T$SM1{EQU{24,T$SMC+1{{{SEMICOLON, STATE ONE{7667
{T$SM2{EQU{24,T$SMC+2{{{SEMICOLON, STATE TWO{7668
*
{T$NES{EQU{24,T$SM2+1{{{NUMBER OF ENTRIES IN BRANCH TABLE{7670
{{EJC{{{{{7671
*
*       DEFINITION OF OFFSETS USED IN CONTROL CARD PROCESSING
*
{CC$CA{EQU{24,0{{{-CASE{7676
{CC$DO{EQU{24,CC$CA+1{{{-DOUBLE{7677
{CC$CO{EQU{24,CC$DO+1{{{-COMPARE{7682
{CC$DU{EQU{24,CC$CO+1{{{-DUMP{7683
{CC$CP{EQU{24,CC$DU+1{{{-COPY{7688
{CC$EJ{EQU{24,CC$CP+1{{{-EJECT{7689
{CC$ER{EQU{24,CC$EJ+1{{{-ERRORS{7693
{CC$EX{EQU{24,CC$ER+1{{{-EXECUTE{7694
{CC$FA{EQU{24,CC$EX+1{{{-FAIL{7695
{CC$IN{EQU{24,CC$FA+1{{{-INCLUDE{7697
{CC$LN{EQU{24,CC$IN+1{{{-LINE{7699
{CC$LI{EQU{24,CC$LN+1{{{-LIST{7700
{CC$NR{EQU{24,CC$LI+1{{{-NOERRORS{7712
{CC$NX{EQU{24,CC$NR+1{{{-NOEXECUTE{7713
{CC$NF{EQU{24,CC$NX+1{{{-NOFAIL{7714
{CC$NL{EQU{24,CC$NF+1{{{-NOLIST{7715
{CC$NO{EQU{24,CC$NL+1{{{-NOOPT{7716
{CC$NP{EQU{24,CC$NO+1{{{-NOPRINT{7717
{CC$OP{EQU{24,CC$NP+1{{{-OPTIMISE{7718
{CC$PR{EQU{24,CC$OP+1{{{-PRINT{7719
{CC$SI{EQU{24,CC$PR+1{{{-SINGLE{7720
{CC$SP{EQU{24,CC$SI+1{{{-SPACE{7721
{CC$ST{EQU{24,CC$SP+1{{{-STITL{7722
{CC$TI{EQU{24,CC$ST+1{{{-TITLE{7723
{CC$TR{EQU{24,CC$TI+1{{{-TRACE{7724
{CC$NC{EQU{24,CC$TR+1{{{NUMBER OF CONTROL CARDS{7725
{CCNOC{EQU{24,4{{{NO. OF CHARS INCLUDED IN MATCH{7726
{CCOFS{EQU{24,7{{{OFFSET TO START OF TITLE/SUBTITLE{7727
{CCINM{EQU{24,9{{{MAX DEPTH OF INCLUDE FILE NESTING{7729
{{EJC{{{{{7731
*
*      DEFINITIONS OF STACK OFFSETS USED IN CMPIL PROCEDURE
*
*      SEE DESCRIPTION AT START OF CMPIL PROCEDURE FOR DETAILS
*      OF USE OF THESE LOCATIONS ON THE STACK.
*
{CMSTM{EQU{24,0{{{TREE FOR STATEMENT BODY{7738
{CMSGO{EQU{24,CMSTM+1{{{TREE FOR SUCCESS GOTO{7739
{CMFGO{EQU{24,CMSGO+1{{{TREE FOR FAIL GOTO{7740
{CMCGO{EQU{24,CMFGO+1{{{CONDITIONAL GOTO FLAG{7741
{CMPCD{EQU{24,CMCGO+1{{{PREVIOUS CDBLK POINTER{7742
{CMFFP{EQU{24,CMPCD+1{{{FAILURE FILL IN FLAG FOR PREVIOUS{7743
{CMFFC{EQU{24,CMFFP+1{{{FAILURE FILL IN FLAG FOR CURRENT{7744
{CMSOP{EQU{24,CMFFC+1{{{SUCCESS FILL IN OFFSET FOR PREVIOUS{7745
{CMSOC{EQU{24,CMSOP+1{{{SUCCESS FILL IN OFFSET FOR CURRENT{7746
{CMLBL{EQU{24,CMSOC+1{{{PTR TO VRBLK FOR CURRENT LABEL{7747
{CMTRA{EQU{24,CMLBL+1{{{PTR TO ENTRY CDBLK{7748
*
{CMNEN{EQU{24,CMTRA+1{{{COUNT OF STACK ENTRIES FOR CMPIL{7750
*
*      A FEW CONSTANTS USED BY THE PROFILER
{PFPD1{EQU{24,8{{{PAD POSITIONS ...{7755
{PFPD2{EQU{24,20{{{... FOR PROFILE ...{7756
{PFPD3{EQU{24,32{{{... PRINTOUT{7757
{PF$I2{EQU{24,CFP$I+CFP$I{{{SIZE OF TABLE ENTRY (2 INTS){7758
{{EJC{{{{{7761
*
*      DEFINITION OF LIMITS AND ADJUSTMENTS THAT ARE BUILT BY
*      RELCR FOR USE BY THE ROUTINES THAT RELOCATE POINTERS
*      AFTER A SAVE FILE IS RELOADED.  SEE RELOC ETC. FOR USAGE.
*
*      A BLOCK OF INFORMATION IS BUILT THAT IS USED IN
*      RELOCATING POINTERS.  THERE ARE RNSI$ INSTANCES
*      OF A RSSI$ WORD STRUCTURE.  EACH INSTANCE CORRESPONDS
*      TO ONE OF THE REGIONS THAT A POINTER MIGHT POINT INTO.
*
*      EACH STRUCTURE TAKES THE FORM:
*
*           +------------------------------------+
*           I    ADDRESS PAST END OF SECTION     I
*           +------------------------------------+
*           I  ADJUSTMENT FROM OLD TO NEW ADRS   I
*           +------------------------------------+
*           I    ADDRESS OF START OF SECTION     I
*           +------------------------------------+
*
*      THE INSTANCES ARE ORDERED THUSLY:
*
*           +------------------------------------+
*           I           DYNAMIC STORAGE          I
*           +------------------------------------+
*           I           STATIC STORAGE           I
*           +------------------------------------+
*           I       WORKING SECTION GLOBALS      I
*           +------------------------------------+
*           I          CONSTANT SECTION          I
*           +------------------------------------+
*           I            CODE SECTION            I
*           +------------------------------------+
*
*      SYMBOLIC NAMES FOR THESE LOCATIONS AS OFFSETS FROM
*      THE FIRST ENTRY ARE PROVIDED HERE.
*
*      DEFINITIONS WITHIN A SECTION
*
{RLEND{EQU{24,0{{{END{7801
{RLADJ{EQU{24,RLEND+1{{{ADJUSTMENT{7802
{RLSTR{EQU{24,RLADJ+1{{{START{7803
{RSSI${EQU{24,RLSTR+1{{{SIZE OF SECTION{7804
{RNSI${EQU{24,5{{{NUMBER OF STRUCTURES{7805
*
*      OVERALL DEFINITIONS OF ALL STRUCTURES
*
{RLDYE{EQU{24,0{{{DYNAMIC REGION END{7809
{RLDYA{EQU{24,RLDYE+1{{{DYNAMIC REGION ADJUSTMENT{7810
{RLDYS{EQU{24,RLDYA+1{{{DYNAMIC REGION START{7811
{RLSTE{EQU{24,RLDYS+1{{{STATIC REGION END{7812
{RLSTA{EQU{24,RLSTE+1{{{STATIC REGION ADJUSTMENT{7813
{RLSTS{EQU{24,RLSTA+1{{{STATIC REGION START{7814
{RLWKE{EQU{24,RLSTS+1{{{WORKING SECTION GLOBALS END{7815
{RLWKA{EQU{24,RLWKE+1{{{WORKING SECTION GLOBALS ADJUSTMENT{7816
{RLWKS{EQU{24,RLWKA+1{{{WORKING SECTION GLOBALS START{7817
{RLCNE{EQU{24,RLWKS+1{{{CONSTANTS SECTION END{7818
{RLCNA{EQU{24,RLCNE+1{{{CONSTANTS SECTION ADJUSTMENT{7819
{RLCNS{EQU{24,RLCNA+1{{{CONSTANTS SECTION START{7820
{RLCDE{EQU{24,RLCNS+1{{{CODE SECTION END{7821
{RLCDA{EQU{24,RLCDE+1{{{CODE SECTION ADJUSTMENT{7822
{RLCDS{EQU{24,RLCDA+1{{{CODE SECTION START{7823
{RLSI${EQU{24,RLCDS+1{{{NUMBER OF FIELDS IN STRUCTURE{7824
*
{{TTL{27,S P I T B O L -- CONSTANT SECTION{{{{7827
*
*      THIS SECTION CONSISTS ENTIRELY OF ASSEMBLED CONSTANTS.
*
*      ALL LABEL NAMES ARE FIVE LETTERS. THE ORDER IS
*      APPROXIMATELY ALPHABETICAL, BUT IN SOME CASES (ALWAYS
*      DOCUMENTED), CONSTANTS MUST BE PLACED IN SOME SPECIAL
*      ORDER WHICH MUST NOT BE DISTURBED.
*
*      IT MUST ALSO BE REMEMBERED THAT THERE IS A REQUIREMENT
*      FOR NO FORWARD REFERENCES WHICH ALSO DISTURBS THE
*      ALPHABETICAL ORDER IN SOME CASES.
*
{{SEC{{{{START OF CONSTANT SECTION{7840
*
*      START OF CONSTANT SECTION
*
{C$AAA{DAC{1,0{{{FIRST LOCATION OF CONSTANT SECTION{7844
*
*      FREE STORE PERCENTAGE (USED BY ALLOC)
*
{ALFSP{DAC{2,E$FSP{{{FREE STORE PERCENTAGE{7848
*
*      BIT CONSTANTS FOR GENERAL USE
*
{BITS0{DBC{1,0{{{ALL ZERO BITS{7852
{BITS1{DBC{1,1{{{ONE BIT IN LOW ORDER POSITION{7853
{BITS2{DBC{1,2{{{BIT IN POSITION 2{7854
{BITS3{DBC{1,4{{{BIT IN POSITION 3{7855
{BITS4{DBC{1,8{{{BIT IN POSITION 4{7856
{BITS5{DBC{1,16{{{BIT IN POSITION 5{7857
{BITS6{DBC{1,32{{{BIT IN POSITION 6{7858
{BITS7{DBC{1,64{{{BIT IN POSITION 7{7859
{BITS8{DBC{1,128{{{BIT IN POSITION 8{7860
{BITS9{DBC{1,256{{{BIT IN POSITION 9{7861
{BIT10{DBC{1,512{{{BIT IN POSITION 10{7862
{BIT11{DBC{1,1024{{{BIT IN POSITION 11{7863
{BIT12{DBC{1,2048{{{BIT IN POSITION 12{7864
{BITSM{DBC{2,CFP$M{{{MASK FOR MAX INTEGER{7865
*
*      BIT CONSTANTS FOR SVBLK (SVBIT FIELD) TESTS
*
{BTFNC{DBC{2,SVFNC{{{BIT TO TEST FOR FUNCTION{7869
{BTKNM{DBC{2,SVKNM{{{BIT TO TEST FOR KEYWORD NUMBER{7870
{BTLBL{DBC{2,SVLBL{{{BIT TO TEST FOR LABEL{7871
{BTFFC{DBC{2,SVFFC{{{BIT TO TEST FOR FAST CALL{7872
{BTCKW{DBC{2,SVCKW{{{BIT TO TEST FOR CONSTANT KEYWORD{7873
{BTKWV{DBC{2,SVKWV{{{BITS TO TEST FOR KEWORD WITH VALUE{7874
{BTPRD{DBC{2,SVPRD{{{BIT TO TEST FOR PREDICATE FUNCTION{7875
{BTPRE{DBC{2,SVPRE{{{BIT TO TEST FOR PREEVALUATION{7876
{BTVAL{DBC{2,SVVAL{{{BIT TO TEST FOR VALUE{7877
{{EJC{{{{{7878
*
*      LIST OF NAMES USED FOR CONTROL CARD PROCESSING
*
{CCNMS{DTC{27,/CASE/{{{{7883
{{DTC{27,/DOUB/{{{{7884
{{DTC{27,/COMP/{{{{7889
{{DTC{27,/DUMP/{{{{7891
{{DTC{27,/COPY/{{{{7893
{{DTC{27,/EJEC/{{{{7895
{{DTC{27,/ERRO/{{{{7896
{{DTC{27,/EXEC/{{{{7897
{{DTC{27,/FAIL/{{{{7898
{{DTC{27,/INCL/{{{{7900
{{DTC{27,/LINE/{{{{7903
{{DTC{27,/LIST/{{{{7905
{{DTC{27,/NOER/{{{{7906
{{DTC{27,/NOEX/{{{{7907
{{DTC{27,/NOFA/{{{{7908
{{DTC{27,/NOLI/{{{{7909
{{DTC{27,/NOOP/{{{{7910
{{DTC{27,/NOPR/{{{{7911
{{DTC{27,/OPTI/{{{{7912
{{DTC{27,/PRIN/{{{{7913
{{DTC{27,/SING/{{{{7914
{{DTC{27,/SPAC/{{{{7915
{{DTC{27,/STIT/{{{{7916
{{DTC{27,/TITL/{{{{7917
{{DTC{27,/TRAC/{{{{7918
*
*      HEADER MESSAGES FOR DUMPR PROCEDURE (SCBLK FORMAT)
*
{DMHDK{DAC{6,B$SCL{{{DUMP OF KEYWORD VALUES{7922
{{DAC{1,22{{{{7923
{{DTC{27,/Dump of Keyword Values/{{{{7924
*
{DMHDV{DAC{6,B$SCL{{{DUMP OF NATURAL VARIABLES{7926
{{DAC{1,25{{{{7927
{{DTC{27,/Dump of Natural Variables/{{{{7928
{{EJC{{{{{7929
*
*      MESSAGE TEXT FOR COMPILATION STATISTICS
*
{ENCM1{DAC{6,B$SCL{{{{7933
{{DAC{1,19{{{{7935
{{DTC{27,/Memory used (bytes)/{{{{7936
*
{ENCM2{DAC{6,B$SCL{{{{7938
{{DAC{1,19{{{{7939
{{DTC{27,/Memory left (bytes)/{{{{7940
*
{ENCM3{DAC{6,B$SCL{{{{7950
{{DAC{1,11{{{{7951
{{DTC{27,/Comp errors/{{{{7952
*
{ENCM4{DAC{6,B$SCL{{{{7954
{{DAC{1,20{{{{7959
{{DTC{27,/Comp time (millisec)/{{{{7960
*
{ENCM5{DAC{6,B$SCL{{{EXECUTION SUPPRESSED{7963
{{DAC{1,20{{{{7964
{{DTC{27,/Execution suppressed/{{{{7965
*
*      STRING CONSTANT FOR ABNORMAL END
*
{ENDAB{DAC{6,B$SCL{{{{7969
{{DAC{1,12{{{{7970
{{DTC{27,/Abnormal End/{{{{7971
{{EJC{{{{{7972
*
*      MEMORY OVERFLOW DURING INITIALISATION
*
{ENDMO{DAC{6,B$SCL{{{{7976
{ENDML{DAC{1,15{{{{7977
{{DTC{27,/Memory Overflow/{{{{7978
*
*      STRING CONSTANT FOR MESSAGE ISSUED BY L$END
*
{ENDMS{DAC{6,B$SCL{{{{7982
{{DAC{1,10{{{{7983
{{DTC{27,/Normal end/{{{{7984
*
*      FAIL MESSAGE FOR STACK FAIL SECTION
*
{ENDSO{DAC{6,B$SCL{{{STACK OVERFLOW IN GARBAGE COLLECTOR{7988
{{DAC{1,36{{{{7989
{{DTC{27,/Stack overflow in garbage collection/{{{{7990
*
*      STRING CONSTANT FOR TIME UP
*
{ENDTU{DAC{6,B$SCL{{{{7994
{{DAC{1,15{{{{7995
{{DTC{27,/Error - Time Up/{{{{7996
{{EJC{{{{{7997
*
*      STRING CONSTANT FOR ERROR MESSAGE (ERROR SECTION)
*
{ERMMS{DAC{6,B$SCL{{{ERROR{8001
{{DAC{1,5{{{{8002
{{DTC{27,/Error/{{{{8003
*
{ERMNS{DAC{6,B$SCL{{{STRING / -- /{8005
{{DAC{1,4{{{{8006
{{DTC{27,/ -- /{{{{8007
*
*      STRING CONSTANT FOR PAGE NUMBERING
*
{LSTMS{DAC{6,B$SCL{{{PAGE{8011
{{DAC{1,5{{{{8012
{{DTC{27,/Page /{{{{8013
*
*      LISTING HEADER MESSAGE
*
{HEADR{DAC{6,B$SCL{{{{8017
{{DAC{1,25{{{{8018
{{DTC{27,/Macro SPITBOL Version 3.8/{{{{8019
*
{HEADV{DAC{6,B$SCL{{{FOR EXIT() VERSION NO. CHECK{8021
{{DAC{1,5{{{{8022
{{DTC{27,/3.8.2/{{{{8023
*      FREE STORE PERCENTAGE (USED BY GBCOL)
*
{GBSDP{DAC{2,E$SED{{{SEDIMENT PERCENTAGE{8027
*
*      INTEGER CONSTANTS FOR GENERAL USE
*      ICBLD OPTIMISATION USES THE FIRST THREE.
*
{INT$R{DAC{6,B$ICL{{{{8033
{INTV0{DIC{16,+0{{{0{8034
{INTON{DAC{6,B$ICL{{{{8035
{INTV1{DIC{16,+1{{{1{8036
{INTTW{DAC{6,B$ICL{{{{8037
{INTV2{DIC{16,+2{{{2{8038
{INTVT{DIC{16,+10{{{10{8039
{INTVH{DIC{16,+100{{{100{8040
{INTTH{DIC{16,+1000{{{1000{8041
*
*      TABLE USED IN ICBLD OPTIMISATION
*
{INTAB{DAC{4,INT$R{{{POINTER TO 0{8045
{{DAC{4,INTON{{{POINTER TO 1{8046
{{DAC{4,INTTW{{{POINTER TO 2{8047
{{EJC{{{{{8048
*
*      SPECIAL PATTERN NODES. THE FOLLOWING PATTERN NODES
*      CONSIST SIMPLY OF A PCODE POINTER, SEE MATCH ROUTINES
*      (P$XXX) FOR FULL DETAILS OF THEIR USE AND FORMAT).
*
{NDABB{DAC{6,P$ABB{{{ARBNO{8054
{NDABD{DAC{6,P$ABD{{{ARBNO{8055
{NDARC{DAC{6,P$ARC{{{ARB{8056
{NDEXB{DAC{6,P$EXB{{{EXPRESSION{8057
{NDFNB{DAC{6,P$FNB{{{FENCE(){8058
{NDFND{DAC{6,P$FND{{{FENCE(){8059
{NDEXC{DAC{6,P$EXC{{{EXPRESSION{8060
{NDIMB{DAC{6,P$IMB{{{IMMEDIATE ASSIGNMENT{8061
{NDIMD{DAC{6,P$IMD{{{IMMEDIATE ASSIGNMENT{8062
{NDNTH{DAC{6,P$NTH{{{PATTERN END (NULL PATTERN){8063
{NDPAB{DAC{6,P$PAB{{{PATTERN ASSIGNMENT{8064
{NDPAD{DAC{6,P$PAD{{{PATTERN ASSIGNMENT{8065
{NDUNA{DAC{6,P$UNA{{{ANCHOR POINT MOVEMENT{8066
*
*      KEYWORD CONSTANT PATTERN NODES. THE FOLLOWING NODES ARE
*      USED AS THE VALUES OF PATTERN KEYWORDS AND THE INITIAL
*      VALUES OF THE CORRESPONDING NATURAL VARIABLES. ALL
*      NODES ARE IN P0BLK FORMAT AND THE ORDER IS TIED TO THE
*      DEFINITIONS OF CORRESPONDING K$XXX SYMBOLS.
*
{NDABO{DAC{6,P$ABO{{{ABORT{8074
{{DAC{4,NDNTH{{{{8075
{NDARB{DAC{6,P$ARB{{{ARB{8076
{{DAC{4,NDNTH{{{{8077
{NDBAL{DAC{6,P$BAL{{{BAL{8078
{{DAC{4,NDNTH{{{{8079
{NDFAL{DAC{6,P$FAL{{{FAIL{8080
{{DAC{4,NDNTH{{{{8081
{NDFEN{DAC{6,P$FEN{{{FENCE{8082
{{DAC{4,NDNTH{{{{8083
{NDREM{DAC{6,P$REM{{{REM{8084
{{DAC{4,NDNTH{{{{8085
{NDSUC{DAC{6,P$SUC{{{SUCCEED{8086
{{DAC{4,NDNTH{{{{8087
*
*      NULL STRING. ALL NULL VALUES POINT TO THIS STRING. THE
*      SVCHS FIELD CONTAINS A BLANK TO PROVIDE FOR EASY DEFAULT
*      PROCESSING IN TRACE, STOPTR, LPAD AND RPAD.
*      NULLW CONTAINS 10 BLANKS WHICH ENSURES AN ALL BLANK WORD
*      BUT FOR VERY EXCEPTIONAL MACHINES.
*
{NULLS{DAC{6,B$SCL{{{NULL STRING VALUE{8095
{{DAC{1,0{{{SCLEN = 0{8096
{NULLW{DTC{27,/          /{{{{8097
*
*
*      CONSTANT STRINGS FOR LCASE AND UCASE KEYWORDS
*
{LCASE{DAC{6,B$SCL{{{{8103
{{DAC{1,26{{{{8104
{{DTC{27,/abcdefghijklmnopqrstuvwxyz/{{{{8105
*
{UCASE{DAC{6,B$SCL{{{{8107
{{DAC{1,26{{{{8108
{{DTC{27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/{{{{8109
{{EJC{{{{{8111
*
*      OPERATOR DOPE VECTORS (SEE DVBLK FORMAT)
*
{OPDVC{DAC{6,O$CNC{{{CONCATENATION{8115
{{DAC{2,C$CNC{{{{8116
{{DAC{2,LLCNC{{{{8117
{{DAC{2,RRCNC{{{{8118
*
*      OPDVS IS USED WHEN SCANNING BELOW THE TOP LEVEL TO
*      INSURE THAT THE CONCATENATION WILL NOT BE LATER
*      MISTAKEN FOR PATTERN MATCHING
*
{OPDVP{DAC{6,O$CNC{{{CONCATENATION - NOT PATTERN MATCH{8124
{{DAC{2,C$CNP{{{{8125
{{DAC{2,LLCNC{{{{8126
{{DAC{2,RRCNC{{{{8127
*
*      NOTE THAT THE ORDER OF THE REMAINING ENTRIES IS TIED TO
*      THE ORDER OF THE CODING IN THE SCANE PROCEDURE.
*
{OPDVS{DAC{6,O$ASS{{{ASSIGNMENT{8132
{{DAC{2,C$ASS{{{{8133
{{DAC{2,LLASS{{{{8134
{{DAC{2,RRASS{{{{8135
*
{{DAC{1,6{{{UNARY EQUAL{8137
{{DAC{2,C$UUO{{{{8138
{{DAC{2,LLUNO{{{{8139
*
{{DAC{6,O$PMV{{{PATTERN MATCH{8141
{{DAC{2,C$PMT{{{{8142
{{DAC{2,LLPMT{{{{8143
{{DAC{2,RRPMT{{{{8144
*
{{DAC{6,O$INT{{{INTERROGATION{8146
{{DAC{2,C$UVL{{{{8147
{{DAC{2,LLUNO{{{{8148
*
{{DAC{1,1{{{BINARY AMPERSAND{8150
{{DAC{2,C$UBO{{{{8151
{{DAC{2,LLAMP{{{{8152
{{DAC{2,RRAMP{{{{8153
*
{{DAC{6,O$KWV{{{KEYWORD REFERENCE{8155
{{DAC{2,C$KEY{{{{8156
{{DAC{2,LLUNO{{{{8157
*
{{DAC{6,O$ALT{{{ALTERNATION{8159
{{DAC{2,C$ALT{{{{8160
{{DAC{2,LLALT{{{{8161
{{DAC{2,RRALT{{{{8162
{{EJC{{{{{8163
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,5{{{UNARY VERTICAL BAR{8167
{{DAC{2,C$UUO{{{{8168
{{DAC{2,LLUNO{{{{8169
*
{{DAC{1,0{{{BINARY AT{8171
{{DAC{2,C$UBO{{{{8172
{{DAC{2,LLATS{{{{8173
{{DAC{2,RRATS{{{{8174
*
{{DAC{6,O$CAS{{{CURSOR ASSIGNMENT{8176
{{DAC{2,C$UNM{{{{8177
{{DAC{2,LLUNO{{{{8178
*
{{DAC{1,2{{{BINARY NUMBER SIGN{8180
{{DAC{2,C$UBO{{{{8181
{{DAC{2,LLNUM{{{{8182
{{DAC{2,RRNUM{{{{8183
*
{{DAC{1,7{{{UNARY NUMBER SIGN{8185
{{DAC{2,C$UUO{{{{8186
{{DAC{2,LLUNO{{{{8187
*
{{DAC{6,O$DVD{{{DIVISION{8189
{{DAC{2,C$BVL{{{{8190
{{DAC{2,LLDVD{{{{8191
{{DAC{2,RRDVD{{{{8192
*
{{DAC{1,9{{{UNARY SLASH{8194
{{DAC{2,C$UUO{{{{8195
{{DAC{2,LLUNO{{{{8196
*
{{DAC{6,O$MLT{{{MULTIPLICATION{8198
{{DAC{2,C$BVL{{{{8199
{{DAC{2,LLMLT{{{{8200
{{DAC{2,RRMLT{{{{8201
{{EJC{{{{{8202
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,0{{{DEFERRED EXPRESSION{8206
{{DAC{2,C$DEF{{{{8207
{{DAC{2,LLUNO{{{{8208
*
{{DAC{1,3{{{BINARY PERCENT{8210
{{DAC{2,C$UBO{{{{8211
{{DAC{2,LLPCT{{{{8212
{{DAC{2,RRPCT{{{{8213
*
{{DAC{1,8{{{UNARY PERCENT{8215
{{DAC{2,C$UUO{{{{8216
{{DAC{2,LLUNO{{{{8217
*
{{DAC{6,O$EXP{{{EXPONENTIATION{8219
{{DAC{2,C$BVL{{{{8220
{{DAC{2,LLEXP{{{{8221
{{DAC{2,RREXP{{{{8222
*
{{DAC{1,10{{{UNARY EXCLAMATION{8224
{{DAC{2,C$UUO{{{{8225
{{DAC{2,LLUNO{{{{8226
*
{{DAC{6,O$IMA{{{IMMEDIATE ASSIGNMENT{8228
{{DAC{2,C$BVN{{{{8229
{{DAC{2,LLDLD{{{{8230
{{DAC{2,RRDLD{{{{8231
*
{{DAC{6,O$INV{{{INDIRECTION{8233
{{DAC{2,C$IND{{{{8234
{{DAC{2,LLUNO{{{{8235
*
{{DAC{1,4{{{BINARY NOT{8237
{{DAC{2,C$UBO{{{{8238
{{DAC{2,LLNOT{{{{8239
{{DAC{2,RRNOT{{{{8240
*
{{DAC{1,0{{{NEGATION{8242
{{DAC{2,C$NEG{{{{8243
{{DAC{2,LLUNO{{{{8244
{{EJC{{{{{8245
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{6,O$SUB{{{SUBTRACTION{8249
{{DAC{2,C$BVL{{{{8250
{{DAC{2,LLPLM{{{{8251
{{DAC{2,RRPLM{{{{8252
*
{{DAC{6,O$COM{{{COMPLEMENTATION{8254
{{DAC{2,C$UVL{{{{8255
{{DAC{2,LLUNO{{{{8256
*
{{DAC{6,O$ADD{{{ADDITION{8258
{{DAC{2,C$BVL{{{{8259
{{DAC{2,LLPLM{{{{8260
{{DAC{2,RRPLM{{{{8261
*
{{DAC{6,O$AFF{{{AFFIRMATION{8263
{{DAC{2,C$UVL{{{{8264
{{DAC{2,LLUNO{{{{8265
*
{{DAC{6,O$PAS{{{PATTERN ASSIGNMENT{8267
{{DAC{2,C$BVN{{{{8268
{{DAC{2,LLDLD{{{{8269
{{DAC{2,RRDLD{{{{8270
*
{{DAC{6,O$NAM{{{NAME REFERENCE{8272
{{DAC{2,C$UNM{{{{8273
{{DAC{2,LLUNO{{{{8274
*
*      SPECIAL DVS FOR GOTO OPERATORS (SEE PROCEDURE SCNGF)
*
{OPDVD{DAC{6,O$GOD{{{DIRECT GOTO{8278
{{DAC{2,C$UVL{{{{8279
{{DAC{2,LLUNO{{{{8280
*
{OPDVN{DAC{6,O$GOC{{{COMPLEX NORMAL GOTO{8282
{{DAC{2,C$UNM{{{{8283
{{DAC{2,LLUNO{{{{8284
{{EJC{{{{{8285
*
*      OPERATOR ENTRY ADDRESS POINTERS, USED IN CODE
*
{OAMN${DAC{6,O$AMN{{{ARRAY REF (MULTI-SUBS BY VALUE){8289
{OAMV${DAC{6,O$AMV{{{ARRAY REF (MULTI-SUBS BY VALUE){8290
{OAON${DAC{6,O$AON{{{ARRAY REF (ONE SUB BY NAME){8291
{OAOV${DAC{6,O$AOV{{{ARRAY REF (ONE SUB BY VALUE){8292
{OCER${DAC{6,O$CER{{{COMPILATION ERROR{8293
{OFEX${DAC{6,O$FEX{{{FAILURE IN EXPRESSION EVALUATION{8294
{OFIF${DAC{6,O$FIF{{{FAILURE DURING GOTO EVALUATION{8295
{OFNC${DAC{6,O$FNC{{{FUNCTION CALL (MORE THAN ONE ARG){8296
{OFNE${DAC{6,O$FNE{{{FUNCTION NAME ERROR{8297
{OFNS${DAC{6,O$FNS{{{FUNCTION CALL (SINGLE ARGUMENT){8298
{OGOF${DAC{6,O$GOF{{{SET GOTO FAILURE TRAP{8299
{OINN${DAC{6,O$INN{{{INDIRECTION BY NAME{8300
{OKWN${DAC{6,O$KWN{{{KEYWORD REFERENCE BY NAME{8301
{OLEX${DAC{6,O$LEX{{{LOAD EXPRESSION BY NAME{8302
{OLPT${DAC{6,O$LPT{{{LOAD PATTERN{8303
{OLVN${DAC{6,O$LVN{{{LOAD VARIABLE NAME{8304
{ONTA${DAC{6,O$NTA{{{NEGATION, FIRST ENTRY{8305
{ONTB${DAC{6,O$NTB{{{NEGATION, SECOND ENTRY{8306
{ONTC${DAC{6,O$NTC{{{NEGATION, THIRD ENTRY{8307
{OPMN${DAC{6,O$PMN{{{PATTERN MATCH BY NAME{8308
{OPMS${DAC{6,O$PMS{{{PATTERN MATCH (STATEMENT){8309
{OPOP${DAC{6,O$POP{{{POP TOP STACK ITEM{8310
{ORNM${DAC{6,O$RNM{{{RETURN NAME FROM EXPRESSION{8311
{ORPL${DAC{6,O$RPL{{{PATTERN REPLACEMENT{8312
{ORVL${DAC{6,O$RVL{{{RETURN VALUE FROM EXPRESSION{8313
{OSLA${DAC{6,O$SLA{{{SELECTION, FIRST ENTRY{8314
{OSLB${DAC{6,O$SLB{{{SELECTION, SECOND ENTRY{8315
{OSLC${DAC{6,O$SLC{{{SELECTION, THIRD ENTRY{8316
{OSLD${DAC{6,O$SLD{{{SELECTION, FOURTH ENTRY{8317
{OSTP${DAC{6,O$STP{{{STOP EXECUTION{8318
{OUNF${DAC{6,O$UNF{{{UNEXPECTED FAILURE{8319
{{EJC{{{{{8320
*
*      TABLE OF NAMES OF UNDEFINED BINARY OPERATORS FOR OPSYN
*
{OPSNB{DAC{2,CH$AT{{{AT{8324
{{DAC{2,CH$AM{{{AMPERSAND{8325
{{DAC{2,CH$NM{{{NUMBER{8326
{{DAC{2,CH$PC{{{PERCENT{8327
{{DAC{2,CH$NT{{{NOT{8328
*
*      TABLE OF NAMES OF UNDEFINED UNARY OPERATORS FOR OPSYN
*
{OPNSU{DAC{2,CH$BR{{{VERTICAL BAR{8332
{{DAC{2,CH$EQ{{{EQUAL{8333
{{DAC{2,CH$NM{{{NUMBER{8334
{{DAC{2,CH$PC{{{PERCENT{8335
{{DAC{2,CH$SL{{{SLASH{8336
{{DAC{2,CH$EX{{{EXCLAMATION{8337
*
*      ADDRESS CONST CONTAINING PROFILE TABLE ENTRY SIZE
*
{PFI2A{DAC{2,PF$I2{{{{8343
*
*      PROFILER MESSAGE STRINGS
*
{PFMS1{DAC{6,B$SCL{{{{8347
{{DAC{1,15{{{{8348
{{DTC{27,/Program Profile/{{{{8349
{PFMS2{DAC{6,B$SCL{{{{8350
{{DAC{1,42{{{{8351
{{DTC{27,/STMT    Number Of     -- Execution Time --/{{{{8352
{PFMS3{DAC{6,B$SCL{{{{8353
{{DAC{1,47{{{{8354
{{DTC{27,/Number  Executions  Total(MSec) per Excn(MCSec)/{{{{8355
*
*
*      REAL CONSTANTS FOR GENERAL USE. NOTE THAT THE CONSTANTS
*      STARTING AT REAV1 FORM A POWERS OF TEN TABLE (USED IN
*      GTNUM AND GTSTG)
*
{REAV0{DRC{17,+0.0{{{0.0{8365
{REAP1{DRC{17,+0.1{{{0.1{8368
{REAP5{DRC{17,+0.5{{{0.5{8369
{REAV1{DRC{17,+1.0{{{10**0{8371
{REAVT{DRC{17,+1.0E+1{{{10**1{8372
{{DRC{17,+1.0E+2{{{10**2{8373
{{DRC{17,+1.0E+3{{{10**3{8374
{{DRC{17,+1.0E+4{{{10**4{8375
{{DRC{17,+1.0E+5{{{10**5{8376
{{DRC{17,+1.0E+6{{{10**6{8377
{{DRC{17,+1.0E+7{{{10**7{8378
{{DRC{17,+1.0E+8{{{10**8{8379
{{DRC{17,+1.0E+9{{{10**9{8380
{REATT{DRC{17,+1.0E+10{{{10**10{8381
{{EJC{{{{{8383
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR DTYPE PROCEDURE
*
{SCARR{DAC{6,B$SCL{{{ARRAY{8387
{{DAC{1,5{{{{8388
{{DTC{27,/ARRAY/{{{{8389
*
{SCCOD{DAC{6,B$SCL{{{CODE{8398
{{DAC{1,4{{{{8399
{{DTC{27,/CODE/{{{{8400
*
{SCEXP{DAC{6,B$SCL{{{EXPRESSION{8402
{{DAC{1,10{{{{8403
{{DTC{27,/EXPRESSION/{{{{8404
*
{SCEXT{DAC{6,B$SCL{{{EXTERNAL{8406
{{DAC{1,8{{{{8407
{{DTC{27,/EXTERNAL/{{{{8408
*
{SCINT{DAC{6,B$SCL{{{INTEGER{8410
{{DAC{1,7{{{{8411
{{DTC{27,/INTEGER/{{{{8412
*
{SCNAM{DAC{6,B$SCL{{{NAME{8414
{{DAC{1,4{{{{8415
{{DTC{27,/NAME/{{{{8416
*
{SCNUM{DAC{6,B$SCL{{{NUMERIC{8418
{{DAC{1,7{{{{8419
{{DTC{27,/NUMERIC/{{{{8420
*
{SCPAT{DAC{6,B$SCL{{{PATTERN{8422
{{DAC{1,7{{{{8423
{{DTC{27,/PATTERN/{{{{8424
*
{SCREA{DAC{6,B$SCL{{{REAL{8428
{{DAC{1,4{{{{8429
{{DTC{27,/REAL/{{{{8430
*
{SCSTR{DAC{6,B$SCL{{{STRING{8433
{{DAC{1,6{{{{8434
{{DTC{27,/STRING/{{{{8435
*
{SCTAB{DAC{6,B$SCL{{{TABLE{8437
{{DAC{1,5{{{{8438
{{DTC{27,/TABLE/{{{{8439
{SCFIL{DAC{6,B$SCL{{{FILE (FOR EXTENDED LOAD ARGUMENTS){8441
{{DAC{1,4{{{{8442
{{DTC{27,/FILE/{{{{8443
{{EJC{{{{{8445
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR KVRTN (SEE RETRN)
*
{SCFRT{DAC{6,B$SCL{{{FRETURN{8449
{{DAC{1,7{{{{8450
{{DTC{27,/FRETURN/{{{{8451
*
{SCNRT{DAC{6,B$SCL{{{NRETURN{8453
{{DAC{1,7{{{{8454
{{DTC{27,/NRETURN/{{{{8455
*
{SCRTN{DAC{6,B$SCL{{{RETURN{8457
{{DAC{1,6{{{{8458
{{DTC{27,/RETURN/{{{{8459
*
*      DATATYPE NAME TABLE FOR DTYPE PROCEDURE. THE ORDER OF
*      THESE ENTRIES IS TIED TO THE B$XXX DEFINITIONS FOR BLOCKS
*
*      NOTE THAT SLOTS FOR BUFFER AND REAL DATA TYPES ARE FILLED
*      EVEN IF THESE DATA TYPES ARE CONDITIONALIZED OUT OF THE
*      IMPLEMENTATION.  THIS IS DONE SO THAT THE BLOCK NUMBERING
*      AT BL$AR ETC. REMAINS CONSTANT IN ALL VERSIONS.
*
{SCNMT{DAC{4,SCARR{{{ARBLK     ARRAY{8469
{{DAC{4,SCCOD{{{CDBLK     CODE{8470
{{DAC{4,SCEXP{{{EXBLK     EXPRESSION{8471
{{DAC{4,SCINT{{{ICBLK     INTEGER{8472
{{DAC{4,SCNAM{{{NMBLK     NAME{8473
{{DAC{4,SCPAT{{{P0BLK     PATTERN{8474
{{DAC{4,SCPAT{{{P1BLK     PATTERN{8475
{{DAC{4,SCPAT{{{P2BLK     PATTERN{8476
{{DAC{4,SCREA{{{RCBLK     REAL{8481
{{DAC{4,SCSTR{{{SCBLK     STRING{8483
{{DAC{4,SCEXP{{{SEBLK     EXPRESSION{8484
{{DAC{4,SCTAB{{{TBBLK     TABLE{8485
{{DAC{4,SCARR{{{VCBLK     ARRAY{8486
{{DAC{4,SCEXT{{{XNBLK     EXTERNAL{8487
{{DAC{4,SCEXT{{{XRBLK     EXTERNAL{8488
{{DAC{4,NULLS{{{BFBLK     NO BUFFER IN THIS VERSION{8490
*
*      STRING CONSTANT FOR REAL ZERO
*
{SCRE0{DAC{6,B$SCL{{{{8499
{{DAC{1,2{{{{8500
{{DTC{27,/0./{{{{8501
{{EJC{{{{{8503
*
*      USED TO RE-INITIALISE KVSTL
*
{STLIM{DIC{16,+2147483647{{{DEFAULT STATEMENT LIMIT{8511
*
*      DUMMY FUNCTION BLOCK USED FOR UNDEFINED FUNCTIONS
*
{STNDF{DAC{6,O$FUN{{{PTR TO UNDEFINED FUNCTION ERR CALL{8519
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{8520
*
*      DUMMY CODE BLOCK USED FOR UNDEFINED LABELS
*
{STNDL{DAC{6,L$UND{{{CODE PTR POINTS TO UNDEFINED LBL{8524
*
*      DUMMY OPERATOR BLOCK USED FOR UNDEFINED OPERATORS
*
{STNDO{DAC{6,O$OUN{{{PTR TO UNDEFINED OPERATOR ERR CALL{8528
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{8529
*
*      STANDARD VARIABLE BLOCK. THIS BLOCK IS USED TO INITIALIZE
*      THE FIRST SEVEN FIELDS OF A NEWLY CONSTRUCTED VRBLK.
*      ITS FORMAT IS TIED TO THE VRBLK DEFINITIONS (SEE GTNVR).
*
{STNVR{DAC{6,B$VRL{{{VRGET{8535
{{DAC{6,B$VRS{{{VRSTO{8536
{{DAC{4,NULLS{{{VRVAL{8537
{{DAC{6,B$VRG{{{VRTRA{8538
{{DAC{4,STNDL{{{VRLBL{8539
{{DAC{4,STNDF{{{VRFNC{8540
{{DAC{1,0{{{VRNXT{8541
{{EJC{{{{{8542
*
*      MESSAGES USED IN END OF RUN PROCESSING (STOPR)
*
{STPM1{DAC{6,B$SCL{{{IN STATEMENT{8546
{{DAC{1,12{{{{8547
{{DTC{27,/In statement/{{{{8548
*
{STPM2{DAC{6,B$SCL{{{{8550
{{DAC{1,14{{{{8551
{{DTC{27,/Stmts executed/{{{{8552
*
{STPM3{DAC{6,B$SCL{{{{8554
{{DAC{1,19{{{{8559
{{DTC{27,/Run time (millisec)/{{{{8560
*
{STPM4{DAC{6,B$SCL{{{{8563
{{DAC{1,12{{{{8564
{{DTC{27,$MCSec / Stmt${{{{8565
*
{STPM5{DAC{6,B$SCL{{{{8567
{{DAC{1,13{{{{8568
{{DTC{27,/Regenerations/{{{{8569
*
{STPM6{DAC{6,B$SCL{{{IN LINE{8572
{{DAC{1,7{{{{8573
{{DTC{27,/In line/{{{{8574
*
{STPM7{DAC{6,B$SCL{{{IN FILE{8578
{{DAC{1,7{{{{8579
{{DTC{27,/In file/{{{{8580
*
*      CHARS FOR /TU/ ENDING CODE
*
{STRTU{DTC{27,/TU/{{{{8585
*
*      TABLE USED BY CONVERT FUNCTION TO CHECK DATATYPE NAME
*      THE ENTRIES ARE ORDERED TO CORRESPOND TO BRANCH TABLE
*      IN S$CNV
*
{SVCTB{DAC{4,SCSTR{{{STRING{8591
{{DAC{4,SCINT{{{INTEGER{8592
{{DAC{4,SCNAM{{{NAME{8593
{{DAC{4,SCPAT{{{PATTERN{8594
{{DAC{4,SCARR{{{ARRAY{8595
{{DAC{4,SCTAB{{{TABLE{8596
{{DAC{4,SCEXP{{{EXPRESSION{8597
{{DAC{4,SCCOD{{{CODE{8598
{{DAC{4,SCNUM{{{NUMERIC{8599
{{DAC{4,SCREA{{{REAL{8602
{{DAC{1,0{{{ZERO MARKS END OF LIST{8608
{{EJC{{{{{8609
*
*      MESSAGES (SCBLK FORMAT) USED BY TRACE PROCEDURES
*
*
{TMASB{DAC{6,B$SCL{{{ASTERISKS FOR TRACE STATEMENT NO{8614
{{DAC{1,13{{{{8615
{{DTC{27,/************ /{{{{8616
*
{TMBEB{DAC{6,B$SCL{{{BLANK-EQUAL-BLANK{8619
{{DAC{1,3{{{{8620
{{DTC{27,/ = /{{{{8621
*
*      DUMMY TRBLK FOR EXPRESSION VARIABLE
*
{TRBEV{DAC{6,B$TRT{{{DUMMY TRBLK{8625
*
*      DUMMY TRBLK FOR KEYWORD VARIABLE
*
{TRBKV{DAC{6,B$TRT{{{DUMMY TRBLK{8629
*
*      DUMMY CODE BLOCK TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{TRXDR{DAC{6,O$TXR{{{BLOCK POINTS TO RETURN ROUTINE{8633
{TRXDC{DAC{4,TRXDR{{{POINTER TO BLOCK{8634
{{EJC{{{{{8635
*
*      STANDARD VARIABLE BLOCKS
*
*      SEE SVBLK FORMAT FOR FULL DETAILS OF THE FORMAT. THE
*      VRBLKS ARE ORDERED BY LENGTH AND WITHIN EACH LENGTH THE
*      ORDER IS ALPHABETICAL BY NAME OF THE VARIABLE.
*
{V$EQF{DBC{2,SVFPR{{{EQ{8643
{{DAC{1,2{{{{8644
{{DTC{27,/EQ/{{{{8645
{{DAC{6,S$EQF{{{{8646
{{DAC{1,2{{{{8647
*
{V$GEF{DBC{2,SVFPR{{{GE{8649
{{DAC{1,2{{{{8650
{{DTC{27,/GE/{{{{8651
{{DAC{6,S$GEF{{{{8652
{{DAC{1,2{{{{8653
*
{V$GTF{DBC{2,SVFPR{{{GT{8655
{{DAC{1,2{{{{8656
{{DTC{27,/GT/{{{{8657
{{DAC{6,S$GTF{{{{8658
{{DAC{1,2{{{{8659
*
{V$LEF{DBC{2,SVFPR{{{LE{8661
{{DAC{1,2{{{{8662
{{DTC{27,/LE/{{{{8663
{{DAC{6,S$LEF{{{{8664
{{DAC{1,2{{{{8665
*
{V$LNF{DBC{2,SVFNP{{{LN{8668
{{DAC{1,2{{{{8669
{{DTC{27,/LN/{{{{8670
{{DAC{6,S$LNF{{{{8671
{{DAC{1,1{{{{8672
*
{V$LTF{DBC{2,SVFPR{{{LT{8675
{{DAC{1,2{{{{8676
{{DTC{27,/LT/{{{{8677
{{DAC{6,S$LTF{{{{8678
{{DAC{1,2{{{{8679
*
{V$NEF{DBC{2,SVFPR{{{NE{8681
{{DAC{1,2{{{{8682
{{DTC{27,/NE/{{{{8683
{{DAC{6,S$NEF{{{{8684
{{DAC{1,2{{{{8685
*
{V$ANY{DBC{2,SVFNP{{{ANY{8711
{{DAC{1,3{{{{8712
{{DTC{27,/ANY/{{{{8713
{{DAC{6,S$ANY{{{{8714
{{DAC{1,1{{{{8715
*
{V$ARB{DBC{2,SVKVC{{{ARB{8717
{{DAC{1,3{{{{8718
{{DTC{27,/ARB/{{{{8719
{{DAC{2,K$ARB{{{{8720
{{DAC{4,NDARB{{{{8721
{{EJC{{{{{8722
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$ARG{DBC{2,SVFNN{{{ARG{8726
{{DAC{1,3{{{{8727
{{DTC{27,/ARG/{{{{8728
{{DAC{6,S$ARG{{{{8729
{{DAC{1,2{{{{8730
*
{V$BAL{DBC{2,SVKVC{{{BAL{8732
{{DAC{1,3{{{{8733
{{DTC{27,/BAL/{{{{8734
{{DAC{2,K$BAL{{{{8735
{{DAC{4,NDBAL{{{{8736
*
{V$COS{DBC{2,SVFNP{{{COS{8739
{{DAC{1,3{{{{8740
{{DTC{27,/COS/{{{{8741
{{DAC{6,S$COS{{{{8742
{{DAC{1,1{{{{8743
*
{V$END{DBC{2,SVLBL{{{END{8746
{{DAC{1,3{{{{8747
{{DTC{27,/END/{{{{8748
{{DAC{6,L$END{{{{8749
*
{V$EXP{DBC{2,SVFNP{{{EXP{8752
{{DAC{1,3{{{{8753
{{DTC{27,/EXP/{{{{8754
{{DAC{6,S$EXP{{{{8755
{{DAC{1,1{{{{8756
*
{V$LEN{DBC{2,SVFNP{{{LEN{8759
{{DAC{1,3{{{{8760
{{DTC{27,/LEN/{{{{8761
{{DAC{6,S$LEN{{{{8762
{{DAC{1,1{{{{8763
*
{V$LEQ{DBC{2,SVFPR{{{LEQ{8765
{{DAC{1,3{{{{8766
{{DTC{27,/LEQ/{{{{8767
{{DAC{6,S$LEQ{{{{8768
{{DAC{1,2{{{{8769
*
{V$LGE{DBC{2,SVFPR{{{LGE{8771
{{DAC{1,3{{{{8772
{{DTC{27,/LGE/{{{{8773
{{DAC{6,S$LGE{{{{8774
{{DAC{1,2{{{{8775
*
{V$LGT{DBC{2,SVFPR{{{LGT{8777
{{DAC{1,3{{{{8778
{{DTC{27,/LGT/{{{{8779
{{DAC{6,S$LGT{{{{8780
{{DAC{1,2{{{{8781
*
{V$LLE{DBC{2,SVFPR{{{LLE{8783
{{DAC{1,3{{{{8784
{{DTC{27,/LLE/{{{{8785
{{DAC{6,S$LLE{{{{8786
{{DAC{1,2{{{{8787
{{EJC{{{{{8788
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$LLT{DBC{2,SVFPR{{{LLT{8792
{{DAC{1,3{{{{8793
{{DTC{27,/LLT/{{{{8794
{{DAC{6,S$LLT{{{{8795
{{DAC{1,2{{{{8796
*
{V$LNE{DBC{2,SVFPR{{{LNE{8798
{{DAC{1,3{{{{8799
{{DTC{27,/LNE/{{{{8800
{{DAC{6,S$LNE{{{{8801
{{DAC{1,2{{{{8802
*
{V$POS{DBC{2,SVFNP{{{POS{8804
{{DAC{1,3{{{{8805
{{DTC{27,/POS/{{{{8806
{{DAC{6,S$POS{{{{8807
{{DAC{1,1{{{{8808
*
{V$REM{DBC{2,SVKVC{{{REM{8810
{{DAC{1,3{{{{8811
{{DTC{27,/REM/{{{{8812
{{DAC{2,K$REM{{{{8813
{{DAC{4,NDREM{{{{8814
*
{V$SET{DBC{2,SVFNN{{{SET{8817
{{DAC{1,3{{{{8818
{{DTC{27,/SET/{{{{8819
{{DAC{6,S$SET{{{{8820
{{DAC{1,3{{{{8821
*
{V$SIN{DBC{2,SVFNP{{{SIN{8825
{{DAC{1,3{{{{8826
{{DTC{27,/SIN/{{{{8827
{{DAC{6,S$SIN{{{{8828
{{DAC{1,1{{{{8829
*
{V$TAB{DBC{2,SVFNP{{{TAB{8832
{{DAC{1,3{{{{8833
{{DTC{27,/TAB/{{{{8834
{{DAC{6,S$TAB{{{{8835
{{DAC{1,1{{{{8836
*
{V$TAN{DBC{2,SVFNP{{{TAN{8839
{{DAC{1,3{{{{8840
{{DTC{27,/TAN/{{{{8841
{{DAC{6,S$TAN{{{{8842
{{DAC{1,1{{{{8843
*
{V$ATN{DBC{2,SVFNP{{{ATAN{8855
{{DAC{1,4{{{{8856
{{DTC{27,/ATAN/{{{{8857
{{DAC{6,S$ATN{{{{8858
{{DAC{1,1{{{{8859
*
{V$CAS{DBC{2,SVKNM{{{CASE{8863
{{DAC{1,4{{{{8864
{{DTC{27,/CASE/{{{{8865
{{DAC{2,K$CAS{{{{8866
*
{V$CHR{DBC{2,SVFNP{{{CHAR{8869
{{DAC{1,4{{{{8870
{{DTC{27,/CHAR/{{{{8871
{{DAC{6,S$CHR{{{{8872
{{DAC{1,1{{{{8873
*
*
{V$CHP{DBC{2,SVFNP{{{CHOP{8877
{{DAC{1,4{{{{8878
{{DTC{27,/CHOP/{{{{8879
{{DAC{6,S$CHP{{{{8880
{{DAC{1,1{{{{8881
{V$COD{DBC{2,SVFNK{{{CODE{8883
{{DAC{1,4{{{{8884
{{DTC{27,/CODE/{{{{8885
{{DAC{2,K$COD{{{{8886
{{DAC{6,S$COD{{{{8887
{{DAC{1,1{{{{8888
*
{V$COP{DBC{2,SVFNN{{{COPY{8890
{{DAC{1,4{{{{8891
{{DTC{27,/COPY/{{{{8892
{{DAC{6,S$COP{{{{8893
{{DAC{1,1{{{{8894
{{EJC{{{{{8895
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DAT{DBC{2,SVFNN{{{DATA{8899
{{DAC{1,4{{{{8900
{{DTC{27,/DATA/{{{{8901
{{DAC{6,S$DAT{{{{8902
{{DAC{1,1{{{{8903
*
{V$DTE{DBC{2,SVFNN{{{DATE{8905
{{DAC{1,4{{{{8906
{{DTC{27,/DATE/{{{{8907
{{DAC{6,S$DTE{{{{8908
{{DAC{1,1{{{{8909
*
{V$DMP{DBC{2,SVFNK{{{DUMP{8911
{{DAC{1,4{{{{8912
{{DTC{27,/DUMP/{{{{8913
{{DAC{2,K$DMP{{{{8914
{{DAC{6,S$DMP{{{{8915
{{DAC{1,1{{{{8916
*
{V$DUP{DBC{2,SVFNN{{{DUPL{8918
{{DAC{1,4{{{{8919
{{DTC{27,/DUPL/{{{{8920
{{DAC{6,S$DUP{{{{8921
{{DAC{1,2{{{{8922
*
{V$EVL{DBC{2,SVFNN{{{EVAL{8924
{{DAC{1,4{{{{8925
{{DTC{27,/EVAL/{{{{8926
{{DAC{6,S$EVL{{{{8927
{{DAC{1,1{{{{8928
*
{V$EXT{DBC{2,SVFNN{{{EXIT{8932
{{DAC{1,4{{{{8933
{{DTC{27,/EXIT/{{{{8934
{{DAC{6,S$EXT{{{{8935
{{DAC{1,2{{{{8936
*
{V$FAL{DBC{2,SVKVC{{{FAIL{8939
{{DAC{1,4{{{{8940
{{DTC{27,/FAIL/{{{{8941
{{DAC{2,K$FAL{{{{8942
{{DAC{4,NDFAL{{{{8943
*
{V$FIL{DBC{2,SVKNM{{{FILE{8946
{{DAC{1,4{{{{8947
{{DTC{27,/FILE/{{{{8948
{{DAC{2,K$FIL{{{{8949
*
{V$HST{DBC{2,SVFNN{{{HOST{8952
{{DAC{1,4{{{{8953
{{DTC{27,/HOST/{{{{8954
{{DAC{6,S$HST{{{{8955
{{DAC{1,5{{{{8956
{{EJC{{{{{8957
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$ITM{DBC{2,SVFNF{{{ITEM{8961
{{DAC{1,4{{{{8962
{{DTC{27,/ITEM/{{{{8963
{{DAC{6,S$ITM{{{{8964
{{DAC{1,999{{{{8965
*
{V$LIN{DBC{2,SVKNM{{{LINE{8968
{{DAC{1,4{{{{8969
{{DTC{27,/LINE/{{{{8970
{{DAC{2,K$LIN{{{{8971
*
{V$LOD{DBC{2,SVFNN{{{LOAD{8976
{{DAC{1,4{{{{8977
{{DTC{27,/LOAD/{{{{8978
{{DAC{6,S$LOD{{{{8979
{{DAC{1,2{{{{8980
*
{V$LPD{DBC{2,SVFNP{{{LPAD{8983
{{DAC{1,4{{{{8984
{{DTC{27,/LPAD/{{{{8985
{{DAC{6,S$LPD{{{{8986
{{DAC{1,3{{{{8987
*
{V$RPD{DBC{2,SVFNP{{{RPAD{8989
{{DAC{1,4{{{{8990
{{DTC{27,/RPAD/{{{{8991
{{DAC{6,S$RPD{{{{8992
{{DAC{1,3{{{{8993
*
{V$RPS{DBC{2,SVFNP{{{RPOS{8995
{{DAC{1,4{{{{8996
{{DTC{27,/RPOS/{{{{8997
{{DAC{6,S$RPS{{{{8998
{{DAC{1,1{{{{8999
*
{V$RTB{DBC{2,SVFNP{{{RTAB{9001
{{DAC{1,4{{{{9002
{{DTC{27,/RTAB/{{{{9003
{{DAC{6,S$RTB{{{{9004
{{DAC{1,1{{{{9005
*
{V$SI${DBC{2,SVFNP{{{SIZE{9007
{{DAC{1,4{{{{9008
{{DTC{27,/SIZE/{{{{9009
{{DAC{6,S$SI${{{{9010
{{DAC{1,1{{{{9011
*
*
{V$SRT{DBC{2,SVFNN{{{SORT{9016
{{DAC{1,4{{{{9017
{{DTC{27,/SORT/{{{{9018
{{DAC{6,S$SRT{{{{9019
{{DAC{1,2{{{{9020
{V$SPN{DBC{2,SVFNP{{{SPAN{9022
{{DAC{1,4{{{{9023
{{DTC{27,/SPAN/{{{{9024
{{DAC{6,S$SPN{{{{9025
{{DAC{1,1{{{{9026
{{EJC{{{{{9027
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V$SQR{DBC{2,SVFNP{{{SQRT{9033
{{DAC{1,4{{{{9034
{{DTC{27,/SQRT/{{{{9035
{{DAC{6,S$SQR{{{{9036
{{DAC{1,1{{{{9037
{V$STN{DBC{2,SVKNM{{{STNO{9039
{{DAC{1,4{{{{9040
{{DTC{27,/STNO/{{{{9041
{{DAC{2,K$STN{{{{9042
*
{V$TIM{DBC{2,SVFNN{{{TIME{9044
{{DAC{1,4{{{{9045
{{DTC{27,/TIME/{{{{9046
{{DAC{6,S$TIM{{{{9047
{{DAC{1,0{{{{9048
*
{V$TRM{DBC{2,SVFNK{{{TRIM{9050
{{DAC{1,4{{{{9051
{{DTC{27,/TRIM/{{{{9052
{{DAC{2,K$TRM{{{{9053
{{DAC{6,S$TRM{{{{9054
{{DAC{1,1{{{{9055
*
{V$ABE{DBC{2,SVKNM{{{ABEND{9057
{{DAC{1,5{{{{9058
{{DTC{27,/ABEND/{{{{9059
{{DAC{2,K$ABE{{{{9060
*
{V$ABO{DBC{2,SVKVL{{{ABORT{9062
{{DAC{1,5{{{{9063
{{DTC{27,/ABORT/{{{{9064
{{DAC{2,K$ABO{{{{9065
{{DAC{6,L$ABO{{{{9066
{{DAC{4,NDABO{{{{9067
*
{V$APP{DBC{2,SVFNF{{{APPLY{9069
{{DAC{1,5{{{{9070
{{DTC{27,/APPLY/{{{{9071
{{DAC{6,S$APP{{{{9072
{{DAC{1,999{{{{9073
*
{V$ABN{DBC{2,SVFNP{{{ARBNO{9075
{{DAC{1,5{{{{9076
{{DTC{27,/ARBNO/{{{{9077
{{DAC{6,S$ABN{{{{9078
{{DAC{1,1{{{{9079
*
{V$ARR{DBC{2,SVFNN{{{ARRAY{9081
{{DAC{1,5{{{{9082
{{DTC{27,/ARRAY/{{{{9083
{{DAC{6,S$ARR{{{{9084
{{DAC{1,2{{{{9085
{{EJC{{{{{9086
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$BRK{DBC{2,SVFNP{{{BREAK{9090
{{DAC{1,5{{{{9091
{{DTC{27,/BREAK/{{{{9092
{{DAC{6,S$BRK{{{{9093
{{DAC{1,1{{{{9094
*
{V$CLR{DBC{2,SVFNN{{{CLEAR{9096
{{DAC{1,5{{{{9097
{{DTC{27,/CLEAR/{{{{9098
{{DAC{6,S$CLR{{{{9099
{{DAC{1,1{{{{9100
*
{V$EJC{DBC{2,SVFNN{{{EJECT{9110
{{DAC{1,5{{{{9111
{{DTC{27,/EJECT/{{{{9112
{{DAC{6,S$EJC{{{{9113
{{DAC{1,1{{{{9114
*
{V$FEN{DBC{2,SVFPK{{{FENCE{9116
{{DAC{1,5{{{{9117
{{DTC{27,/FENCE/{{{{9118
{{DAC{2,K$FEN{{{{9119
{{DAC{6,S$FNC{{{{9120
{{DAC{1,1{{{{9121
{{DAC{4,NDFEN{{{{9122
*
{V$FLD{DBC{2,SVFNN{{{FIELD{9124
{{DAC{1,5{{{{9125
{{DTC{27,/FIELD/{{{{9126
{{DAC{6,S$FLD{{{{9127
{{DAC{1,2{{{{9128
*
{V$IDN{DBC{2,SVFPR{{{IDENT{9130
{{DAC{1,5{{{{9131
{{DTC{27,/IDENT/{{{{9132
{{DAC{6,S$IDN{{{{9133
{{DAC{1,2{{{{9134
*
{V$INP{DBC{2,SVFNK{{{INPUT{9136
{{DAC{1,5{{{{9137
{{DTC{27,/INPUT/{{{{9138
{{DAC{2,K$INP{{{{9139
{{DAC{6,S$INP{{{{9140
{{DAC{1,3{{{{9141
*
{V$LCS{DBC{2,SVKWC{{{LCASE{9144
{{DAC{1,5{{{{9145
{{DTC{27,/LCASE/{{{{9146
{{DAC{2,K$LCS{{{{9147
*
{V$LOC{DBC{2,SVFNN{{{LOCAL{9150
{{DAC{1,5{{{{9151
{{DTC{27,/LOCAL/{{{{9152
{{DAC{6,S$LOC{{{{9153
{{DAC{1,2{{{{9154
{{EJC{{{{{9155
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$OPS{DBC{2,SVFNN{{{OPSYN{9159
{{DAC{1,5{{{{9160
{{DTC{27,/OPSYN/{{{{9161
{{DAC{6,S$OPS{{{{9162
{{DAC{1,3{{{{9163
*
{V$RMD{DBC{2,SVFNP{{{REMDR{9165
{{DAC{1,5{{{{9166
{{DTC{27,/REMDR/{{{{9167
{{DAC{6,S$RMD{{{{9168
{{DAC{1,2{{{{9169
*
{V$RSR{DBC{2,SVFNN{{{RSORT{9173
{{DAC{1,5{{{{9174
{{DTC{27,/RSORT/{{{{9175
{{DAC{6,S$RSR{{{{9176
{{DAC{1,2{{{{9177
*
{V$TBL{DBC{2,SVFNN{{{TABLE{9180
{{DAC{1,5{{{{9181
{{DTC{27,/TABLE/{{{{9182
{{DAC{6,S$TBL{{{{9183
{{DAC{1,3{{{{9184
*
{V$TRA{DBC{2,SVFNK{{{TRACE{9186
{{DAC{1,5{{{{9187
{{DTC{27,/TRACE/{{{{9188
{{DAC{2,K$TRA{{{{9189
{{DAC{6,S$TRA{{{{9190
{{DAC{1,4{{{{9191
*
{V$UCS{DBC{2,SVKWC{{{UCASE{9194
{{DAC{1,5{{{{9195
{{DTC{27,/UCASE/{{{{9196
{{DAC{2,K$UCS{{{{9197
*
{V$ANC{DBC{2,SVKNM{{{ANCHOR{9200
{{DAC{1,6{{{{9201
{{DTC{27,/ANCHOR/{{{{9202
{{DAC{2,K$ANC{{{{9203
*
{V$BKX{DBC{2,SVFNP{{{BREAKX{9214
{{DAC{1,6{{{{9215
{{DTC{27,/BREAKX/{{{{9216
{{DAC{6,S$BKX{{{{9217
{{DAC{1,1{{{{9218
*
*
{V$DEF{DBC{2,SVFNN{{{DEFINE{9229
{{DAC{1,6{{{{9230
{{DTC{27,/DEFINE/{{{{9231
{{DAC{6,S$DEF{{{{9232
{{DAC{1,2{{{{9233
*
{V$DET{DBC{2,SVFNN{{{DETACH{9235
{{DAC{1,6{{{{9236
{{DTC{27,/DETACH/{{{{9237
{{DAC{6,S$DET{{{{9238
{{DAC{1,1{{{{9239
{{EJC{{{{{9240
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DIF{DBC{2,SVFPR{{{DIFFER{9244
{{DAC{1,6{{{{9245
{{DTC{27,/DIFFER/{{{{9246
{{DAC{6,S$DIF{{{{9247
{{DAC{1,2{{{{9248
*
{V$FTR{DBC{2,SVKNM{{{FTRACE{9250
{{DAC{1,6{{{{9251
{{DTC{27,/FTRACE/{{{{9252
{{DAC{2,K$FTR{{{{9253
*
{V$LST{DBC{2,SVKNM{{{LASTNO{9264
{{DAC{1,6{{{{9265
{{DTC{27,/LASTNO/{{{{9266
{{DAC{2,K$LST{{{{9267
*
{V$NAY{DBC{2,SVFNP{{{NOTANY{9269
{{DAC{1,6{{{{9270
{{DTC{27,/NOTANY/{{{{9271
{{DAC{6,S$NAY{{{{9272
{{DAC{1,1{{{{9273
*
{V$OUP{DBC{2,SVFNK{{{OUTPUT{9275
{{DAC{1,6{{{{9276
{{DTC{27,/OUTPUT/{{{{9277
{{DAC{2,K$OUP{{{{9278
{{DAC{6,S$OUP{{{{9279
{{DAC{1,3{{{{9280
*
{V$RET{DBC{2,SVLBL{{{RETURN{9282
{{DAC{1,6{{{{9283
{{DTC{27,/RETURN/{{{{9284
{{DAC{6,L$RTN{{{{9285
*
{V$REW{DBC{2,SVFNN{{{REWIND{9287
{{DAC{1,6{{{{9288
{{DTC{27,/REWIND/{{{{9289
{{DAC{6,S$REW{{{{9290
{{DAC{1,1{{{{9291
*
{V$STT{DBC{2,SVFNN{{{STOPTR{9293
{{DAC{1,6{{{{9294
{{DTC{27,/STOPTR/{{{{9295
{{DAC{6,S$STT{{{{9296
{{DAC{1,2{{{{9297
{{EJC{{{{{9298
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$SUB{DBC{2,SVFNN{{{SUBSTR{9302
{{DAC{1,6{{{{9303
{{DTC{27,/SUBSTR/{{{{9304
{{DAC{6,S$SUB{{{{9305
{{DAC{1,3{{{{9306
*
{V$UNL{DBC{2,SVFNN{{{UNLOAD{9308
{{DAC{1,6{{{{9309
{{DTC{27,/UNLOAD/{{{{9310
{{DAC{6,S$UNL{{{{9311
{{DAC{1,1{{{{9312
*
{V$COL{DBC{2,SVFNN{{{COLLECT{9314
{{DAC{1,7{{{{9315
{{DTC{27,/COLLECT/{{{{9316
{{DAC{6,S$COL{{{{9317
{{DAC{1,1{{{{9318
*
{V$COM{DBC{2,SVKNM{{{COMPARE{9321
{{DAC{1,7{{{{9322
{{DTC{27,/COMPARE/{{{{9323
{{DAC{2,K$COM{{{{9324
*
{V$CNV{DBC{2,SVFNN{{{CONVERT{9327
{{DAC{1,7{{{{9328
{{DTC{27,/CONVERT/{{{{9329
{{DAC{6,S$CNV{{{{9330
{{DAC{1,2{{{{9331
*
{V$ENF{DBC{2,SVFNN{{{ENDFILE{9333
{{DAC{1,7{{{{9334
{{DTC{27,/ENDFILE/{{{{9335
{{DAC{6,S$ENF{{{{9336
{{DAC{1,1{{{{9337
*
{V$ETX{DBC{2,SVKNM{{{ERRTEXT{9339
{{DAC{1,7{{{{9340
{{DTC{27,/ERRTEXT/{{{{9341
{{DAC{2,K$ETX{{{{9342
*
{V$ERT{DBC{2,SVKNM{{{ERRTYPE{9344
{{DAC{1,7{{{{9345
{{DTC{27,/ERRTYPE/{{{{9346
{{DAC{2,K$ERT{{{{9347
*
{V$FRT{DBC{2,SVLBL{{{FRETURN{9349
{{DAC{1,7{{{{9350
{{DTC{27,/FRETURN/{{{{9351
{{DAC{6,L$FRT{{{{9352
*
{V$INT{DBC{2,SVFPR{{{INTEGER{9354
{{DAC{1,7{{{{9355
{{DTC{27,/INTEGER/{{{{9356
{{DAC{6,S$INT{{{{9357
{{DAC{1,1{{{{9358
*
{V$NRT{DBC{2,SVLBL{{{NRETURN{9360
{{DAC{1,7{{{{9361
{{DTC{27,/NRETURN/{{{{9362
{{DAC{6,L$NRT{{{{9363
{{EJC{{{{{9364
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V$PFL{DBC{2,SVKNM{{{PROFILE{9371
{{DAC{1,7{{{{9372
{{DTC{27,/PROFILE/{{{{9373
{{DAC{2,K$PFL{{{{9374
*
{V$RPL{DBC{2,SVFNP{{{REPLACE{9377
{{DAC{1,7{{{{9378
{{DTC{27,/REPLACE/{{{{9379
{{DAC{6,S$RPL{{{{9380
{{DAC{1,3{{{{9381
*
{V$RVS{DBC{2,SVFNP{{{REVERSE{9383
{{DAC{1,7{{{{9384
{{DTC{27,/REVERSE/{{{{9385
{{DAC{6,S$RVS{{{{9386
{{DAC{1,1{{{{9387
*
{V$RTN{DBC{2,SVKNM{{{RTNTYPE{9389
{{DAC{1,7{{{{9390
{{DTC{27,/RTNTYPE/{{{{9391
{{DAC{2,K$RTN{{{{9392
*
{V$STX{DBC{2,SVFNN{{{SETEXIT{9394
{{DAC{1,7{{{{9395
{{DTC{27,/SETEXIT/{{{{9396
{{DAC{6,S$STX{{{{9397
{{DAC{1,1{{{{9398
*
{V$STC{DBC{2,SVKNM{{{STCOUNT{9400
{{DAC{1,7{{{{9401
{{DTC{27,/STCOUNT/{{{{9402
{{DAC{2,K$STC{{{{9403
*
{V$STL{DBC{2,SVKNM{{{STLIMIT{9405
{{DAC{1,7{{{{9406
{{DTC{27,/STLIMIT/{{{{9407
{{DAC{2,K$STL{{{{9408
*
{V$SUC{DBC{2,SVKVC{{{SUCCEED{9410
{{DAC{1,7{{{{9411
{{DTC{27,/SUCCEED/{{{{9412
{{DAC{2,K$SUC{{{{9413
{{DAC{4,NDSUC{{{{9414
*
{V$ALP{DBC{2,SVKWC{{{ALPHABET{9416
{{DAC{1,8{{{{9417
{{DTC{27,/ALPHABET/{{{{9418
{{DAC{2,K$ALP{{{{9419
*
{V$CNT{DBC{2,SVLBL{{{CONTINUE{9421
{{DAC{1,8{{{{9422
{{DTC{27,/CONTINUE/{{{{9423
{{DAC{6,L$CNT{{{{9424
{{EJC{{{{{9425
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DTP{DBC{2,SVFNP{{{DATATYPE{9429
{{DAC{1,8{{{{9430
{{DTC{27,/DATATYPE/{{{{9431
{{DAC{6,S$DTP{{{{9432
{{DAC{1,1{{{{9433
*
{V$ERL{DBC{2,SVKNM{{{ERRLIMIT{9435
{{DAC{1,8{{{{9436
{{DTC{27,/ERRLIMIT/{{{{9437
{{DAC{2,K$ERL{{{{9438
*
{V$FNC{DBC{2,SVKNM{{{FNCLEVEL{9440
{{DAC{1,8{{{{9441
{{DTC{27,/FNCLEVEL/{{{{9442
{{DAC{2,K$FNC{{{{9443
*
{V$FLS{DBC{2,SVKNM{{{FULLSCAN{9445
{{DAC{1,8{{{{9446
{{DTC{27,/FULLSCAN/{{{{9447
{{DAC{2,K$FLS{{{{9448
*
{V$LFL{DBC{2,SVKNM{{{LASTFILE{9451
{{DAC{1,8{{{{9452
{{DTC{27,/LASTFILE/{{{{9453
{{DAC{2,K$LFL{{{{9454
*
{V$LLN{DBC{2,SVKNM{{{LASTLINE{9458
{{DAC{1,8{{{{9459
{{DTC{27,/LASTLINE/{{{{9460
{{DAC{2,K$LLN{{{{9461
*
{V$MXL{DBC{2,SVKNM{{{MAXLNGTH{9464
{{DAC{1,8{{{{9465
{{DTC{27,/MAXLNGTH/{{{{9466
{{DAC{2,K$MXL{{{{9467
*
{V$TER{DBC{1,0{{{TERMINAL{9469
{{DAC{1,8{{{{9470
{{DTC{27,/TERMINAL/{{{{9471
{{DAC{1,0{{{{9472
*
{V$BSP{DBC{2,SVFNN{{{BACKSPACE{9475
{{DAC{1,9{{{{9476
{{DTC{27,/BACKSPACE/{{{{9477
{{DAC{6,S$BSP{{{{9478
{{DAC{1,1{{{{9479
*
{V$PRO{DBC{2,SVFNN{{{PROTOTYPE{9482
{{DAC{1,9{{{{9483
{{DTC{27,/PROTOTYPE/{{{{9484
{{DAC{6,S$PRO{{{{9485
{{DAC{1,1{{{{9486
*
{V$SCN{DBC{2,SVLBL{{{SCONTINUE{9488
{{DAC{1,9{{{{9489
{{DTC{27,/SCONTINUE/{{{{9490
{{DAC{6,L$SCN{{{{9491
*
{{DBC{1,0{{{DUMMY ENTRY TO END LIST{9493
{{DAC{1,10{{{LENGTH GT 9 (SCONTINUE){9494
{{EJC{{{{{9495
*
*      LIST OF SVBLK POINTERS FOR KEYWORDS TO BE DUMPED. THE
*      LIST IS IN THE ORDER WHICH APPEARS ON THE DUMP OUTPUT.
*
{VDMKW{DAC{4,V$ANC{{{ANCHOR{9500
{{DAC{4,V$CAS{{{CCASE{9502
{{DAC{4,V$COD{{{CODE{9504
{{DAC{1,1{{{COMPARE NOT PRINTED{9509
{{DAC{4,V$DMP{{{DUMP{9512
{{DAC{4,V$ERL{{{ERRLIMIT{9513
{{DAC{4,V$ETX{{{ERRTEXT{9514
{{DAC{4,V$ERT{{{ERRTYPE{9515
{{DAC{4,V$FIL{{{FILE{9517
{{DAC{4,V$FNC{{{FNCLEVEL{9519
{{DAC{4,V$FTR{{{FTRACE{9520
{{DAC{4,V$FLS{{{FULLSCAN{9521
{{DAC{4,V$INP{{{INPUT{9522
{{DAC{4,V$LFL{{{LASTFILE{9524
{{DAC{4,V$LLN{{{LASTLINE{9527
{{DAC{4,V$LST{{{LASTNO{9529
{{DAC{4,V$LIN{{{LINE{9531
{{DAC{4,V$MXL{{{MAXLENGTH{9533
{{DAC{4,V$OUP{{{OUTPUT{9534
{{DAC{4,V$PFL{{{PROFILE{9537
{{DAC{4,V$RTN{{{RTNTYPE{9539
{{DAC{4,V$STC{{{STCOUNT{9540
{{DAC{4,V$STL{{{STLIMIT{9541
{{DAC{4,V$STN{{{STNO{9542
{{DAC{4,V$TRA{{{TRACE{9543
{{DAC{4,V$TRM{{{TRIM{9544
{{DAC{1,0{{{END OF LIST{9545
*
*      TABLE USED BY GTNVR TO SEARCH SVBLK LISTS
*
{VSRCH{DAC{1,0{{{DUMMY ENTRY TO GET PROPER INDEXING{9549
{{DAC{4,V$EQF{{{START OF 1 CHAR VARIABLES (NONE){9550
{{DAC{4,V$EQF{{{START OF 2 CHAR VARIABLES{9551
{{DAC{4,V$ANY{{{START OF 3 CHAR VARIABLES{9552
{{DAC{4,V$ATN{{{START OF 4 CHAR VARIABLES{9554
{{DAC{4,V$ABE{{{START OF 5 CHAR VARIABLES{9562
{{DAC{4,V$ANC{{{START OF 6 CHAR VARIABLES{9563
{{DAC{4,V$COL{{{START OF 7 CHAR VARIABLES{9564
{{DAC{4,V$ALP{{{START OF 8 CHAR VARIABLES{9565
{{DAC{4,V$BSP{{{START OF 9 CHAR VARIABLES{9567
*
*      LAST LOCATION IN CONSTANT SECTION
*
{C$YYY{DAC{1,0{{{LAST LOCATION IN CONSTANT SECTION{9574
{{TTL{27,S P I T B O L -- WORKING STORAGE SECTION{{{{9575
*
*      THE WORKING STORAGE SECTION CONTAINS AREAS WHICH ARE
*      CHANGED DURING EXECUTION OF THE PROGRAM. THE VALUE
*      ASSEMBLED IS THE INITIAL VALUE BEFORE EXECUTION STARTS.
*
*      ALL THESE AREAS ARE FIXED LENGTH AREAS. VARIABLE LENGTH
*      DATA IS STORED IN THE STATIC OR DYNAMIC REGIONS OF THE
*      ALLOCATED DATA AREAS.
*
*      THE VALUES IN THIS AREA ARE DESCRIBED EITHER AS WORK
*      AREAS OR AS GLOBAL VALUES. A WORK AREA IS USED IN AN
*      EPHEMERAL MANNER AND THE VALUE IS NOT SAVED FROM ONE
*      ENTRY INTO A ROUTINE TO ANOTHER. A GLOBAL VALUE IS A
*      LESS TEMPORARY LOCATION WHOSE VALUE IS SAVED FROM ONE
*      CALL TO ANOTHER.
*
*      W$AAA MARKS THE START OF THE WORKING SECTION WHILST
*      W$YYY MARKS ITS END.  G$AAA MARKS THE DIVISION BETWEEN
*      TEMPORARY AND GLOBAL VALUES.
*
*      GLOBAL VALUES ARE FURTHER SUBDIVIDED TO FACILITATE
*      PROCESSING BY THE GARBAGE COLLECTOR. R$AAA THROUGH
*      R$YYY ARE GLOBAL VALUES THAT MAY POINT INTO DYNAMIC
*      STORAGE AND HENCE MUST BE RELOCATED AFTER EACH GARBAGE
*      COLLECTION.  THEY ALSO SERVE AS ROOT POINTERS TO ALL
*      ALLOCATED DATA THAT MUST BE PRESERVED.  POINTERS BETWEEN
*      A$AAA AND R$AAA MAY POINT INTO CODE, STATIC STORAGE,
*      OR MARK THE LIMITS OF DYNAMIC MEMORY.  THESE POINTERS
*      MUST BE ADJUSTED WHEN THE WORKING SECTION IS SAVED TO A
*      FILE AND SUBSEQUENTLY RELOADED AT A DIFFERENT ADDRESS.
*
*      A GENERAL PART OF THE APPROACH IN THIS PROGRAM IS NOT
*      TO OVERLAP WORK AREAS BETWEEN PROCEDURES EVEN THOUGH A
*      SMALL AMOUNT OF SPACE COULD BE SAVED. SUCH OVERLAP IS
*      CONSIDERED A SOURCE OF PROGRAM ERRORS AND DECREASES THE
*      INFORMATION LEFT BEHIND AFTER A SYSTEM CRASH OF ANY KIND.
*
*      THE NAMES OF THESE LOCATIONS ARE LABELS WITH FIVE LETTER
*      (A-Y,$) NAMES. AS FAR AS POSSIBLE THE ORDER IS KEPT
*      ALPHABETICAL BY THESE NAMES BUT IN SOME CASES THERE
*      ARE SLIGHT DEPARTURES CAUSED BY OTHER ORDER REQUIREMENTS.
*
*      UNLESS OTHERWISE DOCUMENTED, THE ORDER OF WORK AREAS
*      DOES NOT AFFECT THE EXECUTION OF THE SPITBOL PROGRAM.
*
{{SEC{{{{START OF WORKING STORAGE SECTION{9621
{{EJC{{{{{9622
*
*      THIS AREA IS NOT CLEARED BY INITIAL CODE
*
{CMLAB{DAC{6,B$SCL{{{STRING USED TO CHECK LABEL LEGALITY{9626
{{DAC{1,2{{{{9627
{{DTC{27,/  /{{{{9628
*
*      LABEL TO MARK START OF WORK AREA
*
{W$AAA{DAC{1,0{{{{9632
*
*      WORK AREAS FOR ACESS PROCEDURE
*
{ACTRM{DAC{1,0{{{TRIM INDICATOR{9636
*
*      WORK AREAS FOR ALLOC PROCEDURE
*
{ALDYN{DAC{1,0{{{AMOUNT OF DYNAMIC STORE{9640
{ALLIA{DIC{16,+0{{{DUMP IA{9641
{ALLSV{DAC{1,0{{{SAVE WB IN ALLOC{9642
*
*      WORK AREAS FOR ALOST PROCEDURE
*
{ALSTA{DAC{1,0{{{SAVE WA IN ALOST{9646
*
*      WORK AREAS FOR ARRAY FUNCTION (S$ARR)
*
{ARCDM{DAC{1,0{{{COUNT DIMENSIONS{9650
{ARNEL{DIC{16,+0{{{COUNT ELEMENTS{9651
{ARPTR{DAC{1,0{{{OFFSET PTR INTO ARBLK{9652
{ARSVL{DIC{16,+0{{{SAVE INTEGER LOW BOUND{9653
{{EJC{{{{{9654
*
*      WORK AREAS FOR ARREF ROUTINE
*
{ARFSI{DIC{16,+0{{{SAVE CURRENT EVOLVING SUBSCRIPT{9658
{ARFXS{DAC{1,0{{{SAVE BASE STACK POINTER{9659
*
*      WORK AREAS FOR B$EFC BLOCK ROUTINE
*
{BEFOF{DAC{1,0{{{SAVE OFFSET PTR INTO EFBLK{9663
*
*      WORK AREAS FOR B$PFC BLOCK ROUTINE
*
{BPFPF{DAC{1,0{{{SAVE PFBLK POINTER{9667
{BPFSV{DAC{1,0{{{SAVE OLD FUNCTION VALUE{9668
{BPFXT{DAC{1,0{{{POINTER TO STACKED ARGUMENTS{9669
*
*      WORK AREA FOR COLLECT FUNCTION (S$COL)
*
{CLSVI{DIC{16,+0{{{SAVE INTEGER ARGUMENT{9673
*
*      WORK AREAS VALUE FOR CNCRD
*
{CNSCC{DAC{1,0{{{POINTER TO CONTROL CARD STRING{9677
{CNSWC{DAC{1,0{{{WORD COUNT{9678
{CNR$T{DAC{1,0{{{POINTER TO R$TTL OR R$STL{9679
*
*      WORK AREAS FOR CONVERT FUNCTION (S$CNV)
*
{CNVTP{DAC{1,0{{{SAVE PTR INTO SCVTB{9683
*
*      WORK AREAS FOR DATA FUNCTION (S$DAT)
*
{DATDV{DAC{1,0{{{SAVE VRBLK PTR FOR DATATYPE NAME{9687
{DATXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{9688
*
*      WORK AREAS FOR DEFINE FUNCTION (S$DEF)
*
{DEFLB{DAC{1,0{{{SAVE VRBLK PTR FOR LABEL{9692
{DEFNA{DAC{1,0{{{COUNT FUNCTION ARGUMENTS{9693
{DEFVR{DAC{1,0{{{SAVE VRBLK PTR FOR FUNCTION NAME{9694
{DEFXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{9695
*
*      WORK AREAS FOR DUMPR PROCEDURE
*
{DMARG{DAC{1,0{{{DUMP ARGUMENT{9699
{DMPSA{DAC{1,0{{{PRESERVE WA OVER PRTVL CALL{9700
{DMPSB{DAC{1,0{{{PRESERVE WB OVER SYSCM CALL{9702
{DMPSV{DAC{1,0{{{GENERAL SCRATCH SAVE{9704
{DMVCH{DAC{1,0{{{CHAIN POINTER FOR VARIABLE BLOCKS{9705
{DMPCH{DAC{1,0{{{SAVE SORTED VRBLK CHAIN POINTER{9706
{DMPKB{DAC{1,0{{{DUMMY KVBLK FOR USE IN DUMPR{9707
{DMPKT{DAC{1,0{{{KVVAR TRBLK PTR (MUST FOLLOW DMPKB){9708
{DMPKN{DAC{1,0{{{KEYWORD NUMBER (MUST FOLLOW DMPKT){9709
*
*      WORK AREA FOR DTACH
*
{DTCNB{DAC{1,0{{{NAME BASE{9713
{DTCNM{DAC{1,0{{{NAME PTR{9714
*
*      WORK AREAS FOR DUPL FUNCTION (S$DUP)
*
{DUPSI{DIC{16,+0{{{STORE INTEGER STRING LENGTH{9718
*
*      WORK AREA FOR ENDFILE (S$ENF)
*
{ENFCH{DAC{1,0{{{FOR IOCHN CHAIN HEAD{9722
{{EJC{{{{{9723
*
*      WORK AREAS FOR ERTEX
*
{ERTWA{DAC{1,0{{{SAVE WA{9727
{ERTWB{DAC{1,0{{{SAVE WB{9728
*
*      WORK AREAS FOR EVALI
*
{EVLIN{DAC{1,0{{{DUMMY PATTERN BLOCK PCODE{9732
{EVLIS{DAC{1,0{{{THEN NODE (MUST FOLLOW EVLIN){9733
{EVLIV{DAC{1,0{{{VALUE OF PARM1 (MUST FOLLOW EVLIS){9734
{EVLIO{DAC{1,0{{{PTR TO ORIGINAL NODE{9735
{EVLIF{DAC{1,0{{{FLAG FOR SIMPLE/COMPLEX ARGUMENT{9736
*
*      WORK AREA FOR EXPAN
*
{EXPSV{DAC{1,0{{{SAVE OP DOPE VECTOR POINTER{9740
*
*      WORK AREAS FOR GBCOL PROCEDURE
*
{GBCFL{DAC{1,0{{{GARBAGE COLLECTOR ACTIVE FLAG{9744
{GBCLM{DAC{1,0{{{POINTER TO LAST MOVE BLOCK (PASS 3){9745
{GBCNM{DAC{1,0{{{DUMMY FIRST MOVE BLOCK{9746
{GBCNS{DAC{1,0{{{REST OF DUMMY BLOCK (FOLLOWS GBCNM){9747
{GBCIA{DIC{16,+0{{{DUMP IA{9753
{GBCSD{DAC{1,0{{{FIRST ADDRESS BEYOND SEDIMENT{9754
{GBCSF{DAC{1,0{{{FREE SPACE WITHIN SEDIMENT{9755
{GBSVA{DAC{1,0{{{SAVE WA{9757
{GBSVB{DAC{1,0{{{SAVE WB{9758
{GBSVC{DAC{1,0{{{SAVE WC{9759
*
*      WORK AREAS FOR GTNVR PROCEDURE
*
{GNVHE{DAC{1,0{{{PTR TO END OF HASH CHAIN{9763
{GNVNW{DAC{1,0{{{NUMBER OF WORDS IN STRING NAME{9764
{GNVSA{DAC{1,0{{{SAVE WA{9765
{GNVSB{DAC{1,0{{{SAVE WB{9766
{GNVSP{DAC{1,0{{{POINTER INTO VSRCH TABLE{9767
{GNVST{DAC{1,0{{{POINTER TO CHARS OF STRING{9768
*
*      WORK AREAS FOR GTARR
*
{GTAWA{DAC{1,0{{{SAVE WA{9772
*
*      WORK AREAS FOR GTINT
*
{GTINA{DAC{1,0{{{SAVE WA{9776
{GTINB{DAC{1,0{{{SAVE WB{9777
{{EJC{{{{{9778
*
*      WORK AREAS FOR GTNUM PROCEDURE
*
{GTNNF{DAC{1,0{{{ZERO/NONZERO FOR RESULT +/-{9782
{GTNSI{DIC{16,+0{{{GENERAL INTEGER SAVE{9783
{GTNDF{DAC{1,0{{{0/1 FOR DEC POINT SO FAR NO/YES{9786
{GTNES{DAC{1,0{{{ZERO/NONZERO EXPONENT +/-{9787
{GTNEX{DIC{16,+0{{{REAL EXPONENT{9788
{GTNSC{DAC{1,0{{{SCALE (PLACES AFTER POINT){9789
{GTNSR{DRC{17,+0.0{{{GENERAL REAL SAVE{9790
{GTNRD{DAC{1,0{{{FLAG FOR OK REAL NUMBER{9791
*
*      WORK AREAS FOR GTPAT PROCEDURE
*
{GTPSB{DAC{1,0{{{SAVE WB{9796
*
*      WORK AREAS FOR GTSTG PROCEDURE
*
{GTSSF{DAC{1,0{{{0/1 FOR RESULT +/-{9800
{GTSVC{DAC{1,0{{{SAVE WC{9801
{GTSVB{DAC{1,0{{{SAVE WB{9802
{GTSES{DAC{1,0{{{CHAR + OR - FOR EXPONENT +/-{9807
{GTSRS{DRC{17,+0.0{{{GENERAL REAL SAVE{9808
*
*      WORK AREAS FOR GTVAR PROCEDURE
*
{GTVRC{DAC{1,0{{{SAVE WC{9814
*
*      WORK AREAS FOR IOPUT
*
{IOPTT{DAC{1,0{{{TYPE OF ASSOCIATION{9829
*
*      WORK AREAS FOR LOAD FUNCTION
*
{LODFN{DAC{1,0{{{POINTER TO VRBLK FOR FUNC NAME{9835
{LODNA{DAC{1,0{{{COUNT NUMBER OF ARGUMENTS{9836
*
*      WORK AREA FOR PROFILER
*
{PFSVW{DAC{1,0{{{TO SAVE A W-REG{9843
*
*      WORK AREAS FOR PRTNM PROCEDURE
*
{PRNSI{DIC{16,+0{{{SCRATCH INTEGER LOC{9848
*
*      WORK AREAS FOR PRTSN PROCEDURE
*
{PRSNA{DAC{1,0{{{SAVE WA{9852
*
*      WORK AREAS FOR PRTST PROCEDURE
*
{PRSVA{DAC{1,0{{{SAVE WA{9856
{PRSVB{DAC{1,0{{{SAVE WB{9857
{PRSVC{DAC{1,0{{{SAVE CHAR COUNTER{9858
*
*      WORK AREA FOR PRTNL
*
{PRTSA{DAC{1,0{{{SAVE WA{9862
{PRTSB{DAC{1,0{{{SAVE WB{9863
*
*      WORK AREA FOR PRTVL
*
{PRVSI{DAC{1,0{{{SAVE IDVAL{9867
*
*      WORK AREAS FOR PATTERN MATCH ROUTINES
*
{PSAVE{DAC{1,0{{{TEMPORARY SAVE FOR CURRENT NODE PTR{9871
{PSAVC{DAC{1,0{{{SAVE CURSOR IN P$SPN, P$STR{9872
*
*      WORK AREA FOR RELAJ ROUTINE
*
{RLALS{DAC{1,0{{{PTR TO LIST OF BOUNDS AND ADJUSTS{9877
*
*      WORK AREA FOR RELDN ROUTINE
*
{RLDCD{DAC{1,0{{{SAVE CODE ADJUSTMENT{9881
{RLDST{DAC{1,0{{{SAVE STATIC ADJUSTMENT{9882
{RLDLS{DAC{1,0{{{SAVE LIST POINTER{9883
*
*      WORK AREAS FOR RETRN ROUTINE
*
{RTNBP{DAC{1,0{{{TO SAVE A BLOCK POINTER{9888
{RTNFV{DAC{1,0{{{NEW FUNCTION VALUE (RESULT){9889
{RTNSV{DAC{1,0{{{OLD FUNCTION VALUE (SAVED VALUE){9890
*
*      WORK AREAS FOR SUBSTR FUNCTION (S$SUB)
*
{SBSSV{DAC{1,0{{{SAVE THIRD ARGUMENT{9894
*
*      WORK AREAS FOR SCAN PROCEDURE
*
{SCNSA{DAC{1,0{{{SAVE WA{9898
{SCNSB{DAC{1,0{{{SAVE WB{9899
{SCNSC{DAC{1,0{{{SAVE WC{9900
{SCNOF{DAC{1,0{{{SAVE OFFSET{9901
{{EJC{{{{{9904
*
*      WORK AREA USED BY SORTA, SORTC, SORTF, SORTH
*
{SRTDF{DAC{1,0{{{DATATYPE FIELD NAME{9908
{SRTFD{DAC{1,0{{{FOUND DFBLK ADDRESS{9909
{SRTFF{DAC{1,0{{{FOUND FIELD NAME{9910
{SRTFO{DAC{1,0{{{OFFSET TO FIELD NAME{9911
{SRTNR{DAC{1,0{{{NUMBER OF ROWS{9912
{SRTOF{DAC{1,0{{{OFFSET WITHIN ROW TO SORT KEY{9913
{SRTRT{DAC{1,0{{{ROOT OFFSET{9914
{SRTS1{DAC{1,0{{{SAVE OFFSET 1{9915
{SRTS2{DAC{1,0{{{SAVE OFFSET 2{9916
{SRTSC{DAC{1,0{{{SAVE WC{9917
{SRTSF{DAC{1,0{{{SORT ARRAY FIRST ROW OFFSET{9918
{SRTSN{DAC{1,0{{{SAVE N{9919
{SRTSO{DAC{1,0{{{OFFSET TO A(0){9920
{SRTSR{DAC{1,0{{{0, NON-ZERO FOR SORT, RSORT{9921
{SRTST{DAC{1,0{{{STRIDE FROM ONE ROW TO NEXT{9922
{SRTWC{DAC{1,0{{{DUMP WC{9923
*
*      WORK AREAS FOR STOPR ROUTINE
*
{STPSI{DIC{16,+0{{{SAVE VALUE OF STCOUNT{9928
{STPTI{DIC{16,+0{{{SAVE TIME ELAPSED{9929
*
*      WORK AREAS FOR TFIND PROCEDURE
*
{TFNSI{DIC{16,+0{{{NUMBER OF HEADERS{9933
*
*      WORK AREAS FOR XSCAN PROCEDURE
*
{XSCRT{DAC{1,0{{{SAVE RETURN CODE{9937
{XSCWB{DAC{1,0{{{SAVE REGISTER WB{9938
*
*      START OF GLOBAL VALUES IN WORKING SECTION
*
{G$AAA{DAC{1,0{{{{9942
*
*      GLOBAL VALUE FOR ALLOC PROCEDURE
*
{ALFSF{DIC{16,+0{{{FACTOR IN FREE STORE PCNTAGE CHECK{9946
*
*      GLOBAL VALUES FOR CMPIL PROCEDURE
*
{CMERC{DAC{1,0{{{COUNT OF INITIAL COMPILE ERRORS{9950
{CMPLN{DAC{1,0{{{LINE NUMBER OF FIRST LINE OF STMT{9951
{CMPXS{DAC{1,0{{{SAVE STACK PTR IN CASE OF ERRORS{9952
{CMPSN{DAC{1,1{{{NUMBER OF NEXT STATEMENT TO COMPILE{9953
*
*      GLOBAL VALUES FOR CNCRD
*
{CNSIL{DAC{1,0{{{SAVE SCNIL DURING INCLUDE PROCESS.{9958
{CNIND{DAC{1,0{{{CURRENT INCLUDE FILE NEST LEVEL{9959
{CNSPT{DAC{1,0{{{SAVE SCNPT DURING INCLUDE PROCESS.{9960
{CNTTL{DAC{1,0{{{FLAG FOR -TITLE, -STITL{9962
*
*      GLOBAL FLAG FOR SUPPRESSION OF COMPILATION STATISTICS.
*
{CPSTS{DAC{1,0{{{SUPPRESS COMP. STATS IF NON ZERO{9966
*
*      GLOBAL VALUES FOR CONTROL CARD SWITCHES
*
{CSWDB{DAC{1,0{{{0/1 FOR -SINGLE/-DOUBLE{9970
{CSWER{DAC{1,0{{{0/1 FOR -ERRORS/-NOERRORS{9971
{CSWEX{DAC{1,0{{{0/1 FOR -EXECUTE/-NOEXECUTE{9972
{CSWFL{DAC{1,1{{{0/1 FOR -NOFAIL/-FAIL{9973
{CSWIN{DAC{2,INILN{{{XXX FOR -INXXX{9974
{CSWLS{DAC{1,1{{{0/1 FOR -NOLIST/-LIST{9975
{CSWNO{DAC{1,0{{{0/1 FOR -OPTIMISE/-NOOPT{9976
{CSWPR{DAC{1,0{{{0/1 FOR -NOPRINT/-PRINT{9977
*
*      GLOBAL LOCATION USED BY PATST PROCEDURE
*
{CTMSK{DBC{1,0{{{LAST BIT POSITION USED IN R$CTP{9981
{CURID{DAC{1,0{{{CURRENT ID VALUE{9982
{{EJC{{{{{9983
*
*      GLOBAL VALUE FOR CDWRD PROCEDURE
*
{CWCOF{DAC{1,0{{{NEXT WORD OFFSET IN CURRENT CCBLK{9987
*
*      GLOBAL LOCATIONS FOR DYNAMIC STORAGE POINTERS
*
{DNAMS{DAC{1,0{{{SIZE OF SEDIMENT IN BAUS{9992
*
*      GLOBAL AREA FOR ERROR PROCESSING.
*
{ERICH{DAC{1,0{{{COPY ERROR REPORTS TO INT.CHAN IF 1{9997
{ERLST{DAC{1,0{{{FOR LISTR WHEN ERRORS GO TO INT.CH.{9998
{ERRFT{DAC{1,0{{{FATAL ERROR FLAG{9999
{ERRSP{DAC{1,0{{{ERROR SUPPRESSION FLAG{10000
*
*      GLOBAL FLAG FOR SUPPRESSION OF EXECUTION STATS
*
{EXSTS{DAC{1,0{{{SUPPRESS EXEC STATS IF SET{10004
*
*      GLOBAL VALUES FOR EXFAL AND RETURN
*
{FLPRT{DAC{1,0{{{LOCATION OF FAIL OFFSET FOR RETURN{10008
{FLPTR{DAC{1,0{{{LOCATION OF FAILURE OFFSET ON STACK{10009
*
*      GLOBAL LOCATION TO COUNT GARBAGE COLLECTIONS (GBCOL)
*
{GBSED{DIC{16,+0{{{FACTOR IN SEDIMENT PCNTAGE CHECK{10014
{GBCNT{DAC{1,0{{{COUNT OF GARBAGE COLLECTIONS{10016
*
*      GLOBAL VALUE FOR GTCOD AND GTEXP
*
{GTCEF{DAC{1,0{{{SAVE FAIL PTR IN CASE OF ERROR{10020
*
*      GLOBAL LOCATIONS FOR GTSTG PROCEDURE
*
{GTSRN{DRC{17,+0.0{{{ROUNDING FACTOR 0.5*10**-CFP$S{10028
{GTSSC{DRC{17,+0.0{{{SCALING VALUE 10**CFP$S{10029
{GTSWK{DAC{1,0{{{PTR TO WORK AREA FOR GTSTG{10032
*
*      GLOBAL FLAG FOR HEADER PRINTING
*
{HEADP{DAC{1,0{{{HEADER PRINTED FLAG{10036
*
*      GLOBAL VALUES FOR VARIABLE HASH TABLE
*
{HSHNB{DIC{16,+0{{{NUMBER OF HASH BUCKETS{10040
*
*      GLOBAL AREAS FOR INIT
*
{INITR{DAC{1,0{{{SAVE TERMINAL FLAG{10044
{{EJC{{{{{10045
*
*      GLOBAL VALUES FOR KEYWORD VALUES WHICH ARE STORED AS ONE
*      WORD INTEGERS. THESE VALUES MUST BE ASSEMBLED IN THE
*      FOLLOWING ORDER (AS DICTATED BY K$XXX DEFINITION VALUES).
*
{KVABE{DAC{1,0{{{ABEND{10051
{KVANC{DAC{1,0{{{ANCHOR{10052
{KVCAS{DAC{1,0{{{CASE{10054
{KVCOD{DAC{1,0{{{CODE{10056
{KVCOM{DAC{1,0{{{COMPARE{10058
{KVDMP{DAC{1,0{{{DUMP{10060
{KVERL{DAC{1,0{{{ERRLIMIT{10061
{KVERT{DAC{1,0{{{ERRTYPE{10062
{KVFTR{DAC{1,0{{{FTRACE{10063
{KVFLS{DAC{1,1{{{FULLSCAN{10064
{KVINP{DAC{1,1{{{INPUT{10065
{KVMXL{DAC{1,5000{{{MAXLENGTH{10066
{KVOUP{DAC{1,1{{{OUTPUT{10067
{KVPFL{DAC{1,0{{{PROFILE{10070
{KVTRA{DAC{1,0{{{TRACE{10072
{KVTRM{DAC{1,0{{{TRIM{10073
{KVFNC{DAC{1,0{{{FNCLEVEL{10074
{KVLST{DAC{1,0{{{LASTNO{10075
{KVLLN{DAC{1,0{{{LASTLINE{10077
{KVLIN{DAC{1,0{{{LINE{10078
{KVSTN{DAC{1,0{{{STNO{10080
*
*      GLOBAL VALUES FOR OTHER KEYWORDS
*
{KVALP{DAC{1,0{{{ALPHABET{10084
{KVRTN{DAC{4,NULLS{{{RTNTYPE (SCBLK POINTER){10085
{KVSTL{DIC{16,+2147483647{{{STLIMIT{10091
{KVSTC{DIC{16,+2147483647{{{STCOUNT (COUNTS DOWN FROM STLIMIT){10092
*
*      GLOBAL VALUES FOR LISTR PROCEDURE
*
{LSTID{DAC{1,0{{{INCLUDE DEPTH OF CURRENT IMAGE{10102
{LSTLC{DAC{1,0{{{COUNT LINES ON SOURCE LIST PAGE{10104
{LSTNP{DAC{1,0{{{MAX NUMBER OF LINES ON PAGE{10105
{LSTPF{DAC{1,1{{{SET NONZERO IF CURRENT IMAGE LISTED{10106
{LSTPG{DAC{1,0{{{CURRENT SOURCE LIST PAGE NUMBER{10107
{LSTPO{DAC{1,0{{{OFFSET TO   PAGE NNN   MESSAGE{10108
{LSTSN{DAC{1,0{{{REMEMBER LAST STMNUM LISTED{10109
*
*      GLOBAL MAXIMUM SIZE OF SPITBOL OBJECTS
*
{MXLEN{DAC{1,0{{{INITIALISED BY SYSMX CALL{10113
*
*      GLOBAL EXECUTION CONTROL VARIABLE
*
{NOXEQ{DAC{1,0{{{SET NON-ZERO TO INHIBIT EXECUTION{10117
*
*      GLOBAL PROFILER VALUES LOCATIONS
*
{PFDMP{DAC{1,0{{{SET NON-0 IF &PROFILE SET NON-0{10123
{PFFNC{DAC{1,0{{{SET NON-0 IF FUNCT JUST ENTERED{10124
{PFSTM{DIC{16,+0{{{TO STORE STARTING TIME OF STMT{10125
{PFETM{DIC{16,+0{{{TO STORE ENDING TIME OF STMT{10126
{PFNTE{DAC{1,0{{{NR OF TABLE ENTRIES{10127
{PFSTE{DIC{16,+0{{{GETS INT REP OF TABLE ENTRY SIZE{10128
*
{{EJC{{{{{10131
*
*      GLOBAL VALUES USED IN PATTERN MATCH ROUTINES
*
{PMDFL{DAC{1,0{{{PATTERN ASSIGNMENT FLAG{10135
{PMHBS{DAC{1,0{{{HISTORY STACK BASE POINTER{10136
{PMSSL{DAC{1,0{{{LENGTH OF SUBJECT STRING IN CHARS{10137
*
*      GLOBAL VALUES FOR INTERFACE POLLING (SYSPL)
*
{POLCS{DAC{1,1{{{POLL INTERVAL START VALUE{10142
{POLCT{DAC{1,1{{{POLL INTERVAL COUNTER{10143
*
*      GLOBAL FLAGS USED FOR STANDARD FILE LISTING OPTIONS
*
{PRICH{DAC{1,0{{{PRINTER ON INTERACTIVE CHANNEL{10148
{PRSTD{DAC{1,0{{{TESTED BY PRTPG{10149
{PRSTO{DAC{1,0{{{STANDARD LISTING OPTION FLAG{10150
*
*      GLOBAL VALUES FOR PRINT PROCEDURES
*
{PRBUF{DAC{1,0{{{PTR TO PRINT BFR IN STATIC{10154
{PRECL{DAC{1,0{{{EXTENDED/COMPACT LISTING FLAG{10155
{PRLEN{DAC{1,0{{{LENGTH OF PRINT BUFFER IN CHARS{10156
{PRLNW{DAC{1,0{{{LENGTH OF PRINT BUFFER IN WORDS{10157
{PROFS{DAC{1,0{{{OFFSET TO NEXT LOCATION IN PRBUF{10158
{PRTEF{DAC{1,0{{{ENDFILE FLAG{10159
{{EJC{{{{{10160
*
*      GLOBAL AREA FOR READR
*
{RDCLN{DAC{1,0{{{CURRENT STATEMENT LINE NUMBER{10164
{RDNLN{DAC{1,0{{{NEXT STATEMENT LINE NUMBER{10165
*
*      GLOBAL AMOUNT OF MEMORY RESERVED FOR END OF EXECUTION
*
{RSMEM{DAC{1,0{{{RESERVE MEMORY{10169
*
*      GLOBAL AREA FOR STMGO COUNTERS
*
{STMCS{DAC{1,1{{{COUNTER STARTUP VALUE{10173
{STMCT{DAC{1,1{{{COUNTER ACTIVE VALUE{10174
*
*      ADJUSTABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO THE
*      DYNAMIC OR THE STATIC REGION.
*      WHEN A SAVE FILE IS RELOADED, THESE POINTERS MUST
*      BE ADJUSTED IF STATIC OR DYNAMIC MEMORY IS NOW
*      AT A DIFFERENT ADDRESS.  SEE ROUTINE RELOC FOR
*      ADDITIONAL INFORMATION.
*
*      SOME VALUES CANNOT BE MOVE HERE BECAUSE OF ADJACENCY
*      CONSTRAINTS.  THEY ARE HANDLED SPECIALLY BY RELOC ET AL.
*      THESE VALUES ARE KVRTN,
*
*      VALUES GTSWK, KVALP, AND PRBUF ARE REINITIALIZED BY
*      PROCEDURE INSTA, AND DO NOT NEED TO APPEAR HERE.
*
*      VALUES FLPRT, FLPTR, GTCEF, AND STBAS POINT INTO THE
*      STACK AND ARE EXPLICITLY ADJUSTED BY OSINT'S RESTART
*      PROCEDURE.
*
{A$AAA{DAC{1,0{{{START OF ADJUSTABLE VALUES{10196
{CMPSS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{10197
{DNAMB{DAC{1,0{{{START OF DYNAMIC AREA{10198
{DNAMP{DAC{1,0{{{NEXT AVAILABLE LOC IN DYNAMIC AREA{10199
{DNAME{DAC{1,0{{{END OF AVAILABLE DYNAMIC AREA{10200
{HSHTB{DAC{1,0{{{POINTER TO START OF VRBLK HASH TABL{10201
{HSHTE{DAC{1,0{{{POINTER PAST END OF VRBLK HASH TABL{10202
{INISS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{10203
{PFTBL{DAC{1,0{{{GETS ADRS OF (IMAG) TABLE BASE{10204
{PRNMV{DAC{1,0{{{VRBLK PTR FROM LAST NAME SEARCH{10205
{STATB{DAC{1,0{{{START OF STATIC AREA{10206
{STATE{DAC{1,0{{{END OF STATIC AREA{10207
{STXVR{DAC{4,NULLS{{{VRBLK POINTER OR NULL{10208
*
*      RELOCATABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO BLOCKS IN
*      THE DYNAMIC STORAGE AREA AND MUST BE RELOCATED BY THE
*      GARBAGE COLLECTOR. THEY ARE IDENTIFIED BY R$XXX NAMES.
*
{R$AAA{DAC{1,0{{{START OF RELOCATABLE VALUES{10217
{R$ARF{DAC{1,0{{{ARRAY BLOCK POINTER FOR ARREF{10218
{R$CCB{DAC{1,0{{{PTR TO CCBLK BEING BUILT (CDWRD){10219
{R$CIM{DAC{1,0{{{PTR TO CURRENT COMPILER INPUT STR{10220
{R$CMP{DAC{1,0{{{COPY OF R$CIM USED IN CMPIL{10221
{R$CNI{DAC{1,0{{{PTR TO NEXT COMPILER INPUT STRING{10222
{R$CNT{DAC{1,0{{{CDBLK POINTER FOR SETEXIT CONTINUE{10223
{R$COD{DAC{1,0{{{POINTER TO CURRENT CDBLK OR EXBLK{10224
{R$CTP{DAC{1,0{{{PTR TO CURRENT CTBLK FOR PATST{10225
{R$CTS{DAC{1,0{{{PTR TO LAST STRING SCANNED BY PATST{10226
{R$ERT{DAC{1,0{{{TRBLK POINTER FOR ERRTYPE TRACE{10227
{R$ETX{DAC{4,NULLS{{{POINTER TO ERRTEXT STRING{10228
{R$EXS{DAC{1,0{{{= SAVE XL IN EXPDM{10229
{R$FCB{DAC{1,0{{{FCBLK CHAIN HEAD{10230
{R$FNC{DAC{1,0{{{TRBLK POINTER FOR FNCLEVEL TRACE{10231
{R$GTC{DAC{1,0{{{KEEP CODE PTR FOR GTCOD,GTEXP{10232
{R$ICI{DAC{1,0{{{SAVED R$CIM DURING INCLUDE PROCESS.{10234
{R$IFA{DAC{1,0{{{ARRAY OF FILE NAMES BY INCL. DEPTH{10236
{R$IFL{DAC{1,0{{{ARRAY OF LINE NUMS BY INCLUDE DEPTH{10237
{R$IFN{DAC{1,0{{{LAST INCLUDE FILE NAME{10239
{R$INC{DAC{1,0{{{TABLE OF INCLUDE FILE NAMES SEEN{10240
{R$IO1{DAC{1,0{{{FILE ARG1 FOR IOPUT{10242
{R$IO2{DAC{1,0{{{FILE ARG2 FOR IOPUT{10243
{R$IOF{DAC{1,0{{{FCBLK PTR OR 0{10244
{R$ION{DAC{1,0{{{NAME BASE PTR{10245
{R$IOP{DAC{1,0{{{PREDECESSOR BLOCK PTR FOR IOPUT{10246
{R$IOT{DAC{1,0{{{TRBLK PTR FOR IOPUT{10247
{R$PMS{DAC{1,0{{{SUBJECT STRING PTR IN PATTERN MATCH{10252
{R$RA2{DAC{1,0{{{REPLACE SECOND ARGUMENT LAST TIME{10253
{R$RA3{DAC{1,0{{{REPLACE THIRD ARGUMENT LAST TIME{10254
{R$RPT{DAC{1,0{{{PTR TO CTBLK REPLACE TABLE LAST USD{10255
{R$SCP{DAC{1,0{{{SAVE POINTER FROM LAST SCANE CALL{10256
{R$SFC{DAC{4,NULLS{{{CURRENT SOURCE FILE NAME{10258
{R$SFN{DAC{1,0{{{PTR TO SOURCE FILE NAME TABLE{10259
{R$SXL{DAC{1,0{{{PRESERVE XL IN SORTC{10261
{R$SXR{DAC{1,0{{{PRESERVE XR IN SORTA/SORTC{10262
{R$STC{DAC{1,0{{{TRBLK POINTER FOR STCOUNT TRACE{10263
{R$STL{DAC{1,0{{{SOURCE LISTING SUB-TITLE{10264
{R$SXC{DAC{1,0{{{CODE (CDBLK) PTR FOR SETEXIT TRAP{10265
{R$TTL{DAC{4,NULLS{{{SOURCE LISTING TITLE{10266
{R$XSC{DAC{1,0{{{STRING POINTER FOR XSCAN{10267
{{EJC{{{{{10268
*
*      THE REMAINING POINTERS IN THIS LIST ARE USED TO POINT
*      TO FUNCTION BLOCKS FOR NORMALLY UNDEFINED OPERATORS.
*
{R$UBA{DAC{4,STNDO{{{BINARY AT{10273
{R$UBM{DAC{4,STNDO{{{BINARY AMPERSAND{10274
{R$UBN{DAC{4,STNDO{{{BINARY NUMBER SIGN{10275
{R$UBP{DAC{4,STNDO{{{BINARY PERCENT{10276
{R$UBT{DAC{4,STNDO{{{BINARY NOT{10277
{R$UUB{DAC{4,STNDO{{{UNARY VERTICAL BAR{10278
{R$UUE{DAC{4,STNDO{{{UNARY EQUAL{10279
{R$UUN{DAC{4,STNDO{{{UNARY NUMBER SIGN{10280
{R$UUP{DAC{4,STNDO{{{UNARY PERCENT{10281
{R$UUS{DAC{4,STNDO{{{UNARY SLASH{10282
{R$UUX{DAC{4,STNDO{{{UNARY EXCLAMATION{10283
{R$YYY{DAC{1,0{{{LAST RELOCATABLE LOCATION{10284
*
*      GLOBAL LOCATIONS USED IN SCAN PROCEDURE
*
{SCNBL{DAC{1,0{{{SET NON-ZERO IF SCANNED PAST BLANKS{10288
{SCNCC{DAC{1,0{{{NON-ZERO TO SCAN CONTROL CARD NAME{10289
{SCNGO{DAC{1,0{{{SET NON-ZERO TO SCAN GOTO FIELD{10290
{SCNIL{DAC{1,0{{{LENGTH OF CURRENT INPUT IMAGE{10291
{SCNPT{DAC{1,0{{{POINTER TO NEXT LOCATION IN R$CIM{10292
{SCNRS{DAC{1,0{{{SET NON-ZERO TO SIGNAL RESCAN{10293
{SCNSE{DAC{1,0{{{START OF CURRENT ELEMENT{10294
{SCNTP{DAC{1,0{{{SAVE SYNTAX TYPE FROM LAST CALL{10295
*
*      GLOBAL VALUE FOR INDICATING STAGE (SEE ERROR SECTION)
*
{STAGE{DAC{1,0{{{INITIAL VALUE = INITIAL COMPILE{10299
{{EJC{{{{{10300
*
*      GLOBAL STACK POINTER
*
{STBAS{DAC{1,0{{{POINTER PAST STACK BASE{10304
*
*      GLOBAL VALUES FOR SETEXIT FUNCTION (S$STX)
*
{STXOC{DAC{1,0{{{CODE POINTER OFFSET{10308
{STXOF{DAC{1,0{{{FAILURE OFFSET{10309
*
*      GLOBAL VALUE FOR TIME KEEPING
*
{TIMSX{DIC{16,+0{{{TIME AT START OF EXECUTION{10313
{TIMUP{DAC{1,0{{{SET WHEN TIME UP OCCURS{10314
*
*      GLOBAL VALUES FOR XSCAN AND XSCNI PROCEDURES
*
{XSOFS{DAC{1,0{{{OFFSET TO CURRENT LOCATION IN R$XSC{10318
*
*      LABEL TO MARK END OF WORKING SECTION
*
{W$YYY{DAC{1,0{{{{10322
{{TTL{27,S P I T B O L -- MINIMAL CODE{{{{10323
{{SEC{{{{START OF PROGRAM SECTION{10324
{S$AAA{ENT{2,BL$$I{{{MARK START OF CODE{10325
{{TTL{27,S P I T B O L -- RELOCATION{{{{10327
*
*      RELOCATION
*      THE FOLLOWING SECTION PROVIDES SERVICES TO OSINT TO
*      RELOCATE PORTIONS OF THE WORKSPACE.  IT IS USED WHEN
*      A SAVED MEMORY IMAGE MUST BE RESTARTED AT A DIFFERENT
*      LOCATION.
*
*      RELAJ -- RELOCATE A LIST OF POINTERS
*
*      (WA)                  PTR PAST LAST POINTER OF LIST
*      (WB)                  PTR TO FIRST POINTER OF LIST
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELAJ            CALL TO PROCESS LIST OF POINTERS
*      (WB)                  DESTROYED
*
{RELAJ{PRC{25,E{1,0{{ENTRY POINT{10343
{{MOV{7,XR{11,-(XS){{SAVE XR{10344
{{MOV{8,WA{11,-(XS){{SAVE WA{10345
{{MOV{7,XL{3,RLALS{{SAVE PTR TO LIST OF BOUNDS{10346
{{MOV{8,WB{7,XR{{PTR TO FIRST POINTER TO PROCESS{10347
*
*      MERGE HERE TO CHECK IF DONE
*
{RLAJ0{MOV{3,RLALS{7,XL{{RESTORE XL{10351
{{BNE{7,XR{9,(XS){6,RLAJ1{PROCEED IF MORE TO DO{10352
{{MOV{10,(XS)+{8,WA{{RESTORE WA{10353
{{MOV{10,(XS)+{7,XR{{RESTORE XR{10354
{{EXI{{{{RETURN TO CALLER{10355
*
*      MERGE HERE TO PROCESS NEXT POINTER ON LIST
*
{RLAJ1{MOV{9,(XR){8,WA{{LOAD NEXT POINTER ON LIST{10359
{{LCT{8,WB{18,=RNSI${{NUMBER OF SECTIONS OF ADJUSTERS{10360
*
*      MERGE HERE TO PROCESS NEXT SECTION OF STACK LIST
*
{RLAJ2{BGT{8,WA{13,RLEND(XL){6,RLAJ3{OK IF PAST END OF SECTION{10364
{{BLT{8,WA{13,RLSTR(XL){6,RLAJ3{OR IF BEFORE START OF SECTION{10365
{{ADD{13,RLADJ(XL){8,WA{{WITHIN SECTION, ADD ADJUSTMENT{10366
{{MOV{8,WA{9,(XR){{RETURN UPDATED PTR TO MEMORY{10367
{{BRN{6,RLAJ4{{{DONE WITH THIS POINTER{10368
*
*      HERE IF NOT WITHIN SECTION
*
{RLAJ3{ADD{19,*RSSI${7,XL{{ADVANCE TO NEXT SECTION{10372
{{BCT{8,WB{6,RLAJ2{{JUMP IF MORE TO GO{10373
*
*      HERE WHEN FINISHED PROCESSING ONE POINTER
*
{RLAJ4{ICA{7,XR{{{INCREMENT TO NEXT PTR ON LIST{10377
{{BRN{6,RLAJ0{{{JUMP TO CHECK  FOR COMPLETION{10378
{{ENP{{{{END PROCEDURE RELAJ{10379
{{EJC{{{{{10380
*
*      RELCR -- CREATE RELOCATION INFO AFTER SAVE FILE RELOAD
*
*      (WA)                  ORIGINAL S$AAA CODE SECTION ADR
*      (WB)                  ORIGINAL C$AAA CONSTANT SECTION ADR
*      (WC)                  ORIGINAL G$AAA WORKING SECTION ADR
*      (XR)                  PTR TO START OF STATIC REGION
*      (CP)                  PTR TO START OF DYNAMIC REGION
*      (XL)                  PTR TO AREA TO RECEIVE INFORMATION
*      JSR  RELCR            CREATE RELOCATION INFORMATION
*      (WA,WB,WC,XR)         DESTROYED
*
*      A BLOCK OF INFORMATION IS BUILT AT (XL) THAT IS USED
*      IN RELOCATING POINTERS.  THERE ARE RNSI$ INSTANCES
*      OF A RSSI$ WORD STRUCTURE.  EACH INSTANCE CORRESPONDS
*      TO ONE OF THE REGIONS THAT A POINTER MIGHT POINT INTO.
*      THE LAYOUT OF THIS STRUCTURE IS SHOWN IN THE DEFINITIONS
*      SECTION, TOGETHER WITH SYMBOLIC DEFINITIONS OF THE
*      ENTRIES AS OFFSETS FROM XL.
*
{RELCR{PRC{25,E{1,0{{ENTRY POINT{10401
{{ADD{19,*RLSI${7,XL{{POINT PAST BUILD AREA{10402
{{MOV{8,WA{11,-(XL){{SAVE ORIGINAL CODE ADDRESS{10403
{{MOV{22,=S$AAA{8,WA{{COMPUTE ADJUSTMENT{10404
{{SUB{9,(XL){8,WA{{AS NEW S$AAA MINUS ORIGINAL S$AAA{10405
{{MOV{8,WA{11,-(XL){{SAVE CODE ADJUSTMENT{10406
{{MOV{22,=S$YYY{8,WA{{END OF TARGET CODE SECTION{10407
{{SUB{22,=S$AAA{8,WA{{LENGTH OF CODE SECTION{10408
{{ADD{13,NUM01(XL){8,WA{{PLUS ORIGINAL START ADDRESS{10409
{{MOV{8,WA{11,-(XL){{END OF ORIGINAL CODE SECTION{10410
{{MOV{8,WB{11,-(XL){{SAVE CONSTANT SECTION ADDRESS{10411
{{MOV{21,=C$AAA{8,WB{{START OF CONSTANTS SECTION{10412
{{MOV{21,=C$YYY{8,WA{{END OF CONSTANTS SECTION{10413
{{SUB{8,WB{8,WA{{LENGTH OF CONSTANTS SECTION{10414
{{SUB{9,(XL){8,WB{{NEW C$AAA MINUS ORIGINAL C$AAA{10415
{{MOV{8,WB{11,-(XL){{SAVE CONSTANT ADJUSTMENT{10416
{{ADD{13,NUM01(XL){8,WA{{LENGTH PLUS ORIGINAL START ADR{10417
{{MOV{8,WA{11,-(XL){{SAVE AS END OF ORIGINAL CONSTANTS{10418
{{MOV{8,WC{11,-(XL){{SAVE WORKING GLOBALS ADDRESS{10419
{{MOV{20,=G$AAA{8,WC{{START OF WORKING GLOBALS SECTION{10420
{{MOV{20,=W$YYY{8,WA{{END OF WORKING SECTION{10421
{{SUB{8,WC{8,WA{{LENGTH OF WORKING GLOBALS{10422
{{SUB{9,(XL){8,WC{{NEW G$AAA MINUS ORIGINAL G$AAA{10423
{{MOV{8,WC{11,-(XL){{SAVE WORKING GLOBALS ADJUSTMENT{10424
{{ADD{13,NUM01(XL){8,WA{{LENGTH PLUS ORIGINAL START ADR{10425
{{MOV{8,WA{11,-(XL){{SAVE AS END OF WORKING GLOBALS{10426
{{MOV{3,STATB{8,WB{{OLD START OF STATIC REGION{10427
{{MOV{8,WB{11,-(XL){{SAVE{10428
{{SUB{8,WB{7,XR{{COMPUTE ADJUSTMENT{10429
{{MOV{7,XR{11,-(XL){{SAVE NEW STATB MINUS OLD STATB{10430
{{MOV{3,STATE{11,-(XL){{OLD END OF STATIC REGION{10431
{{MOV{3,DNAMB{8,WB{{OLD START OF DYNAMIC REGION{10432
{{MOV{8,WB{11,-(XL){{SAVE{10433
{{SCP{8,WA{{{NEW START OF DYNAMIC{10434
{{SUB{8,WB{8,WA{{COMPUTE ADJUSTMENT{10435
{{MOV{8,WA{11,-(XL){{SAVE NEW DNAMB MINUS OLD DNAMB{10436
{{MOV{3,DNAMP{8,WC{{OLD END OF DYNAMIC REGION IN USE{10437
{{MOV{8,WC{11,-(XL){{SAVE AS END OF OLD DYNAMIC REGION{10438
{{EXI{{{{{10439
{{ENP{{{{{10440
{{EJC{{{{{10441
*
*      RELDN -- RELOCATE POINTERS IN THE DYNAMIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  RELDN            CALL TO PROCESS BLOCKS IN DYNAMIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      PROCESSES ALL BLOCKS IN THE DYNAMIC REGION.  WITHIN A
*      BLOCK, POINTERS TO THE CODE SECTION, CONSTANT SECTION,
*      WORKING GLOBALS SECTION, STATIC REGION, AND DYNAMIC
*      REGION ARE RELOCATED AS NEEDED.
*
{RELDN{PRC{25,E{1,0{{ENTRY POINT{10456
{{MOV{13,RLCDA(XL){3,RLDCD{{SAVE CODE ADJUSTMENT{10457
{{MOV{13,RLSTA(XL){3,RLDST{{SAVE STATIC ADJUSTMENT{10458
{{MOV{7,XL{3,RLDLS{{SAVE LIST POINTER{10459
*
*      MERGE HERE TO PROCESS THE NEXT BLOCK IN DYNAMIC
*
{RLD01{ADD{3,RLDCD{9,(XR){{ADJUST BLOCK TYPE WORD{10463
{{MOV{9,(XR){7,XL{{LOAD BLOCK TYPE WORD{10464
{{LEI{7,XL{{{LOAD ENTRY POINT ID (BL$XX){10465
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO RLD05 TO CONTINUE TO NEXT BLOCK.
*
*      NOTE THAT DFBLKS DO NOT APPEAR IN DYNAMIC, ONLY IN STATIC.
*      CCBLKS AND CMBLKS ARE NOT LIVE WHEN A SAVE FILE IS
*      CREATED, AND CAN BE SKIPPED.
*
*      FURTHER NOTE:  STATIC BLOCKS OTHER THAN VRBLKS DISCOVERED
*      WHILE SCANNING DYNAMIC MUST BE ADJUSTED AT THIS TIME.
*      SEE PROCESSING OF FFBLK FOR EXAMPLE.
*
{{EJC{{{{{10478
*
*      RELDN (CONTINUED)
*
{{BSW{7,XL{2,BL$$${{SWITCH ON BLOCK TYPE{10482
{{IFF{2,BL$AR{6,RLD03{{ARBLK{10519
{{IFF{2,BL$CD{6,RLD07{{CDBLK{10519
{{IFF{2,BL$EX{6,RLD10{{EXBLK{10519
{{IFF{2,BL$IC{6,RLD05{{ICBLK{10519
{{IFF{2,BL$NM{6,RLD13{{NMBLK{10519
{{IFF{2,BL$P0{6,RLD13{{P0BLK{10519
{{IFF{2,BL$P1{6,RLD14{{P1BLK{10519
{{IFF{2,BL$P2{6,RLD14{{P2BLK{10519
{{IFF{2,BL$RC{6,RLD05{{RCBLK{10519
{{IFF{2,BL$SC{6,RLD05{{SCBLK{10519
{{IFF{2,BL$SE{6,RLD13{{SEBLK{10519
{{IFF{2,BL$TB{6,RLD17{{TBBLK{10519
{{IFF{2,BL$VC{6,RLD17{{VCBLK{10519
{{IFF{2,BL$XN{6,RLD05{{XNBLK{10519
{{IFF{2,BL$XR{6,RLD20{{XRBLK{10519
{{IFF{2,BL$BC{6,RLD05{{BCBLK - DUMMY TO FILL OUT IFFS{10519
{{IFF{2,BL$PD{6,RLD15{{PDBLK{10519
{{IFF{2,BL$TR{6,RLD19{{TRBLK{10519
{{IFF{2,BL$BF{6,RLD05{{BFBLK{10519
{{IFF{2,BL$CC{6,RLD05{{CCBLK{10519
{{IFF{2,BL$CM{6,RLD05{{CMBLK{10519
{{IFF{2,BL$CT{6,RLD05{{CTBLK{10519
{{IFF{2,BL$DF{6,RLD05{{DFBLK{10519
{{IFF{2,BL$EF{6,RLD08{{EFBLK{10519
{{IFF{2,BL$EV{6,RLD09{{EVBLK{10519
{{IFF{2,BL$FF{6,RLD11{{FFBLK{10519
{{IFF{2,BL$KV{6,RLD13{{KVBLK{10519
{{IFF{2,BL$PF{6,RLD16{{PFBLK{10519
{{IFF{2,BL$TE{6,RLD18{{TEBLK{10519
{{ESW{{{{END OF JUMP TABLE{10519
*
*      ARBLK
*
{RLD03{MOV{13,ARLEN(XR){8,WA{{LOAD LENGTH{10523
{{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO 1ST RELOC FLD (ARPRO){10524
*
*      MERGE HERE TO PROCESS POINTERS IN A BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
{RLD04{ADD{7,XR{8,WA{{POINT PAST LAST RELOC FIELD{10533
{{ADD{7,XR{8,WB{{POINT TO FIRST RELOC FIELD{10534
{{MOV{3,RLDLS{7,XL{{POINT TO LIST OF BOUNDS{10535
{{JSR{6,RELAJ{{{ADJUST POINTERS{10536
{{EJC{{{{{10537
*
*      RELDN (CONTINUED)
*
*
*      MERGE HERE TO ADVANCE TO NEXT BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*
{RLD05{MOV{9,(XR){8,WA{{BLOCK TYPE WORD{10547
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{10548
{{ADD{8,WA{7,XR{{POINT TO NEXT BLOCK{10549
{{BLT{7,XR{8,WC{6,RLD01{CONTINUE IF MORE TO PROCESS{10550
{{MOV{3,RLDLS{7,XL{{RESTORE XL{10551
{{EXI{{{{RETURN TO CALLER IF DONE{10552
*
*      CDBLK
*
{RLD07{MOV{13,CDLEN(XR){8,WA{{LOAD LENGTH{10565
{{MOV{19,*CDFAL{8,WB{{SET OFFSET{10566
{{BNE{9,(XR){22,=B$CDC{6,RLD04{JUMP BACK IF NOT COMPLEX GOTO{10567
{{MOV{19,*CDCOD{8,WB{{DO NOT PROCESS CDFAL WORD{10568
{{BRN{6,RLD04{{{JUMP BACK{10569
*
*      EFBLK
*
*      IF THE EFCOD WORD POINTS TO AN XNBLK, THE XNBLK TYPE
*      WORD WILL NOT BE ADJUSTED.  SINCE THIS IS IMPLEMENTATION
*      DEPENDENT, WE WILL NOT WORRY ABOUT IT.
*
{RLD08{MOV{19,*EFRSL{8,WA{{SET LENGTH{10577
{{MOV{19,*EFCOD{8,WB{{AND OFFSET{10578
{{BRN{6,RLD04{{{ALL SET{10579
*
*      EVBLK
*
{RLD09{MOV{19,*OFFS3{8,WA{{POINT PAST THIRD FIELD{10583
{{MOV{19,*EVEXP{8,WB{{SET OFFSET{10584
{{BRN{6,RLD04{{{ALL SET{10585
*
*      EXBLK
*
{RLD10{MOV{13,EXLEN(XR){8,WA{{LOAD LENGTH{10589
{{MOV{19,*EXFLC{8,WB{{SET OFFSET{10590
{{BRN{6,RLD04{{{JUMP BACK{10591
{{EJC{{{{{10592
*
*      RELDN (CONTINUED)
*
*
*      FFBLK
*
*      THIS BLOCK CONTAINS A PTR TO A DFBLK IN THE STATIC RGN.
*      BECAUSE THERE ARE MULTIPLE FFBLKS POINTING TO THE SAME
*      DFBLK (ONE FOR EACH FIELD NAME), WE ONLY PROCESS THE
*      DFBLK WHEN WE ENCOUNTER THE FFBLK FOR THE FIRST FIELD.
*      THE DFBLK IN TURN CONTAINS A POINTER TO AN SCBLK WITHIN
*      STATIC.
*
{RLD11{BNE{13,FFOFS(XR){19,*PDFLD{6,RLD12{SKIP DFBLK IF NOT FIRST FIELD{10606
{{MOV{7,XR{11,-(XS){{SAVE XR{10607
{{MOV{13,FFDFP(XR){7,XR{{LOAD OLD PTR TO DFBLK{10608
{{ADD{3,RLDST{7,XR{{CURRENT LOCATION OF DFBLK{10609
{{ADD{3,RLDCD{9,(XR){{ADJUST DFBLK TYPE WORD{10610
{{MOV{13,DFLEN(XR){8,WA{{LENGTH OF DFBLK{10611
{{MOV{19,*DFNAM{8,WB{{OFFSET TO DFNAM FIELD{10612
{{ADD{7,XR{8,WA{{POINT PAST LAST RELOC FIELD{10613
{{ADD{7,XR{8,WB{{POINT TO FIRST RELOC FIELD{10614
{{MOV{3,RLDLS{7,XL{{POINT TO LIST OF BOUNDS{10615
{{JSR{6,RELAJ{{{ADJUST POINTERS{10616
{{MOV{13,DFNAM(XR){7,XR{{POINTER TO STATIC SCBLK{10617
{{ADD{3,RLDCD{9,(XR){{ADJUST SCBLK TYPE WORD{10618
{{MOV{10,(XS)+{7,XR{{RESTORE FFBLK POINTER{10619
*
*      FFBLK (CONTINUED)
*
*      MERGE HERE TO SET UP FOR ADJUSTMENT OF PTRS IN FFBLK
*
{RLD12{MOV{19,*FFOFS{8,WA{{SET LENGTH{10625
{{MOV{19,*FFDFP{8,WB{{SET OFFSET{10626
{{BRN{6,RLD04{{{ALL SET{10627
*
*      KVBLK, NMBLK, P0BLK, SEBLK
*
{RLD13{MOV{19,*OFFS2{8,WA{{POINT PAST SECOND FIELD{10631
{{MOV{19,*OFFS1{8,WB{{OFFSET IS ONE (ONLY RELOC FLD IS 2){10632
{{BRN{6,RLD04{{{ALL SET{10633
*
*      P1BLK, P2BLK
*
*      IN P2BLKS, PARM2 CONTAINS EITHER A BIT MASK OR THE
*      NAME OFFSET OF A VARIABLE.  IT NEVER REQUIRES RELOCATION.
*
{RLD14{MOV{19,*PARM2{8,WA{{LENGTH (PARM2 IS NON-RELOCATABLE){10640
{{MOV{19,*PTHEN{8,WB{{SET OFFSET{10641
{{BRN{6,RLD04{{{ALL SET{10642
*
*      PDBLK
*
*      NOTE THAT THE DFBLK POINTED TO BY THIS PDBLK WAS
*      PROCESSED WHEN THE FFBLK WAS ENCOUNTERED.  BECAUSE
*      THE DATA FUNCTION WILL BE CALLED BEFORE ANY RECORDS ARE
*      DEFINED, THE FFBLK IS ENCOUNTERED BEFORE ANY
*      CORRESPONDING PDBLK.
*
{RLD15{MOV{13,PDDFP(XR){7,XL{{LOAD PTR TO DFBLK{10652
{{ADD{3,RLDST{7,XL{{ADJUST FOR STATIC RELOCATION{10653
{{MOV{13,DFPDL(XL){8,WA{{GET PDBLK LENGTH{10654
{{MOV{19,*PDDFP{8,WB{{SET OFFSET{10655
{{BRN{6,RLD04{{{ALL SET{10656
{{EJC{{{{{10657
*
*      RELDN (CONTINUED)
*
*
*      PFBLK
*
{RLD16{ADD{3,RLDST{13,PFVBL(XR){{ADJUST NON-CONTIGUOUS FIELD{10664
{{MOV{13,PFLEN(XR){8,WA{{GET PFBLK LENGTH{10665
{{MOV{19,*PFCOD{8,WB{{OFFSET TO FIRST RELOC{10666
{{BRN{6,RLD04{{{ALL SET{10667
*
*      TBBLK, VCBLK
*
{RLD17{MOV{13,OFFS2(XR){8,WA{{LOAD LENGTH{10671
{{MOV{19,*OFFS3{8,WB{{SET OFFSET{10672
{{BRN{6,RLD04{{{JUMP BACK{10673
*
*      TEBLK
*
{RLD18{MOV{19,*TESI${8,WA{{SET LENGTH{10677
{{MOV{19,*TESUB{8,WB{{AND OFFSET{10678
{{BRN{6,RLD04{{{ALL SET{10679
*
*      TRBLK
*
{RLD19{MOV{19,*TRSI${8,WA{{SET LENGTH{10683
{{MOV{19,*TRVAL{8,WB{{AND OFFSET{10684
{{BRN{6,RLD04{{{ALL SET{10685
*
*      XRBLK
*
{RLD20{MOV{13,XRLEN(XR){8,WA{{LOAD LENGTH{10689
{{MOV{19,*XRPTR{8,WB{{SET OFFSET{10690
{{BRN{6,RLD04{{{JUMP BACK{10691
{{ENP{{{{END PROCEDURE RELDN{10692
{{EJC{{{{{10693
*
*      RELOC -- RELOCATE STORAGE AFTER SAVE FILE RELOAD
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELOC            RELOCATE ALL POINTERS
*      (WA,WB,WC,XR)         DESTROYED
*
*      THE LIST OF BOUNDARIES AND ADJUSTMENTS POINTED TO BY
*      REGISTER XL IS CREATED BY A CALL TO RELCR, WHICH SHOULD
*      BE CONSULTED FOR INFORMATION ON ITS STRUCTURE.
*
{RELOC{PRC{25,E{1,0{{ENTRY POINT{10705
{{MOV{13,RLDYS(XL){7,XR{{OLD START OF DYNAMIC{10706
{{MOV{13,RLDYE(XL){8,WC{{OLD END OF DYNAMIC{10707
{{ADD{13,RLDYA(XL){7,XR{{CREATE NEW START OF DYNAMIC{10708
{{ADD{13,RLDYA(XL){8,WC{{CREATE NEW END OF DYNAMIC{10709
{{JSR{6,RELDN{{{RELOCATE POINTERS IN DYNAMIC{10710
{{JSR{6,RELWS{{{RELOCATE POINTERS IN WORKING SECT{10711
{{JSR{6,RELST{{{RELOCATE POINTERS IN STATIC{10712
{{EXI{{{{RETURN TO CALLER{10713
{{ENP{{{{END PROCEDURE RELOC{10714
{{EJC{{{{{10715
*
*      RELST -- RELOCATE POINTERS IN THE STATIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELST            CALL TO PROCESS BLOCKS IN STATIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      ONLY VRBLKS ON THE HASH CHAIN AND ANY PROFILE BLOCK ARE
*      PROCESSED.  OTHER STATIC BLOCKS (DFBLKS) ARE PROCESSED
*      DURING PROCESSING OF DYNAMIC BLOCKS.
*
*      GLOBAL WORK LOCATIONS WILL BE PROCESSED AT THIS POINT,
*      SO POINTERS THERE CAN BE RELIED UPON.
*
{RELST{PRC{25,E{1,0{{ENTRY POINT{10730
{{MOV{3,PFTBL{7,XR{{PROFILE TABLE{10731
{{BZE{7,XR{6,RLS01{{BRANCH IF NO TABLE ALLOCATED{10732
{{ADD{13,RLCDA(XL){9,(XR){{ADJUST BLOCK TYPE WORD{10733
*
*      HERE AFTER DEALING WITH PROFILER
*
{RLS01{MOV{3,HSHTB{8,WC{{POINT TO START OF HASH TABLE{10737
{{MOV{8,WC{8,WB{{POINT TO FIRST HASH BUCKET{10738
{{MOV{3,HSHTE{8,WA{{POINT BEYOND HASH TABLE{10739
{{JSR{6,RELAJ{{{ADJUST BUCKET POINTERS{10740
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
{RLS02{BEQ{8,WC{3,HSHTE{6,RLS05{DONE IF NONE LEFT{10744
{{MOV{8,WC{7,XR{{ELSE COPY SLOT POINTER{10745
{{ICA{8,WC{{{BUMP SLOT POINTER{10746
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE INTO LOOP{10747
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{RLS03{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{10751
{{BZE{7,XR{6,RLS02{{JUMP FOR NEXT BUCKET IF CHAIN END{10752
{{MOV{19,*VRLEN{8,WA{{OFFSET OF FIRST LOC PAST PTR FIELDS{10753
{{MOV{19,*VRGET{8,WB{{OFFSET OF FIRST LOCATION IN VRBLK{10754
{{BNZ{13,VRLEN(XR){6,RLS04{{JUMP IF NOT SYSTEM VARIABLE{10755
{{MOV{19,*VRSI${8,WA{{OFFSET TO INCLUDE VRSVP FIELD{10756
*
*      MERGE HERE TO PROCESS FIELDS OF VRBLK
*
{RLS04{ADD{7,XR{8,WA{{CREATE END PTR{10760
{{ADD{7,XR{8,WB{{CREATE START PTR{10761
{{JSR{6,RELAJ{{{ADJUST POINTERS IN VRBLK{10762
{{BRN{6,RLS03{{{CHECK FOR ANOTHER VRBLK ON CHAIN{10763
*
*      HERE WHEN ALL VRBLKS PROCESSED
*
{RLS05{EXI{{{{RETURN TO CALLER{10767
{{ENP{{{{END PROCEDURE RELST{10768
{{EJC{{{{{10769
*
*      RELWS -- RELOCATE POINTERS IN THE WORKING SECTION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELWS            CALL TO PROCESS WORKING SECTION
*      (WA,WB,WC,XR)         DESTROYED
*
*      POINTERS BETWEEN A$AAA AND R$YYY ARE EXAMINED AND
*      ADJUSTED IF NECESSARY.  THE POINTER KVRTN IS ALSO
*      ADJUSTED ALTHOUGH IT LIES OUTSIDE THIS RANGE.
*      DNAME IS EXPLICITLY ADJUSTED BECAUSE THE LIMITS
*      ON DYNAMIC REGION IN STACK ARE TO THE AREA ACTIVELY
*      IN USE (BETWEEN DNAMB AND DNAMP), AND DNAME IS OUTSIDE
*      THIS RANGE.
*
{RELWS{PRC{25,E{1,0{{ENTRY POINT{10785
{{MOV{20,=A$AAA{8,WB{{POINT TO START OF ADJUSTABLES{10786
{{MOV{20,=R$YYY{8,WA{{POINT TO END OF ADJUSTABLES{10787
{{JSR{6,RELAJ{{{RELOCATE ADJUSTABLE POINTERS{10788
{{ADD{13,RLDYA(XL){3,DNAME{{ADJUST PTR MISSED BY RELAJ{10789
{{MOV{20,=KVRTN{8,WB{{CASE OF KVRTN{10790
{{MOV{8,WB{8,WA{{HANDLED SPECIALLY{10791
{{ICA{8,WA{{{ONE VALUE TO ADJUST{10792
{{JSR{6,RELAJ{{{ADJUST KVRTN{10793
{{EXI{{{{RETURN TO CALLER{10794
{{ENP{{{{END PROCEDURE RELWS{10795
{{TTL{27,S P I T B O L -- INITIALIZATION{{{{10797
*
*      INITIALISATION
*      THE FOLLOWING SECTION RECEIVES CONTROL FROM THE SYSTEM
*      AT THE START OF A RUN WITH THE REGISTERS SET AS FOLLOWS.
*
*      (WA)                  INITIAL STACK POINTER
*      (XR)                  POINTS TO FIRST WORD OF DATA AREA
*      (XL)                  POINTS TO LAST WORD OF DATA AREA
*
{START{PRC{25,E{1,0{{ENTRY POINT{10807
{{MOV{8,WA{7,XS{{DISCARD RETURN{10808
{{JSR{6,SYSTM{{{INITIALISE TIMER{10809
{{STI{3,TIMSX{{{STORE TIME{10811
{{MOV{7,XR{3,STATB{{START ADDRESS OF STATIC{10812
{{MOV{19,*E$SRS{3,RSMEM{{RESERVE MEMORY{10864
{{MOV{7,XS{3,STBAS{{STORE STACK BASE{10865
{{SSS{3,INISS{{{SAVE S-R STACK PTR{10866
*
*      NOW CONVERT FREE STORE PERCENTAGE TO A SUITABLE FACTOR
*      FOR EASY TESTING IN ALLOC ROUTINE.
*
{{LDI{4,INTVH{{{GET 100{10871
{{DVI{4,ALFSP{{{FORM 100 / ALFSP{10872
{{STI{3,ALFSF{{{STORE THE FACTOR{10873
*
*      NOW CONVERT FREE SEDIMENT PERCENTAGE TO A SUITABLE FACTOR
*      FOR EASY TESTING IN GBCOL ROUTINE.
*
{{LDI{4,INTVH{{{GET 100{10879
{{DVI{4,GBSDP{{{FORM 100 / GBSDP{10880
{{STI{3,GBSED{{{STORE THE FACTOR{10881
*
*      INITIALIZE VALUES FOR REAL CONVERSION ROUTINE
*
{{LCT{8,WB{18,=CFP$S{{LOAD COUNTER FOR SIGNIFICANT DIGITS{10890
{{LDR{4,REAV1{{{LOAD 1.0{10891
*
*      LOOP TO COMPUTE 10**(MAX NUMBER SIGNIFICANT DIGITS)
*
{INI03{MLR{4,REAVT{{{* 10.0{10895
{{BCT{8,WB{6,INI03{{LOOP TILL DONE{10896
{{STR{3,GTSSC{{{STORE 10**(MAX SIG DIGITS){10897
{{LDR{4,REAP5{{{LOAD 0.5{10898
{{DVR{3,GTSSC{{{COMPUTE 0.5*10**(MAX SIG DIGITS){10899
{{STR{3,GTSRN{{{STORE AS ROUNDING BIAS{10900
{{ZER{8,WC{{{SET TO READ PARAMETERS{10903
{{JSR{6,PRPAR{{{READ THEM{10904
{{EJC{{{{{10905
*
*      NOW COMPUTE STARTING ADDRESS FOR DYNAMIC STORE AND IF
*      NECESSARY REQUEST MORE MEMORY.
*
{{SUB{19,*E$SRS{7,XL{{ALLOW FOR RESERVE MEMORY{10910
{{MOV{3,PRLEN{8,WA{{GET PRINT BUFFER LENGTH{10911
{{ADD{18,=CFP$A{8,WA{{ADD NO. OF CHARS IN ALPHABET{10912
{{ADD{18,=NSTMX{8,WA{{ADD CHARS FOR GTSTG BFR{10913
{{CTB{8,WA{1,8{{CONVERT TO BYTES, ALLOWING A MARGIN{10914
{{MOV{3,STATB{7,XR{{POINT TO STATIC BASE{10915
{{ADD{8,WA{7,XR{{INCREMENT FOR ABOVE BUFFERS{10916
{{ADD{19,*E$HNB{7,XR{{INCREMENT FOR HASH TABLE{10917
{{ADD{19,*E$STS{7,XR{{BUMP FOR INITIAL STATIC BLOCK{10918
{{JSR{6,SYSMX{{{GET MXLEN{10919
{{MOV{8,WA{3,KVMXL{{PROVISIONALLY STORE AS MAXLNGTH{10920
{{MOV{8,WA{3,MXLEN{{AND AS MXLEN{10921
{{BGT{7,XR{8,WA{6,INI06{SKIP IF STATIC HI EXCEEDS MXLEN{10922
{{CTB{8,WA{1,1{{ROUND UP AND MAKE BIGGER THAN MXLEN{10923
{{MOV{8,WA{7,XR{{USE IT INSTEAD{10924
*
*      HERE TO STORE VALUES WHICH MARK INITIAL DIVISION
*      OF DATA AREA INTO STATIC AND DYNAMIC
*
{INI06{MOV{7,XR{3,DNAMB{{DYNAMIC BASE ADRS{10929
{{MOV{7,XR{3,DNAMP{{DYNAMIC PTR{10930
{{BNZ{8,WA{6,INI07{{SKIP IF NON-ZERO MXLEN{10931
{{DCA{7,XR{{{POINT A WORD IN FRONT{10932
{{MOV{7,XR{3,KVMXL{{USE AS MAXLNGTH{10933
{{MOV{7,XR{3,MXLEN{{AND AS MXLEN{10934
{{EJC{{{{{10935
*
*      LOOP HERE IF NECESSARY TILL ENOUGH MEMORY OBTAINED
*      SO THAT DNAME IS ABOVE DNAMB
*
{INI07{MOV{7,XL{3,DNAME{{STORE DYNAMIC END ADDRESS{10940
{{BLT{3,DNAMB{7,XL{6,INI09{SKIP IF HIGH ENOUGH{10941
{{JSR{6,SYSMM{{{REQUEST MORE MEMORY{10942
{{WTB{7,XR{{{GET AS BAUS (SGD05){10943
{{ADD{7,XR{7,XL{{BUMP BY AMOUNT OBTAINED{10944
{{BNZ{7,XR{6,INI07{{TRY AGAIN{10945
{{MOV{18,=MXERN{8,WA{{INSUFFICIENT MEMORY FOR MAXLENGTH{10947
{{ZER{8,WB{{{NO COLUMN NUMBER INFO{10948
{{ZER{8,WC{{{NO LINE NUMBER INFO{10949
{{MOV{18,=STGIC{7,XR{{INITIAL COMPILE STAGE{10950
{{MOV{21,=NULLS{7,XL{{NO FILE NAME{10952
{{JSR{6,SYSEA{{{ADVISE OF ERROR{10954
{{PPM{6,INI08{{{CANT USE ERROR LOGIC YET{10955
{{BRN{6,INI08{{{FORCE TERMINATION{10956
*
*      INSERT TEXT FOR ERROR 329 IN ERROR MESSAGE TABLE
*
{{ERB{1,329{26,Requested MAXLNGTH too large{{{10960
{INI08{MOV{21,=ENDMO{7,XR{{POINT TO FAILURE MESSAGE{10962
{{MOV{4,ENDML{8,WA{{MESSAGE LENGTH{10963
{{JSR{6,SYSPR{{{PRINT IT (PRTST NOT YET USABLE){10964
{{PPM{{{{SHOULD NOT FAIL{10965
{{ZER{7,XL{{{NO FCB CHAIN YET{10966
{{MOV{18,=NUM10{8,WB{{SET SPECIAL CODE VALUE{10967
{{JSR{6,SYSEJ{{{PACK UP (STOPR NOT YET USABLE){10968
*
*      INITIALISE STRUCTURES AT START OF STATIC REGION
*
{INI09{MOV{3,STATB{7,XR{{POINT TO STATIC AGAIN{10972
{{JSR{6,INSTA{{{INITIALIZE STATIC{10973
*
*      INITIALIZE NUMBER OF HASH HEADERS
*
{{MOV{18,=E$HNB{8,WA{{GET NUMBER OF HASH HEADERS{10977
{{MTI{8,WA{{{CONVERT TO INTEGER{10978
{{STI{3,HSHNB{{{STORE FOR USE BY GTNVR PROCEDURE{10979
{{LCT{8,WA{8,WA{{COUNTER FOR CLEARING HASH TABLE{10980
{{MOV{7,XR{3,HSHTB{{POINTER TO HASH TABLE{10981
*
*      LOOP TO CLEAR HASH TABLE
*
{INI11{ZER{10,(XR)+{{{BLANK A WORD{10985
{{BCT{8,WA{6,INI11{{LOOP{10986
{{MOV{7,XR{3,HSHTE{{END OF HASH TABLE ADRS IS KEPT{10987
{{MOV{7,XR{3,STATE{{STORE STATIC END ADDRESS{10988
*
*      INIT TABLE TO MAP STATEMENT NUMBERS TO SOURCE FILE NAMES
*
{{MOV{18,=NUM01{8,WC{{TABLE WILL HAVE ONLY ONE BUCKET{10993
{{MOV{21,=NULLS{7,XL{{DEFAULT TABLE VALUE{10994
{{MOV{7,XL{3,R$SFC{{CURRENT SOURCE FILE NAME{10995
{{JSR{6,TMAKE{{{CREATE TABLE{10996
{{MOV{7,XR{3,R$SFN{{SAVE PTR TO TABLE{10997
*
*      INITIALIZE TABLE TO DETECT DUPLICATE INCLUDE FILE NAMES
*
{{MOV{18,=NUM01{8,WC{{TABLE WILL HAVE ONLY ONE BUCKET{11003
{{MOV{21,=NULLS{7,XL{{DEFAULT TABLE VALUE{11004
{{JSR{6,TMAKE{{{CREATE TABLE{11005
{{MOV{7,XR{3,R$INC{{SAVE PTR TO TABLE{11006
*
*      INITIALIZE ARRAY TO HOLD NAMES OF NESTED INCLUDE FILES
*
{{MOV{18,=CCINM{8,WA{{MAXIMUM NESTING LEVEL{11011
{{MOV{21,=NULLS{7,XL{{NULL STRING DEFAULT VALUE{11012
{{JSR{6,VMAKE{{{CREATE ARRAY{11013
{{PPM{{{{{11014
{{MOV{7,XR{3,R$IFA{{SAVE PTR TO ARRAY{11015
*
*      INIT ARRAY TO HOLD LINE NUMBERS OF NESTED INCLUDE FILES
*
{{MOV{18,=CCINM{8,WA{{MAXIMUM NESTING LEVEL{11019
{{MOV{21,=INTON{7,XL{{INTEGER ONE DEFAULT VALUE{11020
{{JSR{6,VMAKE{{{CREATE ARRAY{11021
{{PPM{{{{{11022
{{MOV{7,XR{3,R$IFL{{SAVE PTR TO ARRAY{11023
*
*      INITIALIZE VARIABLE BLOCKS FOR INPUT AND OUTPUT
*
{{MOV{21,=V$INP{7,XL{{POINT TO STRING /INPUT/{11029
{{MOV{18,=TRTIN{8,WB{{TRBLK TYPE FOR INPUT{11030
{{JSR{6,INOUT{{{PERFORM INPUT ASSOCIATION{11031
{{MOV{21,=V$OUP{7,XL{{POINT TO STRING /OUTPUT/{11032
{{MOV{18,=TRTOU{8,WB{{TRBLK TYPE FOR OUTPUT{11033
{{JSR{6,INOUT{{{PERFORM OUTPUT ASSOCIATION{11034
{{MOV{3,INITR{8,WC{{TERMINAL FLAG{11035
{{BZE{8,WC{6,INI13{{SKIP IF NO TERMINAL{11036
{{JSR{6,PRPAR{{{ASSOCIATE TERMINAL{11037
{{EJC{{{{{11038
*
*      CHECK FOR EXPIRY DATE
*
{INI13{JSR{6,SYSDC{{{CALL DATE CHECK{11042
{{MOV{7,XS{3,FLPTR{{IN CASE STACK OVERFLOWS IN COMPILER{11043
*
*      NOW COMPILE SOURCE INPUT CODE
*
{{JSR{6,CMPIL{{{CALL COMPILER{11047
{{MOV{7,XR{3,R$COD{{SET PTR TO FIRST CODE BLOCK{11048
{{MOV{21,=NULLS{3,R$TTL{{FORGET TITLE{11049
{{MOV{21,=NULLS{3,R$STL{{FORGET SUB-TITLE{11050
{{ZER{3,R$CIM{{{FORGET COMPILER INPUT IMAGE{11051
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{11052
{{ZER{3,CNIND{{{IN CASE END OCCURRED WITH INCLUDE{11054
{{ZER{3,LSTID{{{LISTING INCLUDE DEPTH{11055
{{ZER{7,XL{{{CLEAR DUD VALUE{11057
{{ZER{8,WB{{{DONT SHIFT DYNAMIC STORE UP{11058
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{11060
{{JSR{6,GBCOL{{{CLEAR GARBAGE LEFT FROM COMPILE{11061
{{MOV{7,XR{3,DNAMS{{RECORD NEW SEDIMENT SIZE{11062
{{BNZ{3,CPSTS{6,INIX0{{SKIP IF NO LISTING OF COMP STATS{11066
{{JSR{6,PRTPG{{{EJECT PAGE{11067
*
*      PRINT COMPILE STATISTICS
*
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{11071
{{MTI{3,CMERC{{{GET COUNT OF ERRORS AS INTEGER{11072
{{MOV{21,=ENCM3{7,XR{{POINT TO /COMPILE ERRORS/{11073
{{JSR{6,PRTMI{{{PRINT IT{11074
{{MTI{3,GBCNT{{{GARBAGE COLLECTION COUNT{11075
{{SBI{4,INTV1{{{ADJUST FOR UNAVOIDABLE COLLECT{11076
{{MOV{21,=STPM5{7,XR{{POINT TO /STORAGE REGENERATIONS/{11077
{{JSR{6,PRTMI{{{PRINT GBCOL COUNT{11078
{{JSR{6,SYSTM{{{GET TIME{11079
{{SBI{3,TIMSX{{{GET COMPILATION TIME{11080
{{MOV{21,=ENCM4{7,XR{{POINT TO COMPILATION TIME (MSEC)/{11081
{{JSR{6,PRTMI{{{PRINT MESSAGE{11082
{{ADD{18,=NUM05{3,LSTLC{{BUMP LINE COUNT{11083
{{BZE{3,HEADP{6,INIX0{{NO EJECT IF NOTHING PRINTED{11085
{{JSR{6,PRTPG{{{EJECT PRINTER{11086
{{EJC{{{{{11088
*
*      PREPARE NOW TO START EXECUTION
*
*      SET DEFAULT INPUT RECORD LENGTH
*
{INIX0{BGT{3,CSWIN{18,=INILN{6,INIX1{SKIP IF NOT DEFAULT -IN72 USED{11094
{{MOV{18,=INILS{3,CSWIN{{ELSE USE DEFAULT RECORD LENGTH{11095
*
*      RESET TIMER
*
{INIX1{JSR{6,SYSTM{{{GET TIME AGAIN{11099
{{STI{3,TIMSX{{{STORE FOR END RUN PROCESSING{11100
{{ZER{3,GBCNT{{{INITIALISE COLLECT COUNT{11101
{{JSR{6,SYSBX{{{CALL BEFORE STARTING EXECUTION{11102
{{ADD{3,CSWEX{3,NOXEQ{{ADD -NOEXECUTE FLAG{11103
{{BNZ{3,NOXEQ{6,INIX2{{JUMP IF EXECUTION SUPPRESSED{11104
*
*      MERGE WHEN LISTING FILE SET FOR EXECUTION.  ALSO
*      MERGE HERE WHEN RESTARTING A SAVE FILE OR LOAD MODULE.
*
{INIY0{MNZ{3,HEADP{{{MARK HEADERS OUT REGARDLESS{11114
{{ZER{11,-(XS){{{SET FAILURE LOCATION ON STACK{11115
{{MOV{7,XS{3,FLPTR{{SAVE PTR TO FAILURE OFFSET WORD{11116
{{MOV{3,R$COD{7,XR{{LOAD PTR TO ENTRY CODE BLOCK{11117
{{MOV{18,=STGXT{3,STAGE{{SET STAGE FOR EXECUTE TIME{11118
{{MOV{18,=NUM01{3,POLCS{{RESET INTERFACE POLLING INTERVAL{11120
{{MOV{18,=NUM01{3,POLCT{{RESET INTERFACE POLLING INTERVAL{11121
{{MOV{3,CMPSN{3,PFNTE{{COPY STMTS COMPILED COUNT IN CASE{11125
{{MOV{3,KVPFL{3,PFDMP{{START PROFILING IF &PROFILE SET{11126
{{JSR{6,SYSTM{{{TIME YET AGAIN{11127
{{STI{3,PFSTM{{{{11128
{{JSR{6,STGCC{{{COMPUTE STMGO COUNTDOWN COUNTERS{11130
{{BRI{9,(XR){{{START XEQ WITH FIRST STATEMENT{11131
*
*      HERE IF EXECUTION IS SUPPRESSED
*
{INIX2{ZER{8,WA{{{SET ABEND VALUE TO ZERO{11136
{{MOV{18,=NINI9{8,WB{{SET SPECIAL CODE VALUE{11144
{{ZER{7,XL{{{NO FCB CHAIN{11145
{{JSR{6,SYSEJ{{{END OF JOB, EXIT TO SYSTEM{11146
{{ENP{{{{END PROCEDURE START{11147
*
*      HERE FROM OSINT TO RESTART A SAVE FILE OR LOAD MODULE.
*
{RSTRT{PRC{25,E{1,0{{ENTRY POINT{11151
{{MOV{3,STBAS{7,XS{{DISCARD RETURN{11152
{{ZER{7,XL{{{CLEAR XL{11153
{{BRN{6,INIY0{{{RESUME EXECUTION{11154
{{ENP{{{{END PROCEDURE RSTRT{11155
{{TTL{27,S P I T B O L -- SNOBOL4 OPERATOR ROUTINES{{{{11157
*
*      THIS SECTION INCLUDES ALL ROUTINES WHICH CAN BE ACCESSED
*      DIRECTLY FROM THE GENERATED CODE EXCEPT SYSTEM FUNCTIONS.
*
*      ALL ROUTINES IN THIS SECTION START WITH A LABEL OF THE
*      FORM O$XXX WHERE XXX IS THREE LETTERS. THE GENERATED CODE
*      CONTAINS A POINTER TO THE APPROPRIATE ENTRY LABEL.
*
*      SINCE THE GENERAL FORM OF THE GENERATED CODE CONSISTS OF
*      POINTERS TO BLOCKS WHOSE FIRST WORD IS THE ADDRESS OF THE
*      ACTUAL ENTRY POINT LABEL (O$XXX).
*
*      THESE ROUTINES ARE IN ALPHABETICAL ORDER BY THEIR
*      ENTRY LABEL NAMES (I.E. BY THE XXX OF THE O$XXX NAME)
*
*      THESE ROUTINES RECEIVE CONTROL AS FOLLOWS
*
*      (CP)                  POINTER TO NEXT CODE WORD
*      (XS)                  CURRENT STACK POINTER
{{EJC{{{{{11177
*
*      BINARY PLUS (ADDITION)
*
{O$ADD{ENT{{{{ENTRY POINT{11181
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11182
{{ERR{1,001{26,Addition left operand is not numeric{{{11183
{{ERR{1,002{26,Addition right operand is not numeric{{{11184
{{PPM{6,OADD1{{{JUMP IF REAL OPERANDS{11187
*
*      HERE TO ADD TWO INTEGERS
*
{{ADI{13,ICVAL(XL){{{ADD RIGHT OPERAND TO LEFT{11192
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11193
{{ERB{1,003{26,Addition caused integer overflow{{{11194
*
*      HERE TO ADD TWO REALS
*
{OADD1{ADR{13,RCVAL(XL){{{ADD RIGHT OPERAND TO LEFT{11200
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11201
{{ERB{1,261{26,Addition caused real overflow{{{11202
{{EJC{{{{{11204
*
*      UNARY PLUS (AFFIRMATION)
*
{O$AFF{ENT{{{{ENTRY POINT{11208
{{MOV{10,(XS)+{7,XR{{LOAD OPERAND{11209
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{11210
{{ERR{1,004{26,Affirmation operand is not numeric{{{11211
{{MOV{7,XR{11,-(XS){{RESULT IF CONVERTED TO NUMERIC{11212
{{LCW{7,XR{{{GET NEXT CODE WORD{11213
{{BRI{9,(XR){{{EXECUTE IT{11214
{{EJC{{{{{11215
*
*      BINARY BAR (ALTERNATION)
*
{O$ALT{ENT{{{{ENTRY POINT{11219
{{MOV{10,(XS)+{7,XR{{LOAD RIGHT OPERAND{11220
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11221
{{ERR{1,005{26,Alternation right operand is not pattern{{{11222
*
*      MERGE HERE FROM SPECIAL (LEFT ALTERNATION) CASE
*
{OALT1{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATIVE NODE{11226
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{11227
{{MOV{7,XR{7,XL{{SAVE ADDRESS OF ALTERNATIVE NODE{11228
{{MOV{10,(XS)+{7,XR{{LOAD LEFT OPERAND{11229
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11230
{{ERR{1,006{26,Alternation left operand is not pattern{{{11231
{{BEQ{7,XR{22,=P$ALT{6,OALT2{JUMP IF LEFT ARG IS ALTERNATION{11232
{{MOV{7,XR{13,PTHEN(XL){{SET LEFT OPERAND AS SUCCESSOR{11233
{{MOV{7,XL{11,-(XS){{STACK RESULT{11234
{{LCW{7,XR{{{GET NEXT CODE WORD{11235
{{BRI{9,(XR){{{EXECUTE IT{11236
*
*      COME HERE IF LEFT ARGUMENT IS ITSELF AN ALTERNATION
*
*      THE RESULT IS MORE EFFICIENT IF WE MAKE THE REPLACEMENT
*
*      (A / B) / C = A / (B / C)
*
{OALT2{MOV{13,PARM1(XR){13,PTHEN(XL){{BUILD THE (B / C) NODE{11244
{{MOV{13,PTHEN(XR){11,-(XS){{SET A AS NEW LEFT ARG{11245
{{MOV{7,XL{7,XR{{SET (B / C) AS NEW RIGHT ARG{11246
{{BRN{6,OALT1{{{MERGE BACK TO BUILD A / (B / C){11247
{{EJC{{{{{11248
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY NAME)
*
{O$AMN{ENT{{{{ENTRY POINT{11252
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{11253
{{MOV{7,XR{8,WB{{SET FLAG FOR BY NAME{11254
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11255
{{EJC{{{{{11256
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY VALUE)
*
{O$AMV{ENT{{{{ENTRY POINT{11260
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{11261
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{11262
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11263
{{EJC{{{{{11264
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY NAME)
*
{O$AON{ENT{{{{ENTRY POINT{11268
{{MOV{9,(XS){7,XR{{LOAD SUBSCRIPT VALUE{11269
{{MOV{13,NUM01(XS){7,XL{{LOAD ARRAY VALUE{11270
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF ARRAY OPERAND{11271
{{BEQ{8,WA{22,=B$VCT{6,OAON2{JUMP IF VECTOR REFERENCE{11272
{{BEQ{8,WA{22,=B$TBT{6,OAON3{JUMP IF TABLE REFERENCE{11273
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAON1{MOV{18,=NUM01{7,XR{{SET NUMBER OF SUBSCRIPTS TO ONE{11277
{{MOV{7,XR{8,WB{{SET FLAG FOR BY NAME{11278
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11279
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAON2{BNE{9,(XR){22,=B$ICL{6,OAON1{USE LONG ROUTINE IF NOT INTEGER{11283
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{11284
{{MFI{8,WA{6,EXFAL{{COPY AS ADDRESS INT, FAIL IF OVFLO{11285
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{11286
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{11287
{{WTB{8,WA{{{CONVERT TO BYTES{11288
{{MOV{8,WA{9,(XS){{COMPLETE NAME ON STACK{11289
{{BLT{8,WA{13,VCLEN(XL){6,OAON4{EXIT IF SUBSCRIPT NOT TOO LARGE{11290
{{BRN{6,EXFAL{{{ELSE FAIL{11291
*
*      HERE FOR TABLE REFERENCE
*
{OAON3{MNZ{8,WB{{{SET FLAG FOR NAME REFERENCE{11295
{{JSR{6,TFIND{{{LOCATE/CREATE TABLE ELEMENT{11296
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11297
{{MOV{7,XL{13,NUM01(XS){{STORE NAME BASE ON STACK{11298
{{MOV{8,WA{9,(XS){{STORE NAME OFFSET ON STACK{11299
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{OAON4{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11303
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11304
{{EJC{{{{{11305
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY VALUE)
*
{O$AOV{ENT{{{{ENTRY POINT{11309
{{MOV{10,(XS)+{7,XR{{LOAD SUBSCRIPT VALUE{11310
{{MOV{10,(XS)+{7,XL{{LOAD ARRAY VALUE{11311
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF ARRAY OPERAND{11312
{{BEQ{8,WA{22,=B$VCT{6,OAOV2{JUMP IF VECTOR REFERENCE{11313
{{BEQ{8,WA{22,=B$TBT{6,OAOV3{JUMP IF TABLE REFERENCE{11314
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAOV1{MOV{7,XL{11,-(XS){{RESTACK ARRAY VALUE{11318
{{MOV{7,XR{11,-(XS){{RESTACK SUBSCRIPT{11319
{{MOV{18,=NUM01{7,XR{{SET NUMBER OF SUBSCRIPTS TO ONE{11320
{{ZER{8,WB{{{SET FLAG FOR VALUE CALL{11321
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11322
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAOV2{BNE{9,(XR){22,=B$ICL{6,OAOV1{USE LONG ROUTINE IF NOT INTEGER{11326
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{11327
{{MFI{8,WA{6,EXFAL{{MOVE AS ONE WORD INT, FAIL IF OVFLO{11328
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{11329
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{11330
{{WTB{8,WA{{{CONVERT TO BYTES{11331
{{BGE{8,WA{13,VCLEN(XL){6,EXFAL{FAIL IF SUBSCRIPT TOO LARGE{11332
{{JSR{6,ACESS{{{ACCESS VALUE{11333
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11334
{{MOV{7,XR{11,-(XS){{STACK RESULT{11335
{{LCW{7,XR{{{GET NEXT CODE WORD{11336
{{BRI{9,(XR){{{EXECUTE IT{11337
*
*      HERE FOR TABLE REFERENCE BY VALUE
*
{OAOV3{ZER{8,WB{{{SET FLAG FOR VALUE REFERENCE{11341
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{11342
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11343
{{MOV{7,XR{11,-(XS){{STACK RESULT{11344
{{LCW{7,XR{{{GET NEXT CODE WORD{11345
{{BRI{9,(XR){{{EXECUTE IT{11346
{{EJC{{{{{11347
*
*      ASSIGNMENT
*
{O$ASS{ENT{{{{ENTRY POINT{11351
*
*      O$RPL (PATTERN REPLACEMENT) MERGES HERE
*
{OASS0{MOV{10,(XS)+{8,WB{{LOAD VALUE TO BE ASSIGNED{11355
{{MOV{10,(XS)+{8,WA{{LOAD NAME OFFSET{11356
{{MOV{9,(XS){7,XL{{LOAD NAME BASE{11357
{{MOV{8,WB{9,(XS){{STORE ASSIGNED VALUE AS RESULT{11358
{{JSR{6,ASIGN{{{PERFORM ASSIGNMENT{11359
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{11360
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11361
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11362
{{EJC{{{{{11363
*
*      COMPILATION ERROR
*
{O$CER{ENT{{{{ENTRY POINT{11367
{{ERB{1,007{26,Compilation error encountered during execution{{{11368
{{EJC{{{{{11369
*
*      UNARY AT (CURSOR ASSIGNMENT)
*
{O$CAS{ENT{{{{ENTRY POINT{11373
{{MOV{10,(XS)+{8,WC{{LOAD NAME OFFSET (PARM2){11374
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE (PARM1){11375
{{MOV{22,=P$CAS{8,WB{{SET PCODE FOR CURSOR ASSIGNMENT{11376
{{JSR{6,PBILD{{{BUILD NODE{11377
{{MOV{7,XR{11,-(XS){{STACK RESULT{11378
{{LCW{7,XR{{{GET NEXT CODE WORD{11379
{{BRI{9,(XR){{{EXECUTE IT{11380
{{EJC{{{{{11381
*
*      CONCATENATION
*
{O$CNC{ENT{{{{ENTRY POINT{11385
{{MOV{9,(XS){7,XR{{LOAD RIGHT ARGUMENT{11386
{{BEQ{7,XR{21,=NULLS{6,OCNC3{JUMP IF RIGHT ARG IS NULL{11387
{{MOV{12,1(XS){7,XL{{LOAD LEFT ARGUMENT{11388
{{BEQ{7,XL{21,=NULLS{6,OCNC4{JUMP IF LEFT ARGUMENT IS NULL{11389
{{MOV{22,=B$SCL{8,WA{{GET CONSTANT TO TEST FOR STRING{11390
{{BNE{8,WA{9,(XL){6,OCNC2{JUMP IF LEFT ARG NOT A STRING{11391
{{BNE{8,WA{9,(XR){6,OCNC2{JUMP IF RIGHT ARG NOT A STRING{11392
*
*      MERGE HERE TO CONCATENATE TWO STRINGS
*
{OCNC1{MOV{13,SCLEN(XL){8,WA{{LOAD LEFT ARGUMENT LENGTH{11396
{{ADD{13,SCLEN(XR){8,WA{{COMPUTE RESULT LENGTH{11397
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{11398
{{MOV{7,XR{12,1(XS){{STORE RESULT PTR OVER LEFT ARGUMENT{11399
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{11400
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARS IN LEFT ARG{11401
{{PLC{7,XL{{{PREPARE TO LOAD LEFT ARG CHARS{11402
{{MVC{{{{MOVE CHARACTERS OF LEFT ARGUMENT{11403
{{MOV{10,(XS)+{7,XL{{LOAD RIGHT ARG POINTER, POP STACK{11404
{{MOV{13,SCLEN(XL){8,WA{{LOAD NUMBER OF CHARS IN RIGHT ARG{11405
{{PLC{7,XL{{{PREPARE TO LOAD RIGHT ARG CHARS{11406
{{MVC{{{{MOVE CHARACTERS OF RIGHT ARGUMENT{11407
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{11408
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11409
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11410
*
*      COME HERE IF ARGUMENTS ARE NOT BOTH STRINGS
*
{OCNC2{JSR{6,GTSTG{{{CONVERT RIGHT ARG TO STRING{11414
{{PPM{6,OCNC5{{{JUMP IF RIGHT ARG IS NOT STRING{11415
{{MOV{7,XR{7,XL{{SAVE RIGHT ARG PTR{11416
{{JSR{6,GTSTG{{{CONVERT LEFT ARG TO STRING{11417
{{PPM{6,OCNC6{{{JUMP IF LEFT ARG IS NOT A STRING{11418
{{MOV{7,XR{11,-(XS){{STACK LEFT ARGUMENT{11419
{{MOV{7,XL{11,-(XS){{STACK RIGHT ARGUMENT{11420
{{MOV{7,XR{7,XL{{MOVE LEFT ARG TO PROPER REG{11421
{{MOV{9,(XS){7,XR{{MOVE RIGHT ARG TO PROPER REG{11422
{{BRN{6,OCNC1{{{MERGE BACK TO CONCATENATE STRINGS{11423
{{EJC{{{{{11424
*
*      CONCATENATION (CONTINUED)
*
*      COME HERE FOR NULL RIGHT ARGUMENT
*
{OCNC3{ICA{7,XS{{{REMOVE RIGHT ARG FROM STACK{11430
{{LCW{7,XR{{{LEFT ARGUMENT ON STACK{11431
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11432
*
*      HERE FOR NULL LEFT ARGUMENT
*
{OCNC4{ICA{7,XS{{{UNSTACK ONE ARGUMENT{11436
{{MOV{7,XR{9,(XS){{STORE RIGHT ARGUMENT{11437
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11438
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11439
*
*      HERE IF RIGHT ARGUMENT IS NOT A STRING
*
{OCNC5{MOV{7,XR{7,XL{{MOVE RIGHT ARGUMENT PTR{11443
{{MOV{10,(XS)+{7,XR{{LOAD LEFT ARG POINTER{11444
*
*      MERGE HERE WHEN LEFT ARGUMENT IS NOT A STRING
*
{OCNC6{JSR{6,GTPAT{{{CONVERT LEFT ARG TO PATTERN{11448
{{ERR{1,008{26,Concatenation left operand is not a string or pattern{{{11449
{{MOV{7,XR{11,-(XS){{SAVE RESULT ON STACK{11450
{{MOV{7,XL{7,XR{{POINT TO RIGHT OPERAND{11451
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11452
{{ERR{1,009{26,Concatenation right operand is not a string or pattern{{{11453
{{MOV{7,XR{7,XL{{MOVE FOR PCONC{11454
{{MOV{10,(XS)+{7,XR{{RELOAD LEFT OPERAND PTR{11455
{{JSR{6,PCONC{{{CONCATENATE PATTERNS{11456
{{MOV{7,XR{11,-(XS){{STACK RESULT{11457
{{LCW{7,XR{{{GET NEXT CODE WORD{11458
{{BRI{9,(XR){{{EXECUTE IT{11459
{{EJC{{{{{11460
*
*      COMPLEMENTATION
*
{O$COM{ENT{{{{ENTRY POINT{11464
{{MOV{10,(XS)+{7,XR{{LOAD OPERAND{11465
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{11466
*
*      MERGE BACK HERE AFTER CONVERSION
*
{OCOM1{BEQ{8,WA{22,=B$ICL{6,OCOM2{JUMP IF INTEGER{11470
{{BEQ{8,WA{22,=B$RCL{6,OCOM3{JUMP IF REAL{11473
{{JSR{6,GTNUM{{{ELSE CONVERT TO NUMERIC{11475
{{ERR{1,010{26,Negation operand is not numeric{{{11476
{{BRN{6,OCOM1{{{BACK TO CHECK CASES{11477
*
*      HERE TO COMPLEMENT INTEGER
*
{OCOM2{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{11481
{{NGI{{{{NEGATE{11482
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11483
{{ERB{1,011{26,Negation caused integer overflow{{{11484
*
*      HERE TO COMPLEMENT REAL
*
{OCOM3{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{11490
{{NGR{{{{NEGATE{11491
{{BRN{6,EXREA{{{RETURN REAL RESULT{11492
{{EJC{{{{{11494
*
*      BINARY SLASH (DIVISION)
*
{O$DVD{ENT{{{{ENTRY POINT{11498
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11499
{{ERR{1,012{26,Division left operand is not numeric{{{11500
{{ERR{1,013{26,Division right operand is not numeric{{{11501
{{PPM{6,ODVD2{{{JUMP IF REAL OPERANDS{11504
*
*      HERE TO DIVIDE TWO INTEGERS
*
{{DVI{13,ICVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{11509
{{INO{6,EXINT{{{RESULT OK IF NO OVERFLOW{11510
{{ERB{1,014{26,Division caused integer overflow{{{11511
*
*      HERE TO DIVIDE TWO REALS
*
{ODVD2{DVR{13,RCVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{11517
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11518
{{ERB{1,262{26,Division caused real overflow{{{11519
{{EJC{{{{{11521
*
*      EXPONENTIATION
*
{O$EXP{ENT{{{{ENTRY POINT{11525
{{MOV{10,(XS)+{7,XR{{LOAD EXPONENT{11526
{{JSR{6,GTNUM{{{CONVERT TO NUMBER{11527
{{ERR{1,015{26,Exponentiation right operand is not numeric{{{11528
{{MOV{7,XR{7,XL{{MOVE EXPONENT TO XL{11529
{{MOV{10,(XS)+{7,XR{{LOAD BASE{11530
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{11531
{{ERR{1,016{26,Exponentiation left operand is not numeric{{{11532
{{BEQ{9,(XL){22,=B$RCL{6,OEXP7{JUMP IF REAL EXPONENT{11535
{{LDI{13,ICVAL(XL){{{LOAD EXPONENT{11537
{{ILT{6,OEX12{{{JUMP IF NEGATIVE EXPONENT{11538
{{BEQ{8,WA{22,=B$RCL{6,OEXP3{JUMP IF BASE IS REAL{11541
*
*      HERE TO EXPONENTIATE AN INTEGER BASE AND INTEGER EXPONENT
*
{{MFI{8,WA{6,OEXP2{{CONVERT EXPONENT TO 1 WORD INTEGER{11546
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{11547
{{LDI{13,ICVAL(XR){{{LOAD BASE AS INITIAL VALUE{11548
{{BNZ{8,WA{6,OEXP1{{JUMP INTO LOOP IF NON-ZERO EXPONENT{11549
{{IEQ{6,OEXP4{{{ERROR IF 0**0{11550
{{LDI{4,INTV1{{{NONZERO**0{11551
{{BRN{6,EXINT{{{GIVE ONE AS RESULT FOR NONZERO**0{11552
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX13{MLI{13,ICVAL(XR){{{MULTIPLY BY BASE{11556
{{IOV{6,OEXP2{{{JUMP IF OVERFLOW{11557
{OEXP1{BCT{8,WA{6,OEX13{{LOOP IF MORE TO GO{11558
{{BRN{6,EXINT{{{ELSE RETURN INTEGER RESULT{11559
*
*      HERE IF INTEGER OVERFLOW
*
{OEXP2{ERB{1,017{26,Exponentiation caused integer overflow{{{11563
{{EJC{{{{{11564
*
*      EXPONENTIATION (CONTINUED)
*
*      HERE TO EXPONENTIATE A REAL TO AN INTEGER POWER
*
{OEXP3{MFI{8,WA{6,OEXP6{{CONVERT EXPONENT TO ONE WORD{11572
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{11573
{{LDR{13,RCVAL(XR){{{LOAD BASE AS INITIAL VALUE{11574
{{BNZ{8,WA{6,OEXP5{{JUMP INTO LOOP IF NON-ZERO EXPONENT{11575
{{REQ{6,OEXP4{{{ERROR IF 0.0**0{11576
{{LDR{4,REAV1{{{NONZERO**0{11577
{{BRN{6,EXREA{{{RETURN 1.0 IF NONZERO**ZERO{11578
*
*      HERE FOR ERROR OF 0**0 OR 0.0**0
*
{OEXP4{ERB{1,018{26,Exponentiation result is undefined{{{11583
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX14{MLR{13,RCVAL(XR){{{MULTIPLY BY BASE{11589
{{ROV{6,OEXP6{{{JUMP IF OVERFLOW{11590
{OEXP5{BCT{8,WA{6,OEX14{{LOOP TILL COMPUTATION COMPLETE{11591
{{BRN{6,EXREA{{{THEN RETURN REAL RESULT{11592
*
*      HERE IF REAL OVERFLOW
*
{OEXP6{ERB{1,266{26,Exponentiation caused real overflow{{{11596
*
*      HERE WITH REAL EXPONENT IN (XL), NUMERIC BASE IN (XR)
*
{OEXP7{BEQ{9,(XR){22,=B$RCL{6,OEXP8{JUMP IF BASE REAL{11601
{{LDI{13,ICVAL(XR){{{LOAD INTEGER BASE{11602
{{ITR{{{{CONVERT TO REAL{11603
{{JSR{6,RCBLD{{{CREATE REAL IN (XR){11604
*
*      HERE WITH REAL EXPONENT IN (XL)
*      NUMERIC BASE IN (XR) AND RA
*
{OEXP8{ZER{8,WB{{{SET POSITIVE RESULT FLAG{11609
{{LDR{13,RCVAL(XR){{{LOAD BASE TO RA{11610
{{RNE{6,OEXP9{{{JUMP IF BASE NON-ZERO{11611
{{LDR{13,RCVAL(XL){{{BASE IS ZERO.  CHECK EXPONENT{11612
{{REQ{6,OEXP4{{{JUMP IF 0.0 ** 0.0{11613
{{LDR{4,REAV0{{{0.0 TO NON-ZERO EXPONENT YIELDS 0.0{11614
{{BRN{6,EXREA{{{RETURN ZERO RESULT{11615
*
*      HERE WITH NON-ZERO BASE IN (XR) AND RA, EXPONENT IN (XL)
*
*      A NEGATIVE BASE IS ALLOWED IF THE EXPONENT IS INTEGRAL.
*
{OEXP9{RGT{6,OEX10{{{JUMP IF BASE GT 0.0{11621
{{NGR{{{{MAKE BASE POSITIVE{11622
{{JSR{6,RCBLD{{{CREATE POSITIVE BASE IN (XR){11623
{{LDR{13,RCVAL(XL){{{EXAMINE EXPONENT{11624
{{CHP{{{{CHOP TO INTEGRAL VALUE{11625
{{RTI{6,OEXP6{{{CONVERT TO INTEGER, BR IF TOO LARGE{11626
{{SBR{13,RCVAL(XL){{{CHOP(EXPONENT) - EXPONENT{11627
{{RNE{6,OEX11{{{NON-INTEGRAL POWER WITH NEG BASE{11628
{{MFI{8,WB{{{RECORD EVEN/ODD EXPONENT{11629
{{ANB{4,BITS1{8,WB{{ODD EXPONENT YIELDS NEGATIVE RESULT{11630
{{LDR{13,RCVAL(XR){{{RESTORE BASE TO RA{11631
*
*      HERE WITH POSITIVE BASE IN RA AND (XR), EXPONENT IN (XL)
*
{OEX10{LNF{{{{LOG OF BASE{11635
{{ROV{6,OEXP6{{{TOO LARGE{11636
{{MLR{13,RCVAL(XL){{{TIMES EXPONENT{11637
{{ROV{6,OEXP6{{{TOO LARGE{11638
{{ETX{{{{E ** (EXPONENT * LN(BASE)){11639
{{ROV{6,OEXP6{{{TOO LARGE{11640
{{BZE{8,WB{6,EXREA{{IF NO SIGN FIXUP REQUIRED{11641
{{NGR{{{{NEGATIVE RESULT NEEDED{11642
{{BRN{6,EXREA{{{{11643
*
*      HERE FOR NON-INTEGRAL EXPONENT WITH NEGATIVE BASE
*
{OEX11{ERB{1,311{26,Exponentiation of negative base to non-integral power{{{11647
*
*      HERE WITH NEGATIVE INTEGER EXPONENT IN IA
*
{OEX12{MOV{7,XR{11,-(XS){{STACK BASE{11656
{{ITR{{{{CONVERT TO REAL EXPONENT{11657
{{JSR{6,RCBLD{{{REAL NEGATIVE EXPONENT IN (XR){11658
{{MOV{7,XR{7,XL{{PUT EXPONENT IN XL{11659
{{MOV{10,(XS)+{7,XR{{RESTORE BASE VALUE{11660
{{BRN{6,OEXP7{{{PROCESS REAL EXPONENT{11661
{{EJC{{{{{11665
*
*      FAILURE IN EXPRESSION EVALUATION
*
*      THIS ENTRY POINT IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, FAILS.
*      CONTROL IS RETURNED TO AN APPROPRIATE POINT IN EVALX.
*
{O$FEX{ENT{{{{ENTRY POINT{11673
{{BRN{6,EVLX6{{{JUMP TO FAILURE LOC IN EVALX{11674
{{EJC{{{{{11675
*
*      FAILURE DURING EVALUATION OF A COMPLEX OR DIRECT GOTO
*
{O$FIF{ENT{{{{ENTRY POINT{11679
{{ERB{1,020{26,Goto evaluation failure{{{11680
{{EJC{{{{{11681
*
*      FUNCTION CALL (MORE THAN ONE ARGUMENT)
*
{O$FNC{ENT{{{{ENTRY POINT{11685
{{LCW{8,WA{{{LOAD NUMBER OF ARGUMENTS{11686
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{11687
{{MOV{13,VRFNC(XR){7,XL{{LOAD FUNCTION POINTER{11688
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{11689
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{11690
{{EJC{{{{{11691
*
*      FUNCTION NAME ERROR
*
{O$FNE{ENT{{{{ENTRY POINT{11695
{{LCW{8,WA{{{GET NEXT CODE WORD{11696
{{BNE{8,WA{21,=ORNM${6,OFNE1{FAIL IF NOT EVALUATING EXPRESSION{11697
{{BZE{13,NUM02(XS){6,EVLX3{{OK IF EXPR. WAS WANTED BY VALUE{11698
*
*      HERE FOR ERROR
*
{OFNE1{ERB{1,021{26,Function called by name returned a value{{{11702
{{EJC{{{{{11703
*
*      FUNCTION CALL (SINGLE ARGUMENT)
*
{O$FNS{ENT{{{{ENTRY POINT{11707
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{11708
{{MOV{18,=NUM01{8,WA{{SET NUMBER OF ARGUMENTS TO ONE{11709
{{MOV{13,VRFNC(XR){7,XL{{LOAD FUNCTION POINTER{11710
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{11711
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{11712
{{EJC{{{{{11713
*      CALL TO UNDEFINED FUNCTION
*
{O$FUN{ENT{{{{ENTRY POINT{11716
{{ERB{1,022{26,Undefined function called{{{11717
{{EJC{{{{{11718
*
*      EXECUTE COMPLEX GOTO
*
{O$GOC{ENT{{{{ENTRY POINT{11722
{{MOV{13,NUM01(XS){7,XR{{LOAD NAME BASE POINTER{11723
{{BHI{7,XR{3,STATE{6,OGOC1{JUMP IF NOT NATURAL VARIABLE{11724
{{ADD{19,*VRTRA{7,XR{{ELSE POINT TO VRTRA FIELD{11725
{{BRI{9,(XR){{{AND JUMP THROUGH IT{11726
*
*      HERE IF GOTO OPERAND IS NOT NATURAL VARIABLE
*
{OGOC1{ERB{1,023{26,Goto operand is not a natural variable{{{11730
{{EJC{{{{{11731
*
*      EXECUTE DIRECT GOTO
*
{O$GOD{ENT{{{{ENTRY POINT{11735
{{MOV{9,(XS){7,XR{{LOAD OPERAND{11736
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD{11737
{{BEQ{8,WA{22,=B$CDS{6,BCDS0{JUMP IF CODE BLOCK TO CODE ROUTINE{11738
{{BEQ{8,WA{22,=B$CDC{6,BCDC0{JUMP IF CODE BLOCK TO CODE ROUTINE{11739
{{ERB{1,024{26,Goto operand in direct goto is not code{{{11740
{{EJC{{{{{11741
*
*      SET GOTO FAILURE TRAP
*
*      THIS ROUTINE IS EXECUTED AT THE START OF A COMPLEX OR
*      DIRECT FAILURE GOTO TO TRAP A SUBSEQUENT FAIL (SEE EXFAL)
*
{O$GOF{ENT{{{{ENTRY POINT{11748
{{MOV{3,FLPTR{7,XR{{POINT TO FAIL OFFSET ON STACK{11749
{{ICA{9,(XR){{{POINT FAILURE TO O$FIF WORD{11750
{{ICP{{{{POINT TO NEXT CODE WORD{11751
{{LCW{7,XR{{{FETCH NEXT CODE WORD{11752
{{BRI{9,(XR){{{EXECUTE IT{11753
{{EJC{{{{{11754
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOLLAR IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O$IMA{ENT{{{{ENTRY POINT{11762
{{MOV{22,=P$IMC{8,WB{{SET PCODE FOR LAST NODE{11763
{{MOV{10,(XS)+{8,WC{{POP NAME OFFSET (PARM2){11764
{{MOV{10,(XS)+{7,XR{{POP NAME BASE (PARM1){11765
{{JSR{6,PBILD{{{BUILD P$IMC NODE{11766
{{MOV{7,XR{7,XL{{SAVE PTR TO NODE{11767
{{MOV{9,(XS){7,XR{{LOAD LEFT ARGUMENT{11768
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11769
{{ERR{1,025{26,Immediate assignment left operand is not pattern{{{11770
{{MOV{7,XR{9,(XS){{SAVE PTR TO LEFT OPERAND PATTERN{11771
{{MOV{22,=P$IMA{8,WB{{SET PCODE FOR FIRST NODE{11772
{{JSR{6,PBILD{{{BUILD P$IMA NODE{11773
{{MOV{10,(XS)+{13,PTHEN(XR){{SET LEFT OPERAND AS P$IMA SUCCESSOR{11774
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{11775
{{MOV{7,XR{11,-(XS){{STACK RESULT{11776
{{LCW{7,XR{{{GET NEXT CODE WORD{11777
{{BRI{9,(XR){{{EXECUTE IT{11778
{{EJC{{{{{11779
*
*      INDIRECTION (BY NAME)
*
{O$INN{ENT{{{{ENTRY POINT{11783
{{MNZ{8,WB{{{SET FLAG FOR RESULT BY NAME{11784
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{11785
{{EJC{{{{{11786
*
*      INTERROGATION
*
{O$INT{ENT{{{{ENTRY POINT{11790
{{MOV{21,=NULLS{9,(XS){{REPLACE OPERAND WITH NULL{11791
{{LCW{7,XR{{{GET NEXT CODE WORD{11792
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11793
{{EJC{{{{{11794
*
*      INDIRECTION (BY VALUE)
*
{O$INV{ENT{{{{ENTRY POINT{11798
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{11799
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{11800
{{EJC{{{{{11801
*
*      KEYWORD REFERENCE (BY NAME)
*
{O$KWN{ENT{{{{ENTRY POINT{11805
{{JSR{6,KWNAM{{{GET KEYWORD NAME{11806
{{BRN{6,EXNAM{{{EXIT WITH RESULT NAME{11807
{{EJC{{{{{11808
*
*      KEYWORD REFERENCE (BY VALUE)
*
{O$KWV{ENT{{{{ENTRY POINT{11812
{{JSR{6,KWNAM{{{GET KEYWORD NAME{11813
{{MOV{7,XR{3,DNAMP{{DELETE KVBLK{11814
{{JSR{6,ACESS{{{ACCESS VALUE{11815
{{PPM{6,EXNUL{{{DUMMY (UNUSED) FAILURE RETURN{11816
{{MOV{7,XR{11,-(XS){{STACK RESULT{11817
{{LCW{7,XR{{{GET NEXT CODE WORD{11818
{{BRI{9,(XR){{{EXECUTE IT{11819
{{EJC{{{{{11820
*
*      LOAD EXPRESSION BY NAME
*
{O$LEX{ENT{{{{ENTRY POINT{11824
{{MOV{19,*EVSI${8,WA{{SET SIZE OF EVBLK{11825
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EVBLK{11826
{{MOV{22,=B$EVT{9,(XR){{SET TYPE WORD{11827
{{MOV{21,=TRBEV{13,EVVAR(XR){{SET DUMMY TRBLK POINTER{11828
{{LCW{8,WA{{{LOAD EXBLK POINTER{11829
{{MOV{8,WA{13,EVEXP(XR){{SET EXBLK POINTER{11830
{{MOV{7,XR{7,XL{{MOVE NAME BASE TO PROPER REG{11831
{{MOV{19,*EVVAR{8,WA{{SET NAME OFFSET = ZERO{11832
{{BRN{6,EXNAM{{{EXIT WITH NAME IN (XL,WA){11833
{{EJC{{{{{11834
*
*      LOAD PATTERN VALUE
*
{O$LPT{ENT{{{{ENTRY POINT{11838
{{LCW{7,XR{{{LOAD PATTERN POINTER{11839
{{MOV{7,XR{11,-(XS){{STACK RESULT{11840
{{LCW{7,XR{{{GET NEXT CODE WORD{11841
{{BRI{9,(XR){{{EXECUTE IT{11842
{{EJC{{{{{11843
*
*      LOAD VARIABLE NAME
*
{O$LVN{ENT{{{{ENTRY POINT{11847
{{LCW{8,WA{{{LOAD VRBLK POINTER{11848
{{MOV{8,WA{11,-(XS){{STACK VRBLK PTR (NAME BASE){11849
{{MOV{19,*VRVAL{11,-(XS){{STACK NAME OFFSET{11850
{{LCW{7,XR{{{GET NEXT CODE WORD{11851
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11852
{{EJC{{{{{11853
*
*      BINARY ASTERISK (MULTIPLICATION)
*
{O$MLT{ENT{{{{ENTRY POINT{11857
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11858
{{ERR{1,026{26,Multiplication left operand is not numeric{{{11859
{{ERR{1,027{26,Multiplication right operand is not numeric{{{11860
{{PPM{6,OMLT1{{{JUMP IF REAL OPERANDS{11863
*
*      HERE TO MULTIPLY TWO INTEGERS
*
{{MLI{13,ICVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{11868
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11869
{{ERB{1,028{26,Multiplication caused integer overflow{{{11870
*
*      HERE TO MULTIPLY TWO REALS
*
{OMLT1{MLR{13,RCVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{11876
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11877
{{ERB{1,263{26,Multiplication caused real overflow{{{11878
{{EJC{{{{{11880
*
*      NAME REFERENCE
*
{O$NAM{ENT{{{{ENTRY POINT{11884
{{MOV{19,*NMSI${8,WA{{SET LENGTH OF NMBLK{11885
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{11886
{{MOV{22,=B$NML{9,(XR){{SET NAME BLOCK CODE{11887
{{MOV{10,(XS)+{13,NMOFS(XR){{SET NAME OFFSET FROM OPERAND{11888
{{MOV{10,(XS)+{13,NMBAS(XR){{SET NAME BASE FROM OPERAND{11889
{{MOV{7,XR{11,-(XS){{STACK RESULT{11890
{{LCW{7,XR{{{GET NEXT CODE WORD{11891
{{BRI{9,(XR){{{EXECUTE IT{11892
{{EJC{{{{{11893
*
*      NEGATION
*
*      INITIAL ENTRY
*
{O$NTA{ENT{{{{ENTRY POINT{11899
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{11900
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{11901
{{MOV{8,WA{11,-(XS){{STACK NEW FAILURE OFFSET{11902
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{11903
{{LCW{7,XR{{{GET NEXT CODE WORD{11904
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11905
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF OPERAND
*
{O$NTB{ENT{{{{ENTRY POINT{11909
{{MOV{13,NUM02(XS){3,FLPTR{{RESTORE OLD FAILURE POINTER{11910
{{BRN{6,EXFAL{{{AND FAIL{11911
*
*      ENTRY FOR FAILURE DURING OPERAND EVALUATION
*
{O$NTC{ENT{{{{ENTRY POINT{11915
{{ICA{7,XS{{{POP FAILURE OFFSET{11916
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{11917
{{BRN{6,EXNUL{{{EXIT GIVING NULL RESULT{11918
{{EJC{{{{{11919
*
*      USE OF UNDEFINED OPERATOR
*
{O$OUN{ENT{{{{ENTRY POINT{11923
{{ERB{1,029{26,Undefined operator referenced{{{11924
{{EJC{{{{{11925
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOT IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O$PAS{ENT{{{{ENTRY POINT{11933
{{MOV{22,=P$PAC{8,WB{{LOAD PCODE FOR P$PAC NODE{11934
{{MOV{10,(XS)+{8,WC{{LOAD NAME OFFSET (PARM2){11935
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE (PARM1){11936
{{JSR{6,PBILD{{{BUILD P$PAC NODE{11937
{{MOV{7,XR{7,XL{{SAVE PTR TO NODE{11938
{{MOV{9,(XS){7,XR{{LOAD LEFT OPERAND{11939
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11940
{{ERR{1,030{26,Pattern assignment left operand is not pattern{{{11941
{{MOV{7,XR{9,(XS){{SAVE PTR TO LEFT OPERAND PATTERN{11942
{{MOV{22,=P$PAA{8,WB{{SET PCODE FOR P$PAA NODE{11943
{{JSR{6,PBILD{{{BUILD P$PAA NODE{11944
{{MOV{10,(XS)+{13,PTHEN(XR){{SET LEFT OPERAND AS P$PAA SUCCESSOR{11945
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{11946
{{MOV{7,XR{11,-(XS){{STACK RESULT{11947
{{LCW{7,XR{{{GET NEXT CODE WORD{11948
{{BRI{9,(XR){{{EXECUTE IT{11949
{{EJC{{{{{11950
*
*      PATTERN MATCH (BY NAME, FOR REPLACEMENT)
*
{O$PMN{ENT{{{{ENTRY POINT{11954
{{ZER{8,WB{{{SET TYPE CODE FOR MATCH BY NAME{11955
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11956
{{EJC{{{{{11957
*
*      PATTERN MATCH (STATEMENT)
*
*      O$PMS IS USED IN PLACE OF O$PMV WHEN THE PATTERN MATCH
*      OCCURS AT THE OUTER (STATEMENT) LEVEL SINCE IN THIS
*      CASE THE SUBSTRING VALUE NEED NOT BE CONSTRUCTED.
*
{O$PMS{ENT{{{{ENTRY POINT{11965
{{MOV{18,=NUM02{8,WB{{SET FLAG FOR STATEMENT TO MATCH{11966
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11967
{{EJC{{{{{11968
*
*      PATTERN MATCH (BY VALUE)
*
{O$PMV{ENT{{{{ENTRY POINT{11972
{{MOV{18,=NUM01{8,WB{{SET TYPE CODE FOR VALUE MATCH{11973
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11974
{{EJC{{{{{11975
*
*      POP TOP ITEM ON STACK
*
{O$POP{ENT{{{{ENTRY POINT{11979
{{ICA{7,XS{{{POP TOP STACK ENTRY{11980
{{LCW{7,XR{{{GET NEXT CODE WORD{11981
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11982
{{EJC{{{{{11983
*
*      TERMINATE EXECUTION (CODE COMPILED FOR END STATEMENT)
*
{O$STP{ENT{{{{ENTRY POINT{11987
{{BRN{6,LEND0{{{JUMP TO END CIRCUIT{11988
{{EJC{{{{{11989
*
*      RETURN NAME FROM EXPRESSION
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A NAME. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX.
*
{O$RNM{ENT{{{{ENTRY POINT{11996
{{BRN{6,EVLX4{{{RETURN TO EVALX PROCEDURE{11997
{{EJC{{{{{11998
*
*      PATTERN REPLACEMENT
*
*      WHEN THIS ROUTINE GETS CONTROL, THE FOLLOWING STACK
*      ENTRIES HAVE BEEN MADE (SEE END OF MATCH ROUTINE P$NTH)
*
*                            SUBJECT NAME BASE
*                            SUBJECT NAME OFFSET
*                            INITIAL CURSOR VALUE
*                            FINAL CURSOR VALUE
*                            SUBJECT STRING POINTER
*      (XS) ---------------- REPLACEMENT VALUE
*
{O$RPL{ENT{{{{ENTRY POINT{12012
{{JSR{6,GTSTG{{{CONVERT REPLACEMENT VAL TO STRING{12013
{{ERR{1,031{26,Pattern replacement right operand is not a string{{{12014
*
*      GET RESULT LENGTH AND ALLOCATE RESULT SCBLK
*
{{MOV{9,(XS){7,XL{{LOAD SUBJECT STRING POINTER{12018
{{ADD{13,SCLEN(XL){8,WA{{ADD SUBJECT STRING LENGTH{12023
{{ADD{13,NUM02(XS){8,WA{{ADD STARTING CURSOR{12024
{{SUB{13,NUM01(XS){8,WA{{MINUS FINAL CURSOR = TOTAL LENGTH{12025
{{BZE{8,WA{6,ORPL3{{JUMP IF RESULT IS NULL{12026
{{MOV{7,XR{11,-(XS){{RESTACK REPLACEMENT STRING{12027
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{12028
{{MOV{13,NUM03(XS){8,WA{{GET INITIAL CURSOR (PART 1 LEN){12029
{{MOV{7,XR{13,NUM03(XS){{STACK RESULT POINTER{12030
{{PSC{7,XR{{{POINT TO CHARACTERS OF RESULT{12031
*
*      MOVE PART 1 (START OF SUBJECT) TO RESULT
*
{{BZE{8,WA{6,ORPL1{{JUMP IF FIRST PART IS NULL{12035
{{MOV{13,NUM01(XS){7,XL{{ELSE POINT TO SUBJECT STRING{12036
{{PLC{7,XL{{{POINT TO SUBJECT STRING CHARS{12037
{{MVC{{{{MOVE FIRST PART TO RESULT{12038
{{EJC{{{{{12039
*      PATTERN REPLACEMENT (CONTINUED)
*
*      NOW MOVE IN REPLACEMENT VALUE
*
{ORPL1{MOV{10,(XS)+{7,XL{{LOAD REPLACEMENT STRING, POP{12044
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH{12045
{{BZE{8,WA{6,ORPL2{{JUMP IF NULL REPLACEMENT{12046
{{PLC{7,XL{{{ELSE POINT TO CHARS OF REPLACEMENT{12047
{{MVC{{{{MOVE IN CHARS (PART 2){12048
*
*      NOW MOVE IN REMAINDER OF STRING (PART 3)
*
{ORPL2{MOV{10,(XS)+{7,XL{{LOAD SUBJECT STRING POINTER, POP{12052
{{MOV{10,(XS)+{8,WC{{LOAD FINAL CURSOR, POP{12053
{{MOV{13,SCLEN(XL){8,WA{{LOAD SUBJECT STRING LENGTH{12054
{{SUB{8,WC{8,WA{{MINUS FINAL CURSOR = PART 3 LENGTH{12055
{{BZE{8,WA{6,OASS0{{JUMP TO ASSIGN IF PART 3 IS NULL{12056
{{PLC{7,XL{8,WC{{ELSE POINT TO LAST PART OF STRING{12057
{{MVC{{{{MOVE PART 3 TO RESULT{12058
{{BRN{6,OASS0{{{JUMP TO PERFORM ASSIGNMENT{12059
*
*      HERE IF RESULT IS NULL
*
{ORPL3{ADD{19,*NUM02{7,XS{{POP SUBJECT STR PTR, FINAL CURSOR{12063
{{MOV{21,=NULLS{9,(XS){{SET NULL RESULT{12064
{{BRN{6,OASS0{{{JUMP TO ASSIGN NULL VALUE{12065
{{EJC{{{{{12084
*
*      RETURN VALUE FROM EXPRESSION
*
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A VALUE. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX
*
{O$RVL{ENT{{{{ENTRY POINT{12092
{{BRN{6,EVLX3{{{RETURN TO EVALX PROCEDURE{12093
{{EJC{{{{{12094
*
*      SELECTION
*
*      INITIAL ENTRY
*
{O$SLA{ENT{{{{ENTRY POINT{12100
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{12101
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{12102
{{MOV{8,WA{11,-(XS){{STACK NEW FAILURE OFFSET{12103
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{12104
{{LCW{7,XR{{{GET NEXT CODE WORD{12105
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12106
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF ALTERNATIVE
*
{O$SLB{ENT{{{{ENTRY POINT{12110
{{MOV{10,(XS)+{7,XR{{LOAD RESULT{12111
{{ICA{7,XS{{{POP FAIL OFFSET{12112
{{MOV{9,(XS){3,FLPTR{{RESTORE OLD FAILURE POINTER{12113
{{MOV{7,XR{9,(XS){{RESTACK RESULT{12114
{{LCW{8,WA{{{LOAD NEW CODE OFFSET{12115
{{ADD{3,R$COD{8,WA{{POINT TO ABSOLUTE CODE LOCATION{12116
{{LCP{8,WA{{{SET NEW CODE POINTER{12117
{{LCW{7,XR{{{GET NEXT CODE WORD{12118
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12119
*
*      ENTRY AT START OF SUBSEQUENT ALTERNATIVES
*
{O$SLC{ENT{{{{ENTRY POINT{12123
{{LCW{8,WA{{{LOAD NEW FAIL OFFSET{12124
{{MOV{8,WA{9,(XS){{STORE NEW FAIL OFFSET{12125
{{LCW{7,XR{{{GET NEXT CODE WORD{12126
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12127
*
*      ENTRY AT START OF LAST ALTERNATIVE
*
{O$SLD{ENT{{{{ENTRY POINT{12131
{{ICA{7,XS{{{POP FAILURE OFFSET{12132
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{12133
{{LCW{7,XR{{{GET NEXT CODE WORD{12134
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12135
{{EJC{{{{{12136
*
*      BINARY MINUS (SUBTRACTION)
*
{O$SUB{ENT{{{{ENTRY POINT{12140
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{12141
{{ERR{1,032{26,Subtraction left operand is not numeric{{{12142
{{ERR{1,033{26,Subtraction right operand is not numeric{{{12143
{{PPM{6,OSUB1{{{JUMP IF REAL OPERANDS{12146
*
*      HERE TO SUBTRACT TWO INTEGERS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{12151
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{12152
{{ERB{1,034{26,Subtraction caused integer overflow{{{12153
*
*      HERE TO SUBTRACT TWO REALS
*
{OSUB1{SBR{13,RCVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{12159
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{12160
{{ERB{1,264{26,Subtraction caused real overflow{{{12161
{{EJC{{{{{12163
*
*      DUMMY OPERATOR TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{O$TXR{ENT{{{{ENTRY POINT{12167
{{BRN{6,TRXQ1{{{JUMP INTO TRXEQ PROCEDURE{12168
{{EJC{{{{{12169
*
*      UNEXPECTED FAILURE
*
*      NOTE THAT IF A SETEXIT TRAP IS OPERATING THEN
*      TRANSFER TO SYSTEM LABEL CONTINUE
*      WILL RESULT IN LOOPING HERE.  DIFFICULT TO AVOID EXCEPT
*      WITH A CONSIDERABLE OVERHEAD WHICH IS NOT WORTHWHILE OR
*      ELSE BY A TECHNIQUE SUCH AS SETTING KVERL TO ZERO.
*
{O$UNF{ENT{{{{ENTRY POINT{12179
{{ERB{1,035{26,Unexpected failure in -NOFAIL mode{{{12180
{{TTL{27,S P I T B O L -- BLOCK ACTION ROUTINES{{{{12181
*
*      THE FIRST WORD OF EVERY BLOCK IN DYNAMIC STORAGE AND THE
*      VRGET, VRSTO AND VRTRA FIELDS OF A VRBLK CONTAIN A
*      POINTER TO AN ENTRY POINT IN THE PROGRAM. ALL SUCH ENTRY
*      POINTS ARE IN THE FOLLOWING SECTION EXCEPT THOSE FOR
*      PATTERN BLOCKS WHICH ARE IN THE PATTERN MATCHING SEGMENT
*      LATER ON (LABELS OF THE FORM P$XXX), AND DOPE VECTORS
*      (D$XXX) WHICH ARE IN THE DOPE VECTOR SECTION FOLLOWING
*      THE PATTERN ROUTINES (DOPE VECTORS ARE USED FOR CMBLKS).
*
*      THE ENTRY POINTS IN THIS SECTION HAVE LABELS OF THE
*      FORM B$XXY WHERE XX IS THE TWO CHARACTER BLOCK TYPE FOR
*      THE CORRESPONDING BLOCK AND Y IS ANY LETTER.
*
*      IN SOME CASES, THE POINTERS SERVE NO OTHER PURPOSE THAN
*      TO IDENTIFY THE BLOCK TYPE. IN THIS CASE THE ROUTINE
*      IS NEVER EXECUTED AND THUS NO CODE IS ASSEMBLED.
*
*      FOR EACH OF THESE ENTRY POINTS CORRESPONDING TO A BLOCK
*      AN ENTRY POINT IDENTIFICATION IS ASSEMBLED (BL$XX).
*
*      THE EXACT ENTRY CONDITIONS DEPEND ON THE MANNER IN
*      WHICH THE ROUTINE IS ACCESSED AND ARE DOCUMENTED WITH
*      THE INDIVIDUAL ROUTINES AS REQUIRED.
*
*      THE ORDER OF THESE ROUTINES IS ALPHABETICAL WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      THE ROUTINES FOR SEBLK AND EXBLK ENTRIES OCCUR FIRST SO
*      THAT EXPRESSIONS CAN BE QUICKLY IDENTIFIED FROM THE FACT
*      THAT THEIR ROUTINES LIE BEFORE THE SYMBOL B$E$$.
*
*      THESE ARE IMMEDIATELY FOLLOWED BY THE ROUTINE FOR A TRBLK
*      SO THAT THE TEST AGAINST THE SYMBOL B$T$$ CHECKS FOR
*      TRAPPED VALUES OR EXPRESSION VALUES (SEE PROCEDURE EVALP)
*
*      THE PATTERN ROUTINES LIE AFTER THIS SECTION SO THAT
*      PATTERNS ARE IDENTIFIED WITH ROUTINES STARTING AT OR
*      AFTER THE INITIAL INSTRUCTION IN THESE ROUTINES (P$AAA).
*
*      THE SYMBOL B$AAA DEFINES THE FIRST LOCATION FOR BLOCK
*      ROUTINES AND THE SYMBOL P$YYY (AT THE END OF THE PATTERN
*      MATCH ROUTINES SECTION) DEFINES THE LAST SUCH ENTRY POINT
*
{B$AAA{ENT{2,BL$$I{{{ENTRY POINT OF FIRST BLOCK ROUTINE{12226
{{EJC{{{{{12227
*
*      EXBLK
*
*      THE ROUTINE FOR AN EXBLK LOADS THE EXPRESSION ONTO
*      THE STACK AS A VALUE.
*
*      (XR)                  POINTER TO EXBLK
*
{B$EXL{ENT{2,BL$EX{{{ENTRY POINT (EXBLK){12236
{{MOV{7,XR{11,-(XS){{STACK RESULT{12237
{{LCW{7,XR{{{GET NEXT CODE WORD{12238
{{BRI{9,(XR){{{EXECUTE IT{12239
{{EJC{{{{{12240
*
*      SEBLK
*
*      THE ROUTINE FOR SEBLK IS ACCESSED FROM THE GENERATED
*      CODE TO LOAD THE EXPRESSION VALUE ONTO THE STACK.
*
{B$SEL{ENT{2,BL$SE{{{ENTRY POINT (SEBLK){12247
{{MOV{7,XR{11,-(XS){{STACK RESULT{12248
{{LCW{7,XR{{{GET NEXT CODE WORD{12249
{{BRI{9,(XR){{{EXECUTE IT{12250
*
*      DEFINE SYMBOL WHICH MARKS END OF ENTRIES FOR EXPRESSIONS
*
{B$E$${ENT{2,BL$$I{{{ENTRY POINT{12254
{{EJC{{{{{12255
*
*      TRBLK
*
*      THE ROUTINE FOR A TRBLK IS NEVER EXECUTED
*
{B$TRT{ENT{2,BL$TR{{{ENTRY POINT (TRBLK){12261
*
*      DEFINE SYMBOL MARKING END OF TRAP AND EXPRESSION BLOCKS
*
{B$T$${ENT{2,BL$$I{{{END OF TRBLK,SEBLK,EXBLK ENTRIES{12265
{{EJC{{{{{12266
*
*      ARBLK
*
*      THE ROUTINE FOR ARBLK IS NEVER EXECUTED
*
{B$ART{ENT{2,BL$AR{{{ENTRY POINT (ARBLK){12272
{{EJC{{{{{12273
*
*      BCBLK
*
*      THE ROUTINE FOR A BCBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BCBLK
*
{B$BCT{ENT{2,BL$BC{{{ENTRY POINT (BCBLK){12281
{{EJC{{{{{12282
*
*      BFBLK
*
*      THE ROUTINE FOR A BFBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BFBLK
*
{B$BFT{ENT{2,BL$BF{{{ENTRY POINT (BFBLK){12290
{{EJC{{{{{12291
*
*      CCBLK
*
*      THE ROUTINE FOR CCBLK IS NEVER ENTERED
*
{B$CCT{ENT{2,BL$CC{{{ENTRY POINT (CCBLK){12297
{{EJC{{{{{12298
*
*      CDBLK
*
*      THE CDBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE TWO CASES DEPENDING ON THE FORM OF CDFAL.
*
*      ENTRY FOR COMPLEX FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B$CDC{ENT{2,BL$CD{{{ENTRY POINT (CDBLK){12309
{BCDC0{MOV{3,FLPTR{7,XS{{POP GARBAGE OFF STACK{12310
{{MOV{13,CDFAL(XR){9,(XS){{SET FAILURE OFFSET{12311
{{BRN{6,STMGO{{{ENTER STMT{12312
{{EJC{{{{{12313
*
*      CDBLK (CONTINUED)
*
*      ENTRY FOR SIMPLE FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B$CDS{ENT{2,BL$CD{{{ENTRY POINT (CDBLK){12321
{BCDS0{MOV{3,FLPTR{7,XS{{POP GARBAGE OFF STACK{12322
{{MOV{19,*CDFAL{9,(XS){{SET FAILURE OFFSET{12323
{{BRN{6,STMGO{{{ENTER STMT{12324
{{EJC{{{{{12325
*
*      CMBLK
*
*      THE ROUTINE FOR A CMBLK IS NEVER EXECUTED
*
{B$CMT{ENT{2,BL$CM{{{ENTRY POINT (CMBLK){12331
{{EJC{{{{{12332
*
*      CTBLK
*
*      THE ROUTINE FOR A CTBLK IS NEVER EXECUTED
*
{B$CTT{ENT{2,BL$CT{{{ENTRY POINT (CTBLK){12338
{{EJC{{{{{12339
*
*      DFBLK
*
*      THE ROUTINE FOR A DFBLK IS ACCESSED FROM THE O$FNC ENTRY
*      TO CALL A DATATYPE FUNCTION AND BUILD A PDBLK.
*
*      (XL)                  POINTER TO DFBLK
*
{B$DFC{ENT{2,BL$DF{{{ENTRY POINT{12348
{{MOV{13,DFPDL(XL){8,WA{{LOAD LENGTH OF PDBLK{12349
{{JSR{6,ALLOC{{{ALLOCATE PDBLK{12350
{{MOV{22,=B$PDT{9,(XR){{STORE TYPE WORD{12351
{{MOV{7,XL{13,PDDFP(XR){{STORE DFBLK POINTER{12352
{{MOV{7,XR{8,WC{{SAVE POINTER TO PDBLK{12353
{{ADD{8,WA{7,XR{{POINT PAST PDBLK{12354
{{LCT{8,WA{13,FARGS(XL){{SET TO COUNT FIELDS{12355
*
*      LOOP TO ACQUIRE FIELD VALUES FROM STACK
*
{BDFC1{MOV{10,(XS)+{11,-(XR){{MOVE A FIELD VALUE{12359
{{BCT{8,WA{6,BDFC1{{LOOP TILL ALL MOVED{12360
{{MOV{8,WC{7,XR{{RECALL POINTER TO PDBLK{12361
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{12362
{{EJC{{{{{12363
*
*      EFBLK
*
*      THE ROUTINE FOR AN EFBLK IS PASSED CONTROL FORM THE O$FNC
*      ENTRY TO CALL AN EXTERNAL FUNCTION.
*
*      (XL)                  POINTER TO EFBLK
*
{B$EFC{ENT{2,BL$EF{{{ENTRY POINT (EFBLK){12372
{{MOV{13,FARGS(XL){8,WC{{LOAD NUMBER OF ARGUMENTS{12375
{{WTB{8,WC{{{CONVERT TO OFFSET{12376
{{MOV{7,XL{11,-(XS){{SAVE POINTER TO EFBLK{12377
{{MOV{7,XS{7,XT{{COPY POINTER TO ARGUMENTS{12378
*
*      LOOP TO CONVERT ARGUMENTS
*
{BEFC1{ICA{7,XT{{{POINT TO NEXT ENTRY{12382
{{MOV{9,(XS){7,XR{{LOAD POINTER TO EFBLK{12383
{{DCA{8,WC{{{DECREMENT EFTAR OFFSET{12384
{{ADD{8,WC{7,XR{{POINT TO NEXT EFTAR ENTRY{12385
{{MOV{13,EFTAR(XR){7,XR{{LOAD EFTAR ENTRY{12386
{{BSW{7,XR{1,5{{SWITCH ON TYPE{12395
{{IFF{1,0{6,BEFC7{{NO CONVERSION NEEDED{12413
{{IFF{1,1{6,BEFC2{{STRING{12413
{{IFF{1,2{6,BEFC3{{INTEGER{12413
{{IFF{1,3{6,BEFC4{{REAL{12413
{{IFF{1,4{6,BEFF1{{FILE{12413
{{ESW{{{{END OF SWITCH ON TYPE{12413
*
*      HERE TO CONVERT TO FILE
*
{BEFF1{MOV{7,XT{11,-(XS){{SAVE ENTRY POINTER{12418
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12419
{{MOV{9,(XT){11,-(XS){{STACK ARG POINTER{12420
{{JSR{6,IOFCB{{{CONVERT TO FCB{12421
{{ERR{1,298{26,External function argument is not file{{{12422
{{ERR{1,298{26,External function argument is not file{{{12423
{{ERR{1,298{26,External function argument is not file{{{12424
{{MOV{8,WA{7,XR{{POINT TO FCB{12425
{{MOV{10,(XS)+{7,XT{{RELOAD ENTRY POINTER{12426
{{BRN{6,BEFC5{{{JUMP TO MERGE{12427
*
*      HERE TO CONVERT TO STRING
*
{BEFC2{MOV{9,(XT){11,-(XS){{STACK ARG PTR{12432
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{12433
{{ERR{1,039{26,External function argument is not a string{{{12434
{{BRN{6,BEFC6{{{JUMP TO MERGE{12435
{{EJC{{{{{12436
*
*      EFBLK (CONTINUED)
*
*      HERE TO CONVERT AN INTEGER
*
{BEFC3{MOV{9,(XT){7,XR{{LOAD NEXT ARGUMENT{12442
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12443
{{JSR{6,GTINT{{{CONVERT TO INTEGER{12444
{{ERR{1,040{26,External function argument is not integer{{{12445
{{BRN{6,BEFC5{{{MERGE WITH REAL CASE{12448
*
*      HERE TO CONVERT A REAL
*
{BEFC4{MOV{9,(XT){7,XR{{LOAD NEXT ARGUMENT{12452
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12453
{{JSR{6,GTREA{{{CONVERT TO REAL{12454
{{ERR{1,265{26,External function argument is not real{{{12455
*
*      INTEGER CASE MERGES HERE
*
{BEFC5{MOV{3,BEFOF{8,WC{{RESTORE OFFSET{12460
*
*      STRING MERGES HERE
*
{BEFC6{MOV{7,XR{9,(XT){{STORE CONVERTED RESULT{12464
*
*      NO CONVERSION MERGES HERE
*
{BEFC7{BNZ{8,WC{6,BEFC1{{LOOP BACK IF MORE TO GO{12468
*
*      HERE AFTER CONVERTING ALL THE ARGUMENTS
*
{{MOV{10,(XS)+{7,XL{{RESTORE EFBLK POINTER{12472
{{MOV{13,FARGS(XL){8,WA{{GET NUMBER OF ARGS{12473
{{JSR{6,SYSEX{{{CALL ROUTINE TO CALL EXTERNAL FNC{12474
{{PPM{6,EXFAL{{{FAIL IF FAILURE{12475
{{ERR{1,327{26,Calling external function - not found{{{12476
{{ERR{1,326{26,Calling external function - bad argument type{{{12477
{{WTB{8,WA{{{CONVERT NUMBER OF ARGS TO BYTES{12479
{{ADD{8,WA{7,XS{{REMOVE ARGUMENTS FROM STACK{12480
{{EJC{{{{{12482
*
*      EFBLK (CONTINUED)
*
*      RETURN HERE WITH RESULT IN XR
*
*      FIRST DEFEND AGAINST NON-STANDARD NULL STRING RETURNED
*
{{MOV{13,EFRSL(XL){8,WB{{GET RESULT TYPE ID{12490
{{BNZ{8,WB{6,BEFA8{{BRANCH IF NOT UNCONVERTED{12491
{{BNE{9,(XR){22,=B$SCL{6,BEFC8{JUMP IF NOT A STRING{12492
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{12493
*
*      HERE IF CONVERTED RESULT TO CHECK FOR NULL STRING
*
{BEFA8{BNE{8,WB{18,=NUM01{6,BEFC8{JUMP IF NOT A STRING{12497
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{12498
*
*      RETURN IF RESULT IS IN DYNAMIC STORAGE
*
{BEFC8{BLT{7,XR{3,DNAMB{6,BEFC9{JUMP IF NOT IN DYNAMIC STORAGE{12502
{{BLE{7,XR{3,DNAMP{6,EXIXR{RETURN RESULT IF ALREADY DYNAMIC{12503
*
*      HERE WE COPY A RESULT INTO THE DYNAMIC REGION
*
{BEFC9{MOV{9,(XR){8,WA{{GET POSSIBLE TYPE WORD{12507
{{BZE{8,WB{6,BEF11{{JUMP IF UNCONVERTED RESULT{12508
{{MOV{22,=B$SCL{8,WA{{STRING{12509
{{BEQ{8,WB{18,=NUM01{6,BEF10{YES JUMP{12510
{{MOV{22,=B$ICL{8,WA{{INTEGER{12511
{{BEQ{8,WB{18,=NUM02{6,BEF10{YES JUMP{12512
{{MOV{22,=B$RCL{8,WA{{REAL{12515
*
*      STORE TYPE WORD IN RESULT
*
{BEF10{MOV{8,WA{9,(XR){{STORED BEFORE COPYING TO DYNAMIC{12520
*
*      MERGE FOR UNCONVERTED RESULT
*
{BEF11{BEQ{9,(XR){22,=B$SCL{6,BEF12{BRANCH IF STRING RESULT{12524
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{12525
{{MOV{7,XR{7,XL{{COPY ADDRESS OF OLD BLOCK{12526
{{JSR{6,ALLOC{{{ALLOCATE DYNAMIC BLOCK SAME SIZE{12527
{{MOV{7,XR{11,-(XS){{SET POINTER TO NEW BLOCK AS RESULT{12528
{{MVW{{{{COPY OLD BLOCK TO DYNAMIC BLOCK{12529
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{12530
{{LCW{7,XR{{{GET NEXT CODE WORD{12531
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12532
*
*      HERE TO RETURN A STRING RESULT THAT WAS NOT IN DYNAMIC.
*      CANNOT USE THE SIMPLE WORD COPY ABOVE BECAUSE IT WILL NOT
*      GUARANTEE ZERO PADDING IN THE LAST WORD.
*
{BEF12{MOV{7,XR{7,XL{{SAVE SOURCE STRING POINTER{12538
{{MOV{13,SCLEN(XR){8,WA{{FETCH STRING LENGTH{12539
{{BZE{8,WA{6,EXNUL{{RETURN NULL STRING IF LENGTH ZERO{12540
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{12541
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT POINTER{12542
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{12543
{{PLC{7,XL{{{POINT TO CHARS IN SOURCE STRING{12544
{{MOV{8,WC{8,WA{{NUMBER OF CHARACTERS TO COPY{12545
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{12546
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{12547
{{LCW{7,XR{{{GET NEXT CODE WORD{12548
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12549
{{EJC{{{{{12551
*
*      EVBLK
*
*      THE ROUTINE FOR AN EVBLK IS NEVER EXECUTED
*
{B$EVT{ENT{2,BL$EV{{{ENTRY POINT (EVBLK){12557
{{EJC{{{{{12558
*
*      FFBLK
*
*      THE ROUTINE FOR AN FFBLK IS EXECUTED FROM THE O$FNC ENTRY
*      TO CALL A FIELD FUNCTION AND EXTRACT A FIELD VALUE/NAME.
*
*      (XL)                  POINTER TO FFBLK
*
{B$FFC{ENT{2,BL$FF{{{ENTRY POINT (FFBLK){12567
{{MOV{7,XL{7,XR{{COPY FFBLK POINTER{12568
{{LCW{8,WC{{{LOAD NEXT CODE WORD{12569
{{MOV{9,(XS){7,XL{{LOAD PDBLK POINTER{12570
{{BNE{9,(XL){22,=B$PDT{6,BFFC2{JUMP IF NOT PDBLK AT ALL{12571
{{MOV{13,PDDFP(XL){8,WA{{LOAD DFBLK POINTER FROM PDBLK{12572
*
*      LOOP TO FIND CORRECT FFBLK FOR THIS PDBLK
*
{BFFC1{BEQ{8,WA{13,FFDFP(XR){6,BFFC3{JUMP IF THIS IS THE CORRECT FFBLK{12576
{{MOV{13,FFNXT(XR){7,XR{{ELSE LINK TO NEXT FFBLK ON CHAIN{12577
{{BNZ{7,XR{6,BFFC1{{LOOP BACK IF ANOTHER ENTRY TO CHECK{12578
*
*      HERE FOR BAD ARGUMENT
*
{BFFC2{ERB{1,041{26,FIELD function argument is wrong datatype{{{12582
{{EJC{{{{{12583
*
*      FFBLK (CONTINUED)
*
*      HERE AFTER LOCATING CORRECT FFBLK
*
{BFFC3{MOV{13,FFOFS(XR){8,WA{{LOAD FIELD OFFSET{12589
{{BEQ{8,WC{21,=OFNE${6,BFFC5{JUMP IF CALLED BY NAME{12590
{{ADD{8,WA{7,XL{{ELSE POINT TO VALUE FIELD{12591
{{MOV{9,(XL){7,XR{{LOAD VALUE{12592
{{BNE{9,(XR){22,=B$TRT{6,BFFC4{JUMP IF NOT TRAPPED{12593
{{SUB{8,WA{7,XL{{ELSE RESTORE NAME BASE,OFFSET{12594
{{MOV{8,WC{9,(XS){{SAVE NEXT CODE WORD OVER PDBLK PTR{12595
{{JSR{6,ACESS{{{ACCESS VALUE{12596
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{12597
{{MOV{9,(XS){8,WC{{RESTORE NEXT CODE WORD{12598
*
*      HERE AFTER GETTING VALUE IN (XR), XL IS GARBAGE
*
{BFFC4{MOV{7,XR{9,(XS){{STORE VALUE ON STACK (OVER PDBLK){12602
{{MOV{8,WC{7,XR{{COPY NEXT CODE WORD{12603
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{12604
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{12605
*
*      HERE IF CALLED BY NAME
*
{BFFC5{MOV{8,WA{11,-(XS){{STORE NAME OFFSET (BASE IS SET){12609
{{LCW{7,XR{{{GET NEXT CODE WORD{12610
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12611
{{EJC{{{{{12612
*
*      ICBLK
*
*      THE ROUTINE FOR ICBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD AN INTEGER VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO ICBLK
*
{B$ICL{ENT{2,BL$IC{{{ENTRY POINT (ICBLK){12621
{{MOV{7,XR{11,-(XS){{STACK RESULT{12622
{{LCW{7,XR{{{GET NEXT CODE WORD{12623
{{BRI{9,(XR){{{EXECUTE IT{12624
{{EJC{{{{{12625
*
*      KVBLK
*
*      THE ROUTINE FOR A KVBLK IS NEVER EXECUTED.
*
{B$KVT{ENT{2,BL$KV{{{ENTRY POINT (KVBLK){12631
{{EJC{{{{{12632
*
*      NMBLK
*
*      THE ROUTINE FOR A NMBLK IS EXECUTED FROM THE GENERATED
*      CODE FOR THE CASE OF LOADING A NAME ONTO THE STACK
*      WHERE THE NAME IS THAT OF A NATURAL VARIABLE WHICH CAN
*      BE PREEVALUATED AT COMPILE TIME.
*
*      (XR)                  POINTER TO NMBLK
*
{B$NML{ENT{2,BL$NM{{{ENTRY POINT (NMBLK){12643
{{MOV{7,XR{11,-(XS){{STACK RESULT{12644
{{LCW{7,XR{{{GET NEXT CODE WORD{12645
{{BRI{9,(XR){{{EXECUTE IT{12646
{{EJC{{{{{12647
*
*      PDBLK
*
*      THE ROUTINE FOR A PDBLK IS NEVER EXECUTED
*
{B$PDT{ENT{2,BL$PD{{{ENTRY POINT (PDBLK){12653
{{EJC{{{{{12654
*
*      PFBLK
*
*      THE ROUTINE FOR A PFBLK IS EXECUTED FROM THE ENTRY O$FNC
*      TO CALL A PROGRAM DEFINED FUNCTION.
*
*      (XL)                  POINTER TO PFBLK
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE PROGRAM DEFINED FUNCTION.
*
*                            SAVED VALUE OF FIRST ARGUMENT
*                            .
*                            SAVED VALUE OF LAST ARGUMENT
*                            SAVED VALUE OF FIRST LOCAL
*                            .
*                            SAVED VALUE OF LAST LOCAL
*                            SAVED VALUE OF FUNCTION NAME
*                            SAVED CODE BLOCK PTR (R$COD)
*                            SAVED CODE POINTER (-R$COD)
*                            SAVED VALUE OF FLPRT
*                            SAVED VALUE OF FLPTR
*                            POINTER TO PFBLK
*      FLPTR --------------- ZERO (TO BE OVERWRITTEN WITH OFFS)
*
{B$PFC{ENT{2,BL$PF{{{ENTRY POINT (PFBLK){12680
{{MOV{7,XL{3,BPFPF{{SAVE PFBLK PTR (NEED NOT BE RELOC){12681
{{MOV{7,XL{7,XR{{COPY FOR THE MOMENT{12682
{{MOV{13,PFVBL(XR){7,XL{{POINT TO VRBLK FOR FUNCTION{12683
*
*      LOOP TO FIND OLD VALUE OF FUNCTION
*
{BPF01{MOV{7,XL{8,WB{{SAVE POINTER{12687
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{12688
{{BEQ{9,(XL){22,=B$TRT{6,BPF01{LOOP IF TRBLK{12689
*
*      SET VALUE TO NULL AND SAVE OLD FUNCTION VALUE
*
{{MOV{7,XL{3,BPFSV{{SAVE OLD VALUE{12693
{{MOV{8,WB{7,XL{{POINT BACK TO BLOCK WITH VALUE{12694
{{MOV{21,=NULLS{13,VRVAL(XL){{SET VALUE TO NULL{12695
{{MOV{13,FARGS(XR){8,WA{{LOAD NUMBER OF ARGUMENTS{12696
{{ADD{19,*PFARG{7,XR{{POINT TO PFARG ENTRIES{12697
{{BZE{8,WA{6,BPF04{{JUMP IF NO ARGUMENTS{12698
{{MOV{7,XS{7,XT{{PTR TO LAST ARG{12699
{{WTB{8,WA{{{CONVERT NO. OF ARGS TO BYTES OFFSET{12700
{{ADD{8,WA{7,XT{{POINT BEFORE FIRST ARG{12701
{{MOV{7,XT{3,BPFXT{{REMEMBER ARG POINTER{12702
{{EJC{{{{{12703
*
*      PFBLK (CONTINUED)
*
*      LOOP TO SAVE OLD ARGUMENT VALUES AND SET NEW ONES
*
{BPF02{MOV{10,(XR)+{7,XL{{LOAD VRBLK PTR FOR NEXT ARGUMENT{12709
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF03{MOV{7,XL{8,WC{{SAVE POINTER{12713
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE{12714
{{BEQ{9,(XL){22,=B$TRT{6,BPF03{LOOP BACK IF TRBLK{12715
*
*      SAVE OLD VALUE AND GET NEW VALUE
*
{{MOV{7,XL{8,WA{{KEEP OLD VALUE{12719
{{MOV{3,BPFXT{7,XT{{POINT BEFORE NEXT STACKED ARG{12720
{{MOV{11,-(XT){8,WB{{LOAD ARGUMENT (NEW VALUE){12721
{{MOV{8,WA{9,(XT){{SAVE OLD VALUE{12722
{{MOV{7,XT{3,BPFXT{{KEEP ARG PTR FOR NEXT TIME{12723
{{MOV{8,WC{7,XL{{POINT BACK TO BLOCK WITH VALUE{12724
{{MOV{8,WB{13,VRVAL(XL){{SET NEW VALUE{12725
{{BNE{7,XS{3,BPFXT{6,BPF02{LOOP IF NOT ALL DONE{12726
*
*      NOW PROCESS LOCALS
*
{BPF04{MOV{3,BPFPF{7,XL{{RESTORE PFBLK POINTER{12730
{{MOV{13,PFNLO(XL){8,WA{{LOAD NUMBER OF LOCALS{12731
{{BZE{8,WA{6,BPF07{{JUMP IF NO LOCALS{12732
{{MOV{21,=NULLS{8,WB{{GET NULL CONSTANT{12733
{{LCT{8,WA{8,WA{{SET LOCAL COUNTER{12734
*
*      LOOP TO PROCESS LOCALS
*
{BPF05{MOV{10,(XR)+{7,XL{{LOAD VRBLK PTR FOR NEXT LOCAL{12738
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF06{MOV{7,XL{8,WC{{SAVE POINTER{12742
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE{12743
{{BEQ{9,(XL){22,=B$TRT{6,BPF06{LOOP BACK IF TRBLK{12744
*
*      SAVE OLD VALUE AND SET NULL AS NEW VALUE
*
{{MOV{7,XL{11,-(XS){{STACK OLD VALUE{12748
{{MOV{8,WC{7,XL{{POINT BACK TO BLOCK WITH VALUE{12749
{{MOV{8,WB{13,VRVAL(XL){{SET NULL AS NEW VALUE{12750
{{BCT{8,WA{6,BPF05{{LOOP TILL ALL LOCALS PROCESSED{12751
{{EJC{{{{{12752
*
*      PFBLK (CONTINUED)
*
*      HERE AFTER PROCESSING ARGUMENTS AND LOCALS
*
{BPF07{ZER{7,XR{{{ZERO REG XR IN CASE{12761
{{BZE{3,KVPFL{6,BPF7C{{SKIP IF PROFILING IS OFF{12762
{{BEQ{3,KVPFL{18,=NUM02{6,BPF7A{BRANCH ON TYPE OF PROFILE{12763
*
*      HERE IF &PROFILE = 1
*
{{JSR{6,SYSTM{{{GET CURRENT TIME{12767
{{STI{3,PFETM{{{SAVE FOR A SEC{12768
{{SBI{3,PFSTM{{{FIND TIME USED BY CALLER{12769
{{JSR{6,ICBLD{{{BUILD INTO AN ICBLK{12770
{{LDI{3,PFETM{{{RELOAD CURRENT TIME{12771
{{BRN{6,BPF7B{{{MERGE{12772
*
*       HERE IF &PROFILE = 2
*
{BPF7A{LDI{3,PFSTM{{{GET START TIME OF CALLING STMT{12776
{{JSR{6,ICBLD{{{ASSEMBLE AN ICBLK ROUND IT{12777
{{JSR{6,SYSTM{{{GET NOW TIME{12778
*
*      BOTH TYPES OF PROFILE MERGE HERE
*
{BPF7B{STI{3,PFSTM{{{SET START TIME OF 1ST FUNC STMT{12782
{{MNZ{3,PFFNC{{{FLAG FUNCTION ENTRY{12783
*
*      NO PROFILING MERGES HERE
*
{BPF7C{MOV{7,XR{11,-(XS){{STACK ICBLK PTR (OR ZERO){12787
{{MOV{3,R$COD{8,WA{{LOAD OLD CODE BLOCK POINTER{12788
{{SCP{8,WB{{{GET CODE POINTER{12790
{{SUB{8,WA{8,WB{{MAKE CODE POINTER INTO OFFSET{12791
{{MOV{3,BPFPF{7,XL{{RECALL PFBLK POINTER{12792
{{MOV{3,BPFSV{11,-(XS){{STACK OLD VALUE OF FUNCTION NAME{12793
{{MOV{8,WA{11,-(XS){{STACK CODE BLOCK POINTER{12794
{{MOV{8,WB{11,-(XS){{STACK CODE OFFSET{12795
{{MOV{3,FLPRT{11,-(XS){{STACK OLD FLPRT{12796
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{12797
{{MOV{7,XL{11,-(XS){{STACK POINTER TO PFBLK{12798
{{ZER{11,-(XS){{{DUMMY ZERO ENTRY FOR FAIL RETURN{12799
{{CHK{{{{CHECK FOR STACK OVERFLOW{12800
{{MOV{7,XS{3,FLPTR{{SET NEW FAIL RETURN VALUE{12801
{{MOV{7,XS{3,FLPRT{{SET NEW FLPRT{12802
{{MOV{3,KVTRA{8,WA{{LOAD TRACE VALUE{12803
{{ADD{3,KVFTR{8,WA{{ADD FTRACE VALUE{12804
{{BNZ{8,WA{6,BPF09{{JUMP IF TRACING POSSIBLE{12805
{{ICV{3,KVFNC{{{ELSE BUMP FNCLEVEL{12806
*
*      HERE TO ACTUALLY JUMP TO FUNCTION
*
{BPF08{MOV{13,PFCOD(XL){7,XR{{POINT TO VRBLK OF ENTRY LABEL{12810
{{MOV{13,VRLBL(XR){7,XR{{POINT TO TARGET CODE{12811
{{BEQ{7,XR{21,=STNDL{6,BPF17{TEST FOR UNDEFINED LABEL{12812
{{BNE{9,(XR){22,=B$TRT{6,BPF8A{JUMP IF NOT TRAPPED{12813
{{MOV{13,TRLBL(XR){7,XR{{ELSE LOAD PTR TO REAL LABEL CODE{12814
{BPF8A{BRI{9,(XR){{{OFF TO EXECUTE FUNCTION{12815
*
*      HERE IF TRACING IS POSSIBLE
*
{BPF09{MOV{13,PFCTR(XL){7,XR{{LOAD POSSIBLE CALL TRACE TRBLK{12819
{{MOV{13,PFVBL(XL){7,XL{{LOAD VRBLK POINTER FOR FUNCTION{12820
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET FOR VARIABLE{12821
{{BZE{3,KVTRA{6,BPF10{{JUMP IF TRACE MODE IS OFF{12822
{{BZE{7,XR{6,BPF10{{OR IF THERE IS NO CALL TRACE{12823
*
*      HERE IF CALL TRACED
*
{{DCV{3,KVTRA{{{DECREMENT TRACE COUNT{12827
{{BZE{13,TRFNC(XR){6,BPF11{{JUMP IF PRINT TRACE{12828
{{JSR{6,TRXEQ{{{EXECUTE FUNCTION TYPE TRACE{12829
{{EJC{{{{{12830
*
*      PFBLK (CONTINUED)
*
*      HERE TO TEST FOR FTRACE TRACE
*
{BPF10{BZE{3,KVFTR{6,BPF16{{JUMP IF FTRACE IS OFF{12836
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{12837
*
*      HERE FOR PRINT TRACE
*
{BPF11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{12841
{{JSR{6,PRTNM{{{PRINT FUNCTION NAME{12842
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{12843
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{12844
{{MOV{13,NUM01(XS){7,XL{{RECOVER PFBLK POINTER{12845
{{BZE{13,FARGS(XL){6,BPF15{{SKIP IF NO ARGUMENTS{12846
{{ZER{8,WB{{{ELSE SET ARGUMENT COUNTER{12847
{{BRN{6,BPF13{{{JUMP INTO LOOP{12848
*
*      LOOP TO PRINT ARGUMENT VALUES
*
{BPF12{MOV{18,=CH$CM{8,WA{{LOAD COMMA{12852
{{JSR{6,PRTCH{{{PRINT TO SEPARATE FROM LAST ARG{12853
*
*      MERGE HERE FIRST TIME (NO COMMA REQUIRED)
*
{BPF13{MOV{8,WB{9,(XS){{SAVE ARG CTR (OVER FAILOFFS IS OK){12857
{{WTB{8,WB{{{CONVERT TO BYTE OFFSET{12858
{{ADD{8,WB{7,XL{{POINT TO NEXT ARGUMENT POINTER{12859
{{MOV{13,PFARG(XL){7,XR{{LOAD NEXT ARGUMENT VRBLK PTR{12860
{{SUB{8,WB{7,XL{{RESTORE PFBLK POINTER{12861
{{MOV{13,VRVAL(XR){7,XR{{LOAD NEXT VALUE{12862
{{JSR{6,PRTVL{{{PRINT ARGUMENT VALUE{12863
{{EJC{{{{{12864
*
*      HERE AFTER DEALING WITH ONE ARGUMENT
*
{{MOV{9,(XS){8,WB{{RESTORE ARGUMENT COUNTER{12868
{{ICV{8,WB{{{INCREMENT ARGUMENT COUNTER{12869
{{BLT{8,WB{13,FARGS(XL){6,BPF12{LOOP IF MORE TO PRINT{12870
*
*      MERGE HERE IN NO ARGS CASE TO PRINT PAREN
*
{BPF15{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN{12874
{{JSR{6,PRTCH{{{PRINT TO TERMINATE OUTPUT{12875
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{12876
*
*      MERGE HERE TO EXIT WITH TEST FOR FNCLEVEL TRACE
*
{BPF16{ICV{3,KVFNC{{{INCREMENT FNCLEVEL{12880
{{MOV{3,R$FNC{7,XL{{LOAD PTR TO POSSIBLE TRBLK{12881
{{JSR{6,KTREX{{{CALL KEYWORD TRACE ROUTINE{12882
*
*      CALL FUNCTION AFTER TRACE TESTS COMPLETE
*
{{MOV{13,NUM01(XS){7,XL{{RESTORE PFBLK POINTER{12886
{{BRN{6,BPF08{{{JUMP BACK TO EXECUTE FUNCTION{12887
*
*      HERE IF CALLING A FUNCTION WHOSE ENTRY LABEL IS UNDEFINED
*
{BPF17{MOV{13,NUM02(XS){3,FLPTR{{RESET SO EXFAL CAN RETURN TO EVALX{12891
{{ERB{1,286{26,Function call to undefined entry label{{{12892
{{EJC{{{{{12895
*
*      RCBLK
*
*      THE ROUTINE FOR AN RCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A REAL VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO RCBLK
*
{B$RCL{ENT{2,BL$RC{{{ENTRY POINT (RCBLK){12904
{{MOV{7,XR{11,-(XS){{STACK RESULT{12905
{{LCW{7,XR{{{GET NEXT CODE WORD{12906
{{BRI{9,(XR){{{EXECUTE IT{12907
{{EJC{{{{{12909
*
*      SCBLK
*
*      THE ROUTINE FOR AN SCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A STRING VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO SCBLK
*
{B$SCL{ENT{2,BL$SC{{{ENTRY POINT (SCBLK){12918
{{MOV{7,XR{11,-(XS){{STACK RESULT{12919
{{LCW{7,XR{{{GET NEXT CODE WORD{12920
{{BRI{9,(XR){{{EXECUTE IT{12921
{{EJC{{{{{12922
*
*      TBBLK
*
*      THE ROUTINE FOR A TBBLK IS NEVER EXECUTED
*
{B$TBT{ENT{2,BL$TB{{{ENTRY POINT (TBBLK){12928
{{EJC{{{{{12929
*
*      TEBLK
*
*      THE ROUTINE FOR A TEBLK IS NEVER EXECUTED
*
{B$TET{ENT{2,BL$TE{{{ENTRY POINT (TEBLK){12935
{{EJC{{{{{12936
*
*      VCBLK
*
*      THE ROUTINE FOR A VCBLK IS NEVER EXECUTED
*
{B$VCT{ENT{2,BL$VC{{{ENTRY POINT (VCBLK){12942
{{EJC{{{{{12943
*
*      VRBLK
*
*      THE VRBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE SIX ENTRIES FOR VRBLK COVERING VARIOUS CASES
*
{B$VR${ENT{2,BL$$I{{{MARK START OF VRBLK ENTRY POINTS{12950
*
*      ENTRY FOR VRGET (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*      THIS ENTRY POINT IS USED IF AN ACCESS TRACE OR INPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRGET FIELD OF VRBLK
*
{B$VRA{ENT{2,BL$$I{{{ENTRY POINT{12959
{{MOV{7,XR{7,XL{{COPY NAME BASE (VRGET = 0){12960
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{12961
{{JSR{6,ACESS{{{ACCESS VALUE{12962
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{12963
{{MOV{7,XR{11,-(XS){{STACK RESULT{12964
{{LCW{7,XR{{{GET NEXT CODE WORD{12965
{{BRI{9,(XR){{{EXECUTE IT{12966
{{EJC{{{{{12967
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (ERROR CASE. THIS ROUTINE IS CALLED FROM
*      THE EXECUTED CODE FOR AN ATTEMPT TO MODIFY THE VALUE
*      OF A PROTECTED (PATTERN VALUED) NATURAL VARIABLE.
*
{B$VRE{ENT{{{{ENTRY POINT{12975
{{ERB{1,042{26,Attempt to change value of protected variable{{{12976
{{EJC{{{{{12977
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRTRA (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE EXECUTED CODE TO TRANSFER TO A LABEL.
*
*      (XR)                  POINTER TO VRTRA FIELD OF VRBLK
*
{B$VRG{ENT{{{{ENTRY POINT{12986
{{MOV{13,VRLBO(XR){7,XR{{LOAD CODE POINTER{12987
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{12988
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{12989
{{EJC{{{{{12990
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRGET (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTS TO VRGET FIELD OF VRBLK
*
{B$VRL{ENT{{{{ENTRY POINT{12999
{{MOV{13,VRVAL(XR){11,-(XS){{LOAD VALUE ONTO STACK (VRGET = 0){13000
{{LCW{7,XR{{{GET NEXT CODE WORD{13001
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13002
{{EJC{{{{{13003
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B$VRS{ENT{{{{ENTRY POINT{13012
{{MOV{9,(XS){13,VRVLO(XR){{STORE VALUE, LEAVE ON STACK{13013
{{LCW{7,XR{{{GET NEXT CODE WORD{13014
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13015
{{EJC{{{{{13016
*
*      VRBLK (CONTINUED)
*
*      VRTRA (TRAPPED CASE). THIS ROUTINE IS CALLED FROM THE
*      GENERATED CODE TO TRANSFER TO A LABEL WHEN A LABEL
*      TRACE IS CURRENTLY ACTIVE.
*
{B$VRT{ENT{{{{ENTRY POINT{13024
{{SUB{19,*VRTRA{7,XR{{POINT BACK TO START OF VRBLK{13025
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{13026
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{13027
{{MOV{13,VRLBL(XL){7,XR{{LOAD POINTER TO TRBLK{13028
{{BZE{3,KVTRA{6,BVRT2{{JUMP IF TRACE IS OFF{13029
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{13030
{{BZE{13,TRFNC(XR){6,BVRT1{{JUMP IF PRINT TRACE CASE{13031
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{13032
{{BRN{6,BVRT2{{{MERGE TO JUMP TO LABEL{13033
*
*      HERE FOR PRINT TRACE -- PRINT COLON ( LABEL NAME )
*
{BVRT1{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{13037
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER{13038
{{MOV{18,=CH$CL{8,WA{{COLON{13039
{{JSR{6,PRTCH{{{PRINT IT{13040
{{MOV{18,=CH$PP{8,WA{{LEFT PAREN{13041
{{JSR{6,PRTCH{{{PRINT IT{13042
{{JSR{6,PRTVN{{{PRINT LABEL NAME{13043
{{MOV{18,=CH$RP{8,WA{{RIGHT PAREN{13044
{{JSR{6,PRTCH{{{PRINT IT{13045
{{JSR{6,PRTNL{{{TERMINATE LINE{13046
{{MOV{13,VRLBL(XL){7,XR{{POINT BACK TO TRBLK{13047
*
*      MERGE HERE TO JUMP TO LABEL
*
{BVRT2{MOV{13,TRLBL(XR){7,XR{{LOAD POINTER TO ACTUAL CODE{13051
{{BRI{9,(XR){{{EXECUTE STATEMENT AT LABEL{13052
{{EJC{{{{{13053
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*      THIS ENTRY IS USED WHEN A VALUE TRACE OR OUTPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B$VRV{ENT{{{{ENTRY POINT{13064
{{MOV{9,(XS){8,WB{{LOAD VALUE (LEAVE COPY ON STACK){13065
{{SUB{19,*VRSTO{7,XR{{POINT TO VRBLK{13066
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{13067
{{MOV{19,*VRVAL{8,WA{{SET OFFSET{13068
{{JSR{6,ASIGN{{{CALL ASSIGNMENT ROUTINE{13069
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{13070
{{LCW{7,XR{{{ELSE GET NEXT CODE WORD{13071
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13072
{{EJC{{{{{13073
*
*      XNBLK
*
*      THE ROUTINE FOR AN XNBLK IS NEVER EXECUTED
*
{B$XNT{ENT{2,BL$XN{{{ENTRY POINT (XNBLK){13079
{{EJC{{{{{13080
*
*      XRBLK
*
*      THE ROUTINE FOR AN XRBLK IS NEVER EXECUTED
*
{B$XRT{ENT{2,BL$XR{{{ENTRY POINT (XRBLK){13086
*
*      MARK ENTRY ADDRESS PAST LAST BLOCK ACTION ROUTINE
*
{B$YYY{ENT{2,BL$$I{{{LAST BLOCK ROUTINE ENTRY POINT{13090
{{TTL{27,S P I T B O L -- PATTERN MATCHING ROUTINES{{{{13091
*
*      THE FOLLOWING SECTION CONSISTS OF THE PATTERN MATCHING
*      ROUTINES. ALL PATTERN NODES CONTAIN A POINTER (PCODE)
*      TO ONE OF THE ROUTINES IN THIS SECTION (P$XXX).
*
*      NOTE THAT THIS SECTION FOLLOWS THE B$XXX ROUTINES TO
*      ENABLE A FAST TEST FOR THE PATTERN DATATYPE.
*
{P$AAA{ENT{2,BL$$I{{{ENTRY TO MARK FIRST PATTERN{13100
*
*
*      THE ENTRY CONDITIONS TO THE MATCH ROUTINE ARE AS FOLLOWS
*      (SEE O$PMN, O$PMV, O$PMS AND PROCEDURE MATCH).
*
*      STACK CONTENTS.
*
*                            NAME BASE (O$PMN ONLY)
*                            NAME OFFSET (O$PMN ONLY)
*                            TYPE (0-O$PMN, 1-O$PMV, 2-O$PMS)
*      PMHBS --------------- INITIAL CURSOR (ZERO)
*                            INITIAL NODE POINTER
*      XS ------------------ =NDABO (ANCHORED), =NDUNA (UNANCH)
*
*      REGISTER VALUES.
*
*           (XS)             SET AS SHOWN IN STACK DIAGRAM
*           (XR)             POINTER TO INITIAL PATTERN NODE
*           (WB)             INITIAL CURSOR (ZERO)
*
*      GLOBAL PATTERN VALUES
*
*           R$PMS            POINTER TO SUBJECT STRING SCBLK
*           PMSSL            LENGTH OF SUBJECT STRING IN CHARS
*           PMDFL            DOT FLAG, INITIALLY ZERO
*           PMHBS            SET AS SHOWN IN STACK DIAGRAM
*
*      CONTROL IS PASSED BY BRANCHING THROUGH THE PCODE
*      FIELD OF THE INITIAL PATTERN NODE (BRI (XR)).
{{EJC{{{{{13130
*
*      DESCRIPTION OF ALGORITHM
*
*      A PATTERN STRUCTURE IS REPRESENTED AS A LINKED GRAPH
*      OF NODES WITH THE FOLLOWING STRUCTURE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
*      PCODE IS A POINTER TO THE ROUTINE WHICH WILL PERFORM
*      THE MATCH OF THIS PARTICULAR NODE TYPE.
*
*      PTHEN IS A POINTER TO THE SUCCESSOR NODE. I.E. THE NODE
*      TO BE MATCHED IF THE ATTEMPT TO MATCH THIS NODE SUCCEEDS.
*      IF THIS IS THE LAST NODE OF THE PATTERN PTHEN POINTS
*      TO THE DUMMY NODE NDNTH WHICH INITIATES PATTERN EXIT.
*
*      PARM1, PARM2 ARE PARAMETERS WHOSE USE VARIES WITH THE
*      PARTICULAR NODE. THEY ARE ONLY PRESENT IF REQUIRED.
*
*      ALTERNATIVES ARE HANDLED WITH THE SPECIAL ALTERNATIVE
*      NODE WHOSE PARAMETER POINTS TO THE NODE TO BE MATCHED
*      IF THERE IS A FAILURE ON THE SUCCESSOR PATH.
*
*      THE FOLLOWING EXAMPLE ILLUSTRATES THE MANNER IN WHICH
*      THE STRUCTURE IS BUILT UP. THE PATTERN IS
*
*      (A / B / C) (D / E)   WHERE / IS ALTERNATION
*
*      IN THE DIAGRAM, THE NODE MARKED + REPRESENTS AN
*      ALTERNATIVE NODE AND THE DOTTED LINE FROM A + NODE
*      REPRESENTS THE PARAMETER POINTER TO THE ALTERNATIVE.
*
*      +---+     +---+     +---+     +---+
*      I + I-----I A I-----I + I-----I D I-----
*      +---+     +---+  I  +---+     +---+
*        .              I    .
*        .              I    .
*      +---+     +---+  I  +---+
*      I + I-----I B I--I  I E I-----
*      +---+     +---+  I  +---+
*        .              I
*        .              I
*      +---+            I
*      I C I------------I
*      +---+
{{EJC{{{{{13184
*
*      DURING THE MATCH, THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  POINTS TO THE CURRENT NODE
*      (XL)                  SCRATCH
*      (XS)                  MAIN STACK POINTER
*      (WB)                  CURSOR (NUMBER OF CHARS MATCHED)
*      (WA,WC)               SCRATCH
*
*      TO KEEP TRACK OF ALTERNATIVES, THE MAIN STACK IS USED AS
*      A HISTORY STACK AND CONTAINS TWO WORD ENTRIES.
*
*      WORD 1                SAVED CURSOR VALUE
*      WORD 2                NODE TO MATCH ON FAILURE
*
*      WHEN A FAILURE OCCURS, THE MOST RECENT ENTRY ON THIS
*      STACK IS POPPED OFF TO RESTORE THE CURSOR AND POINT
*      TO THE NODE TO BE MATCHED AS AN ALTERNATIVE. THE ENTRY
*      AT THE BOTTOM OF THE STACK POINTS TO THE FOLLOWING
*      SPECIAL NODES DEPENDING ON THE SCAN MODE.
*
*      ANCHORED MODE         THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDABO WHICH CAUSES AN
*                            ABORT. THE CURSOR VALUE STORED
*                            WITH THIS ENTRY IS ALWAYS ZERO.
*
*      UNANCHORED MODE       THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDUNA WHICH MOVES THE
*                            ANCHOR POINT AND RESTARTS THE MATCH
*                            THE CURSOR SAVED WITH THIS ENTRY
*                            IS THE NUMBER OF CHARACTERS WHICH
*                            LIE BEFORE THE INITIAL ANCHOR POINT
*                            (I.E. THE NUMBER OF ANCHOR MOVES).
*                            THIS ENTRY IS THREE WORDS LONG AND
*                            ALSO CONTAINS THE INITIAL PATTERN.
*
*      ENTRIES ARE MADE ON THIS HISTORY STACK BY ALTERNATIVE
*      NODES AND BY SOME SPECIAL COMPOUND PATTERNS AS DESCRIBED
*      LATER ON. THE FOLLOWING GLOBAL LOCATIONS ARE USED DURING
*      PATTERN MATCHING.
*
*      R$PMS                 POINTER TO SUBJECT STRING
*      PMSSL                 LENGTH OF SUBJECT STRING
*      PMDFL                 FLAG SET NON-ZERO FOR DOT PATTERNS
*      PMHBS                 BASE PTR FOR CURRENT HISTORY STACK
*
*      THE FOLLOWING EXIT POINTS ARE AVAILABLE TO MATCH ROUTINES
*
*      SUCCP                 SUCCESS IN MATCHING CURRENT NODE
*      FAILP                 FAILURE IN MATCHING CURRENT NODE
{{EJC{{{{{13235
*
*      COMPOUND PATTERNS
*
*      SOME PATTERNS HAVE IMPLICIT ALTERNATIVES AND THEIR
*      REPRESENTATION IN THE PATTERN STRUCTURE CONSISTS OF A
*      LINKED SET OF NODES AS INDICATED BY THESE DIAGRAMS.
*
*      AS BEFORE, THE + REPRESENTS AN ALTERNATIVE NODE AND
*      THE DOTTED LINE FROM A + NODE IS THE PARAMETER POINTER
*      TO THE ALTERNATIVE PATTERN.
*
*      ARB
*      ---
*
*           +---+            THIS NODE (P$ARB) MATCHES NULL
*           I B I-----       AND STACKS CURSOR, SUCCESSOR PTR,
*           +---+            CURSOR (COPY) AND A PTR TO NDARC.
*
*
*
*
*      BAL
*      ---
*
*           +---+            THE P$BAL NODE SCANS A BALANCED
*           I B I-----       STRING AND THEN STACKS A POINTER
*           +---+            TO ITSELF ON THE HISTORY STACK.
{{EJC{{{{{13263
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*
*      ARBNO
*      -----
*
*           +---+            THIS ALTERNATIVE NODE MATCHES NULL
*      +----I + I-----       THE FIRST TIME AND STACKS A POINTER
*      I    +---+            TO THE ARGUMENT PATTERN X.
*      I      .
*      I      .
*      I    +---+            NODE (P$ABA) TO STACK CURSOR
*      I    I A I            AND HISTORY STACK BASE PTR.
*      I    +---+
*      I      I
*      I      I
*      I    +---+            THIS IS THE ARGUMENT PATTERN. AS
*      I    I X I            INDICATED, THE SUCCESSOR OF THE
*      I    +---+            PATTERN IS THE P$ABC NODE
*      I      I
*      I      I
*      I    +---+            THIS NODE (P$ABC) POPS PMHBS,
*      +----I C I            STACKS OLD PMHBS AND PTR TO NDABD
*           +---+            (UNLESS OPTIMIZATION HAS OCCURRED)
*
*      STRUCTURE AND EXECUTION OF THIS PATTERN RESEMBLE THOSE OF
*      RECURSIVE PATTERN MATCHING AND IMMEDIATE ASSIGNMENT.
*      THE ALTERNATIVE NODE AT THE HEAD OF THE STRUCTURE MATCHES
*      NULL INITIALLY BUT ON SUBSEQUENT FAILURE ENSURES ATTEMPT
*      TO MATCH THE ARGUMENT.  BEFORE THE ARGUMENT IS MATCHED
*      P$ABA STACKS THE CURSOR, PMHBS AND A PTR TO P$ABB.  IF
*      THE ARGUMENT CANT BE MATCHED , P$ABB REMOVES THIS SPECIAL
*      STACK ENTRY AND FAILS.
*      IF ARGUMENT IS MATCHED , P$ABC RESTORES THE OUTER PMHBS
*      VALUE (SAVED BY P$ABA) .  THEN IF THE ARGUMENT HAS LEFT
*      ALTERNATIVES ON STACK IT STACKS THE INNER VALUE OF PMHBS
*      AND A PTR TO NDABD. IF ARGUMENT LEFT NOTHING ON THE STACK
*      IT OPTIMISES BY REMOVING ITEMS STACKED BY P$ABA.  FINALLY
*      A CHECK IS MADE THAT ARGUMENT MATCHED MORE THAN THE NULL
*      STRING (CHECK IS INTENDED TO PREVENT USELESS LOOPING).
*      IF SO THE SUCCESSOR IS AGAIN THE ALTERNATIVE NODE AT THE
*      HEAD OF THE STRUCTURE , ENSURING A POSSIBLE EXTRA ATTEMPT
*      TO MATCH THE ARG IF NECESSARY.  IF NOT , THE SUCCESSOR TO
*      ALTERNATIVE IS TAKEN SO AS TO TERMINATE THE LOOP.  P$ABD
*      RESTORES INNER PMHBS PTR AND FAILS , THUS TRYING TO MATCH
*      ALTERNATIVES LEFT BY THE ARBNO ARGUMENT.
{{EJC{{{{{13311
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*      BREAKX
*      ------
*
*           +---+            THIS NODE IS A BREAK NODE FOR
*      +----I B I            THE ARGUMENT TO BREAKX, IDENTICAL
*      I    +---+            TO AN ORDINARY BREAK NODE.
*      I      I
*      I      I
*      I    +---+            THIS ALTERNATIVE NODE STACKS A
*      I    I + I-----       POINTER TO THE BREAKX NODE TO
*      I    +---+            ALLOW FOR SUBSEQUENT FAILURE
*      I      .
*      I      .
*      I    +---+            THIS IS THE BREAKX NODE ITSELF. IT
*      +----I X I            MATCHES ONE CHARACTER AND THEN
*           +---+            PROCEEDS BACK TO THE BREAK NODE.
*
*
*
*
*      FENCE
*      -----
*
*           +---+            THE FENCE NODE MATCHES NULL AND
*           I F I-----       STACKS A POINTER TO NODE NDABO TO
*           +---+            ABORT ON A SUBSEQUENT REMATCH
*
*
*
*
*      SUCCEED
*      -------
*
*           +---+            THE NODE FOR SUCCEED MATCHES NULL
*           I S I-----       AND STACKS A POINTER TO ITSELF
*           +---+            TO REPEAT THE MATCH ON A FAILURE.
{{EJC{{{{{13351
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*      -------------------------------
*
*           +---+            THIS NODE (P$PAA) SAVES THE CURRENT
*           I A I            CURSOR AND A POINTER TO THE
*           +---+            SPECIAL NODE NDPAB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            PATTERN ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P$PAC) SAVES THE CURSOR,
*           I C I-----       A PTR TO ITSELF, THE CURSOR (COPY)
*           +---+            AND A PTR TO NDPAD ON THE STACK.
*
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAB (P$PAB)
*      IS SIMPLY TO UNSTACK ITSELF AND FAIL BACK ONTO THE STACK.
*
*      THE MATCH ROUTINE FOR P$PAC ALSO SETS THE GLOBAL PATTERN
*      FLAG PMDFL NON-ZERO TO INDICATE THAT PATTERN ASSIGNMENTS
*      MAY HAVE OCCURED IN THE PATTERN MATCH
*
*      IF PMDFL IS SET AT THE END OF THE MATCH (SEE P$NTH), THE
*      HISTORY STACK IS SCANNED FOR MATCHING NDPAB-NDPAD PAIRS
*      AND THE CORRESPONDING PATTERN ASSIGNMENTS ARE EXECUTED.
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAD (P$PAD)
*      IS SIMPLY TO REMOVE ITS ENTRY FROM THE STACK AND FAIL.
*      THIS INCLUDES REMOVING THE SPECIAL NODE POINTER STORED
*      IN ADDITION TO THE STANDARD TWO ENTRIES ON THE STACK.
{{EJC{{{{{13388
*
*      COMPOUNT PATTERN STRUCTURES (CONTINUED)
*
*      FENCE (FUNCTION)
*      ----------------
*
*           +---+            THIS NODE (P$FNA) SAVES THE
*           I A I            CURRENT HISTORY STACK AND A
*           +---+            POINTER TO NDFNB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE PATTERN STRUCTURE
*           I X I            GIVEN AS THE ARGUMENT TO THE
*           +---+            FENCE FUNCTION.
*             I
*             I
*           +---+            THIS NODE P$FNC RESTORES THE OUTER
*           I C I            HISTORY STACK PTR SAVED IN P$FNA,
*           +---+            AND STACKS THE INNER STACK BASE
*                            PTR AND A POINTER TO NDFND ON THE
*                            STACK.
*
*      NDFNB (F$FNB) SIMPLY IS THE FAILURE EXIT FOR PATTERN
*      ARGUMENT FAILURE, AND IT POPS ITSELF AND FAILS ONTO THE
*      STACK.
*
*      THE MATCH ROUTINE P$FNC ALLOWS FOR AN OPTIMIZATION WHEN
*      THE FENCE PATTERN LEAVES NO ALTERNATIVES.  IN THIS CASE,
*      THE NDFNB ENTRY IS POPPED, AND THE MATCH CONTINUES.
*
*      NDFND (P$FND) IS ENTERED WHEN THE PATTERN FAILS AFTER
*      GOING THROUGH A NON-OPTIMIZED P$FNC, AND IT POPS THE
*      STACK BACK PAST THE INNTER STACK BASE CREATED BY P$FNA
{{EJC{{{{{13422
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      EXPRESSION PATTERNS (RECURSIVE PATTERN MATCHES)
*      -----------------------------------------------
*
*      INITIAL ENTRY FOR A PATTERN NODE IS TO THE ROUTINE P$EXA.
*      IF THE EVALUATED RESULT OF THE EXPRESSION IS ITSELF A
*      PATTERN, THEN THE FOLLOWING STEPS ARE TAKEN TO ARRANGE
*      FOR PROPER RECURSIVE PROCESSING.
*
*      1)   A POINTER TO THE CURRENT NODE (THE P$EXA NODE) IS
*           STORED ON THE HISTORY STACK WITH A DUMMY CURSOR.
*
*      2)   A SPECIAL HISTORY STACK ENTRY IS MADE IN WHICH THE
*           NODE POINTER POINTS TO NDEXB, AND THE CURSOR VALUE
*           IS THE SAVED VALUE OF PMHBS ON ENTRY TO THIS NODE.
*           THE MATCH ROUTINE FOR NDEXB (P$EXB) RESTORES PMHBS
*           FROM THIS CURSOR ENTRY, POPS OFF THE P$EXA NODE
*           POINTER AND FAILS.
*
*      3)   THE RESULTING HISTORY STACK POINTER IS SAVED IN
*           PMHBS TO ESTABLISH A NEW LEVEL OF HISTORY STACK.
*
*      AFTER MATCHING A PATTERN, THE END OF MATCH ROUTINE GETS
*      CONTROL (P$NTH). THIS ROUTINE PROCEEDS AS FOLLOWS.
*
*      1)   LOAD THE CURRENT VALUE OF PMHBS AND RECOGNIZE THE
*           OUTER LEVEL CASE BY THE FACT THAT THE ASSOCIATED
*           CURSOR IN THIS CASE IS THE PATTERN MATCH TYPE CODE
*           WHICH IS LESS THAN 3. TERMINATE THE MATCH IN THIS
*           CASE AND CONTINUE EXECUTION OF THE PROGRAM.
*
*      2)   OTHERWISE MAKE A SPECIAL HISTORY STACK ENTRY IN
*           WHICH THE NODE POINTER POINTS TO THE SPECIAL NODE
*           NDEXC AND THE CURSOR IS THE CURRENT VALUE OF PMHBS.
*           THE MATCH ROUTINE FOR NDEXC (P$EXC) RESETS PMHBS TO
*           THIS (INNER) VALUE AND AND THEN FAILS.
*
*      3)   USING THE HISTORY STACK ENTRY MADE ON STARTING THE
*           EXPRESSION (ACCESSIBLE WITH THE CURRENT VALUE OF
*           PMHBS), RESTORE THE P$EXA NODE POINTER AND THE OLD
*           PMHBS SETTING. TAKE THE SUCCESSOR AND CONTINUE.
*
*      AN OPTIMIZATION IS POSSIBLE IF THE EXPRESSION PATTERN
*      MAKES NO ENTRIES ON THE HISTORY STACK. IN THIS CASE,
*      INSTEAD OF BUILDING THE P$EXC NODE IN STEP 2, IT IS MORE
*      EFFICIENT TO SIMPLY POP OFF THE P$EXB ENTRY AND ITS
*      ASSOCIATED NODE POINTER. THE EFFECT IS THE SAME.
{{EJC{{{{{13472
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*      ------------------------------------
*
*           +---+            THIS NODE (P$IMA) STACKS THE CURSOR
*           I A I            PMHBS AND A PTR TO NDIMB AND RESETS
*           +---+            THE STACK PTR PMHBS.
*             I
*             I
*           +---+            THIS IS THE LEFT STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            IMMEDIATE ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P$IMC) PERFORMS THE
*           I C I-----       ASSIGNMENT, POPS PMHBS AND STACKS
*           +---+            THE OLD PMHBS AND A PTR TO NDIMD.
*
*
*      THE STRUCTURE AND EXECUTION OF THIS PATTERN ARE SIMILAR
*      TO THOSE OF THE RECURSIVE EXPRESSION PATTERN MATCHING.
*
*      THE MATCH ROUTINE FOR NDIMB (P$IMB) RESTORES THE OUTER
*      LEVEL VALUE OF PMHBS, UNSTACKS THE SAVED CURSOR AND FAILS
*
*      THE MATCH ROUTINE P$IMC USES THE CURRENT VALUE OF PMHBS
*      TO LOCATE THE P$IMB ENTRY. THIS ENTRY IS USED TO MAKE
*      THE ASSIGNMENT AND RESTORE THE OUTER LEVEL VALUE OF
*      PMHBS. FINALLY, THE INNER LEVEL VALUE OF PMHBS AND A
*      POINTER TO THE SPECIAL NODE NDIMD ARE STACKED.
*
*      THE MATCH ROUTINE FOR NDIMD (P$IMD) RESTORES THE INNER
*      LEVEL VALUE OF PMHBS AND FAILS BACK INTO THE STACK.
*
*      AN OPTIMIZATION OCCURS IF THE INNER PATTERN MAKES NO
*      ENTRIES ON THE HISTORY STACK. IN THIS CASE, P$IMC POPS
*      THE P$IMB ENTRY INSTEAD OF MAKING A P$IMD ENTRY.
{{EJC{{{{{13512
*
*      ARBNO
*
*      SEE COMPOUND PATTERNS SECTION FOR STUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$ABA{ENT{2,BL$P0{{{P0BLK{13521
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13522
{{MOV{7,XR{11,-(XS){{STACK DUMMY NODE PTR{13523
{{MOV{3,PMHBS{11,-(XS){{STACK OLD STACK BASE PTR{13524
{{MOV{21,=NDABB{11,-(XS){{STACK PTR TO NODE NDABB{13525
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE PTR{13526
{{BRN{6,SUCCP{{{SUCCEED{13527
{{EJC{{{{{13528
*
*      ARBNO (REMOVE P$ABA SPECIAL STACK ENTRY)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABB{ENT{{{{ENTRY POINT{13534
{{MOV{8,WB{3,PMHBS{{RESTORE HISTORY STACK BASE PTR{13535
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{13536
{{EJC{{{{{13537
*
*      ARBNO (CHECK IF ARG MATCHED NULL STRING)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABC{ENT{2,BL$P0{{{P0BLK{13543
{{MOV{3,PMHBS{7,XT{{KEEP P$ABB STACK BASE{13544
{{MOV{13,NUM03(XT){8,WA{{LOAD INITIAL CURSOR{13545
{{MOV{13,NUM01(XT){3,PMHBS{{RESTORE OUTER STACK BASE PTR{13546
{{BEQ{7,XT{7,XS{6,PABC1{JUMP IF NO HISTORY STACK ENTRIES{13547
{{MOV{7,XT{11,-(XS){{ELSE SAVE INNER PMHBS ENTRY{13548
{{MOV{21,=NDABD{11,-(XS){{STACK PTR TO SPECIAL NODE NDABD{13549
{{BRN{6,PABC2{{{MERGE{13550
*
*      OPTIMISE CASE OF NO EXTRA ENTRIES ON STACK FROM ARBNO ARG
*
{PABC1{ADD{19,*NUM04{7,XS{{REMOVE NDABB ENTRY AND CURSOR{13554
*
*      MERGE TO CHECK FOR MATCHING OF NULL STRING
*
{PABC2{BNE{8,WA{8,WB{6,SUCCP{ALLOW FURTHER ATTEMPT IF NON-NULL{13558
{{MOV{13,PTHEN(XR){7,XR{{BYPASS ALTERNATIVE NODE SO AS TO ...{13559
{{BRN{6,SUCCP{{{... REFUSE FURTHER MATCH ATTEMPTS{13560
{{EJC{{{{{13561
*
*      ARBNO (TRY FOR ALTERNATIVES IN ARBNO ARGUMENT)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABD{ENT{{{{ENTRY POINT{13567
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE PTR{13568
{{BRN{6,FAILP{{{AND FAIL{13569
{{EJC{{{{{13570
*
*      ABORT
*
*      NO PARAMETERS
*
{P$ABO{ENT{2,BL$P0{{{P0BLK{13576
{{BRN{6,EXFAL{{{SIGNAL STATEMENT FAILURE{13577
{{EJC{{{{{13578
*
*      ALTERNATION
*
*      PARM1                 ALTERNATIVE NODE
*
{P$ALT{ENT{2,BL$P1{{{P1BLK{13584
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13585
{{MOV{13,PARM1(XR){11,-(XS){{STACK POINTER TO ALTERNATIVE{13586
{{CHK{{{{CHECK FOR STACK OVERFLOW{13587
{{BRN{6,SUCCP{{{IF ALL OK, THEN SUCCEED{13588
{{EJC{{{{{13589
*
*      ANY (ONE CHARACTER ARGUMENT) (1-CHAR STRING ALSO)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$ANS{ENT{2,BL$P1{{{P1BLK{13595
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{13596
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13597
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13598
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{13599
{{BNE{8,WA{13,PARM1(XR){6,FAILP{FAIL IF NO MATCH{13600
{{ICV{8,WB{{{ELSE BUMP CURSOR{13601
{{BRN{6,SUCCP{{{AND SUCCEED{13602
{{EJC{{{{{13603
*
*      ANY (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT IN CTBLK
*
{P$ANY{ENT{2,BL$P2{{{P2BLK{13610
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PANY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{13614
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13615
{{PLC{7,XL{8,WB{{GET CHAR PTR TO CURRENT CHARACTER{13616
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{13617
{{MOV{13,PARM1(XR){7,XL{{POINT TO CTBLK{13618
{{WTB{8,WA{{{CHANGE TO BYTE OFFSET{13619
{{ADD{8,WA{7,XL{{POINT TO ENTRY IN CTBLK{13620
{{MOV{13,CTCHS(XL){8,WA{{LOAD WORD FROM CTBLK{13621
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{13622
{{ZRB{8,WA{6,FAILP{{FAIL IF NO MATCH{13623
{{ICV{8,WB{{{ELSE BUMP CURSOR{13624
{{BRN{6,SUCCP{{{AND SUCCEED{13625
{{EJC{{{{{13626
*
*      ANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$AYD{ENT{2,BL$P1{{{P1BLK{13632
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{13633
{{ERR{1,043{26,ANY evaluated argument is not a string{{{13634
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILURE{13635
{{PPM{6,PANY1{{{MERGE MULTI-CHAR CASE IF OK{13636
{{EJC{{{{{13637
*
*      P$ARB                 INITIAL ARB MATCH
*
*      NO PARAMETERS
*
*      THE P$ARB NODE IS PART OF A COMPOUND PATTERN STRUCTURE
*      FOR AN ARB PATTERN (SEE DESCRIPTION OF COMPOUND PATTERNS)
*
{P$ARB{ENT{2,BL$P0{{{P0BLK{13646
{{MOV{13,PTHEN(XR){7,XR{{LOAD SUCCESSOR POINTER{13647
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13648
{{MOV{7,XR{11,-(XS){{STACK SUCCESSOR POINTER{13649
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13650
{{MOV{21,=NDARC{11,-(XS){{STACK PTR TO SPECIAL NODE NDARC{13651
{{BRI{9,(XR){{{EXECUTE NEXT NODE MATCHING NULL{13652
{{EJC{{{{{13653
*
*      P$ARC                 EXTEND ARB MATCH
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ARC{ENT{{{{ENTRY POINT{13659
{{BEQ{8,WB{3,PMSSL{6,FLPOP{FAIL AND POP STACK TO SUCCESSOR{13660
{{ICV{8,WB{{{ELSE BUMP CURSOR{13661
{{MOV{8,WB{11,-(XS){{STACK UPDATED CURSOR{13662
{{MOV{7,XR{11,-(XS){{RESTACK POINTER TO NDARC NODE{13663
{{MOV{13,NUM02(XS){7,XR{{LOAD SUCCESSOR POINTER{13664
{{BRI{9,(XR){{{OFF TO REEXECUTE SUCCESSOR NODE{13665
{{EJC{{{{{13666
*
*      BAL
*
*      NO PARAMETERS
*
*      THE P$BAL NODE IS PART OF THE COMPOUND STRUCTURE BUILT
*      FOR BAL (SEE SECTION ON COMPOUND PATTERNS).
*
{P$BAL{ENT{2,BL$P0{{{P0BLK{13675
{{ZER{8,WC{{{ZERO PARENTHESES LEVEL COUNTER{13676
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{13677
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13678
{{BRN{6,PBAL2{{{JUMP INTO SCAN LOOP{13679
*
*      LOOP TO SCAN OUT CHARACTERS
*
{PBAL1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{13683
{{ICV{8,WB{{{PUSH CURSOR FOR CHARACTER{13684
{{BEQ{8,WA{18,=CH$PP{6,PBAL3{JUMP IF LEFT PAREN{13685
{{BEQ{8,WA{18,=CH$RP{6,PBAL4{JUMP IF RIGHT PAREN{13686
{{BZE{8,WC{6,PBAL5{{ELSE SUCCEED IF AT OUTER LEVEL{13687
*
*      HERE AFTER PROCESSING ONE CHARACTER
*
{PBAL2{BNE{8,WB{3,PMSSL{6,PBAL1{LOOP BACK UNLESS END OF STRING{13691
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{13692
*
*      HERE ON LEFT PAREN
*
{PBAL3{ICV{8,WC{{{BUMP PAREN LEVEL{13696
{{BRN{6,PBAL2{{{LOOP BACK TO CHECK END OF STRING{13697
*
*      HERE FOR RIGHT PAREN
*
{PBAL4{BZE{8,WC{6,FAILP{{FAIL IF NO MATCHING LEFT PAREN{13701
{{DCV{8,WC{{{ELSE DECREMENT LEVEL COUNTER{13702
{{BNZ{8,WC{6,PBAL2{{LOOP BACK IF NOT AT OUTER LEVEL{13703
*
*      HERE AFTER SUCCESSFULLY SCANNING A BALANCED STRING
*
{PBAL5{MOV{8,WB{11,-(XS){{STACK CURSOR{13707
{{MOV{7,XR{11,-(XS){{STACK PTR TO BAL NODE FOR EXTEND{13708
{{BRN{6,SUCCP{{{AND SUCCEED{13709
{{EJC{{{{{13710
*
*      BREAK (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$BKD{ENT{2,BL$P1{{{P1BLK{13716
{{JSR{6,EVALS{{{EVALUATE STRING EXPRESSION{13717
{{ERR{1,044{26,BREAK evaluated argument is not a string{{{13718
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13719
{{PPM{6,PBRK1{{{MERGE WITH MULTI-CHAR CASE IF OK{13720
{{EJC{{{{{13721
*
*      BREAK (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$BKS{ENT{2,BL$P1{{{P1BLK{13727
{{MOV{3,PMSSL{8,WC{{GET SUBJECT STRING LENGTH{13728
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS LEFT{13729
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{13730
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{13731
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{13732
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13733
*
*      LOOP TO SCAN TILL BREAK CHARACTER FOUND
*
{PBKS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{13737
{{BEQ{8,WA{13,PARM1(XR){6,SUCCP{SUCCEED IF BREAK CHARACTER FOUND{13738
{{ICV{8,WB{{{ELSE PUSH CURSOR{13739
{{BCT{8,WC{6,PBKS1{{LOOP BACK IF MORE TO GO{13740
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{13741
{{EJC{{{{{13742
*
*      BREAK (MULTI-CHARACTER ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$BRK{ENT{2,BL$P2{{{P2BLK{13749
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PBRK1{MOV{3,PMSSL{8,WC{{LOAD SUBJECT STRING LENGTH{13753
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS LEFT{13754
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{13755
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{13756
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13757
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13758
{{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{13759
*
*      LOOP TO SEARCH FOR BREAK CHARACTER
*
{PBRK2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{13763
{{MOV{13,PARM1(XR){7,XR{{LOAD POINTER TO CTBLK{13764
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{13765
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{13766
{{MOV{13,CTCHS(XR){8,WA{{LOAD CTBLK WORD{13767
{{MOV{3,PSAVE{7,XR{{RESTORE NODE POINTER{13768
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{13769
{{NZB{8,WA{6,SUCCP{{SUCCEED IF BREAK CHARACTER FOUND{13770
{{ICV{8,WB{{{ELSE PUSH CURSOR{13771
{{BCT{8,WC{6,PBRK2{{LOOP BACK UNLESS END OF STRING{13772
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{13773
{{EJC{{{{{13774
*
*      BREAKX (EXTENSION)
*
*      THIS IS THE ENTRY WHICH CAUSES AN EXTENSION OF A BREAKX
*      MATCH WHEN FAILURE OCCURS. SEE SECTION ON COMPOUND
*      PATTERNS FOR FULL DETAILS OF BREAKX MATCHING.
*
*      NO PARAMETERS
*
{P$BKX{ENT{2,BL$P0{{{P0BLK{13784
{{ICV{8,WB{{{STEP CURSOR PAST PREVIOUS BREAK CHR{13785
{{BRN{6,SUCCP{{{SUCCEED TO REMATCH BREAK{13786
{{EJC{{{{{13787
*
*      BREAKX (EXPRESSION ARGUMENT)
*
*      SEE SECTION ON COMPOUND PATTERNS FOR FULL STRUCTURE OF
*      BREAKX PATTERN. THE ACTUAL CHARACTER MATCHING USES A
*      BREAK NODE. HOWEVER, THE ENTRY FOR THE EXPRESSION
*      ARGUMENT CASE IS SEPARATED TO GET PROPER ERROR MESSAGES.
*
*      PARM1                 EXPRESSION POINTER
*
{P$BXD{ENT{2,BL$P1{{{P1BLK{13798
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{13799
{{ERR{1,045{26,BREAKX evaluated argument is not a string{{{13800
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13801
{{PPM{6,PBRK1{{{MERGE WITH BREAK IF ALL OK{13802
{{EJC{{{{{13803
*
*      CURSOR ASSIGNMENT
*
*      PARM1                 NAME BASE
*      PARM2                 NAME OFFSET
*
{P$CAS{ENT{2,BL$P2{{{P2BLK{13810
{{MOV{7,XR{11,-(XS){{SAVE NODE POINTER{13811
{{MOV{8,WB{11,-(XS){{SAVE CURSOR{13812
{{MOV{13,PARM1(XR){7,XL{{LOAD NAME BASE{13813
{{MTI{8,WB{{{LOAD CURSOR AS INTEGER{13814
{{MOV{13,PARM2(XR){8,WB{{LOAD NAME OFFSET{13815
{{JSR{6,ICBLD{{{GET ICBLK FOR CURSOR VALUE{13816
{{MOV{8,WB{8,WA{{MOVE NAME OFFSET{13817
{{MOV{7,XR{8,WB{{MOVE VALUE TO ASSIGN{13818
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{13819
{{PPM{6,FLPOP{{{FAIL ON ASSIGNMENT FAILURE{13820
{{MOV{10,(XS)+{8,WB{{ELSE RESTORE CURSOR{13821
{{MOV{10,(XS)+{7,XR{{RESTORE NODE POINTER{13822
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{13823
{{EJC{{{{{13824
*
*      EXPRESSION NODE (P$EXA, INITIAL ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      PARM1                 EXPRESSION POINTER
*
{P$EXA{ENT{2,BL$P1{{{P1BLK{13833
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{13834
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13835
{{BLO{8,WA{22,=P$AAA{6,PEXA1{JUMP IF RESULT IS NOT A PATTERN{13836
*
*      HERE IF RESULT OF EXPRESSION IS A PATTERN
*
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13840
{{MOV{7,XR{11,-(XS){{STACK PTR TO P$EXA NODE{13841
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE PTR{13842
{{MOV{21,=NDEXB{11,-(XS){{STACK PTR TO SPECIAL NODE NDEXB{13843
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE POINTER{13844
{{MOV{7,XL{7,XR{{COPY NODE POINTER{13845
{{BRI{9,(XR){{{MATCH FIRST NODE IN EXPRESSION PAT{13846
*
*      HERE IF RESULT OF EXPRESSION IS NOT A PATTERN
*
{PEXA1{BEQ{8,WA{22,=B$SCL{6,PEXA2{JUMP IF IT IS ALREADY A STRING{13850
{{MOV{7,XL{11,-(XS){{ELSE STACK RESULT{13851
{{MOV{7,XR{7,XL{{SAVE NODE POINTER{13852
{{JSR{6,GTSTG{{{CONVERT RESULT TO STRING{13853
{{ERR{1,046{26,Expression does not evaluate to pattern{{{13854
{{MOV{7,XR{8,WC{{COPY STRING POINTER{13855
{{MOV{7,XL{7,XR{{RESTORE NODE POINTER{13856
{{MOV{8,WC{7,XL{{COPY STRING POINTER AGAIN{13857
*
*      MERGE HERE WITH STRING POINTER IN XL
*
{PEXA2{BZE{13,SCLEN(XL){6,SUCCP{{JUST SUCCEED IF NULL STRING{13861
{{BRN{6,PSTR1{{{ELSE MERGE WITH STRING CIRCUIT{13862
{{EJC{{{{{13863
*
*      EXPRESSION NODE (P$EXB, REMOVE NDEXB ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$EXB{ENT{{{{ENTRY POINT{13872
{{MOV{8,WB{3,PMHBS{{RESTORE OUTER LEVEL STACK POINTER{13873
{{BRN{6,FLPOP{{{FAIL AND POP P$EXA NODE PTR{13874
{{EJC{{{{{13875
*
*      EXPRESSION NODE (P$EXC, REMOVE NDEXC ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$EXC{ENT{{{{ENTRY POINT{13884
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE POINTER{13885
{{BRN{6,FAILP{{{AND FAIL INTO EXPR PATTERN ALTERNVS{13886
{{EJC{{{{{13887
*
*      FAIL
*
*      NO PARAMETERS
*
{P$FAL{ENT{2,BL$P0{{{P0BLK{13893
{{BRN{6,FAILP{{{JUST SIGNAL FAILURE{13894
{{EJC{{{{{13895
*
*      FENCE
*
*      SEE COMPOUND PATTERNS SECTION FOR THE STRUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$FEN{ENT{2,BL$P0{{{P0BLK{13904
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13905
{{MOV{21,=NDABO{11,-(XS){{STACK PTR TO ABORT NODE{13906
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{13907
{{EJC{{{{{13908
*
*      FENCE (FUNCTION)
*
*      SEE COMPOUND PATTERNS COMMENTS AT START OF THIS SECTION
*      FOR DETAILS OF SCHEME
*
*      NO PARAMETERS
*
{P$FNA{ENT{2,BL$P0{{{P0BLK{13917
{{MOV{3,PMHBS{11,-(XS){{STACK CURRENT HISTORY STACK BASE{13918
{{MOV{21,=NDFNB{11,-(XS){{STACK INDIR PTR TO P$FNB (FAILURE){13919
{{MOV{7,XS{3,PMHBS{{BEGIN NEW HISTORY STACK{13920
{{BRN{6,SUCCP{{{SUCCEED{13921
{{EJC{{{{{13922
*
*      FENCE (FUNCTION) (RESET HISTORY STACK AND FAIL)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FNB{ENT{2,BL$P0{{{P0BLK{13928
{{MOV{8,WB{3,PMHBS{{RESTORE OUTER PMHBS STACK BASE{13929
{{BRN{6,FAILP{{{...AND FAIL{13930
{{EJC{{{{{13931
*
*      FENCE (FUNCTION) (MAKE FENCE TRAP ENTRY ON STACK)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FNC{ENT{2,BL$P0{{{P0BLK{13937
{{MOV{3,PMHBS{7,XT{{GET INNER STACK BASE PTR{13938
{{MOV{13,NUM01(XT){3,PMHBS{{RESTORE OUTER STACK BASE{13939
{{BEQ{7,XT{7,XS{6,PFNC1{OPTIMIZE IF NO ALTERNATIVES{13940
{{MOV{7,XT{11,-(XS){{ELSE STACK INNER STACK BASE{13941
{{MOV{21,=NDFND{11,-(XS){{STACK PTR TO NDFND{13942
{{BRN{6,SUCCP{{{SUCCEED{13943
*
*      HERE WHEN FENCE FUNCTION LEFT NOTHING ON THE STACK
*
{PFNC1{ADD{19,*NUM02{7,XS{{POP OFF P$FNB ENTRY{13947
{{BRN{6,SUCCP{{{SUCCEED{13948
{{EJC{{{{{13949
*
*      FENCE (FUNCTION) (SKIP PAST ALTERNATIVES ON FAILURE)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FND{ENT{2,BL$P0{{{P0BLK{13955
{{MOV{8,WB{7,XS{{POP STACK TO FENCE() HISTORY BASE{13956
{{BRN{6,FLPOP{{{POP BASE ENTRY AND FAIL{13957
{{EJC{{{{{13958
*
*      IMMEDIATE ASSIGNMENT (INITIAL ENTRY, SAVE CURRENT CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$IMA{ENT{2,BL$P0{{{P0BLK{13967
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13968
{{MOV{7,XR{11,-(XS){{STACK DUMMY NODE POINTER{13969
{{MOV{3,PMHBS{11,-(XS){{STACK OLD STACK BASE POINTER{13970
{{MOV{21,=NDIMB{11,-(XS){{STACK PTR TO SPECIAL NODE NDIMB{13971
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE POINTER{13972
{{BRN{6,SUCCP{{{AND SUCCEED{13973
{{EJC{{{{{13974
*
*      IMMEDIATE ASSIGNMENT (REMOVE CURSOR MARK ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$IMB{ENT{{{{ENTRY POINT{13983
{{MOV{8,WB{3,PMHBS{{RESTORE HISTORY STACK BASE PTR{13984
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{13985
{{EJC{{{{{13986
*
*      IMMEDIATE ASSIGNMENT (PERFORM ACTUAL ASSIGNMENT)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P$IMC{ENT{2,BL$P2{{{P2BLK{13996
{{MOV{3,PMHBS{7,XT{{LOAD POINTER TO P$IMB ENTRY{13997
{{MOV{8,WB{8,WA{{COPY FINAL CURSOR{13998
{{MOV{13,NUM03(XT){8,WB{{LOAD INITIAL CURSOR{13999
{{MOV{13,NUM01(XT){3,PMHBS{{RESTORE OUTER STACK BASE POINTER{14000
{{BEQ{7,XT{7,XS{6,PIMC1{JUMP IF NO HISTORY STACK ENTRIES{14001
{{MOV{7,XT{11,-(XS){{ELSE SAVE INNER PMHBS POINTER{14002
{{MOV{21,=NDIMD{11,-(XS){{AND A PTR TO SPECIAL NODE NDIMD{14003
{{BRN{6,PIMC2{{{MERGE{14004
*
*      HERE IF NO ENTRIES MADE ON HISTORY STACK
*
{PIMC1{ADD{19,*NUM04{7,XS{{REMOVE NDIMB ENTRY AND CURSOR{14008
*
*      MERGE HERE TO PERFORM ASSIGNMENT
*
{PIMC2{MOV{8,WA{11,-(XS){{SAVE CURRENT (FINAL) CURSOR{14012
{{MOV{7,XR{11,-(XS){{SAVE CURRENT NODE POINTER{14013
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14014
{{SUB{8,WB{8,WA{{COMPUTE SUBSTRING LENGTH{14015
{{JSR{6,SBSTR{{{BUILD SUBSTRING{14016
{{MOV{7,XR{8,WB{{MOVE RESULT{14017
{{MOV{9,(XS){7,XR{{RELOAD NODE POINTER{14018
{{MOV{13,PARM1(XR){7,XL{{LOAD NAME BASE{14019
{{MOV{13,PARM2(XR){8,WA{{LOAD NAME OFFSET{14020
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{14021
{{PPM{6,FLPOP{{{FAIL IF ASSIGNMENT FAILS{14022
{{MOV{10,(XS)+{7,XR{{ELSE RESTORE NODE POINTER{14023
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{14024
{{BRN{6,SUCCP{{{AND SUCCEED{14025
{{EJC{{{{{14026
*
*      IMMEDIATE ASSIGNMENT (REMOVE NDIMD ENTRY ON FAILURE)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$IMD{ENT{{{{ENTRY POINT{14035
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE POINTER{14036
{{BRN{6,FAILP{{{AND FAIL{14037
{{EJC{{{{{14038
*
*      LEN (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$LEN{ENT{2,BL$P1{{{P1BLK{14044
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PLEN1{ADD{13,PARM1(XR){8,WB{{PUSH CURSOR INDICATED AMOUNT{14048
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{14049
{{BRN{6,FAILP{{{ELSE FAIL{14050
{{EJC{{{{{14051
*
*      LEN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$LND{ENT{2,BL$P1{{{P1BLK{14057
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14058
{{ERR{1,047{26,LEN evaluated argument is not integer{{{14059
{{ERR{1,048{26,LEN evaluated argument is negative or too large{{{14060
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14061
{{PPM{6,PLEN1{{{MERGE WITH NORMAL CIRCUIT IF OK{14062
{{EJC{{{{{14063
*
*      NOTANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$NAD{ENT{2,BL$P1{{{P1BLK{14069
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{14070
{{ERR{1,049{26,NOTANY evaluated argument is not a string{{{14071
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14072
{{PPM{6,PNAY1{{{MERGE WITH MULTI-CHAR CASE IF OK{14073
{{EJC{{{{{14074
*
*      NOTANY (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$NAS{ENT{2,BL$P1{{{ENTRY POINT{14080
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{14081
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14082
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER IN STRIN{14083
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{14084
{{BEQ{8,WA{13,PARM1(XR){6,FAILP{FAIL IF MATCH{14085
{{ICV{8,WB{{{ELSE BUMP CURSOR{14086
{{BRN{6,SUCCP{{{AND SUCCEED{14087
{{EJC{{{{{14088
*
*      NOTANY (MULTI-CHARACTER STRING ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$NAY{ENT{2,BL$P2{{{P2BLK{14095
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PNAY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{14099
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14100
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14101
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{14102
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{14103
{{MOV{13,PARM1(XR){7,XL{{LOAD POINTER TO CTBLK{14104
{{ADD{8,WA{7,XL{{POINT TO ENTRY IN CTBLK{14105
{{MOV{13,CTCHS(XL){8,WA{{LOAD ENTRY FROM CTBLK{14106
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{14107
{{NZB{8,WA{6,FAILP{{FAIL IF CHARACTER IS MATCHED{14108
{{ICV{8,WB{{{ELSE BUMP CURSOR{14109
{{BRN{6,SUCCP{{{AND SUCCEED{14110
{{EJC{{{{{14111
*
*      END OF PATTERN MATCH
*
*      THIS ROUTINE IS ENTERED ON SUCCESSFUL COMPLETION.
*      SEE DESCRIPTION OF EXPRESSION PATTERNS IN COMPOUND
*      PATTERN SECTION FOR HANDLING OF RECURSION IN MATCHING.
*
*      THIS PATTERN ALSO RESULTS FROM AN ATTEMPT TO CONVERT THE
*      NULL STRING TO A PATTERN VIA CONVERT()
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$NTH{ENT{2,BL$P0{{{P0BLK (DUMMY){14124
{{MOV{3,PMHBS{7,XT{{LOAD POINTER TO BASE OF STACK{14125
{{MOV{13,NUM01(XT){8,WA{{LOAD SAVED PMHBS (OR PATTERN TYPE){14126
{{BLE{8,WA{18,=NUM02{6,PNTH2{JUMP IF OUTER LEVEL (PATTERN TYPE){14127
*
*      HERE WE ARE AT THE END OF MATCHING AN EXPRESSION PATTERN
*
{{MOV{8,WA{3,PMHBS{{RESTORE OUTER STACK BASE POINTER{14131
{{MOV{13,NUM02(XT){7,XR{{RESTORE POINTER TO P$EXA NODE{14132
{{BEQ{7,XT{7,XS{6,PNTH1{JUMP IF NO HISTORY STACK ENTRIES{14133
{{MOV{7,XT{11,-(XS){{ELSE STACK INNER STACK BASE PTR{14134
{{MOV{21,=NDEXC{11,-(XS){{STACK PTR TO SPECIAL NODE NDEXC{14135
{{BRN{6,SUCCP{{{AND SUCCEED{14136
*
*      HERE IF NO HISTORY STACK ENTRIES DURING PATTERN
*
{PNTH1{ADD{19,*NUM04{7,XS{{REMOVE P$EXB ENTRY AND NODE PTR{14140
{{BRN{6,SUCCP{{{AND SUCCEED{14141
*
*      HERE IF END OF MATCH AT OUTER LEVEL
*
{PNTH2{MOV{8,WB{3,PMSSL{{SAVE FINAL CURSOR IN SAFE PLACE{14145
{{BZE{3,PMDFL{6,PNTH6{{JUMP IF NO PATTERN ASSIGNMENTS{14146
{{EJC{{{{{14147
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      NOW WE MUST PERFORM PATTERN ASSIGNMENTS. THIS IS DONE BY
*      SCANNING THE HISTORY STACK FOR MATCHING NDPAB-NDPAD PAIRS
*
{PNTH3{DCA{7,XT{{{POINT PAST CURSOR ENTRY{14154
{{MOV{11,-(XT){8,WA{{LOAD NODE POINTER{14155
{{BEQ{8,WA{21,=NDPAD{6,PNTH4{JUMP IF NDPAD ENTRY{14156
{{BNE{8,WA{21,=NDPAB{6,PNTH5{JUMP IF NOT NDPAB ENTRY{14157
*
*      HERE FOR NDPAB ENTRY, STACK INITIAL CURSOR
*      NOTE THAT THERE MUST BE MORE ENTRIES ON THE STACK.
*
{{MOV{13,NUM01(XT){11,-(XS){{STACK INITIAL CURSOR{14162
{{CHK{{{{CHECK FOR STACK OVERFLOW{14163
{{BRN{6,PNTH3{{{LOOP BACK IF OK{14164
*
*      HERE FOR NDPAD ENTRY. THE STARTING CURSOR FROM THE
*      MATCHING NDPAD ENTRY IS NOW THE TOP STACK ENTRY.
*
{PNTH4{MOV{13,NUM01(XT){8,WA{{LOAD FINAL CURSOR{14169
{{MOV{9,(XS){8,WB{{LOAD INITIAL CURSOR FROM STACK{14170
{{MOV{7,XT{9,(XS){{SAVE HISTORY STACK SCAN PTR{14171
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF STRING{14172
*
*      BUILD SUBSTRING AND PERFORM ASSIGNMENT
*
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14176
{{JSR{6,SBSTR{{{CONSTRUCT SUBSTRING{14177
{{MOV{7,XR{8,WB{{COPY SUBSTRING POINTER{14178
{{MOV{9,(XS){7,XT{{RELOAD HISTORY STACK SCAN PTR{14179
{{MOV{13,NUM02(XT){7,XL{{LOAD POINTER TO P$PAC NODE WITH NAM{14180
{{MOV{13,PARM2(XL){8,WA{{LOAD NAME OFFSET{14181
{{MOV{13,PARM1(XL){7,XL{{LOAD NAME BASE{14182
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{14183
{{PPM{6,EXFAL{{{MATCH FAILS IF NAME EVAL FAILS{14184
{{MOV{10,(XS)+{7,XT{{ELSE RESTORE HISTORY STACK PTR{14185
{{EJC{{{{{14186
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      HERE CHECK FOR END OF ENTRIES
*
{PNTH5{BNE{7,XT{7,XS{6,PNTH3{LOOP IF MORE ENTRIES TO SCAN{14192
*
*      HERE AFTER DEALING WITH PATTERN ASSIGNMENTS
*
{PNTH6{MOV{3,PMHBS{7,XS{{WIPE OUT HISTORY STACK{14196
{{MOV{10,(XS)+{8,WB{{LOAD INITIAL CURSOR{14197
{{MOV{10,(XS)+{8,WC{{LOAD MATCH TYPE CODE{14198
{{MOV{3,PMSSL{8,WA{{LOAD FINAL CURSOR VALUE{14199
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14200
{{ZER{3,R$PMS{{{CLEAR SUBJECT STRING PTR FOR GBCOL{14201
{{BZE{8,WC{6,PNTH7{{JUMP IF CALL BY NAME{14202
{{BEQ{8,WC{18,=NUM02{6,PNTH9{EXIT IF STATEMENT LEVEL CALL{14203
*
*      HERE WE HAVE A CALL BY VALUE, BUILD SUBSTRING
*
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF STRING{14207
{{JSR{6,SBSTR{{{BUILD SUBSTRING{14208
{{MOV{7,XR{11,-(XS){{STACK RESULT{14209
{{LCW{7,XR{{{GET NEXT CODE WORD{14210
{{BRI{9,(XR){{{EXECUTE IT{14211
*
*      HERE FOR CALL BY NAME, MAKE STACK ENTRIES FOR O$RPL
*
{PNTH7{MOV{8,WB{11,-(XS){{STACK INITIAL CURSOR{14215
{{MOV{8,WA{11,-(XS){{STACK FINAL CURSOR{14216
*
*      HERE WITH XL POINTING TO SCBLK OR BCBLK
*
{PNTH8{MOV{7,XL{11,-(XS){{STACK SUBJECT POINTER{14225
*
*      HERE TO OBEY NEXT CODE WORD
*
{PNTH9{LCW{7,XR{{{GET NEXT CODE WORD{14229
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14230
{{EJC{{{{{14231
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$POS{ENT{2,BL$P1{{{P1BLK{14237
*
*      OPTIMIZE POS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND POS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLE PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT.)
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14255
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14256
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14257
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14258
*
*      EXPRESSION ARGUMENT CIRCUIT MERGES HERE
*
{PPOS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{14262
{{MOV{13,PARM1(XR){8,WB{{GET DESIRED CURSOR POSITION{14263
{{BGT{8,WB{3,PMSSL{6,EXFAL{ABORT IF OFF END{14264
{{MOV{8,WB{13,NUM02(XT){{FAKE NUMBER OF UNANCHORED MOVES{14265
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{14266
{{EJC{{{{{14267
*
*      POS (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$PSD{ENT{2,BL$P1{{{P1BLK{14273
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14274
{{ERR{1,050{26,POS evaluated argument is not integer{{{14275
{{ERR{1,051{26,POS evaluated argument is negative or too large{{{14276
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14277
{{PPM{6,PPOS1{{{PROCESS EXPRESSION CASE{14278
*
{PPOS1{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14280
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14281
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{14282
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14283
{{MOV{3,EVLIO{8,WA{{GET ORIGINAL NODE PTR{14284
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14285
{{BRN{6,PPOS2{{{MERGE WITH INTEGER ARGUMENT CODE{14286
{{EJC{{{{{14287
*
*      PATTERN ASSIGNMENT (INITIAL ENTRY, SAVE CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$PAA{ENT{2,BL$P0{{{P0BLK{14296
{{MOV{8,WB{11,-(XS){{STACK INITIAL CURSOR{14297
{{MOV{21,=NDPAB{11,-(XS){{STACK PTR TO NDPAB SPECIAL NODE{14298
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{14299
{{EJC{{{{{14300
*
*      PATTERN ASSIGNMENT (REMOVE SAVED CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$PAB{ENT{{{{ENTRY POINT{14309
{{BRN{6,FAILP{{{JUST FAIL (ENTRY IS ALREADY POPPED){14310
{{EJC{{{{{14311
*
*      PATTERN ASSIGNMENT (END OF MATCH, MAKE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P$PAC{ENT{2,BL$P2{{{P2BLK{14321
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR VALUE{14322
{{MOV{7,XR{11,-(XS){{STACK POINTER TO P$PAC NODE{14323
{{MOV{8,WB{11,-(XS){{STACK FINAL CURSOR{14324
{{MOV{21,=NDPAD{11,-(XS){{STACK PTR TO SPECIAL NDPAD NODE{14325
{{MNZ{3,PMDFL{{{SET DOT FLAG NON-ZERO{14326
{{BRN{6,SUCCP{{{AND SUCCEED{14327
{{EJC{{{{{14328
*
*      PATTERN ASSIGNMENT (REMOVE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY NODE)
*
{P$PAD{ENT{{{{ENTRY POINT{14337
{{BRN{6,FLPOP{{{FAIL AND REMOVE P$PAC NODE{14338
{{EJC{{{{{14339
*
*      REM
*
*      NO PARAMETERS
*
{P$REM{ENT{2,BL$P0{{{P0BLK{14345
{{MOV{3,PMSSL{8,WB{{POINT CURSOR TO END OF STRING{14346
{{BRN{6,SUCCP{{{AND SUCCEED{14347
{{EJC{{{{{14348
*
*      RPOS (EXPRESSION ARGUMENT)
*
*      OPTIMIZE RPOS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND RPOS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLY PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT).
*
*      PARM1                 EXPRESSION POINTER
*
{P$RPD{ENT{2,BL$P1{{{P1BLK{14366
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14367
{{ERR{1,052{26,RPOS evaluated argument is not integer{{{14368
{{ERR{1,053{26,RPOS evaluated argument is negative or too large{{{14369
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14370
{{PPM{6,PRPS1{{{MERGE WITH NORMAL CASE IF OK{14371
*
{PRPS1{MOV{3,PMSSL{8,WC{{GET LENGTH OF STRING{14373
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS REMAINING{14374
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14375
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14376
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{14377
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14378
{{MOV{3,EVLIO{8,WA{{GET ORIGINAL NODE PTR{14379
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14380
{{BRN{6,PRPS2{{{MERGE WITH INTEGER ARG CODE{14381
{{EJC{{{{{14382
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$RPS{ENT{2,BL$P1{{{P1BLK{14388
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{MOV{3,PMSSL{8,WC{{GET LENGTH OF STRING{14394
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS REMAINING{14395
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14396
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14397
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14398
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF RPOS IS NOT FIRST NODE{14399
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PRPS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{14403
{{MOV{3,PMSSL{8,WB{{POINT TO END OF STRING{14404
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{14405
{{SUB{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR{14406
{{MOV{8,WB{13,NUM02(XT){{FAKE NUMBER OF UNANCHORED MOVES{14407
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{14408
{{EJC{{{{{14409
*
*      RTAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$RTB{ENT{2,BL$P1{{{P1BLK{14415
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PRTB1{MOV{8,WB{8,WC{{SAVE INITIAL CURSOR{14419
{{MOV{3,PMSSL{8,WB{{POINT TO END OF STRING{14420
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{14421
{{SUB{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR{14422
{{BGE{8,WB{8,WC{6,SUCCP{AND SUCCEED IF NOT TOO FAR ALREADY{14423
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{14424
{{EJC{{{{{14425
*
*      RTAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$RTD{ENT{2,BL$P1{{{P1BLK{14431
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14432
{{ERR{1,054{26,RTAB evaluated argument is not integer{{{14433
{{ERR{1,055{26,RTAB evaluated argument is negative or too large{{{14434
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14435
{{PPM{6,PRTB1{{{MERGE WITH NORMAL CASE IF SUCCESS{14436
{{EJC{{{{{14437
*
*      SPAN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$SPD{ENT{2,BL$P1{{{P1BLK{14443
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{14444
{{ERR{1,056{26,SPAN evaluated argument is not a string{{{14445
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14446
{{PPM{6,PSPN1{{{MERGE WITH MULTI-CHAR CASE IF OK{14447
{{EJC{{{{{14448
*
*      SPAN (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$SPN{ENT{2,BL$P2{{{P2BLK{14455
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PSPN1{MOV{3,PMSSL{8,WC{{COPY SUBJECT STRING LENGTH{14459
{{SUB{8,WB{8,WC{{CALCULATE NUMBER OF CHARACTERS LEFT{14460
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{14461
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14462
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14463
{{MOV{8,WB{3,PSAVC{{SAVE INITIAL CURSOR{14464
{{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{14465
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{14466
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPN2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{14470
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{14471
{{MOV{13,PARM1(XR){7,XR{{POINT TO CTBLK{14472
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{14473
{{MOV{13,CTCHS(XR){8,WA{{LOAD CTBLK ENTRY{14474
{{MOV{3,PSAVE{7,XR{{RESTORE NODE POINTER{14475
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{14476
{{ZRB{8,WA{6,PSPN3{{JUMP IF NO MATCH{14477
{{ICV{8,WB{{{ELSE PUSH CURSOR{14478
{{BCT{8,WC{6,PSPN2{{LOOP BACK UNLESS END OF STRING{14479
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPN3{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{14483
{{BRN{6,FAILP{{{ELSE FAIL IF NULL STRING MATCHED{14484
{{EJC{{{{{14485
*
*      SPAN (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$SPS{ENT{2,BL$P1{{{P1BLK{14491
{{MOV{3,PMSSL{8,WC{{GET SUBJECT STRING LENGTH{14492
{{SUB{8,WB{8,WC{{CALCULATE NUMBER OF CHARACTERS LEFT{14493
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{14494
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14495
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14496
{{MOV{8,WB{3,PSAVC{{SAVE INITIAL CURSOR{14497
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{14498
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{14502
{{BNE{8,WA{13,PARM1(XR){6,PSPS2{JUMP IF NO MATCH{14503
{{ICV{8,WB{{{ELSE PUSH CURSOR{14504
{{BCT{8,WC{6,PSPS1{{AND LOOP UNLESS END OF STRING{14505
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPS2{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{14509
{{BRN{6,FAILP{{{FAIL IF NULL STRING MATCHED{14510
{{EJC{{{{{14511
*
*      MULTI-CHARACTER STRING
*
*      NOTE THAT ONE CHARACTER STRINGS USE THE CIRCUIT FOR
*      ONE CHARACTER ANY ARGUMENTS (P$AN1).
*
*      PARM1                 POINTER TO SCBLK FOR STRING ARG
*
{P$STR{ENT{2,BL$P1{{{P1BLK{14520
{{MOV{13,PARM1(XR){7,XL{{GET POINTER TO STRING{14521
*
*      MERGE HERE AFTER EVALUATING EXPRESSION WITH STRING VALUE
*
{PSTR1{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{14525
{{MOV{3,R$PMS{7,XR{{LOAD SUBJECT STRING POINTER{14526
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{14527
{{ADD{13,SCLEN(XL){8,WB{{COMPUTE NEW CURSOR POSITION{14528
{{BGT{8,WB{3,PMSSL{6,FAILP{FAIL IF PAST END OF STRING{14529
{{MOV{8,WB{3,PSAVC{{SAVE UPDATED CURSOR{14530
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARS TO COMPARE{14531
{{PLC{7,XL{{{POINT TO CHARS OF TEST STRING{14532
{{CMC{6,FAILP{6,FAILP{{COMPARE, FAIL IF NOT EQUAL{14533
{{MOV{3,PSAVE{7,XR{{IF ALL MATCHED, RESTORE NODE PTR{14534
{{MOV{3,PSAVC{8,WB{{RESTORE UPDATED CURSOR{14535
{{BRN{6,SUCCP{{{AND SUCCEED{14536
{{EJC{{{{{14537
*
*      SUCCEED
*
*      SEE SECTION ON COMPOUND PATTERNS FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE
*
*      NO PARAMETERS
*
{P$SUC{ENT{2,BL$P0{{{P0BLK{14546
{{MOV{8,WB{11,-(XS){{STACK CURSOR{14547
{{MOV{7,XR{11,-(XS){{STACK POINTER TO THIS NODE{14548
{{BRN{6,SUCCP{{{SUCCEED MATCHING NULL{14549
{{EJC{{{{{14550
*
*      TAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$TAB{ENT{2,BL$P1{{{P1BLK{14556
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PTAB1{BGT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF TOO FAR ALREADY{14560
{{MOV{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR POSITION{14561
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{14562
{{BRN{6,FAILP{{{ELSE FAIL{14563
{{EJC{{{{{14564
*
*      TAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$TBD{ENT{2,BL$P1{{{P1BLK{14570
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14571
{{ERR{1,057{26,TAB evaluated argument is not integer{{{14572
{{ERR{1,058{26,TAB evaluated argument is negative or too large{{{14573
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14574
{{PPM{6,PTAB1{{{MERGE WITH NORMAL CASE IF OK{14575
{{EJC{{{{{14576
*
*      ANCHOR MOVEMENT
*
*      NO PARAMETERS (DUMMY NODE)
*
{P$UNA{ENT{{{{ENTRY POINT{14582
{{MOV{8,WB{7,XR{{COPY INITIAL PATTERN NODE POINTER{14583
{{MOV{9,(XS){8,WB{{GET INITIAL CURSOR{14584
{{BEQ{8,WB{3,PMSSL{6,EXFAL{MATCH FAILS IF AT END OF STRING{14585
{{ICV{8,WB{{{ELSE INCREMENT CURSOR{14586
{{MOV{8,WB{9,(XS){{STORE INCREMENTED CURSOR{14587
{{MOV{7,XR{11,-(XS){{RESTACK INITIAL NODE PTR{14588
{{MOV{21,=NDUNA{11,-(XS){{RESTACK UNANCHORED NODE{14589
{{BRI{9,(XR){{{REMATCH FIRST NODE{14590
{{EJC{{{{{14591
*
*      END OF PATTERN MATCH ROUTINES
*
*      THE FOLLOWING ENTRY POINT MARKS THE END OF THE PATTERN
*      MATCHING ROUTINES AND ALSO THE END OF THE ENTRY POINTS
*      REFERENCED FROM THE FIRST WORD OF BLOCKS IN DYNAMIC STORE
*
{P$YYY{ENT{2,BL$$I{{{MARK LAST ENTRY IN PATTERN SECTION{14599
{{TTL{27,S P I T B O L -- SNOBOL4 BUILT-IN LABEL ROUTINES{{{{14600
*
*      THE FOLLOWING SECTION CONTAINS THE ROUTINES FOR LABELS
*      WHICH HAVE A PREDEFINED MEANING IN SNOBOL4.
*
*      CONTROL IS PASSED DIRECTLY TO THE LABEL NAME ENTRY POINT.
*
*      ENTRY NAMES ARE OF THE FORM L$XXX WHERE XXX IS THE THREE
*      LETTER VARIABLE NAME IDENTIFIER.
*
*      ENTRIES ARE IN ALPHABETICAL ORDER
{{EJC{{{{{14611
*
*      ABORT
*
{L$ABO{ENT{{{{ENTRY POINT{14615
*
*      MERGE HERE IF EXECUTION TERMINATES IN ERROR
*
{LABO1{MOV{3,KVERT{8,WA{{LOAD ERROR CODE{14619
{{BZE{8,WA{6,LABO3{{JUMP IF NO ERROR HAS OCCURED{14620
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{14622
{{MOV{3,KVSTN{8,WC{{CURRENT STATEMENT{14626
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{14627
{{MOV{3,R$COD{7,XR{{CURRENT CODE BLOCK{14630
{{MOV{13,CDSLN(XR){8,WC{{LINE NUMBER{14631
{{ZER{8,WB{{{COLUMN NUMBER{14635
{{MOV{3,STAGE{7,XR{{{14636
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{14637
{{PPM{6,STPR4{{{IF SYSTEM DOES NOT WANT PRINT{14638
{{JSR{6,PRTPG{{{ELSE EJECT PRINTER{14640
{{BZE{7,XR{6,LABO2{{DID SYSEA REQUEST PRINT{14642
{{JSR{6,PRTST{{{PRINT TEXT FROM SYSEA{14643
{LABO2{JSR{6,ERMSG{{{PRINT ERROR MESSAGE{14645
{{ZER{7,XR{{{INDICATE NO MESSAGE TO PRINT{14646
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{14647
*
*      HERE IF NO ERROR HAD OCCURED
*
{LABO3{ERB{1,036{26,Goto ABORT with no preceding error{{{14651
{{EJC{{{{{14652
*
*      CONTINUE
*
{L$CNT{ENT{{{{ENTRY POINT{14656
*
*      MERGE HERE AFTER EXECUTION ERROR
*
{LCNT1{MOV{3,R$CNT{7,XR{{LOAD CONTINUATION CODE BLOCK PTR{14660
{{BZE{7,XR{6,LCNT3{{JUMP IF NO PREVIOUS ERROR{14661
{{ZER{3,R$CNT{{{CLEAR FLAG{14662
{{MOV{7,XR{3,R$COD{{ELSE STORE AS NEW CODE BLOCK PTR{14663
{{BNE{9,(XR){22,=B$CDC{6,LCNT2{JUMP IF NOT COMPLEX GO{14664
{{MOV{3,STXOC{8,WA{{GET OFFSET OF ERROR{14665
{{BGE{8,WA{3,STXOF{6,LCNT4{JUMP IF ERROR IN GOTO EVALUATION{14666
*
*      HERE IF ERROR DID NOT OCCUR IN COMPLEX FAILURE GOTO
*
{LCNT2{ADD{3,STXOF{7,XR{{ADD FAILURE OFFSET{14670
{{LCP{7,XR{{{LOAD CODE POINTER{14671
{{MOV{3,FLPTR{7,XS{{RESET STACK POINTER{14672
{{LCW{7,XR{{{GET NEXT CODE WORD{14673
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14674
*
*      HERE IF NO PREVIOUS ERROR
*
{LCNT3{ICV{3,ERRFT{{{FATAL ERROR{14678
{{ERB{1,037{26,Goto CONTINUE with no preceding error{{{14679
*
*      HERE IF ERROR IN EVALUATION OF FAILURE GOTO.
*      CANNOT CONTINUE BACK TO FAILURE GOTO!
*
{LCNT4{ICV{3,ERRFT{{{FATAL ERROR{14684
{{ERB{1,332{26,Goto CONTINUE with error in failure goto{{{14685
{{EJC{{{{{14686
*
*      END
*
{L$END{ENT{{{{ENTRY POINT{14690
*
*      MERGE HERE FROM END CODE CIRCUIT
*
{LEND0{MOV{21,=ENDMS{7,XR{{POINT TO MESSAGE /NORMAL TERM.../{14694
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{14695
{{EJC{{{{{14696
*
*      FRETURN
*
{L$FRT{ENT{{{{ENTRY POINT{14700
{{MOV{21,=SCFRT{8,WA{{POINT TO STRING /FRETURN/{14701
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14702
{{EJC{{{{{14703
*
*      NRETURN
*
{L$NRT{ENT{{{{ENTRY POINT{14707
{{MOV{21,=SCNRT{8,WA{{POINT TO STRING /NRETURN/{14708
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14709
{{EJC{{{{{14710
*
*      RETURN
*
{L$RTN{ENT{{{{ENTRY POINT{14714
{{MOV{21,=SCRTN{8,WA{{POINT TO STRING /RETURN/{14715
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14716
{{EJC{{{{{14717
*
*      SCONTINUE
*
{L$SCN{ENT{{{{ENTRY POINT{14721
{{MOV{3,R$CNT{7,XR{{LOAD CONTINUATION CODE BLOCK PTR{14722
{{BZE{7,XR{6,LSCN2{{JUMP IF NO PREVIOUS ERROR{14723
{{ZER{3,R$CNT{{{CLEAR FLAG{14724
{{BNE{3,KVERT{18,=NM320{6,LSCN1{ERROR MUST BE USER INTERRUPT{14725
{{BEQ{3,KVERT{18,=NM321{6,LSCN2{DETECT SCONTINUE LOOP{14726
{{MOV{7,XR{3,R$COD{{ELSE STORE AS NEW CODE BLOCK PTR{14727
{{ADD{3,STXOC{7,XR{{ADD RESUME OFFSET{14728
{{LCP{7,XR{{{LOAD CODE POINTER{14729
{{LCW{7,XR{{{GET NEXT CODE WORD{14730
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14731
*
*      HERE IF NO USER INTERRUPT
*
{LSCN1{ICV{3,ERRFT{{{FATAL ERROR{14735
{{ERB{1,331{26,Goto SCONTINUE with no user interrupt{{{14736
*
*      HERE IF IN SCONTINUE LOOP OR IF NO PREVIOUS ERROR
*
{LSCN2{ICV{3,ERRFT{{{FATAL ERROR{14740
{{ERB{1,321{26,Goto SCONTINUE with no preceding error{{{14741
{{EJC{{{{{14742
*
*      UNDEFINED LABEL
*
{L$UND{ENT{{{{ENTRY POINT{14746
{{ERB{1,038{26,Goto undefined label{{{14747
{{TTL{27,S P I T B O L -- PREDEFINED SNOBOL4 FUNCTIONS{{{{14748
*
*      THE FOLLOWING SECTION CONTAINS CODING FOR FUNCTIONS
*      WHICH ARE PREDEFINED AND AVAILABLE AT THE SNOBOL LEVEL.
*
*      THESE ROUTINES RECEIVE CONTROL DIRECTLY FROM THE CODE OR
*      INDIRECTLY THROUGH THE O$FNC, O$FNS OR CFUNC ROUTINES.
*      IN BOTH CASES THE CONDITIONS ON ENTRY ARE AS FOLLOWS
*
*      THE ARGUMENTS ARE ON THE STACK. THE NUMBER OF ARGUMENTS
*      HAS BEEN ADJUSTED TO CORRESPOND TO THE SVBLK SVNAR FIELD.
*
*      IN CERTAIN FUNCTIONS THE DIRECT CALL IS NOT PERMITTED
*      AND IN THESE INSTANCES WE ALSO HAVE.
*
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS IN CALL
*
*      CONTROL RETURNS BY PLACING THE FUNCTION RESULT VALUE ON
*      ON THE STACK AND CONTINUING EXECUTION WITH THE NEXT
*      WORD FROM THE GENERATED CODE.
*
*      THE NAMES OF THE ENTRY POINTS OF THESE FUNCTIONS ARE OF
*      THE FORM S$XXX WHERE XXX IS THE THREE LETTER CODE FOR
*      THE SYSTEM VARIABLE NAME. THE FUNCTIONS ARE IN ORDER
*      ALPHABETICALLY BY THEIR ENTRY NAMES.
{{EJC{{{{{14773
*
*      ANY
*
{S$ANY{ENT{{{{ENTRY POINT{14827
{{MOV{22,=P$ANS{8,WB{{SET PCODE FOR SINGLE CHAR CASE{14828
{{MOV{22,=P$ANY{7,XL{{PCODE FOR MULTI-CHAR CASE{14829
{{MOV{22,=P$AYD{8,WC{{PCODE FOR EXPRESSION CASE{14830
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{14831
{{ERR{1,059{26,ANY argument is not a string or expression{{{14832
{{MOV{7,XR{11,-(XS){{STACK RESULT{14833
{{LCW{7,XR{{{GET NEXT CODE WORD{14834
{{BRI{9,(XR){{{EXECUTE IT{14835
{{EJC{{{{{14836
*
*      APPLY
*
*      APPLY DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S$APP{ENT{{{{ENTRY POINT{14862
{{BZE{8,WA{6,SAPP3{{JUMP IF NO ARGUMENTS{14863
{{DCV{8,WA{{{ELSE GET APPLIED FUNC ARG COUNT{14864
{{MOV{8,WA{8,WB{{COPY{14865
{{WTB{8,WB{{{CONVERT TO BYTES{14866
{{MOV{7,XS{7,XT{{COPY STACK POINTER{14867
{{ADD{8,WB{7,XT{{POINT TO FUNCTION ARGUMENT ON STACK{14868
{{MOV{9,(XT){7,XR{{LOAD FUNCTION PTR (APPLY 1ST ARG){14869
{{BZE{8,WA{6,SAPP2{{JUMP IF NO ARGS FOR APPLIED FUNC{14870
{{LCT{8,WB{8,WA{{ELSE SET COUNTER FOR LOOP{14871
*
*      LOOP TO MOVE ARGUMENTS UP ON STACK
*
{SAPP1{DCA{7,XT{{{POINT TO NEXT ARGUMENT{14875
{{MOV{9,(XT){13,NUM01(XT){{MOVE ARGUMENT UP{14876
{{BCT{8,WB{6,SAPP1{{LOOP TILL ALL MOVED{14877
*
*      MERGE HERE TO CALL FUNCTION (WA = NUMBER OF ARGUMENTS)
*
{SAPP2{ICA{7,XS{{{ADJUST STACK PTR FOR APPLY 1ST ARG{14881
{{JSR{6,GTNVR{{{GET VARIABLE BLOCK ADDR FOR FUNC{14882
{{PPM{6,SAPP3{{{JUMP IF NOT NATURAL VARIABLE{14883
{{MOV{13,VRFNC(XR){7,XL{{ELSE POINT TO FUNCTION BLOCK{14884
{{BRN{6,CFUNC{{{GO CALL APPLIED FUNCTION{14885
*
*      HERE FOR INVALID FIRST ARGUMENT
*
{SAPP3{ERB{1,060{26,APPLY first arg is not natural variable name{{{14889
{{EJC{{{{{14890
*
*      ARBNO
*
*      ARBNO BUILDS A COMPOUND PATTERN. SEE DESCRIPTION AT
*      START OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S$ABN{ENT{{{{ENTRY POINT{14897
{{ZER{7,XR{{{SET PARM1 = 0 FOR THE MOMENT{14898
{{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATIVE NODE{14899
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{14900
{{MOV{7,XR{7,XL{{SAVE PTR TO ALTERNATIVE PATTERN{14901
{{MOV{22,=P$ABC{8,WB{{PCODE FOR P$ABC{14902
{{ZER{7,XR{{{P0BLK{14903
{{JSR{6,PBILD{{{BUILD P$ABC NODE{14904
{{MOV{7,XL{13,PTHEN(XR){{PUT ALTERNATIVE NODE AS SUCCESSOR{14905
{{MOV{7,XL{8,WA{{REMEMBER ALTERNATIVE NODE POINTER{14906
{{MOV{7,XR{7,XL{{COPY P$ABC NODE PTR{14907
{{MOV{9,(XS){7,XR{{LOAD ARBNO ARGUMENT{14908
{{MOV{8,WA{9,(XS){{STACK ALTERNATIVE NODE POINTER{14909
{{JSR{6,GTPAT{{{GET ARBNO ARGUMENT AS PATTERN{14910
{{ERR{1,061{26,ARBNO argument is not pattern{{{14911
{{JSR{6,PCONC{{{CONCAT ARG WITH P$ABC NODE{14912
{{MOV{7,XR{7,XL{{REMEMBER PTR TO CONCD PATTERNS{14913
{{MOV{22,=P$ABA{8,WB{{PCODE FOR P$ABA{14914
{{ZER{7,XR{{{P0BLK{14915
{{JSR{6,PBILD{{{BUILD P$ABA NODE{14916
{{MOV{7,XL{13,PTHEN(XR){{CONCATENATE NODES{14917
{{MOV{9,(XS){7,XL{{RECALL PTR TO ALTERNATIVE NODE{14918
{{MOV{7,XR{13,PARM1(XL){{POINT ALTERNATIVE BACK TO ARGUMENT{14919
{{LCW{7,XR{{{GET NEXT CODE WORD{14920
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14921
{{EJC{{{{{14922
*
*      ARG
*
{S$ARG{ENT{{{{ENTRY POINT{14926
{{JSR{6,GTSMI{{{GET SECOND ARG AS SMALL INTEGER{14927
{{ERR{1,062{26,ARG second argument is not integer{{{14928
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE OR NEGATIVE{14929
{{MOV{7,XR{8,WA{{SAVE ARGUMENT NUMBER{14930
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{14931
{{JSR{6,GTNVR{{{LOCATE VRBLK{14932
{{PPM{6,SARG1{{{JUMP IF NOT NATURAL VARIABLE{14933
{{MOV{13,VRFNC(XR){7,XR{{ELSE LOAD FUNCTION BLOCK POINTER{14934
{{BNE{9,(XR){22,=B$PFC{6,SARG1{JUMP IF NOT PROGRAM DEFINED{14935
{{BZE{8,WA{6,EXFAL{{FAIL IF ARG NUMBER IS ZERO{14936
{{BGT{8,WA{13,FARGS(XR){6,EXFAL{FAIL IF ARG NUMBER IS TOO LARGE{14937
{{WTB{8,WA{{{ELSE CONVERT TO BYTE OFFSET{14938
{{ADD{8,WA{7,XR{{POINT TO ARGUMENT SELECTED{14939
{{MOV{13,PFAGB(XR){7,XR{{LOAD ARGUMENT VRBLK POINTER{14940
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{14941
*
*      HERE IF 1ST ARGUMENT IS BAD
*
{SARG1{ERB{1,063{26,ARG first argument is not program function name{{{14945
{{EJC{{{{{14946
*
*      ARRAY
*
{S$ARR{ENT{{{{ENTRY POINT{14950
{{MOV{10,(XS)+{7,XL{{LOAD INITIAL ELEMENT VALUE{14951
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{14952
{{JSR{6,GTINT{{{CONVERT FIRST ARG TO INTEGER{14953
{{PPM{6,SAR02{{{JUMP IF NOT INTEGER{14954
*
*      HERE FOR INTEGER FIRST ARGUMENT, BUILD VCBLK
*
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{14958
{{ILE{6,SAR10{{{JUMP IF ZERO OR NEG (BAD DIMENSION){14959
{{MFI{8,WA{6,SAR11{{ELSE CONVERT TO ONE WORD, TEST OVFL{14960
{{JSR{6,VMAKE{{{CREATE VECTOR{14961
{{PPM{6,SAR11{{{FAIL IF TOO LARGE{14962
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{14963
{{EJC{{{{{14964
*
*      ARRAY (CONTINUED)
*
*      HERE IF FIRST ARGUMENT IS NOT AN INTEGER
*
{SAR02{MOV{7,XR{11,-(XS){{REPLACE ARGUMENT ON STACK{14970
{{JSR{6,XSCNI{{{INITIALIZE SCAN OF FIRST ARGUMENT{14971
{{ERR{1,064{26,ARRAY first argument is not integer or string{{{14972
{{PPM{6,EXNUL{{{DUMMY (UNUSED) NULL STRING EXIT{14973
{{MOV{3,R$XSC{11,-(XS){{SAVE PROTOTYPE POINTER{14974
{{MOV{7,XL{11,-(XS){{SAVE DEFAULT VALUE{14975
{{ZER{3,ARCDM{{{ZERO COUNT OF DIMENSIONS{14976
{{ZER{3,ARPTR{{{ZERO OFFSET TO INDICATE PASS ONE{14977
{{LDI{4,INTV1{{{LOAD INTEGER ONE{14978
{{STI{3,ARNEL{{{INITIALIZE ELEMENT COUNT{14979
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. THE FIRST TIME
*      (ARPTR EQ 0), IT IS USED TO COUNT THE NUMBER OF ELEMENTS
*      AND NUMBER OF DIMENSIONS. THE SECOND TIME (ARPTR GT 0) IS
*      USED TO ACTUALLY FILL IN THE DIM,LBD FIELDS OF THE ARBLK.
*
{SAR03{LDI{4,INTV1{{{LOAD ONE AS DEFAULT LOW BOUND{14986
{{STI{3,ARSVL{{{SAVE AS LOW BOUND{14987
{{MOV{18,=CH$CL{8,WC{{SET DELIMITER ONE = COLON{14988
{{MOV{18,=CH$CM{7,XL{{SET DELIMITER TWO = COMMA{14989
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{14990
{{JSR{6,XSCAN{{{SCAN NEXT BOUND{14991
{{BNE{8,WA{18,=NUM01{6,SAR04{JUMP IF NOT COLON{14992
*
*      HERE WE HAVE A COLON ENDING A LOW BOUND
*
{{JSR{6,GTINT{{{CONVERT LOW BOUND{14996
{{ERR{1,065{26,ARRAY first argument lower bound is not integer{{{14997
{{LDI{13,ICVAL(XR){{{LOAD VALUE OF LOW BOUND{14998
{{STI{3,ARSVL{{{STORE LOW BOUND VALUE{14999
{{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{15000
{{MOV{8,WC{7,XL{{AND DELIMITER TWO = COMMA{15001
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{15002
{{JSR{6,XSCAN{{{SCAN HIGH BOUND{15003
{{EJC{{{{{15004
*
*      ARRAY (CONTINUED)
*
*      MERGE HERE TO PROCESS UPPER BOUND
*
{SAR04{JSR{6,GTINT{{{CONVERT HIGH BOUND TO INTEGER{15010
{{ERR{1,066{26,ARRAY first argument upper bound is not integer{{{15011
{{LDI{13,ICVAL(XR){{{GET HIGH BOUND{15012
{{SBI{3,ARSVL{{{SUBTRACT LOWER BOUND{15013
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{15014
{{ILT{6,SAR10{{{BAD DIMENSION IF NEGATIVE{15015
{{ADI{4,INTV1{{{ADD 1 TO GET DIMENSION{15016
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{15017
{{MOV{3,ARPTR{7,XL{{LOAD OFFSET (ALSO PASS INDICATOR){15018
{{BZE{7,XL{6,SAR05{{JUMP IF FIRST PASS{15019
*
*      HERE IN SECOND PASS TO STORE LBD AND DIM IN ARBLK
*
{{ADD{9,(XS){7,XL{{POINT TO CURRENT LOCATION IN ARBLK{15023
{{STI{13,CFP$I(XL){{{STORE DIMENSION{15024
{{LDI{3,ARSVL{{{LOAD LOW BOUND{15025
{{STI{9,(XL){{{STORE LOW BOUND{15026
{{ADD{19,*ARDMS{3,ARPTR{{BUMP OFFSET TO NEXT BOUNDS{15027
{{BRN{6,SAR06{{{JUMP TO CHECK FOR END OF BOUNDS{15028
*
*      HERE IN PASS 1
*
{SAR05{ICV{3,ARCDM{{{BUMP DIMENSION COUNT{15032
{{MLI{3,ARNEL{{{MULTIPLY DIMENSION BY COUNT SO FAR{15033
{{IOV{6,SAR11{{{TOO LARGE IF OVERFLOW{15034
{{STI{3,ARNEL{{{ELSE STORE UPDATED ELEMENT COUNT{15035
*
*      MERGE HERE AFTER PROCESSING ONE SET OF BOUNDS
*
{SAR06{BNZ{8,WA{6,SAR03{{LOOP BACK UNLESS END OF BOUNDS{15039
{{BNZ{3,ARPTR{6,SAR09{{JUMP IF END OF PASS 2{15040
{{EJC{{{{{15041
*
*      ARRAY (CONTINUED)
*
*      HERE AT END OF PASS ONE, BUILD ARBLK
*
{{LDI{3,ARNEL{{{GET NUMBER OF ELEMENTS{15047
{{MFI{8,WB{6,SAR11{{GET AS ADDR INTEGER, TEST OVFLO{15048
{{WTB{8,WB{{{ELSE CONVERT TO LENGTH IN BYTES{15049
{{MOV{19,*ARSI${8,WA{{SET SIZE OF STANDARD FIELDS{15050
{{LCT{8,WC{3,ARCDM{{SET DIMENSION COUNT TO CONTROL LOOP{15051
*
*      LOOP TO ALLOW SPACE FOR DIMENSIONS
*
{SAR07{ADD{19,*ARDMS{8,WA{{ALLOW SPACE FOR ONE SET OF BOUNDS{15055
{{BCT{8,WC{6,SAR07{{LOOP BACK TILL ALL ACCOUNTED FOR{15056
{{MOV{8,WA{7,XL{{SAVE SIZE (=AROFS){15057
*
*      NOW ALLOCATE SPACE FOR ARBLK
*
{{ADD{8,WB{8,WA{{ADD SPACE FOR ELEMENTS{15061
{{ICA{8,WA{{{ALLOW FOR ARPRO PROTOTYPE FIELD{15062
{{BGT{8,WA{3,MXLEN{6,SAR11{FAIL IF TOO LARGE{15063
{{JSR{6,ALLOC{{{ELSE ALLOCATE ARBLK{15064
{{MOV{9,(XS){8,WB{{LOAD DEFAULT VALUE{15065
{{MOV{7,XR{9,(XS){{SAVE ARBLK POINTER{15066
{{MOV{8,WA{8,WC{{SAVE LENGTH IN BYTES{15067
{{BTW{8,WA{{{CONVERT LENGTH BACK TO WORDS{15068
{{LCT{8,WA{8,WA{{SET COUNTER TO CONTROL LOOP{15069
*
*      LOOP TO CLEAR ENTIRE ARBLK TO DEFAULT VALUE
*
{SAR08{MOV{8,WB{10,(XR)+{{SET ONE WORD{15073
{{BCT{8,WA{6,SAR08{{LOOP TILL ALL SET{15074
{{EJC{{{{{15075
*
*      ARRAY (CONTINUED)
*
*      NOW SET INITIAL FIELDS OF ARBLK
*
{{MOV{10,(XS)+{7,XR{{RELOAD ARBLK POINTER{15081
{{MOV{9,(XS){8,WB{{LOAD PROTOTYPE{15082
{{MOV{22,=B$ART{9,(XR){{SET TYPE WORD{15083
{{MOV{8,WC{13,ARLEN(XR){{STORE LENGTH IN BYTES{15084
{{ZER{13,IDVAL(XR){{{ZERO ID TILL WE GET IT BUILT{15085
{{MOV{7,XL{13,AROFS(XR){{SET PROTOTYPE FIELD PTR{15086
{{MOV{3,ARCDM{13,ARNDM(XR){{SET NUMBER OF DIMENSIONS{15087
{{MOV{7,XR{8,WC{{SAVE ARBLK POINTER{15088
{{ADD{7,XL{7,XR{{POINT TO PROTOTYPE FIELD{15089
{{MOV{8,WB{9,(XR){{STORE PROTOTYPE PTR IN ARBLK{15090
{{MOV{19,*ARLBD{3,ARPTR{{SET OFFSET FOR PASS 2 BOUNDS SCAN{15091
{{MOV{8,WB{3,R$XSC{{RESET STRING POINTER FOR XSCAN{15092
{{MOV{8,WC{9,(XS){{STORE ARBLK POINTER ON STACK{15093
{{ZER{3,XSOFS{{{RESET OFFSET PTR TO START OF STRING{15094
{{BRN{6,SAR03{{{JUMP BACK TO RESCAN BOUNDS{15095
*
*      HERE AFTER FILLING IN BOUNDS INFORMATION (END PASS TWO)
*
{SAR09{MOV{10,(XS)+{7,XR{{RELOAD POINTER TO ARBLK{15099
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{15100
*
*      HERE FOR BAD DIMENSION
*
{SAR10{ERB{1,067{26,ARRAY dimension is zero, negative or out of range{{{15104
*
*      HERE IF ARRAY IS TOO LARGE
*
{SAR11{ERB{1,068{26,ARRAY size exceeds maximum permitted{{{15108
{{EJC{{{{{15109
*
*      ATAN
*
{S$ATN{ENT{{{{ENTRY POINT{15114
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15115
{{JSR{6,GTREA{{{CONVERT TO REAL{15116
{{ERR{1,301{26,ATAN argument not numeric{{{15117
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15118
{{ATN{{{{TAKE ARCTANGENT{15119
{{BRN{6,EXREA{{{OVERFLOW, OUT OF RANGE NOT POSSIBLE{15120
{{EJC{{{{{15121
{{EJC{{{{{15124
*
*      BACKSPACE
*
{S$BSP{ENT{{{{ENTRY POINT{15128
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{15129
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{15130
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{15131
{{ERR{1,317{26,BACKSPACE file does not exist{{{15132
{{JSR{6,SYSBS{{{CALL BACKSPACE FILE FUNCTION{15133
{{ERR{1,317{26,BACKSPACE file does not exist{{{15134
{{ERR{1,318{26,BACKSPACE file does not permit backspace{{{15135
{{ERR{1,319{26,BACKSPACE caused non-recoverable error{{{15136
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{15137
{{EJC{{{{{15138
*
*      BREAK
*
{S$BRK{ENT{{{{ENTRY POINT{15171
{{MOV{22,=P$BKS{8,WB{{SET PCODE FOR SINGLE CHAR CASE{15172
{{MOV{22,=P$BRK{7,XL{{PCODE FOR MULTI-CHAR CASE{15173
{{MOV{22,=P$BKD{8,WC{{PCODE FOR EXPRESSION CASE{15174
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{15175
{{ERR{1,069{26,BREAK argument is not a string or expression{{{15176
{{MOV{7,XR{11,-(XS){{STACK RESULT{15177
{{LCW{7,XR{{{GET NEXT CODE WORD{15178
{{BRI{9,(XR){{{EXECUTE IT{15179
{{EJC{{{{{15180
*
*      BREAKX
*
*      BREAKX IS A COMPOUND PATTERN. SEE DESCRIPTION AT START
*      OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S$BKX{ENT{{{{ENTRY POINT{15187
{{MOV{22,=P$BKS{8,WB{{PCODE FOR SINGLE CHAR ARGUMENT{15188
{{MOV{22,=P$BRK{7,XL{{PCODE FOR MULTI-CHAR ARGUMENT{15189
{{MOV{22,=P$BXD{8,WC{{PCODE FOR EXPRESSION CASE{15190
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{15191
{{ERR{1,070{26,BREAKX argument is not a string or expression{{{15192
*
*      NOW HOOK BREAKX NODE ON AT FRONT END
*
{{MOV{7,XR{11,-(XS){{SAVE PTR TO BREAK NODE{15196
{{MOV{22,=P$BKX{8,WB{{SET PCODE FOR BREAKX NODE{15197
{{JSR{6,PBILD{{{BUILD IT{15198
{{MOV{9,(XS){13,PTHEN(XR){{SET BREAK NODE AS SUCCESSOR{15199
{{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATION NODE{15200
{{JSR{6,PBILD{{{BUILD (PARM1=ALT=BREAKX NODE){15201
{{MOV{7,XR{8,WA{{SAVE PTR TO ALTERNATION NODE{15202
{{MOV{9,(XS){7,XR{{POINT TO BREAK NODE{15203
{{MOV{8,WA{13,PTHEN(XR){{SET ALTERNATE NODE AS SUCCESSOR{15204
{{LCW{7,XR{{{RESULT ON STACK{15205
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{15206
{{EJC{{{{{15207
*
*      CHAR
*
{S$CHR{ENT{{{{ENTRY POINT{15211
{{JSR{6,GTSMI{{{CONVERT ARG TO INTEGER{15212
{{ERR{1,281{26,CHAR argument not integer{{{15213
{{PPM{6,SCHR1{{{TOO BIG ERROR EXIT{15214
{{BGE{8,WC{18,=CFP$A{6,SCHR1{SEE IF OUT OF RANGE OF HOST SET{15215
{{MOV{18,=NUM01{8,WA{{IF NOT SET SCBLK ALLOCATION{15216
{{MOV{8,WC{8,WB{{SAVE CHAR CODE{15217
{{JSR{6,ALOCS{{{ALLOCATE 1 BAU SCBLK{15218
{{MOV{7,XR{7,XL{{COPY SCBLK POINTER{15219
{{PSC{7,XL{{{GET SET TO STUFF CHAR{15220
{{SCH{8,WB{9,(XL){{STUFF IT{15221
{{CSC{7,XL{{{COMPLETE STORE CHARACTER{15222
{{ZER{7,XL{{{CLEAR SLOP IN XL{15223
{{MOV{7,XR{11,-(XS){{STACK RESULT{15224
{{LCW{7,XR{{{GET NEXT CODE WORD{15225
{{BRI{9,(XR){{{EXECUTE IT{15226
*
*      HERE IF CHAR ARGUMENT IS OUT OF RANGE
*
{SCHR1{ERB{1,282{26,CHAR argument not in range{{{15230
{{EJC{{{{{15231
*
*      CHOP
*
{S$CHP{ENT{{{{ENTRY POINT{15236
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15237
{{JSR{6,GTREA{{{CONVERT TO REAL{15238
{{ERR{1,302{26,CHOP argument not numeric{{{15239
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15240
{{CHP{{{{TRUNCATE TO INTEGER VALUED REAL{15241
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE{15242
{{EJC{{{{{15243
*
*      CLEAR
*
{S$CLR{ENT{{{{ENTRY POINT{15248
{{JSR{6,XSCNI{{{INITIALIZE TO SCAN ARGUMENT{15249
{{ERR{1,071{26,CLEAR argument is not a string{{{15250
{{PPM{6,SCLR2{{{JUMP IF NULL{15251
*
*      LOOP TO SCAN OUT NAMES IN FIRST ARGUMENT. VARIABLES IN
*      THE LIST ARE FLAGGED BY SETTING VRGET OF VRBLK TO ZERO.
*
{SCLR1{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{15256
{{MOV{8,WC{7,XL{{DELIMITER TWO = COMMA{15257
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15258
{{JSR{6,XSCAN{{{SCAN NEXT VARIABLE NAME{15259
{{JSR{6,GTNVR{{{LOCATE VRBLK{15260
{{ERR{1,072{26,CLEAR argument has null variable name{{{15261
{{ZER{13,VRGET(XR){{{ELSE FLAG BY ZEROING VRGET FIELD{15262
{{BNZ{8,WA{6,SCLR1{{LOOP BACK IF STOPPED BY COMMA{15263
*
*      HERE AFTER FLAGGING VARIABLES IN ARGUMENT LIST
*
{SCLR2{MOV{3,HSHTB{8,WB{{POINT TO START OF HASH TABLE{15267
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
{SCLR3{BEQ{8,WB{3,HSHTE{6,EXNUL{EXIT RETURNING NULL IF NONE LEFT{15271
{{MOV{8,WB{7,XR{{ELSE COPY SLOT POINTER{15272
{{ICA{8,WB{{{BUMP SLOT POINTER{15273
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE INTO LOOP{15274
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{SCLR4{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{15278
{{BZE{7,XR{6,SCLR3{{JUMP FOR NEXT BUCKET IF CHAIN END{15279
{{BNZ{13,VRGET(XR){6,SCLR5{{JUMP IF NOT FLAGGED{15280
{{EJC{{{{{15281
*
*      CLEAR (CONTINUED)
*
*      HERE FOR FLAGGED VARIABLE, DO NOT SET VALUE TO NULL
*
{{JSR{6,SETVR{{{FOR FLAGGED VAR, RESTORE VRGET{15287
{{BRN{6,SCLR4{{{AND LOOP BACK FOR NEXT VRBLK{15288
*
*      HERE TO SET VALUE OF A VARIABLE TO NULL
*      PROTECTED VARIABLES (ARB, ETC) ARE EXEMPT
*
{SCLR5{BEQ{13,VRSTO(XR){22,=B$VRE{6,SCLR4{CHECK FOR PROTECTED VARIABLE{15293
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{15294
*
*      LOOP TO LOCATE VALUE AT END OF POSSIBLE TRBLK CHAIN
*
{SCLR6{MOV{7,XL{8,WA{{SAVE BLOCK POINTER{15298
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE FIELD{15299
{{BEQ{9,(XL){22,=B$TRT{6,SCLR6{LOOP BACK IF TRAPPED{15300
*
*      NOW STORE THE NULL VALUE
*
{{MOV{8,WA{7,XL{{RESTORE BLOCK POINTER{15304
{{MOV{21,=NULLS{13,VRVAL(XL){{STORE NULL CONSTANT VALUE{15305
{{BRN{6,SCLR4{{{LOOP BACK FOR NEXT VRBLK{15306
{{EJC{{{{{15307
*
*      CODE
*
{S$COD{ENT{{{{ENTRY POINT{15311
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15312
{{JSR{6,GTCOD{{{CONVERT TO CODE{15313
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS IMPOSSIBLE{15314
{{MOV{7,XR{11,-(XS){{STACK RESULT{15315
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15316
{{LCW{7,XR{{{GET NEXT CODE WORD{15317
{{BRI{9,(XR){{{EXECUTE IT{15318
{{EJC{{{{{15319
*
*      COLLECT
*
{S$COL{ENT{{{{ENTRY POINT{15323
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15324
{{JSR{6,GTINT{{{CONVERT TO INTEGER{15325
{{ERR{1,073{26,COLLECT argument is not integer{{{15326
{{LDI{13,ICVAL(XR){{{LOAD COLLECT ARGUMENT{15327
{{STI{3,CLSVI{{{SAVE COLLECT ARGUMENT{15328
{{ZER{8,WB{{{SET NO MOVE UP{15329
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15330
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{15332
{{JSR{6,GBCOL{{{PERFORM GARBAGE COLLECTION{15333
{{MOV{7,XR{3,DNAMS{{RECORD NEW SEDIMENT SIZE{15334
{{MOV{3,DNAME{8,WA{{POINT TO END OF MEMORY{15338
{{SUB{3,DNAMP{8,WA{{SUBTRACT NEXT LOCATION{15339
{{BTW{8,WA{{{CONVERT BYTES TO WORDS{15340
{{MTI{8,WA{{{CONVERT WORDS AVAILABLE AS INTEGER{15341
{{SBI{3,CLSVI{{{SUBTRACT ARGUMENT{15342
{{IOV{6,EXFAL{{{FAIL IF OVERFLOW{15343
{{ILT{6,EXFAL{{{FAIL IF NOT ENOUGH{15344
{{ADI{3,CLSVI{{{ELSE RECOMPUTE AVAILABLE{15345
{{BRN{6,EXINT{{{AND EXIT WITH INTEGER RESULT{15346
{{EJC{{{{{15347
*
*      CONVERT
*
{S$CNV{ENT{{{{ENTRY POINT{15376
{{JSR{6,GTSTG{{{CONVERT SECOND ARGUMENT TO STRING{15377
{{PPM{6,SCV29{{{ERROR IF SECOND ARGUMENT NOT STRING{15378
{{BZE{8,WA{6,SCV29{{OR IF NULL STRING{15379
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{15381
{{MOV{9,(XS){7,XL{{LOAD FIRST ARGUMENT{15383
{{BNE{9,(XL){22,=B$PDT{6,SCV01{JUMP IF NOT PROGRAM DEFINED{15384
*
*      HERE FOR PROGRAM DEFINED DATATYPE
*
{{MOV{13,PDDFP(XL){7,XL{{POINT TO DFBLK{15388
{{MOV{13,DFNAM(XL){7,XL{{LOAD DATATYPE NAME{15389
{{JSR{6,IDENT{{{COMPARE WITH SECOND ARG{15390
{{PPM{6,EXITS{{{EXIT IF IDENT WITH ARG AS RESULT{15391
{{BRN{6,EXFAL{{{ELSE FAIL{15392
*
*      HERE IF NOT PROGRAM DEFINED DATATYPE
*
{SCV01{MOV{7,XR{11,-(XS){{SAVE STRING ARGUMENT{15396
{{MOV{21,=SVCTB{7,XL{{POINT TO TABLE OF NAMES TO COMPARE{15397
{{ZER{8,WB{{{INITIALIZE COUNTER{15398
{{MOV{8,WA{8,WC{{SAVE LENGTH OF ARGUMENT STRING{15399
*
*      LOOP THROUGH TABLE ENTRIES
*
{SCV02{MOV{10,(XL)+{7,XR{{LOAD NEXT TABLE ENTRY, BUMP POINTER{15403
{{BZE{7,XR{6,EXFAL{{FAIL IF ZERO MARKING END OF LIST{15404
{{BNE{8,WC{13,SCLEN(XR){6,SCV05{JUMP IF WRONG LENGTH{15405
{{MOV{7,XL{3,CNVTP{{ELSE STORE TABLE POINTER{15406
{{PLC{7,XR{{{POINT TO CHARS OF TABLE ENTRY{15407
{{MOV{9,(XS){7,XL{{LOAD POINTER TO STRING ARGUMENT{15408
{{PLC{7,XL{{{POINT TO CHARS OF STRING ARG{15409
{{MOV{8,WC{8,WA{{SET NUMBER OF CHARS TO COMPARE{15410
{{CMC{6,SCV04{6,SCV04{{COMPARE, JUMP IF NO MATCH{15411
{{EJC{{{{{15412
*
*      CONVERT (CONTINUED)
*
*      HERE WE HAVE A MATCH
*
{SCV03{MOV{8,WB{7,XL{{COPY ENTRY NUMBER{15418
{{ICA{7,XS{{{POP STRING ARG OFF STACK{15419
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{15420
{{BSW{7,XL{2,CNVTT{{JUMP TO APPROPRIATE ROUTINE{15421
{{IFF{1,0{6,SCV06{{STRING{15439
{{IFF{1,1{6,SCV07{{INTEGER{15439
{{IFF{1,2{6,SCV09{{NAME{15439
{{IFF{1,3{6,SCV10{{PATTERN{15439
{{IFF{1,4{6,SCV11{{ARRAY{15439
{{IFF{1,5{6,SCV19{{TABLE{15439
{{IFF{1,6{6,SCV25{{EXPRESSION{15439
{{IFF{1,7{6,SCV26{{CODE{15439
{{IFF{1,8{6,SCV27{{NUMERIC{15439
{{IFF{2,CNVRT{6,SCV08{{REAL{15439
{{ESW{{{{END OF SWITCH TABLE{15439
*
*      HERE IF NO MATCH WITH TABLE ENTRY
*
{SCV04{MOV{3,CNVTP{7,XL{{RESTORE TABLE POINTER, MERGE{15443
*
*      MERGE HERE IF LENGTHS DID NOT MATCH
*
{SCV05{ICV{8,WB{{{BUMP ENTRY NUMBER{15447
{{BRN{6,SCV02{{{LOOP BACK TO CHECK NEXT ENTRY{15448
*
*      HERE TO CONVERT TO STRING
*
{SCV06{MOV{7,XR{11,-(XS){{REPLACE STRING ARGUMENT ON STACK{15452
{{JSR{6,GTSTG{{{CONVERT TO STRING{15453
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15454
{{MOV{7,XR{11,-(XS){{STACK RESULT{15455
{{LCW{7,XR{{{GET NEXT CODE WORD{15456
{{BRI{9,(XR){{{EXECUTE IT{15457
{{EJC{{{{{15458
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT TO INTEGER
*
{SCV07{JSR{6,GTINT{{{CONVERT TO INTEGER{15464
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15465
{{MOV{7,XR{11,-(XS){{STACK RESULT{15466
{{LCW{7,XR{{{GET NEXT CODE WORD{15467
{{BRI{9,(XR){{{EXECUTE IT{15468
*
*      HERE TO CONVERT TO REAL
*
{SCV08{JSR{6,GTREA{{{CONVERT TO REAL{15474
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15475
{{MOV{7,XR{11,-(XS){{STACK RESULT{15476
{{LCW{7,XR{{{GET NEXT CODE WORD{15477
{{BRI{9,(XR){{{EXECUTE IT{15478
*
*      HERE TO CONVERT TO NAME
*
{SCV09{BEQ{9,(XR){22,=B$NML{6,EXIXR{RETURN IF ALREADY A NAME{15483
{{JSR{6,GTNVR{{{ELSE TRY STRING TO NAME CONVERT{15484
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15485
{{BRN{6,EXVNM{{{ELSE EXIT BUILDING NMBLK FOR VRBLK{15486
*
*      HERE TO CONVERT TO PATTERN
*
{SCV10{JSR{6,GTPAT{{{CONVERT TO PATTERN{15490
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15491
{{MOV{7,XR{11,-(XS){{STACK RESULT{15492
{{LCW{7,XR{{{GET NEXT CODE WORD{15493
{{BRI{9,(XR){{{EXECUTE IT{15494
*
*      CONVERT TO ARRAY
*
*      IF THE FIRST ARGUMENT IS A TABLE, THEN WE GO THROUGH
*      AN INTERMEDIATE ARRAY OF ADDRESSES THAT IS SORTED TO
*      PROVIDE A RESULT ORDERED BY TIME OF ENTRY IN THE
*      ORIGINAL TABLE.  SEE C3.762.
*
{SCV11{MOV{7,XR{11,-(XS){{SAVE ARGUMENT ON STACK{15503
{{ZER{8,WA{{{USE TABLE CHAIN BLOCK ADDRESSES{15504
{{JSR{6,GTARR{{{GET AN ARRAY{15505
{{PPM{6,EXFAL{{{FAIL IF EMPTY TABLE{15506
{{PPM{6,EXFAL{{{FAIL IF NOT CONVERTIBLE{15507
{{MOV{10,(XS)+{7,XL{{RELOAD ORIGINAL ARG{15508
{{BNE{9,(XL){22,=B$TBT{6,EXSID{EXIT IF ORIGINAL NOT A TABLE{15509
{{MOV{7,XR{11,-(XS){{SORT THE INTERMEDIATE ARRAY{15510
{{MOV{21,=NULLS{11,-(XS){{ON FIRST COLUMN{15511
{{ZER{8,WA{{{SORT ASCENDING{15512
{{JSR{6,SORTA{{{DO SORT{15513
{{PPM{6,EXFAL{{{IF SORT FAILS, SO SHALL WE{15514
{{MOV{7,XR{8,WB{{SAVE ARRAY RESULT{15515
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){15516
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{15517
{{LCT{8,WA{8,WA{{COPY TO CONTROL LOOP{15518
{{ADD{19,*ARVL2{7,XR{{POINT TO FIRST ELEMENT IN ARRAY{15519
*
*      HERE FOR EACH ROW OF THIS 2-COLUMN ARRAY
*
{SCV12{MOV{9,(XR){7,XL{{GET TEBLK ADDRESS{15523
{{MOV{13,TESUB(XL){10,(XR)+{{REPLACE WITH SUBSCRIPT{15524
{{MOV{13,TEVAL(XL){10,(XR)+{{REPLACE WITH VALUE{15525
{{BCT{8,WA{6,SCV12{{LOOP TILL ALL COPIED OVER{15526
{{MOV{8,WB{7,XR{{RETRIEVE ARRAY ADDRESS{15527
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{15528
*
*      CONVERT TO TABLE
*
{SCV19{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{15532
{{MOV{7,XR{11,-(XS){{REPLACE ARBLK POINTER ON STACK{15533
{{BEQ{8,WA{22,=B$TBT{6,EXITS{RETURN ARG IF ALREADY A TABLE{15534
{{BNE{8,WA{22,=B$ART{6,EXFAL{ELSE FAIL IF NOT AN ARRAY{15535
{{EJC{{{{{15536
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT AN ARRAY TO TABLE
*
{{BNE{13,ARNDM(XR){18,=NUM02{6,EXFAL{FAIL IF NOT 2-DIM ARRAY{15542
{{LDI{13,ARDM2(XR){{{LOAD DIM 2{15543
{{SBI{4,INTV2{{{SUBTRACT 2 TO COMPARE{15544
{{INE{6,EXFAL{{{FAIL IF DIM2 NOT 2{15545
*
*      HERE WE HAVE AN ARBLK OF THE RIGHT SHAPE
*
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){15549
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{15550
{{LCT{8,WB{8,WA{{COPY TO CONTROL LOOP{15551
{{ADD{18,=TBSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{15552
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15553
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{15554
{{MOV{7,XR{8,WC{{COPY TBBLK POINTER{15555
{{MOV{7,XR{11,-(XS){{SAVE TBBLK POINTER{15556
{{MOV{22,=B$TBT{10,(XR)+{{STORE TYPE WORD{15557
{{ZER{10,(XR)+{{{STORE ZERO FOR IDVAL FOR NOW{15558
{{MOV{8,WA{10,(XR)+{{STORE LENGTH{15559
{{MOV{21,=NULLS{10,(XR)+{{NULL INITIAL LOOKUP VALUE{15560
*
*      LOOP TO INITIALIZE BUCKET PTRS TO POINT TO TABLE
*
{SCV20{MOV{8,WC{10,(XR)+{{SET BUCKET PTR TO POINT TO TBBLK{15564
{{BCT{8,WB{6,SCV20{{LOOP TILL ALL INITIALIZED{15565
{{MOV{19,*ARVL2{8,WB{{SET OFFSET TO FIRST ARBLK ELEMENT{15566
*
*      LOOP TO COPY ELEMENTS FROM ARRAY TO TABLE
*
{SCV21{MOV{13,NUM01(XS){7,XL{{POINT TO ARBLK{15570
{{BEQ{8,WB{13,ARLEN(XL){6,SCV24{JUMP IF ALL MOVED{15571
{{ADD{8,WB{7,XL{{ELSE POINT TO CURRENT LOCATION{15572
{{ADD{19,*NUM02{8,WB{{BUMP OFFSET{15573
{{MOV{9,(XL){7,XR{{LOAD SUBSCRIPT NAME{15574
{{DCA{7,XL{{{ADJUST PTR TO MERGE (TRVAL=1+1){15575
{{EJC{{{{{15576
*
*      CONVERT (CONTINUED)
*
*      LOOP TO CHASE DOWN TRBLK CHAIN FOR VALUE
*
{SCV22{MOV{13,TRVAL(XL){7,XL{{POINT TO NEXT VALUE{15582
{{BEQ{9,(XL){22,=B$TRT{6,SCV22{LOOP BACK IF TRAPPED{15583
*
*      HERE WITH NAME IN XR, VALUE IN XL
*
{SCV23{MOV{7,XL{11,-(XS){{STACK VALUE{15587
{{MOV{13,NUM01(XS){7,XL{{LOAD TBBLK POINTER{15588
{{JSR{6,TFIND{{{BUILD TEBLK (NOTE WB GT 0 BY NAME){15589
{{PPM{6,EXFAL{{{FAIL IF ACESS FAILS{15590
{{MOV{10,(XS)+{13,TEVAL(XL){{STORE VALUE IN TEBLK{15591
{{BRN{6,SCV21{{{LOOP BACK FOR NEXT ELEMENT{15592
*
*      HERE AFTER MOVING ALL ELEMENTS TO TBBLK
*
{SCV24{MOV{10,(XS)+{7,XR{{LOAD TBBLK POINTER{15596
{{ICA{7,XS{{{POP ARBLK POINTER{15597
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{15598
*
*      CONVERT TO EXPRESSION
*
{SCV25{ZER{8,WB{{{BY VALUE{15603
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{15604
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15608
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15609
{{MOV{7,XR{11,-(XS){{STACK RESULT{15610
{{LCW{7,XR{{{GET NEXT CODE WORD{15611
{{BRI{9,(XR){{{EXECUTE IT{15612
*
*      CONVERT TO CODE
*
{SCV26{JSR{6,GTCOD{{{CONVERT TO CODE{15616
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS NOT POSSIBLE{15617
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15618
{{MOV{7,XR{11,-(XS){{STACK RESULT{15619
{{LCW{7,XR{{{GET NEXT CODE WORD{15620
{{BRI{9,(XR){{{EXECUTE IT{15621
*
*      CONVERT TO NUMERIC
*
{SCV27{JSR{6,GTNUM{{{CONVERT TO NUMERIC{15625
{{PPM{6,EXFAL{{{FAIL IF UNCONVERTIBLE{15626
{SCV31{MOV{7,XR{11,-(XS){{STACK RESULT{15627
{{LCW{7,XR{{{GET NEXT CODE WORD{15628
{{BRI{9,(XR){{{EXECUTE IT{15629
{{EJC{{{{{15630
*
*      SECOND ARGUMENT NOT STRING OR NULL
*
{SCV29{ERB{1,074{26,CONVERT second argument is not a string{{{15656
*
*      COPY
*
{S$COP{ENT{{{{ENTRY POINT{15660
{{JSR{6,COPYB{{{COPY THE BLOCK{15661
{{PPM{6,EXITS{{{RETURN IF NO IDVAL FIELD{15662
{{BRN{6,EXSID{{{EXIT SETTING ID VALUE{15663
{{EJC{{{{{15664
*
*      COS
*
{S$COS{ENT{{{{ENTRY POINT{15669
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15670
{{JSR{6,GTREA{{{CONVERT TO REAL{15671
{{ERR{1,303{26,COS argument not numeric{{{15672
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15673
{{COS{{{{TAKE COSINE{15674
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{15675
{{ERB{1,322{26,COS argument is out of range{{{15676
{{EJC{{{{{15677
*
*      DATA
*
{S$DAT{ENT{{{{ENTRY POINT{15682
{{JSR{6,XSCNI{{{PREPARE TO SCAN ARGUMENT{15683
{{ERR{1,075{26,DATA argument is not a string{{{15684
{{ERR{1,076{26,DATA argument is null{{{15685
*
*      SCAN OUT DATATYPE NAME
*
{{MOV{18,=CH$PP{8,WC{{DELIMITER ONE = LEFT PAREN{15689
{{MOV{8,WC{7,XL{{DELIMITER TWO = LEFT PAREN{15690
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15691
{{JSR{6,XSCAN{{{SCAN DATATYPE NAME{15692
{{BNZ{8,WA{6,SDAT1{{SKIP IF LEFT PAREN FOUND{15693
{{ERB{1,077{26,DATA argument is missing a left paren{{{15694
*
*      HERE AFTER SCANNING DATATYPE NAME
*
{SDAT1{MOV{13,SCLEN(XR){8,WA{{GET LENGTH{15699
{{BZE{8,WA{6,SDT1A{{AVOID FOLDING IF NULL STRING{15700
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{15701
{SDT1A{MOV{7,XR{7,XL{{SAVE NAME PTR{15702
{{MOV{13,SCLEN(XR){8,WA{{GET LENGTH{15706
{{CTB{8,WA{2,SCSI${{COMPUTE SPACE NEEDED{15707
{{JSR{6,ALOST{{{REQUEST STATIC STORE FOR NAME{15708
{{MOV{7,XR{11,-(XS){{SAVE DATATYPE NAME{15709
{{MVW{{{{COPY NAME TO STATIC{15710
{{MOV{9,(XS){7,XR{{GET NAME PTR{15711
{{ZER{7,XL{{{SCRUB DUD REGISTER{15712
{{JSR{6,GTNVR{{{LOCATE VRBLK FOR DATATYPE NAME{15713
{{ERR{1,078{26,DATA argument has null datatype name{{{15714
{{MOV{7,XR{3,DATDV{{SAVE VRBLK POINTER FOR DATATYPE{15715
{{MOV{7,XS{3,DATXS{{STORE STARTING STACK VALUE{15716
{{ZER{8,WB{{{ZERO COUNT OF FIELD NAMES{15717
*
*      LOOP TO SCAN FIELD NAMES AND STACK VRBLK POINTERS
*
{SDAT2{MOV{18,=CH$RP{8,WC{{DELIMITER ONE = RIGHT PAREN{15721
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO = COMMA{15722
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15723
{{JSR{6,XSCAN{{{SCAN NEXT FIELD NAME{15724
{{BNZ{8,WA{6,SDAT3{{JUMP IF DELIMITER FOUND{15725
{{ERB{1,079{26,DATA argument is missing a right paren{{{15726
*
*      HERE AFTER SCANNING OUT ONE FIELD NAME
*
{SDAT3{JSR{6,GTNVR{{{LOCATE VRBLK FOR FIELD NAME{15730
{{ERR{1,080{26,DATA argument has null field name{{{15731
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{15732
{{ICV{8,WB{{{INCREMENT COUNTER{15733
{{BEQ{8,WA{18,=NUM02{6,SDAT2{LOOP BACK IF STOPPED BY COMMA{15734
{{EJC{{{{{15735
*
*      DATA (CONTINUED)
*
*      NOW BUILD THE DFBLK
*
{{MOV{18,=DFSI${8,WA{{SET SIZE OF DFBLK STANDARD FIELDS{15741
{{ADD{8,WB{8,WA{{ADD NUMBER OF FIELDS{15742
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15743
{{MOV{8,WB{8,WC{{PRESERVE NO. OF FIELDS{15744
{{JSR{6,ALOST{{{ALLOCATE SPACE FOR DFBLK{15745
{{MOV{8,WC{8,WB{{GET NO OF FIELDS{15746
{{MOV{3,DATXS{7,XT{{POINT TO START OF STACK{15747
{{MOV{9,(XT){8,WC{{LOAD DATATYPE NAME{15748
{{MOV{7,XR{9,(XT){{SAVE DFBLK POINTER ON STACK{15749
{{MOV{22,=B$DFC{10,(XR)+{{STORE TYPE WORD{15750
{{MOV{8,WB{10,(XR)+{{STORE NUMBER OF FIELDS (FARGS){15751
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (DFLEN){15752
{{SUB{19,*PDDFS{8,WA{{COMPUTE PDBLK LENGTH (FOR DFPDL){15753
{{MOV{8,WA{10,(XR)+{{STORE PDBLK LENGTH (DFPDL){15754
{{MOV{8,WC{10,(XR)+{{STORE DATATYPE NAME (DFNAM){15755
{{LCT{8,WC{8,WB{{COPY NUMBER OF FIELDS{15756
*
*      LOOP TO MOVE FIELD NAME VRBLK POINTERS TO DFBLK
*
{SDAT4{MOV{11,-(XT){10,(XR)+{{MOVE ONE FIELD NAME VRBLK POINTER{15760
{{BCT{8,WC{6,SDAT4{{LOOP TILL ALL MOVED{15761
*
*      NOW DEFINE THE DATATYPE FUNCTION
*
{{MOV{8,WA{8,WC{{COPY LENGTH OF PDBLK FOR LATER LOOP{15765
{{MOV{3,DATDV{7,XR{{POINT TO VRBLK{15766
{{MOV{3,DATXS{7,XT{{POINT BACK ON STACK{15767
{{MOV{9,(XT){7,XL{{LOAD DFBLK POINTER{15768
{{JSR{6,DFFNC{{{DEFINE FUNCTION{15769
{{EJC{{{{{15770
*
*      DATA (CONTINUED)
*
*      LOOP TO BUILD FFBLKS
*
*
*      NOTICE THAT THE FFBLKS ARE CONSTRUCTED IN REVERSE ORDER
*      SO THAT THE REQUIRED OFFSETS CAN BE OBTAINED FROM
*      SUCCESSIVE DECREMENTATION OF THE PDBLK LENGTH (IN WC).
*
{SDAT5{MOV{19,*FFSI${8,WA{{SET LENGTH OF FFBLK{15781
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR FFBLK{15782
{{MOV{22,=B$FFC{9,(XR){{SET TYPE WORD{15783
{{MOV{18,=NUM01{13,FARGS(XR){{STORE FARGS (ALWAYS ONE){15784
{{MOV{3,DATXS{7,XT{{POINT BACK ON STACK{15785
{{MOV{9,(XT){13,FFDFP(XR){{COPY DFBLK PTR TO FFBLK{15786
{{DCA{8,WC{{{DECREMENT OLD DFPDL TO GET NEXT OFS{15787
{{MOV{8,WC{13,FFOFS(XR){{SET OFFSET TO THIS FIELD{15788
{{ZER{13,FFNXT(XR){{{TENTATIVELY SET ZERO FORWARD PTR{15789
{{MOV{7,XR{7,XL{{COPY FFBLK POINTER FOR DFFNC{15790
{{MOV{9,(XS){7,XR{{LOAD VRBLK POINTER FOR FIELD{15791
{{MOV{13,VRFNC(XR){7,XR{{LOAD CURRENT FUNCTION POINTER{15792
{{BNE{9,(XR){22,=B$FFC{6,SDAT6{SKIP IF NOT CURRENTLY A FIELD FUNC{15793
*
*      HERE WE MUST CHAIN AN OLD FFBLK PTR TO PRESERVE IT IN THE
*      CASE OF MULTIPLE FIELD FUNCTIONS WITH THE SAME NAME
*
{{MOV{7,XR{13,FFNXT(XL){{LINK NEW FFBLK TO PREVIOUS CHAIN{15798
*
*      MERGE HERE TO DEFINE FIELD FUNCTION
*
{SDAT6{MOV{10,(XS)+{7,XR{{LOAD VRBLK POINTER{15802
{{JSR{6,DFFNC{{{DEFINE FIELD FUNCTION{15803
{{BNE{7,XS{3,DATXS{6,SDAT5{LOOP BACK TILL ALL DONE{15804
{{ICA{7,XS{{{POP DFBLK POINTER{15805
{{BRN{6,EXNUL{{{RETURN WITH NULL RESULT{15806
{{EJC{{{{{15807
*
*      DATATYPE
*
{S$DTP{ENT{{{{ENTRY POINT{15811
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15812
{{JSR{6,DTYPE{{{GET DATATYPE{15813
{{MOV{7,XR{11,-(XS){{STACK RESULT{15814
{{LCW{7,XR{{{GET NEXT CODE WORD{15815
{{BRI{9,(XR){{{EXECUTE IT{15816
{{EJC{{{{{15817
*
*      DATE
*
{S$DTE{ENT{{{{ENTRY POINT{15821
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15822
{{JSR{6,GTINT{{{CONVERT TO AN INTEGER{15823
{{ERR{1,330{26,DATE argument is not integer{{{15824
{{JSR{6,SYSDT{{{CALL SYSTEM DATE ROUTINE{15825
{{MOV{13,NUM01(XL){8,WA{{LOAD LENGTH FOR SBSTR{15826
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF LENGTH IS ZERO{15827
{{ZER{8,WB{{{SET ZERO OFFSET{15828
{{JSR{6,SBSTR{{{USE SBSTR TO BUILD SCBLK{15829
{{MOV{7,XR{11,-(XS){{STACK RESULT{15830
{{LCW{7,XR{{{GET NEXT CODE WORD{15831
{{BRI{9,(XR){{{EXECUTE IT{15832
{{EJC{{{{{15833
*
*      DEFINE
*
{S$DEF{ENT{{{{ENTRY POINT{15837
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{15838
{{ZER{3,DEFLB{{{ZERO LABEL POINTER IN CASE NULL{15839
{{BEQ{7,XR{21,=NULLS{6,SDF01{JUMP IF NULL SECOND ARGUMENT{15840
{{JSR{6,GTNVR{{{ELSE FIND VRBLK FOR LABEL{15841
{{PPM{6,SDF12{{{JUMP IF NOT A VARIABLE NAME{15842
{{MOV{7,XR{3,DEFLB{{ELSE SET SPECIFIED ENTRY{15843
*
*      SCAN FUNCTION NAME
*
{SDF01{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{15847
{{ERR{1,081{26,DEFINE first argument is not a string{{{15848
{{ERR{1,082{26,DEFINE first argument is null{{{15849
{{MOV{18,=CH$PP{8,WC{{DELIMITER ONE = LEFT PAREN{15850
{{MOV{8,WC{7,XL{{DELIMITER TWO = LEFT PAREN{15851
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15852
{{JSR{6,XSCAN{{{SCAN OUT FUNCTION NAME{15853
{{BNZ{8,WA{6,SDF02{{JUMP IF LEFT PAREN FOUND{15854
{{ERB{1,083{26,DEFINE first argument is missing a left paren{{{15855
*
*      HERE AFTER SCANNING OUT FUNCTION NAME
*
{SDF02{JSR{6,GTNVR{{{GET VARIABLE NAME{15859
{{ERR{1,084{26,DEFINE first argument has null function name{{{15860
{{MOV{7,XR{3,DEFVR{{SAVE VRBLK POINTER FOR FUNCTION NAM{15861
{{ZER{8,WB{{{ZERO COUNT OF ARGUMENTS{15862
{{MOV{7,XS{3,DEFXS{{SAVE INITIAL STACK POINTER{15863
{{BNZ{3,DEFLB{6,SDF03{{JUMP IF SECOND ARGUMENT GIVEN{15864
{{MOV{7,XR{3,DEFLB{{ELSE DEFAULT IS FUNCTION NAME{15865
*
*      LOOP TO SCAN ARGUMENT NAMES AND STACK VRBLK POINTERS
*
{SDF03{MOV{18,=CH$RP{8,WC{{DELIMITER ONE = RIGHT PAREN{15869
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO = COMMA{15870
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15871
{{JSR{6,XSCAN{{{SCAN OUT NEXT ARGUMENT NAME{15872
{{BNZ{8,WA{6,SDF04{{SKIP IF DELIMITER FOUND{15873
{{ERB{1,085{26,Null arg name or missing ) in DEFINE first arg.{{{15874
{{EJC{{{{{15875
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING AN ARGUMENT NAME
*
{SDF04{BNE{7,XR{21,=NULLS{6,SDF05{SKIP IF NON-NULL{15881
{{BZE{8,WB{6,SDF06{{IGNORE NULL IF CASE OF NO ARGUMENTS{15882
*
*      HERE AFTER DEALING WITH THE CASE OF NO ARGUMENTS
*
{SDF05{JSR{6,GTNVR{{{GET VRBLK POINTER{15886
{{PPM{6,SDF03{{{LOOP BACK TO IGNORE NULL NAME{15887
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT VRBLK POINTER{15888
{{ICV{8,WB{{{INCREMENT COUNTER{15889
{{BEQ{8,WA{18,=NUM02{6,SDF03{LOOP BACK IF STOPPED BY A COMMA{15890
*
*      HERE AFTER SCANNING OUT FUNCTION ARGUMENT NAMES
*
{SDF06{MOV{8,WB{3,DEFNA{{SAVE NUMBER OF ARGUMENTS{15894
{{ZER{8,WB{{{ZERO COUNT OF LOCALS{15895
*
*      LOOP TO SCAN LOCAL NAMES AND STACK VRBLK POINTERS
*
{SDF07{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{15899
{{MOV{8,WC{7,XL{{SET DELIMITER TWO = COMMA{15900
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15901
{{JSR{6,XSCAN{{{SCAN OUT NEXT LOCAL NAME{15902
{{BNE{7,XR{21,=NULLS{6,SDF08{SKIP IF NON-NULL{15903
{{BZE{8,WA{6,SDF09{{EXIT SCAN IF END OF STRING{15904
*
*      HERE AFTER SCANNING OUT A LOCAL NAME
*
{SDF08{JSR{6,GTNVR{{{GET VRBLK POINTER{15908
{{PPM{6,SDF07{{{LOOP BACK TO IGNORE NULL NAME{15909
{{ICV{8,WB{{{IF OK, INCREMENT COUNT{15910
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{15911
{{BNZ{8,WA{6,SDF07{{LOOP BACK IF STOPPED BY A COMMA{15912
{{EJC{{{{{15913
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING LOCALS, BUILD PFBLK
*
{SDF09{MOV{8,WB{8,WA{{COPY COUNT OF LOCALS{15919
{{ADD{3,DEFNA{8,WA{{ADD NUMBER OF ARGUMENTS{15920
{{MOV{8,WA{8,WC{{SET SUM ARGS+LOCALS AS LOOP COUNT{15921
{{ADD{18,=PFSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{15922
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15923
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR PFBLK{15924
{{MOV{7,XR{7,XL{{SAVE POINTER TO PFBLK{15925
{{MOV{22,=B$PFC{10,(XR)+{{STORE FIRST WORD{15926
{{MOV{3,DEFNA{10,(XR)+{{STORE NUMBER OF ARGUMENTS{15927
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (PFLEN){15928
{{MOV{3,DEFVR{10,(XR)+{{STORE VRBLK PTR FOR FUNCTION NAME{15929
{{MOV{8,WB{10,(XR)+{{STORE NUMBER OF LOCALS{15930
{{ZER{10,(XR)+{{{DEAL WITH LABEL LATER{15931
{{ZER{10,(XR)+{{{ZERO PFCTR{15932
{{ZER{10,(XR)+{{{ZERO PFRTR{15933
{{BZE{8,WC{6,SDF11{{SKIP IF NO ARGS OR LOCALS{15934
{{MOV{7,XL{8,WA{{KEEP PFBLK POINTER{15935
{{MOV{3,DEFXS{7,XT{{POINT BEFORE ARGUMENTS{15936
{{LCT{8,WC{8,WC{{GET COUNT OF ARGS+LOCALS FOR LOOP{15937
*
*      LOOP TO MOVE LOCALS AND ARGS TO PFBLK
*
{SDF10{MOV{11,-(XT){10,(XR)+{{STORE ONE ENTRY AND BUMP POINTERS{15941
{{BCT{8,WC{6,SDF10{{LOOP TILL ALL STORED{15942
{{MOV{8,WA{7,XL{{RECOVER PFBLK POINTER{15943
{{EJC{{{{{15944
*
*      DEFINE (CONTINUED)
*
*      NOW DEAL WITH LABEL
*
{SDF11{MOV{3,DEFXS{7,XS{{POP STACK{15950
{{MOV{3,DEFLB{13,PFCOD(XL){{STORE LABEL VRBLK IN PFBLK{15951
{{MOV{3,DEFVR{7,XR{{POINT BACK TO VRBLK FOR FUNCTION{15952
{{JSR{6,DFFNC{{{DEFINE FUNCTION{15953
{{BRN{6,EXNUL{{{AND EXIT RETURNING NULL{15954
*
*      HERE FOR ERRONEOUS LABEL
*
{SDF12{ERB{1,086{26,DEFINE function entry point is not defined label{{{15958
{{EJC{{{{{15959
*
*      DETACH
*
{S$DET{ENT{{{{ENTRY POINT{15963
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15964
{{JSR{6,GTVAR{{{LOCATE VARIABLE{15965
{{ERR{1,087{26,DETACH argument is not appropriate name{{{15966
{{JSR{6,DTACH{{{DETACH I/O ASSOCIATION FROM NAME{15967
{{BRN{6,EXNUL{{{RETURN NULL RESULT{15968
{{EJC{{{{{15969
*
*      DIFFER
*
{S$DIF{ENT{{{{ENTRY POINT{15973
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{15974
{{MOV{10,(XS)+{7,XL{{LOAD FIRST ARGUMENT{15975
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{15976
{{PPM{6,EXFAL{{{FAIL IF IDENT{15977
{{BRN{6,EXNUL{{{RETURN NULL IF DIFFER{15978
{{EJC{{{{{15979
*
*      DUMP
*
{S$DMP{ENT{{{{ENTRY POINT{15983
{{JSR{6,GTSMI{{{LOAD DUMP ARG AS SMALL INTEGER{15984
{{ERR{1,088{26,DUMP argument is not integer{{{15985
{{ERR{1,089{26,DUMP argument is negative or too large{{{15986
{{JSR{6,DUMPR{{{ELSE CALL DUMP ROUTINE{15987
{{BRN{6,EXNUL{{{AND RETURN NULL AS RESULT{15988
{{EJC{{{{{15989
*
*      DUPL
*
{S$DUP{ENT{{{{ENTRY POINT{15993
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT AS SMALL INTEGR{15994
{{ERR{1,090{26,DUPL second argument is not integer{{{15995
{{PPM{6,SDUP7{{{JUMP IF NEGATIVE OR TOO BIG{15996
{{MOV{7,XR{8,WB{{SAVE DUPLICATION FACTOR{15997
{{JSR{6,GTSTG{{{GET FIRST ARG AS STRING{15998
{{PPM{6,SDUP4{{{JUMP IF NOT A STRING{15999
*
*      HERE FOR CASE OF DUPLICATION OF A STRING
*
{{MTI{8,WA{{{ACQUIRE LENGTH AS INTEGER{16003
{{STI{3,DUPSI{{{SAVE FOR THE MOMENT{16004
{{MTI{8,WB{{{GET DUPLICATION FACTOR AS INTEGER{16005
{{MLI{3,DUPSI{{{FORM PRODUCT{16006
{{IOV{6,SDUP3{{{JUMP IF OVERFLOW{16007
{{IEQ{6,EXNUL{{{RETURN NULL IF RESULT LENGTH = 0{16008
{{MFI{8,WA{6,SDUP3{{GET AS ADDR INTEGER, CHECK OVFLO{16009
*
*      MERGE HERE WITH RESULT LENGTH IN WA
*
{SDUP1{MOV{7,XR{7,XL{{SAVE STRING POINTER{16013
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{16014
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT POINTER{16015
{{MOV{7,XL{8,WC{{SAVE POINTER TO ARGUMENT STRING{16016
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{16017
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{16018
*
*      LOOP THROUGH DUPLICATIONS
*
{SDUP2{MOV{8,WC{7,XL{{POINT BACK TO ARGUMENT STRING{16022
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARACTERS{16023
{{PLC{7,XL{{{POINT TO CHARS IN ARGUMENT STRING{16024
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{16025
{{BCT{8,WB{6,SDUP2{{LOOP TILL ALL DUPLICATIONS DONE{16026
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{16027
{{LCW{7,XR{{{GET NEXT CODE WORD{16028
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16029
{{EJC{{{{{16030
*
*      DUPL (CONTINUED)
*
*      HERE IF TOO LARGE, SET MAX LENGTH AND LET ALOCS CATCH IT
*
{SDUP3{MOV{3,DNAME{8,WA{{SET IMPOSSIBLE LENGTH FOR ALOCS{16036
{{BRN{6,SDUP1{{{MERGE BACK{16037
*
*      HERE IF NOT A STRING
*
{SDUP4{JSR{6,GTPAT{{{CONVERT ARGUMENT TO PATTERN{16041
{{ERR{1,091{26,DUPL first argument is not a string or pattern{{{16042
*
*      HERE TO DUPLICATE A PATTERN ARGUMENT
*
{{MOV{7,XR{11,-(XS){{STORE PATTERN ON STACK{16046
{{MOV{21,=NDNTH{7,XR{{START OFF WITH NULL PATTERN{16047
{{BZE{8,WB{6,SDUP6{{NULL PATTERN IS RESULT IF DUPFAC=0{16048
{{MOV{8,WB{11,-(XS){{PRESERVE LOOP COUNT{16049
*
*      LOOP TO DUPLICATE BY SUCCESSIVE CONCATENATION
*
{SDUP5{MOV{7,XR{7,XL{{COPY CURRENT VALUE AS RIGHT ARGUMNT{16053
{{MOV{13,NUM01(XS){7,XR{{GET A NEW COPY OF LEFT{16054
{{JSR{6,PCONC{{{CONCATENATE{16055
{{DCV{9,(XS){{{COUNT DOWN{16056
{{BNZ{9,(XS){6,SDUP5{{LOOP{16057
{{ICA{7,XS{{{POP LOOP COUNT{16058
*
*      HERE TO EXIT AFTER CONSTRUCTING PATTERN
*
{SDUP6{MOV{7,XR{9,(XS){{STORE RESULT ON STACK{16062
{{LCW{7,XR{{{GET NEXT CODE WORD{16063
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16064
*
*      FAIL IF SECOND ARG IS OUT OF RANGE
*
{SDUP7{ICA{7,XS{{{POP FIRST ARGUMENT{16068
{{BRN{6,EXFAL{{{FAIL{16069
{{EJC{{{{{16070
*
*      EJECT
*
{S$EJC{ENT{{{{ENTRY POINT{16074
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{16075
{{ERR{1,092{26,EJECT argument is not a suitable name{{{16076
{{PPM{6,SEJC1{{{NULL ARGUMENT{16077
{{ERR{1,093{26,EJECT file does not exist{{{16078
{{JSR{6,SYSEF{{{CALL EJECT FILE FUNCTION{16079
{{ERR{1,093{26,EJECT file does not exist{{{16080
{{ERR{1,094{26,EJECT file does not permit page eject{{{16081
{{ERR{1,095{26,EJECT caused non-recoverable output error{{{16082
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{16083
*
*      HERE TO EJECT STANDARD OUTPUT FILE
*
{SEJC1{JSR{6,SYSEP{{{CALL ROUTINE TO EJECT PRINTER{16087
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{16088
{{EJC{{{{{16089
*
*      ENDFILE
*
{S$ENF{ENT{{{{ENTRY POINT{16093
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{16094
{{ERR{1,096{26,ENDFILE argument is not a suitable name{{{16095
{{ERR{1,097{26,ENDFILE argument is null{{{16096
{{ERR{1,098{26,ENDFILE file does not exist{{{16097
{{JSR{6,SYSEN{{{CALL ENDFILE ROUTINE{16098
{{ERR{1,098{26,ENDFILE file does not exist{{{16099
{{ERR{1,099{26,ENDFILE file does not permit endfile{{{16100
{{ERR{1,100{26,ENDFILE caused non-recoverable output error{{{16101
{{MOV{7,XL{8,WB{{REMEMBER VRBLK PTR FROM IOFCB CALL{16102
{{MOV{7,XL{7,XR{{COPY POINTER{16103
*
*      LOOP TO FIND TRTRF BLOCK
*
{SENF1{MOV{7,XR{7,XL{{REMEMBER PREVIOUS ENTRY{16107
{{MOV{13,TRVAL(XR){7,XR{{CHAIN ALONG{16108
{{BNE{9,(XR){22,=B$TRT{6,EXNUL{SKIP OUT IF CHAIN END{16109
{{BNE{13,TRTYP(XR){18,=TRTFC{6,SENF1{LOOP IF NOT FOUND{16110
{{MOV{13,TRVAL(XR){13,TRVAL(XL){{REMOVE TRTRF{16111
{{MOV{13,TRTRF(XR){3,ENFCH{{POINT TO HEAD OF IOCHN{16112
{{MOV{13,TRFPT(XR){8,WC{{POINT TO FCBLK{16113
{{MOV{8,WB{7,XR{{FILEARG1 VRBLK FROM IOFCB{16114
{{JSR{6,SETVR{{{RESET IT{16115
{{MOV{20,=R$FCB{7,XL{{PTR TO HEAD OF FCBLK CHAIN{16116
{{SUB{19,*NUM02{7,XL{{ADJUST READY TO ENTER LOOP{16117
*
*      FIND FCBLK
*
{SENF2{MOV{7,XL{7,XR{{COPY PTR{16121
{{MOV{13,NUM02(XL){7,XL{{GET NEXT LINK{16122
{{BZE{7,XL{6,SENF4{{STOP IF CHAIN END{16123
{{BEQ{13,NUM03(XL){8,WC{6,SENF3{JUMP IF FCBLK FOUND{16124
{{BRN{6,SENF2{{{LOOP{16125
*
*      REMOVE FCBLK
*
{SENF3{MOV{13,NUM02(XL){13,NUM02(XR){{DELETE FCBLK FROM CHAIN{16129
*
*      LOOP WHICH DETACHES ALL VBLS ON IOCHN CHAIN
*
{SENF4{MOV{3,ENFCH{7,XL{{GET CHAIN HEAD{16133
{{BZE{7,XL{6,EXNUL{{FINISHED IF CHAIN END{16134
{{MOV{13,TRTRF(XL){3,ENFCH{{CHAIN ALONG{16135
{{MOV{13,IONMO(XL){8,WA{{NAME OFFSET{16136
{{MOV{13,IONMB(XL){7,XL{{NAME BASE{16137
{{JSR{6,DTACH{{{DETACH NAME{16138
{{BRN{6,SENF4{{{LOOP TILL DONE{16139
{{EJC{{{{{16140
*
*      EQ
*
{S$EQF{ENT{{{{ENTRY POINT{16144
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16145
{{ERR{1,101{26,EQ first argument is not numeric{{{16146
{{ERR{1,102{26,EQ second argument is not numeric{{{16147
{{PPM{6,EXFAL{{{FAIL IF LT{16148
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16149
{{PPM{6,EXFAL{{{FAIL IF GT{16150
{{EJC{{{{{16151
*
*      EVAL
*
{S$EVL{ENT{{{{ENTRY POINT{16155
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16156
{{LCW{8,WC{{{LOAD NEXT CODE WORD{16162
{{BNE{8,WC{21,=OFNE${6,SEVL1{JUMP IF CALLED BY VALUE{16163
{{SCP{7,XL{{{COPY CODE POINTER{16164
{{MOV{9,(XL){8,WA{{GET NEXT CODE WORD{16165
{{BNE{8,WA{21,=ORNM${6,SEVL2{BY NAME UNLESS EXPRESSION{16166
{{BNZ{13,NUM01(XS){6,SEVL2{{JUMP IF BY NAME{16167
*
*      HERE IF CALLED BY VALUE
*
{SEVL1{ZER{8,WB{{{SET FLAG FOR BY VALUE{16171
{{MOV{8,WC{11,-(XS){{SAVE CODE WORD{16173
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{16174
{{ERR{1,103{26,EVAL argument is not expression{{{16175
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16176
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{16177
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY VALUE{16181
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{16182
{{MOV{7,XR{7,XL{{COPY RESULT{16183
{{MOV{9,(XS){7,XR{{RELOAD NEXT CODE WORD{16184
{{MOV{7,XL{9,(XS){{STACK RESULT{16185
{{BRI{9,(XR){{{JUMP TO EXECUTE NEXT CODE WORD{16186
*
*      HERE IF CALLED BY NAME
*
{SEVL2{MOV{18,=NUM01{8,WB{{SET FLAG FOR BY NAME{16190
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{16192
{{ERR{1,103{26,EVAL argument is not expression{{{16193
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16194
{{MOV{18,=NUM01{8,WB{{SET FLAG FOR BY NAME{16195
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{16197
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{16198
{{BRN{6,EXNAM{{{EXIT WITH NAME{16199
{{EJC{{{{{16202
*
*      EXIT
*
{S$EXT{ENT{{{{ENTRY POINT{16206
{{ZER{8,WB{{{CLEAR AMOUNT OF STATIC SHIFT{16207
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16208
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{16210
{{JSR{6,GBCOL{{{COMPACT MEMORY BY COLLECTING{16211
{{MOV{7,XR{3,DNAMS{{RECORD NEW SEDIMENT SIZE{16212
{{JSR{6,GTSTG{{{{16216
{{ERR{1,288{26,EXIT second argument is not a string{{{16217
{{MOV{7,XR{7,XL{{COPY SECOND ARG STRING POINTER{16218
{{JSR{6,GTSTG{{{CONVERT ARG TO STRING{16219
{{ERR{1,104{26,EXIT first argument is not suitable integer or string{{{16220
{{MOV{7,XL{11,-(XS){{SAVE SECOND ARGUMENT{16221
{{MOV{7,XR{7,XL{{COPY FIRST ARG STRING PTR{16222
{{JSR{6,GTINT{{{CHECK IT IS INTEGER{16223
{{PPM{6,SEXT1{{{SKIP IF UNCONVERTIBLE{16224
{{ZER{7,XL{{{NOTE IT IS INTEGER{16225
{{LDI{13,ICVAL(XR){{{GET INTEGER ARG{16226
*
*      MERGE TO CALL OSINT EXIT ROUTINE
*
{SEXT1{MOV{3,R$FCB{8,WB{{GET FCBLK CHAIN HEADER{16230
{{MOV{21,=HEADV{7,XR{{POINT TO V.V STRING{16231
{{MOV{10,(XS)+{8,WA{{PROVIDE SECOND ARGUMENT SCBLK{16232
{{JSR{6,SYSXI{{{CALL EXTERNAL ROUTINE{16233
{{ERR{1,105{26,EXIT action not available in this implementation{{{16234
{{ERR{1,106{26,EXIT action caused irrecoverable error{{{16235
{{IEQ{6,EXNUL{{{RETURN IF ARGUMENT 0{16236
{{IGT{6,SEXT2{{{SKIP IF POSITIVE{16237
{{NGI{{{{MAKE POSITIVE{16238
*
*      CHECK FOR OPTION RESPECIFICATION
*
*      SYSXI RETURNS 0 IN WA WHEN A FILE HAS BEEN RESUMED,
*      1 WHEN THIS IS A CONTINUATION OF AN EXIT(4) OR EXIT(-4)
*      ACTION.
*
{SEXT2{MFI{8,WC{{{GET VALUE IN WORK REG{16246
{{ADD{8,WC{8,WA{{PREPARE TO TEST FOR CONTINUE{16247
{{BEQ{8,WA{18,=NUM05{6,SEXT5{CONTINUED EXECUTION IF 4 PLUS 1{16248
{{ZER{3,GBCNT{{{RESUMING EXECUTION SO RESET{16249
{{BGE{8,WC{18,=NUM03{6,SEXT3{SKIP IF WAS 3 OR 4{16250
{{MOV{8,WC{11,-(XS){{SAVE VALUE{16251
{{ZER{8,WC{{{SET TO READ OPTIONS{16252
{{JSR{6,PRPAR{{{READ SYSPP OPTIONS{16253
{{MOV{10,(XS)+{8,WC{{RESTORE VALUE{16254
*
*      DEAL WITH HEADER OPTION (FIDDLED BY PRPAR)
*
{SEXT3{MNZ{3,HEADP{{{ASSUME NO HEADERS{16258
{{BNE{8,WC{18,=NUM01{6,SEXT4{SKIP IF NOT 1{16259
{{ZER{3,HEADP{{{REQUEST HEADER PRINTING{16260
*
*      ALMOST READY TO RESUME RUNNING
*
{SEXT4{JSR{6,SYSTM{{{GET EXECUTION TIME START (SGD11){16264
{{STI{3,TIMSX{{{SAVE AS INITIAL TIME{16265
{{LDI{3,KVSTC{{{RESET TO ENSURE ...{16266
{{STI{3,KVSTL{{{... CORRECT EXECUTION STATS{16267
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{16268
{{BRN{6,EXNUL{{{RESUME EXECUTION{16269
*
*      HERE AFTER EXIT(4) OR EXIT(-4) -- CREATE SAVE FILE
*      OR LOAD MODULE AND CONTINUE EXECUTION.
*
*      RETURN INTEGER 1 TO SIGNAL THE CONTINUATION OF THE
*      ORIGINAL EXECUTION.
*
{SEXT5{MOV{21,=INTON{7,XR{{INTEGER ONE{16277
{{BRN{6,EXIXR{{{RETURN AS RESULT{16278
{{EJC{{{{{16280
*
*      EXP
*
{S$EXP{ENT{{{{ENTRY POINT{16285
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16286
{{JSR{6,GTREA{{{CONVERT TO REAL{16287
{{ERR{1,304{26,EXP argument not numeric{{{16288
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{16289
{{ETX{{{{TAKE EXPONENTIAL{16290
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{16291
{{ERB{1,305{26,EXP produced real overflow{{{16292
{{EJC{{{{{16293
*
*      FIELD
*
{S$FLD{ENT{{{{ENTRY POINT{16298
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (FIELD NUMBER){16299
{{ERR{1,107{26,FIELD second argument is not integer{{{16300
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{16301
{{MOV{7,XR{8,WB{{ELSE SAVE INTEGER VALUE{16302
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16303
{{JSR{6,GTNVR{{{POINT TO VRBLK{16304
{{PPM{6,SFLD1{{{JUMP (ERROR) IF NOT VARIABLE NAME{16305
{{MOV{13,VRFNC(XR){7,XR{{ELSE POINT TO FUNCTION BLOCK{16306
{{BNE{9,(XR){22,=B$DFC{6,SFLD1{ERROR IF NOT DATATYPE FUNCTION{16307
*
*      HERE IF FIRST ARGUMENT IS A DATATYPE FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF ARGUMENT NUMBER IS ZERO{16311
{{BGT{8,WB{13,FARGS(XR){6,EXFAL{FAIL IF TOO LARGE{16312
{{WTB{8,WB{{{ELSE CONVERT TO BYTE OFFSET{16313
{{ADD{8,WB{7,XR{{POINT TO FIELD NAME{16314
{{MOV{13,DFFLB(XR){7,XR{{LOAD VRBLK POINTER{16315
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{16316
*
*      HERE FOR BAD FIRST ARGUMENT
*
{SFLD1{ERB{1,108{26,FIELD first argument is not datatype name{{{16320
{{EJC{{{{{16321
*
*      FENCE
*
{S$FNC{ENT{{{{ENTRY POINT{16325
{{MOV{22,=P$FNC{8,WB{{SET PCODE FOR P$FNC{16326
{{ZER{7,XR{{{P0BLK{16327
{{JSR{6,PBILD{{{BUILD P$FNC NODE{16328
{{MOV{7,XR{7,XL{{SAVE POINTER TO IT{16329
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16330
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{16331
{{ERR{1,259{26,FENCE argument is not pattern{{{16332
{{JSR{6,PCONC{{{CONCATENATE TO P$FNC NODE{16333
{{MOV{7,XR{7,XL{{SAVE PTR TO CONCATENATED PATTERN{16334
{{MOV{22,=P$FNA{8,WB{{SET FOR P$FNA PCODE{16335
{{ZER{7,XR{{{P0BLK{16336
{{JSR{6,PBILD{{{CONSTRUCT P$FNA NODE{16337
{{MOV{7,XL{13,PTHEN(XR){{SET PATTERN AS PTHEN{16338
{{MOV{7,XR{11,-(XS){{SET AS RESULT{16339
{{LCW{7,XR{{{GET NEXT CODE WORD{16340
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16341
{{EJC{{{{{16342
*
*      GE
*
{S$GEF{ENT{{{{ENTRY POINT{16346
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16347
{{ERR{1,109{26,GE first argument is not numeric{{{16348
{{ERR{1,110{26,GE second argument is not numeric{{{16349
{{PPM{6,EXFAL{{{FAIL IF LT{16350
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16351
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16352
{{EJC{{{{{16353
*
*      GT
*
{S$GTF{ENT{{{{ENTRY POINT{16357
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16358
{{ERR{1,111{26,GT first argument is not numeric{{{16359
{{ERR{1,112{26,GT second argument is not numeric{{{16360
{{PPM{6,EXFAL{{{FAIL IF LT{16361
{{PPM{6,EXFAL{{{FAIL IF EQ{16362
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16363
{{EJC{{{{{16364
*
*      HOST
*
{S$HST{ENT{{{{ENTRY POINT{16368
{{MOV{10,(XS)+{8,WC{{GET FIFTH ARG{16369
{{MOV{10,(XS)+{8,WB{{GET FOURTH ARG{16370
{{MOV{10,(XS)+{7,XR{{GET THIRD ARG{16371
{{MOV{10,(XS)+{7,XL{{GET SECOND ARG{16372
{{MOV{10,(XS)+{8,WA{{GET FIRST ARG{16373
{{JSR{6,SYSHS{{{ENTER SYSHS ROUTINE{16374
{{ERR{1,254{26,Erroneous argument for HOST{{{16375
{{ERR{1,255{26,Error during execution of HOST{{{16376
{{PPM{6,SHST1{{{STORE HOST STRING{16377
{{PPM{6,EXNUL{{{RETURN NULL RESULT{16378
{{PPM{6,EXIXR{{{RETURN XR{16379
{{PPM{6,EXFAL{{{FAIL RETURN{16380
{{PPM{6,SHST3{{{STORE ACTUAL STRING{16381
{{PPM{6,SHST4{{{RETURN COPY OF XR{16382
*
*      RETURN HOST STRING
*
{SHST1{BZE{7,XL{6,EXNUL{{NULL STRING IF SYSHS UNCOOPERATIVE{16386
{{MOV{13,SCLEN(XL){8,WA{{LENGTH{16387
{{ZER{8,WB{{{ZERO OFFSET{16388
*
*      COPY STRING AND RETURN
*
{SHST2{JSR{6,SBSTR{{{BUILD COPY OF STRING{16392
{{MOV{7,XR{11,-(XS){{STACK THE RESULT{16393
{{LCW{7,XR{{{LOAD NEXT CODE WORD{16394
{{BRI{9,(XR){{{EXECUTE IT{16395
*
*      RETURN ACTUAL STRING POINTED TO BY XL
*
{SHST3{ZER{8,WB{{{TREAT XL LIKE AN SCBLK PTR{16399
{{SUB{18,=CFP$F{8,WB{{BY CREATING A NEGATIVE OFFSET{16400
{{BRN{6,SHST2{{{JOIN TO COPY STRING{16401
*
*      RETURN COPY OF BLOCK POINTED TO BY XR
*
{SHST4{MOV{7,XR{11,-(XS){{STACK RESULTS{16405
{{JSR{6,COPYB{{{MAKE COPY OF BLOCK{16406
{{PPM{6,EXITS{{{IF NOT AN AGGREGATE STRUCTURE{16407
{{BRN{6,EXSID{{{SET CURRENT ID VALUE OTHERWISE{16408
{{EJC{{{{{16409
*
*      IDENT
*
{S$IDN{ENT{{{{ENTRY POINT{16413
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{16414
{{MOV{10,(XS)+{7,XL{{LOAD FIRST ARGUMENT{16415
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{16416
{{PPM{6,EXNUL{{{RETURN NULL IF IDENT{16417
{{BRN{6,EXFAL{{{FAIL IF DIFFER{16418
{{EJC{{{{{16419
*
*      INPUT
*
{S$INP{ENT{{{{ENTRY POINT{16423
{{ZER{8,WB{{{INPUT FLAG{16424
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{16425
{{ERR{1,113{26,INPUT third argument is not a string{{{16426
{{ERR{1,114{26,Inappropriate second argument for INPUT{{{16427
{{ERR{1,115{26,Inappropriate first argument for INPUT{{{16428
{{ERR{1,116{26,Inappropriate file specification for INPUT{{{16429
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{16430
{{ERR{1,117{26,INPUT file cannot be read{{{16431
{{ERR{1,289{26,INPUT channel currently in use{{{16432
{{BRN{6,EXNUL{{{RETURN NULL STRING{16433
{{EJC{{{{{16434
*
*      INTEGER
*
{S$INT{ENT{{{{ENTRY POINT{16467
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16468
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{16469
{{PPM{6,EXFAL{{{FAIL IF NON-NUMERIC{16470
{{BEQ{8,WA{22,=B$ICL{6,EXNUL{RETURN NULL IF INTEGER{16471
{{BRN{6,EXFAL{{{FAIL IF REAL{16472
{{EJC{{{{{16473
*
*      ITEM
*
*      ITEM DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S$ITM{ENT{{{{ENTRY POINT{16480
*
*      DEAL WITH CASE OF NO ARGS
*
{{BNZ{8,WA{6,SITM1{{JUMP IF AT LEAST ONE ARG{16484
{{MOV{21,=NULLS{11,-(XS){{ELSE SUPPLY GARBAGE NULL ARG{16485
{{MOV{18,=NUM01{8,WA{{AND FIX ARGUMENT COUNT{16486
*
*      CHECK FOR NAME/VALUE CASES
*
{SITM1{SCP{7,XR{{{GET CURRENT CODE POINTER{16490
{{MOV{9,(XR){7,XL{{LOAD NEXT CODE WORD{16491
{{DCV{8,WA{{{GET NUMBER OF SUBSCRIPTS{16492
{{MOV{8,WA{7,XR{{COPY FOR ARREF{16493
{{BEQ{7,XL{21,=OFNE${6,SITM2{JUMP IF CALLED BY NAME{16494
*
*      HERE IF CALLED BY VALUE
*
{{ZER{8,WB{{{SET CODE FOR CALL BY VALUE{16498
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{16499
*
*      HERE FOR CALL BY NAME
*
{SITM2{MNZ{8,WB{{{SET CODE FOR CALL BY NAME{16503
{{LCW{8,WA{{{LOAD AND IGNORE OFNE$ CALL{16504
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{16505
{{EJC{{{{{16506
*
*      LE
*
{S$LEF{ENT{{{{ENTRY POINT{16510
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16511
{{ERR{1,118{26,LE first argument is not numeric{{{16512
{{ERR{1,119{26,LE second argument is not numeric{{{16513
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16514
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16515
{{PPM{6,EXFAL{{{FAIL IF GT{16516
{{EJC{{{{{16517
*
*      LEN
*
{S$LEN{ENT{{{{ENTRY POINT{16521
{{MOV{22,=P$LEN{8,WB{{SET PCODE FOR INTEGER ARG CASE{16522
{{MOV{22,=P$LND{8,WA{{SET PCODE FOR EXPR ARG CASE{16523
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{16524
{{ERR{1,120{26,LEN argument is not integer or expression{{{16525
{{ERR{1,121{26,LEN argument is negative or too large{{{16526
{{MOV{7,XR{11,-(XS){{STACK RESULT{16527
{{LCW{7,XR{{{GET NEXT CODE WORD{16528
{{BRI{9,(XR){{{EXECUTE IT{16529
{{EJC{{{{{16530
*
*      LEQ
*
{S$LEQ{ENT{{{{ENTRY POINT{16534
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16535
{{ERR{1,122{26,LEQ first argument is not a string{{{16536
{{ERR{1,123{26,LEQ second argument is not a string{{{16537
{{PPM{6,EXFAL{{{FAIL IF LLT{16538
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16539
{{PPM{6,EXFAL{{{FAIL IF LGT{16540
{{EJC{{{{{16541
*
*      LGE
*
{S$LGE{ENT{{{{ENTRY POINT{16545
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16546
{{ERR{1,124{26,LGE first argument is not a string{{{16547
{{ERR{1,125{26,LGE second argument is not a string{{{16548
{{PPM{6,EXFAL{{{FAIL IF LLT{16549
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16550
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16551
{{EJC{{{{{16552
*
*      LGT
*
{S$LGT{ENT{{{{ENTRY POINT{16556
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16557
{{ERR{1,126{26,LGT first argument is not a string{{{16558
{{ERR{1,127{26,LGT second argument is not a string{{{16559
{{PPM{6,EXFAL{{{FAIL IF LLT{16560
{{PPM{6,EXFAL{{{FAIL IF LEQ{16561
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16562
{{EJC{{{{{16563
*
*      LLE
*
{S$LLE{ENT{{{{ENTRY POINT{16567
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16568
{{ERR{1,128{26,LLE first argument is not a string{{{16569
{{ERR{1,129{26,LLE second argument is not a string{{{16570
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16571
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16572
{{PPM{6,EXFAL{{{FAIL IF LGT{16573
{{EJC{{{{{16574
*
*      LLT
*
{S$LLT{ENT{{{{ENTRY POINT{16578
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16579
{{ERR{1,130{26,LLT first argument is not a string{{{16580
{{ERR{1,131{26,LLT second argument is not a string{{{16581
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16582
{{PPM{6,EXFAL{{{FAIL IF LEQ{16583
{{PPM{6,EXFAL{{{FAIL IF LGT{16584
{{EJC{{{{{16585
*
*      LNE
*
{S$LNE{ENT{{{{ENTRY POINT{16589
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16590
{{ERR{1,132{26,LNE first argument is not a string{{{16591
{{ERR{1,133{26,LNE second argument is not a string{{{16592
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16593
{{PPM{6,EXFAL{{{FAIL IF LEQ{16594
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16595
{{EJC{{{{{16596
*
*      LN
*
{S$LNF{ENT{{{{ENTRY POINT{16601
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16602
{{JSR{6,GTREA{{{CONVERT TO REAL{16603
{{ERR{1,306{26,LN argument not numeric{{{16604
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{16605
{{REQ{6,SLNF1{{{OVERFLOW IF ARGUMENT IS 0{16606
{{RLT{6,SLNF2{{{ERROR IF ARGUMENT LESS THAN 0{16607
{{LNF{{{{TAKE NATURAL LOGARITHM{16608
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{16609
{SLNF1{ERB{1,307{26,LN produced real overflow{{{16610
*
*      HERE FOR BAD ARGUMENT
*
{SLNF2{ERB{1,315{26,LN argument negative{{{16614
{{EJC{{{{{16615
*
*      LOCAL
*
{S$LOC{ENT{{{{ENTRY POINT{16620
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (LOCAL NUMBER){16621
{{ERR{1,134{26,LOCAL second argument is not integer{{{16622
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{16623
{{MOV{7,XR{8,WB{{SAVE LOCAL NUMBER{16624
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16625
{{JSR{6,GTNVR{{{POINT TO VRBLK{16626
{{PPM{6,SLOC1{{{JUMP IF NOT VARIABLE NAME{16627
{{MOV{13,VRFNC(XR){7,XR{{ELSE LOAD FUNCTION POINTER{16628
{{BNE{9,(XR){22,=B$PFC{6,SLOC1{JUMP IF NOT PROGRAM DEFINED{16629
*
*      HERE IF WE HAVE A PROGRAM DEFINED FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF SECOND ARG IS ZERO{16633
{{BGT{8,WB{13,PFNLO(XR){6,EXFAL{OR TOO LARGE{16634
{{ADD{13,FARGS(XR){8,WB{{ELSE ADJUST OFFSET TO INCLUDE ARGS{16635
{{WTB{8,WB{{{CONVERT TO BYTES{16636
{{ADD{8,WB{7,XR{{POINT TO LOCAL POINTER{16637
{{MOV{13,PFAGB(XR){7,XR{{LOAD VRBLK POINTER{16638
{{BRN{6,EXVNM{{{EXIT BUILDING NMBLK{16639
*
*      HERE IF FIRST ARGUMENT IS NO GOOD
*
{SLOC1{ERB{1,135{26,LOCAL first arg is not a program function name{{{16643
{{EJC{{{{{16646
*
*      LOAD
*
{S$LOD{ENT{{{{ENTRY POINT{16650
{{JSR{6,GTSTG{{{LOAD LIBRARY NAME{16651
{{ERR{1,136{26,LOAD second argument is not a string{{{16652
{{MOV{7,XR{7,XL{{SAVE LIBRARY NAME{16653
{{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{16654
{{ERR{1,137{26,LOAD first argument is not a string{{{16655
{{ERR{1,138{26,LOAD first argument is null{{{16656
{{MOV{7,XL{11,-(XS){{STACK LIBRARY NAME{16657
{{MOV{18,=CH$PP{8,WC{{SET DELIMITER ONE = LEFT PAREN{16658
{{MOV{8,WC{7,XL{{SET DELIMITER TWO = LEFT PAREN{16659
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16660
{{JSR{6,XSCAN{{{SCAN FUNCTION NAME{16661
{{MOV{7,XR{11,-(XS){{SAVE PTR TO FUNCTION NAME{16662
{{BNZ{8,WA{6,SLOD1{{JUMP IF LEFT PAREN FOUND{16663
{{ERB{1,139{26,LOAD first argument is missing a left paren{{{16664
*
*      HERE AFTER SUCCESSFULLY SCANNING FUNCTION NAME
*
{SLOD1{JSR{6,GTNVR{{{LOCATE VRBLK{16668
{{ERR{1,140{26,LOAD first argument has null function name{{{16669
{{MOV{7,XR{3,LODFN{{SAVE VRBLK POINTER{16670
{{ZER{3,LODNA{{{ZERO COUNT OF ARGUMENTS{16671
*
*      LOOP TO SCAN ARGUMENT DATATYPE NAMES
*
{SLOD2{MOV{18,=CH$RP{8,WC{{DELIMITER ONE IS RIGHT PAREN{16675
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO IS COMMA{16676
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16677
{{JSR{6,XSCAN{{{SCAN NEXT ARGUMENT NAME{16678
{{ICV{3,LODNA{{{BUMP ARGUMENT COUNT{16679
{{BNZ{8,WA{6,SLOD3{{JUMP IF OK DELIMITER WAS FOUND{16680
{{ERB{1,141{26,LOAD first argument is missing a right paren{{{16681
{{EJC{{{{{16682
*
*      LOAD (CONTINUED)
*
*      COME HERE TO ANALYZE THE DATATYPE POINTER IN (XR). THIS
*      CODE IS USED BOTH FOR ARGUMENTS (WA=1,2) AND FOR THE
*      RESULT DATATYPE (WITH WA SET TO ZERO).
*
{SLOD3{MOV{8,WA{8,WB{{SAVE SCAN MODE{16691
{{MOV{13,SCLEN(XR){8,WA{{DATATYPE LENGTH{16692
{{BZE{8,WA{6,SLD3A{{BYPASS IF NULL STRING{16693
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{16694
{SLD3A{MOV{8,WB{8,WA{{RESTORE SCAN MODE{16695
{{MOV{7,XR{11,-(XS){{STACK DATATYPE NAME POINTER{16696
{{MOV{18,=NUM01{8,WB{{SET STRING CODE IN CASE{16700
{{MOV{21,=SCSTR{7,XL{{POINT TO /STRING/{16701
{{JSR{6,IDENT{{{CHECK FOR MATCH{16702
{{PPM{6,SLOD4{{{JUMP IF MATCH{16703
{{MOV{9,(XS){7,XR{{ELSE RELOAD NAME{16704
{{ADD{8,WB{8,WB{{SET CODE FOR INTEGER (2){16705
{{MOV{21,=SCINT{7,XL{{POINT TO /INTEGER/{16706
{{JSR{6,IDENT{{{CHECK FOR MATCH{16707
{{PPM{6,SLOD4{{{JUMP IF MATCH{16708
{{MOV{9,(XS){7,XR{{ELSE RELOAD STRING POINTER{16711
{{ICV{8,WB{{{SET CODE FOR REAL (3){16712
{{MOV{21,=SCREA{7,XL{{POINT TO /REAL/{16713
{{JSR{6,IDENT{{{CHECK FOR MATCH{16714
{{PPM{6,SLOD4{{{JUMP IF MATCH{16715
{{MOV{9,(XS){7,XR{{RELOAD STRING POINTER{16718
{{ICV{8,WB{{{CODE FOR FILE (4, OR 3 IF NO REALS){16719
{{MOV{21,=SCFIL{7,XL{{POINT TO /FILE/{16720
{{JSR{6,IDENT{{{CHECK FOR MATCH{16721
{{PPM{6,SLOD4{{{JUMP IF MATCH{16722
{{ZER{8,WB{{{ELSE GET CODE FOR NO CONVERT{16724
*
*      MERGE HERE WITH PROPER DATATYPE CODE IN WB
*
{SLOD4{MOV{8,WB{9,(XS){{STORE CODE ON STACK{16728
{{BEQ{8,WA{18,=NUM02{6,SLOD2{LOOP BACK IF ARG STOPPED BY COMMA{16729
{{BZE{8,WA{6,SLOD5{{JUMP IF THAT WAS THE RESULT TYPE{16730
*
*      HERE WE SCAN OUT THE RESULT TYPE (ARG STOPPED BY ) )
*
{{MOV{3,MXLEN{8,WC{{SET DUMMY (IMPOSSIBLE) DELIMITER 1{16734
{{MOV{8,WC{7,XL{{AND DELIMITER TWO{16735
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16736
{{JSR{6,XSCAN{{{SCAN RESULT NAME{16737
{{ZER{8,WA{{{SET CODE FOR PROCESSING RESULT{16738
{{BRN{6,SLOD3{{{JUMP BACK TO PROCESS RESULT NAME{16739
{{EJC{{{{{16740
*
*      LOAD (CONTINUED)
*
*      HERE AFTER PROCESSING ALL ARGS AND RESULT
*
{SLOD5{MOV{3,LODNA{8,WA{{GET NUMBER OF ARGUMENTS{16746
{{MOV{8,WA{8,WC{{COPY FOR LATER{16747
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{16748
{{ADD{19,*EFSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{16749
{{JSR{6,ALLOC{{{ALLOCATE EFBLK{16750
{{MOV{22,=B$EFC{9,(XR){{SET TYPE WORD{16751
{{MOV{8,WC{13,FARGS(XR){{SET NUMBER OF ARGUMENTS{16752
{{ZER{13,EFUSE(XR){{{SET USE COUNT (DFFNC WILL SET TO 1){16753
{{ZER{13,EFCOD(XR){{{ZERO CODE POINTER FOR NOW{16754
{{MOV{10,(XS)+{13,EFRSL(XR){{STORE RESULT TYPE CODE{16755
{{MOV{3,LODFN{13,EFVAR(XR){{STORE FUNCTION VRBLK POINTER{16756
{{MOV{8,WA{13,EFLEN(XR){{STORE EFBLK LENGTH{16757
{{MOV{7,XR{8,WB{{SAVE EFBLK POINTER{16758
{{ADD{8,WA{7,XR{{POINT PAST END OF EFBLK{16759
{{LCT{8,WC{8,WC{{SET NUMBER OF ARGUMENTS FOR LOOP{16760
*
*      LOOP TO SET ARGUMENT TYPE CODES FROM STACK
*
{SLOD6{MOV{10,(XS)+{11,-(XR){{STORE ONE TYPE CODE FROM STACK{16764
{{BCT{8,WC{6,SLOD6{{LOOP TILL ALL STORED{16765
*
*      NOW LOAD THE EXTERNAL FUNCTION AND PERFORM DEFINITION
*
{{MOV{10,(XS)+{7,XR{{LOAD FUNCTION STRING NAME{16769
{{MOV{13,SCLEN(XR){8,WA{{FUNCTION NAME LENGTH{16771
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{16772
{{MOV{9,(XS){7,XL{{LOAD LIBRARY NAME{16774
{{MOV{8,WB{9,(XS){{STORE EFBLK POINTER{16775
{{JSR{6,SYSLD{{{CALL FUNCTION TO LOAD EXTERNAL FUNC{16776
{{ERR{1,142{26,LOAD function does not exist{{{16777
{{ERR{1,143{26,LOAD function caused input error during load{{{16778
{{ERR{1,328{26,LOAD function - insufficient memory{{{16779
{{MOV{10,(XS)+{7,XL{{RECALL EFBLK POINTER{16780
{{MOV{7,XR{13,EFCOD(XL){{STORE CODE POINTER{16781
{{MOV{3,LODFN{7,XR{{POINT TO VRBLK FOR FUNCTION{16782
{{JSR{6,DFFNC{{{PERFORM FUNCTION DEFINITION{16783
{{BRN{6,EXNUL{{{RETURN NULL RESULT{16784
{{EJC{{{{{16786
*
*      LPAD
*
{S$LPD{ENT{{{{ENTRY POINT{16790
{{JSR{6,GTSTG{{{GET PAD CHARACTER{16791
{{ERR{1,144{26,LPAD third argument is not a string{{{16792
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){16793
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{16794
{{JSR{6,GTSMI{{{GET PAD LENGTH{16795
{{ERR{1,145{26,LPAD second argument is not integer{{{16796
{{PPM{6,SLPD4{{{SKIP IF NEGATIVE OR LARGE{16797
*
*      MERGE TO CHECK FIRST ARG
*
{SLPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){16801
{{ERR{1,146{26,LPAD first argument is not a string{{{16802
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{16803
{{MOV{7,XR{7,XL{{ELSE MOVE PTR TO STRING TO PAD{16804
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WC{8,WA{{COPY LENGTH{16812
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{16813
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT{16814
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH OF ARGUMENT{16815
{{SUB{8,WA{8,WC{{CALCULATE NUMBER OF PAD CHARACTERS{16816
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{16817
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{16818
*
*      LOOP TO PERFORM PAD
*
{SLPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{16822
{{BCT{8,WC{6,SLPD2{{LOOP TILL ALL PAD CHARS STORED{16823
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{16824
*
*      NOW COPY STRING
*
{{BZE{8,WA{6,SLPD3{{EXIT IF NULL STRING{16828
{{PLC{7,XL{{{ELSE POINT TO CHARS IN ARGUMENT{16829
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{16830
{{ZER{7,XL{{{CLEAR GARBAGE XL{16831
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{SLPD3{LCW{7,XR{{{LOAD NEXT CODE WORD{16835
{{BRI{9,(XR){{{EXECUTE IT{16836
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SLPD4{ZER{8,WC{{{ZERO PAD COUNT{16840
{{BRN{6,SLPD1{{{MERGE{16841
{{EJC{{{{{16842
*
*      LT
*
{S$LTF{ENT{{{{ENTRY POINT{16846
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16847
{{ERR{1,147{26,LT first argument is not numeric{{{16848
{{ERR{1,148{26,LT second argument is not numeric{{{16849
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16850
{{PPM{6,EXFAL{{{FAIL IF EQ{16851
{{PPM{6,EXFAL{{{FAIL IF GT{16852
{{EJC{{{{{16853
*
*      NE
*
{S$NEF{ENT{{{{ENTRY POINT{16857
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16858
{{ERR{1,149{26,NE first argument is not numeric{{{16859
{{ERR{1,150{26,NE second argument is not numeric{{{16860
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16861
{{PPM{6,EXFAL{{{FAIL IF EQ{16862
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16863
{{EJC{{{{{16864
*
*      NOTANY
*
{S$NAY{ENT{{{{ENTRY POINT{16868
{{MOV{22,=P$NAS{8,WB{{SET PCODE FOR SINGLE CHAR ARG{16869
{{MOV{22,=P$NAY{7,XL{{PCODE FOR MULTI-CHAR ARG{16870
{{MOV{22,=P$NAD{8,WC{{SET PCODE FOR EXPR ARG{16871
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{16872
{{ERR{1,151{26,NOTANY argument is not a string or expression{{{16873
{{MOV{7,XR{11,-(XS){{STACK RESULT{16874
{{LCW{7,XR{{{GET NEXT CODE WORD{16875
{{BRI{9,(XR){{{EXECUTE IT{16876
{{EJC{{{{{16877
*
*      OPSYN
*
{S$OPS{ENT{{{{ENTRY POINT{16881
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{16882
{{ERR{1,152{26,OPSYN third argument is not integer{{{16883
{{ERR{1,153{26,OPSYN third argument is negative or too large{{{16884
{{MOV{8,WC{8,WB{{IF OK, SAVE THIRD ARGUMNET{16885
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{16886
{{JSR{6,GTNVR{{{LOCATE VARIABLE BLOCK{16887
{{ERR{1,154{26,OPSYN second arg is not natural variable name{{{16888
{{MOV{13,VRFNC(XR){7,XL{{IF OK, LOAD FUNCTION BLOCK POINTER{16889
{{BNZ{8,WB{6,SOPS2{{JUMP IF OPERATOR OPSYN CASE{16890
*
*      HERE FOR FUNCTION OPSYN (THIRD ARG ZERO)
*
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16894
{{JSR{6,GTNVR{{{GET VRBLK POINTER{16895
{{ERR{1,155{26,OPSYN first arg is not natural variable name{{{16896
*
*      MERGE HERE TO PERFORM FUNCTION DEFINITION
*
{SOPS1{JSR{6,DFFNC{{{CALL FUNCTION DEFINER{16900
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{16901
*
*      HERE FOR OPERATOR OPSYN (THIRD ARG NON-ZERO)
*
{SOPS2{JSR{6,GTSTG{{{GET OPERATOR NAME{16905
{{PPM{6,SOPS5{{{JUMP IF NOT STRING{16906
{{BNE{8,WA{18,=NUM01{6,SOPS5{ERROR IF NOT ONE CHAR LONG{16907
{{PLC{7,XR{{{ELSE POINT TO CHARACTER{16908
{{LCH{8,WC{9,(XR){{LOAD CHARACTER NAME{16909
{{EJC{{{{{16910
*
*      OPSYN (CONTINUED)
*
*      NOW SET TO SEARCH FOR MATCHING UNARY OR BINARY OPERATOR
*      NAME AS APPROPRIATE. NOTE THAT THERE ARE =OPBUN UNDEFINED
*      BINARY OPERATORS AND =OPUUN UNDEFINED UNARY OPERATORS.
*
{{MOV{20,=R$UUB{8,WA{{POINT TO UNOP POINTERS IN CASE{16918
{{MOV{21,=OPNSU{7,XR{{POINT TO NAMES OF UNARY OPERATORS{16919
{{ADD{18,=OPBUN{8,WB{{ADD NO. OF UNDEFINED BINARY OPS{16920
{{BEQ{8,WB{18,=OPUUN{6,SOPS3{JUMP IF UNOP (THIRD ARG WAS 1){16921
{{MOV{20,=R$UBA{8,WA{{ELSE POINT TO BINARY OPERATOR PTRS{16922
{{MOV{21,=OPSNB{7,XR{{POINT TO NAMES OF BINARY OPERATORS{16923
{{MOV{18,=OPBUN{8,WB{{SET NUMBER OF UNDEFINED BINOPS{16924
*
*      MERGE HERE TO CHECK LIST (WB = NUMBER TO CHECK)
*
{SOPS3{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{16928
*
*      LOOP TO SEARCH FOR NAME MATCH
*
{SOPS4{BEQ{8,WC{9,(XR){6,SOPS6{JUMP IF NAMES MATCH{16932
{{ICA{8,WA{{{ELSE PUSH POINTER TO FUNCTION PTR{16933
{{ICA{7,XR{{{BUMP POINTER{16934
{{BCT{8,WB{6,SOPS4{{LOOP BACK TILL ALL CHECKED{16935
*
*      HERE IF BAD OPERATOR NAME
*
{SOPS5{ERB{1,156{26,OPSYN first arg is not correct operator name{{{16939
*
*      COME HERE ON FINDING A MATCH IN THE OPERATOR NAME TABLE
*
{SOPS6{MOV{8,WA{7,XR{{COPY POINTER TO FUNCTION BLOCK PTR{16943
{{SUB{19,*VRFNC{7,XR{{MAKE IT LOOK LIKE DUMMY VRBLK{16944
{{BRN{6,SOPS1{{{MERGE BACK TO DEFINE OPERATOR{16945
{{EJC{{{{{16946
*
*      OUTPUT
*
{S$OUP{ENT{{{{ENTRY POINT{16971
{{MOV{18,=NUM03{8,WB{{OUTPUT FLAG{16972
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{16973
{{ERR{1,157{26,OUTPUT third argument is not a string{{{16974
{{ERR{1,158{26,Inappropriate second argument for OUTPUT{{{16975
{{ERR{1,159{26,Inappropriate first argument for OUTPUT{{{16976
{{ERR{1,160{26,Inappropriate file specification for OUTPUT{{{16977
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{16978
{{ERR{1,161{26,OUTPUT file cannot be written to{{{16979
{{ERR{1,290{26,OUTPUT channel currently in use{{{16980
{{BRN{6,EXNUL{{{RETURN NULL STRING{16981
{{EJC{{{{{16982
*
*      POS
*
{S$POS{ENT{{{{ENTRY POINT{16986
{{MOV{22,=P$POS{8,WB{{SET PCODE FOR INTEGER ARG CASE{16987
{{MOV{22,=P$PSD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{16988
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{16989
{{ERR{1,162{26,POS argument is not integer or expression{{{16990
{{ERR{1,163{26,POS argument is negative or too large{{{16991
{{MOV{7,XR{11,-(XS){{STACK RESULT{16992
{{LCW{7,XR{{{GET NEXT CODE WORD{16993
{{BRI{9,(XR){{{EXECUTE IT{16994
{{EJC{{{{{16995
*
*      PROTOTYPE
*
{S$PRO{ENT{{{{ENTRY POINT{16999
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{17000
{{MOV{13,TBLEN(XR){8,WB{{LENGTH IF TABLE, VECTOR (=VCLEN){17001
{{BTW{8,WB{{{CONVERT TO WORDS{17002
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD OF ARGUMENT BLOCK{17003
{{BEQ{8,WA{22,=B$ART{6,SPRO4{JUMP IF ARRAY{17004
{{BEQ{8,WA{22,=B$TBT{6,SPRO1{JUMP IF TABLE{17005
{{BEQ{8,WA{22,=B$VCT{6,SPRO3{JUMP IF VECTOR{17006
{{ERB{1,164{26,PROTOTYPE argument is not valid object{{{17011
*
*      HERE FOR TABLE
*
{SPRO1{SUB{18,=TBSI${8,WB{{SUBTRACT STANDARD FIELDS{17015
*
*      MERGE FOR VECTOR
*
{SPRO2{MTI{8,WB{{{CONVERT TO INTEGER{17019
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{17020
*
*      HERE FOR VECTOR
*
{SPRO3{SUB{18,=VCSI${8,WB{{SUBTRACT STANDARD FIELDS{17024
{{BRN{6,SPRO2{{{MERGE{17025
*
*      HERE FOR ARRAY
*
{SPRO4{ADD{13,AROFS(XR){7,XR{{POINT TO PROTOTYPE FIELD{17029
{{MOV{9,(XR){7,XR{{LOAD PROTOTYPE{17030
{{MOV{7,XR{11,-(XS){{STACK RESULT{17031
{{LCW{7,XR{{{GET NEXT CODE WORD{17032
{{BRI{9,(XR){{{EXECUTE IT{17033
{{EJC{{{{{17043
*
*      REMDR
*
{S$RMD{ENT{{{{ENTRY POINT{17047
{{JSR{6,ARITH{{{GET TWO INTEGERS OR TWO REALS{17049
{{ERR{1,166{26,REMDR first argument is not numeric{{{17050
{{ERR{1,165{26,REMDR second argument is not numeric{{{17051
{{PPM{6,SRM06{{{IF REAL{17052
*
*      BOTH ARGUMENTS INTEGER
*
{{ZER{8,WB{{{SET POSITIVE FLAG{17069
{{LDI{13,ICVAL(XR){{{LOAD LEFT ARGUMENT VALUE{17070
{{IGE{6,SRM01{{{JUMP IF POSITIVE{17071
{{MNZ{8,WB{{{SET NEGATIVE FLAG{17072
{SRM01{RMI{13,ICVAL(XL){{{GET REMAINDER{17073
{{IOV{6,SRM05{{{ERROR IF OVERFLOW{17074
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*
{{BZE{8,WB{6,SRM03{{IF RESULT SHOULD BE POSITIVE{17078
{{ILE{6,EXINT{{{IF SHOULD BE NEGATIVE, AND IS{17079
{SRM02{NGI{{{{ADJUST SIGN OF RESULT{17080
{{BRN{6,EXINT{{{RETURN RESULT{17081
{SRM03{ILT{6,SRM02{{{SHOULD BE POS, AND RESULT NEGATIVE{17082
{{BRN{6,EXINT{{{SHOULD BE POSITIVE, AND IS{17083
*
*      FAIL FIRST ARGUMENT
*
{SRM04{ERB{1,166{26,REMDR first argument is not numeric{{{17087
*
*      FAIL IF OVERFLOW
*
{SRM05{ERB{1,167{26,REMDR caused integer overflow{{{17091
*
*      HERE WITH 1ST ARGUMENT IN (XR), 2ND IN (XL), BOTH REAL
*
*      RESULT = N1 - CHOP(N1/N2)*N2
*
{SRM06{ZER{8,WB{{{SET POSITIVE FLAG{17098
{{LDR{13,RCVAL(XR){{{LOAD LEFT ARGUMENT VALUE{17099
{{RGE{6,SRM07{{{JUMP IF POSITIVE{17100
{{MNZ{8,WB{{{SET NEGATIVE FLAG{17101
{SRM07{DVR{13,RCVAL(XL){{{COMPUTE N1/N2{17102
{{ROV{6,SRM10{{{JUMP IF OVERFLOW{17103
{{CHP{{{{CHOP RESULT{17104
{{MLR{13,RCVAL(XL){{{TIMES N2{17105
{{SBR{13,RCVAL(XR){{{COMPUTE DIFFERENCE{17106
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*      -RESULT IS IN RA AT THIS POINT
*
{{BZE{8,WB{6,SRM09{{IF RESULT SHOULD BE POSITIVE{17111
{{RLE{6,EXREA{{{IF SHOULD BE NEGATIVE, AND IS{17112
{SRM08{NGR{{{{ADJUST SIGN OF RESULT{17113
{{BRN{6,EXREA{{{RETURN RESULT{17114
{SRM09{RLT{6,SRM08{{{SHOULD BE POS, AND RESULT NEGATIVE{17115
{{BRN{6,EXREA{{{SHOULD BE POSITIVE, AND IS{17116
*
*      FAIL IF OVERFLOW
*
{SRM10{ERB{1,312{26,REMDR caused real overflow{{{17120
{{EJC{{{{{17122
*
*      REPLACE
*
*      THE ACTUAL REPLACE OPERATION USES AN SCBLK WHOSE CFP$A
*      CHARS CONTAIN THE TRANSLATED VERSIONS OF ALL THE CHARS.
*      THE TABLE POINTER IS REMEMBERED FROM CALL TO CALL AND
*      THE TABLE IS ONLY BUILT WHEN THE ARGUMENTS CHANGE.
*
*      WE ALSO PERFORM AN OPTIMIZATION GLEANED FROM SPITBOL 370.
*      IF THE SECOND ARGUMENT IS &ALPHABET, THERE IS NO NEED TO
*      TO BUILD A REPLACE TABLE.  THE THIRD ARGUMENT CAN BE
*      USED DIRECTLY AS THE REPLACE TABLE.
*
{S$RPL{ENT{{{{ENTRY POINT{17136
{{JSR{6,GTSTG{{{LOAD THIRD ARGUMENT AS STRING{17137
{{ERR{1,168{26,REPLACE third argument is not a string{{{17138
{{MOV{7,XR{7,XL{{SAVE THIRD ARG PTR{17139
{{JSR{6,GTSTG{{{GET SECOND ARGUMENT{17140
{{ERR{1,169{26,REPLACE second argument is not a string{{{17141
*
*      CHECK TO SEE IF THIS IS THE SAME TABLE AS LAST TIME
*
{{BNE{7,XR{3,R$RA2{6,SRPL1{JUMP IF 2ND ARGUMENT DIFFERENT{17145
{{BEQ{7,XL{3,R$RA3{6,SRPL4{JUMP IF ARGS SAME AS LAST TIME{17146
*
*      HERE WE BUILD A NEW REPLACE TABLE (NOTE WA = 2ND ARG LEN)
*
{SRPL1{MOV{13,SCLEN(XL){8,WB{{LOAD 3RD ARGUMENT LENGTH{17150
{{BNE{8,WA{8,WB{6,SRPL6{JUMP IF ARGUMENTS NOT SAME LENGTH{17151
{{BEQ{7,XR{3,KVALP{6,SRPL5{JUMP IF 2ND ARG IS ALPHABET STRING{17152
{{BZE{8,WB{6,SRPL6{{JUMP IF NULL 2ND ARGUMENT{17153
{{MOV{7,XL{3,R$RA3{{SAVE THIRD ARG FOR NEXT TIME IN{17154
{{MOV{7,XR{3,R$RA2{{SAVE SECOND ARG FOR NEXT TIME IN{17155
{{MOV{3,KVALP{7,XL{{POINT TO ALPHABET STRING{17156
{{MOV{13,SCLEN(XL){8,WA{{LOAD ALPHABET SCBLK LENGTH{17157
{{MOV{3,R$RPT{7,XR{{POINT TO CURRENT TABLE (IF ANY){17158
{{BNZ{7,XR{6,SRPL2{{JUMP IF WE ALREADY HAVE A TABLE{17159
*
*      HERE WE ALLOCATE A NEW TABLE
*
{{JSR{6,ALOCS{{{ALLOCATE NEW TABLE{17163
{{MOV{8,WC{8,WA{{KEEP SCBLK LENGTH{17164
{{MOV{7,XR{3,R$RPT{{SAVE TABLE POINTER FOR NEXT TIME{17165
*
*      MERGE HERE WITH POINTER TO NEW TABLE BLOCK IN (XR)
*
{SRPL2{CTB{8,WA{2,SCSI${{COMPUTE LENGTH OF SCBLK{17169
{{MVW{{{{COPY TO GET INITIAL TABLE VALUES{17170
{{EJC{{{{{17171
*
*      REPLACE (CONTINUED)
*
*      NOW WE MUST PLUG SELECTED ENTRIES AS REQUIRED. NOTE THAT
*      WE ARE SHORT OF INDEX REGISTERS FOR THE FOLLOWING LOOP.
*      HENCE THE NEED TO REPEATEDLY RE-INITIALISE CHAR PTR XL
*
{{MOV{3,R$RA2{7,XL{{POINT TO SECOND ARGUMENT{17179
{{LCT{8,WB{8,WB{{NUMBER OF CHARS TO PLUG{17180
{{ZER{8,WC{{{ZERO CHAR OFFSET{17181
{{MOV{3,R$RA3{7,XR{{POINT TO 3RD ARG{17182
{{PLC{7,XR{{{GET CHAR PTR FOR 3RD ARG{17183
*
*      LOOP TO PLUG CHARS
*
{SRPL3{MOV{3,R$RA2{7,XL{{POINT TO 2ND ARG{17187
{{PLC{7,XL{8,WC{{POINT TO NEXT CHAR{17188
{{ICV{8,WC{{{INCREMENT OFFSET{17189
{{LCH{8,WA{9,(XL){{GET NEXT CHAR{17190
{{MOV{3,R$RPT{7,XL{{POINT TO TRANSLATE TABLE{17191
{{PSC{7,XL{8,WA{{CONVERT CHAR TO OFFSET INTO TABLE{17192
{{LCH{8,WA{10,(XR)+{{GET TRANSLATED CHAR{17193
{{SCH{8,WA{9,(XL){{STORE IN TABLE{17194
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{17195
{{BCT{8,WB{6,SRPL3{{LOOP TILL DONE{17196
{{EJC{{{{{17197
*
*      REPLACE (CONTINUED)
*
*      HERE TO USE R$RPT AS REPLACE TABLE.
*
{SRPL4{MOV{3,R$RPT{7,XL{{REPLACE TABLE TO USE{17203
*
*      HERE TO PERFORM TRANSLATE USING TABLE IN XL.
*
{SRPL5{JSR{6,GTSTG{{{GET FIRST ARGUMENT{17208
{{ERR{1,170{26,REPLACE first argument is not a string{{{17209
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF NULL ARGUMENT{17218
{{MOV{7,XL{11,-(XS){{STACK REPLACE TABLE TO USE{17219
{{MOV{7,XR{7,XL{{COPY POINTER{17220
{{MOV{8,WA{8,WC{{SAVE LENGTH{17221
{{CTB{8,WA{2,SCHAR{{GET SCBLK LENGTH{17222
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{17223
{{MOV{7,XR{8,WB{{SAVE ADDRESS OF COPY{17224
{{MVW{{{{MOVE SCBLK CONTENTS TO COPY{17225
{{MOV{10,(XS)+{7,XR{{UNSTACK REPLACE TABLE{17226
{{PLC{7,XR{{{POINT TO CHARS OF TABLE{17227
{{MOV{8,WB{7,XL{{POINT TO STRING TO TRANSLATE{17228
{{PLC{7,XL{{{POINT TO CHARS OF STRING{17229
{{MOV{8,WC{8,WA{{SET NUMBER OF CHARS TO TRANSLATE{17230
{{TRC{{{{PERFORM TRANSLATION{17231
{SRPL8{MOV{8,WB{11,-(XS){{STACK RESULT{17232
{{LCW{7,XR{{{LOAD NEXT CODE WORD{17233
{{BRI{9,(XR){{{EXECUTE IT{17234
*
*      ERROR POINT
*
{SRPL6{ERB{1,171{26,Null or unequally long 2nd, 3rd args to REPLACE{{{17238
{{EJC{{{{{17253
*
*      REWIND
*
{S$REW{ENT{{{{ENTRY POINT{17257
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{17258
{{ERR{1,172{26,REWIND argument is not a suitable name{{{17259
{{ERR{1,173{26,REWIND argument is null{{{17260
{{ERR{1,174{26,REWIND file does not exist{{{17261
{{JSR{6,SYSRW{{{CALL SYSTEM REWIND FUNCTION{17262
{{ERR{1,174{26,REWIND file does not exist{{{17263
{{ERR{1,175{26,REWIND file does not permit rewind{{{17264
{{ERR{1,176{26,REWIND caused non-recoverable error{{{17265
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT IF NO ERROR{17266
{{EJC{{{{{17267
*
*      REVERSE
*
{S$RVS{ENT{{{{ENTRY POINT{17271
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{17273
{{ERR{1,177{26,REVERSE argument is not a string{{{17274
{{BZE{8,WA{6,EXIXR{{RETURN ARGUMENT IF NULL{17280
{{MOV{7,XR{7,XL{{ELSE SAVE POINTER TO STRING ARG{17281
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR NEW SCBLK{17282
{{MOV{7,XR{11,-(XS){{STORE SCBLK PTR ON STACK AS RESULT{17283
{{PSC{7,XR{{{PREPARE TO STORE IN NEW SCBLK{17284
{{PLC{7,XL{8,WC{{POINT PAST LAST CHAR IN ARGUMENT{17285
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{17286
*
*      LOOP TO MOVE CHARS IN REVERSE ORDER
*
{SRVS1{LCH{8,WB{11,-(XL){{LOAD NEXT CHAR FROM ARGUMENT{17290
{{SCH{8,WB{10,(XR)+{{STORE IN RESULT{17291
{{BCT{8,WC{6,SRVS1{{LOOP TILL ALL MOVED{17292
*
*      HERE WHEN COMPLETE TO EXECUTE NEXT CODE WORD
*
{SRVS4{CSC{7,XR{{{COMPLETE STORE CHARACTERS{17296
{{ZER{7,XL{{{CLEAR GARBAGE XL{17297
{SRVS2{LCW{7,XR{{{LOAD NEXT CODE WORD{17298
{{BRI{9,(XR){{{EXECUTE IT{17299
{{EJC{{{{{17323
*
*      RPAD
*
{S$RPD{ENT{{{{ENTRY POINT{17327
{{JSR{6,GTSTG{{{GET PAD CHARACTER{17328
{{ERR{1,178{26,RPAD third argument is not a string{{{17329
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){17330
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{17331
{{JSR{6,GTSMI{{{GET PAD LENGTH{17332
{{ERR{1,179{26,RPAD second argument is not integer{{{17333
{{PPM{6,SRPD3{{{SKIP IF NEGATIVE OR LARGE{17334
*
*      MERGE TO CHECK FIRST ARG.
*
{SRPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){17338
{{ERR{1,180{26,RPAD first argument is not a string{{{17339
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{17340
{{MOV{7,XR{7,XL{{ELSE MOVE PTR TO STRING TO PAD{17341
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WC{8,WA{{COPY LENGTH{17349
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{17350
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT{17351
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH OF ARGUMENT{17352
{{SUB{8,WA{8,WC{{CALCULATE NUMBER OF PAD CHARACTERS{17353
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{17354
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{17355
*
*      COPY ARGUMENT STRING
*
{{BZE{8,WA{6,SRPD2{{JUMP IF ARGUMENT IS NULL{17359
{{PLC{7,XL{{{ELSE POINT TO ARGUMENT CHARS{17360
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{17361
{{ZER{7,XL{{{CLEAR GARBAGE XL{17362
*
*      LOOP TO SUPPLY PAD CHARACTERS
*
{SRPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{17366
{{BCT{8,WC{6,SRPD2{{LOOP TILL ALL PAD CHARS STORED{17367
{{CSC{7,XR{{{COMPLETE CHARACTER STORING{17368
{{LCW{7,XR{{{LOAD NEXT CODE WORD{17369
{{BRI{9,(XR){{{EXECUTE IT{17370
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SRPD3{ZER{8,WC{{{ZERO PAD COUNT{17374
{{BRN{6,SRPD1{{{MERGE{17375
{{EJC{{{{{17376
*
*      RTAB
*
{S$RTB{ENT{{{{ENTRY POINT{17380
{{MOV{22,=P$RTB{8,WB{{SET PCODE FOR INTEGER ARG CASE{17381
{{MOV{22,=P$RTD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17382
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17383
{{ERR{1,181{26,RTAB argument is not integer or expression{{{17384
{{ERR{1,182{26,RTAB argument is negative or too large{{{17385
{{MOV{7,XR{11,-(XS){{STACK RESULT{17386
{{LCW{7,XR{{{GET NEXT CODE WORD{17387
{{BRI{9,(XR){{{EXECUTE IT{17388
{{EJC{{{{{17389
*
*      SET
*
{S$SET{ENT{{{{ENTRY POINT{17394
{{MOV{10,(XS)+{3,R$IO2{{SAVE THIRD ARG (WHENCE){17395
{{MOV{10,(XS)+{3,R$IO1{{SAVE SECOND ARG (OFFSET){17402
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{17404
{{ERR{1,291{26,SET first argument is not a suitable name{{{17405
{{ERR{1,292{26,SET first argument is null{{{17406
{{ERR{1,295{26,SET file does not exist{{{17407
{{MOV{3,R$IO1{8,WB{{LOAD SECOND ARG{17410
{{MOV{3,R$IO2{8,WC{{LOAD THIRD ARG{17412
{{JSR{6,SYSST{{{CALL SYSTEM SET ROUTINE{17413
{{ERR{1,293{26,Inappropriate second argument to SET{{{17414
{{ERR{1,294{26,Inappropriate third argument to SET{{{17415
{{ERR{1,295{26,SET file does not exist{{{17416
{{ERR{1,296{26,SET file does not permit setting file pointer{{{17417
{{ERR{1,297{26,SET caused non-recoverable I/O error{{{17418
{{BRN{6,EXINT{{{OTHERWISE RETURN POSITION{17423
{{EJC{{{{{17425
*
*      TAB
*
{S$TAB{ENT{{{{ENTRY POINT{17430
{{MOV{22,=P$TAB{8,WB{{SET PCODE FOR INTEGER ARG CASE{17431
{{MOV{22,=P$TBD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17432
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17433
{{ERR{1,183{26,TAB argument is not integer or expression{{{17434
{{ERR{1,184{26,TAB argument is negative or too large{{{17435
{{MOV{7,XR{11,-(XS){{STACK RESULT{17436
{{LCW{7,XR{{{GET NEXT CODE WORD{17437
{{BRI{9,(XR){{{EXECUTE IT{17438
{{EJC{{{{{17439
*
*      RPOS
*
{S$RPS{ENT{{{{ENTRY POINT{17443
{{MOV{22,=P$RPS{8,WB{{SET PCODE FOR INTEGER ARG CASE{17444
{{MOV{22,=P$RPD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17445
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17446
{{ERR{1,185{26,RPOS argument is not integer or expression{{{17447
{{ERR{1,186{26,RPOS argument is negative or too large{{{17448
{{MOV{7,XR{11,-(XS){{STACK RESULT{17449
{{LCW{7,XR{{{GET NEXT CODE WORD{17450
{{BRI{9,(XR){{{EXECUTE IT{17451
{{EJC{{{{{17454
*
*      RSORT
*
{S$RSR{ENT{{{{ENTRY POINT{17458
{{MNZ{8,WA{{{MARK AS RSORT{17459
{{JSR{6,SORTA{{{CALL SORT ROUTINE{17460
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{17461
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{17462
{{EJC{{{{{17464
*
*      SETEXIT
*
{S$STX{ENT{{{{ENTRY POINT{17468
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{17469
{{MOV{3,STXVR{8,WA{{LOAD OLD VRBLK POINTER{17470
{{ZER{7,XL{{{LOAD ZERO IN CASE NULL ARG{17471
{{BEQ{7,XR{21,=NULLS{6,SSTX1{JUMP IF NULL ARGUMENT (RESET CALL){17472
{{JSR{6,GTNVR{{{ELSE GET SPECIFIED VRBLK{17473
{{PPM{6,SSTX2{{{JUMP IF NOT NATURAL VARIABLE{17474
{{MOV{13,VRLBL(XR){7,XL{{ELSE LOAD LABEL{17475
{{BEQ{7,XL{21,=STNDL{6,SSTX2{JUMP IF LABEL IS NOT DEFINED{17476
{{BNE{9,(XL){22,=B$TRT{6,SSTX1{JUMP IF NOT TRAPPED{17477
{{MOV{13,TRLBL(XL){7,XL{{ELSE LOAD PTR TO REAL LABEL CODE{17478
*
*      HERE TO SET/RESET SETEXIT TRAP
*
{SSTX1{MOV{7,XR{3,STXVR{{STORE NEW VRBLK POINTER (OR NULL){17482
{{MOV{7,XL{3,R$SXC{{STORE NEW CODE PTR (OR ZERO){17483
{{BEQ{8,WA{21,=NULLS{6,EXNUL{RETURN NULL IF NULL RESULT{17484
{{MOV{8,WA{7,XR{{ELSE COPY VRBLK POINTER{17485
{{BRN{6,EXVNM{{{AND RETURN BUILDING NMBLK{17486
*
*      HERE IF BAD ARGUMENT
*
{SSTX2{ERB{1,187{26,SETEXIT argument is not label name or null{{{17490
*
*      SIN
*
{S$SIN{ENT{{{{ENTRY POINT{17495
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17496
{{JSR{6,GTREA{{{CONVERT TO REAL{17497
{{ERR{1,308{26,SIN argument not numeric{{{17498
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17499
{{SIN{{{{TAKE SINE{17500
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{17501
{{ERB{1,323{26,SIN argument is out of range{{{17502
{{EJC{{{{{17503
*
*      SQRT
*
{S$SQR{ENT{{{{ENTRY POINT{17509
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17510
{{JSR{6,GTREA{{{CONVERT TO REAL{17511
{{ERR{1,313{26,SQRT argument not numeric{{{17512
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17513
{{RLT{6,SSQR1{{{NEGATIVE NUMBER{17514
{{SQR{{{{TAKE SQUARE ROOT{17515
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE, RESULT IN RA{17516
*
*      HERE IF BAD ARGUMENT
*
{SSQR1{ERB{1,314{26,SQRT argument negative{{{17520
{{EJC{{{{{17521
{{EJC{{{{{17525
*
*      SORT
*
{S$SRT{ENT{{{{ENTRY POINT{17529
{{ZER{8,WA{{{MARK AS SORT{17530
{{JSR{6,SORTA{{{CALL SORT ROUTINE{17531
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{17532
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{17533
{{EJC{{{{{17535
*
*      SPAN
*
{S$SPN{ENT{{{{ENTRY POINT{17539
{{MOV{22,=P$SPS{8,WB{{SET PCODE FOR SINGLE CHAR ARG{17540
{{MOV{22,=P$SPN{7,XL{{SET PCODE FOR MULTI-CHAR ARG{17541
{{MOV{22,=P$SPD{8,WC{{SET PCODE FOR EXPRESSION ARG{17542
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{17543
{{ERR{1,188{26,SPAN argument is not a string or expression{{{17544
{{MOV{7,XR{11,-(XS){{STACK RESULT{17545
{{LCW{7,XR{{{GET NEXT CODE WORD{17546
{{BRI{9,(XR){{{EXECUTE IT{17547
{{EJC{{{{{17548
*
*      SIZE
*
{S$SI${ENT{{{{ENTRY POINT{17552
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{17554
{{ERR{1,189{26,SIZE argument is not a string{{{17555
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH.
*
{{MTI{8,WA{{{LOAD LENGTH AS INTEGER{17563
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{17564
{{EJC{{{{{17565
*
*      STOPTR
*
{S$STT{ENT{{{{ENTRY POINT{17569
{{ZER{7,XL{{{INDICATE STOPTR CASE{17570
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{17571
{{ERR{1,190{26,STOPTR first argument is not appropriate name{{{17572
{{ERR{1,191{26,STOPTR second argument is not trace type{{{17573
{{BRN{6,EXNUL{{{RETURN NULL{17574
{{EJC{{{{{17575
*
*      SUBSTR
*
{S$SUB{ENT{{{{ENTRY POINT{17579
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{17580
{{ERR{1,192{26,SUBSTR third argument is not integer{{{17581
{{PPM{6,EXFAL{{{JUMP IF NEGATIVE OR TOO LARGE{17582
{{MOV{7,XR{3,SBSSV{{SAVE THIRD ARGUMENT{17583
{{JSR{6,GTSMI{{{LOAD SECOND ARGUMENT{17584
{{ERR{1,193{26,SUBSTR second argument is not integer{{{17585
{{PPM{6,EXFAL{{{JUMP IF OUT OF RANGE{17586
{{MOV{7,XR{8,WC{{SAVE SECOND ARGUMENT{17587
{{BZE{8,WC{6,EXFAL{{JUMP IF SECOND ARGUMENT ZERO{17588
{{DCV{8,WC{{{ELSE DECREMENT FOR ONES ORIGIN{17589
{{JSR{6,GTSTG{{{LOAD FIRST ARGUMENT{17591
{{ERR{1,194{26,SUBSTR first argument is not a string{{{17592
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH
*
{{MOV{8,WC{8,WB{{COPY SECOND ARG TO WB{17600
{{MOV{3,SBSSV{8,WC{{RELOAD THIRD ARGUMENT{17601
{{BNZ{8,WC{6,SSUB2{{SKIP IF THIRD ARG GIVEN{17602
{{MOV{8,WA{8,WC{{ELSE GET STRING LENGTH{17603
{{BGT{8,WB{8,WC{6,EXFAL{FAIL IF IMPROPER{17604
{{SUB{8,WB{8,WC{{REDUCE BY OFFSET TO START{17605
*
*      MERGE
*
{SSUB2{MOV{8,WA{7,XL{{SAVE STRING LENGTH{17609
{{MOV{8,WC{8,WA{{SET LENGTH OF SUBSTRING{17610
{{ADD{8,WB{8,WC{{ADD 2ND ARG TO 3RD ARG{17611
{{BGT{8,WC{7,XL{6,EXFAL{JUMP IF IMPROPER SUBSTRING{17612
{{MOV{7,XR{7,XL{{COPY POINTER TO FIRST ARG{17613
{{JSR{6,SBSTR{{{BUILD SUBSTRING{17614
{{MOV{7,XR{11,-(XS){{STACK RESULT{17615
{{LCW{7,XR{{{GET NEXT CODE WORD{17616
{{BRI{9,(XR){{{EXECUTE IT{17617
{{EJC{{{{{17618
*
*      TABLE
*
{S$TBL{ENT{{{{ENTRY POINT{17622
{{MOV{10,(XS)+{7,XL{{GET INITIAL LOOKUP VALUE{17623
{{ICA{7,XS{{{POP SECOND ARGUMENT{17624
{{JSR{6,GTSMI{{{LOAD ARGUMENT{17625
{{ERR{1,195{26,TABLE argument is not integer{{{17626
{{ERR{1,196{26,TABLE argument is out of range{{{17627
{{BNZ{8,WC{6,STBL1{{JUMP IF NON-ZERO{17628
{{MOV{18,=TBNBK{8,WC{{ELSE SUPPLY DEFAULT VALUE{17629
*
*      MERGE HERE WITH NUMBER OF HEADERS IN WC
*
{STBL1{JSR{6,TMAKE{{{MAKE TABLE{17633
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{17634
{{EJC{{{{{17635
*
*      TAN
*
{S$TAN{ENT{{{{ENTRY POINT{17640
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17641
{{JSR{6,GTREA{{{CONVERT TO REAL{17642
{{ERR{1,309{26,TAN argument not numeric{{{17643
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17644
{{TAN{{{{TAKE TANGENT{17645
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{17646
{{ERB{1,310{26,TAN produced real overflow or argument is out of range{{{17647
{{EJC{{{{{17648
*
*      TIME
*
{S$TIM{ENT{{{{ENTRY POINT{17653
{{JSR{6,SYSTM{{{GET TIMER VALUE{17654
{{SBI{3,TIMSX{{{SUBTRACT STARTING TIME{17655
{{BRN{6,EXINT{{{EXIT WITH INTEGER VALUE{17656
{{EJC{{{{{17657
*
*      TRACE
*
{S$TRA{ENT{{{{ENTRY POINT{17661
{{BEQ{13,NUM03(XS){21,=NULLS{6,STR02{JUMP IF FIRST ARGUMENT IS NULL{17662
{{MOV{10,(XS)+{7,XR{{LOAD FOURTH ARGUMENT{17663
{{ZER{7,XL{{{TENTATIVELY SET ZERO POINTER{17664
{{BEQ{7,XR{21,=NULLS{6,STR01{JUMP IF 4TH ARGUMENT IS NULL{17665
{{JSR{6,GTNVR{{{ELSE POINT TO VRBLK{17666
{{PPM{6,STR03{{{JUMP IF NOT VARIABLE NAME{17667
{{MOV{7,XR{7,XL{{ELSE SAVE VRBLK IN TRFNC{17668
*
*      HERE WITH VRBLK OR ZERO IN XL
*
{STR01{MOV{10,(XS)+{7,XR{{LOAD THIRD ARGUMENT (TAG){17672
{{ZER{8,WB{{{SET ZERO AS TRTYP VALUE FOR NOW{17673
{{JSR{6,TRBLD{{{BUILD TRBLK FOR TRACE CALL{17674
{{MOV{7,XR{7,XL{{MOVE TRBLK POINTER FOR TRACE{17675
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{17676
{{ERR{1,198{26,TRACE first argument is not appropriate name{{{17677
{{ERR{1,199{26,TRACE second argument is not trace type{{{17678
{{BRN{6,EXNUL{{{RETURN NULL{17679
*
*      HERE TO CALL SYSTEM TRACE TOGGLE ROUTINE
*
{STR02{JSR{6,SYSTT{{{CALL IT{17683
{{ADD{19,*NUM04{7,XS{{POP TRACE ARGUMENTS{17684
{{BRN{6,EXNUL{{{RETURN{17685
*
*      HERE FOR BAD FOURTH ARGUMENT
*
{STR03{ERB{1,197{26,TRACE fourth arg is not function name or null{{{17689
{{EJC{{{{{17690
*
*      TRIM
*
{S$TRM{ENT{{{{ENTRY POINT{17694
{{JSR{6,GTSTG{{{LOAD ARGUMENT AS STRING{17696
{{ERR{1,200{26,TRIM argument is not a string{{{17697
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF ARGUMENT IS NULL{17703
{{MOV{7,XR{7,XL{{COPY STRING POINTER{17704
{{CTB{8,WA{2,SCHAR{{GET BLOCK LENGTH{17705
{{JSR{6,ALLOC{{{ALLOCATE COPY SAME SIZE{17706
{{MOV{7,XR{8,WB{{SAVE POINTER TO COPY{17707
{{MVW{{{{COPY OLD STRING BLOCK TO NEW{17708
{{MOV{8,WB{7,XR{{RESTORE PTR TO NEW BLOCK{17709
{{JSR{6,TRIMR{{{TRIM BLANKS (WB IS NON-ZERO){17710
{{MOV{7,XR{11,-(XS){{STACK RESULT{17711
{{LCW{7,XR{{{GET NEXT CODE WORD{17712
{{BRI{9,(XR){{{EXECUTE IT{17713
{{EJC{{{{{17756
*
*      UNLOAD
*
{S$UNL{ENT{{{{ENTRY POINT{17760
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{17761
{{JSR{6,GTNVR{{{POINT TO VRBLK{17762
{{ERR{1,201{26,UNLOAD argument is not natural variable name{{{17763
{{MOV{21,=STNDF{7,XL{{GET PTR TO UNDEFINED FUNCTION{17764
{{JSR{6,DFFNC{{{UNDEFINE NAMED FUNCTION{17765
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{17766
{{TTL{27,S P I T B O L -- UTILITY ROUTINES{{{{17788
*
*      THE FOLLOWING SECTION CONTAINS UTILITY ROUTINES USED FOR
*      VARIOUS PURPOSES THROUGHOUT THE SYSTEM. THESE DIFFER
*      FROM THE PROCEDURES IN THE UTILITY PROCEDURES SECTION IN
*      THEY ARE NOT IN PROCEDURE FORM AND THEY DO NOT RETURN
*      TO THEIR CALLERS. THEY ARE ACCESSED WITH A BRANCH TYPE
*      INSTRUCTION AFTER SETTING THE REGISTERS TO APPROPRIATE
*      PARAMETER VALUES.
*
*      THE REGISTER VALUES REQUIRED FOR EACH ROUTINE ARE
*      DOCUMENTED AT THE START OF EACH ROUTINE. REGISTERS NOT
*      MENTIONED MAY CONTAIN ANY VALUES EXCEPT THAT XR,XL
*      CAN ONLY CONTAIN PROPER COLLECTABLE POINTERS.
*
*      SOME OF THESE ROUTINES WILL TOLERATE GARBAGE POINTERS
*      IN XL,XR ON ENTRY. THIS IS ALWAYS DOCUMENTED AND IN
*      EACH CASE, THE ROUTINE CLEARS THESE GARBAGE VALUES BEFORE
*      EXITING AFTER COMPLETING ITS TASK.
*
*      THE ROUTINES HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE ASSEMBLED IN ALPHABETICAL ORDER.
{{EJC{{{{{17810
*      ARREF -- ARRAY REFERENCE
*
*      (XL)                  MAY BE NON-COLLECTABLE
*      (XR)                  NUMBER OF SUBSCRIPTS
*      (WB)                  SET ZERO/NONZERO FOR VALUE/NAME
*                            THE VALUE IN WB MUST BE COLLECTABLE
*      STACK                 SUBSCRIPTS AND ARRAY OPERAND
*      BRN  ARREF            JUMP TO CALL FUNCTION
*
*      ARREF CONTINUES BY EXECUTING THE NEXT CODE WORD WITH
*      THE RESULT NAME OR VALUE PLACED ON TOP OF THE STACK.
*      TO DEAL WITH THE PROBLEM OF ACCESSING SUBSCRIPTS IN THE
*      ORDER OF STACKING, XL IS USED AS A SUBSCRIPT POINTER
*      WORKING BELOW THE STACK POINTER.
*
{ARREF{RTN{{{{{17826
{{MOV{7,XR{8,WA{{COPY NUMBER OF SUBSCRIPTS{17827
{{MOV{7,XS{7,XT{{POINT TO STACK FRONT{17828
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{17829
{{ADD{7,XR{7,XT{{POINT TO ARRAY OPERAND ON STACK{17830
{{ICA{7,XT{{{FINAL VALUE FOR STACK POPPING{17831
{{MOV{7,XT{3,ARFXS{{KEEP FOR LATER{17832
{{MOV{11,-(XT){7,XR{{LOAD ARRAY OPERAND POINTER{17833
{{MOV{7,XR{3,R$ARF{{KEEP ARRAY POINTER{17834
{{MOV{7,XT{7,XR{{SAVE POINTER TO SUBSCRIPTS{17835
{{MOV{3,R$ARF{7,XL{{POINT XL TO POSSIBLE VCBLK OR TBBLK{17836
{{MOV{9,(XL){8,WC{{LOAD FIRST WORD{17837
{{BEQ{8,WC{22,=B$ART{6,ARF01{JUMP IF ARBLK{17838
{{BEQ{8,WC{22,=B$VCT{6,ARF07{JUMP IF VCBLK{17839
{{BEQ{8,WC{22,=B$TBT{6,ARF10{JUMP IF TBBLK{17840
{{ERB{1,235{26,Subscripted operand is not table or array{{{17841
*
*      HERE FOR ARRAY (ARBLK)
*
{ARF01{BNE{8,WA{13,ARNDM(XL){6,ARF09{JUMP IF WRONG NUMBER OF DIMS{17845
{{LDI{4,INTV0{{{GET INITIAL SUBSCRIPT OF ZERO{17846
{{MOV{7,XR{7,XT{{POINT BEFORE SUBSCRIPTS{17847
{{ZER{8,WA{{{INITIAL OFFSET TO BOUNDS{17848
{{BRN{6,ARF03{{{JUMP INTO LOOP{17849
*
*      LOOP TO COMPUTE SUBSCRIPTS BY MULTIPLICATIONS
*
{ARF02{MLI{13,ARDM2(XR){{{MULTIPLY TOTAL BY NEXT DIMENSION{17853
*
*      MERGE HERE FIRST TIME
*
{ARF03{MOV{11,-(XT){7,XR{{LOAD NEXT SUBSCRIPT{17857
{{STI{3,ARFSI{{{SAVE CURRENT SUBSCRIPT{17858
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE IN CASE{17859
{{BEQ{9,(XR){22,=B$ICL{6,ARF04{JUMP IF IT WAS AN INTEGER{17860
{{EJC{{{{{17861
*
*      ARREF (CONTINUED)
*
*
{{JSR{6,GTINT{{{CONVERT TO INTEGER{17866
{{PPM{6,ARF12{{{JUMP IF NOT INTEGER{17867
{{LDI{13,ICVAL(XR){{{IF OK, LOAD INTEGER VALUE{17868
*
*      HERE WITH INTEGER SUBSCRIPT IN (IA)
*
{ARF04{MOV{3,R$ARF{7,XR{{POINT TO ARRAY{17872
{{ADD{8,WA{7,XR{{OFFSET TO NEXT BOUNDS{17873
{{SBI{13,ARLBD(XR){{{SUBTRACT LOW BOUND TO COMPARE{17874
{{IOV{6,ARF13{{{OUT OF RANGE FAIL IF OVERFLOW{17875
{{ILT{6,ARF13{{{OUT OF RANGE FAIL IF TOO SMALL{17876
{{SBI{13,ARDIM(XR){{{SUBTRACT DIMENSION{17877
{{IGE{6,ARF13{{{OUT OF RANGE FAIL IF TOO LARGE{17878
{{ADI{13,ARDIM(XR){{{ELSE RESTORE SUBSCRIPT OFFSET{17879
{{ADI{3,ARFSI{{{ADD TO CURRENT TOTAL{17880
{{ADD{19,*ARDMS{8,WA{{POINT TO NEXT BOUNDS{17881
{{BNE{7,XT{7,XS{6,ARF02{LOOP BACK IF MORE TO GO{17882
*
*      HERE WITH INTEGER SUBSCRIPT COMPUTED
*
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{17886
{{WTB{8,WA{{{CONVERT TO OFFSET{17887
{{MOV{3,R$ARF{7,XL{{POINT TO ARBLK{17888
{{ADD{13,AROFS(XL){8,WA{{ADD OFFSET PAST BOUNDS{17889
{{ICA{8,WA{{{ADJUST FOR ARPRO FIELD{17890
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{17891
*
*      MERGE HERE TO GET VALUE FOR VALUE CALL
*
{ARF05{JSR{6,ACESS{{{GET VALUE{17895
{{PPM{6,ARF13{{{FAIL IF ACESS FAILS{17896
*
*      RETURN VALUE
*
{ARF06{MOV{3,ARFXS{7,XS{{POP STACK ENTRIES{17900
{{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17901
{{MOV{7,XR{11,-(XS){{STACK RESULT{17902
{{LCW{7,XR{{{GET NEXT CODE WORD{17903
{{BRI{9,(XR){{{EXECUTE IT{17904
{{EJC{{{{{17905
*
*      ARREF (CONTINUED)
*
*      HERE FOR VECTOR
*
{ARF07{BNE{8,WA{18,=NUM01{6,ARF09{ERROR IF MORE THAN 1 SUBSCRIPT{17911
{{MOV{9,(XS){7,XR{{ELSE LOAD SUBSCRIPT{17912
{{JSR{6,GTINT{{{CONVERT TO INTEGER{17913
{{PPM{6,ARF12{{{ERROR IF NOT INTEGER{17914
{{LDI{13,ICVAL(XR){{{ELSE LOAD INTEGER VALUE{17915
{{SBI{4,INTV1{{{SUBTRACT FOR ONES OFFSET{17916
{{MFI{8,WA{6,ARF13{{GET SUBSCRIPT AS ONE WORD{17917
{{ADD{18,=VCVLS{8,WA{{ADD OFFSET FOR STANDARD FIELDS{17918
{{WTB{8,WA{{{CONVERT OFFSET TO BYTES{17919
{{BGE{8,WA{13,VCLEN(XL){6,ARF13{FAIL IF OUT OF RANGE SUBSCRIPT{17920
{{BZE{8,WB{6,ARF05{{BACK TO GET VALUE IF VALUE CALL{17921
*
*      RETURN NAME
*
{ARF08{MOV{3,ARFXS{7,XS{{POP STACK ENTRIES{17925
{{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17926
{{BRN{6,EXNAM{{{ELSE EXIT WITH NAME{17927
*
*      HERE IF SUBSCRIPT COUNT IS WRONG
*
{ARF09{ERB{1,236{26,Array referenced with wrong number of subscripts{{{17931
*
*      TABLE
*
{ARF10{BNE{8,WA{18,=NUM01{6,ARF11{ERROR IF MORE THAN 1 SUBSCRIPT{17935
{{MOV{9,(XS){7,XR{{ELSE LOAD SUBSCRIPT{17936
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{17937
{{PPM{6,ARF13{{{FAIL IF FAILED{17938
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{17939
{{BRN{6,ARF06{{{ELSE EXIT WITH VALUE{17940
*
*      HERE FOR BAD TABLE REFERENCE
*
{ARF11{ERB{1,237{26,Table referenced with more than one subscript{{{17944
*
*      HERE FOR BAD SUBSCRIPT
*
{ARF12{ERB{1,238{26,Array subscript is not integer{{{17948
*
*      HERE TO SIGNAL FAILURE
*
{ARF13{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17952
{{BRN{6,EXFAL{{{FAIL{17953
{{EJC{{{{{17954
*
*      CFUNC -- CALL A FUNCTION
*
*      CFUNC IS USED TO CALL A SNOBOL LEVEL FUNCTION. IT IS
*      USED BY THE APPLY FUNCTION (S$APP), THE FUNCTION
*      TRACE ROUTINE (TRXEQ) AND THE MAIN FUNCTION CALL ENTRY
*      (O$FNC, O$FNS). IN THE LATTER CASES, CFUNC IS USED ONLY
*      IF THE NUMBER OF ARGUMENTS IS INCORRECT.
*
*      (XL)                  POINTER TO FUNCTION BLOCK
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS
*      (XS)                  POINTS TO STACKED ARGUMENTS
*      BRN  CFUNC            JUMP TO CALL FUNCTION
*
*      CFUNC CONTINUES BY EXECUTING THE FUNCTION
*
{CFUNC{RTN{{{{{17971
{{BLT{8,WA{13,FARGS(XL){6,CFNC1{JUMP IF TOO FEW ARGUMENTS{17972
{{BEQ{8,WA{13,FARGS(XL){6,CFNC3{JUMP IF CORRECT NUMBER OF ARGS{17973
*
*      HERE IF TOO MANY ARGUMENTS SUPPLIED, POP THEM OFF
*
{{MOV{8,WA{8,WB{{COPY ACTUAL NUMBER{17977
{{SUB{13,FARGS(XL){8,WB{{GET NUMBER OF EXTRA ARGS{17978
{{WTB{8,WB{{{CONVERT TO BYTES{17979
{{ADD{8,WB{7,XS{{POP OFF UNWANTED ARGUMENTS{17980
{{BRN{6,CFNC3{{{JUMP TO GO OFF TO FUNCTION{17981
*
*      HERE IF TOO FEW ARGUMENTS
*
{CFNC1{MOV{13,FARGS(XL){8,WB{{LOAD REQUIRED NUMBER OF ARGUMENTS{17985
{{BEQ{8,WB{18,=NINI9{6,CFNC3{JUMP IF CASE OF VAR NUM OF ARGS{17986
{{SUB{8,WA{8,WB{{CALCULATE NUMBER MISSING{17987
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{17988
*
*      LOOP TO SUPPLY EXTRA NULL ARGUMENTS
*
{CFNC2{MOV{21,=NULLS{11,-(XS){{STACK A NULL ARGUMENT{17992
{{BCT{8,WB{6,CFNC2{{LOOP TILL PROPER NUMBER STACKED{17993
*
*      MERGE HERE TO JUMP TO FUNCTION
*
{CFNC3{BRI{9,(XL){{{JUMP THROUGH FCODE FIELD{17997
{{EJC{{{{{17998
*
*      EXFAL -- EXIT SIGNALLING SNOBOL FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXFAL            JUMP TO FAIL
*
*      EXFAL CONTINUES BY EXECUTING THE APPROPRIATE FAIL GOTO
*
{EXFAL{RTN{{{{{18007
{{MOV{3,FLPTR{7,XS{{POP STACK{18008
{{MOV{9,(XS){7,XR{{LOAD FAILURE OFFSET{18009
{{ADD{3,R$COD{7,XR{{POINT TO FAILURE CODE LOCATION{18010
{{LCP{7,XR{{{SET CODE POINTER{18011
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18012
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18013
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18014
{{EJC{{{{{18015
*
*      EXINT -- EXIT WITH INTEGER RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (IA)                  INTEGER VALUE
*      BRN  EXINT            JUMP TO EXIT WITH INTEGER
*
*      EXINT CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXIXR
*
{EXINT{RTN{{{{{18026
{{ZER{7,XL{{{CLEAR DUD VALUE{18027
{{JSR{6,ICBLD{{{BUILD ICBLK{18028
{{EJC{{{{{18029
*      EXIXR -- EXIT WITH RESULT IN (XR)
*
*      (XR)                  RESULT
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXIXR            JUMP TO EXIT WITH RESULT IN (XR)
*
*      EXIXR CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXITS.
{EXIXR{RTN{{{{{18038
*
{{MOV{7,XR{11,-(XS){{STACK RESULT{18040
*
*
*      EXITS -- EXIT WITH RESULT IF ANY STACKED
*
*      (XR,XL)               MAY BE NON-COLLECTABLE
*
*      BRN  EXITS            ENTER EXITS ROUTINE
*
{EXITS{RTN{{{{{18049
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18050
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18051
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18052
{{EJC{{{{{18053
*
*      EXNAM -- EXIT WITH NAME IN (XL,WA)
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      (XR)                  MAY BE NON-COLLECTABLE
*      BRN  EXNAM            JUMP TO EXIT WITH NAME IN (XL,WA)
*
*      EXNAM CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNAM{RTN{{{{{18064
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{18065
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{18066
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18067
{{BRI{9,(XR){{{EXECUTE IT{18068
{{EJC{{{{{18069
*
*      EXNUL -- EXIT WITH NULL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXNUL            JUMP TO EXIT WITH NULL VALUE
*
*      EXNUL CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNUL{RTN{{{{{18078
{{MOV{21,=NULLS{11,-(XS){{STACK NULL VALUE{18079
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18080
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18081
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18082
{{EJC{{{{{18083
*
*      EXREA -- EXIT WITH REAL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (RA)                  REAL VALUE
*      BRN  EXREA            JUMP TO EXIT WITH REAL VALUE
*
*      EXREA CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXREA{RTN{{{{{18095
{{ZER{7,XL{{{CLEAR DUD VALUE{18096
{{JSR{6,RCBLD{{{BUILD RCBLK{18097
{{BRN{6,EXIXR{{{JUMP TO EXIT WITH RESULT IN XR{18098
{{EJC{{{{{18100
*
*      EXSID -- EXIT SETTING ID FIELD
*
*      EXSID IS USED TO EXIT AFTER BUILDING ANY OF THE FOLLOWING
*      BLOCKS (ARBLK, TBBLK, PDBLK, VCBLK). IT SETS THE IDVAL.
*
*      (XR)                  PTR TO BLOCK WITH IDVAL FIELD
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXSID            JUMP TO EXIT AFTER SETTING ID FIELD
*
*      EXSID CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXSID{RTN{{{{{18113
{{MOV{3,CURID{8,WA{{LOAD CURRENT ID VALUE{18114
{{BNE{8,WA{18,=CFP$M{6,EXSI1{JUMP IF NO OVERFLOW{18115
{{ZER{8,WA{{{ELSE RESET FOR WRAPAROUND{18116
*
*      HERE WITH OLD IDVAL IN WA
*
{EXSI1{ICV{8,WA{{{BUMP ID VALUE{18120
{{MOV{8,WA{3,CURID{{STORE FOR NEXT TIME{18121
{{MOV{8,WA{13,IDVAL(XR){{STORE ID VALUE{18122
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN (XR){18123
{{EJC{{{{{18124
*
*      EXVNM -- EXIT WITH NAME OF VARIABLE
*
*      EXVNM EXITS AFTER STACKING A VALUE WHICH IS A NMBLK
*      REFERENCING THE NAME OF A GIVEN NATURAL VARIABLE.
*
*      (XR)                  VRBLK POINTER
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXVNM            EXIT WITH VRBLK POINTER IN XR
*
{EXVNM{RTN{{{{{18135
{{MOV{7,XR{7,XL{{COPY NAME BASE POINTER{18136
{{MOV{19,*NMSI${8,WA{{SET SIZE OF NMBLK{18137
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{18138
{{MOV{22,=B$NML{9,(XR){{STORE TYPE WORD{18139
{{MOV{7,XL{13,NMBAS(XR){{STORE NAME BASE{18140
{{MOV{19,*VRVAL{13,NMOFS(XR){{STORE NAME OFFSET{18141
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN XR{18142
{{EJC{{{{{18143
*
*      FLPOP -- FAIL AND POP IN PATTERN MATCHING
*
*      FLPOP POPS THE NODE AND CURSOR ON THE STACK AND THEN
*      DROPS THROUGH INTO FAILP TO CAUSE PATTERN FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FLPOP            JUMP TO FAIL AND POP STACK
*
{FLPOP{RTN{{{{{18153
{{ADD{19,*NUM02{7,XS{{POP TWO ENTRIES OFF STACK{18154
{{EJC{{{{{18155
*
*      FAILP -- FAILURE IN MATCHING PATTERN NODE
*
*      FAILP IS USED AFTER FAILING TO MATCH A PATTERN NODE.
*      SEE PATTERN MATCH ROUTINES FOR DETAILS OF USE.
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FAILP            SIGNAL FAILURE TO MATCH
*
*      FAILP CONTINUES BY MATCHING AN ALTERNATIVE FROM THE STACK
*
{FAILP{RTN{{{{{18167
{{MOV{10,(XS)+{7,XR{{LOAD ALTERNATIVE NODE POINTER{18168
{{MOV{10,(XS)+{8,WB{{RESTORE OLD CURSOR{18169
{{MOV{9,(XR){7,XL{{LOAD PCODE ENTRY POINTER{18170
{{BRI{7,XL{{{JUMP TO EXECUTE CODE FOR NODE{18171
{{EJC{{{{{18172
*
*      INDIR -- COMPUTE INDIRECT REFERENCE
*
*      (WB)                  NONZERO/ZERO FOR BY NAME/VALUE
*      BRN  INDIR            JUMP TO GET INDIRECT REF ON STACK
*
*      INDIR CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{INDIR{RTN{{{{{18181
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{18182
{{BEQ{9,(XR){22,=B$NML{6,INDR2{JUMP IF A NAME{18183
{{JSR{6,GTNVR{{{ELSE CONVERT TO VARIABLE{18184
{{ERR{1,239{26,Indirection operand is not name{{{18185
{{BZE{8,WB{6,INDR1{{SKIP IF BY VALUE{18186
{{MOV{7,XR{11,-(XS){{ELSE STACK VRBLK PTR{18187
{{MOV{19,*VRVAL{11,-(XS){{STACK NAME OFFSET{18188
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18189
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18190
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18191
*
*      HERE TO GET VALUE OF NATURAL VARIABLE
*
{INDR1{BRI{9,(XR){{{JUMP THROUGH VRGET FIELD OF VRBLK{18195
*
*      HERE IF OPERAND IS A NAME
*
{INDR2{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{18199
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{18200
{{BNZ{8,WB{6,EXNAM{{EXIT IF CALLED BY NAME{18201
{{JSR{6,ACESS{{{ELSE GET VALUE FIRST{18202
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18203
{{BRN{6,EXIXR{{{ELSE RETURN WITH VALUE IN XR{18204
{{EJC{{{{{18205
*
*      MATCH -- INITIATE PATTERN MATCH
*
*      (WB)                  MATCH TYPE CODE
*      BRN  MATCH            JUMP TO INITIATE PATTERN MATCH
*
*      MATCH CONTINUES BY EXECUTING THE PATTERN MATCH. SEE
*      PATTERN MATCH ROUTINES (P$XXX) FOR FULL DETAILS.
*
{MATCH{RTN{{{{{18215
{{MOV{10,(XS)+{7,XR{{LOAD PATTERN OPERAND{18216
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{18217
{{ERR{1,240{26,Pattern match right operand is not pattern{{{18218
{{MOV{7,XR{7,XL{{IF OK, SAVE PATTERN POINTER{18219
{{BNZ{8,WB{6,MTCH1{{JUMP IF NOT MATCH BY NAME{18220
{{MOV{9,(XS){8,WA{{ELSE LOAD NAME OFFSET{18221
{{MOV{7,XL{11,-(XS){{SAVE PATTERN POINTER{18222
{{MOV{13,NUM02(XS){7,XL{{LOAD NAME BASE{18223
{{JSR{6,ACESS{{{ACCESS SUBJECT VALUE{18224
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18225
{{MOV{9,(XS){7,XL{{RESTORE PATTERN POINTER{18226
{{MOV{7,XR{9,(XS){{STACK SUBJECT STRING VAL FOR MERGE{18227
{{ZER{8,WB{{{RESTORE TYPE CODE{18228
*
*      MERGE HERE WITH SUBJECT VALUE ON STACK
*
{MTCH1{JSR{6,GTSTG{{{CONVERT SUBJECT TO STRING{18233
{{ERR{1,241{26,Pattern match left operand is not a string{{{18234
{{MOV{8,WB{11,-(XS){{STACK MATCH TYPE CODE{18235
{{MOV{7,XR{3,R$PMS{{IF OK, STORE SUBJECT STRING POINTER{18243
{{MOV{8,WA{3,PMSSL{{AND LENGTH{18244
{{ZER{11,-(XS){{{STACK INITIAL CURSOR (ZERO){18245
{{ZER{8,WB{{{SET INITIAL CURSOR{18246
{{MOV{7,XS{3,PMHBS{{SET HISTORY STACK BASE PTR{18247
{{ZER{3,PMDFL{{{RESET PATTERN ASSIGNMENT FLAG{18248
{{MOV{7,XL{7,XR{{SET INITIAL NODE POINTER{18249
{{BNZ{3,KVANC{6,MTCH2{{JUMP IF ANCHORED{18250
*
*      HERE FOR UNANCHORED
*
{{MOV{7,XR{11,-(XS){{STACK INITIAL NODE POINTER{18254
{{MOV{21,=NDUNA{11,-(XS){{STACK POINTER TO ANCHOR MOVE NODE{18255
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{18256
*
*      HERE IN ANCHORED MODE
*
{MTCH2{ZER{11,-(XS){{{DUMMY CURSOR VALUE{18260
{{MOV{21,=NDABO{11,-(XS){{STACK POINTER TO ABORT NODE{18261
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{18262
{{EJC{{{{{18263
*
*      RETRN -- RETURN FROM FUNCTION
*
*      (WA)                  STRING POINTER FOR RETURN TYPE
*      BRN  RETRN            JUMP TO RETURN FROM (SNOBOL) FUNC
*
*      RETRN CONTINUES BY EXECUTING THE CODE AT THE RETURN POINT
*      THE STACK IS CLEANED OF ANY GARBAGE LEFT BY OTHER
*      ROUTINES WHICH MAY HAVE ALTERED FLPTR SINCE FUNCTION
*      ENTRY BY USING FLPRT, RESERVED FOR USE ONLY BY
*      FUNCTION CALL AND RETURN.
*
{RETRN{RTN{{{{{18276
{{BNZ{3,KVFNC{6,RTN01{{JUMP IF NOT LEVEL ZERO{18277
{{ERB{1,242{26,Function return from level zero{{{18278
*
*      HERE IF NOT LEVEL ZERO RETURN
*
{RTN01{MOV{3,FLPRT{7,XS{{POP STACK{18282
{{ICA{7,XS{{{REMOVE FAILURE OFFSET{18283
{{MOV{10,(XS)+{7,XR{{POP PFBLK POINTER{18284
{{MOV{10,(XS)+{3,FLPTR{{POP FAILURE POINTER{18285
{{MOV{10,(XS)+{3,FLPRT{{POP OLD FLPRT{18286
{{MOV{10,(XS)+{8,WB{{POP CODE POINTER OFFSET{18287
{{MOV{10,(XS)+{8,WC{{POP OLD CODE BLOCK POINTER{18288
{{ADD{8,WC{8,WB{{MAKE OLD CODE POINTER ABSOLUTE{18289
{{LCP{8,WB{{{RESTORE OLD CODE POINTER{18290
{{MOV{8,WC{3,R$COD{{RESTORE OLD CODE BLOCK POINTER{18291
{{DCV{3,KVFNC{{{DECREMENT FUNCTION LEVEL{18292
{{MOV{3,KVTRA{8,WB{{LOAD TRACE{18293
{{ADD{3,KVFTR{8,WB{{ADD FTRACE{18294
{{BZE{8,WB{6,RTN06{{JUMP IF NO TRACING POSSIBLE{18295
*
*      HERE IF THERE MAY BE A TRACE
*
{{MOV{8,WA{11,-(XS){{SAVE FUNCTION RETURN TYPE{18299
{{MOV{7,XR{11,-(XS){{SAVE PFBLK POINTER{18300
{{MOV{8,WA{3,KVRTN{{SET RTNTYPE FOR TRACE FUNCTION{18301
{{MOV{3,R$FNC{7,XL{{LOAD FNCLEVEL TRBLK PTR (IF ANY){18302
{{JSR{6,KTREX{{{EXECUTE POSSIBLE FNCLEVEL TRACE{18303
{{MOV{13,PFVBL(XR){7,XL{{LOAD VRBLK PTR (SGD13){18304
{{BZE{3,KVTRA{6,RTN02{{JUMP IF TRACE IS OFF{18305
{{MOV{13,PFRTR(XR){7,XR{{ELSE LOAD RETURN TRACE TRBLK PTR{18306
{{BZE{7,XR{6,RTN02{{JUMP IF NOT RETURN TRACED{18307
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{18308
{{BZE{13,TRFNC(XR){6,RTN03{{JUMP IF PRINT TRACE{18309
{{MOV{19,*VRVAL{8,WA{{ELSE SET NAME OFFSET{18310
{{MOV{13,NUM01(XS){3,KVRTN{{MAKE SURE RTNTYPE IS SET RIGHT{18311
{{JSR{6,TRXEQ{{{EXECUTE FULL TRACE{18312
{{EJC{{{{{18313
*
*      RETRN (CONTINUED)
*
*      HERE TO TEST FOR FTRACE
*
{RTN02{BZE{3,KVFTR{6,RTN05{{JUMP IF FTRACE IS OFF{18319
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{18320
*
*      HERE FOR PRINT TRACE OF FUNCTION RETURN
*
{RTN03{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{18324
{{MOV{13,NUM01(XS){7,XR{{LOAD RETURN TYPE{18325
{{JSR{6,PRTST{{{PRINT IT{18326
{{MOV{18,=CH$BL{8,WA{{LOAD BLANK{18327
{{JSR{6,PRTCH{{{PRINT IT{18328
{{MOV{12,0(XS){7,XL{{LOAD PFBLK PTR{18329
{{MOV{13,PFVBL(XL){7,XL{{LOAD FUNCTION VRBLK PTR{18330
{{MOV{19,*VRVAL{8,WA{{SET VRBLK NAME OFFSET{18331
{{BNE{7,XR{21,=SCFRT{6,RTN04{JUMP IF NOT FRETURN CASE{18332
*
*      FOR FRETURN, JUST PRINT FUNCTION NAME
*
{{JSR{6,PRTNM{{{PRINT NAME{18336
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{18337
{{BRN{6,RTN05{{{MERGE{18338
*
*      HERE FOR RETURN OR NRETURN, PRINT FUNCTION NAME = VALUE
*
{RTN04{JSR{6,PRTNV{{{PRINT NAME = VALUE{18342
*
*      HERE AFTER COMPLETING TRACE
*
{RTN05{MOV{10,(XS)+{7,XR{{POP PFBLK POINTER{18346
{{MOV{10,(XS)+{8,WA{{POP RETURN TYPE STRING{18347
*
*      MERGE HERE IF NO TRACE REQUIRED
*
{RTN06{MOV{8,WA{3,KVRTN{{SET RTNTYPE KEYWORD{18351
{{MOV{13,PFVBL(XR){7,XL{{LOAD POINTER TO FN VRBLK{18352
{{EJC{{{{{18353
*      RETRN (CONTINUED)
*
*      GET VALUE OF FUNCTION
*
{RTN07{MOV{7,XL{3,RTNBP{{SAVE BLOCK POINTER{18358
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{18359
{{BEQ{9,(XL){22,=B$TRT{6,RTN07{LOOP BACK IF TRAPPED{18360
{{MOV{7,XL{3,RTNFV{{ELSE SAVE FUNCTION RESULT VALUE{18361
{{MOV{10,(XS)+{3,RTNSV{{SAVE ORIGINAL FUNCTION VALUE{18362
{{MOV{10,(XS)+{7,XL{{POP SAVED POINTER{18366
{{BZE{7,XL{6,RTN7C{{NO ACTION IF NONE{18367
{{BZE{3,KVPFL{6,RTN7C{{JUMP IF NO PROFILING{18368
{{JSR{6,PRFLU{{{ELSE PROFILE LAST FUNC STMT{18369
{{BEQ{3,KVPFL{18,=NUM02{6,RTN7A{BRANCH ON VALUE OF PROFILE KEYWD{18370
*
*      HERE IF &PROFILE = 1. START TIME MUST BE FRIGGED TO
*      APPEAR EARLIER THAN IT ACTUALLY IS, BY AMOUNT USED BEFORE
*      THE CALL.
*
{{LDI{3,PFSTM{{{LOAD CURRENT TIME{18376
{{SBI{13,ICVAL(XL){{{FRIG BY SUBTRACTING SAVED AMOUNT{18377
{{BRN{6,RTN7B{{{AND MERGE{18378
*
*      HERE IF &PROFILE = 2
*
{RTN7A{LDI{13,ICVAL(XL){{{LOAD SAVED TIME{18382
*
*      BOTH PROFILE TYPES MERGE HERE
*
{RTN7B{STI{3,PFSTM{{{STORE BACK CORRECT START TIME{18386
*
*      MERGE HERE IF NO PROFILING
*
{RTN7C{MOV{13,FARGS(XR){8,WB{{GET NUMBER OF ARGS{18390
{{ADD{13,PFNLO(XR){8,WB{{ADD NUMBER OF LOCALS{18392
{{BZE{8,WB{6,RTN10{{JUMP IF NO ARGS/LOCALS{18393
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{18394
{{ADD{13,PFLEN(XR){7,XR{{AND POINT TO END OF PFBLK{18395
*
*      LOOP TO RESTORE FUNCTIONS AND LOCALS
*
{RTN08{MOV{11,-(XR){7,XL{{LOAD NEXT VRBLK POINTER{18399
*
*      LOOP TO FIND VALUE BLOCK
*
{RTN09{MOV{7,XL{8,WA{{SAVE BLOCK POINTER{18403
{{MOV{13,VRVAL(XL){7,XL{{LOAD POINTER TO NEXT VALUE{18404
{{BEQ{9,(XL){22,=B$TRT{6,RTN09{LOOP BACK IF TRAPPED{18405
{{MOV{8,WA{7,XL{{ELSE RESTORE LAST BLOCK POINTER{18406
{{MOV{10,(XS)+{13,VRVAL(XL){{RESTORE OLD VARIABLE VALUE{18407
{{BCT{8,WB{6,RTN08{{LOOP TILL ALL PROCESSED{18408
*
*      NOW RESTORE FUNCTION VALUE AND EXIT
*
{RTN10{MOV{3,RTNBP{7,XL{{RESTORE PTR TO LAST FUNCTION BLOCK{18412
{{MOV{3,RTNSV{13,VRVAL(XL){{RESTORE OLD FUNCTION VALUE{18413
{{MOV{3,RTNFV{7,XR{{RELOAD FUNCTION RESULT{18414
{{MOV{3,R$COD{7,XL{{POINT TO NEW CODE BLOCK{18415
{{MOV{3,KVSTN{3,KVLST{{SET LASTNO FROM STNO{18416
{{MOV{13,CDSTM(XL){3,KVSTN{{RESET PROPER STNO VALUE{18417
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE FROM LINE{18419
{{MOV{13,CDSLN(XL){3,KVLIN{{RESET PROPER LINE VALUE{18420
{{MOV{3,KVRTN{8,WA{{LOAD RETURN TYPE{18422
{{BEQ{8,WA{21,=SCRTN{6,EXIXR{EXIT WITH RESULT IN XR IF RETURN{18423
{{BEQ{8,WA{21,=SCFRT{6,EXFAL{FAIL IF FRETURN{18424
{{EJC{{{{{18425
*
*      RETRN (CONTINUED)
*
*      HERE FOR NRETURN
*
{{BEQ{9,(XR){22,=B$NML{6,RTN11{JUMP IF IS A NAME{18431
{{JSR{6,GTNVR{{{ELSE TRY CONVERT TO VARIABLE NAME{18432
{{ERR{1,243{26,Function result in NRETURN is not name{{{18433
{{MOV{7,XR{7,XL{{IF OK, COPY VRBLK (NAME BASE) PTR{18434
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{18435
{{BRN{6,RTN12{{{AND MERGE{18436
*
*      HERE IF RETURNED RESULT IS A NAME
*
{RTN11{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{18440
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{18441
*
*      MERGE HERE WITH RETURNED NAME IN (XL,WA)
*
{RTN12{MOV{7,XL{7,XR{{PRESERVE XL{18445
{{LCW{8,WB{{{LOAD NEXT WORD{18446
{{MOV{7,XR{7,XL{{RESTORE XL{18447
{{BEQ{8,WB{21,=OFNE${6,EXNAM{EXIT IF CALLED BY NAME{18448
{{MOV{8,WB{11,-(XS){{ELSE SAVE CODE WORD{18449
{{JSR{6,ACESS{{{GET VALUE{18450
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18451
{{MOV{7,XR{7,XL{{IF OK, COPY RESULT{18452
{{MOV{9,(XS){7,XR{{RELOAD NEXT CODE WORD{18453
{{MOV{7,XL{9,(XS){{STORE RESULT ON STACK{18454
{{MOV{9,(XR){7,XL{{LOAD ROUTINE ADDRESS{18455
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18456
{{EJC{{{{{18457
*
*      STCOV -- SIGNAL STATEMENT COUNTER OVERFLOW
*
*      BRN  STCOV            JUMP TO SIGNAL STATEMENT COUNT OFLO
*
*      PERMIT UP TO 10 MORE STATEMENTS TO BE OBEYED SO THAT
*      SETEXIT TRAP CAN REGAIN CONTROL.
*      STCOV CONTINUES BY ISSUING THE ERROR MESSAGE
*
{STCOV{RTN{{{{{18467
{{ICV{3,ERRFT{{{FATAL ERROR{18468
{{LDI{4,INTVT{{{GET 10{18469
{{ADI{3,KVSTL{{{ADD TO FORMER LIMIT{18470
{{STI{3,KVSTL{{{STORE AS NEW STLIMIT{18471
{{LDI{4,INTVT{{{GET 10{18472
{{STI{3,KVSTC{{{SET AS NEW COUNT{18473
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{18474
{{ERB{1,244{26,Statement count exceeds value of STLIMIT keyword{{{18475
{{EJC{{{{{18476
*
*      STMGO -- START EXECUTION OF NEW STATEMENT
*
*      (XR)                  POINTER TO CDBLK FOR NEW STATEMENT
*      BRN  STMGO            JUMP TO EXECUTE NEW STATEMENT
*
*      STMGO CONTINUES BY EXECUTING THE NEXT STATEMENT
*
{STMGO{RTN{{{{{18485
{{MOV{7,XR{3,R$COD{{SET NEW CODE BLOCK POINTER{18486
{{DCV{3,STMCT{{{SEE IF TIME TO CHECK SOMETHING{18487
{{BZE{3,STMCT{6,STGO2{{JUMP IF SO{18488
{{MOV{3,KVSTN{3,KVLST{{SET LASTNO{18489
{{MOV{13,CDSTM(XR){3,KVSTN{{SET STNO{18490
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE{18492
{{MOV{13,CDSLN(XR){3,KVLIN{{SET LINE{18493
{{ADD{19,*CDCOD{7,XR{{POINT TO FIRST CODE WORD{18495
{{LCP{7,XR{{{SET CODE POINTER{18496
*
*      HERE TO EXECUTE FIRST CODE WORD OF STATEMENT
*
{STGO1{LCW{7,XR{{{LOAD NEXT CODE WORD{18500
{{ZER{7,XL{{{CLEAR GARBAGE XL{18501
{{BRI{9,(XR){{{EXECUTE IT{18502
*
*      CHECK PROFILING, POLLING, STLIMIT, STATEMENT TRACING
*
{STGO2{BZE{3,KVPFL{6,STGO3{{SKIP IF NO PROFILING{18506
{{JSR{6,PRFLU{{{ELSE PROFILE THE STATEMENT IN KVSTN{18507
*
*      HERE WHEN FINISHED WITH PROFILING
*
{STGO3{MOV{3,KVSTN{3,KVLST{{SET LASTNO{18511
{{MOV{13,CDSTM(XR){3,KVSTN{{SET STNO{18512
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE{18514
{{MOV{13,CDSLN(XR){3,KVLIN{{SET LINE{18515
{{ADD{19,*CDCOD{7,XR{{POINT TO FIRST CODE WORD{18517
{{LCP{7,XR{{{SET CODE POINTER{18518
*
*      HERE TO CHECK FOR POLLING
*
{{MOV{3,STMCS{11,-(XS){{SAVE PRESENT COUNT START ON STACK{18523
{{DCV{3,POLCT{{{POLL INTERVAL WITHIN STMCT{18524
{{BNZ{3,POLCT{6,STGO4{{JUMP IF NOT POLL TIME YET{18525
{{ZER{8,WA{{{=0 FOR POLL{18526
{{MOV{3,KVSTN{8,WB{{STATEMENT NUMBER{18527
{{MOV{7,XR{7,XL{{MAKE COLLECTABLE{18528
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{18529
{{ERR{1,320{26,User interrupt{{{18530
{{PPM{{{{SINGLE STEP{18531
{{PPM{{{{EXPRESSION EVALUATION{18532
{{MOV{7,XL{7,XR{{RESTORE CODE BLOCK POINTER{18533
{{MOV{8,WA{3,POLCS{{POLL INTERVAL START VALUE{18534
{{JSR{6,STGCC{{{RECOMPUTE COUNTER VALUES{18535
*
*      CHECK STATEMENT LIMIT
*
{STGO4{LDI{3,KVSTC{{{GET STMT COUNT{18540
{{ILT{6,STGO5{{{OMIT COUNTING IF NEGATIVE{18541
{{MTI{10,(XS)+{{{RELOAD START VALUE OF COUNTER{18542
{{NGI{{{{NEGATE{18543
{{ADI{3,KVSTC{{{STMT COUNT MINUS COUNTER{18544
{{STI{3,KVSTC{{{REPLACE IT{18545
{{ILE{6,STCOV{{{FAIL IF STLIMIT REACHED{18546
{{BZE{3,R$STC{6,STGO5{{JUMP IF NO STATEMENT TRACE{18547
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{18548
{{MOV{3,R$STC{7,XL{{LOAD POINTER TO STCOUNT TRBLK{18549
{{JSR{6,KTREX{{{EXECUTE KEYWORD TRACE{18550
*
*      RESET STMGO COUNTER
*
{STGO5{MOV{3,STMCS{3,STMCT{{RESET COUNTER{18554
{{BRN{6,STGO1{{{FETCH NEXT CODE WORD{18555
{{EJC{{{{{18556
*
*      STOPR -- TERMINATE RUN
*
*      (XR)                  POINTS TO ENDING MESSAGE
*      BRN STOPR             JUMP TO TERMINATE RUN
*
*      TERMINATE RUN AND PRINT STATISTICS.  ON ENTRY XR POINTS
*      TO ENDING MESSAGE OR IS ZERO IF MESSAGE  PRINTED ALREADY.
*
{STOPR{RTN{{{{{18566
{{BZE{7,XR{6,STPRA{{SKIP IF SYSAX ALREADY CALLED{18568
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{18569
{STPRA{ADD{3,RSMEM{3,DNAME{{USE THE RESERVE MEMORY{18570
{{BNE{7,XR{21,=ENDMS{6,STPR0{SKIP IF NOT NORMAL END MESSAGE{18574
{{BNZ{3,EXSTS{6,STPR3{{SKIP IF EXEC STATS SUPPRESSED{18575
{{ZER{3,ERICH{{{CLEAR ERRORS TO INT.CH. FLAG{18576
*
*      LOOK TO SEE IF AN ENDING MESSAGE IS SUPPLIED
*
{STPR0{JSR{6,PRTPG{{{EJECT PRINTER{18580
{{BZE{7,XR{6,STPR1{{SKIP IF NO MESSAGE{18581
{{JSR{6,PRTST{{{PRINT MESSAGE{18582
*
*      MERGE HERE IF NO MESSAGE TO PRINT
*
{STPR1{JSR{6,PRTIS{{{PRINT BLANK LINE{18586
{{BNZ{3,GBCFL{6,STPR5{{IF IN GARBAGE COLLECTION, SKIP{18588
{{MOV{21,=STPM7{7,XR{{POINT TO MESSAGE /IN FILE XXX/{18589
{{JSR{6,PRTST{{{PRINT IT{18590
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{18591
{{MOV{3,KVSTN{8,WC{{GET STATEMENT NUMBER{18592
{{JSR{6,FILNM{{{GET FILE NAME{18593
{{MOV{7,XL{7,XR{{PREPARE TO PRINT{18594
{{JSR{6,PRTST{{{PRINT FILE NAME{18595
{{JSR{6,PRTIS{{{PRINT TO INTERACTIVE CHANNEL{18596
{{MOV{3,R$COD{7,XR{{GET CODE POINTER{18603
{{MTI{13,CDSLN(XR){{{GET SOURCE LINE NUMBER{18604
{{MOV{21,=STPM6{7,XR{{POINT TO MESSAGE /IN LINE XXX/{18605
{{JSR{6,PRTMX{{{PRINT IT{18606
{STPR5{MTI{3,KVSTN{{{GET STATEMENT NUMBER{18608
{{MOV{21,=STPM1{7,XR{{POINT TO MESSAGE /IN STATEMENT XXX/{18609
{{JSR{6,PRTMX{{{PRINT IT{18610
{{JSR{6,SYSTM{{{GET CURRENT TIME{18611
{{SBI{3,TIMSX{{{MINUS START TIME = ELAPSED EXEC TIM{18612
{{STI{3,STPTI{{{SAVE FOR LATER{18613
{{MOV{21,=STPM3{7,XR{{POINT TO MSG /EXECUTION TIME MSEC /{18614
{{JSR{6,PRTMX{{{PRINT IT{18615
{{LDI{3,KVSTL{{{GET STATEMENT LIMIT{18616
{{ILT{6,STPR2{{{SKIP IF NEGATIVE{18617
{{SBI{3,KVSTC{{{MINUS COUNTER = COURSE COUNT{18618
{{STI{3,STPSI{{{SAVE{18619
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER START VALUE{18620
{{SUB{3,STMCT{8,WA{{MINUS CURRENT COUNTER{18621
{{MTI{8,WA{{{CONVERT TO INTEGER{18622
{{ADI{3,STPSI{{{ADD IN COURSE COUNT{18623
{{STI{3,STPSI{{{SAVE{18624
{{MOV{21,=STPM2{7,XR{{POINT TO MESSAGE /STMTS EXECUTED/{18625
{{JSR{6,PRTMX{{{PRINT IT{18626
{{LDI{3,STPTI{{{RELOAD ELAPSED TIME{18629
{{MLI{4,INTTH{{{*1000 (MICROSECS){18630
{{IOV{6,STPR2{{{JUMP IF WE CANNOT COMPUTE{18631
{{DVI{3,STPSI{{{DIVIDE BY STATEMENT COUNT{18632
{{IOV{6,STPR2{{{JUMP IF OVERFLOW{18633
{{MOV{21,=STPM4{7,XR{{POINT TO MSG (MCSEC PER STATEMENT /{18634
{{JSR{6,PRTMX{{{PRINT IT{18635
{{EJC{{{{{18637
*
*      STOPR (CONTINUED)
*
*      MERGE TO SKIP MESSAGE (OVERFLOW OR NEGATIVE STLIMIT)
*
{STPR2{MTI{3,GBCNT{{{LOAD COUNT OF COLLECTIONS{18643
{{MOV{21,=STPM5{7,XR{{POINT TO MESSAGE /REGENERATIONS /{18644
{{JSR{6,PRTMX{{{PRINT IT{18645
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{18646
{{JSR{6,PRTIS{{{ONE MORE BLANK FOR LUCK{18647
*
*      CHECK IF DUMP REQUESTED
*
{STPR3{JSR{6,PRFLR{{{PRINT PROFILE IF WANTED{18654
*
{{MOV{3,KVDMP{7,XR{{LOAD DUMP KEYWORD{18656
{{JSR{6,DUMPR{{{EXECUTE DUMP IF REQUESTED{18658
{{MOV{3,R$FCB{7,XL{{GET FCBLK CHAIN HEAD{18659
{{MOV{3,KVABE{8,WA{{LOAD ABEND VALUE{18660
{{MOV{3,KVCOD{8,WB{{LOAD CODE VALUE{18661
{{JSR{6,SYSEJ{{{EXIT TO SYSTEM{18662
*
*      HERE AFTER SYSEA CALL AND SUPPRESSING ERROR MSG PRINT
*
{STPR4{RTN{{{{{18667
{{ADD{3,RSMEM{3,DNAME{{USE THE RESERVE MEMORY{18668
{{BZE{3,EXSTS{6,STPR1{{IF EXECUTION STATS REQUESTED{18669
{{BRN{6,STPR3{{{CHECK IF DUMP OR PROFILE NEEDED{18670
{{EJC{{{{{18673
*
*      SUCCP -- SIGNAL SUCCESSFUL MATCH OF A PATTERN NODE
*
*      SEE PATTERN MATCH ROUTINES FOR DETAILS
*
*      (XR)                  CURRENT NODE
*      (WB)                  CURRENT CURSOR
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  SUCCP            SIGNAL SUCCESSFUL PATTERN MATCH
*
*      SUCCP CONTINUES BY MATCHING THE SUCCESSOR NODE
*
{SUCCP{RTN{{{{{18686
{{MOV{13,PTHEN(XR){7,XR{{LOAD SUCCESSOR NODE{18687
{{MOV{9,(XR){7,XL{{LOAD NODE CODE ENTRY ADDRESS{18688
{{BRI{7,XL{{{JUMP TO MATCH SUCCESSOR NODE{18689
{{EJC{{{{{18690
*
*      SYSAB -- PRINT /ABNORMAL END/ AND TERMINATE
*
{SYSAB{RTN{{{{{18694
{{MOV{21,=ENDAB{7,XR{{POINT TO MESSAGE{18695
{{MOV{18,=NUM01{3,KVABE{{SET ABEND FLAG{18696
{{JSR{6,PRTNL{{{SKIP TO NEW LINE{18697
{{BRN{6,STOPR{{{JUMP TO PACK UP{18698
{{EJC{{{{{18699
*
*      SYSTU -- PRINT /TIME UP/ AND TERMINATE
*
{SYSTU{RTN{{{{{18703
{{MOV{21,=ENDTU{7,XR{{POINT TO MESSAGE{18704
{{MOV{4,STRTU{8,WA{{GET CHARS /TU/{18705
{{MOV{8,WA{3,KVCOD{{PUT IN KVCOD{18706
{{MOV{3,TIMUP{8,WA{{CHECK STATE OF TIMEUP SWITCH{18707
{{MNZ{3,TIMUP{{{SET SWITCH{18708
{{BNZ{8,WA{6,STOPR{{STOP RUN IF ALREADY SET{18709
{{ERB{1,245{26,Translation/execution time expired{{{18710
{{TTL{27,S P I T B O L -- UTILITY PROCEDURES{{{{18711
*
*      THE FOLLOWING SECTION CONTAINS PROCEDURES WHICH ARE
*      USED FOR VARIOUS PURPOSES THROUGHOUT THE SYSTEM.
*
*      EACH PROCEDURE IS PRECEDED BY A DESCRIPTION OF THE
*      CALLING SEQUENCE. USUALLY THE ARGUMENTS ARE IN REGISTERS
*      BUT ARGUMENTS CAN ALSO OCCUR ON THE STACK AND AS
*      PARAMETERS ASSEMBLED AFTER THE JSR INSTRUCTION.
*
*      THE FOLLOWING CONSIDERATIONS APPLY TO THESE DESCRIPTIONS.
*
*      1)   THE STACK POINTER (XS) IS NOT CHANGED UNLESS THE
*           CHANGE IS EXPLICITLY DOCUMENTED IN THE CALL.
*
*      2)   REGISTERS WHOSE ENTRY VALUES ARE NOT MENTIONED
*           MAY CONTAIN ANY VALUE EXCEPT THAT XL,XR MAY ONLY
*           CONTAIN PROPER (COLLECTABLE) POINTER VALUES.
*           THIS CONDITION ON MEANS THAT THE CALLED ROUTINE
*           MAY IF IT CHOOSES PRESERVE XL,XR BY STACKING.
*
*      3)   REGISTERS NOT MENTIONED ON EXIT CONTAIN THE SAME
*           VALUES AS THEY DID ON ENTRY EXCEPT THAT VALUES IN
*           XR,XL MAY HAVE BEEN RELOCATED BY THE COLLECTOR.
*
*      4)   REGISTERS WHICH ARE DESTROYED ON EXIT MAY CONTAIN
*           ANY VALUE EXCEPT THAT VALUES IN XL,XR ARE PROPER
*           (COLLECTABLE) POINTERS.
*
*      5)   THE CODE POINTER REGISTER POINTS TO THE CURRENT
*           CODE LOCATION ON ENTRY AND IS UNCHANGED ON EXIT.
*
*      IN THE ABOVE DESCRIPTION, A COLLECTABLE POINTER IS ONE
*      WHICH EITHER POINTS OUTSIDE THE DYNAMIC REGION OR
*      POINTS TO THE START OF A BLOCK IN THE DYNAMIC REGION.
*
*      IN THOSE CASES WHERE THE CALLING SEQUENCE CONTAINS
*      PARAMETERS WHICH ARE USED AS ALTERNATE RETURN POINTS,
*      THESE PARAMETERS MAY BE REPLACED BY ERROR CODES
*      ASSEMBLED WITH THE ERR INSTRUCTION. THIS WILL RESULT
*      IN THE POSTING OF THE ERROR IF THE RETURN IS TAKEN.
*
*      THE PROCEDURES ALL HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE IN ALPHABETICAL ORDER BY THEIR NAMES.
{{EJC{{{{{18755
*
*      ACESS - ACCESS VARIABLE VALUE WITH TRACE/INPUT CHECKS
*
*      ACESS LOADS THE VALUE OF A VARIABLE. TRACE AND INPUT
*      ASSOCIATIONS ARE TESTED FOR AND EXECUTED AS REQUIRED.
*      ACESS ALSO HANDLES THE SPECIAL CASES OF PSEUDO-VARIABLES.
*
*      (XL)                  VARIABLE NAME BASE
*      (WA)                  VARIABLE NAME OFFSET
*      JSR  ACESS            CALL TO ACCESS VALUE
*      PPM  LOC              TRANSFER LOC IF ACCESS FAILURE
*      (XR)                  VARIABLE VALUE
*      (WA,WB,WC)            DESTROYED
*      (XL,RA)               DESTROYED
*
*      FAILURE CAN OCCUR IF AN INPUT ASSOCIATION CAUSES AN END
*      OF FILE CONDITION OR IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ACESS{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){18775
{{MOV{7,XL{7,XR{{COPY NAME BASE{18776
{{ADD{8,WA{7,XR{{POINT TO VARIABLE LOCATION{18777
{{MOV{9,(XR){7,XR{{LOAD VARIABLE VALUE{18778
*
*      LOOP HERE TO CHECK FOR SUCCESSIVE TRBLKS
*
{ACS02{BNE{9,(XR){22,=B$TRT{6,ACS18{JUMP IF NOT TRAPPED{18782
*
*      HERE IF TRAPPED
*
{{BEQ{7,XR{21,=TRBKV{6,ACS12{JUMP IF KEYWORD VARIABLE{18786
{{BNE{7,XR{21,=TRBEV{6,ACS05{JUMP IF NOT EXPRESSION VARIABLE{18787
*
*      HERE FOR EXPRESSION VARIABLE, EVALUATE VARIABLE
*
{{MOV{13,EVEXP(XL){7,XR{{LOAD EXPRESSION POINTER{18791
{{ZER{8,WB{{{EVALUATE BY VALUE{18792
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{18793
{{PPM{6,ACS04{{{JUMP IF EVALUATION FAILURE{18794
{{BRN{6,ACS02{{{CHECK VALUE FOR MORE TRBLKS{18795
{{EJC{{{{{18796
*
*      ACESS (CONTINUED)
*
*      HERE ON READING END OF FILE
*
{ACS03{ADD{19,*NUM03{7,XS{{POP TRBLK PTR, NAME BASE AND OFFSET{18802
{{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{18803
*
*      MERGE HERE WHEN EVALUATION OF EXPRESSION FAILS
*
{ACS04{EXI{1,1{{{TAKE ALTERNATE (FAILURE) RETURN{18807
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ACS05{MOV{13,TRTYP(XR){8,WB{{LOAD TRAP TYPE CODE{18811
{{BNZ{8,WB{6,ACS10{{JUMP IF NOT INPUT ASSOCIATION{18812
{{BZE{3,KVINP{6,ACS09{{IGNORE INPUT ASSOC IF INPUT IS OFF{18813
*
*      HERE FOR INPUT ASSOCIATION
*
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{18817
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{18818
{{MOV{7,XR{11,-(XS){{STACK TRBLK POINTER{18819
{{MOV{3,KVTRM{3,ACTRM{{TEMP TO HOLD TRIM KEYWORD{18820
{{MOV{13,TRFPT(XR){7,XL{{GET FILE CTRL BLK PTR OR ZERO{18821
{{BNZ{7,XL{6,ACS06{{JUMP IF NOT STANDARD INPUT FILE{18822
{{BEQ{13,TRTER(XR){21,=V$TER{6,ACS21{JUMP IF TERMINAL{18823
*
*      HERE TO READ FROM STANDARD INPUT FILE
*
{{MOV{3,CSWIN{8,WA{{LENGTH FOR READ BUFFER{18827
{{JSR{6,ALOCS{{{BUILD STRING OF APPROPRIATE LENGTH{18828
{{JSR{6,SYSRD{{{READ NEXT STANDARD INPUT IMAGE{18829
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{18830
{{BRN{6,ACS07{{{ELSE MERGE WITH OTHER FILE CASE{18831
*
*      HERE FOR INPUT FROM OTHER THAN STANDARD INPUT FILE
*
{ACS06{MOV{7,XL{8,WA{{FCBLK PTR{18835
{{JSR{6,SYSIL{{{GET INPUT RECORD MAX LENGTH (TO WA){18836
{{BNZ{8,WC{6,ACS6A{{JUMP IF NOT BINARY FILE{18837
{{MOV{8,WC{3,ACTRM{{DISABLE TRIM FOR BINARY FILE{18838
{ACS6A{JSR{6,ALOCS{{{ALLOCATE STRING OF CORRECT SIZE{18839
{{MOV{7,XL{8,WA{{FCBLK PTR{18840
{{JSR{6,SYSIN{{{CALL SYSTEM INPUT ROUTINE{18841
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{18842
{{PPM{6,ACS22{{{ERROR{18843
{{PPM{6,ACS23{{{ERROR{18844
{{EJC{{{{{18845
*
*      ACESS (CONTINUED)
*
*      MERGE HERE AFTER OBTAINING INPUT RECORD
*
{ACS07{MOV{3,ACTRM{8,WB{{LOAD TRIM INDICATOR{18851
{{JSR{6,TRIMR{{{TRIM RECORD AS REQUIRED{18852
{{MOV{7,XR{8,WB{{COPY RESULT POINTER{18853
{{MOV{9,(XS){7,XR{{RELOAD POINTER TO TRBLK{18854
*
*      LOOP TO CHASE TO END OF TRBLK CHAIN AND STORE VALUE
*
{ACS08{MOV{7,XR{7,XL{{SAVE POINTER TO THIS TRBLK{18858
{{MOV{13,TRNXT(XR){7,XR{{LOAD FORWARD POINTER{18859
{{BEQ{9,(XR){22,=B$TRT{6,ACS08{LOOP IF THIS IS ANOTHER TRBLK{18860
{{MOV{8,WB{13,TRNXT(XL){{ELSE STORE RESULT AT END OF CHAIN{18861
{{MOV{10,(XS)+{7,XR{{RESTORE INITIAL TRBLK POINTER{18862
{{MOV{10,(XS)+{8,WA{{RESTORE NAME OFFSET{18863
{{MOV{10,(XS)+{7,XL{{RESTORE NAME BASE POINTER{18864
*
*      COME HERE TO MOVE TO NEXT TRBLK
*
{ACS09{MOV{13,TRNXT(XR){7,XR{{LOAD FORWARD PTR TO NEXT VALUE{18868
{{BRN{6,ACS02{{{BACK TO CHECK IF TRAPPED{18869
*
*      HERE TO CHECK FOR ACCESS TRACE TRBLK
*
{ACS10{BNE{8,WB{18,=TRTAC{6,ACS09{LOOP BACK IF NOT ACCESS TRACE{18873
{{BZE{3,KVTRA{6,ACS09{{IGNORE ACCESS TRACE IF TRACE OFF{18874
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{18875
{{BZE{13,TRFNC(XR){6,ACS11{{JUMP IF PRINT TRACE{18876
{{EJC{{{{{18877
*
*      ACESS (CONTINUED)
*
*      HERE FOR FULL FUNCTION TRACE
*
{{JSR{6,TRXEQ{{{CALL ROUTINE TO EXECUTE TRACE{18883
{{BRN{6,ACS09{{{JUMP FOR NEXT TRBLK{18884
*
*      HERE FOR CASE OF PRINT TRACE
*
{ACS11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{18888
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{18889
{{BRN{6,ACS09{{{JUMP BACK FOR NEXT TRBLK{18890
*
*      HERE FOR KEYWORD VARIABLE
*
{ACS12{MOV{13,KVNUM(XL){7,XR{{LOAD KEYWORD NUMBER{18894
{{BGE{7,XR{18,=K$V$${6,ACS14{JUMP IF NOT ONE WORD VALUE{18895
{{MTI{15,KVABE(XR){{{ELSE LOAD VALUE AS INTEGER{18896
*
*      COMMON EXIT WITH KEYWORD VALUE AS INTEGER IN (IA)
*
{ACS13{JSR{6,ICBLD{{{BUILD ICBLK{18900
{{BRN{6,ACS18{{{JUMP TO EXIT{18901
*
*      HERE IF NOT ONE WORD KEYWORD VALUE
*
{ACS14{BGE{7,XR{18,=K$S$${6,ACS15{JUMP IF SPECIAL CASE{18905
{{SUB{18,=K$V$${7,XR{{ELSE GET OFFSET{18906
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{18907
{{ADD{21,=NDABO{7,XR{{POINT TO PATTERN VALUE{18908
{{BRN{6,ACS18{{{JUMP TO EXIT{18909
*
*      HERE IF SPECIAL KEYWORD CASE
*
{ACS15{MOV{3,KVRTN{7,XL{{LOAD RTNTYPE IN CASE{18913
{{LDI{3,KVSTL{{{LOAD STLIMIT IN CASE{18914
{{SUB{18,=K$S$${7,XR{{GET CASE NUMBER{18915
{{BSW{7,XR{2,K$$N${{SWITCH ON KEYWORD NUMBER{18916
{{IFF{2,K$$AL{6,ACS16{{JUMP IF ALPHABET{18930
{{IFF{2,K$$RT{6,ACS17{{RTNTYPE{18930
{{IFF{2,K$$SC{6,ACS19{{STCOUNT{18930
{{IFF{2,K$$ET{6,ACS20{{ERRTEXT{18930
{{IFF{2,K$$FL{6,ACS26{{FILE{18930
{{IFF{2,K$$LF{6,ACS27{{LASTFILE{18930
{{IFF{2,K$$SL{6,ACS13{{STLIMIT{18930
{{IFF{2,K$$LC{6,ACS24{{LCASE{18930
{{IFF{2,K$$UC{6,ACS25{{UCASE{18930
{{ESW{{{{END SWITCH ON KEYWORD NUMBER{18930
{{EJC{{{{{18931
*
*      ACESS (CONTINUED)
*
*      LCASE
*
{ACS24{MOV{21,=LCASE{7,XR{{LOAD POINTER TO LCASE STRING{18938
{{BRN{6,ACS18{{{COMMON RETURN{18939
*
*      UCASE
*
{ACS25{MOV{21,=UCASE{7,XR{{LOAD POINTER TO UCASE STRING{18943
{{BRN{6,ACS18{{{COMMON RETURN{18944
*
*      FILE
*
{ACS26{MOV{3,KVSTN{8,WC{{LOAD CURRENT STMT NUMBER{18950
{{BRN{6,ACS28{{{MERGE TO OBTAIN FILE NAME{18951
*
*      LASTFILE
*
{ACS27{MOV{3,KVLST{8,WC{{LOAD LAST STMT NUMBER{18955
*
*      MERGE HERE TO MAP STATEMENT NUMBER IN WC TO FILE NAME
*
{ACS28{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STMT{18959
{{BRN{6,ACS17{{{MERGE TO RETURN STRING IN XL{18960
*      ALPHABET
*
{ACS16{MOV{3,KVALP{7,XL{{LOAD POINTER TO ALPHABET STRING{18964
*
*      RTNTYPE MERGES HERE
*
{ACS17{MOV{7,XL{7,XR{{COPY STRING PTR TO PROPER REG{18968
*
*      COMMON RETURN POINT
*
{ACS18{EXI{{{{RETURN TO ACESS CALLER{18972
*
*      HERE FOR STCOUNT (IA HAS STLIMIT)
*
{ACS19{ILT{6,ACS29{{{IF COUNTING SUPPRESSED{18976
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER START VALUE{18977
{{SUB{3,STMCT{8,WA{{MINUS CURRENT COUNTER{18978
{{MTI{8,WA{{{CONVERT TO INTEGER{18979
{{ADI{3,KVSTL{{{ADD STLIMIT{18980
{ACS29{SBI{3,KVSTC{{{STCOUNT = LIMIT - LEFT{18981
{{BRN{6,ACS13{{{MERGE BACK WITH INTEGER RESULT{18982
*
*      ERRTEXT
*
{ACS20{MOV{3,R$ETX{7,XR{{GET ERRTEXT STRING{18986
{{BRN{6,ACS18{{{MERGE WITH RESULT{18987
*
*      HERE TO READ A RECORD FROM TERMINAL
*
{ACS21{MOV{18,=RILEN{8,WA{{BUFFER LENGTH{18991
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{18992
{{JSR{6,SYSRI{{{READ RECORD{18993
{{PPM{6,ACS03{{{ENDFILE{18994
{{BRN{6,ACS07{{{MERGE WITH RECORD READ{18995
*
*      ERROR RETURNS
*
{ACS22{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{18999
{{ERB{1,202{26,Input from file caused non-recoverable error{{{19000
*
{ACS23{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{19002
{{ERB{1,203{26,Input file record has incorrect format{{{19003
{{ENP{{{{END PROCEDURE ACESS{19004
{{EJC{{{{{19005
*
*      ACOMP -- COMPARE TWO ARITHMETIC VALUES
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  ACOMP            CALL TO COMPARE VALUES
*      PPM  LOC              TRANSFER LOC IF ARG1 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC IF ARG2 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR ARG1 LT ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 EQ ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 GT ARG2
*      (NORMAL RETURN IS NEVER GIVEN)
*      (WA,WB,WC,IA,RA)      DESTROYED
*      (XL,XR)               DESTROYED
*
{ACOMP{PRC{25,N{1,5{{ENTRY POINT{19021
{{JSR{6,ARITH{{{LOAD ARITHMETIC OPERANDS{19022
{{PPM{6,ACMP7{{{JUMP IF FIRST ARG NON-NUMERIC{19023
{{PPM{6,ACMP8{{{JUMP IF SECOND ARG NON-NUMERIC{19024
{{PPM{6,ACMP4{{{JUMP IF REAL ARGUMENTS{19027
*
*      HERE FOR INTEGER ARGUMENTS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT TO COMPARE{19032
{{IOV{6,ACMP3{{{JUMP IF OVERFLOW{19033
{{ILT{6,ACMP5{{{ELSE JUMP IF ARG1 LT ARG2{19034
{{IEQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{19035
*
*      HERE IF ARG1 GT ARG2
*
{ACMP1{EXI{1,5{{{TAKE GT EXIT{19039
*
*      HERE IF ARG1 EQ ARG2
*
{ACMP2{EXI{1,4{{{TAKE EQ EXIT{19043
{{EJC{{{{{19044
*
*      ACOMP (CONTINUED)
*
*      HERE FOR INTEGER OVERFLOW ON SUBTRACT
*
{ACMP3{LDI{13,ICVAL(XL){{{LOAD SECOND ARGUMENT{19050
{{ILT{6,ACMP1{{{GT IF NEGATIVE{19051
{{BRN{6,ACMP5{{{ELSE LT{19052
*
*      HERE FOR REAL OPERANDS
*
{ACMP4{SBR{13,RCVAL(XL){{{SUBTRACT TO COMPARE{19058
{{ROV{6,ACMP6{{{JUMP IF OVERFLOW{19059
{{RGT{6,ACMP1{{{ELSE JUMP IF ARG1 GT{19060
{{REQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{19061
*
*      HERE IF ARG1 LT ARG2
*
{ACMP5{EXI{1,3{{{TAKE LT EXIT{19066
*
*      HERE IF OVERFLOW ON REAL SUBTRACTION
*
{ACMP6{LDR{13,RCVAL(XL){{{RELOAD ARG2{19072
{{RLT{6,ACMP1{{{GT IF NEGATIVE{19073
{{BRN{6,ACMP5{{{ELSE LT{19074
*
*      HERE IF ARG1 NON-NUMERIC
*
{ACMP7{EXI{1,1{{{TAKE ERROR EXIT{19079
*
*      HERE IF ARG2 NON-NUMERIC
*
{ACMP8{EXI{1,2{{{TAKE ERROR EXIT{19083
{{ENP{{{{END PROCEDURE ACOMP{19084
{{EJC{{{{{19085
*
*      ALLOC                 ALLOCATE BLOCK OF DYNAMIC STORAGE
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALLOC            CALL TO ALLOCATE BLOCK
*      (XR)                  POINTER TO ALLOCATED BLOCK
*
*      A POSSIBLE ALTERNATIVE TO AOV ... AND FOLLOWING STMT IS -
*      MOV  DNAME,XR .  SUB  WA,XR .  BLO XR,DNAMP,ALOC2 .
*      MOV  DNAMP,XR .  ADD  WA,XR
*
{ALLOC{PRC{25,E{1,0{{ENTRY POINT{19097
*
*      COMMON EXIT POINT
*
{ALOC1{MOV{3,DNAMP{7,XR{{POINT TO NEXT AVAILABLE LOC{19101
{{AOV{8,WA{7,XR{6,ALOC2{POINT PAST ALLOCATED BLOCK{19102
{{BGT{7,XR{3,DNAME{6,ALOC2{JUMP IF NOT ENOUGH ROOM{19103
{{MOV{7,XR{3,DNAMP{{STORE NEW POINTER{19104
{{SUB{8,WA{7,XR{{POINT BACK TO START OF ALLOCATED BK{19105
{{EXI{{{{RETURN TO CALLER{19106
*
*      HERE IF INSUFFICIENT ROOM, TRY A GARBAGE COLLECTION
*
{ALOC2{MOV{8,WB{3,ALLSV{{SAVE WB{19110
{ALC2A{ZER{8,WB{{{SET NO UPWARD MOVE FOR GBCOL{19111
{{JSR{6,GBCOL{{{GARBAGE COLLECT{19112
{{MOV{7,XR{8,WB{{REMEMBER NEW SEDIMENT SIZE{19114
*
*      SEE IF ROOM AFTER GBCOL OR SYSMM CALL
*
{ALOC3{MOV{3,DNAMP{7,XR{{POINT TO FIRST AVAILABLE LOC{19119
{{AOV{8,WA{7,XR{6,ALC3A{POINT PAST NEW BLOCK{19120
{{BLO{7,XR{3,DNAME{6,ALOC4{JUMP IF THERE IS ROOM NOW{19121
*
*      FAILED AGAIN, SEE IF WE CAN GET MORE CORE
*
{ALC3A{JSR{6,SYSMM{{{TRY TO GET MORE MEMORY{19125
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){19126
{{ADD{7,XR{3,DNAME{{BUMP PTR BY AMOUNT OBTAINED{19127
{{BNZ{7,XR{6,ALOC3{{JUMP IF GOT MORE CORE{19128
{{BZE{3,DNAMS{6,ALC3B{{JUMP IF THERE WAS NO SEDIMENT{19130
{{ZER{3,DNAMS{{{TRY COLLECTING THE SEDIMENT{19131
{{BRN{6,ALC2A{{{{19132
*
*      SYSMM FAILED AND THERE WAS NO SEDIMENT TO COLLECT
*
{ALC3B{ADD{3,RSMEM{3,DNAME{{GET THE RESERVE MEMORY{19136
{{ZER{3,RSMEM{{{ONLY PERMISSIBLE ONCE{19140
{{ICV{3,ERRFT{{{FATAL ERROR{19141
{{ERB{1,204{26,Memory overflow{{{19142
{{EJC{{{{{19143
*
*      HERE AFTER SUCCESSFUL GARBAGE COLLECTION
*
{ALOC4{STI{3,ALLIA{{{SAVE IA{19147
{{MOV{8,WB{3,DNAMS{{RECORD NEW SEDIMENT SIZE{19149
{{MOV{3,DNAME{8,WB{{GET DYNAMIC END ADRS{19151
{{SUB{3,DNAMP{8,WB{{COMPUTE FREE STORE{19152
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{19153
{{MTI{8,WB{{{PUT FREE STORE IN IA{19154
{{MLI{3,ALFSF{{{MULTIPLY BY FREE STORE FACTOR{19155
{{IOV{6,ALOC5{{{JUMP IF OVERFLOWED{19156
{{MOV{3,DNAME{8,WB{{DYNAMIC END ADRS{19157
{{SUB{3,DNAMB{8,WB{{COMPUTE TOTAL AMOUNT OF DYNAMIC{19158
{{BTW{8,WB{{{CONVERT TO WORDS{19159
{{MOV{8,WB{3,ALDYN{{STORE IT{19160
{{SBI{3,ALDYN{{{SUBTRACT FROM SCALED UP FREE STORE{19161
{{IGT{6,ALOC5{{{JUMP IF SUFFICIENT FREE STORE{19162
{{JSR{6,SYSMM{{{TRY TO GET MORE STORE{19163
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){19164
{{ADD{7,XR{3,DNAME{{ADJUST DYNAMIC END ADRS{19165
*
*      MERGE TO RESTORE IA AND WB
*
{ALOC5{LDI{3,ALLIA{{{RECOVER IA{19169
{{MOV{3,ALLSV{8,WB{{RESTORE WB{19170
{{BRN{6,ALOC1{{{JUMP BACK TO EXIT{19171
{{ENP{{{{END PROCEDURE ALLOC{19172
{{EJC{{{{{19173
*
*      ALOCS -- ALLOCATE STRING BLOCK
*
*      ALOCS IS USED TO BUILD A FRAME FOR A STRING BLOCK INTO
*      WHICH THE ACTUAL CHARACTERS ARE PLACED BY THE CALLER.
*      ALL STRINGS ARE CREATED WITH A CALL TO ALOCS (THE
*      EXCEPTIONS OCCUR IN TRIMR AND S$RPL PROCEDURES).
*
*      (WA)                  LENGTH OF STRING TO BE ALLOCATED
*      JSR  ALOCS            CALL TO ALLOCATE SCBLK
*      (XR)                  POINTER TO RESULTING SCBLK
*      (WA)                  DESTROYED
*      (WC)                  CHARACTER COUNT (ENTRY VALUE OF WA)
*
*      THE RESULTING SCBLK HAS THE TYPE WORD AND THE LENGTH
*      FILLED IN AND THE LAST WORD IS CLEARED TO ZERO CHARACTERS
*      TO ENSURE CORRECT RIGHT PADDING OF THE FINAL WORD.
*
{ALOCS{PRC{25,E{1,0{{ENTRY POINT{19233
{{BGT{8,WA{3,KVMXL{6,ALCS2{JUMP IF LENGTH EXCEEDS MAXLENGTH{19234
{{MOV{8,WA{8,WC{{ELSE COPY LENGTH{19235
{{CTB{8,WA{2,SCSI${{COMPUTE LENGTH OF SCBLK IN BYTES{19236
{{MOV{3,DNAMP{7,XR{{POINT TO NEXT AVAILABLE LOCATION{19237
{{AOV{8,WA{7,XR{6,ALCS0{POINT PAST BLOCK{19238
{{BLO{7,XR{3,DNAME{6,ALCS1{JUMP IF THERE IS ROOM{19239
*
*      INSUFFICIENT MEMORY
*
{ALCS0{ZER{7,XR{{{ELSE CLEAR GARBAGE XR VALUE{19243
{{JSR{6,ALLOC{{{AND USE STANDARD ALLOCATOR{19244
{{ADD{8,WA{7,XR{{POINT PAST END OF BLOCK TO MERGE{19245
*
*      MERGE HERE WITH XR POINTING BEYOND NEW BLOCK
*
{ALCS1{MOV{7,XR{3,DNAMP{{SET UPDATED STORAGE POINTER{19249
{{ZER{11,-(XR){{{STORE ZERO CHARS IN LAST WORD{19250
{{DCA{8,WA{{{DECREMENT LENGTH{19251
{{SUB{8,WA{7,XR{{POINT BACK TO START OF BLOCK{19252
{{MOV{22,=B$SCL{9,(XR){{SET TYPE WORD{19253
{{MOV{8,WC{13,SCLEN(XR){{STORE LENGTH IN CHARS{19254
{{EXI{{{{RETURN TO ALOCS CALLER{19255
*
*      COME HERE IF STRING IS TOO LONG
*
{ALCS2{ERB{1,205{26,String length exceeds value of MAXLNGTH keyword{{{19259
{{ENP{{{{END PROCEDURE ALOCS{19260
{{EJC{{{{{19261
*
*      ALOST -- ALLOCATE SPACE IN STATIC REGION
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALOST            CALL TO ALLOCATE SPACE
*      (XR)                  POINTER TO ALLOCATED BLOCK
*      (WB)                  DESTROYED
*
*      NOTE THAT THE CODING ENSURES THAT THE RESULTING VALUE
*      OF STATE IS ALWAYS LESS THAN DNAMB. THIS FACT IS USED
*      IN TESTING A VARIABLE NAME FOR BEING IN THE STATIC REGION
*
{ALOST{PRC{25,E{1,0{{ENTRY POINT{19274
*
*      MERGE BACK HERE AFTER ALLOCATING NEW CHUNK
*
{ALST1{MOV{3,STATE{7,XR{{POINT TO CURRENT END OF AREA{19278
{{AOV{8,WA{7,XR{6,ALST2{POINT BEYOND PROPOSED BLOCK{19279
{{BGE{7,XR{3,DNAMB{6,ALST2{JUMP IF OVERLAP WITH DYNAMIC AREA{19280
{{MOV{7,XR{3,STATE{{ELSE STORE NEW POINTER{19281
{{SUB{8,WA{7,XR{{POINT BACK TO START OF BLOCK{19282
{{EXI{{{{RETURN TO ALOST CALLER{19283
*
*      HERE IF NO ROOM, PREPARE TO MOVE DYNAMIC STORAGE UP
*
{ALST2{MOV{8,WA{3,ALSTA{{SAVE WA{19287
{{BGE{8,WA{19,*E$STS{6,ALST3{SKIP IF REQUESTED CHUNK IS LARGE{19288
{{MOV{19,*E$STS{8,WA{{ELSE SET TO GET LARGE ENOUGH CHUNK{19289
*
*      HERE WITH AMOUNT TO MOVE UP IN WA
*
{ALST3{JSR{6,ALLOC{{{ALLOCATE BLOCK TO ENSURE ROOM{19293
{{MOV{7,XR{3,DNAMP{{AND DELETE IT{19294
{{MOV{8,WA{8,WB{{COPY MOVE UP AMOUNT{19295
{{JSR{6,GBCOL{{{CALL GBCOL TO MOVE DYNAMIC AREA UP{19296
{{MOV{7,XR{3,DNAMS{{REMEMBER NEW SEDIMENT SIZE{19298
{{MOV{3,ALSTA{8,WA{{RESTORE WA{19300
{{BRN{6,ALST1{{{LOOP BACK TO TRY AGAIN{19301
{{ENP{{{{END PROCEDURE ALOST{19302
{{EJC{{{{{19303
*
*      ARITH -- FETCH ARITHMETIC OPERANDS
*
*      ARITH IS USED BY FUNCTIONS AND OPERATORS WHICH EXPECT
*      TWO NUMERIC ARGUMENTS (OPERANDS) WHICH MUST BOTH BE
*      INTEGER OR BOTH BE REAL. ARITH FETCHES TWO ARGUMENTS FROM
*      THE STACK AND PERFORMS ANY NECESSARY CONVERSIONS.
*
*      1(XS)                 FIRST ARGUMENT (LEFT OPERAND)
*      0(XS)                 SECOND ARGUMENT (RIGHT OPERAND)
*      JSR  ARITH            CALL TO FETCH NUMERIC ARGUMENTS
*      PPM  LOC              TRANSFER LOC FOR OPND 1 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR OPND 2 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR REAL OPERANDS
*
*      FOR INTEGER ARGS, CONTROL RETURNS PAST THE PARAMETERS
*
*      (IA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO ICBLK FOR LEFT OPERAND
*      (XL)                  PTR TO ICBLK FOR RIGHT OPERAND
*      (XS)                  POPPED TWICE
*      (WA,WB,RA)            DESTROYED
*
*      FOR REAL ARGUMENTS, CONTROL RETURNS TO THE LOCATION
*      SPECIFIED BY THE THIRD PARAMETER.
*
*      (RA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO RCBLK FOR LEFT OPERAND
*      (XL)                  PTR TO RCBLK FOR RIGHT OPERAND
*      (WA,WB,WC)            DESTROYED
*      (XS)                  POPPED TWICE
{{EJC{{{{{19377
*
*      ARITH (CONTINUED)
*
*      ENTRY POINT
*
{ARITH{PRC{25,N{1,3{{ENTRY POINT{19386
{{MOV{10,(XS)+{7,XL{{LOAD RIGHT OPERAND{19388
{{MOV{10,(XS)+{7,XR{{LOAD LEFT OPERAND{19389
{{MOV{9,(XL){8,WA{{GET RIGHT OPERAND TYPE WORD{19390
{{BEQ{8,WA{22,=B$ICL{6,ARTH1{JUMP IF INTEGER{19391
{{BEQ{8,WA{22,=B$RCL{6,ARTH4{JUMP IF REAL{19394
{{MOV{7,XR{11,-(XS){{ELSE REPLACE LEFT ARG ON STACK{19396
{{MOV{7,XL{7,XR{{COPY LEFT ARG POINTER{19397
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{19398
{{PPM{6,ARTH6{{{JUMP IF UNCONVERTIBLE{19399
{{MOV{7,XR{7,XL{{ELSE COPY CONVERTED RESULT{19400
{{MOV{9,(XL){8,WA{{GET RIGHT OPERAND TYPE WORD{19401
{{MOV{10,(XS)+{7,XR{{RELOAD LEFT ARGUMENT{19402
{{BEQ{8,WA{22,=B$RCL{6,ARTH4{JUMP IF RIGHT ARG IS REAL{19405
*
*      HERE IF RIGHT ARG IS AN INTEGER
*
{ARTH1{BNE{9,(XR){22,=B$ICL{6,ARTH3{JUMP IF LEFT ARG NOT INTEGER{19410
*
*      EXIT FOR INTEGER CASE
*
{ARTH2{LDI{13,ICVAL(XR){{{LOAD LEFT OPERAND VALUE{19414
{{EXI{{{{RETURN TO ARITH CALLER{19415
*
*      HERE FOR RIGHT OPERAND INTEGER, LEFT OPERAND NOT
*
{ARTH3{JSR{6,GTNUM{{{CONVERT LEFT ARG TO NUMERIC{19419
{{PPM{6,ARTH7{{{JUMP IF NOT CONVERTIBLE{19420
{{BEQ{8,WA{22,=B$ICL{6,ARTH2{JUMP BACK IF INTEGER-INTEGER{19421
*
*      HERE WE MUST CONVERT REAL-INTEGER TO REAL-REAL
*
{{MOV{7,XR{11,-(XS){{PUT LEFT ARG BACK ON STACK{19427
{{LDI{13,ICVAL(XL){{{LOAD RIGHT ARGUMENT VALUE{19428
{{ITR{{{{CONVERT TO REAL{19429
{{JSR{6,RCBLD{{{GET REAL BLOCK FOR RIGHT ARG, MERGE{19430
{{MOV{7,XR{7,XL{{COPY RIGHT ARG PTR{19431
{{MOV{10,(XS)+{7,XR{{LOAD LEFT ARGUMENT{19432
{{BRN{6,ARTH5{{{MERGE FOR REAL-REAL CASE{19433
{{EJC{{{{{19434
*
*      ARITH (CONTINUED)
*
*      HERE IF RIGHT ARGUMENT IS REAL
*
{ARTH4{BEQ{9,(XR){22,=B$RCL{6,ARTH5{JUMP IF LEFT ARG REAL{19440
{{JSR{6,GTREA{{{ELSE CONVERT TO REAL{19441
{{PPM{6,ARTH7{{{ERROR IF UNCONVERTIBLE{19442
*
*      HERE FOR REAL-REAL
*
{ARTH5{LDR{13,RCVAL(XR){{{LOAD LEFT OPERAND VALUE{19446
{{EXI{1,3{{{TAKE REAL-REAL EXIT{19447
*
*      HERE FOR ERROR CONVERTING RIGHT ARGUMENT
*
{ARTH6{ICA{7,XS{{{POP UNWANTED LEFT ARG{19452
{{EXI{1,2{{{TAKE APPROPRIATE ERROR EXIT{19453
*
*      HERE FOR ERROR CONVERTING LEFT OPERAND
*
{ARTH7{EXI{1,1{{{TAKE APPROPRIATE ERROR RETURN{19457
{{ENP{{{{END PROCEDURE ARITH{19458
{{EJC{{{{{19459
*
*      ASIGN -- PERFORM ASSIGNMENT
*
*      ASIGN PERFORMS THE ASSIGNMENT OF A VALUE TO A VARIABLE
*      WITH APPROPRIATE CHECKS FOR OUTPUT ASSOCIATIONS AND
*      VALUE TRACE ASSOCIATIONS WHICH ARE EXECUTED AS REQUIRED.
*      ASIGN ALSO HANDLES THE SPECIAL CASES OF ASSIGNMENT TO
*      PATTERN AND EXPRESSION VARIABLES.
*
*      (WB)                  VALUE TO BE ASSIGNED
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      JSR  ASIGN            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC FOR FAILURE
*      (XR,XL,WA,WB,WC)      DESTROYED
*      (RA)                  DESTROYED
*
*      FAILURE OCCURS IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ASIGN{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){19480
*
*      MERGE BACK HERE TO ASSIGN RESULT TO EXPRESSION VARIABLE.
*
{ASG01{ADD{8,WA{7,XL{{POINT TO VARIABLE VALUE{19484
{{MOV{9,(XL){7,XR{{LOAD VARIABLE VALUE{19485
{{BEQ{9,(XR){22,=B$TRT{6,ASG02{JUMP IF TRAPPED{19486
{{MOV{8,WB{9,(XL){{ELSE PERFORM ASSIGNMENT{19487
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{19488
{{EXI{{{{AND RETURN TO ASIGN CALLER{19489
*
*      HERE IF VALUE IS TRAPPED
*
{ASG02{SUB{8,WA{7,XL{{RESTORE NAME BASE{19493
{{BEQ{7,XR{21,=TRBKV{6,ASG14{JUMP IF KEYWORD VARIABLE{19494
{{BNE{7,XR{21,=TRBEV{6,ASG04{JUMP IF NOT EXPRESSION VARIABLE{19495
*
*      HERE FOR ASSIGNMENT TO EXPRESSION VARIABLE
*
{{MOV{13,EVEXP(XL){7,XR{{POINT TO EXPRESSION{19499
{{MOV{8,WB{11,-(XS){{STORE VALUE TO ASSIGN ON STACK{19500
{{MOV{18,=NUM01{8,WB{{SET FOR EVALUATION BY NAME{19501
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{19502
{{PPM{6,ASG03{{{JUMP IF EVALUATION FAILS{19503
{{MOV{10,(XS)+{8,WB{{ELSE RELOAD VALUE TO ASSIGN{19504
{{BRN{6,ASG01{{{LOOP BACK TO PERFORM ASSIGNMENT{19505
{{EJC{{{{{19506
*
*      ASIGN (CONTINUED)
*
*      HERE FOR FAILURE DURING EXPRESSION EVALUATION
*
{ASG03{ICA{7,XS{{{REMOVE STACKED VALUE ENTRY{19512
{{EXI{1,1{{{TAKE FAILURE EXIT{19513
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ASG04{MOV{7,XR{11,-(XS){{SAVE PTR TO FIRST TRBLK{19517
*
*      LOOP TO CHASE DOWN TRBLK CHAIN AND ASSIGN VALUE AT END
*
{ASG05{MOV{7,XR{8,WC{{SAVE PTR TO THIS TRBLK{19521
{{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK{19522
{{BEQ{9,(XR){22,=B$TRT{6,ASG05{LOOP BACK IF ANOTHER TRBLK{19523
{{MOV{8,WC{7,XR{{ELSE POINT BACK TO LAST TRBLK{19524
{{MOV{8,WB{13,TRVAL(XR){{STORE VALUE AT END OF CHAIN{19525
{{MOV{10,(XS)+{7,XR{{RESTORE PTR TO FIRST TRBLK{19526
*
*      LOOP TO PROCESS TRBLK ENTRIES ON CHAIN
*
{ASG06{MOV{13,TRTYP(XR){8,WB{{LOAD TYPE CODE OF TRBLK{19530
{{BEQ{8,WB{18,=TRTVL{6,ASG08{JUMP IF VALUE TRACE{19531
{{BEQ{8,WB{18,=TRTOU{6,ASG10{JUMP IF OUTPUT ASSOCIATION{19532
*
*      HERE TO MOVE TO NEXT TRBLK ON CHAIN
*
{ASG07{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK ON CHAIN{19536
{{BEQ{9,(XR){22,=B$TRT{6,ASG06{LOOP BACK IF ANOTHER TRBLK{19537
{{EXI{{{{ELSE END OF CHAIN, RETURN TO CALLER{19538
*
*      HERE TO PROCESS VALUE TRACE
*
{ASG08{BZE{3,KVTRA{6,ASG07{{IGNORE VALUE TRACE IF TRACE OFF{19542
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{19543
{{BZE{13,TRFNC(XR){6,ASG09{{JUMP IF PRINT TRACE{19544
{{JSR{6,TRXEQ{{{ELSE EXECUTE FUNCTION TRACE{19545
{{BRN{6,ASG07{{{AND LOOP BACK{19546
{{EJC{{{{{19547
*
*      ASIGN (CONTINUED)
*
*      HERE FOR PRINT TRACE
*
{ASG09{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{19553
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{19554
{{BRN{6,ASG07{{{LOOP BACK FOR NEXT TRBLK{19555
*
*      HERE FOR OUTPUT ASSOCIATION
*
{ASG10{BZE{3,KVOUP{6,ASG07{{IGNORE OUTPUT ASSOC IF OUTPUT OFF{19559
{ASG1B{MOV{7,XR{7,XL{{COPY TRBLK POINTER{19560
{{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK{19561
{{BEQ{9,(XR){22,=B$TRT{6,ASG1B{LOOP BACK IF ANOTHER TRBLK{19562
{{MOV{7,XL{7,XR{{ELSE POINT BACK TO LAST TRBLK{19563
{{MOV{13,TRVAL(XR){11,-(XS){{STACK VALUE TO OUTPUT{19565
{{JSR{6,GTSTG{{{CONVERT TO STRING{19571
{{PPM{6,ASG12{{{GET DATATYPE NAME IF UNCONVERTIBLE{19572
*
*      MERGE WITH STRING OR BUFFER TO OUTPUT IN XR
*
{ASG11{MOV{13,TRFPT(XL){8,WA{{FCBLK PTR{19576
{{BZE{8,WA{6,ASG13{{JUMP IF STANDARD OUTPUT FILE{19577
*
*      HERE FOR OUTPUT TO FILE
*
{ASG1A{JSR{6,SYSOU{{{CALL SYSTEM OUTPUT ROUTINE{19581
{{ERR{1,206{26,Output caused file overflow{{{19582
{{ERR{1,207{26,Output caused non-recoverable error{{{19583
{{EXI{{{{ELSE ALL DONE, RETURN TO CALLER{19584
*
*      IF NOT PRINTABLE, GET DATATYPE NAME INSTEAD
*
{ASG12{JSR{6,DTYPE{{{CALL DATATYPE ROUTINE{19588
{{BRN{6,ASG11{{{MERGE{19589
*
*      HERE TO PRINT A STRING TO STANDARD OUTPUT OR TERMINAL
*
{ASG13{BEQ{13,TRTER(XL){21,=V$TER{6,ASG1A{JUMP IF TERMINAL OUTPUT{19594
{{ICV{8,WA{{{SIGNAL STANDARD OUTPUT{19595
{{BRN{6,ASG1A{{{USE SYSOU TO PERFORM OUTPUT{19596
{{EJC{{{{{19611
*
*      ASIGN (CONTINUED)
*
*      HERE FOR KEYWORD ASSIGNMENT
*
{ASG14{MOV{13,KVNUM(XL){7,XL{{LOAD KEYWORD NUMBER{19617
{{BEQ{7,XL{18,=K$ETX{6,ASG19{JUMP IF ERRTEXT{19618
{{MOV{8,WB{7,XR{{COPY VALUE TO BE ASSIGNED{19619
{{JSR{6,GTINT{{{CONVERT TO INTEGER{19620
{{ERR{1,208{26,Keyword value assigned is not integer{{{19621
{{LDI{13,ICVAL(XR){{{ELSE LOAD VALUE{19622
{{BEQ{7,XL{18,=K$STL{6,ASG16{JUMP IF SPECIAL CASE OF STLIMIT{19623
{{MFI{8,WA{6,ASG18{{ELSE GET ADDR INTEGER, TEST OVFLOW{19624
{{BGT{8,WA{3,MXLEN{6,ASG18{FAIL IF TOO LARGE{19625
{{BEQ{7,XL{18,=K$ERT{6,ASG17{JUMP IF SPECIAL CASE OF ERRTYPE{19626
{{BEQ{7,XL{18,=K$PFL{6,ASG21{JUMP IF SPECIAL CASE OF PROFILE{19629
{{BEQ{7,XL{18,=K$MXL{6,ASG24{JUMP IF SPECIAL CASE OF MAXLNGTH{19631
{{BEQ{7,XL{18,=K$FLS{6,ASG26{JUMP IF SPECIAL CASE OF FULLSCAN{19632
{{BLT{7,XL{18,=K$P$${6,ASG15{JUMP UNLESS PROTECTED{19633
{{ERB{1,209{26,Keyword in assignment is protected{{{19634
*
*      HERE TO DO ASSIGNMENT IF NOT PROTECTED
*
{ASG15{MOV{8,WA{15,KVABE(XL){{STORE NEW VALUE{19638
{{EXI{{{{RETURN TO ASIGN CALLER{19639
*
*      HERE FOR SPECIAL CASE OF STLIMIT
*
*      SINCE STCOUNT IS MAINTAINED AS (STLIMIT-STCOUNT)
*      IT IS ALSO NECESSARY TO MODIFY STCOUNT APPROPRIATELY.
*
{ASG16{SBI{3,KVSTL{{{SUBTRACT OLD LIMIT{19646
{{ADI{3,KVSTC{{{ADD OLD COUNTER{19647
{{STI{3,KVSTC{{{STORE COURSE COUNTER VALUE{19648
{{LDI{3,KVSTL{{{CHECK IF COUNTING SUPPRESSED{19649
{{ILT{6,ASG25{{{DO NOT REFINE IF SO{19650
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER BREAKOUT{19651
{{SUB{3,STMCT{8,WA{{VALUES{19652
{{MTI{8,WA{{{CONVERT TO INTEGER{19653
{{NGI{{{{CURRENT-START VALUE{19654
{{ADI{3,KVSTC{{{ADD IN COURSE COUNTER VALUE{19655
{{STI{3,KVSTC{{{SAVE REFINED VALUE{19656
{ASG25{LDI{13,ICVAL(XR){{{RELOAD NEW LIMIT VALUE{19657
{{STI{3,KVSTL{{{STORE NEW LIMIT VALUE{19658
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{19659
{{EXI{{{{RETURN TO ASIGN CALLER{19660
*
*      HERE FOR SPECIAL CASE OF ERRTYPE
*
{ASG17{BLE{8,WA{18,=NINI9{6,ERROR{OK TO SIGNAL IF IN RANGE{19664
*
*      HERE IF VALUE ASSIGNED IS OUT OF RANGE
*
{ASG18{ERB{1,210{26,Keyword value assigned is negative or too large{{{19668
*
*      HERE FOR SPECIAL CASE OF ERRTEXT
*
{ASG19{MOV{8,WB{11,-(XS){{STACK VALUE{19672
{{JSR{6,GTSTG{{{CONVERT TO STRING{19673
{{ERR{1,211{26,Value assigned to keyword ERRTEXT not a string{{{19674
{{MOV{7,XR{3,R$ETX{{MAKE ASSIGNMENT{19675
{{EXI{{{{RETURN TO CALLER{19676
*
*      HERE FOR KEYWORD PROFILE
*
{ASG21{BGT{8,WA{18,=NUM02{6,ASG18{MOAN IF NOT 0,1, OR 2{19690
{{BZE{8,WA{6,ASG15{{JUST ASSIGN IF ZERO{19691
{{BZE{3,PFDMP{6,ASG22{{BRANCH IF FIRST ASSIGNMENT{19692
{{BEQ{8,WA{3,PFDMP{6,ASG23{ALSO IF SAME VALUE AS BEFORE{19693
{{ERB{1,268{26,Inconsistent value assigned to keyword PROFILE{{{19694
*
{ASG22{MOV{8,WA{3,PFDMP{{NOTE VALUE ON FIRST ASSIGNMENT{19696
{ASG23{MOV{8,WA{3,KVPFL{{STORE NEW VALUE{19697
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTS{19698
{{JSR{6,SYSTM{{{GET THE TIME{19699
{{STI{3,PFSTM{{{FUDGE SOME KIND OF START TIME{19700
{{EXI{{{{RETURN TO ASIGN CALLER{19701
*
*      HERE FOR KEYWORD MAXLNGTH
*
{ASG24{BGE{8,WA{18,=MNLEN{6,ASG15{IF ACCEPTABLE VALUE{19706
{{ERB{1,287{26,Value assigned to keyword MAXLNGTH is too small{{{19707
*
*      HERE FOR KEYWORD FULLSCAN
*
{ASG26{BNZ{8,WA{6,ASG15{{IF ACCEPTABLE VALUE{19711
{{ERB{1,274{26,Value assigned to keyword FULLSCAN is zero{{{19712
*
{{ENP{{{{END PROCEDURE ASIGN{19714
{{EJC{{{{{19715
*
*      ASINP -- ASSIGN DURING PATTERN MATCH
*
*      ASINP IS LIKE ASIGN AND HAS A SIMILAR CALLING SEQUENCE
*      AND EFFECT. THE DIFFERENCE IS THAT THE GLOBAL PATTERN
*      VARIABLES ARE SAVED AND RESTORED IF REQUIRED.
*
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      (WB)                  VALUE TO BE ASSIGNED
*      JSR  ASINP            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC IF FAILURE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{ASINP{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{19731
{{ADD{8,WA{7,XL{{POINT TO VARIABLE{19732
{{MOV{9,(XL){7,XR{{LOAD CURRENT CONTENTS{19733
{{BEQ{9,(XR){22,=B$TRT{6,ASNP1{JUMP IF TRAPPED{19734
{{MOV{8,WB{9,(XL){{ELSE PERFORM ASSIGNMENT{19735
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{19736
{{EXI{{{{RETURN TO ASINP CALLER{19737
*
*      HERE IF VARIABLE IS TRAPPED
*
{ASNP1{SUB{8,WA{7,XL{{RESTORE BASE POINTER{19741
{{MOV{3,PMSSL{11,-(XS){{STACK SUBJECT STRING LENGTH{19742
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE PTR{19743
{{MOV{3,R$PMS{11,-(XS){{STACK SUBJECT STRING POINTER{19744
{{MOV{3,PMDFL{11,-(XS){{STACK DOT FLAG{19745
{{JSR{6,ASIGN{{{CALL FULL-BLOWN ASSIGNMENT ROUTINE{19746
{{PPM{6,ASNP2{{{JUMP IF FAILURE{19747
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{19748
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{19749
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{19750
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{19751
{{EXI{{{{RETURN TO ASINP CALLER{19752
*
*      HERE IF FAILURE IN ASIGN CALL
*
{ASNP2{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{19756
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{19757
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{19758
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{19759
{{EXI{1,1{{{TAKE FAILURE EXIT{19760
{{ENP{{{{END PROCEDURE ASINP{19761
{{EJC{{{{{19762
*
*      BLKLN -- DETERMINE LENGTH OF BLOCK
*
*      BLKLN DETERMINES THE LENGTH OF A BLOCK IN DYNAMIC STORE.
*
*      (WA)                  FIRST WORD OF BLOCK
*      (XR)                  POINTER TO BLOCK
*      JSR  BLKLN            CALL TO GET BLOCK LENGTH
*      (WA)                  LENGTH OF BLOCK IN BYTES
*      (XL)                  DESTROYED
*
*      BLKLN IS USED BY THE GARBAGE COLLECTOR AND IS NOT
*      PERMITTED TO CALL GBCOL DIRECTLY OR INDIRECTLY.
*
*      THE FIRST WORD STORED IN THE BLOCK (I.E. AT XR) MAY
*      BE ANYTHING, BUT THE CONTENTS OF WA MUST BE CORRECT.
*
{BLKLN{PRC{25,E{1,0{{ENTRY POINT{19780
{{MOV{8,WA{7,XL{{COPY FIRST WORD{19781
{{LEI{7,XL{{{GET ENTRY ID (BL$XX){19782
{{BSW{7,XL{2,BL$$${6,BLN00{SWITCH ON BLOCK TYPE{19783
{{IFF{2,BL$AR{6,BLN01{{ARBLK{19823
{{IFF{2,BL$CD{6,BLN12{{CDBLK{19823
{{IFF{2,BL$EX{6,BLN12{{EXBLK{19823
{{IFF{2,BL$IC{6,BLN07{{ICBLK{19823
{{IFF{2,BL$NM{6,BLN03{{NMBLK{19823
{{IFF{2,BL$P0{6,BLN02{{P0BLK{19823
{{IFF{2,BL$P1{6,BLN03{{P1BLK{19823
{{IFF{2,BL$P2{6,BLN04{{P2BLK{19823
{{IFF{2,BL$RC{6,BLN09{{RCBLK{19823
{{IFF{2,BL$SC{6,BLN10{{SCBLK{19823
{{IFF{2,BL$SE{6,BLN02{{SEBLK{19823
{{IFF{2,BL$TB{6,BLN01{{TBBLK{19823
{{IFF{2,BL$VC{6,BLN01{{VCBLK{19823
{{IFF{1,13{6,BLN00{{{19823
{{IFF{1,14{6,BLN00{{{19823
{{IFF{1,15{6,BLN00{{{19823
{{IFF{2,BL$PD{6,BLN08{{PDBLK{19823
{{IFF{2,BL$TR{6,BLN05{{TRBLK{19823
{{IFF{1,18{6,BLN00{{{19823
{{IFF{1,19{6,BLN00{{{19823
{{IFF{1,20{6,BLN00{{{19823
{{IFF{2,BL$CT{6,BLN06{{CTBLK{19823
{{IFF{2,BL$DF{6,BLN01{{DFBLK{19823
{{IFF{2,BL$EF{6,BLN01{{EFBLK{19823
{{IFF{2,BL$EV{6,BLN03{{EVBLK{19823
{{IFF{2,BL$FF{6,BLN05{{FFBLK{19823
{{IFF{2,BL$KV{6,BLN03{{KVBLK{19823
{{IFF{2,BL$PF{6,BLN01{{PFBLK{19823
{{IFF{2,BL$TE{6,BLN04{{TEBLK{19823
{{ESW{{{{END OF JUMP TABLE ON BLOCK TYPE{19823
{{EJC{{{{{19824
*
*      BLKLN (CONTINUED)
*
*      HERE FOR BLOCKS WITH LENGTH IN SECOND WORD
*
{BLN00{MOV{13,NUM01(XR){8,WA{{LOAD LENGTH{19830
{{EXI{{{{RETURN TO BLKLN CALLER{19831
*
*      HERE FOR LENGTH IN THIRD WORD (AR,CD,DF,EF,EX,PF,TB,VC)
*
{BLN01{MOV{13,NUM02(XR){8,WA{{LOAD LENGTH FROM THIRD WORD{19835
{{EXI{{{{RETURN TO BLKLN CALLER{19836
*
*      HERE FOR TWO WORD BLOCKS (P0,SE)
*
{BLN02{MOV{19,*NUM02{8,WA{{LOAD LENGTH (TWO WORDS){19840
{{EXI{{{{RETURN TO BLKLN CALLER{19841
*
*      HERE FOR THREE WORD BLOCKS (NM,P1,EV,KV)
*
{BLN03{MOV{19,*NUM03{8,WA{{LOAD LENGTH (THREE WORDS){19845
{{EXI{{{{RETURN TO BLKLN CALLER{19846
*
*      HERE FOR FOUR WORD BLOCKS (P2,TE,BC)
*
{BLN04{MOV{19,*NUM04{8,WA{{LOAD LENGTH (FOUR WORDS){19850
{{EXI{{{{RETURN TO BLKLN CALLER{19851
*
*      HERE FOR FIVE WORD BLOCKS (FF,TR)
*
{BLN05{MOV{19,*NUM05{8,WA{{LOAD LENGTH{19855
{{EXI{{{{RETURN TO BLKLN CALLER{19856
{{EJC{{{{{19857
*
*      BLKLN (CONTINUED)
*
*      HERE FOR CTBLK
*
{BLN06{MOV{19,*CTSI${8,WA{{SET SIZE OF CTBLK{19863
{{EXI{{{{RETURN TO BLKLN CALLER{19864
*
*      HERE FOR ICBLK
*
{BLN07{MOV{19,*ICSI${8,WA{{SET SIZE OF ICBLK{19868
{{EXI{{{{RETURN TO BLKLN CALLER{19869
*
*      HERE FOR PDBLK
*
{BLN08{MOV{13,PDDFP(XR){7,XL{{POINT TO DFBLK{19873
{{MOV{13,DFPDL(XL){8,WA{{LOAD PDBLK LENGTH FROM DFBLK{19874
{{EXI{{{{RETURN TO BLKLN CALLER{19875
*
*      HERE FOR RCBLK
*
{BLN09{MOV{19,*RCSI${8,WA{{SET SIZE OF RCBLK{19881
{{EXI{{{{RETURN TO BLKLN CALLER{19882
*
*      HERE FOR SCBLK
*
{BLN10{MOV{13,SCLEN(XR){8,WA{{LOAD LENGTH IN CHARACTERS{19887
{{CTB{8,WA{2,SCSI${{CALCULATE LENGTH IN BYTES{19888
{{EXI{{{{RETURN TO BLKLN CALLER{19889
*
*      HERE FOR LENGTH IN FOURTH WORD (CD,EX)
*
{BLN12{MOV{13,NUM03(XR){8,WA{{LOAD LENGTH FROM CDLEN/EXLEN{19903
{{EXI{{{{RETURN TO BLKLN CALLER{19904
{{ENP{{{{END PROCEDURE BLKLN{19906
{{EJC{{{{{19907
*
*      COPYB -- COPY A BLOCK
*
*      (XS)                  BLOCK TO BE COPIED
*      JSR  COPYB            CALL TO COPY BLOCK
*      PPM  LOC              RETURN IF BLOCK HAS NO IDVAL FIELD
*                            NORMAL RETURN IF IDVAL FIELD
*      (XR)                  COPY OF BLOCK
*      (XS)                  POPPED
*      (XL,WA,WB,WC)         DESTROYED
*
{COPYB{PRC{25,N{1,1{{ENTRY POINT{19919
{{MOV{9,(XS){7,XR{{LOAD ARGUMENT{19920
{{BEQ{7,XR{21,=NULLS{6,COP10{RETURN ARGUMENT IF IT IS NULL{19921
{{MOV{9,(XR){8,WA{{ELSE LOAD TYPE WORD{19922
{{MOV{8,WA{8,WB{{COPY TYPE WORD{19923
{{JSR{6,BLKLN{{{GET LENGTH OF ARGUMENT BLOCK{19924
{{MOV{7,XR{7,XL{{COPY POINTER{19925
{{JSR{6,ALLOC{{{ALLOCATE BLOCK OF SAME SIZE{19926
{{MOV{7,XR{9,(XS){{STORE POINTER TO COPY{19927
{{MVW{{{{COPY CONTENTS OF OLD BLOCK TO NEW{19928
{{ZER{7,XL{{{CLEAR GARBAGE XL{19929
{{MOV{9,(XS){7,XR{{RELOAD POINTER TO START OF COPY{19930
{{BEQ{8,WB{22,=B$TBT{6,COP05{JUMP IF TABLE{19931
{{BEQ{8,WB{22,=B$VCT{6,COP01{JUMP IF VECTOR{19932
{{BEQ{8,WB{22,=B$PDT{6,COP01{JUMP IF PROGRAM DEFINED{19933
{{BNE{8,WB{22,=B$ART{6,COP10{RETURN COPY IF NOT ARRAY{19938
*
*      HERE FOR ARRAY (ARBLK)
*
{{ADD{13,AROFS(XR){7,XR{{POINT TO PROTOTYPE FIELD{19942
{{BRN{6,COP02{{{JUMP TO MERGE{19943
*
*      HERE FOR VECTOR, PROGRAM DEFINED
*
{COP01{ADD{19,*PDFLD{7,XR{{POINT TO PDFLD = VCVLS{19947
*
*      MERGE HERE FOR ARBLK, VCBLK, PDBLK TO DELETE TRAP
*      BLOCKS FROM ALL VALUE FIELDS (THE COPY IS UNTRAPPED)
*
{COP02{MOV{9,(XR){7,XL{{LOAD NEXT POINTER{19952
*
*      LOOP TO GET VALUE AT END OF TRBLK CHAIN
*
{COP03{BNE{9,(XL){22,=B$TRT{6,COP04{JUMP IF NOT TRAPPED{19956
{{MOV{13,TRVAL(XL){7,XL{{ELSE POINT TO NEXT VALUE{19957
{{BRN{6,COP03{{{AND LOOP BACK{19958
{{EJC{{{{{19959
*
*      COPYB (CONTINUED)
*
*      HERE WITH UNTRAPPED VALUE IN XL
*
{COP04{MOV{7,XL{10,(XR)+{{STORE REAL VALUE, BUMP POINTER{19965
{{BNE{7,XR{3,DNAMP{6,COP02{LOOP BACK IF MORE TO GO{19966
{{BRN{6,COP09{{{ELSE JUMP TO EXIT{19967
*
*      HERE TO COPY A TABLE
*
{COP05{ZER{13,IDVAL(XR){{{ZERO ID TO STOP DUMP BLOWING UP{19971
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{19972
{{MOV{19,*TBBUK{8,WC{{SET INITIAL OFFSET{19973
*
*      LOOP THROUGH BUCKETS IN TABLE
*
{COP06{MOV{9,(XS){7,XR{{LOAD TABLE POINTER{19977
{{BEQ{8,WC{13,TBLEN(XR){6,COP09{JUMP TO EXIT IF ALL DONE{19978
{{MOV{8,WC{8,WB{{ELSE COPY OFFSET{19979
{{SUB{19,*TENXT{8,WB{{SUBTRACT LINK OFFSET TO MERGE{19980
{{ADD{8,WB{7,XR{{NEXT BUCKET HEADER LESS LINK OFFSET{19981
{{ICA{8,WC{{{BUMP OFFSET{19982
*
*      LOOP THROUGH TEBLKS ON ONE CHAIN
*
{COP07{MOV{13,TENXT(XR){7,XL{{LOAD POINTER TO NEXT TEBLK{19986
{{MOV{9,(XS){13,TENXT(XR){{SET END OF CHAIN POINTER IN CASE{19987
{{BEQ{9,(XL){22,=B$TBT{6,COP06{BACK FOR NEXT BUCKET IF CHAIN END{19988
{{SUB{8,WB{7,XR{{POINT TO HEAD OF PREVIOUS BLOCK{19989
{{MOV{7,XR{11,-(XS){{STACK PTR TO PREVIOUS BLOCK{19990
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{19991
{{JSR{6,ALLOC{{{ALLOCATE NEW TEBLK{19992
{{MOV{7,XR{11,-(XS){{STACK PTR TO NEW TEBLK{19993
{{MVW{{{{COPY OLD TEBLK TO NEW TEBLK{19994
{{MOV{10,(XS)+{7,XR{{RESTORE POINTER TO NEW TEBLK{19995
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER TO PREVIOUS BLOCK{19996
{{ADD{8,WB{7,XL{{ADD OFFSET BACK IN{19997
{{MOV{7,XR{13,TENXT(XL){{LINK NEW BLOCK TO PREVIOUS{19998
{{MOV{7,XR{7,XL{{COPY POINTER TO NEW BLOCK{19999
*
*      LOOP TO SET REAL VALUE AFTER REMOVING TRAP CHAIN
*
{COP08{MOV{13,TEVAL(XL){7,XL{{LOAD VALUE{20003
{{BEQ{9,(XL){22,=B$TRT{6,COP08{LOOP BACK IF TRAPPED{20004
{{MOV{7,XL{13,TEVAL(XR){{STORE UNTRAPPED VALUE IN TEBLK{20005
{{ZER{8,WB{{{ZERO OFFSET WITHIN TEBLK{20006
{{BRN{6,COP07{{{BACK FOR NEXT TEBLK{20007
*
*      COMMON EXIT POINT
*
{COP09{MOV{10,(XS)+{7,XR{{LOAD POINTER TO BLOCK{20011
{{EXI{{{{RETURN{20012
*
*      ALTERNATIVE RETURN
*
{COP10{EXI{1,1{{{RETURN{20016
{{EJC{{{{{20017
{{ENP{{{{END PROCEDURE COPYB{20035
*
*      CDGCG -- GENERATE CODE FOR COMPLEX GOTO
*
*      USED BY CMPIL TO PROCESS COMPLEX GOTO TREE
*
*      (WB)                  MUST BE COLLECTABLE
*      (XR)                  EXPRESSION POINTER
*      JSR  CDGCG            CALL TO GENERATE COMPLEX GOTO
*      (XL,XR,WA)            DESTROYED
*
{CDGCG{PRC{25,E{1,0{{ENTRY POINT{20046
{{MOV{13,CMOPN(XR){7,XL{{GET UNARY GOTO OPERATOR{20047
{{MOV{13,CMROP(XR){7,XR{{POINT TO GOTO OPERAND{20048
{{BEQ{7,XL{21,=OPDVD{6,CDGC2{JUMP IF DIRECT GOTO{20049
{{JSR{6,CDGNM{{{GENERATE OPND BY NAME IF NOT DIRECT{20050
*
*      RETURN POINT
*
{CDGC1{MOV{7,XL{8,WA{{GOTO OPERATOR{20054
{{JSR{6,CDWRD{{{GENERATE IT{20055
{{EXI{{{{RETURN TO CALLER{20056
*
*      DIRECT GOTO
*
{CDGC2{JSR{6,CDGVL{{{GENERATE OPERAND BY VALUE{20060
{{BRN{6,CDGC1{{{MERGE TO RETURN{20061
{{ENP{{{{END PROCEDURE CDGCG{20062
{{EJC{{{{{20063
*
*      CDGEX -- BUILD EXPRESSION BLOCK
*
*      CDGEX IS PASSED A POINTER TO AN EXPRESSION TREE (SEE
*      EXPAN) AND RETURNS AN EXPRESSION (SEBLK OR EXBLK).
*
*      (WA)                  0 IF BY VALUE, 1 IF BY NAME
*      (WC)                  SOME COLLECTABLE VALUE
*      (WB)                  INTEGER IN RANGE 0 LE X LE MXLEN
*      (XL)                  PTR TO EXPRESSION TREE
*      JSR  CDGEX            CALL TO BUILD EXPRESSION
*      (XR)                  PTR TO SEBLK OR EXBLK
*      (XL,WA,WB)            DESTROYED
*
{CDGEX{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20080
{{BLO{9,(XL){22,=B$VR${6,CDGX1{JUMP IF NOT VARIABLE{20081
*
*      HERE FOR NATURAL VARIABLE, BUILD SEBLK
*
{{MOV{19,*SESI${8,WA{{SET SIZE OF SEBLK{20085
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR SEBLK{20086
{{MOV{22,=B$SEL{9,(XR){{SET TYPE WORD{20087
{{MOV{7,XL{13,SEVAR(XR){{STORE VRBLK POINTER{20088
{{EXI{{{{RETURN TO CDGEX CALLER{20089
*
*      HERE IF NOT VARIABLE, BUILD EXBLK
*
{CDGX1{MOV{7,XL{7,XR{{COPY TREE POINTER{20093
{{MOV{8,WC{11,-(XS){{SAVE WC{20094
{{MOV{3,CWCOF{7,XL{{SAVE CURRENT OFFSET{20095
{{BZE{8,WA{6,CDGX2{{JUMP IF BY VALUE{20097
{{MOV{9,(XR){8,WA{{GET TYPE WORD{20099
{{BNE{8,WA{22,=B$CMT{6,CDGX2{CALL BY VALUE IF NOT CMBLK{20100
{{BGE{13,CMTYP(XR){18,=C$$NM{6,CDGX2{JUMP IF CMBLK ONLY BY VALUE{20101
{{EJC{{{{{20102
*
*      CDGEX (CONTINUED)
*
*      HERE IF EXPRESSION CAN BE EVALUATED BY NAME
*
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME{20108
{{MOV{21,=ORNM${8,WA{{LOAD RETURN BY NAME WORD{20109
{{BRN{6,CDGX3{{{MERGE WITH VALUE CASE{20110
*
*      HERE IF EXPRESSION CAN ONLY BE EVALUATED BY VALUE
*
{CDGX2{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20114
{{MOV{21,=ORVL${8,WA{{LOAD RETURN BY VALUE WORD{20115
*
*      MERGE HERE TO CONSTRUCT EXBLK
*
{CDGX3{JSR{6,CDWRD{{{GENERATE RETURN WORD{20119
{{JSR{6,EXBLD{{{BUILD EXBLK{20120
{{MOV{10,(XS)+{8,WC{{RESTORE WC{20121
{{EXI{{{{RETURN TO CDGEX CALLER{20122
{{ENP{{{{END PROCEDURE CDGEX{20123
{{EJC{{{{{20124
*
*      CDGNM -- GENERATE CODE BY NAME
*
*      CDGNM IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY NAME FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF CODE GENERATED. THE INPUT
*      TO CDGNM IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGNM IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGNM            CALL TO GENERATE CODE BY NAME
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGNM{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20149
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20150
{{MOV{8,WB{11,-(XS){{SAVE ENTRY WB{20151
{{CHK{{{{CHECK FOR STACK OVERFLOW{20152
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{20153
{{BEQ{8,WA{22,=B$CMT{6,CGN04{JUMP IF CMBLK{20154
{{BHI{8,WA{22,=B$VR${6,CGN02{JUMP IF SIMPLE VARIABLE{20155
*
*      MERGE HERE FOR OPERAND YIELDING VALUE (E.G. CONSTANT)
*
{CGN01{ERB{1,212{26,Syntax error: Value used where name is required{{{20159
*
*      HERE FOR NATURAL VARIABLE REFERENCE
*
{CGN02{MOV{21,=OLVN${8,WA{{LOAD VARIABLE LOAD CALL{20163
{{JSR{6,CDWRD{{{GENERATE IT{20164
{{MOV{7,XR{8,WA{{COPY VRBLK POINTER{20165
{{JSR{6,CDWRD{{{GENERATE VRBLK POINTER{20166
{{EJC{{{{{20167
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT WITH WC SET CORRECTLY
*
{CGN03{MOV{10,(XS)+{8,WB{{RESTORE ENTRY WB{20173
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{20174
{{EXI{{{{RETURN TO CDGNM CALLER{20175
*
*      HERE FOR CMBLK
*
{CGN04{MOV{7,XR{7,XL{{COPY CMBLK POINTER{20179
{{MOV{13,CMTYP(XR){7,XR{{LOAD CMBLK TYPE{20180
{{BGE{7,XR{18,=C$$NM{6,CGN01{ERROR IF NOT NAME OPERAND{20181
{{BSW{7,XR{2,C$$NM{{ELSE SWITCH ON TYPE{20182
{{IFF{2,C$ARR{6,CGN05{{ARRAY REFERENCE{20190
{{IFF{2,C$FNC{6,CGN08{{FUNCTION CALL{20190
{{IFF{2,C$DEF{6,CGN09{{DEFERRED EXPRESSION{20190
{{IFF{2,C$IND{6,CGN10{{INDIRECT REFERENCE{20190
{{IFF{2,C$KEY{6,CGN11{{KEYWORD REFERENCE{20190
{{IFF{2,C$UBO{6,CGN08{{UNDEFINED BINARY OP{20190
{{IFF{2,C$UUO{6,CGN08{{UNDEFINED UNARY OP{20190
{{ESW{{{{END SWITCH ON CMBLK TYPE{20190
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGN05{MOV{19,*CMOPN{8,WB{{POINT TO ARRAY OPERAND{20194
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGN06{JSR{6,CMGEN{{{GENERATE CODE FOR NEXT OPERAND{20198
{{MOV{13,CMLEN(XL){8,WC{{LOAD LENGTH OF CMBLK{20199
{{BLT{8,WB{8,WC{6,CGN06{LOOP TILL ALL GENERATED{20200
*
*      GENERATE APPROPRIATE ARRAY CALL
*
{{MOV{21,=OAON${8,WA{{LOAD ONE-SUBSCRIPT CASE CALL{20204
{{BEQ{8,WC{19,*CMAR1{6,CGN07{JUMP TO EXIT IF ONE SUBSCRIPT CASE{20205
{{MOV{21,=OAMN${8,WA{{ELSE LOAD MULTI-SUBSCRIPT CASE CALL{20206
{{JSR{6,CDWRD{{{GENERATE CALL{20207
{{MOV{8,WC{8,WA{{COPY CMBLK LENGTH{20208
{{BTW{8,WA{{{CONVERT TO WORDS{20209
{{SUB{18,=CMVLS{8,WA{{CALCULATE NUMBER OF SUBSCRIPTS{20210
{{EJC{{{{{20211
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT GENERATING WORD (NON-CONSTANT)
*
{CGN07{MNZ{8,WC{{{SET RESULT NON-CONSTANT{20217
{{JSR{6,CDWRD{{{GENERATE WORD{20218
{{BRN{6,CGN03{{{BACK TO EXIT{20219
*
*      HERE TO GENERATE CODE FOR FUNCTIONS AND UNDEFINED OPRS
*
{CGN08{MOV{7,XL{7,XR{{COPY CMBLK POINTER{20223
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR CALL{20224
{{MOV{21,=OFNE${8,WA{{GET EXTRA CALL FOR BY NAME{20225
{{BRN{6,CGN07{{{BACK TO GENERATE AND EXIT{20226
*
*      HERE TO GENERATE CODE FOR DEFERED EXPRESSION
*
{CGN09{MOV{13,CMROP(XL){7,XR{{CHECK IF VARIABLE{20230
{{BHI{9,(XR){22,=B$VR${6,CGN02{TREAT *VARIABLE AS SIMPLE VAR{20231
{{MOV{7,XR{7,XL{{COPY PTR TO EXPRESSION TREE{20232
{{MOV{18,=NUM01{8,WA{{RETURN NAME{20234
{{JSR{6,CDGEX{{{ELSE BUILD EXBLK{20236
{{MOV{21,=OLEX${8,WA{{SET CALL TO LOAD EXPR BY NAME{20237
{{JSR{6,CDWRD{{{GENERATE IT{20238
{{MOV{7,XR{8,WA{{COPY EXBLK POINTER{20239
{{JSR{6,CDWRD{{{GENERATE EXBLK POINTER{20240
{{BRN{6,CGN03{{{BACK TO EXIT{20241
*
*      HERE TO GENERATE CODE FOR INDIRECT REFERENCE
*
{CGN10{MOV{13,CMROP(XL){7,XR{{GET OPERAND{20245
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE FOR IT{20246
{{MOV{21,=OINN${8,WA{{LOAD CALL FOR INDIRECT BY NAME{20247
{{BRN{6,CGN12{{{MERGE{20248
*
*      HERE TO GENERATE CODE FOR KEYWORD REFERENCE
*
{CGN11{MOV{13,CMROP(XL){7,XR{{GET OPERAND{20252
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME FOR IT{20253
{{MOV{21,=OKWN${8,WA{{LOAD CALL FOR KEYWORD BY NAME{20254
*
*      KEYWORD, INDIRECT MERGE HERE
*
{CGN12{JSR{6,CDWRD{{{GENERATE CODE FOR OPERATOR{20258
{{BRN{6,CGN03{{{EXIT{20259
{{ENP{{{{END PROCEDURE CDGNM{20260
{{EJC{{{{{20261
*
*      CDGVL -- GENERATE CODE BY VALUE
*
*      CDGVL IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY VALUE FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF THE CODE GENERATED. THE INPUT
*      TO CDGVL IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGVL IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGVL            CALL TO GENERATE CODE BY VALUE
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      IF WC IS NON-ZERO ON ENTRY, THEN PREEVALUATION IS NOT
*      ALLOWED REGARDLESS OF THE NATURE OF THE OPERAND.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20289
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{20290
{{BEQ{8,WA{22,=B$CMT{6,CGV01{JUMP IF CMBLK{20291
{{BLT{8,WA{22,=B$VRA{6,CGV00{JUMP IF ICBLK, RCBLK, SCBLK{20292
{{BNZ{13,VRLEN(XR){6,CGVL0{{JUMP IF NOT SYSTEM VARIABLE{20293
{{MOV{7,XR{11,-(XS){{STACK XR{20294
{{MOV{13,VRSVP(XR){7,XR{{POINT TO SVBLK{20295
{{MOV{13,SVBIT(XR){8,WA{{GET SVBLK PROPERTY BITS{20296
{{MOV{10,(XS)+{7,XR{{RECOVER XR{20297
{{ANB{4,BTKWV{8,WA{{CHECK IF CONSTANT KEYWORD VALUE{20298
{{BEQ{8,WA{4,BTKWV{6,CGV00{JUMP IF CONSTANT KEYWORD VALUE{20299
*
*      HERE FOR VARIABLE VALUE REFERENCE
*
{CGVL0{MNZ{8,WC{{{INDICATE NON-CONSTANT VALUE{20303
*
*      MERGE HERE FOR SIMPLE CONSTANT (ICBLK,RCBLK,SCBLK)
*      AND FOR VARIABLES CORRESPONDING TO CONSTANT KEYWORDS.
*
{CGV00{MOV{7,XR{8,WA{{COPY PTR TO VAR OR CONSTANT{20308
{{JSR{6,CDWRD{{{GENERATE AS CODE WORD{20309
{{EXI{{{{RETURN TO CALLER{20310
{{EJC{{{{{20311
*
*      CDGVL (CONTINUED)
*
*      HERE FOR TREE NODE (CMBLK)
*
{CGV01{MOV{8,WB{11,-(XS){{SAVE ENTRY WB{20317
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20318
{{MOV{8,WC{11,-(XS){{SAVE ENTRY CONSTANT FLAG{20319
{{MOV{3,CWCOF{11,-(XS){{SAVE INITIAL CODE OFFSET{20320
{{CHK{{{{CHECK FOR STACK OVERFLOW{20321
*
*      PREPARE TO GENERATE CODE FOR CMBLK. WC IS SET TO THE
*      VALUE OF CSWNO (ZERO IF -OPTIMISE, 1 IF -NOOPT) TO
*      START WITH AND IS RESET NON-ZERO FOR ANY NON-CONSTANT
*      CODE GENERATED. IF IT IS STILL ZERO AFTER GENERATING ALL
*      THE CMBLK CODE, THEN ITS VALUE IS COMPUTED AS THE RESULT.
*
{{MOV{7,XR{7,XL{{COPY CMBLK POINTER{20329
{{MOV{13,CMTYP(XR){7,XR{{LOAD CMBLK TYPE{20330
{{MOV{3,CSWNO{8,WC{{RESET CONSTANT FLAG{20331
{{BLE{7,XR{18,=C$PR${6,CGV02{JUMP IF NOT PREDICATE VALUE{20332
{{MNZ{8,WC{{{ELSE FORCE NON-CONSTANT CASE{20333
*
*      HERE WITH WC SET APPROPRIATELY
*
{CGV02{BSW{7,XR{2,C$$NV{{SWITCH TO APPROPRIATE GENERATOR{20337
{{IFF{2,C$ARR{6,CGV03{{ARRAY REFERENCE{20357
{{IFF{2,C$FNC{6,CGV05{{FUNCTION CALL{20357
{{IFF{2,C$DEF{6,CGV14{{DEFERRED EXPRESSION{20357
{{IFF{2,C$IND{6,CGV31{{INDIRECT REFERENCE{20357
{{IFF{2,C$KEY{6,CGV27{{KEYWORD REFERENCE{20357
{{IFF{2,C$UBO{6,CGV29{{UNDEFINED BINOP{20357
{{IFF{2,C$UUO{6,CGV30{{UNDEFINED UNOP{20357
{{IFF{2,C$BVL{6,CGV18{{BINOPS WITH VAL OPDS{20357
{{IFF{2,C$UVL{6,CGV19{{UNOPS WITH VALU OPND{20357
{{IFF{2,C$ALT{6,CGV18{{ALTERNATION{20357
{{IFF{2,C$CNC{6,CGV24{{CONCATENATION{20357
{{IFF{2,C$CNP{6,CGV24{{CONCATENATION (NOT PATTERN MATCH){20357
{{IFF{2,C$UNM{6,CGV27{{UNOPS WITH NAME OPND{20357
{{IFF{2,C$BVN{6,CGV26{{BINARY $ AND .{20357
{{IFF{2,C$ASS{6,CGV21{{ASSIGNMENT{20357
{{IFF{2,C$INT{6,CGV31{{INTERROGATION{20357
{{IFF{2,C$NEG{6,CGV28{{NEGATION{20357
{{IFF{2,C$SEL{6,CGV15{{SELECTION{20357
{{IFF{2,C$PMT{6,CGV18{{PATTERN MATCH{20357
{{ESW{{{{END SWITCH ON CMBLK TYPE{20357
{{EJC{{{{{20358
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGV03{MOV{19,*CMOPN{8,WB{{SET OFFSET TO ARRAY OPERAND{20364
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGV04{JSR{6,CMGEN{{{GEN VALUE CODE FOR NEXT OPERAND{20368
{{MOV{13,CMLEN(XL){8,WC{{LOAD CMBLK LENGTH{20369
{{BLT{8,WB{8,WC{6,CGV04{LOOP BACK IF MORE TO GO{20370
*
*      GENERATE CALL TO APPROPRIATE ARRAY REFERENCE ROUTINE
*
{{MOV{21,=OAOV${8,WA{{SET ONE SUBSCRIPT CALL IN CASE{20374
{{BEQ{8,WC{19,*CMAR1{6,CGV32{JUMP TO EXIT IF 1-SUB CASE{20375
{{MOV{21,=OAMV${8,WA{{ELSE SET CALL FOR MULTI-SUBSCRIPTS{20376
{{JSR{6,CDWRD{{{GENERATE CALL{20377
{{MOV{8,WC{8,WA{{COPY LENGTH OF CMBLK{20378
{{SUB{19,*CMVLS{8,WA{{SUBTRACT STANDARD LENGTH{20379
{{BTW{8,WA{{{GET NUMBER OF WORDS{20380
{{BRN{6,CGV32{{{JUMP TO GENERATE SUBSCRIPT COUNT{20381
*
*      HERE TO GENERATE CODE FOR FUNCTION CALL
*
{CGV05{MOV{19,*CMVLS{8,WB{{SET OFFSET TO FIRST ARGUMENT{20385
*
*      LOOP TO GENERATE CODE FOR ARGUMENTS
*
{CGV06{BEQ{8,WB{13,CMLEN(XL){6,CGV07{JUMP IF ALL GENERATED{20389
{{JSR{6,CMGEN{{{ELSE GEN VALUE CODE FOR NEXT ARG{20390
{{BRN{6,CGV06{{{BACK TO GENERATE NEXT ARGUMENT{20391
*
*      HERE TO GENERATE ACTUAL FUNCTION CALL
*
{CGV07{SUB{19,*CMVLS{8,WB{{GET NUMBER OF ARG PTRS (BYTES){20395
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{20396
{{MOV{13,CMOPN(XL){7,XR{{LOAD FUNCTION VRBLK POINTER{20397
{{BNZ{13,VRLEN(XR){6,CGV12{{JUMP IF NOT SYSTEM FUNCTION{20398
{{MOV{13,VRSVP(XR){7,XL{{LOAD SVBLK PTR IF SYSTEM VAR{20399
{{MOV{13,SVBIT(XL){8,WA{{LOAD BIT MASK{20400
{{ANB{4,BTFFC{8,WA{{TEST FOR FAST FUNCTION CALL ALLOWED{20401
{{ZRB{8,WA{6,CGV12{{JUMP IF NOT{20402
{{EJC{{{{{20403
*
*      CDGVL (CONTINUED)
*
*      HERE IF FAST FUNCTION CALL IS ALLOWED
*
{{MOV{13,SVBIT(XL){8,WA{{RELOAD BIT INDICATORS{20409
{{ANB{4,BTPRE{8,WA{{TEST FOR PREEVALUATION OK{20410
{{NZB{8,WA{6,CGV08{{JUMP IF PREEVALUATION PERMITTED{20411
{{MNZ{8,WC{{{ELSE SET RESULT NON-CONSTANT{20412
*
*      TEST FOR CORRECT NUMBER OF ARGS FOR FAST CALL
*
{CGV08{MOV{13,VRFNC(XR){7,XL{{LOAD PTR TO SVFNC FIELD{20416
{{MOV{13,FARGS(XL){8,WA{{LOAD SVNAR FIELD VALUE{20417
{{BEQ{8,WA{8,WB{6,CGV11{JUMP IF ARGUMENT COUNT IS CORRECT{20418
{{BHI{8,WA{8,WB{6,CGV09{JUMP IF TOO FEW ARGUMENTS GIVEN{20419
*
*      HERE IF TOO MANY ARGUMENTS, PREPARE TO GENERATE O$POPS
*
{{SUB{8,WA{8,WB{{GET NUMBER OF EXTRA ARGS{20423
{{LCT{8,WB{8,WB{{SET AS COUNT TO CONTROL LOOP{20424
{{MOV{21,=OPOP${8,WA{{SET POP CALL{20425
{{BRN{6,CGV10{{{JUMP TO COMMON LOOP{20426
*
*      HERE IF TOO FEW ARGUMENTS, PREPARE TO GENERATE NULLS
*
{CGV09{SUB{8,WB{8,WA{{GET NUMBER OF MISSING ARGUMENTS{20430
{{LCT{8,WB{8,WA{{LOAD AS COUNT TO CONTROL LOOP{20431
{{MOV{21,=NULLS{8,WA{{LOAD PTR TO NULL CONSTANT{20432
*
*      LOOP TO GENERATE CALLS TO FIX ARGUMENT COUNT
*
{CGV10{JSR{6,CDWRD{{{GENERATE ONE CALL{20436
{{BCT{8,WB{6,CGV10{{LOOP TILL ALL GENERATED{20437
*
*      HERE AFTER ADJUSTING ARG COUNT AS REQUIRED
*
{CGV11{MOV{7,XL{8,WA{{COPY POINTER TO SVFNC FIELD{20441
{{BRN{6,CGV36{{{JUMP TO GENERATE CALL{20442
{{EJC{{{{{20443
*
*      CDGVL (CONTINUED)
*
*      COME HERE IF FAST CALL IS NOT PERMITTED
*
{CGV12{MOV{21,=OFNS${8,WA{{SET ONE ARG CALL IN CASE{20449
{{BEQ{8,WB{18,=NUM01{6,CGV13{JUMP IF ONE ARG CASE{20450
{{MOV{21,=OFNC${8,WA{{ELSE LOAD CALL FOR MORE THAN 1 ARG{20451
{{JSR{6,CDWRD{{{GENERATE IT{20452
{{MOV{8,WB{8,WA{{COPY ARGUMENT COUNT{20453
*
*      ONE ARG CASE MERGES HERE
*
{CGV13{JSR{6,CDWRD{{{GENERATE =O$FNS OR ARG COUNT{20457
{{MOV{7,XR{8,WA{{COPY VRBLK POINTER{20458
{{BRN{6,CGV32{{{JUMP TO GENERATE VRBLK PTR{20459
*
*      HERE FOR DEFERRED EXPRESSION
*
{CGV14{MOV{13,CMROP(XL){7,XL{{POINT TO EXPRESSION TREE{20463
{{ZER{8,WA{{{RETURN VALUE{20465
{{JSR{6,CDGEX{{{BUILD EXBLK OR SEBLK{20467
{{MOV{7,XR{8,WA{{COPY BLOCK PTR{20468
{{JSR{6,CDWRD{{{GENERATE PTR TO EXBLK OR SEBLK{20469
{{BRN{6,CGV34{{{JUMP TO EXIT, CONSTANT TEST{20470
*
*      HERE TO GENERATE CODE FOR SELECTION
*
{CGV15{ZER{11,-(XS){{{ZERO PTR TO CHAIN OF FORWARD JUMPS{20474
{{ZER{11,-(XS){{{ZERO PTR TO PREV O$SLC FORWARD PTR{20475
{{MOV{19,*CMVLS{8,WB{{POINT TO FIRST ALTERNATIVE{20476
{{MOV{21,=OSLA${8,WA{{SET INITIAL CODE WORD{20477
*
*      0(XS)                 IS THE OFFSET TO THE PREVIOUS WORD
*                            WHICH REQUIRES FILLING IN WITH AN
*                            OFFSET TO THE FOLLOWING O$SLC,O$SLD
*
*      1(XS)                 IS THE HEAD OF A CHAIN OF OFFSET
*                            POINTERS INDICATING THOSE LOCATIONS
*                            TO BE FILLED WITH OFFSETS PAST
*                            THE END OF ALL THE ALTERNATIVES
*
{CGV16{JSR{6,CDWRD{{{GENERATE O$SLC (O$SLA FIRST TIME){20488
{{MOV{3,CWCOF{9,(XS){{SET CURRENT LOC AS PTR TO FILL IN{20489
{{JSR{6,CDWRD{{{GENERATE GARBAGE WORD THERE FOR NOW{20490
{{JSR{6,CMGEN{{{GEN VALUE CODE FOR ALTERNATIVE{20491
{{MOV{21,=OSLB${8,WA{{LOAD O$SLB POINTER{20492
{{JSR{6,CDWRD{{{GENERATE O$SLB CALL{20493
{{MOV{13,NUM01(XS){8,WA{{LOAD OLD CHAIN PTR{20494
{{MOV{3,CWCOF{13,NUM01(XS){{SET CURRENT LOC AS NEW CHAIN HEAD{20495
{{JSR{6,CDWRD{{{GENERATE FORWARD CHAIN LINK{20496
{{EJC{{{{{20497
*
*      CDGVL (CONTINUED)
*
*      NOW TO FILL IN THE SKIP OFFSET TO O$SLC,O$SLD
*
{{MOV{9,(XS){7,XR{{LOAD OFFSET TO WORD TO PLUG{20503
{{ADD{3,R$CCB{7,XR{{POINT TO ACTUAL LOCATION TO PLUG{20504
{{MOV{3,CWCOF{9,(XR){{PLUG PROPER OFFSET IN{20505
{{MOV{21,=OSLC${8,WA{{LOAD O$SLC PTR FOR NEXT ALTERNATIVE{20506
{{MOV{8,WB{7,XR{{COPY OFFSET (DESTROY GARBAGE XR){20507
{{ICA{7,XR{{{BUMP EXTRA TIME FOR TEST{20508
{{BLT{7,XR{13,CMLEN(XL){6,CGV16{LOOP BACK IF NOT LAST ALTERNATIVE{20509
*
*      HERE TO GENERATE CODE FOR LAST ALTERNATIVE
*
{{MOV{21,=OSLD${8,WA{{GET HEADER CALL{20513
{{JSR{6,CDWRD{{{GENERATE O$SLD CALL{20514
{{JSR{6,CMGEN{{{GENERATE CODE FOR LAST ALTERNATIVE{20515
{{ICA{7,XS{{{POP OFFSET PTR{20516
{{MOV{10,(XS)+{7,XR{{LOAD CHAIN PTR{20517
*
*      LOOP TO PLUG OFFSETS PAST STRUCTURE
*
{CGV17{ADD{3,R$CCB{7,XR{{MAKE NEXT PTR ABSOLUTE{20521
{{MOV{9,(XR){8,WA{{LOAD FORWARD PTR{20522
{{MOV{3,CWCOF{9,(XR){{PLUG REQUIRED OFFSET{20523
{{MOV{8,WA{7,XR{{COPY FORWARD PTR{20524
{{BNZ{8,WA{6,CGV17{{LOOP BACK IF MORE TO GO{20525
{{BRN{6,CGV33{{{ELSE JUMP TO EXIT (NOT CONSTANT){20526
*
*      HERE FOR BINARY OPS WITH VALUE OPERANDS
*
{CGV18{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND POINTER{20530
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR LEFT OPERAND{20531
*
*      HERE FOR UNARY OPS WITH VALUE OPERAND (BINOPS MERGE)
*
{CGV19{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT (ONLY) OPERAND PTR{20535
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20536
{{EJC{{{{{20537
*
*      CDGVL (CONTINUED)
*
*      MERGE HERE TO GENERATE OPERATOR CALL FROM CMOPN FIELD
*
{CGV20{MOV{13,CMOPN(XL){8,WA{{LOAD OPERATOR CALL POINTER{20543
{{BRN{6,CGV36{{{JUMP TO GENERATE IT WITH CONS TEST{20544
*
*      HERE FOR ASSIGNMENT
*
{CGV21{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND POINTER{20548
{{BLO{9,(XR){22,=B$VR${6,CGV22{JUMP IF NOT VARIABLE{20549
*
*      HERE FOR ASSIGNMENT TO SIMPLE VARIABLE
*
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20553
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20554
{{MOV{13,CMLOP(XL){8,WA{{RELOAD LEFT OPERAND VRBLK PTR{20555
{{ADD{19,*VRSTO{8,WA{{POINT TO VRSTO FIELD{20556
{{BRN{6,CGV32{{{JUMP TO GENERATE STORE PTR{20557
*
*      HERE IF NOT SIMPLE VARIABLE ASSIGNMENT
*
{CGV22{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH ON LEFT SIDE{20561
{{PPM{6,CGV23{{{JUMP IF NOT PATTERN MATCH{20562
*
*      HERE FOR PATTERN REPLACEMENT
*
{{MOV{13,CMROP(XR){13,CMLOP(XL){{SAVE PATTERN PTR IN SAFE PLACE{20566
{{MOV{13,CMLOP(XR){7,XR{{LOAD SUBJECT PTR{20567
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR SUBJECT{20568
{{MOV{13,CMLOP(XL){7,XR{{LOAD PATTERN PTR{20569
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR PATTERN{20570
{{MOV{21,=OPMN${8,WA{{LOAD MATCH BY NAME CALL{20571
{{JSR{6,CDWRD{{{GENERATE IT{20572
{{MOV{13,CMROP(XL){7,XR{{LOAD REPLACEMENT VALUE PTR{20573
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20574
{{MOV{21,=ORPL${8,WA{{LOAD REPLACE CALL{20575
{{BRN{6,CGV32{{{JUMP TO GEN AND EXIT (NOT CONSTANT){20576
*
*      HERE FOR ASSIGNMENT TO COMPLEX VARIABLE
*
{CGV23{MNZ{8,WC{{{INHIBIT PRE-EVALUATION{20580
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR LEFT SIDE{20581
{{BRN{6,CGV31{{{MERGE WITH UNOP CIRCUIT{20582
{{EJC{{{{{20583
*
*      CDGVL (CONTINUED)
*
*      HERE FOR CONCATENATION
*
{CGV24{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND PTR{20589
{{BNE{9,(XR){22,=B$CMT{6,CGV18{ORDINARY BINOP IF NOT CMBLK{20590
{{MOV{13,CMTYP(XR){8,WB{{LOAD CMBLK TYPE CODE{20591
{{BEQ{8,WB{18,=C$INT{6,CGV25{SPECIAL CASE IF INTERROGATION{20592
{{BEQ{8,WB{18,=C$NEG{6,CGV25{OR NEGATION{20593
{{BNE{8,WB{18,=C$FNC{6,CGV18{ELSE ORDINARY BINOP IF NOT FUNCTION{20594
{{MOV{13,CMOPN(XR){7,XR{{ELSE LOAD FUNCTION VRBLK PTR{20595
{{BNZ{13,VRLEN(XR){6,CGV18{{ORDINARY BINOP IF NOT SYSTEM VAR{20596
{{MOV{13,VRSVP(XR){7,XR{{ELSE POINT TO SVBLK{20597
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT INDICATORS{20598
{{ANB{4,BTPRD{8,WA{{TEST FOR PREDICATE FUNCTION{20599
{{ZRB{8,WA{6,CGV18{{ORDINARY BINOP IF NOT{20600
*
*      HERE IF LEFT ARG OF CONCATENATION IS PREDICATE FUNCTION
*
{CGV25{MOV{13,CMLOP(XL){7,XR{{RELOAD LEFT ARG{20604
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20605
{{MOV{21,=OPOP${8,WA{{LOAD POP CALL{20606
{{JSR{6,CDWRD{{{GENERATE IT{20607
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND{20608
{{JSR{6,CDGVL{{{GEN CODE BY VALUE AS RESULT CODE{20609
{{BRN{6,CGV33{{{EXIT (NOT CONSTANT){20610
*
*      HERE TO GENERATE CODE FOR PATTERN, IMMEDIATE ASSIGNMENT
*
{CGV26{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND{20614
{{JSR{6,CDGVL{{{GEN CODE BY VALUE, MERGE{20615
*
*      HERE FOR UNOPS WITH ARG BY NAME (BINARY $ . MERGE)
*
{CGV27{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20619
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR RIGHT ARG{20620
{{MOV{13,CMOPN(XL){7,XR{{GET OPERATOR CODE WORD{20621
{{BNE{9,(XR){22,=O$KWV{6,CGV20{GEN CALL UNLESS KEYWORD VALUE{20622
{{EJC{{{{{20623
*
*      CDGVL (CONTINUED)
*
*      HERE FOR KEYWORD BY VALUE. THIS IS CONSTANT ONLY IF
*      THE OPERAND IS ONE OF THE SPECIAL SYSTEM VARIABLES WITH
*      THE SVCKW BIT SET TO INDICATE A CONSTANT KEYWORD VALUE.
*      NOTE THAT THE ONLY CONSTANT OPERAND BY NAME IS A VARIABLE
*
{{BNZ{8,WC{6,CGV20{{GEN CALL IF NON-CONSTANT (NOT VAR){20632
{{MNZ{8,WC{{{ELSE SET NON-CONSTANT IN CASE{20633
{{MOV{13,CMROP(XL){7,XR{{LOAD PTR TO OPERAND VRBLK{20634
{{BNZ{13,VRLEN(XR){6,CGV20{{GEN (NON-CONSTANT) IF NOT SYS VAR{20635
{{MOV{13,VRSVP(XR){7,XR{{ELSE LOAD PTR TO SVBLK{20636
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT MASK{20637
{{ANB{4,BTCKW{8,WA{{TEST FOR CONSTANT KEYWORD{20638
{{ZRB{8,WA{6,CGV20{{GO GEN IF NOT CONSTANT{20639
{{ZER{8,WC{{{ELSE SET RESULT CONSTANT{20640
{{BRN{6,CGV20{{{AND JUMP BACK TO GENERATE CALL{20641
*
*      HERE TO GENERATE CODE FOR NEGATION
*
{CGV28{MOV{21,=ONTA${8,WA{{GET INITIAL WORD{20645
{{JSR{6,CDWRD{{{GENERATE IT{20646
{{MOV{3,CWCOF{8,WB{{SAVE NEXT OFFSET{20647
{{JSR{6,CDWRD{{{GENERATE GUNK WORD FOR NOW{20648
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20649
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20650
{{MOV{21,=ONTB${8,WA{{LOAD END OF EVALUATION CALL{20651
{{JSR{6,CDWRD{{{GENERATE IT{20652
{{MOV{8,WB{7,XR{{COPY OFFSET TO WORD TO PLUG{20653
{{ADD{3,R$CCB{7,XR{{POINT TO ACTUAL WORD TO PLUG{20654
{{MOV{3,CWCOF{9,(XR){{PLUG WORD WITH CURRENT OFFSET{20655
{{MOV{21,=ONTC${8,WA{{LOAD FINAL CALL{20656
{{BRN{6,CGV32{{{JUMP TO GENERATE IT (NOT CONSTANT){20657
*
*      HERE TO GENERATE CODE FOR UNDEFINED BINARY OPERATOR
*
{CGV29{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND PTR{20661
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20662
{{EJC{{{{{20663
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR UNDEFINED UNARY OPERATOR
*
{CGV30{MOV{18,=C$UO${8,WB{{SET UNOP CODE + 1{20669
{{SUB{13,CMTYP(XL){8,WB{{SET NUMBER OF ARGS (1 OR 2){20670
*
*      MERGE HERE FOR UNDEFINED OPERATORS
*
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT (ONLY) OPERAND POINTER{20674
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR RIGHT OPERAND{20675
{{MOV{13,CMOPN(XL){7,XR{{LOAD POINTER TO OPERATOR DV{20676
{{MOV{13,DVOPN(XR){7,XR{{LOAD POINTER OFFSET{20677
{{WTB{7,XR{{{CONVERT WORD OFFSET TO BYTES{20678
{{ADD{20,=R$UBA{7,XR{{POINT TO PROPER FUNCTION PTR{20679
{{SUB{19,*VRFNC{7,XR{{SET STANDARD FUNCTION OFFSET{20680
{{BRN{6,CGV12{{{MERGE WITH FUNCTION CALL CIRCUIT{20681
*
*      HERE TO GENERATE CODE FOR INTERROGATION, INDIRECTION
*
{CGV31{MNZ{8,WC{{{SET NON CONSTANT{20685
{{BRN{6,CGV19{{{MERGE{20686
*
*      HERE TO EXIT GENERATING A WORD, RESULT NOT CONSTANT
*
{CGV32{JSR{6,CDWRD{{{GENERATE WORD, MERGE{20690
*
*      HERE TO EXIT WITH NO WORD GENERATED, NOT CONSTANT
*
{CGV33{MNZ{8,WC{{{INDICATE RESULT IS NOT CONSTANT{20694
*
*      COMMON EXIT POINT
*
{CGV34{ICA{7,XS{{{POP INITIAL CODE OFFSET{20698
{{MOV{10,(XS)+{8,WA{{RESTORE OLD CONSTANT FLAG{20699
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{20700
{{MOV{10,(XS)+{8,WB{{RESTORE ENTRY WB{20701
{{BNZ{8,WC{6,CGV35{{JUMP IF NOT CONSTANT{20702
{{MOV{8,WA{8,WC{{ELSE RESTORE ENTRY CONSTANT FLAG{20703
*
*      HERE TO RETURN AFTER DEALING WITH WC SETTING
*
{CGV35{EXI{{{{RETURN TO CDGVL CALLER{20707
*
*      EXIT HERE TO GENERATE WORD AND TEST FOR CONSTANT
*
{CGV36{JSR{6,CDWRD{{{GENERATE WORD{20711
{{BNZ{8,WC{6,CGV34{{JUMP TO EXIT IF NOT CONSTANT{20712
{{EJC{{{{{20713
*
*      CDGVL (CONTINUED)
*
*      HERE TO PREEVALUATE CONSTANT SUB-EXPRESSION
*
{{MOV{21,=ORVL${8,WA{{LOAD CALL TO RETURN VALUE{20719
{{JSR{6,CDWRD{{{GENERATE IT{20720
{{MOV{9,(XS){7,XL{{LOAD INITIAL CODE OFFSET{20721
{{JSR{6,EXBLD{{{BUILD EXBLK FOR EXPRESSION{20722
{{ZER{8,WB{{{SET TO EVALUATE BY VALUE{20723
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{20724
{{PPM{{{{SHOULD NOT FAIL{20725
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD OF RESULT{20726
{{BLO{8,WA{22,=P$AAA{6,CGV37{JUMP IF NOT PATTERN{20727
{{MOV{21,=OLPT${8,WA{{ELSE LOAD SPECIAL PATTERN LOAD CALL{20728
{{JSR{6,CDWRD{{{GENERATE IT{20729
*
*      MERGE HERE TO GENERATE POINTER TO RESULTING CONSTANT
*
{CGV37{MOV{7,XR{8,WA{{COPY CONSTANT POINTER{20733
{{JSR{6,CDWRD{{{GENERATE PTR{20734
{{ZER{8,WC{{{SET RESULT CONSTANT{20735
{{BRN{6,CGV34{{{JUMP BACK TO EXIT{20736
{{ENP{{{{END PROCEDURE CDGVL{20737
{{EJC{{{{{20738
*
*      CDWRD -- GENERATE ONE WORD OF CODE
*
*      CDWRD WRITES ONE WORD INTO THE CURRENT CODE BLOCK UNDER
*      CONSTRUCTION. A NEW, LARGER, BLOCK IS ALLOCATED IF THERE
*      IS INSUFFICIENT ROOM IN THE CURRENT BLOCK. CDWRD ENSURES
*      THAT THERE ARE AT LEAST FOUR WORDS LEFT IN THE BLOCK
*      AFTER ENTERING THE NEW WORD. THIS GUARANTEES THAT ANY
*      EXTRA SPACE AT THE END CAN BE SPLIT OFF AS A CCBLK.
*
*      (WA)                  WORD TO BE GENERATED
*      JSR  CDWRD            CALL TO GENERATE WORD
*
{CDWRD{PRC{25,E{1,0{{ENTRY POINT{20756
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{20757
{{MOV{8,WA{11,-(XS){{SAVE CODE WORD TO BE GENERATED{20758
*
*      MERGE BACK HERE AFTER ALLOCATING LARGER BLOCK
*
{CDWD1{MOV{3,R$CCB{7,XR{{LOAD PTR TO CCBLK BEING BUILT{20762
{{BNZ{7,XR{6,CDWD2{{JUMP IF BLOCK ALLOCATED{20763
*
*      HERE WE ALLOCATE AN ENTIRELY FRESH BLOCK
*
{{MOV{19,*E$CBS{8,WA{{LOAD INITIAL LENGTH{20767
{{JSR{6,ALLOC{{{ALLOCATE CCBLK{20768
{{MOV{22,=B$CCT{9,(XR){{STORE TYPE WORD{20769
{{MOV{19,*CCCOD{3,CWCOF{{SET INITIAL OFFSET{20770
{{MOV{8,WA{13,CCLEN(XR){{STORE BLOCK LENGTH{20771
{{ZER{13,CCSLN(XR){{{ZERO LINE NUMBER{20773
{{MOV{7,XR{3,R$CCB{{STORE PTR TO NEW BLOCK{20775
*
*      HERE WE HAVE A BLOCK WE CAN USE
*
{CDWD2{MOV{3,CWCOF{8,WA{{LOAD CURRENT OFFSET{20779
{{ADD{19,*NUM05{8,WA{{ADJUST FOR TEST (FIVE WORDS){20781
{{BLO{8,WA{13,CCLEN(XR){6,CDWD4{JUMP IF ROOM IN THIS BLOCK{20785
*
*      HERE IF NO ROOM IN CURRENT BLOCK
*
{{BGE{8,WA{3,MXLEN{6,CDWD5{JUMP IF ALREADY AT MAX SIZE{20789
{{ADD{19,*E$CBS{8,WA{{ELSE GET NEW SIZE{20790
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20791
{{MOV{7,XR{7,XL{{COPY POINTER{20792
{{BLT{8,WA{3,MXLEN{6,CDWD3{JUMP IF NOT TOO LARGE{20793
{{MOV{3,MXLEN{8,WA{{ELSE RESET TO MAX ALLOWED SIZE{20794
{{EJC{{{{{20795
*
*      CDWRD (CONTINUED)
*
*      HERE WITH NEW BLOCK SIZE IN WA
*
{CDWD3{JSR{6,ALLOC{{{ALLOCATE NEW BLOCK{20801
{{MOV{7,XR{3,R$CCB{{STORE POINTER TO NEW BLOCK{20802
{{MOV{22,=B$CCT{10,(XR)+{{STORE TYPE WORD IN NEW BLOCK{20803
{{MOV{8,WA{10,(XR)+{{STORE BLOCK LENGTH{20804
{{MOV{13,CCSLN(XL){10,(XR)+{{COPY SOURCE LINE NUMBER WORD{20806
{{ADD{19,*CCUSE{7,XL{{POINT TO CCUSE,CCCOD FIELDS IN OLD{20808
{{MOV{9,(XL){8,WA{{LOAD CCUSE VALUE{20809
{{MVW{{{{COPY USEFUL WORDS FROM OLD BLOCK{20810
{{MOV{10,(XS)+{7,XL{{RESTORE XL{20811
{{BRN{6,CDWD1{{{MERGE BACK TO TRY AGAIN{20812
*
*      HERE WITH ROOM IN CURRENT BLOCK
*
{CDWD4{MOV{3,CWCOF{8,WA{{LOAD CURRENT OFFSET{20816
{{ICA{8,WA{{{GET NEW OFFSET{20817
{{MOV{8,WA{3,CWCOF{{STORE NEW OFFSET{20818
{{MOV{8,WA{13,CCUSE(XR){{STORE IN CCBLK FOR GBCOL{20819
{{DCA{8,WA{{{RESTORE PTR TO THIS WORD{20820
{{ADD{8,WA{7,XR{{POINT TO CURRENT ENTRY{20821
{{MOV{10,(XS)+{8,WA{{RELOAD WORD TO GENERATE{20822
{{MOV{8,WA{9,(XR){{STORE WORD IN BLOCK{20823
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{20824
{{EXI{{{{RETURN TO CALLER{20825
*
*      HERE IF COMPILED CODE IS TOO LONG FOR CDBLK
*
{CDWD5{ERB{1,213{26,Syntax error: Statement is too complicated.{{{20829
{{ENP{{{{END PROCEDURE CDWRD{20830
{{EJC{{{{{20831
*
*      CMGEN -- GENERATE CODE FOR CMBLK PTR
*
*      CMGEN IS A SUBSIDIARY PROCEDURE USED TO GENERATE VALUE
*      CODE FOR A CMBLK PTR FROM THE MAIN CODE GENERATORS.
*
*      (XL)                  CMBLK POINTER
*      (WB)                  OFFSET TO POINTER IN CMBLK
*      JSR  CMGEN            CALL TO GENERATE CODE
*      (XR,WA)               DESTROYED
*      (WB)                  BUMPED BY ONE WORD
*
{CMGEN{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20844
{{MOV{7,XL{7,XR{{COPY CMBLK POINTER{20845
{{ADD{8,WB{7,XR{{POINT TO CMBLK POINTER{20846
{{MOV{9,(XR){7,XR{{LOAD CMBLK POINTER{20847
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20848
{{ICA{8,WB{{{BUMP OFFSET{20849
{{EXI{{{{RETURN TO CALLER{20850
{{ENP{{{{END PROCEDURE CMGEN{20851
{{EJC{{{{{20852
*
*      CMPIL (COMPILE SOURCE CODE)
*
*      CMPIL IS USED TO CONVERT SNOBOL4 SOURCE CODE TO INTERNAL
*      FORM (SEE CDBLK FORMAT). IT IS USED BOTH FOR THE INITIAL
*      COMPILE AND AT RUN TIME BY THE CODE AND CONVERT FUNCTIONS
*      THIS PROCEDURE HAS CONTROL FOR THE ENTIRE DURATION OF
*      INITIAL COMPILATION. AN ERROR IN ANY PROCEDURE CALLED
*      DURING COMPILATION WILL LEAD FIRST TO THE ERROR SECTION
*      AND ULTIMATELY BACK HERE FOR RESUMED COMPILATION. THE
*      RE-ENTRY POINTS AFTER AN ERROR ARE SPECIALLY LABELLED -
*
*      CMPCE                 RESUME AFTER CONTROL CARD ERROR
*      CMPLE                 RESUME AFTER LABEL ERROR
*      CMPSE                 RESUME AFTER STATEMENT ERROR
*
*      JSR  CMPIL            CALL TO COMPILE CODE
*      (XR)                  PTR TO CDBLK FOR ENTRY STATEMENT
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE FOLLOWING GLOBAL VARIABLES ARE REFERENCED
*
*      CMPLN                 LINE NUMBER OF FIRST LINE OF
*                            STATEMENT TO BE COMPILED
*
*      CMPSN                 NUMBER OF NEXT STATEMENT
*                            TO BE COMPILED.
*
*      CSWXX                 CONTROL CARD SWITCH VALUES ARE
*                            CHANGED WHEN RELEVANT CONTROL
*                            CARDS ARE MET.
*
*      CWCOF                 OFFSET TO NEXT WORD IN CODE BLOCK
*                            BEING BUILT (SEE CDWRD).
*
*      LSTSN                 NUMBER OF STATEMENT MOST RECENTLY
*                            COMPILED (INITIALLY SET TO ZERO).
*
*      R$CIM                 CURRENT (INITIAL) COMPILER IMAGE
*                            (ZERO FOR INITIAL COMPILE CALL)
*
*      R$CNI                 USED TO POINT TO FOLLOWING IMAGE.
*                            (SEE READR PROCEDURE).
*
*      SCNGO                 GOTO SWITCH FOR SCANE PROCEDURE
*
*      SCNIL                 LENGTH OF CURRENT IMAGE EXCLUDING
*                            CHARACTERS REMOVED BY -INPUT.
*
*      SCNPT                 CURRENT SCAN OFFSET, SEE SCANE.
*
*      SCNRS                 RESCAN SWITCH FOR SCANE PROCEDURE.
*
*      SCNSE                 OFFSET (IN R$CIM) OF MOST RECENTLY
*                            SCANNED ELEMENT. SET ZERO IF NOT
*                            CURRENTLY SCANNING ITEMS
{{EJC{{{{{20909
*
*      CMPIL (CONTINUED)
*
*      STAGE               STGIC  INITIAL COMPILE IN PROGRESS
*                          STGXC  CODE/CONVERT COMPILE
*                          STGEV  BUILDING EXBLK FOR EVAL
*                          STGXT  EXECUTE TIME (OUTSIDE COMPILE)
*                          STGCE  INITIAL COMPILE AFTER END LINE
*                          STGXE  EXECUTE COMPILE AFTER END LINE
*
*      CMPIL ALSO USES A FIXED NUMBER OF LOCATIONS ON THE
*      MAIN STACK AS FOLLOWS. (THE DEFINITIONS OF THE ACTUAL
*      OFFSETS ARE IN THE DEFINITIONS SECTION).
*
*      CMSTM(XS)             POINTER TO EXPAN TREE FOR BODY OF
*                            STATEMENT (SEE EXPAN PROCEDURE).
*
*      CMSGO(XS)             POINTER TO TREE REPRESENTATION OF
*                            SUCCESS GOTO (SEE PROCEDURE SCNGO)
*                            ZERO IF NO SUCCESS GOTO IS GIVEN
*
*      CMFGO(XS)             LIKE CMSGO FOR FAILURE GOTO.
*
*      CMCGO(XS)             SET NON-ZERO ONLY IF THERE IS A
*                            CONDITIONAL GOTO. USED FOR -FAIL,
*                            -NOFAIL CODE GENERATION.
*
*      CMPCD(XS)             POINTER TO CDBLK FOR PREVIOUS
*                            STATEMENT. ZERO FOR 1ST STATEMENT.
*
*      CMFFP(XS)             SET NON-ZERO IF CDFAL IN PREVIOUS
*                            CDBLK NEEDS FILLING WITH FORWARD
*                            POINTER, ELSE SET TO ZERO.
*
*      CMFFC(XS)             SAME AS CMFFP FOR CURRENT CDBLK
*
*      CMSOP(XS)             OFFSET TO WORD IN PREVIOUS CDBLK
*                            TO BE FILLED IN WITH FORWARD PTR
*                            TO NEXT CDBLK FOR SUCCESS GOTO.
*                            ZERO IF NO FILL IN IS REQUIRED.
*
*      CMSOC(XS)             SAME AS CMSOP FOR CURRENT CDBLK.
*
*      CMLBL(XS)             POINTER TO VRBLK FOR LABEL OF
*                            CURRENT STATEMENT. ZERO IF NO LABEL
*
*      CMTRA(XS)             POINTER TO CDBLK FOR ENTRY STMNT.
{{EJC{{{{{20957
*
*      CMPIL (CONTINUED)
*
*      ENTRY POINT
*
{CMPIL{PRC{25,E{1,0{{ENTRY POINT{20963
{{LCT{8,WB{18,=CMNEN{{SET NUMBER OF STACK WORK LOCATIONS{20964
*
*      LOOP TO INITIALIZE STACK WORKING LOCATIONS
*
{CMP00{ZER{11,-(XS){{{STORE A ZERO, MAKE ONE ENTRY{20968
{{BCT{8,WB{6,CMP00{{LOOP BACK UNTIL ALL SET{20969
{{MOV{7,XS{3,CMPXS{{SAVE STACK POINTER FOR ERROR SEC{20970
{{SSS{3,CMPSS{{{SAVE S-R STACK POINTER IF ANY{20971
*
*      LOOP THROUGH STATEMENTS
*
{CMP01{MOV{3,SCNPT{8,WB{{SET SCAN POINTER OFFSET{20975
{{MOV{8,WB{3,SCNSE{{SET START OF ELEMENT LOCATION{20976
{{MOV{21,=OCER${8,WA{{POINT TO COMPILE ERROR CALL{20977
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY CDFAL{20978
{{BLT{8,WB{3,SCNIL{6,CMP04{JUMP IF CHARS LEFT ON THIS IMAGE{20979
*
*      LOOP HERE AFTER COMMENT OR CONTROL CARD
*      ALSO SPECIAL ENTRY AFTER CONTROL CARD ERROR
*
{CMPCE{ZER{7,XR{{{CLEAR POSSIBLE GARBAGE XR VALUE{20984
{{BNZ{3,CNIND{6,CMPC2{{IF WITHIN INCLUDE FILE{20986
{{BNE{3,STAGE{18,=STGIC{6,CMP02{SKIP UNLESS INITIAL COMPILE{20988
{CMPC2{JSR{6,READR{{{READ NEXT INPUT IMAGE{20989
{{BZE{7,XR{6,CMP09{{JUMP IF NO INPUT AVAILABLE{20990
{{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{20991
{{MOV{3,CMPSN{3,LSTSN{{STORE STMT NO FOR USE BY LISTR{20992
{{MOV{3,RDCLN{3,CMPLN{{STORE LINE NUMBER AT START OF STMT{20993
{{ZER{3,SCNPT{{{RESET SCAN POINTER{20994
{{BRN{6,CMP04{{{GO PROCESS IMAGE{20995
*
*      FOR EXECUTE TIME COMPILE, PERMIT EMBEDDED CONTROL CARDS
*      AND COMMENTS (BY SKIPPING TO NEXT SEMI-COLON)
*
{CMP02{MOV{3,R$CIM{7,XR{{GET CURRENT IMAGE{21000
{{MOV{3,SCNPT{8,WB{{GET CURRENT OFFSET{21001
{{PLC{7,XR{8,WB{{PREPARE TO GET CHARS{21002
*
*      SKIP TO SEMI-COLON
*
{CMP03{BGE{3,SCNPT{3,SCNIL{6,CMP09{END LOOP IF END OF IMAGE{21006
{{LCH{8,WC{10,(XR)+{{GET CHAR{21007
{{ICV{3,SCNPT{{{ADVANCE OFFSET{21008
{{BNE{8,WC{18,=CH$SM{6,CMP03{LOOP IF NOT SEMI-COLON{21009
{{EJC{{{{{21010
*
*      CMPIL (CONTINUED)
*
*      HERE WITH IMAGE AVAILABLE TO SCAN. NOTE THAT IF THE INPUT
*      STRING IS NULL, THEN EVERYTHING IS OK SINCE NULL IS
*      ACTUALLY ASSEMBLED AS A WORD OF BLANKS.
*
{CMP04{MOV{3,R$CIM{7,XR{{POINT TO CURRENT IMAGE{21018
{{MOV{3,SCNPT{8,WB{{LOAD CURRENT OFFSET{21019
{{MOV{8,WB{8,WA{{COPY FOR LABEL SCAN{21020
{{PLC{7,XR{8,WB{{POINT TO FIRST CHARACTER{21021
{{LCH{8,WC{10,(XR)+{{LOAD FIRST CHARACTER{21022
{{BEQ{8,WC{18,=CH$SM{6,CMP12{NO LABEL IF SEMICOLON{21023
{{BEQ{8,WC{18,=CH$AS{6,CMPCE{LOOP BACK IF COMMENT CARD{21024
{{BEQ{8,WC{18,=CH$MN{6,CMP32{JUMP IF CONTROL CARD{21025
{{MOV{3,R$CIM{3,R$CMP{{ABOUT TO DESTROY R$CIM{21026
{{MOV{20,=CMLAB{7,XL{{POINT TO LABEL WORK STRING{21027
{{MOV{7,XL{3,R$CIM{{SCANE IS TO SCAN WORK STRING{21028
{{PSC{7,XL{{{POINT TO FIRST CHARACTER POSITION{21029
{{SCH{8,WC{10,(XL)+{{STORE CHAR JUST LOADED{21030
{{MOV{18,=CH$SM{8,WC{{GET A SEMICOLON{21031
{{SCH{8,WC{9,(XL){{STORE AFTER FIRST CHAR{21032
{{CSC{7,XL{{{FINISHED CHARACTER STORING{21033
{{ZER{7,XL{{{CLEAR POINTER{21034
{{ZER{3,SCNPT{{{START AT FIRST CHARACTER{21035
{{MOV{3,SCNIL{11,-(XS){{PRESERVE IMAGE LENGTH{21036
{{MOV{18,=NUM02{3,SCNIL{{READ 2 CHARS AT MOST{21037
{{JSR{6,SCANE{{{SCAN FIRST CHAR FOR TYPE{21038
{{MOV{10,(XS)+{3,SCNIL{{RESTORE IMAGE LENGTH{21039
{{MOV{7,XL{8,WC{{NOTE RETURN CODE{21040
{{MOV{3,R$CMP{7,XL{{GET OLD R$CIM{21041
{{MOV{7,XL{3,R$CIM{{PUT IT BACK{21042
{{MOV{8,WB{3,SCNPT{{REINSTATE OFFSET{21043
{{BNZ{3,SCNBL{6,CMP12{{BLANK SEEN - CANT BE LABEL{21044
{{MOV{7,XL{7,XR{{POINT TO CURRENT IMAGE{21045
{{PLC{7,XR{8,WB{{POINT TO FIRST CHAR AGAIN{21046
{{BEQ{8,WC{18,=T$VAR{6,CMP06{OK IF LETTER{21047
{{BEQ{8,WC{18,=T$CON{6,CMP06{OK IF DIGIT{21048
*
*      DROP IN OR JUMP FROM ERROR SECTION IF SCANE FAILED
*
{CMPLE{MOV{3,R$CMP{3,R$CIM{{POINT TO BAD LINE{21052
{{ERB{1,214{26,Bad label or misplaced continuation line{{{21053
*
*      LOOP TO SCAN LABEL
*
{CMP05{BEQ{8,WC{18,=CH$SM{6,CMP07{SKIP IF SEMICOLON{21057
{{ICV{8,WA{{{BUMP OFFSET{21058
{{BEQ{8,WA{3,SCNIL{6,CMP07{JUMP IF END OF IMAGE (LABEL END){21059
{{EJC{{{{{21060
*
*      CMPIL (CONTINUED)
*
*      ENTER LOOP AT THIS POINT
*
{CMP06{LCH{8,WC{10,(XR)+{{ELSE LOAD NEXT CHARACTER{21066
{{BEQ{8,WC{18,=CH$HT{6,CMP07{JUMP IF HORIZONTAL TAB{21068
{{BNE{8,WC{18,=CH$BL{6,CMP05{LOOP BACK IF NON-BLANK{21073
*
*      HERE AFTER SCANNING OUT LABEL
*
{CMP07{MOV{8,WA{3,SCNPT{{SAVE UPDATED SCAN OFFSET{21077
{{SUB{8,WB{8,WA{{GET LENGTH OF LABEL{21078
{{BZE{8,WA{6,CMP12{{SKIP IF LABEL LENGTH ZERO{21079
{{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{21080
{{JSR{6,SBSTR{{{BUILD SCBLK FOR LABEL NAME{21081
{{JSR{6,GTNVR{{{LOCATE/CONTRUCT VRBLK{21082
{{PPM{{{{DUMMY (IMPOSSIBLE) ERROR RETURN{21083
{{MOV{7,XR{13,CMLBL(XS){{STORE LABEL POINTER{21084
{{BNZ{13,VRLEN(XR){6,CMP11{{JUMP IF NOT SYSTEM LABEL{21085
{{BNE{13,VRSVP(XR){21,=V$END{6,CMP11{JUMP IF NOT END LABEL{21086
*
*      HERE FOR END LABEL SCANNED OUT
*
{{ADD{18,=STGND{3,STAGE{{ADJUST STAGE APPROPRIATELY{21090
{{JSR{6,SCANE{{{SCAN OUT NEXT ELEMENT{21091
{{BEQ{7,XL{18,=T$SMC{6,CMP10{JUMP IF END OF IMAGE{21092
{{BNE{7,XL{18,=T$VAR{6,CMP08{ELSE ERROR IF NOT VARIABLE{21093
*
*      HERE CHECK FOR VALID INITIAL TRANSFER
*
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP08{JUMP IF NOT DEFINED (ERROR){21097
{{MOV{13,VRLBL(XR){13,CMTRA(XS){{ELSE SET INITIAL ENTRY POINTER{21098
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21099
{{BEQ{7,XL{18,=T$SMC{6,CMP10{JUMP IF OK (END OF IMAGE){21100
*
*      HERE FOR BAD TRANSFER LABEL
*
{CMP08{ERB{1,215{26,Syntax error: Undefined or erroneous entry label{{{21104
*
*      HERE FOR END OF INPUT (NO END LABEL DETECTED)
*
{CMP09{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{21108
{{ADD{18,=STGND{3,STAGE{{ADJUST STAGE APPROPRIATELY{21109
{{BEQ{3,STAGE{18,=STGXE{6,CMP10{JUMP IF CODE CALL (OK){21110
{{ERB{1,216{26,Syntax error: Missing END line{{{21111
*
*      HERE AFTER PROCESSING END LINE (MERGE HERE ON END ERROR)
*
{CMP10{MOV{21,=OSTP${8,WA{{SET STOP CALL POINTER{21115
{{JSR{6,CDWRD{{{GENERATE AS STATEMENT CALL{21116
{{BRN{6,CMPSE{{{JUMP TO GENERATE AS FAILURE{21117
{{EJC{{{{{21118
*
*      CMPIL (CONTINUED)
*
*      HERE AFTER PROCESSING LABEL OTHER THAN END
*
{CMP11{BNE{3,STAGE{18,=STGIC{6,CMP12{JUMP IF CODE CALL - REDEF. OK{21124
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP12{ELSE CHECK FOR REDEFINITION{21125
{{ZER{13,CMLBL(XS){{{LEAVE FIRST LABEL DECLN UNDISTURBED{21126
{{ERB{1,217{26,Syntax error: Duplicate label{{{21127
*
*      HERE AFTER DEALING WITH LABEL
*      NULL STATEMENTS AND STATEMENTS JUST CONTAINING A
*      CONSTANT SUBJECT ARE OPTIMIZED OUT BY RESETTING THE
*      CURRENT CCBLK TO EMPTY.
*
{CMP12{ZER{8,WB{{{SET FLAG FOR STATEMENT BODY{21134
{{JSR{6,EXPAN{{{GET TREE FOR STATEMENT BODY{21135
{{MOV{7,XR{13,CMSTM(XS){{STORE FOR LATER USE{21136
{{ZER{13,CMSGO(XS){{{CLEAR SUCCESS GOTO POINTER{21137
{{ZER{13,CMFGO(XS){{{CLEAR FAILURE GOTO POINTER{21138
{{ZER{13,CMCGO(XS){{{CLEAR CONDITIONAL GOTO FLAG{21139
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21140
{{BEQ{7,XL{18,=T$COL{6,CMP13{JUMP IF COLON (GOTO){21141
{{BNZ{3,CSWNO{6,CMP18{{JUMP IF NOT OPTIMIZING{21142
{{BNZ{13,CMLBL(XS){6,CMP18{{JUMP IF LABEL PRESENT{21143
{{MOV{13,CMSTM(XS){7,XR{{LOAD TREE PTR FOR STATEMENT BODY{21144
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{21145
{{BEQ{8,WA{22,=B$CMT{6,CMP18{JUMP IF CMBLK{21146
{{BGE{8,WA{22,=B$VRA{6,CMP18{JUMP IF NOT ICBLK, SCBLK, OR RCBLK{21147
{{MOV{3,R$CCB{7,XL{{LOAD PTR TO CCBLK{21148
{{MOV{19,*CCCOD{13,CCUSE(XL){{RESET USE OFFSET IN CCBLK{21149
{{MOV{19,*CCCOD{3,CWCOF{{AND IN GLOBAL{21150
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{21151
{{BRN{6,CMP01{{{GENERATE NO CODE FOR STATEMENT{21152
*
*      LOOP TO PROCESS GOTO FIELDS
*
{CMP13{MNZ{3,SCNGO{{{SET GOTO FLAG{21156
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21157
{{BEQ{7,XL{18,=T$SMC{6,CMP31{JUMP IF NO FIELDS LEFT{21158
{{BEQ{7,XL{18,=T$SGO{6,CMP14{JUMP IF S FOR SUCCESS GOTO{21159
{{BEQ{7,XL{18,=T$FGO{6,CMP16{JUMP IF F FOR FAILURE GOTO{21160
*
*      HERE FOR UNCONDITIONAL GOTO (I.E. NOT F OR S)
*
{{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT NOT F,S{21164
{{JSR{6,SCNGF{{{SCAN OUT GOTO FIELD{21165
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY{21166
{{MOV{7,XR{13,CMFGO(XS){{ELSE SET AS FGOTO{21167
{{BRN{6,CMP15{{{MERGE WITH SGOTO CIRCUIT{21168
*
*      HERE FOR SUCCESS GOTO
*
{CMP14{JSR{6,SCNGF{{{SCAN SUCCESS GOTO FIELD{21172
{{MOV{18,=NUM01{13,CMCGO(XS){{SET CONDITIONAL GOTO FLAG{21173
*
*      UNCONTIONAL GOTO MERGES HERE
*
{CMP15{BNZ{13,CMSGO(XS){6,CMP17{{ERROR IF SGOTO ALREADY GIVEN{21177
{{MOV{7,XR{13,CMSGO(XS){{ELSE SET SGOTO{21178
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT GOTO FIELD{21179
*
*      HERE FOR FAILURE GOTO
*
{CMP16{JSR{6,SCNGF{{{SCAN GOTO FIELD{21183
{{MOV{18,=NUM01{13,CMCGO(XS){{SET CONDITONAL GOTO FLAG{21184
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY GIVEN{21185
{{MOV{7,XR{13,CMFGO(XS){{ELSE STORE FGOTO POINTER{21186
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT FIELD{21187
{{EJC{{{{{21188
*
*      CMPIL (CONTINUED)
*
*      HERE FOR DUPLICATED GOTO FIELD
*
{CMP17{ERB{1,218{26,Syntax error: Duplicated goto field{{{21194
*
*      HERE TO GENERATE CODE
*
{CMP18{ZER{3,SCNSE{{{STOP POSITIONAL ERROR FLAGS{21198
{{MOV{13,CMSTM(XS){7,XR{{LOAD TREE PTR FOR STATEMENT BODY{21199
{{ZER{8,WB{{{COLLECTABLE VALUE FOR WB FOR CDGVL{21200
{{ZER{8,WC{{{RESET CONSTANT FLAG FOR CDGVL{21201
{{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH{21202
{{PPM{6,CMP19{{{JUMP IF NOT PATTERN MATCH{21203
{{MOV{21,=OPMS${13,CMOPN(XR){{ELSE SET PATTERN MATCH POINTER{21204
{{MOV{18,=C$PMT{13,CMTYP(XR){{{21205
*
*      HERE AFTER DEALING WITH SPECIAL PATTERN MATCH CASE
*
{CMP19{JSR{6,CDGVL{{{GENERATE CODE FOR BODY OF STATEMENT{21209
{{MOV{13,CMSGO(XS){7,XR{{LOAD SGOTO POINTER{21210
{{MOV{7,XR{8,WA{{COPY IT{21211
{{BZE{7,XR{6,CMP21{{JUMP IF NO SUCCESS GOTO{21212
{{ZER{13,CMSOC(XS){{{CLEAR SUCCESS OFFSET FILLIN PTR{21213
{{BHI{7,XR{3,STATE{6,CMP20{JUMP IF COMPLEX GOTO{21214
*
*      HERE FOR SIMPLE SUCCESS GOTO (LABEL)
*
{{ADD{19,*VRTRA{8,WA{{POINT TO VRTRA FIELD AS REQUIRED{21218
{{JSR{6,CDWRD{{{GENERATE SUCCESS GOTO{21219
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{21220
*
*      HERE FOR COMPLEX SUCCESS GOTO
*
{CMP20{BEQ{7,XR{13,CMFGO(XS){6,CMP22{NO CODE IF SAME AS FGOTO{21224
{{ZER{8,WB{{{ELSE SET OK VALUE FOR CDGVL IN WB{21225
{{JSR{6,CDGCG{{{GENERATE CODE FOR SUCCESS GOTO{21226
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{21227
*
*      HERE FOR NO SUCCESS GOTO
*
{CMP21{MOV{3,CWCOF{13,CMSOC(XS){{SET SUCCESS FILL IN OFFSET{21231
{{MOV{21,=OCER${8,WA{{POINT TO COMPILE ERROR CALL{21232
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY VALUE{21233
{{EJC{{{{{21234
*
*      CMPIL (CONTINUED)
*
*      HERE TO DEAL WITH FAILURE GOTO
*
{CMP22{MOV{13,CMFGO(XS){7,XR{{LOAD FAILURE GOTO POINTER{21240
{{MOV{7,XR{8,WA{{COPY IT{21241
{{ZER{13,CMFFC(XS){{{SET NO FILL IN REQUIRED YET{21242
{{BZE{7,XR{6,CMP23{{JUMP IF NO FAILURE GOTO GIVEN{21243
{{ADD{19,*VRTRA{8,WA{{POINT TO VRTRA FIELD IN CASE{21244
{{BLO{7,XR{3,STATE{6,CMPSE{JUMP TO GEN IF SIMPLE FGOTO{21245
*
*      HERE FOR COMPLEX FAILURE GOTO
*
{{MOV{3,CWCOF{8,WB{{SAVE OFFSET TO O$GOF CALL{21249
{{MOV{21,=OGOF${8,WA{{POINT TO FAILURE GOTO CALL{21250
{{JSR{6,CDWRD{{{GENERATE{21251
{{MOV{21,=OFIF${8,WA{{POINT TO FAIL IN FAIL WORD{21252
{{JSR{6,CDWRD{{{GENERATE{21253
{{JSR{6,CDGCG{{{GENERATE CODE FOR FAILURE GOTO{21254
{{MOV{8,WB{8,WA{{COPY OFFSET TO O$GOF FOR CDFAL{21255
{{MOV{22,=B$CDC{8,WB{{SET COMPLEX CASE CDTYP{21256
{{BRN{6,CMP25{{{JUMP TO BUILD CDBLK{21257
*
*      HERE IF NO FAILURE GOTO GIVEN
*
{CMP23{MOV{21,=OUNF${8,WA{{LOAD UNEXPECTED FAILURE CALL IN CAS{21261
{{MOV{3,CSWFL{8,WC{{GET -NOFAIL FLAG{21262
{{ORB{13,CMCGO(XS){8,WC{{CHECK IF CONDITIONAL GOTO{21263
{{ZRB{8,WC{6,CMPSE{{JUMP IF -NOFAIL AND NO COND. GOTO{21264
{{MNZ{13,CMFFC(XS){{{ELSE SET FILL IN FLAG{21265
{{MOV{21,=OCER${8,WA{{AND SET COMPILE ERROR FOR TEMPORARY{21266
*
*      MERGE HERE WITH CDFAL VALUE IN WA, SIMPLE CDBLK
*      ALSO SPECIAL ENTRY AFTER STATEMENT ERROR
*
{CMPSE{MOV{22,=B$CDS{8,WB{{SET CDTYP FOR SIMPLE CASE{21271
{{EJC{{{{{21272
*
*      CMPIL (CONTINUED)
*
*      MERGE HERE TO BUILD CDBLK
*
*      (WA)                  CDFAL VALUE TO BE GENERATED
*      (WB)                  CDTYP VALUE TO BE GENERATED
*
*      AT THIS STAGE, WE CHOP OFF AN APPROPRIATE CHUNK OF THE
*      CURRENT CCBLK AND CONVERT IT INTO A CDBLK. THE REMAINDER
*      OF THE CCBLK IS REFORMATTED TO BE THE NEW CCBLK.
*
{CMP25{MOV{3,R$CCB{7,XR{{POINT TO CCBLK{21285
{{MOV{13,CMLBL(XS){7,XL{{GET POSSIBLE LABEL POINTER{21286
{{BZE{7,XL{6,CMP26{{SKIP IF NO LABEL{21287
{{ZER{13,CMLBL(XS){{{CLEAR FLAG FOR NEXT STATEMENT{21288
{{MOV{7,XR{13,VRLBL(XL){{PUT CDBLK PTR IN VRBLK LABEL FIELD{21289
*
*      MERGE AFTER DOING LABEL
*
{CMP26{MOV{8,WB{9,(XR){{SET TYPE WORD FOR NEW CDBLK{21293
{{MOV{8,WA{13,CDFAL(XR){{SET FAILURE WORD{21294
{{MOV{7,XR{7,XL{{COPY POINTER TO CCBLK{21295
{{MOV{13,CCUSE(XR){8,WB{{LOAD LENGTH GEN (= NEW CDLEN){21296
{{MOV{13,CCLEN(XR){8,WC{{LOAD TOTAL CCBLK LENGTH{21297
{{ADD{8,WB{7,XL{{POINT PAST CDBLK{21298
{{SUB{8,WB{8,WC{{GET LENGTH LEFT FOR CHOP OFF{21299
{{MOV{22,=B$CCT{9,(XL){{SET TYPE CODE FOR NEW CCBLK AT END{21300
{{MOV{19,*CCCOD{13,CCUSE(XL){{SET INITIAL CODE OFFSET{21301
{{MOV{19,*CCCOD{3,CWCOF{{REINITIALISE CWCOF{21302
{{MOV{8,WC{13,CCLEN(XL){{SET NEW LENGTH{21303
{{MOV{7,XL{3,R$CCB{{SET NEW CCBLK POINTER{21304
{{ZER{13,CCSLN(XL){{{INITIALIZE NEW LINE NUMBER{21306
{{MOV{3,CMPLN{13,CDSLN(XR){{SET LINE NUMBER IN OLD BLOCK{21307
{{MOV{3,CMPSN{13,CDSTM(XR){{SET STATEMENT NUMBER{21309
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{21310
*
*      SET POINTERS IN PREVIOUS CODE BLOCK AS REQUIRED
*
{{MOV{13,CMPCD(XS){7,XL{{LOAD PTR TO PREVIOUS CDBLK{21314
{{BZE{13,CMFFP(XS){6,CMP27{{JUMP IF NO FAILURE FILL IN REQUIRED{21315
{{MOV{7,XR{13,CDFAL(XL){{ELSE SET FAILURE PTR IN PREVIOUS{21316
*
*      HERE TO DEAL WITH SUCCESS FORWARD POINTER
*
{CMP27{MOV{13,CMSOP(XS){8,WA{{LOAD SUCCESS OFFSET{21320
{{BZE{8,WA{6,CMP28{{JUMP IF NO FILL IN REQUIRED{21321
{{ADD{8,WA{7,XL{{ELSE POINT TO FILL IN LOCATION{21322
{{MOV{7,XR{9,(XL){{STORE FORWARD POINTER{21323
{{ZER{7,XL{{{CLEAR GARBAGE XL VALUE{21324
{{EJC{{{{{21325
*
*      CMPIL (CONTINUED)
*
*      NOW SET FILL IN POINTERS FOR THIS STATEMENT
*
{CMP28{MOV{13,CMFFC(XS){13,CMFFP(XS){{COPY FAILURE FILL IN FLAG{21331
{{MOV{13,CMSOC(XS){13,CMSOP(XS){{COPY SUCCESS FILL IN OFFSET{21332
{{MOV{7,XR{13,CMPCD(XS){{SAVE PTR TO THIS CDBLK{21333
{{BNZ{13,CMTRA(XS){6,CMP29{{JUMP IF INITIAL ENTRY ALREADY SET{21334
{{MOV{7,XR{13,CMTRA(XS){{ELSE SET PTR HERE AS DEFAULT{21335
*
*      HERE AFTER COMPILING ONE STATEMENT
*
{CMP29{BLT{3,STAGE{18,=STGCE{6,CMP01{JUMP IF NOT END LINE JUST DONE{21339
{{BZE{3,CSWLS{6,CMP30{{SKIP IF -NOLIST{21340
{{JSR{6,LISTR{{{LIST LAST LINE{21341
*
*      RETURN
*
{CMP30{MOV{13,CMTRA(XS){7,XR{{LOAD INITIAL ENTRY CDBLK POINTER{21345
{{ADD{19,*CMNEN{7,XS{{POP WORK LOCATIONS OFF STACK{21346
{{EXI{{{{AND RETURN TO CMPIL CALLER{21347
*
*      HERE AT END OF GOTO FIELD
*
{CMP31{MOV{13,CMFGO(XS){8,WB{{GET FAIL GOTO{21351
{{ORB{13,CMSGO(XS){8,WB{{OR IN SUCCESS GOTO{21352
{{BNZ{8,WB{6,CMP18{{OK IF NON-NULL FIELD{21353
{{ERB{1,219{26,Syntax error: Empty goto field{{{21354
*
*      CONTROL CARD FOUND
*
{CMP32{ICV{8,WB{{{POINT PAST CH$MN{21358
{{JSR{6,CNCRD{{{PROCESS CONTROL CARD{21359
{{ZER{3,SCNSE{{{CLEAR START OF ELEMENT LOC.{21360
{{BRN{6,CMPCE{{{LOOP FOR NEXT STATEMENT{21361
{{ENP{{{{END PROCEDURE CMPIL{21362
{{EJC{{{{{21363
*
*      CNCRD -- CONTROL CARD PROCESSOR
*
*      CALLED TO DEAL WITH CONTROL CARDS
*
*      R$CIM                 POINTS TO CURRENT IMAGE
*      (WB)                  OFFSET TO 1ST CHAR OF CONTROL CARD
*      JSR  CNCRD            CALL TO PROCESS CONTROL CARDS
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{CNCRD{PRC{25,E{1,0{{ENTRY POINT{21374
{{MOV{8,WB{3,SCNPT{{OFFSET FOR CONTROL CARD SCAN{21375
{{MOV{18,=CCNOC{8,WA{{NUMBER OF CHARS FOR COMPARISON{21376
{{CTW{8,WA{1,0{{CONVERT TO WORD COUNT{21377
{{MOV{8,WA{3,CNSWC{{SAVE WORD COUNT{21378
*
*      LOOP HERE IF MORE THAN ONE CONTROL CARD
*
{CNC01{BGE{3,SCNPT{3,SCNIL{6,CNC09{RETURN IF END OF IMAGE{21382
{{MOV{3,R$CIM{7,XR{{POINT TO IMAGE{21383
{{PLC{7,XR{3,SCNPT{{CHAR PTR FOR FIRST CHAR{21384
{{LCH{8,WA{10,(XR)+{{GET FIRST CHAR{21385
{{FLC{8,WA{{{FOLD TO UPPER CASE{21387
{{BEQ{8,WA{18,=CH$LI{6,CNC07{SPECIAL CASE OF -INXXX{21389
{CNC0A{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21390
{{JSR{6,SCANE{{{SCAN CARD NAME{21391
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21392
{{BNZ{7,XL{6,CNC06{{FAIL UNLESS CONTROL CARD NAME{21393
{{MOV{18,=CCNOC{8,WA{{NO. OF CHARS TO BE COMPARED{21394
{{BLT{13,SCLEN(XR){8,WA{6,CNC08{FAIL IF TOO FEW CHARS{21396
{{MOV{7,XR{7,XL{{POINT TO CONTROL CARD NAME{21400
{{ZER{8,WB{{{ZERO OFFSET FOR SUBSTRING{21401
{{JSR{6,SBSTR{{{EXTRACT SUBSTRING FOR COMPARISON{21402
{{MOV{13,SCLEN(XR){8,WA{{RELOAD LENGTH{21404
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{21405
{{MOV{7,XR{3,CNSCC{{KEEP CONTROL CARD SUBSTRING PTR{21407
{{MOV{21,=CCNMS{7,XR{{POINT TO LIST OF STANDARD NAMES{21408
{{ZER{8,WB{{{INITIALISE NAME OFFSET{21409
{{LCT{8,WC{18,=CC$NC{{NUMBER OF STANDARD NAMES{21410
*
*      TRY TO MATCH NAME
*
{CNC02{MOV{3,CNSCC{7,XL{{POINT TO NAME{21414
{{LCT{8,WA{3,CNSWC{{COUNTER FOR INNER LOOP{21415
{{BRN{6,CNC04{{{JUMP INTO LOOP{21416
*
*      INNER LOOP TO MATCH CARD NAME CHARS
*
{CNC03{ICA{7,XR{{{BUMP STANDARD NAMES PTR{21420
{{ICA{7,XL{{{BUMP NAME POINTER{21421
*
*      HERE TO INITIATE THE LOOP
*
{CNC04{CNE{13,SCHAR(XL){9,(XR){6,CNC05{COMP. UP TO CFP$C CHARS AT ONCE{21425
{{BCT{8,WA{6,CNC03{{LOOP IF MORE WORDS TO COMPARE{21426
{{EJC{{{{{21427
*
*      CNCRD (CONTINUED)
*
*      MATCHED - BRANCH ON CARD OFFSET
*
{{MOV{8,WB{7,XL{{GET NAME OFFSET{21433
{{BSW{7,XL{2,CC$NC{6,CNC08{SWITCH{21435
{{IFF{2,CC$CA{6,CNC37{{-CASE{21474
{{IFF{2,CC$DO{6,CNC10{{-DOUBLE{21474
{{IFF{1,2{6,CNC08{{{21474
{{IFF{2,CC$DU{6,CNC11{{-DUMP{21474
{{IFF{2,CC$CP{6,CNC41{{-COPY{21474
{{IFF{2,CC$EJ{6,CNC12{{-EJECT{21474
{{IFF{2,CC$ER{6,CNC13{{-ERRORS{21474
{{IFF{2,CC$EX{6,CNC14{{-EXECUTE{21474
{{IFF{2,CC$FA{6,CNC15{{-FAIL{21474
{{IFF{2,CC$IN{6,CNC41{{-INCLUDE{21474
{{IFF{2,CC$LN{6,CNC44{{-LINE{21474
{{IFF{2,CC$LI{6,CNC16{{-LIST{21474
{{IFF{2,CC$NR{6,CNC17{{-NOERRORS{21474
{{IFF{2,CC$NX{6,CNC18{{-NOEXECUTE{21474
{{IFF{2,CC$NF{6,CNC19{{-NOFAIL{21474
{{IFF{2,CC$NL{6,CNC20{{-NOLIST{21474
{{IFF{2,CC$NO{6,CNC21{{-NOOPT{21474
{{IFF{2,CC$NP{6,CNC22{{-NOPRINT{21474
{{IFF{2,CC$OP{6,CNC24{{-OPTIMISE{21474
{{IFF{2,CC$PR{6,CNC25{{-PRINT{21474
{{IFF{2,CC$SI{6,CNC27{{-SINGLE{21474
{{IFF{2,CC$SP{6,CNC28{{-SPACE{21474
{{IFF{2,CC$ST{6,CNC31{{-STITLE{21474
{{IFF{2,CC$TI{6,CNC32{{-TITLE{21474
{{IFF{2,CC$TR{6,CNC36{{-TRACE{21474
{{ESW{{{{END SWITCH{21474
*
*      NOT MATCHED YET. ALIGN STD NAMES PTR AND TRY AGAIN
*
{CNC05{ICA{7,XR{{{BUMP STANDARD NAMES PTR{21478
{{BCT{8,WA{6,CNC05{{LOOP{21479
{{ICV{8,WB{{{BUMP NAMES OFFSET{21480
{{BCT{8,WC{6,CNC02{{CONTINUE IF MORE NAMES{21481
{{BRN{6,CNC08{{{IGNORE UNRECOGNIZED CONTROL CARD{21483
*
*      INVALID CONTROL CARD NAME
*
{CNC06{ERB{1,247{26,Invalid control statement{{{21488
*
*      SPECIAL PROCESSING FOR -INXXX
*
{CNC07{LCH{8,WA{10,(XR)+{{GET NEXT CHAR{21492
{{FLC{8,WA{{{FOLD TO UPPER CASE{21494
{{BNE{8,WA{18,=CH$LN{6,CNC0A{IF NOT LETTER N{21496
{{LCH{8,WA{9,(XR){{GET THIRD CHAR{21497
{{BLT{8,WA{18,=CH$D0{6,CNC0A{IF NOT DIGIT{21498
{{BGT{8,WA{18,=CH$D9{6,CNC0A{IF NOT DIGIT{21499
{{ADD{18,=NUM02{3,SCNPT{{BUMP OFFSET PAST -IN{21500
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -IN{21501
{{MOV{7,XR{11,-(XS){{STACK SCANNED ITEM{21502
{{JSR{6,GTSMI{{{CHECK IF INTEGER{21503
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21504
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{21505
{{MOV{7,XR{3,CSWIN{{KEEP INTEGER{21506
{{EJC{{{{{21507
*
*      CNCRD (CONTINUED)
*
*      CHECK FOR MORE CONTROL CARDS BEFORE RETURNING
*
{CNC08{MOV{3,SCNPT{8,WA{{PRESERVE IN CASE XEQ TIME COMPILE{21513
{{JSR{6,SCANE{{{LOOK FOR COMMA{21514
{{BEQ{7,XL{18,=T$CMA{6,CNC01{LOOP IF COMMA FOUND{21515
{{MOV{8,WA{3,SCNPT{{RESTORE SCNPT IN CASE XEQ TIME{21516
*
*      RETURN POINT
*
{CNC09{EXI{{{{RETURN{21520
*
*      -DOUBLE
*
{CNC10{MNZ{3,CSWDB{{{SET SWITCH{21524
{{BRN{6,CNC08{{{MERGE{21525
*
*      -DUMP
*      THIS IS USED FOR SYSTEM DEBUGGING . IT HAS THE EFFECT OF
*      PRODUCING A CORE DUMP AT COMPILATION TIME
*
{CNC11{JSR{6,SYSDM{{{CALL DUMPER{21531
{{BRN{6,CNC09{{{FINISHED{21532
*
*      -EJECT
*
{CNC12{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{21536
{{JSR{6,PRTPS{{{EJECT{21537
{{JSR{6,LISTT{{{LIST TITLE{21538
{{BRN{6,CNC09{{{FINISHED{21539
*
*      -ERRORS
*
{CNC13{ZER{3,CSWER{{{CLEAR SWITCH{21543
{{BRN{6,CNC08{{{MERGE{21544
*
*      -EXECUTE
*
{CNC14{ZER{3,CSWEX{{{CLEAR SWITCH{21548
{{BRN{6,CNC08{{{MERGE{21549
*
*      -FAIL
*
{CNC15{MNZ{3,CSWFL{{{SET SWITCH{21553
{{BRN{6,CNC08{{{MERGE{21554
*
*      -LIST
*
{CNC16{MNZ{3,CSWLS{{{SET SWITCH{21558
{{BEQ{3,STAGE{18,=STGIC{6,CNC08{DONE IF COMPILE TIME{21559
*
*      LIST CODE LINE IF EXECUTE TIME COMPILE
*
{{ZER{3,LSTPF{{{PERMIT LISTING{21563
{{JSR{6,LISTR{{{LIST LINE{21564
{{BRN{6,CNC08{{{MERGE{21565
{{EJC{{{{{21566
*
*      CNCRD (CONTINUED)
*
*      -NOERRORS
*
{CNC17{MNZ{3,CSWER{{{SET SWITCH{21572
{{BRN{6,CNC08{{{MERGE{21573
*
*      -NOEXECUTE
*
{CNC18{MNZ{3,CSWEX{{{SET SWITCH{21577
{{BRN{6,CNC08{{{MERGE{21578
*
*      -NOFAIL
*
{CNC19{ZER{3,CSWFL{{{CLEAR SWITCH{21582
{{BRN{6,CNC08{{{MERGE{21583
*
*      -NOLIST
*
{CNC20{ZER{3,CSWLS{{{CLEAR SWITCH{21587
{{BRN{6,CNC08{{{MERGE{21588
*
*      -NOOPTIMISE
*
{CNC21{MNZ{3,CSWNO{{{SET SWITCH{21592
{{BRN{6,CNC08{{{MERGE{21593
*
*      -NOPRINT
*
{CNC22{ZER{3,CSWPR{{{CLEAR SWITCH{21597
{{BRN{6,CNC08{{{MERGE{21598
*
*      -OPTIMISE
*
{CNC24{ZER{3,CSWNO{{{CLEAR SWITCH{21602
{{BRN{6,CNC08{{{MERGE{21603
*
*      -PRINT
*
{CNC25{MNZ{3,CSWPR{{{SET SWITCH{21607
{{BRN{6,CNC08{{{MERGE{21608
{{EJC{{{{{21609
*
*      CNCRD (CONTINUED)
*
*      -SINGLE
*
{CNC27{ZER{3,CSWDB{{{CLEAR SWITCH{21615
{{BRN{6,CNC08{{{MERGE{21616
*
*      -SPACE
*
{CNC28{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{21620
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -SPACE{21621
{{MOV{18,=NUM01{8,WC{{1 SPACE IN CASE{21622
{{BEQ{7,XR{18,=T$SMC{6,CNC29{JUMP IF NO INTEGER{21623
{{MOV{7,XR{11,-(XS){{STACK IT{21624
{{JSR{6,GTSMI{{{CHECK INTEGER{21625
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21626
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{21627
{{BNZ{8,WC{6,CNC29{{JUMP IF NON ZERO{21628
{{MOV{18,=NUM01{8,WC{{ELSE 1 SPACE{21629
*
*      MERGE WITH COUNT OF LINES TO SKIP
*
{CNC29{ADD{8,WC{3,LSTLC{{BUMP LINE COUNT{21633
{{LCT{8,WC{8,WC{{CONVERT TO LOOP COUNTER{21634
{{BLT{3,LSTLC{3,LSTNP{6,CNC30{JUMP IF FITS ON PAGE{21635
{{JSR{6,PRTPS{{{EJECT{21636
{{JSR{6,LISTT{{{LIST TITLE{21637
{{BRN{6,CNC09{{{MERGE{21638
*
*      SKIP LINES
*
{CNC30{JSR{6,PRTNL{{{PRINT A BLANK{21642
{{BCT{8,WC{6,CNC30{{LOOP{21643
{{BRN{6,CNC09{{{MERGE{21644
{{EJC{{{{{21645
*
*      CNCRD (CONTINUED)
*
*      -STITL
*
{CNC31{MOV{20,=R$STL{3,CNR$T{{PTR TO R$STL{21651
{{BRN{6,CNC33{{{MERGE{21652
*
*      -TITLE
*
{CNC32{MOV{21,=NULLS{3,R$STL{{CLEAR SUBTITLE{21656
{{MOV{20,=R$TTL{3,CNR$T{{PTR TO R$TTL{21657
*
*      COMMON PROCESSING FOR -TITLE, -STITL
*
{CNC33{MOV{21,=NULLS{7,XR{{NULL IN CASE NEEDED{21661
{{MNZ{3,CNTTL{{{SET FLAG FOR NEXT LISTR CALL{21662
{{MOV{18,=CCOFS{8,WB{{OFFSET TO TITLE/SUBTITLE{21663
{{MOV{3,SCNIL{8,WA{{INPUT IMAGE LENGTH{21664
{{BLO{8,WA{8,WB{6,CNC34{JUMP IF NO CHARS LEFT{21665
{{SUB{8,WB{8,WA{{NO OF CHARS TO EXTRACT{21666
{{MOV{3,R$CIM{7,XL{{POINT TO IMAGE{21667
{{JSR{6,SBSTR{{{GET TITLE/SUBTITLE{21668
*
*      STORE TITLE/SUBTITLE
*
{CNC34{MOV{3,CNR$T{7,XL{{POINT TO STORAGE LOCATION{21672
{{MOV{7,XR{9,(XL){{STORE TITLE/SUBTITLE{21673
{{BEQ{7,XL{20,=R$STL{6,CNC09{RETURN IF STITL{21674
{{BNZ{3,PRECL{6,CNC09{{RETURN IF EXTENDED LISTING{21675
{{BZE{3,PRICH{6,CNC09{{RETURN IF REGULAR PRINTER{21676
{{MOV{13,SCLEN(XR){7,XL{{GET LENGTH OF TITLE{21677
{{MOV{7,XL{8,WA{{COPY IT{21678
{{BZE{7,XL{6,CNC35{{JUMP IF NULL{21679
{{ADD{18,=NUM10{7,XL{{INCREMENT{21680
{{BHI{7,XL{3,PRLEN{6,CNC09{USE DEFAULT LSTP0 VAL IF TOO LONG{21681
{{ADD{18,=NUM04{8,WA{{POINT JUST PAST TITLE{21682
*
*      STORE OFFSET TO PAGE NN MESSAGE FOR SHORT TITLE
*
{CNC35{MOV{8,WA{3,LSTPO{{STORE OFFSET{21686
{{BRN{6,CNC09{{{RETURN{21687
*
*      -TRACE
*      PROVIDED FOR SYSTEM DEBUGGING.  TOGGLES THE SYSTEM LABEL
*      TRACE SWITCH AT COMPILE TIME
*
{CNC36{JSR{6,SYSTT{{{TOGGLE SWITCH{21693
{{BRN{6,CNC08{{{MERGE{21694
*
*      -CASE
*      SETS VALUE OF KVCAS SO THAT NAMES ARE FOLDED OR NOT
*      DURING COMPILATION.
*
{CNC37{JSR{6,SCANE{{{SCAN INTEGER AFTER -CASE{21701
{{ZER{8,WC{{{GET 0 IN CASE NONE THERE{21702
{{BEQ{7,XL{18,=T$SMC{6,CNC38{SKIP IF NO INTEGER{21703
{{MOV{7,XR{11,-(XS){{STACK IT{21704
{{JSR{6,GTSMI{{{CHECK INTEGER{21705
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21706
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR TOO LARGE{21707
{CNC38{MOV{8,WC{3,KVCAS{{STORE NEW CASE VALUE{21708
{{BRN{6,CNC09{{{MERGE{21709
*
*      -INCLUDE
*
{CNC41{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21732
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{21733
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21734
{{BNE{7,XL{18,=T$CON{6,CNC06{IF NOT CONSTANT{21735
{{BNE{9,(XR){22,=B$SCL{6,CNC06{IF NOT STRING CONSTANT{21736
{{MOV{7,XR{3,R$IFN{{SAVE FILE NAME{21737
{{MOV{3,R$INC{7,XL{{EXAMINE INCLUDE FILE NAME TABLE{21738
{{ZER{8,WB{{{LOOKUP BY VALUE{21739
{{JSR{6,TFIND{{{DO LOOKUP{21740
{{PPM{{{{NEVER FAILS{21741
{{BEQ{7,XR{21,=INTON{6,CNC09{IGNORE IF ALREADY IN TABLE{21742
{{MNZ{8,WB{{{SET FOR TRIM{21743
{{MOV{3,R$IFN{7,XR{{FILE NAME{21744
{{JSR{6,TRIMR{{{REMOVE TRAILING BLANKS{21745
{{MOV{3,R$INC{7,XL{{INCLUDE FILE NAME TABLE{21746
{{MNZ{8,WB{{{LOOKUP BY NAME THIS TIME{21747
{{JSR{6,TFIND{{{DO LOOKUP{21748
{{PPM{{{{NEVER FAILS{21749
{{MOV{21,=INTON{13,TEVAL(XL){{MAKE TABLE VALUE INTEGER 1{21750
{{ICV{3,CNIND{{{INCREASE NESTING LEVEL{21751
{{MOV{3,CNIND{8,WA{{LOAD NEW NEST LEVEL{21752
{{BGT{8,WA{18,=CCINM{6,CNC42{FAIL IF EXCESSIVE NESTING{21753
*
*      RECORD THE NAME AND LINE NUMBER OF THE CURRENT INPUT FILE
*
{{MOV{3,R$IFA{7,XL{{ARRAY OF NESTED FILE NAMES{21758
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{21759
{{WTB{8,WA{{{CONVERT TO BYTES{21760
{{ADD{8,WA{7,XL{{POINT TO ELEMENT{21761
{{MOV{3,R$SFC{9,(XL){{RECORD CURRENT FILE NAME{21762
{{MOV{8,WA{7,XL{{PRESERVE NESTING BYTE OFFSET{21763
{{MTI{3,RDNLN{{{FETCH SOURCE LINE NUMBER AS INTEGER{21764
{{JSR{6,ICBLD{{{CONVERT TO ICBLK{21765
{{ADD{3,R$IFL{7,XL{{ENTRY IN NESTED LINE NUMBER ARRAY{21766
{{MOV{7,XR{9,(XL){{RECORD IN ARRAY{21767
*
*      HERE TO SWITCH TO INCLUDE FILE NAMED IN R$IFN
*
{{MOV{3,CSWIN{8,WA{{MAX READ LENGTH{21772
{{MOV{3,R$IFN{7,XL{{INCLUDE FILE NAME{21773
{{JSR{6,ALOCS{{{GET BUFFER FOR COMPLETE FILE NAME{21774
{{JSR{6,SYSIF{{{OPEN INCLUDE FILE{21775
{{PPM{6,CNC43{{{COULD NOT OPEN{21776
*
*      MAKE NOTE OF THE COMPLETE FILE NAME FOR ERROR MESSAGES
*
{{ZER{8,WB{{{DO NOT TRIM TRAILING BLANKS{21781
{{JSR{6,TRIMR{{{ADJUST SCBLK FOR ACTUAL LENGTH{21782
{{MOV{7,XR{3,R$SFC{{SAVE PTR TO FILE NAME{21783
{{MTI{3,CMPSN{{{CURRENT STATEMENT AS INTEGER{21784
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{21785
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{21786
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{21787
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{21788
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{21789
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{21790
{{ZER{3,RDNLN{{{RESTART LINE COUNTER FOR NEW FILE{21794
{{BEQ{3,STAGE{18,=STGIC{6,CNC09{IF INITIAL COMPILE{21795
{{BNE{3,CNIND{18,=NUM01{6,CNC09{IF NOT FIRST EXECUTE-TIME NESTING{21796
*
*      HERE FOR -INCLUDE DURING EXECUTE-TIME COMPILE
*
{{MOV{3,R$CIM{3,R$ICI{{REMEMBER CODE ARGUMENT STRING{21800
{{MOV{3,SCNPT{3,CNSPT{{SAVE POSITION IN STRING{21801
{{MOV{3,SCNIL{3,CNSIL{{AND LENGTH OF STRING{21802
{{BRN{6,CNC09{{{ALL DONE, MERGE{21803
*
*      HERE FOR EXCESSIVE INCLUDE FILE NESTING
*
{CNC42{ERB{1,284{26,Excessively nested INCLUDE files{{{21807
*
*      HERE IF INCLUDE FILE COULD NOT BE OPENED
*
{CNC43{MOV{7,XR{3,DNAMP{{RELEASE ALLOCATED SCBLK{21811
{{ERB{1,285{26,INCLUDE file cannot be opened{{{21812
*
*
*      -LINE N FILENAME
*
{CNC44{JSR{6,SCANE{{{SCAN INTEGER AFTER -LINE{21819
{{BNE{7,XL{18,=T$CON{6,CNC06{JUMP IF NO LINE NUMBER{21820
{{BNE{9,(XR){22,=B$ICL{6,CNC06{JUMP IF NOT INTEGER{21821
{{LDI{13,ICVAL(XR){{{FETCH INTEGER LINE NUMBER{21822
{{ILE{6,CNC06{{{ERROR IF NEGATIVE OR ZERO{21823
{{BEQ{3,STAGE{18,=STGIC{6,CNC45{SKIP IF INITIAL COMPILE{21824
{{MFI{3,CMPLN{{{SET DIRECTLY FOR OTHER COMPILES{21825
{{BRN{6,CNC46{{{NO NEED TO SET RDNLN{21826
{CNC45{SBI{4,INTV1{{{ADJUST NUMBER BY ONE{21827
{{MFI{3,RDNLN{{{SAVE LINE NUMBER{21828
{CNC46{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21830
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{21831
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21832
{{BEQ{7,XL{18,=T$SMC{6,CNC47{DONE IF NO FILE NAME{21833
{{BNE{7,XL{18,=T$CON{6,CNC06{ERROR IF NOT CONSTANT{21834
{{BNE{9,(XR){22,=B$SCL{6,CNC06{IF NOT STRING CONSTANT{21835
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{21836
{{BRN{6,CNC09{{{MERGE{21837
*
*      HERE IF FILE NAME NOT PRESENT
*
{CNC47{DCV{3,SCNPT{{{SET TO RESCAN THE TERMINATOR{21841
{{BRN{6,CNC09{{{MERGE{21842
{{ENP{{{{END PROCEDURE CNCRD{21847
{{EJC{{{{{21848
*
*      DFFNC -- DEFINE FUNCTION
*
*      DFFNC IS CALLED WHENEVER A NEW FUNCTION IS ASSIGNED TO
*      A VARIABLE. IT DEALS WITH EXTERNAL FUNCTION USE COUNTS.
*
*      (XR)                  POINTER TO VRBLK
*      (XL)                  POINTER TO NEW FUNCTION BLOCK
*      JSR  DFFNC            CALL TO DEFINE FUNCTION
*      (WA,WB)               DESTROYED
*
{DFFNC{PRC{25,E{1,0{{ENTRY POINT{21930
{{BNE{9,(XL){22,=B$EFC{6,DFFN1{SKIP IF NEW FUNCTION NOT EXTERNAL{21933
{{ICV{13,EFUSE(XL){{{ELSE INCREMENT ITS USE COUNT{21934
*
*      HERE AFTER DEALING WITH NEW FUNCTION USE COUNT
*
{DFFN1{MOV{7,XR{8,WA{{SAVE VRBLK POINTER{21938
{{MOV{13,VRFNC(XR){7,XR{{LOAD OLD FUNCTION POINTER{21939
{{BNE{9,(XR){22,=B$EFC{6,DFFN2{JUMP IF OLD FUNCTION NOT EXTERNAL{21940
{{MOV{13,EFUSE(XR){8,WB{{ELSE GET USE COUNT{21941
{{DCV{8,WB{{{DECREMENT{21942
{{MOV{8,WB{13,EFUSE(XR){{STORE DECREMENTED VALUE{21943
{{BNZ{8,WB{6,DFFN2{{JUMP IF USE COUNT STILL NON-ZERO{21944
{{JSR{6,SYSUL{{{ELSE CALL SYSTEM UNLOAD FUNCTION{21945
*
*      HERE AFTER DEALING WITH OLD FUNCTION USE COUNT
*
{DFFN2{MOV{8,WA{7,XR{{RESTORE VRBLK POINTER{21949
{{MOV{7,XL{8,WA{{COPY FUNCTION BLOCK PTR{21951
{{BLT{7,XR{20,=R$YYY{6,DFFN3{SKIP CHECKS IF OPSYN OP DEFINITION{21952
{{BNZ{13,VRLEN(XR){6,DFFN3{{JUMP IF NOT SYSTEM VARIABLE{21953
*
*      FOR SYSTEM VARIABLE, CHECK FOR ILLEGAL REDEFINITION
*
{{MOV{13,VRSVP(XR){7,XL{{POINT TO SVBLK{21957
{{MOV{13,SVBIT(XL){8,WB{{LOAD BIT INDICATORS{21958
{{ANB{4,BTFNC{8,WB{{IS IT A SYSTEM FUNCTION{21959
{{ZRB{8,WB{6,DFFN3{{REDEF OK IF NOT{21960
{{ERB{1,248{26,Attempted redefinition of system function{{{21961
*
*      HERE IF REDEFINITION IS PERMITTED
*
{DFFN3{MOV{8,WA{13,VRFNC(XR){{STORE NEW FUNCTION POINTER{21965
{{MOV{8,WA{7,XL{{RESTORE FUNCTION BLOCK POINTER{21966
{{EXI{{{{RETURN TO DFFNC CALLER{21967
{{ENP{{{{END PROCEDURE DFFNC{21968
{{EJC{{{{{21969
*
*      DTACH -- DETACH I/O ASSOCIATED NAMES
*
*      DETACHES TRBLKS FROM I/O ASSOCIATED VARIABLES, REMOVES
*      ENTRY FROM IOCHN CHAIN ATTACHED TO FILEARG1 VRBLK AND MAY
*      REMOVE VRBLK ACCESS AND STORE TRAPS.
*      INPUT, OUTPUT, TERMINAL ARE HANDLED SPECIALLY.
*
*      (XL)                  I/O ASSOC. VBL NAME BASE PTR
*      (WA)                  OFFSET TO NAME
*      JSR  DTACH            CALL FOR DETACH OPERATION
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{DTACH{PRC{25,E{1,0{{ENTRY POINT{21983
{{MOV{7,XL{3,DTCNB{{STORE NAME BASE (GBCOL NOT CALLED){21984
{{ADD{8,WA{7,XL{{POINT TO NAME LOCATION{21985
{{MOV{7,XL{3,DTCNM{{STORE IT{21986
*
*      LOOP TO SEARCH FOR I/O TRBLK
*
{DTCH1{MOV{7,XL{7,XR{{COPY NAME POINTER{21990
*
*      CONTINUE AFTER BLOCK DELETION
*
{DTCH2{MOV{9,(XL){7,XL{{POINT TO NEXT VALUE{21994
{{BNE{9,(XL){22,=B$TRT{6,DTCH6{JUMP AT CHAIN END{21995
{{MOV{13,TRTYP(XL){8,WA{{GET TRAP BLOCK TYPE{21996
{{BEQ{8,WA{18,=TRTIN{6,DTCH3{JUMP IF INPUT{21997
{{BEQ{8,WA{18,=TRTOU{6,DTCH3{JUMP IF OUTPUT{21998
{{ADD{19,*TRNXT{7,XL{{POINT TO NEXT LINK{21999
{{BRN{6,DTCH1{{{LOOP{22000
*
*      DELETE AN OLD ASSOCIATION
*
{DTCH3{MOV{13,TRVAL(XL){9,(XR){{DELETE TRBLK{22004
{{MOV{7,XL{8,WA{{DUMP XL ...{22005
{{MOV{7,XR{8,WB{{... AND XR{22006
{{MOV{13,TRTRF(XL){7,XL{{POINT TO TRTRF TRAP BLOCK{22007
{{BZE{7,XL{6,DTCH5{{JUMP IF NO IOCHN{22008
{{BNE{9,(XL){22,=B$TRT{6,DTCH5{JUMP IF INPUT, OUTPUT, TERMINAL{22009
*
*      LOOP TO SEARCH IOCHN CHAIN FOR NAME PTR
*
{DTCH4{MOV{7,XL{7,XR{{REMEMBER LINK PTR{22013
{{MOV{13,TRTRF(XL){7,XL{{POINT TO NEXT LINK{22014
{{BZE{7,XL{6,DTCH5{{JUMP IF END OF CHAIN{22015
{{MOV{13,IONMB(XL){8,WC{{GET NAME BASE{22016
{{ADD{13,IONMO(XL){8,WC{{ADD OFFSET{22017
{{BNE{8,WC{3,DTCNM{6,DTCH4{LOOP IF NO MATCH{22018
{{MOV{13,TRTRF(XL){13,TRTRF(XR){{REMOVE NAME FROM CHAIN{22019
{{EJC{{{{{22020
*
*      DTACH (CONTINUED)
*
*      PREPARE TO RESUME I/O TRBLK SCAN
*
{DTCH5{MOV{8,WA{7,XL{{RECOVER XL ...{22026
{{MOV{8,WB{7,XR{{... AND XR{22027
{{ADD{19,*TRVAL{7,XL{{POINT TO VALUE FIELD{22028
{{BRN{6,DTCH2{{{CONTINUE{22029
*
*      EXIT POINT
*
{DTCH6{MOV{3,DTCNB{7,XR{{POSSIBLE VRBLK PTR{22033
{{JSR{6,SETVR{{{RESET VRBLK IF NECESSARY{22034
{{EXI{{{{RETURN{22035
{{ENP{{{{END PROCEDURE DTACH{22036
{{EJC{{{{{22037
*
*      DTYPE -- GET DATATYPE NAME
*
*      (XR)                  OBJECT WHOSE DATATYPE IS REQUIRED
*      JSR  DTYPE            CALL TO GET DATATYPE
*      (XR)                  RESULT DATATYPE
*
{DTYPE{PRC{25,E{1,0{{ENTRY POINT{22045
{{BEQ{9,(XR){22,=B$PDT{6,DTYP1{JUMP IF PROG.DEFINED{22046
{{MOV{9,(XR){7,XR{{LOAD TYPE WORD{22047
{{LEI{7,XR{{{GET ENTRY POINT ID (BLOCK CODE){22048
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{22049
{{MOV{14,SCNMT(XR){7,XR{{LOAD TABLE ENTRY{22050
{{EXI{{{{EXIT TO DTYPE CALLER{22051
*
*      HERE IF PROGRAM DEFINED
*
{DTYP1{MOV{13,PDDFP(XR){7,XR{{POINT TO DFBLK{22055
{{MOV{13,DFNAM(XR){7,XR{{GET DATATYPE NAME FROM DFBLK{22056
{{EXI{{{{RETURN TO DTYPE CALLER{22057
{{ENP{{{{END PROCEDURE DTYPE{22058
{{EJC{{{{{22059
*
*      DUMPR -- PRINT DUMP OF STORAGE
*
*      (XR)                  DUMP ARGUMENT (SEE BELOW)
*      JSR  DUMPR            CALL TO PRINT DUMP
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      THE DUMP ARGUMENT HAS THE FOLLOWING SIGNIFICANCE
*
*      DMARG = 0             NO DUMP PRINTED
*      DMARG = 1             PARTIAL DUMP (NAT VARS, KEYWORDS)
*      DMARG = 2             FULL DUMP (ARRAYS, TABLES, ETC.)
*      DMARG = 3             FULL DUMP + NULL VARIABLES
*      DMARG GE 4            CORE DUMP
*
*      SINCE DUMPR SCRAMBLES STORE, IT IS NOT PERMISSIBLE TO
*      COLLECT IN MID-DUMP. HENCE A COLLECT IS DONE INITIALLY
*      AND THEN IF STORE RUNS OUT AN ERROR MESSAGE IS PRODUCED.
*
{DUMPR{PRC{25,E{1,0{{ENTRY POINT{22080
{{BZE{7,XR{6,DMP28{{SKIP DUMP IF ARGUMENT IS ZERO{22081
{{BGT{7,XR{18,=NUM03{6,DMP29{JUMP IF CORE DUMP REQUIRED{22082
{{ZER{7,XL{{{CLEAR XL{22083
{{ZER{8,WB{{{ZERO MOVE OFFSET{22084
{{MOV{7,XR{3,DMARG{{SAVE DUMP ARGUMENT{22085
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{22087
{{JSR{6,GBCOL{{{COLLECT GARBAGE{22089
{{JSR{6,PRTPG{{{EJECT PRINTER{22090
{{MOV{21,=DMHDV{7,XR{{POINT TO HEADING FOR VARIABLES{22091
{{JSR{6,PRTST{{{PRINT IT{22092
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{22093
{{JSR{6,PRTNL{{{AND PRINT A BLANK LINE{22094
*
*      FIRST ALL NATURAL VARIABLE BLOCKS (VRBLK) WHOSE VALUES
*      ARE NON-NULL ARE LINKED IN LEXICAL ORDER USING DMVCH AS
*      THE CHAIN HEAD AND CHAINING THROUGH THE VRGET FIELDS.
*      NOTE THAT THIS SCRAMBLES STORE IF THE PROCESS IS
*      INTERRUPTED BEFORE COMPLETION E.G. BY EXCEEDING TIME  OR
*      PRINT LIMITS. SINCE THE SUBSEQUENT CORE DUMPS AND
*      FAILURES IF EXECUTION IS RESUMED ARE VERY CONFUSING, THE
*      EXECUTION TIME ERROR ROUTINE CHECKS FOR THIS EVENT AND
*      ATTEMPTS AN UNSCRAMBLE. SIMILAR PRECAUTIONS SHOULD BE
*      OBSERVED IF TRANSLATE TIME DUMPING IS IMPLEMENTED.
*
{{ZER{3,DMVCH{{{SET NULL CHAIN TO START{22107
{{MOV{3,HSHTB{8,WA{{POINT TO HASH TABLE{22108
*
*      LOOP THROUGH HEADERS IN HASH TABLE
*
{DMP00{MOV{8,WA{7,XR{{COPY HASH BUCKET POINTER{22112
{{ICA{8,WA{{{BUMP POINTER{22113
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE{22114
*
*      LOOP THROUGH VRBLKS ON ONE CHAIN
*
{DMP01{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{22118
{{BZE{7,XR{6,DMP09{{JUMP IF END OF THIS HASH CHAIN{22119
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK POINTER{22120
{{EJC{{{{{22121
*
*      DUMPR (CONTINUED)
*
*      LOOP TO FIND VALUE AND SKIP IF NULL
*
{DMP02{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{22127
{{BEQ{3,DMARG{18,=NUM03{6,DMP2A{SKIP NULL VALUE CHECK IF DUMP(3){22128
{{BEQ{7,XL{21,=NULLS{6,DMP01{LOOP FOR NEXT VRBLK IF NULL VALUE{22129
{DMP2A{BEQ{9,(XL){22,=B$TRT{6,DMP02{LOOP BACK IF VALUE IS TRAPPED{22130
*
*      NON-NULL VALUE, PREPARE TO SEARCH CHAIN
*
{{MOV{7,XR{8,WC{{SAVE VRBLK POINTER{22134
{{ADD{19,*VRSOF{7,XR{{ADJUST PTR TO BE LIKE SCBLK PTR{22135
{{BNZ{13,SCLEN(XR){6,DMP03{{JUMP IF NON-SYSTEM VARIABLE{22136
{{MOV{13,VRSVO(XR){7,XR{{ELSE LOAD PTR TO NAME IN SVBLK{22137
*
*      HERE WITH NAME POINTER FOR NEW BLOCK IN XR
*
{DMP03{MOV{7,XR{8,WB{{SAVE POINTER TO CHARS{22141
{{MOV{8,WA{3,DMPSV{{SAVE HASH BUCKET POINTER{22142
{{MOV{20,=DMVCH{8,WA{{POINT TO CHAIN HEAD{22143
*
*      LOOP TO SEARCH CHAIN FOR CORRECT INSERTION POINT
*
{DMP04{MOV{8,WA{3,DMPCH{{SAVE CHAIN POINTER{22147
{{MOV{8,WA{7,XL{{COPY IT{22148
{{MOV{9,(XL){7,XR{{LOAD POINTER TO NEXT ENTRY{22149
{{BZE{7,XR{6,DMP08{{JUMP IF END OF CHAIN TO INSERT{22150
{{ADD{19,*VRSOF{7,XR{{ELSE GET NAME PTR FOR CHAINED VRBLK{22151
{{BNZ{13,SCLEN(XR){6,DMP05{{JUMP IF NOT SYSTEM VARIABLE{22152
{{MOV{13,VRSVO(XR){7,XR{{ELSE POINT TO NAME IN SVBLK{22153
*
*      HERE PREPARE TO COMPARE THE NAMES
*
*      (WA)                  SCRATCH
*      (WB)                  POINTER TO STRING OF ENTERING VRBLK
*      (WC)                  POINTER TO ENTERING VRBLK
*      (XR)                  POINTER TO STRING OF CURRENT BLOCK
*      (XL)                  SCRATCH
*
{DMP05{MOV{8,WB{7,XL{{POINT TO ENTERING VRBLK STRING{22163
{{MOV{13,SCLEN(XL){8,WA{{LOAD ITS LENGTH{22164
{{PLC{7,XL{{{POINT TO CHARS OF ENTERING STRING{22165
{{BHI{8,WA{13,SCLEN(XR){6,DMP06{JUMP IF ENTERING LENGTH HIGH{22188
{{PLC{7,XR{{{ELSE POINT TO CHARS OF OLD STRING{22189
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW IS LLT OLD{22190
{{BRN{6,DMP08{{{OR IF LEQ (WE HAD SHORTER LENGTH){22191
*
*      HERE WHEN NEW LENGTH IS LONGER THAN OLD LENGTH
*
{DMP06{MOV{13,SCLEN(XR){8,WA{{LOAD SHORTER LENGTH{22195
{{PLC{7,XR{{{POINT TO CHARS OF OLD STRING{22196
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW ONE LOW{22197
{{EJC{{{{{22198
*
*      DUMPR (CONTINUED)
*
*      HERE WE MOVE OUT ON THE CHAIN
*
{DMP07{MOV{3,DMPCH{7,XL{{COPY CHAIN POINTER{22204
{{MOV{9,(XL){8,WA{{MOVE TO NEXT ENTRY ON CHAIN{22206
{{BRN{6,DMP04{{{LOOP BACK{22207
*
*      HERE AFTER LOCATING THE PROPER INSERTION POINT
*
{DMP08{MOV{3,DMPCH{7,XL{{COPY CHAIN POINTER{22211
{{MOV{3,DMPSV{8,WA{{RESTORE HASH BUCKET POINTER{22212
{{MOV{8,WC{7,XR{{RESTORE VRBLK POINTER{22213
{{MOV{9,(XL){13,VRGET(XR){{LINK VRBLK TO REST OF CHAIN{22214
{{MOV{7,XR{9,(XL){{LINK VRBLK INTO CURRENT CHAIN LOC{22215
{{BRN{6,DMP01{{{LOOP BACK FOR NEXT VRBLK{22216
*
*      HERE AFTER PROCESSING ALL VRBLKS ON ONE CHAIN
*
{DMP09{BNE{8,WA{3,HSHTE{6,DMP00{LOOP BACK IF MORE BUCKETS TO GO{22220
*
*      LOOP TO GENERATE DUMP OF NATURAL VARIABLE VALUES
*
{DMP10{MOV{3,DMVCH{7,XR{{LOAD POINTER TO NEXT ENTRY ON CHAIN{22224
{{BZE{7,XR{6,DMP11{{JUMP IF END OF CHAIN{22225
{{MOV{9,(XR){3,DMVCH{{ELSE UPDATE CHAIN PTR TO NEXT ENTRY{22226
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{22227
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER (NAME BASE){22228
{{MOV{19,*VRVAL{8,WA{{SET OFFSET FOR VRBLK NAME{22229
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{22230
{{BRN{6,DMP10{{{LOOP BACK TILL ALL PRINTED{22231
*
*      PREPARE TO PRINT KEYWORDS
*
{DMP11{JSR{6,PRTNL{{{PRINT BLANK LINE{22235
{{JSR{6,PRTNL{{{AND ANOTHER{22236
{{MOV{21,=DMHDK{7,XR{{POINT TO KEYWORD HEADING{22237
{{JSR{6,PRTST{{{PRINT HEADING{22238
{{JSR{6,PRTNL{{{END LINE{22239
{{JSR{6,PRTNL{{{PRINT ONE BLANK LINE{22240
{{MOV{21,=VDMKW{7,XL{{POINT TO LIST OF KEYWORD SVBLK PTRS{22241
{{EJC{{{{{22242
*
*      DUMPR (CONTINUED)
*
*      LOOP TO DUMP KEYWORD VALUES
*
{DMP12{MOV{10,(XL)+{7,XR{{LOAD NEXT SVBLK PTR FROM TABLE{22248
{{BZE{7,XR{6,DMP13{{JUMP IF END OF LIST{22249
{{BEQ{7,XR{18,=NUM01{6,DMP12{&COMPARE IGNORED IF NOT IMPLEMENTED{22251
{{MOV{18,=CH$AM{8,WA{{LOAD AMPERSAND{22253
{{JSR{6,PRTCH{{{PRINT AMPERSAND{22254
{{JSR{6,PRTST{{{PRINT KEYWORD NAME{22255
{{MOV{13,SVLEN(XR){8,WA{{LOAD NAME LENGTH FROM SVBLK{22256
{{CTB{8,WA{2,SVCHS{{GET LENGTH OF NAME{22257
{{ADD{8,WA{7,XR{{POINT TO SVKNM FIELD{22258
{{MOV{9,(XR){3,DMPKN{{STORE IN DUMMY KVBLK{22259
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK-EQUAL-BLANK{22260
{{JSR{6,PRTST{{{PRINT IT{22261
{{MOV{7,XL{3,DMPSV{{SAVE TABLE POINTER{22262
{{MOV{20,=DMPKB{7,XL{{POINT TO DUMMY KVBLK{22263
{{MOV{22,=B$KVT{9,(XL){{BUILD TYPE WORD{22264
{{MOV{21,=TRBKV{13,KVVAR(XL){{BUILD PTR TO DUMMY TRACE BLOCK{22265
{{MOV{19,*KVVAR{8,WA{{SET ZERO OFFSET{22266
{{JSR{6,ACESS{{{GET KEYWORD VALUE{22267
{{PPM{{{{FAILURE IS IMPOSSIBLE{22268
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{22269
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{22270
{{MOV{3,DMPSV{7,XL{{RESTORE TABLE POINTER{22271
{{BRN{6,DMP12{{{LOOP BACK TILL ALL PRINTED{22272
*
*      HERE AFTER COMPLETING PARTIAL DUMP
*
{DMP13{BEQ{3,DMARG{18,=NUM01{6,DMP27{EXIT IF PARTIAL DUMP COMPLETE{22276
{{MOV{3,DNAMB{7,XR{{ELSE POINT TO FIRST DYNAMIC BLOCK{22277
*
*      LOOP THROUGH BLOCKS IN DYNAMIC STORAGE
*
{DMP14{BEQ{7,XR{3,DNAMP{6,DMP27{JUMP IF END OF USED REGION{22281
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF BLOCK{22282
{{BEQ{8,WA{22,=B$VCT{6,DMP16{JUMP IF VECTOR{22283
{{BEQ{8,WA{22,=B$ART{6,DMP17{JUMP IF ARRAY{22284
{{BEQ{8,WA{22,=B$PDT{6,DMP18{JUMP IF PROGRAM DEFINED{22285
{{BEQ{8,WA{22,=B$TBT{6,DMP19{JUMP IF TABLE{22286
*
*      MERGE HERE TO MOVE TO NEXT BLOCK
*
{DMP15{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{22294
{{ADD{8,WA{7,XR{{POINT PAST THIS BLOCK{22295
{{BRN{6,DMP14{{{LOOP BACK FOR NEXT BLOCK{22296
{{EJC{{{{{22297
*
*      DUMPR (CONTINUED)
*
*      HERE FOR VECTOR
*
{DMP16{MOV{19,*VCVLS{8,WB{{SET OFFSET TO FIRST VALUE{22303
{{BRN{6,DMP19{{{JUMP TO MERGE{22304
*
*      HERE FOR ARRAY
*
{DMP17{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO ARPRO FIELD{22308
{{ICA{8,WB{{{BUMP TO GET OFFSET TO VALUES{22309
{{BRN{6,DMP19{{{JUMP TO MERGE{22310
*
*      HERE FOR PROGRAM DEFINED
*
{DMP18{MOV{19,*PDFLD{8,WB{{POINT TO VALUES, MERGE{22314
*
*      HERE FOR TABLE (OTHERS MERGE)
*
{DMP19{BZE{13,IDVAL(XR){6,DMP15{{IGNORE BLOCK IF ZERO ID VALUE{22318
{{JSR{6,BLKLN{{{ELSE GET BLOCK LENGTH{22319
{{MOV{7,XR{7,XL{{COPY BLOCK POINTER{22320
{{MOV{8,WA{3,DMPSV{{SAVE LENGTH{22321
{{MOV{8,WB{8,WA{{COPY OFFSET TO FIRST VALUE{22322
{{JSR{6,PRTNL{{{PRINT BLANK LINE{22323
{{MOV{8,WA{3,DMPSA{{PRESERVE OFFSET{22324
{{JSR{6,PRTVL{{{PRINT BLOCK VALUE (FOR TITLE){22325
{{MOV{3,DMPSA{8,WA{{RECOVER OFFSET{22326
{{JSR{6,PRTNL{{{END PRINT LINE{22327
{{BEQ{9,(XR){22,=B$TBT{6,DMP22{JUMP IF TABLE{22328
{{DCA{8,WA{{{POINT BEFORE FIRST WORD{22329
*
*      LOOP TO PRINT CONTENTS OF ARRAY, VECTOR, OR PROGRAM DEF
*
{DMP20{MOV{7,XL{7,XR{{COPY BLOCK POINTER{22333
{{ICA{8,WA{{{BUMP OFFSET{22334
{{ADD{8,WA{7,XR{{POINT TO NEXT VALUE{22335
{{BEQ{8,WA{3,DMPSV{6,DMP14{EXIT IF END (XR PAST BLOCK){22336
{{SUB{19,*VRVAL{7,XR{{SUBTRACT OFFSET TO MERGE INTO LOOP{22337
*
*      LOOP TO FIND VALUE AND IGNORE NULLS
*
{DMP21{MOV{13,VRVAL(XR){7,XR{{LOAD NEXT VALUE{22341
{{BEQ{3,DMARG{18,=NUM03{6,DMP2B{SKIP NULL VALUE CHECK IF DUMP(3){22342
{{BEQ{7,XR{21,=NULLS{6,DMP20{LOOP BACK IF NULL VALUE{22343
{DMP2B{BEQ{9,(XR){22,=B$TRT{6,DMP21{LOOP BACK IF TRAPPED{22344
{{JSR{6,PRTNV{{{ELSE PRINT NAME = VALUE{22345
{{BRN{6,DMP20{{{LOOP BACK FOR NEXT FIELD{22346
{{EJC{{{{{22347
*
*      DUMPR (CONTINUED)
*
*      HERE TO DUMP A TABLE
*
{DMP22{MOV{19,*TBBUK{8,WC{{SET OFFSET TO FIRST BUCKET{22353
{{MOV{19,*TEVAL{8,WA{{SET NAME OFFSET FOR ALL TEBLKS{22354
*
*      LOOP THROUGH TABLE BUCKETS
*
{DMP23{MOV{7,XL{11,-(XS){{SAVE TBBLK POINTER{22358
{{ADD{8,WC{7,XL{{POINT TO NEXT BUCKET HEADER{22359
{{ICA{8,WC{{{BUMP BUCKET OFFSET{22360
{{SUB{19,*TENXT{7,XL{{SUBTRACT OFFSET TO MERGE INTO LOOP{22361
*
*      LOOP TO PROCESS TEBLKS ON ONE CHAIN
*
{DMP24{MOV{13,TENXT(XL){7,XL{{POINT TO NEXT TEBLK{22365
{{BEQ{7,XL{9,(XS){6,DMP26{JUMP IF END OF CHAIN{22366
{{MOV{7,XL{7,XR{{ELSE COPY TEBLK POINTER{22367
*
*      LOOP TO FIND VALUE AND IGNORE IF NULL
*
{DMP25{MOV{13,TEVAL(XR){7,XR{{LOAD NEXT VALUE{22371
{{BEQ{7,XR{21,=NULLS{6,DMP24{IGNORE IF NULL VALUE{22372
{{BEQ{9,(XR){22,=B$TRT{6,DMP25{LOOP BACK IF TRAPPED{22373
{{MOV{8,WC{3,DMPSV{{ELSE SAVE OFFSET POINTER{22374
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{22375
{{MOV{3,DMPSV{8,WC{{RELOAD OFFSET{22376
{{BRN{6,DMP24{{{LOOP BACK FOR NEXT TEBLK{22377
*
*      HERE TO MOVE TO NEXT HASH CHAIN
*
{DMP26{MOV{10,(XS)+{7,XL{{RESTORE TBBLK POINTER{22381
{{BNE{8,WC{13,TBLEN(XL){6,DMP23{LOOP BACK IF MORE BUCKETS TO GO{22382
{{MOV{7,XL{7,XR{{ELSE COPY TABLE POINTER{22383
{{ADD{8,WC{7,XR{{POINT TO FOLLOWING BLOCK{22384
{{BRN{6,DMP14{{{LOOP BACK TO PROCESS NEXT BLOCK{22385
*
*      HERE AFTER COMPLETING DUMP
*
{DMP27{JSR{6,PRTPG{{{EJECT PRINTER{22389
*
*      MERGE HERE IF NO DUMP GIVEN (DMARG=0)
*
{DMP28{EXI{{{{RETURN TO DUMP CALLER{22393
*
*      CALL SYSTEM CORE DUMP ROUTINE
*
{DMP29{JSR{6,SYSDM{{{CALL IT{22397
{{BRN{6,DMP28{{{RETURN{22398
{{ENP{{{{END PROCEDURE DUMPR{22434
{{EJC{{{{{22435
*
*      ERMSG -- PRINT ERROR CODE AND ERROR MESSAGE
*
*      KVERT                 ERROR CODE
*      JSR  ERMSG            CALL TO PRINT MESSAGE
*      (XR,XL,WA,WB,WC,IA)   DESTROYED
*
{ERMSG{PRC{25,E{1,0{{ENTRY POINT{22443
{{MOV{3,KVERT{8,WA{{LOAD ERROR CODE{22444
{{MOV{21,=ERMMS{7,XR{{POINT TO ERROR MESSAGE /ERROR/{22445
{{JSR{6,PRTST{{{PRINT IT{22446
{{JSR{6,ERTEX{{{GET ERROR MESSAGE TEXT{22447
{{ADD{18,=THSND{8,WA{{BUMP ERROR CODE FOR PRINT{22448
{{MTI{8,WA{{{FAIL CODE IN INT ACC{22449
{{MOV{3,PROFS{8,WB{{SAVE CURRENT BUFFER POSITION{22450
{{JSR{6,PRTIN{{{PRINT CODE (NOW HAVE ERROR1XXX){22451
{{MOV{3,PRBUF{7,XL{{POINT TO PRINT BUFFER{22452
{{PSC{7,XL{8,WB{{POINT TO THE 1{22453
{{MOV{18,=CH$BL{8,WA{{LOAD A BLANK{22454
{{SCH{8,WA{9,(XL){{STORE BLANK OVER 1 (ERROR XXX){22455
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{22456
{{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{22457
{{MOV{7,XR{8,WA{{KEEP ERROR TEXT{22458
{{MOV{21,=ERMNS{7,XR{{POINT TO / -- /{22459
{{JSR{6,PRTST{{{PRINT IT{22460
{{MOV{8,WA{7,XR{{GET ERROR TEXT AGAIN{22461
{{JSR{6,PRTST{{{PRINT ERROR MESSAGE TEXT{22462
{{JSR{6,PRTIS{{{PRINT LINE{22463
{{JSR{6,PRTIS{{{PRINT BLANK LINE{22464
{{EXI{{{{RETURN TO ERMSG CALLER{22465
{{ENP{{{{END PROCEDURE ERMSG{22466
{{EJC{{{{{22467
*
*      ERTEX -- GET ERROR MESSAGE TEXT
*
*      (WA)                  ERROR CODE
*      JSR  ERTEX            CALL TO GET ERROR TEXT
*      (XR)                  PTR TO ERROR TEXT IN DYNAMIC
*      (R$ETX)               COPY OF PTR TO ERROR TEXT
*      (XL,WC,IA)            DESTROYED
*
{ERTEX{PRC{25,E{1,0{{ENTRY POINT{22477
{{MOV{8,WA{3,ERTWA{{SAVE WA{22478
{{MOV{8,WB{3,ERTWB{{SAVE WB{22479
{{JSR{6,SYSEM{{{GET FAILURE MESSAGE TEXT{22480
{{MOV{7,XR{7,XL{{COPY POINTER TO IT{22481
{{MOV{13,SCLEN(XR){8,WA{{GET LENGTH OF STRING{22482
{{BZE{8,WA{6,ERT02{{JUMP IF NULL{22483
{{ZER{8,WB{{{OFFSET OF ZERO{22484
{{JSR{6,SBSTR{{{COPY INTO DYNAMIC STORE{22485
{{MOV{7,XR{3,R$ETX{{STORE FOR RELOCATION{22486
*
*      RETURN
*
{ERT01{MOV{3,ERTWB{8,WB{{RESTORE WB{22490
{{MOV{3,ERTWA{8,WA{{RESTORE WA{22491
{{EXI{{{{RETURN TO CALLER{22492
*
*      RETURN ERRTEXT CONTENTS INSTEAD OF NULL
*
{ERT02{MOV{3,R$ETX{7,XR{{GET ERRTEXT{22496
{{BRN{6,ERT01{{{RETURN{22497
{{ENP{{{{{22498
{{EJC{{{{{22499
*
*      EVALI -- EVALUATE INTEGER ARGUMENT
*
*      EVALI IS USED BY PATTERN PRIMITIVES LEN,TAB,RTAB,POS,RPOS
*      WHEN THEIR ARGUMENT IS AN EXPRESSION VALUE.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALI            CALL TO EVALUATE INTEGER
*      PPM  LOC              TRANSFER LOC FOR NON-INTEGER ARG
*      PPM  LOC              TRANSFER LOC FOR OUT OF RANGE ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH INTEGER ARGUMENT
*      (WC,XL,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS THE INTEGER ARGUMENT
*      IN PARM1 AND THE PROPER SUCCESSOR POINTER IN PTHEN.
*      THIS ALLOWS MERGING WITH THE NORMAL (INTEGER ARG) CASE.
*
{EVALI{PRC{25,R{1,4{{ENTRY POINT (RECURSIVE){22521
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{22522
{{PPM{6,EVLI1{{{JUMP ON FAILURE{22523
{{MOV{7,XL{11,-(XS){{STACK RESULT FOR GTSMI{22524
{{MOV{13,PTHEN(XR){7,XL{{LOAD SUCCESSOR POINTER{22525
{{MOV{7,XR{3,EVLIO{{SAVE ORIGINAL NODE POINTER{22526
{{MOV{8,WC{3,EVLIF{{ZERO IF SIMPLE ARGUMENT{22527
{{JSR{6,GTSMI{{{CONVERT ARG TO SMALL INTEGER{22528
{{PPM{6,EVLI2{{{JUMP IF NOT INTEGER{22529
{{PPM{6,EVLI3{{{JUMP IF OUT OF RANGE{22530
{{MOV{7,XR{3,EVLIV{{STORE RESULT IN SPECIAL DUMMY NODE{22531
{{MOV{20,=EVLIN{7,XR{{POINT TO DUMMY NODE WITH RESULT{22532
{{MOV{22,=P$LEN{9,(XR){{DUMMY PATTERN BLOCK PCODE{22533
{{MOV{7,XL{13,PTHEN(XR){{STORE SUCCESSOR POINTER{22534
{{EXI{1,4{{{TAKE SUCCESSFUL EXIT{22535
*
*      HERE IF EVALUATION FAILS
*
{EVLI1{EXI{1,3{{{TAKE FAILURE RETURN{22539
*
*      HERE IF ARGUMENT IS NOT INTEGER
*
{EVLI2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{22543
*
*      HERE IF ARGUMENT IS OUT OF RANGE
*
{EVLI3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{22547
{{ENP{{{{END PROCEDURE EVALI{22548
{{EJC{{{{{22549
*
*      EVALP -- EVALUATE EXPRESSION DURING PATTERN MATCH
*
*      EVALP IS USED TO EVALUATE AN EXPRESSION (BY VALUE) DURING
*      A PATTERN MATCH. THE EFFECT IS LIKE EVALX, BUT PATTERN
*      VARIABLES ARE STACKED AND RESTORED IF NECESSARY.
*
*      EVALP ALSO DIFFERS FROM EVALX IN THAT IF THE RESULT IS
*      AN EXPRESSION IT IS REEVALUATED. THIS OCCURS REPEATEDLY.
*
*      TO SUPPORT OPTIMIZATION OF POS AND RPOS, EVALP USES WC
*      TO SIGNAL THE CALLER FOR THE CASE OF A SIMPLE VRBLK
*      THAT IS NOT AN EXPRESSION AND IS NOT TRAPPED.  BECAUSE
*      THIS CASE CANNOT HAVE ANY SIDE EFFECTS, OPTIMIZATION IS
*      POSSIBLE.
*
*      (XR)                  NODE POINTER
*      (WB)                  PATTERN MATCH CURSOR
*      JSR  EVALP            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XL)                  RESULT
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WC)                  ZERO IF SIMPLE VRBLK, ELSE NON-ZERO
*      (XR,WB)               DESTROYED (FAILURE CASE ONLY)
*      (RA)                  DESTROYED
*
*      THE EXPRESSION POINTER IS STORED IN PARM1 OF THE NODE
*
*      CONTROL RETURNS TO FAILP ON FAILURE OF EVALUATION
*
{EVALP{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){22580
{{MOV{13,PARM1(XR){7,XL{{LOAD EXPRESSION POINTER{22581
{{BEQ{9,(XL){22,=B$EXL{6,EVLP1{JUMP IF EXBLK CASE{22582
*
*      HERE FOR CASE OF SEBLK
*
*      WE CAN GIVE A FAST RETURN IF THE VALUE OF THE VRBLK IS
*      NOT AN EXPRESSION AND IS NOT TRAPPED.
*
{{MOV{13,SEVAR(XL){7,XL{{LOAD VRBLK POINTER{22589
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE OF VRBLK{22590
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF VALUE{22591
{{BHI{8,WA{22,=B$T$${6,EVLP3{JUMP IF NOT SEBLK, TRBLK OR EXBLK{22592
*
*      HERE FOR EXBLK OR SEBLK WITH EXPR VALUE OR TRAPPED VALUE
*
{EVLP1{CHK{{{{CHECK FOR STACK SPACE{22596
{{MOV{7,XR{11,-(XS){{STACK NODE POINTER{22597
{{MOV{8,WB{11,-(XS){{STACK CURSOR{22598
{{MOV{3,R$PMS{11,-(XS){{STACK SUBJECT STRING POINTER{22599
{{MOV{3,PMSSL{11,-(XS){{STACK SUBJECT STRING LENGTH{22600
{{MOV{3,PMDFL{11,-(XS){{STACK DOT FLAG{22601
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE POINTER{22602
{{MOV{13,PARM1(XR){7,XR{{LOAD EXPRESSION POINTER{22603
{{EJC{{{{{22604
*
*      EVALP (CONTINUED)
*
*      LOOP BACK HERE TO REEVALUATE EXPRESSION RESULT
*
{EVLP2{ZER{8,WB{{{SET FLAG FOR BY VALUE{22610
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{22611
{{PPM{6,EVLP4{{{JUMP ON FAILURE{22612
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF VALUE{22613
{{BLO{8,WA{22,=B$E$${6,EVLP2{LOOP BACK TO REEVALUATE EXPRESSION{22614
*
*      HERE TO RESTORE PATTERN VALUES AFTER SUCCESSFUL EVAL
*
{{MOV{7,XR{7,XL{{COPY RESULT POINTER{22618
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{22619
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{22620
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{22621
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{22622
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{22623
{{MOV{10,(XS)+{7,XR{{RESTORE NODE POINTER{22624
{{MOV{7,XR{8,WC{{NON-ZERO FOR SIMPLE VRBLK{22625
{{EXI{{{{RETURN TO EVALP CALLER{22626
*
*      HERE TO RETURN AFTER SIMPLE VRBLK CASE
*
{EVLP3{ZER{8,WC{{{SIMPLE VRBLK, NO SIDE EFFECTS{22630
{{EXI{{{{RETURN TO EVALP CALLER{22631
*
*      HERE FOR FAILURE DURING EVALUATION
*
{EVLP4{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{22635
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{22636
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{22637
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{22638
{{ADD{19,*NUM02{7,XS{{REMOVE NODE PTR, CURSOR{22639
{{EXI{1,1{{{TAKE FAILURE EXIT{22640
{{ENP{{{{END PROCEDURE EVALP{22641
{{EJC{{{{{22642
*
*      EVALS -- EVALUATE STRING ARGUMENT
*
*      EVALS IS USED BY SPAN, ANY, NOTANY, BREAK, BREAKX WHEN
*      THEY ARE PASSED AN EXPRESSION ARGUMENT.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALS            CALL TO EVALUATE STRING
*      PPM  LOC              TRANSFER LOC FOR NON-STRING ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH PARMS SET
*      (XL,WC,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS A CHARACTER TABLE
*      POINTER IN PARM1 AND A BIT MASK IN PARM2. THE PROPER
*      SUCCESSOR IS STORED IN PTHEN OF THIS NODE. THUS IT IS
*      OK FOR MERGING WITH THE NORMAL (MULTI-CHAR STRING) CASE.
*
{EVALS{PRC{25,R{1,3{{ENTRY POINT (RECURSIVE){22664
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{22665
{{PPM{6,EVLS1{{{JUMP IF EVALUATION FAILS{22666
{{MOV{13,PTHEN(XR){11,-(XS){{SAVE SUCCESSOR POINTER{22667
{{MOV{8,WB{11,-(XS){{SAVE CURSOR{22668
{{MOV{7,XL{11,-(XS){{STACK RESULT PTR FOR PATST{22669
{{ZER{8,WB{{{DUMMY PCODE FOR ONE CHAR STRING{22670
{{ZER{8,WC{{{DUMMY PCODE FOR EXPRESSION ARG{22671
{{MOV{22,=P$BRK{7,XL{{APPROPRIATE PCODE FOR OUR USE{22672
{{JSR{6,PATST{{{CALL ROUTINE TO BUILD NODE{22673
{{PPM{6,EVLS2{{{JUMP IF NOT STRING{22674
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{22675
{{MOV{10,(XS)+{13,PTHEN(XR){{STORE SUCCESSOR POINTER{22676
{{EXI{1,3{{{TAKE SUCCESS RETURN{22677
*
*      HERE IF EVALUATION FAILS
*
{EVLS1{EXI{1,2{{{TAKE FAILURE RETURN{22681
*
*      HERE IF ARGUMENT IS NOT STRING
*
{EVLS2{ADD{19,*NUM02{7,XS{{POP SUCCESSOR AND CURSOR{22685
{{EXI{1,1{{{TAKE NON-STRING ERROR EXIT{22686
{{ENP{{{{END PROCEDURE EVALS{22687
{{EJC{{{{{22688
*
*      EVALX -- EVALUATE EXPRESSION
*
*      EVALX IS CALLED TO EVALUATE AN EXPRESSION
*
*      (XR)                  POINTER TO EXBLK OR SEBLK
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      JSR  EVALX            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XR)                  RESULT IF CALLED BY VALUE
*      (XL,WA)               RESULT NAME BASE,OFFSET IF BY NAME
*      (XR)                  DESTROYED (NAME CASE ONLY)
*      (XL,WA)               DESTROYED (VALUE CASE ONLY)
*      (WB,WC,RA)            DESTROYED
*
{EVALX{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{22704
{{BEQ{9,(XR){22,=B$EXL{6,EVLX2{JUMP IF EXBLK CASE{22705
*
*      HERE FOR SEBLK
*
{{MOV{13,SEVAR(XR){7,XL{{LOAD VRBLK POINTER (NAME BASE){22709
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{22710
{{BNZ{8,WB{6,EVLX1{{JUMP IF CALLED BY NAME{22711
{{JSR{6,ACESS{{{CALL ROUTINE TO ACCESS VALUE{22712
{{PPM{6,EVLX9{{{JUMP IF FAILURE ON ACCESS{22713
*
*      MERGE HERE TO EXIT FOR SEBLK CASE
*
{EVLX1{EXI{{{{RETURN TO EVALX CALLER{22717
{{EJC{{{{{22718
*
*      EVALX (CONTINUED)
*
*      HERE FOR FULL EXPRESSION (EXBLK) CASE
*
*      IF AN ERROR OCCURS IN THE EXPRESSION CODE AT EXECUTION
*      TIME, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*      THE FOLLOWING ENTRIES ARE MADE ON THE STACK BEFORE
*      GIVING CONTROL TO THE EXPRESSION CODE
*
*                            EVALX RETURN POINT
*                            SAVED VALUE OF R$COD
*                            CODE POINTER (-R$COD)
*                            SAVED VALUE OF FLPTR
*                            0 IF BY VALUE, 1 IF BY NAME
*      FLPTR --------------- *EXFLC, FAIL OFFSET IN EXBLK
*
{EVLX2{SCP{8,WC{{{GET CODE POINTER{22737
{{MOV{3,R$COD{8,WA{{LOAD CODE BLOCK POINTER{22738
{{SUB{8,WA{8,WC{{GET CODE POINTER AS OFFSET{22739
{{MOV{8,WA{11,-(XS){{STACK OLD CODE BLOCK POINTER{22740
{{MOV{8,WC{11,-(XS){{STACK RELATIVE CODE OFFSET{22741
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{22742
{{MOV{8,WB{11,-(XS){{STACK NAME/VALUE INDICATOR{22743
{{MOV{19,*EXFLC{11,-(XS){{STACK NEW FAIL OFFSET{22744
{{MOV{3,FLPTR{3,GTCEF{{KEEP IN CASE OF ERROR{22745
{{MOV{3,R$COD{3,R$GTC{{KEEP CODE BLOCK POINTER SIMILARLY{22746
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{22747
{{MOV{7,XR{3,R$COD{{SET NEW CODE BLOCK POINTER{22748
{{MOV{3,KVSTN{13,EXSTM(XR){{REMEMBER STMNT NUMBER{22749
{{ADD{19,*EXCOD{7,XR{{POINT TO FIRST CODE WORD{22750
{{LCP{7,XR{{{SET CODE POINTER{22751
{{BNE{3,STAGE{18,=STGXT{6,EVLX0{JUMP IF NOT EXECUTION TIME{22752
{{MOV{18,=STGEE{3,STAGE{{EVALUATING EXPRESSION{22753
*
*      HERE TO EXECUTE FIRST CODE WORD OF EXPRESSION
*
{EVLX0{ZER{7,XL{{{CLEAR GARBAGE XL{22757
{{LCW{7,XR{{{LOAD FIRST CODE WORD{22758
{{BRI{9,(XR){{{EXECUTE IT{22759
{{EJC{{{{{22760
*
*      EVALX (CONTINUED)
*
*      COME HERE IF SUCCESSFUL RETURN BY VALUE (SEE O$RVL)
*
{EVLX3{MOV{10,(XS)+{7,XR{{LOAD VALUE{22766
{{BZE{13,NUM01(XS){6,EVLX5{{JUMP IF CALLED BY VALUE{22767
{{ERB{1,249{26,Expression evaluated by name returned value{{{22768
*
*      HERE FOR EXPRESSION RETURNING BY NAME (SEE O$RNM)
*
{EVLX4{MOV{10,(XS)+{8,WA{{LOAD NAME OFFSET{22772
{{MOV{10,(XS)+{7,XL{{LOAD NAME BASE{22773
{{BNZ{13,NUM01(XS){6,EVLX5{{JUMP IF CALLED BY NAME{22774
{{JSR{6,ACESS{{{ELSE ACCESS VALUE FIRST{22775
{{PPM{6,EVLX6{{{JUMP IF FAILURE DURING ACCESS{22776
*
*      HERE AFTER LOADING CORRECT RESULT INTO XR OR XL,WA
*
{EVLX5{ZER{8,WB{{{NOTE SUCCESSFUL{22780
{{BRN{6,EVLX7{{{MERGE{22781
*
*      HERE FOR FAILURE IN EXPRESSION EVALUATION (SEE O$FEX)
*
{EVLX6{MNZ{8,WB{{{NOTE UNSUCCESSFUL{22785
*
*      RESTORE ENVIRONMENT
*
{EVLX7{BNE{3,STAGE{18,=STGEE{6,EVLX8{SKIP IF WAS NOT PREVIOUSLY XT{22789
{{MOV{18,=STGXT{3,STAGE{{EXECUTE TIME{22790
*
*      MERGE WITH STAGE SET UP
*
{EVLX8{ADD{19,*NUM02{7,XS{{POP NAME/VALUE INDICATOR, *EXFAL{22794
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{22795
{{MOV{10,(XS)+{8,WC{{LOAD CODE OFFSET{22796
{{ADD{9,(XS){8,WC{{MAKE CODE POINTER ABSOLUTE{22797
{{MOV{10,(XS)+{3,R$COD{{RESTORE OLD CODE BLOCK POINTER{22798
{{LCP{8,WC{{{RESTORE OLD CODE POINTER{22799
{{BZE{8,WB{6,EVLX1{{JUMP FOR SUCCESSFUL RETURN{22800
*
*      MERGE HERE FOR FAILURE IN SEBLK CASE
*
{EVLX9{EXI{1,1{{{TAKE FAILURE EXIT{22804
{{ENP{{{{END OF PROCEDURE EVALX{22805
{{EJC{{{{{22806
*
*      EXBLD -- BUILD EXBLK
*
*      EXBLD IS USED TO BUILD AN EXPRESSION BLOCK FROM THE
*      CODE COMPILED MOST RECENTLY IN THE CURRENT CCBLK.
*
*      (XL)                  OFFSET IN CCBLK TO START OF CODE
*      (WB)                  INTEGER IN RANGE 0 LE N LE MXLEN
*      JSR  EXBLD            CALL TO BUILD EXBLK
*      (XR)                  PTR TO CONSTRUCTED EXBLK
*      (WA,WB,XL)            DESTROYED
*
{EXBLD{PRC{25,E{1,0{{ENTRY POINT{22819
{{MOV{7,XL{8,WA{{COPY OFFSET TO START OF CODE{22820
{{SUB{19,*EXCOD{8,WA{{CALC REDUCTION IN OFFSET IN EXBLK{22821
{{MOV{8,WA{11,-(XS){{STACK FOR LATER{22822
{{MOV{3,CWCOF{8,WA{{LOAD FINAL OFFSET{22823
{{SUB{7,XL{8,WA{{COMPUTE LENGTH OF CODE{22824
{{ADD{19,*EXSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{22825
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EXBLK{22826
{{MOV{7,XR{11,-(XS){{SAVE POINTER TO EXBLK{22827
{{MOV{22,=B$EXL{13,EXTYP(XR){{STORE TYPE WORD{22828
{{ZER{13,EXSTM(XR){{{ZEROISE STMNT NUMBER FIELD{22829
{{MOV{3,CMPLN{13,EXSLN(XR){{SET LINE NUMBER FIELD{22831
{{MOV{8,WA{13,EXLEN(XR){{STORE LENGTH{22833
{{MOV{21,=OFEX${13,EXFLC(XR){{STORE FAILURE WORD{22834
{{ADD{19,*EXSI${7,XR{{SET XR FOR MVW{22835
{{MOV{7,XL{3,CWCOF{{RESET OFFSET TO START OF CODE{22836
{{ADD{3,R$CCB{7,XL{{POINT TO START OF CODE{22837
{{SUB{19,*EXSI${8,WA{{LENGTH OF CODE TO MOVE{22838
{{MOV{8,WA{11,-(XS){{STACK LENGTH OF CODE{22839
{{MVW{{{{MOVE CODE TO EXBLK{22840
{{MOV{10,(XS)+{8,WA{{GET LENGTH OF CODE{22841
{{BTW{8,WA{{{CONVERT BYTE COUNT TO WORD COUNT{22842
{{LCT{8,WA{8,WA{{PREPARE COUNTER FOR LOOP{22843
{{MOV{9,(XS){7,XL{{COPY EXBLK PTR, DONT UNSTACK{22844
{{ADD{19,*EXCOD{7,XL{{POINT TO CODE ITSELF{22845
{{MOV{13,NUM01(XS){8,WB{{GET REDUCTION IN OFFSET{22846
*
*      THIS LOOP SEARCHES FOR NEGATION AND SELECTION CODE SO
*      THAT THE OFFSETS COMPUTED WHILST CODE WAS IN CODE BLOCK
*      CAN BE TRANSFORMED TO REDUCED VALUES APPLICABLE IN AN
*      EXBLK.
*
{EXBL1{MOV{10,(XL)+{7,XR{{GET NEXT CODE WORD{22853
{{BEQ{7,XR{21,=OSLA${6,EXBL3{JUMP IF SELECTION FOUND{22854
{{BEQ{7,XR{21,=ONTA${6,EXBL3{JUMP IF NEGATION FOUND{22855
{{BCT{8,WA{6,EXBL1{{LOOP TO END OF CODE{22856
*
*      NO SELECTION FOUND OR MERGE TO EXIT ON TERMINATION
*
{EXBL2{MOV{10,(XS)+{7,XR{{POP EXBLK PTR INTO XR{22860
{{MOV{10,(XS)+{7,XL{{POP REDUCTION CONSTANT{22861
{{EXI{{{{RETURN TO CALLER{22862
{{EJC{{{{{22863
*
*      EXBLD (CONTINUED)
*
*      SELECTION OR NEGATION FOUND
*      REDUCE THE OFFSETS AS NEEDED. OFFSETS OCCUR IN WORDS
*      FOLLOWING CODE WORDS -
*           =ONTA$, =OSLA$, =OSLB$, =OSLC$
*
{EXBL3{SUB{8,WB{10,(XL)+{{ADJUST OFFSET{22872
{{BCT{8,WA{6,EXBL4{{DECREMENT COUNT{22873
*
{EXBL4{BCT{8,WA{6,EXBL5{{DECREMENT COUNT{22875
*
*      CONTINUE SEARCH FOR MORE OFFSETS
*
{EXBL5{MOV{10,(XL)+{7,XR{{GET NEXT CODE WORD{22879
{{BEQ{7,XR{21,=OSLA${6,EXBL3{JUMP IF OFFSET FOUND{22880
{{BEQ{7,XR{21,=OSLB${6,EXBL3{JUMP IF OFFSET FOUND{22881
{{BEQ{7,XR{21,=OSLC${6,EXBL3{JUMP IF OFFSET FOUND{22882
{{BEQ{7,XR{21,=ONTA${6,EXBL3{JUMP IF OFFSET FOUND{22883
{{BCT{8,WA{6,EXBL5{{LOOP{22884
{{BRN{6,EXBL2{{{MERGE TO RETURN{22885
{{ENP{{{{END PROCEDURE EXBLD{22886
{{EJC{{{{{22887
*
*      EXPAN -- ANALYZE EXPRESSION
*
*      THE EXPRESSION ANALYZER (EXPAN) PROCEDURE IS USED TO SCAN
*      AN EXPRESSION AND CONVERT IT INTO A TREE REPRESENTATION.
*      SEE THE DESCRIPTION OF CMBLK IN THE STRUCTURES SECTION
*      FOR DETAILED FORMAT OF TREE BLOCKS.
*
*      THE ANALYZER USES A SIMPLE PRECEDENCE SCHEME IN WHICH
*      OPERANDS AND OPERATORS ARE PLACED ON A SINGLE STACK
*      AND CONDENSATIONS ARE MADE WHEN LOW PRECEDENCE OPERATORS
*      ARE STACKED AFTER A HIGHER PRECEDENCE OPERATOR. A GLOBAL
*      VARIABLE (IN WB) KEEPS TRACK OF THE LEVEL AS FOLLOWS.
*
*      0    SCANNING OUTER LEVEL OF STATEMENT OR EXPRESSION
*      1    SCANNING OUTER LEVEL OF NORMAL GOTO
*      2    SCANNING OUTER LEVEL OF DIRECT GOTO
*      3    SCANNING INSIDE ARRAY BRACKETS
*      4    SCANNING INSIDE GROUPING PARENTHESES
*      5    SCANNING INSIDE FUNCTION PARENTHESES
*
*      THIS VARIABLE IS SAVED ON THE STACK ON ENCOUNTERING A
*      GROUPING AND RESTORED AT THE END OF THE GROUPING.
*
*      ANOTHER GLOBAL VARIABLE (IN WC) COUNTS THE NUMBER OF
*      ITEMS AT ONE GROUPING LEVEL AND IS INCREMENTED FOR EACH
*      COMMA ENCOUNTERED. IT IS STACKED WITH THE LEVEL INDICATOR
*
*      THE SCAN IS CONTROLLED BY A THREE STATE FINITE MACHINE.
*      A GLOBAL VARIABLE STORED IN WA IS THE CURRENT STATE.
*
*      WA=0                  NOTHING SCANNED AT THIS LEVEL
*      WA=1                  OPERAND EXPECTED
*      WA=2                  OPERATOR EXPECTED
*
*      (WB)                  CALL TYPE (SEE BELOW)
*      JSR  EXPAN            CALL TO ANALYZE EXPRESSION
*      (XR)                  POINTER TO RESULTING TREE
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE ENTRY VALUE OF WB INDICATES THE CALL TYPE AS FOLLOWS.
*
*      0    SCANNING EITHER THE MAIN BODY OF A STATEMENT OR THE
*           TEXT OF AN EXPRESSION (FROM EVAL CALL). VALID
*           TERMINATORS ARE COLON, SEMICOLON. THE RESCAN FLAG IS
*           SET TO RETURN THE TERMINATOR ON THE NEXT SCANE CALL.
*
*      1    SCANNING A NORMAL GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT PAREN.
*
*      2    SCANNING A DIRECT GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT BRACKET.
{{EJC{{{{{22940
*
*      EXPAN (CONTINUED)
*
*      ENTRY POINT
*
{EXPAN{PRC{25,E{1,0{{ENTRY POINT{22946
{{ZER{11,-(XS){{{SET TOP OF STACK INDICATOR{22947
{{ZER{8,WA{{{SET INITIAL STATE TO ZERO{22948
{{ZER{8,WC{{{ZERO COUNTER VALUE{22949
*
*      LOOP HERE FOR SUCCESSIVE ENTRIES
*
{EXP01{JSR{6,SCANE{{{SCAN NEXT ELEMENT{22953
{{ADD{8,WA{7,XL{{ADD STATE TO SYNTAX CODE{22954
{{BSW{7,XL{2,T$NES{{SWITCH ON ELEMENT TYPE/STATE{22955
{{IFF{2,T$UO0{6,EXP27{{UNOP, S=0{22992
{{IFF{2,T$UO1{6,EXP27{{UNOP, S=1{22992
{{IFF{2,T$UO2{6,EXP04{{UNOP, S=2{22992
{{IFF{2,T$LP0{6,EXP06{{LEFT PAREN, S=0{22992
{{IFF{2,T$LP1{6,EXP06{{LEFT PAREN, S=1{22992
{{IFF{2,T$LP2{6,EXP04{{LEFT PAREN, S=2{22992
{{IFF{2,T$LB0{6,EXP08{{LEFT BRKT, S=0{22992
{{IFF{2,T$LB1{6,EXP08{{LEFT BRKT, S=1{22992
{{IFF{2,T$LB2{6,EXP09{{LEFT BRKT, S=2{22992
{{IFF{2,T$CM0{6,EXP02{{COMMA, S=0{22992
{{IFF{2,T$CM1{6,EXP05{{COMMA, S=1{22992
{{IFF{2,T$CM2{6,EXP11{{COMMA, S=2{22992
{{IFF{2,T$FN0{6,EXP10{{FUNCTION, S=0{22992
{{IFF{2,T$FN1{6,EXP10{{FUNCTION, S=1{22992
{{IFF{2,T$FN2{6,EXP04{{FUNCTION, S=2{22992
{{IFF{2,T$VA0{6,EXP03{{VARIABLE, S=0{22992
{{IFF{2,T$VA1{6,EXP03{{VARIABLE, STATE ONE{22992
{{IFF{2,T$VA2{6,EXP04{{VARIABLE, S=2{22992
{{IFF{2,T$CO0{6,EXP03{{CONSTANT, S=0{22992
{{IFF{2,T$CO1{6,EXP03{{CONSTANT, S=1{22992
{{IFF{2,T$CO2{6,EXP04{{CONSTANT, S=2{22992
{{IFF{2,T$BO0{6,EXP05{{BINOP, S=0{22992
{{IFF{2,T$BO1{6,EXP05{{BINOP, S=1{22992
{{IFF{2,T$BO2{6,EXP26{{BINOP, S=2{22992
{{IFF{2,T$RP0{6,EXP02{{RIGHT PAREN, S=0{22992
{{IFF{2,T$RP1{6,EXP05{{RIGHT PAREN, S=1{22992
{{IFF{2,T$RP2{6,EXP12{{RIGHT PAREN, S=2{22992
{{IFF{2,T$RB0{6,EXP02{{RIGHT BRKT, S=0{22992
{{IFF{2,T$RB1{6,EXP05{{RIGHT BRKT, S=1{22992
{{IFF{2,T$RB2{6,EXP18{{RIGHT BRKT, S=2{22992
{{IFF{2,T$CL0{6,EXP02{{COLON, S=0{22992
{{IFF{2,T$CL1{6,EXP05{{COLON, S=1{22992
{{IFF{2,T$CL2{6,EXP19{{COLON, S=2{22992
{{IFF{2,T$SM0{6,EXP02{{SEMICOLON, S=0{22992
{{IFF{2,T$SM1{6,EXP05{{SEMICOLON, S=1{22992
{{IFF{2,T$SM2{6,EXP19{{SEMICOLON, S=2{22992
{{ESW{{{{END SWITCH ON ELEMENT TYPE/STATE{22992
{{EJC{{{{{22993
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RBR,RPR,COL,SMC,CMA IN STATE 0
*
*      SET TO RESCAN THE TERMINATOR ENCOUNTERED AND CREATE
*      A NULL CONSTANT (CASE OF OMITTED NULL)
*
{EXP02{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{23002
{{MOV{21,=NULLS{7,XR{{POINT TO NULL, MERGE{23003
*
*      HERE FOR VAR OR CON IN STATES 0,1
*
*      STACK THE VARIABLE/CONSTANT AND SET STATE=2
*
{EXP03{MOV{7,XR{11,-(XS){{STACK POINTER TO OPERAND{23009
{{MOV{18,=NUM02{8,WA{{SET STATE 2{23010
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{23011
*
*      HERE FOR VAR,CON,LPR,FNC,UOP IN STATE 2
*
*      WE RESCAN THE ELEMENT AND CREATE A CONCATENATION OPERATOR
*      THIS IS THE CASE OF THE BLANK CONCATENATION OPERATOR.
*
{EXP04{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{23018
{{MOV{21,=OPDVC{7,XR{{POINT TO CONCAT OPERATOR DV{23019
{{BZE{8,WB{6,EXP4A{{OK IF AT TOP LEVEL{23020
{{MOV{21,=OPDVP{7,XR{{ELSE POINT TO UNMISTAKABLE CONCAT.{23021
*
*      MERGE HERE WHEN XR SET UP WITH PROPER CONCATENATION DVBLK
*
{EXP4A{BNZ{3,SCNBL{6,EXP26{{MERGE BOP IF BLANKS, ELSE ERROR{23025
*      DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{{ERB{1,220{26,Syntax error: Missing operator{{{23027
*
*      HERE FOR CMA,RPR,RBR,COL,SMC,BOP(S=1) BOP(S=0)
*
*      THIS IS AN ERRONOUS CONTRUCTION
*
*EXP05 DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{EXP05{ERB{1,221{26,Syntax error: Missing operand{{{23035
*
*      HERE FOR LPR (S=0,1)
*
{EXP06{MOV{18,=NUM04{7,XL{{SET NEW LEVEL INDICATOR{23039
{{ZER{7,XR{{{SET ZERO VALUE FOR CMOPN{23040
{{EJC{{{{{23041
*
*      EXPAN (CONTINUED)
*
*      MERGE HERE TO STORE OLD LEVEL ON STACK AND START NEW ONE
*
{EXP07{MOV{7,XR{11,-(XS){{STACK CMOPN VALUE{23047
{{MOV{8,WC{11,-(XS){{STACK OLD COUNTER{23048
{{MOV{8,WB{11,-(XS){{STACK OLD LEVEL INDICATOR{23049
{{CHK{{{{CHECK FOR STACK OVERFLOW{23050
{{ZER{8,WA{{{SET NEW STATE TO ZERO{23051
{{MOV{7,XL{8,WB{{SET NEW LEVEL INDICATOR{23052
{{MOV{18,=NUM01{8,WC{{INITIALIZE NEW COUNTER{23053
{{BRN{6,EXP01{{{JUMP TO SCAN NEXT ELEMENT{23054
*
*      HERE FOR LBR (S=0,1)
*
*      THIS IS AN ILLEGAL USE OF LEFT BRACKET
*
{EXP08{ERB{1,222{26,Syntax error: Invalid use of left bracket{{{23060
*
*      HERE FOR LBR (S=2)
*
*      SET NEW LEVEL AND START TO SCAN SUBSCRIPTS
*
{EXP09{MOV{10,(XS)+{7,XR{{LOAD ARRAY PTR FOR CMOPN{23066
{{MOV{18,=NUM03{7,XL{{SET NEW LEVEL INDICATOR{23067
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{23068
*
*      HERE FOR FNC (S=0,1)
*
*      STACK OLD LEVEL AND START TO SCAN ARGUMENTS
*
{EXP10{MOV{18,=NUM05{7,XL{{SET NEW LEV INDIC (XR=VRBLK=CMOPN){23074
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{23075
*
*      HERE FOR CMA (S=2)
*
*      INCREMENT ARGUMENT COUNT AND CONTINUE
*
{EXP11{ICV{8,WC{{{INCREMENT COUNTER{23081
{{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23082
{{ZER{11,-(XS){{{SET NEW LEVEL FOR PARAMETER{23083
{{ZER{8,WA{{{SET NEW STATE{23084
{{BGT{8,WB{18,=NUM02{6,EXP01{LOOP BACK UNLESS OUTER LEVEL{23085
{{ERB{1,223{26,Syntax error: Invalid use of comma{{{23086
{{EJC{{{{{23087
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RPR (S=2)
*
*      AT OUTER LEVEL IN A NORMAL GOTO THIS IS A TERMINATOR
*      OTHERWISE IT MUST TERMINATE A FUNCTION OR GROUPING
*
{EXP12{BEQ{8,WB{18,=NUM01{6,EXP20{END OF NORMAL GOTO{23096
{{BEQ{8,WB{18,=NUM05{6,EXP13{END OF FUNCTION ARGUMENTS{23097
{{BEQ{8,WB{18,=NUM04{6,EXP14{END OF GROUPING / SELECTION{23098
{{ERB{1,224{26,Syntax error: Unbalanced right parenthesis{{{23099
*
*      HERE AT END OF FUNCTION ARGUMENTS
*
{EXP13{MOV{18,=C$FNC{7,XL{{SET CMTYP VALUE FOR FUNCTION{23103
{{BRN{6,EXP15{{{JUMP TO BUILD CMBLK{23104
*
*      HERE FOR END OF GROUPING
*
{EXP14{BEQ{8,WC{18,=NUM01{6,EXP17{JUMP IF END OF GROUPING{23108
{{MOV{18,=C$SEL{7,XL{{ELSE SET CMTYP FOR SELECTION{23109
*
*      MERGE HERE TO BUILD CMBLK FOR LEVEL JUST SCANNED AND
*      TO POP UP TO THE PREVIOUS SCAN LEVEL BEFORE CONTINUING.
*
{EXP15{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23114
{{MOV{8,WC{8,WA{{COPY COUNT{23115
{{ADD{18,=CMVLS{8,WA{{ADD FOR STANDARD FIELDS AT START{23116
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{23117
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23118
{{MOV{22,=B$CMT{9,(XR){{STORE TYPE CODE FOR CMBLK{23119
{{MOV{7,XL{13,CMTYP(XR){{STORE CMBLK NODE TYPE INDICATOR{23120
{{MOV{8,WA{13,CMLEN(XR){{STORE LENGTH{23121
{{ADD{8,WA{7,XR{{POINT PAST END OF BLOCK{23122
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{23123
*
*      LOOP TO MOVE REMAINING WORDS TO CMBLK
*
{EXP16{MOV{10,(XS)+{11,-(XR){{MOVE ONE OPERAND PTR FROM STACK{23127
{{MOV{10,(XS)+{8,WB{{POP TO OLD LEVEL INDICATOR{23128
{{BCT{8,WC{6,EXP16{{LOOP TILL ALL MOVED{23129
{{EJC{{{{{23130
*
*      EXPAN (CONTINUED)
*
*      COMPLETE CMBLK AND STACK POINTER TO IT ON STACK
*
{{SUB{19,*CMVLS{7,XR{{POINT BACK TO START OF BLOCK{23136
{{MOV{10,(XS)+{8,WC{{RESTORE OLD COUNTER{23137
{{MOV{9,(XS){13,CMOPN(XR){{STORE OPERAND PTR IN CMBLK{23138
{{MOV{7,XR{9,(XS){{STACK CMBLK POINTER{23139
{{MOV{18,=NUM02{8,WA{{SET NEW STATE{23140
{{BRN{6,EXP01{{{BACK FOR NEXT ELEMENT{23141
*
*      HERE AT END OF A PARENTHESIZED EXPRESSION
*
{EXP17{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23145
{{MOV{10,(XS)+{7,XR{{RESTORE XR{23146
{{MOV{10,(XS)+{8,WB{{RESTORE OUTER LEVEL{23147
{{MOV{10,(XS)+{8,WC{{RESTORE OUTER COUNT{23148
{{MOV{7,XR{9,(XS){{STORE OPND OVER UNUSED CMOPN VAL{23149
{{MOV{18,=NUM02{8,WA{{SET NEW STATE{23150
{{BRN{6,EXP01{{{BACK FOR NEXT ELE8ENT{23151
*
*      HERE FOR RBR (S=2)
*
*      AT OUTER LEVEL IN A DIRECT GOTO, THIS IS A TERMINATOR.
*      OTHERWISE IT MUST TERMINATE A SUBSCRIPT LIST.
*
{EXP18{MOV{18,=C$ARR{7,XL{{SET CMTYP FOR ARRAY REFERENCE{23158
{{BEQ{8,WB{18,=NUM03{6,EXP15{JUMP TO BUILD CMBLK IF END ARRAYREF{23159
{{BEQ{8,WB{18,=NUM02{6,EXP20{JUMP IF END OF DIRECT GOTO{23160
{{ERB{1,225{26,Syntax error: Unbalanced right bracket{{{23161
{{EJC{{{{{23162
*
*      EXPAN (CONTINUED)
*
*      HERE FOR COL,SMC (S=2)
*
*      ERROR UNLESS TERMINATING STATEMENT BODY AT OUTER LEVEL
*
{EXP19{MNZ{3,SCNRS{{{RESCAN TERMINATOR{23170
{{MOV{8,WB{7,XL{{COPY LEVEL INDICATOR{23171
{{BSW{7,XL{1,6{{SWITCH ON LEVEL INDICATOR{23172
{{IFF{1,0{6,EXP20{{NORMAL OUTER LEVEL{23179
{{IFF{1,1{6,EXP22{{FAIL IF NORMAL GOTO{23179
{{IFF{1,2{6,EXP23{{FAIL IF DIRECT GOTO{23179
{{IFF{1,3{6,EXP24{{FAIL ARRAY BRACKETS{23179
{{IFF{1,4{6,EXP21{{FAIL IF IN GROUPING{23179
{{IFF{1,5{6,EXP21{{FAIL FUNCTION ARGS{23179
{{ESW{{{{END SWITCH ON LEVEL{23179
*
*      HERE AT NORMAL END OF EXPRESSION
*
{EXP20{JSR{6,EXPDM{{{DUMP REMAINING OPERATORS{23183
{{MOV{10,(XS)+{7,XR{{LOAD TREE POINTER{23184
{{ICA{7,XS{{{POP OFF BOTTOM OF STACK MARKER{23185
{{EXI{{{{RETURN TO EXPAN CALLER{23186
*
*      MISSING RIGHT PAREN
*
{EXP21{ERB{1,226{26,Syntax error: Missing right paren{{{23190
*
*      MISSING RIGHT PAREN IN GOTO FIELD
*
{EXP22{ERB{1,227{26,Syntax error: Right paren missing from goto{{{23194
*
*      MISSING BRACKET IN GOTO
*
{EXP23{ERB{1,228{26,Syntax error: Right bracket missing from goto{{{23198
*
*      MISSING ARRAY BRACKET
*
{EXP24{ERB{1,229{26,Syntax error: Missing right array bracket{{{23202
{{EJC{{{{{23203
*
*      EXPAN (CONTINUED)
*
*      LOOP HERE WHEN AN OPERATOR CAUSES AN OPERATOR DUMP
*
{EXP25{MOV{7,XR{3,EXPSV{{{23209
{{JSR{6,EXPOP{{{POP ONE OPERATOR{23210
{{MOV{3,EXPSV{7,XR{{RESTORE OP DV POINTER AND MERGE{23211
*
*      HERE FOR BOP (S=2)
*
*      REMOVE OPERATORS (CONDENSE) FROM STACK UNTIL NO MORE
*      LEFT AT THIS LEVEL OR TOP ONE HAS LOWER PRECEDENCE.
*      LOOP HERE TILL THIS CONDITION IS MET.
*
{EXP26{MOV{13,NUM01(XS){7,XL{{LOAD OPERATOR DVPTR FROM STACK{23219
{{BLE{7,XL{18,=NUM05{6,EXP27{JUMP IF BOTTOM OF STACK LEVEL{23220
{{BLT{13,DVRPR(XR){13,DVLPR(XL){6,EXP25{ELSE POP IF NEW PREC IS LO{23221
*
*      HERE FOR UOP (S=0,1)
*
*      BINARY OPERATOR MERGES AFTER PRECEDENCE CHECK
*
*      THE OPERATOR DV IS STORED ON THE STACK AND THE SCAN
*      CONTINUES AFTER SETTING THE SCAN STATE TO ONE.
*
{EXP27{MOV{7,XR{11,-(XS){{STACK OPERATOR DVPTR ON STACK{23230
{{CHK{{{{CHECK FOR STACK OVERFLOW{23231
{{MOV{18,=NUM01{8,WA{{SET NEW STATE{23232
{{BNE{7,XR{21,=OPDVS{6,EXP01{BACK FOR NEXT ELEMENT UNLESS ={23233
*
*      HERE FOR SPECIAL CASE OF BINARY =. THE SYNTAX ALLOWS A
*      NULL RIGHT ARGUMENT FOR THIS OPERATOR TO BE LEFT
*      OUT. ACCORDINGLY WE RESET TO STATE ZERO TO GET PROPER
*      ACTION ON A TERMINATOR (SUPPLY A NULL CONSTANT).
*
{{ZER{8,WA{{{SET STATE ZERO{23240
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{23241
{{ENP{{{{END PROCEDURE EXPAN{23242
{{EJC{{{{{23243
*
*      EXPAP -- TEST FOR PATTERN MATCH TREE
*
*      EXPAP IS PASSED AN EXPRESSION TREE TO DETERMINE IF IT
*      IS A PATTERN MATCH. THE FOLLOWING ARE RECOGIZED AS
*      MATCHES IN THE CONTEXT OF THIS CALL.
*
*      1)   AN EXPLICIT USE OF BINARY QUESTION MARK
*      2)   A CONCATENATION
*      3)   AN ALTERNATION WHOSE LEFT OPERAND IS A CONCATENATION
*
*      (XR)                  PTR TO EXPAN TREE
*      JSR  EXPAP            CALL TO TEST FOR PATTERN MATCH
*      PPM  LOC              TRANSFER LOC IF NOT A PATTERN MATCH
*      (WA)                  DESTROYED
*      (XR)                  UNCHANGED (IF NOT MATCH)
*      (XR)                  PTR TO BINARY OPERATOR BLK IF MATCH
*
{EXPAP{PRC{25,E{1,1{{ENTRY POINT{23262
{{MOV{7,XL{11,-(XS){{SAVE XL{23263
{{BNE{9,(XR){22,=B$CMT{6,EXPP2{NO MATCH IF NOT COMPLEX{23264
{{MOV{13,CMTYP(XR){8,WA{{ELSE LOAD TYPE CODE{23265
{{BEQ{8,WA{18,=C$CNC{6,EXPP1{CONCATENATION IS A MATCH{23266
{{BEQ{8,WA{18,=C$PMT{6,EXPP1{BINARY QUESTION MARK IS A MATCH{23267
{{BNE{8,WA{18,=C$ALT{6,EXPP2{ELSE NOT MATCH UNLESS ALTERNATION{23268
*
*      HERE FOR ALTERNATION. CHANGE (A B) / C TO A QM (B / C)
*
{{MOV{13,CMLOP(XR){7,XL{{LOAD LEFT OPERAND POINTER{23272
{{BNE{9,(XL){22,=B$CMT{6,EXPP2{NOT MATCH IF LEFT OPND NOT COMPLEX{23273
{{BNE{13,CMTYP(XL){18,=C$CNC{6,EXPP2{NOT MATCH IF LEFT OP NOT CONC{23274
{{MOV{13,CMROP(XL){13,CMLOP(XR){{XR POINTS TO (B / C){23275
{{MOV{7,XR{13,CMROP(XL){{SET XL OPNDS TO A, (B / C){23276
{{MOV{7,XL{7,XR{{POINT TO THIS ALTERED NODE{23277
*
*      EXIT HERE FOR PATTERN MATCH
*
{EXPP1{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23281
{{EXI{{{{GIVE PATTERN MATCH RETURN{23282
*
*      EXIT HERE IF NOT PATTERN MATCH
*
{EXPP2{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23286
{{EXI{1,1{{{GIVE NON-MATCH RETURN{23287
{{ENP{{{{END PROCEDURE EXPAP{23288
{{EJC{{{{{23289
*
*      EXPDM -- DUMP OPERATORS AT CURRENT LEVEL (FOR EXPAN)
*
*      EXPDM USES EXPOP TO CONDENSE ALL OPERATORS AT THIS SYNTAX
*      LEVEL. THE STACK BOTTOM IS RECOGNIZED FROM THE LEVEL
*      VALUE WHICH IS SAVED ON THE TOP OF THE STACK.
*
*      JSR  EXPDM            CALL TO DUMP OPERATORS
*      (XS)                  POPPED AS REQUIRED
*      (XR,WA)               DESTROYED
*
{EXPDM{PRC{25,N{1,0{{ENTRY POINT{23301
{{MOV{7,XL{3,R$EXS{{SAVE XL VALUE{23302
*
*      LOOP TO DUMP OPERATORS
*
{EXDM1{BLE{13,NUM01(XS){18,=NUM05{6,EXDM2{JUMP IF STACK BOTTOM (SAVED LEVEL{23306
{{JSR{6,EXPOP{{{ELSE POP ONE OPERATOR{23307
{{BRN{6,EXDM1{{{AND LOOP BACK{23308
*
*      HERE AFTER POPPING ALL OPERATORS
*
{EXDM2{MOV{3,R$EXS{7,XL{{RESTORE XL{23312
{{ZER{3,R$EXS{{{RELEASE SAVE LOCATION{23313
{{EXI{{{{RETURN TO EXPDM CALLER{23314
{{ENP{{{{END PROCEDURE EXPDM{23315
{{EJC{{{{{23316
*
*      EXPOP-- POP OPERATOR (FOR EXPAN)
*
*      EXPOP IS USED BY THE EXPAN ROUTINE TO CONDENSE ONE
*      OPERATOR FROM THE TOP OF THE SYNTAX STACK. AN APPROPRIATE
*      CMBLK IS BUILT FOR THE OPERATOR (UNARY OR BINARY) AND A
*      POINTER TO THIS CMBLK IS STACKED.
*
*      EXPOP IS ALSO USED BY SCNGF (GOTO FIELD SCAN) PROCEDURE
*
*      JSR  EXPOP            CALL TO POP OPERATOR
*      (XS)                  POPPED APPROPRIATELY
*      (XR,XL,WA)            DESTROYED
*
{EXPOP{PRC{25,N{1,0{{ENTRY POINT{23331
{{MOV{13,NUM01(XS){7,XR{{LOAD OPERATOR DV POINTER{23332
{{BEQ{13,DVLPR(XR){18,=LLUNO{6,EXPO2{JUMP IF UNARY{23333
*
*      HERE FOR BINARY OPERATOR
*
{{MOV{19,*CMBS${8,WA{{SET SIZE OF BINARY OPERATOR CMBLK{23337
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23338
{{MOV{10,(XS)+{13,CMROP(XR){{POP AND STORE RIGHT OPERAND PTR{23339
{{MOV{10,(XS)+{7,XL{{POP AND LOAD OPERATOR DV PTR{23340
{{MOV{9,(XS){13,CMLOP(XR){{STORE LEFT OPERAND POINTER{23341
*
*      COMMON EXIT POINT
*
{EXPO1{MOV{22,=B$CMT{9,(XR){{STORE TYPE CODE FOR CMBLK{23345
{{MOV{13,DVTYP(XL){13,CMTYP(XR){{STORE CMBLK NODE TYPE CODE{23346
{{MOV{7,XL{13,CMOPN(XR){{STORE DVPTR (=PTR TO DAC O$XXX){23347
{{MOV{8,WA{13,CMLEN(XR){{STORE CMBLK LENGTH{23348
{{MOV{7,XR{9,(XS){{STORE RESULTING NODE PTR ON STACK{23349
{{EXI{{{{RETURN TO EXPOP CALLER{23350
*
*      HERE FOR UNARY OPERATOR
*
{EXPO2{MOV{19,*CMUS${8,WA{{SET SIZE OF UNARY OPERATOR CMBLK{23354
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23355
{{MOV{10,(XS)+{13,CMROP(XR){{POP AND STORE OPERAND POINTER{23356
{{MOV{9,(XS){7,XL{{LOAD OPERATOR DV POINTER{23357
{{BRN{6,EXPO1{{{MERGE BACK TO EXIT{23358
{{ENP{{{{END PROCEDURE EXPOP{23359
{{EJC{{{{{23360
*
*      FILNM -- OBTAIN FILE NAME FROM STATEMENT NUMBER
*
*      FILNM TAKES A STATEMENT NUMBER AND EXAMINES THE FILE NAME
*      TABLE POINTED TO BY R$SFN TO FIND THE NAME OF THE FILE
*      CONTAINING THE GIVEN STATEMENT.  TABLE ENTRIES ARE
*      ARRANGED IN ORDER OF ASCENDING STATEMENT NUMBER (THERE
*      IS ONLY ONE HASH BUCKET IN THIS TABLE).  ELEMENTS ARE
*      ADDED TO THE TABLE EACH TIME THERE IS A CHANGE IN
*      FILE NAME, RECORDING THE THEN CURRENT STATEMENT NUMBER.
*
*      TO FIND THE FILE NAME, THE LINKED LIST OF TEBLKS IS
*      SCANNED FOR AN ELEMENT CONTAINING A SUBSCRIPT (STATEMENT
*      NUMBER) GREATER THAN THE ARGUMENT STATEMENT NUMBER, OR
*      THE END OF CHAIN.  WHEN THIS CONDITION IS MET, THE
*      PREVIOUS TEBLK CONTAINS THE DESIRED FILE NAME AS ITS
*      VALUE ENTRY.
*
*      (WC)                  STATEMENT NUMBER
*      JSR  FILNM            CALL TO OBTAIN FILE NAME
*      (XL)                  FILE NAME (SCBLK)
*      (IA)                  DESTROYED
*
{FILNM{PRC{25,E{1,0{{ENTRY POINT{23385
{{MOV{8,WB{11,-(XS){{PRESERVE WB{23386
{{BZE{8,WC{6,FILN3{{RETURN NULLS IF STNO IS ZERO{23387
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{23388
{{BZE{7,XL{6,FILN3{{IF NO TABLE{23389
{{MOV{13,TBBUK(XL){8,WB{{GET BUCKET ENTRY{23390
{{BEQ{8,WB{3,R$SFN{6,FILN3{JUMP IF NO TEBLKS ON CHAIN{23391
{{MOV{7,XR{11,-(XS){{PRESERVE XR{23392
{{MOV{8,WB{7,XR{{PREVIOUS BLOCK POINTER{23393
{{MOV{8,WC{11,-(XS){{PRESERVE STMT NUMBER{23394
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{FILN1{MOV{7,XR{7,XL{{NEXT ELEMENT TO EXAMINE{23398
{{MOV{13,TESUB(XL){7,XR{{LOAD SUBSCRIPT VALUE (AN ICBLK){23399
{{LDI{13,ICVAL(XR){{{LOAD THE STATEMENT NUMBER{23400
{{MFI{8,WC{{{CONVERT TO ADDRESS CONSTANT{23401
{{BLT{9,(XS){8,WC{6,FILN2{COMPARE ARG WITH TEBLK STMT NUMBER{23402
*
*      HERE IF DESIRED STMT NUMBER IS GE TEBLK STMT NUMBER
*
{{MOV{7,XL{8,WB{{SAVE PREVIOUS ENTRY POINTER{23406
{{MOV{13,TENXT(XL){7,XR{{POINT TO NEXT TEBLK ON CHAIN{23407
{{BNE{7,XR{3,R$SFN{6,FILN1{JUMP IF THERE IS ONE{23408
*
*      HERE IF CHAIN EXHAUSTED OR DESIRED BLOCK FOUND.
*
{FILN2{MOV{8,WB{7,XL{{PREVIOUS TEBLK{23412
{{MOV{13,TEVAL(XL){7,XL{{GET PTR TO FILE NAME SCBLK{23413
{{MOV{10,(XS)+{8,WC{{RESTORE STMT NUMBER{23414
{{MOV{10,(XS)+{7,XR{{RESTORE XR{23415
{{MOV{10,(XS)+{8,WB{{RESTORE WB{23416
{{EXI{{{{{23417
*
*      NO TABLE OR NO TABLE ENTRIES
*
{FILN3{MOV{10,(XS)+{8,WB{{RESTORE WB{23421
{{MOV{21,=NULLS{7,XL{{RETURN NULL STRING{23422
{{EXI{{{{{23423
{{ENP{{{{{23424
{{EJC{{{{{23425
*
*
*      FLSTG -- FOLD STRING TO UPPER CASE
*
*      FLSTG FOLDS A CHARACTER STRING CONTAINING LOWER CASE
*      CHARACCTERS TO ONE CONTAINING UPPER CASE CHARACTERS.
*      FOLDING IS ONLY DONE IF &CASE (KVCAS) IS NOT ZERO.
*
*      (XR)                  STRING ARGUMENT
*      (WA)                  LENGTH OF STRING
*      JSR  FLSTG            CALL TO FOLD STRING
*      (XR)                  RESULT STRING (POSSIBLY ORIGINAL)
*      (WC)                  DESTROYED
*
{FLSTG{PRC{25,E{1,0{{ENTRY POINT{23442
{{BZE{3,KVCAS{6,FST99{{SKIP IF &CASE IS 0{23443
{{MOV{7,XL{11,-(XS){{SAVE XL ACROSS CALL{23444
{{MOV{7,XR{11,-(XS){{SAVE ORIGINAL SCBLK PTR{23445
{{JSR{6,ALOCS{{{ALLOCATE NEW STRING BLOCK{23446
{{MOV{9,(XS){7,XL{{POINT TO ORIGINAL SCBLK{23447
{{MOV{7,XR{11,-(XS){{SAVE POINTER TO NEW SCBLK{23448
{{PLC{7,XL{{{POINT TO ORIGINAL CHARS{23449
{{PSC{7,XR{{{POINT TO NEW CHARS{23450
{{ZER{11,-(XS){{{INIT DID FOLD FLAG{23451
{{LCT{8,WC{8,WC{{LOAD LOOP COUNTER{23452
{FST01{LCH{8,WA{10,(XL)+{{LOAD CHARACTER{23453
{{BLT{8,WA{18,=CH$$A{6,FST02{SKIP IF LESS THAN LC A{23454
{{BGT{8,WA{18,=CH$$${6,FST02{SKIP IF GREATER THAN LC Z{23455
{{FLC{8,WA{{{FOLD CHARACTER TO UPPER CASE{23456
{{MNZ{9,(XS){{{SET DID FOLD CHARACTER FLAG{23457
{FST02{SCH{8,WA{10,(XR)+{{STORE (POSSIBLY FOLDED) CHARACTER{23458
{{BCT{8,WC{6,FST01{{LOOP THRU ENTIRE STRING{23459
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{23460
{{MOV{10,(XS)+{7,XR{{SEE IF ANY CHANGE{23461
{{BNZ{7,XR{6,FST10{{SKIP IF FOLDING DONE (NO CHANGE){23462
{{MOV{10,(XS)+{3,DNAMP{{DO NOT NEED NEW SCBLK{23463
{{MOV{10,(XS)+{7,XR{{RETURN ORIGINAL SCBLK{23464
{{BRN{6,FST20{{{MERGE BELOW{23465
{FST10{MOV{10,(XS)+{7,XR{{RETURN NEW SCBLK{23466
{{ICA{7,XS{{{THROW AWAY ORIGINAL SCBLK POINTER{23467
{FST20{MOV{13,SCLEN(XR){8,WA{{RELOAD STRING LENGTH{23468
{{MOV{10,(XS)+{7,XL{{RESTORE XL{23469
{FST99{EXI{{{{RETURN{23470
{{ENP{{{{{23471
{{EJC{{{{{23472
*
*      GBCOL -- PERFORM GARBAGE COLLECTION
*
*      GBCOL PERFORMS A GARBAGE COLLECTION ON THE DYNAMIC REGION
*      ALL BLOCKS WHICH ARE NO LONGER IN USE ARE ELIMINATED
*      BY MOVING BLOCKS WHICH ARE IN USE DOWN AND RESETTING
*      DNAMP, THE POINTER TO THE NEXT AVAILABLE LOCATION.
*
*      (WB)                  MOVE OFFSET (SEE BELOW)
*      JSR  GBCOL            CALL TO COLLECT GARBAGE
*      (XR)                  SEDIMENT SIZE AFTER COLLECTION
*
*      THE FOLLOWING CONDITIONS MUST BE MET AT THE TIME WHEN
*      GBCOL IS CALLED.
*
*      1)   ALL POINTERS TO BLOCKS IN THE DYNAMIC AREA MUST BE
*           ACCESSIBLE TO THE GARBAGE COLLECTOR. THIS MEANS
*           THAT THEY MUST OCCUR IN ONE OF THE FOLLOWING.
*
*           A)               MAIN STACK, WITH CURRENT TOP
*                            ELEMENT BEING INDICATED BY XS
*
*           B)               IN RELOCATABLE FIELDS OF VRBLKS.
*
*           C)               IN REGISTER XL AT THE TIME OF CALL
*
*           E)               IN THE SPECIAL REGION OF WORKING
*                            STORAGE WHERE NAMES BEGIN WITH R$.
*
*      2)   ALL POINTERS MUST POINT TO THE START OF BLOCKS WITH
*           THE SOLE EXCEPTION OF THE CONTENTS OF THE CODE
*           POINTER REGISTER WHICH POINTS INTO THE R$COD BLOCK.
*
*      3)   NO LOCATION WHICH APPEARS TO CONTAIN A POINTER
*           INTO THE DYNAMIC REGION MAY OCCUR UNLESS IT IS IN
*           FACT A POINTER TO THE START OF THE BLOCK. HOWEVER
*           POINTERS OUTSIDE THIS AREA MAY OCCUR AND WILL
*           NOT BE CHANGED BY THE GARBAGE COLLECTOR.
*           IT IS ESPECIALLY IMPORTANT TO MAKE SURE THAT XL
*           DOES NOT CONTAIN A GARBAGE VALUE FROM SOME PROCESS
*           CARRIED OUT BEFORE THE CALL TO THE COLLECTOR.
*
*      GBCOL HAS THE CAPABILITY OF MOVING THE FINAL COMPACTED
*      RESULT UP IN MEMORY (WITH ADDRESSES ADJUSTED ACCORDINGLY)
*      THIS IS USED TO ADD SPACE TO THE STATIC REGION. THE
*      ENTRY VALUE OF WB IS THE NUMBER OF BYTES TO MOVE UP.
*      THE CALLER MUST GUARANTEE THAT THERE IS ENOUGH ROOM.
*      FURTHERMORE THE VALUE IN WB IF IT IS NON-ZERO, MUST BE AT
*      LEAST 256 SO THAT THE MWB INSTRUCTION CONDITIONS ARE MET.
{{EJC{{{{{23527
*
*      GBCOL (CONTINUED)
*
*      THE ALGORITHM, WHICH IS A MODIFICATION OF THE LISP-2
*      GARBAGE COLLECTOR DEVISED BY R.DEWAR AND K.BELCHER
*      TAKES THREE PASSES AS FOLLOWS.
*
*      1)   ALL POINTERS IN MEMORY ARE SCANNED AND BLOCKS IN USE
*           DETERMINED FROM THIS SCAN. NOTE THAT THIS PROCEDURE
*           IS RECURSIVE AND USES THE MAIN STACK FOR LINKAGE.
*           THE MARKING PROCESS IS THUS SIMILAR TO THAT USED IN
*           A STANDARD LISP COLLECTOR. HOWEVER THE METHOD OF
*           ACTUALLY MARKING THE BLOCKS IS DIFFERENT.
*
*           THE FIRST FIELD OF A BLOCK NORMALLY CONTAINS A
*           CODE ENTRY POINT POINTER. SUCH AN ENTRY POINTER
*           CAN BE DISTINGUISHED FROM THE ADDRESS OF ANY POINTER
*           TO BE PROCESSED BY THE COLLECTOR. DURING GARBAGE
*           COLLECTION, THIS WORD IS USED TO BUILD A BACK CHAIN
*           OF POINTERS THROUGH FIELDS WHICH POINT TO THE BLOCK.
*           THE END OF THE CHAIN IS MARKED BY THE OCCURENCE
*           OF THE WORD WHICH USED TO BE IN THE FIRST WORD OF
*           THE BLOCK. THIS BACKCHAIN SERVES BOTH AS A MARK
*           INDICATING THAT THE BLOCK IS IN USE AND AS A LIST OF
*           REFERENCES FOR THE RELOCATION PHASE.
*
*      2)   STORAGE IS SCANNED SEQUENTIALLY TO DISCOVER WHICH
*           BLOCKS ARE CURRENTLY IN USE AS INDICATED BY THE
*           PRESENCE OF A BACKCHAIN. TWO POINTERS ARE MAINTAINED
*           ONE SCANS THROUGH LOOKING AT EACH BLOCK. THE OTHER
*           IS INCREMENTED ONLY FOR BLOCKS FOUND TO BE IN USE.
*           IN THIS WAY, THE EVENTUAL LOCATION OF EACH BLOCK CAN
*           BE DETERMINED WITHOUT ACTUALLY MOVING ANY BLOCKS.
*           AS EACH BLOCK WHICH IS IN USE IS PROCESSED, THE BACK
*           CHAIN IS USED TO RESET ALL POINTERS WHICH POINT TO
*           THIS BLOCK TO CONTAIN ITS NEW ADDRESS, I.E. THE
*           ADDRESS IT WILL OCCUPY AFTER THE BLOCKS ARE MOVED.
*           THE FIRST WORD OF THE BLOCK, TAKEN FROM THE END OF
*           THE CHAIN IS RESTORED AT THIS POINT.
*
*           DURING PASS 2, THE COLLECTOR BUILDS BLOCKS WHICH
*           DESCRIBE THE REGIONS OF STORAGE WHICH ARE TO BE
*           MOVED IN THE THIRD PASS. THERE IS ONE DESCRIPTOR FOR
*           EACH CONTIGUOUS SET OF GOOD BLOCKS. THE DESCRIPTOR
*           IS BUILT JUST BEHIND THE BLOCK TO BE MOVED AND
*           CONTAINS A POINTER TO THE NEXT BLOCK AND THE NUMBER
*           OF WORDS TO BE MOVED.
*
*      3)   IN THE THIRD AND FINAL PASS, THE MOVE DESCRIPTOR
*           BLOCKS BUILT IN PASS TWO ARE USED TO ACTUALLY MOVE
*           THE BLOCKS DOWN TO THE BOTTOM OF THE DYNAMIC REGION.
*           THE COLLECTION IS THEN COMPLETE AND THE NEXT
*           AVAILABLE LOCATION POINTER IS RESET.
{{EJC{{{{{23581
*
*      GBCOL (CONTINUED)
*
*      THE GARBAGE COLLECTOR ALSO RECOGNIZES THE CONCEPT OF
*      SEDIMENT.  SEDIMENT IS DEFINED AS LONG-LIVED OBJECTS
*      WHICH PERCIPITATE TO THE BOTTOM OF DYNAMIC STORAGE.
*      MOVING THESE OBJECTS DURING REPEATED COLLECTIONS IS
*      INEFFICIENT.  IT ALSO CONTRIBUTES TO THRASHING ON
*      SYSTEMS WITH VIRTUAL MEMORY.  IN A TYPICAL WORST-CASE
*      SITUATION, THERE MAY BE SEVERAL MEGABYTES OF LIVE OBJECTS
*      IN THE SEDIMENT, AND ONLY A FEW DEAD OBJECTS IN NEED OF
*      COLLECTION.  WITHOUT RECOGNISING SEDIMENT, THE STANDARD
*      COLLECTOR WOULD MOVE THOSE MEGABYTES OF OBJECTS DOWNWARD
*      TO SQUEEZE OUT THE DEAD OBJECTS.  THIS TYPE OF MOVE
*      WOULD RESULT IN EXCESSIVE THRASING FOR VERY LITTLE MEMORY
*      GAIN.
*
*      SCANNING OF BLOCKS IN THE SEDIMENT CANNOT BE AVOIDED
*      ENTIRELY, BECAUSE THESE BLOCKS MAY CONTAIN POINTERS TO
*      LIVE OBJECTS ABOVE THE SEDIMENT.  HOWEVER, SEDIMENT
*      BLOCKS NEED NOT BE LINKED TO A BACK CHAIN AS DESCRIBED
*      IN PASS ONE ABOVE.  SINCE THESE BLOCKS WILL NOT BE MOVED,
*      POINTERS TO THEM DO NOT NEED TO BE ADJUSTED.  ELIMINATING
*      UNNECESSARY BACK CHAIN LINKS INCREASES LOCALITY OF
*      REFERENCE, IMPROVING VIRTUAL MEMORY PERFORMANCE.
*
*      BECAUSE BACK CHAINS ARE USED TO MARK BLOCKS WHOSE CON-
*      TENTS HAVE BEEN PROCESSED, A DIFFERENT MARKING SYSTEM
*      IS NEEDED FOR BLOCKS IN THE SEDIMENT.  SINCE BLOCK TYPE
*      WORDS POINT TO ODD-PARITY ENTRY ADDRESSES, MERELY INCRE-
*      MENTING THE TYPE WORD SERVES TO MARK THE BLOCK AS PRO-
*      CESSED.  DURING PASS THREE, THE TYPE WORDS ARE DECRE-
*      MENTED TO RESTORE THEM TO THEIR ORIGINAL VALUE.
{{EJC{{{{{23625
*
*      GBCOL (CONTINUED)
*
*
*      THE VARIABLE DNAMS CONTAINS THE NUMBER OF BYTES OF MEMORY
*      CURRENTLY IN THE SEDIMENT.  SETTING DNAMS TO ZERO WILL
*      ELIMINATE THE SEDIMENT AND FORCE IT TO BE INCLUDED IN A
*      FULL GARBAGE COLLECTION.  GBCOL RETURNS A SUGGESTED NEW
*      VALUE FOR DNAMS (USUALLY DNAMP-DNAMB) IN XR WHICH THE
*      CALLER CAN STORE IN DNAMS IF IT WISHES TO MAINTAIN THE
*      SEDIMENT.  THAT IS, DATA REMAINING AFTER A GARBAGE
*      COLLECTION IS CONSIDERED TO BE SEDIMENT.  IF ONE ACCEPTS
*      THE COMMON LORE THAT MOST OBJECTS ARE EITHER VERY SHORT-
*      OR VERY LONG-LIVED, THEN THIS NAIVE SETTING OF DNAMS
*      PROBABLY INCLUDES SOME SHORT-LIVED OBJECTS TOWARD THE END
*      OF THE SEDIMENT.
*
*      KNOWING WHEN TO RESET DNAMS TO ZERO TO COLLECT THE SEDI-
*      MENT IS NOT PRECISELY KNOWN.  WE FORCE IT TO ZERO PRIOR
*      TO PRODUCING A DUMP, WHEN GBCOL IS INVOKED BY COLLECT()
*      (SO THAT THE SEDIMENT IS INVISIBLE TO THE USER), WHEN
*      SYSMM IS UNABLE TO OBTAIN ADDITIONAL MEMORY, AND WHEN
*      GBCOL IS CALLED TO RELOCATE THE DYNAMIC AREA UP IN MEMORY
*      (TO MAKE ROOM FOR ENLARGING THE STATIC AREA).  IF THERE
*      ARE NO OTHER RESET SITUATIONS, THIS LEADS TO THE INEXO-
*      RABLE GROWTH OF THE SEDIMENT, POSSIBLE FORCING A MODEST
*      PROGRAM TO BEGIN TO USE VIRTUAL MEMORY THAT IT OTHERWISE
*      WOULD NOT.
*
*      AS WE SCAN SEDIMENT BLOCKS IN PASS THREE, WE MAINTAIN
*      AGGREGATE COUNTS OF THE AMOUNT OF DEAD AND LIVE STORAGE,
*      WHICH IS USED TO DECIDE WHEN TO RESET DNAMS.  WHEN THE
*      RATIO OF FREE STORAGE FOUND IN THE SEDIMENT TO TOTAL
*      SEDIMENT SIZE EXCEEDS A THRESHOLD, THE SEDIMENT IS MARKED
*      FOR COLLECTION ON THE NEXT GBCOL CALL.
*
{{EJC{{{{{23663
*
*      GBCOL (CONTINUED)
*
{GBCOL{PRC{25,E{1,0{{ENTRY POINT{23667
{{BNZ{3,DMVCH{6,GBC14{{FAIL IF IN MID-DUMP{23668
{{MNZ{3,GBCFL{{{NOTE GBCOL ENTERED{23669
{{MOV{8,WA{3,GBSVA{{SAVE ENTRY WA{23670
{{MOV{8,WB{3,GBSVB{{SAVE ENTRY WB{23671
{{MOV{8,WC{3,GBSVC{{SAVE ENTRY WC{23672
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{23673
{{SCP{8,WA{{{GET CODE POINTER VALUE{23674
{{SUB{3,R$COD{8,WA{{MAKE RELATIVE{23675
{{LCP{8,WA{{{AND RESTORE{23676
{{BZE{8,WB{6,GBC0A{{CHECK THERE IS NO MOVE OFFSET{23678
{{ZER{3,DNAMS{{{COLLECT SEDIMENT IF MUST MOVE IT{23679
{GBC0A{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23680
{{ADD{3,DNAMS{8,WA{{SIZE OF SEDIMENT{23681
{{MOV{8,WA{3,GBCSD{{FIRST LOCATION PAST SEDIMENT{23682
*
*      INFORM SYSGC THAT COLLECTION TO COMMENCE
*
{{MNZ{7,XR{{{NON-ZERO FLAGS START OF COLLECTION{23695
{{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23696
{{MOV{3,DNAMP{8,WB{{NEXT AVAILABLE LOCATION{23697
{{MOV{3,DNAME{8,WC{{LAST AVAILABLE LOCATION + 1{23698
{{JSR{6,SYSGC{{{INFORM OF COLLECTION{23699
*
*      PROCESS STACK ENTRIES
*
{{MOV{7,XS{7,XR{{POINT TO STACK FRONT{23704
{{MOV{3,STBAS{7,XL{{POINT PAST END OF STACK{23705
{{BGE{7,XL{7,XR{6,GBC00{OK IF D-STACK{23706
{{MOV{7,XL{7,XR{{REVERSE IF ...{23707
{{MOV{7,XS{7,XL{{... U-STACK{23708
*
*      PROCESS THE STACK
*
{GBC00{JSR{6,GBCPF{{{PROCESS POINTERS ON STACK{23712
*
*      PROCESS SPECIAL WORK LOCATIONS
*
{{MOV{20,=R$AAA{7,XR{{POINT TO START OF RELOCATABLE LOCS{23716
{{MOV{20,=R$YYY{7,XL{{POINT PAST END OF RELOCATABLE LOCS{23717
{{JSR{6,GBCPF{{{PROCESS WORK FIELDS{23718
*
*      PREPARE TO PROCESS VARIABLE BLOCKS
*
{{MOV{3,HSHTB{8,WA{{POINT TO FIRST HASH SLOT POINTER{23722
*
*      LOOP THROUGH HASH SLOTS
*
{GBC01{MOV{8,WA{7,XL{{POINT TO NEXT SLOT{23726
{{ICA{8,WA{{{BUMP BUCKET POINTER{23727
{{MOV{8,WA{3,GBCNM{{SAVE BUCKET POINTER{23728
{{EJC{{{{{23729
*
*      GBCOL (CONTINUED)
*
*      LOOP THROUGH VARIABLES ON ONE HASH CHAIN
*
{GBC02{MOV{9,(XL){7,XR{{LOAD PTR TO NEXT VRBLK{23735
{{BZE{7,XR{6,GBC03{{JUMP IF END OF CHAIN{23736
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK POINTER{23737
{{ADD{19,*VRVAL{7,XR{{POINT TO FIRST RELOC FLD{23738
{{ADD{19,*VRNXT{7,XL{{POINT PAST LAST (AND TO LINK PTR){23739
{{JSR{6,GBCPF{{{PROCESS RELOC FIELDS IN VRBLK{23740
{{BRN{6,GBC02{{{LOOP BACK FOR NEXT BLOCK{23741
*
*      HERE AT END OF ONE HASH CHAIN
*
{GBC03{MOV{3,GBCNM{8,WA{{RESTORE BUCKET POINTER{23745
{{BNE{8,WA{3,HSHTE{6,GBC01{LOOP BACK IF MORE BUCKETS TO GO{23746
{{EJC{{{{{23747
*
*      GBCOL (CONTINUED)
*
*      NOW WE ARE READY TO START PASS TWO. REGISTERS ARE USED
*      AS FOLLOWS IN PASS TWO.
*
*      (XR)                  SCANS THROUGH ALL BLOCKS
*      (WC)                  POINTER TO EVENTUAL LOCATION
*
*      THE MOVE DESCRIPTION BLOCKS BUILT IN THIS PASS HAVE
*      THE FOLLOWING FORMAT.
*
*      WORD 1                POINTER TO NEXT MOVE BLOCK,
*                            ZERO IF END OF CHAIN OF BLOCKS
*
*      WORD 2                LENGTH OF BLOCKS TO BE MOVED IN
*                            BYTES. SET TO THE ADDRESS OF THE
*                            FIRST BYTE WHILE ACTUALLY SCANNING
*                            THE BLOCKS.
*
*      THE FIRST ENTRY ON THIS CHAIN IS A SPECIAL ENTRY
*      CONSISTING OF THE TWO WORDS GBCNM AND GBCNS. AFTER
*      BUILDING THE CHAIN OF MOVE DESCRIPTORS, GBCNM POINTS TO
*      THE FIRST REAL MOVE BLOCK, AND GBCNS IS THE LENGTH OF
*      BLOCKS IN USE AT THE START OF STORAGE WHICH NEED NOT
*      BE MOVED SINCE THEY ARE IN THE CORRECT POSITION.
*
{{MOV{3,DNAMB{7,XR{{POINT TO FIRST BLOCK{23776
{{ZER{8,WB{{{ACCUMULATE SIZE OF DEAD BLOCKS{23777
{GBC04{BEQ{7,XR{3,GBCSD{6,GBC4C{JUMP IF END OF SEDIMENT{23778
{{MOV{9,(XR){8,WA{{ELSE GET FIRST WORD{23779
{{BOD{8,WA{6,GBC4B{{JUMP IF ENTRY POINTER (UNUSED){23781
{{DCV{8,WA{{{RESTORE ENTRY POINTER{23782
{{MOV{8,WA{9,(XR){{RESTORE FIRST WORD{23788
{{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{23789
{{ADD{8,WA{7,XR{{BUMP ACTUAL POINTER{23790
{{BRN{6,GBC04{{{CONTINUE SCAN THROUGH SEDIMENT{23791
*
*      HERE FOR UNUSED SEDIMENT BLOCK
*
{GBC4B{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{23795
{{ADD{8,WA{7,XR{{BUMP ACTUAL POINTER{23796
{{ADD{8,WA{8,WB{{COUNT SIZE OF UNUSED BLOCKS{23797
{{BRN{6,GBC04{{{CONTINUE SCAN THROUGH SEDIMENT{23798
*
*      HERE AT END OF SEDIMENT.  REMEMBER SIZE OF FREE BLOCKS
*      WITHIN THE SEDIMENT.  THIS WILL BE USED LATER TO DECIDE
*      HOW TO SET THE SEDIMENT SIZE RETURNED TO CALLER.
*
*      THEN SCAN REST OF DYNAMIC AREA ABOVE SEDIMENT.
*
*      (WB) = AGGREGATE SIZE OF FREE BLOCKS IN SEDIMENT
*      (XR) = FIRST LOCATION PAST SEDIMENT
*
{GBC4C{MOV{8,WB{3,GBCSF{{SIZE OF SEDIMENT FREE SPACE{23809
{{MOV{7,XR{8,WC{{SET AS FIRST EVENTUAL LOCATION{23813
{{ADD{3,GBSVB{8,WC{{ADD OFFSET FOR EVENTUAL MOVE UP{23814
{{ZER{3,GBCNM{{{CLEAR INITIAL FORWARD POINTER{23815
{{MOV{20,=GBCNM{3,GBCLM{{INITIALIZE PTR TO LAST MOVE BLOCK{23816
{{MOV{7,XR{3,GBCNS{{INITIALIZE FIRST ADDRESS{23817
*
*      LOOP THROUGH A SERIES OF BLOCKS IN USE
*
{GBC05{BEQ{7,XR{3,DNAMP{6,GBC07{JUMP IF END OF USED REGION{23821
{{MOV{9,(XR){8,WA{{ELSE GET FIRST WORD{23822
{{BOD{8,WA{6,GBC07{{JUMP IF ENTRY POINTER (UNUSED){23824
*
*      HERE FOR BLOCK IN USE, LOOP TO RELOCATE REFERENCES
*
{GBC06{MOV{8,WA{7,XL{{COPY POINTER{23832
{{MOV{9,(XL){8,WA{{LOAD FORWARD POINTER{23833
{{MOV{8,WC{9,(XL){{RELOCATE REFERENCE{23834
{{BEV{8,WA{6,GBC06{{LOOP BACK IF NOT END OF CHAIN{23836
{{EJC{{{{{23841
*
*      GBCOL (CONTINUED)
*
*      AT END OF CHAIN, RESTORE FIRST WORD AND BUMP PAST
*
{{MOV{8,WA{9,(XR){{RESTORE FIRST WORD{23847
{{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{23848
{{ADD{8,WA{7,XR{{BUMP ACTUAL POINTER{23849
{{ADD{8,WA{8,WC{{BUMP EVENTUAL POINTER{23850
{{BRN{6,GBC05{{{LOOP BACK FOR NEXT BLOCK{23851
*
*      HERE AT END OF A SERIES OF BLOCKS IN USE
*
{GBC07{MOV{7,XR{8,WA{{COPY POINTER PAST LAST BLOCK{23855
{{MOV{3,GBCLM{7,XL{{POINT TO PREVIOUS MOVE BLOCK{23856
{{SUB{13,NUM01(XL){8,WA{{SUBTRACT STARTING ADDRESS{23857
{{MOV{8,WA{13,NUM01(XL){{STORE LENGTH OF BLOCK TO BE MOVED{23858
*
*      LOOP THROUGH A SERIES OF BLOCKS NOT IN USE
*
{GBC08{BEQ{7,XR{3,DNAMP{6,GBC10{JUMP IF END OF USED REGION{23862
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF NEXT BLOCK{23863
{{BEV{8,WA{6,GBC09{{JUMP IF IN USE{23865
{{JSR{6,BLKLN{{{ELSE GET LENGTH OF NEXT BLOCK{23870
{{ADD{8,WA{7,XR{{PUSH POINTER{23871
{{BRN{6,GBC08{{{AND LOOP BACK{23872
*
*      HERE FOR A BLOCK IN USE AFTER PROCESSING A SERIES OF
*      BLOCKS WHICH WERE NOT IN USE, BUILD NEW MOVE BLOCK.
*
{GBC09{SUB{19,*NUM02{7,XR{{POINT 2 WORDS BEHIND FOR MOVE BLOCK{23877
{{MOV{3,GBCLM{7,XL{{POINT TO PREVIOUS MOVE BLOCK{23878
{{MOV{7,XR{9,(XL){{SET FORWARD PTR IN PREVIOUS BLOCK{23879
{{ZER{9,(XR){{{ZERO FORWARD PTR OF NEW BLOCK{23880
{{MOV{7,XR{3,GBCLM{{REMEMBER ADDRESS OF THIS BLOCK{23881
{{MOV{7,XR{7,XL{{COPY PTR TO MOVE BLOCK{23882
{{ADD{19,*NUM02{7,XR{{POINT BACK TO BLOCK IN USE{23883
{{MOV{7,XR{13,NUM01(XL){{STORE STARTING ADDRESS{23884
{{BRN{6,GBC06{{{JUMP TO PROCESS BLOCK IN USE{23885
{{EJC{{{{{23886
*
*      GBCOL (CONTINUED)
*
*      HERE FOR PASS THREE -- ACTUALLY MOVE THE BLOCKS DOWN
*
*      (XL)                  POINTER TO OLD LOCATION
*      (XR)                  POINTER TO NEW LOCATION
*
{GBC10{MOV{3,GBCSD{7,XR{{POINT TO STORAGE ABOVE SEDIMENT{23896
{{ADD{3,GBCNS{7,XR{{BUMP PAST UNMOVED BLOCKS AT START{23900
*
*      LOOP THROUGH MOVE DESCRIPTORS
*
{GBC11{MOV{3,GBCNM{7,XL{{POINT TO NEXT MOVE BLOCK{23904
{{BZE{7,XL{6,GBC12{{JUMP IF END OF CHAIN{23905
{{MOV{10,(XL)+{3,GBCNM{{MOVE POINTER DOWN CHAIN{23906
{{MOV{10,(XL)+{8,WA{{GET LENGTH TO MOVE{23907
{{MVW{{{{PERFORM MOVE{23908
{{BRN{6,GBC11{{{LOOP BACK{23909
*
*      NOW TEST FOR MOVE UP
*
{GBC12{MOV{7,XR{3,DNAMP{{SET NEXT AVAILABLE LOC PTR{23913
{{MOV{3,GBSVB{8,WB{{RELOAD MOVE OFFSET{23914
{{BZE{8,WB{6,GBC13{{JUMP IF NO MOVE REQUIRED{23915
{{MOV{7,XR{7,XL{{ELSE COPY OLD TOP OF CORE{23916
{{ADD{8,WB{7,XR{{POINT TO NEW TOP OF CORE{23917
{{MOV{7,XR{3,DNAMP{{SAVE NEW TOP OF CORE POINTER{23918
{{MOV{7,XL{8,WA{{COPY OLD TOP{23919
{{SUB{3,DNAMB{8,WA{{MINUS OLD BOTTOM = LENGTH{23920
{{ADD{8,WB{3,DNAMB{{BUMP BOTTOM TO GET NEW VALUE{23921
{{MWB{{{{PERFORM MOVE (BACKWARDS){23922
*
*      MERGE HERE TO EXIT
*
{GBC13{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{23926
{{MOV{7,XR{3,GBCFL{{NOTE EXIT FROM GBCOL{23927
{{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23929
{{MOV{3,DNAMP{8,WB{{NEXT AVAILABLE LOCATION{23930
{{MOV{3,DNAME{8,WC{{LAST AVAILABLE LOCATION + 1{23931
{{JSR{6,SYSGC{{{INFORM SYSGC OF COMPLETION{23932
*
*      DECIDE WHETHER TO MARK SEDIMENT FOR COLLECTION NEXT TIME.
*      THIS IS DONE BY EXAMINING THE RATIO OF PREVIOUS SEDIMENT
*      FREE SPACE TO THE NEW SEDIMENT SIZE.
*
{{STI{3,GBCIA{{{SAVE IA{23940
{{ZER{7,XR{{{PRESUME NO SEDIMENT WILL REMAIN{23941
{{MOV{3,GBCSF{8,WB{{FREE SPACE IN SEDIMENT{23942
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{23943
{{MTI{8,WB{{{PUT SEDIMENT FREE STORE IN IA{23944
{{MLI{3,GBSED{{{MULTIPLY BY SEDIMENT FACTOR{23945
{{IOV{6,GB13A{{{JUMP IF OVERFLOWED{23946
{{MOV{3,DNAMP{8,WB{{END OF DYNAMIC AREA IN USE{23947
{{SUB{3,DNAMB{8,WB{{MINUS START IS SEDIMENT REMAINING{23948
{{BTW{8,WB{{{CONVERT TO WORDS{23949
{{MOV{8,WB{3,GBCSF{{STORE IT{23950
{{SBI{3,GBCSF{{{SUBTRACT FROM SCALED UP FREE STORE{23951
{{IGT{6,GB13A{{{JUMP IF LARGE FREE STORE IN SEDIMNT{23952
{{MOV{3,DNAMP{7,XR{{BELOW THRESHOLD, RETURN SEDIMENT{23953
{{SUB{3,DNAMB{7,XR{{FOR USE BY CALLER{23954
{GB13A{LDI{3,GBCIA{{{RESTORE IA{23955
{{MOV{3,GBSVA{8,WA{{RESTORE WA{23957
{{MOV{3,GBSVB{8,WB{{RESTORE WB{23958
{{SCP{8,WC{{{GET CODE POINTER{23959
{{ADD{3,R$COD{8,WC{{MAKE ABSOLUTE AGAIN{23960
{{LCP{8,WC{{{AND REPLACE ABSOLUTE VALUE{23961
{{MOV{3,GBSVC{8,WC{{RESTORE WC{23962
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23963
{{ICV{3,GBCNT{{{INCREMENT COUNT OF COLLECTIONS{23964
{{EXI{{{{EXIT TO GBCOL CALLER{23965
*
*      GARBAGE COLLECTION NOT ALLOWED WHILST DUMPING
*
{GBC14{ICV{3,ERRFT{{{FATAL ERROR{23969
{{ERB{1,250{26,Insufficient memory to complete dump{{{23970
{{ENP{{{{END PROCEDURE GBCOL{23971
{{EJC{{{{{23972
*
*      GBCPF -- PROCESS FIELDS FOR GARBAGE COLLECTOR
*
*      THIS PROCEDURE IS USED BY THE GARBAGE COLLECTOR TO
*      PROCESS FIELDS IN PASS ONE. SEE GBCOL FOR FULL DETAILS.
*
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (XL)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  GBCPF            CALL TO PROCESS FIELDS
*      (XR,WA,WB,WC,IA)      DESTROYED
*
*      NOTE THAT ALTHOUGH THIS PROCEDURE USES A RECURSIVE
*      APPROACH, IT CONTROLS ITS OWN STACK AND IS NOT RECURSIVE.
*
{GBCPF{PRC{25,E{1,0{{ENTRY POINT{23987
{{ZER{11,-(XS){{{SET ZERO TO MARK BOTTOM OF STACK{23988
{{MOV{7,XL{11,-(XS){{SAVE END POINTER{23989
*
*      MERGE HERE TO GO DOWN A LEVEL AND START A NEW LOOP
*
*      1(XS)                 NEXT LVL FIELD PTR (0 AT OUTER LVL)
*      0(XS)                 PTR PAST LAST FIELD TO PROCESS
*      (XR)                  PTR TO FIRST FIELD TO PROCESS
*
*      LOOP TO PROCESS SUCCESSIVE FIELDS
*
{GPF01{MOV{9,(XR){7,XL{{LOAD FIELD CONTENTS{23999
{{MOV{7,XR{8,WC{{SAVE FIELD POINTER{24000
{{BLT{7,XL{3,DNAMB{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{24004
{{BGE{7,XL{3,DNAMP{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{24005
*
*      HERE WE HAVE A PTR TO A BLOCK IN THE DYNAMIC AREA.
*      LINK THIS FIELD ONTO THE REFERENCE BACKCHAIN.
*
{{MOV{9,(XL){8,WA{{LOAD PTR TO CHAIN (OR ENTRY PTR){24010
{{BLT{7,XL{3,GBCSD{6,GPF1A{DO NOT CHAIN IF WITHIN SEDIMENT{24012
{{MOV{7,XR{9,(XL){{SET THIS FIELD AS NEW HEAD OF CHAIN{24014
{{MOV{8,WA{9,(XR){{SET FORWARD POINTER{24015
*
*      NOW SEE IF THIS BLOCK HAS BEEN PROCESSED BEFORE
*
{GPF1A{BOD{8,WA{6,GPF03{{JUMP IF NOT ALREADY PROCESSED{24020
*
*      HERE TO RESTORE POINTER IN XR TO FIELD JUST PROCESSED
*
{GPF02{MOV{8,WC{7,XR{{RESTORE FIELD POINTER{24028
*
*      HERE TO MOVE TO NEXT FIELD
*
{GPF2A{ICA{7,XR{{{BUMP TO NEXT FIELD{24032
{{BNE{7,XR{9,(XS){6,GPF01{LOOP BACK IF MORE TO GO{24033
{{EJC{{{{{24034
*
*      GBCPF (CONTINUED)
*
*      HERE WE POP UP A LEVEL AFTER FINISHING A BLOCK
*
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER PAST END{24040
{{MOV{10,(XS)+{7,XR{{RESTORE BLOCK POINTER{24041
{{BNZ{7,XR{6,GPF2A{{CONTINUE LOOP UNLESS OUTER LEVL{24042
{{EXI{{{{RETURN TO CALLER IF OUTER LEVEL{24043
*
*      HERE TO PROCESS AN ACTIVE BLOCK WHICH HAS NOT BEEN DONE
*
*
*      SINCE SEDIMENT BLOCKS ARE NOT MARKED BY PUTTING THEM ON
*      THE BACK CHAIN, THEY MUST BE EXPLICITLY MARKED IN ANOTHER
*      MANNER.  IF ODD PARITY ENTRY POINTS ARE PRESENT, MARK BY
*      TEMPORARILY CONVERTING TO EVEN PARITY.  IF ODD PARITY NOT
*      AVAILABLE, THE ENTRY POINT IS ADJUSTED BY THE VALUE IN
*      GBCMK.
*
{GPF03{BGE{7,XL{3,GBCSD{6,GPF3A{IF NOT WITHIN SEDIMENT{24056
{{ICV{9,(XL){{{MARK BY MAKING ENTRY POINT EVEN{24058
{GPF3A{MOV{7,XL{7,XR{{COPY BLOCK POINTER{24062
{{MOV{8,WA{7,XL{{COPY FIRST WORD OF BLOCK{24066
{{LEI{7,XL{{{LOAD ENTRY POINT ID (BL$XX){24067
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO GPF02 HERE TO CONTINUE TO NEXT FLD.
*
{{BSW{7,XL{2,BL$$${{SWITCH ON BLOCK TYPE{24072
{{IFF{2,BL$AR{6,GPF06{{ARBLK{24110
{{IFF{2,BL$CD{6,GPF19{{CDBLK{24110
{{IFF{2,BL$EX{6,GPF17{{EXBLK{24110
{{IFF{2,BL$IC{6,GPF02{{ICBLK{24110
{{IFF{2,BL$NM{6,GPF10{{NMBLK{24110
{{IFF{2,BL$P0{6,GPF10{{P0BLK{24110
{{IFF{2,BL$P1{6,GPF12{{P1BLK{24110
{{IFF{2,BL$P2{6,GPF12{{P2BLK{24110
{{IFF{2,BL$RC{6,GPF02{{RCBLK{24110
{{IFF{2,BL$SC{6,GPF02{{SCBLK{24110
{{IFF{2,BL$SE{6,GPF02{{SEBLK{24110
{{IFF{2,BL$TB{6,GPF08{{TBBLK{24110
{{IFF{2,BL$VC{6,GPF08{{VCBLK{24110
{{IFF{2,BL$XN{6,GPF02{{XNBLK{24110
{{IFF{2,BL$XR{6,GPF09{{XRBLK{24110
{{IFF{2,BL$BC{6,GPF02{{BCBLK - DUMMY TO FILL OUT IFFS{24110
{{IFF{2,BL$PD{6,GPF13{{PDBLK{24110
{{IFF{2,BL$TR{6,GPF16{{TRBLK{24110
{{IFF{2,BL$BF{6,GPF02{{BFBLK{24110
{{IFF{2,BL$CC{6,GPF07{{CCBLK{24110
{{IFF{2,BL$CM{6,GPF04{{CMBLK{24110
{{IFF{2,BL$CT{6,GPF02{{CTBLK{24110
{{IFF{2,BL$DF{6,GPF02{{DFBLK{24110
{{IFF{2,BL$EF{6,GPF02{{EFBLK{24110
{{IFF{2,BL$EV{6,GPF10{{EVBLK{24110
{{IFF{2,BL$FF{6,GPF11{{FFBLK{24110
{{IFF{2,BL$KV{6,GPF02{{KVBLK{24110
{{IFF{2,BL$PF{6,GPF14{{PFBLK{24110
{{IFF{2,BL$TE{6,GPF15{{TEBLK{24110
{{ESW{{{{END OF JUMP TABLE{24110
{{EJC{{{{{24111
*
*      GBCPF (CONTINUED)
*
*      CMBLK
*
{GPF04{MOV{13,CMLEN(XR){8,WA{{LOAD LENGTH{24117
{{MOV{19,*CMTYP{8,WB{{SET OFFSET{24118
*
*      HERE TO PUSH DOWN TO NEW LEVEL
*
*      (WC)                  FIELD PTR AT PREVIOUS LEVEL
*      (XR)                  PTR TO NEW BLOCK
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
{GPF05{ADD{7,XR{8,WA{{POINT PAST LAST RELOC FIELD{24127
{{ADD{8,WB{7,XR{{POINT TO FIRST RELOC FIELD{24128
{{MOV{8,WC{11,-(XS){{STACK OLD FIELD POINTER{24129
{{MOV{8,WA{11,-(XS){{STACK NEW LIMIT POINTER{24130
{{CHK{{{{CHECK FOR STACK OVERFLOW{24131
{{BRN{6,GPF01{{{IF OK, BACK TO PROCESS{24132
*
*      ARBLK
*
{GPF06{MOV{13,ARLEN(XR){8,WA{{LOAD LENGTH{24136
{{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO 1ST RELOC FLD (ARPRO){24137
{{BRN{6,GPF05{{{ALL SET{24138
*
*      CCBLK
*
{GPF07{MOV{13,CCUSE(XR){8,WA{{SET LENGTH IN USE{24142
{{MOV{19,*CCUSE{8,WB{{1ST WORD (MAKE SURE AT LEAST ONE){24143
{{BRN{6,GPF05{{{ALL SET{24144
{{EJC{{{{{24145
*
*      GBCPF (CONTINUED)
*
*      CDBLK
*
{GPF19{MOV{13,CDLEN(XR){8,WA{{LOAD LENGTH{24152
{{MOV{19,*CDFAL{8,WB{{SET OFFSET{24153
{{BRN{6,GPF05{{{JUMP BACK{24154
*
*      TBBLK, VCBLK
*
{GPF08{MOV{13,OFFS2(XR){8,WA{{LOAD LENGTH{24161
{{MOV{19,*OFFS3{8,WB{{SET OFFSET{24162
{{BRN{6,GPF05{{{JUMP BACK{24163
*
*      XRBLK
*
{GPF09{MOV{13,XRLEN(XR){8,WA{{LOAD LENGTH{24167
{{MOV{19,*XRPTR{8,WB{{SET OFFSET{24168
{{BRN{6,GPF05{{{JUMP BACK{24169
*
*      EVBLK, NMBLK, P0BLK
*
{GPF10{MOV{19,*OFFS2{8,WA{{POINT PAST SECOND FIELD{24173
{{MOV{19,*OFFS1{8,WB{{OFFSET IS ONE (ONLY RELOC FLD IS 2){24174
{{BRN{6,GPF05{{{ALL SET{24175
*
*      FFBLK
*
{GPF11{MOV{19,*FFOFS{8,WA{{SET LENGTH{24179
{{MOV{19,*FFNXT{8,WB{{SET OFFSET{24180
{{BRN{6,GPF05{{{ALL SET{24181
*
*      P1BLK, P2BLK
*
{GPF12{MOV{19,*PARM2{8,WA{{LENGTH (PARM2 IS NON-RELOCATABLE){24185
{{MOV{19,*PTHEN{8,WB{{SET OFFSET{24186
{{BRN{6,GPF05{{{ALL SET{24187
{{EJC{{{{{24188
*
*      GBCPF (CONTINUED)
*
*      PDBLK
*
{GPF13{MOV{13,PDDFP(XR){7,XL{{LOAD PTR TO DFBLK{24194
{{MOV{13,DFPDL(XL){8,WA{{GET PDBLK LENGTH{24195
{{MOV{19,*PDFLD{8,WB{{SET OFFSET{24196
{{BRN{6,GPF05{{{ALL SET{24197
*
*      PFBLK
*
{GPF14{MOV{19,*PFARG{8,WA{{LENGTH PAST LAST RELOC{24201
{{MOV{19,*PFCOD{8,WB{{OFFSET TO FIRST RELOC{24202
{{BRN{6,GPF05{{{ALL SET{24203
*
*      TEBLK
*
{GPF15{MOV{19,*TESI${8,WA{{SET LENGTH{24207
{{MOV{19,*TESUB{8,WB{{AND OFFSET{24208
{{BRN{6,GPF05{{{ALL SET{24209
*
*      TRBLK
*
{GPF16{MOV{19,*TRSI${8,WA{{SET LENGTH{24213
{{MOV{19,*TRVAL{8,WB{{AND OFFSET{24214
{{BRN{6,GPF05{{{ALL SET{24215
*
*      EXBLK
*
{GPF17{MOV{13,EXLEN(XR){8,WA{{LOAD LENGTH{24219
{{MOV{19,*EXFLC{8,WB{{SET OFFSET{24220
{{BRN{6,GPF05{{{JUMP BACK{24221
{{ENP{{{{END PROCEDURE GBCPF{24231
{{EJC{{{{{24232
*
*      GTARR -- GET ARRAY
*
*      GTARR IS PASSED AN OBJECT AND RETURNS AN ARRAY IF POSSIBL
*
*      (XR)                  VALUE TO BE CONVERTED
*      (WA)                  0 TO PLACE TABLE ADDRESSES IN ARRAY
*                            NON-ZERO FOR KEYS/VALUES IN ARRAY
*      JSR  GTARR            CALL TO GET ARRAY
*      PPM  LOC              TRANSFER LOC FOR ALL NULL TABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING ARRAY
*      (XL,WA,WB,WC)         DESTROYED
*
{GTARR{PRC{25,E{1,2{{ENTRY POINT{24247
{{MOV{8,WA{3,GTAWA{{SAVE WA INDICATOR{24248
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{24249
{{BEQ{8,WA{22,=B$ART{6,GTAR8{EXIT IF ALREADY AN ARRAY{24250
{{BEQ{8,WA{22,=B$VCT{6,GTAR8{EXIT IF ALREADY AN ARRAY{24251
{{BNE{8,WA{22,=B$TBT{6,GTA9A{ELSE FAIL IF NOT A TABLE (SGD02){24252
*
*      HERE WE CONVERT A TABLE TO AN ARRAY
*
{{MOV{7,XR{11,-(XS){{REPLACE TBBLK POINTER ON STACK{24256
{{ZER{7,XR{{{SIGNAL FIRST PASS{24257
{{ZER{8,WB{{{ZERO NON-NULL ELEMENT COUNT{24258
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. ON THE FIRST PASS,
*      SIGNALLED BY XR=0, THE NUMBER OF NON-NULL ELEMENTS IN
*      THE TABLE IS COUNTED IN WB. IN THE SECOND PASS, WHERE
*      XR IS A POINTER INTO THE ARBLK, THE NAME AND VALUE ARE
*      ENTERED INTO THE CURRENT ARBLK LOCATION PROVIDED GTAWA
*      IS NON-ZERO.  IF GTAWA IS ZERO, THE ADDRESS OF THE TEBLK
*      IS ENTERED INTO THE ARBLK TWICE (C3.762).
*
{GTAR1{MOV{9,(XS){7,XL{{POINT TO TABLE{24268
{{ADD{13,TBLEN(XL){7,XL{{POINT PAST LAST BUCKET{24269
{{SUB{19,*TBBUK{7,XL{{SET FIRST BUCKET OFFSET{24270
{{MOV{7,XL{8,WA{{COPY ADJUSTED POINTER{24271
*
*      LOOP THROUGH BUCKETS IN TABLE BLOCK
*      NEXT THREE LINES OF CODE RELY ON TENXT HAVING A VALUE
*      1 LESS THAN TBBUK.
*
{GTAR2{MOV{8,WA{7,XL{{COPY BUCKET POINTER{24277
{{DCA{8,WA{{{DECREMENT BUCKET POINTER{24278
*
*      LOOP THROUGH TEBLKS ON ONE BUCKET CHAIN
*
{GTAR3{MOV{13,TENXT(XL){7,XL{{POINT TO NEXT TEBLK{24282
{{BEQ{7,XL{9,(XS){6,GTAR6{JUMP IF CHAIN END (TBBLK PTR){24283
{{MOV{7,XL{3,CNVTP{{ELSE SAVE TEBLK POINTER{24284
*
*      LOOP TO FIND VALUE DOWN TRBLK CHAIN
*
{GTAR4{MOV{13,TEVAL(XL){7,XL{{LOAD VALUE{24288
{{BEQ{9,(XL){22,=B$TRT{6,GTAR4{LOOP TILL VALUE FOUND{24289
{{MOV{7,XL{8,WC{{COPY VALUE{24290
{{MOV{3,CNVTP{7,XL{{RESTORE TEBLK POINTER{24291
{{EJC{{{{{24292
*
*      GTARR (CONTINUED)
*
*      NOW CHECK FOR NULL AND TEST CASES
*
{{BEQ{8,WC{21,=NULLS{6,GTAR3{LOOP BACK TO IGNORE NULL VALUE{24298
{{BNZ{7,XR{6,GTAR5{{JUMP IF SECOND PASS{24299
{{ICV{8,WB{{{FOR THE FIRST PASS, BUMP COUNT{24300
{{BRN{6,GTAR3{{{AND LOOP BACK FOR NEXT TEBLK{24301
*
*      HERE IN SECOND PASS
*
{GTAR5{BZE{3,GTAWA{6,GTA5A{{JUMP IF ADDRESS WANTED{24305
{{MOV{13,TESUB(XL){10,(XR)+{{STORE SUBSCRIPT NAME{24306
{{MOV{8,WC{10,(XR)+{{STORE VALUE IN ARBLK{24307
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{24308
*
*      HERE TO RECORD TEBLK ADDRESS IN ARBLK.  THIS ALLOWS
*      A SORT ROUTINE TO SORT BY ASCENDING ADDRESS.
*
{GTA5A{MOV{7,XL{10,(XR)+{{STORE TEBLK ADDRESS IN NAME{24313
{{MOV{7,XL{10,(XR)+{{AND VALUE SLOTS{24314
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{24315
*
*      HERE AFTER SCANNING TEBLKS ON ONE CHAIN
*
{GTAR6{BNE{8,WA{9,(XS){6,GTAR2{LOOP BACK IF MORE BUCKETS TO GO{24319
{{BNZ{7,XR{6,GTAR7{{ELSE JUMP IF SECOND PASS{24320
*
*      HERE AFTER COUNTING NON-NULL ELEMENTS
*
{{BZE{8,WB{6,GTAR9{{FAIL IF NO NON-NULL ELEMENTS{24324
{{MOV{8,WB{8,WA{{ELSE COPY COUNT{24325
{{ADD{8,WB{8,WA{{DOUBLE (TWO WORDS/ELEMENT){24326
{{ADD{18,=ARVL2{8,WA{{ADD SPACE FOR STANDARD FIELDS{24327
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{24328
{{BGT{8,WA{3,MXLEN{6,GTA9B{ERROR IF TOO LONG FOR ARRAY{24329
{{JSR{6,ALLOC{{{ELSE ALLOCATE SPACE FOR ARBLK{24330
{{MOV{22,=B$ART{9,(XR){{STORE TYPE WORD{24331
{{ZER{13,IDVAL(XR){{{ZERO ID FOR THE MOMENT{24332
{{MOV{8,WA{13,ARLEN(XR){{STORE LENGTH{24333
{{MOV{18,=NUM02{13,ARNDM(XR){{SET DIMENSIONS = 2{24334
{{LDI{4,INTV1{{{GET INTEGER ONE{24335
{{STI{13,ARLBD(XR){{{STORE AS LBD 1{24336
{{STI{13,ARLB2(XR){{{STORE AS LBD 2{24337
{{LDI{4,INTV2{{{LOAD INTEGER TWO{24338
{{STI{13,ARDM2(XR){{{STORE AS DIM 2{24339
{{MTI{8,WB{{{GET ELEMENT COUNT AS INTEGER{24340
{{STI{13,ARDIM(XR){{{STORE AS DIM 1{24341
{{ZER{13,ARPR2(XR){{{ZERO PROTOTYPE FIELD FOR NOW{24342
{{MOV{19,*ARPR2{13,AROFS(XR){{SET OFFSET FIELD (SIGNAL PASS 2){24343
{{MOV{7,XR{8,WB{{SAVE ARBLK POINTER{24344
{{ADD{19,*ARVL2{7,XR{{POINT TO FIRST ELEMENT LOCATION{24345
{{BRN{6,GTAR1{{{JUMP BACK TO FILL IN ELEMENTS{24346
{{EJC{{{{{24347
*
*      GTARR (CONTINUED)
*
*      HERE AFTER FILLING IN ELEMENT VALUES
*
{GTAR7{MOV{8,WB{7,XR{{RESTORE ARBLK POINTER{24353
{{MOV{8,WB{9,(XS){{STORE AS RESULT{24354
*
*      NOW WE NEED THE ARRAY PROTOTYPE WHICH IS OF THE FORM NN,2
*      THIS IS OBTAINED BY BUILDING THE STRING FOR NN02 AND
*      CHANGING THE ZERO TO A COMMA BEFORE STORING IT.
*
{{LDI{13,ARDIM(XR){{{GET NUMBER OF ELEMENTS (NN){24360
{{MLI{4,INTVH{{{MULTIPLY BY 100{24361
{{ADI{4,INTV2{{{ADD 2 (NN02){24362
{{JSR{6,ICBLD{{{BUILD INTEGER{24363
{{MOV{7,XR{11,-(XS){{STORE PTR FOR GTSTG{24364
{{JSR{6,GTSTG{{{CONVERT TO STRING{24365
{{PPM{{{{CONVERT FAIL IS IMPOSSIBLE{24366
{{MOV{7,XR{7,XL{{COPY STRING POINTER{24367
{{MOV{10,(XS)+{7,XR{{RELOAD ARBLK POINTER{24368
{{MOV{7,XL{13,ARPR2(XR){{STORE PROTOTYPE PTR (NN02){24369
{{SUB{18,=NUM02{8,WA{{ADJUST LENGTH TO POINT TO ZERO{24370
{{PSC{7,XL{8,WA{{POINT TO ZERO{24371
{{MOV{18,=CH$CM{8,WB{{LOAD A COMMA{24372
{{SCH{8,WB{9,(XL){{STORE A COMMA OVER THE ZERO{24373
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{24374
*
*      NORMAL RETURN
*
{GTAR8{EXI{{{{RETURN TO CALLER{24378
*
*      NULL TABLE NON-CONVERSION RETURN
*
{GTAR9{MOV{10,(XS)+{7,XR{{RESTORE STACK FOR CONV ERR (SGD02){24382
{{EXI{1,1{{{RETURN{24383
*
*      IMPOSSIBLE CONVERSION RETURN
*
{GTA9A{EXI{1,2{{{RETURN{24387
*
*      ARRAY SIZE TOO LARGE
*
{GTA9B{ERB{1,260{26,Conversion array size exceeds maximum permitted{{{24391
{{ENP{{{{PROCEDURE GTARR{24392
{{EJC{{{{{24393
*
*      GTCOD -- CONVERT TO CODE
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTCOD            CALL TO CONVERT TO CODE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING CDBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTCOD{PRC{25,E{1,1{{ENTRY POINT{24407
{{BEQ{9,(XR){22,=B$CDS{6,GTCD1{JUMP IF ALREADY CODE{24408
{{BEQ{9,(XR){22,=B$CDC{6,GTCD1{JUMP IF ALREADY CODE{24409
*
*      HERE WE MUST GENERATE A CDBLK BY COMPILATION
*
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24413
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24414
{{PPM{6,GTCD2{{{JUMP IF NON-CONVERTIBLE{24415
{{MOV{3,FLPTR{3,GTCEF{{SAVE FAIL PTR IN CASE OF ERROR{24416
{{MOV{3,R$COD{3,R$GTC{{ALSO SAVE CODE PTR{24417
{{MOV{7,XR{3,R$CIM{{ELSE SET IMAGE POINTER{24418
{{MOV{8,WA{3,SCNIL{{SET IMAGE LENGTH{24419
{{ZER{3,SCNPT{{{SET SCAN POINTER{24420
{{MOV{18,=STGXC{3,STAGE{{SET STAGE FOR EXECUTE COMPILE{24421
{{MOV{3,CMPSN{3,LSTSN{{IN CASE LISTR CALLED{24422
{{ICV{3,CMPLN{{{BUMP LINE NUMBER{24424
{{JSR{6,CMPIL{{{COMPILE STRING{24426
{{MOV{18,=STGXT{3,STAGE{{RESET STAGE FOR EXECUTE TIME{24427
{{ZER{3,R$CIM{{{CLEAR IMAGE{24428
*
*      MERGE HERE IF NO CONVERT REQUIRED
*
{GTCD1{EXI{{{{GIVE NORMAL GTCOD RETURN{24432
*
*      HERE IF UNCONVERTIBLE
*
{GTCD2{EXI{1,1{{{GIVE ERROR RETURN{24436
{{ENP{{{{END PROCEDURE GTCOD{24437
{{EJC{{{{{24438
*
*      GTEXP -- CONVERT TO EXPRESSION
*
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      (XR)                  INPUT VALUE TO BE CONVERTED
*      JSR  GTEXP            CALL TO CONVERT TO EXPRESSION
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT EXBLK OR SEBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTEXP{PRC{25,E{1,1{{ENTRY POINT{24455
{{BLO{9,(XR){22,=B$E$${6,GTEX1{JUMP IF ALREADY AN EXPRESSION{24456
{{MOV{7,XR{11,-(XS){{STORE ARGUMENT FOR GTSTG{24457
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24458
{{PPM{6,GTEX2{{{JUMP IF UNCONVERTIBLE{24459
*
*      CHECK THE LAST CHARACTER OF THE STRING FOR COLON OR
*      SEMICOLON.  THESE CHARACTERS CAN LEGITIMATELY END AN
*      EXPRESSION IN OPEN CODE, SO EXPAN WILL NOT DETECT THEM
*      AS ERRORS, BUT THEY ARE INVALID AS TERMINATORS FOR A
*      STRING THAT IS BEING CONVERTED TO EXPRESSION FORM.
*
{{MOV{7,XR{7,XL{{COPY INPUT STRING POINTER{24467
{{PLC{7,XL{8,WA{{POINT ONE PAST THE STRING END{24468
{{LCH{7,XL{11,-(XL){{FETCH THE LAST CHARACTER{24469
{{BEQ{7,XL{18,=CH$CL{6,GTEX2{ERROR IF IT IS A SEMICOLON{24470
{{BEQ{7,XL{18,=CH$SM{6,GTEX2{OR IF IT IS A COLON{24471
*
*      HERE WE CONVERT A STRING BY COMPILATION
*
{{MOV{7,XR{3,R$CIM{{SET INPUT IMAGE POINTER{24475
{{ZER{3,SCNPT{{{SET SCAN POINTER{24476
{{MOV{8,WA{3,SCNIL{{SET INPUT IMAGE LENGTH{24477
{{MOV{8,WB{11,-(XS){{SAVE VALUE/NAME FLAG{24479
{{ZER{8,WB{{{SET CODE FOR NORMAL SCAN{24481
{{MOV{3,FLPTR{3,GTCEF{{SAVE FAIL PTR IN CASE OF ERROR{24482
{{MOV{3,R$COD{3,R$GTC{{ALSO SAVE CODE PTR{24483
{{MOV{18,=STGEV{3,STAGE{{ADJUST STAGE FOR COMPILE{24484
{{MOV{18,=T$UOK{3,SCNTP{{INDICATE UNARY OPERATOR ACCEPTABLE{24485
{{JSR{6,EXPAN{{{BUILD TREE FOR EXPRESSION{24486
{{ZER{3,SCNRS{{{RESET RESCAN FLAG{24487
{{MOV{10,(XS)+{8,WA{{RESTORE VALUE/NAME FLAG{24489
{{BNE{3,SCNPT{3,SCNIL{6,GTEX2{ERROR IF NOT END OF IMAGE{24491
{{ZER{8,WB{{{SET OK VALUE FOR CDGEX CALL{24492
{{MOV{7,XR{7,XL{{COPY TREE POINTER{24493
{{JSR{6,CDGEX{{{BUILD EXPRESSION BLOCK{24494
{{ZER{3,R$CIM{{{CLEAR POINTER{24495
{{MOV{18,=STGXT{3,STAGE{{RESTORE STAGE FOR EXECUTE TIME{24496
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTEX1{EXI{{{{RETURN TO GTEXP CALLER{24500
*
*      HERE IF UNCONVERTIBLE
*
{GTEX2{EXI{1,1{{{TAKE ERROR EXIT{24504
{{ENP{{{{END PROCEDURE GTEXP{24505
{{EJC{{{{{24506
*
*      GTINT -- GET INTEGER VALUE
*
*      GTINT IS PASSED AN OBJECT AND RETURNS AN INTEGER AFTER
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  VALUE TO BE CONVERTED
*      JSR  GTINT            CALL TO CONVERT TO INTEGER
*      PPM  LOC              TRANSFER LOC FOR CONVERT IMPOSSIBLE
*      (XR)                  RESULTING INTEGER
*      (WC,RA)               DESTROYED
*      (WA,WB)               DESTROYED (ONLY ON CONVERSION ERR)
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTINT{PRC{25,E{1,1{{ENTRY POINT{24521
{{BEQ{9,(XR){22,=B$ICL{6,GTIN2{JUMP IF ALREADY AN INTEGER{24522
{{MOV{8,WA{3,GTINA{{ELSE SAVE WA{24523
{{MOV{8,WB{3,GTINB{{SAVE WB{24524
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{24525
{{PPM{6,GTIN3{{{JUMP IF UNCONVERTIBLE{24526
{{BEQ{8,WA{22,=B$ICL{6,GTIN1{JUMP IF INTEGER{24529
*
*      HERE WE CONVERT A REAL TO INTEGER
*
{{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{24533
{{RTI{6,GTIN3{{{CONVERT TO INTEGER (ERR IF OVFLOW){24534
{{JSR{6,ICBLD{{{IF OK BUILD ICBLK{24535
*
*      HERE AFTER SUCCESSFUL CONVERSION TO INTEGER
*
{GTIN1{MOV{3,GTINA{8,WA{{RESTORE WA{24540
{{MOV{3,GTINB{8,WB{{RESTORE WB{24541
*
*      COMMON EXIT POINT
*
{GTIN2{EXI{{{{RETURN TO GTINT CALLER{24545
*
*      HERE ON CONVERSION ERROR
*
{GTIN3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{24549
{{ENP{{{{END PROCEDURE GTINT{24550
{{EJC{{{{{24551
*
*      GTNUM -- GET NUMERIC VALUE
*
*      GTNUM IS GIVEN AN OBJECT AND RETURNS EITHER AN INTEGER
*      OR A REAL, PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTNUM            CALL TO CONVERT TO NUMERIC
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT (INT OR REAL)
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WB,WC,RA)            DESTROYED
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTNUM{PRC{25,E{1,1{{ENTRY POINT{24566
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{24567
{{BEQ{8,WA{22,=B$ICL{6,GTN34{JUMP IF INTEGER (NO CONVERSION){24568
{{BEQ{8,WA{22,=B$RCL{6,GTN34{JUMP IF REAL (NO CONVERSION){24571
*
*      AT THIS POINT THE ONLY POSSIBILITY IS TO CONVERT A STRING
*      TO AN INTEGER OR REAL AS APPROPRIATE.
*
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT IN CASE CONVERT ERR{24577
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24578
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24580
{{PPM{6,GTN36{{{JUMP IF UNCONVERTIBLE{24584
*
*      INITIALIZE NUMERIC CONVERSION
*
{{LDI{4,INTV0{{{INITIALIZE INTEGER RESULT TO ZERO{24588
{{BZE{8,WA{6,GTN32{{JUMP TO EXIT WITH ZERO IF NULL{24589
{{LCT{8,WA{8,WA{{SET BCT COUNTER FOR FOLLOWING LOOPS{24590
{{ZER{3,GTNNF{{{TENTATIVELY INDICATE RESULT +{24591
{{STI{3,GTNEX{{{INITIALISE EXPONENT TO ZERO{24594
{{ZER{3,GTNSC{{{ZERO SCALE IN CASE REAL{24595
{{ZER{3,GTNDF{{{RESET FLAG FOR DEC POINT FOUND{24596
{{ZER{3,GTNRD{{{RESET FLAG FOR DIGITS FOUND{24597
{{LDR{4,REAV0{{{ZERO REAL ACCUM IN CASE REAL{24598
{{PLC{7,XR{{{POINT TO ARGUMENT CHARACTERS{24600
*
*      MERGE BACK HERE AFTER IGNORING LEADING BLANK
*
{GTN01{LCH{8,WB{10,(XR)+{{LOAD FIRST CHARACTER{24604
{{BLT{8,WB{18,=CH$D0{6,GTN02{JUMP IF NOT DIGIT{24605
{{BLE{8,WB{18,=CH$D9{6,GTN06{JUMP IF FIRST CHAR IS A DIGIT{24606
{{EJC{{{{{24607
*
*      GTNUM (CONTINUED)
*
*      HERE IF FIRST DIGIT IS NON-DIGIT
*
{GTN02{BNE{8,WB{18,=CH$BL{6,GTN03{JUMP IF NON-BLANK{24613
{GTNA2{BCT{8,WA{6,GTN01{{ELSE DECR COUNT AND LOOP BACK{24614
{{BRN{6,GTN07{{{JUMP TO RETURN ZERO IF ALL BLANKS{24615
*
*      HERE FOR FIRST CHARACTER NON-BLANK, NON-DIGIT
*
{GTN03{BEQ{8,WB{18,=CH$PL{6,GTN04{JUMP IF PLUS SIGN{24619
{{BEQ{8,WB{18,=CH$HT{6,GTNA2{HORIZONTAL TAB EQUIV TO BLANK{24621
{{BNE{8,WB{18,=CH$MN{6,GTN12{JUMP IF NOT MINUS (MAY BE REAL){24629
{{MNZ{3,GTNNF{{{IF MINUS SIGN, SET NEGATIVE FLAG{24631
*
*      MERGE HERE AFTER PROCESSING SIGN
*
{GTN04{BCT{8,WA{6,GTN05{{JUMP IF CHARS LEFT{24635
{{BRN{6,GTN36{{{ELSE ERROR{24636
*
*      LOOP TO FETCH CHARACTERS OF AN INTEGER
*
{GTN05{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24640
{{BLT{8,WB{18,=CH$D0{6,GTN08{JUMP IF NOT A DIGIT{24641
{{BGT{8,WB{18,=CH$D9{6,GTN08{JUMP IF NOT A DIGIT{24642
*
*      MERGE HERE FOR FIRST DIGIT
*
{GTN06{STI{3,GTNSI{{{SAVE CURRENT VALUE{24646
{{CVM{6,GTN35{{{CURRENT*10-(NEW DIG) JUMP IF OVFLOW{24650
{{MNZ{3,GTNRD{{{SET DIGIT READ FLAG{24651
{{BCT{8,WA{6,GTN05{{ELSE LOOP BACK IF MORE CHARS{24653
*
*      HERE TO EXIT WITH CONVERTED INTEGER VALUE
*
{GTN07{BNZ{3,GTNNF{6,GTN32{{JUMP IF NEGATIVE (ALL SET){24657
{{NGI{{{{ELSE NEGATE{24658
{{INO{6,GTN32{{{JUMP IF NO OVERFLOW{24659
{{BRN{6,GTN36{{{ELSE SIGNAL ERROR{24660
{{EJC{{{{{24661
*
*      GTNUM (CONTINUED)
*
*      HERE FOR A NON-DIGIT CHARACTER WHILE ATTEMPTING TO
*      CONVERT AN INTEGER, CHECK FOR TRAILING BLANKS OR REAL.
*
{GTN08{BEQ{8,WB{18,=CH$BL{6,GTNA9{JUMP IF A BLANK{24668
{{BEQ{8,WB{18,=CH$HT{6,GTNA9{JUMP IF HORIZONTAL TAB{24670
{{ITR{{{{ELSE CONVERT INTEGER TO REAL{24678
{{NGR{{{{NEGATE TO GET POSITIVE VALUE{24679
{{BRN{6,GTN12{{{JUMP TO TRY FOR REAL{24680
*
*      HERE WE SCAN OUT BLANKS TO END OF STRING
*
{GTN09{LCH{8,WB{10,(XR)+{{GET NEXT CHAR{24685
{{BEQ{8,WB{18,=CH$HT{6,GTNA9{JUMP IF HORIZONTAL TAB{24687
{{BNE{8,WB{18,=CH$BL{6,GTN36{ERROR IF NON-BLANK{24692
{GTNA9{BCT{8,WA{6,GTN09{{LOOP BACK IF MORE CHARS TO CHECK{24693
{{BRN{6,GTN07{{{RETURN INTEGER IF ALL BLANKS{24694
*
*      LOOP TO COLLECT MANTISSA OF REAL
*
{GTN10{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24700
{{BLT{8,WB{18,=CH$D0{6,GTN12{JUMP IF NON-NUMERIC{24701
{{BGT{8,WB{18,=CH$D9{6,GTN12{JUMP IF NON-NUMERIC{24702
*
*      MERGE HERE TO COLLECT FIRST REAL DIGIT
*
{GTN11{SUB{18,=CH$D0{8,WB{{CONVERT DIGIT TO NUMBER{24706
{{MLR{4,REAVT{{{MULTIPLY REAL BY 10.0{24707
{{ROV{6,GTN36{{{CONVERT ERROR IF OVERFLOW{24708
{{STR{3,GTNSR{{{SAVE RESULT{24709
{{MTI{8,WB{{{GET NEW DIGIT AS INTEGER{24710
{{ITR{{{{CONVERT NEW DIGIT TO REAL{24711
{{ADR{3,GTNSR{{{ADD TO GET NEW TOTAL{24712
{{ADD{3,GTNDF{3,GTNSC{{INCREMENT SCALE IF AFTER DEC POINT{24713
{{MNZ{3,GTNRD{{{SET DIGIT FOUND FLAG{24714
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{24715
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24716
{{EJC{{{{{24717
*
*      GTNUM (CONTINUED)
*
*      HERE IF NON-DIGIT FOUND WHILE COLLECTING A REAL
*
{GTN12{BNE{8,WB{18,=CH$DT{6,GTN13{JUMP IF NOT DEC POINT{24723
{{BNZ{3,GTNDF{6,GTN36{{IF DEC POINT, ERROR IF ONE ALREADY{24724
{{MOV{18,=NUM01{3,GTNDF{{ELSE SET FLAG FOR DEC POINT{24725
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{24726
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24727
*
*      HERE IF NOT DECIMAL POINT
*
{GTN13{BEQ{8,WB{18,=CH$LE{6,GTN15{JUMP IF E FOR EXPONENT{24731
{{BEQ{8,WB{18,=CH$LD{6,GTN15{JUMP IF D FOR EXPONENT{24732
{{BEQ{8,WB{18,=CH$$E{6,GTN15{JUMP IF E FOR EXPONENT{24734
{{BEQ{8,WB{18,=CH$$D{6,GTN15{JUMP IF D FOR EXPONENT{24735
*
*      HERE CHECK FOR TRAILING BLANKS
*
{GTN14{BEQ{8,WB{18,=CH$BL{6,GTNB4{JUMP IF BLANK{24740
{{BEQ{8,WB{18,=CH$HT{6,GTNB4{JUMP IF HORIZONTAL TAB{24742
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{24747
*
{GTNB4{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{24749
{{BCT{8,WA{6,GTN14{{LOOP BACK TO CHECK IF MORE{24750
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24751
*
*      HERE TO READ AND PROCESS AN EXPONENT
*
{GTN15{ZER{3,GTNES{{{SET EXPONENT SIGN POSITIVE{24755
{{LDI{4,INTV0{{{INITIALIZE EXPONENT TO ZERO{24756
{{MNZ{3,GTNDF{{{RESET NO DEC POINT INDICATION{24757
{{BCT{8,WA{6,GTN16{{JUMP SKIPPING PAST E OR D{24758
{{BRN{6,GTN36{{{ERROR IF NULL EXPONENT{24759
*
*      CHECK FOR EXPONENT SIGN
*
{GTN16{LCH{8,WB{10,(XR)+{{LOAD FIRST EXPONENT CHARACTER{24763
{{BEQ{8,WB{18,=CH$PL{6,GTN17{JUMP IF PLUS SIGN{24764
{{BNE{8,WB{18,=CH$MN{6,GTN19{ELSE JUMP IF NOT MINUS SIGN{24765
{{MNZ{3,GTNES{{{SET SIGN NEGATIVE IF MINUS SIGN{24766
*
*      MERGE HERE AFTER PROCESSING EXPONENT SIGN
*
{GTN17{BCT{8,WA{6,GTN18{{JUMP IF CHARS LEFT{24770
{{BRN{6,GTN36{{{ELSE ERROR{24771
*
*      LOOP TO CONVERT EXPONENT DIGITS
*
{GTN18{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24775
{{EJC{{{{{24776
*
*      GTNUM (CONTINUED)
*
*      MERGE HERE FOR FIRST EXPONENT DIGIT
*
{GTN19{BLT{8,WB{18,=CH$D0{6,GTN20{JUMP IF NOT DIGIT{24782
{{BGT{8,WB{18,=CH$D9{6,GTN20{JUMP IF NOT DIGIT{24783
{{CVM{6,GTN36{{{ELSE CURRENT*10, SUBTRACT NEW DIGIT{24784
{{BCT{8,WA{6,GTN18{{LOOP BACK IF MORE CHARS{24785
{{BRN{6,GTN21{{{JUMP IF EXPONENT FIELD IS EXHAUSTED{24786
*
*      HERE TO CHECK FOR TRAILING BLANKS AFTER EXPONENT
*
{GTN20{BEQ{8,WB{18,=CH$BL{6,GTNC0{JUMP IF BLANK{24790
{{BEQ{8,WB{18,=CH$HT{6,GTNC0{JUMP IF HORIZONTAL TAB{24792
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{24797
*
{GTNC0{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{24799
{{BCT{8,WA{6,GTN20{{LOOP BACK TILL ALL BLANKS SCANNED{24800
*
*      MERGE HERE AFTER COLLECTING EXPONENT
*
{GTN21{STI{3,GTNEX{{{SAVE COLLECTED EXPONENT{24804
{{BNZ{3,GTNES{6,GTN22{{JUMP IF IT WAS NEGATIVE{24805
{{NGI{{{{ELSE COMPLEMENT{24806
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24807
{{STI{3,GTNEX{{{AND STORE POSITIVE EXPONENT{24808
*
*      MERGE HERE WITH EXPONENT (0 IF NONE GIVEN)
*
{GTN22{BZE{3,GTNRD{6,GTN36{{ERROR IF NOT DIGITS COLLECTED{24812
{{BZE{3,GTNDF{6,GTN36{{ERROR IF NO EXPONENT OR DEC POINT{24813
{{MTI{3,GTNSC{{{ELSE LOAD SCALE AS INTEGER{24814
{{SBI{3,GTNEX{{{SUBTRACT EXPONENT{24815
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24816
{{ILT{6,GTN26{{{JUMP IF WE MUST SCALE UP{24817
*
*      HERE WE HAVE A NEGATIVE EXPONENT, SO SCALE DOWN
*
{{MFI{8,WA{6,GTN36{{LOAD SCALE FACTOR, ERR IF OVFLOW{24821
*
*      LOOP TO SCALE DOWN IN STEPS OF 10**10
*
{GTN23{BLE{8,WA{18,=NUM10{6,GTN24{JUMP IF 10 OR LESS TO GO{24825
{{DVR{4,REATT{{{ELSE DIVIDE BY 10**10{24826
{{SUB{18,=NUM10{8,WA{{DECREMENT SCALE{24827
{{BRN{6,GTN23{{{AND LOOP BACK{24828
{{EJC{{{{{24829
*
*      GTNUM (CONTINUED)
*
*      HERE SCALE REST OF WAY FROM POWERS OF TEN TABLE
*
{GTN24{BZE{8,WA{6,GTN30{{JUMP IF SCALED{24835
{{LCT{8,WB{18,=CFP$R{{ELSE GET INDEXING FACTOR{24836
{{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{24837
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{24838
*
*      LOOP TO POINT TO POWERS OF TEN TABLE ENTRY
*
{GTN25{ADD{8,WA{7,XR{{BUMP POINTER{24842
{{BCT{8,WB{6,GTN25{{ONCE FOR EACH VALUE WORD{24843
{{DVR{9,(XR){{{SCALE DOWN AS REQUIRED{24844
{{BRN{6,GTN30{{{AND JUMP{24845
*
*      COME HERE TO SCALE RESULT UP (POSITIVE EXPONENT)
*
{GTN26{NGI{{{{GET ABSOLUTE VALUE OF EXPONENT{24849
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24850
{{MFI{8,WA{6,GTN36{{ACQUIRE SCALE, ERROR IF OVFLOW{24851
*
*      LOOP TO SCALE UP IN STEPS OF 10**10
*
{GTN27{BLE{8,WA{18,=NUM10{6,GTN28{JUMP IF 10 OR LESS TO GO{24855
{{MLR{4,REATT{{{ELSE MULTIPLY BY 10**10{24856
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{24857
{{SUB{18,=NUM10{8,WA{{ELSE DECREMENT SCALE{24858
{{BRN{6,GTN27{{{AND LOOP BACK{24859
*
*      HERE TO SCALE UP REST OF WAY WITH TABLE
*
{GTN28{BZE{8,WA{6,GTN30{{JUMP IF SCALED{24863
{{LCT{8,WB{18,=CFP$R{{ELSE GET INDEXING FACTOR{24864
{{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{24865
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{24866
*
*      LOOP TO POINT TO PROPER ENTRY IN POWERS OF TEN TABLE
*
{GTN29{ADD{8,WA{7,XR{{BUMP POINTER{24870
{{BCT{8,WB{6,GTN29{{ONCE FOR EACH WORD IN VALUE{24871
{{MLR{9,(XR){{{SCALE UP{24872
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{24873
{{EJC{{{{{24874
*
*      GTNUM (CONTINUED)
*
*      HERE WITH REAL VALUE SCALED AND READY EXCEPT FOR SIGN
*
{GTN30{BZE{3,GTNNF{6,GTN31{{JUMP IF POSITIVE{24880
{{NGR{{{{ELSE NEGATE{24881
*
*      HERE WITH PROPERLY SIGNED REAL VALUE IN (RA)
*
{GTN31{JSR{6,RCBLD{{{BUILD REAL BLOCK{24885
{{BRN{6,GTN33{{{MERGE TO EXIT{24886
*
*      HERE WITH PROPERLY SIGNED INTEGER VALUE IN (IA)
*
{GTN32{JSR{6,ICBLD{{{BUILD ICBLK{24891
*
*      REAL MERGES HERE
*
{GTN33{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF RESULT BLOCK{24895
{{ICA{7,XS{{{POP ARGUMENT OFF STACK{24896
*
*      COMMON EXIT POINT
*
{GTN34{EXI{{{{RETURN TO GTNUM CALLER{24900
*
*      COME HERE IF OVERFLOW OCCURS DURING COLLECTION OF INTEGER
*      HAVE TO RESTORE WB WHICH CVM MAY HAVE DESTROYED.
*
{GTN35{LCH{8,WB{11,-(XR){{RELOAD CURRENT CHARACTER{24907
{{LCH{8,WB{10,(XR)+{{BUMP CHARACTER POINTER{24908
{{LDI{3,GTNSI{{{RELOAD INTEGER SO FAR{24909
{{ITR{{{{CONVERT TO REAL{24910
{{NGR{{{{MAKE VALUE POSITIVE{24911
{{BRN{6,GTN11{{{MERGE WITH REAL CIRCUIT{24912
*
*      HERE FOR UNCONVERTIBLE TO STRING OR CONVERSION ERROR
*
{GTN36{MOV{10,(XS)+{7,XR{{RELOAD ORIGINAL ARGUMENT{24917
{{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{24918
{{ENP{{{{END PROCEDURE GTNUM{24919
{{EJC{{{{{24920
*
*      GTNVR -- CONVERT TO NATURAL VARIABLE
*
*      GTNVR LOCATES A VARIABLE BLOCK (VRBLK) GIVEN EITHER AN
*      APPROPRIATE NAME (NMBLK) OR A NON-NULL STRING (SCBLK).
*
*      (XR)                  ARGUMENT
*      JSR  GTNVR            CALL TO CONVERT TO NATURAL VARIABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO VRBLK
*      (WA,WB)               DESTROYED (CONVERSION ERROR ONLY)
*      (WC)                  DESTROYED
*
{GTNVR{PRC{25,E{1,1{{ENTRY POINT{24934
{{BNE{9,(XR){22,=B$NML{6,GNV02{JUMP IF NOT NAME{24935
{{MOV{13,NMBAS(XR){7,XR{{ELSE LOAD NAME BASE IF NAME{24936
{{BLO{7,XR{3,STATE{6,GNV07{SKIP IF VRBLK (IN STATIC REGION){24937
*
*      COMMON ERROR EXIT
*
{GNV01{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{24941
*
*      HERE IF NOT NAME
*
{GNV02{MOV{8,WA{3,GNVSA{{SAVE WA{24945
{{MOV{8,WB{3,GNVSB{{SAVE WB{24946
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24947
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24948
{{PPM{6,GNV01{{{JUMP IF CONVERSION ERROR{24949
{{BZE{8,WA{6,GNV01{{NULL STRING IS AN ERROR{24950
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{24952
{{MOV{7,XL{11,-(XS){{SAVE XL{24954
{{MOV{7,XR{11,-(XS){{STACK STRING PTR FOR LATER{24955
{{MOV{7,XR{8,WB{{COPY STRING POINTER{24956
{{ADD{19,*SCHAR{8,WB{{POINT TO CHARACTERS OF STRING{24957
{{MOV{8,WB{3,GNVST{{SAVE POINTER TO CHARACTERS{24958
{{MOV{8,WA{8,WB{{COPY LENGTH{24959
{{CTW{8,WB{1,0{{GET NUMBER OF WORDS IN NAME{24960
{{MOV{8,WB{3,GNVNW{{SAVE FOR LATER{24961
{{JSR{6,HASHS{{{COMPUTE HASH INDEX FOR STRING{24962
{{RMI{3,HSHNB{{{COMPUTE HASH OFFSET BY TAKING MOD{24963
{{MFI{8,WC{{{GET AS OFFSET{24964
{{WTB{8,WC{{{CONVERT OFFSET TO BYTES{24965
{{ADD{3,HSHTB{8,WC{{POINT TO PROPER HASH CHAIN{24966
{{SUB{19,*VRNXT{8,WC{{SUBTRACT OFFSET TO MERGE INTO LOOP{24967
{{EJC{{{{{24968
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH HASH CHAIN
*
{GNV03{MOV{8,WC{7,XL{{COPY HASH CHAIN POINTER{24974
{{MOV{13,VRNXT(XL){7,XL{{POINT TO NEXT VRBLK ON CHAIN{24975
{{BZE{7,XL{6,GNV08{{JUMP IF END OF CHAIN{24976
{{MOV{7,XL{8,WC{{SAVE POINTER TO THIS VRBLK{24977
{{BNZ{13,VRLEN(XL){6,GNV04{{JUMP IF NOT SYSTEM VARIABLE{24978
{{MOV{13,VRSVP(XL){7,XL{{ELSE POINT TO SVBLK{24979
{{SUB{19,*VRSOF{7,XL{{ADJUST OFFSET FOR MERGE{24980
*
*      MERGE HERE WITH STRING PTR (LIKE VRBLK) IN XL
*
{GNV04{BNE{8,WA{13,VRLEN(XL){6,GNV03{BACK FOR NEXT VRBLK IF LENGTHS NE{24984
{{ADD{19,*VRCHS{7,XL{{ELSE POINT TO CHARS OF CHAIN ENTRY{24985
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{24986
{{MOV{3,GNVST{7,XR{{POINT TO CHARS OF NEW NAME{24987
*
*      LOOP TO COMPARE CHARACTERS OF THE TWO NAMES
*
{GNV05{CNE{9,(XR){9,(XL){6,GNV03{JUMP IF NO MATCH FOR NEXT VRBLK{24991
{{ICA{7,XR{{{BUMP NEW NAME POINTER{24992
{{ICA{7,XL{{{BUMP VRBLK IN CHAIN NAME POINTER{24993
{{BCT{8,WB{6,GNV05{{ELSE LOOP TILL ALL COMPARED{24994
{{MOV{8,WC{7,XR{{WE HAVE FOUND A MATCH, GET VRBLK{24995
*
*      EXIT POINT AFTER FINDING VRBLK OR BUILDING NEW ONE
*
{GNV06{MOV{3,GNVSA{8,WA{{RESTORE WA{24999
{{MOV{3,GNVSB{8,WB{{RESTORE WB{25000
{{ICA{7,XS{{{POP STRING POINTER{25001
{{MOV{10,(XS)+{7,XL{{RESTORE XL{25002
*
*      COMMON EXIT POINT
*
{GNV07{EXI{{{{RETURN TO GTNVR CALLER{25006
*
*      NOT FOUND, PREPARE TO SEARCH SYSTEM VARIABLE TABLE
*
{GNV08{ZER{7,XR{{{CLEAR GARBAGE XR POINTER{25010
{{MOV{8,WC{3,GNVHE{{SAVE PTR TO END OF HASH CHAIN{25011
{{BGT{8,WA{18,=NUM09{6,GNV14{CANNOT BE SYSTEM VAR IF LENGTH GT 9{25012
{{MOV{8,WA{7,XL{{ELSE COPY LENGTH{25013
{{WTB{7,XL{{{CONVERT TO BYTE OFFSET{25014
{{MOV{14,VSRCH(XL){7,XL{{POINT TO FIRST SVBLK OF THIS LENGTH{25015
{{EJC{{{{{25016
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH ENTRIES IN STANDARD VARIABLE TABLE
*
{GNV09{MOV{7,XL{3,GNVSP{{SAVE TABLE POINTER{25022
{{MOV{10,(XL)+{8,WC{{LOAD SVBIT BIT STRING{25023
{{MOV{10,(XL)+{8,WB{{LOAD LENGTH FROM TABLE ENTRY{25024
{{BNE{8,WA{8,WB{6,GNV14{JUMP IF END OF RIGHT LENGTH ENTRIES{25025
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{25026
{{MOV{3,GNVST{7,XR{{POINT TO CHARS OF NEW NAME{25027
*
*      LOOP TO CHECK FOR MATCHING NAMES
*
{GNV10{CNE{9,(XR){9,(XL){6,GNV11{JUMP IF NAME MISMATCH{25031
{{ICA{7,XR{{{ELSE BUMP NEW NAME POINTER{25032
{{ICA{7,XL{{{BUMP SVBLK POINTER{25033
{{BCT{8,WB{6,GNV10{{ELSE LOOP UNTIL ALL CHECKED{25034
*
*      HERE WE HAVE A MATCH IN THE STANDARD VARIABLE TABLE
*
{{ZER{8,WC{{{SET VRLEN VALUE ZERO{25038
{{MOV{19,*VRSI${8,WA{{SET STANDARD SIZE{25039
{{BRN{6,GNV15{{{JUMP TO BUILD VRBLK{25040
*
*      HERE IF NO MATCH WITH TABLE ENTRY IN SVBLKS TABLE
*
{GNV11{ICA{7,XL{{{BUMP PAST WORD OF CHARS{25044
{{BCT{8,WB{6,GNV11{{LOOP BACK IF MORE TO GO{25045
{{RSH{8,WC{2,SVNBT{{REMOVE UNINTERESTING BITS{25046
*
*      LOOP TO BUMP TABLE PTR FOR EACH FLAGGED WORD
*
{GNV12{MOV{4,BITS1{8,WB{{LOAD BIT TO TEST{25050
{{ANB{8,WC{8,WB{{TEST FOR WORD PRESENT{25051
{{ZRB{8,WB{6,GNV13{{JUMP IF NOT PRESENT{25052
{{ICA{7,XL{{{ELSE BUMP TABLE POINTER{25053
*
*      HERE AFTER DEALING WITH ONE WORD (ONE BIT)
*
{GNV13{RSH{8,WC{1,1{{REMOVE BIT ALREADY PROCESSED{25057
{{NZB{8,WC{6,GNV12{{LOOP BACK IF MORE BITS TO TEST{25058
{{BRN{6,GNV09{{{ELSE LOOP BACK FOR NEXT SVBLK{25059
*
*      HERE IF NOT SYSTEM VARIABLE
*
{GNV14{MOV{8,WA{8,WC{{COPY VRLEN VALUE{25063
{{MOV{18,=VRCHS{8,WA{{LOAD STANDARD SIZE -CHARS{25064
{{ADD{3,GNVNW{8,WA{{ADJUST FOR CHARS OF NAME{25065
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{25066
{{EJC{{{{{25067
*
*      GTNVR (CONTINUED)
*
*      MERGE HERE TO BUILD VRBLK
*
{GNV15{JSR{6,ALOST{{{ALLOCATE SPACE FOR VRBLK (STATIC){25073
{{MOV{7,XR{8,WB{{SAVE VRBLK POINTER{25074
{{MOV{21,=STNVR{7,XL{{POINT TO MODEL VARIABLE BLOCK{25075
{{MOV{19,*VRLEN{8,WA{{SET LENGTH OF STANDARD FIELDS{25076
{{MVW{{{{SET INITIAL FIELDS OF NEW BLOCK{25077
{{MOV{3,GNVHE{7,XL{{LOAD POINTER TO END OF HASH CHAIN{25078
{{MOV{8,WB{13,VRNXT(XL){{ADD NEW BLOCK TO END OF CHAIN{25079
{{MOV{8,WC{10,(XR)+{{SET VRLEN FIELD, BUMP PTR{25080
{{MOV{3,GNVNW{8,WA{{GET LENGTH IN WORDS{25081
{{WTB{8,WA{{{CONVERT TO LENGTH IN BYTES{25082
{{BZE{8,WC{6,GNV16{{JUMP IF SYSTEM VARIABLE{25083
*
*      HERE FOR NON-SYSTEM VARIABLE -- SET CHARS OF NAME
*
{{MOV{9,(XS){7,XL{{POINT BACK TO STRING NAME{25087
{{ADD{19,*SCHAR{7,XL{{POINT TO CHARS OF NAME{25088
{{MVW{{{{MOVE CHARACTERS INTO PLACE{25089
{{MOV{8,WB{7,XR{{RESTORE VRBLK POINTER{25090
{{BRN{6,GNV06{{{JUMP BACK TO EXIT{25091
*
*      HERE FOR SYSTEM VARIABLE CASE TO FILL IN FIELDS WHERE
*      NECESSARY FROM THE FIELDS PRESENT IN THE SVBLK.
*
{GNV16{MOV{3,GNVSP{7,XL{{LOAD POINTER TO SVBLK{25096
{{MOV{7,XL{9,(XR){{SET SVBLK PTR IN VRBLK{25097
{{MOV{8,WB{7,XR{{RESTORE VRBLK POINTER{25098
{{MOV{13,SVBIT(XL){8,WB{{LOAD BIT INDICATORS{25099
{{ADD{19,*SVCHS{7,XL{{POINT TO CHARACTERS OF NAME{25100
{{ADD{8,WA{7,XL{{POINT PAST CHARACTERS{25101
*
*      SKIP PAST KEYWORD NUMBER (SVKNM) IF PRESENT
*
{{MOV{4,BTKNM{8,WC{{LOAD TEST BIT{25105
{{ANB{8,WB{8,WC{{AND TO TEST{25106
{{ZRB{8,WC{6,GNV17{{JUMP IF NO KEYWORD NUMBER{25107
{{ICA{7,XL{{{ELSE BUMP POINTER{25108
{{EJC{{{{{25109
*
*      GTNVR (CONTINUED)
*
*      HERE TEST FOR FUNCTION (SVFNC AND SVNAR)
*
{GNV17{MOV{4,BTFNC{8,WC{{GET TEST BIT{25115
{{ANB{8,WB{8,WC{{AND TO TEST{25116
{{ZRB{8,WC{6,GNV18{{SKIP IF NO SYSTEM FUNCTION{25117
{{MOV{7,XL{13,VRFNC(XR){{ELSE POINT VRFNC TO SVFNC FIELD{25118
{{ADD{19,*NUM02{7,XL{{AND BUMP PAST SVFNC, SVNAR FIELDS{25119
*
*      NOW TEST FOR LABEL (SVLBL)
*
{GNV18{MOV{4,BTLBL{8,WC{{GET TEST BIT{25123
{{ANB{8,WB{8,WC{{AND TO TEST{25124
{{ZRB{8,WC{6,GNV19{{JUMP IF BIT IS OFF (NO SYSTEM LABL){25125
{{MOV{7,XL{13,VRLBL(XR){{ELSE POINT VRLBL TO SVLBL FIELD{25126
{{ICA{7,XL{{{BUMP PAST SVLBL FIELD{25127
*
*      NOW TEST FOR VALUE (SVVAL)
*
{GNV19{MOV{4,BTVAL{8,WC{{LOAD TEST BIT{25131
{{ANB{8,WB{8,WC{{AND TO TEST{25132
{{ZRB{8,WC{6,GNV06{{ALL DONE IF NO VALUE{25133
{{MOV{9,(XL){13,VRVAL(XR){{ELSE SET INITIAL VALUE{25134
{{MOV{22,=B$VRE{13,VRSTO(XR){{SET ERROR STORE ACCESS{25135
{{BRN{6,GNV06{{{MERGE BACK TO EXIT TO CALLER{25136
{{ENP{{{{END PROCEDURE GTNVR{25137
{{EJC{{{{{25138
*
*      GTPAT -- GET PATTERN
*
*      GTPAT IS PASSED AN OBJECT IN (XR) AND RETURNS A
*      PATTERN AFTER PERFORMING ANY NECESSARY CONVERSIONS
*
*      (XR)                  INPUT ARGUMENT
*      JSR  GTPAT            CALL TO CONVERT TO PATTERN
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING PATTERN
*      (WA)                  DESTROYED
*      (WB)                  DESTROYED (ONLY ON CONVERT ERROR)
*      (XR)                  UNCHANGED (ONLY ON CONVERT ERROR)
*
{GTPAT{PRC{25,E{1,1{{ENTRY POINT{25153
{{BHI{9,(XR){22,=P$AAA{6,GTPT5{JUMP IF PATTERN ALREADY{25154
*
*      HERE IF NOT PATTERN, TRY FOR STRING
*
{{MOV{8,WB{3,GTPSB{{SAVE WB{25158
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{25159
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{25160
{{PPM{6,GTPT2{{{JUMP IF IMPOSSIBLE{25161
*
*      HERE WE HAVE A STRING
*
{{BNZ{8,WA{6,GTPT1{{JUMP IF NON-NULL{25165
*
*      HERE FOR NULL STRING. GENERATE POINTER TO NULL PATTERN.
*
{{MOV{21,=NDNTH{7,XR{{POINT TO NOTHEN NODE{25169
{{BRN{6,GTPT4{{{JUMP TO EXIT{25170
{{EJC{{{{{25171
*
*      GTPAT (CONTINUED)
*
*      HERE FOR NON-NULL STRING
*
{GTPT1{MOV{22,=P$STR{8,WB{{LOAD PCODE FOR MULTI-CHAR STRING{25177
{{BNE{8,WA{18,=NUM01{6,GTPT3{JUMP IF MULTI-CHAR STRING{25178
*
*      HERE FOR ONE CHARACTER STRING, SHARE ONE CHARACTER ANY
*
{{PLC{7,XR{{{POINT TO CHARACTER{25182
{{LCH{8,WA{9,(XR){{LOAD CHARACTER{25183
{{MOV{8,WA{7,XR{{SET AS PARM1{25184
{{MOV{22,=P$ANS{8,WB{{POINT TO PCODE FOR 1-CHAR ANY{25185
{{BRN{6,GTPT3{{{JUMP TO BUILD NODE{25186
*
*      HERE IF ARGUMENT IS NOT CONVERTIBLE TO STRING
*
{GTPT2{MOV{22,=P$EXA{8,WB{{SET PCODE FOR EXPRESSION IN CASE{25190
{{BLO{9,(XR){22,=B$E$${6,GTPT3{JUMP TO BUILD NODE IF EXPRESSION{25191
*
*      HERE WE HAVE AN ERROR (CONVERSION IMPOSSIBLE)
*
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25195
*
*      MERGE HERE TO BUILD NODE FOR STRING OR EXPRESSION
*
{GTPT3{JSR{6,PBILD{{{CALL ROUTINE TO BUILD PATTERN NODE{25199
*
*      COMMON EXIT AFTER SUCCESSFUL CONVERSION
*
{GTPT4{MOV{3,GTPSB{8,WB{{RESTORE WB{25203
*
*      MERGE HERE TO EXIT IF NO CONVERSION REQUIRED
*
{GTPT5{EXI{{{{RETURN TO GTPAT CALLER{25207
{{ENP{{{{END PROCEDURE GTPAT{25208
{{EJC{{{{{25211
*
*      GTREA -- GET REAL VALUE
*
*      GTREA IS PASSED AN OBJECT AND RETURNS A REAL VALUE
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTREA            CALL TO CONVERT OBJECT TO REAL
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING REAL
*      (WA,WB,WC,RA)         DESTROYED
*      (XR)                  UNCHANGED (CONVERT ERROR ONLY)
*
{GTREA{PRC{25,E{1,1{{ENTRY POINT{25225
{{MOV{9,(XR){8,WA{{GET FIRST WORD OF BLOCK{25226
{{BEQ{8,WA{22,=B$RCL{6,GTRE2{JUMP IF REAL{25227
{{JSR{6,GTNUM{{{ELSE CONVERT ARGUMENT TO NUMERIC{25228
{{PPM{6,GTRE3{{{JUMP IF UNCONVERTIBLE{25229
{{BEQ{8,WA{22,=B$RCL{6,GTRE2{JUMP IF REAL WAS RETURNED{25230
*
*      HERE FOR CASE OF AN INTEGER TO CONVERT TO REAL
*
{GTRE1{LDI{13,ICVAL(XR){{{LOAD INTEGER{25234
{{ITR{{{{CONVERT TO REAL{25235
{{JSR{6,RCBLD{{{BUILD RCBLK{25236
*
*      EXIT WITH REAL
*
{GTRE2{EXI{{{{RETURN TO GTREA CALLER{25240
*
*      HERE ON CONVERSION ERROR
*
{GTRE3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25244
{{ENP{{{{END PROCEDURE GTREA{25245
{{EJC{{{{{25247
*
*      GTSMI -- GET SMALL INTEGER
*
*      GTSMI IS PASSED A SNOBOL OBJECT AND RETURNS AN ADDRESS
*      INTEGER IN THE RANGE (0 LE N LE DNAMB). SUCH A VALUE CAN
*      ONLY BE DERIVED FROM AN INTEGER IN THE APPROPRIATE RANGE.
*      SMALL INTEGERS NEVER APPEAR AS SNOBOL VALUES. HOWEVER,
*      THEY ARE USED INTERNALLY FOR A VARIETY OF PURPOSES.
*
*      -(XS)                 ARGUMENT TO CONVERT (ON STACK)
*      JSR  GTSMI            CALL TO CONVERT TO SMALL INTEGER
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER
*      PPM  LOC              TRANSFER LOC FOR LT 0, GT DNAMB
*      (XR,WC)               RESULTING SMALL INT (TWO COPIES)
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (WA,WB)               DESTROYED (ON CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSMI{PRC{25,N{1,2{{ENTRY POINT{25267
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{25268
{{BEQ{9,(XR){22,=B$ICL{6,GTSM1{SKIP IF ALREADY AN INTEGER{25269
*
*      HERE IF NOT AN INTEGER
*
{{JSR{6,GTINT{{{CONVERT ARGUMENT TO INTEGER{25273
{{PPM{6,GTSM2{{{JUMP IF CONVERT IS IMPOSSIBLE{25274
*
*      MERGE HERE WITH INTEGER
*
{GTSM1{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{25278
{{MFI{8,WC{6,GTSM3{{MOVE AS ONE WORD, JUMP IF OVFLOW{25279
{{BGT{8,WC{3,MXLEN{6,GTSM3{OR IF TOO LARGE{25280
{{MOV{8,WC{7,XR{{COPY RESULT TO XR{25281
{{EXI{{{{RETURN TO GTSMI CALLER{25282
*
*      HERE IF UNCONVERTIBLE TO INTEGER
*
{GTSM2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{25286
*
*      HERE IF OUT OF RANGE
*
{GTSM3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{25290
{{ENP{{{{END PROCEDURE GTSMI{25291
{{EJC{{{{{25292
*
*      GTSTG -- GET STRING
*
*      GTSTG IS PASSED AN OBJECT AND RETURNS A STRING WITH
*      ANY NECESSARY CONVERSIONS PERFORMED.
*
*      -(XS)                 INPUT ARGUMENT (ON STACK)
*      JSR  GTSTG            CALL TO CONVERT TO STRING
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING STRING
*      (WA)                  LENGTH OF STRING IN CHARACTERS
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSTG{PRC{25,N{1,1{{ENTRY POINT{25358
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT, POP STACK{25359
{{BEQ{9,(XR){22,=B$SCL{6,GTS30{JUMP IF ALREADY A STRING{25360
*
*      HERE IF NOT A STRING ALREADY
*
{GTS01{MOV{7,XR{11,-(XS){{RESTACK ARGUMENT IN CASE ERROR{25364
{{MOV{7,XL{11,-(XS){{SAVE XL{25365
{{MOV{8,WB{3,GTSVB{{SAVE WB{25366
{{MOV{8,WC{3,GTSVC{{SAVE WC{25367
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{25368
{{BEQ{8,WA{22,=B$ICL{6,GTS05{JUMP TO CONVERT INTEGER{25369
{{BEQ{8,WA{22,=B$RCL{6,GTS10{JUMP TO CONVERT REAL{25372
{{BEQ{8,WA{22,=B$NML{6,GTS03{JUMP TO CONVERT NAME{25374
*
*      HERE ON CONVERSION ERROR
*
{GTS02{MOV{10,(XS)+{7,XL{{RESTORE XL{25382
{{MOV{10,(XS)+{7,XR{{RELOAD INPUT ARGUMENT{25383
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25384
{{EJC{{{{{25385
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A NAME (ONLY POSSIBLE IF NATURAL VAR)
*
{GTS03{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{25391
{{BHI{7,XL{3,STATE{6,GTS02{ERROR IF NOT NATURAL VAR (STATIC){25392
{{ADD{19,*VRSOF{7,XL{{ELSE POINT TO POSSIBLE STRING NAME{25393
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH{25394
{{BNZ{8,WA{6,GTS04{{JUMP IF NOT SYSTEM VARIABLE{25395
{{MOV{13,VRSVO(XL){7,XL{{ELSE POINT TO SVBLK{25396
{{MOV{13,SVLEN(XL){8,WA{{AND LOAD NAME LENGTH{25397
*
*      MERGE HERE WITH STRING IN XR, LENGTH IN WA
*
{GTS04{ZER{8,WB{{{SET OFFSET TO ZERO{25401
{{JSR{6,SBSTR{{{USE SBSTR TO COPY STRING{25402
{{BRN{6,GTS29{{{JUMP TO EXIT{25403
*
*      COME HERE TO CONVERT AN INTEGER
*
{GTS05{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{25407
{{MOV{18,=NUM01{3,GTSSF{{SET SIGN FLAG NEGATIVE{25415
{{ILT{6,GTS06{{{SKIP IF INTEGER IS NEGATIVE{25416
{{NGI{{{{ELSE NEGATE INTEGER{25417
{{ZER{3,GTSSF{{{AND RESET NEGATIVE FLAG{25418
{{EJC{{{{{25419
*
*      GTSTG (CONTINUED)
*
*      HERE WITH SIGN FLAG SET AND SIGN FORCED NEGATIVE AS
*      REQUIRED BY THE CVD INSTRUCTION.
*
{GTS06{MOV{3,GTSWK{7,XR{{POINT TO RESULT WORK AREA{25426
{{MOV{18,=NSTMX{8,WB{{INITIALIZE COUNTER TO MAX LENGTH{25427
{{PSC{7,XR{8,WB{{PREPARE TO STORE (RIGHT-LEFT){25428
*
*      LOOP TO CONVERT DIGITS INTO WORK AREA
*
{GTS07{CVD{{{{CONVERT ONE DIGIT INTO WA{25432
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25433
{{DCV{8,WB{{{DECREMENT COUNTER{25434
{{INE{6,GTS07{{{LOOP IF MORE DIGITS TO GO{25435
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25436
*
*      MERGE HERE AFTER CONVERTING INTEGER OR REAL INTO WORK
*      AREA. WB IS SET TO NSTMX - (NUMBER OF CHARS IN RESULT).
*
{GTS08{MOV{18,=NSTMX{8,WA{{GET MAX NUMBER OF CHARACTERS{25442
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF RESULT{25443
{{MOV{8,WA{7,XL{{REMEMBER LENGTH FOR MOVE LATER ON{25444
{{ADD{3,GTSSF{8,WA{{ADD ONE FOR NEGATIVE SIGN IF NEEDED{25445
{{JSR{6,ALOCS{{{ALLOCATE STRING FOR RESULT{25446
{{MOV{7,XR{8,WC{{SAVE RESULT POINTER FOR THE MOMENT{25447
{{PSC{7,XR{{{POINT TO CHARS OF RESULT BLOCK{25448
{{BZE{3,GTSSF{6,GTS09{{SKIP IF POSITIVE{25449
{{MOV{18,=CH$MN{8,WA{{ELSE LOAD NEGATIVE SIGN{25450
{{SCH{8,WA{10,(XR)+{{AND STORE IT{25451
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25452
*
*      HERE AFTER DEALING WITH SIGN
*
{GTS09{MOV{7,XL{8,WA{{RECALL LENGTH TO MOVE{25456
{{MOV{3,GTSWK{7,XL{{POINT TO RESULT WORK AREA{25457
{{PLC{7,XL{8,WB{{POINT TO FIRST RESULT CHARACTER{25458
{{MVC{{{{MOVE CHARS TO RESULT STRING{25459
{{MOV{8,WC{7,XR{{RESTORE RESULT POINTER{25460
{{BRN{6,GTS29{{{JUMP TO EXIT{25463
{{EJC{{{{{25464
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A REAL
*
{GTS10{LDR{13,RCVAL(XR){{{LOAD REAL{25470
{{ZER{3,GTSSF{{{RESET NEGATIVE FLAG{25482
{{REQ{6,GTS31{{{SKIP IF ZERO{25483
{{RGE{6,GTS11{{{JUMP IF REAL IS POSITIVE{25484
{{MOV{18,=NUM01{3,GTSSF{{ELSE SET NEGATIVE FLAG{25485
{{NGR{{{{AND GET ABSOLUTE VALUE OF REAL{25486
*
*      NOW SCALE THE REAL TO THE RANGE (0.1 LE X LT 1.0)
*
{GTS11{LDI{4,INTV0{{{INITIALIZE EXPONENT TO ZERO{25490
*
*      LOOP TO SCALE UP IN STEPS OF 10**10
*
{GTS12{STR{3,GTSRS{{{SAVE REAL VALUE{25494
{{SBR{4,REAP1{{{SUBTRACT 0.1 TO COMPARE{25495
{{RGE{6,GTS13{{{JUMP IF SCALE UP NOT REQUIRED{25496
{{LDR{3,GTSRS{{{ELSE RELOAD VALUE{25497
{{MLR{4,REATT{{{MULTIPLY BY 10**10{25498
{{SBI{4,INTVT{{{DECREMENT EXPONENT BY 10{25499
{{BRN{6,GTS12{{{LOOP BACK TO TEST AGAIN{25500
*
*      TEST FOR SCALE DOWN REQUIRED
*
{GTS13{LDR{3,GTSRS{{{RELOAD VALUE{25504
{{SBR{4,REAV1{{{SUBTRACT 1.0{25505
{{RLT{6,GTS17{{{JUMP IF NO SCALE DOWN REQUIRED{25506
{{LDR{3,GTSRS{{{ELSE RELOAD VALUE{25507
*
*      LOOP TO SCALE DOWN IN STEPS OF 10**10
*
{GTS14{SBR{4,REATT{{{SUBTRACT 10**10 TO COMPARE{25511
{{RLT{6,GTS15{{{JUMP IF LARGE STEP NOT REQUIRED{25512
{{LDR{3,GTSRS{{{ELSE RESTORE VALUE{25513
{{DVR{4,REATT{{{DIVIDE BY 10**10{25514
{{STR{3,GTSRS{{{STORE NEW VALUE{25515
{{ADI{4,INTVT{{{INCREMENT EXPONENT BY 10{25516
{{BRN{6,GTS14{{{LOOP BACK{25517
{{EJC{{{{{25518
*
*      GTSTG (CONTINUED)
*
*      AT THIS POINT WE HAVE (1.0 LE X LT 10**10)
*      COMPLETE SCALING WITH POWERS OF TEN TABLE
*
{GTS15{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{25525
*
*      LOOP TO LOCATE CORRECT ENTRY IN TABLE
*
{GTS16{LDR{3,GTSRS{{{RELOAD VALUE{25529
{{ADI{4,INTV1{{{INCREMENT EXPONENT{25530
{{ADD{19,*CFP$R{7,XR{{POINT TO NEXT ENTRY IN TABLE{25531
{{SBR{9,(XR){{{SUBTRACT IT TO COMPARE{25532
{{RGE{6,GTS16{{{LOOP TILL WE FIND A LARGER ENTRY{25533
{{LDR{3,GTSRS{{{THEN RELOAD THE VALUE{25534
{{DVR{9,(XR){{{AND COMPLETE SCALING{25535
{{STR{3,GTSRS{{{STORE VALUE{25536
*
*      WE ARE NOW SCALED, SO ROUND BY ADDING 0.5 * 10**(-CFP$S)
*
{GTS17{LDR{3,GTSRS{{{GET VALUE AGAIN{25540
{{ADR{3,GTSRN{{{ADD ROUNDING FACTOR{25541
{{STR{3,GTSRS{{{STORE RESULT{25542
*
*      THE ROUNDING OPERATION MAY HAVE PUSHED US UP PAST
*      1.0 AGAIN, SO CHECK ONE MORE TIME.
*
{{SBR{4,REAV1{{{SUBTRACT 1.0 TO COMPARE{25547
{{RLT{6,GTS18{{{SKIP IF OK{25548
{{ADI{4,INTV1{{{ELSE INCREMENT EXPONENT{25549
{{LDR{3,GTSRS{{{RELOAD VALUE{25550
{{DVR{4,REAVT{{{DIVIDE BY 10.0 TO RESCALE{25551
{{BRN{6,GTS19{{{JUMP TO MERGE{25552
*
*      HERE IF ROUNDING DID NOT MUCK UP SCALING
*
{GTS18{LDR{3,GTSRS{{{RELOAD ROUNDED VALUE{25556
{{EJC{{{{{25557
*
*      GTSTG (CONTINUED)
*
*      NOW WE HAVE COMPLETED THE SCALING AS FOLLOWS
*
*      (IA)                  SIGNED EXPONENT
*      (RA)                  SCALED REAL (ABSOLUTE VALUE)
*
*      IF THE EXPONENT IS NEGATIVE OR GREATER THAN CFP$S, THEN
*      WE CONVERT THE NUMBER IN THE FORM.
*
*      (NEG SIGN) 0 . (CPF$S DIGITS) E (EXP SIGN) (EXP DIGITS)
*
*      IF THE EXPONENT IS POSITIVE AND LESS THAN OR EQUAL TO
*      CFP$S, THE NUMBER IS CONVERTED IN THE FORM.
*
*      (NEG SIGN) (EXPONENT DIGITS) . (CFP$S-EXPONENT DIGITS)
*
*      IN BOTH CASES, THE FORMATS OBTAINED FROM THE ABOVE
*      RULES ARE MODIFIED BY DELETING TRAILING ZEROS AFTER THE
*      DECIMAL POINT. THERE ARE NO LEADING ZEROS IN THE EXPONENT
*      AND THE EXPONENT SIGN IS ALWAYS PRESENT.
*
{GTS19{MOV{18,=CFP$S{7,XL{{SET NUM DEC DIGITS = CFP$S{25581
{{MOV{18,=CH$MN{3,GTSES{{SET EXPONENT SIGN NEGATIVE{25582
{{ILT{6,GTS21{{{ALL SET IF EXPONENT IS NEGATIVE{25583
{{MFI{8,WA{{{ELSE FETCH EXPONENT{25584
{{BLE{8,WA{18,=CFP$S{6,GTS20{SKIP IF WE CAN USE SPECIAL FORMAT{25585
{{MTI{8,WA{{{ELSE RESTORE EXPONENT{25586
{{NGI{{{{SET NEGATIVE FOR CVD{25587
{{MOV{18,=CH$PL{3,GTSES{{SET PLUS SIGN FOR EXPONENT SIGN{25588
{{BRN{6,GTS21{{{JUMP TO GENERATE EXPONENT{25589
*
*      HERE IF WE CAN USE THE FORMAT WITHOUT AN EXPONENT
*
{GTS20{SUB{8,WA{7,XL{{COMPUTE DIGITS AFTER DECIMAL POINT{25593
{{LDI{4,INTV0{{{RESET EXPONENT TO ZERO{25594
{{EJC{{{{{25595
*
*      GTSTG (CONTINUED)
*
*      MERGE HERE AS FOLLOWS
*
*      (IA)                  EXPONENT ABSOLUTE VALUE
*      GTSES                 CHARACTER FOR EXPONENT SIGN
*      (RA)                  POSITIVE FRACTION
*      (XL)                  NUMBER OF DIGITS AFTER DEC POINT
*
{GTS21{MOV{3,GTSWK{7,XR{{POINT TO WORK AREA{25606
{{MOV{18,=NSTMX{8,WB{{SET CHARACTER CTR TO MAX LENGTH{25607
{{PSC{7,XR{8,WB{{PREPARE TO STORE (RIGHT TO LEFT){25608
{{IEQ{6,GTS23{{{SKIP EXPONENT IF IT IS ZERO{25609
*
*      LOOP TO GENERATE DIGITS OF EXPONENT
*
{GTS22{CVD{{{{CONVERT A DIGIT INTO WA{25613
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25614
{{DCV{8,WB{{{DECREMENT COUNTER{25615
{{INE{6,GTS22{{{LOOP BACK IF MORE DIGITS TO GO{25616
*
*      HERE GENERATE EXPONENT SIGN AND E
*
{{MOV{3,GTSES{8,WA{{LOAD EXPONENT SIGN{25620
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25621
{{MOV{18,=CH$LE{8,WA{{GET CHARACTER LETTER E{25622
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25623
{{SUB{18,=NUM02{8,WB{{DECREMENT COUNTER FOR SIGN AND E{25624
*
*      HERE TO GENERATE THE FRACTION
*
{GTS23{MLR{3,GTSSC{{{CONVERT REAL TO INTEGER (10**CFP$S){25628
{{RTI{{{{GET INTEGER (OVERFLOW IMPOSSIBLE){25629
{{NGI{{{{NEGATE AS REQUIRED BY CVD{25630
*
*      LOOP TO SUPPRESS TRAILING ZEROS
*
{GTS24{BZE{7,XL{6,GTS27{{JUMP IF NO DIGITS LEFT TO DO{25634
{{CVD{{{{ELSE CONVERT ONE DIGIT{25635
{{BNE{8,WA{18,=CH$D0{6,GTS26{JUMP IF NOT A ZERO{25636
{{DCV{7,XL{{{DECREMENT COUNTER{25637
{{BRN{6,GTS24{{{LOOP BACK FOR NEXT DIGIT{25638
{{EJC{{{{{25639
*
*      GTSTG (CONTINUED)
*
*      LOOP TO GENERATE DIGITS AFTER DECIMAL POINT
*
{GTS25{CVD{{{{CONVERT A DIGIT INTO WA{25645
*
*      MERGE HERE FIRST TIME
*
{GTS26{SCH{8,WA{11,-(XR){{STORE DIGIT{25649
{{DCV{8,WB{{{DECREMENT COUNTER{25650
{{DCV{7,XL{{{DECREMENT COUNTER{25651
{{BNZ{7,XL{6,GTS25{{LOOP BACK IF MORE TO GO{25652
*
*      HERE GENERATE THE DECIMAL POINT
*
{GTS27{MOV{18,=CH$DT{8,WA{{LOAD DECIMAL POINT{25656
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25657
{{DCV{8,WB{{{DECREMENT COUNTER{25658
*
*      HERE GENERATE THE DIGITS BEFORE THE DECIMAL POINT
*
{GTS28{CVD{{{{CONVERT A DIGIT INTO WA{25662
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25663
{{DCV{8,WB{{{DECREMENT COUNTER{25664
{{INE{6,GTS28{{{LOOP BACK IF MORE TO GO{25665
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25666
{{BRN{6,GTS08{{{ELSE JUMP BACK TO EXIT{25667
*
*      EXIT POINT AFTER SUCCESSFUL CONVERSION
*
{GTS29{MOV{10,(XS)+{7,XL{{RESTORE XL{25673
{{ICA{7,XS{{{POP ARGUMENT{25674
{{MOV{3,GTSVB{8,WB{{RESTORE WB{25675
{{MOV{3,GTSVC{8,WC{{RESTORE WC{25676
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTS30{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{25680
{{EXI{{{{RETURN TO CALLER{25681
*
*      HERE TO RETURN STRING FOR REAL ZERO
*
{GTS31{MOV{21,=SCRE0{7,XL{{POINT TO STRING{25687
{{MOV{18,=NUM02{8,WA{{2 CHARS{25688
{{ZER{8,WB{{{ZERO OFFSET{25689
{{JSR{6,SBSTR{{{COPY STRING{25690
{{BRN{6,GTS29{{{RETURN{25691
{{ENP{{{{END PROCEDURE GTSTG{25718
{{EJC{{{{{25719
*
*      GTVAR -- GET VARIABLE FOR I/O/TRACE ASSOCIATION
*
*      GTVAR IS USED TO POINT TO AN ACTUAL VARIABLE LOCATION
*      FOR THE DETACH,INPUT,OUTPUT,TRACE,STOPTR SYSTEM FUNCTIONS
*
*      (XR)                  ARGUMENT TO FUNCTION
*      JSR  GTVAR            CALL TO LOCATE VARIABLE POINTER
*      PPM  LOC              TRANSFER LOC IF NOT OK VARIABLE
*      (XL,WA)               NAME BASE,OFFSET OF VARIABLE
*      (XR,RA)               DESTROYED
*      (WB,WC)               DESTROYED (CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTVAR{PRC{25,E{1,1{{ENTRY POINT{25734
{{BNE{9,(XR){22,=B$NML{6,GTVR2{JUMP IF NOT A NAME{25735
{{MOV{13,NMOFS(XR){8,WA{{ELSE LOAD NAME OFFSET{25736
{{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{25737
{{BEQ{9,(XL){22,=B$EVT{6,GTVR1{ERROR IF EXPRESSION VARIABLE{25738
{{BNE{9,(XL){22,=B$KVT{6,GTVR3{ALL OK IF NOT KEYWORD VARIABLE{25739
*
*      HERE ON CONVERSION ERROR
*
{GTVR1{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25743
*
*      HERE IF NOT A NAME, TRY CONVERT TO NATURAL VARIABLE
*
{GTVR2{MOV{8,WC{3,GTVRC{{SAVE WC{25747
{{JSR{6,GTNVR{{{LOCATE VRBLK IF POSSIBLE{25748
{{PPM{6,GTVR1{{{JUMP IF CONVERT ERROR{25749
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK NAME BASE{25750
{{MOV{19,*VRVAL{8,WA{{AND SET OFFSET{25751
{{MOV{3,GTVRC{8,WC{{RESTORE WC{25752
*
*      HERE FOR NAME OBTAINED
*
{GTVR3{BHI{7,XL{3,STATE{6,GTVR4{ALL OK IF NOT NATURAL VARIABLE{25756
{{BEQ{13,VRSTO(XL){22,=B$VRE{6,GTVR1{ERROR IF PROTECTED VARIABLE{25757
*
*      COMMON EXIT POINT
*
{GTVR4{EXI{{{{RETURN TO CALLER{25761
{{ENP{{{{END PROCEDURE GTVAR{25762
{{EJC{{{{{25763
*
*      HASHS -- COMPUTE HASH INDEX FOR STRING
*
*      HASHS IS USED TO CONVERT A STRING TO A UNIQUE INTEGER
*      VALUE. THE RESULTING HASH VALUE IS A POSITIVE INTEGER
*      IN THE RANGE 0 TO CFP$M
*
*      (XR)                  STRING TO BE HASHED
*      JSR  HASHS            CALL TO HASH STRING
*      (IA)                  HASH VALUE
*      (XR,WB,WC)            DESTROYED
*
*      THE HASH FUNCTION USED IS AS FOLLOWS.
*
*      START WITH THE LENGTH OF THE STRING (SGD07)
*
*      TAKE THE FIRST E$HNW WORDS OF THE CHARACTERS FROM
*      THE STRING OR ALL THE WORDS IF FEWER THAN E$HNW.
*
*      COMPUTE THE EXCLUSIVE OR OF ALL THESE WORDS TREATING
*      THEM AS ONE WORD BIT STRING VALUES.
*
*      MOVE THE RESULT AS AN INTEGER WITH THE MTI INSTRUCTION.
*
{HASHS{PRC{25,E{1,0{{ENTRY POINT{25788
{{MOV{13,SCLEN(XR){8,WC{{LOAD STRING LENGTH IN CHARACTERS{25789
{{MOV{8,WC{8,WB{{INITIALIZE WITH LENGTH{25790
{{BZE{8,WC{6,HSHS3{{JUMP IF NULL STRING{25791
{{ZGB{8,WB{{{CORRECT BYTE ORDERING IF NECESSARY{25792
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS OF CHARS{25793
{{ADD{19,*SCHAR{7,XR{{POINT TO CHARACTERS OF STRING{25794
{{BLO{8,WC{18,=E$HNW{6,HSHS1{USE WHOLE STRING IF SHORT{25795
{{MOV{18,=E$HNW{8,WC{{ELSE SET TO INVOLVE FIRST E$HNW WDS{25796
*
*      HERE WITH COUNT OF WORDS TO CHECK IN WC
*
{HSHS1{LCT{8,WC{8,WC{{SET COUNTER TO CONTROL LOOP{25800
*
*      LOOP TO COMPUTE EXCLUSIVE OR
*
{HSHS2{XOB{10,(XR)+{8,WB{{EXCLUSIVE OR NEXT WORD OF CHARS{25804
{{BCT{8,WC{6,HSHS2{{LOOP TILL ALL PROCESSED{25805
*
*      MERGE HERE WITH EXCLUSIVE OR IN WB
*
{HSHS3{ZGB{8,WB{{{ZEROISE UNDEFINED BITS{25809
{{ANB{4,BITSM{8,WB{{ENSURE IN RANGE 0 TO CFP$M{25810
{{MTI{8,WB{{{MOVE RESULT AS INTEGER{25811
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{25812
{{EXI{{{{RETURN TO HASHS CALLER{25813
{{ENP{{{{END PROCEDURE HASHS{25814
{{EJC{{{{{25815
*
*      ICBLD -- BUILD INTEGER BLOCK
*
*      (IA)                  INTEGER VALUE FOR ICBLK
*      JSR  ICBLD            CALL TO BUILD INTEGER BLOCK
*      (XR)                  POINTER TO RESULT ICBLK
*      (WA)                  DESTROYED
*
{ICBLD{PRC{25,E{1,0{{ENTRY POINT{25824
{{MFI{7,XR{6,ICBL1{{COPY SMALL INTEGERS{25825
{{BLE{7,XR{18,=NUM02{6,ICBL3{JUMP IF 0,1 OR 2{25826
*
*      CONSTRUCT ICBLK
*
{ICBL1{MOV{3,DNAMP{7,XR{{LOAD POINTER TO NEXT AVAILABLE LOC{25830
{{ADD{19,*ICSI${7,XR{{POINT PAST NEW ICBLK{25831
{{BLO{7,XR{3,DNAME{6,ICBL2{JUMP IF THERE IS ROOM{25832
{{MOV{19,*ICSI${8,WA{{ELSE LOAD LENGTH OF ICBLK{25833
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{25834
{{ADD{8,WA{7,XR{{POINT PAST BLOCK TO MERGE{25835
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{ICBL2{MOV{7,XR{3,DNAMP{{SET NEW POINTER{25839
{{SUB{19,*ICSI${7,XR{{POINT BACK TO START OF BLOCK{25840
{{MOV{22,=B$ICL{9,(XR){{STORE TYPE WORD{25841
{{STI{13,ICVAL(XR){{{STORE INTEGER VALUE IN ICBLK{25842
{{EXI{{{{RETURN TO ICBLD CALLER{25843
*
*      OPTIMISE BY NOT BUILDING ICBLKS FOR SMALL INTEGERS
*
{ICBL3{WTB{7,XR{{{CONVERT INTEGER TO OFFSET{25847
{{MOV{14,INTAB(XR){7,XR{{POINT TO PRE-BUILT ICBLK{25848
{{EXI{{{{RETURN{25849
{{ENP{{{{END PROCEDURE ICBLD{25850
{{EJC{{{{{25851
*
*      IDENT -- COMPARE TWO VALUES
*
*      IDENT COMPARES TWO VALUES IN THE SENSE OF THE IDENT
*      DIFFER FUNCTIONS AVAILABLE AT THE SNOBOL LEVEL.
*
*      (XR)                  FIRST ARGUMENT
*      (XL)                  SECOND ARGUMENT
*      JSR  IDENT            CALL TO COMPARE ARGUMENTS
*      PPM  LOC              TRANSFER LOC IF IDENT
*      (NORMAL RETURN IF DIFFER)
*      (XR,XL,WC,RA)         DESTROYED
*
{IDENT{PRC{25,E{1,1{{ENTRY POINT{25865
{{BEQ{7,XR{7,XL{6,IDEN7{JUMP IF SAME POINTER (IDENT){25866
{{MOV{9,(XR){8,WC{{ELSE LOAD ARG 1 TYPE WORD{25867
{{BNE{8,WC{9,(XL){6,IDEN1{DIFFER IF ARG 2 TYPE WORD DIFFER{25869
{{BEQ{8,WC{22,=B$SCL{6,IDEN2{JUMP IF STRINGS{25873
{{BEQ{8,WC{22,=B$ICL{6,IDEN4{JUMP IF INTEGERS{25874
{{BEQ{8,WC{22,=B$RCL{6,IDEN5{JUMP IF REALS{25877
{{BEQ{8,WC{22,=B$NML{6,IDEN6{JUMP IF NAMES{25879
*
*      FOR ALL OTHER DATATYPES, MUST BE DIFFER IF XR NE XL
*
*      MERGE HERE FOR DIFFER
*
{IDEN1{EXI{{{{TAKE DIFFER EXIT{25922
*
*      HERE FOR STRINGS, IDENT ONLY IF LENGTHS AND CHARS SAME
*
{IDEN2{MOV{13,SCLEN(XR){8,WC{{LOAD ARG 1 LENGTH{25926
{{BNE{8,WC{13,SCLEN(XL){6,IDEN1{DIFFER IF LENGTHS DIFFER{25927
*
*      BUFFER AND STRING COMPARISONS MERGE HERE
*
{IDN2A{ADD{19,*SCHAR{7,XR{{POINT TO CHARS OF ARG 1{25931
{{ADD{19,*SCHAR{7,XL{{POINT TO CHARS OF ARG 2{25932
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN STRINGS{25933
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{25934
*
*      LOOP TO COMPARE CHARACTERS. NOTE THAT WC CANNOT BE ZERO
*      SINCE ALL NULL STRINGS POINT TO NULLS AND GIVE XL=XR.
*
{IDEN3{CNE{9,(XR){9,(XL){6,IDEN8{DIFFER IF CHARS DO NOT MATCH{25939
{{ICA{7,XR{{{ELSE BUMP ARG ONE POINTER{25940
{{ICA{7,XL{{{BUMP ARG TWO POINTER{25941
{{BCT{8,WC{6,IDEN3{{LOOP BACK TILL ALL CHECKED{25942
{{EJC{{{{{25943
*
*      IDENT (CONTINUED)
*
*      HERE TO EXIT FOR CASE OF TWO IDENT STRINGS
*
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{25949
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{25950
{{EXI{1,1{{{TAKE IDENT EXIT{25951
*
*      HERE FOR INTEGERS, IDENT IF SAME VALUES
*
{IDEN4{LDI{13,ICVAL(XR){{{LOAD ARG 1{25955
{{SBI{13,ICVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{25956
{{IOV{6,IDEN1{{{DIFFER IF OVERFLOW{25957
{{INE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{25958
{{EXI{1,1{{{TAKE IDENT EXIT{25959
*
*      HERE FOR REALS, IDENT IF SAME VALUES
*
{IDEN5{LDR{13,RCVAL(XR){{{LOAD ARG 1{25965
{{SBR{13,RCVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{25966
{{ROV{6,IDEN1{{{DIFFER IF OVERFLOW{25967
{{RNE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{25968
{{EXI{1,1{{{TAKE IDENT EXIT{25969
*
*      HERE FOR NAMES, IDENT IF BASES AND OFFSETS SAME
*
{IDEN6{BNE{13,NMOFS(XR){13,NMOFS(XL){6,IDEN1{DIFFER IF DIFFERENT OFFSET{25974
{{BNE{13,NMBAS(XR){13,NMBAS(XL){6,IDEN1{DIFFER IF DIFFERENT BASE{25975
*
*      MERGE HERE TO SIGNAL IDENT FOR IDENTICAL POINTERS
*
{IDEN7{EXI{1,1{{{TAKE IDENT EXIT{25979
*
*      HERE FOR DIFFER STRINGS
*
{IDEN8{ZER{7,XR{{{CLEAR GARBAGE PTR IN XR{25983
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{25984
{{EXI{{{{RETURN TO CALLER (DIFFER){25985
{{ENP{{{{END PROCEDURE IDENT{25986
{{EJC{{{{{25987
*
*      INOUT - USED TO INITIALISE INPUT AND OUTPUT VARIABLES
*
*      (XL)                  POINTER TO VBL NAME STRING
*      (WB)                  TRBLK TYPE
*      JSR  INOUT            CALL TO PERFORM INITIALISATION
*      (XL)                  VRBLK PTR
*      (XR)                  TRBLK PTR
*      (WA,WC)               DESTROYED
*
*      NOTE THAT TRTER (= TRTRF) FIELD OF STANDARD I/O VARIABLES
*      POINTS TO CORRESPONDING SVBLK NOT TO A TRBLK AS IS THE
*      CASE FOR ORDINARY VARIABLES.
*
{INOUT{PRC{25,E{1,0{{ENTRY POINT{26002
{{MOV{8,WB{11,-(XS){{STACK TRBLK TYPE{26003
{{MOV{13,SCLEN(XL){8,WA{{GET NAME LENGTH{26004
{{ZER{8,WB{{{POINT TO START OF NAME{26005
{{JSR{6,SBSTR{{{BUILD A PROPER SCBLK{26006
{{JSR{6,GTNVR{{{BUILD VRBLK{26007
{{PPM{{{{NO ERROR RETURN{26008
{{MOV{7,XR{8,WC{{SAVE VRBLK POINTER{26009
{{MOV{10,(XS)+{8,WB{{GET TRTER FIELD{26010
{{ZER{7,XL{{{ZERO TRFPT{26011
{{JSR{6,TRBLD{{{BUILD TRBLK{26012
{{MOV{8,WC{7,XL{{RECALL VRBLK POINTER{26013
{{MOV{13,VRSVP(XL){13,TRTER(XR){{STORE SVBLK POINTER{26014
{{MOV{7,XR{13,VRVAL(XL){{STORE TRBLK PTR IN VRBLK{26015
{{MOV{22,=B$VRA{13,VRGET(XL){{SET TRAPPED ACCESS{26016
{{MOV{22,=B$VRV{13,VRSTO(XL){{SET TRAPPED STORE{26017
{{EXI{{{{RETURN TO CALLER{26018
{{ENP{{{{END PROCEDURE INOUT{26019
{{EJC{{{{{26020
*
*      INSTA - USED TO INITIALIZE STRUCTURES IN STATIC REGION
*
*      (XR)                  POINTER TO STARTING STATIC LOCATION
*      JSR  INSTA            CALL TO INITIALIZE STATIC STRUCTURE
*      (XR)                  PTR TO NEXT FREE STATIC LOCATION
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT THIS PROCEDURE ESTABLISHES THE POINTERS
*      PRBUF, GTSWK, AND KVALP.
*
{INSTA{PRC{25,E{1,0{{ENTRY POINT{26199
*
*      INITIALIZE PRINT BUFFER WITH BLANK WORDS
*
{{MOV{3,PRLEN{8,WC{{NO. OF CHARS IN PRINT BFR{26203
{{MOV{7,XR{3,PRBUF{{PRINT BFR IS PUT AT STATIC START{26204
{{MOV{22,=B$SCL{10,(XR)+{{STORE STRING TYPE CODE{26205
{{MOV{8,WC{10,(XR)+{{AND STRING LENGTH{26206
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN BUFFER{26207
{{MOV{8,WC{3,PRLNW{{STORE FOR BUFFER CLEAR{26208
{{LCT{8,WC{8,WC{{WORDS TO CLEAR{26209
*
*      LOOP TO CLEAR BUFFER
*
{INST1{MOV{4,NULLW{10,(XR)+{{STORE BLANK{26213
{{BCT{8,WC{6,INST1{{LOOP{26214
*
*      ALLOCATE WORK AREA FOR GTSTG CONVERSION PROCEDURE
*
{{MOV{18,=NSTMX{8,WA{{GET MAX NUM CHARS IN OUTPUT NUMBER{26218
{{CTB{8,WA{2,SCSI${{NO OF BYTES NEEDED{26219
{{MOV{7,XR{3,GTSWK{{STORE BFR ADRS{26220
{{ADD{8,WA{7,XR{{BUMP FOR WORK BFR{26221
*
*      BUILD ALPHABET STRING FOR ALPHABET KEYWORD AND REPLACE
*
{{MOV{7,XR{3,KVALP{{SAVE ALPHABET POINTER{26225
{{MOV{22,=B$SCL{9,(XR){{STRING BLK TYPE{26226
{{MOV{18,=CFP$A{8,WC{{NO OF CHARS IN ALPHABET{26227
{{MOV{8,WC{13,SCLEN(XR){{STORE AS STRING LENGTH{26228
{{MOV{8,WC{8,WB{{COPY CHAR COUNT{26229
{{CTB{8,WB{2,SCSI${{NO. OF BYTES NEEDED{26230
{{ADD{7,XR{8,WB{{CURRENT END ADDRESS FOR STATIC{26231
{{MOV{8,WB{8,WA{{SAVE ADRS PAST ALPHABET STRING{26232
{{LCT{8,WC{8,WC{{LOOP COUNTER{26233
{{PSC{7,XR{{{POINT TO CHARS OF STRING{26234
{{ZER{8,WB{{{SET INITIAL CHARACTER VALUE{26235
*
*      LOOP TO ENTER CHARACTER CODES IN ORDER
*
{INST2{SCH{8,WB{10,(XR)+{{STORE NEXT CODE{26239
{{ICV{8,WB{{{BUMP CODE VALUE{26240
{{BCT{8,WC{6,INST2{{LOOP TILL ALL STORED{26241
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{26242
{{MOV{8,WA{7,XR{{RETURN CURRENT STATIC PTR{26243
{{EXI{{{{RETURN TO CALLER{26244
{{ENP{{{{END PROCEDURE INSTA{26245
{{EJC{{{{{26246
*
*      IOFCB -- GET INPUT/OUTPUT FCBLK POINTER
*
*      USED BY ENDFILE, EJECT AND REWIND TO FIND THE FCBLK
*      (IF ANY) CORRESPONDING TO THEIR ARGUMENT.
*
*      -(XS)                 ARGUMENT
*      JSR  IOFCB            CALL TO FIND FCBLK
*      PPM  LOC              ARG IS AN UNSUITABLE NAME
*      PPM  LOC              ARG IS NULL STRING
*      PPM  LOC              ARG FILE NOT FOUND
*      (XS)                  POPPED
*      (XL)                  PTR TO FILEARG1 VRBLK
*      (XR)                  ARGUMENT
*      (WA)                  FCBLK PTR OR 0
*      (WB,WC)               DESTROYED
*
{IOFCB{PRC{25,N{1,3{{ENTRY POINT{26264
{{JSR{6,GTSTG{{{GET ARG AS STRING{26265
{{PPM{6,IOFC2{{{FAIL{26266
{{MOV{7,XR{7,XL{{COPY STRING PTR{26267
{{JSR{6,GTNVR{{{GET AS NATURAL VARIABLE{26268
{{PPM{6,IOFC3{{{FAIL IF NULL{26269
{{MOV{7,XL{8,WB{{COPY STRING POINTER AGAIN{26270
{{MOV{7,XR{7,XL{{COPY VRBLK PTR FOR RETURN{26271
{{ZER{8,WA{{{IN CASE NO TRBLK FOUND{26272
*
*      LOOP TO FIND FILE ARG1 TRBLK
*
{IOFC1{MOV{13,VRVAL(XR){7,XR{{GET POSSIBLE TRBLK PTR{26276
{{BNE{9,(XR){22,=B$TRT{6,IOFC4{FAIL IF END OF CHAIN{26277
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOFC1{LOOP IF NOT FILE ARG TRBLK{26278
{{MOV{13,TRFPT(XR){8,WA{{GET FCBLK PTR{26279
{{MOV{8,WB{7,XR{{COPY ARG{26280
{{EXI{{{{RETURN{26281
*
*      FAIL RETURN
*
{IOFC2{EXI{1,1{{{FAIL{26285
*
*      NULL ARG
*
{IOFC3{EXI{1,2{{{NULL ARG RETURN{26289
*
*      FILE NOT FOUND
*
{IOFC4{EXI{1,3{{{FILE NOT FOUND RETURN{26293
{{ENP{{{{END PROCEDURE IOFCB{26294
{{EJC{{{{{26295
*
*      IOPPF -- PROCESS FILEARG2 FOR IOPUT
*
*      (R$XSC)               FILEARG2 PTR
*      JSR  IOPPF            CALL TO PROCESS FILEARG2
*      (XL)                  FILEARG1 PTR
*      (XR)                  FILE ARG2 PTR
*      -(XS)...-(XS)         FIELDS EXTRACTED FROM FILEARG2
*      (WC)                  NO. OF FIELDS EXTRACTED
*      (WB)                  INPUT/OUTPUT FLAG
*      (WA)                  FCBLK PTR OR 0
*
{IOPPF{PRC{25,N{1,0{{ENTRY POINT{26308
{{ZER{8,WB{{{TO COUNT FIELDS EXTRACTED{26309
*
*      LOOP TO EXTRACT FIELDS
*
{IOPP1{MOV{18,=IODEL{7,XL{{GET DELIMITER{26313
{{MOV{7,XL{8,WC{{COPY IT{26314
{{ZER{8,WA{{{RETAIN LEADING BLANKS IN FILEARG2{26315
{{JSR{6,XSCAN{{{GET NEXT FIELD{26316
{{MOV{7,XR{11,-(XS){{STACK IT{26317
{{ICV{8,WB{{{INCREMENT COUNT{26318
{{BNZ{8,WA{6,IOPP1{{LOOP{26319
{{MOV{8,WB{8,WC{{COUNT OF FIELDS{26320
{{MOV{3,IOPTT{8,WB{{I/O MARKER{26321
{{MOV{3,R$IOF{8,WA{{FCBLK PTR OR 0{26322
{{MOV{3,R$IO2{7,XR{{FILE ARG2 PTR{26323
{{MOV{3,R$IO1{7,XL{{FILEARG1{26324
{{EXI{{{{RETURN{26325
{{ENP{{{{END PROCEDURE IOPPF{26326
{{EJC{{{{{26327
*
*      IOPUT -- ROUTINE USED BY INPUT AND OUTPUT
*
*      IOPUT SETS UP INPUT/OUTPUT  ASSOCIATIONS. IT BUILDS
*      SUCH TRACE AND FILE CONTROL BLOCKS AS ARE NECESSARY AND
*      CALLS SYSFC,SYSIO TO PERFORM CHECKS ON THE
*      ARGUMENTS AND TO OPEN THE FILES.
*
*         +-----------+   +---------------+       +-----------+
*      +-.I           I   I               I------.I   =B$XRT  I
*      I  +-----------+   +---------------+       +-----------+
*      I  /           /        (R$FCB)            I    *4     I
*      I  /           /                           +-----------+
*      I  +-----------+   +---------------+       I           I-
*      I  I   NAME    +--.I    =B$TRT     I       +-----------+
*      I  /           /   +---------------+       I           I
*      I   (FIRST ARG)    I =TRTIN/=TRTOU I       +-----------+
*      I                  +---------------+             I
*      I                  I     VALUE     I             I
*      I                  +---------------+             I
*      I                  I(TRTRF) 0   OR I--+          I
*      I                  +---------------+  I          I
*      I                  I(TRFPT) 0   OR I----+        I
*      I                  +---------------+  I I        I
*      I                     (I/O TRBLK)     I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+   +---------------+  I I        I
*      I  I           +--.I    =B$TRT     I.-+ I        I
*      I  +-----------+   +---------------+    I        I
*      I  /           /   I    =TRTFC     I    I        I
*      I  /           /   +---------------+    I        I
*      I    (FILEARG1     I     VALUE     I    I        I
*      I         VRBLK)   +---------------+    I        I
*      I                  I(TRTRF) 0   OR I--+ I        .
*      I                  +---------------+  I .  +-----------+
*      I                  I(TRFPT) 0   OR I------./   FCBLK   /
*      I                  +---------------+  I    +-----------+
*      I                       (TRTRF)       I
*      I                                     I
*      I                                     I
*      I                  +---------------+  I
*      I                  I    =B$XRT     I.-+
*      I                  +---------------+
*      I                  I      *5       I
*      I                  +---------------+
*      +------------------I               I
*                         +---------------+       +-----------+
*                         I(TRTRF) O   OR I------.I  =B$XRT   I
*                         +---------------+       +-----------+
*                         I  NAME OFFSET  I       I    ETC    I
*                         +---------------+
*                           (IOCHN - CHAIN OF NAME POINTERS)
{{EJC{{{{{26383
*
*      IOPUT (CONTINUED)
*
*      NO ADDITIONAL TRAP BLOCKS ARE USED FOR STANDARD INPUT/OUT
*      FILES. OTHERWISE AN I/O TRAP BLOCK IS ATTACHED TO SECOND
*      ARG (FILEARG1) VRBLK. SEE DIAGRAM ABOVE FOR DETAILS OF
*      THE STRUCTURE BUILT.
*
*      -(XS)                 1ST ARG (VBL TO BE ASSOCIATED)
*      -(XS)                 2ND ARG (FILE ARG1)
*      -(XS)                 3RD ARG (FILE ARG2)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT ASSOC.
*      JSR  IOPUT            CALL FOR INPUT/OUTPUT ASSOCIATION
*      PPM  LOC              3RD ARG NOT A STRING
*      PPM  LOC              2ND ARG NOT A SUITABLE NAME
*      PPM  LOC              1ST ARG NOT A SUITABLE NAME
*      PPM  LOC              INAPPROPRIATE FILE SPEC FOR I/O
*      PPM  LOC              I/O FILE DOES NOT EXIST
*      PPM  LOC              I/O FILE CANNOT BE READ/WRITTEN
*      PPM  LOC              I/O FCBLK CURRENTLY IN USE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{IOPUT{PRC{25,N{1,7{{ENTRY POINT{26407
{{ZER{3,R$IOT{{{IN CASE NO TRTRF BLOCK USED{26408
{{ZER{3,R$IOF{{{IN CASE NO FCBLK ALOCATED{26409
{{ZER{3,R$IOP{{{IN CASE SYSIO FAILS{26410
{{MOV{8,WB{3,IOPTT{{STORE I/O TRACE TYPE{26411
{{JSR{6,XSCNI{{{PREPARE TO SCAN FILEARG2{26412
{{PPM{6,IOP13{{{FAIL{26413
{{PPM{6,IOPA0{{{NULL FILE ARG2{26414
*
{IOPA0{MOV{7,XR{3,R$IO2{{KEEP FILE ARG2{26416
{{MOV{8,WA{7,XL{{COPY LENGTH{26417
{{JSR{6,GTSTG{{{CONVERT FILEARG1 TO STRING{26418
{{PPM{6,IOP14{{{FAIL{26419
{{MOV{7,XR{3,R$IO1{{KEEP FILEARG1 PTR{26420
{{JSR{6,GTNVR{{{CONVERT TO NATURAL VARIABLE{26421
{{PPM{6,IOP00{{{JUMP IF NULL{26422
{{BRN{6,IOP04{{{JUMP TO PROCESS NON-NULL ARGS{26423
*
*      NULL FILEARG1
*
{IOP00{BZE{7,XL{6,IOP01{{SKIP IF BOTH ARGS NULL{26427
{{JSR{6,IOPPF{{{PROCESS FILEARG2{26428
{{JSR{6,SYSFC{{{CALL FOR FILEARG2 CHECK{26429
{{PPM{6,IOP16{{{FAIL{26430
{{PPM{6,IOP26{{{FAIL{26431
{{BRN{6,IOP11{{{COMPLETE FILE ASSOCIATION{26432
{{EJC{{{{{26433
*
*      IOPUT (CONTINUED)
*
*      HERE WITH 0 OR FCBLK PTR IN (XL)
*
{IOP01{MOV{3,IOPTT{8,WB{{GET TRACE TYPE{26439
{{MOV{3,R$IOT{7,XR{{GET 0 OR TRTRF PTR{26440
{{JSR{6,TRBLD{{{BUILD TRBLK{26441
{{MOV{7,XR{8,WC{{COPY TRBLK POINTER{26442
{{MOV{10,(XS)+{7,XR{{GET VARIABLE FROM STACK{26443
{{MOV{8,WC{11,-(XS){{MAKE TRBLK COLLECTABLE{26444
{{JSR{6,GTVAR{{{POINT TO VARIABLE{26445
{{PPM{6,IOP15{{{FAIL{26446
{{MOV{10,(XS)+{8,WC{{RECOVER TRBLK POINTER{26447
{{MOV{7,XL{3,R$ION{{SAVE NAME POINTER{26448
{{MOV{7,XL{7,XR{{COPY NAME POINTER{26449
{{ADD{8,WA{7,XR{{POINT TO VARIABLE{26450
{{SUB{19,*VRVAL{7,XR{{SUBTRACT OFFSET,MERGE INTO LOOP{26451
*
*      LOOP TO END OF TRBLK CHAIN IF ANY
*
{IOP02{MOV{7,XR{7,XL{{COPY BLK PTR{26455
{{MOV{13,VRVAL(XR){7,XR{{LOAD PTR TO NEXT TRBLK{26456
{{BNE{9,(XR){22,=B$TRT{6,IOP03{JUMP IF NOT TRAPPED{26457
{{BNE{13,TRTYP(XR){3,IOPTT{6,IOP02{LOOP IF NOT SAME ASSOCN{26458
{{MOV{13,TRNXT(XR){7,XR{{GET VALUE AND DELETE OLD TRBLK{26459
*
*      IOPUT (CONTINUED)
*
*      STORE NEW ASSOCIATION
*
{IOP03{MOV{8,WC{13,VRVAL(XL){{LINK TO THIS TRBLK{26465
{{MOV{8,WC{7,XL{{COPY POINTER{26466
{{MOV{7,XR{13,TRNXT(XL){{STORE VALUE IN TRBLK{26467
{{MOV{3,R$ION{7,XR{{RESTORE POSSIBLE VRBLK POINTER{26468
{{MOV{8,WA{8,WB{{KEEP OFFSET TO NAME{26469
{{JSR{6,SETVR{{{IF VRBLK, SET VRGET,VRSTO{26470
{{MOV{3,R$IOT{7,XR{{GET 0 OR TRTRF PTR{26471
{{BNZ{7,XR{6,IOP19{{JUMP IF TRTRF BLOCK EXISTS{26472
{{EXI{{{{RETURN TO CALLER{26473
*
*      NON STANDARD FILE
*      SEE IF AN FCBLK HAS ALREADY BEEN ALLOCATED.
*
{IOP04{ZER{8,WA{{{IN CASE NO FCBLK FOUND{26478
{{EJC{{{{{26479
*
*      IOPUT (CONTINUED)
*
*      SEARCH POSSIBLE TRBLK CHAIN TO PICK UP THE FCBLK
*
{IOP05{MOV{7,XR{8,WB{{REMEMBER BLK PTR{26485
{{MOV{13,VRVAL(XR){7,XR{{CHAIN ALONG{26486
{{BNE{9,(XR){22,=B$TRT{6,IOP06{JUMP IF END OF TRBLK CHAIN{26487
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOP05{LOOP IF MORE TO GO{26488
{{MOV{7,XR{3,R$IOT{{POINT TO FILE ARG1 TRBLK{26489
{{MOV{13,TRFPT(XR){8,WA{{GET FCBLK PTR FROM TRBLK{26490
*
*      WA = 0 OR FCBLK PTR
*      WB = PTR TO PRECEDING BLK TO WHICH ANY TRTRF BLOCK
*           FOR FILE ARG1 MUST BE CHAINED.
*
{IOP06{MOV{8,WA{3,R$IOF{{KEEP POSSIBLE FCBLK PTR{26496
{{MOV{8,WB{3,R$IOP{{KEEP PRECEDING BLK PTR{26497
{{JSR{6,IOPPF{{{PROCESS FILEARG2{26498
{{JSR{6,SYSFC{{{SEE IF FCBLK REQUIRED{26499
{{PPM{6,IOP16{{{FAIL{26500
{{PPM{6,IOP26{{{FAIL{26501
{{BZE{8,WA{6,IOP12{{SKIP IF NO NEW FCBLK WANTED{26502
{{BLT{8,WC{18,=NUM02{6,IOP6A{JUMP IF FCBLK IN DYNAMIC{26503
{{JSR{6,ALOST{{{GET IT IN STATIC{26504
{{BRN{6,IOP6B{{{SKIP{26505
*
*      OBTAIN FCBLK IN DYNAMIC
*
{IOP6A{JSR{6,ALLOC{{{GET SPACE FOR FCBLK{26509
*
*      MERGE
*
{IOP6B{MOV{7,XR{7,XL{{POINT TO FCBLK{26513
{{MOV{8,WA{8,WB{{COPY ITS LENGTH{26514
{{BTW{8,WB{{{GET COUNT AS WORDS (SGD APR80){26515
{{LCT{8,WB{8,WB{{LOOP COUNTER{26516
*
*      CLEAR FCBLK
*
{IOP07{ZER{10,(XR)+{{{CLEAR A WORD{26520
{{BCT{8,WB{6,IOP07{{LOOP{26521
{{BEQ{8,WC{18,=NUM02{6,IOP09{SKIP IF IN STATIC - DONT SET FIELDS{26522
{{MOV{22,=B$XNT{9,(XL){{STORE XNBLK CODE IN CASE{26523
{{MOV{8,WA{13,NUM01(XL){{STORE LENGTH{26524
{{BNZ{8,WC{6,IOP09{{JUMP IF XNBLK WANTED{26525
{{MOV{22,=B$XRT{9,(XL){{XRBLK CODE REQUESTED{26526
*
{{EJC{{{{{26528
*      IOPUT (CONTINUED)
*
*      COMPLETE FCBLK INITIALISATION
*
{IOP09{MOV{3,R$IOT{7,XR{{GET POSSIBLE TRBLK PTR{26533
{{MOV{7,XL{3,R$IOF{{STORE FCBLK PTR{26534
{{BNZ{7,XR{6,IOP10{{JUMP IF TRBLK ALREADY FOUND{26535
*
*      A NEW TRBLK IS NEEDED
*
{{MOV{18,=TRTFC{8,WB{{TRTYP FOR FCBLK TRAP BLK{26539
{{JSR{6,TRBLD{{{MAKE THE BLOCK{26540
{{MOV{7,XR{3,R$IOT{{COPY TRTRF PTR{26541
{{MOV{3,R$IOP{7,XL{{POINT TO PRECEDING BLK{26542
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{COPY VALUE FIELD TO TRBLK{26543
{{MOV{7,XR{13,VRVAL(XL){{LINK NEW TRBLK INTO CHAIN{26544
{{MOV{7,XL{7,XR{{POINT TO PREDECESSOR BLK{26545
{{JSR{6,SETVR{{{SET TRACE INTERCEPTS{26546
{{MOV{13,VRVAL(XR){7,XR{{RECOVER TRBLK PTR{26547
{{BRN{6,IOP1A{{{STORE FCBLK PTR{26548
*
*      HERE IF EXISTING TRBLK
*
{IOP10{ZER{3,R$IOP{{{DO NOT RELEASE IF SYSIO FAILS{26552
*
*      XR IS PTR TO TRBLK, XL IS FCBLK PTR OR 0
*
{IOP1A{MOV{3,R$IOF{13,TRFPT(XR){{STORE FCBLK PTR{26556
*
*      CALL SYSIO TO COMPLETE FILE ACCESSING
*
{IOP11{MOV{3,R$IOF{8,WA{{COPY FCBLK PTR OR 0{26560
{{MOV{3,IOPTT{8,WB{{GET INPUT/OUTPUT FLAG{26561
{{MOV{3,R$IO2{7,XR{{GET FILE ARG2{26562
{{MOV{3,R$IO1{7,XL{{GET FILE ARG1{26563
{{JSR{6,SYSIO{{{ASSOCIATE TO THE FILE{26564
{{PPM{6,IOP17{{{FAIL{26565
{{PPM{6,IOP18{{{FAIL{26566
{{BNZ{3,R$IOT{6,IOP01{{NOT STD INPUT IF NON-NULL TRTRF BLK{26567
{{BNZ{3,IOPTT{6,IOP01{{JUMP IF OUTPUT{26568
{{BZE{8,WC{6,IOP01{{NO CHANGE TO STANDARD READ LENGTH{26569
{{MOV{8,WC{3,CSWIN{{STORE NEW READ LENGTH FOR STD FILE{26570
{{BRN{6,IOP01{{{MERGE TO FINISH THE TASK{26571
*
*      SYSFC MAY HAVE RETURNED A POINTER TO A PRIVATE FCBLK
*
{IOP12{BNZ{7,XL{6,IOP09{{JUMP IF PRIVATE FCBLK{26575
{{BRN{6,IOP11{{{FINISH THE ASSOCIATION{26576
*
*      FAILURE RETURNS
*
{IOP13{EXI{1,1{{{3RD ARG NOT A STRING{26580
{IOP14{EXI{1,2{{{2ND ARG UNSUITABLE{26581
{IOP15{ICA{7,XS{{{DISCARD TRBLK POINTER{26582
{{EXI{1,3{{{1ST ARG UNSUITABLE{26583
{IOP16{EXI{1,4{{{FILE SPEC WRONG{26584
{IOP26{EXI{1,7{{{FCBLK IN USE{26585
*
*      I/O FILE DOES NOT EXIST
*
{IOP17{MOV{3,R$IOP{7,XR{{IS THERE A TRBLK TO RELEASE{26589
{{BZE{7,XR{6,IOPA7{{IF NOT{26590
{{MOV{13,VRVAL(XR){7,XL{{POINT TO TRBLK{26591
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{UNSPLICE IT{26592
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{26593
{IOPA7{EXI{1,5{{{I/O FILE DOES NOT EXIST{26594
*
*      I/O FILE CANNOT BE READ/WRITTEN
*
{IOP18{MOV{3,R$IOP{7,XR{{IS THERE A TRBLK TO RELEASE{26598
{{BZE{7,XR{6,IOPA7{{IF NOT{26599
{{MOV{13,VRVAL(XR){7,XL{{POINT TO TRBLK{26600
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{UNSPLICE IT{26601
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{26602
{IOPA8{EXI{1,6{{{I/O FILE CANNOT BE READ/WRITTEN{26603
{{EJC{{{{{26604
*
*      IOPUT (CONTINUED)
*
*      ADD TO IOCHN CHAIN OF ASSOCIATED VARIABLES UNLESS
*      ALREADY PRESENT.
*
{IOP19{MOV{3,R$ION{8,WC{{WC = NAME BASE, WB = NAME OFFSET{26611
*
*      SEARCH LOOP
*
{IOP20{MOV{13,TRTRF(XR){7,XR{{NEXT LINK OF CHAIN{26615
{{BZE{7,XR{6,IOP21{{NOT FOUND{26616
{{BNE{8,WC{13,IONMB(XR){6,IOP20{NO MATCH{26617
{{BEQ{8,WB{13,IONMO(XR){6,IOP22{EXIT IF MATCHED{26618
{{BRN{6,IOP20{{{LOOP{26619
*
*      NOT FOUND
*
{IOP21{MOV{19,*NUM05{8,WA{{SPACE NEEDED{26623
{{JSR{6,ALLOC{{{GET IT{26624
{{MOV{22,=B$XRT{9,(XR){{STORE XRBLK CODE{26625
{{MOV{8,WA{13,NUM01(XR){{STORE LENGTH{26626
{{MOV{8,WC{13,IONMB(XR){{STORE NAME BASE{26627
{{MOV{8,WB{13,IONMO(XR){{STORE NAME OFFSET{26628
{{MOV{3,R$IOT{7,XL{{POINT TO TRTRF BLK{26629
{{MOV{13,TRTRF(XL){8,WA{{GET PTR FIELD CONTENTS{26630
{{MOV{7,XR{13,TRTRF(XL){{STORE PTR TO NEW BLOCK{26631
{{MOV{8,WA{13,TRTRF(XR){{COMPLETE THE LINKING{26632
*
*      INSERT FCBLK ON FCBLK CHAIN FOR SYSEJ, SYSXI
*
{IOP22{BZE{3,R$IOF{6,IOP25{{SKIP IF NO FCBLK{26636
{{MOV{3,R$FCB{7,XL{{PTR TO HEAD OF EXISTING CHAIN{26637
*
*      SEE IF FCBLK ALREADY ON CHAIN
*
{IOP23{BZE{7,XL{6,IOP24{{NOT ON IF END OF CHAIN{26641
{{BEQ{13,NUM03(XL){3,R$IOF{6,IOP25{DONT DUPLICATE IF FIND IT{26642
{{MOV{13,NUM02(XL){7,XL{{GET NEXT LINK{26643
{{BRN{6,IOP23{{{LOOP{26644
*
*      NOT FOUND SO ADD AN ENTRY FOR THIS FCBLK
*
{IOP24{MOV{19,*NUM04{8,WA{{SPACE NEEDED{26648
{{JSR{6,ALLOC{{{GET IT{26649
{{MOV{22,=B$XRT{9,(XR){{STORE BLOCK CODE{26650
{{MOV{8,WA{13,NUM01(XR){{STORE LENGTH{26651
{{MOV{3,R$FCB{13,NUM02(XR){{STORE PREVIOUS LINK IN THIS NODE{26652
{{MOV{3,R$IOF{13,NUM03(XR){{STORE FCBLK PTR{26653
{{MOV{7,XR{3,R$FCB{{INSERT NODE INTO FCBLK CHAIN{26654
*
*      RETURN
*
{IOP25{EXI{{{{RETURN TO CALLER{26658
{{ENP{{{{END PROCEDURE IOPUT{26659
{{EJC{{{{{26660
*
*      KTREX -- EXECUTE KEYWORD TRACE
*
*      KTREX IS USED TO EXECUTE A POSSIBLE KEYWORD TRACE. IT
*      INCLUDES THE TEST ON TRACE AND TESTS FOR TRACE ACTIVE.
*
*      (XL)                  PTR TO TRBLK (OR 0 IF UNTRACED)
*      JSR  KTREX            CALL TO EXECUTE KEYWORD TRACE
*      (XL,WA,WB,WC)         DESTROYED
*      (RA)                  DESTROYED
*
{KTREX{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){26672
{{BZE{7,XL{6,KTRX3{{IMMEDIATE EXIT IF KEYWORD UNTRACED{26673
{{BZE{3,KVTRA{6,KTRX3{{IMMEDIATE EXIT IF TRACE = 0{26674
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE{26675
{{MOV{7,XR{11,-(XS){{SAVE XR{26676
{{MOV{7,XL{7,XR{{COPY TRBLK POINTER{26677
{{MOV{13,TRKVR(XR){7,XL{{LOAD VRBLK POINTER (NMBAS){26678
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{26679
{{BZE{13,TRFNC(XR){6,KTRX1{{JUMP IF PRINT TRACE{26680
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{26681
{{BRN{6,KTRX2{{{AND JUMP TO EXIT{26682
*
*      HERE FOR PRINT TRACE
*
{KTRX1{MOV{7,XL{11,-(XS){{STACK VRBLK PTR FOR KWNAM{26686
{{MOV{8,WA{11,-(XS){{STACK OFFSET FOR KWNAM{26687
{{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{26688
{{MOV{18,=CH$AM{8,WA{{LOAD AMPERSAND{26689
{{JSR{6,PRTCH{{{PRINT AMPERSAND{26690
{{JSR{6,PRTNM{{{PRINT KEYWORD NAME{26691
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK-EQUAL-BLANK{26692
{{JSR{6,PRTST{{{PRINT BLANK-EQUAL-BLANK{26693
{{JSR{6,KWNAM{{{GET KEYWORD PSEUDO-VARIABLE NAME{26694
{{MOV{7,XR{3,DNAMP{{RESET PTR TO DELETE KVBLK{26695
{{JSR{6,ACESS{{{GET KEYWORD VALUE{26696
{{PPM{{{{FAILURE IS IMPOSSIBLE{26697
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{26698
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{26699
*
*      HERE TO EXIT AFTER COMPLETING TRACE
*
{KTRX2{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{26703
*
*      MERGE HERE TO EXIT IF NO TRACE REQUIRED
*
{KTRX3{EXI{{{{RETURN TO KTREX CALLER{26707
{{ENP{{{{END PROCEDURE KTREX{26708
{{EJC{{{{{26709
*
*      KWNAM -- GET PSEUDO-VARIABLE NAME FOR KEYWORD
*
*      1(XS)                 NAME BASE FOR VRBLK
*      0(XS)                 OFFSET (SHOULD BE *VRVAL)
*      JSR  KWNAM            CALL TO GET PSEUDO-VARIABLE NAME
*      (XS)                  POPPED TWICE
*      (XL,WA)               RESULTING PSEUDO-VARIABLE NAME
*      (XR,WA,WB)            DESTROYED
*
{KWNAM{PRC{25,N{1,0{{ENTRY POINT{26720
{{ICA{7,XS{{{IGNORE NAME OFFSET{26721
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE{26722
{{BGE{7,XR{3,STATE{6,KWNM1{JUMP IF NOT NATURAL VARIABLE NAME{26723
{{BNZ{13,VRLEN(XR){6,KWNM1{{ERROR IF NOT SYSTEM VARIABLE{26724
{{MOV{13,VRSVP(XR){7,XR{{ELSE POINT TO SVBLK{26725
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT MASK{26726
{{ANB{4,BTKNM{8,WA{{AND WITH KEYWORD BIT{26727
{{ZRB{8,WA{6,KWNM1{{ERROR IF NO KEYWORD ASSOCIATION{26728
{{MOV{13,SVLEN(XR){8,WA{{ELSE LOAD NAME LENGTH IN CHARACTERS{26729
{{CTB{8,WA{2,SVCHS{{COMPUTE OFFSET TO FIELD WE WANT{26730
{{ADD{8,WA{7,XR{{POINT TO SVKNM FIELD{26731
{{MOV{9,(XR){8,WB{{LOAD SVKNM VALUE{26732
{{MOV{19,*KVSI${8,WA{{SET SIZE OF KVBLK{26733
{{JSR{6,ALLOC{{{ALLOCATE KVBLK{26734
{{MOV{22,=B$KVT{9,(XR){{STORE TYPE WORD{26735
{{MOV{8,WB{13,KVNUM(XR){{STORE KEYWORD NUMBER{26736
{{MOV{21,=TRBKV{13,KVVAR(XR){{SET DUMMY TRBLK POINTER{26737
{{MOV{7,XR{7,XL{{COPY KVBLK POINTER{26738
{{MOV{19,*KVVAR{8,WA{{SET PROPER OFFSET{26739
{{EXI{{{{RETURN TO KVNAM CALLER{26740
*
*      HERE IF NOT KEYWORD NAME
*
{KWNM1{ERB{1,251{26,Keyword operand is not name of defined keyword{{{26744
{{ENP{{{{END PROCEDURE KWNAM{26745
{{EJC{{{{{26746
*
*      LCOMP-- COMPARE TWO STRINGS LEXICALLY
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  LCOMP            CALL TO COMPARE ARUMENTS
*      PPM  LOC              TRANSFER LOC FOR ARG1 NOT STRING
*      PPM  LOC              TRANSFER LOC FOR ARG2 NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARG1 LLT ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LEQ ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LGT ARG2
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XS)                  POPPED TWICE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{LCOMP{PRC{25,N{1,5{{ENTRY POINT{26763
{{JSR{6,GTSTG{{{CONVERT SECOND ARG TO STRING{26765
{{PPM{6,LCMP6{{{JUMP IF SECOND ARG NOT STRING{26769
{{MOV{7,XR{7,XL{{ELSE SAVE POINTER{26770
{{MOV{8,WA{8,WC{{AND LENGTH{26771
{{JSR{6,GTSTG{{{CONVERT FIRST ARGUMENT TO STRING{26773
{{PPM{6,LCMP5{{{JUMP IF NOT STRING{26777
{{MOV{8,WA{8,WB{{SAVE ARG 1 LENGTH{26778
{{PLC{7,XR{{{POINT TO CHARS OF ARG 1{26779
{{PLC{7,XL{{{POINT TO CHARS OF ARG 2{26780
{{BLO{8,WA{8,WC{6,LCMP1{JUMP IF ARG 1 LENGTH IS SMALLER{26792
{{MOV{8,WC{8,WA{{ELSE SET ARG 2 LENGTH AS SMALLER{26793
*
*      HERE WITH SMALLER LENGTH IN (WA)
*
{LCMP1{BZE{8,WA{6,LCMP7{{IF NULL STRING, COMPARE LENGTHS{26797
{{CMC{6,LCMP4{6,LCMP3{{COMPARE STRINGS, JUMP IF UNEQUAL{26798
{LCMP7{BNE{8,WB{8,WC{6,LCMP2{IF EQUAL, JUMP IF LENGTHS UNEQUAL{26799
{{EXI{1,4{{{ELSE IDENTICAL STRINGS, LEQ EXIT{26800
{{EJC{{{{{26801
*
*      LCOMP (CONTINUED)
*
*      HERE IF INITIAL STRINGS IDENTICAL, BUT LENGTHS UNEQUAL
*
{LCMP2{BHI{8,WB{8,WC{6,LCMP4{JUMP IF ARG 1 LENGTH GT ARG 2 LENG{26807
*
*      HERE IF FIRST ARG LLT SECOND ARG
*
{LCMP3{EXI{1,3{{{TAKE LLT EXIT{26812
*
*      HERE IF FIRST ARG LGT SECOND ARG
*
{LCMP4{EXI{1,5{{{TAKE LGT EXIT{26816
*
*      HERE IF FIRST ARG IS NOT A STRING
*
{LCMP5{EXI{1,1{{{TAKE BAD FIRST ARG EXIT{26820
*
*      HERE FOR SECOND ARG NOT A STRING
*
{LCMP6{EXI{1,2{{{TAKE BAD SECOND ARG ERROR EXIT{26824
{{ENP{{{{END PROCEDURE LCOMP{26825
{{EJC{{{{{26826
*
*      LISTR -- LIST SOURCE LINE
*
*      LISTR IS USED TO LIST A SOURCE LINE DURING THE INITIAL
*      COMPILATION. IT IS CALLED FROM SCANE AND SCANL.
*
*      JSR  LISTR            CALL TO LIST LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL LOCATIONS USED BY LISTR
*
*      CNTTL                 FLAG FOR -TITLE, -STITL
*
*      ERLST                 IF LISTING ON ACCOUNT OF AN ERROR
*
*      LSTID                 INCLUDE DEPTH OF CURRENT IMAGE
*
*      LSTLC                 COUNT LINES ON CURRENT PAGE
*
*      LSTNP                 MAX NUMBER OF LINES/PAGE
*
*      LSTPF                 SET NON-ZERO IF THE CURRENT SOURCE
*                            LINE HAS BEEN LISTED, ELSE ZERO.
*
*      LSTPG                 COMPILER LISTING PAGE NUMBER
*
*      LSTSN                 SET IF STMNT NUM TO BE LISTED
*
*      R$CIM                 POINTER TO CURRENT INPUT LINE.
*
*      R$TTL                 TITLE FOR SOURCE LISTING
*
*      R$STL                 PTR TO SUB-TITLE STRING
*
*      ENTRY POINT
*
{LISTR{PRC{25,E{1,0{{ENTRY POINT{26865
{{BNZ{3,CNTTL{6,LIST5{{JUMP IF -TITLE OR -STITL{26866
{{BNZ{3,LSTPF{6,LIST4{{IMMEDIATE EXIT IF ALREADY LISTED{26867
{{BGE{3,LSTLC{3,LSTNP{6,LIST6{JUMP IF NO ROOM{26868
*
*      HERE AFTER PRINTING TITLE (IF NEEDED)
*
{LIST0{MOV{3,R$CIM{7,XR{{LOAD POINTER TO CURRENT IMAGE{26872
{{BZE{7,XR{6,LIST4{{JUMP IF NO IMAGE TO PRINT{26873
{{PLC{7,XR{{{POINT TO CHARACTERS{26874
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{26875
{{MOV{3,LSTSN{7,XR{{LOAD STATEMENT NUMBER{26876
{{BZE{7,XR{6,LIST2{{JUMP IF NO STATEMENT NUMBER{26877
{{MTI{7,XR{{{ELSE GET STMNT NUMBER AS INTEGER{26878
{{BNE{3,STAGE{18,=STGIC{6,LIST1{SKIP IF EXECUTE TIME{26879
{{BEQ{8,WA{18,=CH$AS{6,LIST2{NO STMNT NUMBER LIST IF COMMENT{26880
{{BEQ{8,WA{18,=CH$MN{6,LIST2{NO STMNT NO. IF CONTROL CARD{26881
*
*      PRINT STATEMENT NUMBER
*
{LIST1{JSR{6,PRTIN{{{ELSE PRINT STATEMENT NUMBER{26885
{{ZER{3,LSTSN{{{AND CLEAR FOR NEXT TIME IN{26886
*
*      HERE TO TEST FOR PRINTING INCLUDE DEPTH
*
{LIST2{MOV{3,LSTID{7,XR{{INCLUDE DEPTH OF IMAGE{26891
{{BZE{7,XR{6,LIST8{{IF NOT FROM AN INCLUDE FILE{26892
{{MOV{18,=STNPD{8,WA{{POSITION FOR START OF STATEMENT{26893
{{SUB{18,=NUM03{8,WA{{POSITION TO PLACE INCLUDE DEPTH{26894
{{MOV{8,WA{3,PROFS{{SET AS STARTING POSITION{26895
{{MTI{7,XR{{{INCLUDE DEPTH AS INTEGER{26896
{{JSR{6,PRTIN{{{PRINT INCLUDE DEPTH{26897
{{EJC{{{{{26898
*
*      LISTR (CONTINUED)
*
*      HERE AFTER PRINTING STATEMENT NUMBER AND INCLUDE DEPTH
*
{LIST8{MOV{18,=STNPD{3,PROFS{{POINT PAST STATEMENT NUMBER{26904
{{MOV{3,R$CIM{7,XR{{LOAD POINTER TO CURRENT IMAGE{26914
{{JSR{6,PRTST{{{PRINT IT{26915
{{ICV{3,LSTLC{{{BUMP LINE COUNTER{26916
{{BNZ{3,ERLST{6,LIST3{{JUMP IF ERROR COPY TO INT.CH.{26917
{{JSR{6,PRTNL{{{TERMINATE LINE{26918
{{BZE{3,CSWDB{6,LIST3{{JUMP IF -SINGLE MODE{26919
{{JSR{6,PRTNL{{{ELSE ADD A BLANK LINE{26920
{{ICV{3,LSTLC{{{AND BUMP LINE COUNTER{26921
*
*      HERE AFTER PRINTING SOURCE IMAGE
*
{LIST3{MNZ{3,LSTPF{{{SET FLAG FOR LINE PRINTED{26925
*
*      MERGE HERE TO EXIT
*
{LIST4{EXI{{{{RETURN TO LISTR CALLER{26929
*
*      PRINT TITLE AFTER -TITLE OR -STITL CARD
*
{LIST5{ZER{3,CNTTL{{{CLEAR FLAG{26933
*
*      EJECT TO NEW PAGE AND LIST TITLE
*
{LIST6{JSR{6,PRTPS{{{EJECT{26937
{{BZE{3,PRICH{6,LIST7{{SKIP IF LISTING TO REGULAR PRINTER{26938
{{BEQ{3,R$TTL{21,=NULLS{6,LIST0{TERMINAL LISTING OMITS NULL TITLE{26939
*
*      LIST TITLE
*
{LIST7{JSR{6,LISTT{{{LIST TITLE{26943
{{BRN{6,LIST0{{{MERGE{26944
{{ENP{{{{END PROCEDURE LISTR{26945
{{EJC{{{{{26946
*
*      LISTT -- LIST TITLE AND SUBTITLE
*
*      USED DURING COMPILATION TO PRINT PAGE HEADING
*
*      JSR  LISTT            CALL TO LIST TITLE
*      (XR,WA)               DESTROYED
*
{LISTT{PRC{25,E{1,0{{ENTRY POINT{26955
{{MOV{3,R$TTL{7,XR{{POINT TO SOURCE LISTING TITLE{26956
{{JSR{6,PRTST{{{PRINT TITLE{26957
{{MOV{3,LSTPO{3,PROFS{{SET OFFSET{26958
{{MOV{21,=LSTMS{7,XR{{SET PAGE MESSAGE{26959
{{JSR{6,PRTST{{{PRINT PAGE MESSAGE{26960
{{ICV{3,LSTPG{{{BUMP PAGE NUMBER{26961
{{MTI{3,LSTPG{{{LOAD PAGE NUMBER AS INTEGER{26962
{{JSR{6,PRTIN{{{PRINT PAGE NUMBER{26963
{{JSR{6,PRTNL{{{TERMINATE TITLE LINE{26964
{{ADD{18,=NUM02{3,LSTLC{{COUNT TITLE LINE AND BLANK LINE{26965
*
*      PRINT SUB-TITLE (IF ANY)
*
{{MOV{3,R$STL{7,XR{{LOAD POINTER TO SUB-TITLE{26969
{{BZE{7,XR{6,LSTT1{{JUMP IF NO SUB-TITLE{26970
{{JSR{6,PRTST{{{ELSE PRINT SUB-TITLE{26971
{{JSR{6,PRTNL{{{TERMINATE LINE{26972
{{ICV{3,LSTLC{{{BUMP LINE COUNT{26973
*
*      RETURN POINT
*
{LSTT1{JSR{6,PRTNL{{{PRINT A BLANK LINE{26977
{{EXI{{{{RETURN TO CALLER{26978
{{ENP{{{{END PROCEDURE LISTT{26979
{{EJC{{{{{26980
*
*      NEWFN -- RECORD NEW SOURCE FILE NAME
*
*      NEWFN IS USED AFTER SWITCHING TO A NEW INCLUDE FILE, OR
*      AFTER A -LINE STATEMENT WHICH CONTAINS A FILE NAME.
*
*      (XR)                  FILE NAME SCBLK
*      JSR  NEWFN
*      (WA,WB,WC,XL,XR,RA)   DESTROYED
*
*      ON RETURN, THE TABLE THAT MAPS STATEMENT NUMBERS TO FILE
*      NAMES HAS BEEN UPDATED TO INCLUDE THIS NEW FILE NAME AND
*      THE CURRENT STATEMENT NUMBER.  THE ENTRY IS MADE ONLY IF
*      THE FILE NAME HAD CHANGED FROM ITS PREVIOUS VALUE.
*
{NEWFN{PRC{25,E{1,0{{ENTRY POINT{26997
{{MOV{7,XR{11,-(XS){{SAVE NEW NAME{26998
{{MOV{3,R$SFC{7,XL{{LOAD PREVIOUS NAME{26999
{{JSR{6,IDENT{{{CHECK FOR EQUALITY{27000
{{PPM{6,NWFN1{{{JUMP IF IDENTICAL{27001
{{MOV{10,(XS)+{7,XR{{DIFFERENT, RESTORE NAME{27002
{{MOV{7,XR{3,R$SFC{{RECORD CURRENT FILE NAME{27003
{{MOV{3,CMPSN{8,WB{{GET CURRENT STATEMENT{27004
{{MTI{8,WB{{{CONVERT TO INTEGER{27005
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{27006
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{27007
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{27008
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{27009
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{27010
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{27011
{{EXI{{{{{27012
*
*     HERE IF NEW NAME AND OLD NAME IDENTICAL
*
{NWFN1{ICA{7,XS{{{POP STACK{27016
{{EXI{{{{{27017
{{EJC{{{{{27018
*
*      NEXTS -- ACQUIRE NEXT SOURCE IMAGE
*
*      NEXTS IS USED TO ACQUIRE THE NEXT SOURCE IMAGE AT COMPILE
*      TIME. IT ASSUMES THAT A PRIOR CALL TO READR HAS INPUT
*      A LINE IMAGE (SEE PROCEDURE READR). BEFORE THE CURRENT
*      IMAGE IS FINALLY LOST IT MAY BE LISTED HERE.
*
*      JSR  NEXTS            CALL TO ACQUIRE NEXT INPUT LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL VALUES AFFECTED
*
*      LSTID                 INCLUDE DEPTH OF NEXT IMAGE
*
*      R$CNI                 ON INPUT, NEXT IMAGE. ON
*                            EXIT RESET TO ZERO
*
*      R$CIM                 ON EXIT, SET TO POINT TO IMAGE
*
*      RDCLN                 CURRENT LN SET FROM NEXT LINE NUM
*
*      SCNIL                 INPUT IMAGE LENGTH ON EXIT
*
*      SCNSE                 RESET TO ZERO ON EXIT
*
*      LSTPF                 SET ON EXIT IF LINE IS LISTED
*
{NEXTS{PRC{25,E{1,0{{ENTRY POINT{27050
{{BZE{3,CSWLS{6,NXTS2{{JUMP IF -NOLIST{27051
{{MOV{3,R$CIM{7,XR{{POINT TO IMAGE{27052
{{BZE{7,XR{6,NXTS2{{JUMP IF NO IMAGE{27053
{{PLC{7,XR{{{GET CHAR PTR{27054
{{LCH{8,WA{9,(XR){{GET FIRST CHAR{27055
{{BNE{8,WA{18,=CH$MN{6,NXTS1{JUMP IF NOT CTRL CARD{27056
{{BZE{3,CSWPR{6,NXTS2{{JUMP IF -NOPRINT{27057
*
*      HERE TO CALL LISTER
*
{NXTS1{JSR{6,LISTR{{{LIST LINE{27061
*
*      HERE AFTER POSSIBLE LISTING
*
{NXTS2{MOV{3,R$CNI{7,XR{{POINT TO NEXT IMAGE{27065
{{MOV{7,XR{3,R$CIM{{SET AS NEXT IMAGE{27066
{{MOV{3,RDNLN{3,RDCLN{{SET AS CURRENT LINE NUMBER{27067
{{MOV{3,CNIND{3,LSTID{{SET AS CURRENT INCLUDE DEPTH{27069
{{ZER{3,R$CNI{{{CLEAR NEXT IMAGE POINTER{27071
{{MOV{13,SCLEN(XR){8,WA{{GET INPUT IMAGE LENGTH{27072
{{MOV{3,CSWIN{8,WB{{GET MAX ALLOWABLE LENGTH{27073
{{BLO{8,WA{8,WB{6,NXTS3{SKIP IF NOT TOO LONG{27074
{{MOV{8,WB{8,WA{{ELSE TRUNCATE{27075
*
*      HERE WITH LENGTH IN (WA)
*
{NXTS3{MOV{8,WA{3,SCNIL{{USE AS RECORD LENGTH{27079
{{ZER{3,SCNSE{{{RESET SCNSE{27080
{{ZER{3,LSTPF{{{SET LINE NOT LISTED YET{27081
{{EXI{{{{RETURN TO NEXTS CALLER{27082
{{ENP{{{{END PROCEDURE NEXTS{27083
{{EJC{{{{{27084
*
*      PATIN -- PATTERN CONSTRUCTION FOR LEN,POS,RPOS,TAB,RTAB
*
*      THESE PATTERN TYPES ALL GENERATE A SIMILAR NODE TYPE. SO
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE FUNCTIONS.
*
*      (WA)                  PCODE FOR EXPRESSION ARG CASE
*      (WB)                  PCODE FOR INTEGER ARG CASE
*      JSR  PATIN            CALL TO BUILD PATTERN NODE
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER OR EXP
*      PPM  LOC              TRANSFER LOC FOR INT OUT OF RANGE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL,WA,WB,WC,IA)      DESTROYED
*
{PATIN{PRC{25,N{1,2{{ENTRY POINT{27100
{{MOV{8,WA{7,XL{{PRESERVE EXPRESSION ARG PCODE{27101
{{JSR{6,GTSMI{{{TRY TO CONVERT ARG AS SMALL INTEGER{27102
{{PPM{6,PTIN2{{{JUMP IF NOT INTEGER{27103
{{PPM{6,PTIN3{{{JUMP IF OUT OF RANGE{27104
*
*      COMMON SUCCESSFUL EXIT POINT
*
{PTIN1{JSR{6,PBILD{{{BUILD PATTERN NODE{27108
{{EXI{{{{RETURN TO CALLER{27109
*
*      HERE IF ARGUMENT IS NOT AN INTEGER
*
{PTIN2{MOV{7,XL{8,WB{{COPY EXPR ARG CASE PCODE{27113
{{BLO{9,(XR){22,=B$E$${6,PTIN1{ALL OK IF EXPRESSION ARG{27114
{{EXI{1,1{{{ELSE TAKE ERROR EXIT FOR WRONG TYPE{27115
*
*      HERE FOR ERROR OF OUT OF RANGE INTEGER ARGUMENT
*
{PTIN3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{27119
{{ENP{{{{END PROCEDURE PATIN{27120
{{EJC{{{{{27121
*
*      PATST -- PATTERN CONSTRUCTION FOR ANY,NOTANY,
*               BREAK,SPAN AND BREAKX PATTERN FUNCTIONS.
*
*      THESE PATTERN FUNCTIONS BUILD SIMILAR TYPES OF NODES AND
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE PATTERN FUNCTIONS.
*
*      0(XS)                 STRING ARGUMENT
*      (WB)                  PCODE FOR ONE CHAR ARGUMENT
*      (XL)                  PCODE FOR MULTI-CHAR ARGUMENT
*      (WC)                  PCODE FOR EXPRESSION ARGUMENT
*      JSR  PATST            CALL TO BUILD NODE
*      PPM  LOC              IF NOT STRING OR EXPR (OR NULL)
*      (XS)                  POPPED PAST STRING ARGUMENT
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL)                  DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      NOTE THAT THERE IS A SPECIAL CALL TO PATST IN THE EVALS
*      PROCEDURE WITH A SLIGHTLY DIFFERENT FORM. SEE EVALS
*      FOR DETAILS OF THE FORM OF THIS CALL.
*
{PATST{PRC{25,N{1,1{{ENTRY POINT{27145
{{JSR{6,GTSTG{{{CONVERT ARGUMENT AS STRING{27146
{{PPM{6,PATS7{{{JUMP IF NOT STRING{27147
{{BZE{8,WA{6,PATS7{{JUMP IF NULL STRING (CATSPAW){27148
{{BNE{8,WA{18,=NUM01{6,PATS2{JUMP IF NOT ONE CHAR STRING{27149
*
*      HERE FOR ONE CHAR STRING CASE
*
{{BZE{8,WB{6,PATS2{{TREAT AS MULTI-CHAR IF EVALS CALL{27153
{{PLC{7,XR{{{POINT TO CHARACTER{27154
{{LCH{7,XR{9,(XR){{LOAD CHARACTER{27155
*
*      COMMON EXIT POINT AFTER SUCCESSFUL CONSTRUCTION
*
{PATS1{JSR{6,PBILD{{{CALL ROUTINE TO BUILD NODE{27159
{{EXI{{{{RETURN TO PATST CALLER{27160
{{EJC{{{{{27161
*
*      PATST (CONTINUED)
*
*      HERE FOR MULTI-CHARACTER STRING CASE
*
{PATS2{MOV{7,XL{11,-(XS){{SAVE MULTI-CHAR PCODE{27167
{{MOV{3,CTMSK{8,WC{{LOAD CURRENT MASK BIT{27168
{{BEQ{7,XR{3,R$CTS{6,PATS6{JUMP IF SAME AS LAST STRING C3.738{27169
{{MOV{7,XR{11,-(XS){{SAVE STRING POINTER{27170
{{LSH{8,WC{1,1{{SHIFT TO NEXT POSITION{27171
{{NZB{8,WC{6,PATS4{{SKIP IF POSITION LEFT IN THIS TBL{27172
*
*      HERE WE MUST ALLOCATE A NEW CHARACTER TABLE
*
{{MOV{19,*CTSI${8,WA{{SET SIZE OF CTBLK{27176
{{JSR{6,ALLOC{{{ALLOCATE CTBLK{27177
{{MOV{7,XR{3,R$CTP{{STORE PTR TO NEW CTBLK{27178
{{MOV{22,=B$CTT{10,(XR)+{{STORE TYPE CODE, BUMP PTR{27179
{{LCT{8,WB{18,=CFP$A{{SET NUMBER OF WORDS TO CLEAR{27180
{{MOV{4,BITS0{8,WC{{LOAD ALL ZERO BITS{27181
*
*      LOOP TO CLEAR ALL BITS IN TABLE TO ZEROS
*
{PATS3{MOV{8,WC{10,(XR)+{{MOVE WORD OF ZERO BITS{27185
{{BCT{8,WB{6,PATS3{{LOOP TILL ALL CLEARED{27186
{{MOV{4,BITS1{8,WC{{SET INITIAL BIT POSITION{27187
*
*      MERGE HERE WITH BIT POSITION AVAILABLE
*
{PATS4{MOV{8,WC{3,CTMSK{{SAVE PARM2 (NEW BIT POSITION){27191
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER TO ARGUMENT STRING{27192
{{MOV{7,XL{3,R$CTS{{SAVE FOR NEXT TIME   C3.738{27193
{{MOV{13,SCLEN(XL){8,WB{{LOAD STRING LENGTH{27194
{{BZE{8,WB{6,PATS6{{JUMP IF NULL STRING CASE{27195
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{27196
{{PLC{7,XL{{{POINT TO CHARACTERS IN ARGUMENT{27197
{{EJC{{{{{27198
*
*      PATST (CONTINUED)
*
*      LOOP TO SET BITS IN COLUMN OF TABLE
*
{PATS5{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{27204
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{27205
{{MOV{3,R$CTP{7,XR{{POINT TO CTBLK{27206
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{27207
{{MOV{8,WC{8,WA{{COPY BIT MASK{27208
{{ORB{13,CTCHS(XR){8,WA{{OR IN BITS ALREADY SET{27209
{{MOV{8,WA{13,CTCHS(XR){{STORE RESULTING BIT STRING{27210
{{BCT{8,WB{6,PATS5{{LOOP TILL ALL BITS SET{27211
*
*      COMPLETE PROCESSING FOR MULTI-CHAR STRING CASE
*
{PATS6{MOV{3,R$CTP{7,XR{{LOAD CTBLK PTR AS PARM1 FOR PBILD{27215
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{27216
{{MOV{10,(XS)+{8,WB{{LOAD PCODE FOR MULTI-CHAR STR CASE{27217
{{BRN{6,PATS1{{{BACK TO EXIT (WC=BITSTRING=PARM2){27218
*
*      HERE IF ARGUMENT IS NOT A STRING
*
*      NOTE THAT THE CALL FROM EVALS CANNOT PASS AN EXPRESSION
*      SINCE EVALP ALWAYS REEVALUATES EXPRESSIONS.
*
{PATS7{MOV{8,WC{8,WB{{SET PCODE FOR EXPRESSION ARGUMENT{27225
{{BLO{9,(XR){22,=B$E$${6,PATS1{JUMP TO EXIT IF EXPRESSION ARG{27226
{{EXI{1,1{{{ELSE TAKE WRONG TYPE ERROR EXIT{27227
{{ENP{{{{END PROCEDURE PATST{27228
{{EJC{{{{{27229
*
*      PBILD -- BUILD PATTERN NODE
*
*      (XR)                  PARM1 (ONLY IF REQUIRED)
*      (WB)                  PCODE FOR NODE
*      (WC)                  PARM2 (ONLY IF REQUIRED)
*      JSR  PBILD            CALL TO BUILD NODE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (WA)                  DESTROYED
*
{PBILD{PRC{25,E{1,0{{ENTRY POINT{27240
{{MOV{7,XR{11,-(XS){{STACK POSSIBLE PARM1{27241
{{MOV{8,WB{7,XR{{COPY PCODE{27242
{{LEI{7,XR{{{LOAD ENTRY POINT ID (BL$PX){27243
{{BEQ{7,XR{18,=BL$P1{6,PBLD1{JUMP IF ONE PARAMETER{27244
{{BEQ{7,XR{18,=BL$P0{6,PBLD3{JUMP IF NO PARAMETERS{27245
*
*      HERE FOR TWO PARAMETER CASE
*
{{MOV{19,*PCSI${8,WA{{SET SIZE OF P2BLK{27249
{{JSR{6,ALLOC{{{ALLOCATE BLOCK{27250
{{MOV{8,WC{13,PARM2(XR){{STORE SECOND PARAMETER{27251
{{BRN{6,PBLD2{{{MERGE WITH ONE PARM CASE{27252
*
*      HERE FOR ONE PARAMETER CASE
*
{PBLD1{MOV{19,*PBSI${8,WA{{SET SIZE OF P1BLK{27256
{{JSR{6,ALLOC{{{ALLOCATE NODE{27257
*
*      MERGE HERE FROM TWO PARM CASE
*
{PBLD2{MOV{9,(XS){13,PARM1(XR){{STORE FIRST PARAMETER{27261
{{BRN{6,PBLD4{{{MERGE WITH NO PARAMETER CASE{27262
*
*      HERE FOR CASE OF NO PARAMETERS
*
{PBLD3{MOV{19,*PASI${8,WA{{SET SIZE OF P0BLK{27266
{{JSR{6,ALLOC{{{ALLOCATE NODE{27267
*
*      MERGE HERE FROM OTHER CASES
*
{PBLD4{MOV{8,WB{9,(XR){{STORE PCODE{27271
{{ICA{7,XS{{{POP FIRST PARAMETER{27272
{{MOV{21,=NDNTH{13,PTHEN(XR){{SET NOTHEN SUCCESSOR POINTER{27273
{{EXI{{{{RETURN TO PBILD CALLER{27274
{{ENP{{{{END PROCEDURE PBILD{27275
{{EJC{{{{{27276
*
*      PCONC -- CONCATENATE TWO PATTERNS
*
*      (XL)                  PTR TO RIGHT PATTERN
*      (XR)                  PTR TO LEFT PATTERN
*      JSR  PCONC            CALL TO CONCATENATE PATTERNS
*      (XR)                  PTR TO CONCATENATED PATTERN
*      (XL,WA,WB,WC)         DESTROYED
*
*
*      TO CONCATENATE TWO PATTERNS, ALL SUCCESSORS IN THE LEFT
*      PATTERN WHICH POINT TO THE NOTHEN NODE MUST BE CHANGED TO
*      POINT TO THE RIGHT PATTERN. HOWEVER, THIS MODIFICATION
*      MUST BE PERFORMED ON A COPY OF THE LEFT ARGUMENT RATHER
*      THAN THE LEFT ARGUMENT ITSELF, SINCE THE LEFT ARGUMENT
*      MAY BE POINTED TO BY SOME OTHER VARIABLE VALUE.
*
*      ACCORDINGLY, IT IS NECESSARY TO COPY THE LEFT ARGUMENT.
*      THIS IS NOT A TRIVIAL PROCESS SINCE WE MUST AVOID COPYING
*      NODES MORE THAN ONCE AND THE PATTERN IS A GRAPH STRUCTURE
*      THE FOLLOWING ALGORITHM IS EMPLOYED.
*
*      THE STACK IS USED TO STORE A LIST OF NODES WHICH
*      HAVE ALREADY BEEN COPIED. THE FORMAT OF THE ENTRIES ON
*      THIS LIST CONSISTS OF A TWO WORD BLOCK. THE FIRST WORD
*      IS THE OLD ADDRESS AND THE SECOND WORD IS THE ADDRESS
*      OF THE COPY. THIS LIST IS SEARCHED BY THE PCOPY
*      ROUTINE TO AVOID MAKING DUPLICATE COPIES. A TRICK IS
*      USED TO ACCOMPLISH THE CONCATENATION AT THE SAME TIME.
*      A SPECIAL ENTRY IS MADE TO START WITH ON THE STACK. THIS
*      ENTRY RECORDS THAT THE NOTHEN NODE HAS BEEN COPIED
*      ALREADY AND THE ADDRESS OF ITS COPY IS THE RIGHT PATTERN.
*      THIS AUTOMATICALLY PERFORMS THE CORRECT REPLACEMENTS.
*
{PCONC{PRC{25,E{1,0{{ENTRY POINT{27311
{{ZER{11,-(XS){{{MAKE ROOM FOR ONE ENTRY AT BOTTOM{27312
{{MOV{7,XS{8,WC{{STORE POINTER TO START OF LIST{27313
{{MOV{21,=NDNTH{11,-(XS){{STACK NOTHEN NODE AS OLD NODE{27314
{{MOV{7,XL{11,-(XS){{STORE RIGHT ARG AS COPY OF NOTHEN{27315
{{MOV{7,XS{7,XT{{INITIALIZE POINTER TO STACK ENTRIES{27316
{{JSR{6,PCOPY{{{COPY FIRST NODE OF LEFT ARG{27317
{{MOV{8,WA{13,NUM02(XT){{STORE AS RESULT UNDER LIST{27318
{{EJC{{{{{27319
*
*      PCONC (CONTINUED)
*
*      THE FOLLOWING LOOP SCANS ENTRIES IN THE LIST AND MAKES
*      SURE THAT THEIR SUCCESSORS HAVE BEEN COPIED.
*
{PCNC1{BEQ{7,XT{7,XS{6,PCNC2{JUMP IF ALL ENTRIES PROCESSED{27326
{{MOV{11,-(XT){7,XR{{ELSE LOAD NEXT OLD ADDRESS{27327
{{MOV{13,PTHEN(XR){7,XR{{LOAD POINTER TO SUCCESSOR{27328
{{JSR{6,PCOPY{{{COPY SUCCESSOR NODE{27329
{{MOV{11,-(XT){7,XR{{LOAD POINTER TO NEW NODE (COPY){27330
{{MOV{8,WA{13,PTHEN(XR){{STORE PTR TO NEW SUCCESSOR{27331
*
*      NOW CHECK FOR SPECIAL CASE OF ALTERNATION NODE WHERE
*      PARM1 POINTS TO A NODE AND MUST BE COPIED LIKE PTHEN.
*
{{BNE{9,(XR){22,=P$ALT{6,PCNC1{LOOP BACK IF NOT{27336
{{MOV{13,PARM1(XR){7,XR{{ELSE LOAD POINTER TO ALTERNATIVE{27337
{{JSR{6,PCOPY{{{COPY IT{27338
{{MOV{9,(XT){7,XR{{RESTORE PTR TO NEW NODE{27339
{{MOV{8,WA{13,PARM1(XR){{STORE PTR TO COPIED ALTERNATIVE{27340
{{BRN{6,PCNC1{{{LOOP BACK FOR NEXT ENTRY{27341
*
*      HERE AT END OF COPY PROCESS
*
{PCNC2{MOV{8,WC{7,XS{{RESTORE STACK POINTER{27345
{{MOV{10,(XS)+{7,XR{{LOAD POINTER TO COPY{27346
{{EXI{{{{RETURN TO PCONC CALLER{27347
{{ENP{{{{END PROCEDURE PCONC{27348
{{EJC{{{{{27349
*
*      PCOPY -- COPY A PATTERN NODE
*
*      PCOPY IS CALLED FROM THE PCONC PROCEDURE TO COPY A SINGLE
*      PATTERN NODE. THE COPY IS ONLY CARRIED OUT IF THE NODE
*      HAS NOT BEEN COPIED ALREADY.
*
*      (XR)                  POINTER TO NODE TO BE COPIED
*      (XT)                  PTR TO CURRENT LOC IN COPY LIST
*      (WC)                  POINTER TO LIST OF COPIED NODES
*      JSR  PCOPY            CALL TO COPY A NODE
*      (WA)                  POINTER TO COPY
*      (WB,XR)               DESTROYED
*
{PCOPY{PRC{25,N{1,0{{ENTRY POINT{27364
{{MOV{7,XT{8,WB{{SAVE XT{27365
{{MOV{8,WC{7,XT{{POINT TO START OF LIST{27366
*
*      LOOP TO SEARCH LIST OF NODES COPIED ALREADY
*
{PCOP1{DCA{7,XT{{{POINT TO NEXT ENTRY ON LIST{27370
{{BEQ{7,XR{9,(XT){6,PCOP2{JUMP IF MATCH{27371
{{DCA{7,XT{{{ELSE SKIP OVER COPIED ADDRESS{27372
{{BNE{7,XT{7,XS{6,PCOP1{LOOP BACK IF MORE TO TEST{27373
*
*      HERE IF NOT IN LIST, PERFORM COPY
*
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{27377
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{27378
{{MOV{7,XR{7,XL{{SAVE POINTER TO OLD NODE{27379
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{27380
{{MOV{7,XL{11,-(XS){{STORE OLD ADDRESS ON LIST{27381
{{MOV{7,XR{11,-(XS){{STORE NEW ADDRESS ON LIST{27382
{{CHK{{{{CHECK FOR STACK OVERFLOW{27383
{{MVW{{{{MOVE WORDS FROM OLD BLOCK TO COPY{27384
{{MOV{9,(XS){8,WA{{LOAD POINTER TO COPY{27385
{{BRN{6,PCOP3{{{JUMP TO EXIT{27386
*
*      HERE IF WE FIND ENTRY IN LIST
*
{PCOP2{MOV{11,-(XT){8,WA{{LOAD ADDRESS OF COPY FROM LIST{27390
*
*      COMMON EXIT POINT
*
{PCOP3{MOV{8,WB{7,XT{{RESTORE XT{27394
{{EXI{{{{RETURN TO PCOPY CALLER{27395
{{ENP{{{{END PROCEDURE PCOPY{27396
{{EJC{{{{{27397
*
*      PRFLR -- PRINT PROFILE
*      PRFLR IS CALLED TO PRINT THE CONTENTS OF THE PROFILE
*      TABLE IN A FAIRLY READABLE TABULAR FORMAT.
*
*      JSR  PRFLR            CALL TO PRINT PROFILE
*      (WA,IA)               DESTROYED
*
{PRFLR{PRC{25,E{1,0{{{27408
{{BZE{3,PFDMP{6,PRFL4{{NO PRINTING IF NO PROFILING DONE{27409
{{MOV{7,XR{11,-(XS){{PRESERVE ENTRY XR{27410
{{MOV{8,WB{3,PFSVW{{AND ALSO WB{27411
{{JSR{6,PRTPG{{{EJECT{27412
{{MOV{21,=PFMS1{7,XR{{LOAD MSG /PROGRAM PROFILE/{27413
{{JSR{6,PRTST{{{AND PRINT IT{27414
{{JSR{6,PRTNL{{{FOLLOWED BY NEWLINE{27415
{{JSR{6,PRTNL{{{AND ANOTHER{27416
{{MOV{21,=PFMS2{7,XR{{POINT TO FIRST HDR{27417
{{JSR{6,PRTST{{{PRINT IT{27418
{{JSR{6,PRTNL{{{NEW LINE{27419
{{MOV{21,=PFMS3{7,XR{{SECOND HDR{27420
{{JSR{6,PRTST{{{PRINT IT{27421
{{JSR{6,PRTNL{{{NEW LINE{27422
{{JSR{6,PRTNL{{{AND ANOTHER BLANK LINE{27423
{{ZER{8,WB{{{INITIAL STMT COUNT{27424
{{MOV{3,PFTBL{7,XR{{POINT TO TABLE ORIGIN{27425
{{ADD{19,*XNDTA{7,XR{{BIAS PAST XNBLK HEADER (SGD07){27426
*
*      LOOP HERE TO PRINT SUCCESSIVE ENTRIES
*
{PRFL1{ICV{8,WB{{{BUMP STMT NR{27430
{{LDI{9,(XR){{{LOAD NR OF EXECUTIONS{27431
{{IEQ{6,PRFL3{{{NO PRINTING IF ZERO{27432
{{MOV{18,=PFPD1{3,PROFS{{POINT WHERE TO PRINT{27433
{{JSR{6,PRTIN{{{AND PRINT IT{27434
{{ZER{3,PROFS{{{BACK TO START OF LINE{27435
{{MTI{8,WB{{{LOAD STMT NR{27436
{{JSR{6,PRTIN{{{PRINT IT THERE{27437
{{MOV{18,=PFPD2{3,PROFS{{AND PAD PAST COUNT{27438
{{LDI{13,CFP$I(XR){{{LOAD TOTAL EXEC TIME{27439
{{JSR{6,PRTIN{{{PRINT THAT TOO{27440
{{LDI{13,CFP$I(XR){{{RELOAD TIME{27441
{{MLI{4,INTTH{{{CONVERT TO MICROSEC{27442
{{IOV{6,PRFL2{{{OMIT NEXT BIT IF OVERFLOW{27443
{{DVI{9,(XR){{{DIVIDE BY EXECUTIONS{27444
{{MOV{18,=PFPD3{3,PROFS{{PAD LAST PRINT{27445
{{JSR{6,PRTIN{{{AND PRINT MCSEC/EXECN{27446
*
*      MERGE AFTER PRINTING TIME
*
{PRFL2{JSR{6,PRTNL{{{THATS ANOTHER LINE{27450
*
*      HERE TO GO TO NEXT ENTRY
*
{PRFL3{ADD{19,*PF$I2{7,XR{{BUMP INDEX PTR (SGD07){27454
{{BLT{8,WB{3,PFNTE{6,PRFL1{LOOP IF MORE STMTS{27455
{{MOV{10,(XS)+{7,XR{{RESTORE CALLERS XR{27456
{{MOV{3,PFSVW{8,WB{{AND WB TOO{27457
*
*      HERE TO EXIT
*
{PRFL4{EXI{{{{RETURN{27461
{{ENP{{{{END OF PRFLR{27462
{{EJC{{{{{27463
*
*      PRFLU -- UPDATE AN ENTRY IN THE PROFILE TABLE
*
*      ON ENTRY, KVSTN CONTAINS NR OF STMT TO PROFILE
*
*      JSR  PRFLU            CALL TO UPDATE ENTRY
*      (IA)                  DESTROYED
*
{PRFLU{PRC{25,E{1,0{{{27472
{{BNZ{3,PFFNC{6,PFLU4{{SKIP IF JUST ENTERED FUNCTION{27473
{{MOV{7,XR{11,-(XS){{PRESERVE ENTRY XR{27474
{{MOV{8,WA{3,PFSVW{{SAVE WA (SGD07){27475
{{BNZ{3,PFTBL{6,PFLU2{{BRANCH IF TABLE ALLOCATED{27476
*
*      HERE IF SPACE FOR PROFILE TABLE NOT YET ALLOCATED.
*      CALCULATE SIZE NEEDED, ALLOCATE A STATIC XNBLK, AND
*      INITIALIZE IT ALL TO ZERO.
*      THE TIME TAKEN FOR THIS WILL BE ATTRIBUTED TO THE CURRENT
*      STATEMENT (ASSIGNMENT TO KEYWD PROFILE), BUT SINCE THE
*      TIMING FOR THIS STATEMENT IS UP THE POLE ANYWAY, THIS
*      DOESNT REALLY MATTER...
*
{{SUB{18,=NUM01{3,PFNTE{{ADJUST FOR EXTRA COUNT (SGD07){27486
{{MTI{4,PFI2A{{{CONVRT ENTRY SIZE TO INT{27487
{{STI{3,PFSTE{{{AND STORE SAFELY FOR LATER{27488
{{MTI{3,PFNTE{{{LOAD TABLE LENGTH AS INTEGER{27489
{{MLI{3,PFSTE{{{MULTIPLY BY ENTRY SIZE{27490
{{MFI{8,WA{{{GET BACK ADDRESS-STYLE{27491
{{ADD{18,=NUM02{8,WA{{ADD ON 2 WORD OVERHEAD{27492
{{WTB{8,WA{{{CONVERT THE WHOLE LOT TO BYTES{27493
{{JSR{6,ALOST{{{GIMME THE SPACE{27494
{{MOV{7,XR{3,PFTBL{{SAVE BLOCK POINTER{27495
{{MOV{22,=B$XNT{10,(XR)+{{PUT BLOCK TYPE AND ...{27496
{{MOV{8,WA{10,(XR)+{{... LENGTH INTO HEADER{27497
{{MFI{8,WA{{{GET BACK NR OF WDS IN DATA AREA{27498
{{LCT{8,WA{8,WA{{LOAD THE COUNTER{27499
*
*      LOOP HERE TO ZERO THE BLOCK DATA
*
{PFLU1{ZER{10,(XR)+{{{BLANK A WORD{27503
{{BCT{8,WA{6,PFLU1{{AND ALLLLLLL THE REST{27504
*
*      END OF ALLOCATION. MERGE BACK INTO ROUTINE
*
{PFLU2{MTI{3,KVSTN{{{LOAD NR OF STMT JUST ENDED{27508
{{SBI{4,INTV1{{{MAKE INTO INDEX OFFSET{27509
{{MLI{3,PFSTE{{{MAKE OFFSET OF TABLE ENTRY{27510
{{MFI{8,WA{{{CONVERT TO ADDRESS{27511
{{WTB{8,WA{{{GET AS BAUS{27512
{{ADD{19,*NUM02{8,WA{{OFFSET INCLUDES TABLE HEADER{27513
{{MOV{3,PFTBL{7,XR{{GET TABLE START{27514
{{BGE{8,WA{13,NUM01(XR){6,PFLU3{IF OUT OF TABLE, SKIP IT{27515
{{ADD{8,WA{7,XR{{ELSE POINT TO ENTRY{27516
{{LDI{9,(XR){{{GET NR OF EXECUTIONS SO FAR{27517
{{ADI{4,INTV1{{{NUDGE UP ONE{27518
{{STI{9,(XR){{{AND PUT BACK{27519
{{JSR{6,SYSTM{{{GET TIME NOW{27520
{{STI{3,PFETM{{{STASH ENDING TIME{27521
{{SBI{3,PFSTM{{{SUBTRACT START TIME{27522
{{ADI{13,CFP$I(XR){{{ADD CUMULATIVE TIME SO FAR{27523
{{STI{13,CFP$I(XR){{{AND PUT BACK NEW TOTAL{27524
{{LDI{3,PFETM{{{LOAD END TIME OF THIS STMT ...{27525
{{STI{3,PFSTM{{{... WHICH IS START TIME OF NEXT{27526
*
*      MERGE HERE TO EXIT
*
{PFLU3{MOV{10,(XS)+{7,XR{{RESTORE CALLERS XR{27530
{{MOV{3,PFSVW{8,WA{{RESTORE SAVED REG{27531
{{EXI{{{{AND RETURN{27532
*
*      HERE IF PROFILE IS SUPPRESSED BECAUSE A PROGRAM DEFINED
*      FUNCTION IS ABOUT TO BE ENTERED, AND SO THE CURRENT STMT
*      HAS NOT YET FINISHED
*
{PFLU4{ZER{3,PFFNC{{{RESET THE CONDITION FLAG{27538
{{EXI{{{{AND IMMEDIATE RETURN{27539
{{ENP{{{{END OF PROCEDURE PRFLU{27540
{{EJC{{{{{27541
*
*      PRPAR - PROCESS PRINT PARAMETERS
*
*      (WC)                  IF NONZERO ASSOCIATE TERMINAL ONLY
*      JSR  PRPAR            CALL TO PROCESS PRINT PARAMETERS
*      (XL,XR,WA,WB,WC)      DESTROYED
*
*      SINCE MEMORY ALLOCATION IS UNDECIDED ON INITIAL CALL,
*      TERMINAL CANNOT BE ASSOCIATED. THE ENTRY WITH WC NON-ZERO
*      IS PROVIDED SO A LATER CALL CAN BE MADE TO COMPLETE THIS.
*
{PRPAR{PRC{25,E{1,0{{ENTRY POINT{27554
{{BNZ{8,WC{6,PRPA8{{JUMP TO ASSOCIATE TERMINAL{27555
{{JSR{6,SYSPP{{{GET PRINT PARAMETERS{27556
{{BNZ{8,WB{6,PRPA1{{JUMP IF LINES/PAGE SPECIFIED{27557
{{MOV{18,=CFP$M{8,WB{{ELSE USE A LARGE VALUE{27558
{{RSH{8,WB{1,1{{BUT NOT TOO LARGE{27559
*
*      STORE LINE COUNT/PAGE
*
{PRPA1{MOV{8,WB{3,LSTNP{{STORE NUMBER OF LINES/PAGE{27563
{{MOV{8,WB{3,LSTLC{{PRETEND PAGE IS FULL INITIALLY{27564
{{ZER{3,LSTPG{{{CLEAR PAGE NUMBER{27565
{{MOV{3,PRLEN{8,WB{{GET PRIOR LENGTH IF ANY{27566
{{BZE{8,WB{6,PRPA2{{SKIP IF NO LENGTH{27567
{{BGT{8,WA{8,WB{6,PRPA3{SKIP STORING IF TOO BIG{27568
*
*      STORE PRINT BUFFER LENGTH
*
{PRPA2{MOV{8,WA{3,PRLEN{{STORE VALUE{27572
*
*      PROCESS BITS OPTIONS
*
{PRPA3{MOV{4,BITS3{8,WB{{BIT 3 MASK{27576
{{ANB{8,WC{8,WB{{GET -NOLIST BIT{27577
{{ZRB{8,WB{6,PRPA4{{SKIP IF CLEAR{27578
{{ZER{3,CSWLS{{{SET -NOLIST{27579
*
*      CHECK IF FAIL REPORTS GOTO INTERACTIVE CHANNEL
*
{PRPA4{MOV{4,BITS1{8,WB{{BIT 1 MASK{27583
{{ANB{8,WC{8,WB{{GET BIT{27584
{{MOV{8,WB{3,ERICH{{STORE INT. CHAN. ERROR FLAG{27585
{{MOV{4,BITS2{8,WB{{BIT 2 MASK{27586
{{ANB{8,WC{8,WB{{GET BIT{27587
{{MOV{8,WB{3,PRICH{{FLAG FOR STD PRINTER ON INT. CHAN.{27588
{{MOV{4,BITS4{8,WB{{BIT 4 MASK{27589
{{ANB{8,WC{8,WB{{GET BIT{27590
{{MOV{8,WB{3,CPSTS{{FLAG FOR COMPILE STATS SUPPRESSN.{27591
{{MOV{4,BITS5{8,WB{{BIT 5 MASK{27592
{{ANB{8,WC{8,WB{{GET BIT{27593
{{MOV{8,WB{3,EXSTS{{FLAG FOR EXEC STATS SUPPRESSION{27594
{{EJC{{{{{27595
*
*      PRPAR (CONTINUED)
*
{{MOV{4,BITS6{8,WB{{BIT 6 MASK{27599
{{ANB{8,WC{8,WB{{GET BIT{27600
{{MOV{8,WB{3,PRECL{{EXTENDED/COMPACT LISTING FLAG{27601
{{SUB{18,=NUM08{8,WA{{POINT 8 CHARS FROM LINE END{27602
{{ZRB{8,WB{6,PRPA5{{JUMP IF NOT EXTENDED{27603
{{MOV{8,WA{3,LSTPO{{STORE FOR LISTING PAGE HEADINGS{27604
*
*       CONTINUE OPTION PROCESSING
*
{PRPA5{MOV{4,BITS7{8,WB{{BIT 7 MASK{27608
{{ANB{8,WC{8,WB{{GET BIT 7{27609
{{MOV{8,WB{3,CSWEX{{SET -NOEXECUTE IF NON-ZERO{27610
{{MOV{4,BIT10{8,WB{{BIT 10 MASK{27611
{{ANB{8,WC{8,WB{{GET BIT 10{27612
{{MOV{8,WB{3,HEADP{{PRETEND PRINTED TO OMIT HEADERS{27613
{{MOV{4,BITS9{8,WB{{BIT 9 MASK{27614
{{ANB{8,WC{8,WB{{GET BIT 9{27615
{{MOV{8,WB{3,PRSTO{{KEEP IT AS STD LISTING OPTION{27616
{{MOV{8,WC{8,WB{{COPY FLAGS{27618
{{RSH{8,WB{1,12{{RIGHT JUSTIFY BIT 13{27619
{{ANB{4,BITS1{8,WB{{GET BIT{27620
{{MOV{8,WB{3,KVCAS{{SET -CASE{27621
{{MOV{4,BIT12{8,WB{{BIT 12 MASK{27623
{{ANB{8,WC{8,WB{{GET BIT 12{27624
{{MOV{8,WB{3,CSWER{{KEEP IT AS ERRORS/NOERRORS OPTION{27625
{{ZRB{8,WB{6,PRPA6{{SKIP IF CLEAR{27626
{{MOV{3,PRLEN{8,WA{{GET PRINT BUFFER LENGTH{27627
{{SUB{18,=NUM08{8,WA{{POINT 8 CHARS FROM LINE END{27628
{{MOV{8,WA{3,LSTPO{{STORE PAGE OFFSET{27629
*
*      CHECK FOR -PRINT/-NOPRINT
*
{PRPA6{MOV{4,BIT11{8,WB{{BIT 11 MASK{27633
{{ANB{8,WC{8,WB{{GET BIT 11{27634
{{MOV{8,WB{3,CSWPR{{SET -PRINT IF NON-ZERO{27635
*
*      CHECK FOR TERMINAL
*
{{ANB{4,BITS8{8,WC{{SEE IF TERMINAL TO BE ACTIVATED{27639
{{BNZ{8,WC{6,PRPA8{{JUMP IF TERMINAL REQUIRED{27640
{{BZE{3,INITR{6,PRPA9{{JUMP IF NO TERMINAL TO DETACH{27641
{{MOV{21,=V$TER{7,XL{{PTR TO /TERMINAL/{27642
{{JSR{6,GTNVR{{{GET VRBLK POINTER{27643
{{PPM{{{{CANT FAIL{27644
{{MOV{21,=NULLS{13,VRVAL(XR){{CLEAR VALUE OF TERMINAL{27645
{{JSR{6,SETVR{{{REMOVE ASSOCIATION{27646
{{BRN{6,PRPA9{{{RETURN{27647
*
*      ASSOCIATE TERMINAL
*
{PRPA8{MNZ{3,INITR{{{NOTE TERMINAL ASSOCIATED{27651
{{BZE{3,DNAMB{6,PRPA9{{CANT IF MEMORY NOT ORGANISED{27652
{{MOV{21,=V$TER{7,XL{{POINT TO TERMINAL STRING{27653
{{MOV{18,=TRTOU{8,WB{{OUTPUT TRACE TYPE{27654
{{JSR{6,INOUT{{{ATTACH OUTPUT TRBLK TO VRBLK{27655
{{MOV{7,XR{11,-(XS){{STACK TRBLK PTR{27656
{{MOV{21,=V$TER{7,XL{{POINT TO TERMINAL STRING{27657
{{MOV{18,=TRTIN{8,WB{{INPUT TRACE TYPE{27658
{{JSR{6,INOUT{{{ATTACH INPUT TRACE BLK{27659
{{MOV{10,(XS)+{13,VRVAL(XR){{ADD OUTPUT TRBLK TO CHAIN{27660
*
*      RETURN POINT
*
{PRPA9{EXI{{{{RETURN{27664
{{ENP{{{{END PROCEDURE PRPAR{27665
{{EJC{{{{{27666
*
*      PRTCH -- PRINT A CHARACTER
*
*      PRTCH IS USED TO PRINT A SINGLE CHARACTER
*
*      (WA)                  CHARACTER TO BE PRINTED
*      JSR  PRTCH            CALL TO PRINT CHARACTER
*
{PRTCH{PRC{25,E{1,0{{ENTRY POINT{27675
{{MOV{7,XR{11,-(XS){{SAVE XR{27676
{{BNE{3,PROFS{3,PRLEN{6,PRCH1{JUMP IF ROOM IN BUFFER{27677
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{27678
*
*      HERE AFTER MAKING SURE WE HAVE ROOM
*
{PRCH1{MOV{3,PRBUF{7,XR{{POINT TO PRINT BUFFER{27682
{{PSC{7,XR{3,PROFS{{POINT TO NEXT CHARACTER LOCATION{27683
{{SCH{8,WA{9,(XR){{STORE NEW CHARACTER{27684
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{27685
{{ICV{3,PROFS{{{BUMP POINTER{27686
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27687
{{EXI{{{{RETURN TO PRTCH CALLER{27688
{{ENP{{{{END PROCEDURE PRTCH{27689
{{EJC{{{{{27690
*
*      PRTIC -- PRINT TO INTERACTIVE CHANNEL
*
*      PRTIC IS CALLED TO PRINT THE CONTENTS OF THE STANDARD
*      PRINT BUFFER TO THE INTERACTIVE CHANNEL. IT IS ONLY
*      CALLED AFTER PRTST HAS SET UP THE STRING FOR PRINTING.
*      IT DOES NOT CLEAR THE BUFFER.
*
*      JSR  PRTIC            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTIC{PRC{25,E{1,0{{ENTRY POINT{27702
{{MOV{7,XR{11,-(XS){{SAVE XR{27703
{{MOV{3,PRBUF{7,XR{{POINT TO BUFFER{27704
{{MOV{3,PROFS{8,WA{{NO OF CHARS{27705
{{JSR{6,SYSPI{{{PRINT{27706
{{PPM{6,PRTC2{{{FAIL RETURN{27707
*
*      RETURN
*
{PRTC1{MOV{10,(XS)+{7,XR{{RESTORE XR{27711
{{EXI{{{{RETURN{27712
*
*      ERROR OCCURED
*
{PRTC2{ZER{3,ERICH{{{PREVENT LOOPING{27716
{{ERB{1,252{26,Error on printing to interactive channel{{{27717
{{BRN{6,PRTC1{{{RETURN{27718
{{ENP{{{{PROCEDURE PRTIC{27719
{{EJC{{{{{27720
*
*      PRTIS -- PRINT TO INTERACTIVE AND STANDARD PRINTER
*
*      PRTIS PUTS A LINE FROM THE PRINT BUFFER ONTO THE
*      INTERACTIVE CHANNEL (IF ANY) AND THE STANDARD PRINTER.
*      IT ALWAYS PRINTS TO THE STANDARD PRINTER BUT DOES
*      NOT DUPLICATE LINES IF THE STANDARD PRINTER IS
*      INTERACTIVE.  IT CLEARS DOWN THE PRINT BUFFER.
*
*      JSR  PRTIS            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTIS{PRC{25,E{1,0{{ENTRY POINT{27733
{{BNZ{3,PRICH{6,PRTS1{{JUMP IF STANDARD PRINTER IS INT.CH.{27734
{{BZE{3,ERICH{6,PRTS1{{SKIP IF NOT DOING INT. ERROR REPS.{27735
{{JSR{6,PRTIC{{{PRINT TO INTERACTIVE CHANNEL{27736
*
*      MERGE AND EXIT
*
{PRTS1{JSR{6,PRTNL{{{PRINT TO STANDARD PRINTER{27740
{{EXI{{{{RETURN{27741
{{ENP{{{{END PROCEDURE PRTIS{27742
{{EJC{{{{{27743
*
*      PRTIN -- PRINT AN INTEGER
*
*      PRTIN PRINTS THE INTEGER VALUE WHICH IS IN THE INTEGER
*      ACCUMULATOR. BLOCKS BUILT IN DYNAMIC STORAGE
*      DURING THIS PROCESS ARE IMMEDIATELY DELETED.
*
*      (IA)                  INTEGER VALUE TO BE PRINTED
*      JSR  PRTIN            CALL TO PRINT INTEGER
*      (IA,RA)               DESTROYED
*
{PRTIN{PRC{25,E{1,0{{ENTRY POINT{27755
{{MOV{7,XR{11,-(XS){{SAVE XR{27756
{{JSR{6,ICBLD{{{BUILD INTEGER BLOCK{27757
{{BLO{7,XR{3,DNAMB{6,PRTI1{JUMP IF ICBLK BELOW DYNAMIC{27758
{{BHI{7,XR{3,DNAMP{6,PRTI1{JUMP IF ABOVE DYNAMIC{27759
{{MOV{7,XR{3,DNAMP{{IMMEDIATELY DELETE IT{27760
*
*      DELETE ICBLK FROM DYNAMIC STORE
*
{PRTI1{MOV{7,XR{11,-(XS){{STACK PTR FOR GTSTG{27764
{{JSR{6,GTSTG{{{CONVERT TO STRING{27765
{{PPM{{{{CONVERT ERROR IS IMPOSSIBLE{27766
{{MOV{7,XR{3,DNAMP{{RESET POINTER TO DELETE SCBLK{27767
{{JSR{6,PRTST{{{PRINT INTEGER STRING{27768
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27769
{{EXI{{{{RETURN TO PRTIN CALLER{27770
{{ENP{{{{END PROCEDURE PRTIN{27771
{{EJC{{{{{27772
*
*      PRTMI -- PRINT MESSAGE AND INTEGER
*
*      PRTMI IS USED TO PRINT MESSAGES TOGETHER WITH AN INTEGER
*      VALUE STARTING IN COLUMN 15 (USED BY THE ROUTINES AT
*      THE END OF COMPILATION).
*
*      JSR  PRTMI            CALL TO PRINT MESSAGE AND INTEGER
*
{PRTMI{PRC{25,E{1,0{{ENTRY POINT{27782
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{27783
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{27784
{{JSR{6,PRTIN{{{PRINT INTEGER{27785
{{JSR{6,PRTNL{{{PRINT LINE{27786
{{EXI{{{{RETURN TO PRTMI CALLER{27787
{{ENP{{{{END PROCEDURE PRTMI{27788
{{EJC{{{{{27789
*
*      PRTMM -- PRINT MEMORY USED AND AVAILABLE
*
*      PRTMM IS USED TO PROVIDE MEMORY USAGE INFORMATION IN
*      BOTH THE END-OF-COMPILE AND END-OF-RUN STATISTICS.
*
*      JSR  PRTMM            CALL TO PRINT MEMORY STATS
*
{PRTMM{PRC{25,E{1,0{{{27798
{{MOV{3,DNAMP{8,WA{{NEXT AVAILABLE LOC{27799
{{SUB{3,STATB{8,WA{{MINUS START{27800
{{MTI{8,WA{{{CONVERT TO INTEGER{27805
{{MOV{21,=ENCM1{7,XR{{POINT TO /MEMORY USED (WORDS)/{27806
{{JSR{6,PRTMI{{{PRINT MESSAGE{27807
{{MOV{3,DNAME{8,WA{{END OF MEMORY{27808
{{SUB{3,DNAMP{8,WA{{MINUS NEXT AVAILABLE LOC{27809
{{MTI{8,WA{{{CONVERT TO INTEGER{27814
{{MOV{21,=ENCM2{7,XR{{POINT TO /MEMORY AVAILABLE (WORDS)/{27815
{{JSR{6,PRTMI{{{PRINT LINE{27816
{{EXI{{{{RETURN TO PRTMM CALLER{27817
{{ENP{{{{END OF PROCEDURE PRTMM{27818
{{EJC{{{{{27819
*
*      PRTMX  -- AS PRTMI WITH EXTRA COPY TO INTERACTIVE CHAN.
*
*      JSR  PRTMX            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTMX{PRC{25,E{1,0{{ENTRY POINT{27826
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{27827
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{27828
{{JSR{6,PRTIN{{{PRINT INTEGER{27829
{{JSR{6,PRTIS{{{PRINT LINE{27830
{{EXI{{{{RETURN{27831
{{ENP{{{{END PROCEDURE PRTMX{27832
{{EJC{{{{{27833
*
*      PRTNL -- PRINT NEW LINE (END PRINT LINE)
*
*      PRTNL PRINTS THE CONTENTS OF THE PRINT BUFFER, RESETS
*      THE BUFFER TO ALL BLANKS AND RESETS THE PRINT POINTER.
*
*      JSR  PRTNL            CALL TO PRINT LINE
*
{PRTNL{PRC{25,R{1,0{{ENTRY POINT{27842
{{BNZ{3,HEADP{6,PRNL0{{WERE HEADERS PRINTED{27843
{{JSR{6,PRTPS{{{NO - PRINT THEM{27844
*
*      CALL SYSPR
*
{PRNL0{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{27848
{{MOV{8,WA{3,PRTSA{{SAVE WA{27849
{{MOV{8,WB{3,PRTSB{{SAVE WB{27850
{{MOV{3,PRBUF{7,XR{{LOAD POINTER TO BUFFER{27851
{{MOV{3,PROFS{8,WA{{LOAD NUMBER OF CHARS IN BUFFER{27852
{{JSR{6,SYSPR{{{CALL SYSTEM PRINT ROUTINE{27853
{{PPM{6,PRNL2{{{JUMP IF FAILED{27854
{{LCT{8,WA{3,PRLNW{{LOAD LENGTH OF BUFFER IN WORDS{27855
{{ADD{19,*SCHAR{7,XR{{POINT TO CHARS OF BUFFER{27856
{{MOV{4,NULLW{8,WB{{GET WORD OF BLANKS{27857
*
*      LOOP TO BLANK BUFFER
*
{PRNL1{MOV{8,WB{10,(XR)+{{STORE WORD OF BLANKS, BUMP PTR{27861
{{BCT{8,WA{6,PRNL1{{LOOP TILL ALL BLANKED{27862
*
*      EXIT POINT
*
{{MOV{3,PRTSB{8,WB{{RESTORE WB{27866
{{MOV{3,PRTSA{8,WA{{RESTORE WA{27867
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27868
{{ZER{3,PROFS{{{RESET PRINT BUFFER POINTER{27869
{{EXI{{{{RETURN TO PRTNL CALLER{27870
*
*      FILE FULL OR NO OUTPUT FILE FOR LOAD MODULE
*
{PRNL2{BNZ{3,PRTEF{6,PRNL3{{JUMP IF NOT FIRST TIME{27874
{{MNZ{3,PRTEF{{{MARK FIRST OCCURRENCE{27875
{{ERB{1,253{26,Print limit exceeded on standard output channel{{{27876
*
*      STOP AT ONCE
*
{PRNL3{MOV{18,=NINI8{8,WB{{ENDING CODE{27880
{{MOV{3,KVSTN{8,WA{{STATEMENT NUMBER{27881
{{MOV{3,R$FCB{7,XL{{GET FCBLK CHAIN HEAD{27882
{{JSR{6,SYSEJ{{{STOP{27883
{{ENP{{{{END PROCEDURE PRTNL{27884
{{EJC{{{{{27885
*
*      PRTNM -- PRINT VARIABLE NAME
*
*      PRTNM IS USED TO PRINT A CHARACTER REPRESENTATION OF THE
*      NAME OF A VARIABLE (NOT A VALUE OF DATATYPE NAME)
*      NAMES OF PSEUDO-VARIABLES MAY NOT BE PASSED TO PRTNM.
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNM            CALL TO PRINT NAME
*      (WB,WC,RA)            DESTROYED
*
{PRTNM{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE, SEE PRTVL){27898
{{MOV{8,WA{11,-(XS){{SAVE WA (OFFSET IS COLLECTABLE){27899
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{27900
{{MOV{7,XL{11,-(XS){{SAVE NAME BASE{27901
{{BHI{7,XL{3,STATE{6,PRN02{JUMP IF NOT NATURAL VARIABLE{27902
*
*      HERE FOR NATURAL VARIABLE NAME, RECOGNIZED BY THE FACT
*      THAT THE NAME BASE POINTS INTO THE STATIC AREA.
*
{{MOV{7,XL{7,XR{{POINT TO VRBLK{27907
{{JSR{6,PRTVN{{{PRINT NAME OF VARIABLE{27908
*
*      COMMON EXIT POINT
*
{PRN01{MOV{10,(XS)+{7,XL{{RESTORE NAME BASE{27912
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY VALUE OF XR{27913
{{MOV{10,(XS)+{8,WA{{RESTORE WA{27914
{{EXI{{{{RETURN TO PRTNM CALLER{27915
*
*      HERE FOR CASE OF NON-NATURAL VARIABLE
*
{PRN02{MOV{8,WA{8,WB{{COPY NAME OFFSET{27919
{{BNE{9,(XL){22,=B$PDT{6,PRN03{JUMP IF ARRAY OR TABLE{27920
*
*      FOR PROGRAM DEFINED DATATYPE, PRT FLD NAME, LEFT PAREN
*
{{MOV{13,PDDFP(XL){7,XR{{LOAD POINTER TO DFBLK{27924
{{ADD{8,WA{7,XR{{ADD NAME OFFSET{27925
{{MOV{13,PDFOF(XR){7,XR{{LOAD VRBLK POINTER FOR FIELD{27926
{{JSR{6,PRTVN{{{PRINT FIELD NAME{27927
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{27928
{{JSR{6,PRTCH{{{PRINT CHARACTER{27929
{{EJC{{{{{27930
*
*      PRTNM (CONTINUED)
*
*      NOW WE PRINT AN IDENTIFYING NAME FOR THE OBJECT IF ONE
*      CAN BE FOUND. THE FOLLOWING CODE SEARCHES FOR A NATURAL
*      VARIABLE WHICH CONTAINS THIS OBJECT AS VALUE. IF SUCH A
*      VARIABLE IS FOUND, ITS NAME IS PRINTED, ELSE THE VALUE
*      OF THE OBJECT (AS PRINTED BY PRTVL) IS USED INSTEAD.
*
*      FIRST WE POINT TO THE PARENT TBBLK IF THIS IS THE CASE OF
*      A TABLE ELEMENT. TO DO THIS, CHASE DOWN THE TRNXT CHAIN.
*
{PRN03{BNE{9,(XL){22,=B$TET{6,PRN04{JUMP IF WE GOT THERE (OR NOT TE){27943
{{MOV{13,TENXT(XL){7,XL{{ELSE MOVE OUT ON CHAIN{27944
{{BRN{6,PRN03{{{AND LOOP BACK{27945
*
*      NOW WE ARE READY FOR THE SEARCH. TO SPEED THINGS UP IN
*      THE CASE OF CALLS FROM DUMP WHERE THE SAME NAME BASE
*      WILL OCCUR REPEATEDLY WHILE DUMPING AN ARRAY OR TABLE,
*      WE REMEMBER THE LAST VRBLK POINTER FOUND IN PRNMV. SO
*      FIRST CHECK TO SEE IF WE HAVE THIS ONE AGAIN.
*
{PRN04{MOV{3,PRNMV{7,XR{{POINT TO VRBLK WE FOUND LAST TIME{27953
{{MOV{3,HSHTB{8,WA{{POINT TO HASH TABLE IN CASE NOT{27954
{{BRN{6,PRN07{{{JUMP INTO SEARCH FOR SPECIAL CHECK{27955
*
*      LOOP THROUGH HASH SLOTS
*
{PRN05{MOV{8,WA{7,XR{{COPY SLOT POINTER{27959
{{ICA{8,WA{{{BUMP SLOT POINTER{27960
{{SUB{19,*VRNXT{7,XR{{INTRODUCE STANDARD VRBLK OFFSET{27961
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{PRN06{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON HASH CHAIN{27965
*
*      MERGE HERE FIRST TIME TO CHECK BLOCK WE FOUND LAST TIME
*
{PRN07{MOV{7,XR{8,WC{{COPY VRBLK POINTER{27969
{{BZE{8,WC{6,PRN09{{JUMP IF CHAIN END (OR PRNMV ZERO){27970
{{EJC{{{{{27971
*
*      PRTNM (CONTINUED)
*
*      LOOP TO FIND VALUE (CHASE DOWN POSSIBLE TRBLK CHAIN)
*
{PRN08{MOV{13,VRVAL(XR){7,XR{{LOAD VALUE{27977
{{BEQ{9,(XR){22,=B$TRT{6,PRN08{LOOP IF THAT WAS A TRBLK{27978
*
*      NOW WE HAVE THE VALUE, IS THIS THE BLOCK WE WANT
*
{{BEQ{7,XR{7,XL{6,PRN10{JUMP IF THIS MATCHES THE NAME BASE{27982
{{MOV{8,WC{7,XR{{ELSE POINT BACK TO THAT VRBLK{27983
{{BRN{6,PRN06{{{AND LOOP BACK{27984
*
*      HERE TO MOVE TO NEXT HASH SLOT
*
{PRN09{BLT{8,WA{3,HSHTE{6,PRN05{LOOP BACK IF MORE TO GO{27988
{{MOV{7,XL{7,XR{{ELSE NOT FOUND, COPY VALUE POINTER{27989
{{JSR{6,PRTVL{{{PRINT VALUE{27990
{{BRN{6,PRN11{{{AND MERGE AHEAD{27991
*
*      HERE WHEN WE FIND A MATCHING ENTRY
*
{PRN10{MOV{8,WC{7,XR{{COPY VRBLK POINTER{27995
{{MOV{7,XR{3,PRNMV{{SAVE FOR NEXT TIME IN{27996
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{27997
*
*      MERGE HERE IF NO ENTRY FOUND
*
{PRN11{MOV{9,(XL){8,WC{{LOAD FIRST WORD OF NAME BASE{28001
{{BNE{8,WC{22,=B$PDT{6,PRN13{JUMP IF NOT PROGRAM DEFINED{28002
*
*      FOR PROGRAM DEFINED DATATYPE, ADD RIGHT PAREN AND EXIT
*
{{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN, MERGE{28006
*
*      MERGE HERE TO PRINT FINAL RIGHT PAREN OR BRACKET
*
{PRN12{JSR{6,PRTCH{{{PRINT FINAL CHARACTER{28010
{{MOV{8,WB{8,WA{{RESTORE NAME OFFSET{28011
{{BRN{6,PRN01{{{MERGE BACK TO EXIT{28012
{{EJC{{{{{28013
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY OR TABLE
*
{PRN13{MOV{18,=CH$BB{8,WA{{LOAD LEFT BRACKET{28019
{{JSR{6,PRTCH{{{AND PRINT IT{28020
{{MOV{9,(XS){7,XL{{RESTORE BLOCK POINTER{28021
{{MOV{9,(XL){8,WC{{LOAD TYPE WORD AGAIN{28022
{{BNE{8,WC{22,=B$TET{6,PRN15{JUMP IF NOT TABLE{28023
*
*      HERE FOR TABLE, PRINT SUBSCRIPT VALUE
*
{{MOV{13,TESUB(XL){7,XR{{LOAD SUBSCRIPT VALUE{28027
{{MOV{8,WB{7,XL{{SAVE NAME OFFSET{28028
{{JSR{6,PRTVL{{{PRINT SUBSCRIPT VALUE{28029
{{MOV{7,XL{8,WB{{RESTORE NAME OFFSET{28030
*
*      MERGE HERE FROM ARRAY CASE TO PRINT RIGHT BRACKET
*
{PRN14{MOV{18,=CH$RB{8,WA{{LOAD RIGHT BRACKET{28034
{{BRN{6,PRN12{{{MERGE BACK TO PRINT IT{28035
*
*      HERE FOR ARRAY OR VECTOR, TO PRINT SUBSCRIPT(S)
*
{PRN15{MOV{8,WB{8,WA{{COPY NAME OFFSET{28039
{{BTW{8,WA{{{CONVERT TO WORDS{28040
{{BEQ{8,WC{22,=B$ART{6,PRN16{JUMP IF ARBLK{28041
*
*      HERE FOR VECTOR
*
{{SUB{18,=VCVLB{8,WA{{ADJUST FOR STANDARD FIELDS{28045
{{MTI{8,WA{{{MOVE TO INTEGER ACCUM{28046
{{JSR{6,PRTIN{{{PRINT LINEAR SUBSCRIPT{28047
{{BRN{6,PRN14{{{MERGE BACK FOR RIGHT BRACKET{28048
{{EJC{{{{{28049
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY. FIRST CALCULATE ABSOLUTE SUBSCRIPT
*      OFFSETS BY SUCCESSIVE DIVISIONS BY THE DIMENSION VALUES.
*      THIS MUST BE DONE RIGHT TO LEFT SINCE THE ELEMENTS ARE
*      STORED ROW-WISE. THE SUBSCRIPTS ARE STACKED AS INTEGERS.
*
{PRN16{MOV{13,AROFS(XL){8,WC{{LOAD LENGTH OF BOUNDS INFO{28058
{{ICA{8,WC{{{ADJUST FOR ARPRO FIELD{28059
{{BTW{8,WC{{{CONVERT TO WORDS{28060
{{SUB{8,WC{8,WA{{GET LINEAR ZERO-ORIGIN SUBSCRIPT{28061
{{MTI{8,WA{{{GET INTEGER VALUE{28062
{{LCT{8,WA{13,ARNDM(XL){{SET NUM OF DIMENSIONS AS LOOP COUNT{28063
{{ADD{13,AROFS(XL){7,XL{{POINT PAST BOUNDS INFORMATION{28064
{{SUB{19,*ARLBD{7,XL{{SET OK OFFSET FOR PROPER PTR LATER{28065
*
*      LOOP TO STACK SUBSCRIPT OFFSETS
*
{PRN17{SUB{19,*ARDMS{7,XL{{POINT TO NEXT SET OF BOUNDS{28069
{{STI{3,PRNSI{{{SAVE CURRENT OFFSET{28070
{{RMI{13,ARDIM(XL){{{GET REMAINDER ON DIVIDING BY DIMENS{28071
{{MFI{11,-(XS){{{STORE ON STACK (ONE WORD){28072
{{LDI{3,PRNSI{{{RELOAD ARGUMENT{28073
{{DVI{13,ARDIM(XL){{{DIVIDE TO GET QUOTIENT{28074
{{BCT{8,WA{6,PRN17{{LOOP TILL ALL STACKED{28075
{{ZER{7,XR{{{SET OFFSET TO FIRST SET OF BOUNDS{28076
{{LCT{8,WB{13,ARNDM(XL){{LOAD COUNT OF DIMS TO CONTROL LOOP{28077
{{BRN{6,PRN19{{{JUMP INTO PRINT LOOP{28078
*
*      LOOP TO PRINT SUBSCRIPTS FROM STACK ADJUSTING BY ADDING
*      THE APPROPRIATE LOW BOUND VALUE FROM THE ARBLK
*
{PRN18{MOV{18,=CH$CM{8,WA{{LOAD A COMMA{28083
{{JSR{6,PRTCH{{{PRINT IT{28084
*
*      MERGE HERE FIRST TIME IN (NO COMMA REQUIRED)
*
{PRN19{MTI{10,(XS)+{{{LOAD SUBSCRIPT OFFSET AS INTEGER{28088
{{ADD{7,XR{7,XL{{POINT TO CURRENT LBD{28089
{{ADI{13,ARLBD(XL){{{ADD LBD TO GET SIGNED SUBSCRIPT{28090
{{SUB{7,XR{7,XL{{POINT BACK TO START OF ARBLK{28091
{{JSR{6,PRTIN{{{PRINT SUBSCRIPT{28092
{{ADD{19,*ARDMS{7,XR{{BUMP OFFSET TO NEXT BOUNDS{28093
{{BCT{8,WB{6,PRN18{{LOOP BACK TILL ALL PRINTED{28094
{{BRN{6,PRN14{{{MERGE BACK TO PRINT RIGHT BRACKET{28095
{{ENP{{{{END PROCEDURE PRTNM{28096
{{EJC{{{{{28097
*
*      PRTNV -- PRINT NAME VALUE
*
*      PRTNV IS USED BY THE TRACE AND DUMP ROUTINES TO PRINT
*      A LINE OF THE FORM
*
*      NAME = VALUE
*
*      NOTE THAT THE NAME INVOLVED CAN NEVER BE A PSEUDO-VAR
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNV            CALL TO PRINT NAME = VALUE
*      (WB,WC,RA)            DESTROYED
*
{PRTNV{PRC{25,E{1,0{{ENTRY POINT{28113
{{JSR{6,PRTNM{{{PRINT ARGUMENT NAME{28114
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{28115
{{MOV{8,WA{11,-(XS){{SAVE NAME OFFSET (COLLECTABLE){28116
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK EQUAL BLANK{28117
{{JSR{6,PRTST{{{PRINT IT{28118
{{MOV{7,XL{7,XR{{COPY NAME BASE{28119
{{ADD{8,WA{7,XR{{POINT TO VALUE{28120
{{MOV{9,(XR){7,XR{{LOAD VALUE POINTER{28121
{{JSR{6,PRTVL{{{PRINT VALUE{28122
{{JSR{6,PRTNL{{{TERMINATE LINE{28123
{{MOV{10,(XS)+{8,WA{{RESTORE NAME OFFSET{28124
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{28125
{{EXI{{{{RETURN TO CALLER{28126
{{ENP{{{{END PROCEDURE PRTNV{28127
{{EJC{{{{{28128
*
*      PRTPG  -- PRINT A PAGE THROW
*
*      PRINTS A PAGE THROW OR A FEW BLANK LINES ON THE STANDARD
*      LISTING CHANNEL DEPENDING ON THE LISTING OPTIONS CHOSEN.
*
*      JSR  PRTPG            CALL FOR PAGE EJECT
*
{PRTPG{PRC{25,E{1,0{{ENTRY POINT{28137
{{BEQ{3,STAGE{18,=STGXT{6,PRP01{JUMP IF EXECUTION TIME{28138
{{BZE{3,LSTLC{6,PRP06{{RETURN IF TOP OF PAGE ALREADY{28139
{{ZER{3,LSTLC{{{CLEAR LINE COUNT{28140
*
*      CHECK TYPE OF LISTING
*
{PRP01{MOV{7,XR{11,-(XS){{PRESERVE XR{28144
{{BNZ{3,PRSTD{6,PRP02{{EJECT IF FLAG SET{28145
{{BNZ{3,PRICH{6,PRP03{{JUMP IF INTERACTIVE LISTING CHANNEL{28146
{{BZE{3,PRECL{6,PRP03{{JUMP IF COMPACT LISTING{28147
*
*      PERFORM AN EJECT
*
{PRP02{JSR{6,SYSEP{{{EJECT{28151
{{BRN{6,PRP04{{{MERGE{28152
*
*      COMPACT OR INTERACTIVE CHANNEL LISTING. CANT PRINT
*      BLANKS UNTIL CHECK MADE FOR HEADERS PRINTED AND FLAG SET.
*
*
{PRP03{MOV{3,HEADP{7,XR{{REMEMBER HEADP{28158
{{MNZ{3,HEADP{{{SET TO AVOID REPEATED PRTPG CALLS{28159
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28160
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28161
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28162
{{MOV{18,=NUM03{3,LSTLC{{COUNT BLANK LINES{28163
{{MOV{7,XR{3,HEADP{{RESTORE HEADER FLAG{28164
{{EJC{{{{{28165
*
*      PRPTG (CONTINUED)
*
*      PRINT THE HEADING
*
{PRP04{BNZ{3,HEADP{6,PRP05{{JUMP IF HEADER LISTED{28171
{{MNZ{3,HEADP{{{MARK HEADERS PRINTED{28172
{{MOV{7,XL{11,-(XS){{KEEP XL{28173
{{MOV{21,=HEADR{7,XR{{POINT TO LISTING HEADER{28174
{{JSR{6,PRTST{{{PLACE IT{28175
{{JSR{6,SYSID{{{GET SYSTEM IDENTIFICATION{28176
{{JSR{6,PRTST{{{APPEND EXTRA CHARS{28177
{{JSR{6,PRTNL{{{PRINT IT{28178
{{MOV{7,XL{7,XR{{EXTRA HEADER LINE{28179
{{JSR{6,PRTST{{{PLACE IT{28180
{{JSR{6,PRTNL{{{PRINT IT{28181
{{JSR{6,PRTNL{{{PRINT A BLANK{28182
{{JSR{6,PRTNL{{{AND ANOTHER{28183
{{ADD{18,=NUM04{3,LSTLC{{FOUR HEADER LINES PRINTED{28184
{{MOV{10,(XS)+{7,XL{{RESTORE XL{28185
*
*      MERGE IF HEADER NOT PRINTED
*
{PRP05{MOV{10,(XS)+{7,XR{{RESTORE XR{28189
*
*      RETURN
*
{PRP06{EXI{{{{RETURN{28193
{{ENP{{{{END PROCEDURE PRTPG{28194
{{EJC{{{{{28195
*
*      PRTPS - PRINT PAGE WITH TEST FOR STANDARD LISTING OPTION
*
*      IF THE STANDARD LISTING OPTION IS SELECTED, INSIST THAT
*      AN EJECT BE DONE
*
*      JSR  PRTPS            CALL FOR EJECT
*
{PRTPS{PRC{25,E{1,0{{ENTRY POINT{28204
{{MOV{3,PRSTO{3,PRSTD{{COPY OPTION FLAG{28205
{{JSR{6,PRTPG{{{PRINT PAGE{28206
{{ZER{3,PRSTD{{{CLEAR FLAG{28207
{{EXI{{{{RETURN{28208
{{ENP{{{{END PROCEDURE PRTPS{28209
{{EJC{{{{{28210
*
*      PRTSN -- PRINT STATEMENT NUMBER
*
*      PRTSN IS USED TO INITIATE A PRINT TRACE LINE BY PRINTING
*      ASTERISKS AND THE CURRENT STATEMENT NUMBER. THE ACTUAL
*      FORMAT OF THE OUTPUT GENERATED IS.
*
*      ***NNNNN**** III.....IIII
*
*      NNNNN IS THE STATEMENT NUMBER WITH LEADING ZEROS REPLACED
*      BY ASTERISKS (E.G. *******9****)
*
*      III...III REPRESENTS A VARIABLE LENGTH OUTPUT CONSISTING
*      OF A NUMBER OF LETTER I CHARACTERS EQUAL TO FNCLEVEL.
*
*      JSR  PRTSN            CALL TO PRINT STATEMENT NUMBER
*      (WC)                  DESTROYED
*
{PRTSN{PRC{25,E{1,0{{ENTRY POINT{28229
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{28230
{{MOV{8,WA{3,PRSNA{{SAVE ENTRY WA{28231
{{MOV{21,=TMASB{7,XR{{POINT TO ASTERISKS{28232
{{JSR{6,PRTST{{{PRINT ASTERISKS{28233
{{MOV{18,=NUM04{3,PROFS{{POINT INTO MIDDLE OF ASTERISKS{28234
{{MTI{3,KVSTN{{{LOAD STATEMENT NUMBER AS INTEGER{28235
{{JSR{6,PRTIN{{{PRINT INTEGER STATEMENT NUMBER{28236
{{MOV{18,=PRSNF{3,PROFS{{POINT PAST ASTERISKS PLUS BLANK{28237
{{MOV{3,KVFNC{7,XR{{GET FNCLEVEL{28238
{{MOV{18,=CH$LI{8,WA{{SET LETTER I{28239
*
*      LOOP TO GENERATE LETTER I FNCLEVEL TIMES
*
{PRSN1{BZE{7,XR{6,PRSN2{{JUMP IF ALL SET{28243
{{JSR{6,PRTCH{{{ELSE PRINT AN I{28244
{{DCV{7,XR{{{DECREMENT COUNTER{28245
{{BRN{6,PRSN1{{{LOOP BACK{28246
*
*      MERGE WITH ALL LETTER I CHARACTERS GENERATED
*
{PRSN2{MOV{18,=CH$BL{8,WA{{GET BLANK{28250
{{JSR{6,PRTCH{{{PRINT BLANK{28251
{{MOV{3,PRSNA{8,WA{{RESTORE ENTRY WA{28252
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{28253
{{EXI{{{{RETURN TO PRTSN CALLER{28254
{{ENP{{{{END PROCEDURE PRTSN{28255
{{EJC{{{{{28256
*
*      PRTST -- PRINT STRING
*
*      PRTST PLACES A STRING OF CHARACTERS IN THE PRINT BUFFER
*
*      SEE PRTNL FOR GLOBAL LOCATIONS USED
*
*      NOTE THAT THE FIRST WORD OF THE BLOCK (NORMALLY B$SCL)
*      IS NOT USED AND NEED NOT BE SET CORRECTLY (SEE PRTVN)
*
*      (XR)                  STRING TO BE PRINTED
*      JSR  PRTST            CALL TO PRINT STRING
*      (PROFS)               UPDATED PAST CHARS PLACED
*
{PRTST{PRC{25,R{1,0{{ENTRY POINT{28271
{{BNZ{3,HEADP{6,PRST0{{WERE HEADERS PRINTED{28272
{{JSR{6,PRTPS{{{NO - PRINT THEM{28273
*
*      CALL SYSPR
*
{PRST0{MOV{8,WA{3,PRSVA{{SAVE WA{28277
{{MOV{8,WB{3,PRSVB{{SAVE WB{28278
{{ZER{8,WB{{{SET CHARS PRINTED COUNT TO ZERO{28279
*
*      LOOP TO PRINT SUCCESSIVE LINES FOR LONG STRING
*
{PRST1{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{28283
{{SUB{8,WB{8,WA{{SUBTRACT COUNT OF CHARS ALREADY OUT{28284
{{BZE{8,WA{6,PRST4{{JUMP TO EXIT IF NONE LEFT{28285
{{MOV{7,XL{11,-(XS){{ELSE STACK ENTRY XL{28286
{{MOV{7,XR{11,-(XS){{SAVE ARGUMENT{28287
{{MOV{7,XR{7,XL{{COPY FOR EVENTUAL MOVE{28288
{{MOV{3,PRLEN{7,XR{{LOAD PRINT BUFFER LENGTH{28289
{{SUB{3,PROFS{7,XR{{GET CHARS LEFT IN PRINT BUFFER{28290
{{BNZ{7,XR{6,PRST2{{SKIP IF ROOM LEFT ON THIS LINE{28291
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{28292
{{MOV{3,PRLEN{7,XR{{AND SET FULL WIDTH AVAILABLE{28293
{{EJC{{{{{28294
*
*      PRTST (CONTINUED)
*
*      HERE WITH CHARS TO PRINT AND SOME ROOM IN BUFFER
*
{PRST2{BLO{8,WA{7,XR{6,PRST3{JUMP IF ROOM FOR REST OF STRING{28300
{{MOV{7,XR{8,WA{{ELSE SET TO FILL LINE{28301
*
*      MERGE HERE WITH CHARACTER COUNT IN WA
*
{PRST3{MOV{3,PRBUF{7,XR{{POINT TO PRINT BUFFER{28305
{{PLC{7,XL{8,WB{{POINT TO LOCATION IN STRING{28306
{{PSC{7,XR{3,PROFS{{POINT TO LOCATION IN BUFFER{28307
{{ADD{8,WA{8,WB{{BUMP STRING CHARS COUNT{28308
{{ADD{8,WA{3,PROFS{{BUMP BUFFER POINTER{28309
{{MOV{8,WB{3,PRSVC{{PRESERVE CHAR COUNTER{28310
{{MVC{{{{MOVE CHARACTERS TO BUFFER{28311
{{MOV{3,PRSVC{8,WB{{RECOVER CHAR COUNTER{28312
{{MOV{10,(XS)+{7,XR{{RESTORE ARGUMENT POINTER{28313
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{28314
{{BRN{6,PRST1{{{LOOP BACK TO TEST FOR MORE{28315
*
*      HERE TO EXIT AFTER PRINTING STRING
*
{PRST4{MOV{3,PRSVB{8,WB{{RESTORE ENTRY WB{28319
{{MOV{3,PRSVA{8,WA{{RESTORE ENTRY WA{28320
{{EXI{{{{RETURN TO PRTST CALLER{28321
{{ENP{{{{END PROCEDURE PRTST{28322
{{EJC{{{{{28323
*
*      PRTTR -- PRINT TO TERMINAL
*
*      CALLED TO PRINT CONTENTS OF STANDARD PRINT BUFFER TO
*      ONLINE TERMINAL. CLEARS BUFFER DOWN AND RESETS PROFS.
*
*      JSR  PRTTR            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTTR{PRC{25,E{1,0{{ENTRY POINT{28333
{{MOV{7,XR{11,-(XS){{SAVE XR{28334
{{JSR{6,PRTIC{{{PRINT BUFFER CONTENTS{28335
{{MOV{3,PRBUF{7,XR{{POINT TO PRINT BFR TO CLEAR IT{28336
{{LCT{8,WA{3,PRLNW{{GET BUFFER LENGTH{28337
{{ADD{19,*SCHAR{7,XR{{POINT PAST SCBLK HEADER{28338
{{MOV{4,NULLW{8,WB{{GET BLANKS{28339
*
*      LOOP TO CLEAR BUFFER
*
{PRTT1{MOV{8,WB{10,(XR)+{{CLEAR A WORD{28343
{{BCT{8,WA{6,PRTT1{{LOOP{28344
{{ZER{3,PROFS{{{RESET PROFS{28345
{{MOV{10,(XS)+{7,XR{{RESTORE XR{28346
{{EXI{{{{RETURN{28347
{{ENP{{{{END PROCEDURE PRTTR{28348
{{EJC{{{{{28349
*
*      PRTVL -- PRINT A VALUE
*
*      PRTVL PLACES AN APPROPRIATE CHARACTER REPRESENTATION OF
*      A DATA VALUE IN THE PRINT BUFFER FOR DUMP/TRACE USE.
*
*      (XR)                  VALUE TO BE PRINTED
*      JSR  PRTVL            CALL TO PRINT VALUE
*      (WA,WB,WC,RA)         DESTROYED
*
{PRTVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{28360
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{28361
{{MOV{7,XR{11,-(XS){{SAVE ARGUMENT{28362
{{CHK{{{{CHECK FOR STACK OVERFLOW{28363
*
*      LOOP BACK HERE AFTER FINDING A TRAP BLOCK (TRBLK)
*
{PRV01{MOV{13,IDVAL(XR){3,PRVSI{{COPY IDVAL (IF ANY){28367
{{MOV{9,(XR){7,XL{{LOAD FIRST WORD OF BLOCK{28368
{{LEI{7,XL{{{LOAD ENTRY POINT ID{28369
{{BSW{7,XL{2,BL$$T{6,PRV02{SWITCH ON BLOCK TYPE{28370
{{IFF{2,BL$AR{6,PRV05{{ARBLK{28388
{{IFF{1,1{6,PRV02{{{28388
{{IFF{1,2{6,PRV02{{{28388
{{IFF{2,BL$IC{6,PRV08{{ICBLK{28388
{{IFF{2,BL$NM{6,PRV09{{NMBLK{28388
{{IFF{1,5{6,PRV02{{{28388
{{IFF{1,6{6,PRV02{{{28388
{{IFF{1,7{6,PRV02{{{28388
{{IFF{2,BL$RC{6,PRV08{{RCBLK{28388
{{IFF{2,BL$SC{6,PRV11{{SCBLK{28388
{{IFF{2,BL$SE{6,PRV12{{SEBLK{28388
{{IFF{2,BL$TB{6,PRV13{{TBBLK{28388
{{IFF{2,BL$VC{6,PRV13{{VCBLK{28388
{{IFF{1,13{6,PRV02{{{28388
{{IFF{1,14{6,PRV02{{{28388
{{IFF{1,15{6,PRV02{{{28388
{{IFF{2,BL$PD{6,PRV10{{PDBLK{28388
{{IFF{2,BL$TR{6,PRV04{{TRBLK{28388
{{ESW{{{{END OF SWITCH ON BLOCK TYPE{28388
*
*      HERE FOR BLOCKS FOR WHICH WE JUST PRINT DATATYPE NAME
*
{PRV02{JSR{6,DTYPE{{{GET DATATYPE NAME{28392
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28393
*
*      COMMON EXIT POINT
*
{PRV03{MOV{10,(XS)+{7,XR{{RELOAD ARGUMENT{28397
{{MOV{10,(XS)+{7,XL{{RESTORE XL{28398
{{EXI{{{{RETURN TO PRTVL CALLER{28399
*
*      HERE FOR TRBLK
*
{PRV04{MOV{13,TRVAL(XR){7,XR{{LOAD REAL VALUE{28403
{{BRN{6,PRV01{{{AND LOOP BACK{28404
{{EJC{{{{{28405
*
*      PRTVL (CONTINUED)
*
*      HERE FOR ARRAY (ARBLK)
*
*      PRINT ARRAY ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV05{MOV{7,XR{7,XL{{PRESERVE ARGUMENT{28413
{{MOV{21,=SCARR{7,XR{{POINT TO DATATYPE NAME (ARRAY){28414
{{JSR{6,PRTST{{{PRINT IT{28415
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{28416
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{28417
{{ADD{13,AROFS(XL){7,XL{{POINT TO PROTOTYPE{28418
{{MOV{9,(XL){7,XR{{LOAD PROTOTYPE{28419
{{JSR{6,PRTST{{{PRINT PROTOTYPE{28420
*
*      VCBLK, TBBLK, BCBLK MERGE HERE FOR ) BLANK NUMBER IDVAL
*
{PRV06{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN{28424
{{JSR{6,PRTCH{{{PRINT RIGHT PAREN{28425
*
*      PDBLK MERGES HERE TO PRINT BLANK NUMBER IDVAL
*
{PRV07{MOV{18,=CH$BL{8,WA{{LOAD BLANK{28429
{{JSR{6,PRTCH{{{PRINT IT{28430
{{MOV{18,=CH$NM{8,WA{{LOAD NUMBER SIGN{28431
{{JSR{6,PRTCH{{{PRINT IT{28432
{{MTI{3,PRVSI{{{GET IDVAL{28433
{{JSR{6,PRTIN{{{PRINT ID NUMBER{28434
{{BRN{6,PRV03{{{BACK TO EXIT{28435
*
*      HERE FOR INTEGER (ICBLK), REAL (RCBLK)
*
*      PRINT CHARACTER REPRESENTATION OF VALUE
*
{PRV08{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{28441
{{JSR{6,GTSTG{{{CONVERT TO STRING{28442
{{PPM{{{{ERROR RETURN IS IMPOSSIBLE{28443
{{JSR{6,PRTST{{{PRINT THE STRING{28444
{{MOV{7,XR{3,DNAMP{{DELETE GARBAGE STRING FROM STORAGE{28445
{{BRN{6,PRV03{{{BACK TO EXIT{28446
{{EJC{{{{{28447
*
*      PRTVL (CONTINUED)
*
*      NAME (NMBLK)
*
*      FOR PSEUDO-VARIABLE, JUST PRINT DATATYPE NAME (NAME)
*      FOR ALL OTHER NAMES, PRINT DOT FOLLOWED BY NAME REP
*
{PRV09{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{28456
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF BLOCK{28457
{{BEQ{8,WA{22,=B$KVT{6,PRV02{JUST PRINT NAME IF KEYWORD{28458
{{BEQ{8,WA{22,=B$EVT{6,PRV02{JUST PRINT NAME IF EXPRESSION VAR{28459
{{MOV{18,=CH$DT{8,WA{{ELSE GET DOT{28460
{{JSR{6,PRTCH{{{AND PRINT IT{28461
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{28462
{{JSR{6,PRTNM{{{PRINT NAME{28463
{{BRN{6,PRV03{{{BACK TO EXIT{28464
*
*      PROGRAM DATATYPE (PDBLK)
*
*      PRINT DATATYPE NAME CH$BL CH$NM IDVAL
*
{PRV10{JSR{6,DTYPE{{{GET DATATYPE NAME{28470
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28471
{{BRN{6,PRV07{{{MERGE BACK TO PRINT ID{28472
*
*      HERE FOR STRING (SCBLK)
*
*      PRINT QUOTE STRING-CHARACTERS QUOTE
*
{PRV11{MOV{18,=CH$SQ{8,WA{{LOAD SINGLE QUOTE{28478
{{JSR{6,PRTCH{{{PRINT QUOTE{28479
{{JSR{6,PRTST{{{PRINT STRING VALUE{28480
{{JSR{6,PRTCH{{{PRINT ANOTHER QUOTE{28481
{{BRN{6,PRV03{{{BACK TO EXIT{28482
{{EJC{{{{{28483
*
*      PRTVL (CONTINUED)
*
*      HERE FOR SIMPLE EXPRESSION (SEBLK)
*
*      PRINT ASTERISK VARIABLE-NAME
*
{PRV12{MOV{18,=CH$AS{8,WA{{LOAD ASTERISK{28491
{{JSR{6,PRTCH{{{PRINT ASTERISK{28492
{{MOV{13,SEVAR(XR){7,XR{{LOAD VARIABLE POINTER{28493
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{28494
{{BRN{6,PRV03{{{JUMP BACK TO EXIT{28495
*
*      HERE FOR TABLE (TBBLK) AND ARRAY (VCBLK)
*
*      PRINT DATATYPE ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV13{MOV{7,XR{7,XL{{PRESERVE ARGUMENT{28501
{{JSR{6,DTYPE{{{GET DATATYPE NAME{28502
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28503
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{28504
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{28505
{{MOV{13,TBLEN(XL){8,WA{{LOAD LENGTH OF BLOCK (=VCLEN){28506
{{BTW{8,WA{{{CONVERT TO WORD COUNT{28507
{{SUB{18,=TBSI${8,WA{{ALLOW FOR STANDARD FIELDS{28508
{{BEQ{9,(XL){22,=B$TBT{6,PRV14{JUMP IF TABLE{28509
{{ADD{18,=VCTBD{8,WA{{FOR VCBLK, ADJUST SIZE{28510
*
*      PRINT PROTOTYPE
*
{PRV14{MTI{8,WA{{{MOVE AS INTEGER{28514
{{JSR{6,PRTIN{{{PRINT INTEGER PROTOTYPE{28515
{{BRN{6,PRV06{{{MERGE BACK FOR REST{28516
{{ENP{{{{END PROCEDURE PRTVL{28539
{{EJC{{{{{28540
*
*      PRTVN -- PRINT NATURAL VARIABLE NAME
*
*      PRTVN PRINTS THE NAME OF A NATURAL VARIABLE
*
*      (XR)                  POINTER TO VRBLK
*      JSR  PRTVN            CALL TO PRINT VARIABLE NAME
*
{PRTVN{PRC{25,E{1,0{{ENTRY POINT{28549
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{28550
{{ADD{19,*VRSOF{7,XR{{POINT TO POSSIBLE STRING NAME{28551
{{BNZ{13,SCLEN(XR){6,PRVN1{{JUMP IF NOT SYSTEM VARIABLE{28552
{{MOV{13,VRSVO(XR){7,XR{{POINT TO SVBLK WITH NAME{28553
*
*      MERGE HERE WITH DUMMY SCBLK POINTER IN XR
*
{PRVN1{JSR{6,PRTST{{{PRINT STRING NAME OF VARIABLE{28557
{{MOV{10,(XS)+{7,XR{{RESTORE VRBLK POINTER{28558
{{EXI{{{{RETURN TO PRTVN CALLER{28559
{{ENP{{{{END PROCEDURE PRTVN{28560
{{EJC{{{{{28563
*
*      RCBLD -- BUILD A REAL BLOCK
*
*      (RA)                  REAL VALUE FOR RCBLK
*      JSR  RCBLD            CALL TO BUILD REAL BLOCK
*      (XR)                  POINTER TO RESULT RCBLK
*      (WA)                  DESTROYED
*
{RCBLD{PRC{25,E{1,0{{ENTRY POINT{28572
{{MOV{3,DNAMP{7,XR{{LOAD POINTER TO NEXT AVAILABLE LOC{28573
{{ADD{19,*RCSI${7,XR{{POINT PAST NEW RCBLK{28574
{{BLO{7,XR{3,DNAME{6,RCBL1{JUMP IF THERE IS ROOM{28575
{{MOV{19,*RCSI${8,WA{{ELSE LOAD RCBLK LENGTH{28576
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{28577
{{ADD{8,WA{7,XR{{POINT PAST BLOCK TO MERGE{28578
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{RCBL1{MOV{7,XR{3,DNAMP{{SET NEW POINTER{28582
{{SUB{19,*RCSI${7,XR{{POINT BACK TO START OF BLOCK{28583
{{MOV{22,=B$RCL{9,(XR){{STORE TYPE WORD{28584
{{STR{13,RCVAL(XR){{{STORE REAL VALUE IN RCBLK{28585
{{EXI{{{{RETURN TO RCBLD CALLER{28586
{{ENP{{{{END PROCEDURE RCBLD{28587
{{EJC{{{{{28589
*
*      READR -- READ NEXT SOURCE IMAGE AT COMPILE TIME
*
*      READR IS USED TO READ THE NEXT SOURCE IMAGE. TO PROCESS
*      CONTINUATION CARDS PROPERLY, THE COMPILER MUST READ ONE
*      LINE AHEAD. THUS READR DOES NOT DESTROY THE CURRENT IMAGE
*      SEE ALSO THE NEXTS ROUTINE WHICH ACTUALLY GETS THE IMAGE.
*
*      JSR  READR            CALL TO READ NEXT IMAGE
*      (XR)                  PTR TO NEXT IMAGE (0 IF NONE)
*      (R$CNI)               COPY OF POINTER
*      (WA,WB,WC,XL)         DESTROYED
*
{READR{PRC{25,E{1,0{{ENTRY POINT{28603
{{MOV{3,R$CNI{7,XR{{GET PTR TO NEXT IMAGE{28604
{{BNZ{7,XR{6,READ3{{EXIT IF ALREADY READ{28605
{{BNZ{3,CNIND{6,READA{{IF WITHIN INCLUDE FILE{28607
{{BNE{3,STAGE{18,=STGIC{6,READ3{EXIT IF NOT INITIAL COMPILE{28609
{READA{MOV{3,CSWIN{8,WA{{MAX READ LENGTH{28610
{{ZER{7,XL{{{CLEAR ANY DUD VALUE IN XL{28611
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{28612
{{JSR{6,SYSRD{{{READ INPUT IMAGE{28613
{{PPM{6,READ4{{{JUMP IF EOF OR NEW FILE NAME{28614
{{ICV{3,RDNLN{{{INCREMENT NEXT LINE NUMBER{28615
{{DCV{3,POLCT{{{TEST IF TIME TO POLL INTERFACE{28617
{{BNZ{3,POLCT{6,READ0{{NOT YET{28618
{{ZER{8,WA{{{=0 FOR POLL{28619
{{MOV{3,RDNLN{8,WB{{LINE NUMBER{28620
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{28621
{{ERR{1,320{26,User interrupt{{{28622
{{PPM{{{{SINGLE STEP{28623
{{PPM{{{{EXPRESSION EVALUATION{28624
{{MOV{8,WA{3,POLCS{{NEW COUNTDOWN START VALUE{28625
{{MOV{8,WA{3,POLCT{{NEW COUNTER VALUE{28626
{READ0{BLE{13,SCLEN(XR){3,CSWIN{6,READ1{USE SMALLER OF STRING LNTH ...{28628
{{MOV{3,CSWIN{13,SCLEN(XR){{... AND XXX OF -INXXX{28629
*
*      PERFORM THE TRIM
*
{READ1{MNZ{8,WB{{{SET TRIMR TO PERFORM TRIM{28633
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS{28634
*
*      MERGE HERE AFTER READ
*
{READ2{MOV{7,XR{3,R$CNI{{STORE COPY OF POINTER{28638
*
*      MERGE HERE IF NO READ ATTEMPTED
*
{READ3{EXI{{{{RETURN TO READR CALLER{28642
*
*      HERE ON END OF FILE OR NEW SOURCE FILE NAME.
*      IF THIS IS A NEW SOURCE FILE NAME, THE R$SFN TABLE WILL
*      BE AUGMENTED WITH A NEW TABLE ENTRY CONSISTING OF THE
*      CURRENT COMPILER STATEMENT NUMBER AS SUBSCRIPT, AND THE
*      FILE NAME AS VALUE.
*
{READ4{BZE{13,SCLEN(XR){6,READ5{{JUMP IF TRUE END OF FILE{28651
{{ZER{8,WB{{{NEW SOURCE FILE NAME{28652
{{MOV{8,WB{3,RDNLN{{RESTART LINE COUNTER FOR NEW FILE{28653
{{JSR{6,TRIMR{{{REMOVE UNUSED SPACE IN BLOCK{28654
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{28655
{{BRN{6,READA{{{NOW REISSUE READ FOR RECORD DATA{28656
*
*      HERE ON END OF FILE
*
{READ5{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{28660
{{BZE{3,CNIND{6,READ6{{JUMP IF NOT WITHIN AN INCLUDE FILE{28662
{{ZER{7,XL{{{EOF WITHIN INCLUDE FILE{28663
{{JSR{6,SYSIF{{{SWITCH STREAM BACK TO PREVIOUS FILE{28664
{{PPM{{{{{28665
{{MOV{3,CNIND{8,WA{{RESTORE PREV LINE NUMBER, FILE NAME{28666
{{ADD{18,=VCVLB{8,WA{{VECTOR OFFSET IN WORDS{28667
{{WTB{8,WA{{{CONVERT TO BYTES{28668
{{MOV{3,R$IFA{7,XR{{FILE NAME ARRAY{28669
{{ADD{8,WA{7,XR{{PTR TO ELEMENT{28670
{{MOV{9,(XR){3,R$SFC{{CHANGE SOURCE FILE NAME{28671
{{MOV{21,=NULLS{9,(XR){{RELEASE SCBLK{28672
{{MOV{3,R$IFL{7,XR{{LINE NUMBER ARRAY{28673
{{ADD{8,WA{7,XR{{PTR TO ELEMENT{28674
{{MOV{9,(XR){7,XL{{ICBLK CONTAINING SAVED LINE NUMBER{28675
{{LDI{13,ICVAL(XL){{{LINE NUMBER INTEGER{28676
{{MFI{3,RDNLN{{{CHANGE SOURCE LINE NUMBER{28677
{{MOV{21,=INTON{9,(XR){{RELEASE ICBLK{28678
{{DCV{3,CNIND{{{DECREMENT NESTING LEVEL{28679
{{MOV{3,CMPSN{8,WB{{CURRENT STATEMENT NUMBER{28680
{{ICV{8,WB{{{ANTICIPATE END OF PREVIOUS STMT{28681
{{MTI{8,WB{{{CONVERT TO INTEGER{28682
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{28683
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{28684
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{28685
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{28686
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{28687
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{28688
{{BEQ{3,STAGE{18,=STGIC{6,READA{IF INITIAL COMPILE, REISSUE READ{28689
{{BNZ{3,CNIND{6,READA{{STILL READING FROM INCLUDE FILE{28690
*
*      OUTER NESTING OF EXECUTE-TIME COMPILE OF -INCLUDE
*      RESUME WITH ANY STRING REMAINING PRIOR TO -INCLUDE.
*
{{MOV{3,R$ICI{7,XL{{RESTORE CODE ARGUMENT STRING{28695
{{ZER{3,R$ICI{{{RELEASE ORIGINAL STRING{28696
{{MOV{3,CNSIL{8,WA{{GET LENGTH OF STRING{28697
{{MOV{3,CNSPT{8,WB{{OFFSET OF CHARACTERS LEFT{28698
{{SUB{8,WB{8,WA{{NUMBER OF CHARACTERS LEFT{28699
{{MOV{8,WA{3,SCNIL{{SET NEW SCAN LENGTH{28700
{{ZER{3,SCNPT{{{SCAN FROM START OF SUBSTRING{28701
{{JSR{6,SBSTR{{{CREATE SUBSTRING OF REMAINDER{28702
{{MOV{7,XR{3,R$CIM{{SET SCAN IMAGE{28703
{{BRN{6,READ2{{{RETURN{28704
{READ6{ZER{7,XR{{{ZERO PTR AS RESULT{28720
{{BRN{6,READ2{{{MERGE{28721
{{ENP{{{{END PROCEDURE READR{28722
{{EJC{{{{{28723
*
*      SBSTR -- BUILD A SUBSTRING
*
*      (XL)                  PTR TO SCBLK/BFBLK WITH CHARS
*      (WA)                  NUMBER OF CHARS IN SUBSTRING
*      (WB)                  OFFSET TO FIRST CHAR IN SCBLK
*      JSR  SBSTR            CALL TO BUILD SUBSTRING
*      (XR)                  PTR TO NEW SCBLK WITH SUBSTRING
*      (XL)                  ZERO
*      (WA,WB,WC,XL,IA)      DESTROYED
*
*      NOTE THAT SBSTR IS CALLED WITH A DUMMY STRING POINTER
*      (POINTING INTO A VRBLK OR SVBLK) TO COPY THE NAME OF A
*      VARIABLE AS A STANDARD STRING VALUE.
*
{SBSTR{PRC{25,E{1,0{{ENTRY POINT{28818
{{BZE{8,WA{6,SBST2{{JUMP IF NULL SUBSTRING{28819
{{JSR{6,ALOCS{{{ELSE ALLOCATE SCBLK{28820
{{MOV{8,WC{8,WA{{MOVE NUMBER OF CHARACTERS{28821
{{MOV{7,XR{8,WC{{SAVE PTR TO NEW SCBLK{28822
{{PLC{7,XL{8,WB{{PREPARE TO LOAD CHARS FROM OLD BLK{28823
{{PSC{7,XR{{{PREPARE TO STORE CHARS IN NEW BLK{28824
{{MVC{{{{MOVE CHARACTERS TO NEW STRING{28825
{{MOV{8,WC{7,XR{{THEN RESTORE SCBLK POINTER{28826
*
*      RETURN POINT
*
{SBST1{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{28830
{{EXI{{{{RETURN TO SBSTR CALLER{28831
*
*      HERE FOR NULL SUBSTRING
*
{SBST2{MOV{21,=NULLS{7,XR{{SET NULL STRING AS RESULT{28835
{{BRN{6,SBST1{{{RETURN{28836
{{ENP{{{{END PROCEDURE SBSTR{28837
{{EJC{{{{{28838
*
*      STGCC -- COMPUTE COUNTERS FOR STMT STARTUP TESTING
*
*      JSR  STGCC            CALL TO RECOMPUTE COUNTERS
*      (WA,WB)               DESTROYED
*
*      ON EXIT, STMCS AND STMCT CONTAIN THE COUNTER VALUE TO
*      TESTED IN STMGO.
*
*
{STGCC{PRC{25,E{1,0{{{28849
{{MOV{3,POLCS{8,WA{{ASSUME NO PROFILING OR STCOUNT TRACING{28851
{{MOV{18,=NUM01{8,WB{{POLL EACH TIME POLCS EXPIRES{28852
{{LDI{3,KVSTL{{{GET STMT LIMIT{28856
{{BNZ{3,KVPFL{6,STGC1{{JUMP IF PROFILING ENABLED{28857
{{ILT{6,STGC3{{{NO STCOUNT TRACING IF NEGATIVE{28858
{{BZE{3,R$STC{6,STGC2{{JUMP IF NOT STCOUNT TRACING{28859
*
*      HERE IF PROFILING OR IF STCOUNT TRACING ENABLED
*
{STGC1{MOV{8,WA{8,WB{{COUNT POLCS TIMES WITHIN STMG{28864
{{MOV{18,=NUM01{8,WA{{BREAK OUT OF STMGO ON EACH STMT{28865
{{BRN{6,STGC3{{{{28869
*
*      CHECK THAT STMCS DOES NOT EXCEED KVSTL
*
{STGC2{MTI{8,WA{{{BREAKOUT COUNT START VALUE{28873
{{SBI{3,KVSTL{{{PROPOSED STMCS MINUS STMT LIMIT{28874
{{ILE{6,STGC3{{{JUMP IF STMT COUNT DOES NOT LIMIT{28875
{{LDI{3,KVSTL{{{STLIMIT LIMITS BREAKCOUNT COUNT{28876
{{MFI{8,WA{{{USE IT INSTEAD{28877
*
*      RE-INITIALIZE COUNTER
*
{STGC3{MOV{8,WA{3,STMCS{{UPDATE BREAKOUT COUNT START VALUE{28881
{{MOV{8,WA{3,STMCT{{RESET BREAKOUT COUNTER{28882
{{MOV{8,WB{3,POLCT{{{28884
{{EXI{{{{{28886
{{EJC{{{{{28887
*
*      TFIND -- LOCATE TABLE ELEMENT
*
*      (XR)                  SUBSCRIPT VALUE FOR ELEMENT
*      (XL)                  POINTER TO TABLE
*      (WB)                  ZERO BY VALUE, NON-ZERO BY NAME
*      JSR  TFIND            CALL TO LOCATE ELEMENT
*      PPM  LOC              TRANSFER LOCATION IF ACCESS FAILS
*      (XR)                  ELEMENT VALUE (IF BY VALUE)
*      (XR)                  DESTROYED (IF BY NAME)
*      (XL,WA)               TEBLK NAME (IF BY NAME)
*      (XL,WA)               DESTROYED (IF BY VALUE)
*      (WC,RA)               DESTROYED
*
*      NOTE THAT IF A CALL BY VALUE SPECIFIES A NON-EXISTENT
*      SUBSCRIPT, THE DEFAULT VALUE IS RETURNED WITHOUT BUILDING
*      A NEW TEBLK.
*
{TFIND{PRC{25,E{1,1{{ENTRY POINT{28906
{{MOV{8,WB{11,-(XS){{SAVE NAME/VALUE INDICATOR{28907
{{MOV{7,XR{11,-(XS){{SAVE SUBSCRIPT VALUE{28908
{{MOV{7,XL{11,-(XS){{SAVE TABLE POINTER{28909
{{MOV{13,TBLEN(XL){8,WA{{LOAD LENGTH OF TBBLK{28910
{{BTW{8,WA{{{CONVERT TO WORD COUNT{28911
{{SUB{18,=TBBUK{8,WA{{GET NUMBER OF BUCKETS{28912
{{MTI{8,WA{{{CONVERT TO INTEGER VALUE{28913
{{STI{3,TFNSI{{{SAVE FOR LATER{28914
{{MOV{9,(XR){7,XL{{LOAD FIRST WORD OF SUBSCRIPT{28915
{{LEI{7,XL{{{LOAD BLOCK ENTRY ID (BL$XX){28916
{{BSW{7,XL{2,BL$$D{6,TFN00{SWITCH ON BLOCK TYPE{28917
{{IFF{1,0{6,TFN00{{{28928
{{IFF{1,1{6,TFN00{{{28928
{{IFF{1,2{6,TFN00{{{28928
{{IFF{2,BL$IC{6,TFN02{{JUMP IF INTEGER{28928
{{IFF{2,BL$NM{6,TFN04{{JUMP IF NAME{28928
{{IFF{2,BL$P0{6,TFN03{{JUMP IF PATTERN{28928
{{IFF{2,BL$P1{6,TFN03{{JUMP IF PATTERN{28928
{{IFF{2,BL$P2{6,TFN03{{JUMP IF PATTERN{28928
{{IFF{2,BL$RC{6,TFN02{{REAL{28928
{{IFF{2,BL$SC{6,TFN05{{JUMP IF STRING{28928
{{IFF{1,10{6,TFN00{{{28928
{{IFF{1,11{6,TFN00{{{28928
{{IFF{1,12{6,TFN00{{{28928
{{IFF{1,13{6,TFN00{{{28928
{{IFF{1,14{6,TFN00{{{28928
{{IFF{1,15{6,TFN00{{{28928
{{IFF{1,16{6,TFN00{{{28928
{{ESW{{{{END SWITCH ON BLOCK TYPE{28928
*
*      HERE FOR BLOCKS FOR WHICH WE USE THE SECOND WORD OF THE
*      BLOCK AS THE HASH SOURCE (SEE BLOCK FORMATS FOR DETAILS).
*
{TFN00{MOV{12,1(XR){8,WA{{LOAD SECOND WORD{28933
*
*      MERGE HERE WITH ONE WORD HASH SOURCE IN WA
*
{TFN01{MTI{8,WA{{{CONVERT TO INTEGER{28937
{{BRN{6,TFN06{{{JUMP TO MERGE{28938
{{EJC{{{{{28939
*
*      TFIND (CONTINUED)
*
*      HERE FOR INTEGER OR REAL
*      POSSIBILITY OF OVERFLOW EXIST ON TWOS COMPLEMENT
*      MACHINE IF HASH SOURCE IS MOST NEGATIVE INTEGER OR IS
*      A REAL HAVING THE SAME BIT PATTERN.
*
*
{TFN02{LDI{12,1(XR){{{LOAD VALUE AS HASH SOURCE{28949
{{IGE{6,TFN06{{{OK IF POSITIVE OR ZERO{28950
{{NGI{{{{MAKE POSITIVE{28951
{{IOV{6,TFN06{{{CLEAR POSSIBLE OVERFLOW{28952
{{BRN{6,TFN06{{{MERGE{28953
*
*      FOR PATTERN, USE FIRST WORD (PCODE) AS SOURCE
*
{TFN03{MOV{9,(XR){8,WA{{LOAD FIRST WORD AS HASH SOURCE{28957
{{BRN{6,TFN01{{{MERGE BACK{28958
*
*      FOR NAME, USE OFFSET AS HASH SOURCE
*
{TFN04{MOV{13,NMOFS(XR){8,WA{{LOAD OFFSET AS HASH SOURCE{28962
{{BRN{6,TFN01{{{MERGE BACK{28963
*
*      HERE FOR STRING
*
{TFN05{JSR{6,HASHS{{{CALL ROUTINE TO COMPUTE HASH{28967
*
*      MERGE HERE WITH HASH SOURCE IN (IA)
*
{TFN06{RMI{3,TFNSI{{{COMPUTE HASH INDEX BY REMAINDERING{28971
{{MFI{8,WC{{{GET AS ONE WORD INTEGER{28972
{{WTB{8,WC{{{CONVERT TO BYTE OFFSET{28973
{{MOV{9,(XS){7,XL{{GET TABLE PTR AGAIN{28974
{{ADD{8,WC{7,XL{{POINT TO PROPER BUCKET{28975
{{MOV{13,TBBUK(XL){7,XR{{LOAD FIRST TEBLK POINTER{28976
{{BEQ{7,XR{9,(XS){6,TFN10{JUMP IF NO TEBLKS ON CHAIN{28977
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{TFN07{MOV{7,XR{8,WB{{SAVE TEBLK POINTER{28981
{{MOV{13,TESUB(XR){7,XR{{LOAD SUBSCRIPT VALUE{28982
{{MOV{12,1(XS){7,XL{{LOAD INPUT ARGUMENT SUBSCRIPT VAL{28983
{{JSR{6,IDENT{{{COMPARE THEM{28984
{{PPM{6,TFN08{{{JUMP IF EQUAL (IDENT){28985
*
*      HERE IF NO MATCH WITH THAT TEBLK
*
{{MOV{8,WB{7,XL{{RESTORE TEBLK POINTER{28989
{{MOV{13,TENXT(XL){7,XR{{POINT TO NEXT TEBLK ON CHAIN{28990
{{BNE{7,XR{9,(XS){6,TFN07{JUMP IF THERE IS ONE{28991
*
*      HERE IF NO MATCH WITH ANY TEBLK ON CHAIN
*
{{MOV{19,*TENXT{8,WC{{SET OFFSET TO LINK FIELD (XL BASE){28995
{{BRN{6,TFN11{{{JUMP TO MERGE{28996
{{EJC{{{{{28997
*
*      TFIND (CONTINUED)
*
*      HERE WE HAVE FOUND A MATCHING ELEMENT
*
{TFN08{MOV{8,WB{7,XL{{RESTORE TEBLK POINTER{29003
{{MOV{19,*TEVAL{8,WA{{SET TEBLK NAME OFFSET{29004
{{MOV{12,2(XS){8,WB{{RESTORE NAME/VALUE INDICATOR{29005
{{BNZ{8,WB{6,TFN09{{JUMP IF CALLED BY NAME{29006
{{JSR{6,ACESS{{{ELSE GET VALUE{29007
{{PPM{6,TFN12{{{JUMP IF REFERENCE FAILS{29008
{{ZER{8,WB{{{RESTORE NAME/VALUE INDICATOR{29009
*
*      COMMON EXIT FOR ENTRY FOUND
*
{TFN09{ADD{19,*NUM03{7,XS{{POP STACK ENTRIES{29013
{{EXI{{{{RETURN TO TFIND CALLER{29014
*
*      HERE IF NO TEBLKS ON THE HASH CHAIN
*
{TFN10{ADD{19,*TBBUK{8,WC{{GET OFFSET TO BUCKET PTR{29018
{{MOV{9,(XS){7,XL{{SET TBBLK PTR AS BASE{29019
*
*      MERGE HERE WITH (XL,WC) BASE,OFFSET OF FINAL LINK
*
{TFN11{MOV{9,(XS){7,XR{{TBBLK POINTER{29023
{{MOV{13,TBINV(XR){7,XR{{LOAD DEFAULT VALUE IN CASE{29024
{{MOV{12,2(XS){8,WB{{LOAD NAME/VALUE INDICATOR{29025
{{BZE{8,WB{6,TFN09{{EXIT WITH DEFAULT IF VALUE CALL{29026
{{MOV{7,XR{8,WB{{COPY DEFAULT VALUE{29027
*
*      HERE WE MUST BUILD A NEW TEBLK
*
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{29031
{{JSR{6,ALLOC{{{ALLOCATE TEBLK{29032
{{ADD{8,WC{7,XL{{POINT TO HASH LINK{29033
{{MOV{7,XR{9,(XL){{LINK NEW TEBLK AT END OF CHAIN{29034
{{MOV{22,=B$TET{9,(XR){{STORE TYPE WORD{29035
{{MOV{8,WB{13,TEVAL(XR){{SET DEFAULT AS INITIAL VALUE{29036
{{MOV{10,(XS)+{13,TENXT(XR){{SET TBBLK PTR TO MARK END OF CHAIN{29037
{{MOV{10,(XS)+{13,TESUB(XR){{STORE SUBSCRIPT VALUE{29038
{{MOV{10,(XS)+{8,WB{{RESTORE NAME/VALUE INDICATOR{29039
{{MOV{7,XR{7,XL{{COPY TEBLK POINTER (NAME BASE){29040
{{MOV{19,*TEVAL{8,WA{{SET OFFSET{29041
{{EXI{{{{RETURN TO CALLER WITH NEW TEBLK{29042
*
*      ACESS FAIL RETURN
*
{TFN12{EXI{1,1{{{ALTERNATIVE RETURN{29046
{{ENP{{{{END PROCEDURE TFIND{29047
{{EJC{{{{{29048
*
*      TMAKE -- MAKE NEW TABLE
*
*      (XL)                  INITIAL LOOKUP VALUE
*      (WC)                  NUMBER OF BUCKETS DESIRED
*      JSR  TMAKE            CALL TO MAKE NEW TABLE
*      (XR)                  NEW TABLE
*      (WA,WB)               DESTROYED
*
{TMAKE{PRC{25,E{1,0{{{29058
{{MOV{8,WC{8,WA{{COPY NUMBER OF HEADERS{29059
{{ADD{18,=TBSI${8,WA{{ADJUST FOR STANDARD FIELDS{29060
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{29061
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{29062
{{MOV{7,XR{8,WB{{COPY POINTER TO TBBLK{29063
{{MOV{22,=B$TBT{10,(XR)+{{STORE TYPE WORD{29064
{{ZER{10,(XR)+{{{ZERO ID FOR THE MOMENT{29065
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (TBLEN){29066
{{MOV{7,XL{10,(XR)+{{STORE INITIAL LOOKUP VALUE{29067
{{LCT{8,WC{8,WC{{SET LOOP COUNTER (NUM HEADERS){29068
*
*      LOOP TO INITIALIZE ALL BUCKET POINTERS
*
{TMA01{MOV{8,WB{10,(XR)+{{STORE TBBLK PTR IN BUCKET HEADER{29072
{{BCT{8,WC{6,TMA01{{LOOP TILL ALL STORED{29073
{{MOV{8,WB{7,XR{{RECALL POINTER TO TBBLK{29074
{{EXI{{{{{29075
{{ENP{{{{{29076
{{EJC{{{{{29077
*
*      VMAKE -- CREATE A VECTOR
*
*      (WA)                  NUMBER OF ELEMENTS IN VECTOR
*      (XL)                  DEFAULT VALUE FOR VECTOR ELEMENTS
*      JSR  VMAKE            CALL TO CREATE VECTOR
*      PPM  LOC              IF VECTOR TOO LARGE
*
*      (XR)                  POINTER TO VCBLK
*      (WA,WB,WC,XL)         DESTROYED
*
{VMAKE{PRC{25,E{1,1{{ENTRY POINT{29089
{{LCT{8,WB{8,WA{{COPY ELEMENTS FOR LOOP LATER ON{29090
{{ADD{18,=VCSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{29091
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{29092
{{BGT{8,WA{3,MXLEN{6,VMAK2{FAIL IF TOO LARGE{29093
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR VCBLK{29094
{{MOV{22,=B$VCT{9,(XR){{STORE TYPE WORD{29095
{{ZER{13,IDVAL(XR){{{INITIALIZE IDVAL{29096
{{MOV{8,WA{13,VCLEN(XR){{SET LENGTH{29097
{{MOV{7,XL{8,WC{{COPY DEFAULT VALUE{29098
{{MOV{7,XR{7,XL{{COPY VCBLK POINTER{29099
{{ADD{19,*VCVLS{7,XL{{POINT TO FIRST ELEMENT VALUE{29100
*
*      LOOP TO SET VECTOR ELEMENTS TO DEFAULT VALUE
*
{VMAK1{MOV{8,WC{10,(XL)+{{STORE ONE VALUE{29104
{{BCT{8,WB{6,VMAK1{{LOOP TILL ALL STORED{29105
{{EXI{{{{SUCCESS RETURN{29106
*
*      HERE IF DESIRED VECTOR SIZE TOO LARGE
*
{VMAK2{EXI{1,1{{{FAIL RETURN{29110
{{ENP{{{{{29111
{{EJC{{{{{29112
*
*      SCANE -- SCAN AN ELEMENT
*
*      SCANE IS CALLED AT COMPILE TIME (BY EXPAN ,CMPIL,CNCRD)
*      TO SCAN ONE ELEMENT FROM THE INPUT IMAGE.
*
*      (SCNCC)               NON-ZERO IF CALLED FROM CNCRD
*      JSR  SCANE            CALL TO SCAN ELEMENT
*      (XR)                  RESULT POINTER (SEE BELOW)
*      (XL)                  SYNTAX TYPE CODE (T$XXX)
*
*      THE FOLLOWING GLOBAL LOCATIONS ARE USED.
*
*      R$CIM                 POINTER TO STRING BLOCK (SCBLK)
*                            FOR CURRENT INPUT IMAGE.
*
*      R$CNI                 POINTER TO NEXT INPUT IMAGE STRING
*                            POINTER (ZERO IF NONE).
*
*      R$SCP                 SAVE POINTER (EXIT XR) FROM LAST
*                            CALL IN CASE RESCAN IS SET.
*
*      SCNBL                 THIS LOCATION IS SET NON-ZERO ON
*                            EXIT IF SCANE SCANNED PAST BLANKS
*                            BEFORE LOCATING THE CURRENT ELEMENT
*                            THE END OF A LINE COUNTS AS BLANKS.
*
*      SCNCC                 CNCRD SETS THIS NON-ZERO TO SCAN
*                            CONTROL CARD NAMES AND CLEARS IT
*                            ON RETURN
*
*      SCNIL                 LENGTH OF CURRENT INPUT IMAGE
*
*      SCNGO                 IF SET NON-ZERO ON ENTRY, F AND S
*                            ARE RETURNED AS SEPARATE SYNTAX
*                            TYPES (NOT LETTERS) (GOTO PRO-
*                            CESSING). SCNGO IS RESET ON EXIT.
*
*      SCNPT                 OFFSET TO CURRENT LOC IN R$CIM
*
*      SCNRS                 IF SET NON-ZERO ON ENTRY, SCANE
*                            RETURNS THE SAME RESULT AS ON THE
*                            LAST CALL (RESCAN). SCNRS IS RESET
*                            ON EXIT FROM ANY CALL TO SCANE.
*
*      SCNTP                 SAVE SYNTAX TYPE FROM LAST
*                            CALL (IN CASE RESCAN IS SET).
{{EJC{{{{{29160
*
*      SCANE (CONTINUED)
*
*
*
*      ELEMENT SCANNED       XL        XR
*      ---------------       --        --
*
*      CONTROL CARD NAME     0         POINTER TO SCBLK FOR NAME
*
*      UNARY OPERATOR        T$UOP     PTR TO OPERATOR DVBLK
*
*      LEFT PAREN            T$LPR     T$LPR
*
*      LEFT BRACKET          T$LBR     T$LBR
*
*      COMMA                 T$CMA     T$CMA
*
*      FUNCTION CALL         T$FNC     PTR TO FUNCTION VRBLK
*
*      VARIABLE              T$VAR     PTR TO VRBLK
*
*      STRING CONSTANT       T$CON     PTR TO SCBLK
*
*      INTEGER CONSTANT      T$CON     PTR TO ICBLK
*
*      REAL CONSTANT         T$CON     PTR TO RCBLK
*
*      BINARY OPERATOR       T$BOP     PTR TO OPERATOR DVBLK
*
*      RIGHT PAREN           T$RPR     T$RPR
*
*      RIGHT BRACKET         T$RBR     T$RBR
*
*      COLON                 T$COL     T$COL
*
*      SEMI-COLON            T$SMC     T$SMC
*
*      F (SCNGO NE 0)        T$FGO     T$FGO
*
*      S (SCNGO NE 0)        T$SGO     T$SGO
{{EJC{{{{{29205
*
*      SCANE (CONTINUED)
*
*      ENTRY POINT
*
{SCANE{PRC{25,E{1,0{{ENTRY POINT{29211
{{ZER{3,SCNBL{{{RESET BLANKS FLAG{29212
{{MOV{8,WA{3,SCNSA{{SAVE WA{29213
{{MOV{8,WB{3,SCNSB{{SAVE WB{29214
{{MOV{8,WC{3,SCNSC{{SAVE WC{29215
{{BZE{3,SCNRS{6,SCN03{{JUMP IF NO RESCAN{29216
*
*      HERE FOR RESCAN REQUEST
*
{{MOV{3,SCNTP{7,XL{{SET PREVIOUS RETURNED SCAN TYPE{29220
{{MOV{3,R$SCP{7,XR{{SET PREVIOUS RETURNED POINTER{29221
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH{29222
{{BRN{6,SCN13{{{JUMP TO EXIT{29223
*
*      COME HERE TO READ NEW IMAGE TO TEST FOR CONTINUATION
*
{SCN01{JSR{6,READR{{{READ NEXT IMAGE{29227
{{MOV{19,*DVUBS{8,WB{{SET WB FOR NOT READING NAME{29228
{{BZE{7,XR{6,SCN30{{TREAT AS SEMI-COLON IF NONE{29229
{{PLC{7,XR{{{ELSE POINT TO FIRST CHARACTER{29230
{{LCH{8,WC{9,(XR){{LOAD FIRST CHARACTER{29231
{{BEQ{8,WC{18,=CH$DT{6,SCN02{JUMP IF DOT FOR CONTINUATION{29232
{{BNE{8,WC{18,=CH$PL{6,SCN30{ELSE TREAT AS SEMICOLON UNLESS PLUS{29233
*
*      HERE FOR CONTINUATION LINE
*
{SCN02{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{29237
{{MOV{18,=NUM01{3,SCNPT{{SET SCAN POINTER PAST CONTINUATION{29238
{{MNZ{3,SCNBL{{{SET BLANKS FLAG{29239
{{EJC{{{{{29240
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO SCAN NEXT ELEMENT ON CURRENT LINE
*
{SCN03{MOV{3,SCNPT{8,WA{{LOAD CURRENT OFFSET{29246
{{BEQ{8,WA{3,SCNIL{6,SCN01{CHECK CONTINUATION IF END{29247
{{MOV{3,R$CIM{7,XL{{POINT TO CURRENT LINE{29248
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHARACTER{29249
{{MOV{8,WA{3,SCNSE{{SET START OF ELEMENT LOCATION{29250
{{MOV{21,=OPDVS{8,WC{{POINT TO OPERATOR DV LIST{29251
{{MOV{19,*DVUBS{8,WB{{SET CONSTANT FOR OPERATOR CIRCUIT{29252
{{BRN{6,SCN06{{{START SCANNING{29253
*
*      LOOP HERE TO IGNORE LEADING BLANKS AND TABS
*
{SCN05{BZE{8,WB{6,SCN10{{JUMP IF TRAILING{29257
{{ICV{3,SCNSE{{{INCREMENT START OF ELEMENT{29258
{{BEQ{8,WA{3,SCNIL{6,SCN01{JUMP IF END OF IMAGE{29259
{{MNZ{3,SCNBL{{{NOTE BLANKS SEEN{29260
*
*      THE FOLLOWING JUMP IS USED REPEATEDLY FOR SCANNING OUT
*      THE CHARACTERS OF A NUMERIC CONSTANT OR VARIABLE NAME.
*      THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  SCRATCH
*      (XL)                  PTR TO NEXT CHARACTER
*      (WA)                  CURRENT SCAN OFFSET
*      (WB)                  *DVUBS (0 IF SCANNING NAME,CONST)
*      (WC)                  =OPDVS (0 IF SCANNING CONSTANT)
*
{SCN06{LCH{7,XR{10,(XL)+{{GET NEXT CHARACTER{29272
{{ICV{8,WA{{{BUMP SCAN OFFSET{29273
{{MOV{8,WA{3,SCNPT{{STORE OFFSET PAST CHAR SCANNED{29274
{{BSW{7,XR{2,CFP$U{6,SCN07{SWITCH ON SCANNED CHARACTER{29276
*
*      SWITCH TABLE FOR SWITCH ON CHARACTER
*
{{EJC{{{{{29303
*
*      SCANE (CONTINUED)
*
{{EJC{{{{{29359
*
*      SCANE (CONTINUED)
*
{{IFF{1,0{6,SCN07{{{29392
{{IFF{1,1{6,SCN07{{{29392
{{IFF{1,2{6,SCN07{{{29392
{{IFF{1,3{6,SCN07{{{29392
{{IFF{1,4{6,SCN07{{{29392
{{IFF{1,5{6,SCN07{{{29392
{{IFF{1,6{6,SCN07{{{29392
{{IFF{1,7{6,SCN07{{{29392
{{IFF{1,8{6,SCN07{{{29392
{{IFF{2,CH$HT{6,SCN05{{HORIZONTAL TAB{29392
{{IFF{1,10{6,SCN07{{{29392
{{IFF{1,11{6,SCN07{{{29392
{{IFF{1,12{6,SCN07{{{29392
{{IFF{1,13{6,SCN07{{{29392
{{IFF{1,14{6,SCN07{{{29392
{{IFF{1,15{6,SCN07{{{29392
{{IFF{1,16{6,SCN07{{{29392
{{IFF{1,17{6,SCN07{{{29392
{{IFF{1,18{6,SCN07{{{29392
{{IFF{1,19{6,SCN07{{{29392
{{IFF{1,20{6,SCN07{{{29392
{{IFF{1,21{6,SCN07{{{29392
{{IFF{1,22{6,SCN07{{{29392
{{IFF{1,23{6,SCN07{{{29392
{{IFF{1,24{6,SCN07{{{29392
{{IFF{1,25{6,SCN07{{{29392
{{IFF{1,26{6,SCN07{{{29392
{{IFF{1,27{6,SCN07{{{29392
{{IFF{1,28{6,SCN07{{{29392
{{IFF{1,29{6,SCN07{{{29392
{{IFF{1,30{6,SCN07{{{29392
{{IFF{1,31{6,SCN07{{{29392
{{IFF{2,CH$BL{6,SCN05{{BLANK{29392
{{IFF{2,CH$EX{6,SCN37{{EXCLAMATION MARK{29392
{{IFF{2,CH$DQ{6,SCN17{{DOUBLE QUOTE{29392
{{IFF{2,CH$NM{6,SCN41{{NUMBER SIGN{29392
{{IFF{2,CH$DL{6,SCN36{{DOLLAR{29392
{{IFF{2,CH$PC{6,SCN38{{PERCENT{29392
{{IFF{2,CH$AM{6,SCN44{{AMPERSAND{29392
{{IFF{2,CH$SQ{6,SCN16{{SINGLE QUOTE{29392
{{IFF{2,CH$PP{6,SCN25{{LEFT PAREN{29392
{{IFF{2,CH$RP{6,SCN26{{RIGHT PAREN{29392
{{IFF{2,CH$AS{6,SCN49{{ASTERISK{29392
{{IFF{2,CH$PL{6,SCN33{{PLUS{29392
{{IFF{2,CH$CM{6,SCN31{{COMMA{29392
{{IFF{2,CH$MN{6,SCN34{{MINUS{29392
{{IFF{2,CH$DT{6,SCN32{{DOT{29392
{{IFF{2,CH$SL{6,SCN40{{SLASH{29392
{{IFF{2,CH$D0{6,SCN08{{DIGIT 0{29392
{{IFF{2,CH$D1{6,SCN08{{DIGIT 1{29392
{{IFF{2,CH$D2{6,SCN08{{DIGIT 2{29392
{{IFF{2,CH$D3{6,SCN08{{DIGIT 3{29392
{{IFF{2,CH$D4{6,SCN08{{DIGIT 4{29392
{{IFF{2,CH$D5{6,SCN08{{DIGIT 5{29392
{{IFF{2,CH$D6{6,SCN08{{DIGIT 6{29392
{{IFF{2,CH$D7{6,SCN08{{DIGIT 7{29392
{{IFF{2,CH$D8{6,SCN08{{DIGIT 8{29392
{{IFF{2,CH$D9{6,SCN08{{DIGIT 9{29392
{{IFF{2,CH$CL{6,SCN29{{COLON{29392
{{IFF{2,CH$SM{6,SCN30{{SEMI-COLON{29392
{{IFF{2,CH$BB{6,SCN28{{LEFT BRACKET{29392
{{IFF{2,CH$EQ{6,SCN46{{EQUAL{29392
{{IFF{2,CH$RB{6,SCN27{{RIGHT BRACKET{29392
{{IFF{2,CH$QU{6,SCN45{{QUESTION MARK{29392
{{IFF{2,CH$AT{6,SCN42{{AT{29392
{{IFF{2,CH$LA{6,SCN09{{LETTER A{29392
{{IFF{2,CH$LB{6,SCN09{{LETTER B{29392
{{IFF{2,CH$LC{6,SCN09{{LETTER C{29392
{{IFF{2,CH$LD{6,SCN09{{LETTER D{29392
{{IFF{2,CH$LE{6,SCN09{{LETTER E{29392
{{IFF{2,CH$LF{6,SCN20{{LETTER F{29392
{{IFF{2,CH$LG{6,SCN09{{LETTER G{29392
{{IFF{2,CH$LH{6,SCN09{{LETTER H{29392
{{IFF{2,CH$LI{6,SCN09{{LETTER I{29392
{{IFF{2,CH$LJ{6,SCN09{{LETTER J{29392
{{IFF{2,CH$LK{6,SCN09{{LETTER K{29392
{{IFF{2,CH$LL{6,SCN09{{LETTER L{29392
{{IFF{2,CH$LM{6,SCN09{{LETTER M{29392
{{IFF{2,CH$LN{6,SCN09{{LETTER N{29392
{{IFF{2,CH$LO{6,SCN09{{LETTER O{29392
{{IFF{2,CH$LP{6,SCN09{{LETTER P{29392
{{IFF{2,CH$LQ{6,SCN09{{LETTER Q{29392
{{IFF{2,CH$LR{6,SCN09{{LETTER R{29392
{{IFF{2,CH$LS{6,SCN21{{LETTER S{29392
{{IFF{2,CH$LT{6,SCN09{{LETTER T{29392
{{IFF{2,CH$LU{6,SCN09{{LETTER U{29392
{{IFF{2,CH$LV{6,SCN09{{LETTER V{29392
{{IFF{2,CH$LW{6,SCN09{{LETTER W{29392
{{IFF{2,CH$LX{6,SCN09{{LETTER X{29392
{{IFF{2,CH$LY{6,SCN09{{LETTER Y{29392
{{IFF{2,CH$L${6,SCN09{{LETTER Z{29392
{{IFF{2,CH$OB{6,SCN28{{LEFT BRACKET{29392
{{IFF{1,92{6,SCN07{{{29392
{{IFF{2,CH$CB{6,SCN27{{RIGHT BRACKET{29392
{{IFF{2,CH$EY{6,SCN37{{UP ARROW{29392
{{IFF{2,CH$UN{6,SCN24{{UNDERLINE{29392
{{IFF{1,96{6,SCN07{{{29392
{{IFF{2,CH$$A{6,SCN09{{SHIFTED A{29392
{{IFF{2,CH$$B{6,SCN09{{SHIFTED B{29392
{{IFF{2,CH$$C{6,SCN09{{SHIFTED C{29392
{{IFF{2,CH$$D{6,SCN09{{SHIFTED D{29392
{{IFF{2,CH$$E{6,SCN09{{SHIFTED E{29392
{{IFF{2,CH$$F{6,SCN20{{SHIFTED F{29392
{{IFF{2,CH$$G{6,SCN09{{SHIFTED G{29392
{{IFF{2,CH$$H{6,SCN09{{SHIFTED H{29392
{{IFF{2,CH$$I{6,SCN09{{SHIFTED I{29392
{{IFF{2,CH$$J{6,SCN09{{SHIFTED J{29392
{{IFF{2,CH$$K{6,SCN09{{SHIFTED K{29392
{{IFF{2,CH$$L{6,SCN09{{SHIFTED L{29392
{{IFF{2,CH$$M{6,SCN09{{SHIFTED M{29392
{{IFF{2,CH$$N{6,SCN09{{SHIFTED N{29392
{{IFF{2,CH$$O{6,SCN09{{SHIFTED O{29392
{{IFF{2,CH$$P{6,SCN09{{SHIFTED P{29392
{{IFF{2,CH$$Q{6,SCN09{{SHIFTED Q{29392
{{IFF{2,CH$$R{6,SCN09{{SHIFTED R{29392
{{IFF{2,CH$$S{6,SCN21{{SHIFTED S{29392
{{IFF{2,CH$$T{6,SCN09{{SHIFTED T{29392
{{IFF{2,CH$$U{6,SCN09{{SHIFTED U{29392
{{IFF{2,CH$$V{6,SCN09{{SHIFTED V{29392
{{IFF{2,CH$$W{6,SCN09{{SHIFTED W{29392
{{IFF{2,CH$$X{6,SCN09{{SHIFTED X{29392
{{IFF{2,CH$$Y{6,SCN09{{SHIFTED Y{29392
{{IFF{2,CH$$${6,SCN09{{SHIFTED Z{29392
{{IFF{1,123{6,SCN07{{{29392
{{IFF{2,CH$BR{6,SCN43{{VERTICAL BAR{29392
{{IFF{1,125{6,SCN07{{{29392
{{IFF{2,CH$NT{6,SCN35{{NOT{29392
{{IFF{1,127{6,SCN07{{{29392
{{ESW{{{{END SWITCH ON CHARACTER{29392
*
*      HERE FOR ILLEGAL CHARACTER (UNDERLINE MERGES)
*
{SCN07{BZE{8,WB{6,SCN10{{JUMP IF SCANNING NAME OR CONSTANT{29396
{{ERB{1,230{26,Syntax error: Illegal character{{{29397
{{EJC{{{{{29398
*
*      SCANE (CONTINUED)
*
*      HERE FOR DIGITS 0-9
*
{SCN08{BZE{8,WB{6,SCN09{{KEEP SCANNING IF NAME/CONSTANT{29404
{{ZER{8,WC{{{ELSE SET FLAG FOR SCANNING CONSTANT{29405
*
*      HERE FOR LETTER. LOOP HERE WHEN SCANNING NAME/CONSTANT
*
{SCN09{BEQ{8,WA{3,SCNIL{6,SCN11{JUMP IF END OF IMAGE{29409
{{ZER{8,WB{{{SET FLAG FOR SCANNING NAME/CONST{29410
{{BRN{6,SCN06{{{MERGE BACK TO CONTINUE SCAN{29411
*
*      COME HERE FOR DELIMITER ENDING NAME OR CONSTANT
*
{SCN10{DCV{8,WA{{{RESET OFFSET TO POINT TO DELIMITER{29415
*
*      COME HERE AFTER FINISHING SCAN OF NAME OR CONSTANT
*
{SCN11{MOV{8,WA{3,SCNPT{{STORE UPDATED SCAN OFFSET{29419
{{MOV{3,SCNSE{8,WB{{POINT TO START OF ELEMENT{29420
{{SUB{8,WB{8,WA{{GET NUMBER OF CHARACTERS{29421
{{MOV{3,R$CIM{7,XL{{POINT TO LINE IMAGE{29422
{{BNZ{8,WC{6,SCN15{{JUMP IF NAME{29423
*
*      HERE AFTER SCANNING OUT NUMERIC CONSTANT
*
{{JSR{6,SBSTR{{{GET STRING FOR CONSTANT{29427
{{MOV{7,XR{3,DNAMP{{DELETE FROM STORAGE (NOT NEEDED){29428
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{29429
{{PPM{6,SCN14{{{JUMP IF CONVERSION FAILURE{29430
*
*      MERGE HERE TO EXIT WITH CONSTANT
*
{SCN12{MOV{18,=T$CON{7,XL{{SET RESULT TYPE OF CONSTANT{29434
{{EJC{{{{{29435
*
*      SCANE (CONTINUED)
*
*      COMMON EXIT POINT (XR,XL) SET
*
{SCN13{MOV{3,SCNSA{8,WA{{RESTORE WA{29441
{{MOV{3,SCNSB{8,WB{{RESTORE WB{29442
{{MOV{3,SCNSC{8,WC{{RESTORE WC{29443
{{MOV{7,XR{3,R$SCP{{SAVE XR IN CASE RESCAN{29444
{{MOV{7,XL{3,SCNTP{{SAVE XL IN CASE RESCAN{29445
{{ZER{3,SCNGO{{{RESET POSSIBLE GOTO FLAG{29446
{{EXI{{{{RETURN TO SCANE CALLER{29447
*
*      HERE IF CONVERSION ERROR ON NUMERIC ITEM
*
{SCN14{ERB{1,231{26,Syntax error: Invalid numeric item{{{29451
*
*      HERE AFTER SCANNING OUT VARIABLE NAME
*
{SCN15{JSR{6,SBSTR{{{BUILD STRING NAME OF VARIABLE{29455
{{BNZ{3,SCNCC{6,SCN13{{RETURN IF CNCRD CALL{29456
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{29457
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{29458
{{MOV{18,=T$VAR{7,XL{{SET TYPE AS VARIABLE{29459
{{BRN{6,SCN13{{{BACK TO EXIT{29460
*
*      HERE FOR SINGLE QUOTE (START OF STRING CONSTANT)
*
{SCN16{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{29464
{{MOV{18,=CH$SQ{8,WB{{SET TERMINATOR AS SINGLE QUOTE{29465
{{BRN{6,SCN18{{{MERGE{29466
*
*      HERE FOR DOUBLE QUOTE (START OF STRING CONSTANT)
*
{SCN17{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{29470
{{MOV{18,=CH$DQ{8,WB{{SET DOUBLE QUOTE TERMINATOR, MERGE{29471
*
*      LOOP TO SCAN OUT STRING CONSTANT
*
{SCN18{BEQ{8,WA{3,SCNIL{6,SCN19{ERROR IF END OF IMAGE{29475
{{LCH{8,WC{10,(XL)+{{ELSE LOAD NEXT CHARACTER{29476
{{ICV{8,WA{{{BUMP OFFSET{29477
{{BNE{8,WC{8,WB{6,SCN18{LOOP BACK IF NOT TERMINATOR{29478
{{EJC{{{{{29479
*
*      SCANE (CONTINUED)
*
*      HERE AFTER SCANNING OUT STRING CONSTANT
*
{{MOV{3,SCNPT{8,WB{{POINT TO FIRST CHARACTER{29485
{{MOV{8,WA{3,SCNPT{{SAVE OFFSET PAST FINAL QUOTE{29486
{{DCV{8,WA{{{POINT BACK PAST LAST CHARACTER{29487
{{SUB{8,WB{8,WA{{GET NUMBER OF CHARACTERS{29488
{{MOV{3,R$CIM{7,XL{{POINT TO INPUT IMAGE{29489
{{JSR{6,SBSTR{{{BUILD SUBSTRING VALUE{29490
{{BRN{6,SCN12{{{BACK TO EXIT WITH CONSTANT RESULT{29491
*
*      HERE IF NO MATCHING QUOTE FOUND
*
{SCN19{MOV{8,WA{3,SCNPT{{SET UPDATED SCAN POINTER{29495
{{ERB{1,232{26,Syntax error: Unmatched string quote{{{29496
*
*      HERE FOR F (POSSIBLE FAILURE GOTO)
*
{SCN20{MOV{18,=T$FGO{7,XR{{SET RETURN CODE FOR FAIL GOTO{29500
{{BRN{6,SCN22{{{JUMP TO MERGE{29501
*
*      HERE FOR S (POSSIBLE SUCCESS GOTO)
*
{SCN21{MOV{18,=T$SGO{7,XR{{SET SUCCESS GOTO AS RETURN CODE{29505
*
*      SPECIAL GOTO CASES MERGE HERE
*
{SCN22{BZE{3,SCNGO{6,SCN09{{TREAT AS NORMAL LETTER IF NOT GOTO{29509
*
*      MERGE HERE FOR SPECIAL CHARACTER EXIT
*
{SCN23{BZE{8,WB{6,SCN10{{JUMP IF END OF NAME/CONSTANT{29513
{{MOV{7,XR{7,XL{{ELSE COPY CODE{29514
{{BRN{6,SCN13{{{AND JUMP TO EXIT{29515
*
*      HERE FOR UNDERLINE
*
{SCN24{BZE{8,WB{6,SCN09{{PART OF NAME IF SCANNING NAME{29519
{{BRN{6,SCN07{{{ELSE ILLEGAL{29520
{{EJC{{{{{29521
*
*      SCANE (CONTINUED)
*
*      HERE FOR LEFT PAREN
*
{SCN25{MOV{18,=T$LPR{7,XR{{SET LEFT PAREN RETURN CODE{29527
{{BNZ{8,WB{6,SCN23{{RETURN LEFT PAREN UNLESS NAME{29528
{{BZE{8,WC{6,SCN10{{DELIMITER IF SCANNING CONSTANT{29529
*
*      HERE FOR LEFT PAREN AFTER NAME (FUNCTION CALL)
*
{{MOV{3,SCNSE{8,WB{{POINT TO START OF NAME{29533
{{MOV{8,WA{3,SCNPT{{SET POINTER PAST LEFT PAREN{29534
{{DCV{8,WA{{{POINT BACK PAST LAST CHAR OF NAME{29535
{{SUB{8,WB{8,WA{{GET NAME LENGTH{29536
{{MOV{3,R$CIM{7,XL{{POINT TO INPUT IMAGE{29537
{{JSR{6,SBSTR{{{GET STRING NAME FOR FUNCTION{29538
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{29539
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{29540
{{MOV{18,=T$FNC{7,XL{{SET CODE FOR FUNCTION CALL{29541
{{BRN{6,SCN13{{{BACK TO EXIT{29542
*
*      PROCESSING FOR SPECIAL CHARACTERS
*
{SCN26{MOV{18,=T$RPR{7,XR{{RIGHT PAREN, SET CODE{29546
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29547
*
{SCN27{MOV{18,=T$RBR{7,XR{{RIGHT BRACKET, SET CODE{29549
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29550
*
{SCN28{MOV{18,=T$LBR{7,XR{{LEFT BRACKET, SET CODE{29552
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29553
*
{SCN29{MOV{18,=T$COL{7,XR{{COLON, SET CODE{29555
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29556
*
{SCN30{MOV{18,=T$SMC{7,XR{{SEMI-COLON, SET CODE{29558
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29559
*
{SCN31{MOV{18,=T$CMA{7,XR{{COMMA, SET CODE{29561
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29562
{{EJC{{{{{29563
*
*      SCANE (CONTINUED)
*
*      HERE FOR OPERATORS. ON ENTRY, WC POINTS TO THE TABLE OF
*      OPERATOR DOPE VECTORS AND WB IS THE INCREMENT TO STEP
*      TO THE NEXT PAIR (BINARY/UNARY) OF DOPE VECTORS IN THE
*      LIST. ON REACHING SCN46, THE POINTER HAS BEEN ADJUSTED TO
*      POINT TO THE APPROPRIATE PAIR OF DOPE VECTORS.
*      THE FIRST THREE ENTRIES ARE SPECIAL SINCE THEY CAN OCCUR
*      AS PART OF A VARIABLE NAME (.) OR CONSTANT (.+-).
*
{SCN32{BZE{8,WB{6,SCN09{{DOT CAN BE PART OF NAME OR CONSTANT{29575
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29576
*
{SCN33{BZE{8,WC{6,SCN09{{PLUS CAN BE PART OF CONSTANT{29578
{{BZE{8,WB{6,SCN48{{PLUS CANNOT BE PART OF NAME{29579
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29580
*
{SCN34{BZE{8,WC{6,SCN09{{MINUS CAN BE PART OF CONSTANT{29582
{{BZE{8,WB{6,SCN48{{MINUS CANNOT BE PART OF NAME{29583
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29584
*
{SCN35{ADD{8,WB{8,WC{{NOT{29586
{SCN36{ADD{8,WB{8,WC{{DOLLAR{29587
{SCN37{ADD{8,WB{8,WC{{EXCLAMATION{29588
{SCN38{ADD{8,WB{8,WC{{PERCENT{29589
{SCN39{ADD{8,WB{8,WC{{ASTERISK{29590
{SCN40{ADD{8,WB{8,WC{{SLASH{29591
{SCN41{ADD{8,WB{8,WC{{NUMBER SIGN{29592
{SCN42{ADD{8,WB{8,WC{{AT SIGN{29593
{SCN43{ADD{8,WB{8,WC{{VERTICAL BAR{29594
{SCN44{ADD{8,WB{8,WC{{AMPERSAND{29595
{SCN45{ADD{8,WB{8,WC{{QUESTION MARK{29596
*
*      ALL OPERATORS COME HERE (EQUAL MERGES DIRECTLY)
*      (WC) POINTS TO THE BINARY/UNARY PAIR OF OPERATOR DVBLKS.
*
{SCN46{BZE{8,WB{6,SCN10{{OPERATOR TERMINATES NAME/CONSTANT{29601
{{MOV{8,WC{7,XR{{ELSE COPY DV POINTER{29602
{{LCH{8,WC{9,(XL){{LOAD NEXT CHARACTER{29603
{{MOV{18,=T$BOP{7,XL{{SET BINARY OP IN CASE{29604
{{BEQ{8,WA{3,SCNIL{6,SCN47{SHOULD BE BINARY IF IMAGE END{29605
{{BEQ{8,WC{18,=CH$BL{6,SCN47{SHOULD BE BINARY IF FOLLOWED BY BLK{29606
{{BEQ{8,WC{18,=CH$HT{6,SCN47{JUMP IF HORIZONTAL TAB{29608
{{BEQ{8,WC{18,=CH$SM{6,SCN47{SEMICOLON CAN IMMEDIATELY FOLLOW ={29613
{{BEQ{8,WC{18,=CH$CL{6,SCN47{COLON CAN IMMEDIATELY FOLLOW ={29614
{{BEQ{8,WC{18,=CH$RP{6,SCN47{RIGHT PAREN CAN IMMEDIATELY FOLLOW ={29615
{{BEQ{8,WC{18,=CH$RB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={29616
{{BEQ{8,WC{18,=CH$CB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={29617
*
*      HERE FOR UNARY OPERATOR
*
{{ADD{19,*DVBS${7,XR{{POINT TO DV FOR UNARY OP{29621
{{MOV{18,=T$UOP{7,XL{{SET TYPE FOR UNARY OPERATOR{29622
{{BLE{3,SCNTP{18,=T$UOK{6,SCN13{OK UNARY IF OK PRECEDING ELEMENT{29623
{{EJC{{{{{29624
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO REQUIRE PRECEDING BLANKS
*
{SCN47{BNZ{3,SCNBL{6,SCN13{{ALL OK IF PRECEDING BLANKS, EXIT{29630
*
*      FAIL OPERATOR IN THIS POSITION
*
{SCN48{ERB{1,233{26,Syntax error: Invalid use of operator{{{29634
*
*      HERE FOR ASTERISK, COULD BE ** SUBSTITUTE FOR EXCLAMATION
*
{SCN49{BZE{8,WB{6,SCN10{{END OF NAME IF SCANNING NAME{29638
{{BEQ{8,WA{3,SCNIL{6,SCN39{NOT ** IF * AT IMAGE END{29639
{{MOV{8,WA{7,XR{{ELSE SAVE OFFSET PAST FIRST *{29640
{{MOV{8,WA{3,SCNOF{{SAVE ANOTHER COPY{29641
{{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{29642
{{BNE{8,WA{18,=CH$AS{6,SCN50{NOT ** IF NEXT CHAR NOT *{29643
{{ICV{7,XR{{{ELSE STEP OFFSET PAST SECOND *{29644
{{BEQ{7,XR{3,SCNIL{6,SCN51{OK EXCLAM IF END OF IMAGE{29645
{{LCH{8,WA{9,(XL){{ELSE LOAD NEXT CHARACTER{29646
{{BEQ{8,WA{18,=CH$BL{6,SCN51{EXCLAMATION IF BLANK{29647
{{BEQ{8,WA{18,=CH$HT{6,SCN51{EXCLAMATION IF HORIZONTAL TAB{29649
*
*      UNARY *
*
{SCN50{MOV{3,SCNOF{8,WA{{RECOVER STORED OFFSET{29657
{{MOV{3,R$CIM{7,XL{{POINT TO LINE AGAIN{29658
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHAR{29659
{{BRN{6,SCN39{{{MERGE WITH UNARY *{29660
*
*      HERE FOR ** AS SUBSTITUTE FOR EXCLAMATION
*
{SCN51{MOV{7,XR{3,SCNPT{{SAVE SCAN POINTER PAST 2ND *{29664
{{MOV{7,XR{8,WA{{COPY SCAN POINTER{29665
{{BRN{6,SCN37{{{MERGE WITH EXCLAMATION{29666
{{ENP{{{{END PROCEDURE SCANE{29667
{{EJC{{{{{29668
*
*      SCNGF -- SCAN GOTO FIELD
*
*      SCNGF IS CALLED FROM CMPIL TO SCAN AND ANALYZE A GOTO
*      FIELD INCLUDING THE SURROUNDING BRACKETS OR PARENTHESES.
*      FOR A NORMAL GOTO, THE RESULT RETURNED IS EITHER A VRBLK
*      POINTER FOR A SIMPLE LABEL OPERAND, OR A POINTER TO AN
*      EXPRESSION TREE WITH A SPECIAL OUTER UNARY OPERATOR
*      (O$GOC). FOR A DIRECT GOTO, THE RESULT RETURNED IS A
*      POINTER TO AN EXPRESSION TREE WITH THE SPECIAL OUTER
*      UNARY OPERATOR O$GOD.
*
*      JSR  SCNGF            CALL TO SCAN GOTO FIELD
*      (XR)                  RESULT (SEE ABOVE)
*      (XL,WA,WB,WC)         DESTROYED
*
{SCNGF{PRC{25,E{1,0{{ENTRY POINT{29685
{{JSR{6,SCANE{{{SCAN INITIAL ELEMENT{29686
{{BEQ{7,XL{18,=T$LPR{6,SCNG1{SKIP IF LEFT PAREN (NORMAL GOTO){29687
{{BEQ{7,XL{18,=T$LBR{6,SCNG2{SKIP IF LEFT BRACKET (DIRECT GOTO){29688
{{ERB{1,234{26,Syntax error: Goto field incorrect{{{29689
*
*      HERE FOR LEFT PAREN (NORMAL GOTO)
*
{SCNG1{MOV{18,=NUM01{8,WB{{SET EXPAN FLAG FOR NORMAL GOTO{29693
{{JSR{6,EXPAN{{{ANALYZE GOTO FIELD{29694
{{MOV{21,=OPDVN{8,WA{{POINT TO OPDV FOR COMPLEX GOTO{29695
{{BLE{7,XR{3,STATB{6,SCNG3{JUMP IF NOT IN STATIC (SGD15){29696
{{BLO{7,XR{3,STATE{6,SCNG4{JUMP TO EXIT IF SIMPLE LABEL NAME{29697
{{BRN{6,SCNG3{{{COMPLEX GOTO - MERGE{29698
*
*      HERE FOR LEFT BRACKET (DIRECT GOTO)
*
{SCNG2{MOV{18,=NUM02{8,WB{{SET EXPAN FLAG FOR DIRECT GOTO{29702
{{JSR{6,EXPAN{{{SCAN GOTO FIELD{29703
{{MOV{21,=OPDVD{8,WA{{SET OPDV POINTER FOR DIRECT GOTO{29704
{{EJC{{{{{29705
*
*      SCNGF (CONTINUED)
*
*      MERGE HERE TO BUILD OUTER UNARY OPERATOR BLOCK
*
{SCNG3{MOV{8,WA{11,-(XS){{STACK OPERATOR DV POINTER{29711
{{MOV{7,XR{11,-(XS){{STACK POINTER TO EXPRESSION TREE{29712
{{JSR{6,EXPOP{{{POP OPERATOR OFF{29713
{{MOV{10,(XS)+{7,XR{{RELOAD NEW EXPRESSION TREE POINTER{29714
*
*      COMMON EXIT POINT
*
{SCNG4{EXI{{{{RETURN TO CALLER{29718
{{ENP{{{{END PROCEDURE SCNGF{29719
{{EJC{{{{{29720
*
*      SETVR -- SET VRGET,VRSTO FIELDS OF VRBLK
*
*      SETVR SETS THE PROPER VALUES IN THE VRGET AND VRSTO
*      FIELDS OF A VRBLK. IT IS CALLED WHENEVER TRBLKS ARE
*      ADDED OR SUBTRACTED (TRACE,STOPTR,INPUT,OUTPUT,DETACH)
*
*      (XR)                  POINTER TO VRBLK
*      JSR  SETVR            CALL TO SET FIELDS
*      (XL,WA)               DESTROYED
*
*      NOTE THAT SETVR IGNORES THE CALL IF XR DOES NOT POINT
*      INTO THE STATIC REGION (I.E. IS SOME OTHER NAME BASE)
*
{SETVR{PRC{25,E{1,0{{ENTRY POINT{29735
{{BHI{7,XR{3,STATE{6,SETV1{EXIT IF NOT NATURAL VARIABLE{29736
*
*      HERE IF WE HAVE A VRBLK
*
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{29740
{{MOV{22,=B$VRL{13,VRGET(XR){{STORE NORMAL GET VALUE{29741
{{BEQ{13,VRSTO(XR){22,=B$VRE{6,SETV1{SKIP IF PROTECTED VARIABLE{29742
{{MOV{22,=B$VRS{13,VRSTO(XR){{STORE NORMAL STORE VALUE{29743
{{MOV{13,VRVAL(XL){7,XL{{POINT TO NEXT ENTRY ON CHAIN{29744
{{BNE{9,(XL){22,=B$TRT{6,SETV1{JUMP IF END OF TRBLK CHAIN{29745
{{MOV{22,=B$VRA{13,VRGET(XR){{STORE TRAPPED ROUTINE ADDRESS{29746
{{MOV{22,=B$VRV{13,VRSTO(XR){{SET TRAPPED ROUTINE ADDRESS{29747
*
*      MERGE HERE TO EXIT TO CALLER
*
{SETV1{EXI{{{{RETURN TO SETVR CALLER{29751
{{ENP{{{{END PROCEDURE SETVR{29752
{{EJC{{{{{29755
*
*      SORTA -- SORT ARRAY
*
*      ROUTINE TO SORT AN ARRAY OR TABLE ON SAME BASIS AS IN
*      SITBOL. A TABLE IS CONVERTED TO AN ARRAY, LEAVING TWO
*      DIMENSIONAL ARRAYS AND VECTORS AS CASES TO BE CONSIDERED.
*      WHOLE ROWS OF ARRAYS ARE PERMUTED ACCORDING TO THE
*      ORDERING OF THE KEYS THEY CONTAIN, AND THE STRIDE
*      REFERRED TO, IS THE THE LENGTH OF A ROW. IT IS ONE
*      FOR A VECTOR.
*      THE SORT USED IS HEAPSORT, FUNDAMENTALS OF DATA STRUCTURE
*      HOROWITZ AND SAHNI, PITMAN 1977, PAGE 347.
*      IT IS AN ORDER N*LOG(N) ALGORITHM. IN ORDER
*      TO MAKE IT STABLE, COMPARANDS MAY NOT COMPARE EQUAL. THIS
*      IS ACHIEVED BY SORTING A COPY ARRAY (REFERRED TO AS THE
*      SORT ARRAY) CONTAINING AT ITS HIGH ADDRESS END, BYTE
*      OFFSETS TO THE ROWS TO BE SORTED HELD IN THE ORIGINAL
*      ARRAY (REFERRED TO AS THE KEY ARRAY). SORTC, THE
*      COMPARISON ROUTINE, ACCESSES THE KEYS THROUGH THESE
*      OFFSETS AND IN THE CASE OF EQUALITY, RESOLVES IT BY
*      COMPARING THE OFFSETS THEMSELVES. THE SORT PERMUTES THE
*      OFFSETS WHICH ARE THEN USED IN A FINAL OPERATION TO COPY
*      THE ACTUAL ITEMS INTO THE NEW ARRAY IN SORTED ORDER.
*      REFERENCES TO ZEROTH ITEM ARE TO NOTIONAL ITEM
*      PRECEDING FIRST ACTUAL ITEM.
*      REVERSE SORTING FOR RSORT IS DONE BY HAVING THE LESS THAN
*      TEST FOR KEYS EFFECTIVELY BE REPLACED BY A
*      GREATER THAN TEST.
*
*      1(XS)                 FIRST ARG - ARRAY OR TABLE
*      0(XS)                 2ND ARG - INDEX OR PDTYPE NAME
*      (WA)                  0 , NON-ZERO FOR SORT , RSORT
*      JSR  SORTA            CALL TO SORT ARRAY
*      PPM  LOC              TRANSFER LOC IF TABLE IS EMPTY
*      (XR)                  SORTED ARRAY
*      (XL,WA,WB,WC)         DESTROYED
{{EJC{{{{{29792
*
*      SORTA (CONTINUED)
*
{SORTA{PRC{25,N{1,1{{ENTRY POINT{29796
{{MOV{8,WA{3,SRTSR{{SORT/RSORT INDICATOR{29797
{{MOV{19,*NUM01{3,SRTST{{DEFAULT STRIDE OF 1{29798
{{ZER{3,SRTOF{{{DEFAULT ZERO OFFSET TO SORT KEY{29799
{{MOV{21,=NULLS{3,SRTDF{{CLEAR DATATYPE FIELD NAME{29800
{{MOV{10,(XS)+{3,R$SXR{{UNSTACK ARGUMENT 2{29801
{{MOV{10,(XS)+{7,XR{{GET FIRST ARGUMENT{29802
{{MNZ{8,WA{{{USE KEY/VALUES OF TABLE ENTRIES{29803
{{JSR{6,GTARR{{{CONVERT TO ARRAY{29804
{{PPM{6,SRT18{{{SIGNAL THAT TABLE IS EMPTY{29805
{{PPM{6,SRT16{{{ERROR IF NON-CONVERTABLE{29806
{{MOV{7,XR{11,-(XS){{STACK PTR TO RESULTING KEY ARRAY{29807
{{MOV{7,XR{11,-(XS){{ANOTHER COPY FOR COPYB{29808
{{JSR{6,COPYB{{{GET COPY ARRAY FOR SORTING INTO{29809
{{PPM{{{{CANT FAIL{29810
{{MOV{7,XR{11,-(XS){{STACK POINTER TO SORT ARRAY{29811
{{MOV{3,R$SXR{7,XR{{GET SECOND ARG{29812
{{MOV{13,NUM01(XS){7,XL{{GET PTR TO KEY ARRAY{29813
{{BNE{9,(XL){22,=B$VCT{6,SRT02{JUMP IF ARBLK{29814
{{BEQ{7,XR{21,=NULLS{6,SRT01{JUMP IF NULL SECOND ARG{29815
{{JSR{6,GTNVR{{{GET VRBLK PTR FOR IT{29816
{{ERR{1,257{26,Erroneous 2nd arg in SORT/RSORT of vector{{{29817
{{MOV{7,XR{3,SRTDF{{STORE DATATYPE FIELD NAME VRBLK{29818
*
*      COMPUTE N AND OFFSET TO ITEM A(0) IN VECTOR CASE
*
{SRT01{MOV{19,*VCLEN{8,WC{{OFFSET TO A(0){29822
{{MOV{19,*VCVLS{8,WB{{OFFSET TO FIRST ITEM{29823
{{MOV{13,VCLEN(XL){8,WA{{GET BLOCK LENGTH{29824
{{SUB{19,*VCSI${8,WA{{GET NO. OF ENTRIES, N (IN BYTES){29825
{{BRN{6,SRT04{{{MERGE{29826
*
*      HERE FOR ARRAY
*
{SRT02{LDI{13,ARDIM(XL){{{GET POSSIBLE DIMENSION{29830
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{29831
{{WTB{8,WA{{{FURTHER CONVERT TO BAUS{29832
{{MOV{19,*ARVLS{8,WB{{OFFSET TO FIRST VALUE IF ONE{29833
{{MOV{19,*ARPRO{8,WC{{OFFSET BEFORE VALUES IF ONE DIM.{29834
{{BEQ{13,ARNDM(XL){18,=NUM01{6,SRT04{JUMP IN FACT IF ONE DIM.{29835
{{BNE{13,ARNDM(XL){18,=NUM02{6,SRT16{FAIL UNLESS TWO DIMENS{29836
{{LDI{13,ARLB2(XL){{{GET LOWER BOUND 2 AS DEFAULT{29837
{{BEQ{7,XR{21,=NULLS{6,SRT03{JUMP IF DEFAULT SECOND ARG{29838
{{JSR{6,GTINT{{{CONVERT TO INTEGER{29839
{{PPM{6,SRT17{{{FAIL{29840
{{LDI{13,ICVAL(XR){{{GET ACTUAL INTEGER VALUE{29841
{{EJC{{{{{29842
*
*      SORTA (CONTINUED)
*
*      HERE WITH SORT COLUMN INDEX IN IA IN ARRAY CASE
*
{SRT03{SBI{13,ARLB2(XL){{{SUBTRACT LOW BOUND{29848
{{IOV{6,SRT17{{{FAIL IF OVERFLOW{29849
{{ILT{6,SRT17{{{FAIL IF BELOW LOW BOUND{29850
{{SBI{13,ARDM2(XL){{{CHECK AGAINST DIMENSION{29851
{{IGE{6,SRT17{{{FAIL IF TOO LARGE{29852
{{ADI{13,ARDM2(XL){{{RESTORE VALUE{29853
{{MFI{8,WA{{{GET AS SMALL INTEGER{29854
{{WTB{8,WA{{{OFFSET WITHIN ROW TO KEY{29855
{{MOV{8,WA{3,SRTOF{{KEEP OFFSET{29856
{{LDI{13,ARDM2(XL){{{SECOND DIMENSION IS ROW LENGTH{29857
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{29858
{{MOV{8,WA{7,XR{{COPY ROW LENGTH{29859
{{WTB{8,WA{{{CONVERT TO BYTES{29860
{{MOV{8,WA{3,SRTST{{STORE AS STRIDE{29861
{{LDI{13,ARDIM(XL){{{GET NUMBER OF ROWS{29862
{{MFI{8,WA{{{AS A SHORT INTEGER{29863
{{WTB{8,WA{{{CONVERT N TO BAUS{29864
{{MOV{13,ARLEN(XL){8,WC{{OFFSET PAST ARRAY END{29865
{{SUB{8,WA{8,WC{{ADJUST, GIVING SPACE FOR N OFFSETS{29866
{{DCA{8,WC{{{POINT TO A(0){29867
{{MOV{13,AROFS(XL){8,WB{{OFFSET TO WORD BEFORE FIRST ITEM{29868
{{ICA{8,WB{{{OFFSET TO FIRST ITEM{29869
*
*      SEPARATE PRE-PROCESSING FOR ARRAYS AND VECTORS DONE.
*      TO SIMPLIFY LATER KEY COMPARISONS, REMOVAL OF ANY TRBLK
*      TRAP BLOCKS FROM ENTRIES IN KEY ARRAY IS EFFECTED.
*
*      (XL) = 1(XS) = POINTER TO KEY ARRAY
*      (XS) = POINTER TO SORT ARRAY
*      WA = NUMBER OF ITEMS, N (CONVERTED TO BYTES).
*      WB = OFFSET TO FIRST ITEM OF ARRAYS.
*      WC = OFFSET TO A(0)
*
{SRT04{BLE{8,WA{19,*NUM01{6,SRT15{RETURN IF ONLY A SINGLE ITEM{29881
{{MOV{8,WA{3,SRTSN{{STORE NUMBER OF ITEMS (IN BAUS){29882
{{MOV{8,WC{3,SRTSO{{STORE OFFSET TO A(0){29883
{{MOV{13,ARLEN(XL){8,WC{{LENGTH OF ARRAY OR VEC (=VCLEN){29884
{{ADD{7,XL{8,WC{{POINT PAST END OF ARRAY OR VECTOR{29885
{{MOV{8,WB{3,SRTSF{{STORE OFFSET TO FIRST ROW{29886
{{ADD{8,WB{7,XL{{POINT TO FIRST ITEM IN KEY ARRAY{29887
*
*      LOOP THROUGH ARRAY
*
{SRT05{MOV{9,(XL){7,XR{{GET AN ENTRY{29891
*
*      HUNT ALONG TRBLK CHAIN
*
{SRT06{BNE{9,(XR){22,=B$TRT{6,SRT07{JUMP OUT IF NOT TRBLK{29895
{{MOV{13,TRVAL(XR){7,XR{{GET VALUE FIELD{29896
{{BRN{6,SRT06{{{LOOP{29897
{{EJC{{{{{29898
*
*      SORTA (CONTINUED)
*
*      XR IS VALUE FROM END OF CHAIN
*
{SRT07{MOV{7,XR{10,(XL)+{{STORE AS ARRAY ENTRY{29904
{{BLT{7,XL{8,WC{6,SRT05{LOOP IF NOT DONE{29905
{{MOV{9,(XS){7,XL{{GET ADRS OF SORT ARRAY{29906
{{MOV{3,SRTSF{7,XR{{INITIAL OFFSET TO FIRST KEY{29907
{{MOV{3,SRTST{8,WB{{GET STRIDE{29908
{{ADD{3,SRTSO{7,XL{{OFFSET TO A(0){29909
{{ICA{7,XL{{{POINT TO A(1){29910
{{MOV{3,SRTSN{8,WC{{GET N{29911
{{BTW{8,WC{{{CONVERT FROM BYTES{29912
{{MOV{8,WC{3,SRTNR{{STORE AS ROW COUNT{29913
{{LCT{8,WC{8,WC{{LOOP COUNTER{29914
*
*      STORE KEY OFFSETS AT TOP OF SORT ARRAY
*
{SRT08{MOV{7,XR{10,(XL)+{{STORE AN OFFSET{29918
{{ADD{8,WB{7,XR{{BUMP OFFSET BY STRIDE{29919
{{BCT{8,WC{6,SRT08{{LOOP THROUGH ROWS{29920
*
*      PERFORM THE SORT ON OFFSETS IN SORT ARRAY.
*
*      (SRTSN)               NUMBER OF ITEMS TO SORT, N (BYTES)
*      (SRTSO)               OFFSET TO A(0)
*
{SRT09{MOV{3,SRTSN{8,WA{{GET N{29927
{{MOV{3,SRTNR{8,WC{{GET NUMBER OF ROWS{29928
{{RSH{8,WC{1,1{{I = N / 2 (WC=I, INDEX INTO ARRAY){29929
{{WTB{8,WC{{{CONVERT BACK TO BYTES{29930
*
*      LOOP TO FORM INITIAL HEAP
*
{SRT10{JSR{6,SORTH{{{SORTH(I,N){29934
{{DCA{8,WC{{{I = I - 1{29935
{{BNZ{8,WC{6,SRT10{{LOOP IF I GT 0{29936
{{MOV{8,WA{8,WC{{I = N{29937
*
*      SORTING LOOP. AT THIS POINT, A(1) IS THE LARGEST
*      ITEM, SINCE ALGORITHM INITIALISES IT AS, AND THEN MAINTAINS
*      IT AS, ROOT OF TREE.
*
{SRT11{DCA{8,WC{{{I = I - 1 (N - 1 INITIALLY){29943
{{BZE{8,WC{6,SRT12{{JUMP IF DONE{29944
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADDRESS{29945
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){29946
{{MOV{7,XR{7,XL{{A(0) ADDRESS{29947
{{ADD{8,WC{7,XL{{A(I) ADDRESS{29948
{{MOV{13,NUM01(XL){8,WB{{COPY A(I+1){29949
{{MOV{13,NUM01(XR){13,NUM01(XL){{MOVE A(1) TO A(I+1){29950
{{MOV{8,WB{13,NUM01(XR){{COMPLETE EXCHANGE OF A(1), A(I+1){29951
{{MOV{8,WC{8,WA{{N = I FOR SORTH{29952
{{MOV{19,*NUM01{8,WC{{I = 1 FOR SORTH{29953
{{JSR{6,SORTH{{{SORTH(1,N){29954
{{MOV{8,WA{8,WC{{RESTORE WC{29955
{{BRN{6,SRT11{{{LOOP{29956
{{EJC{{{{{29957
*
*      SORTA (CONTINUED)
*
*      OFFSETS HAVE BEEN PERMUTED INTO REQUIRED ORDER BY SORT.
*      COPY ARRAY ELEMENTS OVER THEM.
*
{SRT12{MOV{9,(XS){7,XR{{BASE ADRS OF KEY ARRAY{29964
{{MOV{7,XR{8,WC{{COPY IT{29965
{{ADD{3,SRTSO{8,WC{{OFFSET OF A(0){29966
{{ADD{3,SRTSF{7,XR{{ADRS OF FIRST ROW OF SORT ARRAY{29967
{{MOV{3,SRTST{8,WB{{GET STRIDE{29968
*
*      COPYING LOOP FOR SUCCESSIVE ITEMS. SORTED OFFSETS ARE
*      HELD AT END OF SORT ARRAY.
*
{SRT13{ICA{8,WC{{{ADRS OF NEXT OF SORTED OFFSETS{29973
{{MOV{8,WC{7,XL{{COPY IT FOR ACCESS{29974
{{MOV{9,(XL){7,XL{{GET OFFSET{29975
{{ADD{13,NUM01(XS){7,XL{{ADD KEY ARRAY BASE ADRS{29976
{{MOV{8,WB{8,WA{{GET COUNT OF CHARACTERS IN ROW{29977
{{MVW{{{{COPY A COMPLETE ROW{29978
{{DCV{3,SRTNR{{{DECREMENT ROW COUNT{29979
{{BNZ{3,SRTNR{6,SRT13{{REPEAT TILL ALL ROWS DONE{29980
*
*      RETURN POINT
*
{SRT15{MOV{10,(XS)+{7,XR{{POP RESULT ARRAY PTR{29984
{{ICA{7,XS{{{POP KEY ARRAY PTR{29985
{{ZER{3,R$SXL{{{CLEAR JUNK{29986
{{ZER{3,R$SXR{{{CLEAR JUNK{29987
{{EXI{{{{RETURN{29988
*
*      ERROR POINT
*
{SRT16{ERB{1,256{26,SORT/RSORT 1st arg not suitable ARRAY or TABLE{{{29992
{SRT17{ERB{1,258{26,SORT/RSORT 2nd arg out of range or non-integer{{{29993
*
*      RETURN POINT IF INPUT TABLE IS EMPTY
*
{SRT18{EXI{1,1{{{RETURN INDICATION OF NULL TABLE{29997
{{ENP{{{{END PROCUDURE SORTA{29998
{{EJC{{{{{29999
*
*      SORTC --  COMPARE SORT KEYS
*
*      COMPARE TWO SORT KEYS GIVEN THEIR OFFSETS. IF
*      EQUAL, COMPARE KEY OFFSETS TO GIVE STABLE SORT.
*      NOTE THAT IF SRTSR IS NON-ZERO (REQUEST FOR REVERSE
*      SORT), THE QUOTED RETURNS ARE INVERTED.
*      FOR OBJECTS OF DIFFERING DATATYPES, THE ENTRY POINT
*      IDENTIFICATIONS ARE COMPARED.
*
*      (XL)                  BASE ADRS FOR KEYS
*      (WA)                  OFFSET TO KEY 1 ITEM
*      (WB)                  OFFSET TO KEY 2 ITEM
*      (SRTSR)               ZERO/NON-ZERO FOR SORT/RSORT
*      (SRTOF)               OFFSET WITHIN ROW TO COMPARANDS
*      JSR  SORTC            CALL TO COMPARE KEYS
*      PPM  LOC              KEY1 LESS THAN KEY2
*                            NORMAL RETURN, KEY1 GT THAN KEY2
*      (XL,XR,WA,WB)         DESTROYED
*
{SORTC{PRC{25,E{1,1{{ENTRY POINT{30020
{{MOV{8,WA{3,SRTS1{{SAVE OFFSET 1{30021
{{MOV{8,WB{3,SRTS2{{SAVE OFFSET 2{30022
{{MOV{8,WC{3,SRTSC{{SAVE WC{30023
{{ADD{3,SRTOF{7,XL{{ADD OFFSET TO COMPARAND FIELD{30024
{{MOV{7,XL{7,XR{{COPY BASE + OFFSET{30025
{{ADD{8,WA{7,XL{{ADD KEY1 OFFSET{30026
{{ADD{8,WB{7,XR{{ADD KEY2 OFFSET{30027
{{MOV{9,(XL){7,XL{{GET KEY1{30028
{{MOV{9,(XR){7,XR{{GET KEY2{30029
{{BNE{3,SRTDF{21,=NULLS{6,SRC12{JUMP IF DATATYPE FIELD NAME USED{30030
{{EJC{{{{{30031
*
*      SORTC (CONTINUED)
*
*      MERGE AFTER DEALING WITH FIELD NAME. TRY FOR STRINGS.
*
{SRC01{MOV{9,(XL){8,WC{{GET TYPE CODE{30037
{{BNE{8,WC{9,(XR){6,SRC02{SKIP IF NOT SAME DATATYPE{30038
{{BEQ{8,WC{22,=B$SCL{6,SRC09{JUMP IF BOTH STRINGS{30039
{{BEQ{8,WC{22,=B$ICL{6,SRC14{JUMP IF BOTH INTEGERS{30040
*
*      DATATYPES DIFFERENT.  NOW TRY FOR NUMERIC
*
{SRC02{MOV{7,XL{3,R$SXL{{KEEP ARG1{30048
{{MOV{7,XR{3,R$SXR{{KEEP ARG2{30049
{{BEQ{8,WC{22,=B$SCL{6,SRC11{DO NOT ALLOW CONVERSION TO NUMBER{30052
{{BEQ{9,(XR){22,=B$SCL{6,SRC11{IF EITHER ARG IS A STRING{30053
{SRC14{MOV{7,XL{11,-(XS){{STACK{30096
{{MOV{7,XR{11,-(XS){{ARGS{30097
{{JSR{6,ACOMP{{{COMPARE OBJECTS{30098
{{PPM{6,SRC10{{{NOT NUMERIC{30099
{{PPM{6,SRC10{{{NOT NUMERIC{30100
{{PPM{6,SRC03{{{KEY1 LESS{30101
{{PPM{6,SRC08{{{KEYS EQUAL{30102
{{PPM{6,SRC05{{{KEY1 GREATER{30103
*
*      RETURN IF KEY1 SMALLER (SORT), GREATER (RSORT)
*
{SRC03{BNZ{3,SRTSR{6,SRC06{{JUMP IF RSORT{30107
*
{SRC04{MOV{3,SRTSC{8,WC{{RESTORE WC{30109
{{EXI{1,1{{{RETURN{30110
*
*      RETURN IF KEY1 GREATER (SORT), SMALLER (RSORT)
*
{SRC05{BNZ{3,SRTSR{6,SRC04{{JUMP IF RSORT{30114
*
{SRC06{MOV{3,SRTSC{8,WC{{RESTORE WC{30116
{{EXI{{{{RETURN{30117
*
*      KEYS ARE OF SAME DATATYPE
*
{SRC07{BLT{7,XL{7,XR{6,SRC03{ITEM FIRST CREATED IS LESS{30121
{{BGT{7,XL{7,XR{6,SRC05{ADDRESSES RISE IN ORDER OF CREATION{30122
*
*      DROP THROUGH OR MERGE FOR IDENTICAL OR EQUAL OBJECTS
*
{SRC08{BLT{3,SRTS1{3,SRTS2{6,SRC04{TEST OFFSETS OR KEY ADDRSS INSTEAD{30126
{{BRN{6,SRC06{{{OFFSET 1 GREATER{30127
{{EJC{{{{{30128
*
*      SORTC (CONTINUED)
*
*      STRINGS
*
{SRC09{MOV{7,XL{11,-(XS){{STACK{30138
{{MOV{7,XR{11,-(XS){{ARGS{30139
{{JSR{6,LCOMP{{{COMPARE OBJECTS{30140
{{PPM{{{{CANT{30141
{{PPM{{{{FAIL{30142
{{PPM{6,SRC03{{{KEY1 LESS{30143
{{PPM{6,SRC08{{{KEYS EQUAL{30144
{{PPM{6,SRC05{{{KEY1 GREATER{30145
*
*      ARITHMETIC COMPARISON FAILED - RECOVER ARGS
*
{SRC10{MOV{3,R$SXL{7,XL{{GET ARG1{30149
{{MOV{3,R$SXR{7,XR{{GET ARG2{30150
{{MOV{9,(XL){8,WC{{GET TYPE OF KEY1{30151
{{BEQ{8,WC{9,(XR){6,SRC07{JUMP IF KEYS OF SAME TYPE{30152
*
*      HERE TO COMPARE DATATYPE IDS
*
{SRC11{MOV{8,WC{7,XL{{GET BLOCK TYPE WORD{30156
{{MOV{9,(XR){7,XR{{GET BLOCK TYPE WORD{30157
{{LEI{7,XL{{{ENTRY POINT ID FOR KEY1{30158
{{LEI{7,XR{{{ENTRY POINT ID FOR KEY2{30159
{{BGT{7,XL{7,XR{6,SRC05{JUMP IF KEY1 GT KEY2{30160
{{BRN{6,SRC03{{{KEY1 LT KEY2{30161
*
*      DATATYPE FIELD NAME USED
*
{SRC12{JSR{6,SORTF{{{CALL ROUTINE TO FIND FIELD 1{30165
{{MOV{7,XL{11,-(XS){{STACK ITEM POINTER{30166
{{MOV{7,XR{7,XL{{GET KEY2{30167
{{JSR{6,SORTF{{{FIND FIELD 2{30168
{{MOV{7,XL{7,XR{{PLACE AS KEY2{30169
{{MOV{10,(XS)+{7,XL{{RECOVER KEY1{30170
{{BRN{6,SRC01{{{MERGE{30171
{{ENP{{{{PROCEDURE SORTC{30172
{{EJC{{{{{30173
*
*      SORTF -- FIND FIELD FOR SORTC
*
*      ROUTINE USED BY SORTC TO OBTAIN ITEM CORRESPONDING
*      TO A GIVEN FIELD NAME, IF THIS EXISTS, IN A PROGRAMMER
*      DEFINED OBJECT PASSED AS ARGUMENT.
*      IF SUCH A MATCH OCCURS, RECORD IS KEPT OF DATATYPE
*      NAME, FIELD NAME AND OFFSET TO FIELD IN ORDER TO
*      SHORT-CIRCUIT LATER SEARCHES ON SAME TYPE. NOTE THAT
*      DFBLKS ARE STORED IN STATIC AND HENCE CANNOT BE MOVED.
*
*      (SRTDF)               VRBLK POINTER OF FIELD NAME
*      (XL)                  POSSIBLE PDBLK POINTER
*      JSR  SORTF            CALL TO SEARCH FOR FIELD NAME
*      (XL)                  ITEM FOUND OR ORIGINAL PDBLK PTR
*      (WC)                  DESTROYED
*
{SORTF{PRC{25,E{1,0{{ENTRY POINT{30191
{{BNE{9,(XL){22,=B$PDT{6,SRTF3{RETURN IF NOT PDBLK{30192
{{MOV{7,XR{11,-(XS){{KEEP XR{30193
{{MOV{3,SRTFD{7,XR{{GET POSSIBLE FORMER DFBLK PTR{30194
{{BZE{7,XR{6,SRTF4{{JUMP IF NOT{30195
{{BNE{7,XR{13,PDDFP(XL){6,SRTF4{JUMP IF NOT RIGHT DATATYPE{30196
{{BNE{3,SRTDF{3,SRTFF{6,SRTF4{JUMP IF NOT RIGHT FIELD NAME{30197
{{ADD{3,SRTFO{7,XL{{ADD OFFSET TO REQUIRED FIELD{30198
*
*      HERE WITH XL POINTING TO FOUND FIELD
*
{SRTF1{MOV{9,(XL){7,XL{{GET ITEM FROM FIELD{30202
*
*      RETURN POINT
*
{SRTF2{MOV{10,(XS)+{7,XR{{RESTORE XR{30206
*
{SRTF3{EXI{{{{RETURN{30208
{{EJC{{{{{30209
*
*      SORTF (CONTINUED)
*
*      CONDUCT A SEARCH
*
{SRTF4{MOV{7,XL{7,XR{{COPY ORIGINAL POINTER{30215
{{MOV{13,PDDFP(XR){7,XR{{POINT TO DFBLK{30216
{{MOV{7,XR{3,SRTFD{{KEEP A COPY{30217
{{MOV{13,FARGS(XR){8,WC{{GET NUMBER OF FIELDS{30218
{{WTB{8,WC{{{CONVERT TO BYTES{30219
{{ADD{13,DFLEN(XR){7,XR{{POINT PAST LAST FIELD{30220
*
*      LOOP TO FIND NAME IN PDFBLK
*
{SRTF5{DCA{8,WC{{{COUNT DOWN{30224
{{DCA{7,XR{{{POINT IN FRONT{30225
{{BEQ{9,(XR){3,SRTDF{6,SRTF6{SKIP OUT IF FOUND{30226
{{BNZ{8,WC{6,SRTF5{{LOOP{30227
{{BRN{6,SRTF2{{{RETURN - NOT FOUND{30228
*
*      FOUND
*
{SRTF6{MOV{9,(XR){3,SRTFF{{KEEP FIELD NAME PTR{30232
{{ADD{19,*PDFLD{8,WC{{ADD OFFSET TO FIRST FIELD{30233
{{MOV{8,WC{3,SRTFO{{STORE AS FIELD OFFSET{30234
{{ADD{8,WC{7,XL{{POINT TO FIELD{30235
{{BRN{6,SRTF1{{{RETURN{30236
{{ENP{{{{PROCEDURE SORTF{30237
{{EJC{{{{{30238
*
*      SORTH -- HEAP ROUTINE FOR SORTA
*
*      THIS ROUTINE CONSTRUCTS A HEAP FROM ELEMENTS OF ARRAY, A.
*      IN THIS APPLICATION, THE ELEMENTS ARE OFFSETS TO KEYS IN
*      A KEY ARRAY.
*
*      (XS)                  POINTER TO SORT ARRAY BASE
*      1(XS)                 POINTER TO KEY ARRAY BASE
*      (WA)                  MAX ARRAY INDEX, N (IN BYTES)
*      (WC)                  OFFSET J IN A TO ROOT (IN *1 TO *N)
*      JSR  SORTH            CALL SORTH(J,N) TO MAKE HEAP
*      (XL,XR,WB)            DESTROYED
*
{SORTH{PRC{25,N{1,0{{ENTRY POINT{30253
{{MOV{8,WA{3,SRTSN{{SAVE N{30254
{{MOV{8,WC{3,SRTWC{{KEEP WC{30255
{{MOV{9,(XS){7,XL{{SORT ARRAY BASE ADRS{30256
{{ADD{3,SRTSO{7,XL{{ADD OFFSET TO A(0){30257
{{ADD{8,WC{7,XL{{POINT TO A(J){30258
{{MOV{9,(XL){3,SRTRT{{GET OFFSET TO ROOT{30259
{{ADD{8,WC{8,WC{{DOUBLE J - CANT EXCEED N{30260
*
*      LOOP TO MOVE DOWN TREE USING DOUBLED INDEX J
*
{SRH01{BGT{8,WC{3,SRTSN{6,SRH03{DONE IF J GT N{30264
{{BEQ{8,WC{3,SRTSN{6,SRH02{SKIP IF J EQUALS N{30265
{{MOV{9,(XS){7,XR{{SORT ARRAY BASE ADRS{30266
{{MOV{13,NUM01(XS){7,XL{{KEY ARRAY BASE ADRS{30267
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){30268
{{ADD{8,WC{7,XR{{ADRS OF A(J){30269
{{MOV{13,NUM01(XR){8,WA{{GET A(J+1){30270
{{MOV{9,(XR){8,WB{{GET A(J){30271
*
*      COMPARE SONS. (WA) RIGHT SON, (WB) LEFT SON
*
{{JSR{6,SORTC{{{COMPARE KEYS - LT(A(J+1),A(J)){30275
{{PPM{6,SRH02{{{A(J+1) LT A(J){30276
{{ICA{8,WC{{{POINT TO GREATER SON, A(J+1){30277
{{EJC{{{{{30278
*
*      SORTH (CONTINUED)
*
*      COMPARE ROOT WITH GREATER SON
*
{SRH02{MOV{13,NUM01(XS){7,XL{{KEY ARRAY BASE ADRS{30284
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADDRESS{30285
{{ADD{3,SRTSO{7,XR{{ADRS OF A(0){30286
{{MOV{7,XR{8,WB{{COPY THIS ADRS{30287
{{ADD{8,WC{7,XR{{ADRS OF GREATER SON, A(J){30288
{{MOV{9,(XR){8,WA{{GET A(J){30289
{{MOV{8,WB{7,XR{{POINT BACK TO A(0){30290
{{MOV{3,SRTRT{8,WB{{GET ROOT{30291
{{JSR{6,SORTC{{{COMPARE THEM - LT(A(J),ROOT){30292
{{PPM{6,SRH03{{{FATHER EXCEEDS SONS - DONE{30293
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADRS{30294
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){30295
{{MOV{7,XR{7,XL{{COPY IT{30296
{{MOV{8,WC{8,WA{{COPY J{30297
{{BTW{8,WC{{{CONVERT TO WORDS{30298
{{RSH{8,WC{1,1{{GET J/2{30299
{{WTB{8,WC{{{CONVERT BACK TO BYTES{30300
{{ADD{8,WA{7,XL{{POINT TO A(J){30301
{{ADD{8,WC{7,XR{{ADRS OF A(J/2){30302
{{MOV{9,(XL){9,(XR){{A(J/2) = A(J){30303
{{MOV{8,WA{8,WC{{RECOVER J{30304
{{AOV{8,WC{8,WC{6,SRH03{J = J*2. DONE IF TOO BIG{30305
{{BRN{6,SRH01{{{LOOP{30306
*
*      FINISH BY COPYING ROOT OFFSET BACK INTO ARRAY
*
{SRH03{BTW{8,WC{{{CONVERT TO WORDS{30310
{{RSH{8,WC{1,1{{J = J/2{30311
{{WTB{8,WC{{{CONVERT BACK TO BYTES{30312
{{MOV{9,(XS){7,XR{{SORT ARRAY ADRS{30313
{{ADD{3,SRTSO{7,XR{{ADRS OF A(0){30314
{{ADD{8,WC{7,XR{{ADRS OF A(J/2){30315
{{MOV{3,SRTRT{9,(XR){{A(J/2) = ROOT{30316
{{MOV{3,SRTSN{8,WA{{RESTORE WA{30317
{{MOV{3,SRTWC{8,WC{{RESTORE WC{30318
{{EXI{{{{RETURN{30319
{{ENP{{{{END PROCEDURE SORTH{30320
{{EJC{{{{{30322
*
*      TRACE -- SET/RESET A TRACE ASSOCIATION
*
*      THIS PROCEDURE IS SHARED BY TRACE AND STOPTR TO
*      EITHER INITIATE OR STOP A TRACE RESPECTIVELY.
*
*      (XL)                  TRBLK PTR (TRACE) OR ZERO (STOPTR)
*      1(XS)                 FIRST ARGUMENT (NAME)
*      0(XS)                 SECOND ARGUMENT (TRACE TYPE)
*      JSR  TRACE            CALL TO SET/RESET TRACE
*      PPM  LOC              TRANSFER LOC IF 1ST ARG IS BAD NAME
*      PPM  LOC              TRANSFER LOC IF 2ND ARG IS BAD TYPE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{TRACE{PRC{25,N{1,2{{ENTRY POINT{30338
{{JSR{6,GTSTG{{{GET TRACE TYPE STRING{30339
{{PPM{6,TRC15{{{JUMP IF NOT STRING{30340
{{PLC{7,XR{{{ELSE POINT TO STRING{30341
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{30342
{{FLC{8,WA{{{FOLD TO UPPER CASE{30344
{{MOV{9,(XS){7,XR{{LOAD NAME ARGUMENT{30346
{{MOV{7,XL{9,(XS){{STACK TRBLK PTR OR ZERO{30347
{{MOV{18,=TRTAC{8,WC{{SET TRTYP FOR ACCESS TRACE{30348
{{BEQ{8,WA{18,=CH$LA{6,TRC10{JUMP IF A (ACCESS){30349
{{MOV{18,=TRTVL{8,WC{{SET TRTYP FOR VALUE TRACE{30350
{{BEQ{8,WA{18,=CH$LV{6,TRC10{JUMP IF V (VALUE){30351
{{BEQ{8,WA{18,=CH$BL{6,TRC10{JUMP IF BLANK (VALUE){30352
*
*      HERE FOR L,K,F,C,R
*
{{BEQ{8,WA{18,=CH$LF{6,TRC01{JUMP IF F (FUNCTION){30356
{{BEQ{8,WA{18,=CH$LR{6,TRC01{JUMP IF R (RETURN){30357
{{BEQ{8,WA{18,=CH$LL{6,TRC03{JUMP IF L (LABEL){30358
{{BEQ{8,WA{18,=CH$LK{6,TRC06{JUMP IF K (KEYWORD){30359
{{BNE{8,WA{18,=CH$LC{6,TRC15{ELSE ERROR IF NOT C (CALL){30360
*
*      HERE FOR F,C,R
*
{TRC01{JSR{6,GTNVR{{{POINT TO VRBLK FOR NAME{30364
{{PPM{6,TRC16{{{JUMP IF BAD NAME{30365
{{ICA{7,XS{{{POP STACK{30366
{{MOV{13,VRFNC(XR){7,XR{{POINT TO FUNCTION BLOCK{30367
{{BNE{9,(XR){22,=B$PFC{6,TRC17{ERROR IF NOT PROGRAM FUNCTION{30368
{{BEQ{8,WA{18,=CH$LR{6,TRC02{JUMP IF R (RETURN){30369
{{EJC{{{{{30370
*
*      TRACE (CONTINUED)
*
*      HERE FOR F,C TO SET/RESET CALL TRACE
*
{{MOV{7,XL{13,PFCTR(XR){{SET/RESET CALL TRACE{30376
{{BEQ{8,WA{18,=CH$LC{6,EXNUL{EXIT WITH NULL IF C (CALL){30377
*
*      HERE FOR F,R TO SET/RESET RETURN TRACE
*
{TRC02{MOV{7,XL{13,PFRTR(XR){{SET/RESET RETURN TRACE{30381
{{EXI{{{{RETURN{30382
*
*      HERE FOR L TO SET/RESET LABEL TRACE
*
{TRC03{JSR{6,GTNVR{{{POINT TO VRBLK{30386
{{PPM{6,TRC16{{{JUMP IF BAD NAME{30387
{{MOV{13,VRLBL(XR){7,XL{{LOAD LABEL POINTER{30388
{{BNE{9,(XL){22,=B$TRT{6,TRC04{JUMP IF NO OLD TRACE{30389
{{MOV{13,TRLBL(XL){7,XL{{ELSE DELETE OLD TRACE ASSOCIATION{30390
*
*      HERE WITH OLD LABEL TRACE ASSOCIATION DELETED
*
{TRC04{BEQ{7,XL{21,=STNDL{6,TRC16{ERROR IF UNDEFINED LABEL{30394
{{MOV{10,(XS)+{8,WB{{GET TRBLK PTR AGAIN{30395
{{BZE{8,WB{6,TRC05{{JUMP IF STOPTR CASE{30396
{{MOV{8,WB{13,VRLBL(XR){{ELSE SET NEW TRBLK POINTER{30397
{{MOV{22,=B$VRT{13,VRTRA(XR){{SET LABEL TRACE ROUTINE ADDRESS{30398
{{MOV{8,WB{7,XR{{COPY TRBLK POINTER{30399
{{MOV{7,XL{13,TRLBL(XR){{STORE REAL LABEL IN TRBLK{30400
{{EXI{{{{RETURN{30401
*
*      HERE FOR STOPTR CASE FOR LABEL
*
{TRC05{MOV{7,XL{13,VRLBL(XR){{STORE LABEL PTR BACK IN VRBLK{30405
{{MOV{22,=B$VRG{13,VRTRA(XR){{STORE NORMAL TRANSFER ADDRESS{30406
{{EXI{{{{RETURN{30407
{{EJC{{{{{30408
*
*      TRACE (CONTINUED)
*
*      HERE FOR K (KEYWORD)
*
{TRC06{JSR{6,GTNVR{{{POINT TO VRBLK{30414
{{PPM{6,TRC16{{{ERROR IF NOT NATURAL VAR{30415
{{BNZ{13,VRLEN(XR){6,TRC16{{ERROR IF NOT SYSTEM VAR{30416
{{ICA{7,XS{{{POP STACK{30417
{{BZE{7,XL{6,TRC07{{JUMP IF STOPTR CASE{30418
{{MOV{7,XR{13,TRKVR(XL){{STORE VRBLK PTR IN TRBLK FOR KTREX{30419
*
*      MERGE HERE WITH TRBLK SET UP IN WB (OR ZERO)
*
{TRC07{MOV{13,VRSVP(XR){7,XR{{POINT TO SVBLK{30423
{{BEQ{7,XR{21,=V$ERT{6,TRC08{JUMP IF ERRTYPE{30424
{{BEQ{7,XR{21,=V$STC{6,TRC09{JUMP IF STCOUNT{30425
{{BNE{7,XR{21,=V$FNC{6,TRC17{ELSE ERROR IF NOT FNCLEVEL{30426
*
*      FNCLEVEL
*
{{MOV{7,XL{3,R$FNC{{SET/RESET FNCLEVEL TRACE{30430
{{EXI{{{{RETURN{30431
*
*      ERRTYPE
*
{TRC08{MOV{7,XL{3,R$ERT{{SET/RESET ERRTYPE TRACE{30435
{{EXI{{{{RETURN{30436
*
*      STCOUNT
*
{TRC09{MOV{7,XL{3,R$STC{{SET/RESET STCOUNT TRACE{30440
{{JSR{6,STGCC{{{UPDATE COUNTDOWN COUNTERS{30441
{{EXI{{{{RETURN{30442
{{EJC{{{{{30443
*
*      TRACE (CONTINUED)
*
*      A,V MERGE HERE WITH TRTYP VALUE IN WC
*
{TRC10{JSR{6,GTVAR{{{LOCATE VARIABLE{30449
{{PPM{6,TRC16{{{ERROR IF NOT APPROPRIATE NAME{30450
{{MOV{10,(XS)+{8,WB{{GET NEW TRBLK PTR AGAIN{30451
{{ADD{7,XL{8,WA{{POINT TO VARIABLE LOCATION{30452
{{MOV{8,WA{7,XR{{COPY VARIABLE POINTER{30453
*
*      LOOP TO SEARCH TRBLK CHAIN
*
{TRC11{MOV{9,(XR){7,XL{{POINT TO NEXT ENTRY{30457
{{BNE{9,(XL){22,=B$TRT{6,TRC13{JUMP IF NOT TRBLK{30458
{{BLT{8,WC{13,TRTYP(XL){6,TRC13{JUMP IF TOO FAR OUT ON CHAIN{30459
{{BEQ{8,WC{13,TRTYP(XL){6,TRC12{JUMP IF THIS MATCHES OUR TYPE{30460
{{ADD{19,*TRNXT{7,XL{{ELSE POINT TO LINK FIELD{30461
{{MOV{7,XL{7,XR{{COPY POINTER{30462
{{BRN{6,TRC11{{{AND LOOP BACK{30463
*
*      HERE TO DELETE AN OLD TRBLK OF THE TYPE WE WERE GIVEN
*
{TRC12{MOV{13,TRNXT(XL){7,XL{{GET PTR TO NEXT BLOCK OR VALUE{30467
{{MOV{7,XL{9,(XR){{STORE TO DELETE THIS TRBLK{30468
*
*      HERE AFTER DELETING ANY OLD ASSOCIATION OF THIS TYPE
*
{TRC13{BZE{8,WB{6,TRC14{{JUMP IF STOPTR CASE{30472
{{MOV{8,WB{9,(XR){{ELSE LINK NEW TRBLK IN{30473
{{MOV{8,WB{7,XR{{COPY TRBLK POINTER{30474
{{MOV{7,XL{13,TRNXT(XR){{STORE FORWARD POINTER{30475
{{MOV{8,WC{13,TRTYP(XR){{STORE APPROPRIATE TRAP TYPE CODE{30476
*
*      HERE TO MAKE SURE VRGET,VRSTO ARE SET PROPERLY
*
{TRC14{MOV{8,WA{7,XR{{RECALL POSSIBLE VRBLK POINTER{30480
{{SUB{19,*VRVAL{7,XR{{POINT BACK TO VRBLK{30481
{{JSR{6,SETVR{{{SET FIELDS IF VRBLK{30482
{{EXI{{{{RETURN{30483
*
*      HERE FOR BAD TRACE TYPE
*
{TRC15{EXI{1,2{{{TAKE BAD TRACE TYPE ERROR EXIT{30487
*
*      POP STACK BEFORE FAILING
*
{TRC16{ICA{7,XS{{{POP STACK{30491
*
*      HERE FOR BAD NAME ARGUMENT
*
{TRC17{EXI{1,1{{{TAKE BAD NAME ERROR EXIT{30495
{{ENP{{{{END PROCEDURE TRACE{30496
{{EJC{{{{{30497
*
*      TRBLD -- BUILD TRBLK
*
*      TRBLK IS USED BY THE INPUT, OUTPUT AND TRACE FUNCTIONS
*      TO CONSTRUCT A TRBLK (TRAP BLOCK)
*
*      (XR)                  TRTAG OR TRTER
*      (XL)                  TRFNC OR TRFPT
*      (WB)                  TRTYP
*      JSR  TRBLD            CALL TO BUILD TRBLK
*      (XR)                  POINTER TO TRBLK
*      (WA)                  DESTROYED
*
{TRBLD{PRC{25,E{1,0{{ENTRY POINT{30511
{{MOV{7,XR{11,-(XS){{STACK TRTAG (OR TRFNM){30512
{{MOV{19,*TRSI${8,WA{{SET SIZE OF TRBLK{30513
{{JSR{6,ALLOC{{{ALLOCATE TRBLK{30514
{{MOV{22,=B$TRT{9,(XR){{STORE FIRST WORD{30515
{{MOV{7,XL{13,TRFNC(XR){{STORE TRFNC (OR TRFPT){30516
{{MOV{10,(XS)+{13,TRTAG(XR){{STORE TRTAG (OR TRFNM){30517
{{MOV{8,WB{13,TRTYP(XR){{STORE TYPE{30518
{{MOV{21,=NULLS{13,TRVAL(XR){{FOR NOW, A NULL VALUE{30519
{{EXI{{{{RETURN TO CALLER{30520
{{ENP{{{{END PROCEDURE TRBLD{30521
{{EJC{{{{{30522
*
*      TRIMR -- TRIM TRAILING BLANKS
*
*      TRIMR IS PASSED A POINTER TO AN SCBLK WHICH MUST BE THE
*      LAST BLOCK IN DYNAMIC STORAGE. TRAILING BLANKS ARE
*      TRIMMED OFF AND THE DYNAMIC STORAGE POINTER RESET TO
*      THE END OF THE (POSSIBLY) SHORTENED BLOCK.
*
*      (WB)                  NON-ZERO TO TRIM TRAILING BLANKS
*      (XR)                  POINTER TO STRING TO TRIM
*      JSR  TRIMR            CALL TO TRIM STRING
*      (XR)                  POINTER TO TRIMMED STRING
*      (XL,WA,WB,WC)         DESTROYED
*
*      THE CALL WITH WB ZERO STILL PERFORMS THE END ZERO PAD
*      AND DNAMP READJUSTMENT. IT IS USED FROM ACESS IF KVTRM=0.
*
{TRIMR{PRC{25,E{1,0{{ENTRY POINT{30540
{{MOV{7,XR{7,XL{{COPY STRING POINTER{30541
{{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{30542
{{BZE{8,WA{6,TRIM2{{JUMP IF NULL INPUT{30543
{{PLC{7,XL{8,WA{{ELSE POINT PAST LAST CHARACTER{30544
{{BZE{8,WB{6,TRIM3{{JUMP IF NO TRIM{30545
{{MOV{18,=CH$BL{8,WC{{LOAD BLANK CHARACTER{30546
*
*      LOOP THROUGH CHARACTERS FROM RIGHT TO LEFT
*
{TRIM0{LCH{8,WB{11,-(XL){{LOAD NEXT CHARACTER{30550
{{BEQ{8,WB{18,=CH$HT{6,TRIM1{JUMP IF HORIZONTAL TAB{30552
{{BNE{8,WB{8,WC{6,TRIM3{JUMP IF NON-BLANK FOUND{30554
{TRIM1{DCV{8,WA{{{ELSE DECREMENT CHARACTER COUNT{30555
{{BNZ{8,WA{6,TRIM0{{LOOP BACK IF MORE TO CHECK{30556
*
*      HERE IF RESULT IS NULL (NULL OR ALL-BLANK INPUT)
*
{TRIM2{MOV{7,XR{3,DNAMP{{WIPE OUT INPUT STRING BLOCK{30560
{{MOV{21,=NULLS{7,XR{{LOAD NULL RESULT{30561
{{BRN{6,TRIM5{{{MERGE TO EXIT{30562
{{EJC{{{{{30563
*
*      TRIMR (CONTINUED)
*
*      HERE WITH NON-BLANK FOUND (MERGE FOR NO TRIM)
*
{TRIM3{MOV{8,WA{13,SCLEN(XR){{SET NEW LENGTH{30569
{{MOV{7,XR{7,XL{{COPY STRING POINTER{30570
{{PSC{7,XL{8,WA{{READY FOR STORING BLANKS{30571
{{CTB{8,WA{2,SCHAR{{GET LENGTH OF BLOCK IN BYTES{30572
{{ADD{7,XR{8,WA{{POINT PAST NEW BLOCK{30573
{{MOV{8,WA{3,DNAMP{{SET NEW TOP OF STORAGE POINTER{30574
{{LCT{8,WA{18,=CFP$C{{GET COUNT OF CHARS IN WORD{30575
{{ZER{8,WC{{{SET ZERO CHAR{30576
*
*      LOOP TO ZERO PAD LAST WORD OF CHARACTERS
*
{TRIM4{SCH{8,WC{10,(XL)+{{STORE ZERO CHARACTER{30580
{{BCT{8,WA{6,TRIM4{{LOOP BACK TILL ALL STORED{30581
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{30582
*
*      COMMON EXIT POINT
*
{TRIM5{ZER{7,XL{{{CLEAR GARBAGE XL POINTER{30586
{{EXI{{{{RETURN TO CALLER{30587
{{ENP{{{{END PROCEDURE TRIMR{30588
{{EJC{{{{{30589
*
*      TRXEQ -- EXECUTE FUNCTION TYPE TRACE
*
*      TRXEQ IS USED TO EXECUTE A TRACE WHEN A FOURTH ARGUMENT
*      HAS BEEN SUPPLIED. TRACE HAS ALREADY BEEN DECREMENTED.
*
*      (XR)                  POINTER TO TRBLK
*      (XL,WA)               NAME BASE,OFFSET FOR VARIABLE
*      JSR  TRXEQ            CALL TO EXECUTE TRACE
*      (WB,WC,RA)            DESTROYED
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE TRACE FUNCTION USING THE CFUNC ROUTINE.
*
*                            TRXEQ RETURN POINT WORD(S)
*                            SAVED VALUE OF TRACE KEYWORD
*                            TRBLK POINTER
*                            NAME BASE
*                            NAME OFFSET
*                            SAVED VALUE OF R$COD
*                            SAVED CODE PTR (-R$COD)
*                            SAVED VALUE OF FLPTR
*      FLPTR --------------- ZERO (DUMMY FAIL OFFSET)
*                            NMBLK FOR VARIABLE NAME
*      XS ------------------ TRACE TAG
*
*      R$COD AND THE CODE PTR ARE SET TO DUMMY VALUES WHICH
*      CAUSE CONTROL TO RETURN TO THE TRXEQ PROCEDURE ON SUCCESS
*      OR FAILURE (TRXEQ IGNORES A FAILURE CONDITION).
*
{TRXEQ{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){30620
{{MOV{3,R$COD{8,WC{{LOAD CODE BLOCK POINTER{30621
{{SCP{8,WB{{{GET CURRENT CODE POINTER{30622
{{SUB{8,WC{8,WB{{MAKE CODE POINTER INTO OFFSET{30623
{{MOV{3,KVTRA{11,-(XS){{STACK TRACE KEYWORD VALUE{30624
{{MOV{7,XR{11,-(XS){{STACK TRBLK POINTER{30625
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{30626
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{30627
{{MOV{8,WC{11,-(XS){{STACK CODE BLOCK POINTER{30628
{{MOV{8,WB{11,-(XS){{STACK CODE POINTER OFFSET{30629
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{30630
{{ZER{11,-(XS){{{SET DUMMY FAIL OFFSET{30631
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{30632
{{ZER{3,KVTRA{{{RESET TRACE KEYWORD TO ZERO{30633
{{MOV{21,=TRXDC{8,WC{{LOAD NEW (DUMMY) CODE BLK POINTER{30634
{{MOV{8,WC{3,R$COD{{SET AS CODE BLOCK POINTER{30635
{{LCP{8,WC{{{AND NEW CODE POINTER{30636
{{EJC{{{{{30637
*
*      TRXEQ (CONTINUED)
*
*      NOW PREPARE ARGUMENTS FOR FUNCTION
*
{{MOV{8,WA{8,WB{{SAVE NAME OFFSET{30643
{{MOV{19,*NMSI${8,WA{{LOAD NMBLK SIZE{30644
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR NMBLK{30645
{{MOV{22,=B$NML{9,(XR){{SET TYPE WORD{30646
{{MOV{7,XL{13,NMBAS(XR){{STORE NAME BASE{30647
{{MOV{8,WB{13,NMOFS(XR){{STORE NAME OFFSET{30648
{{MOV{12,6(XS){7,XL{{RELOAD POINTER TO TRBLK{30649
{{MOV{7,XR{11,-(XS){{STACK NMBLK POINTER (1ST ARGUMENT){30650
{{MOV{13,TRTAG(XL){11,-(XS){{STACK TRACE TAG (2ND ARGUMENT){30651
{{MOV{13,TRFNC(XL){7,XL{{LOAD TRACE VRBLK POINTER{30652
{{MOV{13,VRFNC(XL){7,XL{{LOAD TRACE FUNCTION POINTER{30653
{{BEQ{7,XL{21,=STNDF{6,TRXQ2{JUMP IF NOT A DEFINED FUNCTION{30654
{{MOV{18,=NUM02{8,WA{{SET NUMBER OF ARGUMENTS TO TWO{30655
{{BRN{6,CFUNC{{{JUMP TO CALL FUNCTION{30656
*
*      SEE O$TXR FOR DETAILS OF RETURN TO THIS POINT
*
{TRXQ1{MOV{3,FLPTR{7,XS{{POINT BACK TO OUR STACK ENTRIES{30660
{{ICA{7,XS{{{POP OFF GARBAGE FAIL OFFSET{30661
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{30662
{{MOV{10,(XS)+{8,WB{{RELOAD CODE OFFSET{30663
{{MOV{10,(XS)+{8,WC{{LOAD OLD CODE BASE POINTER{30664
{{MOV{8,WC{7,XR{{COPY CDBLK POINTER{30665
{{MOV{13,CDSTM(XR){3,KVSTN{{RESTORE STMNT NO{30666
{{MOV{10,(XS)+{8,WA{{RELOAD NAME OFFSET{30667
{{MOV{10,(XS)+{7,XL{{RELOAD NAME BASE{30668
{{MOV{10,(XS)+{7,XR{{RELOAD TRBLK POINTER{30669
{{MOV{10,(XS)+{3,KVTRA{{RESTORE TRACE KEYWORD VALUE{30670
{{ADD{8,WC{8,WB{{RECOMPUTE ABSOLUTE CODE POINTER{30671
{{LCP{8,WB{{{RESTORE CODE POINTER{30672
{{MOV{8,WC{3,R$COD{{AND CODE BLOCK POINTER{30673
{{EXI{{{{RETURN TO TRXEQ CALLER{30674
*
*      HERE IF THE TARGET FUNCTION IS NOT DEFINED
*
{TRXQ2{ERB{1,197{26,TRACE fourth arg is not function name or null{{{30678
*
{{ENP{{{{END PROCEDURE TRXEQ{30680
{{EJC{{{{{30681
*
*      XSCAN -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCAN SCANS OUT ONE TOKEN IN A PROTOTYPE ARGUMENT IN
*      ARRAY,CLEAR,DATA,DEFINE,LOAD FUNCTION CALLS. XSCAN
*      CALLS MUST BE PRECEDED BY A CALL TO THE INITIALIZATION
*      PROCEDURE XSCNI. THE FOLLOWING VARIABLES ARE USED.
*
*      R$XSC                 POINTER TO SCBLK FOR FUNCTION ARG
*      XSOFS                 OFFSET (NUM CHARS SCANNED SO FAR)
*
*      (WA)                  NON-ZERO TO SKIP AND TRIM BLANKS
*      (WC)                  DELIMITER ONE (CH$XX)
*      (XL)                  DELIMITER TWO (CH$XX)
*      JSR  XSCAN            CALL TO SCAN NEXT ITEM
*      (XR)                  POINTER TO SCBLK FOR TOKEN SCANNED
*      (WA)                  COMPLETION CODE (SEE BELOW)
*      (WC,XL)               DESTROYED
*
*      THE SCAN STARTS FROM THE CURRENT POSITION AND CONTINUES
*      UNTIL ONE OF THE FOLLOWING THREE CONDITIONS OCCURS.
*
*      1)   DELIMITER ONE IS ENCOUNTERED  (WA SET TO 1)
*
*      2)   DELIMITER TWO ENCOUNTERED  (WA SET TO 2)
*
*      3)   END OF STRING ENCOUNTERED  (WA SET TO 0)
*
*      THE RESULT IS A STRING CONTAINING ALL CHARACTERS SCANNED
*      UP TO BUT NOT INCLUDING ANY DELIMITER CHARACTER.
*      THE POINTER IS LEFT POINTING PAST THE DELIMITER.
*
*      IF ONLY ONE DELIMITER IS TO BE DETECTED, DELIMITER ONE
*      AND DELIMITER TWO SHOULD BE SET TO THE SAME VALUE.
*
*      IN THE CASE WHERE THE END OF STRING IS ENCOUNTERED, THE
*      STRING INCLUDES ALL THE CHARACTERS TO THE END OF THE
*      STRING. NO FURTHER CALLS CAN BE MADE TO XSCAN UNTIL
*      XSCNI IS CALLED TO INITIALIZE A NEW ARGUMENT SCAN
{{EJC{{{{{30721
*
*      XSCAN (CONTINUED)
*
{XSCAN{PRC{25,E{1,0{{ENTRY POINT{30725
{{MOV{8,WB{3,XSCWB{{PRESERVE WB{30726
{{MOV{8,WA{11,-(XS){{RECORD BLANK SKIP FLAG{30727
{{MOV{8,WA{11,-(XS){{AND SECOND COPY{30728
{{MOV{3,R$XSC{7,XR{{POINT TO ARGUMENT STRING{30729
{{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{30730
{{MOV{3,XSOFS{8,WB{{LOAD CURRENT OFFSET{30731
{{SUB{8,WB{8,WA{{GET NUMBER OF REMAINING CHARACTERS{30732
{{BZE{8,WA{6,XSCN3{{JUMP IF NO CHARACTERS LEFT{30733
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{30734
*
*      LOOP TO SEARCH FOR DELIMITER
*
{XSCN1{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{30738
{{BEQ{8,WB{8,WC{6,XSCN4{JUMP IF DELIMITER ONE FOUND{30739
{{BEQ{8,WB{7,XL{6,XSCN5{JUMP IF DELIMITER TWO FOUND{30740
{{BZE{9,(XS){6,XSCN2{{JUMP IF NOT SKIPPING BLANKS{30741
{{ICV{3,XSOFS{{{ASSUME BLANK AND DELETE IT{30742
{{BEQ{8,WB{18,=CH$HT{6,XSCN2{JUMP IF HORIZONTAL TAB{30744
{{BEQ{8,WB{18,=CH$BL{6,XSCN2{JUMP IF BLANK{30749
{{DCV{3,XSOFS{{{UNDELETE NON-BLANK CHARACTER{30750
{{ZER{9,(XS){{{AND DISCONTINUE BLANK CHECKING{30751
*
*      HERE AFTER PERFORMING ANY LEADING BLANK TRIMMING.
*
{XSCN2{DCV{8,WA{{{DECREMENT COUNT OF CHARS LEFT{30755
{{BNZ{8,WA{6,XSCN1{{LOOP BACK IF MORE CHARS TO GO{30756
*
*      HERE FOR RUNOUT
*
{XSCN3{MOV{3,R$XSC{7,XL{{POINT TO STRING BLOCK{30760
{{MOV{13,SCLEN(XL){8,WA{{GET STRING LENGTH{30761
{{MOV{3,XSOFS{8,WB{{LOAD OFFSET{30762
{{SUB{8,WB{8,WA{{GET SUBSTRING LENGTH{30763
{{ZER{3,R$XSC{{{CLEAR STRING PTR FOR COLLECTOR{30764
{{ZER{3,XSCRT{{{SET ZERO (RUNOUT) RETURN CODE{30765
{{BRN{6,XSCN7{{{JUMP TO EXIT{30766
{{EJC{{{{{30767
*
*      XSCAN (CONTINUED)
*
*      HERE IF DELIMITER ONE FOUND
*
{XSCN4{MOV{18,=NUM01{3,XSCRT{{SET RETURN CODE{30773
{{BRN{6,XSCN6{{{JUMP TO MERGE{30774
*
*      HERE IF DELIMITER TWO FOUND
*
{XSCN5{MOV{18,=NUM02{3,XSCRT{{SET RETURN CODE{30778
*
*      MERGE HERE AFTER DETECTING A DELIMITER
*
{XSCN6{MOV{3,R$XSC{7,XL{{RELOAD POINTER TO STRING{30782
{{MOV{13,SCLEN(XL){8,WC{{GET ORIGINAL LENGTH OF STRING{30783
{{SUB{8,WA{8,WC{{MINUS CHARS LEFT = CHARS SCANNED{30784
{{MOV{8,WC{8,WA{{MOVE TO REG FOR SBSTR{30785
{{MOV{3,XSOFS{8,WB{{SET OFFSET{30786
{{SUB{8,WB{8,WA{{COMPUTE LENGTH FOR SBSTR{30787
{{ICV{8,WC{{{ADJUST NEW CURSOR PAST DELIMITER{30788
{{MOV{8,WC{3,XSOFS{{STORE NEW OFFSET{30789
*
*      COMMON EXIT POINT
*
{XSCN7{ZER{7,XR{{{CLEAR GARBAGE CHARACTER PTR IN XR{30793
{{JSR{6,SBSTR{{{BUILD SUB-STRING{30794
{{ICA{7,XS{{{REMOVE COPY OF BLANK FLAG{30795
{{MOV{10,(XS)+{8,WB{{ORIGINAL BLANK SKIP/TRIM FLAG{30796
{{BZE{13,SCLEN(XR){6,XSCN8{{CANNOT TRIM THE NULL STRING{30797
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS IF REQUESTED{30798
*
*      FINAL EXIT POINT
*
{XSCN8{MOV{3,XSCRT{8,WA{{LOAD RETURN CODE{30802
{{MOV{3,XSCWB{8,WB{{RESTORE WB{30803
{{EXI{{{{RETURN TO XSCAN CALLER{30804
{{ENP{{{{END PROCEDURE XSCAN{30805
{{EJC{{{{{30806
*
*      XSCNI -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCNI INITIALIZES THE SCAN USED FOR PROTOTYPE ARGUMENTS
*      IN THE CLEAR, DEFINE, LOAD, DATA, ARRAY FUNCTIONS. SEE
*      XSCAN FOR THE PROCEDURE WHICH IS USED AFTER THIS CALL.
*
*      -(XS)                 ARGUMENT TO BE SCANNED (ON STACK)
*      JSR  XSCNI            CALL TO SCAN ARGUMENT
*      PPM  LOC              TRANSFER LOC IF ARG IS NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARGUMENT IS NULL
*      (XS)                  POPPED
*      (XR,R$XSC)            ARGUMENT (SCBLK PTR)
*      (WA)                  ARGUMENT LENGTH
*      (IA,RA)               DESTROYED
*
{XSCNI{PRC{25,N{1,2{{ENTRY POINT{30823
{{JSR{6,GTSTG{{{FETCH ARGUMENT AS STRING{30824
{{PPM{6,XSCI1{{{JUMP IF NOT CONVERTIBLE{30825
{{MOV{7,XR{3,R$XSC{{ELSE STORE SCBLK PTR FOR XSCAN{30826
{{ZER{3,XSOFS{{{SET OFFSET TO ZERO{30827
{{BZE{8,WA{6,XSCI2{{JUMP IF NULL STRING{30828
{{EXI{{{{RETURN TO XSCNI CALLER{30829
*
*      HERE IF ARGUMENT IS NOT A STRING
*
{XSCI1{EXI{1,1{{{TAKE NOT-STRING ERROR EXIT{30833
*
*      HERE FOR NULL STRING
*
{XSCI2{EXI{1,2{{{TAKE NULL-STRING ERROR EXIT{30837
{{ENP{{{{END PROCEDURE XSCNI{30838
{{TTL{27,S P I T B O L -- STACK OVERFLOW SECTION{{{{30839
*
*      CONTROL COMES HERE IF THE MAIN STACK OVERFLOWS
*
{{SEC{{{{START OF STACK OVERFLOW SECTION{30843
*
{{ADD{18,=NUM04{3,ERRFT{{FORCE CONCLUSIVE FATAL ERROR{30845
{{MOV{3,FLPTR{7,XS{{POP STACK TO AVOID MORE FAILS{30846
{{BNZ{3,GBCFL{6,STAK1{{JUMP IF GARBAGE COLLECTING{30847
{{ERB{1,246{26,Stack overflow{{{30848
*
*      NO CHANCE OF RECOVERY IN MID GARBAGE COLLECTION
*
{STAK1{MOV{21,=ENDSO{7,XR{{POINT TO MESSAGE{30852
{{ZER{3,KVDMP{{{MEMORY IS UNDUMPABLE{30853
{{BRN{6,STOPR{{{GIVE UP{30854
{{TTL{27,S P I T B O L -- ERROR SECTION{{{{30855
*
*      THIS SECTION OF CODE IS ENTERED WHENEVER A PROCEDURE
*      RETURN VIA AN ERR PARAMETER OR AN ERB OPCODE IS OBEYED.
*
*      (WA)                  IS THE ERROR CODE
*
*      THE GLOBAL VARIABLE STAGE INDICATES THE POINT AT WHICH
*      THE ERROR OCCURED AS FOLLOWS.
*
*      STAGE=STGIC           ERROR DURING INITIAL COMPILE
*
*      STAGE=STGXC           ERROR DURING COMPILE AT EXECUTE
*                            TIME (CODE, CONVERT FUNCTION CALLS)
*
*      STAGE=STGEV           ERROR DURING COMPILATION OF
*                            EXPRESSION AT EXECUTION TIME
*                            (EVAL, CONVERT FUNCTION CALL).
*
*      STAGE=STGXT           ERROR AT EXECUTE TIME. COMPILER
*                            NOT ACTIVE.
*
*      STAGE=STGCE           ERROR DURING INITIAL COMPILE AFTER
*                            SCANNING OUT THE END LINE.
*
*      STAGE=STGXE           ERROR DURING COMPILE AT EXECUTE
*                            TIME AFTER SCANNING END LINE.
*
*      STAGE=STGEE           ERROR DURING EXPRESSION EVALUATION
*
{{SEC{{{{START OF ERROR SECTION{30885
*
{ERROR{BEQ{3,R$CIM{20,=CMLAB{6,CMPLE{JUMP IF ERROR IN SCANNING LABEL{30887
{{MOV{8,WA{3,KVERT{{SAVE ERROR CODE{30888
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH FOR SCANE{30889
{{ZER{3,SCNGO{{{RESET GOTO SWITCH FOR SCANE{30890
{{MOV{18,=NUM01{3,POLCS{{RESET POLL COUNT{30892
{{MOV{18,=NUM01{3,POLCT{{RESET POLL COUNT{30893
{{MOV{3,STAGE{7,XR{{LOAD CURRENT STAGE{30895
{{BSW{7,XR{2,STGNO{{JUMP TO APPROPRIATE ERROR CIRCUIT{30896
{{IFF{2,STGIC{6,ERR01{{INITIAL COMPILE{30904
{{IFF{2,STGXC{6,ERR04{{EXECUTE TIME COMPILE{30904
{{IFF{2,STGEV{6,ERR04{{EVAL COMPILING EXPR.{30904
{{IFF{2,STGXT{6,ERR05{{EXECUTE TIME{30904
{{IFF{2,STGCE{6,ERR01{{COMPILE - AFTER END{30904
{{IFF{2,STGXE{6,ERR04{{XEQ COMPILE-PAST END{30904
{{IFF{2,STGEE{6,ERR04{{EVAL EVALUATING EXPR{30904
{{ESW{{{{END SWITCH ON ERROR TYPE{30904
{{EJC{{{{{30905
*
*      ERROR DURING INITIAL COMPILE
*
*      THE ERROR MESSAGE IS PRINTED AS PART OF THE COMPILER
*      OUTPUT. THIS PRINTOUT INCLUDES THE OFFENDING LINE (IF NOT
*      PRINTED ALREADY) AND AN ERROR FLAG UNDER THE APPROPRIATE
*      COLUMN AS INDICATED BY SCNSE UNLESS SCNSE IS SET TO ZERO.
*
*      AFTER PRINTING THE MESSAGE, THE GENERATED CODE IS
*      MODIFIED TO AN ERROR CALL AND CONTROL IS RETURNED TO
*      THE CMPIL PROCEDURE AFTER RESETTING THE STACK POINTER.
*
*      IF THE ERROR OCCURS AFTER THE END LINE, CONTROL RETURNS
*      IN A SLIGHTLY DIFFERENT MANNER TO ENSURE PROPER CLEANUP.
*
{ERR01{MOV{3,CMPXS{7,XS{{RESET STACK POINTER{30921
{{SSL{3,CMPSS{{{RESTORE S-R STACK PTR FOR CMPIL{30922
{{BNZ{3,ERRSP{6,ERR03{{JUMP IF ERROR SUPPRESS FLAG SET{30923
{{MOV{3,CMPSN{8,WC{{CURRENT STATEMENT{30926
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{30927
{{MOV{3,SCNSE{8,WB{{COLUMN NUMBER{30929
{{MOV{3,RDCLN{8,WC{{LINE NUMBER{30930
{{MOV{3,STAGE{7,XR{{{30931
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{30932
{{PPM{6,ERRA3{{{IF SYSTEM DOES NOT WANT PRINT{30933
{{MOV{7,XR{11,-(XS){{SAVE ANY PROVIDED PRINT MESSAGE{30934
{{MOV{3,ERICH{3,ERLST{{SET FLAG FOR LISTR{30936
{{JSR{6,LISTR{{{LIST LINE{30937
{{JSR{6,PRTIS{{{TERMINATE LISTING{30938
{{ZER{3,ERLST{{{CLEAR LISTR FLAG{30939
{{MOV{3,SCNSE{8,WA{{LOAD SCAN ELEMENT OFFSET{30940
{{BZE{8,WA{6,ERR02{{SKIP IF NOT SET{30941
{{LCT{8,WB{8,WA{{LOOP COUNTER{30943
{{ICV{8,WA{{{INCREASE FOR CH$EX{30944
{{MOV{3,R$CIM{7,XL{{POINT TO BAD STATEMENT{30945
{{JSR{6,ALOCS{{{STRING BLOCK FOR ERROR FLAG{30946
{{MOV{7,XR{8,WA{{REMEMBER STRING PTR{30947
{{PSC{7,XR{{{READY FOR CHARACTER STORING{30948
{{PLC{7,XL{{{READY TO GET CHARS{30949
*
*      LOOP TO REPLACE ALL CHARS BUT TABS BY BLANKS
*
{ERRA1{LCH{8,WC{10,(XL)+{{GET NEXT CHAR{30953
{{BEQ{8,WC{18,=CH$HT{6,ERRA2{SKIP IF TAB{30954
{{MOV{18,=CH$BL{8,WC{{GET A BLANK{30955
{{EJC{{{{{30956
*
*      MERGE TO STORE BLANK OR TAB IN ERROR LINE
*
{ERRA2{SCH{8,WC{10,(XR)+{{STORE CHAR{30960
{{BCT{8,WB{6,ERRA1{{LOOP{30961
{{MOV{18,=CH$EX{7,XL{{EXCLAMATION MARK{30962
{{SCH{7,XL{9,(XR){{STORE AT END OF ERROR LINE{30963
{{CSC{7,XR{{{END OF SCH LOOP{30964
{{MOV{18,=STNPD{3,PROFS{{ALLOW FOR STATEMENT NUMBER{30965
{{MOV{8,WA{7,XR{{POINT TO ERROR LINE{30966
{{JSR{6,PRTST{{{PRINT ERROR LINE{30967
*
*      HERE AFTER PLACING ERROR FLAG AS REQUIRED
*
{ERR02{JSR{6,PRTIS{{{PRINT BLANK LINE{30981
{{MOV{10,(XS)+{7,XR{{RESTORE ANY SYSEA MESSAGE{30983
{{BZE{7,XR{6,ERRA0{{DID SYSEA PROVIDE MESSAGE TO PRINT{30984
{{JSR{6,PRTST{{{PRINT SYSEA MESSAGE{30985
{ERRA0{JSR{6,ERMSG{{{GENERATE FLAG AND ERROR MESSAGE{30987
{{ADD{18,=NUM03{3,LSTLC{{BUMP PAGE CTR FOR BLANK, ERROR, BLK{30988
{ERRA3{ZER{7,XR{{{IN CASE OF FATAL ERROR{30989
{{BHI{3,ERRFT{18,=NUM03{6,STOPR{PACK UP IF SEVERAL FATALS{30990
*
*      COUNT ERROR, INHIBIT EXECUTION IF REQUIRED
*
{{ICV{3,CMERC{{{BUMP ERROR COUNT{30994
{{ADD{3,CSWER{3,NOXEQ{{INHIBIT XEQ IF -NOERRORS{30995
{{BNE{3,STAGE{18,=STGIC{6,CMP10{SPECIAL RETURN IF AFTER END LINE{30996
{{EJC{{{{{30997
*
*      LOOP TO SCAN TO END OF STATEMENT
*
{ERR03{MOV{3,R$CIM{7,XR{{POINT TO START OF IMAGE{31001
{{PLC{7,XR{{{POINT TO FIRST CHAR{31002
{{LCH{7,XR{9,(XR){{GET FIRST CHAR{31003
{{BEQ{7,XR{18,=CH$MN{6,CMPCE{JUMP IF ERROR IN CONTROL CARD{31004
{{ZER{3,SCNRS{{{CLEAR RESCAN FLAG{31005
{{MNZ{3,ERRSP{{{SET ERROR SUPPRESS FLAG{31006
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{31007
{{BNE{7,XL{18,=T$SMC{6,ERR03{LOOP BACK IF NOT STATEMENT END{31008
{{ZER{3,ERRSP{{{CLEAR ERROR SUPPRESS FLAG{31009
*
*      GENERATE ERROR CALL IN CODE AND RETURN TO CMPIL
*
{{MOV{19,*CDCOD{3,CWCOF{{RESET OFFSET IN CCBLK{31013
{{MOV{21,=OCER${8,WA{{LOAD COMPILE ERROR CALL{31014
{{JSR{6,CDWRD{{{GENERATE IT{31015
{{MOV{3,CWCOF{13,CMSOC(XS){{SET SUCCESS FILL IN OFFSET{31016
{{MNZ{13,CMFFC(XS){{{SET FAILURE FILL IN FLAG{31017
{{JSR{6,CDWRD{{{GENERATE SUCC. FILL IN WORD{31018
{{BRN{6,CMPSE{{{MERGE TO GENERATE ERROR AS CDFAL{31019
*
*      ERROR DURING EXECUTE TIME COMPILE OR EXPRESSION EVALUATIO
*
*      EXECUTE TIME COMPILATION IS INITIATED THROUGH GTCOD OR
*      GTEXP WHICH ARE CALLED BY COMPILE, CODE OR EVAL.
*      BEFORE CAUSING STATEMENT FAILURE THROUGH EXFAL IT IS
*      HELPFUL TO SET KEYWORD ERRTEXT AND FOR GENERALITY
*      THESE ERRORS MAY BE HANDLED BY THE SETEXIT MECHANISM.
*
{ERR04{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{31029
{{BEQ{3,KVERT{18,=NM320{6,ERR06{TREAT USER INTERRUPT SPECIALLY{31031
{{ZER{3,R$CCB{{{FORGET GARBAGE CODE BLOCK{31033
{{MOV{19,*CCCOD{3,CWCOF{{SET INITIAL OFFSET (MBE CATSPAW){31034
{{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{31035
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{31036
{{DCA{7,XS{{{ENSURE STACK OK ON LOOP START{31037
*
*      POP STACK UNTIL FIND FLPTR FOR MOST DEEPLY NESTED PROG.
*      DEFINED FUNCTION CALL OR CALL OF EVAL / CODE.
*
{ERRA4{ICA{7,XS{{{POP STACK{31042
{{BEQ{7,XS{3,FLPRT{6,ERRC4{JUMP IF PROG DEFINED FN CALL FOUND{31043
{{BNE{7,XS{3,GTCEF{6,ERRA4{LOOP IF NOT EVAL OR CODE CALL YET{31044
{{MOV{18,=STGXT{3,STAGE{{RE-SET STAGE FOR EXECUTE{31045
{{MOV{3,R$GTC{3,R$COD{{RECOVER CODE PTR{31046
{{MOV{7,XS{3,FLPTR{{RESTORE FAIL POINTER{31047
{{ZER{3,R$CIM{{{FORGET POSSIBLE IMAGE{31048
{{ZER{3,CNIND{{{FORGET POSSIBLE INCLUDE{31050
*
*      TEST ERRLIMIT
*
{ERRB4{BNZ{3,KVERL{6,ERR07{{JUMP IF ERRLIMIT NON-ZERO{31055
{{BRN{6,EXFAL{{{FAIL{31056
*
*      RETURN FROM PROG. DEFINED FUNCTION IS OUTSTANDING
*
{ERRC4{MOV{3,FLPTR{7,XS{{RESTORE STACK FROM FLPTR{31060
{{BRN{6,ERRB4{{{MERGE{31061
{{EJC{{{{{31062
*
*      ERROR AT EXECUTE TIME.
*
*      THE ACTION TAKEN ON AN ERROR IS AS FOLLOWS.
*
*      IF ERRLIMIT KEYWORD IS ZERO, AN ABORT IS SIGNALLED,
*      SEE CODING FOR SYSTEM LABEL ABORT AT L$ABO.
*
*      OTHERWISE, ERRLIMIT IS DECREMENTED AND AN ERRTYPE TRACE
*      GENERATED IF REQUIRED. CONTROL RETURNS EITHER VIA A JUMP
*      TO CONTINUE (TO TAKE THE FAILURE EXIT) OR A SPECIFIED
*      SETEXIT TRAP IS EXECUTED AND CONTROL PASSES TO THE TRAP.
*      IF 3 OR MORE FATAL ERRORS OCCUR AN ABORT IS SIGNALLED
*      REGARDLESS OF ERRLIMIT AND SETEXIT - LOOPING IS ALL TOO
*      PROBABLE OTHERWISE. FATAL ERRORS INCLUDE STACK OVERFLOW
*      AND EXCEEDING STLIMIT.
*
{ERR05{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{31080
{{BNZ{3,DMVCH{6,ERR08{{JUMP IF IN MID-DUMP{31081
*
*      MERGE HERE FROM ERR08 AND ERR04 (ERROR 320)
*
{ERR06{BZE{3,KVERL{6,LABO1{{ABORT IF ERRLIMIT IS ZERO{31085
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{31086
*
*      MERGE FROM ERR04
*
{ERR07{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{31090
{{DCV{3,KVERL{{{DECREMENT ERRLIMIT{31091
{{MOV{3,R$ERT{7,XL{{LOAD ERRTYPE TRACE POINTER{31092
{{JSR{6,KTREX{{{GENERATE ERRTYPE TRACE IF REQUIRED{31093
{{MOV{3,R$COD{8,WA{{GET CURRENT CODE BLOCK{31094
{{MOV{8,WA{3,R$CNT{{SET CDBLK PTR FOR CONTINUATION{31095
{{SCP{8,WB{{{CURRENT CODE POINTER{31096
{{SUB{8,WA{8,WB{{OFFSET WITHIN CODE BLOCK{31097
{{MOV{8,WB{3,STXOC{{SAVE CODE PTR OFFSET FOR SCONTINUE{31098
{{MOV{3,FLPTR{7,XR{{SET PTR TO FAILURE OFFSET{31099
{{MOV{9,(XR){3,STXOF{{SAVE FAILURE OFFSET FOR CONTINUE{31100
{{MOV{3,R$SXC{7,XR{{LOAD SETEXIT CDBLK POINTER{31101
{{BZE{7,XR{6,LCNT1{{CONTINUE IF NO SETEXIT TRAP{31102
{{ZER{3,R$SXC{{{ELSE RESET TRAP{31103
{{MOV{21,=NULLS{3,STXVR{{RESET SETEXIT ARG TO NULL{31104
{{MOV{9,(XR){7,XL{{LOAD PTR TO CODE BLOCK ROUTINE{31105
{{BRI{7,XL{{{EXECUTE FIRST TRAP STATEMENT{31106
*
*      INTERRUPTED PARTLY THROUGH A DUMP WHILST STORE IS IN A
*      MESS SO DO A TIDY UP OPERATION. SEE DUMPR FOR DETAILS.
*
{ERR08{MOV{3,DMVCH{7,XR{{CHAIN HEAD FOR AFFECTED VRBLKS{31111
{{BZE{7,XR{6,ERR06{{DONE IF ZERO{31112
{{MOV{9,(XR){3,DMVCH{{SET NEXT LINK AS CHAIN HEAD{31113
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{31114
*
*      LABEL TO MARK END OF CODE
*
{S$YYY{BRN{6,ERR08{{{LOOP THROUGH CHAIN{31118
{{TTL{27,S P I T B O L -- HERE ENDETH THE CODE{{{{31119
*
*      END OF ASSEMBLY
*
{{END{{{{END MACRO-SPITBOL ASSEMBLY{31123
