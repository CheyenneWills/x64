        .title "SPITBOL TRANSLATOR V40"
        .sbttl "V40"
# MINIMAL/80386 Translator V1.12 08/04/12 17:17:57 for linux
        .psize          80,132
        .arch           pentium
        .include        "systype.ah"

        header_

        cseg_

        .include        "hdrcode.inc"
        .include        "hdrdata.inc"

        .extern         ldr_:near
        .extern         str_:near
        .extern         ovr_:near
        .extern         dvi_:near
        .extern         rmi_:near
        .extern         cvd_:near
        .extern         rti_:near
        .extern         itr_:near
        .extern         adr_:near
        .extern         sbr_:near
        .extern         mlr_:near
        .extern         dvr_:near
        .extern         ngr_:near
        .extern         atn_:near
        .extern         chp_:near
        .extern         cos_:near
        .extern         etx_:near
        .extern         lnf_:near
        .extern         sin_:near
        .extern         sqr_:near
        .extern         tan_:near
        .extern         cpr_:near

        csegend_
#      spitbol conditional assembly symbols for use by token.spt
#      ---------------------------------------------------------
#
#      this file of conditional symbols will override the conditional
#      definitions contained in the spitbol minimal file.   in addition,
#      lines beginning with ">" are treated as spitbol statements and
#      immediately executed.
#
#      for linux spitbol-x86
#
#      in the spitbol translator, the following conditional
#      assembly symbols are referred to. to incorporate the
#      features referred to, the minimal source should be
#      prefaced by suitable conditional assembly symbol
#      definitions.
#      in all cases it is permissible to default the definitions
#      in which case the additional features will be omitted
#      from the target code.
#
#
#                            conditional options
#                            since .undef not allowed if symbol not
#                            defined, a full comment line indicates
#                            symbol initially not defined.
#
#      .cavt                 define to include vertical tab
#      .ccmc                 define to include syscm function
#      .ceng                 define to include engine features
#      .cnci                 define to enable sysci routine
#      .cncr                 define to enable syscr routine
#      .cnex                 define to omit exit() code.
#      .cnld                 define to omit load() code.
#      .cnpf                 define to omit profile stuff
#      .cnra                 define to omit all real arithmetic
#      .cnsr                 define to omit sort, rsort
#      .crpp                 define if return points have odd parity
#      .cs16                 define to initialize stlim to 32767
#      .csn5                 define to pad stmt nos to 5 chars
#      .csn6                 define to pad stmt nos to 6 chars
#      .ctmd                 define if systm unit is decisecond
#      .cusr                 define to have set() use real values
#                             (must also #define setreal 1 in systype.h)
#
                            #} ttl l i c e n s e -- software license for this program
        .sbttl "l i c e n s e -- software license for this program"
#
#     copyright 1983-2012 robert b. k. dewar
#
#     this file is part of macro spitbol.
#
#     macro spitbol is free software: you can redistribute it and/or modify
#     it under the terms of the gnu general public license as published by
#     the free software foundation, either version 3 of the license, or
#     (at your option) any later version.
#
#     macro spitbol is distributed in the hope that it will be useful,
#     but without any warranty; without even the implied warranty of
#     merchantability or fitness for a particular purpose.  see the
#     gnu general public license for more details.
#
#     you should have received a copy of the gnu general public license
#     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
#
                            #} ttl s p i t b o l -- notes to implementors
        .sbttl "s p i t b o l -- notes to implementors"
#
#      m a c r o   s p i t b o l     v e r s i o n   3 . 8
#      ---------------------------------------------------
#
#      date of release  -  june 2012
#
#      version 3.8 is maintained by
#           dr. david shields
#           260 garth rd apt 3h4
#           scarsdale, ny 10583
#      e-mail - thedaveshields at gmail dot com
#
#      version 3.7 was maintained by
#           mark emmer
#           catspaw, inc.
#           p.o. box 1123
#           salida, colorado 81021
#           u.s.a
#      e-mail - marke at snobol4 dot com
#
#      versions 2.6 through 3.4 were maintained by
#           dr. a. p. mccann
#           department of computer studies
#           university of leeds
#           leeds ls2 9jt
#           england.
#
#      from 1979 through early 1983 a number of fixes and
#      enhancements were made by steve duff and robert goldberg.
#
#      to assist implementors a revision history based on
#      version 2.7 is being maintained.
#
                            #} ttl s p i t b o l - revision history
        .sbttl "s p i t b o l - revision history"
                            #} ejc
        .eject
#      r e v i s i o n   h i s t o r y
#      -------------------------------
#
#
#      version 3.8 (june 2012, david shields)
#      --------------------------------------
#
#	       this version is very close to v3.7, with the
#              same functionality.
#
#              the source is now maintained using git, so going forward
#              the detailed revision history will be recorded in the git
#              commit logs, not in this file.
#
                            #} ttl minimal -- machine independent macro assembly lang.
        .sbttl "minimal -- machine independent macro assembly lang."
                            #} ejc
        .eject
#
#              the definition of minimal can be found in the file
#              minimal-specification.txt
#      the following sections describe the implementation
                            #} ttl s p i t b o l  -- basic information
        .sbttl "s p i t b o l  -- basic information"
                            #} ejc
        .eject
#
#      general structure
#      -----------------
#
#      this program is a translator for a version of the snobol4
#      programming language. language details are contained in
#      the manual macro spitbol by dewar and mccann, technical
#      report 90, university of leeds 1976.
#      the implementation is discussed in dewar and mccann,
#      macro spitbol - a snobol4 compiler, software practice and
#      experience, 7, 95-113, 1977.
#      the language is as implemented by the btl translator
#      (griswold, poage and polonsky, prentice hall, 1971)
#      with the following principal exceptions.
#
#      1)   redefinition of standard system functions and
#           operators is not permitted.
#
#      2)   the value function is not provided.
#
#      3)   access tracing is provided in addition to the
#           other standard trace modes.
#
#      4)   the keyword stfcount is not provided.
#
#      5)   the keyword fullscan is not provided and all pattern
#           matching takes place in fullscan mode (i.e. with no
#           heuristics applied).
#
#      6)   a series of expressions separated by commas may
#           be grouped within parentheses to provide a selection
#           capability. the semantics are that the selection
#           assumes the value of the first expression within it
#           which succeeds as they are evaluated from the left.
#           if no expression succeeds the entire statement fails
#
#      7)   an explicit pattern matching operator is provided.
#           this is the binary query (see gimpel sigplan oct 74)
#
#      8)   the assignment operator is introduced as in the
#           gimpel reference.
#
#      9)   the exit function is provided for generating load
#           modules - cf. gimpels sitbol.
#
#
#      the method used in this program is to translate the
#      source code into an internal pseudo-code (see following
#      section). an interpretor is then used to execute this
#      generated pseudo-code. the nature of the snobol4 language
#      is such that the latter task is much more complex than
#      the actual translation phase. accordingly, nearly all the
#      code in the program section is concerned with the actual
#      execution of the snobol4 program.
                            #} ejc
        .eject
#
#      interpretive code format
#      ------------------------
#
#      the interpretive pseudo-code consists of a series of
#      address pointers. the exact format of the code is
#      described in connection with the cdblk format. the
#      purpose of this section is to give general insight into
#      the interpretive approach involved.
#
#      the basic form of the code is related to reverse polish.
#      in other words, the operands precede the operators which
#      are zero address operators. there are some exceptions to
#      these rules, notably the unary not operator and the
#      selection construction which clearly require advance
#      knowledge of the operator involved.
#
#      the operands are moved to the top of the main stack and
#      the operators are applied to the top stack entries. like
#      other versions of spitbol, this processor depends on
#      knowing whether operands are required by name or by value
#      and moves the appropriate object to the stack. thus no
#      name/value checks are included in the operator circuits.
#
#      the actual pointers in the code point to a block whose
#      first word is the address of the interpretor routine
#      to be executed for the code word.
#
#      in the case of operators, the pointer is to a word which
#      contains the address of the operator to be executed. in
#      the case of operands such as constants, the pointer is to
#      the operand itself. accordingly, all operands contain
#      a field which points to the routine to load the value of
#      the operand onto the stack. in the case of a variable,
#      there are three such pointers. one to load the value,
#      one to store the value and a third to jump to the label.
#
#      the handling of failure returns deserves special comment.
#      the location flptr contains the pointer to the location
#      on the main stack which contains the failure return
#      which is in the form of a byte offset in the current
#      code block (cdblk or exblk). when a failure occurs, the
#      stack is popped as indicated by the setting of flptr and
#      control is passed to the appropriate location in the
#      current code block with the stack pointer pointing to the
#      failure offset on the stack and flptr unchanged.
                            #} ejc
        .eject
#
#      internal data representations
#      -----------------------------
#
#      representation of values
#
#      a value is represented by a pointer to a block which
#      describes the type and particulars of the data value.
#      in general, a variable is a location containing such a
#      pointer (although in the case of trace associations this
#      is modified, see description of trblk).
#
#      the following is a list of possible datatypes showing the
#      type of block used to hold the value. the details of
#      each block format are given later.
#
#      datatype              block type
#      --------              ----------
#
#      array                 arblk or vcblk
#
#      code                  cdblk
#
#      expression            exblk or seblk
#
#      integer               icblk
#
#      name                  nmblk
#
#      pattern               p0blk or p1blk or p2blk
#
#      real                  rcblk
#
#      string                scblk
#
#      table                 tbblk
#
#      program datatype      pdblk
                            #} ejc
        .eject
#
#      representation of variables
#      ---------------------------
#
#      during the course of evaluating expressions, it is
#      necessary to generate names of variables (for example
#      on the left side of a binary equals operator). these are
#      not to be confused with objects of datatype name which
#      are in fact values.
#
#      from a logical point of view, such names could be simply
#      represented by a pointer to the appropriate value cell.
#      however in the case of arrays and program defined
#      datatypes, this would violate the rule that there must be
#      no pointers into the middle of a block in dynamic store.
#      accordingly, a name is always represented by a base and
#      offset. the base points to the start of the block
#      containing the variable value and the offset is the
#      offset within this block in bytes. thus the address
#      of the actual variable is determined by adding the base
#      and offset values.
#
#      the following are the instances of variables represented
#      in this manner.
#
#      1)   natural variable base is ptr to vrblk
#                            offset is *vrval
#
#      2)   table element    base is ptr to teblk
#                            offset is *teval
#
#      3)   array element    base is ptr to arblk
#                            offset is offset to element
#
#      4)   vector element   base is ptr to vcblk
#                            offset is offset to element
#
#      5)   prog def dtp     base is ptr to pdblk
#                            offset is offset to field value
#
#      in addition there are two cases of objects which are
#      like variables but cannot be handled in this manner.
#      these are called pseudo-variables and are represented
#      with a special base pointer as follows=
#
#      expression variable   ptr to evblk (see evblk)
#
#      keyword variable      ptr to kvblk (see kvblk)
#
#      pseudo-variables are handled as special cases by the
#      access procedure (acess) and the assignment procedure
#      (asign). see these two procedures for details.
                            #} ejc
        .eject
#
#      organization of data area
#      -------------------------
#
#      the data area is divided into two regions.
#
#      static area
#
#      the static area builds up from the bottom and contains
#      data areas which are allocated dynamically but are never
#      deleted or moved around. the macro-program itself
#      uses the static area for the following.
#
#      1)   all variable blocks (vrblk).
#
#      2)   the hash table for variable blocks.
#
#      3)   miscellaneous buffers and work areas (see program
#           initialization section).
#
#      in addition, the system procedures may use this area for
#      input/output buffers, external functions etc. space in
#      the static region is allocated by calling procedure alost
#
#      the following global variables define the current
#      location and size of the static area.
#
#      statb                 address of start of static area
#      state                 address+1 of last word in area.
#
#      the minimum size of static is given approximately by
#           12 + *e$hnb + *e$sts + space for alphabet string
#           and standard print buffer.
                            #} ejc
        .eject
#      dynamic area
#
#      the dynamic area is built upwards in memory after the
#      static region. data in this area must all be in standard
#      block formats so that it can be processed by the garbage
#      collector (procedure gbcol). gbcol compacts blocks down
#      in this region as required by space exhaustion and can
#      also move all blocks up to allow for expansion of the
#      static region.
#      with the exception of tables and arrays, no spitbol
#      object once built in dynamic memory is ever subsequently
#      modified. observing this rule necessitates a copying
#      action during string and pattern concatenation.
#
#      garbage collection is fundamental to the allocation of
#      space for values. spitbol uses a very efficient garbage
#      collector which insists that pointers into dynamic store
#      should be identifiable without use of bit tables,
#      marker bits etc. to satisfy this requirement, dynamic
#      memory must not start at too low an address and lengths
#      of arrays, tables, strings, code and expression blocks
#      may not exceed the numerical value of the lowest dynamic
#      address.
#
#      to avoid either penalizing users with modest
#      requirements or restricting those with greater needs on
#      host systems where dynamic memory is allocated in low
#      addresses, the minimum dynamic address may be specified
#      sufficiently high to permit arbitrarily large spitbol
#      objects to be created (with the possibility in extreme
#      cases of wasting large amounts of memory below the
#      start address). this minimum value is made available
#      in variable mxlen by a system routine, sysmx.
#      alternatively sysmx may indicate that a
#      default may be used in which dynamic is placed
#      at the lowest possible address following static.
#
#      the following global work cells define the location and
#      length of the dynamic area.
#
#      dnamb                 start of dynamic area
#      dnamp                 next available location
#      dname                 last available location + 1
#
#      dnamb is always higher than state since the alost
#      procedure maintains some expansion space above state.
#      *** dnamb must never be permitted to have a value less
#      than that in mxlen ***
#
#      space in the dynamic region is allocated by the alloc
#      procedure. the dynamic region may be used by system
#      procedures provided that all the rules are obeyed.
#      some of the rules are subtle so it is preferable for
#      osint to manage its own memory needs. spitbol procs
#      obey rules to ensure that no action can cause a garbage
#      collection except at such times as contents of xl, xr
#      and the stack are +clean+ (see comment before utility
#      procedures and in gbcol for more detail). note
#      that calls of alost may cause garbage collection (shift
#      of memory to free space). spitbol procs which call
#      system routines assume that they cannot precipitate
#      collection and this must be respected.
                            #} ejc
        .eject
#
#      register usage
#      --------------
#
#      (cp)                  code pointer register. used to
#                            hold a pointer to the current
#                            location in the interpretive pseudo
#                            code (i.e. ptr into a cdblk).
#
#      (xl,xr)               general index registers. usually
#                            used to hold pointers to blocks in
#                            dynamic storage. an important
#                            restriction is that the value in
#                            xl must be collectable for
#                            a garbage collect call. a value
#                            is collectable if it either points
#                            outside the dynamic area, or if it
#                            points to the start of a block in
#                            the dynamic area.
#
#      (xs)                  stack pointer. used to point to
#                            the stack front. the stack may
#                            build up or down and is used
#                            to stack subroutine return points
#                            and other recursively saved data.
#
#      (xt)                  an alternative name for xl during
#                            its use in accessing stacked items.
#
#      (wa,wb,wc)            general work registers. cannot be
#                            used for indexing, but may hold
#                            various types of data.
#
#      (ia)                  used for all signed integer
#                            arithmetic, both that used by the
#                            translator and that arising from
#                            use of snobol4 arithmetic operators
#
#      (ra)                  real accumulator. used for all
#                            floating point arithmetic.
                            #} ejc
        .eject
#
#      spitbol conditional assembly symbols
#      ------------------------------------
#
#      in the spitbol translator, the following conditional
#      assembly symbols are referred to. to incorporate the
#      features referred to, the minimal source should be
#      prefaced by suitable conditional assembly symbol
#      definitions.
#      in all cases it is permissible to default the definitions
#      in which case the additional features will be omitted
#      from the target code.
#
#      .caex                 define to allow up arrow for expon.
#      .caht                 define to include horizontal tab
#      .casl                 define to include 26 shifted lettrs
#      .cavt                 define to include vertical tab
#      .cbyt                 define for statistics in bytes
#      .ccmc                 define to include syscm function
#      .ccmk                 define to include compare keyword
#      .cepp                 define if entrys have odd parity
#      .cera                 define to include sysea function
#      .cexp                 define if spitbol pops sysex args
#      .cgbc                 define to include sysgc function
#      .cicc                 define to ignore bad control cards
#      .cinc                 define to add -include control card
#      .ciod                 define to not use default delimiter
#                              in processing 3rd arg of input()
#                              and output()
#      .cmth                 define to include math functions
#      .cnbf                 define to omit buffer extension
#      .cnbt                 define to omit batch initialisation
#      .cnci                 define to enable sysci routine
#      .cncr                 define to enable syscr routine
#      .cnex                 define to omit exit() code.
#      .cnld                 define to omit load() code.
#      .cnlf                 define to add file type for load()
#      .cnpf                 define to omit profile stuff
#      .cnra                 define to omit all real arithmetic
#      .cnsc                 define to no numeric-string compare
#      .cnsr                 define to omit sort, rsort
#      .cpol                 define if interface polling desired
#      .crel                 define to include reloc routines
#      .crpp                 define if returns have odd parity
#      .cs16                 define to initialize stlim to 32767
#      .cs32                 define to init stlim to 2147483647
#                            omit to take default of 50000
#      .csax                 define if sysax is to be called
#      .csed                 define to use sediment in gbcol
#      .csfn                 define to track source file names
#      .csln                 define if line number in code block
#      .csn5                 define to pad stmt nos to 5 chars
#      .csn6                 define to pad stmt nos to 6 chars
#      .csn8                 define to pad stmt nos to 8 chars
#      .csou                 define if output, terminal to sysou
#      .ctet                 define to table entry trace wanted
#      .ctmd                 define if systm unit is decisecond
#      .cucf                 define to include cfp$u
#      .cuej                 define to suppress needless ejects
#      .culk                 define to include &l/ucase keywords
#      .culc                 define to include &case (lc names)
#                            if cucl defined, must support
#                            minimal op flc wreg that folds
#                            argument to upper case
#      .cust                 define to include set() code
#
#                            conditional options
#                            since .undef not allowed if symbol
#                            not defined, a full comment line
#                            indicates symbol initially not
#                            defined.
#
#      .cbyt                 define for statistics in bytes
#      .ccmc                 define to include syscm function
#      .ccmk                 define to include compare keyword
#      .cepp                 define if entrys have odd parity
#      .cera                 define to include sysea function
#      .cexp                 define if spitbol pops sysex args
#      .cicc                 define to ignore bad control cards
#      .cinc                 define to add -include control card
#                            in processing 3rd arg of input()
#                            and output()
#      .cmth                 define to include math functions
#      .cnci                 define to enable sysci routine
#      .cncr                 define to enable syscr routine
#      .cnex                 define to omit exit() code.
#      .cnlf                 define to add file type to load()
#      .cnpf                 define to omit profile stuff
#      .cnra                 define to omit all real arithmetic
#      .cnsc                 define if no numeric-string compare
#      .cnsr                 define to omit sort, rsort
#      .cpol                 define if interface polling desired
#      .crel                 define to include reloc routines
#      .crpp                 define if returns have odd parity
#      .cs16                 define to initialize stlim to 32767
#      .cs32                 define to init stlim to 2147483647
#      .csed                 define to use sediment in gbcol
#      .csfn                 define to track source file names
#      .csln                 define if line number in code block
#      .csn5                 define to pad stmt nos to 5 chars
#      .csn6                 define to pad stmt nos to 6 chars
#      .csou                 define if output, terminal to sysou
#      .ctmd                 define if systm unit is decisecond
#
#      force definition of .ccmk if .ccmc is defined
#
                            #} ttl s p i t b o l -- procedures section
        .sbttl "s p i t b o l -- procedures section"
#
#      this section starts with descriptions of the operating
#      system dependent procedures which are used by the spitbol
#      translator. all such procedures have five letter names
#      beginning with sys. they are listed in alphabetical
#      order.
#      all procedures have a  specification consisting of a
#      model call, preceded by a possibly empty list of register
#      contents giving parameters available to the procedure and
#      followed by a possibly empty list of register contents
#      required on return from the call or which may have had
#      their contents destroyed. only those registers explicitly
#      mentioned in the list after the call may have their
#      values changed.
#      the segment of code providing the external procedures is
#      conveniently referred to as osint (operating system
#      interface). the sysxx procedures it contains provide
#      facilities not usually available as primitives in
#      assembly languages. for particular target machines,
#      implementors may choose for some minimal opcodes which
#      do not have reasonably direct translations, to use calls
#      of additional procedures which they provide in osint.
#      e.g. mwb or trc might be translated as jsr sysmb,
#      jsr systc in some implementations.
#
#      in the descriptions, reference is made to --blk
#      formats (-- = a pair of letters). see the spitbol
#      definitions section for detailed descriptions of all
#      such block formats except fcblk for which sysfc should
#      be consulted.
#
#      section 0 contains inp,inr specifications of internal
#      procedures,routines. this gives a single pass translator
#      information making it easy to generate alternative calls
#      in the translation of jsr-s for procedures of different
#      types if this proves necessary.
#
                            #start of procedures section} sec
        CSeg_
        .global SEC01
SEC01:
                            #} ejc
        .eject
#
#      sysax -- after execution
#
        .extern sysax:NEAR  #define external entry point} exp
#
#      if the conditional assembly symbol .csax is defined,
#      this routine is called immediately after execution and
#      before printing of execution statistics or dump output.
#      purpose of call is for implementor to determine and
#      if the call is not required it will be omitted if .csax
#      is undefined. in this case sysax need not be coded.
#
#      jsr  sysax            call after execution
                            #} ejc
        .eject
#
#      sysbs -- backspace file
#
        .extern sysbs:NEAR  #define external entry point} exp
#
#      sysbs is used to implement the snobol4 function backspace
#      if the conditional assembly symbol .cbsp is defined.
#      the meaning is system dependent.  in general, backspace
#      repositions the file one record closer to the beginning
#      of file, such that a subsequent read or write will
#      operate on the previous record.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  backspace argument (scblk ptr)
#      jsr  sysbs            call to backspace
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if backspace not allowed
#      ppm  loc              return here if i/o error
#      (wa,wb)               destroyed
#
#      the second error return is used for files for which
#      backspace is not permitted. for example, it may be expected
#      files on character devices are in this category.
                            #} ejc
        .eject
#
#      sysbx -- before execution
#
        .extern sysbx:NEAR  #define external entry point} exp
#
#      called after initial spitbol compilation and before
#      commencing execution in case osint needs
#      to assign files or perform other necessary services.
#      osint may also choose to send a message to online
#      terminal (if any) indicating that execution is starting.
#
#      jsr  sysbx            call before execution starts
                            #} ejc
        .eject
#
#      sysdc -- date check
#
        .extern sysdc:NEAR  #define external entry point} exp
#
#      sysdc is called to check that the expiry date for a trial
#      version of spitbol is unexpired.
#
#      jsr  sysdc            call to check date
#      return only if date is ok
                            #} ejc
        .eject
#
#      sysdm  -- dump core
#
        .extern sysdm:NEAR  #define external entry point} exp
#
#      sysdm is called by a spitbol program call of dump(n) with
#      n ge 4.  its purpose is to provide a core dump.
#      n could hold an encoding of the start adrs for dump and
#      amount to be dumped e.g.  n = 256*a + s , s = start adrs
#      in kilowords,  a = kilowords to dump
#
#      (xr)                  parameter n of call dump(n)
#      jsr  sysdm            call to enter routine
                            #} ejc
        .eject
#
#      sysdt -- get current date
#
        .extern sysdt:NEAR  #define external entry point} exp
#
#      sysdt is used to obtain the current date. the date is
#      returned as a character string in any format appropriate
#      to the operating system in use. it may also contain the
#      current time of day. sysdt is used to implement the
#      snobol4 function date().
#
#      (xr)                  parameter n of call date(n)
#      jsr  sysdt            call to get date
#      (xl)                  pointer to block containing date
#
#      the format of the block is like an scblk except that
#      the first word need not be set. the result is copied
#      into spitbol dynamic memory on return.
                            #} ejc
        .eject
#
#      sysea -- inform osint of compilation and runtime errors
#
        .extern sysea:NEAR  #define external entry point} exp
#
#      provides means for interface to take special actions on
#      errors
#
#      (wa)                  error code
#      (wb)                  line number
#      (wc)                  column number
#      (xr)                  system stage
#      (xl)                  file name (scblk)
#      jsr  sysea            call to sysea function
#      ppm  loc              suppress printing of error message
#      (xr)                  message to print (scblk) or 0
#
#      sysea may not return if interface chooses to retain
#      control.  closing files via the fcb chain will be the
#      responsibility of the interface.
#
#      all registers preserved
                            #} ejc
        .eject
#
#      sysef -- eject file
#
        .extern sysef:NEAR  #define external entry point} exp
#
#      sysef is used to write a page eject to a named file. it
#      may only be used for files where this concept makes
#      sense. note that sysef is not normally used for the
#      standard output file (see sysep).
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  eject argument (scblk ptr)
#      jsr  sysef            call to eject file
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if inappropriate file
#      ppm  loc              return here if i/o error
                            #} ejc
        .eject
#
#      sysej -- end of job
#
        .extern sysej:NEAR  #define external entry point} exp
#
#      sysej is called once at the end of execution to
#      terminate the run. the significance of the abend and
#      code values is system dependent. in general, the code
#      value should be made available for testing, and the
#      abend value should cause some post-mortem action such as
#      a dump. note that sysej does not return to its caller.
#      see sysxi for details of fcblk chain
#
#      (wa)                  value of abend keyword
#      (wb)                  value of code keyword
#      (xl)                  o or ptr to head of fcblk chain
#      jsr  sysej            call to end job
#
#      the following special values are used as codes in (wb)
#      999  execution suppressed
#      998  standard output file full or unavailable in a sysxi
#           load module. in these cases (wa) contains the number
#           of the statement causing premature termination.
                            #} ejc
        .eject
#
#      sysem -- get error message text
#
        .extern sysem:NEAR  #define external entry point} exp
#
#      sysem is used to obtain the text of err, erb calls in the
#      source program given the error code number. it is allowed
#      to return a null string if this facility is unavailable.
#
#      (wa)                  error code number
#      jsr  sysem            call to get text
#      (xr)                  text of message
#
#      the returned value is a pointer to a block in scblk
#      format except that the first word need not be set. the
#      string is copied into dynamic memory on return.
#      if the null string is returned either because sysem does
#      not provide error message texts or because wa is out of
#      range, spitbol will print the string stored in errtext
#      keyword.
                            #} ejc
        .eject
#
#      sysen -- endfile
#
        .extern sysen:NEAR  #define external entry point} exp
#
#      sysen is used to implement the snobol4 function endfile.
#      the meaning is system dependent. in general, endfile
#      implies that no further i/o operations will be performed,
#      but does not guarantee this to be the case. the file
#      should be closed after the call, a subsequent read
#      or write may reopen the file at the start or it may be
#      necessary to reopen the file via sysio.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  endfile argument (scblk ptr)
#      jsr  sysen            call to endfile
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if endfile not allowed
#      ppm  loc              return here if i/o error
#      (wa,wb)               destroyed
#
#      the second error return is used for files for which
#      endfile is not permitted. for example, it may be expected
#      that the standard input and output files are in this
#      category.
                            #} ejc
        .eject
#
#      sysep -- eject printer page
#
        .extern sysep:NEAR  #define external entry point} exp
#
#      sysep is called to perform a page eject on the standard
#      printer output file (corresponding to syspr output).
#
#      jsr  sysep            call to eject printer output
                            #} ejc
        .eject
#
#      sysex -- call external function
#
        .extern sysex:NEAR  #define external entry point} exp
#
#      sysex is called to pass control to an external function
#      previously loaded with a call to sysld.
#
#      (xs)                  pointer to arguments on stack
#      (xl)                  pointer to control block (efblk)
#      (wa)                  number of arguments on stack
#      jsr  sysex            call to pass control to function
#      ppm  loc              return here if function call fails
#      ppm  loc              return here if insufficient memory
#      ppm  loc              return here if bad argument type
#      (xr)                  result returned
#
#      the arguments are stored on the stack with
#      the last argument at 0(xs). on return, xs
#      is popped past the arguments.
#
#      the form of the arguments as passed is that used in the
#      spitbol translator (see definitions and data structures
#      section). the control block format is also described
#      (under efblk) in this section.
#
#      there are two ways of returning a result.
#
#      1)   return a pointer to a block in dynamic storage. this
#           block must be in exactly correct format, including
#           the first word. only functions written with intimate
#           knowledge of the system will return in this way.
#
#      2)   string, integer and real results may be returned by
#           pointing to a pseudo-block outside dynamic memory.
#           this block is in icblk, rcblk or scblk format except
#           that the first word will be overwritten
#           by a type word on return and so need not
#           be correctly set. such a result is
#           copied into main storage before proceeding.
#           unconverted results may similarly be returned in a
#           pseudo-block which is in correct format including
#           type word recognisable by garbage collector since
#           block is copied into dynamic memory.
                            #} ejc
        .eject
#
#      sysfc -- file control block routine
#
        .extern sysfc:NEAR  #define external entry point} exp
#
#      see also sysio
#      input and output have 3 arguments referred to as shown
#           input(variable name,file arg1,file arg2)
#           output(variable name,file arg1,file arg2)
#      file arg1 may be an integer or string used to identify
#      an i/o channel. it is converted to a string for checking.
#      the exact significance of file arg2
#      is not rigorously prescribed but to improve portability,
#      the scheme described in the spitbol user manual
#      should be adopted when possible. the preferred form is
#      a string $f$,r$r$,c$c$,i$i$,...,z$z$  where
#      $f$ is an optional file name which is placed first.
#       remaining items may be omitted or included in any order.
#      $r$ is maximum record length
#      $c$ is a carriage control character or character string
#      $i$ is some form of channel identification used in the
#         absence of $f$ to associate the variable
#         with a file allocated dynamically by jcl commands at
#         spitbol load time.
#      ,...,z$z$ are additional fields.
#      if , (comma) cannot be used as a delimiter, .ciod
#      should be defined to introduce by conditional assembly
#      another delimiter (see
#        iodel  equ  *
#      early in definitions section).
#      sysfc is called when a variable is input or output
#      associated to check file arg1 and file arg2 and
#      to  report whether an fcblk (file control
#      block) is necessary and if so what size it should be.
#      this makes it possible for spitbol rather than osint to
#      allocate such a block in dynamic memory if required
#      or alternatively in static memory.
#      the significance of an fcblk , if one is requested, is
#      entirely up to the system interface. the only restriction
#      is that if the fcblk should appear to lie in dynamic
#      memory, pointers to it should be proper pointers to
#      the start of a recognisable and garbage collectable
#      block (this condition will be met if sysfc requests
#      spitbol to provide an fcblk).
#      an option is provided for osint to return a pointer in
#      xl to an fcblk which it privately allocated. this ptr
#      will be made available when i/o occurs later.
#      private fcblks may have arbitrary contents and spitbol
#      stores nothing in them.
                            #} ejc
        .eject
#      the requested size for an fcblk in dynamic memory
#      should allow a 2 word overhead for block type and
#      length fields. information subsequently stored in the
#      remaining words may be arbitrary if an xnblk (external
#      non-relocatable block) is requested. if the request is
#      for an xrblk (external relocatable block) the
#      contents of words should be collectable (i.e. any
#      apparent pointers into dynamic should be genuine block
#      pointers). these restrictions do not apply if an fcblk
#      is allocated outside dynamic or is not allocated at all.
#      if an fcblk is requested, its fields will be initialised
#      to zero before entry to sysio with the exception of
#      words 0 and 1 in which the block type and length
#      fields are placed for fcblks in dynamic memory only.
#      for the possible use of sysej and sysxi, if fcblks
#      are used, a chain is built so that they may all be
#      found - see sysxi for details.
#      if both file arg1 and file arg2 are null, calls of sysfc
#      and sysio are omitted.
#      if file arg1 is null (standard input/output file), sysfc
#      is called to check non-null file arg2 but any request
#      for an fcblk will be ignored, since spitbol handles the
#      standard files specially and cannot readily keep fcblk
#      pointers for them.
#      filearg1 is type checked by spitbol so further checking
#      may be unneccessary in many implementations.
#      file arg2 is passed so that sysfc may analyse and
#      check it. however to assist in this, spitbol also passes
#      on the stack the components of this argument with
#      file name, $f$ (otherwise null) extracted and stacked
#      first.
#      the other fields, if any, are extracted as substrings,
#      pointers to them are stacked and a count of all items
#      stacked is placed in wc. if an fcblk was earlier
#      allocated and pointed to via file arg1, sysfc is also
#      passed a pointer to this fcblk.
#
#      (xl)                  file arg1 scblk ptr (2nd arg)
#      (xr)                  filearg2 (3rd arg) or null
#      -(xs)...-(xs)         scblks for $f$,$r$,$c$,...
#      (wc)                  no. of stacked scblks above
#      (wa)                  existing file arg1 fcblk ptr or 0
#      (wb)                  0/3 for input/output assocn
#      jsr  sysfc            call to check need for fcblk
#      ppm  loc              invalid file argument
#      ppm  loc              fcblk already in use
#      (xs)                  popped (wc) times
#      (wa non zero)         byte size of requested fcblk
#      (wa=0,xl non zero)    private fcblk ptr in xl
#      (wa=xl=0)             no fcblk wanted, no private fcblk
#      (wc)                  0/1/2 request alloc of xrblk/xnblk
#                            /static block for use as fcblk
#      (wb)                  destroyed
                            #} ejc
        .eject
#
#      sysgc -- inform interface of garbage collections
#
        .extern sysgc:NEAR  #define external entry point} exp
#
#      provides means for interface to take special actions
#      prior to and after a garbage collection.
#
#      possible usages-
#      1. provide visible screen icon of garbage collection
#         in progress
#      2. inform virtual memory manager to ignore page access
#         patterns during garbage collection.  such accesses
#         typically destroy the page working set accumulated
#         by the program.
#      3. inform virtual memory manager that contents of memory
#         freed by garbage collection can be discarded.
#
#      (xr)                  non-zero if beginning gc
#                            =0 if completing gc
#      (wa)                  dnamb=start of dynamic area
#      (wb)                  dnamp=next available location
#      (wc)                  dname=last available location + 1
#      jsr  sysgc            call to sysgc function
#      all registers preserved
                            #} ejc
        .eject
#
#      syshs -- give access to host computer features
#
        .extern syshs:NEAR  #define external entry point} exp
#
#      provides means for implementing special features
#      on different host computers. the only defined entry is
#      that where all arguments are null in which case syshs
#      returns an scblk containing name of computer,
#      name of operating system and name of site separated by
#      colons. the scblk need not have a correct first field
#      as this is supplied on copying string to dynamic memory.
#      spitbol does no argument checking but does provide a
#      single error return for arguments checked as erroneous
#      by osint. it also provides a single execution error
#      return. if these are inadequate, use may be made of the
#      minimal error section direct as described in minimal
#      documentation, section 10.
#      several non-error returns are provided. the first
#      corresponds to the defined entry or, for implementation
#      defined entries, any string may be returned. the others
#      permit respectively,  return a null result, return with a
#      result to be stacked which is pointed at by xr, and a
#      return causing spitbol statement failure. if a returned
#      result is in dynamic memory it must obey garbage
#      collector rules. the only results copied on return
#      are strings returned via ppm loc3 return.
#
#      (wa)                  argument 1
#      (xl)                  argument 2
#      (xr)                  argument 3
#      (wb)                  argument 4
#      (wc)                  argument 5
#      jsr  syshs            call to get host information
#      ppm  loc1             erroneous arg
#      ppm  loc2             execution error
#      ppm  loc3             scblk ptr in xl or 0 if unavailable
#      ppm  loc4             return a null result
#      ppm  loc5             return result in xr
#      ppm  loc6             cause statement failure
#      ppm  loc7             return string at xl, length wa
#      ppm  loc8             return copy of result in xr
                            #} ejc
        .eject
#
#      sysid -- return system identification
#
        .extern sysid:NEAR  #define external entry point} exp
#
#      this routine should return strings to head the standard
#      printer output. the first string will be appended to
#      a heading line of the form
#           macro spitbol version v.v
#      supplied by spitbol itself. v.v are digits giving the
#      major version number and generally at least a minor
#      version number relating to osint should be supplied to
#      give say
#           macro spitbol version v.v(m.m)
#      the second string should identify at least the machine
#      and operating system.  preferably it should include
#      the date and time of the run.
#      optionally the strings may include site name of the
#      the implementor and/or machine on which run takes place,
#      unique site or copy number and other information as
#      appropriate without making it so long as to be a
#      nuisance to users.
#      the first words of the scblks pointed at need not be
#      correctly set.
#
#      jsr  sysid            call for system identification
#      (xr)                  scblk ptr for addition to header
#      (xl)                  scblk ptr for second header
                            #} ejc
        .eject
#
#      sysif -- switch to new include file
#
        .extern sysif:NEAR  #define external entry point} exp
#
#      sysif is used for include file processing, both to inform
#      the interface when a new include file is desired, and
#      when the end of file of an include file has been reached
#      and it is desired to return to reading from the previous
#      nested file.
#
#      it is the responsibility of sysif to remember the file
#      access path to the present input file before switching to
#      the new include file.
#
#      (xl)                  ptr to scblk or zero
#      (xr)                  ptr to vacant scblk of length cswin
#                            (xr not used if xl is zero)
#      jsr  sysif            call to change files
#      ppm  loc              unable to open file
#      (xr)                  scblk with full path name of file
#                            (xr not used if input xl is zero)
#
#      register xl points to an scblk containing the name of the
#      include file to which the interface should switch.  data
#      is fetched from the file upon the next call to sysrd.
#
#      sysif may have the ability to search multiple libraries
#      for the include file named in (xl).  it is therefore
#      required that the full path name of the file where the
#      file was finally located be returned in (xr).  it is this
#      name that is recorded along with the source statements,
#      and will accompany subsequent error messages.
#
#      register xl is zero to mark conclusion of use of an
#      include file.
                            #} ejc
        .eject
#
#      sysil -- get input record length
#
        .extern sysil:NEAR  #define external entry point} exp
#
#      sysil is used to get the length of the next input record
#      from a file previously input associated with a sysio
#      call. the length returned is used to establish a buffer
#      for a subsequent sysin call.  sysil also indicates to the
#      caller if this is a binary or text file.
#
#      (wa)                  ptr to fcblk or zero
#      jsr  sysil            call to get record length
#      (wa)                  length or zero if file closed
#      (wc)                  zero if binary, non-zero if text
#
#      no harm is done if the value returned is too long since
#      unused space will be reclaimed after the sysin call.
#
#      note that it is the sysil call (not the sysio call) which
#      causes the file to be opened as required for the first
#      record input from the file.
                            #} ejc
        .eject
#
#      sysin -- read input record
#
        .extern sysin:NEAR  #define external entry point} exp
#
#      sysin is used to read a record from the file which was
#      referenced in a prior call to sysil (i.e. these calls
#      always occur in pairs). the buffer provided is an
#      scblk for a string of length set from the sysil call.
#      if the actual length read is less than this, the length
#      field of the scblk must be modified before returning
#      unless buffer is right padded with zeroes.
#      it is also permissible to take any of the alternative
#      returns after scblk length has been modified.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  pointer to buffer (scblk ptr)
#      jsr  sysin            call to read record
#      ppm  loc              endfile or no i/p file after sysxi
#      ppm  loc              return here if i/o error
#      ppm  loc              return here if record format error
#      (wa,wb,wc)            destroyed
                            #} ejc
        .eject
#
#      sysio -- input/output file association
#
        .extern sysio:NEAR  #define external entry point} exp
#
#      see also sysfc.
#      sysio is called in response to a snobol4 input or output
#      function call except when file arg1 and file arg2
#      are both null.
#      its call always follows immediately after a call
#      of sysfc. if sysfc requested allocation
#      of an fcblk, its address will be in wa.
#      for input files, non-zero values of $r$ should be
#      copied to wc for use in allocating input buffers. if $r$
#      is defaulted or not implemented, wc should be zeroised.
#      once a file has been opened, subsequent input(),output()
#      calls in which the second argument is identical with that
#      in a previous call, merely associate the additional
#      variable name (first argument) to the file and do not
#      result in re-opening the file.
#      in subsequent associated accesses to the file a pointer
#      to any fcblk allocated will be made available.
#
#      (xl)                  file arg1 scblk ptr (2nd arg)
#      (xr)                  file arg2 scblk ptr (3rd arg)
#      (wa)                  fcblk ptr (0 if none)
#      (wb)                  0 for input, 3 for output
#      jsr  sysio            call to associate file
#      ppm  loc              return here if file does not exist
#      ppm  loc              return if input/output not allowed
#      (xl)                  fcblk pointer (0 if none)
#      (wc)                  0 (for default) or max record lngth
#      (wa,wb)               destroyed
#
#      the second error return is used if the file named exists
#      but input/output from the file is not allowed. for
#      example, the standard output file may be in this category
#      as regards input association.
                            #} ejc
        .eject
#
#      sysld -- load external function
#
        .extern sysld:NEAR  #define external entry point} exp
#
#      sysld is called in response to the use of the snobol4
#      load function. the named function is loaded (whatever
#      this means), and a pointer is returned. the pointer will
#      be used on subsequent calls to the function (see sysex).
#
#      (xr)                  pointer to function name (scblk)
#      (xl)                  pointer to library name (scblk)
#      jsr  sysld            call to load function
#      ppm  loc              return here if func does not exist
#      ppm  loc              return here if i/o error
#      ppm  loc              return here if insufficient memory
#      (xr)                  pointer to loaded code
#
#      the significance of the pointer returned is up to the
#      system interface routine. the only restriction is that
#      if the pointer is within dynamic storage, it must be
#      a proper block pointer.
                            #} ejc
        .eject
#
#      sysmm -- get more memory
#
        .extern sysmm:NEAR  #define external entry point} exp
#
#      sysmm is called in an attempt to allocate more dynamic
#      memory. this memory must be allocated contiguously with
#      the current dynamic data area.
#
#      the amount allocated is up to the system to decide. any
#      value is acceptable including zero if allocation is
#      impossible.
#
#      jsr  sysmm            call to get more memory
#      (xr)                  number of additional words obtained
                            #} ejc
        .eject
#
#      sysmx -- supply mxlen
#
        .extern sysmx:NEAR  #define external entry point} exp
#
#      because of the method of garbage collection, no spitbol
#      object is allowed to occupy more bytes of memory than
#      the integer giving the lowest address of dynamic
#      (garbage collectable) memory. mxlen is the name used to
#      refer to this maximum length of an object and for most
#      users of most implementations, provided dynamic memory
#      starts at an address of at least a few thousand words,
#      there is no problem.
#      if the default starting address is less than say 10000 or
#      20000, then a load time option should be provided where a
#      user can request that he be able to create larger
#      objects. this routine informs spitbol of this request if
#      any. the value returned is either an integer
#      representing the desired value of mxlen (and hence the
#      minimum dynamic store address which may result in
#      non-use of some store) or zero if a default is acceptable
#      in which mxlen is set to the lowest address allocated
#      to dynamic store before compilation starts.
#      if a non-zero value is returned, this is used for keyword
#      maxlngth. otherwise the initial low address of dynamic
#      memory is used for this keyword.
#
#      jsr  sysmx            call to get mxlen
#      (wa)                  either mxlen or 0 for default
                            #} ejc
        .eject
#
#      sysou -- output record
#
        .extern sysou:NEAR  #define external entry point} exp
#
#      sysou is used to write a record to a file previously
#      associated with a sysio call.
#
#      (wa)                  ptr to fcblk
#                            or 0 for terminal or 1 for output
#      (xr)                  record to be written (scblk)
#      jsr  sysou            call to output record
#      ppm  loc              file full or no file after sysxi
#      ppm  loc              return here if i/o error
#      (wa,wb,wc)            destroyed
#
#      note that it is the sysou call (not the sysio call) which
#      causes the file to be opened as required for the first
#      record output to the file.
                            #} ejc
        .eject
#
#      syspi -- print on interactive channel
#
        .extern syspi:NEAR  #define external entry point} exp
#
#      if spitbol is run from an online terminal, osint can
#      request that messages such as copies of compilation
#      errors be sent to the terminal (see syspp). if relevant
#      reply was made by syspp then syspi is called to send such
#      messages to the interactive channel.
#      syspi is also used for sending output to the terminal
#      through the special variable name, terminal.
#
#      (xr)                  ptr to line buffer (scblk)
#      (wa)                  line length
#      jsr  syspi            call to print line
#      ppm  loc              failure return
#      (wa,wb)               destroyed
                            #} ejc
        .eject
#
#      syspl -- provide interactive control of spitbol
#
        .extern syspl:NEAR  #define external entry point} exp
#
#      provides means for interface to take special actions,
#      such as interrupting execution, breakpointing, stepping,
#      and expression evaluation.  these last three options are
#      not presently implemented by the code calling syspl.
#
#
#      (wa)                  opcode as follows-
#                            =0 poll to allow osint to interrupt
#                            =1 breakpoint hit
#                            =2 completion of statement stepping
#                            =3 expression evaluation result
#      (wb)                  statement number
#      r$fcb                 o or ptr to head of fcblk chain
#      jsr  syspl            call to syspl function
#      ppm  loc              user interruption
#      ppm  loc              step one statement
#      ppm  loc              evaluate expression
#      ---                   resume execution
#                            (wa) = new polling interval
#
                            #} ejc
        .eject
#
#      syspp -- obtain print parameters
#
        .extern syspp:NEAR  #define external entry point} exp
#
#      syspp is called once during compilation to obtain
#      parameters required for correct printed output format
#      and to select other options. it may also be called again
#      after sysxi when a load module is resumed. in this
#      case the value returned in wa may be less than or equal
#      to that returned in initial call but may not be
#      greater.
#      the information returned is -
#      1.   line length in chars for standard print file
#      2.   no of lines/page. 0 is preferable for a non-paged
#           device (e.g. online terminal) in which case listing
#           page throws are suppressed and page headers
#           resulting from -title,-stitl lines are kept short.
#      3.   an initial -nolist option to suppress listing unless
#           the program contains an explicit -list.
#      4.   options to suppress listing of compilation and/or
#           execution stats (useful for established programs) -
#           combined with 3. gives possibility of listing
#           file never being opened.
#      5.   option to have copies of errors sent to an
#           interactive channel in addition to standard printer.
#      6.   option to keep page headers short (e.g. if listing
#           to an online terminal).
#      7.   an option to choose extended or compact listing
#           format. in the former a page eject and in the latter
#           a few line feeds precede the printing of each
#           of-- listing, compilation statistics, execution
#           output and execution statistics.
#      8.   an option to suppress execution as though a
#           -noexecute card were supplied.
#      9.   an option to request that name /terminal/  be pre-
#           associated to an online terminal via syspi and sysri
#      10.  an intermediate (standard) listing option requiring
#           that page ejects occur in source listings. redundant
#           if extended option chosen but partially extends
#           compact option.
#      11.  option to suppress sysid identification.
#
#      jsr  syspp            call to get print parameters
#      (wa)                  print line length in chars
#      (wb)                  number of lines/page
#      (wc)                  bits value ...mlkjihgfedcba where
#                            a = 1 to send error copy to int.ch.
#                            b = 1 means std printer is int. ch.
#                            c = 1 for -nolist option
#                            d = 1 to suppress compiln. stats
#
#                            e = 1 to suppress execn. stats
#                            f = 1/0 for extnded/compact listing
#                            g = 1 for -noexecute
#                            h = 1 pre-associate /terminal/
#
#                            i = 1 for standard listing option.
#                            j = 1 suppresses listing header
#                            k = 1 for -print
#                            l = 1 for -noerrors
#
#                            m = 1 for -case 1
                            #} ejc
        .eject
#
#      syspr -- print line on standard output file
#
        .extern syspr:NEAR  #define external entry point} exp
#
#      syspr is used to print a single line on the standard
#      output file.
#
#      (xr)                  pointer to line buffer (scblk)
#      (wa)                  line length
#      jsr  syspr            call to print line
#      ppm  loc              too much o/p or no file after sysxi
#      (wa,wb)               destroyed
#
#      the buffer pointed to is the length obtained from the
#      syspp call and is filled out with trailing blanks. the
#      value in wa is the actual line length which may be less
#      than the maximum line length possible. there is no space
#      control associated with the line, all lines are printed
#      single spaced. note that null lines (wa=0) are possible
#      in which case a blank line is to be printed.
#
#      the error exit is used for systems which limit the amount
#      of printed output. if possible, printing should be
#      permitted after this condition has been signalled once to
#      allow for dump and other diagnostic information.
#      assuming this to be possible, spitbol may make more syspr
#      calls. if the error return occurs another time, execution
#      is terminated by a call of sysej with ending code 998.
                            #} ejc
        .eject
#
#      sysrd -- read record from standard input file
#
        .extern sysrd:NEAR  #define external entry point} exp
#
#      sysrd is used to read a record from the standard input
#      file. the buffer provided is an scblk for a string the
#      length of which in characters is given in wc, this
#      corresponding to the maximum length of string which
#      spitbol is prepared to receive. at compile time it
#      corresponds to xxx in the most recent -inxxx card
#      (default 72) and at execution time to the most recent
#      ,r$r$ (record length) in the third arg of an input()
#      statement for the standard input file (default 80).
#      if fewer than (wc) characters are read, the length
#      field of the scblk must be adjusted before returning
#      unless the buffer is right padded with zeroes.
#      it is also permissible to take the alternative return
#      after such an adjustment has been made.
#      spitbol may continue to make calls after an endfile
#      return so this routine should be prepared to make
#      repeated endfile returns.
#
#      (xr)                  pointer to buffer (scblk ptr)
#      (wc)                  length of buffer in characters
#      jsr  sysrd            call to read line
#      ppm  loc              endfile or no i/p file after sysxi
#                            or input file name change.  if
#                            the former, scblk length is zero.
#                            if input file name change, length
#                            is non-zero. caller should re-issue
#                            sysrd to obtain input record.
#      (wa,wb,wc)            destroyed
                            #} ejc
        .eject
#
#      sysri -- read record from interactive channel
#
        .extern sysri:NEAR  #define external entry point} exp
#
#      reads a record from online terminal for spitbol variable,
#      terminal. if online terminal is unavailable then code the
#      endfile return only.
#      the buffer provided is of length 258 characters. sysri
#      should replace the count in the second word of the scblk
#      by the actual character count unless buffer is right
#      padded with zeroes.
#      it is also permissible to take the alternative
#      return after adjusting the count.
#      the end of file return may be used if this makes
#      sense on the target machine (e.g. if there is an
#      eof character.)
#
#      (xr)                  ptr to 258 char buffer (scblk ptr)
#      jsr  sysri            call to read line from terminal
#      ppm  loc              end of file return
#      (wa,wb,wc)            may be destroyed
                            #} ejc
        .eject
#
#      sysrw -- rewind file
#
        .extern sysrw:NEAR  #define external entry point} exp
#
#      sysrw is used to rewind a file i.e. reposition the file
#      at the start before the first record. the file should be
#      closed and the next read or write call will open the
#      file at the start.
#
#      (wa)                  ptr to fcblk or zero
#      (xr)                  rewind arg (scblk ptr)
#      jsr  sysrw            call to rewind file
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if rewind not allowed
#      ppm  loc              return here if i/o error
                            #} ejc
        .eject
#
#      sysst -- set file pointer
#
        .extern sysst:NEAR  #define external entry point} exp
#
#      sysst is called to change the position of a file
#      pointer. this is accomplished in a system dependent
#      manner, and thus the 2nd and 3rd arguments are passed
#      unconverted.
#
#      (wa)                  fcblk pointer
#      (wb)                  2nd argument
#      (wc)                  3rd argument
#      jsr  sysst            call to set file pointer
#      ppm  loc              return here if invalid 2nd arg
#      ppm  loc              return here if invalid 3rd arg
#      ppm  loc              return here if file does not exist
#      ppm  loc              return here if set not allowed
#      ppm  loc              return here if i/o error
#
                            #} ejc
        .eject
#
#      systm -- get execution time so far
#
        .extern systm:NEAR  #define external entry point} exp
#
#      systm is used to obtain the amount of execution time
#      used so far since spitbol was given control. the units
#      are described as milliseconds in the spitbol output, but
#      the exact meaning is system dependent. where appropriate,
#      this value should relate to processor rather than clock
#      timing values.
#      if the symbol .ctmd is defined, the units are described
#      as deciseconds (0.1 second).
#
#      jsr  systm            call to get timer value
#      (ia)                  time so far in milliseconds
#                            (deciseconds if .ctmd defined)
                            #} ejc
        .eject
#
#      systt -- trace toggle
#
        .extern systt:NEAR  #define external entry point} exp
#
#      called by spitbol function trace() with no args to
#      toggle the system trace switch.  this permits tracing of
#      labels in spitbol code to be turned on or off.
#
#      jsr  systt            call to toggle trace switch
                            #} ejc
        .eject
#
#      sysul -- unload external function
#
        .extern sysul:NEAR  #define external entry point} exp
#
#      sysul is used to unload a function previously
#      loaded with a call to sysld.
#
#      (xr)                  ptr to control block (efblk)
#      jsr  sysul            call to unload function
#
#      the function cannot be called following a sysul call
#      until another sysld call is made for the same function.
#
#      the efblk contains the function code pointer and also a
#      pointer to the vrblk containing the function name (see
#      definitions and data structures section).
                            #} ejc
        .eject
#
#      sysxi -- exit to produce load module
#
        .extern sysxi:NEAR  #define external entry point} exp
#
#      when sysxi is called, xl contains either a string pointer
#      or zero. in the former case, the string gives the
#      character name of a program. the intention is that
#      spitbol execution should be terminated forthwith and
#      the named program loaded and executed. this type of chain
#      execution is very system dependent and implementors may
#      choose to omit it or find it impossible to provide.
#      if (xl) is zero,ia contains one of the following integers
#
#      -1, -2, -3, -4
#           create if possible a load module containing only the
#           impure area of memory which needs to be loaded with
#           a compatible pure segment for subsequent executions.
#           version numbers to check compatibility should be
#           kept in both segments and checked on loading.
#           to assist with this check, (xr) on entry is a
#           pointer to an scblk containing the spitbol major
#           version number v.v (see sysid).  the file thus
#           created is called a save file.
#
#      0    if possible, return control to job control
#           command level. the effect if available will be
#           system dependent.
#
#      +1, +2, +3, +4
#           create if possible a load module from all of
#           memory. it should be possible to load and execute
#           this module directly.
#
#      in the case of saved load modules, the status of open
#      files is not preserved and implementors may choose to
#      offer means of attaching files before execution of load
#      modules starts or leave it to the user to include
#      suitable input(), output() calls in his program.
#      sysxi should make a note that no i/o channels,
#      including standard files, have files attached so that
#      calls of sysin, sysou, syspr, sysrd should fail unless
#      new associations are made for the load module.
#      at least in the case of the standard output file, it is
#      recommended that either the user be required to attach
#      a file or that a default file is attached, since the
#      problem of error messages generated by the load module
#      is otherwise severe. as a last resort, if spitbol
#      attempts to write to the standard output file and gets a
#      reply indicating that such ouput is unacceptable it stops
#      by using an entry to sysej with ending code 998.
#      as described below, passing of some arguments makes it
#      clear that load module will use a standard output file.
#
#      if use is made of fcblks for i/o association, spitbol
#      builds a chain so that those in use may be found in sysxi
#      and sysej. the nodes are 4 words long. third word
#      contains link to next node or 0, fourth word contains
#      fcblk pointer.
                            #} ejc
        .eject
#
#      sysxi (continued)
#
#      (xl)                  zero or scblk ptr to first argument
#      (xr)                  ptr to v.v scblk
#      (ia)                  signed integer argument
#      (wa)                  scblk ptr to second argument
#      (wb)                  0 or ptr to head of fcblk chain
#      jsr  sysxi            call to exit
#      ppm  loc              requested action not possible
#      ppm  loc              action caused irrecoverable error
#      (wb,wc,ia,xr,xl,cp)   should be preserved over call
#      (wa)                  0 in all cases except sucessful
#                            performance of exit(4) or exit(-4),
#                            in which case 1 should be returned.
#
#      loading and running the load module or returning from
#      jcl command level causes execution to resume at the point
#      after the error returns which follow the call of sysxi.
#      the value passed as exit argument is used to indicate
#      options required on resumption of load module.
#      +1 or -1 require that on resumption, sysid and syspp be
#      called and a heading printed on the standard output file.
#      +2 or -2 indicate that syspp will be called but not sysid
#      and no heading will be put on standard output file.
#      above options have the obvious implication that a
#      standard o/p file must be provided for the load module.
#      +3, +4, -3 or -4 indicate calls of neither sysid nor
#      syspp and no heading will be placed on standard output
#      file.
#      +4 or -4 indicate that execution is to continue after
#      creation of the save file or load module, although all
#      files will be closed by the sysxi action.  this permits
#      the user to checkpoint long-running programs while
#      continuing execution.
#
#      no return from sysxi is possible if another program
#      is loaded and entered.
                            #} ejc
        .eject
#
#      introduce the internal procedures.
#
                            #} ejc
        .eject
                            #} ejc
        .eject
#
#      introduce the internal routines
#
                            #} ttl s p i t b o l -- definitions and data structures
        .sbttl "s p i t b o l -- definitions and data structures"
#      this section contains all symbol definitions and also
#      pictures of all data structures used in the system.
#
                            #start of definitions section} sec
        CSegEnd_
        DSeg_
        .global SEC02
SEC02:
#
#      definitions of machine parameters
#
#      the minimal translator should supply appropriate values
#      for the particular target machine for all the
#      equ  *
#      definitions given at the start of this section.
#      note that even if conditional assembly is used to omit
#      some feature (e.g. real arithmetic) a full set of cfp$-
#      values must be supplied. use dummy values if genuine
#      ones are not needed.
#
cfp_a   =    256            #number of characters in alphabet} equ 256
#
cfp_b   =    4              #bytes/word addressing factor} equ 4
#
cfp_c   =    4              #number of characters per word} equ 4
#
cfp_f   =    8              #offset in bytes to chars in} equ 8
#                            scblk. see scblk format.
#
cfp_i   =    1              #number of words in integer constant} equ 1
#
cfp_m   =    2147483647     #max positive integer in one word} equ 2147483647
#
cfp_n   =    32             #number of bits in one word} equ 32
#
#      the following definitions require the supply of either
#      a single parameter if real arithmetic is omitted or
#      three parameters if real arithmetic is included.
#
#
cfp_r   =    2              #number of words in real constant} equ 2
#
cfp_s   =    9              #number of sig digs for real output} equ 9
#
cfp_x   =    3              #max digits in real exponent} equ 3
#
mxdgs   =    cfp_s+cfp_x    #max digits in real number} equ cfp_s+cfp_x
#
#
#      max space for real (for +0.e+) needs five more places
#
nstmx   =    mxdgs+5        #max space for real} equ mxdgs+5
#
#      the following definition for cfp$u supplies a realistic
#      upper bound on the size of the alphabet.  cfp$u is used
#      to save space in the scane bsw-iff-esw table and to ease
#      translation storage requirements.
#
cfp_u   =    128            #realistic upper bound on alphabet} equ 128
                            #} ejc
        .eject
#
#      environment parameters
#
#      the spitbol program is essentially independent of
#      the definitions of these parameters. however, the
#      efficiency of the system may be affected. consequently,
#      these parameters may require tuning for a given version
#      the values given in comments have been successfully used.
#
#      e$srs is the number of words to reserve at the end of
#      storage for end of run processing. it should be
#      set as small as possible without causing memory overflow
#      in critical situations (e.g. memory overflow termination)
#      and should thus reserve sufficient space at least for
#      an scblk containing say 30 characters.
#
e_srs   =    100            #30 words} equ 100
#
#      e$sts is the number of words grabbed in a chunk when
#      storage is allocated in the static region. the minimum
#      permitted value is 256/cfp$b. larger values will lead
#      to increased efficiency at the cost of wasting memory.
#
e_sts   =    1000           #500 words} equ 1000
#
#      e$cbs is the size of code block allocated initially and
#      the expansion increment if overflow occurs. if this value
#      is too small or too large, excessive garbage collections
#      will occur during compilation and memory may be lost
#      in the case of a too large value.
#
e_cbs   =    500            #500 words} equ 500
#
#      e$hnb is the number of bucket headers in the variable
#      hash table. it should always be odd. larger values will
#      speed up compilation and indirect references at the
#      expense of additional storage for the hash table itself.
#
e_hnb   =    257            #127 bucket headers} equ 257
#
#      e$hnw is the maximum number of words of a string
#      name which participate in the string hash algorithm.
#      larger values give a better hash at the expense of taking
#      longer to compute the hash. there is some optimal value.
#
e_hnw   =    6              #6 words} equ 6
#
#      e$fsp.  if the amount of free space left after a garbage
#      collection is small compared to the total amount of space
#      in use garbage collector thrashing is likely to occur as
#      this space is used up.  e$fsp is a measure of the
#      minimum percentage of dynamic memory left as free space
#      before the system routine sysmm is called to try to
#      obtain more memory.
#
e_fsp   =    15             #15 percent} equ 15
#
#      e$sed.  if the amount of free space left in the sediment
#      after a garbage collection is a significant fraction of
#      the new sediment size, the sediment is marked for
#      collection on the next call to the garbage collector.
#
e_sed   =    25             #25 percent} equ 25
                            #} ejc
        .eject
#
#      definitions of codes for letters
#
ch_la   =    65             #letter a} equ 65
ch_lb   =    66             #letter b} equ 66
ch_lc   =    67             #letter c} equ 67
ch_ld   =    68             #letter d} equ 68
ch_le   =    69             #letter e} equ 69
ch_lf   =    70             #letter f} equ 70
ch_lg   =    71             #letter g} equ 71
ch_lh   =    72             #letter h} equ 72
ch_li   =    73             #letter i} equ 73
ch_lj   =    74             #letter j} equ 74
ch_lk   =    75             #letter k} equ 75
ch_ll   =    76             #letter l} equ 76
ch_lm   =    77             #letter m} equ 77
ch_ln   =    78             #letter n} equ 78
ch_lo   =    79             #letter o} equ 79
ch_lp   =    80             #letter p} equ 80
ch_lq   =    81             #letter q} equ 81
ch_lr   =    82             #letter r} equ 82
ch_ls   =    83             #letter s} equ 83
ch_lt   =    84             #letter t} equ 84
ch_lu   =    85             #letter u} equ 85
ch_lv   =    86             #letter v} equ 86
ch_lw   =    87             #letter w} equ 87
ch_lx   =    88             #letter x} equ 88
ch_ly   =    89             #letter y} equ 89
ch_l_   =    90             #letter z} equ 90
#
#      definitions of codes for digits
#
ch_d0   =    48             #digit 0} equ 48
ch_d1   =    49             #digit 1} equ 49
ch_d2   =    50             #digit 2} equ 50
ch_d3   =    51             #digit 3} equ 51
ch_d4   =    52             #digit 4} equ 52
ch_d5   =    53             #digit 5} equ 53
ch_d6   =    54             #digit 6} equ 54
ch_d7   =    55             #digit 7} equ 55
ch_d8   =    56             #digit 8} equ 56
ch_d9   =    57             #digit 9} equ 57
                            #} ejc
        .eject
#
#      definitions of codes for special characters
#
#      the names of these characters are related to their
#      original representation in the ebcdic set corresponding
#      to the description in standard snobol4 manuals and texts.
#
ch_am   =    38             #keyword operator (ampersand)} equ 38
ch_as   =    42             #multiplication symbol (asterisk)} equ 42
ch_at   =    64             #cursor position operator (at)} equ 64
ch_bb   =    60             #left array bracket (less than)} equ 60
ch_bl   =    32             #blank} equ 32
ch_br   =    124            #alternation operator (vertical bar)} equ 124
ch_cl   =    58             #goto symbol (colon)} equ 58
ch_cm   =    44             #comma} equ 44
ch_dl   =    36             #indirection operator (dollar)} equ 36
ch_dt   =    46             #name operator (dot)} equ 46
ch_dq   =    34             #double quote} equ 34
ch_eq   =    61             #equal sign} equ 61
ch_ex   =    33             #exponentiation operator (exclm)} equ 33
ch_mn   =    45             #minus sign / hyphen} equ 45
ch_nm   =    35             #number sign} equ 35
ch_nt   =    126            #negation operator (not)} equ 126
ch_pc   =    37             #percent} equ 37
ch_pl   =    43             #plus sign} equ 43
ch_pp   =    40             #left parenthesis} equ 40
ch_rb   =    62             #right array bracket (grtr than)} equ 62
ch_rp   =    41             #right parenthesis} equ 41
ch_qu   =    63             #interrogation operator (question)} equ 63
ch_sl   =    47             #slash} equ 47
ch_sm   =    59             #semicolon} equ 59
ch_sq   =    39             #single quote} equ 39
ch_un   =    95             #special identifier char (underline)} equ 95
ch_ob   =    91             #opening bracket} equ 91
ch_cb   =    93             #closing bracket} equ 93
                            #} ejc
        .eject
#
#      remaining chars are optional additions to the standards.
#
#      tab characters - syntactically equivalent to blank
#
ch_ht   =    9              #horizontal tab} equ 9
#
#      up arrow same as exclamation mark for exponentiation
#
ch_ey   =    94             #up arrow} equ 94
#
#      lower case or shifted case alphabetic chars
#
ch__a   =    97             #shifted a} equ 97
ch__b   =    98             #shifted b} equ 98
ch__c   =    99             #shifted c} equ 99
ch__d   =    100            #shifted d} equ 100
ch__e   =    101            #shifted e} equ 101
ch__f   =    102            #shifted f} equ 102
ch__g   =    103            #shifted g} equ 103
ch__h   =    104            #shifted h} equ 104
ch__i   =    105            #shifted i} equ 105
ch__j   =    106            #shifted j} equ 106
ch__k   =    107            #shifted k} equ 107
ch__l   =    108            #shifted l} equ 108
ch__m   =    109            #shifted m} equ 109
ch__n   =    110            #shifted n} equ 110
ch__o   =    111            #shifted o} equ 111
ch__p   =    112            #shifted p} equ 112
ch__q   =    113            #shifted q} equ 113
ch__r   =    114            #shifted r} equ 114
ch__s   =    115            #shifted s} equ 115
ch__t   =    116            #shifted t} equ 116
ch__u   =    117            #shifted u} equ 117
ch__v   =    118            #shifted v} equ 118
ch__w   =    119            #shifted w} equ 119
ch__x   =    120            #shifted x} equ 120
ch__y   =    121            #shifted y} equ 121
ch___   =    122            #shifted z} equ 122
#      if a delimiter other than ch$cm must be used in
#      the third argument of input(),output() then .ciod should
#      be defined and a parameter supplied for iodel.
#
iodel   =    32             #} equ 32
                            #} ejc
        .eject
#
#      data block formats and definitions
#
#      the following sections describe the detailed format of
#      all possible data blocks in static and dynamic memory.
#
#      every block has a name of the form xxblk where xx is a
#      unique two character identifier. the first word of every
#      block must contain a pointer to a program location in the
#      interpretor which is immediately preceded by an address
#      constant containing the value bl$xx where xx is the block
#      identifier. this provides a uniform mechanism for
#      distinguishing between the various block types.
#
#      in some cases, the contents of the first word is constant
#      for a given block type and merely serves as a pointer
#      to the identifying address constant. however, in other
#      cases there are several possibilities for the first
#      word in which case each of the several program entry
#      points must be preceded by the appropriate constant.
#
#      in each block, some of the fields are relocatable. this
#      means that they may contain a pointer to another block
#      in the dynamic area. (to be more precise, if they contain
#      a pointer within the dynamic area, then it is a pointer
#      to a block). such fields must be modified by the garbage
#      collector (procedure gbcol) whenever blocks are compacted
#      in the dynamic region. the garbage collector (actually
#      procedure gbcpf) requires that all such relocatable
#      fields in a block must be contiguous.
                            #} ejc
        .eject
#
#      the description format uses the following scheme.
#
#      1)   block title and two character identifier
#
#      2)   description of basic use of block and indication
#           of circumstances under which it is constructed.
#
#      3)   picture of the block format. in these pictures low
#           memory addresses are at the top of the page. fixed
#           length fields are surrounded by i (letter i). fields
#           which are fixed length but whose length is dependent
#           on a configuration parameter are surrounded by *
#           (asterisk). variable length fields are surrounded
#           by / (slash).
#
#      4)   definition of symbolic offsets to fields in
#           block and of the size of the block if fixed length
#           or of the size of the fixed length fields if the
#           block is variable length.
#           note that some routines such as gbcpf assume
#           certain offsets are equal. the definitions
#           given here enforce this.  make changes to
#           them only with due care.
#
#      definitions of common offsets
#
offs1   =    1              #} equ 1
offs2   =    2              #} equ 2
offs3   =    3              #} equ 3
#
#      5)   detailed comments on the significance and formats
#           of the various fields.
#
#      the order is alphabetical by identification code.
                            #} ejc
        .eject
#
#      definitions of block codes
#
#      this table provides a unique identification code for
#      each separate block type. the first word of a block in
#      the dynamic area always contains the address of a program
#      entry point. the block code is used as the entry point id
#      the order of these codes dictates the order of the table
#      used by the datatype function (scnmt in the constant sec)
#
#      block codes for accessible datatypes
#
#      note that real and buffer types are always included, even
#      if they are conditionally excluded elsewhere.  this main-
#      tains block type codes across all versions of spitbol,
#      providing consistancy for external functions.  but note
#      that the bcblk is out of alphabetic order, placed at the
#      end of the list so as not to change the block type
#      ordering in use in existing external functions.
#
bl_ar   =    0              #arblk     array} equ 0
bl_cd   =    bl_ar+1        #cdblk     code} equ bl_ar+1
bl_ex   =    bl_cd+1        #exblk     expression} equ bl_cd+1
bl_ic   =    bl_ex+1        #icblk     integer} equ bl_ex+1
bl_nm   =    bl_ic+1        #nmblk     name} equ bl_ic+1
bl_p0   =    bl_nm+1        #p0blk     pattern} equ bl_nm+1
bl_p1   =    bl_p0+1        #p1blk     pattern} equ bl_p0+1
bl_p2   =    bl_p1+1        #p2blk     pattern} equ bl_p1+1
bl_rc   =    bl_p2+1        #rcblk     real} equ bl_p2+1
bl_sc   =    bl_rc+1        #scblk     string} equ bl_rc+1
bl_se   =    bl_sc+1        #seblk     expression} equ bl_sc+1
bl_tb   =    bl_se+1        #tbblk     table} equ bl_se+1
bl_vc   =    bl_tb+1        #vcblk     array} equ bl_tb+1
bl_xn   =    bl_vc+1        #xnblk     external} equ bl_vc+1
bl_xr   =    bl_xn+1        #xrblk     external} equ bl_xn+1
bl_bc   =    bl_xr+1        #bcblk     buffer} equ bl_xr+1
bl_pd   =    bl_bc+1        #pdblk     program defined datatype} equ bl_bc+1
#
bl__d   =    bl_pd+1        #number of block codes for data} equ bl_pd+1
#
#      other block codes
#
bl_tr   =    bl_pd+1        #trblk} equ bl_pd+1
bl_bf   =    bl_tr+1        #bfblk} equ bl_tr+1
bl_cc   =    bl_bf+1        #ccblk} equ bl_bf+1
bl_cm   =    bl_cc+1        #cmblk} equ bl_cc+1
bl_ct   =    bl_cm+1        #ctblk} equ bl_cm+1
bl_df   =    bl_ct+1        #dfblk} equ bl_ct+1
bl_ef   =    bl_df+1        #efblk} equ bl_df+1
bl_ev   =    bl_ef+1        #evblk} equ bl_ef+1
bl_ff   =    bl_ev+1        #ffblk} equ bl_ev+1
bl_kv   =    bl_ff+1        #kvblk} equ bl_ff+1
bl_pf   =    bl_kv+1        #pfblk} equ bl_kv+1
bl_te   =    bl_pf+1        #teblk} equ bl_pf+1
#
bl__i   =    0              #default identification code} equ 0
bl__t   =    bl_tr+1        #code for data or trace block} equ bl_tr+1
bl___   =    bl_te+1        #number of block codes} equ bl_te+1
                            #} ejc
        .eject
#
#      field references
#
#      references to the fields of data blocks are symbolic
#      (i.e. use the symbolic offsets) with the following
#      exceptions.
#
#      1)   references to the first word are usually not
#           symbolic since they use the (x) operand format.
#
#      2)   the code which constructs a block is often not
#           symbolic and should be changed if the corresponding
#           block format is modified.
#
#      3)   the plc and psc instructions imply an offset
#           corresponding to the definition of cfp$f.
#
#      4)   there are non-symbolic references (easily changed)
#           in the garbage collector (procedures gbcpf, blkln).
#
#      5)   the fields idval, fargs appear in several blocks
#           and any changes must be made in parallel to all
#           blocks containing the fields. the actual references
#           to these fields are symbolic with the above
#           listed exceptions.
#
#      6)   several spots in the code assume that the
#           definitions of the fields vrval, teval, trnxt are
#           the same (these are sections of code which search
#           out along a trblk chain from a variable).
#
#      7)   references to the fields of an array block in the
#           array reference routine arref are non-symbolic.
#
#      apart from the exceptions listed, references are symbolic
#      as far as possible and modifying the order or number
#      of fields will not require changes.
                            #} ejc
        .eject
#
#      common fields for function blocks
#
#      blocks which represent callable functions have two
#      common fields at the start of the block as follows.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           /                                    /
#           /       rest of function block       /
#           /                                    /
#           +------------------------------------+
#
fcode   =    0              #pointer to code for function} equ 0
fargs   =    1              #number of arguments} equ 1
#
#      fcode is a pointer to the location in the interpretor
#      program which processes this type of function call.
#
#      fargs is the expected number of arguments. the actual
#      number of arguments is adjusted to this amount by
#      deleting extra arguments or supplying trailing nulls
#      for missing ones before transferring though fcode.
#      a value of 999 may be used in this field to indicate a
#      variable number of arguments (see svblk field svnar).
#
#      the block types which follow this scheme are.
#
#      ffblk                 field function
#      dfblk                 datatype function
#      pfblk                 program defined function
#      efblk                 external loaded function
                            #} ejc
        .eject
#
#      identification field
#
#
#      id   field
#
#      certain program accessible objects (those which contain
#      other data values and can be copied) are given a unique
#      identification number (see exsid). this id value is an
#      address integer value which is always stored in word two.
#
idval   =    1              #id value field} equ 1
#
#      the blocks containing an idval field are.
#
#      arblk                 array
#      pdblk                 program defined datatype
#      tbblk                 table
#      vcblk                 vector block (array)
#
#      note that a zero idval means that the block is only
#      half built and should not be dumped (see dumpr).
                            #} ejc
        .eject
#
#      array block (arblk)
#
#      an array block represents an array value other than one
#      with one dimension whose lower bound is one (see vcblk).
#      an arblk is built with a call to the functions convert
#      (s$cnv) or array (s$arr).
#
#           +------------------------------------+
#           i                artyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                arlen               i
#           +------------------------------------+
#           i                arofs               i
#           +------------------------------------+
#           i                arndm               i
#           +------------------------------------+
#           *                arlbd               *
#           +------------------------------------+
#           *                ardim               *
#           +------------------------------------+
#           *                                    *
#           * above 2 flds repeated for each dim *
#           *                                    *
#           +------------------------------------+
#           i                arpro               i
#           +------------------------------------+
#           /                                    /
#           /                arvls               /
#           /                                    /
#           +------------------------------------+
                            #} ejc
        .eject
#
#      array block (continued)
#
artyp   =    0              #pointer to dummy routine b_art} equ 0
arlen   =    idval+1        #length of arblk in bytes} equ idval+1
arofs   =    arlen+1        #offset in arblk to arpro field} equ arlen+1
arndm   =    arofs+1        #number of dimensions} equ arofs+1
arlbd   =    arndm+1        #low bound (first subscript)} equ arndm+1
ardim   =    arlbd+cfp_i    #dimension (first subscript)} equ arlbd+cfp_i
arlb2   =    ardim+cfp_i    #low bound (second subscript)} equ ardim+cfp_i
ardm2   =    arlb2+cfp_i    #dimension (second subscript)} equ arlb2+cfp_i
arpro   =    ardim+cfp_i    #array prototype (one dimension)} equ ardim+cfp_i
arvls   =    arpro+1        #start of values (one dimension)} equ arpro+1
arpr2   =    ardm2+cfp_i    #array prototype (two dimensions)} equ ardm2+cfp_i
arvl2   =    arpr2+1        #start of values (two dimensions)} equ arpr2+1
arsi_   =    arlbd          #number of standard fields in block} equ arlbd
ardms   =    arlb2-arlbd    #size of info for one set of bounds} equ arlb2-arlbd
#
#      the bounds and dimension fields are signed integer
#      values and each occupy cfp$i words in the arblk.
#
#      the length of an arblk in bytes may not exceed mxlen.
#      this is required to keep name offsets garbage collectable
#
#      the actual values are arranged in row-wise order and
#      can contain a data pointer or a pointer to a trblk.
                            #} ejc
        .eject
#
#      code construction block (ccblk)
#
#      at any one moment there is at most one ccblk into
#      which the compiler is currently storing code (cdwrd).
#
#           +------------------------------------+
#           i                cctyp               i
#           +------------------------------------+
#           i                cclen               i
#           +------------------------------------+
#           i                ccsln               i
#           +------------------------------------+
#           i                ccuse               i
#           +------------------------------------+
#           /                                    /
#           /                cccod               /
#           /                                    /
#           +------------------------------------+
#
cctyp   =    0              #pointer to dummy routine b_cct} equ 0
cclen   =    cctyp+1        #length of ccblk in bytes} equ cctyp+1
ccsln   =    cclen+1        #source line number} equ cclen+1
ccuse   =    ccsln+1        #offset past last used word (bytes)} equ ccsln+1
cccod   =    ccuse+1        #start of generated code in block} equ ccuse+1
#
#      the reason that the ccblk is a separate block type from
#      the usual cdblk is that the garbage collector must
#      only process those fields which have been set (see gbcpf)
                            #} ejc
        .eject
#
#      code block (cdblk)
#
#      a code block is built for each statement compiled during
#      the initial compilation or by subsequent calls to code.
#
#           +------------------------------------+
#           i                cdjmp               i
#           +------------------------------------+
#           i                cdstm               i
#           +------------------------------------+
#           i                cdsln               i
#           +------------------------------------+
#           i                cdlen               i
#           +------------------------------------+
#           i                cdfal               i
#           +------------------------------------+
#           /                                    /
#           /                cdcod               /
#           /                                    /
#           +------------------------------------+
#
cdjmp   =    0              #ptr to routine to execute statement} equ 0
cdstm   =    cdjmp+1        #statement number} equ cdjmp+1
cdsln   =    cdstm+1        #source line number} equ cdstm+1
cdlen   =    cdsln+1        #length of cdblk in bytes} equ cdsln+1
cdfal   =    cdlen+1        #failure exit (see below)} equ cdlen+1
cdcod   =    cdfal+1        #executable pseudo-code} equ cdfal+1
cdsi_   =    cdcod          #number of standard fields in cdblk} equ cdcod
#
#      cdstm is the statement number of the current statement.
#
#      cdjmp, cdfal are set as follows.
#
#      1)   if the failure exit is the next statement
#
#           cdjmp = b$cds
#           cdfal = ptr to cdblk for next statement
#
#      2)   if the failure exit is a simple label name
#
#           cdjmp = b$cds
#           cdfal is a ptr to the vrtra field of the vrblk
#
#      3)   if there is no failure exit (-nofail mode)
#
#           cdjmp = b$cds
#           cdfal = o$unf
#
#      4)   if the failure exit is complex or direct
#
#           cdjmp = b$cdc
#           cdfal is the offset to the o$gof word
                            #} ejc
        .eject
#
#      code block (continued)
#
#      cdcod is the start of the actual code. first we describe
#      the code generated for an expression. in an expression,
#      elements are fetched by name or by value. for example,
#      the binary equal operator fetches its left argument
#      by name and its right argument by value. these two
#      cases generate quite different code and are described
#      separately. first we consider the code by value case.
#
#      generation of code by value for expressions elements.
#
#      expression            pointer to exblk or seblk
#
#      integer constant      pointer to icblk
#
#      null constant         pointer to nulls
#
#      pattern               (resulting from preevaluation)
#                            =o$lpt
#                            pointer to p0blk,p1blk or p2blk
#
#      real constant         pointer to rcblk
#
#      string constant       pointer to scblk
#
#      variable              pointer to vrget field of vrblk
#
#      addition              value code for left operand
#                            value code for right operand
#                            =o$add
#
#      affirmation           value code for operand
#                            =o$aff
#
#      alternation           value code for left operand
#                            value code for right operand
#                            =o$alt
#
#      array reference       (case of one subscript)
#                            value code for array operand
#                            value code for subscript operand
#                            =o$aov
#
#                            (case of more than one subscript)
#                            value code for array operand
#                            value code for first subscript
#                            value code for second subscript
#                            ...
#                            value code for last subscript
#                            =o$amv
#                            number of subscripts
                            #} ejc
        .eject
#
#      code block (continued)
#
#      assignment            (to natural variable)
#                            value code for right operand
#                            pointer to vrsto field of vrblk
#
#                            (to any other variable)
#                            name code for left operand
#                            value code for right operand
#                            =o$ass
#
#      compile error         =o$cer
#
#
#      complementation       value code for operand
#                            =o$com
#
#      concatenation         (case of pred func left operand)
#                            value code for left operand
#                            =o$pop
#                            value code for right operand
#
#                            (all other cases)
#                            value code for left operand
#                            value code for right operand
#                            =o$cnc
#
#      cursor assignment     name code for operand
#                            =o$cas
#
#      division              value code for left operand
#                            value code for right operand
#                            =o$dvd
#
#      exponentiation        value code for left operand
#                            value code for right operand
#                            =o$exp
#
#      function call         (case of call to system function)
#                            value code for first argument
#                            value code for second argument
#                            ...
#                            value code for last argument
#                            pointer to svfnc field of svblk
#
                            #} ejc
        .eject
#
#      code block (continued)
#
#      function call         (case of non-system function 1 arg)
#                            value code for argument
#                            =o$fns
#                            pointer to vrblk for function
#
#                            (non-system function, gt 1 arg)
#                            value code for first argument
#                            value code for second argument
#                            ...
#                            value code for last argument
#                            =o$fnc
#                            number of arguments
#                            pointer to vrblk for function
#
#      immediate assignment  value code for left operand
#                            name code for right operand
#                            =o$ima
#
#      indirection           value code for operand
#                            =o$inv
#
#      interrogation         value code for operand
#                            =o$int
#
#      keyword reference     name code for operand
#                            =o$kwv
#
#      multiplication        value code for left operand
#                            value code for right operand
#                            =o$mlt
#
#      name reference        (natural variable case)
#                            pointer to nmblk for name
#
#                            (all other cases)
#                            name code for operand
#                            =o$nam
#
#      negation              =o$nta
#                            cdblk offset of o$ntc word
#                            value code for operand
#                            =o$ntb
#                            =o$ntc
                            #} ejc
        .eject
#
#      code block (continued)
#
#      pattern assignment    value code for left operand
#                            name code for right operand
#                            =o$pas
#
#      pattern match         value code for left operand
#                            value code for right operand
#                            =o$pmv
#
#      pattern replacement   name code for subject
#                            value code for pattern
#                            =o$pmn
#                            value code for replacement
#                            =o$rpl
#
#      selection             (for first alternative)
#                            =o$sla
#                            cdblk offset to next o$slc word
#                            value code for first alternative
#                            =o$slb
#                            cdblk offset past alternatives
#
#                            (for subsequent alternatives)
#                            =o$slc
#                            cdblk offset to next o$slc,o$sld
#                            value code for alternative
#                            =o$slb
#                            offset in cdblk past alternatives
#
#                            (for last alternative)
#                            =o$sld
#                            value code for last alternative
#
#      subtraction           value code for left operand
#                            value code for right operand
#                            =o$sub
                            #} ejc
        .eject
#
#      code block (continued)
#
#      generation of code by name for expression elements.
#
#      variable              =o$lvn
#                            pointer to vrblk
#
#      expression            (case of *natural variable)
#                            =o$lvn
#                            pointer to vrblk
#
#                            (all other cases)
#                            =o$lex
#                            pointer to exblk
#
#
#      array reference       (case of one subscript)
#                            value code for array operand
#                            value code for subscript operand
#                            =o$aon
#
#                            (case of more than one subscript)
#                            value code for array operand
#                            value code for first subscript
#                            value code for second subscript
#                            ...
#                            value code for last subscript
#                            =o$amn
#                            number of subscripts
#
#      compile error         =o$cer
#
#      function call         (same code as for value call)
#                            =o$fne
#
#      indirection           value code for operand
#                            =o$inn
#
#      keyword reference     name code for operand
#                            =o$kwn
#
#      any other operand is an error in a name position
#
#      note that in this description, =o$xxx refers to the
#      generation of a word containing the address of another
#      word which contains the entry point address o$xxx.
                            #} ejc
        .eject
#
#      code block (continued)
#
#      now we consider the overall structure of the code block
#      for a statement with possible goto fields.
#
#      first comes the code for the statement body.
#      the statement body is an expression to be evaluated
#      by value although the value is not actually required.
#      normal value code is generated for the body of the
#      statement except in the case of a pattern match by
#      value, in which case the following is generated.
#
#                            value code for left operand
#                            value code for right operand
#                            =o$pms
#
#      next we have the code for the success goto. there are
#      several cases as follows.
#
#      1)   no success goto  ptr to cdblk for next statement
#
#      2)   simple label     ptr to vrtra field of vrblk
#
#      3)   complex goto     (code by name for goto operand)
#                            =o$goc
#
#      4)   direct goto      (code by value for goto operand)
#                            =o$god
#
#      following this we generate code for the failure goto if
#      it is direct or if it is complex, simple failure gotos
#      having been handled by an appropriate setting of the
#      cdfal field of the cdblk. the generated code is one
#      of the following.
#
#      1)   complex fgoto    =o$fif
#                            =o$gof
#                            name code for goto operand
#                            =o$goc
#
#      2)   direct fgoto     =o$fif
#                            =o$gof
#                            value code for goto operand
#                            =o$god
#
#      an optimization occurs if the success and failure gotos
#      are identical and either complex or direct. in this case,
#      no code is generated for the success goto and control
#      is allowed to fall into the failure goto on success.
                            #} ejc
        .eject
#
#      compiler block (cmblk)
#
#      a compiler block (cmblk) is built by expan to represent
#      one node of a tree structured expression representation.
#
#           +------------------------------------+
#           i                cmidn               i
#           +------------------------------------+
#           i                cmlen               i
#           +------------------------------------+
#           i                cmtyp               i
#           +------------------------------------+
#           i                cmopn               i
#           +------------------------------------+
#           /           cmvls or cmrop           /
#           /                                    /
#           /                cmlop               /
#           /                                    /
#           +------------------------------------+
#
cmidn   =    0              #pointer to dummy routine b_cmt} equ 0
cmlen   =    cmidn+1        #length of cmblk in bytes} equ cmidn+1
cmtyp   =    cmlen+1        #type (c_xxx, see list below)} equ cmlen+1
cmopn   =    cmtyp+1        #operand pointer (see below)} equ cmtyp+1
cmvls   =    cmopn+1        #operand value pointers (see below)} equ cmopn+1
cmrop   =    cmvls          #right (only) operator operand} equ cmvls
cmlop   =    cmvls+1        #left operator operand} equ cmvls+1
cmsi_   =    cmvls          #number of standard fields in cmblk} equ cmvls
cmus_   =    cmsi_+1        #size of unary operator cmblk} equ cmsi_+1
cmbs_   =    cmsi_+2        #size of binary operator cmblk} equ cmsi_+2
cmar1   =    cmvls+1        #array subscript pointers} equ cmvls+1
#
#      the cmopn and cmvls fields are set as follows
#
#      array reference       cmopn = ptr to array operand
#                            cmvls = ptrs to subscript operands
#
#      function call         cmopn = ptr to vrblk for function
#                            cmvls = ptrs to argument operands
#
#      selection             cmopn = zero
#                            cmvls = ptrs to alternate operands
#
#      unary operator        cmopn = ptr to operator dvblk
#                            cmrop = ptr to operand
#
#      binary operator       cmopn = ptr to operator dvblk
#                            cmrop = ptr to right operand
#                            cmlop = ptr to left operand
                            #} ejc
        .eject
#
#      cmtyp is set to indicate the type of expression element
#      as shown by the following table of definitions.
#
c_arr   =    0              #array reference} equ 0
c_fnc   =    c_arr+1        #function call} equ c_arr+1
c_def   =    c_fnc+1        #deferred expression (unary *)} equ c_fnc+1
c_ind   =    c_def+1        #indirection (unary _)} equ c_def+1
c_key   =    c_ind+1        #keyword reference (unary ampersand)} equ c_ind+1
c_ubo   =    c_key+1        #undefined binary operator} equ c_key+1
c_uuo   =    c_ubo+1        #undefined unary operator} equ c_ubo+1
c_uo_   =    c_uuo+1        #test value (=c_uuo+1=c_ubo+2)} equ c_uuo+1
c__nm   =    c_uuo+1        #number of codes for name operands} equ c_uuo+1
#
#      the remaining types indicate expression elements which
#      can only be evaluated by value (not by name).
#
c_bvl   =    c_uuo+1        #binary op with value operands} equ c_uuo+1
c_uvl   =    c_bvl+1        #unary operator with value operand} equ c_bvl+1
c_alt   =    c_uvl+1        #alternation (binary bar)} equ c_uvl+1
c_cnc   =    c_alt+1        #concatenation} equ c_alt+1
c_cnp   =    c_cnc+1        #concatenation, not pattern match} equ c_cnc+1
c_unm   =    c_cnp+1        #unary op with name operand} equ c_cnp+1
c_bvn   =    c_unm+1        #binary op (operands by value, name)} equ c_unm+1
c_ass   =    c_bvn+1        #assignment} equ c_bvn+1
c_int   =    c_ass+1        #interrogation} equ c_ass+1
c_neg   =    c_int+1        #negation (unary not)} equ c_int+1
c_sel   =    c_neg+1        #selection} equ c_neg+1
c_pmt   =    c_sel+1        #pattern match} equ c_sel+1
#
c_pr_   =    c_bvn          #last preevaluable code} equ c_bvn
c__nv   =    c_pmt+1        #number of different cmblk types} equ c_pmt+1
                            #} ejc
        .eject
#
#      character table block (ctblk)
#
#      a character table block is used to hold logical character
#      tables for use with any,notany,span,break,breakx
#      patterns. each character table can be used to store
#      cfp$n distinct tables as bit columns. a bit column
#      allocated for each argument of more than one character
#      in length to one of the above listed pattern primitives.
#
#           +------------------------------------+
#           i                cttyp               i
#           +------------------------------------+
#           *                                    *
#           *                                    *
#           *                ctchs               *
#           *                                    *
#           *                                    *
#           +------------------------------------+
#
cttyp   =    0              #pointer to dummy routine b_ctt} equ 0
ctchs   =    cttyp+1        #start of character table words} equ cttyp+1
ctsi_   =    ctchs+cfp_a    #number of words in ctblk} equ ctchs+cfp_a
#
#      ctchs is cfp$a words long and consists of a one word
#      bit string value for each possible character in the
#      internal alphabet. each of the cfp$n possible bits in
#      a bitstring is used to form a column of bit indicators.
#      a bit is set on if the character is in the table and off
#      if the character is not present.
                            #} ejc
        .eject
#
#      datatype function block (dfblk)
#
#      a datatype function is used to control the construction
#      of a program defined datatype object. a call to the
#      system function data builds a dfblk for the datatype name
#
#      note that these blocks are built in static because pdblk
#      length is got from dflen field.  if dfblk was in dynamic
#      store this would cause trouble during pass two of garbage
#      collection.  scblk referred to by dfnam field is also put
#      in static so that there are no reloc. fields. this cuts
#      garbage collection task appreciably for pdblks which are
#      likely to be present in large numbers.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                dflen               i
#           +------------------------------------+
#           i                dfpdl               i
#           +------------------------------------+
#           i                dfnam               i
#           +------------------------------------+
#           /                                    /
#           /                dffld               /
#           /                                    /
#           +------------------------------------+
#
dflen   =    fargs+1        #length of dfblk in bytes} equ fargs+1
dfpdl   =    dflen+1        #length of corresponding pdblk} equ dflen+1
dfnam   =    dfpdl+1        #pointer to scblk for datatype name} equ dfpdl+1
dffld   =    dfnam+1        #start of vrblk ptrs for field names} equ dfnam+1
dfflb   =    dffld-1        #offset behind dffld for field func} equ dffld-1
dfsi_   =    dffld          #number of standard fields in dfblk} equ dffld
#
#      the fcode field points to the routine b$dfc
#
#      fargs (the number of arguments) is the number of fields.
                            #} ejc
        .eject
#
#      dope vector block (dvblk)
#
#      a dope vector is assembled for each possible operator in
#      the snobol4 language as part of the constant section.
#
#           +------------------------------------+
#           i                dvopn               i
#           +------------------------------------+
#           i                dvtyp               i
#           +------------------------------------+
#           i                dvlpr               i
#           +------------------------------------+
#           i                dvrpr               i
#           +------------------------------------+
#
dvopn   =    0              #entry address (ptr to o_xxx)} equ 0
dvtyp   =    dvopn+1        #type code (c_xxx, see cmblk)} equ dvopn+1
dvlpr   =    dvtyp+1        #left precedence (llxxx, see below)} equ dvtyp+1
dvrpr   =    dvlpr+1        #right precedence (rrxxx, see below)} equ dvlpr+1
dvus_   =    dvlpr+1        #size of unary operator dv} equ dvlpr+1
dvbs_   =    dvrpr+1        #size of binary operator dv} equ dvrpr+1
dvubs   =    dvus_+dvbs_    #size of unop + binop (see scane)} equ dvus_+dvbs_
#
#      the contents of the dvtyp field is copied into the cmtyp
#      field of the cmblk for the operator if it is used.
#
#      the cmopn field of an operator cmblk points to the dvblk
#      itself, providing the required entry address pointer ptr.
#
#      for normally undefined operators, the dvopn (and cmopn)
#      fields contain a word offset from r$uba of the function
#      block pointer for the operator (instead of o$xxx ptr).
#      for certain special operators, the dvopn field is not
#      required at all and is assembled as zero.
#
#      the left precedence is used in comparing an operator to
#      the left of some other operator. it therefore governs the
#      precedence of the operator towards its right operand.
#
#      the right precedence is used in comparing an operator to
#      the right of some other operator. it therefore governs
#      the precedence of the operator towards its left operand.
#
#      higher precedence values correspond to a tighter binding
#      capability. thus we have the left precedence lower
#      (higher) than the right precedence for right (left)
#      associative binary operators.
#
#      the left precedence of unary operators is set to an
#      arbitrary high value. the right value is not required and
#      consequently the dvrpr field is omitted for unary ops.
                            #} ejc
        .eject
#
#      table of operator precedence values
#
rrass   =    10             #right     equal} equ 10
llass   =    00             #left      equal} equ 00
rrpmt   =    20             #right     question mark} equ 20
llpmt   =    30             #left      question mark} equ 30
rramp   =    40             #right     ampersand} equ 40
llamp   =    50             #left      ampersand} equ 50
rralt   =    70             #right     vertical bar} equ 70
llalt   =    60             #left      vertical bar} equ 60
rrcnc   =    90             #right     blank} equ 90
llcnc   =    80             #left      blank} equ 80
rrats   =    110            #right     at} equ 110
llats   =    100            #left      at} equ 100
rrplm   =    120            #right     plus, minus} equ 120
llplm   =    130            #left      plus, minus} equ 130
rrnum   =    140            #right     number} equ 140
llnum   =    150            #left      number} equ 150
rrdvd   =    160            #right     slash} equ 160
lldvd   =    170            #left      slash} equ 170
rrmlt   =    180            #right     asterisk} equ 180
llmlt   =    190            #left      asterisk} equ 190
rrpct   =    200            #right     percent} equ 200
llpct   =    210            #left      percent} equ 210
rrexp   =    230            #right     exclamation} equ 230
llexp   =    220            #left      exclamation} equ 220
rrdld   =    240            #right     dollar, dot} equ 240
lldld   =    250            #left      dollar, dot} equ 250
rrnot   =    270            #right     not} equ 270
llnot   =    260            #left      not} equ 260
lluno   =    999            #left      all unary operators} equ 999
#
#      precedences are the same as in btl snobol4 with the
#      following exceptions.
#
#      1)   binary question mark is lowered and made left assoc-
#           iative to reflect its new use for pattern matching.
#
#      2)   alternation and concatenation are made right
#           associative for greater efficiency in pattern
#           construction and matching respectively. this change
#           is transparent to the snobol4 programmer.
#
#      3)   the equal sign has been added as a low precedence
#           operator which is right associative to reflect its
#           more general usage in this version of snobol4.
                            #} ejc
        .eject
#
#      external function block (efblk)
#
#      an external function block is used to control the calling
#      of an external function. it is built by a call to load.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                eflen               i
#           +------------------------------------+
#           i                efuse               i
#           +------------------------------------+
#           i                efcod               i
#           +------------------------------------+
#           i                efvar               i
#           +------------------------------------+
#           i                efrsl               i
#           +------------------------------------+
#           /                                    /
#           /                eftar               /
#           /                                    /
#           +------------------------------------+
#
eflen   =    fargs+1        #length of efblk in bytes} equ fargs+1
efuse   =    eflen+1        #use count (for opsyn)} equ eflen+1
efcod   =    efuse+1        #ptr to code (from sysld)} equ efuse+1
efvar   =    efcod+1        #ptr to associated vrblk} equ efcod+1
efrsl   =    efvar+1        #result type (see below)} equ efvar+1
eftar   =    efrsl+1        #argument types (see below)} equ efrsl+1
efsi_   =    eftar          #number of standard fields in efblk} equ eftar
#
#      the fcode field points to the routine b$efc.
#
#      efuse is used to keep track of multiple use when opsyn
#      is employed. the function is automatically unloaded
#      when there are no more references to the function.
#
#      efrsl and eftar are type codes as follows.
#
#           0                type is unconverted
#           1                type is string
#           2                type is integer
#           3                type is real
#           4                type is file
                            #} ejc
        .eject
#
#      expression variable block (evblk)
#
#      in this version of spitbol, an expression can be used in
#      any position which would normally expect a name (for
#      example on the left side of equals or as the right
#      argument of binary dot). this corresponds to the creation
#      of a pseudo-variable which is represented by a pointer to
#      an expression variable block as follows.
#
#           +------------------------------------+
#           i                evtyp               i
#           +------------------------------------+
#           i                evexp               i
#           +------------------------------------+
#           i                evvar               i
#           +------------------------------------+
#
evtyp   =    0              #pointer to dummy routine b_evt} equ 0
evexp   =    evtyp+1        #pointer to exblk for expression} equ evtyp+1
evvar   =    evexp+1        #pointer to trbev dummy trblk} equ evexp+1
evsi_   =    evvar+1        #size of evblk} equ evvar+1
#
#      the name of an expression variable is represented by a
#      base pointer to the evblk and an offset of evvar. this
#      value appears to be trapped by the dummy trbev block.
#
#      note that there is no need to allow for the case of an
#      expression variable which references an seblk since a
#      variable which is of the form *var is equivalent to var.
                            #} ejc
        .eject
#
#      expression block (exblk)
#
#      an expression block is built for each expression
#      referenced in a program or created by eval or convert
#      during execution of a program.
#
#           +------------------------------------+
#           i                extyp               i
#           +------------------------------------+
#           i                exstm               i
#           +------------------------------------+
#           i                exsln               i
#           +------------------------------------+
#           i                exlen               i
#           +------------------------------------+
#           i                exflc               i
#           +------------------------------------+
#           /                                    /
#           /                excod               /
#           /                                    /
#           +------------------------------------+
#
extyp   =    0              #ptr to routine b_exl to load expr} equ 0
exstm   =    cdstm          #stores stmnt no. during evaluation} equ cdstm
exsln   =    exstm+1        #stores line no. during evaluation} equ exstm+1
exlen   =    exsln+1        #length of exblk in bytes} equ exsln+1
exflc   =    exlen+1        #failure code (=o_fex)} equ exlen+1
excod   =    exflc+1        #pseudo-code for expression} equ exflc+1
exsi_   =    excod          #number of standard fields in exblk} equ excod
#
#      there are two cases for excod depending on whether the
#      expression can be evaluated by name (see description
#      of cdblk for details of code for expressions).
#
#      if the expression can be evaluated by name we have.
#
#                            (code for expr by name)
#                            =o$rnm
#
#      if the expression can only be evaluated by value.
#
#                            (code for expr by value)
#                            =o$rvl
                            #} ejc
        .eject
#
#      field function block (ffblk)
#
#      a field function block is used to control the selection
#      of a field from a program defined datatype block.
#      a call to data creates an ffblk for each field.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                ffdfp               i
#           +------------------------------------+
#           i                ffnxt               i
#           +------------------------------------+
#           i                ffofs               i
#           +------------------------------------+
#
ffdfp   =    fargs+1        #pointer to associated dfblk} equ fargs+1
ffnxt   =    ffdfp+1        #ptr to next ffblk on chain or zero} equ ffdfp+1
ffofs   =    ffnxt+1        #offset (bytes) to field in pdblk} equ ffnxt+1
ffsi_   =    ffofs+1        #size of ffblk in words} equ ffofs+1
#
#      the fcode field points to the routine b$ffc.
#
#      fargs always contains one.
#
#      ffdfp is used to verify that the correct program defined
#      datatype is being accessed by this call.
#      ffdfp is non-reloc. because dfblk is in static
#
#      ffofs is used to select the appropriate field. note that
#      it is an actual offset (not a field number)
#
#      ffnxt is used to point to the next ffblk of the same name
#      in the case where there are several fields of the same
#      name for different datatypes. zero marks the end of chain
                            #} ejc
        .eject
#
#      integer constant block (icblk)
#
#      an icblk is created for every integer referenced or
#      created by a program. note however that certain internal
#      integer values are stored as addresses (e.g. the length
#      field in a string constant block)
#
#           +------------------------------------+
#           i                icget               i
#           +------------------------------------+
#           *                icval               *
#           +------------------------------------+
#
icget   =    0              #ptr to routine b_icl to load int} equ 0
icval   =    icget+1        #integer value} equ icget+1
icsi_   =    icval+cfp_i    #size of icblk} equ icval+cfp_i
#
#      the length of the icval field is cfp$i.
                            #} ejc
        .eject
#
#      keyword variable block (kvblk)
#
#      a kvblk is used to represent a keyword pseudo-variable.
#      a kvblk is built for each keyword reference (kwnam).
#
#           +------------------------------------+
#           i                kvtyp               i
#           +------------------------------------+
#           i                kvvar               i
#           +------------------------------------+
#           i                kvnum               i
#           +------------------------------------+
#
kvtyp   =    0              #pointer to dummy routine b_kvt} equ 0
kvvar   =    kvtyp+1        #pointer to dummy block trbkv} equ kvtyp+1
kvnum   =    kvvar+1        #keyword number} equ kvvar+1
kvsi_   =    kvnum+1        #size of kvblk} equ kvnum+1
#
#      the name of a keyword variable is represented by a
#      base pointer to the kvblk and an offset of kvvar. the
#      value appears to be trapped by the pointer to trbkv.
                            #} ejc
        .eject
#
#      name block (nmblk)
#
#      a name block is used wherever a name must be stored as
#      a value following use of the unary dot operator.
#
#           +------------------------------------+
#           i                nmtyp               i
#           +------------------------------------+
#           i                nmbas               i
#           +------------------------------------+
#           i                nmofs               i
#           +------------------------------------+
#
nmtyp   =    0              #ptr to routine b_nml to load name} equ 0
nmbas   =    nmtyp+1        #base pointer for variable} equ nmtyp+1
nmofs   =    nmbas+1        #offset for variable} equ nmbas+1
nmsi_   =    nmofs+1        #size of nmblk} equ nmofs+1
#
#      the actual field representing the contents of the name
#      is found nmofs bytes past the address in nmbas.
#
#      the name is split into base and offset form to avoid
#      creation of a pointer into the middle of a block which
#      could not be handled properly by the garbage collector.
#
#      a name may be built for any variable (see section on
#      representations of variables) this includes the
#      cases of pseudo-variables.
                            #} ejc
        .eject
#
#      pattern block, no parameters (p0blk)
#
#      a p0blk is used to represent pattern nodes which do
#      not require the use of any parameter values.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#
pcode   =    0              #ptr to match routine (p_xxx)} equ 0
pthen   =    pcode+1        #pointer to subsequent node} equ pcode+1
pasi_   =    pthen+1        #size of p0blk} equ pthen+1
#
#      pthen points to the pattern block for the subsequent
#      node to be matched. this is a pointer to the pattern
#      block ndnth if there is no subsequent (end of pattern)
#
#      pcode is a pointer to the match routine for the node.
                            #} ejc
        .eject
#
#      pattern block (one parameter)
#
#      a p1blk is used to represent pattern nodes which
#      require one parameter value.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#           i                parm1               i
#           +------------------------------------+
#
parm1   =    pthen+1        #first parameter value} equ pthen+1
pbsi_   =    parm1+1        #size of p1blk in words} equ parm1+1
#
#      see p0blk for definitions of pcode, pthen
#
#      parm1 contains a parameter value used in matching the
#      node. for example, in a len pattern, it is the integer
#      argument to len. the details of the use of the parameter
#      field are included in the description of the individual
#      match routines. parm1 is always an address pointer which
#      is processed by the garbage collector.
                            #} ejc
        .eject
#
#      pattern block (two parameters)
#
#      a p2blk is used to represent pattern nodes which
#      require two parameter values.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#           i                parm1               i
#           +------------------------------------+
#           i                parm2               i
#           +------------------------------------+
#
parm2   =    parm1+1        #second parameter value} equ parm1+1
pcsi_   =    parm2+1        #size of p2blk in words} equ parm2+1
#
#      see p1blk for definitions of pcode, pthen, parm1
#
#      parm2 is a parameter which performs the same sort of
#      function as parm1 (see description of p1blk).
#
#      parm2 is a non-relocatable field and is not
#      processed by the garbage collector. accordingly, it may
#      not contain a pointer to a block in dynamic memory.
                            #} ejc
        .eject
#
#      program-defined datatype block
#
#      a pdblk represents the data item formed by a call to a
#      datatype function as defined by the system function data.
#
#           +------------------------------------+
#           i                pdtyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                pddfp               i
#           +------------------------------------+
#           /                                    /
#           /                pdfld               /
#           /                                    /
#           +------------------------------------+
#
pdtyp   =    0              #ptr to dummy routine b_pdt} equ 0
pddfp   =    idval+1        #ptr to associated dfblk} equ idval+1
pdfld   =    pddfp+1        #start of field value pointers} equ pddfp+1
pdfof   =    dffld-pdfld    #difference in offset to field ptrs} equ dffld-pdfld
pdsi_   =    pdfld          #size of standard fields in pdblk} equ pdfld
pddfs   =    dfsi_-pdsi_    #difference in dfblk, pdblk sizes} equ dfsi_-pdsi_
#
#      the pddfp pointer may be used to determine the datatype
#      and the names of the fields if required. the dfblk also
#      contains the length of the pdblk in bytes (field dfpdl).
#      pddfp is non-reloc. because dfblk is in static
#
#      pdfld values are stored in order from left to right.
#      they contain values or pointers to trblk chains.
                            #} ejc
        .eject
#
#      program defined function block (pfblk)
#
#      a pfblk is created for each call to the define function
#      and a pointer to the pfblk placed in the proper vrblk.
#
#           +------------------------------------+
#           i                fcode               i
#           +------------------------------------+
#           i                fargs               i
#           +------------------------------------+
#           i                pflen               i
#           +------------------------------------+
#           i                pfvbl               i
#           +------------------------------------+
#           i                pfnlo               i
#           +------------------------------------+
#           i                pfcod               i
#           +------------------------------------+
#           i                pfctr               i
#           +------------------------------------+
#           i                pfrtr               i
#           +------------------------------------+
#           /                                    /
#           /                pfarg               /
#           /                                    /
#           +------------------------------------+
#
pflen   =    fargs+1        #length of pfblk in bytes} equ fargs+1
pfvbl   =    pflen+1        #pointer to vrblk for function name} equ pflen+1
pfnlo   =    pfvbl+1        #number of locals} equ pfvbl+1
pfcod   =    pfnlo+1        #ptr to vrblk for entry label} equ pfnlo+1
pfctr   =    pfcod+1        #trblk ptr if call traced else 0} equ pfcod+1
pfrtr   =    pfctr+1        #trblk ptr if return traced else 0} equ pfctr+1
pfarg   =    pfrtr+1        #vrblk ptrs for arguments and locals} equ pfrtr+1
pfagb   =    pfarg-1        #offset behind pfarg for arg, local} equ pfarg-1
pfsi_   =    pfarg          #number of standard fields in pfblk} equ pfarg
#
#      the fcode field points to the routine b$pfc.
#
#      pfarg is stored in the following order.
#
#           arguments (left to right)
#           locals (left to right)
                            #} ejc
        .eject
#
#      real constant block (rcblk)
#
#      an rcblk is created for every real referenced or
#      created by a program.
#
#           +------------------------------------+
#           i                rcget               i
#           +------------------------------------+
#           *                rcval               *
#           +------------------------------------+
#
rcget   =    0              #ptr to routine b_rcl to load real} equ 0
rcval   =    rcget+1        #real value} equ rcget+1
rcsi_   =    rcval+cfp_r    #size of rcblk} equ rcval+cfp_r
#
#      the length of the rcval field is cfp$r.
                            #} ejc
        .eject
#
#      string constant block (scblk)
#
#      an scblk is built for every string referenced or created
#      by a program.
#
#           +------------------------------------+
#           i                scget               i
#           +------------------------------------+
#           i                sclen               i
#           +------------------------------------+
#           /                                    /
#           /                schar               /
#           /                                    /
#           +------------------------------------+
#
scget   =    0              #ptr to routine b_scl to load string} equ 0
sclen   =    scget+1        #length of string in characters} equ scget+1
schar   =    sclen+1        #characters of string} equ sclen+1
scsi_   =    schar          #size of standard fields in scblk} equ schar
#
#      the characters of the string are stored left justified.
#      the final word is padded on the right with zeros.
#      (i.e. the character whose internal code is zero).
#
#      the value of sclen may not exceed mxlen. this ensures
#      that character offsets (e.g. the pattern match cursor)
#      can be correctly processed by the garbage collector.
#
#      note that the offset to the characters of the string
#      is given in bytes by cfp$f and that this value is
#      automatically allowed for in plc, psc.
#      note that for a spitbol scblk, the value of cfp$f
#      is given by cfp$b*schar.
                            #} ejc
        .eject
#
#      simple expression block (seblk)
#
#      an seblk is used to represent an expression of the form
#      *(natural variable). all other expressions are exblks.
#
#           +------------------------------------+
#           i                setyp               i
#           +------------------------------------+
#           i                sevar               i
#           +------------------------------------+
#
setyp   =    0              #ptr to routine b_sel to load expr} equ 0
sevar   =    setyp+1        #ptr to vrblk for variable} equ setyp+1
sesi_   =    sevar+1        #length of seblk in words} equ sevar+1
                            #} ejc
        .eject
#
#      standard variable block (svblk)
#
#      an svblk is assembled in the constant section for each
#      variable which satisfies one of the following conditions.
#
#      1)   it is the name of a system function
#      2)   it has an initial value
#      3)   it has a keyword association
#      4)   it has a standard i/o association
#      6)   it has a standard label association
#
#      if vrblks are constructed for any of these variables,
#      then the vrsvp field points to the svblk (see vrblk)
#
#           +------------------------------------+
#           i                svbit               i
#           +------------------------------------+
#           i                svlen               i
#           +------------------------------------+
#           /                svchs               /
#           +------------------------------------+
#           i                svknm               i
#           +------------------------------------+
#           i                svfnc               i
#           +------------------------------------+
#           i                svnar               i
#           +------------------------------------+
#           i                svlbl               i
#           +------------------------------------+
#           i                svval               i
#           +------------------------------------+
                            #} ejc
        .eject
#
#      standard variable block (continued)
#
svbit   =    0              #bit string indicating attributes} equ 0
svlen   =    1              #(=sclen) length of name in chars} equ 1
svchs   =    2              #(=schar) characters of name} equ 2
svsi_   =    2              #number of standard fields in svblk} equ 2
svpre   =    1              #set if preevaluation permitted} equ 1
svffc   =    svpre+svpre    #set on if fast call permitted} equ svpre+svpre
svckw   =    svffc+svffc    #set on if keyword value constant} equ svffc+svffc
svprd   =    svckw+svckw    #set on if predicate function} equ svckw+svckw
svnbt   =    4              #number of bits to right of svknm} equ 4
svknm   =    svprd+svprd    #set on if keyword association} equ svprd+svprd
svfnc   =    svknm+svknm    #set on if system function} equ svknm+svknm
svnar   =    svfnc+svfnc    #set on if system function} equ svfnc+svfnc
svlbl   =    svnar+svnar    #set on if system label} equ svnar+svnar
svval   =    svlbl+svlbl    #set on if predefined value} equ svlbl+svlbl
#
#      note that the last five bits correspond in order
#      to the fields which are present (see procedure gtnvr).
#
#      the following definitions are used in the svblk table
#
svfnf   =    svfnc+svnar    #function with no fast call} equ svfnc+svnar
svfnn   =    svfnf+svffc    #function with fast call, no preeval} equ svfnf+svffc
svfnp   =    svfnn+svpre    #function allowing preevaluation} equ svfnn+svpre
svfpr   =    svfnn+svprd    #predicate function} equ svfnn+svprd
svfnk   =    svfnn+svknm    #no preeval func + keyword} equ svfnn+svknm
svkwv   =    svknm+svval    #keyword + value} equ svknm+svval
svkwc   =    svckw+svknm    #keyword with constant value} equ svckw+svknm
svkvc   =    svkwv+svckw    #constant keyword + value} equ svkwv+svckw
svkvl   =    svkvc+svlbl    #constant keyword + value + label} equ svkvc+svlbl
svfpk   =    svfnp+svkvc    #preeval fcn + const keywd + val} equ svfnp+svkvc
#
#      the svpre bit allows the compiler to preevaluate a call
#      to the associated system function if all the arguments
#      are themselves constants. functions in this category
#      must have no side effects and must never cause failure.
#      the call may generate an error condition.
#
#      the svffc bit allows the compiler to generate the special
#      fast call after adjusting the number of arguments. only
#      the item and apply functions fall outside this category.
#
#      the svckw bit is set if the associated keyword value is
#      a constant, thus allowing preevaluation for a value call.
#
#      the svprd bit is set on for all predicate functions to
#      enable the special concatenation code optimization.
                            #} ejc
        .eject
#
#      svblk (continued)
#
#      svknm                 keyword number
#
#           svknm is present only for a standard keyword assoc.
#           it contains a keyword number as defined by the
#           keyword number table given later on.
#
#      svfnc                 system function pointer
#
#           svfnc is present only for a system function assoc.
#           it is a pointer to the actual code for the system
#           function. the generated code for a fast call is a
#           pointer to the svfnc field of the svblk for the
#           function. the vrfnc field of the vrblk points to
#           this same field, in which case, it serves as the
#           fcode field for the function call.
#
#      svnar                 number of function arguments
#
#           svnar is present only for a system function assoc.
#           it is the number of arguments required for a call
#           to the system function. the compiler uses this
#           value to adjust the number of arguments in a fast
#           call and in the case of a function called through
#           the vrfnc field of the vrblk, the svnar field
#           serves as the fargs field for o$fnc. a special
#           case occurs if this value is set to 999. this is
#           used to indicate that the function has a variable
#           number of arguments and causes o$fnc to pass control
#           without adjusting the argument count. the only
#           predefined functions using this are apply and item.
#
#      svlbl                 system label pointer
#
#           svlbl is present only for a standard label assoc.
#           it is a pointer to a system label routine (l$xxx).
#           the vrlbl field of the corresponding vrblk points to
#           the svlbl field of the svblk.
#
#      svval                 system value pointer
#
#           svval is present only for a standard value.
#           it is a pointer to the pattern node (ndxxx) which
#           is the standard initial value of the variable.
#           this value is copied to the vrval field of the vrblk
                            #} ejc
        .eject
#
#      svblk (continued)
#
#      keyword number table
#
#      the following table gives symbolic names for keyword
#      numbers. these values are stored in the svknm field of
#      svblks and in the kvnum field of kvblks. see also
#      procedures asign, acess and kwnam.
#
#      unprotected keywords with one word integer values
#
k_abe   =    0              #abend} equ 0
k_anc   =    k_abe+cfp_b    #anchor} equ k_abe+cfp_b
k_cas   =    k_anc+cfp_b    #case} equ k_anc+cfp_b
k_cod   =    k_cas+cfp_b    #code} equ k_cas+cfp_b
k_com   =    k_cod+cfp_b    #compare} equ k_cod+cfp_b
k_dmp   =    k_com+cfp_b    #dump} equ k_com+cfp_b
k_erl   =    k_dmp+cfp_b    #errlimit} equ k_dmp+cfp_b
k_ert   =    k_erl+cfp_b    #errtype} equ k_erl+cfp_b
k_ftr   =    k_ert+cfp_b    #ftrace} equ k_ert+cfp_b
k_fls   =    k_ftr+cfp_b    #fullscan} equ k_ftr+cfp_b
k_inp   =    k_fls+cfp_b    #input} equ k_fls+cfp_b
k_mxl   =    k_inp+cfp_b    #maxlength} equ k_inp+cfp_b
k_oup   =    k_mxl+cfp_b    #output} equ k_mxl+cfp_b
k_pfl   =    k_oup+cfp_b    #profile} equ k_oup+cfp_b
k_tra   =    k_pfl+cfp_b    #trace} equ k_pfl+cfp_b
k_trm   =    k_tra+cfp_b    #trim} equ k_tra+cfp_b
#
#      protected keywords with one word integer values
#
k_fnc   =    k_trm+cfp_b    #fnclevel} equ k_trm+cfp_b
k_lst   =    k_fnc+cfp_b    #lastno} equ k_fnc+cfp_b
k_lln   =    k_lst+cfp_b    #lastline} equ k_lst+cfp_b
k_lin   =    k_lln+cfp_b    #line} equ k_lln+cfp_b
k_stn   =    k_lin+cfp_b    #stno} equ k_lin+cfp_b
#
#      keywords with constant pattern values
#
k_abo   =    k_stn+cfp_b    #abort} equ k_stn+cfp_b
k_arb   =    k_abo+pasi_    #arb} equ k_abo+pasi_
k_bal   =    k_arb+pasi_    #bal} equ k_arb+pasi_
k_fal   =    k_bal+pasi_    #fail} equ k_bal+pasi_
k_fen   =    k_fal+pasi_    #fence} equ k_fal+pasi_
k_rem   =    k_fen+pasi_    #rem} equ k_fen+pasi_
k_suc   =    k_rem+pasi_    #succeed} equ k_rem+pasi_
                            #} ejc
        .eject
#
#      keyword number table (continued)
#
#      special keywords
#
k_alp   =    k_suc+1        #alphabet} equ k_suc+1
k_rtn   =    k_alp+1        #rtntype} equ k_alp+1
k_stc   =    k_rtn+1        #stcount} equ k_rtn+1
k_etx   =    k_stc+1        #errtext} equ k_stc+1
k_fil   =    k_etx+1        #file} equ k_etx+1
k_lfl   =    k_fil+1        #lastfile} equ k_fil+1
k_stl   =    k_lfl+1        #stlimit} equ k_lfl+1
k_lcs   =    k_stl+1        #lcase} equ k_stl+1
k_ucs   =    k_lcs+1        #ucase} equ k_lcs+1
#
#      relative offsets of special keywords
#
k__al   =    k_alp-k_alp    #alphabet} equ k_alp-k_alp
k__rt   =    k_rtn-k_alp    #rtntype} equ k_rtn-k_alp
k__sc   =    k_stc-k_alp    #stcount} equ k_stc-k_alp
k__et   =    k_etx-k_alp    #errtext} equ k_etx-k_alp
k__fl   =    k_fil-k_alp    #file} equ k_fil-k_alp
k__lf   =    k_lfl-k_alp    #lastfile} equ k_lfl-k_alp
k__sl   =    k_stl-k_alp    #stlimit} equ k_stl-k_alp
k__lc   =    k_lcs-k_alp    #lcase} equ k_lcs-k_alp
k__uc   =    k_ucs-k_alp    #ucase} equ k_ucs-k_alp
k__n_   =    k__uc+1        #number of special cases} equ k__uc+1
#
#      symbols used in asign and acess procedures
#
k_p__   =    k_fnc          #first protected keyword} equ k_fnc
k_v__   =    k_abo          #first keyword with constant value} equ k_abo
k_s__   =    k_alp          #first keyword with special acess} equ k_alp
                            #} ejc
        .eject
#
#      format of a table block (tbblk)
#
#      a table block is used to represent a table value.
#      it is built by a call to the table or convert functions.
#
#           +------------------------------------+
#           i                tbtyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                tblen               i
#           +------------------------------------+
#           i                tbinv               i
#           +------------------------------------+
#           /                                    /
#           /                tbbuk               /
#           /                                    /
#           +------------------------------------+
#
tbtyp   =    0              #pointer to dummy routine b_tbt} equ 0
tblen   =    offs2          #length of tbblk in bytes} equ offs2
tbinv   =    offs3          #default initial lookup value} equ offs3
tbbuk   =    tbinv+1        #start of hash bucket pointers} equ tbinv+1
tbsi_   =    tbbuk          #size of standard fields in tbblk} equ tbbuk
tbnbk   =    11             #default no. of buckets} equ 11
#
#      the table block is a hash table which points to chains
#      of table element blocks representing the elements
#      in the table which hash into the same bucket.
#
#      tbbuk entries either point to the first teblk on the
#      chain or they point to the tbblk itself to indicate the
#      end of the chain.
                            #} ejc
        .eject
#
#      table element block (teblk)
#
#      a table element is used to represent a single entry in
#      a table (see description of tbblk format for hash table)
#
#           +------------------------------------+
#           i                tetyp               i
#           +------------------------------------+
#           i                tesub               i
#           +------------------------------------+
#           i                teval               i
#           +------------------------------------+
#           i                tenxt               i
#           +------------------------------------+
#
tetyp   =    0              #pointer to dummy routine b_tet} equ 0
tesub   =    tetyp+1        #subscript value} equ tetyp+1
teval   =    tesub+1        #(=vrval) table element value} equ tesub+1
tenxt   =    teval+1        #link to next teblk} equ teval+1
#      see s$cnv where relation is assumed with tenxt and tbbuk
tesi_   =    tenxt+1        #size of teblk in words} equ tenxt+1
#
#      tenxt points to the next teblk on the hash chain from the
#      tbbuk chain for this hash index. at the end of the chain,
#      tenxt points back to the start of the tbblk.
#
#      teval contains a data pointer or a trblk pointer.
#
#      tesub contains a data pointer.
                            #} ejc
        .eject
#
#      trap block (trblk)
#
#      a trap block is used to represent a trace or input or
#      output association in response to a call to the trace
#      input or output system functions. see below for details
#
#           +------------------------------------+
#           i                tridn               i
#           +------------------------------------+
#           i                trtyp               i
#           +------------------------------------+
#           i  trval or trlbl or trnxt or trkvr  i
#           +------------------------------------+
#           i       trtag or trter or trtrf      i
#           +------------------------------------+
#           i            trfnc or trfpt          i
#           +------------------------------------+
#
tridn   =    0              #pointer to dummy routine b_trt} equ 0
trtyp   =    tridn+1        #trap type code} equ tridn+1
trval   =    trtyp+1        #value of trapped variable (=vrval)} equ trtyp+1
trnxt   =    trval          #ptr to next trblk on trblk chain} equ trval
trlbl   =    trval          #ptr to actual label (traced label)} equ trval
trkvr   =    trval          #vrblk pointer for keyword trace} equ trval
trtag   =    trval+1        #trace tag} equ trval+1
trter   =    trtag          #ptr to terminal vrblk or null} equ trtag
trtrf   =    trtag          #ptr to trblk holding fcblk ptr} equ trtag
trfnc   =    trtag+1        #trace function vrblk (zero if none)} equ trtag+1
trfpt   =    trfnc          #fcblk ptr for sysio} equ trfnc
trsi_   =    trfnc+1        #number of words in trblk} equ trfnc+1
#
trtin   =    0              #trace type for input association} equ 0
trtac   =    trtin+1        #trace type for access trace} equ trtin+1
trtvl   =    trtac+1        #trace type for value trace} equ trtac+1
trtou   =    trtvl+1        #trace type for output association} equ trtvl+1
trtfc   =    trtou+1        #trace type for fcblk identification} equ trtou+1
                            #} ejc
        .eject
#
#      trap block (continued)
#
#      variable input association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtin
#           trnxt points to next trblk or trval has variable val
#           trter is a pointer to svblk if association is
#           for input, terminal, else it is null.
#           trtrf points to the trap block which in turn points
#           to an fcblk used for i/o association.
#           trfpt is the fcblk ptr returned by sysio.
#
#      variable access trace association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtac
#           trnxt points to next trblk or trval has variable val
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      variable value trace association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtvl
#           trnxt points to next trblk or trval has variable val
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
                            #} ejc
        .eject
#      trap block (continued)
#
#      variable output association
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case
#           of a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv to activate the check.
#
#           trtyp is set to trtou
#           trnxt points to next trblk or trval has variable val
#           trter is a pointer to svblk if association is
#           for output, terminal, else it is null.
#           trtrf points to the trap block which in turn points
#           to an fcblk used for i/o association.
#           trfpt is the fcblk ptr returned by sysio.
#
#      function call trace
#
#           the pfctr field of the corresponding pfblk is set
#           to point to a trblk.
#
#           trtyp is set to trtin
#           trnxt is zero
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      function return trace
#
#           the pfrtr field of the corresponding pfblk is set
#           to point to a trblk
#
#           trtyp is set to trtin
#           trnxt is zero
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      label trace
#
#           the vrlbl of the vrblk for the label is
#           changed to point to a trblk and the vrtra field is
#           set to b$vrt to activate the check.
#
#           trtyp is set to trtin
#           trlbl points to the actual label (cdblk) value
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
                            #} ejc
        .eject
#
#      trap block (continued)
#
#      keyword trace
#
#           keywords which can be traced possess a unique
#           location which is zero if there is no trace and
#           points to a trblk if there is a trace. the locations
#           are as follows.
#
#           r$ert            errtype
#           r$fnc            fnclevel
#           r$stc            stcount
#
#           the format of the trblk is as follows.
#
#           trtyp is set to trtin
#           trkvr is a pointer to the vrblk for the keyword
#           trtag is the trace tag (0 if none)
#           trfnc is the trace function vrblk ptr (0 if none)
#
#      input/output file arg1 trap block
#
#           the value field of the variable points to a trblk
#           instead of containing the data value. in the case of
#           a natural variable, the vrget and vrsto fields
#           contain =b$vra and =b$vrv. this trap block is used
#           to hold a pointer to the fcblk which an
#           implementation may request to hold information
#           about a file.
#
#           trtyp is set to trtfc
#           trnext points to next trblk or trval is variable val
#           trfnm is 0
#           trfpt is the fcblk pointer.
#
#      note that when multiple traps are set on a variable
#      the order is in ascending value of trtyp field.
#
#      input association (if present)
#      access trace (if present)
#      value trace (if present)
#      output association (if present)
#
#      the actual value of the variable is stored in the trval
#      field of the last trblk on the chain.
#
#      this implementation does not permit trace or i/o
#      associations to any of the pseudo-variables.
                            #} ejc
        .eject
#
#      vector block (vcblk)
#
#      a vcblk is used to represent an array value which has
#      one dimension whose lower bound is one. all other arrays
#      are represented by arblks. a vcblk is created by the
#      system function array (s$arr) when passed an integer arg.
#
#           +------------------------------------+
#           i                vctyp               i
#           +------------------------------------+
#           i                idval               i
#           +------------------------------------+
#           i                vclen               i
#           +------------------------------------+
#           i                vcvls               i
#           +------------------------------------+
#
vctyp   =    0              #pointer to dummy routine b_vct} equ 0
vclen   =    offs2          #length of vcblk in bytes} equ offs2
vcvls   =    offs3          #start of vector values} equ offs3
vcsi_   =    vcvls          #size of standard fields in vcblk} equ vcvls
vcvlb   =    vcvls-1        #offset one word behind vcvls} equ vcvls-1
vctbd   =    tbsi_-vcsi_    #difference in sizes - see prtvl} equ tbsi_-vcsi_
#
#      vcvls are either data pointers or trblk pointers
#
#      the dimension can be deduced from vclen.
                            #} ejc
        .eject
#
#      variable block (vrblk)
#
#      a variable block is built in the static memory area
#      for every variable referenced or created by a program.
#      the order of fields is assumed in the model vrblk stnvr.
#
#      note that since these blocks only occur in the static
#      region, it is permissible to point to any word in
#      the block and this is used to provide three distinct
#      access points from the generated code as follows.
#
#      1)   point to vrget (first word of vrblk) to load the
#           value of the variable onto the main stack.
#
#      2)   point to vrsto (second word of vrblk) to store the
#           top stack element as the value of the variable.
#
#      3)   point to vrtra (fourth word of vrblk) to jump to
#           the label associated with the variable name.
#
#           +------------------------------------+
#           i                vrget               i
#           +------------------------------------+
#           i                vrsto               i
#           +------------------------------------+
#           i                vrval               i
#           +------------------------------------+
#           i                vrtra               i
#           +------------------------------------+
#           i                vrlbl               i
#           +------------------------------------+
#           i                vrfnc               i
#           +------------------------------------+
#           i                vrnxt               i
#           +------------------------------------+
#           i                vrlen               i
#           +------------------------------------+
#           /                                    /
#           /            vrchs = vrsvp           /
#           /                                    /
#           +------------------------------------+
                            #} ejc
        .eject
#
#      variable block (continued)
#
vrget   =    0              #pointer to routine to load value} equ 0
vrsto   =    vrget+1        #pointer to routine to store value} equ vrget+1
vrval   =    vrsto+1        #variable value} equ vrsto+1
vrvlo   =    vrval-vrsto    #offset to value from store field} equ vrval-vrsto
vrtra   =    vrval+1        #pointer to routine to jump to label} equ vrval+1
vrlbl   =    vrtra+1        #pointer to code for label} equ vrtra+1
vrlbo   =    vrlbl-vrtra    #offset to label from transfer field} equ vrlbl-vrtra
vrfnc   =    vrlbl+1        #pointer to function block} equ vrlbl+1
vrnxt   =    vrfnc+1        #pointer to next vrblk on hash chain} equ vrfnc+1
vrlen   =    vrnxt+1        #length of name (or zero)} equ vrnxt+1
vrchs   =    vrlen+1        #characters of name (vrlen gt 0)} equ vrlen+1
vrsvp   =    vrlen+1        #ptr to svblk (vrlen eq 0)} equ vrlen+1
vrsi_   =    vrchs+1        #number of standard fields in vrblk} equ vrchs+1
vrsof   =    vrlen-sclen    #offset to dummy scblk for name} equ vrlen-sclen
vrsvo   =    vrsvp-vrsof    #pseudo-offset to vrsvp field} equ vrsvp-vrsof
#
#      vrget = b$vrl if not input associated or access traced
#      vrget = b$vra if input associated or access traced
#
#      vrsto = b$vrs if not output associated or value traced
#      vrsto = b$vrv if output associated or value traced
#      vrsto = b$vre if value is protected pattern value
#
#      vrval points to the appropriate value unless the
#      variable is i/o/trace associated in which case, vrval
#      points to an appropriate trblk (trap block) chain.
#
#      vrtra = b$vrg if the label is not traced
#      vrtra = b$vrt if the label is traced
#
#      vrlbl points to a cdblk if there is a label
#      vrlbl points to the svblk svlbl field for a system label
#      vrlbl points to stndl for an undefined label
#      vrlbl points to a trblk if the label is traced
#
#      vrfnc points to a ffblk for a field function
#      vrfnc points to a dfblk for a datatype function
#      vrfnc points to a pfblk for a program defined function
#      vrfnc points to a efblk for an external loaded function
#      vrfnc points to svfnc (svblk) for a system function
#      vrfnc points to stndf if the function is undefined
#
#      vrnxt points to the next vrblk on this chain unless
#      this is the end of the chain in which case it is zero.
#
#      vrlen is the name length for a non-system variable.
#      vrlen is zero for a system variable.
#
#      vrchs is the name (ljrz) if vrlen is non-zero.
#      vrsvp is a ptr to the svblk if vrlen is zero.
                            #} ejc
        .eject
#
#      format of a non-relocatable external block (xnblk)
#
#      an xnblk is a block representing an unknown (external)
#      data value. the block contains no pointers to other
#      relocatable blocks. an xnblk is used by external function
#      processing or possibly for system i/o routines etc.
#      the macro-system itself does not use xnblks.
#      this type of block may be used as a file control block.
#      see sysfc,sysin,sysou,s$inp,s$oup for details.
#
#           +------------------------------------+
#           i                xntyp               i
#           +------------------------------------+
#           i                xnlen               i
#           +------------------------------------+
#           /                                    /
#           /                xndta               /
#           /                                    /
#           +------------------------------------+
#
xntyp   =    0              #pointer to dummy routine b_xnt} equ 0
xnlen   =    xntyp+1        #length of xnblk in bytes} equ xntyp+1
xndta   =    xnlen+1        #data words} equ xnlen+1
xnsi_   =    xndta          #size of standard fields in xnblk} equ xndta
#
#      note that the term non-relocatable refers to the contents
#      and not the block itself. an xnblk can be moved around if
#      it is built in the dynamic memory area.
                            #} ejc
        .eject
#
#      relocatable external block (xrblk)
#
#      an xrblk is a block representing an unknown (external)
#      data value. the data area in this block consists only
#      of address values and any addresses pointing into the
#      dynamic memory area must point to the start of other
#      data blocks. see also description of xnblk.
#      this type of block may be used as a file control block.
#      see sysfc,sysin,sysou,s$inp,s$oup for details.
#
#           +------------------------------------+
#           i                xrtyp               i
#           +------------------------------------+
#           i                xrlen               i
#           +------------------------------------+
#           /                                    /
#           /                xrptr               /
#           /                                    /
#           +------------------------------------+
#
xrtyp   =    0              #pointer to dummy routine b_xrt} equ 0
xrlen   =    xrtyp+1        #length of xrblk in bytes} equ xrtyp+1
xrptr   =    xrlen+1        #start of address pointers} equ xrlen+1
xrsi_   =    xrptr          #size of standard fields in xrblk} equ xrptr
                            #} ejc
        .eject
#
#      s$cnv (convert) function switch constants.  the values
#      are tied to the order of the entries in the svctb table
#      and hence to the branch table in s$cnv.
#
cnvst   =    8              #max standard type code for convert} equ 8
cnvrt   =    cnvst+1        #convert code for reals} equ cnvst+1
cnvbt   =    cnvrt          #no buffers - same as real code} equ cnvrt
cnvtt   =    cnvbt+1        #bsw code for convert} equ cnvbt+1
#
#      input image length
#
iniln   =    1024           #default image length for compiler} equ 1024
inils   =    1024           #image length if -sequ in effect} equ 1024
#
ionmb   =    2              #name base used for iochn in sysio} equ 2
ionmo   =    4              #name offset used for iochn in sysio} equ 4
#
#      minimum value for keyword maxlngth
#      should be larger than iniln
#
mnlen   =    1024           #min value allowed keyword maxlngth} equ 1024
mxern   =    329            #err num inadequate startup memory} equ 329
#
#      in general, meaningful mnemonics should be used for
#      offsets. however for small integers used often in
#      literals the following general definitions are provided.
#
num01   =    1              #} equ 1
num02   =    2              #} equ 2
num03   =    3              #} equ 3
num04   =    4              #} equ 4
num05   =    5              #} equ 5
num06   =    6              #} equ 6
num07   =    7              #} equ 7
num08   =    8              #} equ 8
num09   =    9              #} equ 9
num10   =    10             #} equ 10
nm320   =    320            #} equ 320
nm321   =    321            #} equ 321
nini8   =    998            #} equ 998
nini9   =    999            #} equ 999
thsnd   =    1000           #} equ 1000
                            #} ejc
        .eject
#
#      numbers of undefined spitbol operators
#
opbun   =    5              #no. of binary undefined ops} equ 5
opuun   =    6              #no of unary undefined ops} equ 6
#
#      offsets used in prtsn, prtmi and acess
#
prsnf   =    13             #offset used in prtsn} equ 13
prtmf   =    21             #offset to col 21 (prtmi)} equ 21
rilen   =    1024           #buffer length for sysri} equ 1024
#
#      codes for stages of processing
#
stgic   =    0              #initial compile} equ 0
stgxc   =    stgic+1        #execution compile (code)} equ stgic+1
stgev   =    stgxc+1        #expression eval during execution} equ stgxc+1
stgxt   =    stgev+1        #execution time} equ stgev+1
stgce   =    stgxt+1        #initial compile after end line} equ stgxt+1
stgxe   =    stgce+1        #exec. compile after end line} equ stgce+1
stgnd   =    stgce-stgic    #difference in stage after end} equ stgce-stgic
stgee   =    stgxe+1        #eval evaluating expression} equ stgxe+1
stgno   =    stgee+1        #number of codes} equ stgee+1
                            #} ejc
        .eject
#
#
#      statement number pad count for listr
#
stnpd   =    8              #statement no. pad count} equ 8
#
#      syntax type codes
#
#      these codes are returned from the scane procedure.
#
#      they are spaced 3 apart for the benefit of expan.
#
t_uop   =    0              #unary operator} equ 0
t_lpr   =    t_uop+3        #left paren} equ t_uop+3
t_lbr   =    t_lpr+3        #left bracket} equ t_lpr+3
t_cma   =    t_lbr+3        #comma} equ t_lbr+3
t_fnc   =    t_cma+3        #function call} equ t_cma+3
t_var   =    t_fnc+3        #variable} equ t_fnc+3
t_con   =    t_var+3        #constant} equ t_var+3
t_bop   =    t_con+3        #binary operator} equ t_con+3
t_rpr   =    t_bop+3        #right paren} equ t_bop+3
t_rbr   =    t_rpr+3        #right bracket} equ t_rpr+3
t_col   =    t_rbr+3        #colon} equ t_rbr+3
t_smc   =    t_col+3        #semi-colon} equ t_col+3
#
#      the following definitions are used only in the goto field
#
t_fgo   =    t_smc+1        #failure goto} equ t_smc+1
t_sgo   =    t_fgo+1        #success goto} equ t_fgo+1
#
#      the above codes are grouped so that codes for elements
#      which can legitimately immediately precede a unary
#      operator come first to facilitate operator syntax check.
#
t_uok   =    t_fnc          #last code ok before unary operator} equ t_fnc
                            #} ejc
        .eject
#
#      definitions of values for expan jump table
#
t_uo0   =    t_uop+0        #unary operator, state zero} equ t_uop+0
t_uo1   =    t_uop+1        #unary operator, state one} equ t_uop+1
t_uo2   =    t_uop+2        #unary operator, state two} equ t_uop+2
t_lp0   =    t_lpr+0        #left paren, state zero} equ t_lpr+0
t_lp1   =    t_lpr+1        #left paren, state one} equ t_lpr+1
t_lp2   =    t_lpr+2        #left paren, state two} equ t_lpr+2
t_lb0   =    t_lbr+0        #left bracket, state zero} equ t_lbr+0
t_lb1   =    t_lbr+1        #left bracket, state one} equ t_lbr+1
t_lb2   =    t_lbr+2        #left bracket, state two} equ t_lbr+2
t_cm0   =    t_cma+0        #comma, state zero} equ t_cma+0
t_cm1   =    t_cma+1        #comma, state one} equ t_cma+1
t_cm2   =    t_cma+2        #comma, state two} equ t_cma+2
t_fn0   =    t_fnc+0        #function call, state zero} equ t_fnc+0
t_fn1   =    t_fnc+1        #function call, state one} equ t_fnc+1
t_fn2   =    t_fnc+2        #function call, state two} equ t_fnc+2
t_va0   =    t_var+0        #variable, state zero} equ t_var+0
t_va1   =    t_var+1        #variable, state one} equ t_var+1
t_va2   =    t_var+2        #variable, state two} equ t_var+2
t_co0   =    t_con+0        #constant, state zero} equ t_con+0
t_co1   =    t_con+1        #constant, state one} equ t_con+1
t_co2   =    t_con+2        #constant, state two} equ t_con+2
t_bo0   =    t_bop+0        #binary operator, state zero} equ t_bop+0
t_bo1   =    t_bop+1        #binary operator, state one} equ t_bop+1
t_bo2   =    t_bop+2        #binary operator, state two} equ t_bop+2
t_rp0   =    t_rpr+0        #right paren, state zero} equ t_rpr+0
t_rp1   =    t_rpr+1        #right paren, state one} equ t_rpr+1
t_rp2   =    t_rpr+2        #right paren, state two} equ t_rpr+2
t_rb0   =    t_rbr+0        #right bracket, state zero} equ t_rbr+0
t_rb1   =    t_rbr+1        #right bracket, state one} equ t_rbr+1
t_rb2   =    t_rbr+2        #right bracket, state two} equ t_rbr+2
t_cl0   =    t_col+0        #colon, state zero} equ t_col+0
t_cl1   =    t_col+1        #colon, state one} equ t_col+1
t_cl2   =    t_col+2        #colon, state two} equ t_col+2
t_sm0   =    t_smc+0        #semicolon, state zero} equ t_smc+0
t_sm1   =    t_smc+1        #semicolon, state one} equ t_smc+1
t_sm2   =    t_smc+2        #semicolon, state two} equ t_smc+2
#
t_nes   =    t_sm2+1        #number of entries in branch table} equ t_sm2+1
                            #} ejc
        .eject
#
#       definition of offsets used in control card processing
#
cc_ca   =    0              #-case} equ 0
cc_do   =    cc_ca+1        #-double} equ cc_ca+1
cc_co   =    cc_do+1        #-compare} equ cc_do+1
cc_du   =    cc_co+1        #-dump} equ cc_co+1
cc_cp   =    cc_du+1        #-copy} equ cc_du+1
cc_ej   =    cc_cp+1        #-eject} equ cc_cp+1
cc_er   =    cc_ej+1        #-errors} equ cc_ej+1
cc_ex   =    cc_er+1        #-execute} equ cc_er+1
cc_fa   =    cc_ex+1        #-fail} equ cc_ex+1
cc_in   =    cc_fa+1        #-include} equ cc_fa+1
cc_ln   =    cc_in+1        #-line} equ cc_in+1
cc_li   =    cc_ln+1        #-list} equ cc_ln+1
cc_nr   =    cc_li+1        #-noerrors} equ cc_li+1
cc_nx   =    cc_nr+1        #-noexecute} equ cc_nr+1
cc_nf   =    cc_nx+1        #-nofail} equ cc_nx+1
cc_nl   =    cc_nf+1        #-nolist} equ cc_nf+1
cc_no   =    cc_nl+1        #-noopt} equ cc_nl+1
cc_np   =    cc_no+1        #-noprint} equ cc_no+1
cc_op   =    cc_np+1        #-optimise} equ cc_np+1
cc_pr   =    cc_op+1        #-print} equ cc_op+1
cc_si   =    cc_pr+1        #-single} equ cc_pr+1
cc_sp   =    cc_si+1        #-space} equ cc_si+1
cc_st   =    cc_sp+1        #-stitl} equ cc_sp+1
cc_ti   =    cc_st+1        #-title} equ cc_st+1
cc_tr   =    cc_ti+1        #-trace} equ cc_ti+1
cc_nc   =    cc_tr+1        #number of control cards} equ cc_tr+1
ccnoc   =    4              #no. of chars included in match} equ 4
ccofs   =    7              #offset to start of title/subtitle} equ 7
ccinm   =    9              #max depth of include file nesting} equ 9
                            #} ejc
        .eject
#
#      definitions of stack offsets used in cmpil procedure
#
#      see description at start of cmpil procedure for details
#      of use of these locations on the stack.
#
cmstm   =    0              #tree for statement body} equ 0
cmsgo   =    cmstm+1        #tree for success goto} equ cmstm+1
cmfgo   =    cmsgo+1        #tree for fail goto} equ cmsgo+1
cmcgo   =    cmfgo+1        #conditional goto flag} equ cmfgo+1
cmpcd   =    cmcgo+1        #previous cdblk pointer} equ cmcgo+1
cmffp   =    cmpcd+1        #failure fill in flag for previous} equ cmpcd+1
cmffc   =    cmffp+1        #failure fill in flag for current} equ cmffp+1
cmsop   =    cmffc+1        #success fill in offset for previous} equ cmffc+1
cmsoc   =    cmsop+1        #success fill in offset for current} equ cmsop+1
cmlbl   =    cmsoc+1        #ptr to vrblk for current label} equ cmsoc+1
cmtra   =    cmlbl+1        #ptr to entry cdblk} equ cmlbl+1
#
cmnen   =    cmtra+1        #count of stack entries for cmpil} equ cmtra+1
#
#      a few constants used by the profiler
pfpd1   =    8              #pad positions ...} equ 8
pfpd2   =    20             #... for profile ...} equ 20
pfpd3   =    32             #... printout} equ 32
pf_i2   =    cfp_i+cfp_i    #size of table entry (2 ints)} equ cfp_i+cfp_i
                            #} ejc
        .eject
#
#      definition of limits and adjustments that are built by
#      relcr for use by the routines that relocate pointers
#      after a save file is reloaded.  see reloc etc. for usage.
#
#      a block of information is built that is used in
#      relocating pointers.  there are rnsi$ instances
#      of a rssi$ word structure.  each instance corresponds
#      to one of the regions that a pointer might point into.
#
#      each structure takes the form:
#
#           +------------------------------------+
#           i    address past end of section     i
#           +------------------------------------+
#           i  adjustment from old to new adrs   i
#           +------------------------------------+
#           i    address of start of section     i
#           +------------------------------------+
#
#      the instances are ordered thusly:
#
#           +------------------------------------+
#           i           dynamic storage          i
#           +------------------------------------+
#           i           static storage           i
#           +------------------------------------+
#           i       working section globals      i
#           +------------------------------------+
#           i          constant section          i
#           +------------------------------------+
#           i            code section            i
#           +------------------------------------+
#
#      symbolic names for these locations as offsets from
#      the first entry are provided here.
#
#      definitions within a section
#
rlend   =    0              #end} equ 0
rladj   =    rlend+1        #adjustment} equ rlend+1
rlstr   =    rladj+1        #start} equ rladj+1
rssi_   =    rlstr+1        #size of section} equ rlstr+1
rnsi_   =    5              #number of structures} equ 5
#
#      overall definitions of all structures
#
rldye   =    0              #dynamic region end} equ 0
rldya   =    rldye+1        #dynamic region adjustment} equ rldye+1
rldys   =    rldya+1        #dynamic region start} equ rldya+1
rlste   =    rldys+1        #static region end} equ rldys+1
rlsta   =    rlste+1        #static region adjustment} equ rlste+1
rlsts   =    rlsta+1        #static region start} equ rlsta+1
rlwke   =    rlsts+1        #working section globals end} equ rlsts+1
rlwka   =    rlwke+1        #working section globals adjustment} equ rlwke+1
rlwks   =    rlwka+1        #working section globals start} equ rlwka+1
rlcne   =    rlwks+1        #constants section end} equ rlwks+1
rlcna   =    rlcne+1        #constants section adjustment} equ rlcne+1
rlcns   =    rlcna+1        #constants section start} equ rlcna+1
rlcde   =    rlcns+1        #code section end} equ rlcns+1
rlcda   =    rlcde+1        #code section adjustment} equ rlcde+1
rlcds   =    rlcda+1        #code section start} equ rlcda+1
rlsi_   =    rlcds+1        #number of fields in structure} equ rlcds+1
#
                            #} ttl s p i t b o l -- constant section
        .sbttl "s p i t b o l -- constant section"
#
#      this section consists entirely of assembled constants.
#
#      all label names are five letters. the order is
#      approximately alphabetical, but in some cases (always
#      documented), constants must be placed in some special
#      order which must not be disturbed.
#
#      it must also be remembered that there is a requirement
#      for no forward references which also disturbs the
#      alphabetical order in some cases.
#
                            #start of constant section} sec
        DSegEnd_
        DSeg_
        .global SEC03
SEC03:
#
#      start of constant section
#
c_aaa:  .long 0             #first location of constant section} dac 0
#
#      free store percentage (used by alloc)
#
alfsp:  .long e_fsp         #free store percentage} dac e_fsp
#
#      bit constants for general use
#
bits0:  .long 0             #all zero bits} dbc 0
bits1:  .long 1             #one bit in low order position} dbc 1
bits2:  .long 2             #bit in position 2} dbc 2
bits3:  .long 4             #bit in position 3} dbc 4
bits4:  .long 8             #bit in position 4} dbc 8
bits5:  .long 16            #bit in position 5} dbc 16
bits6:  .long 32            #bit in position 6} dbc 32
bits7:  .long 64            #bit in position 7} dbc 64
bits8:  .long 128           #bit in position 8} dbc 128
bits9:  .long 256           #bit in position 9} dbc 256
bit10:  .long 512           #bit in position 10} dbc 512
bit11:  .long 1024          #bit in position 11} dbc 1024
bit12:  .long 2048          #bit in position 12} dbc 2048
bitsm:  .long cfp_m         #mask for max integer} dbc cfp_m
#
#      bit constants for svblk (svbit field) tests
#
btfnc:  .long svfnc         #bit to test for function} dbc svfnc
btknm:  .long svknm         #bit to test for keyword number} dbc svknm
btlbl:  .long svlbl         #bit to test for label} dbc svlbl
btffc:  .long svffc         #bit to test for fast call} dbc svffc
btckw:  .long svckw         #bit to test for constant keyword} dbc svckw
btkwv:  .long svkwv         #bits to test for keword with value} dbc svkwv
btprd:  .long svprd         #bit to test for predicate function} dbc svprd
btpre:  .long svpre         #bit to test for preevaluation} dbc svpre
btval:  .long svval         #bit to test for value} dbc svval
                            #} ejc
        .eject
#
#      list of names used for control card processing
#
ccnms:  .ascii "case"       #} dtc /case/
        .ascii "doub"       #} dtc /doub/
        .ascii "comp"       #} dtc /comp/
        .ascii "dump"       #} dtc /dump/
        .ascii "copy"       #} dtc /copy/
        .ascii "ejec"       #} dtc /ejec/
        .ascii "erro"       #} dtc /erro/
        .ascii "exec"       #} dtc /exec/
        .ascii "fail"       #} dtc /fail/
        .ascii "incl"       #} dtc /incl/
        .ascii "line"       #} dtc /line/
        .ascii "list"       #} dtc /list/
        .ascii "noer"       #} dtc /noer/
        .ascii "noex"       #} dtc /noex/
        .ascii "nofa"       #} dtc /nofa/
        .ascii "noli"       #} dtc /noli/
        .ascii "noop"       #} dtc /noop/
        .ascii "nopr"       #} dtc /nopr/
        .ascii "opti"       #} dtc /opti/
        .ascii "prin"       #} dtc /prin/
        .ascii "sing"       #} dtc /sing/
        .ascii "spac"       #} dtc /spac/
        .ascii "stit"       #} dtc /stit/
        .ascii "titl"       #} dtc /titl/
        .ascii "trac"       #} dtc /trac/
#
#      header messages for dumpr procedure (scblk format)
#
dmhdk:  .long b_scl         #dump of keyword values} dac b_scl
        .long 22            #} dac 22
        .ascii "dump of keyword values\x00\x00" #} dtc /dump of keyword values/
#
dmhdv:  .long b_scl         #dump of natural variables} dac b_scl
        .long 25            #} dac 25
        .ascii "dump of natural variables\x00\x00\x00" #} dtc /dump of natural variables/
                            #} ejc
        .eject
#
#      message text for compilation statistics
#
encm1:  .long b_scl         #} dac b_scl
        .long 19            #} dac 19
        .ascii "memory used (bytes)\x00" #} dtc /memory used (bytes)/
#
encm2:  .long b_scl         #} dac b_scl
        .long 19            #} dac 19
        .ascii "memory left (bytes)\x00" #} dtc /memory left (bytes)/
#
encm3:  .long b_scl         #} dac b_scl
        .long 11            #} dac 11
        .ascii "comp errors\x00" #} dtc /comp errors/
#
encm4:  .long b_scl         #} dac b_scl
        .long 20            #} dac 20
        .ascii "comp time (millisec)" #} dtc /comp time (millisec)/
#
encm5:  .long b_scl         #execution suppressed} dac b_scl
        .long 20            #} dac 20
        .ascii "execution suppressed" #} dtc /execution suppressed/
#
#      string constant for abnormal end
#
endab:  .long b_scl         #} dac b_scl
        .long 12            #} dac 12
        .ascii "abnormal end" #} dtc /abnormal end/
                            #} ejc
        .eject
#
#      memory overflow during initialisation
#
endmo:  .long b_scl         #} dac b_scl
endml:  .long 15            #} dac 15
        .ascii "memory overflow\x00" #} dtc /memory overflow/
#
#      string constant for message issued by l$end
#
endms:  .long b_scl         #} dac b_scl
        .long 10            #} dac 10
        .ascii "normal end\x00\x00" #} dtc /normal end/
#
#      fail message for stack fail section
#
endso:  .long b_scl         #stack overflow in garbage collector} dac b_scl
        .long 36            #} dac 36
        .ascii "stack overflow in garbage collection" #} dtc /stack overflow in garbage collection/
#
#      string constant for time up
#
endtu:  .long b_scl         #} dac b_scl
        .long 15            #} dac 15
        .ascii "error - time up\x00" #} dtc /error - time up/
                            #} ejc
        .eject
#
#      string constant for error message (error section)
#
ermms:  .long b_scl         #error} dac b_scl
        .long 5             #} dac 5
        .ascii "error\x00\x00\x00" #} dtc /error/
#
ermns:  .long b_scl         #string / -- /} dac b_scl
        .long 4             #} dac 4
        .ascii " -- "       #} dtc / -- /
#
#      string constant for page numbering
#
lstms:  .long b_scl         #page} dac b_scl
        .long 5             #} dac 5
        .ascii "page \x00\x00\x00" #} dtc /page /
#
#      listing header message
#
headr:  .long b_scl         #} dac b_scl
        .long 25            #} dac 25
        .ascii "macro spitbol version 4.0\x00\x00\x00" #} dtc /macro spitbol version 4.0/
#
headv:  .long b_scl         #for exit() version no. check} dac b_scl
        .long 5             #} dac 5
        .ascii "4.0.0\x00\x00\x00" #} dtc /4.0.0/
#      free store percentage (used by gbcol)
#
gbsdp:  .long e_sed         #sediment percentage} dac e_sed
#
#      integer constants for general use
#      icbld optimisation uses the first three.
#
int_r:  .long b_icl         #} dac b_icl
intv0:  .long +0            #0} dic +0
inton:  .long b_icl         #} dac b_icl
intv1:  .long +1            #1} dic +1
inttw:  .long b_icl         #} dac b_icl
intv2:  .long +2            #2} dic +2
intvt:  .long +10           #10} dic +10
intvh:  .long +100          #100} dic +100
intth:  .long +1000         #1000} dic +1000
#
#      table used in icbld optimisation
#
intab:  .long int_r         #pointer to 0} dac int_r
        .long inton         #pointer to 1} dac inton
        .long inttw         #pointer to 2} dac inttw
                            #} ejc
        .eject
#
#      special pattern nodes. the following pattern nodes
#      consist simply of a pcode pointer, see match routines
#      (p$xxx) for full details of their use and format).
#
ndabb:  .long p_abb         #arbno} dac p_abb
ndabd:  .long p_abd         #arbno} dac p_abd
ndarc:  .long p_arc         #arb} dac p_arc
ndexb:  .long p_exb         #expression} dac p_exb
ndfnb:  .long p_fnb         #fence()} dac p_fnb
ndfnd:  .long p_fnd         #fence()} dac p_fnd
ndexc:  .long p_exc         #expression} dac p_exc
ndimb:  .long p_imb         #immediate assignment} dac p_imb
ndimd:  .long p_imd         #immediate assignment} dac p_imd
ndnth:  .long p_nth         #pattern end (null pattern)} dac p_nth
ndpab:  .long p_pab         #pattern assignment} dac p_pab
ndpad:  .long p_pad         #pattern assignment} dac p_pad
nduna:  .long p_una         #anchor point movement} dac p_una
#
#      keyword constant pattern nodes. the following nodes are
#      used as the values of pattern keywords and the initial
#      values of the corresponding natural variables. all
#      nodes are in p0blk format and the order is tied to the
#      definitions of corresponding k$xxx symbols.
#
ndabo:  .long p_abo         #abort} dac p_abo
        .long ndnth         #} dac ndnth
ndarb:  .long p_arb         #arb} dac p_arb
        .long ndnth         #} dac ndnth
ndbal:  .long p_bal         #bal} dac p_bal
        .long ndnth         #} dac ndnth
ndfal:  .long p_fal         #fail} dac p_fal
        .long ndnth         #} dac ndnth
ndfen:  .long p_fen         #fence} dac p_fen
        .long ndnth         #} dac ndnth
ndrem:  .long p_rem         #rem} dac p_rem
        .long ndnth         #} dac ndnth
ndsuc:  .long p_suc         #succeed} dac p_suc
        .long ndnth         #} dac ndnth
#
#      null string. all null values point to this string. the
#      svchs field contains a blank to provide for easy default
#      processing in trace, stoptr, lpad and rpad.
#      nullw contains 10 blanks which ensures an all blank word
#      but for very exceptional machines.
#
nulls:  .long b_scl         #null string value} dac b_scl
        .long 0             #sclen = 0} dac 0
nullw:  .ascii "          \x00\x00" #} dtc /          /
#
#
#      constant strings for lcase and ucase keywords
#
lcase:  .long b_scl         #} dac b_scl
        .long 26            #} dac 26
        .ascii "abcdefghijklmnopqrstuvwxyz\x00\x00" #} dtc /abcdefghijklmnopqrstuvwxyz/
#
ucase:  .long b_scl         #} dac b_scl
        .long 26            #} dac 26
        .ascii "abcdefghijklmnopqrstuvwxyz\x00\x00" #} dtc /abcdefghijklmnopqrstuvwxyz/
                            #} ejc
        .eject
#
#      operator dope vectors (see dvblk format)
#
opdvc:  .long o_cnc         #concatenation} dac o_cnc
        .long c_cnc         #} dac c_cnc
        .long llcnc         #} dac llcnc
        .long rrcnc         #} dac rrcnc
#
#      opdvs is used when scanning below the top level to
#      insure that the concatenation will not be later
#      mistaken for pattern matching
#
opdvp:  .long o_cnc         #concatenation - not pattern match} dac o_cnc
        .long c_cnp         #} dac c_cnp
        .long llcnc         #} dac llcnc
        .long rrcnc         #} dac rrcnc
#
#      note that the order of the remaining entries is tied to
#      the order of the coding in the scane procedure.
#
opdvs:  .long o_ass         #assignment} dac o_ass
        .long c_ass         #} dac c_ass
        .long llass         #} dac llass
        .long rrass         #} dac rrass
#
        .long 6             #unary equal} dac 6
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_pmv         #pattern match} dac o_pmv
        .long c_pmt         #} dac c_pmt
        .long llpmt         #} dac llpmt
        .long rrpmt         #} dac rrpmt
#
        .long o_int         #interrogation} dac o_int
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
        .long 1             #binary ampersand} dac 1
        .long c_ubo         #} dac c_ubo
        .long llamp         #} dac llamp
        .long rramp         #} dac rramp
#
        .long o_kwv         #keyword reference} dac o_kwv
        .long c_key         #} dac c_key
        .long lluno         #} dac lluno
#
        .long o_alt         #alternation} dac o_alt
        .long c_alt         #} dac c_alt
        .long llalt         #} dac llalt
        .long rralt         #} dac rralt
                            #} ejc
        .eject
#
#      operator dope vectors (continued)
#
        .long 5             #unary vertical bar} dac 5
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long 0             #binary at} dac 0
        .long c_ubo         #} dac c_ubo
        .long llats         #} dac llats
        .long rrats         #} dac rrats
#
        .long o_cas         #cursor assignment} dac o_cas
        .long c_unm         #} dac c_unm
        .long lluno         #} dac lluno
#
        .long 2             #binary number sign} dac 2
        .long c_ubo         #} dac c_ubo
        .long llnum         #} dac llnum
        .long rrnum         #} dac rrnum
#
        .long 7             #unary number sign} dac 7
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_dvd         #division} dac o_dvd
        .long c_bvl         #} dac c_bvl
        .long lldvd         #} dac lldvd
        .long rrdvd         #} dac rrdvd
#
        .long 9             #unary slash} dac 9
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_mlt         #multiplication} dac o_mlt
        .long c_bvl         #} dac c_bvl
        .long llmlt         #} dac llmlt
        .long rrmlt         #} dac rrmlt
                            #} ejc
        .eject
#
#      operator dope vectors (continued)
#
        .long 0             #deferred expression} dac 0
        .long c_def         #} dac c_def
        .long lluno         #} dac lluno
#
        .long 3             #binary percent} dac 3
        .long c_ubo         #} dac c_ubo
        .long llpct         #} dac llpct
        .long rrpct         #} dac rrpct
#
        .long 8             #unary percent} dac 8
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_exp         #exponentiation} dac o_exp
        .long c_bvl         #} dac c_bvl
        .long llexp         #} dac llexp
        .long rrexp         #} dac rrexp
#
        .long 10            #unary exclamation} dac 10
        .long c_uuo         #} dac c_uuo
        .long lluno         #} dac lluno
#
        .long o_ima         #immediate assignment} dac o_ima
        .long c_bvn         #} dac c_bvn
        .long lldld         #} dac lldld
        .long rrdld         #} dac rrdld
#
        .long o_inv         #indirection} dac o_inv
        .long c_ind         #} dac c_ind
        .long lluno         #} dac lluno
#
        .long 4             #binary not} dac 4
        .long c_ubo         #} dac c_ubo
        .long llnot         #} dac llnot
        .long rrnot         #} dac rrnot
#
        .long 0             #negation} dac 0
        .long c_neg         #} dac c_neg
        .long lluno         #} dac lluno
                            #} ejc
        .eject
#
#      operator dope vectors (continued)
#
        .long o_sub         #subtraction} dac o_sub
        .long c_bvl         #} dac c_bvl
        .long llplm         #} dac llplm
        .long rrplm         #} dac rrplm
#
        .long o_com         #complementation} dac o_com
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
        .long o_add         #addition} dac o_add
        .long c_bvl         #} dac c_bvl
        .long llplm         #} dac llplm
        .long rrplm         #} dac rrplm
#
        .long o_aff         #affirmation} dac o_aff
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
        .long o_pas         #pattern assignment} dac o_pas
        .long c_bvn         #} dac c_bvn
        .long lldld         #} dac lldld
        .long rrdld         #} dac rrdld
#
        .long o_nam         #name reference} dac o_nam
        .long c_unm         #} dac c_unm
        .long lluno         #} dac lluno
#
#      special dvs for goto operators (see procedure scngf)
#
opdvd:  .long o_god         #direct goto} dac o_god
        .long c_uvl         #} dac c_uvl
        .long lluno         #} dac lluno
#
opdvn:  .long o_goc         #complex normal goto} dac o_goc
        .long c_unm         #} dac c_unm
        .long lluno         #} dac lluno
                            #} ejc
        .eject
#
#      operator entry address pointers, used in code
#
oamn_:  .long o_amn         #array ref (multi-subs by value)} dac o_amn
oamv_:  .long o_amv         #array ref (multi-subs by value)} dac o_amv
oaon_:  .long o_aon         #array ref (one sub by name)} dac o_aon
oaov_:  .long o_aov         #array ref (one sub by value)} dac o_aov
ocer_:  .long o_cer         #compilation error} dac o_cer
ofex_:  .long o_fex         #failure in expression evaluation} dac o_fex
ofif_:  .long o_fif         #failure during goto evaluation} dac o_fif
ofnc_:  .long o_fnc         #function call (more than one arg)} dac o_fnc
ofne_:  .long o_fne         #function name error} dac o_fne
ofns_:  .long o_fns         #function call (single argument)} dac o_fns
ogof_:  .long o_gof         #set goto failure trap} dac o_gof
oinn_:  .long o_inn         #indirection by name} dac o_inn
okwn_:  .long o_kwn         #keyword reference by name} dac o_kwn
olex_:  .long o_lex         #load expression by name} dac o_lex
olpt_:  .long o_lpt         #load pattern} dac o_lpt
olvn_:  .long o_lvn         #load variable name} dac o_lvn
onta_:  .long o_nta         #negation, first entry} dac o_nta
ontb_:  .long o_ntb         #negation, second entry} dac o_ntb
ontc_:  .long o_ntc         #negation, third entry} dac o_ntc
opmn_:  .long o_pmn         #pattern match by name} dac o_pmn
opms_:  .long o_pms         #pattern match (statement)} dac o_pms
opop_:  .long o_pop         #pop top stack item} dac o_pop
ornm_:  .long o_rnm         #return name from expression} dac o_rnm
orpl_:  .long o_rpl         #pattern replacement} dac o_rpl
orvl_:  .long o_rvl         #return value from expression} dac o_rvl
osla_:  .long o_sla         #selection, first entry} dac o_sla
oslb_:  .long o_slb         #selection, second entry} dac o_slb
oslc_:  .long o_slc         #selection, third entry} dac o_slc
osld_:  .long o_sld         #selection, fourth entry} dac o_sld
ostp_:  .long o_stp         #stop execution} dac o_stp
ounf_:  .long o_unf         #unexpected failure} dac o_unf
                            #} ejc
        .eject
#
#      table of names of undefined binary operators for opsyn
#
opsnb:  .long ch_at         #at} dac ch_at
        .long ch_am         #ampersand} dac ch_am
        .long ch_nm         #number} dac ch_nm
        .long ch_pc         #percent} dac ch_pc
        .long ch_nt         #not} dac ch_nt
#
#      table of names of undefined unary operators for opsyn
#
opnsu:  .long ch_br         #vertical bar} dac ch_br
        .long ch_eq         #equal} dac ch_eq
        .long ch_nm         #number} dac ch_nm
        .long ch_pc         #percent} dac ch_pc
        .long ch_sl         #slash} dac ch_sl
        .long ch_ex         #exclamation} dac ch_ex
#
#      address const containing profile table entry size
#
pfi2a:  .long pf_i2         #} dac pf_i2
#
#      profiler message strings
#
pfms1:  .long b_scl         #} dac b_scl
        .long 15            #} dac 15
        .ascii "program profile\x00" #} dtc /program profile/
pfms2:  .long b_scl         #} dac b_scl
        .long 42            #} dac 42
        .ascii "stmt    number of     -- execution time --\x00\x00" #} dtc /stmt    number of     -- execution time --/
pfms3:  .long b_scl         #} dac b_scl
        .long 47            #} dac 47
        .ascii "number  executions  total(msec) per excn(mcsec)\x00" #} dtc /number  executions  total(msec) per excn(mcsec)/
#
#
#      real constants for general use. note that the constants
#      starting at reav1 form a powers of ten table (used in
#      gtnum and gtstg)
#
        .balign 4           #0.0} drc +0.0
reav0:  .double 0e0.0
        .balign 4           #0.1} drc +0.1
reap1:  .double 0e0.1
        .balign 4           #0.5} drc +0.5
reap5:  .double 0e0.5
        .balign 4           #10**0} drc +1.0
reav1:  .double 0e1.0
        .balign 4           #10**1} drc +1.0e+1
reavt:  .double 0e1.0e+1
        .balign 4           #10**2} drc +1.0e+2
        .double 0e1.0e+2
        .balign 4           #10**3} drc +1.0e+3
        .double 0e1.0e+3
        .balign 4           #10**4} drc +1.0e+4
        .double 0e1.0e+4
        .balign 4           #10**5} drc +1.0e+5
        .double 0e1.0e+5
        .balign 4           #10**6} drc +1.0e+6
        .double 0e1.0e+6
        .balign 4           #10**7} drc +1.0e+7
        .double 0e1.0e+7
        .balign 4           #10**8} drc +1.0e+8
        .double 0e1.0e+8
        .balign 4           #10**9} drc +1.0e+9
        .double 0e1.0e+9
        .balign 4           #10**10} drc +1.0e+10
reatt:  .double 0e1.0e+10
                            #} ejc
        .eject
#
#      string constants (scblk format) for dtype procedure
#
scarr:  .long b_scl         #array} dac b_scl
        .long 5             #} dac 5
        .ascii "array\x00\x00\x00" #} dtc /array/
#
sccod:  .long b_scl         #code} dac b_scl
        .long 4             #} dac 4
        .ascii "code"       #} dtc /code/
#
scexp:  .long b_scl         #expression} dac b_scl
        .long 10            #} dac 10
        .ascii "expression\x00\x00" #} dtc /expression/
#
scext:  .long b_scl         #external} dac b_scl
        .long 8             #} dac 8
        .ascii "external"   #} dtc /external/
#
scint:  .long b_scl         #integer} dac b_scl
        .long 7             #} dac 7
        .ascii "integer\x00" #} dtc /integer/
#
scnam:  .long b_scl         #name} dac b_scl
        .long 4             #} dac 4
        .ascii "name"       #} dtc /name/
#
scnum:  .long b_scl         #numeric} dac b_scl
        .long 7             #} dac 7
        .ascii "numeric\x00" #} dtc /numeric/
#
scpat:  .long b_scl         #pattern} dac b_scl
        .long 7             #} dac 7
        .ascii "pattern\x00" #} dtc /pattern/
#
screa:  .long b_scl         #real} dac b_scl
        .long 4             #} dac 4
        .ascii "real"       #} dtc /real/
#
scstr:  .long b_scl         #string} dac b_scl
        .long 6             #} dac 6
        .ascii "string\x00\x00" #} dtc /string/
#
sctab:  .long b_scl         #table} dac b_scl
        .long 5             #} dac 5
        .ascii "table\x00\x00\x00" #} dtc /table/
scfil:  .long b_scl         #file (for extended load arguments)} dac b_scl
        .long 4             #} dac 4
        .ascii "file"       #} dtc /file/
                            #} ejc
        .eject
#
#      string constants (scblk format) for kvrtn (see retrn)
#
scfrt:  .long b_scl         #freturn} dac b_scl
        .long 7             #} dac 7
        .ascii "freturn\x00" #} dtc /freturn/
#
scnrt:  .long b_scl         #nreturn} dac b_scl
        .long 7             #} dac 7
        .ascii "nreturn\x00" #} dtc /nreturn/
#
scrtn:  .long b_scl         #return} dac b_scl
        .long 6             #} dac 6
        .ascii "return\x00\x00" #} dtc /return/
#
#      datatype name table for dtype procedure. the order of
#      these entries is tied to the b$xxx definitions for blocks
#
#      note that slots for buffer and real data types are filled
#      even if these data types are conditionalized out of the
#      implementation.  this is done so that the block numbering
#      at bl$ar etc. remains constant in all versions.
#
scnmt:  .long scarr         #arblk     array} dac scarr
        .long sccod         #cdblk     code} dac sccod
        .long scexp         #exblk     expression} dac scexp
        .long scint         #icblk     integer} dac scint
        .long scnam         #nmblk     name} dac scnam
        .long scpat         #p0blk     pattern} dac scpat
        .long scpat         #p1blk     pattern} dac scpat
        .long scpat         #p2blk     pattern} dac scpat
        .long screa         #rcblk     real} dac screa
        .long scstr         #scblk     string} dac scstr
        .long scexp         #seblk     expression} dac scexp
        .long sctab         #tbblk     table} dac sctab
        .long scarr         #vcblk     array} dac scarr
        .long scext         #xnblk     external} dac scext
        .long scext         #xrblk     external} dac scext
        .long nulls         #bfblk     no buffer in this version} dac nulls
#
#      string constant for real zero
#
scre0:  .long b_scl         #} dac b_scl
        .long 2             #} dac 2
        .ascii "0.\x00\x00" #} dtc /0./
                            #} ejc
        .eject
#
#      used to re-initialise kvstl
#
stlim:  .long +2147483647   #default statement limit} dic +2147483647
#
#      dummy function block used for undefined functions
#
stndf:  .long o_fun         #ptr to undefined function err call} dac o_fun
        .long 0             #dummy fargs count for call circuit} dac 0
#
#      dummy code block used for undefined labels
#
stndl:  .long l_und         #code ptr points to undefined lbl} dac l_und
#
#      dummy operator block used for undefined operators
#
stndo:  .long o_oun         #ptr to undefined operator err call} dac o_oun
        .long 0             #dummy fargs count for call circuit} dac 0
#
#      standard variable block. this block is used to initialize
#      the first seven fields of a newly constructed vrblk.
#      its format is tied to the vrblk definitions (see gtnvr).
#
stnvr:  .long b_vrl         #vrget} dac b_vrl
        .long b_vrs         #vrsto} dac b_vrs
        .long nulls         #vrval} dac nulls
        .long b_vrg         #vrtra} dac b_vrg
        .long stndl         #vrlbl} dac stndl
        .long stndf         #vrfnc} dac stndf
        .long 0             #vrnxt} dac 0
                            #} ejc
        .eject
#
#      messages used in end of run processing (stopr)
#
stpm1:  .long b_scl         #in statement} dac b_scl
        .long 12            #} dac 12
        .ascii "in statement" #} dtc /in statement/
#
stpm2:  .long b_scl         #} dac b_scl
        .long 14            #} dac 14
        .ascii "stmts executed\x00\x00" #} dtc /stmts executed/
#
stpm3:  .long b_scl         #} dac b_scl
        .long 19            #} dac 19
        .ascii "run time (millisec)\x00" #} dtc /run time (millisec)/
#
stpm4:  .long b_scl         #} dac b_scl
        .long 12            #} dac 12
        .ascii "mcsec / stmt" #} dtc _mcsec / stmt_
#
stpm5:  .long b_scl         #} dac b_scl
        .long 13            #} dac 13
        .ascii "regenerations\x00\x00\x00" #} dtc /regenerations/
#
stpm6:  .long b_scl         #in line} dac b_scl
        .long 7             #} dac 7
        .ascii "in line\x00" #} dtc /in line/
#
stpm7:  .long b_scl         #in file} dac b_scl
        .long 7             #} dac 7
        .ascii "in file\x00" #} dtc /in file/
#
#      chars for /tu/ ending code
#
strtu:  .ascii "tu\x00\x00" #} dtc /tu/
#
#      table used by convert function to check datatype name
#      the entries are ordered to correspond to branch table
#      in s$cnv
#
svctb:  .long scstr         #string} dac scstr
        .long scint         #integer} dac scint
        .long scnam         #name} dac scnam
        .long scpat         #pattern} dac scpat
        .long scarr         #array} dac scarr
        .long sctab         #table} dac sctab
        .long scexp         #expression} dac scexp
        .long sccod         #code} dac sccod
        .long scnum         #numeric} dac scnum
        .long screa         #real} dac screa
        .long 0             #zero marks end of list} dac 0
                            #} ejc
        .eject
#
#      messages (scblk format) used by trace procedures
#
#
tmasb:  .long b_scl         #asterisks for trace statement no} dac b_scl
        .long 13            #} dac 13
        .ascii "************ \x00\x00\x00" #} dtc /************ /
#
tmbeb:  .long b_scl         #blank-equal-blank} dac b_scl
        .long 3             #} dac 3
        .ascii " = \x00"    #} dtc / = /
#
#      dummy trblk for expression variable
#
trbev:  .long b_trt         #dummy trblk} dac b_trt
#
#      dummy trblk for keyword variable
#
trbkv:  .long b_trt         #dummy trblk} dac b_trt
#
#      dummy code block to return control to trxeq procedure
#
trxdr:  .long o_txr         #block points to return routine} dac o_txr
trxdc:  .long trxdr         #pointer to block} dac trxdr
                            #} ejc
        .eject
#
#      standard variable blocks
#
#      see svblk format for full details of the format. the
#      vrblks are ordered by length and within each length the
#      order is alphabetical by name of the variable.
#
v_eqf:  .long svfpr         #eq} dbc svfpr
        .long 2             #} dac 2
        .ascii "eq\x00\x00" #} dtc /eq/
        .long s_eqf         #} dac s_eqf
        .long 2             #} dac 2
#
v_gef:  .long svfpr         #ge} dbc svfpr
        .long 2             #} dac 2
        .ascii "ge\x00\x00" #} dtc /ge/
        .long s_gef         #} dac s_gef
        .long 2             #} dac 2
#
v_gtf:  .long svfpr         #gt} dbc svfpr
        .long 2             #} dac 2
        .ascii "gt\x00\x00" #} dtc /gt/
        .long s_gtf         #} dac s_gtf
        .long 2             #} dac 2
#
v_lef:  .long svfpr         #le} dbc svfpr
        .long 2             #} dac 2
        .ascii "le\x00\x00" #} dtc /le/
        .long s_lef         #} dac s_lef
        .long 2             #} dac 2
#
v_lnf:  .long svfnp         #ln} dbc svfnp
        .long 2             #} dac 2
        .ascii "ln\x00\x00" #} dtc /ln/
        .long s_lnf         #} dac s_lnf
        .long 1             #} dac 1
#
v_ltf:  .long svfpr         #lt} dbc svfpr
        .long 2             #} dac 2
        .ascii "lt\x00\x00" #} dtc /lt/
        .long s_ltf         #} dac s_ltf
        .long 2             #} dac 2
#
v_nef:  .long svfpr         #ne} dbc svfpr
        .long 2             #} dac 2
        .ascii "ne\x00\x00" #} dtc /ne/
        .long s_nef         #} dac s_nef
        .long 2             #} dac 2
#
v_any:  .long svfnp         #any} dbc svfnp
        .long 3             #} dac 3
        .ascii "any\x00"    #} dtc /any/
        .long s_any         #} dac s_any
        .long 1             #} dac 1
#
v_arb:  .long svkvc         #arb} dbc svkvc
        .long 3             #} dac 3
        .ascii "arb\x00"    #} dtc /arb/
        .long k_arb         #} dac k_arb
        .long ndarb         #} dac ndarb
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_arg:  .long svfnn         #arg} dbc svfnn
        .long 3             #} dac 3
        .ascii "arg\x00"    #} dtc /arg/
        .long s_arg         #} dac s_arg
        .long 2             #} dac 2
#
v_bal:  .long svkvc         #bal} dbc svkvc
        .long 3             #} dac 3
        .ascii "bal\x00"    #} dtc /bal/
        .long k_bal         #} dac k_bal
        .long ndbal         #} dac ndbal
#
v_cos:  .long svfnp         #cos} dbc svfnp
        .long 3             #} dac 3
        .ascii "cos\x00"    #} dtc /cos/
        .long s_cos         #} dac s_cos
        .long 1             #} dac 1
#
v_end:  .long svlbl         #end} dbc svlbl
        .long 3             #} dac 3
        .ascii "end\x00"    #} dtc /end/
        .long l_end         #} dac l_end
#
v_exp:  .long svfnp         #exp} dbc svfnp
        .long 3             #} dac 3
        .ascii "exp\x00"    #} dtc /exp/
        .long s_exp         #} dac s_exp
        .long 1             #} dac 1
#
v_len:  .long svfnp         #len} dbc svfnp
        .long 3             #} dac 3
        .ascii "len\x00"    #} dtc /len/
        .long s_len         #} dac s_len
        .long 1             #} dac 1
#
v_leq:  .long svfpr         #leq} dbc svfpr
        .long 3             #} dac 3
        .ascii "leq\x00"    #} dtc /leq/
        .long s_leq         #} dac s_leq
        .long 2             #} dac 2
#
v_lge:  .long svfpr         #lge} dbc svfpr
        .long 3             #} dac 3
        .ascii "lge\x00"    #} dtc /lge/
        .long s_lge         #} dac s_lge
        .long 2             #} dac 2
#
v_lgt:  .long svfpr         #lgt} dbc svfpr
        .long 3             #} dac 3
        .ascii "lgt\x00"    #} dtc /lgt/
        .long s_lgt         #} dac s_lgt
        .long 2             #} dac 2
#
v_lle:  .long svfpr         #lle} dbc svfpr
        .long 3             #} dac 3
        .ascii "lle\x00"    #} dtc /lle/
        .long s_lle         #} dac s_lle
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_llt:  .long svfpr         #llt} dbc svfpr
        .long 3             #} dac 3
        .ascii "llt\x00"    #} dtc /llt/
        .long s_llt         #} dac s_llt
        .long 2             #} dac 2
#
v_lne:  .long svfpr         #lne} dbc svfpr
        .long 3             #} dac 3
        .ascii "lne\x00"    #} dtc /lne/
        .long s_lne         #} dac s_lne
        .long 2             #} dac 2
#
v_pos:  .long svfnp         #pos} dbc svfnp
        .long 3             #} dac 3
        .ascii "pos\x00"    #} dtc /pos/
        .long s_pos         #} dac s_pos
        .long 1             #} dac 1
#
v_rem:  .long svkvc         #rem} dbc svkvc
        .long 3             #} dac 3
        .ascii "rem\x00"    #} dtc /rem/
        .long k_rem         #} dac k_rem
        .long ndrem         #} dac ndrem
#
v_set:  .long svfnn         #set} dbc svfnn
        .long 3             #} dac 3
        .ascii "set\x00"    #} dtc /set/
        .long s_set         #} dac s_set
        .long 3             #} dac 3
#
v_sin:  .long svfnp         #sin} dbc svfnp
        .long 3             #} dac 3
        .ascii "sin\x00"    #} dtc /sin/
        .long s_sin         #} dac s_sin
        .long 1             #} dac 1
#
v_tab:  .long svfnp         #tab} dbc svfnp
        .long 3             #} dac 3
        .ascii "tab\x00"    #} dtc /tab/
        .long s_tab         #} dac s_tab
        .long 1             #} dac 1
#
v_tan:  .long svfnp         #tan} dbc svfnp
        .long 3             #} dac 3
        .ascii "tan\x00"    #} dtc /tan/
        .long s_tan         #} dac s_tan
        .long 1             #} dac 1
#
v_atn:  .long svfnp         #atan} dbc svfnp
        .long 4             #} dac 4
        .ascii "atan"       #} dtc /atan/
        .long s_atn         #} dac s_atn
        .long 1             #} dac 1
#
v_cas:  .long svknm         #case} dbc svknm
        .long 4             #} dac 4
        .ascii "case"       #} dtc /case/
        .long k_cas         #} dac k_cas
#
v_chr:  .long svfnp         #char} dbc svfnp
        .long 4             #} dac 4
        .ascii "char"       #} dtc /char/
        .long s_chr         #} dac s_chr
        .long 1             #} dac 1
#
#
v_chp:  .long svfnp         #chop} dbc svfnp
        .long 4             #} dac 4
        .ascii "chop"       #} dtc /chop/
        .long s_chp         #} dac s_chp
        .long 1             #} dac 1
v_cod:  .long svfnk         #code} dbc svfnk
        .long 4             #} dac 4
        .ascii "code"       #} dtc /code/
        .long k_cod         #} dac k_cod
        .long s_cod         #} dac s_cod
        .long 1             #} dac 1
#
v_cop:  .long svfnn         #copy} dbc svfnn
        .long 4             #} dac 4
        .ascii "copy"       #} dtc /copy/
        .long s_cop         #} dac s_cop
        .long 1             #} dac 1
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_dat:  .long svfnn         #data} dbc svfnn
        .long 4             #} dac 4
        .ascii "data"       #} dtc /data/
        .long s_dat         #} dac s_dat
        .long 1             #} dac 1
#
v_dte:  .long svfnn         #date} dbc svfnn
        .long 4             #} dac 4
        .ascii "date"       #} dtc /date/
        .long s_dte         #} dac s_dte
        .long 1             #} dac 1
#
v_dmp:  .long svfnk         #dump} dbc svfnk
        .long 4             #} dac 4
        .ascii "dump"       #} dtc /dump/
        .long k_dmp         #} dac k_dmp
        .long s_dmp         #} dac s_dmp
        .long 1             #} dac 1
#
v_dup:  .long svfnn         #dupl} dbc svfnn
        .long 4             #} dac 4
        .ascii "dupl"       #} dtc /dupl/
        .long s_dup         #} dac s_dup
        .long 2             #} dac 2
#
v_evl:  .long svfnn         #eval} dbc svfnn
        .long 4             #} dac 4
        .ascii "eval"       #} dtc /eval/
        .long s_evl         #} dac s_evl
        .long 1             #} dac 1
#
v_ext:  .long svfnn         #exit} dbc svfnn
        .long 4             #} dac 4
        .ascii "exit"       #} dtc /exit/
        .long s_ext         #} dac s_ext
        .long 2             #} dac 2
#
v_fal:  .long svkvc         #fail} dbc svkvc
        .long 4             #} dac 4
        .ascii "fail"       #} dtc /fail/
        .long k_fal         #} dac k_fal
        .long ndfal         #} dac ndfal
#
v_fil:  .long svknm         #file} dbc svknm
        .long 4             #} dac 4
        .ascii "file"       #} dtc /file/
        .long k_fil         #} dac k_fil
#
v_hst:  .long svfnn         #host} dbc svfnn
        .long 4             #} dac 4
        .ascii "host"       #} dtc /host/
        .long s_hst         #} dac s_hst
        .long 5             #} dac 5
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_itm:  .long svfnf         #item} dbc svfnf
        .long 4             #} dac 4
        .ascii "item"       #} dtc /item/
        .long s_itm         #} dac s_itm
        .long 999           #} dac 999
#
v_lin:  .long svknm         #line} dbc svknm
        .long 4             #} dac 4
        .ascii "line"       #} dtc /line/
        .long k_lin         #} dac k_lin
#
v_lod:  .long svfnn         #load} dbc svfnn
        .long 4             #} dac 4
        .ascii "load"       #} dtc /load/
        .long s_lod         #} dac s_lod
        .long 2             #} dac 2
#
v_lpd:  .long svfnp         #lpad} dbc svfnp
        .long 4             #} dac 4
        .ascii "lpad"       #} dtc /lpad/
        .long s_lpd         #} dac s_lpd
        .long 3             #} dac 3
#
v_rpd:  .long svfnp         #rpad} dbc svfnp
        .long 4             #} dac 4
        .ascii "rpad"       #} dtc /rpad/
        .long s_rpd         #} dac s_rpd
        .long 3             #} dac 3
#
v_rps:  .long svfnp         #rpos} dbc svfnp
        .long 4             #} dac 4
        .ascii "rpos"       #} dtc /rpos/
        .long s_rps         #} dac s_rps
        .long 1             #} dac 1
#
v_rtb:  .long svfnp         #rtab} dbc svfnp
        .long 4             #} dac 4
        .ascii "rtab"       #} dtc /rtab/
        .long s_rtb         #} dac s_rtb
        .long 1             #} dac 1
#
v_si_:  .long svfnp         #size} dbc svfnp
        .long 4             #} dac 4
        .ascii "size"       #} dtc /size/
        .long s_si_         #} dac s_si_
        .long 1             #} dac 1
#
#
v_srt:  .long svfnn         #sort} dbc svfnn
        .long 4             #} dac 4
        .ascii "sort"       #} dtc /sort/
        .long s_srt         #} dac s_srt
        .long 2             #} dac 2
v_spn:  .long svfnp         #span} dbc svfnp
        .long 4             #} dac 4
        .ascii "span"       #} dtc /span/
        .long s_spn         #} dac s_spn
        .long 1             #} dac 1
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
#
v_sqr:  .long svfnp         #sqrt} dbc svfnp
        .long 4             #} dac 4
        .ascii "sqrt"       #} dtc /sqrt/
        .long s_sqr         #} dac s_sqr
        .long 1             #} dac 1
v_stn:  .long svknm         #stno} dbc svknm
        .long 4             #} dac 4
        .ascii "stno"       #} dtc /stno/
        .long k_stn         #} dac k_stn
#
v_tim:  .long svfnn         #time} dbc svfnn
        .long 4             #} dac 4
        .ascii "time"       #} dtc /time/
        .long s_tim         #} dac s_tim
        .long 0             #} dac 0
#
v_trm:  .long svfnk         #trim} dbc svfnk
        .long 4             #} dac 4
        .ascii "trim"       #} dtc /trim/
        .long k_trm         #} dac k_trm
        .long s_trm         #} dac s_trm
        .long 1             #} dac 1
#
v_abe:  .long svknm         #abend} dbc svknm
        .long 5             #} dac 5
        .ascii "abend\x00\x00\x00" #} dtc /abend/
        .long k_abe         #} dac k_abe
#
v_abo:  .long svkvl         #abort} dbc svkvl
        .long 5             #} dac 5
        .ascii "abort\x00\x00\x00" #} dtc /abort/
        .long k_abo         #} dac k_abo
        .long l_abo         #} dac l_abo
        .long ndabo         #} dac ndabo
#
v_app:  .long svfnf         #apply} dbc svfnf
        .long 5             #} dac 5
        .ascii "apply\x00\x00\x00" #} dtc /apply/
        .long s_app         #} dac s_app
        .long 999           #} dac 999
#
v_abn:  .long svfnp         #arbno} dbc svfnp
        .long 5             #} dac 5
        .ascii "arbno\x00\x00\x00" #} dtc /arbno/
        .long s_abn         #} dac s_abn
        .long 1             #} dac 1
#
v_arr:  .long svfnn         #array} dbc svfnn
        .long 5             #} dac 5
        .ascii "array\x00\x00\x00" #} dtc /array/
        .long s_arr         #} dac s_arr
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_brk:  .long svfnp         #break} dbc svfnp
        .long 5             #} dac 5
        .ascii "break\x00\x00\x00" #} dtc /break/
        .long s_brk         #} dac s_brk
        .long 1             #} dac 1
#
v_clr:  .long svfnn         #clear} dbc svfnn
        .long 5             #} dac 5
        .ascii "clear\x00\x00\x00" #} dtc /clear/
        .long s_clr         #} dac s_clr
        .long 1             #} dac 1
#
v_ejc:  .long svfnn         #eject} dbc svfnn
        .long 5             #} dac 5
        .ascii "eject\x00\x00\x00" #} dtc /eject/
        .long s_ejc         #} dac s_ejc
        .long 1             #} dac 1
#
v_fen:  .long svfpk         #fence} dbc svfpk
        .long 5             #} dac 5
        .ascii "fence\x00\x00\x00" #} dtc /fence/
        .long k_fen         #} dac k_fen
        .long s_fnc         #} dac s_fnc
        .long 1             #} dac 1
        .long ndfen         #} dac ndfen
#
v_fld:  .long svfnn         #field} dbc svfnn
        .long 5             #} dac 5
        .ascii "field\x00\x00\x00" #} dtc /field/
        .long s_fld         #} dac s_fld
        .long 2             #} dac 2
#
v_idn:  .long svfpr         #ident} dbc svfpr
        .long 5             #} dac 5
        .ascii "ident\x00\x00\x00" #} dtc /ident/
        .long s_idn         #} dac s_idn
        .long 2             #} dac 2
#
v_inp:  .long svfnk         #input} dbc svfnk
        .long 5             #} dac 5
        .ascii "input\x00\x00\x00" #} dtc /input/
        .long k_inp         #} dac k_inp
        .long s_inp         #} dac s_inp
        .long 3             #} dac 3
#
v_lcs:  .long svkwc         #lcase} dbc svkwc
        .long 5             #} dac 5
        .ascii "lcase\x00\x00\x00" #} dtc /lcase/
        .long k_lcs         #} dac k_lcs
#
v_loc:  .long svfnn         #local} dbc svfnn
        .long 5             #} dac 5
        .ascii "local\x00\x00\x00" #} dtc /local/
        .long s_loc         #} dac s_loc
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_ops:  .long svfnn         #opsyn} dbc svfnn
        .long 5             #} dac 5
        .ascii "opsyn\x00\x00\x00" #} dtc /opsyn/
        .long s_ops         #} dac s_ops
        .long 3             #} dac 3
#
v_rmd:  .long svfnp         #remdr} dbc svfnp
        .long 5             #} dac 5
        .ascii "remdr\x00\x00\x00" #} dtc /remdr/
        .long s_rmd         #} dac s_rmd
        .long 2             #} dac 2
#
v_rsr:  .long svfnn         #rsort} dbc svfnn
        .long 5             #} dac 5
        .ascii "rsort\x00\x00\x00" #} dtc /rsort/
        .long s_rsr         #} dac s_rsr
        .long 2             #} dac 2
#
v_tbl:  .long svfnn         #table} dbc svfnn
        .long 5             #} dac 5
        .ascii "table\x00\x00\x00" #} dtc /table/
        .long s_tbl         #} dac s_tbl
        .long 3             #} dac 3
#
v_tra:  .long svfnk         #trace} dbc svfnk
        .long 5             #} dac 5
        .ascii "trace\x00\x00\x00" #} dtc /trace/
        .long k_tra         #} dac k_tra
        .long s_tra         #} dac s_tra
        .long 4             #} dac 4
#
v_ucs:  .long svkwc         #ucase} dbc svkwc
        .long 5             #} dac 5
        .ascii "ucase\x00\x00\x00" #} dtc /ucase/
        .long k_ucs         #} dac k_ucs
#
v_anc:  .long svknm         #anchor} dbc svknm
        .long 6             #} dac 6
        .ascii "anchor\x00\x00" #} dtc /anchor/
        .long k_anc         #} dac k_anc
#
v_bkx:  .long svfnp         #breakx} dbc svfnp
        .long 6             #} dac 6
        .ascii "breakx\x00\x00" #} dtc /breakx/
        .long s_bkx         #} dac s_bkx
        .long 1             #} dac 1
#
#
v_def:  .long svfnn         #define} dbc svfnn
        .long 6             #} dac 6
        .ascii "define\x00\x00" #} dtc /define/
        .long s_def         #} dac s_def
        .long 2             #} dac 2
#
v_det:  .long svfnn         #detach} dbc svfnn
        .long 6             #} dac 6
        .ascii "detach\x00\x00" #} dtc /detach/
        .long s_det         #} dac s_det
        .long 1             #} dac 1
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_dif:  .long svfpr         #differ} dbc svfpr
        .long 6             #} dac 6
        .ascii "differ\x00\x00" #} dtc /differ/
        .long s_dif         #} dac s_dif
        .long 2             #} dac 2
#
v_ftr:  .long svknm         #ftrace} dbc svknm
        .long 6             #} dac 6
        .ascii "ftrace\x00\x00" #} dtc /ftrace/
        .long k_ftr         #} dac k_ftr
#
v_lst:  .long svknm         #lastno} dbc svknm
        .long 6             #} dac 6
        .ascii "lastno\x00\x00" #} dtc /lastno/
        .long k_lst         #} dac k_lst
#
v_nay:  .long svfnp         #notany} dbc svfnp
        .long 6             #} dac 6
        .ascii "notany\x00\x00" #} dtc /notany/
        .long s_nay         #} dac s_nay
        .long 1             #} dac 1
#
v_oup:  .long svfnk         #output} dbc svfnk
        .long 6             #} dac 6
        .ascii "output\x00\x00" #} dtc /output/
        .long k_oup         #} dac k_oup
        .long s_oup         #} dac s_oup
        .long 3             #} dac 3
#
v_ret:  .long svlbl         #return} dbc svlbl
        .long 6             #} dac 6
        .ascii "return\x00\x00" #} dtc /return/
        .long l_rtn         #} dac l_rtn
#
v_rew:  .long svfnn         #rewind} dbc svfnn
        .long 6             #} dac 6
        .ascii "rewind\x00\x00" #} dtc /rewind/
        .long s_rew         #} dac s_rew
        .long 1             #} dac 1
#
v_stt:  .long svfnn         #stoptr} dbc svfnn
        .long 6             #} dac 6
        .ascii "stoptr\x00\x00" #} dtc /stoptr/
        .long s_stt         #} dac s_stt
        .long 2             #} dac 2
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_sub:  .long svfnn         #substr} dbc svfnn
        .long 6             #} dac 6
        .ascii "substr\x00\x00" #} dtc /substr/
        .long s_sub         #} dac s_sub
        .long 3             #} dac 3
#
v_unl:  .long svfnn         #unload} dbc svfnn
        .long 6             #} dac 6
        .ascii "unload\x00\x00" #} dtc /unload/
        .long s_unl         #} dac s_unl
        .long 1             #} dac 1
#
v_col:  .long svfnn         #collect} dbc svfnn
        .long 7             #} dac 7
        .ascii "collect\x00" #} dtc /collect/
        .long s_col         #} dac s_col
        .long 1             #} dac 1
#
v_com:  .long svknm         #compare} dbc svknm
        .long 7             #} dac 7
        .ascii "compare\x00" #} dtc /compare/
        .long k_com         #} dac k_com
#
v_cnv:  .long svfnn         #convert} dbc svfnn
        .long 7             #} dac 7
        .ascii "convert\x00" #} dtc /convert/
        .long s_cnv         #} dac s_cnv
        .long 2             #} dac 2
#
v_enf:  .long svfnn         #endfile} dbc svfnn
        .long 7             #} dac 7
        .ascii "endfile\x00" #} dtc /endfile/
        .long s_enf         #} dac s_enf
        .long 1             #} dac 1
#
v_etx:  .long svknm         #errtext} dbc svknm
        .long 7             #} dac 7
        .ascii "errtext\x00" #} dtc /errtext/
        .long k_etx         #} dac k_etx
#
v_ert:  .long svknm         #errtype} dbc svknm
        .long 7             #} dac 7
        .ascii "errtype\x00" #} dtc /errtype/
        .long k_ert         #} dac k_ert
#
v_frt:  .long svlbl         #freturn} dbc svlbl
        .long 7             #} dac 7
        .ascii "freturn\x00" #} dtc /freturn/
        .long l_frt         #} dac l_frt
#
v_int:  .long svfpr         #integer} dbc svfpr
        .long 7             #} dac 7
        .ascii "integer\x00" #} dtc /integer/
        .long s_int         #} dac s_int
        .long 1             #} dac 1
#
v_nrt:  .long svlbl         #nreturn} dbc svlbl
        .long 7             #} dac 7
        .ascii "nreturn\x00" #} dtc /nreturn/
        .long l_nrt         #} dac l_nrt
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
#
v_pfl:  .long svknm         #profile} dbc svknm
        .long 7             #} dac 7
        .ascii "profile\x00" #} dtc /profile/
        .long k_pfl         #} dac k_pfl
#
v_rpl:  .long svfnp         #replace} dbc svfnp
        .long 7             #} dac 7
        .ascii "replace\x00" #} dtc /replace/
        .long s_rpl         #} dac s_rpl
        .long 3             #} dac 3
#
v_rvs:  .long svfnp         #reverse} dbc svfnp
        .long 7             #} dac 7
        .ascii "reverse\x00" #} dtc /reverse/
        .long s_rvs         #} dac s_rvs
        .long 1             #} dac 1
#
v_rtn:  .long svknm         #rtntype} dbc svknm
        .long 7             #} dac 7
        .ascii "rtntype\x00" #} dtc /rtntype/
        .long k_rtn         #} dac k_rtn
#
v_stx:  .long svfnn         #setexit} dbc svfnn
        .long 7             #} dac 7
        .ascii "setexit\x00" #} dtc /setexit/
        .long s_stx         #} dac s_stx
        .long 1             #} dac 1
#
v_stc:  .long svknm         #stcount} dbc svknm
        .long 7             #} dac 7
        .ascii "stcount\x00" #} dtc /stcount/
        .long k_stc         #} dac k_stc
#
v_stl:  .long svknm         #stlimit} dbc svknm
        .long 7             #} dac 7
        .ascii "stlimit\x00" #} dtc /stlimit/
        .long k_stl         #} dac k_stl
#
v_suc:  .long svkvc         #succeed} dbc svkvc
        .long 7             #} dac 7
        .ascii "succeed\x00" #} dtc /succeed/
        .long k_suc         #} dac k_suc
        .long ndsuc         #} dac ndsuc
#
v_alp:  .long svkwc         #alphabet} dbc svkwc
        .long 8             #} dac 8
        .ascii "alphabet"   #} dtc /alphabet/
        .long k_alp         #} dac k_alp
#
v_cnt:  .long svlbl         #continue} dbc svlbl
        .long 8             #} dac 8
        .ascii "continue"   #} dtc /continue/
        .long l_cnt         #} dac l_cnt
                            #} ejc
        .eject
#
#      standard variable blocks (continued)
#
v_dtp:  .long svfnp         #datatype} dbc svfnp
        .long 8             #} dac 8
        .ascii "datatype"   #} dtc /datatype/
        .long s_dtp         #} dac s_dtp
        .long 1             #} dac 1
#
v_erl:  .long svknm         #errlimit} dbc svknm
        .long 8             #} dac 8
        .ascii "errlimit"   #} dtc /errlimit/
        .long k_erl         #} dac k_erl
#
v_fnc:  .long svknm         #fnclevel} dbc svknm
        .long 8             #} dac 8
        .ascii "fnclevel"   #} dtc /fnclevel/
        .long k_fnc         #} dac k_fnc
#
v_fls:  .long svknm         #fullscan} dbc svknm
        .long 8             #} dac 8
        .ascii "fullscan"   #} dtc /fullscan/
        .long k_fls         #} dac k_fls
#
v_lfl:  .long svknm         #lastfile} dbc svknm
        .long 8             #} dac 8
        .ascii "lastfile"   #} dtc /lastfile/
        .long k_lfl         #} dac k_lfl
#
v_lln:  .long svknm         #lastline} dbc svknm
        .long 8             #} dac 8
        .ascii "lastline"   #} dtc /lastline/
        .long k_lln         #} dac k_lln
#
v_mxl:  .long svknm         #maxlngth} dbc svknm
        .long 8             #} dac 8
        .ascii "maxlngth"   #} dtc /maxlngth/
        .long k_mxl         #} dac k_mxl
#
v_ter:  .long 0             #terminal} dbc 0
        .long 8             #} dac 8
        .ascii "terminal"   #} dtc /terminal/
        .long 0             #} dac 0
#
v_bsp:  .long svfnn         #backspace} dbc svfnn
        .long 9             #} dac 9
        .ascii "backspace\x00\x00\x00" #} dtc /backspace/
        .long s_bsp         #} dac s_bsp
        .long 1             #} dac 1
#
v_pro:  .long svfnn         #prototype} dbc svfnn
        .long 9             #} dac 9
        .ascii "prototype\x00\x00\x00" #} dtc /prototype/
        .long s_pro         #} dac s_pro
        .long 1             #} dac 1
#
v_scn:  .long svlbl         #scontinue} dbc svlbl
        .long 9             #} dac 9
        .ascii "scontinue\x00\x00\x00" #} dtc /scontinue/
        .long l_scn         #} dac l_scn
#
        .long 0             #dummy entry to end list} dbc 0
        .long 10            #length gt 9 (scontinue)} dac 10
                            #} ejc
        .eject
#
#      list of svblk pointers for keywords to be dumped. the
#      list is in the order which appears on the dump output.
#
vdmkw:  .long v_anc         #anchor} dac v_anc
        .long v_cas         #ccase} dac v_cas
        .long v_cod         #code} dac v_cod
        .long 1             #compare not printed} dac 1
        .long v_dmp         #dump} dac v_dmp
        .long v_erl         #errlimit} dac v_erl
        .long v_etx         #errtext} dac v_etx
        .long v_ert         #errtype} dac v_ert
        .long v_fil         #file} dac v_fil
        .long v_fnc         #fnclevel} dac v_fnc
        .long v_ftr         #ftrace} dac v_ftr
        .long v_fls         #fullscan} dac v_fls
        .long v_inp         #input} dac v_inp
        .long v_lfl         #lastfile} dac v_lfl
        .long v_lln         #lastline} dac v_lln
        .long v_lst         #lastno} dac v_lst
        .long v_lin         #line} dac v_lin
        .long v_mxl         #maxlength} dac v_mxl
        .long v_oup         #output} dac v_oup
        .long v_pfl         #profile} dac v_pfl
        .long v_rtn         #rtntype} dac v_rtn
        .long v_stc         #stcount} dac v_stc
        .long v_stl         #stlimit} dac v_stl
        .long v_stn         #stno} dac v_stn
        .long v_tra         #trace} dac v_tra
        .long v_trm         #trim} dac v_trm
        .long 0             #end of list} dac 0
#
#      table used by gtnvr to search svblk lists
#
vsrch:  .long 0             #dummy entry to get proper indexing} dac 0
        .long v_eqf         #start of 1 char variables (none)} dac v_eqf
        .long v_eqf         #start of 2 char variables} dac v_eqf
        .long v_any         #start of 3 char variables} dac v_any
        .long v_atn         #start of 4 char variables} dac v_atn
        .long v_abe         #start of 5 char variables} dac v_abe
        .long v_anc         #start of 6 char variables} dac v_anc
        .long v_col         #start of 7 char variables} dac v_col
        .long v_alp         #start of 8 char variables} dac v_alp
        .long v_bsp         #start of 9 char variables} dac v_bsp
#
#      last location in constant section
#
c_yyy:  .long 0             #last location in constant section} dac 0
                            #} ttl s p i t b o l -- working storage section
        .sbttl "s p i t b o l -- working storage section"
#
#      the working storage section contains areas which are
#      changed during execution of the program. the value
#      assembled is the initial value before execution starts.
#
#      all these areas are fixed length areas. variable length
#      data is stored in the static or dynamic regions of the
#      allocated data areas.
#
#      the values in this area are described either as work
#      areas or as global values. a work area is used in an
#      ephemeral manner and the value is not saved from one
#      entry into a routine to another. a global value is a
#      less temporary location whose value is saved from one
#      call to another.
#
#      w$aaa marks the start of the working section whilst
#      w$yyy marks its end.  g$aaa marks the division between
#      temporary and global values.
#
#      global values are further subdivided to facilitate
#      processing by the garbage collector. r$aaa through
#      r$yyy are global values that may point into dynamic
#      storage and hence must be relocated after each garbage
#      collection.  they also serve as root pointers to all
#      allocated data that must be preserved.  pointers between
#      a$aaa and r$aaa may point into code, static storage,
#      or mark the limits of dynamic memory.  these pointers
#      must be adjusted when the working section is saved to a
#      file and subsequently reloaded at a different address.
#
#      a general part of the approach in this program is not
#      to overlap work areas between procedures even though a
#      small amount of space could be saved. such overlap is
#      considered a source of program errors and decreases the
#      information left behind after a system crash of any kind.
#
#      the names of these locations are labels with five letter
#      (a-y,$) names. as far as possible the order is kept
#      alphabetical by these names but in some cases there
#      are slight departures caused by other order requirements.
#
#      unless otherwise documented, the order of work areas
#      does not affect the execution of the spitbol program.
#
                            #start of working storage section} sec
        .global ESEC03
ESEC03:
        DSegEnd_
        DSeg_
        .global SEC04
SEC04:
                            #} ejc
        .eject
#
#      this area is not cleared by initial code
#
cmlab:  .long b_scl         #string used to check label legality} dac b_scl
        .long 2             #} dac 2
        .ascii "  \x00\x00" #} dtc /  /
#
#      label to mark start of work area
#
w_aaa:  .long 0             #} dac 0
#
#      work areas for acess procedure
#
actrm:  .long 0             #trim indicator} dac 0
#
#      work areas for alloc procedure
#
aldyn:  .long 0             #amount of dynamic store} dac 0
allia:  .long +0            #dump ia} dic +0
allsv:  .long 0             #save wb in alloc} dac 0
#
#      work areas for alost procedure
#
alsta:  .long 0             #save wa in alost} dac 0
#
#      work areas for array function (s$arr)
#
arcdm:  .long 0             #count dimensions} dac 0
arnel:  .long +0            #count elements} dic +0
arptr:  .long 0             #offset ptr into arblk} dac 0
arsvl:  .long +0            #save integer low bound} dic +0
                            #} ejc
        .eject
#
#      work areas for arref routine
#
arfsi:  .long +0            #save current evolving subscript} dic +0
arfxs:  .long 0             #save base stack pointer} dac 0
#
#      work areas for b$efc block routine
#
befof:  .long 0             #save offset ptr into efblk} dac 0
#
#      work areas for b$pfc block routine
#
bpfpf:  .long 0             #save pfblk pointer} dac 0
bpfsv:  .long 0             #save old function value} dac 0
bpfxt:  .long 0             #pointer to stacked arguments} dac 0
#
#      work area for collect function (s$col)
#
clsvi:  .long +0            #save integer argument} dic +0
#
#      work areas value for cncrd
#
cnscc:  .long 0             #pointer to control card string} dac 0
cnswc:  .long 0             #word count} dac 0
cnr_t:  .long 0             #pointer to r_ttl or r_stl} dac 0
#
#      work areas for convert function (s$cnv)
#
cnvtp:  .long 0             #save ptr into scvtb} dac 0
#
#      work areas for data function (s$dat)
#
datdv:  .long 0             #save vrblk ptr for datatype name} dac 0
datxs:  .long 0             #save initial stack pointer} dac 0
#
#      work areas for define function (s$def)
#
deflb:  .long 0             #save vrblk ptr for label} dac 0
defna:  .long 0             #count function arguments} dac 0
defvr:  .long 0             #save vrblk ptr for function name} dac 0
defxs:  .long 0             #save initial stack pointer} dac 0
#
#      work areas for dumpr procedure
#
dmarg:  .long 0             #dump argument} dac 0
dmpsa:  .long 0             #preserve wa over prtvl call} dac 0
dmpsb:  .long 0             #preserve wb over syscm call} dac 0
dmpsv:  .long 0             #general scratch save} dac 0
dmvch:  .long 0             #chain pointer for variable blocks} dac 0
dmpch:  .long 0             #save sorted vrblk chain pointer} dac 0
dmpkb:  .long 0             #dummy kvblk for use in dumpr} dac 0
dmpkt:  .long 0             #kvvar trblk ptr (must follow dmpkb)} dac 0
dmpkn:  .long 0             #keyword number (must follow dmpkt)} dac 0
#
#      work area for dtach
#
dtcnb:  .long 0             #name base} dac 0
dtcnm:  .long 0             #name ptr} dac 0
#
#      work areas for dupl function (s$dup)
#
dupsi:  .long +0            #store integer string length} dic +0
#
#      work area for endfile (s$enf)
#
enfch:  .long 0             #for iochn chain head} dac 0
                            #} ejc
        .eject
#
#      work areas for ertex
#
ertwa:  .long 0             #save wa} dac 0
ertwb:  .long 0             #save wb} dac 0
#
#      work areas for evali
#
evlin:  .long 0             #dummy pattern block pcode} dac 0
evlis:  .long 0             #then node (must follow evlin)} dac 0
evliv:  .long 0             #value of parm1 (must follow evlis)} dac 0
evlio:  .long 0             #ptr to original node} dac 0
evlif:  .long 0             #flag for simple/complex argument} dac 0
#
#      work area for expan
#
expsv:  .long 0             #save op dope vector pointer} dac 0
#
#      work areas for gbcol procedure
#
gbcfl:  .long 0             #garbage collector active flag} dac 0
gbclm:  .long 0             #pointer to last move block (pass 3)} dac 0
gbcnm:  .long 0             #dummy first move block} dac 0
gbcns:  .long 0             #rest of dummy block (follows gbcnm)} dac 0
gbcia:  .long +0            #dump ia} dic +0
gbcsd:  .long 0             #first address beyond sediment} dac 0
gbcsf:  .long 0             #free space within sediment} dac 0
gbsva:  .long 0             #save wa} dac 0
gbsvb:  .long 0             #save wb} dac 0
gbsvc:  .long 0             #save wc} dac 0
#
#      work areas for gtnvr procedure
#
gnvhe:  .long 0             #ptr to end of hash chain} dac 0
gnvnw:  .long 0             #number of words in string name} dac 0
gnvsa:  .long 0             #save wa} dac 0
gnvsb:  .long 0             #save wb} dac 0
gnvsp:  .long 0             #pointer into vsrch table} dac 0
gnvst:  .long 0             #pointer to chars of string} dac 0
#
#      work areas for gtarr
#
gtawa:  .long 0             #save wa} dac 0
#
#      work areas for gtint
#
gtina:  .long 0             #save wa} dac 0
gtinb:  .long 0             #save wb} dac 0
                            #} ejc
        .eject
#
#      work areas for gtnum procedure
#
gtnnf:  .long 0             #zero/nonzero for result +/-} dac 0
gtnsi:  .long +0            #general integer save} dic +0
gtndf:  .long 0             #0/1 for dec point so far no/yes} dac 0
gtnes:  .long 0             #zero/nonzero exponent +/-} dac 0
gtnex:  .long +0            #real exponent} dic +0
gtnsc:  .long 0             #scale (places after point)} dac 0
        .balign 4           #general real save} drc +0.0
gtnsr:  .double 0e0.0
gtnrd:  .long 0             #flag for ok real number} dac 0
#
#      work areas for gtpat procedure
#
gtpsb:  .long 0             #save wb} dac 0
#
#      work areas for gtstg procedure
#
gtssf:  .long 0             #0/1 for result +/-} dac 0
gtsvc:  .long 0             #save wc} dac 0
gtsvb:  .long 0             #save wb} dac 0
gtses:  .long 0             #char + or - for exponent +/-} dac 0
        .balign 4           #general real save} drc +0.0
gtsrs:  .double 0e0.0
#
#      work areas for gtvar procedure
#
gtvrc:  .long 0             #save wc} dac 0
#
#      work areas for ioput
#
ioptt:  .long 0             #type of association} dac 0
#
#      work areas for load function
#
lodfn:  .long 0             #pointer to vrblk for func name} dac 0
lodna:  .long 0             #count number of arguments} dac 0
#
#      work area for profiler
#
pfsvw:  .long 0             #to save a w-reg} dac 0
#
#      work areas for prtnm procedure
#
prnsi:  .long +0            #scratch integer loc} dic +0
#
#      work areas for prtsn procedure
#
prsna:  .long 0             #save wa} dac 0
#
#      work areas for prtst procedure
#
prsva:  .long 0             #save wa} dac 0
prsvb:  .long 0             #save wb} dac 0
prsvc:  .long 0             #save char counter} dac 0
#
#      work area for prtnl
#
prtsa:  .long 0             #save wa} dac 0
prtsb:  .long 0             #save wb} dac 0
#
#      work area for prtvl
#
prvsi:  .long 0             #save idval} dac 0
#
#      work areas for pattern match routines
#
psave:  .long 0             #temporary save for current node ptr} dac 0
psavc:  .long 0             #save cursor in p_spn, p_str} dac 0
#
#      work area for relaj routine
#
rlals:  .long 0             #ptr to list of bounds and adjusts} dac 0
#
#      work area for reldn routine
#
rldcd:  .long 0             #save code adjustment} dac 0
rldst:  .long 0             #save static adjustment} dac 0
rldls:  .long 0             #save list pointer} dac 0
#
#      work areas for retrn routine
#
rtnbp:  .long 0             #to save a block pointer} dac 0
rtnfv:  .long 0             #new function value (result)} dac 0
rtnsv:  .long 0             #old function value (saved value)} dac 0
#
#      work areas for substr function (s$sub)
#
sbssv:  .long 0             #save third argument} dac 0
#
#      work areas for scan procedure
#
scnsa:  .long 0             #save wa} dac 0
scnsb:  .long 0             #save wb} dac 0
scnsc:  .long 0             #save wc} dac 0
scnof:  .long 0             #save offset} dac 0
                            #} ejc
        .eject
#
#      work area used by sorta, sortc, sortf, sorth
#
srtdf:  .long 0             #datatype field name} dac 0
srtfd:  .long 0             #found dfblk address} dac 0
srtff:  .long 0             #found field name} dac 0
srtfo:  .long 0             #offset to field name} dac 0
srtnr:  .long 0             #number of rows} dac 0
srtof:  .long 0             #offset within row to sort key} dac 0
srtrt:  .long 0             #root offset} dac 0
srts1:  .long 0             #save offset 1} dac 0
srts2:  .long 0             #save offset 2} dac 0
srtsc:  .long 0             #save wc} dac 0
srtsf:  .long 0             #sort array first row offset} dac 0
srtsn:  .long 0             #save n} dac 0
srtso:  .long 0             #offset to a(0)} dac 0
srtsr:  .long 0             #0, non-zero for sort, rsort} dac 0
srtst:  .long 0             #stride from one row to next} dac 0
srtwc:  .long 0             #dump wc} dac 0
#
#      work areas for stopr routine
#
stpsi:  .long +0            #save value of stcount} dic +0
stpti:  .long +0            #save time elapsed} dic +0
#
#      work areas for tfind procedure
#
tfnsi:  .long +0            #number of headers} dic +0
#
#      work areas for xscan procedure
#
xscrt:  .long 0             #save return code} dac 0
xscwb:  .long 0             #save register wb} dac 0
#
#      start of global values in working section
#
g_aaa:  .long 0             #} dac 0
#
#      global value for alloc procedure
#
alfsf:  .long +0            #factor in free store pcntage check} dic +0
#
#      global values for cmpil procedure
#
cmerc:  .long 0             #count of initial compile errors} dac 0
cmpln:  .long 0             #line number of first line of stmt} dac 0
cmpxs:  .long 0             #save stack ptr in case of errors} dac 0
cmpsn:  .long 1             #number of next statement to compile} dac 1
#
#      global values for cncrd
#
cnsil:  .long 0             #save scnil during include process.} dac 0
cnind:  .long 0             #current include file nest level} dac 0
cnspt:  .long 0             #save scnpt during include process.} dac 0
cnttl:  .long 0             #flag for -title, -stitl} dac 0
#
#      global flag for suppression of compilation statistics.
#
cpsts:  .long 0             #suppress comp. stats if non zero} dac 0
#
#      global values for control card switches
#
cswdb:  .long 0             #0/1 for -single/-double} dac 0
cswer:  .long 0             #0/1 for -errors/-noerrors} dac 0
cswex:  .long 0             #0/1 for -execute/-noexecute} dac 0
cswfl:  .long 1             #0/1 for -nofail/-fail} dac 1
cswin:  .long iniln         #xxx for -inxxx} dac iniln
cswls:  .long 1             #0/1 for -nolist/-list} dac 1
cswno:  .long 0             #0/1 for -optimise/-noopt} dac 0
cswpr:  .long 0             #0/1 for -noprint/-print} dac 0
#
#      global location used by patst procedure
#
ctmsk:  .long 0             #last bit position used in r_ctp} dbc 0
curid:  .long 0             #current id value} dac 0
                            #} ejc
        .eject
#
#      global value for cdwrd procedure
#
cwcof:  .long 0             #next word offset in current ccblk} dac 0
#
#      global locations for dynamic storage pointers
#
dnams:  .long 0             #size of sediment in baus} dac 0
#
#      global area for error processing.
#
erich:  .long 0             #copy error reports to int.chan if 1} dac 0
erlst:  .long 0             #for listr when errors go to int.ch.} dac 0
errft:  .long 0             #fatal error flag} dac 0
errsp:  .long 0             #error suppression flag} dac 0
#
#      global flag for suppression of execution stats
#
exsts:  .long 0             #suppress exec stats if set} dac 0
#
#      global values for exfal and return
#
flprt:  .long 0             #location of fail offset for return} dac 0
flptr:  .long 0             #location of failure offset on stack} dac 0
#
#      global location to count garbage collections (gbcol)
#
gbsed:  .long +0            #factor in sediment pcntage check} dic +0
gbcnt:  .long 0             #count of garbage collections} dac 0
#
#      global value for gtcod and gtexp
#
gtcef:  .long 0             #save fail ptr in case of error} dac 0
#
#      global locations for gtstg procedure
#
        .balign 4           #rounding factor 0.5*10**-cfp_s} drc +0.0
gtsrn:  .double 0e0.0
        .balign 4           #scaling value 10**cfp_s} drc +0.0
gtssc:  .double 0e0.0
gtswk:  .long 0             #ptr to work area for gtstg} dac 0
#
#      global flag for header printing
#
headp:  .long 0             #header printed flag} dac 0
#
#      global values for variable hash table
#
hshnb:  .long +0            #number of hash buckets} dic +0
#
#      global areas for init
#
initr:  .long 0             #save terminal flag} dac 0
                            #} ejc
        .eject
#
#      global values for keyword values which are stored as one
#      word integers. these values must be assembled in the
#      following order (as dictated by k$xxx definition values).
#
kvabe:  .long 0             #abend} dac 0
kvanc:  .long 0             #anchor} dac 0
kvcas:  .long 0             #case} dac 0
kvcod:  .long 0             #code} dac 0
kvcom:  .long 0             #compare} dac 0
kvdmp:  .long 0             #dump} dac 0
kverl:  .long 0             #errlimit} dac 0
kvert:  .long 0             #errtype} dac 0
kvftr:  .long 0             #ftrace} dac 0
kvfls:  .long 1             #fullscan} dac 1
kvinp:  .long 1             #input} dac 1
kvmxl:  .long 5000          #maxlength} dac 5000
kvoup:  .long 1             #output} dac 1
kvpfl:  .long 0             #profile} dac 0
kvtra:  .long 0             #trace} dac 0
kvtrm:  .long 0             #trim} dac 0
kvfnc:  .long 0             #fnclevel} dac 0
kvlst:  .long 0             #lastno} dac 0
kvlln:  .long 0             #lastline} dac 0
kvlin:  .long 0             #line} dac 0
kvstn:  .long 0             #stno} dac 0
#
#      global values for other keywords
#
kvalp:  .long 0             #alphabet} dac 0
kvrtn:  .long nulls         #rtntype (scblk pointer)} dac nulls
kvstl:  .long +2147483647   #stlimit} dic +2147483647
kvstc:  .long +2147483647   #stcount (counts down from stlimit)} dic +2147483647
#
#      global values for listr procedure
#
lstid:  .long 0             #include depth of current image} dac 0
lstlc:  .long 0             #count lines on source list page} dac 0
lstnp:  .long 0             #max number of lines on page} dac 0
lstpf:  .long 1             #set nonzero if current image listed} dac 1
lstpg:  .long 0             #current source list page number} dac 0
lstpo:  .long 0             #offset to   page nnn   message} dac 0
lstsn:  .long 0             #remember last stmnum listed} dac 0
#
#      global maximum size of spitbol objects
#
mxlen:  .long 0             #initialised by sysmx call} dac 0
#
#      global execution control variable
#
noxeq:  .long 0             #set non-zero to inhibit execution} dac 0
#
#      global profiler values locations
#
pfdmp:  .long 0             #set non-0 if &profile set non-0} dac 0
pffnc:  .long 0             #set non-0 if funct just entered} dac 0
pfstm:  .long +0            #to store starting time of stmt} dic +0
pfetm:  .long +0            #to store ending time of stmt} dic +0
pfnte:  .long 0             #nr of table entries} dac 0
pfste:  .long +0            #gets int rep of table entry size} dic +0
#
                            #} ejc
        .eject
#
#      global values used in pattern match routines
#
pmdfl:  .long 0             #pattern assignment flag} dac 0
pmhbs:  .long 0             #history stack base pointer} dac 0
pmssl:  .long 0             #length of subject string in chars} dac 0
#
#      global values for interface polling (syspl)
#
polcs:  .long 1             #poll interval start value} dac 1
polct:  .long 1             #poll interval counter} dac 1
#
#      global flags used for standard file listing options
#
prich:  .long 0             #printer on interactive channel} dac 0
prstd:  .long 0             #tested by prtpg} dac 0
prsto:  .long 0             #standard listing option flag} dac 0
#
#      global values for print procedures
#
prbuf:  .long 0             #ptr to print bfr in static} dac 0
precl:  .long 0             #extended/compact listing flag} dac 0
prlen:  .long 0             #length of print buffer in chars} dac 0
prlnw:  .long 0             #length of print buffer in words} dac 0
profs:  .long 0             #offset to next location in prbuf} dac 0
prtef:  .long 0             #endfile flag} dac 0
                            #} ejc
        .eject
#
#      global area for readr
#
rdcln:  .long 0             #current statement line number} dac 0
rdnln:  .long 0             #next statement line number} dac 0
#
#      global amount of memory reserved for end of execution
#
rsmem:  .long 0             #reserve memory} dac 0
#
#      global area for stmgo counters
#
stmcs:  .long 1             #counter startup value} dac 1
stmct:  .long 1             #counter active value} dac 1
#
#      adjustable global values
#
#      all the pointers in this section can point to the
#      dynamic or the static region.
#      when a save file is reloaded, these pointers must
#      be adjusted if static or dynamic memory is now
#      at a different address.  see routine reloc for
#      additional information.
#
#      some values cannot be move here because of adjacency
#      constraints.  they are handled specially by reloc et al.
#      these values are kvrtn,
#
#      values gtswk, kvalp, and prbuf are reinitialized by
#      procedure insta, and do not need to appear here.
#
#      values flprt, flptr, gtcef, and stbas point into the
#      stack and are explicitly adjusted by osint's restart
#      procedure.
#
a_aaa:  .long 0             #start of adjustable values} dac 0
cmpss:  .long 0             #save subroutine stack ptr} dac 0
dnamb:  .long 0             #start of dynamic area} dac 0
dnamp:  .long 0             #next available loc in dynamic area} dac 0
dname:  .long 0             #end of available dynamic area} dac 0
hshtb:  .long 0             #pointer to start of vrblk hash tabl} dac 0
hshte:  .long 0             #pointer past end of vrblk hash tabl} dac 0
iniss:  .long 0             #save subroutine stack ptr} dac 0
pftbl:  .long 0             #gets adrs of (imag) table base} dac 0
prnmv:  .long 0             #vrblk ptr from last name search} dac 0
statb:  .long 0             #start of static area} dac 0
state:  .long 0             #end of static area} dac 0
stxvr:  .long nulls         #vrblk pointer or null} dac nulls
#
#      relocatable global values
#
#      all the pointers in this section can point to blocks in
#      the dynamic storage area and must be relocated by the
#      garbage collector. they are identified by r$xxx names.
#
r_aaa:  .long 0             #start of relocatable values} dac 0
r_arf:  .long 0             #array block pointer for arref} dac 0
r_ccb:  .long 0             #ptr to ccblk being built (cdwrd)} dac 0
r_cim:  .long 0             #ptr to current compiler input str} dac 0
r_cmp:  .long 0             #copy of r_cim used in cmpil} dac 0
r_cni:  .long 0             #ptr to next compiler input string} dac 0
r_cnt:  .long 0             #cdblk pointer for setexit continue} dac 0
r_cod:  .long 0             #pointer to current cdblk or exblk} dac 0
r_ctp:  .long 0             #ptr to current ctblk for patst} dac 0
r_cts:  .long 0             #ptr to last string scanned by patst} dac 0
r_ert:  .long 0             #trblk pointer for errtype trace} dac 0
r_etx:  .long nulls         #pointer to errtext string} dac nulls
r_exs:  .long 0             #= save xl in expdm} dac 0
r_fcb:  .long 0             #fcblk chain head} dac 0
r_fnc:  .long 0             #trblk pointer for fnclevel trace} dac 0
r_gtc:  .long 0             #keep code ptr for gtcod,gtexp} dac 0
r_ici:  .long 0             #saved r_cim during include process.} dac 0
r_ifa:  .long 0             #array of file names by incl. depth} dac 0
r_ifl:  .long 0             #array of line nums by include depth} dac 0
r_ifn:  .long 0             #last include file name} dac 0
r_inc:  .long 0             #table of include file names seen} dac 0
r_io1:  .long 0             #file arg1 for ioput} dac 0
r_io2:  .long 0             #file arg2 for ioput} dac 0
r_iof:  .long 0             #fcblk ptr or 0} dac 0
r_ion:  .long 0             #name base ptr} dac 0
r_iop:  .long 0             #predecessor block ptr for ioput} dac 0
r_iot:  .long 0             #trblk ptr for ioput} dac 0
r_pms:  .long 0             #subject string ptr in pattern match} dac 0
r_ra2:  .long 0             #replace second argument last time} dac 0
r_ra3:  .long 0             #replace third argument last time} dac 0
r_rpt:  .long 0             #ptr to ctblk replace table last usd} dac 0
r_scp:  .long 0             #save pointer from last scane call} dac 0
r_sfc:  .long nulls         #current source file name} dac nulls
r_sfn:  .long 0             #ptr to source file name table} dac 0
r_sxl:  .long 0             #preserve xl in sortc} dac 0
r_sxr:  .long 0             #preserve xr in sorta/sortc} dac 0
r_stc:  .long 0             #trblk pointer for stcount trace} dac 0
r_stl:  .long 0             #source listing sub-title} dac 0
r_sxc:  .long 0             #code (cdblk) ptr for setexit trap} dac 0
r_ttl:  .long nulls         #source listing title} dac nulls
r_xsc:  .long 0             #string pointer for xscan} dac 0
                            #} ejc
        .eject
#
#      the remaining pointers in this list are used to point
#      to function blocks for normally undefined operators.
#
r_uba:  .long stndo         #binary at} dac stndo
r_ubm:  .long stndo         #binary ampersand} dac stndo
r_ubn:  .long stndo         #binary number sign} dac stndo
r_ubp:  .long stndo         #binary percent} dac stndo
r_ubt:  .long stndo         #binary not} dac stndo
r_uub:  .long stndo         #unary vertical bar} dac stndo
r_uue:  .long stndo         #unary equal} dac stndo
r_uun:  .long stndo         #unary number sign} dac stndo
r_uup:  .long stndo         #unary percent} dac stndo
r_uus:  .long stndo         #unary slash} dac stndo
r_uux:  .long stndo         #unary exclamation} dac stndo
r_yyy:  .long 0             #last relocatable location} dac 0
#
#      global locations used in scan procedure
#
scnbl:  .long 0             #set non-zero if scanned past blanks} dac 0
scncc:  .long 0             #non-zero to scan control card name} dac 0
scngo:  .long 0             #set non-zero to scan goto field} dac 0
scnil:  .long 0             #length of current input image} dac 0
scnpt:  .long 0             #pointer to next location in r_cim} dac 0
scnrs:  .long 0             #set non-zero to signal rescan} dac 0
scnse:  .long 0             #start of current element} dac 0
scntp:  .long 0             #save syntax type from last call} dac 0
#
#      global value for indicating stage (see error section)
#
stage:  .long 0             #initial value = initial compile} dac 0
                            #} ejc
        .eject
#
#      global stack pointer
#
stbas:  .long 0             #pointer past stack base} dac 0
#
#      global values for setexit function (s$stx)
#
stxoc:  .long 0             #code pointer offset} dac 0
stxof:  .long 0             #failure offset} dac 0
#
#      global value for time keeping
#
timsx:  .long +0            #time at start of execution} dic +0
timup:  .long 0             #set when time up occurs} dac 0
#
#      global values for xscan and xscni procedures
#
xsofs:  .long 0             #offset to current location in r_xsc} dac 0
#
#      label to mark end of working section
#
w_yyy:  .long 0             #} dac 0
                            #} ttl s p i t b o l -- minimal code
        .sbttl "s p i t b o l -- minimal code"
                            #start of program section} sec
        .global ESEC04
ESEC04:
        .global LOWSPMIN
LOWSPMIN: .long 0
        .global END_MIN_DATA
END_MIN_DATA:
        DSegEnd_
        CSeg_
        .global SEC05
SEC05:
        .balign 2           #mark start of code} ent bl__i
        .byte bl__i
s_aaa:
                            #} ttl s p i t b o l -- relocation
        .sbttl "s p i t b o l -- relocation"
#
#      relocation
#      the following section provides services to osint to
#      relocate portions of the workspace.  it is used when
#      a saved memory image must be restarted at a different
#      location.
#
#      relaj -- relocate a list of pointers
#
#      (wa)                  ptr past last pointer of list
#      (wb)                  ptr to first pointer of list
#      (xl)                  list of boundaries and adjustments
#      jsr  relaj            call to process list of pointers
#      (wb)                  destroyed
#
relaj:                      #entry point} prc e 0
        .global relaj
        LEA                 #save xr} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #save wa} mov wa -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR rlals #save ptr to list of bounds} mov xl rlals
        MOV                 #ptr to first pointer to process} mov wb xr
#
#      merge here to check if done
#
rlaj0:  MOV                 #restore xl} mov rlals xl
        CMP                 #proceed if more to do} bne xr (xs) rlaj1
             rlaj1
        MOV                 #restore wa} mov (xs)+ wa
        LEA
        MOV                 #restore xr} mov (xs)+ xr
        LEA
        RET                 #return to caller} exi
#
#      merge here to process next pointer on list
#
rlaj1:  MOV                 #load next pointer on list} mov (xr) wa
        MOV                 #number of sections of adjusters} lct wb =rnsi_
#
#      merge here to process next section of stack list
#
rlaj2:  CMP                 #ok if past end of section} bgt wa rlend(xl) rlaj3
             rlaj3
        CMP                 #or if before start of section} blt wa rlstr(xl) rlaj3
             rlaj3
        ADD                 #within section, add adjustment} add rladj(xl) wa
        MOV  DWORD PTR []   #return updated ptr to memory} mov wa (xr)
        JMP  rlaj4          #done with this pointer} brn rlaj4
#
#      here if not within section
#
rlaj3:  ADD                 #advance to next section} add *rssi_ xl
        DEC                 #jump if more to go} bct wb rlaj2
        JNZ  rlaj2
#
#      here when finished processing one pointer
#
rlaj4:  ADD                 #increment to next ptr on list} ica xr
        JMP  rlaj0          #jump to check  for completion} brn rlaj0
                            #end procedure relaj} enp
                            #} ejc
        .eject
#
#      relcr -- create relocation info after save file reload
#
#      (wa)                  original s$aaa code section adr
#      (wb)                  original c$aaa constant section adr
#      (wc)                  original g$aaa working section adr
#      (xr)                  ptr to start of static region
#      (cp)                  ptr to start of dynamic region
#      (xl)                  ptr to area to receive information
#      jsr  relcr            create relocation information
#      (wa,wb,wc,xr)         destroyed
#
#      a block of information is built at (xl) that is used
#      in relocating pointers.  there are rnsi$ instances
#      of a rssi$ word structure.  each instance corresponds
#      to one of the regions that a pointer might point into.
#      the layout of this structure is shown in the definitions
#      section, together with symbolic definitions of the
#      entries as offsets from xl.
#
relcr:                      #entry point} prc e 0
        .global relcr
        ADD                 #point past build area} add *rlsi_ xl
        LEA                 #save original code address} mov wa -(xl)
        MOV  DWORD PTR []
        MOV                 #compute adjustment} mov =s_aaa wa
        SUB                 #as new s_aaa minus original s_aaa} sub (xl) wa
        LEA                 #save code adjustment} mov wa -(xl)
        MOV  DWORD PTR []
        MOV                 #end of target code section} mov =s_yyy wa
        SUB                 #length of code section} sub =s_aaa wa
        ADD                 #plus original start address} add num01(xl) wa
        LEA                 #end of original code section} mov wa -(xl)
        MOV  DWORD PTR []
        LEA                 #save constant section address} mov wb -(xl)
        MOV  DWORD PTR []
        MOV                 #start of constants section} mov =c_aaa wb
        MOV                 #end of constants section} mov =c_yyy wa
        SUB                 #length of constants section} sub wb wa
        SUB                 #new c_aaa minus original c_aaa} sub (xl) wb
        LEA                 #save constant adjustment} mov wb -(xl)
        MOV  DWORD PTR []
        ADD                 #length plus original start adr} add num01(xl) wa
        LEA                 #save as end of original constants} mov wa -(xl)
        MOV  DWORD PTR []
        LEA                 #save working globals address} mov wc -(xl)
        MOV  DWORD PTR []
        MOV                 #start of working globals section} mov =g_aaa wc
        MOV                 #end of working section} mov =w_yyy wa
        SUB                 #length of working globals} sub wc wa
        SUB                 #new g_aaa minus original g_aaa} sub (xl) wc
        LEA                 #save working globals adjustment} mov wc -(xl)
        MOV  DWORD PTR []
        ADD                 #length plus original start adr} add num01(xl) wa
        LEA                 #save as end of working globals} mov wa -(xl)
        MOV  DWORD PTR []
        MOV                 #old start of static region} mov statb wb
        LEA                 #save} mov wb -(xl)
        MOV  DWORD PTR []
        SUB                 #compute adjustment} sub wb xr
        LEA                 #save new statb minus old statb} mov xr -(xl)
        MOV  DWORD PTR []
        LEA                 #old end of static region} mov state -(xl)
        MOV  EAX,DWORD PTR state
        MOV  DWORD PTR [],EAX
        MOV                 #old start of dynamic region} mov dnamb wb
        LEA                 #save} mov wb -(xl)
        MOV  DWORD PTR []
        MOV                 #new start of dynamic} scp wa
        SUB                 #compute adjustment} sub wb wa
        LEA                 #save new dnamb minus old dnamb} mov wa -(xl)
        MOV  DWORD PTR []
        MOV                 #old end of dynamic region in use} mov dnamp wc
        LEA                 #save as end of old dynamic region} mov wc -(xl)
        MOV  DWORD PTR []
        RET                 #} exi
                            #} enp
                            #} ejc
        .eject
#
#      reldn -- relocate pointers in the dynamic region
#
#      (xl)                  list of boundaries and adjustments
#      (xr)                  ptr to first location to process
#      (wc)                  ptr past last location to process
#      jsr  reldn            call to process blocks in dynamic
#      (wa,wb,wc,xr)         destroyed
#
#      processes all blocks in the dynamic region.  within a
#      block, pointers to the code section, constant section,
#      working globals section, static region, and dynamic
#      region are relocated as needed.
#
reldn:                      #entry point} prc e 0
        .global reldn
        MOV  EAX,DWORD PTR (4*rlcda)[] #save code adjustment} mov rlcda(xl) rldcd
        MOV  DWORD PTR rldcd,EAX
        MOV  EAX,DWORD PTR (4*rlsta)[] #save static adjustment} mov rlsta(xl) rldst
        MOV  DWORD PTR rldst,EAX
        MOV  DWORD PTR rldls #save list pointer} mov xl rldls
#
#      merge here to process the next block in dynamic
#
rld01:  MOV  EAX,DWORD PTR rldcd #adjust block type word} add rldcd (xr)
        ADD  DWORD PTR [],EAX
        MOV                 #load block type word} mov (xr) xl
        MOVZX               #load entry point id (bl_xx)} lei xl
#
#      block type switch. note that blocks with no relocatable
#      fields just return to rld05 to continue to next block.
#
#      note that dfblks do not appear in dynamic, only in static.
#      ccblks and cmblks are not live when a save file is
#      created, and can be skipped.
#
#      further note:  static blocks other than vrblks discovered
#      while scanning dynamic must be adjusted at this time.
#      see processing of ffblk for example.
#
                            #} ejc
        .eject
#
#      reldn (continued)
#
        JMP  DWORD PTR L0001[*4] #switch on block type} bsw xl bl___
        DSeg_
L0001:
        .long rld03         #arblk} iff bl_ar rld03
        .long rld07         #cdblk} iff bl_cd rld07
        .long rld10         #exblk} iff bl_ex rld10
        .long rld05         #icblk} iff bl_ic rld05
        .long rld13         #nmblk} iff bl_nm rld13
        .long rld13         #p0blk} iff bl_p0 rld13
        .long rld14         #p1blk} iff bl_p1 rld14
        .long rld14         #p2blk} iff bl_p2 rld14
        .long rld05         #rcblk} iff bl_rc rld05
        .long rld05         #scblk} iff bl_sc rld05
        .long rld13         #seblk} iff bl_se rld13
        .long rld17         #tbblk} iff bl_tb rld17
        .long rld17         #vcblk} iff bl_vc rld17
        .long rld05         #xnblk} iff bl_xn rld05
        .long rld20         #xrblk} iff bl_xr rld20
        .long rld05         #bcblk - dummy to fill out iffs} iff bl_bc rld05
        .long rld15         #pdblk} iff bl_pd rld15
        .long rld19         #trblk} iff bl_tr rld19
        .long rld05         #bfblk} iff bl_bf rld05
        .long rld05         #ccblk} iff bl_cc rld05
        .long rld05         #cmblk} iff bl_cm rld05
        .long rld05         #ctblk} iff bl_ct rld05
        .long rld05         #dfblk} iff bl_df rld05
        .long rld08         #efblk} iff bl_ef rld08
        .long rld09         #evblk} iff bl_ev rld09
        .long rld11         #ffblk} iff bl_ff rld11
        .long rld13         #kvblk} iff bl_kv rld13
        .long rld16         #pfblk} iff bl_pf rld16
        .long rld18         #teblk} iff bl_te rld18
        DSegEnd_            #end of jump table} esw
        CSeg_
#
#      arblk
#
rld03:  MOV                 #load length} mov arlen(xr) wa
        MOV                 #set offset to 1st reloc fld (arpro)} mov arofs(xr) wb
#
#      merge here to process pointers in a block
#
#      (xr)                  ptr to current block
#      (wc)                  ptr past last location to process
#      (wa)                  length (reloc flds + flds at start)
#      (wb)                  offset to first reloc field
#
rld04:  ADD                 #point past last reloc field} add xr wa
        ADD                 #point to first reloc field} add xr wb
        MOV                 #point to list of bounds} mov rldls xl
        CALL relaj          #adjust pointers} jsr relaj
                            #} ejc
        .eject
#
#      reldn (continued)
#
#
#      merge here to advance to next block
#
#      (xr)                  ptr to current block
#      (wc)                  ptr past last location to process
#
rld05:  MOV                 #block type word} mov (xr) wa
        CALL blkln          #get length of block} jsr blkln
        ADD                 #point to next block} add wa xr
        CMP                 #continue if more to process} blt xr wc rld01
             rld01
        MOV                 #restore xl} mov rldls xl
        RET                 #return to caller if done} exi
#
#      cdblk
#
rld07:  MOV                 #load length} mov cdlen(xr) wa
        MOV                 #set offset} mov *cdfal wb
        CMP  DWORD PTR [],offset b_cdc #jump back if not complex goto} bne (xr) =b_cdc rld04
             rld04
        MOV                 #do not process cdfal word} mov *cdcod wb
        JMP  rld04          #jump back} brn rld04
#
#      efblk
#
#      if the efcod word points to an xnblk, the xnblk type
#      word will not be adjusted.  since this is implementation
#      dependent, we will not worry about it.
#
rld08:  MOV                 #set length} mov *efrsl wa
        MOV                 #and offset} mov *efcod wb
        JMP  rld04          #all set} brn rld04
#
#      evblk
#
rld09:  MOV                 #point past third field} mov *offs3 wa
        MOV                 #set offset} mov *evexp wb
        JMP  rld04          #all set} brn rld04
#
#      exblk
#
rld10:  MOV                 #load length} mov exlen(xr) wa
        MOV                 #set offset} mov *exflc wb
        JMP  rld04          #jump back} brn rld04
                            #} ejc
        .eject
#
#      reldn (continued)
#
#
#      ffblk
#
#      this block contains a ptr to a dfblk in the static rgn.
#      because there are multiple ffblks pointing to the same
#      dfblk (one for each field name), we only process the
#      dfblk when we encounter the ffblk for the first field.
#      the dfblk in turn contains a pointer to an scblk within
#      static.
#
rld11:  CMP  DWORD PTR (4*ffofs)[],4*pdfld #skip dfblk if not first field} bne ffofs(xr) *pdfld rld12
             rld12
        LEA                 #save xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #load old ptr to dfblk} mov ffdfp(xr) xr
        ADD                 #current location of dfblk} add rldst xr
        MOV  EAX,DWORD PTR rldcd #adjust dfblk type word} add rldcd (xr)
        ADD  DWORD PTR [],EAX
        MOV                 #length of dfblk} mov dflen(xr) wa
        MOV                 #offset to dfnam field} mov *dfnam wb
        ADD                 #point past last reloc field} add xr wa
        ADD                 #point to first reloc field} add xr wb
        MOV                 #point to list of bounds} mov rldls xl
        CALL relaj          #adjust pointers} jsr relaj
        MOV                 #pointer to static scblk} mov dfnam(xr) xr
        MOV  EAX,DWORD PTR rldcd #adjust scblk type word} add rldcd (xr)
        ADD  DWORD PTR [],EAX
        MOV                 #restore ffblk pointer} mov (xs)+ xr
        LEA
#
#      ffblk (continued)
#
#      merge here to set up for adjustment of ptrs in ffblk
#
rld12:  MOV                 #set length} mov *ffofs wa
        MOV                 #set offset} mov *ffdfp wb
        JMP  rld04          #all set} brn rld04
#
#      kvblk, nmblk, p0blk, seblk
#
rld13:  MOV                 #point past second field} mov *offs2 wa
        MOV                 #offset is one (only reloc fld is 2)} mov *offs1 wb
        JMP  rld04          #all set} brn rld04
#
#      p1blk, p2blk
#
#      in p2blks, parm2 contains either a bit mask or the
#      name offset of a variable.  it never requires relocation.
#
rld14:  MOV                 #length (parm2 is non-relocatable)} mov *parm2 wa
        MOV                 #set offset} mov *pthen wb
        JMP  rld04          #all set} brn rld04
#
#      pdblk
#
#      note that the dfblk pointed to by this pdblk was
#      processed when the ffblk was encountered.  because
#      the data function will be called before any records are
#      defined, the ffblk is encountered before any
#      corresponding pdblk.
#
rld15:  MOV                 #load ptr to dfblk} mov pddfp(xr) xl
        ADD                 #adjust for static relocation} add rldst xl
        MOV                 #get pdblk length} mov dfpdl(xl) wa
        MOV                 #set offset} mov *pddfp wb
        JMP  rld04          #all set} brn rld04
                            #} ejc
        .eject
#
#      reldn (continued)
#
#
#      pfblk
#
rld16:  MOV  EAX,DWORD PTR rldst #adjust non-contiguous field} add rldst pfvbl(xr)
        ADD  DWORD PTR (4*pfvbl)[],EAX
        MOV                 #get pfblk length} mov pflen(xr) wa
        MOV                 #offset to first reloc} mov *pfcod wb
        JMP  rld04          #all set} brn rld04
#
#      tbblk, vcblk
#
rld17:  MOV                 #load length} mov offs2(xr) wa
        MOV                 #set offset} mov *offs3 wb
        JMP  rld04          #jump back} brn rld04
#
#      teblk
#
rld18:  MOV                 #set length} mov *tesi_ wa
        MOV                 #and offset} mov *tesub wb
        JMP  rld04          #all set} brn rld04
#
#      trblk
#
rld19:  MOV                 #set length} mov *trsi_ wa
        MOV                 #and offset} mov *trval wb
        JMP  rld04          #all set} brn rld04
#
#      xrblk
#
rld20:  MOV                 #load length} mov xrlen(xr) wa
        MOV                 #set offset} mov *xrptr wb
        JMP  rld04          #jump back} brn rld04
                            #end procedure reldn} enp
                            #} ejc
        .eject
#
#      reloc -- relocate storage after save file reload
#
#      (xl)                  list of boundaries and adjustments
#      jsr  reloc            relocate all pointers
#      (wa,wb,wc,xr)         destroyed
#
#      the list of boundaries and adjustments pointed to by
#      register xl is created by a call to relcr, which should
#      be consulted for information on its structure.
#
reloc:                      #entry point} prc e 0
        .global reloc
        MOV                 #old start of dynamic} mov rldys(xl) xr
        MOV                 #old end of dynamic} mov rldye(xl) wc
        ADD                 #create new start of dynamic} add rldya(xl) xr
        ADD                 #create new end of dynamic} add rldya(xl) wc
        CALL reldn          #relocate pointers in dynamic} jsr reldn
        CALL relws          #relocate pointers in working sect} jsr relws
        CALL relst          #relocate pointers in static} jsr relst
        RET                 #return to caller} exi
                            #end procedure reloc} enp
                            #} ejc
        .eject
#
#      relst -- relocate pointers in the static region
#
#      (xl)                  list of boundaries and adjustments
#      jsr  relst            call to process blocks in static
#      (wa,wb,wc,xr)         destroyed
#
#      only vrblks on the hash chain and any profile block are
#      processed.  other static blocks (dfblks) are processed
#      during processing of dynamic blocks.
#
#      global work locations will be processed at this point,
#      so pointers there can be relied upon.
#
relst:                      #entry point} prc e 0
        .global relst
        MOV                 #profile table} mov pftbl xr
        OR                  #branch if no table allocated} bze xr rls01
        JZ   rls01
        MOV  EAX,DWORD PTR (4*rlcda)[] #adjust block type word} add rlcda(xl) (xr)
        ADD  DWORD PTR [],EAX
#
#      here after dealing with profiler
#
rls01:  MOV                 #point to start of hash table} mov hshtb wc
        MOV                 #point to first hash bucket} mov wc wb
        MOV                 #point beyond hash table} mov hshte wa
        CALL relaj          #adjust bucket pointers} jsr relaj
#
#      loop through slots in hash table
#
rls02:  CMP                 #done if none left} beq wc hshte rls05
             rls05
        MOV                 #else copy slot pointer} mov wc xr
        ADD                 #bump slot pointer} ica wc
        SUB                 #set offset to merge into loop} sub *vrnxt xr
#
#      loop through vrblks on one hash chain
#
rls03:  MOV                 #point to next vrblk on chain} mov vrnxt(xr) xr
        OR                  #jump for next bucket if chain end} bze xr rls02
        JZ   rls02
        MOV                 #offset of first loc past ptr fields} mov *vrlen wa
        MOV                 #offset of first location in vrblk} mov *vrget wb
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #jump if not system variable} bnz vrlen(xr) rls04
        JNZ  rls04
        MOV                 #offset to include vrsvp field} mov *vrsi_ wa
#
#      merge here to process fields of vrblk
#
rls04:  ADD                 #create end ptr} add xr wa
        ADD                 #create start ptr} add xr wb
        CALL relaj          #adjust pointers in vrblk} jsr relaj
        JMP  rls03          #check for another vrblk on chain} brn rls03
#
#      here when all vrblks processed
#
rls05:  RET                 #return to caller} exi
                            #end procedure relst} enp
                            #} ejc
        .eject
#
#      relws -- relocate pointers in the working section
#
#      (xl)                  list of boundaries and adjustments
#      jsr  relws            call to process working section
#      (wa,wb,wc,xr)         destroyed
#
#      pointers between a$aaa and r$yyy are examined and
#      adjusted if necessary.  the pointer kvrtn is also
#      adjusted although it lies outside this range.
#      dname is explicitly adjusted because the limits
#      on dynamic region in stack are to the area actively
#      in use (between dnamb and dnamp), and dname is outside
#      this range.
#
relws:                      #entry point} prc e 0
        .global relws
        MOV                 #point to start of adjustables} mov =a_aaa wb
        MOV                 #point to end of adjustables} mov =r_yyy wa
        CALL relaj          #relocate adjustable pointers} jsr relaj
        MOV  EAX,DWORD PTR (4*rldya)[] #adjust ptr missed by relaj} add rldya(xl) dname
        ADD  DWORD PTR dname,EAX
        MOV                 #case of kvrtn} mov =kvrtn wb
        MOV                 #handled specially} mov wb wa
        ADD                 #one value to adjust} ica wa
        CALL relaj          #adjust kvrtn} jsr relaj
        RET                 #return to caller} exi
                            #end procedure relws} enp
                            #} ttl s p i t b o l -- initialization
        .sbttl "s p i t b o l -- initialization"
#
#      initialisation
#      the following section receives control from the system
#      at the start of a run with the registers set as follows.
#
#      (wa)                  initial stack pointer
#      (xr)                  points to first word of data area
#      (xl)                  points to last word of data area
#
start:                      #entry point} prc e 0
        .global start
        MOV                 #discard return} mov wa xs
        CALL systm          #initialise timer} jsr systm
        MOV  DWORD PTR timsx,EDX #store time} sti timsx
        MOV  DWORD PTR statb #start address of static} mov xr statb
        MOV  DWORD PTR rsmem,4*e_srs #reserve memory} mov *e_srs rsmem
        MOV  DWORD PTR stbas #store stack base} mov xs stbas
                            #save s-r stack ptr} sss iniss
#
#      now convert free store percentage to a suitable factor
#      for easy testing in alloc routine.
#
        MOV  EDX,DWORD PTR intvh #get 100} ldi intvh
        MOV  EAX,DWORD PTR alfsp #form 100 / alfsp} dvi alfsp
        CALL dvi_
        MOV  DWORD PTR alfsf,EDX #store the factor} sti alfsf
#
#      now convert free sediment percentage to a suitable factor
#      for easy testing in gbcol routine.
#
        MOV  EDX,DWORD PTR intvh #get 100} ldi intvh
        MOV  EAX,DWORD PTR gbsdp #form 100 / gbsdp} dvi gbsdp
        CALL dvi_
        MOV  DWORD PTR gbsed,EDX #store the factor} sti gbsed
#
#      initialize values for real conversion routine
#
        MOV                 #load counter for significant digits} lct wb =cfp_s
        MOV  EAX,offset DWORD PTR reav1 #load 1.0} ldr reav1
        CALL ldr_
#
#      loop to compute 10**(max number significant digits)
#
ini03:  MOV  EAX,offset DWORD PTR reavt #* 10.0} mlr reavt
        CALL mlr_
        DEC                 #loop till done} bct wb ini03
        JNZ  ini03
        MOV  EAX,offset DWORD PTR gtssc #store 10**(max sig digits)} str gtssc
        CALL str_
        MOV  EAX,offset DWORD PTR reap5 #load 0.5} ldr reap5
        CALL ldr_
        MOV  EAX,offset DWORD PTR gtssc #compute 0.5*10**(max sig digits)} dvr gtssc
        CALL dvr_
        MOV  EAX,offset DWORD PTR gtsrn #store as rounding bias} str gtsrn
        CALL str_
        XOR                 #set to read parameters} zer wc
        CALL prpar          #read them} jsr prpar
                            #} ejc
        .eject
#
#      now compute starting address for dynamic store and if
#      necessary request more memory.
#
        SUB                 #allow for reserve memory} sub *e_srs xl
        MOV                 #get print buffer length} mov prlen wa
        ADD                 #add no. of chars in alphabet} add =cfp_a wa
        ADD                 #add chars for gtstg bfr} add =nstmx wa
        ADD                 #convert to bytes, allowing a margin} ctb wa 8
        AND
        MOV                 #point to static base} mov statb xr
        ADD                 #increment for above buffers} add wa xr
        ADD                 #increment for hash table} add *e_hnb xr
        ADD                 #bump for initial static block} add *e_sts xr
        CALL sysmx          #get mxlen} jsr sysmx
        MOV  DWORD PTR kvmxl #provisionally store as maxlngth} mov wa kvmxl
        MOV  DWORD PTR mxlen #and as mxlen} mov wa mxlen
        CMP                 #skip if static hi exceeds mxlen} bgt xr wa ini06
             ini06
        ADD                 #round up and make bigger than mxlen} ctb wa 1
        AND
        MOV                 #use it instead} mov wa xr
#
#      here to store values which mark initial division
#      of data area into static and dynamic
#
ini06:  MOV  DWORD PTR dnamb #dynamic base adrs} mov xr dnamb
        MOV  DWORD PTR dnamp #dynamic ptr} mov xr dnamp
        OR                  #skip if non-zero mxlen} bnz wa ini07
        JNZ  ini07
        SUB                 #point a word in front} dca xr
        MOV  DWORD PTR kvmxl #use as maxlngth} mov xr kvmxl
        MOV  DWORD PTR mxlen #and as mxlen} mov xr mxlen
                            #} ejc
        .eject
#
#      loop here if necessary till enough memory obtained
#      so that dname is above dnamb
#
ini07:  MOV  DWORD PTR dname #store dynamic end address} mov xl dname
        CMP  DWORD PTR dnamb #skip if high enough} blt dnamb xl ini09
             ini09
        CALL sysmm          #request more memory} jsr sysmm
        SAL                 #get as baus (sgd05)} wtb xr
        ADD                 #bump by amount obtained} add xr xl
#        OR                  #try again} bnz xr ini07  (Optimized)
        JNZ  ini07
        MOV                 #insufficient memory for maxlength} mov =mxern wa
        XOR                 #no column number info} zer wb
        XOR                 #no line number info} zer wc
        MOV                 #initial compile stage} mov =stgic xr
        MOV                 #no file name} mov =nulls xl
        CALL sysea          #advise of error} jsr sysea
        .short ini08-DFFNC  #cant use error logic yet} ppm ini08
        JMP  ini08          #force termination} brn ini08
#
#      insert text for error 329 in error message table
#
        CALL ERR_1          #} erb 329 requested maxlngth too large
        .byte 73
ini08:  MOV                 #point to failure message} mov =endmo xr
        MOV                 #message length} mov endml wa
        CALL syspr          #print it (prtst not yet usable)} jsr syspr
        .short ERR_-299-DFFNC #should not fail} ppm
        XOR                 #no fcb chain yet} zer xl
        MOV                 #set special code value} mov =num10 wb
        CALL sysej          #pack up (stopr not yet usable)} jsr sysej
#
#      initialise structures at start of static region
#
ini09:  MOV                 #point to static again} mov statb xr
        CALL insta          #initialize static} jsr insta
#
#      initialize number of hash headers
#
        MOV                 #get number of hash headers} mov =e_hnb wa
        MOV  EDX            #convert to integer} mti wa
        MOV  DWORD PTR hshnb,EDX #store for use by gtnvr procedure} sti hshnb
        MOV  DWORD PTR hshtb #pointer to hash table} mov xr hshtb
#
#      loop to clear hash table
#
ini11:  XOR  EAX,EAX        #blank a word} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop} bct wa ini11
        JNZ  ini11
        MOV  DWORD PTR hshte #end of hash table adrs is kept} mov xr hshte
        MOV  DWORD PTR state #store static end address} mov xr state
#
#      init table to map statement numbers to source file names
#
        MOV                 #table will have only one bucket} mov =num01 wc
        MOV                 #default table value} mov =nulls xl
        MOV  DWORD PTR r_sfc #current source file name} mov xl r_sfc
        CALL tmake          #create table} jsr tmake
        MOV  DWORD PTR r_sfn #save ptr to table} mov xr r_sfn
#
#      initialize table to detect duplicate include file names
#
        MOV                 #table will have only one bucket} mov =num01 wc
        MOV                 #default table value} mov =nulls xl
        CALL tmake          #create table} jsr tmake
        MOV  DWORD PTR r_inc #save ptr to table} mov xr r_inc
#
#      initialize array to hold names of nested include files
#
        MOV                 #maximum nesting level} mov =ccinm wa
        MOV                 #null string default value} mov =nulls xl
        CALL vmake          #create array} jsr vmake
        .short ERR_-299-DFFNC #} ppm
        MOV  DWORD PTR r_ifa #save ptr to array} mov xr r_ifa
#
#      init array to hold line numbers of nested include files
#
        MOV                 #maximum nesting level} mov =ccinm wa
        MOV                 #integer one default value} mov =inton xl
        CALL vmake          #create array} jsr vmake
        .short ERR_-299-DFFNC #} ppm
        MOV  DWORD PTR r_ifl #save ptr to array} mov xr r_ifl
#
#      initialize variable blocks for input and output
#
        MOV                 #point to string /input/} mov =v_inp xl
        MOV                 #trblk type for input} mov =trtin wb
        CALL inout          #perform input association} jsr inout
        MOV                 #point to string /output/} mov =v_oup xl
        MOV                 #trblk type for output} mov =trtou wb
        CALL inout          #perform output association} jsr inout
        MOV                 #terminal flag} mov initr wc
        OR                  #skip if no terminal} bze wc ini13
        JZ   ini13
        CALL prpar          #associate terminal} jsr prpar
                            #} ejc
        .eject
#
#      check for expiry date
#
ini13:  CALL sysdc          #call date check} jsr sysdc
        MOV  DWORD PTR flptr #in case stack overflows in compiler} mov xs flptr
#
#      now compile source input code
#
        CALL cmpil          #call compiler} jsr cmpil
        MOV  DWORD PTR r_cod #set ptr to first code block} mov xr r_cod
        MOV  DWORD PTR r_ttl,offset nulls #forget title} mov =nulls r_ttl
        MOV  DWORD PTR r_stl,offset nulls #forget sub-title} mov =nulls r_stl
        XOR  EAX,EAX        #forget compiler input image} zer r_cim
        MOV  DWORD PTR r_cim,EAX
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        XOR  EAX,EAX        #in case end occurred with include} zer cnind
        MOV  DWORD PTR cnind,EAX
        XOR  EAX,EAX        #listing include depth} zer lstid
        MOV  DWORD PTR lstid,EAX
        XOR                 #clear dud value} zer xl
        XOR                 #dont shift dynamic store up} zer wb
        XOR  EAX,EAX        #collect sediment too} zer dnams
        MOV  DWORD PTR dnams,EAX
        CALL gbcol          #clear garbage left from compile} jsr gbcol
        MOV  DWORD PTR dnams #record new sediment size} mov xr dnams
        CMP  DWORD PTR DWORD PTR cpsts,0 #skip if no listing of comp stats} bnz cpsts inix0
        JNZ  inix0
        CALL prtpg          #eject page} jsr prtpg
#
#      print compile statistics
#
        CALL prtmm          #print memory usage} jsr prtmm
        MOV  EDX,DWORD PTR cmerc #get count of errors as integer} mti cmerc
        MOV                 #point to /compile errors/} mov =encm3 xr
        CALL prtmi          #print it} jsr prtmi
        MOV  EDX,DWORD PTR gbcnt #garbage collection count} mti gbcnt
        SUB  EDX,DWORD PTR intv1 #adjust for unavoidable collect} sbi intv1
        MOV                 #point to /storage regenerations/} mov =stpm5 xr
        CALL prtmi          #print gbcol count} jsr prtmi
        CALL systm          #get time} jsr systm
        SUB  EDX,DWORD PTR timsx #get compilation time} sbi timsx
        MOV                 #point to compilation time (msec)/} mov =encm4 xr
        CALL prtmi          #print message} jsr prtmi
        ADD  DWORD PTR lstlc,num05 #bump line count} add =num05 lstlc
        CMP  DWORD PTR DWORD PTR headp,0 #no eject if nothing printed} bze headp inix0
        JZ   inix0
        CALL prtpg          #eject printer} jsr prtpg
                            #} ejc
        .eject
#
#      prepare now to start execution
#
#      set default input record length
#
inix0:  CMP  DWORD PTR cswin,iniln #skip if not default -in72 used} bgt cswin =iniln inix1
             inix1
        MOV  DWORD PTR cswin,inils #else use default record length} mov =inils cswin
#
#      reset timer
#
inix1:  CALL systm          #get time again} jsr systm
        MOV  DWORD PTR timsx,EDX #store for end run processing} sti timsx
        XOR  EAX,EAX        #initialise collect count} zer gbcnt
        MOV  DWORD PTR gbcnt,EAX
        CALL sysbx          #call before starting execution} jsr sysbx
        MOV  EAX,DWORD PTR cswex #add -noexecute flag} add cswex noxeq
        ADD  DWORD PTR noxeq,EAX
        CMP  DWORD PTR DWORD PTR noxeq,0 #jump if execution suppressed} bnz noxeq inix2
        JNZ  inix2
#
#      merge when listing file set for execution.  also
#      merge here when restarting a save file or load module.
#
iniy0:  MOV  DWORD PTR headp,ESP #mark headers out regardless} mnz headp
        LEA                 #set failure location on stack} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        MOV  DWORD PTR flptr #save ptr to failure offset word} mov xs flptr
        MOV                 #load ptr to entry code block} mov r_cod xr
        MOV  DWORD PTR stage,stgxt #set stage for execute time} mov =stgxt stage
        MOV  DWORD PTR polcs,num01 #reset interface polling interval} mov =num01 polcs
        MOV  DWORD PTR polct,num01 #reset interface polling interval} mov =num01 polct
        MOV  EAX,DWORD PTR cmpsn #copy stmts compiled count in case} mov cmpsn pfnte
        MOV  DWORD PTR pfnte,EAX
        MOV  EAX,DWORD PTR kvpfl #start profiling if &profile set} mov kvpfl pfdmp
        MOV  DWORD PTR pfdmp,EAX
        CALL systm          #time yet again} jsr systm
        MOV  DWORD PTR pfstm,EDX #} sti pfstm
        CALL stgcc          #compute stmgo countdown counters} jsr stgcc
        JMP  DWORD PTR []   #start xeq with first statement} bri (xr)
#
#      here if execution is suppressed
#
inix2:  XOR                 #set abend value to zero} zer wa
        MOV                 #set special code value} mov =nini9 wb
        XOR                 #no fcb chain} zer xl
        CALL sysej          #end of job, exit to system} jsr sysej
                            #end procedure start} enp
#
#      here from osint to restart a save file or load module.
#
rstrt:                      #entry point} prc e 0
        .global rstrt
        MOV                 #discard return} mov stbas xs
        XOR                 #clear xl} zer xl
        JMP  iniy0          #resume execution} brn iniy0
                            #end procedure rstrt} enp
                            #} ttl s p i t b o l -- snobol4 operator routines
        .sbttl "s p i t b o l -- snobol4 operator routines"
#
#      this section includes all routines which can be accessed
#      directly from the generated code except system functions.
#
#      all routines in this section start with a label of the
#      form o$xxx where xxx is three letters. the generated code
#      contains a pointer to the appropriate entry label.
#
#      since the general form of the generated code consists of
#      pointers to blocks whose first word is the address of the
#      actual entry point label (o$xxx).
#
#      these routines are in alphabetical order by their
#      entry label names (i.e. by the xxx of the o$xxx name)
#
#      these routines receive control as follows
#
#      (cp)                  pointer to next code word
#      (xs)                  current stack pointer
                            #} ejc
        .eject
#
#      binary plus (addition)
#
        .balign 2           #entry point} ent
        NOP
o_add:
        CALL arith          #fetch arithmetic operands} jsr arith
        .short ERR_-1-DFFNC #} err 001 addition left operand is not numeric
        .short ERR_-2-DFFNC #} err 002 addition right operand is not numeric
        .short oadd1-DFFNC  #jump if real operands} ppm oadd1
#
#      here to add two integers
#
        ADD  EDX,DWORD PTR (4*icval)[] #add right operand to left} adi icval(xl)
        JNO  exint          #return integer if no overflow} ino exint
        CALL ERR_0          #} erb 003 addition caused integer overflow
        .byte 3
#
#      here to add two reals
#
oadd1:  LEA  EAX,DWORD PTR (4*rcval)[] #add right operand to left} adr rcval(xl)
        CALL adr_
        CALL OVR_           #return real if no overflow} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 261 addition caused real overflow
        .byte 5
                            #} ejc
        .eject
#
#      unary plus (affirmation)
#
        .balign 2           #entry point} ent
        NOP
o_aff:
        MOV                 #load operand} mov (xs)+ xr
        LEA
        CALL gtnum          #convert to numeric} jsr gtnum
        .short ERR_-4-DFFNC #} err 004 affirmation operand is not numeric
        LEA                 #result if converted to numeric} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      binary bar (alternation)
#
        .balign 2           #entry point} ent
        NOP
o_alt:
        MOV                 #load right operand} mov (xs)+ xr
        LEA
        CALL gtpat          #convert to pattern} jsr gtpat
        .short ERR_-5-DFFNC #} err 005 alternation right operand is not pattern
#
#      merge here from special (left alternation) case
#
oalt1:  MOV                 #set pcode for alternative node} mov =p_alt wb
        CALL pbild          #build alternative node} jsr pbild
        MOV                 #save address of alternative node} mov xr xl
        MOV                 #load left operand} mov (xs)+ xr
        LEA
        CALL gtpat          #convert to pattern} jsr gtpat
        .short ERR_-6-DFFNC #} err 006 alternation left operand is not pattern
        CMP                 #jump if left arg is alternation} beq xr =p_alt oalt2
             oalt2
        MOV  DWORD PTR (4*pthen)[] #set left operand as successor} mov xr pthen(xl)
        LEA                 #stack result} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      come here if left argument is itself an alternation
#
#      the result is more efficient if we make the replacement
#
#      (a / b) / c = a / (b / c)
#
oalt2:  MOV  EAX,DWORD PTR (4*parm1)[] #build the (b / c) node} mov parm1(xr) pthen(xl)
        MOV  DWORD PTR (4*pthen)[],EAX
        LEA                 #set a as new left arg} mov pthen(xr) -(xs)
        MOV  EAX,DWORD PTR (4*pthen)[]
        MOV  DWORD PTR [],EAX
        MOV                 #set (b / c) as new right arg} mov xl xr
        JMP  oalt1          #merge back to build a / (b / c)} brn oalt1
                            #} ejc
        .eject
#
#      array reference (multiple subscripts, by name)
#
        .balign 2           #entry point} ent
        NOP
o_amn:
        MOV                 #load number of subscripts} lcw xr
        ADD  EBP,4
        MOV                 #set flag for by name} mov xr wb
        JMP  arref          #jump to array reference routine} brn arref
                            #} ejc
        .eject
#
#      array reference (multiple subscripts, by value)
#
        .balign 2           #entry point} ent
        NOP
o_amv:
        MOV                 #load number of subscripts} lcw xr
        ADD  EBP,4
        XOR                 #set flag for by value} zer wb
        JMP  arref          #jump to array reference routine} brn arref
                            #} ejc
        .eject
#
#      array reference (one subscript, by name)
#
        .balign 2           #entry point} ent
        NOP
o_aon:
        MOV                 #load subscript value} mov (xs) xr
        MOV                 #load array value} mov num01(xs) xl
        MOV                 #load first word of array operand} mov (xl) wa
        CMP                 #jump if vector reference} beq wa =b_vct oaon2
             oaon2
        CMP                 #jump if table reference} beq wa =b_tbt oaon3
             oaon3
#
#      here to use central array reference routine
#
oaon1:  MOV                 #set number of subscripts to one} mov =num01 xr
        MOV                 #set flag for by name} mov xr wb
        JMP  arref          #jump to array reference routine} brn arref
#
#      here if we have a vector reference
#
oaon2:  CMP  DWORD PTR [],offset b_icl #use long routine if not integer} bne (xr) =b_icl oaon1
             oaon1
        MOV  EDX,DWORD PTR (4*icval)[] #load integer subscript value} ldi icval(xr)
        OR   EDX,EDX        #copy as address int, fail if ovflo} mfi wa exfal
        JS   exfal
        MOV
        OR                  #fail if zero} bze wa exfal
        JZ   exfal
        ADD                 #compute offset in words} add =vcvlb wa
        SAL                 #convert to bytes} wtb wa
        MOV  DWORD PTR []   #complete name on stack} mov wa (xs)
        CMP                 #exit if subscript not too large} blt wa vclen(xl) oaon4
             oaon4
        JMP  exfal          #else fail} brn exfal
#
#      here for table reference
#
oaon3:  MOV                 #set flag for name reference} mnz wb
        CALL tfind          #locate/create table element} jsr tfind
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        MOV  DWORD PTR (4*num01)[] #store name base on stack} mov xl num01(xs)
        MOV  DWORD PTR []   #store name offset on stack} mov wa (xs)
#
#      here to exit with result on stack
#
oaon4:  MOV                 #result on stack, get code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      array reference (one subscript, by value)
#
        .balign 2           #entry point} ent
        NOP
o_aov:
        MOV                 #load subscript value} mov (xs)+ xr
        LEA
        MOV                 #load array value} mov (xs)+ xl
        LEA
        MOV                 #load first word of array operand} mov (xl) wa
        CMP                 #jump if vector reference} beq wa =b_vct oaov2
             oaov2
        CMP                 #jump if table reference} beq wa =b_tbt oaov3
             oaov3
#
#      here to use central array reference routine
#
oaov1:  LEA                 #restack array value} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #restack subscript} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #set number of subscripts to one} mov =num01 xr
        XOR                 #set flag for value call} zer wb
        JMP  arref          #jump to array reference routine} brn arref
#
#      here if we have a vector reference
#
oaov2:  CMP  DWORD PTR [],offset b_icl #use long routine if not integer} bne (xr) =b_icl oaov1
             oaov1
        MOV  EDX,DWORD PTR (4*icval)[] #load integer subscript value} ldi icval(xr)
        OR   EDX,EDX        #move as one word int, fail if ovflo} mfi wa exfal
        JS   exfal
        MOV
        OR                  #fail if zero} bze wa exfal
        JZ   exfal
        ADD                 #compute offset in words} add =vcvlb wa
        SAL                 #convert to bytes} wtb wa
        CMP                 #fail if subscript too large} bge wa vclen(xl) exfal
             exfal
        CALL acess          #access value} jsr acess
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      here for table reference by value
#
oaov3:  XOR                 #set flag for value reference} zer wb
        CALL tfind          #call table search routine} jsr tfind
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      assignment
#
        .balign 2           #entry point} ent
        NOP
o_ass:
#
#      o$rpl (pattern replacement) merges here
#
oass0:  MOV                 #load value to be assigned} mov (xs)+ wb
        LEA
        MOV                 #load name offset} mov (xs)+ wa
        LEA
        MOV                 #load name base} mov (xs) xl
        MOV  DWORD PTR []   #store assigned value as result} mov wb (xs)
        CALL asign          #perform assignment} jsr asign
        .short exfal-DFFNC  #fail if assignment fails} ppm exfal
        MOV                 #result on stack, get code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      compilation error
#
        .balign 2           #entry point} ent
        NOP
o_cer:
        CALL ERR_0          #} erb 007 compilation error encountered during execution
        .byte 7
                            #} ejc
        .eject
#
#      unary at (cursor assignment)
#
        .balign 2           #entry point} ent
        NOP
o_cas:
        MOV                 #load name offset (parm2)} mov (xs)+ wc
        LEA
        MOV                 #load name base (parm1)} mov (xs)+ xr
        LEA
        MOV                 #set pcode for cursor assignment} mov =p_cas wb
        CALL pbild          #build node} jsr pbild
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      concatenation
#
        .balign 2           #entry point} ent
        NOP
o_cnc:
        MOV                 #load right argument} mov (xs) xr
        CMP                 #jump if right arg is null} beq xr =nulls ocnc3
             ocnc3
        MOV                 #load left argument} mov 1(xs) xl
        CMP                 #jump if left argument is null} beq xl =nulls ocnc4
             ocnc4
        MOV                 #get constant to test for string} mov =b_scl wa
        CMP                 #jump if left arg not a string} bne wa (xl) ocnc2
             ocnc2
        CMP                 #jump if right arg not a string} bne wa (xr) ocnc2
             ocnc2
#
#      merge here to concatenate two strings
#
ocnc1:  MOV                 #load left argument length} mov sclen(xl) wa
        ADD                 #compute result length} add sclen(xr) wa
        CALL alocs          #allocate scblk for result} jsr alocs
        MOV  DWORD PTR (4*1)[] #store result ptr over left argument} mov xr 1(xs)
        ADD                 #prepare to store chars of result} psc xr
        MOV                 #get number of chars in left arg} mov sclen(xl) wa
        ADD                 #prepare to load left arg chars} plc xl
        SHRD EAX,ECX,1      #move characters of left argument} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        MOV                 #load right arg pointer, pop stack} mov (xs)+ xl
        LEA
        MOV                 #load number of chars in right arg} mov sclen(xl) wa
        ADD                 #prepare to load right arg chars} plc xl
        SHRD EAX,ECX,1      #move characters of right argument} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        XOR                 #clear garbage value in xl} zer xl
        MOV                 #result on stack, get code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      come here if arguments are not both strings
#
ocnc2:  CALL gtstg          #convert right arg to string} jsr gtstg
        .short ocnc5-DFFNC  #jump if right arg is not string} ppm ocnc5
        MOV                 #save right arg ptr} mov xr xl
        CALL gtstg          #convert left arg to string} jsr gtstg
        .short ocnc6-DFFNC  #jump if left arg is not a string} ppm ocnc6
        LEA                 #stack left argument} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack right argument} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #move left arg to proper reg} mov xr xl
        MOV                 #move right arg to proper reg} mov (xs) xr
        JMP  ocnc1          #merge back to concatenate strings} brn ocnc1
                            #} ejc
        .eject
#
#      concatenation (continued)
#
#      come here for null right argument
#
ocnc3:  ADD                 #remove right arg from stack} ica xs
        MOV                 #left argument on stack} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      here for null left argument
#
ocnc4:  ADD                 #unstack one argument} ica xs
        MOV  DWORD PTR []   #store right argument} mov xr (xs)
        MOV                 #result on stack, get code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      here if right argument is not a string
#
ocnc5:  MOV                 #move right argument ptr} mov xr xl
        MOV                 #load left arg pointer} mov (xs)+ xr
        LEA
#
#      merge here when left argument is not a string
#
ocnc6:  CALL gtpat          #convert left arg to pattern} jsr gtpat
        .short ERR_-8-DFFNC #} err 008 concatenation left operand is not a string or pattern
        LEA                 #save result on stack} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #point to right operand} mov xl xr
        CALL gtpat          #convert to pattern} jsr gtpat
        .short ERR_-9-DFFNC #} err 009 concatenation right operand is not a string or pattern
        MOV                 #move for pconc} mov xr xl
        MOV                 #reload left operand ptr} mov (xs)+ xr
        LEA
        CALL pconc          #concatenate patterns} jsr pconc
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      complementation
#
        .balign 2           #entry point} ent
        NOP
o_com:
        MOV                 #load operand} mov (xs)+ xr
        LEA
        MOV                 #load type word} mov (xr) wa
#
#      merge back here after conversion
#
ocom1:  CMP                 #jump if integer} beq wa =b_icl ocom2
             ocom2
        CMP                 #jump if real} beq wa =b_rcl ocom3
             ocom3
        CALL gtnum          #else convert to numeric} jsr gtnum
        .short ERR_-10-DFFNC #} err 010 negation operand is not numeric
        JMP  ocom1          #back to check cases} brn ocom1
#
#      here to complement integer
#
ocom2:  MOV  EDX,DWORD PTR (4*icval)[] #load integer value} ldi icval(xr)
        NEG  EDX            #negate} ngi
        JNO  exint          #return integer if no overflow} ino exint
        CALL ERR_0          #} erb 011 negation caused integer overflow
        .byte 11
#
#      here to complement real
#
ocom3:  LEA  EAX,DWORD PTR (4*rcval)[] #load real value} ldr rcval(xr)
        CALL ldr_
        CALL ngr_           #negate} ngr
        JMP  exrea          #return real result} brn exrea
                            #} ejc
        .eject
#
#      binary slash (division)
#
        .balign 2           #entry point} ent
        NOP
o_dvd:
        CALL arith          #fetch arithmetic operands} jsr arith
        .short ERR_-12-DFFNC #} err 012 division left operand is not numeric
        .short ERR_-13-DFFNC #} err 013 division right operand is not numeric
        .short odvd2-DFFNC  #jump if real operands} ppm odvd2
#
#      here to divide two integers
#
        MOV  EAX,DWORD PTR (4*icval)[] #divide left operand by right} dvi icval(xl)
        CALL dvi_
        JNO  exint          #result ok if no overflow} ino exint
        CALL ERR_0          #} erb 014 division caused integer overflow
        .byte 14
#
#      here to divide two reals
#
odvd2:  LEA  EAX,DWORD PTR (4*rcval)[] #divide left operand by right} dvr rcval(xl)
        CALL dvr_
        CALL OVR_           #return real if no overflow} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 262 division caused real overflow
        .byte 6
                            #} ejc
        .eject
#
#      exponentiation
#
        .balign 2           #entry point} ent
        NOP
o_exp:
        MOV                 #load exponent} mov (xs)+ xr
        LEA
        CALL gtnum          #convert to number} jsr gtnum
        .short ERR_-15-DFFNC #} err 015 exponentiation right operand is not numeric
        MOV                 #move exponent to xl} mov xr xl
        MOV                 #load base} mov (xs)+ xr
        LEA
        CALL gtnum          #convert to numeric} jsr gtnum
        .short ERR_-16-DFFNC #} err 016 exponentiation left operand is not numeric
        CMP  DWORD PTR [],offset b_rcl #jump if real exponent} beq (xl) =b_rcl oexp7
             oexp7
        MOV  EDX,DWORD PTR (4*icval)[] #load exponent} ldi icval(xl)
        OR   EDX,EDX        #jump if negative exponent} ilt oex12
        JL   oex12
        CMP                 #jump if base is real} beq wa =b_rcl oexp3
             oexp3
#
#      here to exponentiate an integer base and integer exponent
#
        OR   EDX,EDX        #convert exponent to 1 word integer} mfi wa oexp2
        JS   oexp2
        MOV
        MOV  EDX,DWORD PTR (4*icval)[] #load base as initial value} ldi icval(xr)
        OR                  #jump into loop if non-zero exponent} bnz wa oexp1
        JNZ  oexp1
        OR   EDX,EDX        #error if 0**0} ieq oexp4
        JE   oexp4
        MOV  EDX,DWORD PTR intv1 #nonzero**0} ldi intv1
        JMP  exint          #give one as result for nonzero**0} brn exint
#
#      loop to perform exponentiation
#
oex13:  IMUL EDX,DWORD PTR (4*icval)[] #multiply by base} mli icval(xr)
        JO   oexp2          #jump if overflow} iov oexp2
oexp1:  DEC                 #loop if more to go} bct wa oex13
        JNZ  oex13
        JMP  exint          #else return integer result} brn exint
#
#      here if integer overflow
#
oexp2:  CALL ERR_0          #} erb 017 exponentiation caused integer overflow
        .byte 17
                            #} ejc
        .eject
#
#      exponentiation (continued)
#
#      here to exponentiate a real to an integer power
#
oexp3:  OR   EDX,EDX        #convert exponent to one word} mfi wa oexp6
        JS   oexp6
        MOV
        LEA  EAX,DWORD PTR (4*rcval)[] #load base as initial value} ldr rcval(xr)
        CALL ldr_
        OR                  #jump into loop if non-zero exponent} bnz wa oexp5
        JNZ  oexp5
        CALL CPR_           #error if 0.0**0} req oexp4
        JE   oexp4
        MOV  EAX,offset DWORD PTR reav1 #nonzero**0} ldr reav1
        CALL ldr_
        JMP  exrea          #return 1.0 if nonzero**zero} brn exrea
#
#      here for error of 0**0 or 0.0**0
#
oexp4:  CALL ERR_0          #} erb 018 exponentiation result is undefined
        .byte 18
#
#      loop to perform exponentiation
#
oex14:  LEA  EAX,DWORD PTR (4*rcval)[] #multiply by base} mlr rcval(xr)
        CALL mlr_
        CALL OVR_           #jump if overflow} rov oexp6
        JO   oexp6
oexp5:  DEC                 #loop till computation complete} bct wa oex14
        JNZ  oex14
        JMP  exrea          #then return real result} brn exrea
#
#      here if real overflow
#
oexp6:  CALL ERR_1          #} erb 266 exponentiation caused real overflow
        .byte 10
#
#      here with real exponent in (xl), numeric base in (xr)
#
oexp7:  CMP  DWORD PTR [],offset b_rcl #jump if base real} beq (xr) =b_rcl oexp8
             oexp8
        MOV  EDX,DWORD PTR (4*icval)[] #load integer base} ldi icval(xr)
        CALL ITR_           #convert to real} itr
        CALL rcbld          #create real in (xr)} jsr rcbld
#
#      here with real exponent in (xl)
#      numeric base in (xr) and ra
#
oexp8:  XOR                 #set positive result flag} zer wb
        LEA  EAX,DWORD PTR (4*rcval)[] #load base to ra} ldr rcval(xr)
        CALL ldr_
        CALL CPR_           #jump if base non-zero} rne oexp9
        JNE  oexp9
        LEA  EAX,DWORD PTR (4*rcval)[] #base is zero.  check exponent} ldr rcval(xl)
        CALL ldr_
        CALL CPR_           #jump if 0.0 ** 0.0} req oexp4
        JE   oexp4
        MOV  EAX,offset DWORD PTR reav0 #0.0 to non-zero exponent yields 0.0} ldr reav0
        CALL ldr_
        JMP  exrea          #return zero result} brn exrea
#
#      here with non-zero base in (xr) and ra, exponent in (xl)
#
#      a negative base is allowed if the exponent is integral.
#
oexp9:  CALL CPR_           #jump if base gt 0.0} rgt oex10
        JG   oex10
        CALL ngr_           #make base positive} ngr
        CALL rcbld          #create positive base in (xr)} jsr rcbld
        LEA  EAX,DWORD PTR (4*rcval)[] #examine exponent} ldr rcval(xl)
        CALL ldr_
        CALL chp_           #chop to integral value} chp
        CALL RTI_           #convert to integer, br if too large} rti oexp6
        JC   oexp6
        LEA  EAX,DWORD PTR (4*rcval)[] #chop(exponent) - exponent} sbr rcval(xl)
        CALL sbr_
        CALL CPR_           #non-integral power with neg base} rne oex11
        JNE  oex11
        MOV                 #record even/odd exponent} mfi wb
        AND                 #odd exponent yields negative result} anb bits1 wb
        LEA  EAX,DWORD PTR (4*rcval)[] #restore base to ra} ldr rcval(xr)
        CALL ldr_
#
#      here with positive base in ra and (xr), exponent in (xl)
#
oex10:  CALL lnf_           #log of base} lnf
        CALL OVR_           #too large} rov oexp6
        JO   oexp6
        LEA  EAX,DWORD PTR (4*rcval)[] #times exponent} mlr rcval(xl)
        CALL mlr_
        CALL OVR_           #too large} rov oexp6
        JO   oexp6
        CALL etx_           #e ** (exponent * ln(base))} etx
        CALL OVR_           #too large} rov oexp6
        JO   oexp6
        OR                  #if no sign fixup required} bze wb exrea
        JZ   exrea
        CALL ngr_           #negative result needed} ngr
        JMP  exrea          #} brn exrea
#
#      here for non-integral exponent with negative base
#
oex11:  CALL ERR_1          #} erb 311 exponentiation of negative base to non-integral power
        .byte 55
#
#      here with negative integer exponent in ia
#
oex12:  LEA                 #stack base} mov xr -(xs)
        MOV  DWORD PTR []
        CALL ITR_           #convert to real exponent} itr
        CALL rcbld          #real negative exponent in (xr)} jsr rcbld
        MOV                 #put exponent in xl} mov xr xl
        MOV                 #restore base value} mov (xs)+ xr
        LEA
        JMP  oexp7          #process real exponent} brn oexp7
                            #} ejc
        .eject
#
#      failure in expression evaluation
#
#      this entry point is used if the evaluation of an
#      expression, initiated by the evalx procedure, fails.
#      control is returned to an appropriate point in evalx.
#
        .balign 2           #entry point} ent
        NOP
o_fex:
        JMP  evlx6          #jump to failure loc in evalx} brn evlx6
                            #} ejc
        .eject
#
#      failure during evaluation of a complex or direct goto
#
        .balign 2           #entry point} ent
        NOP
o_fif:
        CALL ERR_0          #} erb 020 goto evaluation failure
        .byte 20
                            #} ejc
        .eject
#
#      function call (more than one argument)
#
        .balign 2           #entry point} ent
        NOP
o_fnc:
        MOV                 #load number of arguments} lcw wa
        ADD  EBP,4
        MOV                 #load function vrblk pointer} lcw xr
        ADD  EBP,4
        MOV                 #load function pointer} mov vrfnc(xr) xl
        CMP                 #use central routine if wrong num} bne wa fargs(xl) cfunc
             cfunc
        JMP  DWORD PTR []   #jump to function if arg count ok} bri (xl)
                            #} ejc
        .eject
#
#      function name error
#
        .balign 2           #entry point} ent
        NOP
o_fne:
        MOV                 #get next code word} lcw wa
        ADD  EBP,4
        CMP                 #fail if not evaluating expression} bne wa =ornm_ ofne1
             ofne1
        CMP  DWORD PTR DWORD PTR (4*num02)[],0 #ok if expr. was wanted by value} bze num02(xs) evlx3
        JZ   evlx3
#
#      here for error
#
ofne1:  CALL ERR_0          #} erb 021 function called by name returned a value
        .byte 21
                            #} ejc
        .eject
#
#      function call (single argument)
#
        .balign 2           #entry point} ent
        NOP
o_fns:
        MOV                 #load function vrblk pointer} lcw xr
        ADD  EBP,4
        MOV                 #set number of arguments to one} mov =num01 wa
        MOV                 #load function pointer} mov vrfnc(xr) xl
        CMP                 #use central routine if wrong num} bne wa fargs(xl) cfunc
             cfunc
        JMP  DWORD PTR []   #jump to function if arg count ok} bri (xl)
                            #} ejc
        .eject
#      call to undefined function
#
        .balign 2           #entry point} ent
        NOP
o_fun:
        CALL ERR_0          #} erb 022 undefined function called
        .byte 22
                            #} ejc
        .eject
#
#      execute complex goto
#
        .balign 2           #entry point} ent
        NOP
o_goc:
        MOV                 #load name base pointer} mov num01(xs) xr
        CMP                 #jump if not natural variable} bhi xr state ogoc1
             ogoc1
        ADD                 #else point to vrtra field} add *vrtra xr
        JMP  DWORD PTR []   #and jump through it} bri (xr)
#
#      here if goto operand is not natural variable
#
ogoc1:  CALL ERR_0          #} erb 023 goto operand is not a natural variable
        .byte 23
                            #} ejc
        .eject
#
#      execute direct goto
#
        .balign 2           #entry point} ent
        NOP
o_god:
        MOV                 #load operand} mov (xs) xr
        MOV                 #load first word} mov (xr) wa
        CMP                 #jump if code block to code routine} beq wa =b_cds bcds0
             bcds0
        CMP                 #jump if code block to code routine} beq wa =b_cdc bcdc0
             bcdc0
        CALL ERR_0          #} erb 024 goto operand in direct goto is not code
        .byte 24
                            #} ejc
        .eject
#
#      set goto failure trap
#
#      this routine is executed at the start of a complex or
#      direct failure goto to trap a subsequent fail (see exfal)
#
        .balign 2           #entry point} ent
        NOP
o_gof:
        MOV                 #point to fail offset on stack} mov flptr xr
        ADD  DWORD PTR [],4 #point failure to o_fif word} ica (xr)
        ADD  EBP,4          #point to next code word} icp
        MOV                 #fetch next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      binary dollar (immediate assignment)
#
#      the pattern built by binary dollar is a compound pattern.
#      see description at start of pattern match section for
#      details of the structure which is constructed.
#
        .balign 2           #entry point} ent
        NOP
o_ima:
        MOV                 #set pcode for last node} mov =p_imc wb
        MOV                 #pop name offset (parm2)} mov (xs)+ wc
        LEA
        MOV                 #pop name base (parm1)} mov (xs)+ xr
        LEA
        CALL pbild          #build p_imc node} jsr pbild
        MOV                 #save ptr to node} mov xr xl
        MOV                 #load left argument} mov (xs) xr
        CALL gtpat          #convert to pattern} jsr gtpat
        .short ERR_-25-DFFNC #} err 025 immediate assignment left operand is not pattern
        MOV  DWORD PTR []   #save ptr to left operand pattern} mov xr (xs)
        MOV                 #set pcode for first node} mov =p_ima wb
        CALL pbild          #build p_ima node} jsr pbild
        MOV  EAX,DWORD PTR [] #set left operand as p_ima successor} mov (xs)+ pthen(xr)
        MOV  DWORD PTR (4*pthen)[],EAX
        LEA
        CALL pconc          #concatenate to form final pattern} jsr pconc
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      indirection (by name)
#
        .balign 2           #entry point} ent
        NOP
o_inn:
        MOV                 #set flag for result by name} mnz wb
        JMP  indir          #jump to common routine} brn indir
                            #} ejc
        .eject
#
#      interrogation
#
        .balign 2           #entry point} ent
        NOP
o_int:
        MOV  DWORD PTR [],offset nulls #replace operand with null} mov =nulls (xs)
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      indirection (by value)
#
        .balign 2           #entry point} ent
        NOP
o_inv:
        XOR                 #set flag for by value} zer wb
        JMP  indir          #jump to common routine} brn indir
                            #} ejc
        .eject
#
#      keyword reference (by name)
#
        .balign 2           #entry point} ent
        NOP
o_kwn:
        CALL kwnam          #get keyword name} jsr kwnam
        JMP  exnam          #exit with result name} brn exnam
                            #} ejc
        .eject
#
#      keyword reference (by value)
#
        .balign 2           #entry point} ent
        NOP
o_kwv:
        CALL kwnam          #get keyword name} jsr kwnam
        MOV  DWORD PTR dnamp #delete kvblk} mov xr dnamp
        CALL acess          #access value} jsr acess
        .short exnul-DFFNC  #dummy (unused) failure return} ppm exnul
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      load expression by name
#
        .balign 2           #entry point} ent
        NOP
o_lex:
        MOV                 #set size of evblk} mov *evsi_ wa
        CALL alloc          #allocate space for evblk} jsr alloc
        MOV  DWORD PTR [],offset b_evt #set type word} mov =b_evt (xr)
        MOV  DWORD PTR (4*evvar)[],offset trbev #set dummy trblk pointer} mov =trbev evvar(xr)
        MOV                 #load exblk pointer} lcw wa
        ADD  EBP,4
        MOV  DWORD PTR (4*evexp)[] #set exblk pointer} mov wa evexp(xr)
        MOV                 #move name base to proper reg} mov xr xl
        MOV                 #set name offset = zero} mov *evvar wa
        JMP  exnam          #exit with name in (xl,wa)} brn exnam
                            #} ejc
        .eject
#
#      load pattern value
#
        .balign 2           #entry point} ent
        NOP
o_lpt:
        MOV                 #load pattern pointer} lcw xr
        ADD  EBP,4
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      load variable name
#
        .balign 2           #entry point} ent
        NOP
o_lvn:
        MOV                 #load vrblk pointer} lcw wa
        ADD  EBP,4
        LEA                 #stack vrblk ptr (name base)} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #stack name offset} mov *vrval -(xs)
        MOV  DWORD PTR [],4*vrval
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      binary asterisk (multiplication)
#
        .balign 2           #entry point} ent
        NOP
o_mlt:
        CALL arith          #fetch arithmetic operands} jsr arith
        .short ERR_-26-DFFNC #} err 026 multiplication left operand is not numeric
        .short ERR_-27-DFFNC #} err 027 multiplication right operand is not numeric
        .short omlt1-DFFNC  #jump if real operands} ppm omlt1
#
#      here to multiply two integers
#
        IMUL EDX,DWORD PTR (4*icval)[] #multiply left operand by right} mli icval(xl)
        JNO  exint          #return integer if no overflow} ino exint
        CALL ERR_0          #} erb 028 multiplication caused integer overflow
        .byte 28
#
#      here to multiply two reals
#
omlt1:  LEA  EAX,DWORD PTR (4*rcval)[] #multiply left operand by right} mlr rcval(xl)
        CALL mlr_
        CALL OVR_           #return real if no overflow} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 263 multiplication caused real overflow
        .byte 7
                            #} ejc
        .eject
#
#      name reference
#
        .balign 2           #entry point} ent
        NOP
o_nam:
        MOV                 #set length of nmblk} mov *nmsi_ wa
        CALL alloc          #allocate nmblk} jsr alloc
        MOV  DWORD PTR [],offset b_nml #set name block code} mov =b_nml (xr)
        MOV  EAX,DWORD PTR [] #set name offset from operand} mov (xs)+ nmofs(xr)
        MOV  DWORD PTR (4*nmofs)[],EAX
        LEA
        MOV  EAX,DWORD PTR [] #set name base from operand} mov (xs)+ nmbas(xr)
        MOV  DWORD PTR (4*nmbas)[],EAX
        LEA
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      negation
#
#      initial entry
#
        .balign 2           #entry point} ent
        NOP
o_nta:
        MOV                 #load new failure offset} lcw wa
        ADD  EBP,4
        LEA                 #stack old failure pointer} mov flptr -(xs)
        MOV  EAX,DWORD PTR flptr
        MOV  DWORD PTR [],EAX
        LEA                 #stack new failure offset} mov wa -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR flptr #set new failure pointer} mov xs flptr
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      entry after successful evaluation of operand
#
        .balign 2           #entry point} ent
        NOP
o_ntb:
        MOV  EAX,DWORD PTR (4*num02)[] #restore old failure pointer} mov num02(xs) flptr
        MOV  DWORD PTR flptr,EAX
        JMP  exfal          #and fail} brn exfal
#
#      entry for failure during operand evaluation
#
        .balign 2           #entry point} ent
        NOP
o_ntc:
        ADD                 #pop failure offset} ica xs
        MOV  EAX,DWORD PTR [] #restore old failure pointer} mov (xs)+ flptr
        MOV  DWORD PTR flptr,EAX
        LEA
        JMP  exnul          #exit giving null result} brn exnul
                            #} ejc
        .eject
#
#      use of undefined operator
#
        .balign 2           #entry point} ent
        NOP
o_oun:
        CALL ERR_0          #} erb 029 undefined operator referenced
        .byte 29
                            #} ejc
        .eject
#
#      binary dot (pattern assignment)
#
#      the pattern built by binary dot is a compound pattern.
#      see description at start of pattern match section for
#      details of the structure which is constructed.
#
        .balign 2           #entry point} ent
        NOP
o_pas:
        MOV                 #load pcode for p_pac node} mov =p_pac wb
        MOV                 #load name offset (parm2)} mov (xs)+ wc
        LEA
        MOV                 #load name base (parm1)} mov (xs)+ xr
        LEA
        CALL pbild          #build p_pac node} jsr pbild
        MOV                 #save ptr to node} mov xr xl
        MOV                 #load left operand} mov (xs) xr
        CALL gtpat          #convert to pattern} jsr gtpat
        .short ERR_-30-DFFNC #} err 030 pattern assignment left operand is not pattern
        MOV  DWORD PTR []   #save ptr to left operand pattern} mov xr (xs)
        MOV                 #set pcode for p_paa node} mov =p_paa wb
        CALL pbild          #build p_paa node} jsr pbild
        MOV  EAX,DWORD PTR [] #set left operand as p_paa successor} mov (xs)+ pthen(xr)
        MOV  DWORD PTR (4*pthen)[],EAX
        LEA
        CALL pconc          #concatenate to form final pattern} jsr pconc
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      pattern match (by name, for replacement)
#
        .balign 2           #entry point} ent
        NOP
o_pmn:
        XOR                 #set type code for match by name} zer wb
        JMP  match          #jump to routine to start match} brn match
                            #} ejc
        .eject
#
#      pattern match (statement)
#
#      o$pms is used in place of o$pmv when the pattern match
#      occurs at the outer (statement) level since in this
#      case the substring value need not be constructed.
#
        .balign 2           #entry point} ent
        NOP
o_pms:
        MOV                 #set flag for statement to match} mov =num02 wb
        JMP  match          #jump to routine to start match} brn match
                            #} ejc
        .eject
#
#      pattern match (by value)
#
        .balign 2           #entry point} ent
        NOP
o_pmv:
        MOV                 #set type code for value match} mov =num01 wb
        JMP  match          #jump to routine to start match} brn match
                            #} ejc
        .eject
#
#      pop top item on stack
#
        .balign 2           #entry point} ent
        NOP
o_pop:
        ADD                 #pop top stack entry} ica xs
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      terminate execution (code compiled for end statement)
#
        .balign 2           #entry point} ent
        NOP
o_stp:
        JMP  lend0          #jump to end circuit} brn lend0
                            #} ejc
        .eject
#
#      return name from expression
#      this entry points is used if the evaluation of an
#      expression, initiated by the evalx procedure, returns
#      a name. control is returned to the proper point in evalx.
#
        .balign 2           #entry point} ent
        NOP
o_rnm:
        JMP  evlx4          #return to evalx procedure} brn evlx4
                            #} ejc
        .eject
#
#      pattern replacement
#
#      when this routine gets control, the following stack
#      entries have been made (see end of match routine p$nth)
#
#                            subject name base
#                            subject name offset
#                            initial cursor value
#                            final cursor value
#                            subject string pointer
#      (xs) ---------------- replacement value
#
        .balign 2           #entry point} ent
        NOP
o_rpl:
        CALL gtstg          #convert replacement val to string} jsr gtstg
        .short ERR_-31-DFFNC #} err 031 pattern replacement right operand is not a string
#
#      get result length and allocate result scblk
#
        MOV                 #load subject string pointer} mov (xs) xl
        ADD                 #add subject string length} add sclen(xl) wa
        ADD                 #add starting cursor} add num02(xs) wa
        SUB                 #minus final cursor = total length} sub num01(xs) wa
#        OR                  #jump if result is null} bze wa orpl3  (Optimized)
        JZ   orpl3
        LEA                 #restack replacement string} mov xr -(xs)
        MOV  DWORD PTR []
        CALL alocs          #allocate scblk for result} jsr alocs
        MOV                 #get initial cursor (part 1 len)} mov num03(xs) wa
        MOV  DWORD PTR (4*num03)[] #stack result pointer} mov xr num03(xs)
        ADD                 #point to characters of result} psc xr
#
#      move part 1 (start of subject) to result
#
#        OR                  #jump if first part is null} bze wa orpl1  (Optimized)
        JZ   orpl1
        MOV                 #else point to subject string} mov num01(xs) xl
        ADD                 #point to subject string chars} plc xl
        SHRD EAX,ECX,1      #move first part to result} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
                            #} ejc
        .eject
#      pattern replacement (continued)
#
#      now move in replacement value
#
orpl1:  MOV                 #load replacement string, pop} mov (xs)+ xl
        LEA
        MOV                 #load length} mov sclen(xl) wa
        OR                  #jump if null replacement} bze wa orpl2
        JZ   orpl2
        ADD                 #else point to chars of replacement} plc xl
        SHRD EAX,ECX,1      #move in chars (part 2)} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
#
#      now move in remainder of string (part 3)
#
orpl2:  MOV                 #load subject string pointer, pop} mov (xs)+ xl
        LEA
        MOV                 #load final cursor, pop} mov (xs)+ wc
        LEA
        MOV                 #load subject string length} mov sclen(xl) wa
        SUB                 #minus final cursor = part 3 length} sub wc wa
#        OR                  #jump to assign if part 3 is null} bze wa oass0  (Optimized)
        JZ   oass0
        LEA                 #else point to last part of string} plc xl wc
        SHRD EAX,ECX,1      #move part 3 to result} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        JMP  oass0          #jump to perform assignment} brn oass0
#
#      here if result is null
#
orpl3:  ADD                 #pop subject str ptr, final cursor} add *num02 xs
        MOV  DWORD PTR [],offset nulls #set null result} mov =nulls (xs)
        JMP  oass0          #jump to assign null value} brn oass0
                            #} ejc
        .eject
#
#      return value from expression
#
#      this entry points is used if the evaluation of an
#      expression, initiated by the evalx procedure, returns
#      a value. control is returned to the proper point in evalx
#
        .balign 2           #entry point} ent
        NOP
o_rvl:
        JMP  evlx3          #return to evalx procedure} brn evlx3
                            #} ejc
        .eject
#
#      selection
#
#      initial entry
#
        .balign 2           #entry point} ent
        NOP
o_sla:
        MOV                 #load new failure offset} lcw wa
        ADD  EBP,4
        LEA                 #stack old failure pointer} mov flptr -(xs)
        MOV  EAX,DWORD PTR flptr
        MOV  DWORD PTR [],EAX
        LEA                 #stack new failure offset} mov wa -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR flptr #set new failure pointer} mov xs flptr
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      entry after successful evaluation of alternative
#
        .balign 2           #entry point} ent
        NOP
o_slb:
        MOV                 #load result} mov (xs)+ xr
        LEA
        ADD                 #pop fail offset} ica xs
        MOV  EAX,DWORD PTR [] #restore old failure pointer} mov (xs) flptr
        MOV  DWORD PTR flptr,EAX
        MOV  DWORD PTR []   #restack result} mov xr (xs)
        MOV                 #load new code offset} lcw wa
        ADD  EBP,4
        ADD                 #point to absolute code location} add r_cod wa
        MOV  EBP            #set new code pointer} lcp wa
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      entry at start of subsequent alternatives
#
        .balign 2           #entry point} ent
        NOP
o_slc:
        MOV                 #load new fail offset} lcw wa
        ADD  EBP,4
        MOV  DWORD PTR []   #store new fail offset} mov wa (xs)
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      entry at start of last alternative
#
        .balign 2           #entry point} ent
        NOP
o_sld:
        ADD                 #pop failure offset} ica xs
        MOV  EAX,DWORD PTR [] #restore old failure pointer} mov (xs)+ flptr
        MOV  DWORD PTR flptr,EAX
        LEA
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      binary minus (subtraction)
#
        .balign 2           #entry point} ent
        NOP
o_sub:
        CALL arith          #fetch arithmetic operands} jsr arith
        .short ERR_-32-DFFNC #} err 032 subtraction left operand is not numeric
        .short ERR_-33-DFFNC #} err 033 subtraction right operand is not numeric
        .short osub1-DFFNC  #jump if real operands} ppm osub1
#
#      here to subtract two integers
#
        SUB  EDX,DWORD PTR (4*icval)[] #subtract right operand from left} sbi icval(xl)
        JNO  exint          #return integer if no overflow} ino exint
        CALL ERR_0          #} erb 034 subtraction caused integer overflow
        .byte 34
#
#      here to subtract two reals
#
osub1:  LEA  EAX,DWORD PTR (4*rcval)[] #subtract right operand from left} sbr rcval(xl)
        CALL sbr_
        CALL OVR_           #return real if no overflow} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 264 subtraction caused real overflow
        .byte 8
                            #} ejc
        .eject
#
#      dummy operator to return control to trxeq procedure
#
        .balign 2           #entry point} ent
        NOP
o_txr:
        JMP  trxq1          #jump into trxeq procedure} brn trxq1
                            #} ejc
        .eject
#
#      unexpected failure
#
#      note that if a setexit trap is operating then
#      transfer to system label continue
#      will result in looping here.  difficult to avoid except
#      with a considerable overhead which is not worthwhile or
#      else by a technique such as setting kverl to zero.
#
        .balign 2           #entry point} ent
        NOP
o_unf:
        CALL ERR_0          #} erb 035 unexpected failure in -nofail mode
        .byte 35
                            #} ttl s p i t b o l -- block action routines
        .sbttl "s p i t b o l -- block action routines"
#
#      the first word of every block in dynamic storage and the
#      vrget, vrsto and vrtra fields of a vrblk contain a
#      pointer to an entry point in the program. all such entry
#      points are in the following section except those for
#      pattern blocks which are in the pattern matching segment
#      later on (labels of the form p$xxx), and dope vectors
#      (d$xxx) which are in the dope vector section following
#      the pattern routines (dope vectors are used for cmblks).
#
#      the entry points in this section have labels of the
#      form b$xxy where xx is the two character block type for
#      the corresponding block and y is any letter.
#
#      in some cases, the pointers serve no other purpose than
#      to identify the block type. in this case the routine
#      is never executed and thus no code is assembled.
#
#      for each of these entry points corresponding to a block
#      an entry point identification is assembled (bl$xx).
#
#      the exact entry conditions depend on the manner in
#      which the routine is accessed and are documented with
#      the individual routines as required.
#
#      the order of these routines is alphabetical with the
#      following exceptions.
#
#      the routines for seblk and exblk entries occur first so
#      that expressions can be quickly identified from the fact
#      that their routines lie before the symbol b$e$$.
#
#      these are immediately followed by the routine for a trblk
#      so that the test against the symbol b$t$$ checks for
#      trapped values or expression values (see procedure evalp)
#
#      the pattern routines lie after this section so that
#      patterns are identified with routines starting at or
#      after the initial instruction in these routines (p$aaa).
#
#      the symbol b$aaa defines the first location for block
#      routines and the symbol p$yyy (at the end of the pattern
#      match routines section) defines the last such entry point
#
        .balign 2           #entry point of first block routine} ent bl__i
        .byte bl__i
b_aaa:
                            #} ejc
        .eject
#
#      exblk
#
#      the routine for an exblk loads the expression onto
#      the stack as a value.
#
#      (xr)                  pointer to exblk
#
        .balign 2           #entry point (exblk)} ent bl_ex
        .byte bl_ex
b_exl:
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      seblk
#
#      the routine for seblk is accessed from the generated
#      code to load the expression value onto the stack.
#
        .balign 2           #entry point (seblk)} ent bl_se
        .byte bl_se
b_sel:
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      define symbol which marks end of entries for expressions
#
        .balign 2           #entry point} ent bl__i
        .byte bl__i
b_e__:
                            #} ejc
        .eject
#
#      trblk
#
#      the routine for a trblk is never executed
#
        .balign 2           #entry point (trblk)} ent bl_tr
        .byte bl_tr
b_trt:
#
#      define symbol marking end of trap and expression blocks
#
        .balign 2           #end of trblk,seblk,exblk entries} ent bl__i
        .byte bl__i
b_t__:
                            #} ejc
        .eject
#
#      arblk
#
#      the routine for arblk is never executed
#
        .balign 2           #entry point (arblk)} ent bl_ar
        .byte bl_ar
b_art:
                            #} ejc
        .eject
#
#      bcblk
#
#      the routine for a bcblk is never executed
#
#      (xr)                  pointer to bcblk
#
        .balign 2           #entry point (bcblk)} ent bl_bc
        .byte bl_bc
b_bct:
                            #} ejc
        .eject
#
#      bfblk
#
#      the routine for a bfblk is never executed
#
#      (xr)                  pointer to bfblk
#
        .balign 2           #entry point (bfblk)} ent bl_bf
        .byte bl_bf
b_bft:
                            #} ejc
        .eject
#
#      ccblk
#
#      the routine for ccblk is never entered
#
        .balign 2           #entry point (ccblk)} ent bl_cc
        .byte bl_cc
b_cct:
                            #} ejc
        .eject
#
#      cdblk
#
#      the cdblk routines are executed from the generated code.
#      there are two cases depending on the form of cdfal.
#
#      entry for complex failure code at cdfal
#
#      (xr)                  pointer to cdblk
#
        .balign 2           #entry point (cdblk)} ent bl_cd
        .byte bl_cd
b_cdc:
bcdc0:  MOV                 #pop garbage off stack} mov flptr xs
        MOV  EAX,DWORD PTR (4*cdfal)[] #set failure offset} mov cdfal(xr) (xs)
        MOV  DWORD PTR [],EAX
        JMP  stmgo          #enter stmt} brn stmgo
                            #} ejc
        .eject
#
#      cdblk (continued)
#
#      entry for simple failure code at cdfal
#
#      (xr)                  pointer to cdblk
#
        .balign 2           #entry point (cdblk)} ent bl_cd
        .byte bl_cd
b_cds:
bcds0:  MOV                 #pop garbage off stack} mov flptr xs
        MOV  DWORD PTR [],4*cdfal #set failure offset} mov *cdfal (xs)
        JMP  stmgo          #enter stmt} brn stmgo
                            #} ejc
        .eject
#
#      cmblk
#
#      the routine for a cmblk is never executed
#
        .balign 2           #entry point (cmblk)} ent bl_cm
        .byte bl_cm
b_cmt:
                            #} ejc
        .eject
#
#      ctblk
#
#      the routine for a ctblk is never executed
#
        .balign 2           #entry point (ctblk)} ent bl_ct
        .byte bl_ct
b_ctt:
                            #} ejc
        .eject
#
#      dfblk
#
#      the routine for a dfblk is accessed from the o$fnc entry
#      to call a datatype function and build a pdblk.
#
#      (xl)                  pointer to dfblk
#
        .balign 2           #entry point} ent bl_df
        .byte bl_df
b_dfc:
        MOV                 #load length of pdblk} mov dfpdl(xl) wa
        CALL alloc          #allocate pdblk} jsr alloc
        MOV  DWORD PTR [],offset b_pdt #store type word} mov =b_pdt (xr)
        MOV  DWORD PTR (4*pddfp)[] #store dfblk pointer} mov xl pddfp(xr)
        MOV                 #save pointer to pdblk} mov xr wc
        ADD                 #point past pdblk} add wa xr
        MOV                 #set to count fields} lct wa fargs(xl)
#
#      loop to acquire field values from stack
#
bdfc1:  LEA                 #move a field value} mov (xs)+ -(xr)
        MOV  EAX,DWORD PTR []
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop till all moved} bct wa bdfc1
        JNZ  bdfc1
        MOV                 #recall pointer to pdblk} mov wc xr
        JMP  exsid          #exit setting id field} brn exsid
                            #} ejc
        .eject
#
#      efblk
#
#      the routine for an efblk is passed control form the o$fnc
#      entry to call an external function.
#
#      (xl)                  pointer to efblk
#
        .balign 2           #entry point (efblk)} ent bl_ef
        .byte bl_ef
b_efc:
        MOV                 #load number of arguments} mov fargs(xl) wc
        SAL                 #convert to offset} wtb wc
        LEA                 #save pointer to efblk} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #copy pointer to arguments} mov xs xt
#
#      loop to convert arguments
#
befc1:  ADD                 #point to next entry} ica xt
        MOV                 #load pointer to efblk} mov (xs) xr
        SUB                 #decrement eftar offset} dca wc
        ADD                 #point to next eftar entry} add wc xr
        MOV                 #load eftar entry} mov eftar(xr) xr
        JMP  DWORD PTR L0002[*4] #switch on type} bsw xr 5
        DSeg_
L0002:
        .long befc7         #no conversion needed} iff 0 befc7
        .long befc2         #string} iff 1 befc2
        .long befc3         #integer} iff 2 befc3
        .long befc4         #real} iff 3 befc4
        .long beff1         #file} iff 4 beff1
        DSegEnd_            #end of switch on type} esw
        CSeg_
#
#      here to convert to file
#
beff1:  LEA                 #save entry pointer} mov xt -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR befof #save offset} mov wc befof
        LEA                 #stack arg pointer} mov (xt) -(xs)
        MOV  EAX,DWORD PTR []
        MOV  DWORD PTR [],EAX
        CALL iofcb          #convert to fcb} jsr iofcb
        .short ERR_-298-DFFNC #} err 298 external function argument is not file
        .short ERR_-298-DFFNC #} err 298 external function argument is not file
        .short ERR_-298-DFFNC #} err 298 external function argument is not file
        MOV                 #point to fcb} mov wa xr
        MOV                 #reload entry pointer} mov (xs)+ xt
        LEA
        JMP  befc5          #jump to merge} brn befc5
#
#      here to convert to string
#
befc2:  LEA                 #stack arg ptr} mov (xt) -(xs)
        MOV  EAX,DWORD PTR []
        MOV  DWORD PTR [],EAX
        CALL gtstg          #convert argument to string} jsr gtstg
        .short ERR_-39-DFFNC #} err 039 external function argument is not a string
        JMP  befc6          #jump to merge} brn befc6
                            #} ejc
        .eject
#
#      efblk (continued)
#
#      here to convert an integer
#
befc3:  MOV                 #load next argument} mov (xt) xr
        MOV  DWORD PTR befof #save offset} mov wc befof
        CALL gtint          #convert to integer} jsr gtint
        .short ERR_-40-DFFNC #} err 040 external function argument is not integer
        JMP  befc5          #merge with real case} brn befc5
#
#      here to convert a real
#
befc4:  MOV                 #load next argument} mov (xt) xr
        MOV  DWORD PTR befof #save offset} mov wc befof
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-265-DFFNC #} err 265 external function argument is not real
#
#      integer case merges here
#
befc5:  MOV                 #restore offset} mov befof wc
#
#      string merges here
#
befc6:  MOV  DWORD PTR []   #store converted result} mov xr (xt)
#
#      no conversion merges here
#
befc7:  OR                  #loop back if more to go} bnz wc befc1
        JNZ  befc1
#
#      here after converting all the arguments
#
        MOV                 #restore efblk pointer} mov (xs)+ xl
        LEA
        MOV                 #get number of args} mov fargs(xl) wa
        CALL sysex          #call routine to call external fnc} jsr sysex
        .short exfal-DFFNC  #fail if failure} ppm exfal
        .short ERR_-327-DFFNC #} err 327 calling external function - not found
        .short ERR_-326-DFFNC #} err 326 calling external function - bad argument type
        SAL                 #convert number of args to bytes} wtb wa
        ADD                 #remove arguments from stack} add wa xs
                            #} ejc
        .eject
#
#      efblk (continued)
#
#      return here with result in xr
#
#      first defend against non-standard null string returned
#
        MOV                 #get result type id} mov efrsl(xl) wb
        OR                  #branch if not unconverted} bnz wb befa8
        JNZ  befa8
        CMP  DWORD PTR [],offset b_scl #jump if not a string} bne (xr) =b_scl befc8
             befc8
        CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #return null if null} bze sclen(xr) exnul
        JZ   exnul
#
#      here if converted result to check for null string
#
befa8:  CMP                 #jump if not a string} bne wb =num01 befc8
             befc8
        CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #return null if null} bze sclen(xr) exnul
        JZ   exnul
#
#      return if result is in dynamic storage
#
befc8:  CMP                 #jump if not in dynamic storage} blt xr dnamb befc9
             befc9
        CMP                 #return result if already dynamic} ble xr dnamp exixr
             exixr
#
#      here we copy a result into the dynamic region
#
befc9:  MOV                 #get possible type word} mov (xr) wa
        OR                  #jump if unconverted result} bze wb bef11
        JZ   bef11
        MOV                 #string} mov =b_scl wa
        CMP                 #yes jump} beq wb =num01 bef10
             bef10
        MOV                 #integer} mov =b_icl wa
        CMP                 #yes jump} beq wb =num02 bef10
             bef10
        MOV                 #real} mov =b_rcl wa
#
#      store type word in result
#
bef10:  MOV  DWORD PTR []   #stored before copying to dynamic} mov wa (xr)
#
#      merge for unconverted result
#
bef11:  CMP  DWORD PTR [],offset b_scl #branch if string result} beq (xr) =b_scl bef12
             bef12
        CALL blkln          #get length of block} jsr blkln
        MOV                 #copy address of old block} mov xr xl
        CALL alloc          #allocate dynamic block same size} jsr alloc
        LEA                 #set pointer to new block as result} mov xr -(xs)
        MOV  DWORD PTR []
        SHR  ECX,2          #copy old block to dynamic block} mvw
        REP  MOVSD
        XOR                 #clear garbage value} zer xl
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      here to return a string result that was not in dynamic.
#      cannot use the simple word copy above because it will not
#      guarantee zero padding in the last word.
#
bef12:  MOV                 #save source string pointer} mov xr xl
        MOV                 #fetch string length} mov sclen(xr) wa
        OR                  #return null string if length zero} bze wa exnul
        JZ   exnul
        CALL alocs          #allocate space for string} jsr alocs
        LEA                 #save as result pointer} mov xr -(xs)
        MOV  DWORD PTR []
        ADD                 #prepare to store chars of result} psc xr
        ADD                 #point to chars in source string} plc xl
        MOV                 #number of characters to copy} mov wc wa
        SHRD EAX,ECX,1      #move characters to result string} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        XOR                 #clear garbage value} zer xl
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      evblk
#
#      the routine for an evblk is never executed
#
        .balign 2           #entry point (evblk)} ent bl_ev
        .byte bl_ev
b_evt:
                            #} ejc
        .eject
#
#      ffblk
#
#      the routine for an ffblk is executed from the o$fnc entry
#      to call a field function and extract a field value/name.
#
#      (xl)                  pointer to ffblk
#
        .balign 2           #entry point (ffblk)} ent bl_ff
        .byte bl_ff
b_ffc:
        MOV                 #copy ffblk pointer} mov xl xr
        MOV                 #load next code word} lcw wc
        ADD  EBP,4
        MOV                 #load pdblk pointer} mov (xs) xl
        CMP  DWORD PTR [],offset b_pdt #jump if not pdblk at all} bne (xl) =b_pdt bffc2
             bffc2
        MOV                 #load dfblk pointer from pdblk} mov pddfp(xl) wa
#
#      loop to find correct ffblk for this pdblk
#
bffc1:  CMP                 #jump if this is the correct ffblk} beq wa ffdfp(xr) bffc3
             bffc3
        MOV                 #else link to next ffblk on chain} mov ffnxt(xr) xr
        OR                  #loop back if another entry to check} bnz xr bffc1
        JNZ  bffc1
#
#      here for bad argument
#
bffc2:  CALL ERR_0          #} erb 041 field function argument is wrong datatype
        .byte 41
                            #} ejc
        .eject
#
#      ffblk (continued)
#
#      here after locating correct ffblk
#
bffc3:  MOV                 #load field offset} mov ffofs(xr) wa
        CMP                 #jump if called by name} beq wc =ofne_ bffc5
             bffc5
        ADD                 #else point to value field} add wa xl
        MOV                 #load value} mov (xl) xr
        CMP  DWORD PTR [],offset b_trt #jump if not trapped} bne (xr) =b_trt bffc4
             bffc4
        SUB                 #else restore name base,offset} sub wa xl
        MOV  DWORD PTR []   #save next code word over pdblk ptr} mov wc (xs)
        CALL acess          #access value} jsr acess
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        MOV                 #restore next code word} mov (xs) wc
#
#      here after getting value in (xr), xl is garbage
#
bffc4:  MOV  DWORD PTR []   #store value on stack (over pdblk)} mov xr (xs)
        MOV                 #copy next code word} mov wc xr
        MOV                 #load entry address} mov (xr) xl
        JMP                 #jump to routine for next code word} bri xl
#
#      here if called by name
#
bffc5:  LEA                 #store name offset (base is set)} mov wa -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      icblk
#
#      the routine for icblk is executed from the generated
#      code to load an integer value onto the stack.
#
#      (xr)                  pointer to icblk
#
        .balign 2           #entry point (icblk)} ent bl_ic
        .byte bl_ic
b_icl:
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      kvblk
#
#      the routine for a kvblk is never executed.
#
        .balign 2           #entry point (kvblk)} ent bl_kv
        .byte bl_kv
b_kvt:
                            #} ejc
        .eject
#
#      nmblk
#
#      the routine for a nmblk is executed from the generated
#      code for the case of loading a name onto the stack
#      where the name is that of a natural variable which can
#      be preevaluated at compile time.
#
#      (xr)                  pointer to nmblk
#
        .balign 2           #entry point (nmblk)} ent bl_nm
        .byte bl_nm
b_nml:
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      pdblk
#
#      the routine for a pdblk is never executed
#
        .balign 2           #entry point (pdblk)} ent bl_pd
        .byte bl_pd
b_pdt:
                            #} ejc
        .eject
#
#      pfblk
#
#      the routine for a pfblk is executed from the entry o$fnc
#      to call a program defined function.
#
#      (xl)                  pointer to pfblk
#
#      the following stack entries are made before passing
#      control to the program defined function.
#
#                            saved value of first argument
#                            .
#                            saved value of last argument
#                            saved value of first local
#                            .
#                            saved value of last local
#                            saved value of function name
#                            saved code block ptr (r$cod)
#                            saved code pointer (-r$cod)
#                            saved value of flprt
#                            saved value of flptr
#                            pointer to pfblk
#      flptr --------------- zero (to be overwritten with offs)
#
        .balign 2           #entry point (pfblk)} ent bl_pf
        .byte bl_pf
b_pfc:
        MOV  DWORD PTR bpfpf #save pfblk ptr (need not be reloc)} mov xl bpfpf
        MOV                 #copy for the moment} mov xl xr
        MOV                 #point to vrblk for function} mov pfvbl(xr) xl
#
#      loop to find old value of function
#
bpf01:  MOV                 #save pointer} mov xl wb
        MOV                 #load value} mov vrval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop if trblk} beq (xl) =b_trt bpf01
             bpf01
#
#      set value to null and save old function value
#
        MOV  DWORD PTR bpfsv #save old value} mov xl bpfsv
        MOV                 #point back to block with value} mov wb xl
        MOV  DWORD PTR (4*vrval)[],offset nulls #set value to null} mov =nulls vrval(xl)
        MOV                 #load number of arguments} mov fargs(xr) wa
        ADD                 #point to pfarg entries} add *pfarg xr
#        OR                  #jump if no arguments} bze wa bpf04  (Optimized)
        JZ   bpf04
        MOV                 #ptr to last arg} mov xs xt
        SAL                 #convert no. of args to bytes offset} wtb wa
        ADD                 #point before first arg} add wa xt
        MOV  DWORD PTR bpfxt #remember arg pointer} mov xt bpfxt
                            #} ejc
        .eject
#
#      pfblk (continued)
#
#      loop to save old argument values and set new ones
#
bpf02:  MOV                 #load vrblk ptr for next argument} mov (xr)+ xl
        LEA
#
#      loop through possible trblk chain to find value
#
bpf03:  MOV                 #save pointer} mov xl wc
        MOV                 #load next value} mov vrval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop back if trblk} beq (xl) =b_trt bpf03
             bpf03
#
#      save old value and get new value
#
        MOV                 #keep old value} mov xl wa
        MOV                 #point before next stacked arg} mov bpfxt xt
        LEA                 #load argument (new value)} mov -(xt) wb
        MOV
        MOV  DWORD PTR []   #save old value} mov wa (xt)
        MOV  DWORD PTR bpfxt #keep arg ptr for next time} mov xt bpfxt
        MOV                 #point back to block with value} mov wc xl
        MOV  DWORD PTR (4*vrval)[] #set new value} mov wb vrval(xl)
        CMP                 #loop if not all done} bne xs bpfxt bpf02
             bpf02
#
#      now process locals
#
bpf04:  MOV                 #restore pfblk pointer} mov bpfpf xl
        MOV                 #load number of locals} mov pfnlo(xl) wa
        OR                  #jump if no locals} bze wa bpf07
        JZ   bpf07
        MOV                 #get null constant} mov =nulls wb
#
#      loop to process locals
#
bpf05:  MOV                 #load vrblk ptr for next local} mov (xr)+ xl
        LEA
#
#      loop through possible trblk chain to find value
#
bpf06:  MOV                 #save pointer} mov xl wc
        MOV                 #load next value} mov vrval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop back if trblk} beq (xl) =b_trt bpf06
             bpf06
#
#      save old value and set null as new value
#
        LEA                 #stack old value} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #point back to block with value} mov wc xl
        MOV  DWORD PTR (4*vrval)[] #set null as new value} mov wb vrval(xl)
        DEC                 #loop till all locals processed} bct wa bpf05
        JNZ  bpf05
                            #} ejc
        .eject
#
#      pfblk (continued)
#
#      here after processing arguments and locals
#
bpf07:  XOR                 #zero reg xr in case} zer xr
        CMP  DWORD PTR DWORD PTR kvpfl,0 #skip if profiling is off} bze kvpfl bpf7c
        JZ   bpf7c
        CMP  DWORD PTR kvpfl,num02 #branch on type of profile} beq kvpfl =num02 bpf7a
             bpf7a
#
#      here if &profile = 1
#
        CALL systm          #get current time} jsr systm
        MOV  DWORD PTR pfetm,EDX #save for a sec} sti pfetm
        SUB  EDX,DWORD PTR pfstm #find time used by caller} sbi pfstm
        CALL icbld          #build into an icblk} jsr icbld
        MOV  EDX,DWORD PTR pfetm #reload current time} ldi pfetm
        JMP  bpf7b          #merge} brn bpf7b
#
#       here if &profile = 2
#
bpf7a:  MOV  EDX,DWORD PTR pfstm #get start time of calling stmt} ldi pfstm
        CALL icbld          #assemble an icblk round it} jsr icbld
        CALL systm          #get now time} jsr systm
#
#      both types of profile merge here
#
bpf7b:  MOV  DWORD PTR pfstm,EDX #set start time of 1st func stmt} sti pfstm
        MOV  DWORD PTR pffnc,ESP #flag function entry} mnz pffnc
#
#      no profiling merges here
#
bpf7c:  LEA                 #stack icblk ptr (or zero)} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #load old code block pointer} mov r_cod wa
        MOV                 #get code pointer} scp wb
        SUB                 #make code pointer into offset} sub wa wb
        MOV                 #recall pfblk pointer} mov bpfpf xl
        LEA                 #stack old value of function name} mov bpfsv -(xs)
        MOV  EAX,DWORD PTR bpfsv
        MOV  DWORD PTR [],EAX
        LEA                 #stack code block pointer} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #stack code offset} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack old flprt} mov flprt -(xs)
        MOV  EAX,DWORD PTR flprt
        MOV  DWORD PTR [],EAX
        LEA                 #stack old failure pointer} mov flptr -(xs)
        MOV  EAX,DWORD PTR flptr
        MOV  DWORD PTR [],EAX
        LEA                 #stack pointer to pfblk} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #dummy zero entry for fail return} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        MOV  DWORD PTR flptr #set new fail return value} mov xs flptr
        MOV  DWORD PTR flprt #set new flprt} mov xs flprt
        MOV                 #load trace value} mov kvtra wa
        ADD                 #add ftrace value} add kvftr wa
#        OR                  #jump if tracing possible} bnz wa bpf09  (Optimized)
        JNZ  bpf09
        INC  DWORD PTR kvfnc #else bump fnclevel} icv kvfnc
#
#      here to actually jump to function
#
bpf08:  MOV                 #point to vrblk of entry label} mov pfcod(xl) xr
        MOV                 #point to target code} mov vrlbl(xr) xr
        CMP                 #test for undefined label} beq xr =stndl bpf17
             bpf17
        CMP  DWORD PTR [],offset b_trt #jump if not trapped} bne (xr) =b_trt bpf8a
             bpf8a
        MOV                 #else load ptr to real label code} mov trlbl(xr) xr
bpf8a:  JMP  DWORD PTR []   #off to execute function} bri (xr)
#
#      here if tracing is possible
#
bpf09:  MOV                 #load possible call trace trblk} mov pfctr(xl) xr
        MOV                 #load vrblk pointer for function} mov pfvbl(xl) xl
        MOV                 #set name offset for variable} mov *vrval wa
        CMP  DWORD PTR DWORD PTR kvtra,0 #jump if trace mode is off} bze kvtra bpf10
        JZ   bpf10
        OR                  #or if there is no call trace} bze xr bpf10
        JZ   bpf10
#
#      here if call traced
#
        DEC  DWORD PTR kvtra #decrement trace count} dcv kvtra
        CMP  DWORD PTR DWORD PTR (4*trfnc)[],0 #jump if print trace} bze trfnc(xr) bpf11
        JZ   bpf11
        CALL trxeq          #execute function type trace} jsr trxeq
                            #} ejc
        .eject
#
#      pfblk (continued)
#
#      here to test for ftrace trace
#
bpf10:  CMP  DWORD PTR DWORD PTR kvftr,0 #jump if ftrace is off} bze kvftr bpf16
        JZ   bpf16
        DEC  DWORD PTR kvftr #else decrement ftrace} dcv kvftr
#
#      here for print trace
#
bpf11:  CALL prtsn          #print statement number} jsr prtsn
        CALL prtnm          #print function name} jsr prtnm
        MOV                 #load left paren} mov =ch_pp wa
        CALL prtch          #print left paren} jsr prtch
        MOV                 #recover pfblk pointer} mov num01(xs) xl
        CMP  DWORD PTR DWORD PTR (4*fargs)[],0 #skip if no arguments} bze fargs(xl) bpf15
        JZ   bpf15
        XOR                 #else set argument counter} zer wb
        JMP  bpf13          #jump into loop} brn bpf13
#
#      loop to print argument values
#
bpf12:  MOV                 #load comma} mov =ch_cm wa
        CALL prtch          #print to separate from last arg} jsr prtch
#
#      merge here first time (no comma required)
#
bpf13:  MOV  DWORD PTR []   #save arg ctr (over failoffs is ok)} mov wb (xs)
        SAL                 #convert to byte offset} wtb wb
        ADD                 #point to next argument pointer} add wb xl
        MOV                 #load next argument vrblk ptr} mov pfarg(xl) xr
        SUB                 #restore pfblk pointer} sub wb xl
        MOV                 #load next value} mov vrval(xr) xr
        CALL prtvl          #print argument value} jsr prtvl
                            #} ejc
        .eject
#
#      here after dealing with one argument
#
        MOV                 #restore argument counter} mov (xs) wb
        INC                 #increment argument counter} icv wb
        CMP                 #loop if more to print} blt wb fargs(xl) bpf12
             bpf12
#
#      merge here in no args case to print paren
#
bpf15:  MOV                 #load right paren} mov =ch_rp wa
        CALL prtch          #print to terminate output} jsr prtch
        CALL prtnl          #terminate print line} jsr prtnl
#
#      merge here to exit with test for fnclevel trace
#
bpf16:  INC  DWORD PTR kvfnc #increment fnclevel} icv kvfnc
        MOV                 #load ptr to possible trblk} mov r_fnc xl
        CALL ktrex          #call keyword trace routine} jsr ktrex
#
#      call function after trace tests complete
#
        MOV                 #restore pfblk pointer} mov num01(xs) xl
        JMP  bpf08          #jump back to execute function} brn bpf08
#
#      here if calling a function whose entry label is undefined
#
bpf17:  MOV  EAX,DWORD PTR (4*num02)[] #reset so exfal can return to evalx} mov num02(xs) flptr
        MOV  DWORD PTR flptr,EAX
        CALL ERR_1          #} erb 286 function call to undefined entry label
        .byte 30
                            #} ejc
        .eject
#
#      rcblk
#
#      the routine for an rcblk is executed from the generated
#      code to load a real value onto the stack.
#
#      (xr)                  pointer to rcblk
#
        .balign 2           #entry point (rcblk)} ent bl_rc
        .byte bl_rc
b_rcl:
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      scblk
#
#      the routine for an scblk is executed from the generated
#      code to load a string value onto the stack.
#
#      (xr)                  pointer to scblk
#
        .balign 2           #entry point (scblk)} ent bl_sc
        .byte bl_sc
b_scl:
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      tbblk
#
#      the routine for a tbblk is never executed
#
        .balign 2           #entry point (tbblk)} ent bl_tb
        .byte bl_tb
b_tbt:
                            #} ejc
        .eject
#
#      teblk
#
#      the routine for a teblk is never executed
#
        .balign 2           #entry point (teblk)} ent bl_te
        .byte bl_te
b_tet:
                            #} ejc
        .eject
#
#      vcblk
#
#      the routine for a vcblk is never executed
#
        .balign 2           #entry point (vcblk)} ent bl_vc
        .byte bl_vc
b_vct:
                            #} ejc
        .eject
#
#      vrblk
#
#      the vrblk routines are executed from the generated code.
#      there are six entries for vrblk covering various cases
#
        .balign 2           #mark start of vrblk entry points} ent bl__i
        .byte bl__i
b_vr_:
#
#      entry for vrget (trapped case). this routine is called
#      from the generated code to load the value of a variable.
#      this entry point is used if an access trace or input
#      association is currently active.
#
#      (xr)                  pointer to vrget field of vrblk
#
        .balign 2           #entry point} ent bl__i
        .byte bl__i
b_vra:
        MOV                 #copy name base (vrget = 0)} mov xr xl
        MOV                 #set name offset} mov *vrval wa
        CALL acess          #access value} jsr acess
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrsto (error case. this routine is called from
#      the executed code for an attempt to modify the value
#      of a protected (pattern valued) natural variable.
#
        .balign 2           #entry point} ent
        NOP
b_vre:
        CALL ERR_0          #} erb 042 attempt to change value of protected variable
        .byte 42
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrtra (untrapped case). this routine is called
#      from the executed code to transfer to a label.
#
#      (xr)                  pointer to vrtra field of vrblk
#
        .balign 2           #entry point} ent
        NOP
b_vrg:
        MOV                 #load code pointer} mov vrlbo(xr) xr
        MOV                 #load entry address} mov (xr) xl
        JMP                 #jump to routine for next code word} bri xl
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrget (untrapped case). this routine is called
#      from the generated code to load the value of a variable.
#
#      (xr)                  points to vrget field of vrblk
#
        .balign 2           #entry point} ent
        NOP
b_vrl:
        LEA                 #load value onto stack (vrget = 0)} mov vrval(xr) -(xs)
        MOV  EAX,DWORD PTR (4*vrval)[]
        MOV  DWORD PTR [],EAX
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrsto (untrapped case). this routine is called
#      from the generated code to store the value of a variable.
#
#      (xr)                  pointer to vrsto field of vrblk
#
        .balign 2           #entry point} ent
        NOP
b_vrs:
        MOV  EAX,DWORD PTR [] #store value, leave on stack} mov (xs) vrvlo(xr)
        MOV  DWORD PTR (4*vrvlo)[],EAX
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      vrtra (trapped case). this routine is called from the
#      generated code to transfer to a label when a label
#      trace is currently active.
#
        .balign 2           #entry point} ent
        NOP
b_vrt:
        SUB                 #point back to start of vrblk} sub *vrtra xr
        MOV                 #copy vrblk pointer} mov xr xl
        MOV                 #set name offset} mov *vrval wa
        MOV                 #load pointer to trblk} mov vrlbl(xl) xr
        CMP  DWORD PTR DWORD PTR kvtra,0 #jump if trace is off} bze kvtra bvrt2
        JZ   bvrt2
        DEC  DWORD PTR kvtra #else decrement trace count} dcv kvtra
        CMP  DWORD PTR DWORD PTR (4*trfnc)[],0 #jump if print trace case} bze trfnc(xr) bvrt1
        JZ   bvrt1
        CALL trxeq          #else execute full trace} jsr trxeq
        JMP  bvrt2          #merge to jump to label} brn bvrt2
#
#      here for print trace -- print colon ( label name )
#
bvrt1:  CALL prtsn          #print statement number} jsr prtsn
        MOV                 #copy vrblk pointer} mov xl xr
        MOV                 #colon} mov =ch_cl wa
        CALL prtch          #print it} jsr prtch
        MOV                 #left paren} mov =ch_pp wa
        CALL prtch          #print it} jsr prtch
        CALL prtvn          #print label name} jsr prtvn
        MOV                 #right paren} mov =ch_rp wa
        CALL prtch          #print it} jsr prtch
        CALL prtnl          #terminate line} jsr prtnl
        MOV                 #point back to trblk} mov vrlbl(xl) xr
#
#      merge here to jump to label
#
bvrt2:  MOV                 #load pointer to actual code} mov trlbl(xr) xr
        JMP  DWORD PTR []   #execute statement at label} bri (xr)
                            #} ejc
        .eject
#
#      vrblk (continued)
#
#      entry for vrsto (trapped case). this routine is called
#      from the generated code to store the value of a variable.
#      this entry is used when a value trace or output
#      association is currently active.
#
#      (xr)                  pointer to vrsto field of vrblk
#
        .balign 2           #entry point} ent
        NOP
b_vrv:
        MOV                 #load value (leave copy on stack)} mov (xs) wb
        SUB                 #point to vrblk} sub *vrsto xr
        MOV                 #copy vrblk pointer} mov xr xl
        MOV                 #set offset} mov *vrval wa
        CALL asign          #call assignment routine} jsr asign
        .short exfal-DFFNC  #fail if assignment fails} ppm exfal
        MOV                 #else get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      xnblk
#
#      the routine for an xnblk is never executed
#
        .balign 2           #entry point (xnblk)} ent bl_xn
        .byte bl_xn
b_xnt:
                            #} ejc
        .eject
#
#      xrblk
#
#      the routine for an xrblk is never executed
#
        .balign 2           #entry point (xrblk)} ent bl_xr
        .byte bl_xr
b_xrt:
#
#      mark entry address past last block action routine
#
        .balign 2           #last block routine entry point} ent bl__i
        .byte bl__i
b_yyy:
                            #} ttl s p i t b o l -- pattern matching routines
        .sbttl "s p i t b o l -- pattern matching routines"
#
#      the following section consists of the pattern matching
#      routines. all pattern nodes contain a pointer (pcode)
#      to one of the routines in this section (p$xxx).
#
#      note that this section follows the b$xxx routines to
#      enable a fast test for the pattern datatype.
#
        .balign 2           #entry to mark first pattern} ent bl__i
        .byte bl__i
p_aaa:
#
#
#      the entry conditions to the match routine are as follows
#      (see o$pmn, o$pmv, o$pms and procedure match).
#
#      stack contents.
#
#                            name base (o$pmn only)
#                            name offset (o$pmn only)
#                            type (0-o$pmn, 1-o$pmv, 2-o$pms)
#      pmhbs --------------- initial cursor (zero)
#                            initial node pointer
#      xs ------------------ =ndabo (anchored), =nduna (unanch)
#
#      register values.
#
#           (xs)             set as shown in stack diagram
#           (xr)             pointer to initial pattern node
#           (wb)             initial cursor (zero)
#
#      global pattern values
#
#           r$pms            pointer to subject string scblk
#           pmssl            length of subject string in chars
#           pmdfl            dot flag, initially zero
#           pmhbs            set as shown in stack diagram
#
#      control is passed by branching through the pcode
#      field of the initial pattern node (bri (xr)).
                            #} ejc
        .eject
#
#      description of algorithm
#
#      a pattern structure is represented as a linked graph
#      of nodes with the following structure.
#
#           +------------------------------------+
#           i                pcode               i
#           +------------------------------------+
#           i                pthen               i
#           +------------------------------------+
#           i                parm1               i
#           +------------------------------------+
#           i                parm2               i
#           +------------------------------------+
#
#      pcode is a pointer to the routine which will perform
#      the match of this particular node type.
#
#      pthen is a pointer to the successor node. i.e. the node
#      to be matched if the attempt to match this node succeeds.
#      if this is the last node of the pattern pthen points
#      to the dummy node ndnth which initiates pattern exit.
#
#      parm1, parm2 are parameters whose use varies with the
#      particular node. they are only present if required.
#
#      alternatives are handled with the special alternative
#      node whose parameter points to the node to be matched
#      if there is a failure on the successor path.
#
#      the following example illustrates the manner in which
#      the structure is built up. the pattern is
#
#      (a / b / c) (d / e)   where / is alternation
#
#      in the diagram, the node marked + represents an
#      alternative node and the dotted line from a + node
#      represents the parameter pointer to the alternative.
#
#      +---+     +---+     +---+     +---+
#      i + i-----i a i-----i + i-----i d i-----
#      +---+     +---+  i  +---+     +---+
#        .              i    .
#        .              i    .
#      +---+     +---+  i  +---+
#      i + i-----i b i--i  i e i-----
#      +---+     +---+  i  +---+
#        .              i
#        .              i
#      +---+            i
#      i c i------------i
#      +---+
                            #} ejc
        .eject
#
#      during the match, the registers are used as follows.
#
#      (xr)                  points to the current node
#      (xl)                  scratch
#      (xs)                  main stack pointer
#      (wb)                  cursor (number of chars matched)
#      (wa,wc)               scratch
#
#      to keep track of alternatives, the main stack is used as
#      a history stack and contains two word entries.
#
#      word 1                saved cursor value
#      word 2                node to match on failure
#
#      when a failure occurs, the most recent entry on this
#      stack is popped off to restore the cursor and point
#      to the node to be matched as an alternative. the entry
#      at the bottom of the stack points to the following
#      special nodes depending on the scan mode.
#
#      anchored mode         the bottom entry points to the
#                            special node ndabo which causes an
#                            abort. the cursor value stored
#                            with this entry is always zero.
#
#      unanchored mode       the bottom entry points to the
#                            special node nduna which moves the
#                            anchor point and restarts the match
#                            the cursor saved with this entry
#                            is the number of characters which
#                            lie before the initial anchor point
#                            (i.e. the number of anchor moves).
#                            this entry is three words long and
#                            also contains the initial pattern.
#
#      entries are made on this history stack by alternative
#      nodes and by some special compound patterns as described
#      later on. the following global locations are used during
#      pattern matching.
#
#      r$pms                 pointer to subject string
#      pmssl                 length of subject string
#      pmdfl                 flag set non-zero for dot patterns
#      pmhbs                 base ptr for current history stack
#
#      the following exit points are available to match routines
#
#      succp                 success in matching current node
#      failp                 failure in matching current node
                            #} ejc
        .eject
#
#      compound patterns
#
#      some patterns have implicit alternatives and their
#      representation in the pattern structure consists of a
#      linked set of nodes as indicated by these diagrams.
#
#      as before, the + represents an alternative node and
#      the dotted line from a + node is the parameter pointer
#      to the alternative pattern.
#
#      arb
#      ---
#
#           +---+            this node (p$arb) matches null
#           i b i-----       and stacks cursor, successor ptr,
#           +---+            cursor (copy) and a ptr to ndarc.
#
#
#
#
#      bal
#      ---
#
#           +---+            the p$bal node scans a balanced
#           i b i-----       string and then stacks a pointer
#           +---+            to itself on the history stack.
                            #} ejc
        .eject
#
#      compound pattern structures (continued)
#
#
#      arbno
#      -----
#
#           +---+            this alternative node matches null
#      +----i + i-----       the first time and stacks a pointer
#      i    +---+            to the argument pattern x.
#      i      .
#      i      .
#      i    +---+            node (p$aba) to stack cursor
#      i    i a i            and history stack base ptr.
#      i    +---+
#      i      i
#      i      i
#      i    +---+            this is the argument pattern. as
#      i    i x i            indicated, the successor of the
#      i    +---+            pattern is the p$abc node
#      i      i
#      i      i
#      i    +---+            this node (p$abc) pops pmhbs,
#      +----i c i            stacks old pmhbs and ptr to ndabd
#           +---+            (unless optimization has occurred)
#
#      structure and execution of this pattern resemble those of
#      recursive pattern matching and immediate assignment.
#      the alternative node at the head of the structure matches
#      null initially but on subsequent failure ensures attempt
#      to match the argument.  before the argument is matched
#      p$aba stacks the cursor, pmhbs and a ptr to p$abb.  if
#      the argument cant be matched , p$abb removes this special
#      stack entry and fails.
#      if argument is matched , p$abc restores the outer pmhbs
#      value (saved by p$aba) .  then if the argument has left
#      alternatives on stack it stacks the inner value of pmhbs
#      and a ptr to ndabd. if argument left nothing on the stack
#      it optimises by removing items stacked by p$aba.  finally
#      a check is made that argument matched more than the null
#      string (check is intended to prevent useless looping).
#      if so the successor is again the alternative node at the
#      head of the structure , ensuring a possible extra attempt
#      to match the arg if necessary.  if not , the successor to
#      alternative is taken so as to terminate the loop.  p$abd
#      restores inner pmhbs ptr and fails , thus trying to match
#      alternatives left by the arbno argument.
                            #} ejc
        .eject
#
#      compound pattern structures (continued)
#
#      breakx
#      ------
#
#           +---+            this node is a break node for
#      +----i b i            the argument to breakx, identical
#      i    +---+            to an ordinary break node.
#      i      i
#      i      i
#      i    +---+            this alternative node stacks a
#      i    i + i-----       pointer to the breakx node to
#      i    +---+            allow for subsequent failure
#      i      .
#      i      .
#      i    +---+            this is the breakx node itself. it
#      +----i x i            matches one character and then
#           +---+            proceeds back to the break node.
#
#
#
#
#      fence
#      -----
#
#           +---+            the fence node matches null and
#           i f i-----       stacks a pointer to node ndabo to
#           +---+            abort on a subsequent rematch
#
#
#
#
#      succeed
#      -------
#
#           +---+            the node for succeed matches null
#           i s i-----       and stacks a pointer to itself
#           +---+            to repeat the match on a failure.
                            #} ejc
        .eject
#
#      compound patterns (continued)
#
#      binary dot (pattern assignment)
#      -------------------------------
#
#           +---+            this node (p$paa) saves the current
#           i a i            cursor and a pointer to the
#           +---+            special node ndpab on the stack.
#             i
#             i
#           +---+            this is the structure for the
#           i x i            pattern left argument of the
#           +---+            pattern assignment call.
#             i
#             i
#           +---+            this node (p$pac) saves the cursor,
#           i c i-----       a ptr to itself, the cursor (copy)
#           +---+            and a ptr to ndpad on the stack.
#
#
#      the function of the match routine for ndpab (p$pab)
#      is simply to unstack itself and fail back onto the stack.
#
#      the match routine for p$pac also sets the global pattern
#      flag pmdfl non-zero to indicate that pattern assignments
#      may have occured in the pattern match
#
#      if pmdfl is set at the end of the match (see p$nth), the
#      history stack is scanned for matching ndpab-ndpad pairs
#      and the corresponding pattern assignments are executed.
#
#      the function of the match routine for ndpad (p$pad)
#      is simply to remove its entry from the stack and fail.
#      this includes removing the special node pointer stored
#      in addition to the standard two entries on the stack.
                            #} ejc
        .eject
#
#      compount pattern structures (continued)
#
#      fence (function)
#      ----------------
#
#           +---+            this node (p$fna) saves the
#           i a i            current history stack and a
#           +---+            pointer to ndfnb on the stack.
#             i
#             i
#           +---+            this is the pattern structure
#           i x i            given as the argument to the
#           +---+            fence function.
#             i
#             i
#           +---+            this node p$fnc restores the outer
#           i c i            history stack ptr saved in p$fna,
#           +---+            and stacks the inner stack base
#                            ptr and a pointer to ndfnd on the
#                            stack.
#
#      ndfnb (f$fnb) simply is the failure exit for pattern
#      argument failure, and it pops itself and fails onto the
#      stack.
#
#      the match routine p$fnc allows for an optimization when
#      the fence pattern leaves no alternatives.  in this case,
#      the ndfnb entry is popped, and the match continues.
#
#      ndfnd (p$fnd) is entered when the pattern fails after
#      going through a non-optimized p$fnc, and it pops the
#      stack back past the innter stack base created by p$fna
                            #} ejc
        .eject
#
#      compound patterns (continued)
#
#      expression patterns (recursive pattern matches)
#      -----------------------------------------------
#
#      initial entry for a pattern node is to the routine p$exa.
#      if the evaluated result of the expression is itself a
#      pattern, then the following steps are taken to arrange
#      for proper recursive processing.
#
#      1)   a pointer to the current node (the p$exa node) is
#           stored on the history stack with a dummy cursor.
#
#      2)   a special history stack entry is made in which the
#           node pointer points to ndexb, and the cursor value
#           is the saved value of pmhbs on entry to this node.
#           the match routine for ndexb (p$exb) restores pmhbs
#           from this cursor entry, pops off the p$exa node
#           pointer and fails.
#
#      3)   the resulting history stack pointer is saved in
#           pmhbs to establish a new level of history stack.
#
#      after matching a pattern, the end of match routine gets
#      control (p$nth). this routine proceeds as follows.
#
#      1)   load the current value of pmhbs and recognize the
#           outer level case by the fact that the associated
#           cursor in this case is the pattern match type code
#           which is less than 3. terminate the match in this
#           case and continue execution of the program.
#
#      2)   otherwise make a special history stack entry in
#           which the node pointer points to the special node
#           ndexc and the cursor is the current value of pmhbs.
#           the match routine for ndexc (p$exc) resets pmhbs to
#           this (inner) value and and then fails.
#
#      3)   using the history stack entry made on starting the
#           expression (accessible with the current value of
#           pmhbs), restore the p$exa node pointer and the old
#           pmhbs setting. take the successor and continue.
#
#      an optimization is possible if the expression pattern
#      makes no entries on the history stack. in this case,
#      instead of building the p$exc node in step 2, it is more
#      efficient to simply pop off the p$exb entry and its
#      associated node pointer. the effect is the same.
                            #} ejc
        .eject
#
#      compound patterns (continued)
#
#      binary dollar (immediate assignment)
#      ------------------------------------
#
#           +---+            this node (p$ima) stacks the cursor
#           i a i            pmhbs and a ptr to ndimb and resets
#           +---+            the stack ptr pmhbs.
#             i
#             i
#           +---+            this is the left structure for the
#           i x i            pattern left argument of the
#           +---+            immediate assignment call.
#             i
#             i
#           +---+            this node (p$imc) performs the
#           i c i-----       assignment, pops pmhbs and stacks
#           +---+            the old pmhbs and a ptr to ndimd.
#
#
#      the structure and execution of this pattern are similar
#      to those of the recursive expression pattern matching.
#
#      the match routine for ndimb (p$imb) restores the outer
#      level value of pmhbs, unstacks the saved cursor and fails
#
#      the match routine p$imc uses the current value of pmhbs
#      to locate the p$imb entry. this entry is used to make
#      the assignment and restore the outer level value of
#      pmhbs. finally, the inner level value of pmhbs and a
#      pointer to the special node ndimd are stacked.
#
#      the match routine for ndimd (p$imd) restores the inner
#      level value of pmhbs and fails back into the stack.
#
#      an optimization occurs if the inner pattern makes no
#      entries on the history stack. in this case, p$imc pops
#      the p$imb entry instead of making a p$imd entry.
                            #} ejc
        .eject
#
#      arbno
#
#      see compound patterns section for stucture and
#      algorithm for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_aba:
        LEA                 #stack cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack dummy node ptr} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack old stack base ptr} mov pmhbs -(xs)
        MOV  EAX,DWORD PTR pmhbs
        MOV  DWORD PTR [],EAX
        LEA                 #stack ptr to node ndabb} mov =ndabb -(xs)
        MOV  DWORD PTR [],offset ndabb
        MOV  DWORD PTR pmhbs #store new stack base ptr} mov xs pmhbs
        JMP  succp          #succeed} brn succp
                            #} ejc
        .eject
#
#      arbno (remove p$aba special stack entry)
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_abb:
        MOV  DWORD PTR pmhbs #restore history stack base ptr} mov wb pmhbs
        JMP  flpop          #fail and pop dummy node ptr} brn flpop
                            #} ejc
        .eject
#
#      arbno (check if arg matched null string)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_abc:
        MOV                 #keep p_abb stack base} mov pmhbs xt
        MOV                 #load initial cursor} mov num03(xt) wa
        MOV  EAX,DWORD PTR (4*num01)[] #restore outer stack base ptr} mov num01(xt) pmhbs
        MOV  DWORD PTR pmhbs,EAX
        CMP                 #jump if no history stack entries} beq xt xs pabc1
             pabc1
        LEA                 #else save inner pmhbs entry} mov xt -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to special node ndabd} mov =ndabd -(xs)
        MOV  DWORD PTR [],offset ndabd
        JMP  pabc2          #merge} brn pabc2
#
#      optimise case of no extra entries on stack from arbno arg
#
pabc1:  ADD                 #remove ndabb entry and cursor} add *num04 xs
#
#      merge to check for matching of null string
#
pabc2:  CMP                 #allow further attempt if non-null} bne wa wb succp
             succp
        MOV                 #bypass alternative node so as to ...} mov pthen(xr) xr
        JMP  succp          #... refuse further match attempts} brn succp
                            #} ejc
        .eject
#
#      arbno (try for alternatives in arbno argument)
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_abd:
        MOV  DWORD PTR pmhbs #restore inner stack base ptr} mov wb pmhbs
        JMP  failp          #and fail} brn failp
                            #} ejc
        .eject
#
#      abort
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_abo:
        JMP  exfal          #signal statement failure} brn exfal
                            #} ejc
        .eject
#
#      alternation
#
#      parm1                 alternative node
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_alt:
        LEA                 #stack cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack pointer to alternative} mov parm1(xr) -(xs)
        MOV  EAX,DWORD PTR (4*parm1)[]
        MOV  DWORD PTR [],EAX
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        JMP  succp          #if all ok, then succeed} brn succp
                            #} ejc
        .eject
#
#      any (one character argument) (1-char string also)
#
#      parm1                 character argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_ans:
        CMP                 #fail if no chars left} beq wb pmssl failp
             failp
        MOV                 #else point to subject string} mov r_pms xl
        LEA                 #point to current character} plc xl wb
        MOVZX               #load current character} lch wa (xl)
        CMP                 #fail if no match} bne wa parm1(xr) failp
             failp
        INC                 #else bump cursor} icv wb
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      any (multi-character argument case)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit in ctblk
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_any:
#
#      expression argument case merges here
#
pany1:  CMP                 #fail if no characters left} beq wb pmssl failp
             failp
        MOV                 #else point to subject string} mov r_pms xl
        LEA                 #get char ptr to current character} plc xl wb
        MOVZX               #load current character} lch wa (xl)
        MOV                 #point to ctblk} mov parm1(xr) xl
        SAL                 #change to byte offset} wtb wa
        ADD                 #point to entry in ctblk} add wa xl
        MOV                 #load word from ctblk} mov ctchs(xl) wa
        AND                 #and with selected bit} anb parm2(xr) wa
#        OR                  #fail if no match} zrb wa failp  (Optimized)
        JZ   failp
        INC                 #else bump cursor} icv wb
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      any (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_ayd:
        CALL evals          #evaluate string argument} jsr evals
        .short ERR_-43-DFFNC #} err 043 any evaluated argument is not a string
        .short failp-DFFNC  #fail if evaluation failure} ppm failp
        .short pany1-DFFNC  #merge multi-char case if ok} ppm pany1
                            #} ejc
        .eject
#
#      p$arb                 initial arb match
#
#      no parameters
#
#      the p$arb node is part of a compound pattern structure
#      for an arb pattern (see description of compound patterns)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_arb:
        MOV                 #load successor pointer} mov pthen(xr) xr
        LEA                 #stack dummy cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack successor pointer} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to special node ndarc} mov =ndarc -(xs)
        MOV  DWORD PTR [],offset ndarc
        JMP  DWORD PTR []   #execute next node matching null} bri (xr)
                            #} ejc
        .eject
#
#      p$arc                 extend arb match
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_arc:
        CMP                 #fail and pop stack to successor} beq wb pmssl flpop
             flpop
        INC                 #else bump cursor} icv wb
        LEA                 #stack updated cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #restack pointer to ndarc node} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #load successor pointer} mov num02(xs) xr
        JMP  DWORD PTR []   #off to reexecute successor node} bri (xr)
                            #} ejc
        .eject
#
#      bal
#
#      no parameters
#
#      the p$bal node is part of the compound structure built
#      for bal (see section on compound patterns).
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_bal:
        XOR                 #zero parentheses level counter} zer wc
        MOV                 #point to subject string} mov r_pms xl
        LEA                 #point to current character} plc xl wb
        JMP  pbal2          #jump into scan loop} brn pbal2
#
#      loop to scan out characters
#
pbal1:  MOVZX               #load next character, bump pointer} lch wa (xl)+
        INC
        INC                 #push cursor for character} icv wb
        CMP                 #jump if left paren} beq wa =ch_pp pbal3
             pbal3
        CMP                 #jump if right paren} beq wa =ch_rp pbal4
             pbal4
        OR                  #else succeed if at outer level} bze wc pbal5
        JZ   pbal5
#
#      here after processing one character
#
pbal2:  CMP                 #loop back unless end of string} bne wb pmssl pbal1
             pbal1
        JMP  failp          #in which case, fail} brn failp
#
#      here on left paren
#
pbal3:  INC                 #bump paren level} icv wc
        JMP  pbal2          #loop back to check end of string} brn pbal2
#
#      here for right paren
#
pbal4:  OR                  #fail if no matching left paren} bze wc failp
        JZ   failp
        DEC                 #else decrement level counter} dcv wc
#        OR                  #loop back if not at outer level} bnz wc pbal2  (Optimized)
        JNZ  pbal2
#
#      here after successfully scanning a balanced string
#
pbal5:  LEA                 #stack cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to bal node for extend} mov xr -(xs)
        MOV  DWORD PTR []
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      break (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_bkd:
        CALL evals          #evaluate string expression} jsr evals
        .short ERR_-44-DFFNC #} err 044 break evaluated argument is not a string
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short pbrk1-DFFNC  #merge with multi-char case if ok} ppm pbrk1
                            #} ejc
        .eject
#
#      break (one character argument)
#
#      parm1                 character argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_bks:
        MOV                 #get subject string length} mov pmssl wc
        SUB                 #get number of characters left} sub wb wc
#        OR                  #fail if no characters left} bze wc failp  (Optimized)
        JZ   failp
        MOV                 #point to subject string} mov r_pms xl
        LEA                 #point to current character} plc xl wb
#
#      loop to scan till break character found
#
pbks1:  MOVZX               #load next char, bump pointer} lch wa (xl)+
        INC
        CMP                 #succeed if break character found} beq wa parm1(xr) succp
             succp
        INC                 #else push cursor} icv wb
        DEC                 #loop back if more to go} bct wc pbks1
        JNZ  pbks1
        JMP  failp          #fail if end of string, no break chr} brn failp
                            #} ejc
        .eject
#
#      break (multi-character argument)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit column
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_brk:
#
#      expression argument merges here
#
pbrk1:  MOV                 #load subject string length} mov pmssl wc
        SUB                 #get number of characters left} sub wb wc
#        OR                  #fail if no characters left} bze wc failp  (Optimized)
        JZ   failp
        MOV                 #else point to subject string} mov r_pms xl
        LEA                 #point to current character} plc xl wb
        MOV  DWORD PTR psave #save node pointer} mov xr psave
#
#      loop to search for break character
#
pbrk2:  MOVZX               #load next char, bump pointer} lch wa (xl)+
        INC
        MOV                 #load pointer to ctblk} mov parm1(xr) xr
        SAL                 #convert to byte offset} wtb wa
        ADD                 #point to ctblk entry} add wa xr
        MOV                 #load ctblk word} mov ctchs(xr) wa
        MOV                 #restore node pointer} mov psave xr
        AND                 #and with selected bit} anb parm2(xr) wa
#        OR                  #succeed if break character found} nzb wa succp  (Optimized)
        JNZ  succp
        INC                 #else push cursor} icv wb
        DEC                 #loop back unless end of string} bct wc pbrk2
        JNZ  pbrk2
        JMP  failp          #fail if end of string, no break chr} brn failp
                            #} ejc
        .eject
#
#      breakx (extension)
#
#      this is the entry which causes an extension of a breakx
#      match when failure occurs. see section on compound
#      patterns for full details of breakx matching.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_bkx:
        INC                 #step cursor past previous break chr} icv wb
        JMP  succp          #succeed to rematch break} brn succp
                            #} ejc
        .eject
#
#      breakx (expression argument)
#
#      see section on compound patterns for full structure of
#      breakx pattern. the actual character matching uses a
#      break node. however, the entry for the expression
#      argument case is separated to get proper error messages.
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_bxd:
        CALL evals          #evaluate string argument} jsr evals
        .short ERR_-45-DFFNC #} err 045 breakx evaluated argument is not a string
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short pbrk1-DFFNC  #merge with break if all ok} ppm pbrk1
                            #} ejc
        .eject
#
#      cursor assignment
#
#      parm1                 name base
#      parm2                 name offset
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_cas:
        LEA                 #save node pointer} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #save cursor} mov wb -(xs)
        MOV  DWORD PTR []
        MOV                 #load name base} mov parm1(xr) xl
        MOV  EDX            #load cursor as integer} mti wb
        MOV                 #load name offset} mov parm2(xr) wb
        CALL icbld          #get icblk for cursor value} jsr icbld
        MOV                 #move name offset} mov wb wa
        MOV                 #move value to assign} mov xr wb
        CALL asinp          #perform assignment} jsr asinp
        .short flpop-DFFNC  #fail on assignment failure} ppm flpop
        MOV                 #else restore cursor} mov (xs)+ wb
        LEA
        MOV                 #restore node pointer} mov (xs)+ xr
        LEA
        JMP  succp          #and succeed matching null} brn succp
                            #} ejc
        .eject
#
#      expression node (p$exa, initial entry)
#
#      see compound patterns description for the structure and
#      algorithms for handling expression nodes.
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_exa:
        CALL evalp          #evaluate expression} jsr evalp
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        CMP                 #jump if result is not a pattern} blo wa =p_aaa pexa1
             pexa1
#
#      here if result of expression is a pattern
#
        LEA                 #stack dummy cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to p_exa node} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack history stack base ptr} mov pmhbs -(xs)
        MOV  EAX,DWORD PTR pmhbs
        MOV  DWORD PTR [],EAX
        LEA                 #stack ptr to special node ndexb} mov =ndexb -(xs)
        MOV  DWORD PTR [],offset ndexb
        MOV  DWORD PTR pmhbs #store new stack base pointer} mov xs pmhbs
        MOV                 #copy node pointer} mov xl xr
        JMP  DWORD PTR []   #match first node in expression pat} bri (xr)
#
#      here if result of expression is not a pattern
#
pexa1:  CMP                 #jump if it is already a string} beq wa =b_scl pexa2
             pexa2
        LEA                 #else stack result} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #save node pointer} mov xr xl
        CALL gtstg          #convert result to string} jsr gtstg
        .short ERR_-46-DFFNC #} err 046 expression does not evaluate to pattern
        MOV                 #copy string pointer} mov xr wc
        MOV                 #restore node pointer} mov xl xr
        MOV                 #copy string pointer again} mov wc xl
#
#      merge here with string pointer in xl
#
pexa2:  CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #just succeed if null string} bze sclen(xl) succp
        JZ   succp
        JMP  pstr1          #else merge with string circuit} brn pstr1
                            #} ejc
        .eject
#
#      expression node (p$exb, remove ndexb entry)
#
#      see compound patterns description for the structure and
#      algorithms for handling expression nodes.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_exb:
        MOV  DWORD PTR pmhbs #restore outer level stack pointer} mov wb pmhbs
        JMP  flpop          #fail and pop p_exa node ptr} brn flpop
                            #} ejc
        .eject
#
#      expression node (p$exc, remove ndexc entry)
#
#      see compound patterns description for the structure and
#      algorithms for handling expression nodes.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_exc:
        MOV  DWORD PTR pmhbs #restore inner stack base pointer} mov wb pmhbs
        JMP  failp          #and fail into expr pattern alternvs} brn failp
                            #} ejc
        .eject
#
#      fail
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fal:
        JMP  failp          #just signal failure} brn failp
                            #} ejc
        .eject
#
#      fence
#
#      see compound patterns section for the structure and
#      algorithm for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fen:
        LEA                 #stack dummy cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to abort node} mov =ndabo -(xs)
        MOV  DWORD PTR [],offset ndabo
        JMP  succp          #and succeed matching null} brn succp
                            #} ejc
        .eject
#
#      fence (function)
#
#      see compound patterns comments at start of this section
#      for details of scheme
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fna:
        LEA                 #stack current history stack base} mov pmhbs -(xs)
        MOV  EAX,DWORD PTR pmhbs
        MOV  DWORD PTR [],EAX
        LEA                 #stack indir ptr to p_fnb (failure)} mov =ndfnb -(xs)
        MOV  DWORD PTR [],offset ndfnb
        MOV  DWORD PTR pmhbs #begin new history stack} mov xs pmhbs
        JMP  succp          #succeed} brn succp
                            #} ejc
        .eject
#
#      fence (function) (reset history stack and fail)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fnb:
        MOV  DWORD PTR pmhbs #restore outer pmhbs stack base} mov wb pmhbs
        JMP  failp          #...and fail} brn failp
                            #} ejc
        .eject
#
#      fence (function) (make fence trap entry on stack)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fnc:
        MOV                 #get inner stack base ptr} mov pmhbs xt
        MOV  EAX,DWORD PTR (4*num01)[] #restore outer stack base} mov num01(xt) pmhbs
        MOV  DWORD PTR pmhbs,EAX
        CMP                 #optimize if no alternatives} beq xt xs pfnc1
             pfnc1
        LEA                 #else stack inner stack base} mov xt -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to ndfnd} mov =ndfnd -(xs)
        MOV  DWORD PTR [],offset ndfnd
        JMP  succp          #succeed} brn succp
#
#      here when fence function left nothing on the stack
#
pfnc1:  ADD                 #pop off p_fnb entry} add *num02 xs
        JMP  succp          #succeed} brn succp
                            #} ejc
        .eject
#
#      fence (function) (skip past alternatives on failure)
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_fnd:
        MOV                 #pop stack to fence() history base} mov wb xs
        JMP  flpop          #pop base entry and fail} brn flpop
                            #} ejc
        .eject
#
#      immediate assignment (initial entry, save current cursor)
#
#      see compound patterns description for details of the
#      structure and algorithm for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_ima:
        LEA                 #stack cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack dummy node pointer} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack old stack base pointer} mov pmhbs -(xs)
        MOV  EAX,DWORD PTR pmhbs
        MOV  DWORD PTR [],EAX
        LEA                 #stack ptr to special node ndimb} mov =ndimb -(xs)
        MOV  DWORD PTR [],offset ndimb
        MOV  DWORD PTR pmhbs #store new stack base pointer} mov xs pmhbs
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      immediate assignment (remove cursor mark entry)
#
#      see compound patterns description for details of the
#      structure and algorithms for matching this node type.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_imb:
        MOV  DWORD PTR pmhbs #restore history stack base ptr} mov wb pmhbs
        JMP  flpop          #fail and pop dummy node ptr} brn flpop
                            #} ejc
        .eject
#
#      immediate assignment (perform actual assignment)
#
#      see compound patterns description for details of the
#      structure and algorithms for matching this node type.
#
#      parm1                 name base of variable
#      parm2                 name offset of variable
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_imc:
        MOV                 #load pointer to p_imb entry} mov pmhbs xt
        MOV                 #copy final cursor} mov wb wa
        MOV                 #load initial cursor} mov num03(xt) wb
        MOV  EAX,DWORD PTR (4*num01)[] #restore outer stack base pointer} mov num01(xt) pmhbs
        MOV  DWORD PTR pmhbs,EAX
        CMP                 #jump if no history stack entries} beq xt xs pimc1
             pimc1
        LEA                 #else save inner pmhbs pointer} mov xt -(xs)
        MOV  DWORD PTR []
        LEA                 #and a ptr to special node ndimd} mov =ndimd -(xs)
        MOV  DWORD PTR [],offset ndimd
        JMP  pimc2          #merge} brn pimc2
#
#      here if no entries made on history stack
#
pimc1:  ADD                 #remove ndimb entry and cursor} add *num04 xs
#
#      merge here to perform assignment
#
pimc2:  LEA                 #save current (final) cursor} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #save current node pointer} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #point to subject string} mov r_pms xl
        SUB                 #compute substring length} sub wb wa
        CALL sbstr          #build substring} jsr sbstr
        MOV                 #move result} mov xr wb
        MOV                 #reload node pointer} mov (xs) xr
        MOV                 #load name base} mov parm1(xr) xl
        MOV                 #load name offset} mov parm2(xr) wa
        CALL asinp          #perform assignment} jsr asinp
        .short flpop-DFFNC  #fail if assignment fails} ppm flpop
        MOV                 #else restore node pointer} mov (xs)+ xr
        LEA
        MOV                 #restore cursor} mov (xs)+ wb
        LEA
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      immediate assignment (remove ndimd entry on failure)
#
#      see compound patterns description for details of the
#      structure and algorithms for matching this node type.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_imd:
        MOV  DWORD PTR pmhbs #restore inner stack base pointer} mov wb pmhbs
        JMP  failp          #and fail} brn failp
                            #} ejc
        .eject
#
#      len (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_len:
#
#      expression argument case merges here
#
plen1:  ADD                 #push cursor indicated amount} add parm1(xr) wb
        CMP                 #succeed if not off end} ble wb pmssl succp
             succp
        JMP  failp          #else fail} brn failp
                            #} ejc
        .eject
#
#      len (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_lnd:
        CALL evali          #evaluate integer argument} jsr evali
        .short ERR_-47-DFFNC #} err 047 len evaluated argument is not integer
        .short ERR_-48-DFFNC #} err 048 len evaluated argument is negative or too large
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short plen1-DFFNC  #merge with normal circuit if ok} ppm plen1
                            #} ejc
        .eject
#
#      notany (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_nad:
        CALL evals          #evaluate string argument} jsr evals
        .short ERR_-49-DFFNC #} err 049 notany evaluated argument is not a string
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short pnay1-DFFNC  #merge with multi-char case if ok} ppm pnay1
                            #} ejc
        .eject
#
#      notany (one character argument)
#
#      parm1                 character argument
#
        .balign 2           #entry point} ent bl_p1
        .byte bl_p1
p_nas:
        CMP                 #fail if no chars left} beq wb pmssl failp
             failp
        MOV                 #else point to subject string} mov r_pms xl
        LEA                 #point to current character in strin} plc xl wb
        MOVZX               #load current character} lch wa (xl)
        CMP                 #fail if match} beq wa parm1(xr) failp
             failp
        INC                 #else bump cursor} icv wb
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      notany (multi-character string argument)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit column
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_nay:
#
#      expression argument case merges here
#
pnay1:  CMP                 #fail if no characters left} beq wb pmssl failp
             failp
        MOV                 #else point to subject string} mov r_pms xl
        LEA                 #point to current character} plc xl wb
        MOVZX               #load current character} lch wa (xl)
        SAL                 #convert to byte offset} wtb wa
        MOV                 #load pointer to ctblk} mov parm1(xr) xl
        ADD                 #point to entry in ctblk} add wa xl
        MOV                 #load entry from ctblk} mov ctchs(xl) wa
        AND                 #and with selected bit} anb parm2(xr) wa
#        OR                  #fail if character is matched} nzb wa failp  (Optimized)
        JNZ  failp
        INC                 #else bump cursor} icv wb
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      end of pattern match
#
#      this routine is entered on successful completion.
#      see description of expression patterns in compound
#      pattern section for handling of recursion in matching.
#
#      this pattern also results from an attempt to convert the
#      null string to a pattern via convert()
#
#      no parameters (dummy pattern)
#
        .balign 2           #p0blk (dummy)} ent bl_p0
        .byte bl_p0
p_nth:
        MOV                 #load pointer to base of stack} mov pmhbs xt
        MOV                 #load saved pmhbs (or pattern type)} mov num01(xt) wa
        CMP                 #jump if outer level (pattern type)} ble wa =num02 pnth2
             pnth2
#
#      here we are at the end of matching an expression pattern
#
        MOV  DWORD PTR pmhbs #restore outer stack base pointer} mov wa pmhbs
        MOV                 #restore pointer to p_exa node} mov num02(xt) xr
        CMP                 #jump if no history stack entries} beq xt xs pnth1
             pnth1
        LEA                 #else stack inner stack base ptr} mov xt -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to special node ndexc} mov =ndexc -(xs)
        MOV  DWORD PTR [],offset ndexc
        JMP  succp          #and succeed} brn succp
#
#      here if no history stack entries during pattern
#
pnth1:  ADD                 #remove p_exb entry and node ptr} add *num04 xs
        JMP  succp          #and succeed} brn succp
#
#      here if end of match at outer level
#
pnth2:  MOV  DWORD PTR pmssl #save final cursor in safe place} mov wb pmssl
        CMP  DWORD PTR DWORD PTR pmdfl,0 #jump if no pattern assignments} bze pmdfl pnth6
        JZ   pnth6
                            #} ejc
        .eject
#
#      end of pattern match (continued)
#
#      now we must perform pattern assignments. this is done by
#      scanning the history stack for matching ndpab-ndpad pairs
#
pnth3:  SUB                 #point past cursor entry} dca xt
        LEA                 #load node pointer} mov -(xt) wa
        MOV
        CMP                 #jump if ndpad entry} beq wa =ndpad pnth4
             pnth4
        CMP                 #jump if not ndpab entry} bne wa =ndpab pnth5
             pnth5
#
#      here for ndpab entry, stack initial cursor
#      note that there must be more entries on the stack.
#
        LEA                 #stack initial cursor} mov num01(xt) -(xs)
        MOV  EAX,DWORD PTR (4*num01)[]
        MOV  DWORD PTR [],EAX
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        JMP  pnth3          #loop back if ok} brn pnth3
#
#      here for ndpad entry. the starting cursor from the
#      matching ndpad entry is now the top stack entry.
#
pnth4:  MOV                 #load final cursor} mov num01(xt) wa
        MOV                 #load initial cursor from stack} mov (xs) wb
        MOV  DWORD PTR []   #save history stack scan ptr} mov xt (xs)
        SUB                 #compute length of string} sub wb wa
#
#      build substring and perform assignment
#
        MOV                 #point to subject string} mov r_pms xl
        CALL sbstr          #construct substring} jsr sbstr
        MOV                 #copy substring pointer} mov xr wb
        MOV                 #reload history stack scan ptr} mov (xs) xt
        MOV                 #load pointer to p_pac node with nam} mov num02(xt) xl
        MOV                 #load name offset} mov parm2(xl) wa
        MOV                 #load name base} mov parm1(xl) xl
        CALL asinp          #perform assignment} jsr asinp
        .short exfal-DFFNC  #match fails if name eval fails} ppm exfal
        MOV                 #else restore history stack ptr} mov (xs)+ xt
        LEA
                            #} ejc
        .eject
#
#      end of pattern match (continued)
#
#      here check for end of entries
#
pnth5:  CMP                 #loop if more entries to scan} bne xt xs pnth3
             pnth3
#
#      here after dealing with pattern assignments
#
pnth6:  MOV                 #wipe out history stack} mov pmhbs xs
        MOV                 #load initial cursor} mov (xs)+ wb
        LEA
        MOV                 #load match type code} mov (xs)+ wc
        LEA
        MOV                 #load final cursor value} mov pmssl wa
        MOV                 #point to subject string} mov r_pms xl
        XOR  EAX,EAX        #clear subject string ptr for gbcol} zer r_pms
        MOV  DWORD PTR r_pms,EAX
        OR                  #jump if call by name} bze wc pnth7
        JZ   pnth7
        CMP                 #exit if statement level call} beq wc =num02 pnth9
             pnth9
#
#      here we have a call by value, build substring
#
        SUB                 #compute length of string} sub wb wa
        CALL sbstr          #build substring} jsr sbstr
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      here for call by name, make stack entries for o$rpl
#
pnth7:  LEA                 #stack initial cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack final cursor} mov wa -(xs)
        MOV  DWORD PTR []
#
#      here with xl pointing to scblk or bcblk
#
pnth8:  LEA                 #stack subject pointer} mov xl -(xs)
        MOV  DWORD PTR []
#
#      here to obey next code word
#
pnth9:  MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      pos (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_pos:
#
#      optimize pos if it is the first pattern element,
#      unanchored mode, cursor is zero and pos argument
#      is not beyond end of string.  force cursor position
#      and number of unanchored moves.
#
#      this optimization is performed invisible provided
#      the argument is either a simple integer or an
#      expression that is an untraced variable (that is,
#      it has no side effects that would be lost by short-
#      circuiting the normal logic of failing and moving the
#      unanchored starting point.)
#
#      pos (integer argument)
#
#      parm1                 integer argument
#
        CMP                 #succeed if at right location} beq wb parm1(xr) succp
             succp
        OR                  #don't look further if cursor not 0} bnz wb failp
        JNZ  failp
        MOV                 #get history stack base ptr} mov pmhbs xt
        LEA                 #fail if pos is not first node} bne xr -(xt) failp
        CMP
             failp
#
#      expression argument circuit merges here
#
ppos2:  LEA                 #fail if not unanchored mode} bne -(xt) =nduna failp
        CMP  DWORD PTR [],offset nduna
             failp
        MOV                 #get desired cursor position} mov parm1(xr) wb
        CMP                 #abort if off end} bgt wb pmssl exfal
             exfal
        MOV  DWORD PTR (4*num02)[] #fake number of unanchored moves} mov wb num02(xt)
        JMP  succp          #continue match with adjusted cursor} brn succp
                            #} ejc
        .eject
#
#      pos (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_psd:
        CALL evali          #evaluate integer argument} jsr evali
        .short ERR_-50-DFFNC #} err 050 pos evaluated argument is not integer
        .short ERR_-51-DFFNC #} err 051 pos evaluated argument is negative or too large
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short ppos1-DFFNC  #process expression case} ppm ppos1
#
ppos1:  CMP                 #succeed if at right location} beq wb parm1(xr) succp
             succp
        OR                  #don't look further if cursor not 0} bnz wb failp
        JNZ  failp
        CMP  DWORD PTR DWORD PTR evlif,0 #fail if complex argument} bnz evlif failp
        JNZ  failp
        MOV                 #get history stack base ptr} mov pmhbs xt
        MOV                 #get original node ptr} mov evlio wa
        LEA                 #fail if pos is not first node} bne wa -(xt) failp
        CMP
             failp
        JMP  ppos2          #merge with integer argument code} brn ppos2
                            #} ejc
        .eject
#
#      pattern assignment (initial entry, save cursor)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_paa:
        LEA                 #stack initial cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to ndpab special node} mov =ndpab -(xs)
        MOV  DWORD PTR [],offset ndpab
        JMP  succp          #and succeed matching null} brn succp
                            #} ejc
        .eject
#
#      pattern assignment (remove saved cursor)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      no parameters (dummy pattern)
#
        .balign 2           #entry point} ent
        NOP
p_pab:
        JMP  failp          #just fail (entry is already popped)} brn failp
                            #} ejc
        .eject
#
#      pattern assignment (end of match, make assign entry)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      parm1                 name base of variable
#      parm2                 name offset of variable
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_pac:
        LEA                 #stack dummy cursor value} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack pointer to p_pac node} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack final cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack ptr to special ndpad node} mov =ndpad -(xs)
        MOV  DWORD PTR [],offset ndpad
        MOV  DWORD PTR pmdfl,ESP #set dot flag non-zero} mnz pmdfl
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      pattern assignment (remove assign entry)
#
#      see compound patterns description for the structure and
#      algorithms for matching this node type.
#
#      no parameters (dummy node)
#
        .balign 2           #entry point} ent
        NOP
p_pad:
        JMP  flpop          #fail and remove p_pac node} brn flpop
                            #} ejc
        .eject
#
#      rem
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_rem:
        MOV                 #point cursor to end of string} mov pmssl wb
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      rpos (expression argument)
#
#      optimize rpos if it is the first pattern element,
#      unanchored mode, cursor is zero and rpos argument
#      is not beyond end of string.  force cursor position
#      and number of unanchored moves.
#
#      this optimization is performed invisibly provided
#      the argument is either a simple integer or an
#      expression that is an untraced variable (that is,
#      it has no side effects that would be lost by short-
#      circuiting the normal logic of failing and moving the
#      unanchored starting point).
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rpd:
        CALL evali          #evaluate integer argument} jsr evali
        .short ERR_-52-DFFNC #} err 052 rpos evaluated argument is not integer
        .short ERR_-53-DFFNC #} err 053 rpos evaluated argument is negative or too large
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short prps1-DFFNC  #merge with normal case if ok} ppm prps1
#
prps1:  MOV                 #get length of string} mov pmssl wc
        SUB                 #get number of characters remaining} sub wb wc
        CMP                 #succeed if at right location} beq wc parm1(xr) succp
             succp
        OR                  #don't look further if cursor not 0} bnz wb failp
        JNZ  failp
        CMP  DWORD PTR DWORD PTR evlif,0 #fail if complex argument} bnz evlif failp
        JNZ  failp
        MOV                 #get history stack base ptr} mov pmhbs xt
        MOV                 #get original node ptr} mov evlio wa
        LEA                 #fail if pos is not first node} bne wa -(xt) failp
        CMP
             failp
        JMP  prps2          #merge with integer arg code} brn prps2
                            #} ejc
        .eject
#
#      rpos (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rps:
#
#      rpos (integer argument)
#
#      parm1                 integer argument
#
        MOV                 #get length of string} mov pmssl wc
        SUB                 #get number of characters remaining} sub wb wc
        CMP                 #succeed if at right location} beq wc parm1(xr) succp
             succp
        OR                  #don't look further if cursor not 0} bnz wb failp
        JNZ  failp
        MOV                 #get history stack base ptr} mov pmhbs xt
        LEA                 #fail if rpos is not first node} bne xr -(xt) failp
        CMP
             failp
#
#      expression argument merges here
#
prps2:  LEA                 #fail if not unanchored mode} bne -(xt) =nduna failp
        CMP  DWORD PTR [],offset nduna
             failp
        MOV                 #point to end of string} mov pmssl wb
        CMP                 #fail if string not long enough} blt wb parm1(xr) failp
             failp
        SUB                 #else set new cursor} sub parm1(xr) wb
        MOV  DWORD PTR (4*num02)[] #fake number of unanchored moves} mov wb num02(xt)
        JMP  succp          #continue match with adjusted cursor} brn succp
                            #} ejc
        .eject
#
#      rtab (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rtb:
#
#      expression argument case merges here
#
prtb1:  MOV                 #save initial cursor} mov wb wc
        MOV                 #point to end of string} mov pmssl wb
        CMP                 #fail if string not long enough} blt wb parm1(xr) failp
             failp
        SUB                 #else set new cursor} sub parm1(xr) wb
        CMP                 #and succeed if not too far already} bge wb wc succp
             succp
        JMP  failp          #in which case, fail} brn failp
                            #} ejc
        .eject
#
#      rtab (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_rtd:
        CALL evali          #evaluate integer argument} jsr evali
        .short ERR_-54-DFFNC #} err 054 rtab evaluated argument is not integer
        .short ERR_-55-DFFNC #} err 055 rtab evaluated argument is negative or too large
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short prtb1-DFFNC  #merge with normal case if success} ppm prtb1
                            #} ejc
        .eject
#
#      span (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_spd:
        CALL evals          #evaluate string argument} jsr evals
        .short ERR_-56-DFFNC #} err 056 span evaluated argument is not a string
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short pspn1-DFFNC  #merge with multi-char case if ok} ppm pspn1
                            #} ejc
        .eject
#
#      span (multi-character argument case)
#
#      parm1                 pointer to ctblk
#      parm2                 bit mask to select bit column
#
        .balign 2           #p2blk} ent bl_p2
        .byte bl_p2
p_spn:
#
#      expression argument case merges here
#
pspn1:  MOV                 #copy subject string length} mov pmssl wc
        SUB                 #calculate number of characters left} sub wb wc
#        OR                  #fail if no characters left} bze wc failp  (Optimized)
        JZ   failp
        MOV                 #point to subject string} mov r_pms xl
        LEA                 #point to current character} plc xl wb
        MOV  DWORD PTR psavc #save initial cursor} mov wb psavc
        MOV  DWORD PTR psave #save node pointer} mov xr psave
#
#      loop to scan matching characters
#
pspn2:  MOVZX               #load next character, bump pointer} lch wa (xl)+
        INC
        SAL                 #convert to byte offset} wtb wa
        MOV                 #point to ctblk} mov parm1(xr) xr
        ADD                 #point to ctblk entry} add wa xr
        MOV                 #load ctblk entry} mov ctchs(xr) wa
        MOV                 #restore node pointer} mov psave xr
        AND                 #and with selected bit} anb parm2(xr) wa
#        OR                  #jump if no match} zrb wa pspn3  (Optimized)
        JZ   pspn3
        INC                 #else push cursor} icv wb
        DEC                 #loop back unless end of string} bct wc pspn2
        JNZ  pspn2
#
#      here after scanning matching characters
#
pspn3:  CMP                 #succeed if chars matched} bne wb psavc succp
             succp
        JMP  failp          #else fail if null string matched} brn failp
                            #} ejc
        .eject
#
#      span (one character argument)
#
#      parm1                 character argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_sps:
        MOV                 #get subject string length} mov pmssl wc
        SUB                 #calculate number of characters left} sub wb wc
#        OR                  #fail if no characters left} bze wc failp  (Optimized)
        JZ   failp
        MOV                 #else point to subject string} mov r_pms xl
        LEA                 #point to current character} plc xl wb
        MOV  DWORD PTR psavc #save initial cursor} mov wb psavc
#
#      loop to scan matching characters
#
psps1:  MOVZX               #load next character, bump pointer} lch wa (xl)+
        INC
        CMP                 #jump if no match} bne wa parm1(xr) psps2
             psps2
        INC                 #else push cursor} icv wb
        DEC                 #and loop unless end of string} bct wc psps1
        JNZ  psps1
#
#      here after scanning matching characters
#
psps2:  CMP                 #succeed if chars matched} bne wb psavc succp
             succp
        JMP  failp          #fail if null string matched} brn failp
                            #} ejc
        .eject
#
#      multi-character string
#
#      note that one character strings use the circuit for
#      one character any arguments (p$an1).
#
#      parm1                 pointer to scblk for string arg
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_str:
        MOV                 #get pointer to string} mov parm1(xr) xl
#
#      merge here after evaluating expression with string value
#
pstr1:  MOV  DWORD PTR psave #save node pointer} mov xr psave
        MOV                 #load subject string pointer} mov r_pms xr
        LEA                 #point to current character} plc xr wb
        ADD                 #compute new cursor position} add sclen(xl) wb
        CMP                 #fail if past end of string} bgt wb pmssl failp
             failp
        MOV  DWORD PTR psavc #save updated cursor} mov wb psavc
        MOV                 #get number of chars to compare} mov sclen(xl) wa
        ADD                 #point to chars of test string} plc xl
        REPE CMPSB          #compare, fail if not equal} cmc failp failp
        MOV  ESI,0
        MOV  EDI,ESI
        JNZ  failp
        MOV                 #if all matched, restore node ptr} mov psave xr
        MOV                 #restore updated cursor} mov psavc wb
        JMP  succp          #and succeed} brn succp
                            #} ejc
        .eject
#
#      succeed
#
#      see section on compound patterns for details of the
#      structure and algorithms for matching this node type
#
#      no parameters
#
        .balign 2           #p0blk} ent bl_p0
        .byte bl_p0
p_suc:
        LEA                 #stack cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack pointer to this node} mov xr -(xs)
        MOV  DWORD PTR []
        JMP  succp          #succeed matching null} brn succp
                            #} ejc
        .eject
#
#      tab (integer argument)
#
#      parm1                 integer argument
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_tab:
#
#      expression argument case merges here
#
ptab1:  CMP                 #fail if too far already} bgt wb parm1(xr) failp
             failp
        MOV                 #else set new cursor position} mov parm1(xr) wb
        CMP                 #succeed if not off end} ble wb pmssl succp
             succp
        JMP  failp          #else fail} brn failp
                            #} ejc
        .eject
#
#      tab (expression argument)
#
#      parm1                 expression pointer
#
        .balign 2           #p1blk} ent bl_p1
        .byte bl_p1
p_tbd:
        CALL evali          #evaluate integer argument} jsr evali
        .short ERR_-57-DFFNC #} err 057 tab evaluated argument is not integer
        .short ERR_-58-DFFNC #} err 058 tab evaluated argument is negative or too large
        .short failp-DFFNC  #fail if evaluation fails} ppm failp
        .short ptab1-DFFNC  #merge with normal case if ok} ppm ptab1
                            #} ejc
        .eject
#
#      anchor movement
#
#      no parameters (dummy node)
#
        .balign 2           #entry point} ent
        NOP
p_una:
        MOV                 #copy initial pattern node pointer} mov wb xr
        MOV                 #get initial cursor} mov (xs) wb
        CMP                 #match fails if at end of string} beq wb pmssl exfal
             exfal
        INC                 #else increment cursor} icv wb
        MOV  DWORD PTR []   #store incremented cursor} mov wb (xs)
        LEA                 #restack initial node ptr} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #restack unanchored node} mov =nduna -(xs)
        MOV  DWORD PTR [],offset nduna
        JMP  DWORD PTR []   #rematch first node} bri (xr)
                            #} ejc
        .eject
#
#      end of pattern match routines
#
#      the following entry point marks the end of the pattern
#      matching routines and also the end of the entry points
#      referenced from the first word of blocks in dynamic store
#
        .balign 2           #mark last entry in pattern section} ent bl__i
        .byte bl__i
p_yyy:
                            #} ttl s p i t b o l -- snobol4 built-in label routines
        .sbttl "s p i t b o l -- snobol4 built-in label routines"
#
#      the following section contains the routines for labels
#      which have a predefined meaning in snobol4.
#
#      control is passed directly to the label name entry point.
#
#      entry names are of the form l$xxx where xxx is the three
#      letter variable name identifier.
#
#      entries are in alphabetical order
                            #} ejc
        .eject
#
#      abort
#
        .balign 2           #entry point} ent
        NOP
l_abo:
#
#      merge here if execution terminates in error
#
labo1:  MOV                 #load error code} mov kvert wa
        OR                  #jump if no error has occured} bze wa labo3
        JZ   labo3
        CALL sysax          #call after execution proc} jsr sysax
        MOV                 #current statement} mov kvstn wc
        CALL filnm          #obtain file name for this statement} jsr filnm
        MOV                 #current code block} mov r_cod xr
        MOV                 #line number} mov cdsln(xr) wc
        XOR                 #column number} zer wb
        MOV                 #} mov stage xr
        CALL sysea          #advise system of error} jsr sysea
        .short stpr4-DFFNC  #if system does not want print} ppm stpr4
        CALL prtpg          #else eject printer} jsr prtpg
        OR                  #did sysea request print} bze xr labo2
        JZ   labo2
        CALL prtst          #print text from sysea} jsr prtst
labo2:  CALL ermsg          #print error message} jsr ermsg
        XOR                 #indicate no message to print} zer xr
        JMP  stopr          #jump to routine to stop run} brn stopr
#
#      here if no error had occured
#
labo3:  CALL ERR_0          #} erb 036 goto abort with no preceding error
        .byte 36
                            #} ejc
        .eject
#
#      continue
#
        .balign 2           #entry point} ent
        NOP
l_cnt:
#
#      merge here after execution error
#
lcnt1:  MOV                 #load continuation code block ptr} mov r_cnt xr
        OR                  #jump if no previous error} bze xr lcnt3
        JZ   lcnt3
        XOR  EAX,EAX        #clear flag} zer r_cnt
        MOV  DWORD PTR r_cnt,EAX
        MOV  DWORD PTR r_cod #else store as new code block ptr} mov xr r_cod
        CMP  DWORD PTR [],offset b_cdc #jump if not complex go} bne (xr) =b_cdc lcnt2
             lcnt2
        MOV                 #get offset of error} mov stxoc wa
        CMP                 #jump if error in goto evaluation} bge wa stxof lcnt4
             lcnt4
#
#      here if error did not occur in complex failure goto
#
lcnt2:  ADD                 #add failure offset} add stxof xr
        MOV  EBP            #load code pointer} lcp xr
        MOV                 #reset stack pointer} mov flptr xs
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      here if no previous error
#
lcnt3:  INC  DWORD PTR errft #fatal error} icv errft
        CALL ERR_0          #} erb 037 goto continue with no preceding error
        .byte 37
#
#      here if error in evaluation of failure goto.
#      cannot continue back to failure goto!
#
lcnt4:  INC  DWORD PTR errft #fatal error} icv errft
        CALL ERR_1          #} erb 332 goto continue with error in failure goto
        .byte 76
                            #} ejc
        .eject
#
#      end
#
        .balign 2           #entry point} ent
        NOP
l_end:
#
#      merge here from end code circuit
#
lend0:  MOV                 #point to message /normal term.../} mov =endms xr
        JMP  stopr          #jump to routine to stop run} brn stopr
                            #} ejc
        .eject
#
#      freturn
#
        .balign 2           #entry point} ent
        NOP
l_frt:
        MOV                 #point to string /freturn/} mov =scfrt wa
        JMP  retrn          #jump to common return routine} brn retrn
                            #} ejc
        .eject
#
#      nreturn
#
        .balign 2           #entry point} ent
        NOP
l_nrt:
        MOV                 #point to string /nreturn/} mov =scnrt wa
        JMP  retrn          #jump to common return routine} brn retrn
                            #} ejc
        .eject
#
#      return
#
        .balign 2           #entry point} ent
        NOP
l_rtn:
        MOV                 #point to string /return/} mov =scrtn wa
        JMP  retrn          #jump to common return routine} brn retrn
                            #} ejc
        .eject
#
#      scontinue
#
        .balign 2           #entry point} ent
        NOP
l_scn:
        MOV                 #load continuation code block ptr} mov r_cnt xr
        OR                  #jump if no previous error} bze xr lscn2
        JZ   lscn2
        XOR  EAX,EAX        #clear flag} zer r_cnt
        MOV  DWORD PTR r_cnt,EAX
        CMP  DWORD PTR kvert,nm320 #error must be user interrupt} bne kvert =nm320 lscn1
             lscn1
        CMP  DWORD PTR kvert,nm321 #detect scontinue loop} beq kvert =nm321 lscn2
             lscn2
        MOV  DWORD PTR r_cod #else store as new code block ptr} mov xr r_cod
        ADD                 #add resume offset} add stxoc xr
        MOV  EBP            #load code pointer} lcp xr
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      here if no user interrupt
#
lscn1:  INC  DWORD PTR errft #fatal error} icv errft
        CALL ERR_1          #} erb 331 goto scontinue with no user interrupt
        .byte 75
#
#      here if in scontinue loop or if no previous error
#
lscn2:  INC  DWORD PTR errft #fatal error} icv errft
        CALL ERR_1          #} erb 321 goto scontinue with no preceding error
        .byte 65
                            #} ejc
        .eject
#
#      undefined label
#
        .balign 2           #entry point} ent
        NOP
l_und:
        CALL ERR_0          #} erb 038 goto undefined label
        .byte 38
                            #} ttl s p i t b o l -- predefined snobol4 functions
        .sbttl "s p i t b o l -- predefined snobol4 functions"
#
#      the following section contains coding for functions
#      which are predefined and available at the snobol level.
#
#      these routines receive control directly from the code or
#      indirectly through the o$fnc, o$fns or cfunc routines.
#      in both cases the conditions on entry are as follows
#
#      the arguments are on the stack. the number of arguments
#      has been adjusted to correspond to the svblk svnar field.
#
#      in certain functions the direct call is not permitted
#      and in these instances we also have.
#
#      (wa)                  actual number of arguments in call
#
#      control returns by placing the function result value on
#      on the stack and continuing execution with the next
#      word from the generated code.
#
#      the names of the entry points of these functions are of
#      the form s$xxx where xxx is the three letter code for
#      the system variable name. the functions are in order
#      alphabetically by their entry names.
                            #} ejc
        .eject
#
#      any
#
        .balign 2           #entry point} ent
        NOP
s_any:
        MOV                 #set pcode for single char case} mov =p_ans wb
        MOV                 #pcode for multi-char case} mov =p_any xl
        MOV                 #pcode for expression case} mov =p_ayd wc
        CALL patst          #call common routine to build node} jsr patst
        .short ERR_-59-DFFNC #} err 059 any argument is not a string or expression
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      apply
#
#      apply does not permit the direct (fast) call so that
#      wa contains the actual number of arguments passed.
#
        .balign 2           #entry point} ent
        NOP
s_app:
        OR                  #jump if no arguments} bze wa sapp3
        JZ   sapp3
        DEC                 #else get applied func arg count} dcv wa
        MOV                 #copy} mov wa wb
        SAL                 #convert to bytes} wtb wb
        MOV                 #copy stack pointer} mov xs xt
        ADD                 #point to function argument on stack} add wb xt
        MOV                 #load function ptr (apply 1st arg)} mov (xt) xr
        OR                  #jump if no args for applied func} bze wa sapp2
        JZ   sapp2
        MOV                 #else set counter for loop} lct wb wa
#
#      loop to move arguments up on stack
#
sapp1:  SUB                 #point to next argument} dca xt
        MOV  EAX,DWORD PTR [] #move argument up} mov (xt) num01(xt)
        MOV  DWORD PTR (4*num01)[],EAX
        DEC                 #loop till all moved} bct wb sapp1
        JNZ  sapp1
#
#      merge here to call function (wa = number of arguments)
#
sapp2:  ADD                 #adjust stack ptr for apply 1st arg} ica xs
        CALL gtnvr          #get variable block addr for func} jsr gtnvr
        .short sapp3-DFFNC  #jump if not natural variable} ppm sapp3
        MOV                 #else point to function block} mov vrfnc(xr) xl
        JMP  cfunc          #go call applied function} brn cfunc
#
#      here for invalid first argument
#
sapp3:  CALL ERR_0          #} erb 060 apply first arg is not natural variable name
        .byte 60
                            #} ejc
        .eject
#
#      arbno
#
#      arbno builds a compound pattern. see description at
#      start of pattern matching section for structure formed.
#
        .balign 2           #entry point} ent
        NOP
s_abn:
        XOR                 #set parm1 = 0 for the moment} zer xr
        MOV                 #set pcode for alternative node} mov =p_alt wb
        CALL pbild          #build alternative node} jsr pbild
        MOV                 #save ptr to alternative pattern} mov xr xl
        MOV                 #pcode for p_abc} mov =p_abc wb
        XOR                 #p0blk} zer xr
        CALL pbild          #build p_abc node} jsr pbild
        MOV  DWORD PTR (4*pthen)[] #put alternative node as successor} mov xl pthen(xr)
        MOV                 #remember alternative node pointer} mov xl wa
        MOV                 #copy p_abc node ptr} mov xr xl
        MOV                 #load arbno argument} mov (xs) xr
        MOV  DWORD PTR []   #stack alternative node pointer} mov wa (xs)
        CALL gtpat          #get arbno argument as pattern} jsr gtpat
        .short ERR_-61-DFFNC #} err 061 arbno argument is not pattern
        CALL pconc          #concat arg with p_abc node} jsr pconc
        MOV                 #remember ptr to concd patterns} mov xr xl
        MOV                 #pcode for p_aba} mov =p_aba wb
        XOR                 #p0blk} zer xr
        CALL pbild          #build p_aba node} jsr pbild
        MOV  DWORD PTR (4*pthen)[] #concatenate nodes} mov xl pthen(xr)
        MOV                 #recall ptr to alternative node} mov (xs) xl
        MOV  DWORD PTR (4*parm1)[] #point alternative back to argument} mov xr parm1(xl)
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      arg
#
        .balign 2           #entry point} ent
        NOP
s_arg:
        CALL gtsmi          #get second arg as small integer} jsr gtsmi
        .short ERR_-62-DFFNC #} err 062 arg second argument is not integer
        .short exfal-DFFNC  #fail if out of range or negative} ppm exfal
        MOV                 #save argument number} mov xr wa
        MOV                 #load first argument} mov (xs)+ xr
        LEA
        CALL gtnvr          #locate vrblk} jsr gtnvr
        .short sarg1-DFFNC  #jump if not natural variable} ppm sarg1
        MOV                 #else load function block pointer} mov vrfnc(xr) xr
        CMP  DWORD PTR [],offset b_pfc #jump if not program defined} bne (xr) =b_pfc sarg1
             sarg1
        OR                  #fail if arg number is zero} bze wa exfal
        JZ   exfal
        CMP                 #fail if arg number is too large} bgt wa fargs(xr) exfal
             exfal
        SAL                 #else convert to byte offset} wtb wa
        ADD                 #point to argument selected} add wa xr
        MOV                 #load argument vrblk pointer} mov pfagb(xr) xr
        JMP  exvnm          #exit to build nmblk} brn exvnm
#
#      here if 1st argument is bad
#
sarg1:  CALL ERR_0          #} erb 063 arg first argument is not program function name
        .byte 63
                            #} ejc
        .eject
#
#      array
#
        .balign 2           #entry point} ent
        NOP
s_arr:
        MOV                 #load initial element value} mov (xs)+ xl
        LEA
        MOV                 #load first argument} mov (xs)+ xr
        LEA
        CALL gtint          #convert first arg to integer} jsr gtint
        .short sar02-DFFNC  #jump if not integer} ppm sar02
#
#      here for integer first argument, build vcblk
#
        MOV  EDX,DWORD PTR (4*icval)[] #load integer value} ldi icval(xr)
        OR   EDX,EDX        #jump if zero or neg (bad dimension)} ile sar10
        JLE  sar10
        OR   EDX,EDX        #else convert to one word, test ovfl} mfi wa sar11
        JS   sar11
        MOV
        CALL vmake          #create vector} jsr vmake
        .short sar11-DFFNC  #fail if too large} ppm sar11
        JMP  exsid          #exit setting idval} brn exsid
                            #} ejc
        .eject
#
#      array (continued)
#
#      here if first argument is not an integer
#
sar02:  LEA                 #replace argument on stack} mov xr -(xs)
        MOV  DWORD PTR []
        CALL xscni          #initialize scan of first argument} jsr xscni
        .short ERR_-64-DFFNC #} err 064 array first argument is not integer or string
        .short exnul-DFFNC  #dummy (unused) null string exit} ppm exnul
        LEA                 #save prototype pointer} mov r_xsc -(xs)
        MOV  EAX,DWORD PTR r_xsc
        MOV  DWORD PTR [],EAX
        LEA                 #save default value} mov xl -(xs)
        MOV  DWORD PTR []
        XOR  EAX,EAX        #zero count of dimensions} zer arcdm
        MOV  DWORD PTR arcdm,EAX
        XOR  EAX,EAX        #zero offset to indicate pass one} zer arptr
        MOV  DWORD PTR arptr,EAX
        MOV  EDX,DWORD PTR intv1 #load integer one} ldi intv1
        MOV  DWORD PTR arnel,EDX #initialize element count} sti arnel
#
#      the following code is executed twice. the first time
#      (arptr eq 0), it is used to count the number of elements
#      and number of dimensions. the second time (arptr gt 0) is
#      used to actually fill in the dim,lbd fields of the arblk.
#
sar03:  MOV  EDX,DWORD PTR intv1 #load one as default low bound} ldi intv1
        MOV  DWORD PTR arsvl,EDX #save as low bound} sti arsvl
        MOV                 #set delimiter one = colon} mov =ch_cl wc
        MOV                 #set delimiter two = comma} mov =ch_cm xl
        XOR                 #retain blanks in prototype} zer wa
        CALL xscan          #scan next bound} jsr xscan
        CMP                 #jump if not colon} bne wa =num01 sar04
             sar04
#
#      here we have a colon ending a low bound
#
        CALL gtint          #convert low bound} jsr gtint
        .short ERR_-65-DFFNC #} err 065 array first argument lower bound is not integer
        MOV  EDX,DWORD PTR (4*icval)[] #load value of low bound} ldi icval(xr)
        MOV  DWORD PTR arsvl,EDX #store low bound value} sti arsvl
        MOV                 #set delimiter one = comma} mov =ch_cm wc
        MOV                 #and delimiter two = comma} mov wc xl
        XOR                 #retain blanks in prototype} zer wa
        CALL xscan          #scan high bound} jsr xscan
                            #} ejc
        .eject
#
#      array (continued)
#
#      merge here to process upper bound
#
sar04:  CALL gtint          #convert high bound to integer} jsr gtint
        .short ERR_-66-DFFNC #} err 066 array first argument upper bound is not integer
        MOV  EDX,DWORD PTR (4*icval)[] #get high bound} ldi icval(xr)
        SUB  EDX,DWORD PTR arsvl #subtract lower bound} sbi arsvl
        JO   sar10          #bad dimension if overflow} iov sar10
        OR   EDX,EDX        #bad dimension if negative} ilt sar10
        JL   sar10
        ADD  EDX,DWORD PTR intv1 #add 1 to get dimension} adi intv1
        JO   sar10          #bad dimension if overflow} iov sar10
        MOV                 #load offset (also pass indicator)} mov arptr xl
        OR                  #jump if first pass} bze xl sar05
        JZ   sar05
#
#      here in second pass to store lbd and dim in arblk
#
        ADD                 #point to current location in arblk} add (xs) xl
        MOV  DWORD PTR (4*cfp_i)[],EDX #store dimension} sti cfp_i(xl)
        MOV  EDX,DWORD PTR arsvl #load low bound} ldi arsvl
        MOV  DWORD PTR [],EDX #store low bound} sti (xl)
        ADD  DWORD PTR arptr,4*ardms #bump offset to next bounds} add *ardms arptr
        JMP  sar06          #jump to check for end of bounds} brn sar06
#
#      here in pass 1
#
sar05:  INC  DWORD PTR arcdm #bump dimension count} icv arcdm
        IMUL EDX,DWORD PTR arnel #multiply dimension by count so far} mli arnel
        JO   sar11          #too large if overflow} iov sar11
        MOV  DWORD PTR arnel,EDX #else store updated element count} sti arnel
#
#      merge here after processing one set of bounds
#
sar06:  OR                  #loop back unless end of bounds} bnz wa sar03
        JNZ  sar03
        CMP  DWORD PTR DWORD PTR arptr,0 #jump if end of pass 2} bnz arptr sar09
        JNZ  sar09
                            #} ejc
        .eject
#
#      array (continued)
#
#      here at end of pass one, build arblk
#
        MOV  EDX,DWORD PTR arnel #get number of elements} ldi arnel
        OR   EDX,EDX        #get as addr integer, test ovflo} mfi wb sar11
        JS   sar11
        MOV
        SAL                 #else convert to length in bytes} wtb wb
        MOV                 #set size of standard fields} mov *arsi_ wa
        MOV                 #set dimension count to control loop} lct wc arcdm
#
#      loop to allow space for dimensions
#
sar07:  ADD                 #allow space for one set of bounds} add *ardms wa
        DEC                 #loop back till all accounted for} bct wc sar07
        JNZ  sar07
        MOV                 #save size (=arofs)} mov wa xl
#
#      now allocate space for arblk
#
        ADD                 #add space for elements} add wb wa
        ADD                 #allow for arpro prototype field} ica wa
        CMP                 #fail if too large} bgt wa mxlen sar11
             sar11
        CALL alloc          #else allocate arblk} jsr alloc
        MOV                 #load default value} mov (xs) wb
        MOV  DWORD PTR []   #save arblk pointer} mov xr (xs)
        MOV                 #save length in bytes} mov wa wc
        SHR                 #convert length back to words} btw wa
#
#      loop to clear entire arblk to default value
#
sar08:  MOV  DWORD PTR []   #set one word} mov wb (xr)+
        LEA
        DEC                 #loop till all set} bct wa sar08
        JNZ  sar08
                            #} ejc
        .eject
#
#      array (continued)
#
#      now set initial fields of arblk
#
        MOV                 #reload arblk pointer} mov (xs)+ xr
        LEA
        MOV                 #load prototype} mov (xs) wb
        MOV  DWORD PTR [],offset b_art #set type word} mov =b_art (xr)
        MOV  DWORD PTR (4*arlen)[] #store length in bytes} mov wc arlen(xr)
        XOR  EAX,EAX        #zero id till we get it built} zer idval(xr)
        MOV  DWORD PTR (4*idval)[],EAX
        MOV  DWORD PTR (4*arofs)[] #set prototype field ptr} mov xl arofs(xr)
        MOV  EAX,DWORD PTR arcdm #set number of dimensions} mov arcdm arndm(xr)
        MOV  DWORD PTR (4*arndm)[],EAX
        MOV                 #save arblk pointer} mov xr wc
        ADD                 #point to prototype field} add xl xr
        MOV  DWORD PTR []   #store prototype ptr in arblk} mov wb (xr)
        MOV  DWORD PTR arptr,4*arlbd #set offset for pass 2 bounds scan} mov *arlbd arptr
        MOV  DWORD PTR r_xsc #reset string pointer for xscan} mov wb r_xsc
        MOV  DWORD PTR []   #store arblk pointer on stack} mov wc (xs)
        XOR  EAX,EAX        #reset offset ptr to start of string} zer xsofs
        MOV  DWORD PTR xsofs,EAX
        JMP  sar03          #jump back to rescan bounds} brn sar03
#
#      here after filling in bounds information (end pass two)
#
sar09:  MOV                 #reload pointer to arblk} mov (xs)+ xr
        LEA
        JMP  exsid          #exit setting idval} brn exsid
#
#      here for bad dimension
#
sar10:  CALL ERR_0          #} erb 067 array dimension is zero, negative or out of range
        .byte 67
#
#      here if array is too large
#
sar11:  CALL ERR_0          #} erb 068 array size exceeds maximum permitted
        .byte 68
                            #} ejc
        .eject
#
#      atan
#
        .balign 2           #entry point} ent
        NOP
s_atn:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-301-DFFNC #} err 301 atan argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL atn_           #take arctangent} atn
        JMP  exrea          #overflow, out of range not possible} brn exrea
                            #} ejc
        .eject
                            #} ejc
        .eject
#
#      backspace
#
        .balign 2           #entry point} ent
        NOP
s_bsp:
        CALL iofcb          #call fcblk routine} jsr iofcb
        .short ERR_-316-DFFNC #} err 316 backspace argument is not a suitable name
        .short ERR_-316-DFFNC #} err 316 backspace argument is not a suitable name
        .short ERR_-317-DFFNC #} err 317 backspace file does not exist
        CALL sysbs          #call backspace file function} jsr sysbs
        .short ERR_-317-DFFNC #} err 317 backspace file does not exist
        .short ERR_-318-DFFNC #} err 318 backspace file does not permit backspace
        .short ERR_-319-DFFNC #} err 319 backspace caused non-recoverable error
        JMP  exnul          #return null as result} brn exnul
                            #} ejc
        .eject
#
#      break
#
        .balign 2           #entry point} ent
        NOP
s_brk:
        MOV                 #set pcode for single char case} mov =p_bks wb
        MOV                 #pcode for multi-char case} mov =p_brk xl
        MOV                 #pcode for expression case} mov =p_bkd wc
        CALL patst          #call common routine to build node} jsr patst
        .short ERR_-69-DFFNC #} err 069 break argument is not a string or expression
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      breakx
#
#      breakx is a compound pattern. see description at start
#      of pattern matching section for structure formed.
#
        .balign 2           #entry point} ent
        NOP
s_bkx:
        MOV                 #pcode for single char argument} mov =p_bks wb
        MOV                 #pcode for multi-char argument} mov =p_brk xl
        MOV                 #pcode for expression case} mov =p_bxd wc
        CALL patst          #call common routine to build node} jsr patst
        .short ERR_-70-DFFNC #} err 070 breakx argument is not a string or expression
#
#      now hook breakx node on at front end
#
        LEA                 #save ptr to break node} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #set pcode for breakx node} mov =p_bkx wb
        CALL pbild          #build it} jsr pbild
        MOV  EAX,DWORD PTR [] #set break node as successor} mov (xs) pthen(xr)
        MOV  DWORD PTR (4*pthen)[],EAX
        MOV                 #set pcode for alternation node} mov =p_alt wb
        CALL pbild          #build (parm1=alt=breakx node)} jsr pbild
        MOV                 #save ptr to alternation node} mov xr wa
        MOV                 #point to break node} mov (xs) xr
        MOV  DWORD PTR (4*pthen)[] #set alternate node as successor} mov wa pthen(xr)
        MOV                 #result on stack} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      char
#
        .balign 2           #entry point} ent
        NOP
s_chr:
        CALL gtsmi          #convert arg to integer} jsr gtsmi
        .short ERR_-281-DFFNC #} err 281 char argument not integer
        .short schr1-DFFNC  #too big error exit} ppm schr1
        CMP                 #see if out of range of host set} bge wc =cfp_a schr1
             schr1
        MOV                 #if not set scblk allocation} mov =num01 wa
        MOV                 #save char code} mov wc wb
        CALL alocs          #allocate 1 bau scblk} jsr alocs
        MOV                 #copy scblk pointer} mov xr xl
        ADD                 #get set to stuff char} psc xl
        MOV  [ESI]          #stuff it} sch wb (xl)
        XOR                 #clear slop in xl} zer xl
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      here if char argument is out of range
#
schr1:  CALL ERR_1          #} erb 282 char argument not in range
        .byte 26
                            #} ejc
        .eject
#
#      chop
#
        .balign 2           #entry point} ent
        NOP
s_chp:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-302-DFFNC #} err 302 chop argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL chp_           #truncate to integer valued real} chp
        JMP  exrea          #no overflow possible} brn exrea
                            #} ejc
        .eject
#
#      clear
#
        .balign 2           #entry point} ent
        NOP
s_clr:
        CALL xscni          #initialize to scan argument} jsr xscni
        .short ERR_-71-DFFNC #} err 071 clear argument is not a string
        .short sclr2-DFFNC  #jump if null} ppm sclr2
#
#      loop to scan out names in first argument. variables in
#      the list are flagged by setting vrget of vrblk to zero.
#
sclr1:  MOV                 #set delimiter one = comma} mov =ch_cm wc
        MOV                 #delimiter two = comma} mov wc xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan next variable name} jsr xscan
        CALL gtnvr          #locate vrblk} jsr gtnvr
        .short ERR_-72-DFFNC #} err 072 clear argument has null variable name
        XOR  EAX,EAX        #else flag by zeroing vrget field} zer vrget(xr)
        MOV  DWORD PTR (4*vrget)[],EAX
        OR                  #loop back if stopped by comma} bnz wa sclr1
        JNZ  sclr1
#
#      here after flagging variables in argument list
#
sclr2:  MOV                 #point to start of hash table} mov hshtb wb
#
#      loop through slots in hash table
#
sclr3:  CMP                 #exit returning null if none left} beq wb hshte exnul
             exnul
        MOV                 #else copy slot pointer} mov wb xr
        ADD                 #bump slot pointer} ica wb
        SUB                 #set offset to merge into loop} sub *vrnxt xr
#
#      loop through vrblks on one hash chain
#
sclr4:  MOV                 #point to next vrblk on chain} mov vrnxt(xr) xr
        OR                  #jump for next bucket if chain end} bze xr sclr3
        JZ   sclr3
        CMP  DWORD PTR DWORD PTR (4*vrget)[],0 #jump if not flagged} bnz vrget(xr) sclr5
        JNZ  sclr5
                            #} ejc
        .eject
#
#      clear (continued)
#
#      here for flagged variable, do not set value to null
#
        CALL setvr          #for flagged var, restore vrget} jsr setvr
        JMP  sclr4          #and loop back for next vrblk} brn sclr4
#
#      here to set value of a variable to null
#      protected variables (arb, etc) are exempt
#
sclr5:  CMP  DWORD PTR (4*vrsto)[],offset b_vre #check for protected variable} beq vrsto(xr) =b_vre sclr4
             sclr4
        MOV                 #copy vrblk pointer} mov xr xl
#
#      loop to locate value at end of possible trblk chain
#
sclr6:  MOV                 #save block pointer} mov xl wa
        MOV                 #load next value field} mov vrval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop back if trapped} beq (xl) =b_trt sclr6
             sclr6
#
#      now store the null value
#
        MOV                 #restore block pointer} mov wa xl
        MOV  DWORD PTR (4*vrval)[],offset nulls #store null constant value} mov =nulls vrval(xl)
        JMP  sclr4          #loop back for next vrblk} brn sclr4
                            #} ejc
        .eject
#
#      code
#
        .balign 2           #entry point} ent
        NOP
s_cod:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CALL gtcod          #convert to code} jsr gtcod
        .short exfal-DFFNC  #fail if conversion is impossible} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      collect
#
        .balign 2           #entry point} ent
        NOP
s_col:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CALL gtint          #convert to integer} jsr gtint
        .short ERR_-73-DFFNC #} err 073 collect argument is not integer
        MOV  EDX,DWORD PTR (4*icval)[] #load collect argument} ldi icval(xr)
        MOV  DWORD PTR clsvi,EDX #save collect argument} sti clsvi
        XOR                 #set no move up} zer wb
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        XOR  EAX,EAX        #collect sediment too} zer dnams
        MOV  DWORD PTR dnams,EAX
        CALL gbcol          #perform garbage collection} jsr gbcol
        MOV  DWORD PTR dnams #record new sediment size} mov xr dnams
        MOV                 #point to end of memory} mov dname wa
        SUB                 #subtract next location} sub dnamp wa
        SHR                 #convert bytes to words} btw wa
        MOV  EDX            #convert words available as integer} mti wa
        SUB  EDX,DWORD PTR clsvi #subtract argument} sbi clsvi
        JO   exfal          #fail if overflow} iov exfal
        OR   EDX,EDX        #fail if not enough} ilt exfal
        JL   exfal
        ADD  EDX,DWORD PTR clsvi #else recompute available} adi clsvi
        JMP  exint          #and exit with integer result} brn exint
                            #} ejc
        .eject
#
#      convert
#
        .balign 2           #entry point} ent
        NOP
s_cnv:
        CALL gtstg          #convert second argument to string} jsr gtstg
        .short scv29-DFFNC  #error if second argument not string} ppm scv29
        OR                  #or if null string} bze wa scv29
        JZ   scv29
        CALL flstg          #fold lower case to upper case} jsr flstg
        MOV                 #load first argument} mov (xs) xl
        CMP  DWORD PTR [],offset b_pdt #jump if not program defined} bne (xl) =b_pdt scv01
             scv01
#
#      here for program defined datatype
#
        MOV                 #point to dfblk} mov pddfp(xl) xl
        MOV                 #load datatype name} mov dfnam(xl) xl
        CALL ident          #compare with second arg} jsr ident
        .short exits-DFFNC  #exit if ident with arg as result} ppm exits
        JMP  exfal          #else fail} brn exfal
#
#      here if not program defined datatype
#
scv01:  LEA                 #save string argument} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #point to table of names to compare} mov =svctb xl
        XOR                 #initialize counter} zer wb
        MOV                 #save length of argument string} mov wa wc
#
#      loop through table entries
#
scv02:  MOV                 #load next table entry, bump pointer} mov (xl)+ xr
        LEA
        OR                  #fail if zero marking end of list} bze xr exfal
        JZ   exfal
        CMP                 #jump if wrong length} bne wc sclen(xr) scv05
             scv05
        MOV  DWORD PTR cnvtp #else store table pointer} mov xl cnvtp
        ADD                 #point to chars of table entry} plc xr
        MOV                 #load pointer to string argument} mov (xs) xl
        ADD                 #point to chars of string arg} plc xl
        MOV                 #set number of chars to compare} mov wc wa
        REPE CMPSB          #compare, jump if no match} cmc scv04 scv04
        MOV  ESI,0
        MOV  EDI,ESI
        JNZ  scv04
                            #} ejc
        .eject
#
#      convert (continued)
#
#      here we have a match
#
scv03:  MOV                 #copy entry number} mov wb xl
        ADD                 #pop string arg off stack} ica xs
        MOV                 #load first argument} mov (xs)+ xr
        LEA
        JMP  DWORD PTR L0003[*4] #jump to appropriate routine} bsw xl cnvtt
        DSeg_
L0003:
        .long scv06         #string} iff 0 scv06
        .long scv07         #integer} iff 1 scv07
        .long scv09         #name} iff 2 scv09
        .long scv10         #pattern} iff 3 scv10
        .long scv11         #array} iff 4 scv11
        .long scv19         #table} iff 5 scv19
        .long scv25         #expression} iff 6 scv25
        .long scv26         #code} iff 7 scv26
        .long scv27         #numeric} iff 8 scv27
        .long scv08         #real} iff cnvrt scv08
        DSegEnd_            #end of switch table} esw
        CSeg_
#
#      here if no match with table entry
#
scv04:  MOV                 #restore table pointer, merge} mov cnvtp xl
#
#      merge here if lengths did not match
#
scv05:  INC                 #bump entry number} icv wb
        JMP  scv02          #loop back to check next entry} brn scv02
#
#      here to convert to string
#
scv06:  LEA                 #replace string argument on stack} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert to string} jsr gtstg
        .short exfal-DFFNC  #fail if conversion not possible} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      convert (continued)
#
#      here to convert to integer
#
scv07:  CALL gtint          #convert to integer} jsr gtint
        .short exfal-DFFNC  #fail if conversion not possible} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      here to convert to real
#
scv08:  CALL gtrea          #convert to real} jsr gtrea
        .short exfal-DFFNC  #fail if conversion not possible} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      here to convert to name
#
scv09:  CMP  DWORD PTR [],offset b_nml #return if already a name} beq (xr) =b_nml exixr
             exixr
        CALL gtnvr          #else try string to name convert} jsr gtnvr
        .short exfal-DFFNC  #fail if conversion not possible} ppm exfal
        JMP  exvnm          #else exit building nmblk for vrblk} brn exvnm
#
#      here to convert to pattern
#
scv10:  CALL gtpat          #convert to pattern} jsr gtpat
        .short exfal-DFFNC  #fail if conversion not possible} ppm exfal
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      convert to array
#
#      if the first argument is a table, then we go through
#      an intermediate array of addresses that is sorted to
#      provide a result ordered by time of entry in the
#      original table.  see c3.762.
#
scv11:  LEA                 #save argument on stack} mov xr -(xs)
        MOV  DWORD PTR []
        XOR                 #use table chain block addresses} zer wa
        CALL gtarr          #get an array} jsr gtarr
        .short exfal-DFFNC  #fail if empty table} ppm exfal
        .short exfal-DFFNC  #fail if not convertible} ppm exfal
        MOV                 #reload original arg} mov (xs)+ xl
        LEA
        CMP  DWORD PTR [],offset b_tbt #exit if original not a table} bne (xl) =b_tbt exsid
             exsid
        LEA                 #sort the intermediate array} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #on first column} mov =nulls -(xs)
        MOV  DWORD PTR [],offset nulls
        XOR                 #sort ascending} zer wa
        CALL sorta          #do sort} jsr sorta
        .short exfal-DFFNC  #if sort fails, so shall we} ppm exfal
        MOV                 #save array result} mov xr wb
        MOV  EDX,DWORD PTR (4*ardim)[] #load dim 1 (number of elements)} ldi ardim(xr)
        MOV                 #get as one word integer} mfi wa
        ADD                 #point to first element in array} add *arvl2 xr
#
#      here for each row of this 2-column array
#
scv12:  MOV                 #get teblk address} mov (xr) xl
        MOV  EAX,DWORD PTR (4*tesub)[] #replace with subscript} mov tesub(xl) (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        MOV  EAX,DWORD PTR (4*teval)[] #replace with value} mov teval(xl) (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop till all copied over} bct wa scv12
        JNZ  scv12
        MOV                 #retrieve array address} mov wb xr
        JMP  exsid          #exit setting id field} brn exsid
#
#      convert to table
#
scv19:  MOV                 #load first word of block} mov (xr) wa
        LEA                 #replace arblk pointer on stack} mov xr -(xs)
        MOV  DWORD PTR []
        CMP                 #return arg if already a table} beq wa =b_tbt exits
             exits
        CMP                 #else fail if not an array} bne wa =b_art exfal
             exfal
                            #} ejc
        .eject
#
#      convert (continued)
#
#      here to convert an array to table
#
        CMP  DWORD PTR (4*arndm)[],num02 #fail if not 2-dim array} bne arndm(xr) =num02 exfal
             exfal
        MOV  EDX,DWORD PTR (4*ardm2)[] #load dim 2} ldi ardm2(xr)
        SUB  EDX,DWORD PTR intv2 #subtract 2 to compare} sbi intv2
#        OR   EDX,EDX        #fail if dim2 not 2} ine exfal   (Optimized)
        JNE  exfal
#
#      here we have an arblk of the right shape
#
        MOV  EDX,DWORD PTR (4*ardim)[] #load dim 1 (number of elements)} ldi ardim(xr)
        MOV                 #get as one word integer} mfi wa
        MOV                 #copy to control loop} lct wb wa
        ADD                 #add space for standard fields} add =tbsi_ wa
        SAL                 #convert length to bytes} wtb wa
        CALL alloc          #allocate space for tbblk} jsr alloc
        MOV                 #copy tbblk pointer} mov xr wc
        LEA                 #save tbblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR [],offset b_tbt #store type word} mov =b_tbt (xr)+
        LEA
        XOR  EAX,EAX        #store zero for idval for now} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        MOV  DWORD PTR []   #store length} mov wa (xr)+
        LEA
        MOV  DWORD PTR [],offset nulls #null initial lookup value} mov =nulls (xr)+
        LEA
#
#      loop to initialize bucket ptrs to point to table
#
scv20:  MOV  DWORD PTR []   #set bucket ptr to point to tbblk} mov wc (xr)+
        LEA
        DEC                 #loop till all initialized} bct wb scv20
        JNZ  scv20
        MOV                 #set offset to first arblk element} mov *arvl2 wb
#
#      loop to copy elements from array to table
#
scv21:  MOV                 #point to arblk} mov num01(xs) xl
        CMP                 #jump if all moved} beq wb arlen(xl) scv24
             scv24
        ADD                 #else point to current location} add wb xl
        ADD                 #bump offset} add *num02 wb
        MOV                 #load subscript name} mov (xl) xr
        SUB                 #adjust ptr to merge (trval=1+1)} dca xl
                            #} ejc
        .eject
#
#      convert (continued)
#
#      loop to chase down trblk chain for value
#
scv22:  MOV                 #point to next value} mov trval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop back if trapped} beq (xl) =b_trt scv22
             scv22
#
#      here with name in xr, value in xl
#
scv23:  LEA                 #stack value} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #load tbblk pointer} mov num01(xs) xl
        CALL tfind          #build teblk (note wb gt 0 by name)} jsr tfind
        .short exfal-DFFNC  #fail if acess fails} ppm exfal
        MOV  EAX,DWORD PTR [] #store value in teblk} mov (xs)+ teval(xl)
        MOV  DWORD PTR (4*teval)[],EAX
        LEA
        JMP  scv21          #loop back for next element} brn scv21
#
#      here after moving all elements to tbblk
#
scv24:  MOV                 #load tbblk pointer} mov (xs)+ xr
        LEA
        ADD                 #pop arblk pointer} ica xs
        JMP  exsid          #exit setting idval} brn exsid
#
#      convert to expression
#
scv25:  XOR                 #by value} zer wb
        CALL gtexp          #convert to expression} jsr gtexp
        .short exfal-DFFNC  #fail if conversion not possible} ppm exfal
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      convert to code
#
scv26:  CALL gtcod          #convert to code} jsr gtcod
        .short exfal-DFFNC  #fail if conversion is not possible} ppm exfal
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      convert to numeric
#
scv27:  CALL gtnum          #convert to numeric} jsr gtnum
        .short exfal-DFFNC  #fail if unconvertible} ppm exfal
scv31:  LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      second argument not string or null
#
scv29:  CALL ERR_0          #} erb 074 convert second argument is not a string
        .byte 74
#
#      copy
#
        .balign 2           #entry point} ent
        NOP
s_cop:
        CALL copyb          #copy the block} jsr copyb
        .short exits-DFFNC  #return if no idval field} ppm exits
        JMP  exsid          #exit setting id value} brn exsid
                            #} ejc
        .eject
#
#      cos
#
        .balign 2           #entry point} ent
        NOP
s_cos:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-303-DFFNC #} err 303 cos argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL cos_           #take cosine} cos
        CALL OVR_           #if no overflow, return result in ra} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 322 cos argument is out of range
        .byte 66
                            #} ejc
        .eject
#
#      data
#
        .balign 2           #entry point} ent
        NOP
s_dat:
        CALL xscni          #prepare to scan argument} jsr xscni
        .short ERR_-75-DFFNC #} err 075 data argument is not a string
        .short ERR_-76-DFFNC #} err 076 data argument is null
#
#      scan out datatype name
#
        MOV                 #delimiter one = left paren} mov =ch_pp wc
        MOV                 #delimiter two = left paren} mov wc xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan datatype name} jsr xscan
        OR                  #skip if left paren found} bnz wa sdat1
        JNZ  sdat1
        CALL ERR_0          #} erb 077 data argument is missing a left paren
        .byte 77
#
#      here after scanning datatype name
#
sdat1:  MOV                 #get length} mov sclen(xr) wa
        OR                  #avoid folding if null string} bze wa sdt1a
        JZ   sdt1a
        CALL flstg          #fold lower case to upper case} jsr flstg
sdt1a:  MOV                 #save name ptr} mov xr xl
        MOV                 #get length} mov sclen(xr) wa
        ADD                 #compute space needed} ctb wa scsi_
        AND
        CALL alost          #request static store for name} jsr alost
        LEA                 #save datatype name} mov xr -(xs)
        MOV  DWORD PTR []
        SHR  ECX,2          #copy name to static} mvw
        REP  MOVSD
        MOV                 #get name ptr} mov (xs) xr
        XOR                 #scrub dud register} zer xl
        CALL gtnvr          #locate vrblk for datatype name} jsr gtnvr
        .short ERR_-78-DFFNC #} err 078 data argument has null datatype name
        MOV  DWORD PTR datdv #save vrblk pointer for datatype} mov xr datdv
        MOV  DWORD PTR datxs #store starting stack value} mov xs datxs
        XOR                 #zero count of field names} zer wb
#
#      loop to scan field names and stack vrblk pointers
#
sdat2:  MOV                 #delimiter one = right paren} mov =ch_rp wc
        MOV                 #delimiter two = comma} mov =ch_cm xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan next field name} jsr xscan
        OR                  #jump if delimiter found} bnz wa sdat3
        JNZ  sdat3
        CALL ERR_0          #} erb 079 data argument is missing a right paren
        .byte 79
#
#      here after scanning out one field name
#
sdat3:  CALL gtnvr          #locate vrblk for field name} jsr gtnvr
        .short ERR_-80-DFFNC #} err 080 data argument has null field name
        LEA                 #stack vrblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        INC                 #increment counter} icv wb
        CMP                 #loop back if stopped by comma} beq wa =num02 sdat2
             sdat2
                            #} ejc
        .eject
#
#      data (continued)
#
#      now build the dfblk
#
        MOV                 #set size of dfblk standard fields} mov =dfsi_ wa
        ADD                 #add number of fields} add wb wa
        SAL                 #convert length to bytes} wtb wa
        MOV                 #preserve no. of fields} mov wb wc
        CALL alost          #allocate space for dfblk} jsr alost
        MOV                 #get no of fields} mov wc wb
        MOV                 #point to start of stack} mov datxs xt
        MOV                 #load datatype name} mov (xt) wc
        MOV  DWORD PTR []   #save dfblk pointer on stack} mov xr (xt)
        MOV  DWORD PTR [],offset b_dfc #store type word} mov =b_dfc (xr)+
        LEA
        MOV  DWORD PTR []   #store number of fields (fargs)} mov wb (xr)+
        LEA
        MOV  DWORD PTR []   #store length (dflen)} mov wa (xr)+
        LEA
        SUB                 #compute pdblk length (for dfpdl)} sub *pddfs wa
        MOV  DWORD PTR []   #store pdblk length (dfpdl)} mov wa (xr)+
        LEA
        MOV  DWORD PTR []   #store datatype name (dfnam)} mov wc (xr)+
        LEA
        MOV                 #copy number of fields} lct wc wb
#
#      loop to move field name vrblk pointers to dfblk
#
sdat4:  LEA                 #move one field name vrblk pointer} mov -(xt) (xr)+
        MOV  EAX,DWORD PTR []
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop till all moved} bct wc sdat4
        JNZ  sdat4
#
#      now define the datatype function
#
        MOV                 #copy length of pdblk for later loop} mov wa wc
        MOV                 #point to vrblk} mov datdv xr
        MOV                 #point back on stack} mov datxs xt
        MOV                 #load dfblk pointer} mov (xt) xl
        CALL dffnc          #define function} jsr dffnc
                            #} ejc
        .eject
#
#      data (continued)
#
#      loop to build ffblks
#
#
#      notice that the ffblks are constructed in reverse order
#      so that the required offsets can be obtained from
#      successive decrementation of the pdblk length (in wc).
#
sdat5:  MOV                 #set length of ffblk} mov *ffsi_ wa
        CALL alloc          #allocate space for ffblk} jsr alloc
        MOV  DWORD PTR [],offset b_ffc #set type word} mov =b_ffc (xr)
        MOV  DWORD PTR (4*fargs)[],num01 #store fargs (always one)} mov =num01 fargs(xr)
        MOV                 #point back on stack} mov datxs xt
        MOV  EAX,DWORD PTR [] #copy dfblk ptr to ffblk} mov (xt) ffdfp(xr)
        MOV  DWORD PTR (4*ffdfp)[],EAX
        SUB                 #decrement old dfpdl to get next ofs} dca wc
        MOV  DWORD PTR (4*ffofs)[] #set offset to this field} mov wc ffofs(xr)
        XOR  EAX,EAX        #tentatively set zero forward ptr} zer ffnxt(xr)
        MOV  DWORD PTR (4*ffnxt)[],EAX
        MOV                 #copy ffblk pointer for dffnc} mov xr xl
        MOV                 #load vrblk pointer for field} mov (xs) xr
        MOV                 #load current function pointer} mov vrfnc(xr) xr
        CMP  DWORD PTR [],offset b_ffc #skip if not currently a field func} bne (xr) =b_ffc sdat6
             sdat6
#
#      here we must chain an old ffblk ptr to preserve it in the
#      case of multiple field functions with the same name
#
        MOV  DWORD PTR (4*ffnxt)[] #link new ffblk to previous chain} mov xr ffnxt(xl)
#
#      merge here to define field function
#
sdat6:  MOV                 #load vrblk pointer} mov (xs)+ xr
        LEA
        CALL dffnc          #define field function} jsr dffnc
        CMP                 #loop back till all done} bne xs datxs sdat5
             sdat5
        ADD                 #pop dfblk pointer} ica xs
        JMP  exnul          #return with null result} brn exnul
                            #} ejc
        .eject
#
#      datatype
#
        .balign 2           #entry point} ent
        NOP
s_dtp:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CALL dtype          #get datatype} jsr dtype
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      date
#
        .balign 2           #entry point} ent
        NOP
s_dte:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CALL gtint          #convert to an integer} jsr gtint
        .short ERR_-330-DFFNC #} err 330 date argument is not integer
        CALL sysdt          #call system date routine} jsr sysdt
        MOV                 #load length for sbstr} mov num01(xl) wa
        OR                  #return null if length is zero} bze wa exnul
        JZ   exnul
        XOR                 #set zero offset} zer wb
        CALL sbstr          #use sbstr to build scblk} jsr sbstr
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      define
#
        .balign 2           #entry point} ent
        NOP
s_def:
        MOV                 #load second argument} mov (xs)+ xr
        LEA
        XOR  EAX,EAX        #zero label pointer in case null} zer deflb
        MOV  DWORD PTR deflb,EAX
        CMP                 #jump if null second argument} beq xr =nulls sdf01
             sdf01
        CALL gtnvr          #else find vrblk for label} jsr gtnvr
        .short sdf12-DFFNC  #jump if not a variable name} ppm sdf12
        MOV  DWORD PTR deflb #else set specified entry} mov xr deflb
#
#      scan function name
#
sdf01:  CALL xscni          #prepare to scan first argument} jsr xscni
        .short ERR_-81-DFFNC #} err 081 define first argument is not a string
        .short ERR_-82-DFFNC #} err 082 define first argument is null
        MOV                 #delimiter one = left paren} mov =ch_pp wc
        MOV                 #delimiter two = left paren} mov wc xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan out function name} jsr xscan
        OR                  #jump if left paren found} bnz wa sdf02
        JNZ  sdf02
        CALL ERR_0          #} erb 083 define first argument is missing a left paren
        .byte 83
#
#      here after scanning out function name
#
sdf02:  CALL gtnvr          #get variable name} jsr gtnvr
        .short ERR_-84-DFFNC #} err 084 define first argument has null function name
        MOV  DWORD PTR defvr #save vrblk pointer for function nam} mov xr defvr
        XOR                 #zero count of arguments} zer wb
        MOV  DWORD PTR defxs #save initial stack pointer} mov xs defxs
        CMP  DWORD PTR DWORD PTR deflb,0 #jump if second argument given} bnz deflb sdf03
        JNZ  sdf03
        MOV  DWORD PTR deflb #else default is function name} mov xr deflb
#
#      loop to scan argument names and stack vrblk pointers
#
sdf03:  MOV                 #delimiter one = right paren} mov =ch_rp wc
        MOV                 #delimiter two = comma} mov =ch_cm xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan out next argument name} jsr xscan
        OR                  #skip if delimiter found} bnz wa sdf04
        JNZ  sdf04
        CALL ERR_0          #} erb 085 null arg name or missing ) in define first arg.
        .byte 85
                            #} ejc
        .eject
#
#      define (continued)
#
#      here after scanning an argument name
#
sdf04:  CMP                 #skip if non-null} bne xr =nulls sdf05
             sdf05
        OR                  #ignore null if case of no arguments} bze wb sdf06
        JZ   sdf06
#
#      here after dealing with the case of no arguments
#
sdf05:  CALL gtnvr          #get vrblk pointer} jsr gtnvr
        .short sdf03-DFFNC  #loop back to ignore null name} ppm sdf03
        LEA                 #stack argument vrblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        INC                 #increment counter} icv wb
        CMP                 #loop back if stopped by a comma} beq wa =num02 sdf03
             sdf03
#
#      here after scanning out function argument names
#
sdf06:  MOV  DWORD PTR defna #save number of arguments} mov wb defna
        XOR                 #zero count of locals} zer wb
#
#      loop to scan local names and stack vrblk pointers
#
sdf07:  MOV                 #set delimiter one = comma} mov =ch_cm wc
        MOV                 #set delimiter two = comma} mov wc xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan out next local name} jsr xscan
        CMP                 #skip if non-null} bne xr =nulls sdf08
             sdf08
        OR                  #exit scan if end of string} bze wa sdf09
        JZ   sdf09
#
#      here after scanning out a local name
#
sdf08:  CALL gtnvr          #get vrblk pointer} jsr gtnvr
        .short sdf07-DFFNC  #loop back to ignore null name} ppm sdf07
        INC                 #if ok, increment count} icv wb
        LEA                 #stack vrblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        OR                  #loop back if stopped by a comma} bnz wa sdf07
        JNZ  sdf07
                            #} ejc
        .eject
#
#      define (continued)
#
#      here after scanning locals, build pfblk
#
sdf09:  MOV                 #copy count of locals} mov wb wa
        ADD                 #add number of arguments} add defna wa
        MOV                 #set sum args+locals as loop count} mov wa wc
        ADD                 #add space for standard fields} add =pfsi_ wa
        SAL                 #convert length to bytes} wtb wa
        CALL alloc          #allocate space for pfblk} jsr alloc
        MOV                 #save pointer to pfblk} mov xr xl
        MOV  DWORD PTR [],offset b_pfc #store first word} mov =b_pfc (xr)+
        LEA
        MOV  EAX,DWORD PTR defna #store number of arguments} mov defna (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        MOV  DWORD PTR []   #store length (pflen)} mov wa (xr)+
        LEA
        MOV  EAX,DWORD PTR defvr #store vrblk ptr for function name} mov defvr (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        MOV  DWORD PTR []   #store number of locals} mov wb (xr)+
        LEA
        XOR  EAX,EAX        #deal with label later} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        XOR  EAX,EAX        #zero pfctr} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        XOR  EAX,EAX        #zero pfrtr} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        OR                  #skip if no args or locals} bze wc sdf11
        JZ   sdf11
        MOV                 #keep pfblk pointer} mov xl wa
        MOV                 #point before arguments} mov defxs xt
#
#      loop to move locals and args to pfblk
#
sdf10:  LEA                 #store one entry and bump pointers} mov -(xt) (xr)+
        MOV  EAX,DWORD PTR []
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop till all stored} bct wc sdf10
        JNZ  sdf10
        MOV                 #recover pfblk pointer} mov wa xl
                            #} ejc
        .eject
#
#      define (continued)
#
#      now deal with label
#
sdf11:  MOV                 #pop stack} mov defxs xs
        MOV  EAX,DWORD PTR deflb #store label vrblk in pfblk} mov deflb pfcod(xl)
        MOV  DWORD PTR (4*pfcod)[],EAX
        MOV                 #point back to vrblk for function} mov defvr xr
        CALL dffnc          #define function} jsr dffnc
        JMP  exnul          #and exit returning null} brn exnul
#
#      here for erroneous label
#
sdf12:  CALL ERR_0          #} erb 086 define function entry point is not defined label
        .byte 86
                            #} ejc
        .eject
#
#      detach
#
        .balign 2           #entry point} ent
        NOP
s_det:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CALL gtvar          #locate variable} jsr gtvar
        .short ERR_-87-DFFNC #} err 087 detach argument is not appropriate name
        CALL dtach          #detach i/o association from name} jsr dtach
        JMP  exnul          #return null result} brn exnul
                            #} ejc
        .eject
#
#      differ
#
        .balign 2           #entry point} ent
        NOP
s_dif:
        MOV                 #load second argument} mov (xs)+ xr
        LEA
        MOV                 #load first argument} mov (xs)+ xl
        LEA
        CALL ident          #call ident comparison routine} jsr ident
        .short exfal-DFFNC  #fail if ident} ppm exfal
        JMP  exnul          #return null if differ} brn exnul
                            #} ejc
        .eject
#
#      dump
#
        .balign 2           #entry point} ent
        NOP
s_dmp:
        CALL gtsmi          #load dump arg as small integer} jsr gtsmi
        .short ERR_-88-DFFNC #} err 088 dump argument is not integer
        .short ERR_-89-DFFNC #} err 089 dump argument is negative or too large
        CALL dumpr          #else call dump routine} jsr dumpr
        JMP  exnul          #and return null as result} brn exnul
                            #} ejc
        .eject
#
#      dupl
#
        .balign 2           #entry point} ent
        NOP
s_dup:
        CALL gtsmi          #get second argument as small integr} jsr gtsmi
        .short ERR_-90-DFFNC #} err 090 dupl second argument is not integer
        .short sdup7-DFFNC  #jump if negative or too big} ppm sdup7
        MOV                 #save duplication factor} mov xr wb
        CALL gtstg          #get first arg as string} jsr gtstg
        .short sdup4-DFFNC  #jump if not a string} ppm sdup4
#
#      here for case of duplication of a string
#
        MOV  EDX            #acquire length as integer} mti wa
        MOV  DWORD PTR dupsi,EDX #save for the moment} sti dupsi
        MOV  EDX            #get duplication factor as integer} mti wb
        IMUL EDX,DWORD PTR dupsi #form product} mli dupsi
        JO   sdup3          #jump if overflow} iov sdup3
        OR   EDX,EDX        #return null if result length = 0} ieq exnul
        JE   exnul
        OR   EDX,EDX        #get as addr integer, check ovflo} mfi wa sdup3
        JS   sdup3
        MOV
#
#      merge here with result length in wa
#
sdup1:  MOV                 #save string pointer} mov xr xl
        CALL alocs          #allocate space for string} jsr alocs
        LEA                 #save as result pointer} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #save pointer to argument string} mov xl wc
        ADD                 #prepare to store chars of result} psc xr
#
#      loop through duplications
#
sdup2:  MOV                 #point back to argument string} mov wc xl
        MOV                 #get number of characters} mov sclen(xl) wa
        ADD                 #point to chars in argument string} plc xl
        SHRD EAX,ECX,1      #move characters to result string} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        DEC                 #loop till all duplications done} bct wb sdup2
        JNZ  sdup2
        XOR                 #clear garbage value} zer xl
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      dupl (continued)
#
#      here if too large, set max length and let alocs catch it
#
sdup3:  MOV                 #set impossible length for alocs} mov dname wa
        JMP  sdup1          #merge back} brn sdup1
#
#      here if not a string
#
sdup4:  CALL gtpat          #convert argument to pattern} jsr gtpat
        .short ERR_-91-DFFNC #} err 091 dupl first argument is not a string or pattern
#
#      here to duplicate a pattern argument
#
        LEA                 #store pattern on stack} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #start off with null pattern} mov =ndnth xr
        OR                  #null pattern is result if dupfac=0} bze wb sdup6
        JZ   sdup6
        LEA                 #preserve loop count} mov wb -(xs)
        MOV  DWORD PTR []
#
#      loop to duplicate by successive concatenation
#
sdup5:  MOV                 #copy current value as right argumnt} mov xr xl
        MOV                 #get a new copy of left} mov num01(xs) xr
        CALL pconc          #concatenate} jsr pconc
        DEC  DWORD PTR []   #count down} dcv (xs)
        CMP  DWORD PTR DWORD PTR [],0 #loop} bnz (xs) sdup5
        JNZ  sdup5
        ADD                 #pop loop count} ica xs
#
#      here to exit after constructing pattern
#
sdup6:  MOV  DWORD PTR []   #store result on stack} mov xr (xs)
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
#
#      fail if second arg is out of range
#
sdup7:  ADD                 #pop first argument} ica xs
        JMP  exfal          #fail} brn exfal
                            #} ejc
        .eject
#
#      eject
#
        .balign 2           #entry point} ent
        NOP
s_ejc:
        CALL iofcb          #call fcblk routine} jsr iofcb
        .short ERR_-92-DFFNC #} err 092 eject argument is not a suitable name
        .short sejc1-DFFNC  #null argument} ppm sejc1
        .short ERR_-93-DFFNC #} err 093 eject file does not exist
        CALL sysef          #call eject file function} jsr sysef
        .short ERR_-93-DFFNC #} err 093 eject file does not exist
        .short ERR_-94-DFFNC #} err 094 eject file does not permit page eject
        .short ERR_-95-DFFNC #} err 095 eject caused non-recoverable output error
        JMP  exnul          #return null as result} brn exnul
#
#      here to eject standard output file
#
sejc1:  CALL sysep          #call routine to eject printer} jsr sysep
        JMP  exnul          #exit with null result} brn exnul
                            #} ejc
        .eject
#
#      endfile
#
        .balign 2           #entry point} ent
        NOP
s_enf:
        CALL iofcb          #call fcblk routine} jsr iofcb
        .short ERR_-96-DFFNC #} err 096 endfile argument is not a suitable name
        .short ERR_-97-DFFNC #} err 097 endfile argument is null
        .short ERR_-98-DFFNC #} err 098 endfile file does not exist
        CALL sysen          #call endfile routine} jsr sysen
        .short ERR_-98-DFFNC #} err 098 endfile file does not exist
        .short ERR_-99-DFFNC #} err 099 endfile file does not permit endfile
        .short ERR_-100-DFFNC #} err 100 endfile caused non-recoverable output error
        MOV                 #remember vrblk ptr from iofcb call} mov xl wb
        MOV                 #copy pointer} mov xl xr
#
#      loop to find trtrf block
#
senf1:  MOV                 #remember previous entry} mov xr xl
        MOV                 #chain along} mov trval(xr) xr
        CMP  DWORD PTR [],offset b_trt #skip out if chain end} bne (xr) =b_trt exnul
             exnul
        CMP  DWORD PTR (4*trtyp)[],trtfc #loop if not found} bne trtyp(xr) =trtfc senf1
             senf1
        MOV  EAX,DWORD PTR (4*trval)[] #remove trtrf} mov trval(xr) trval(xl)
        MOV  DWORD PTR (4*trval)[],EAX
        MOV  EAX,DWORD PTR (4*trtrf)[] #point to head of iochn} mov trtrf(xr) enfch
        MOV  DWORD PTR enfch,EAX
        MOV                 #point to fcblk} mov trfpt(xr) wc
        MOV                 #filearg1 vrblk from iofcb} mov wb xr
        CALL setvr          #reset it} jsr setvr
        MOV                 #ptr to head of fcblk chain} mov =r_fcb xl
        SUB                 #adjust ready to enter loop} sub *num02 xl
#
#      find fcblk
#
senf2:  MOV                 #copy ptr} mov xl xr
        MOV                 #get next link} mov num02(xl) xl
        OR                  #stop if chain end} bze xl senf4
        JZ   senf4
        CMP  DWORD PTR (4*num03)[] #jump if fcblk found} beq num03(xl) wc senf3
             senf3
        JMP  senf2          #loop} brn senf2
#
#      remove fcblk
#
senf3:  MOV  EAX,DWORD PTR (4*num02)[] #delete fcblk from chain} mov num02(xl) num02(xr)
        MOV  DWORD PTR (4*num02)[],EAX
#
#      loop which detaches all vbls on iochn chain
#
senf4:  MOV                 #get chain head} mov enfch xl
        OR                  #finished if chain end} bze xl exnul
        JZ   exnul
        MOV  EAX,DWORD PTR (4*trtrf)[] #chain along} mov trtrf(xl) enfch
        MOV  DWORD PTR enfch,EAX
        MOV                 #name offset} mov ionmo(xl) wa
        MOV                 #name base} mov ionmb(xl) xl
        CALL dtach          #detach name} jsr dtach
        JMP  senf4          #loop till done} brn senf4
                            #} ejc
        .eject
#
#      eq
#
        .balign 2           #entry point} ent
        NOP
s_eqf:
        CALL acomp          #call arithmetic comparison routine} jsr acomp
        .short ERR_-101-DFFNC #} err 101 eq first argument is not numeric
        .short ERR_-102-DFFNC #} err 102 eq second argument is not numeric
        .short exfal-DFFNC  #fail if lt} ppm exfal
        .short exnul-DFFNC  #return null if eq} ppm exnul
        .short exfal-DFFNC  #fail if gt} ppm exfal
                            #} ejc
        .eject
#
#      eval
#
        .balign 2           #entry point} ent
        NOP
s_evl:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        MOV                 #load next code word} lcw wc
        ADD  EBP,4
        CMP                 #jump if called by value} bne wc =ofne_ sevl1
             sevl1
        MOV                 #copy code pointer} scp xl
        MOV                 #get next code word} mov (xl) wa
        CMP                 #by name unless expression} bne wa =ornm_ sevl2
             sevl2
        CMP  DWORD PTR DWORD PTR (4*num01)[],0 #jump if by name} bnz num01(xs) sevl2
        JNZ  sevl2
#
#      here if called by value
#
sevl1:  XOR                 #set flag for by value} zer wb
        LEA                 #save code word} mov wc -(xs)
        MOV  DWORD PTR []
        CALL gtexp          #convert to expression} jsr gtexp
        .short ERR_-103-DFFNC #} err 103 eval argument is not expression
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        XOR                 #set flag for by value} zer wb
        CALL evalx          #evaluate expression by value} jsr evalx
        .short exfal-DFFNC  #fail if evaluation fails} ppm exfal
        MOV                 #copy result} mov xr xl
        MOV                 #reload next code word} mov (xs) xr
        MOV  DWORD PTR []   #stack result} mov xl (xs)
        JMP  DWORD PTR []   #jump to execute next code word} bri (xr)
#
#      here if called by name
#
sevl2:  MOV                 #set flag for by name} mov =num01 wb
        CALL gtexp          #convert to expression} jsr gtexp
        .short ERR_-103-DFFNC #} err 103 eval argument is not expression
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        MOV                 #set flag for by name} mov =num01 wb
        CALL evalx          #evaluate expression by name} jsr evalx
        .short exfal-DFFNC  #fail if evaluation fails} ppm exfal
        JMP  exnam          #exit with name} brn exnam
                            #} ejc
        .eject
#
#      exit
#
        .balign 2           #entry point} ent
        NOP
s_ext:
        XOR                 #clear amount of static shift} zer wb
        XOR  EAX,EAX        #forget interim code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        XOR  EAX,EAX        #collect sediment too} zer dnams
        MOV  DWORD PTR dnams,EAX
        CALL gbcol          #compact memory by collecting} jsr gbcol
        MOV  DWORD PTR dnams #record new sediment size} mov xr dnams
        CALL gtstg          #} jsr gtstg
        .short ERR_-288-DFFNC #} err 288 exit second argument is not a string
        MOV                 #copy second arg string pointer} mov xr xl
        CALL gtstg          #convert arg to string} jsr gtstg
        .short ERR_-104-DFFNC #} err 104 exit first argument is not suitable integer or string
        LEA                 #save second argument} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #copy first arg string ptr} mov xr xl
        CALL gtint          #check it is integer} jsr gtint
        .short sext1-DFFNC  #skip if unconvertible} ppm sext1
        XOR                 #note it is integer} zer xl
        MOV  EDX,DWORD PTR (4*icval)[] #get integer arg} ldi icval(xr)
#
#      merge to call osint exit routine
#
sext1:  MOV                 #get fcblk chain header} mov r_fcb wb
        MOV                 #point to v.v string} mov =headv xr
        MOV                 #provide second argument scblk} mov (xs)+ wa
        LEA
        CALL sysxi          #call external routine} jsr sysxi
        .short ERR_-105-DFFNC #} err 105 exit action not available in this implementation
        .short ERR_-106-DFFNC #} err 106 exit action caused irrecoverable error
        OR   EDX,EDX        #return if argument 0} ieq exnul
        JE   exnul
        OR   EDX,EDX        #skip if positive} igt sext2
        JG   sext2
        NEG  EDX            #make positive} ngi
#
#      check for option respecification
#
#      sysxi returns 0 in wa when a file has been resumed,
#      1 when this is a continuation of an exit(4) or exit(-4)
#      action.
#
sext2:  MOV                 #get value in work reg} mfi wc
        ADD                 #prepare to test for continue} add wc wa
        CMP                 #continued execution if 4 plus 1} beq wa =num05 sext5
             sext5
        XOR  EAX,EAX        #resuming execution so reset} zer gbcnt
        MOV  DWORD PTR gbcnt,EAX
        CMP                 #skip if was 3 or 4} bge wc =num03 sext3
             sext3
        LEA                 #save value} mov wc -(xs)
        MOV  DWORD PTR []
        XOR                 #set to read options} zer wc
        CALL prpar          #read syspp options} jsr prpar
        MOV                 #restore value} mov (xs)+ wc
        LEA
#
#      deal with header option (fiddled by prpar)
#
sext3:  MOV  DWORD PTR headp,ESP #assume no headers} mnz headp
        CMP                 #skip if not 1} bne wc =num01 sext4
             sext4
        XOR  EAX,EAX        #request header printing} zer headp
        MOV  DWORD PTR headp,EAX
#
#      almost ready to resume running
#
sext4:  CALL systm          #get execution time start (sgd11)} jsr systm
        MOV  DWORD PTR timsx,EDX #save as initial time} sti timsx
        MOV  EDX,DWORD PTR kvstc #reset to ensure ...} ldi kvstc
        MOV  DWORD PTR kvstl,EDX #... correct execution stats} sti kvstl
        CALL stgcc          #recompute countdown counters} jsr stgcc
        JMP  exnul          #resume execution} brn exnul
#
#      here after exit(4) or exit(-4) -- create save file
#      or load module and continue execution.
#
#      return integer 1 to signal the continuation of the
#      original execution.
#
sext5:  MOV                 #integer one} mov =inton xr
        JMP  exixr          #return as result} brn exixr
                            #} ejc
        .eject
#
#      exp
#
        .balign 2           #entry point} ent
        NOP
s_exp:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-304-DFFNC #} err 304 exp argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL etx_           #take exponential} etx
        CALL OVR_           #if no overflow, return result in ra} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 305 exp produced real overflow
        .byte 49
                            #} ejc
        .eject
#
#      field
#
        .balign 2           #entry point} ent
        NOP
s_fld:
        CALL gtsmi          #get second argument (field number)} jsr gtsmi
        .short ERR_-107-DFFNC #} err 107 field second argument is not integer
        .short exfal-DFFNC  #fail if out of range} ppm exfal
        MOV                 #else save integer value} mov xr wb
        MOV                 #load first argument} mov (xs)+ xr
        LEA
        CALL gtnvr          #point to vrblk} jsr gtnvr
        .short sfld1-DFFNC  #jump (error) if not variable name} ppm sfld1
        MOV                 #else point to function block} mov vrfnc(xr) xr
        CMP  DWORD PTR [],offset b_dfc #error if not datatype function} bne (xr) =b_dfc sfld1
             sfld1
#
#      here if first argument is a datatype function name
#
        OR                  #fail if argument number is zero} bze wb exfal
        JZ   exfal
        CMP                 #fail if too large} bgt wb fargs(xr) exfal
             exfal
        SAL                 #else convert to byte offset} wtb wb
        ADD                 #point to field name} add wb xr
        MOV                 #load vrblk pointer} mov dfflb(xr) xr
        JMP  exvnm          #exit to build nmblk} brn exvnm
#
#      here for bad first argument
#
sfld1:  CALL ERR_0          #} erb 108 field first argument is not datatype name
        .byte 108
                            #} ejc
        .eject
#
#      fence
#
        .balign 2           #entry point} ent
        NOP
s_fnc:
        MOV                 #set pcode for p_fnc} mov =p_fnc wb
        XOR                 #p0blk} zer xr
        CALL pbild          #build p_fnc node} jsr pbild
        MOV                 #save pointer to it} mov xr xl
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtpat          #convert to pattern} jsr gtpat
        .short ERR_-259-DFFNC #} err 259 fence argument is not pattern
        CALL pconc          #concatenate to p_fnc node} jsr pconc
        MOV                 #save ptr to concatenated pattern} mov xr xl
        MOV                 #set for p_fna pcode} mov =p_fna wb
        XOR                 #p0blk} zer xr
        CALL pbild          #construct p_fna node} jsr pbild
        MOV  DWORD PTR (4*pthen)[] #set pattern as pthen} mov xl pthen(xr)
        LEA                 #set as result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute next code word} bri (xr)
                            #} ejc
        .eject
#
#      ge
#
        .balign 2           #entry point} ent
        NOP
s_gef:
        CALL acomp          #call arithmetic comparison routine} jsr acomp
        .short ERR_-109-DFFNC #} err 109 ge first argument is not numeric
        .short ERR_-110-DFFNC #} err 110 ge second argument is not numeric
        .short exfal-DFFNC  #fail if lt} ppm exfal
        .short exnul-DFFNC  #return null if eq} ppm exnul
        .short exnul-DFFNC  #return null if gt} ppm exnul
                            #} ejc
        .eject
#
#      gt
#
        .balign 2           #entry point} ent
        NOP
s_gtf:
        CALL acomp          #call arithmetic comparison routine} jsr acomp
        .short ERR_-111-DFFNC #} err 111 gt first argument is not numeric
        .short ERR_-112-DFFNC #} err 112 gt second argument is not numeric
        .short exfal-DFFNC  #fail if lt} ppm exfal
        .short exfal-DFFNC  #fail if eq} ppm exfal
        .short exnul-DFFNC  #return null if gt} ppm exnul
                            #} ejc
        .eject
#
#      host
#
        .balign 2           #entry point} ent
        NOP
s_hst:
        MOV                 #get fifth arg} mov (xs)+ wc
        LEA
        MOV                 #get fourth arg} mov (xs)+ wb
        LEA
        MOV                 #get third arg} mov (xs)+ xr
        LEA
        MOV                 #get second arg} mov (xs)+ xl
        LEA
        MOV                 #get first arg} mov (xs)+ wa
        LEA
        CALL syshs          #enter syshs routine} jsr syshs
        .short ERR_-254-DFFNC #} err 254 erroneous argument for host
        .short ERR_-255-DFFNC #} err 255 error during execution of host
        .short shst1-DFFNC  #store host string} ppm shst1
        .short exnul-DFFNC  #return null result} ppm exnul
        .short exixr-DFFNC  #return xr} ppm exixr
        .short exfal-DFFNC  #fail return} ppm exfal
        .short shst3-DFFNC  #store actual string} ppm shst3
        .short shst4-DFFNC  #return copy of xr} ppm shst4
#
#      return host string
#
shst1:  OR                  #null string if syshs uncooperative} bze xl exnul
        JZ   exnul
        MOV                 #length} mov sclen(xl) wa
        XOR                 #zero offset} zer wb
#
#      copy string and return
#
shst2:  CALL sbstr          #build copy of string} jsr sbstr
        LEA                 #stack the result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      return actual string pointed to by xl
#
shst3:  XOR                 #treat xl like an scblk ptr} zer wb
        SUB                 #by creating a negative offset} sub =cfp_f wb
        JMP  shst2          #join to copy string} brn shst2
#
#      return copy of block pointed to by xr
#
shst4:  LEA                 #stack results} mov xr -(xs)
        MOV  DWORD PTR []
        CALL copyb          #make copy of block} jsr copyb
        .short exits-DFFNC  #if not an aggregate structure} ppm exits
        JMP  exsid          #set current id value otherwise} brn exsid
                            #} ejc
        .eject
#
#      ident
#
        .balign 2           #entry point} ent
        NOP
s_idn:
        MOV                 #load second argument} mov (xs)+ xr
        LEA
        MOV                 #load first argument} mov (xs)+ xl
        LEA
        CALL ident          #call ident comparison routine} jsr ident
        .short exnul-DFFNC  #return null if ident} ppm exnul
        JMP  exfal          #fail if differ} brn exfal
                            #} ejc
        .eject
#
#      input
#
        .balign 2           #entry point} ent
        NOP
s_inp:
        XOR                 #input flag} zer wb
        CALL ioput          #call input/output assoc. routine} jsr ioput
        .short ERR_-113-DFFNC #} err 113 input third argument is not a string
        .short ERR_-114-DFFNC #} err 114 inappropriate second argument for input
        .short ERR_-115-DFFNC #} err 115 inappropriate first argument for input
        .short ERR_-116-DFFNC #} err 116 inappropriate file specification for input
        .short exfal-DFFNC  #fail if file does not exist} ppm exfal
        .short ERR_-117-DFFNC #} err 117 input file cannot be read
        .short ERR_-289-DFFNC #} err 289 input channel currently in use
        JMP  exnul          #return null string} brn exnul
                            #} ejc
        .eject
#
#      integer
#
        .balign 2           #entry point} ent
        NOP
s_int:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CALL gtnum          #convert to numeric} jsr gtnum
        .short exfal-DFFNC  #fail if non-numeric} ppm exfal
        CMP                 #return null if integer} beq wa =b_icl exnul
             exnul
        JMP  exfal          #fail if real} brn exfal
                            #} ejc
        .eject
#
#      item
#
#      item does not permit the direct (fast) call so that
#      wa contains the actual number of arguments passed.
#
        .balign 2           #entry point} ent
        NOP
s_itm:
#
#      deal with case of no args
#
        OR                  #jump if at least one arg} bnz wa sitm1
        JNZ  sitm1
        LEA                 #else supply garbage null arg} mov =nulls -(xs)
        MOV  DWORD PTR [],offset nulls
        MOV                 #and fix argument count} mov =num01 wa
#
#      check for name/value cases
#
sitm1:  MOV                 #get current code pointer} scp xr
        MOV                 #load next code word} mov (xr) xl
        DEC                 #get number of subscripts} dcv wa
        MOV                 #copy for arref} mov wa xr
        CMP                 #jump if called by name} beq xl =ofne_ sitm2
             sitm2
#
#      here if called by value
#
        XOR                 #set code for call by value} zer wb
        JMP  arref          #off to array reference routine} brn arref
#
#      here for call by name
#
sitm2:  MOV                 #set code for call by name} mnz wb
        MOV                 #load and ignore ofne_ call} lcw wa
        ADD  EBP,4
        JMP  arref          #off to array reference routine} brn arref
                            #} ejc
        .eject
#
#      le
#
        .balign 2           #entry point} ent
        NOP
s_lef:
        CALL acomp          #call arithmetic comparison routine} jsr acomp
        .short ERR_-118-DFFNC #} err 118 le first argument is not numeric
        .short ERR_-119-DFFNC #} err 119 le second argument is not numeric
        .short exnul-DFFNC  #return null if lt} ppm exnul
        .short exnul-DFFNC  #return null if eq} ppm exnul
        .short exfal-DFFNC  #fail if gt} ppm exfal
                            #} ejc
        .eject
#
#      len
#
        .balign 2           #entry point} ent
        NOP
s_len:
        MOV                 #set pcode for integer arg case} mov =p_len wb
        MOV                 #set pcode for expr arg case} mov =p_lnd wa
        CALL patin          #call common routine to build node} jsr patin
        .short ERR_-120-DFFNC #} err 120 len argument is not integer or expression
        .short ERR_-121-DFFNC #} err 121 len argument is negative or too large
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      leq
#
        .balign 2           #entry point} ent
        NOP
s_leq:
        CALL lcomp          #call string comparison routine} jsr lcomp
        .short ERR_-122-DFFNC #} err 122 leq first argument is not a string
        .short ERR_-123-DFFNC #} err 123 leq second argument is not a string
        .short exfal-DFFNC  #fail if llt} ppm exfal
        .short exnul-DFFNC  #return null if leq} ppm exnul
        .short exfal-DFFNC  #fail if lgt} ppm exfal
                            #} ejc
        .eject
#
#      lge
#
        .balign 2           #entry point} ent
        NOP
s_lge:
        CALL lcomp          #call string comparison routine} jsr lcomp
        .short ERR_-124-DFFNC #} err 124 lge first argument is not a string
        .short ERR_-125-DFFNC #} err 125 lge second argument is not a string
        .short exfal-DFFNC  #fail if llt} ppm exfal
        .short exnul-DFFNC  #return null if leq} ppm exnul
        .short exnul-DFFNC  #return null if lgt} ppm exnul
                            #} ejc
        .eject
#
#      lgt
#
        .balign 2           #entry point} ent
        NOP
s_lgt:
        CALL lcomp          #call string comparison routine} jsr lcomp
        .short ERR_-126-DFFNC #} err 126 lgt first argument is not a string
        .short ERR_-127-DFFNC #} err 127 lgt second argument is not a string
        .short exfal-DFFNC  #fail if llt} ppm exfal
        .short exfal-DFFNC  #fail if leq} ppm exfal
        .short exnul-DFFNC  #return null if lgt} ppm exnul
                            #} ejc
        .eject
#
#      lle
#
        .balign 2           #entry point} ent
        NOP
s_lle:
        CALL lcomp          #call string comparison routine} jsr lcomp
        .short ERR_-128-DFFNC #} err 128 lle first argument is not a string
        .short ERR_-129-DFFNC #} err 129 lle second argument is not a string
        .short exnul-DFFNC  #return null if llt} ppm exnul
        .short exnul-DFFNC  #return null if leq} ppm exnul
        .short exfal-DFFNC  #fail if lgt} ppm exfal
                            #} ejc
        .eject
#
#      llt
#
        .balign 2           #entry point} ent
        NOP
s_llt:
        CALL lcomp          #call string comparison routine} jsr lcomp
        .short ERR_-130-DFFNC #} err 130 llt first argument is not a string
        .short ERR_-131-DFFNC #} err 131 llt second argument is not a string
        .short exnul-DFFNC  #return null if llt} ppm exnul
        .short exfal-DFFNC  #fail if leq} ppm exfal
        .short exfal-DFFNC  #fail if lgt} ppm exfal
                            #} ejc
        .eject
#
#      lne
#
        .balign 2           #entry point} ent
        NOP
s_lne:
        CALL lcomp          #call string comparison routine} jsr lcomp
        .short ERR_-132-DFFNC #} err 132 lne first argument is not a string
        .short ERR_-133-DFFNC #} err 133 lne second argument is not a string
        .short exnul-DFFNC  #return null if llt} ppm exnul
        .short exfal-DFFNC  #fail if leq} ppm exfal
        .short exnul-DFFNC  #return null if lgt} ppm exnul
                            #} ejc
        .eject
#
#      ln
#
        .balign 2           #entry point} ent
        NOP
s_lnf:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-306-DFFNC #} err 306 ln argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL CPR_           #overflow if argument is 0} req slnf1
        JE   slnf1
        CALL CPR_           #error if argument less than 0} rlt slnf2
        JL   slnf2
        CALL lnf_           #take natural logarithm} lnf
        CALL OVR_           #if no overflow, return result in ra} rno exrea
        JNO  exrea
slnf1:  CALL ERR_1          #} erb 307 ln produced real overflow
        .byte 51
#
#      here for bad argument
#
slnf2:  CALL ERR_1          #} erb 315 ln argument negative
        .byte 59
                            #} ejc
        .eject
#
#      local
#
        .balign 2           #entry point} ent
        NOP
s_loc:
        CALL gtsmi          #get second argument (local number)} jsr gtsmi
        .short ERR_-134-DFFNC #} err 134 local second argument is not integer
        .short exfal-DFFNC  #fail if out of range} ppm exfal
        MOV                 #save local number} mov xr wb
        MOV                 #load first argument} mov (xs)+ xr
        LEA
        CALL gtnvr          #point to vrblk} jsr gtnvr
        .short sloc1-DFFNC  #jump if not variable name} ppm sloc1
        MOV                 #else load function pointer} mov vrfnc(xr) xr
        CMP  DWORD PTR [],offset b_pfc #jump if not program defined} bne (xr) =b_pfc sloc1
             sloc1
#
#      here if we have a program defined function name
#
        OR                  #fail if second arg is zero} bze wb exfal
        JZ   exfal
        CMP                 #or too large} bgt wb pfnlo(xr) exfal
             exfal
        ADD                 #else adjust offset to include args} add fargs(xr) wb
        SAL                 #convert to bytes} wtb wb
        ADD                 #point to local pointer} add wb xr
        MOV                 #load vrblk pointer} mov pfagb(xr) xr
        JMP  exvnm          #exit building nmblk} brn exvnm
#
#      here if first argument is no good
#
sloc1:  CALL ERR_0          #} erb 135 local first arg is not a program function name
        .byte 135
                            #} ejc
        .eject
#
#      load
#
        .balign 2           #entry point} ent
        NOP
s_lod:
        CALL gtstg          #load library name} jsr gtstg
        .short ERR_-136-DFFNC #} err 136 load second argument is not a string
        MOV                 #save library name} mov xr xl
        CALL xscni          #prepare to scan first argument} jsr xscni
        .short ERR_-137-DFFNC #} err 137 load first argument is not a string
        .short ERR_-138-DFFNC #} err 138 load first argument is null
        LEA                 #stack library name} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #set delimiter one = left paren} mov =ch_pp wc
        MOV                 #set delimiter two = left paren} mov wc xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan function name} jsr xscan
        LEA                 #save ptr to function name} mov xr -(xs)
        MOV  DWORD PTR []
        OR                  #jump if left paren found} bnz wa slod1
        JNZ  slod1
        CALL ERR_0          #} erb 139 load first argument is missing a left paren
        .byte 139
#
#      here after successfully scanning function name
#
slod1:  CALL gtnvr          #locate vrblk} jsr gtnvr
        .short ERR_-140-DFFNC #} err 140 load first argument has null function name
        MOV  DWORD PTR lodfn #save vrblk pointer} mov xr lodfn
        XOR  EAX,EAX        #zero count of arguments} zer lodna
        MOV  DWORD PTR lodna,EAX
#
#      loop to scan argument datatype names
#
slod2:  MOV                 #delimiter one is right paren} mov =ch_rp wc
        MOV                 #delimiter two is comma} mov =ch_cm xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan next argument name} jsr xscan
        INC  DWORD PTR lodna #bump argument count} icv lodna
        OR                  #jump if ok delimiter was found} bnz wa slod3
        JNZ  slod3
        CALL ERR_0          #} erb 141 load first argument is missing a right paren
        .byte 141
                            #} ejc
        .eject
#
#      load (continued)
#
#      come here to analyze the datatype pointer in (xr). this
#      code is used both for arguments (wa=1,2) and for the
#      result datatype (with wa set to zero).
#
slod3:  MOV                 #save scan mode} mov wa wb
        MOV                 #datatype length} mov sclen(xr) wa
        OR                  #bypass if null string} bze wa sld3a
        JZ   sld3a
        CALL flstg          #fold to upper case} jsr flstg
sld3a:  MOV                 #restore scan mode} mov wb wa
        LEA                 #stack datatype name pointer} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #set string code in case} mov =num01 wb
        MOV                 #point to /string/} mov =scstr xl
        CALL ident          #check for match} jsr ident
        .short slod4-DFFNC  #jump if match} ppm slod4
        MOV                 #else reload name} mov (xs) xr
        ADD                 #set code for integer (2)} add wb wb
        MOV                 #point to /integer/} mov =scint xl
        CALL ident          #check for match} jsr ident
        .short slod4-DFFNC  #jump if match} ppm slod4
        MOV                 #else reload string pointer} mov (xs) xr
        INC                 #set code for real (3)} icv wb
        MOV                 #point to /real/} mov =screa xl
        CALL ident          #check for match} jsr ident
        .short slod4-DFFNC  #jump if match} ppm slod4
        MOV                 #reload string pointer} mov (xs) xr
        INC                 #code for file (4, or 3 if no reals)} icv wb
        MOV                 #point to /file/} mov =scfil xl
        CALL ident          #check for match} jsr ident
        .short slod4-DFFNC  #jump if match} ppm slod4
        XOR                 #else get code for no convert} zer wb
#
#      merge here with proper datatype code in wb
#
slod4:  MOV  DWORD PTR []   #store code on stack} mov wb (xs)
        CMP                 #loop back if arg stopped by comma} beq wa =num02 slod2
             slod2
        OR                  #jump if that was the result type} bze wa slod5
        JZ   slod5
#
#      here we scan out the result type (arg stopped by ) )
#
        MOV                 #set dummy (impossible) delimiter 1} mov mxlen wc
        MOV                 #and delimiter two} mov wc xl
        MOV                 #skip/trim blanks in prototype} mnz wa
        CALL xscan          #scan result name} jsr xscan
        XOR                 #set code for processing result} zer wa
        JMP  slod3          #jump back to process result name} brn slod3
                            #} ejc
        .eject
#
#      load (continued)
#
#      here after processing all args and result
#
slod5:  MOV                 #get number of arguments} mov lodna wa
        MOV                 #copy for later} mov wa wc
        SAL                 #convert length to bytes} wtb wa
        ADD                 #add space for standard fields} add *efsi_ wa
        CALL alloc          #allocate efblk} jsr alloc
        MOV  DWORD PTR [],offset b_efc #set type word} mov =b_efc (xr)
        MOV  DWORD PTR (4*fargs)[] #set number of arguments} mov wc fargs(xr)
        XOR  EAX,EAX        #set use count (dffnc will set to 1)} zer efuse(xr)
        MOV  DWORD PTR (4*efuse)[],EAX
        XOR  EAX,EAX        #zero code pointer for now} zer efcod(xr)
        MOV  DWORD PTR (4*efcod)[],EAX
        MOV  EAX,DWORD PTR [] #store result type code} mov (xs)+ efrsl(xr)
        MOV  DWORD PTR (4*efrsl)[],EAX
        LEA
        MOV  EAX,DWORD PTR lodfn #store function vrblk pointer} mov lodfn efvar(xr)
        MOV  DWORD PTR (4*efvar)[],EAX
        MOV  DWORD PTR (4*eflen)[] #store efblk length} mov wa eflen(xr)
        MOV                 #save efblk pointer} mov xr wb
        ADD                 #point past end of efblk} add wa xr
#
#      loop to set argument type codes from stack
#
slod6:  LEA                 #store one type code from stack} mov (xs)+ -(xr)
        MOV  EAX,DWORD PTR []
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop till all stored} bct wc slod6
        JNZ  slod6
#
#      now load the external function and perform definition
#
        MOV                 #load function string name} mov (xs)+ xr
        LEA
        MOV                 #function name length} mov sclen(xr) wa
        CALL flstg          #fold to upper case} jsr flstg
        MOV                 #load library name} mov (xs) xl
        MOV  DWORD PTR []   #store efblk pointer} mov wb (xs)
        CALL sysld          #call function to load external func} jsr sysld
        .short ERR_-142-DFFNC #} err 142 load function does not exist
        .short ERR_-143-DFFNC #} err 143 load function caused input error during load
        .short ERR_-328-DFFNC #} err 328 load function - insufficient memory
        MOV                 #recall efblk pointer} mov (xs)+ xl
        LEA
        MOV  DWORD PTR (4*efcod)[] #store code pointer} mov xr efcod(xl)
        MOV                 #point to vrblk for function} mov lodfn xr
        CALL dffnc          #perform function definition} jsr dffnc
        JMP  exnul          #return null result} brn exnul
                            #} ejc
        .eject
#
#      lpad
#
        .balign 2           #entry point} ent
        NOP
s_lpd:
        CALL gtstg          #get pad character} jsr gtstg
        .short ERR_-144-DFFNC #} err 144 lpad third argument is not a string
        ADD                 #point to character (null is blank)} plc xr
        MOVZX               #load pad character} lch wb (xr)
        CALL gtsmi          #get pad length} jsr gtsmi
        .short ERR_-145-DFFNC #} err 145 lpad second argument is not integer
        .short slpd4-DFFNC  #skip if negative or large} ppm slpd4
#
#      merge to check first arg
#
slpd1:  CALL gtstg          #get first argument (string to pad)} jsr gtstg
        .short ERR_-146-DFFNC #} err 146 lpad first argument is not a string
        CMP                 #return 1st arg if too long to pad} bge wa wc exixr
             exixr
        MOV                 #else move ptr to string to pad} mov xr xl
#
#      now we are ready for the pad
#
#      (xl)                  pointer to string to pad
#      (wb)                  pad character
#      (wc)                  length to pad string to
#
        MOV                 #copy length} mov wc wa
        CALL alocs          #allocate scblk for new string} jsr alocs
        LEA                 #save as result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #load length of argument} mov sclen(xl) wa
        SUB                 #calculate number of pad characters} sub wa wc
        ADD                 #point to chars in result string} psc xr
#
#      loop to perform pad
#
slpd2:  MOV  [ESI]          #store pad character, bump ptr} sch wb (xr)+
        DEC                 #loop till all pad chars stored} bct wc slpd2
        JNZ  slpd2
#
#      now copy string
#
        OR                  #exit if null string} bze wa slpd3
        JZ   slpd3
        ADD                 #else point to chars in argument} plc xl
        SHRD EAX,ECX,1      #move characters to result string} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        XOR                 #clear garbage xl} zer xl
#
#      here to exit with result on stack
#
slpd3:  MOV                 #load next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      here if 2nd arg is negative or large
#
slpd4:  XOR                 #zero pad count} zer wc
        JMP  slpd1          #merge} brn slpd1
                            #} ejc
        .eject
#
#      lt
#
        .balign 2           #entry point} ent
        NOP
s_ltf:
        CALL acomp          #call arithmetic comparison routine} jsr acomp
        .short ERR_-147-DFFNC #} err 147 lt first argument is not numeric
        .short ERR_-148-DFFNC #} err 148 lt second argument is not numeric
        .short exnul-DFFNC  #return null if lt} ppm exnul
        .short exfal-DFFNC  #fail if eq} ppm exfal
        .short exfal-DFFNC  #fail if gt} ppm exfal
                            #} ejc
        .eject
#
#      ne
#
        .balign 2           #entry point} ent
        NOP
s_nef:
        CALL acomp          #call arithmetic comparison routine} jsr acomp
        .short ERR_-149-DFFNC #} err 149 ne first argument is not numeric
        .short ERR_-150-DFFNC #} err 150 ne second argument is not numeric
        .short exnul-DFFNC  #return null if lt} ppm exnul
        .short exfal-DFFNC  #fail if eq} ppm exfal
        .short exnul-DFFNC  #return null if gt} ppm exnul
                            #} ejc
        .eject
#
#      notany
#
        .balign 2           #entry point} ent
        NOP
s_nay:
        MOV                 #set pcode for single char arg} mov =p_nas wb
        MOV                 #pcode for multi-char arg} mov =p_nay xl
        MOV                 #set pcode for expr arg} mov =p_nad wc
        CALL patst          #call common routine to build node} jsr patst
        .short ERR_-151-DFFNC #} err 151 notany argument is not a string or expression
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      opsyn
#
        .balign 2           #entry point} ent
        NOP
s_ops:
        CALL gtsmi          #load third argument} jsr gtsmi
        .short ERR_-152-DFFNC #} err 152 opsyn third argument is not integer
        .short ERR_-153-DFFNC #} err 153 opsyn third argument is negative or too large
        MOV                 #if ok, save third argumnet} mov wc wb
        MOV                 #load second argument} mov (xs)+ xr
        LEA
        CALL gtnvr          #locate variable block} jsr gtnvr
        .short ERR_-154-DFFNC #} err 154 opsyn second arg is not natural variable name
        MOV                 #if ok, load function block pointer} mov vrfnc(xr) xl
        OR                  #jump if operator opsyn case} bnz wb sops2
        JNZ  sops2
#
#      here for function opsyn (third arg zero)
#
        MOV                 #load first argument} mov (xs)+ xr
        LEA
        CALL gtnvr          #get vrblk pointer} jsr gtnvr
        .short ERR_-155-DFFNC #} err 155 opsyn first arg is not natural variable name
#
#      merge here to perform function definition
#
sops1:  CALL dffnc          #call function definer} jsr dffnc
        JMP  exnul          #exit with null result} brn exnul
#
#      here for operator opsyn (third arg non-zero)
#
sops2:  CALL gtstg          #get operator name} jsr gtstg
        .short sops5-DFFNC  #jump if not string} ppm sops5
        CMP                 #error if not one char long} bne wa =num01 sops5
             sops5
        ADD                 #else point to character} plc xr
        MOVZX               #load character name} lch wc (xr)
                            #} ejc
        .eject
#
#      opsyn (continued)
#
#      now set to search for matching unary or binary operator
#      name as appropriate. note that there are =opbun undefined
#      binary operators and =opuun undefined unary operators.
#
        MOV                 #point to unop pointers in case} mov =r_uub wa
        MOV                 #point to names of unary operators} mov =opnsu xr
        ADD                 #add no. of undefined binary ops} add =opbun wb
        CMP                 #jump if unop (third arg was 1)} beq wb =opuun sops3
             sops3
        MOV                 #else point to binary operator ptrs} mov =r_uba wa
        MOV                 #point to names of binary operators} mov =opsnb xr
        MOV                 #set number of undefined binops} mov =opbun wb
#
#      merge here to check list (wb = number to check)
#
sops3:                      #set counter to control loop} lct wb wb
#
#      loop to search for name match
#
sops4:  CMP                 #jump if names match} beq wc (xr) sops6
             sops6
        ADD                 #else push pointer to function ptr} ica wa
        ADD                 #bump pointer} ica xr
        DEC                 #loop back till all checked} bct wb sops4
        JNZ  sops4
#
#      here if bad operator name
#
sops5:  CALL ERR_0          #} erb 156 opsyn first arg is not correct operator name
        .byte 156
#
#      come here on finding a match in the operator name table
#
sops6:  MOV                 #copy pointer to function block ptr} mov wa xr
        SUB                 #make it look like dummy vrblk} sub *vrfnc xr
        JMP  sops1          #merge back to define operator} brn sops1
                            #} ejc
        .eject
#
#      output
#
        .balign 2           #entry point} ent
        NOP
s_oup:
        MOV                 #output flag} mov =num03 wb
        CALL ioput          #call input/output assoc. routine} jsr ioput
        .short ERR_-157-DFFNC #} err 157 output third argument is not a string
        .short ERR_-158-DFFNC #} err 158 inappropriate second argument for output
        .short ERR_-159-DFFNC #} err 159 inappropriate first argument for output
        .short ERR_-160-DFFNC #} err 160 inappropriate file specification for output
        .short exfal-DFFNC  #fail if file does not exist} ppm exfal
        .short ERR_-161-DFFNC #} err 161 output file cannot be written to
        .short ERR_-290-DFFNC #} err 290 output channel currently in use
        JMP  exnul          #return null string} brn exnul
                            #} ejc
        .eject
#
#      pos
#
        .balign 2           #entry point} ent
        NOP
s_pos:
        MOV                 #set pcode for integer arg case} mov =p_pos wb
        MOV                 #set pcode for expression arg case} mov =p_psd wa
        CALL patin          #call common routine to build node} jsr patin
        .short ERR_-162-DFFNC #} err 162 pos argument is not integer or expression
        .short ERR_-163-DFFNC #} err 163 pos argument is negative or too large
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      prototype
#
        .balign 2           #entry point} ent
        NOP
s_pro:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        MOV                 #length if table, vector (=vclen)} mov tblen(xr) wb
        SHR                 #convert to words} btw wb
        MOV                 #load type word of argument block} mov (xr) wa
        CMP                 #jump if array} beq wa =b_art spro4
             spro4
        CMP                 #jump if table} beq wa =b_tbt spro1
             spro1
        CMP                 #jump if vector} beq wa =b_vct spro3
             spro3
        CALL ERR_0          #} erb 164 prototype argument is not valid object
        .byte 164
#
#      here for table
#
spro1:  SUB                 #subtract standard fields} sub =tbsi_ wb
#
#      merge for vector
#
spro2:  MOV  EDX            #convert to integer} mti wb
        JMP  exint          #exit with integer result} brn exint
#
#      here for vector
#
spro3:  SUB                 #subtract standard fields} sub =vcsi_ wb
        JMP  spro2          #merge} brn spro2
#
#      here for array
#
spro4:  ADD                 #point to prototype field} add arofs(xr) xr
        MOV                 #load prototype} mov (xr) xr
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      remdr
#
        .balign 2           #entry point} ent
        NOP
s_rmd:
        CALL arith          #get two integers or two reals} jsr arith
        .short ERR_-166-DFFNC #} err 166 remdr first argument is not numeric
        .short ERR_-165-DFFNC #} err 165 remdr second argument is not numeric
        .short srm06-DFFNC  #if real} ppm srm06
#
#      both arguments integer
#
        XOR                 #set positive flag} zer wb
        MOV  EDX,DWORD PTR (4*icval)[] #load left argument value} ldi icval(xr)
        OR   EDX,EDX        #jump if positive} ige srm01
        JGE  srm01
        MOV                 #set negative flag} mnz wb
srm01:  MOV  EAX,DWORD PTR (4*icval)[] #get remainder} rmi icval(xl)
        CALL rmi_
        JO   srm05          #error if overflow} iov srm05
#
#      make sign of result match sign of first argument
#
        OR                  #if result should be positive} bze wb srm03
        JZ   srm03
        OR   EDX,EDX        #if should be negative, and is} ile exint
        JLE  exint
srm02:  NEG  EDX            #adjust sign of result} ngi
        JMP  exint          #return result} brn exint
srm03:  OR   EDX,EDX        #should be pos, and result negative} ilt srm02
        JL   srm02
        JMP  exint          #should be positive, and is} brn exint
#
#      fail first argument
#
srm04:  CALL ERR_0          #} erb 166 remdr first argument is not numeric
        .byte 166
#
#      fail if overflow
#
srm05:  CALL ERR_0          #} erb 167 remdr caused integer overflow
        .byte 167
#
#      here with 1st argument in (xr), 2nd in (xl), both real
#
#      result = n1 - chop(n1/n2)*n2
#
srm06:  XOR                 #set positive flag} zer wb
        LEA  EAX,DWORD PTR (4*rcval)[] #load left argument value} ldr rcval(xr)
        CALL ldr_
        CALL CPR_           #jump if positive} rge srm07
        JGE  srm07
        MOV                 #set negative flag} mnz wb
srm07:  LEA  EAX,DWORD PTR (4*rcval)[] #compute n1/n2} dvr rcval(xl)
        CALL dvr_
        CALL OVR_           #jump if overflow} rov srm10
        JO   srm10
        CALL chp_           #chop result} chp
        LEA  EAX,DWORD PTR (4*rcval)[] #times n2} mlr rcval(xl)
        CALL mlr_
        LEA  EAX,DWORD PTR (4*rcval)[] #compute difference} sbr rcval(xr)
        CALL sbr_
#
#      make sign of result match sign of first argument
#      -result is in ra at this point
#
        OR                  #if result should be positive} bze wb srm09
        JZ   srm09
        CALL CPR_           #if should be negative, and is} rle exrea
        JLE  exrea
srm08:  CALL ngr_           #adjust sign of result} ngr
        JMP  exrea          #return result} brn exrea
srm09:  CALL CPR_           #should be pos, and result negative} rlt srm08
        JL   srm08
        JMP  exrea          #should be positive, and is} brn exrea
#
#      fail if overflow
#
srm10:  CALL ERR_1          #} erb 312 remdr caused real overflow
        .byte 56
                            #} ejc
        .eject
#
#      replace
#
#      the actual replace operation uses an scblk whose cfp$a
#      chars contain the translated versions of all the chars.
#      the table pointer is remembered from call to call and
#      the table is only built when the arguments change.
#
#      we also perform an optimization gleaned from spitbol 370.
#      if the second argument is &alphabet, there is no need to
#      to build a replace table.  the third argument can be
#      used directly as the replace table.
#
        .balign 2           #entry point} ent
        NOP
s_rpl:
        CALL gtstg          #load third argument as string} jsr gtstg
        .short ERR_-168-DFFNC #} err 168 replace third argument is not a string
        MOV                 #save third arg ptr} mov xr xl
        CALL gtstg          #get second argument} jsr gtstg
        .short ERR_-169-DFFNC #} err 169 replace second argument is not a string
#
#      check to see if this is the same table as last time
#
        CMP                 #jump if 2nd argument different} bne xr r_ra2 srpl1
             srpl1
        CMP                 #jump if args same as last time} beq xl r_ra3 srpl4
             srpl4
#
#      here we build a new replace table (note wa = 2nd arg len)
#
srpl1:  MOV                 #load 3rd argument length} mov sclen(xl) wb
        CMP                 #jump if arguments not same length} bne wa wb srpl6
             srpl6
        CMP                 #jump if 2nd arg is alphabet string} beq xr kvalp srpl5
             srpl5
        OR                  #jump if null 2nd argument} bze wb srpl6
        JZ   srpl6
        MOV  DWORD PTR r_ra3 #save third arg for next time in} mov xl r_ra3
        MOV  DWORD PTR r_ra2 #save second arg for next time in} mov xr r_ra2
        MOV                 #point to alphabet string} mov kvalp xl
        MOV                 #load alphabet scblk length} mov sclen(xl) wa
        MOV                 #point to current table (if any)} mov r_rpt xr
        OR                  #jump if we already have a table} bnz xr srpl2
        JNZ  srpl2
#
#      here we allocate a new table
#
        CALL alocs          #allocate new table} jsr alocs
        MOV                 #keep scblk length} mov wc wa
        MOV  DWORD PTR r_rpt #save table pointer for next time} mov xr r_rpt
#
#      merge here with pointer to new table block in (xr)
#
srpl2:  ADD                 #compute length of scblk} ctb wa scsi_
        AND
        SHR  ECX,2          #copy to get initial table values} mvw
        REP  MOVSD
                            #} ejc
        .eject
#
#      replace (continued)
#
#      now we must plug selected entries as required. note that
#      we are short of index registers for the following loop.
#      hence the need to repeatedly re-initialise char ptr xl
#
        MOV                 #point to second argument} mov r_ra2 xl
        XOR                 #zero char offset} zer wc
        MOV                 #point to 3rd arg} mov r_ra3 xr
        ADD                 #get char ptr for 3rd arg} plc xr
#
#      loop to plug chars
#
srpl3:  MOV                 #point to 2nd arg} mov r_ra2 xl
        LEA                 #point to next char} plc xl wc
        INC                 #increment offset} icv wc
        MOVZX               #get next char} lch wa (xl)
        MOV                 #point to translate table} mov r_rpt xl
        LEA                 #convert char to offset into table} psc xl wa
        MOVZX               #get translated char} lch wa (xr)+
        INC
        MOV  [ESI]          #store in table} sch wa (xl)
        DEC                 #loop till done} bct wb srpl3
        JNZ  srpl3
                            #} ejc
        .eject
#
#      replace (continued)
#
#      here to use r$rpt as replace table.
#
srpl4:  MOV                 #replace table to use} mov r_rpt xl
#
#      here to perform translate using table in xl.
#
srpl5:  CALL gtstg          #get first argument} jsr gtstg
        .short ERR_-170-DFFNC #} err 170 replace first argument is not a string
        OR                  #return null if null argument} bze wa exnul
        JZ   exnul
        LEA                 #stack replace table to use} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #copy pointer} mov xr xl
        MOV                 #save length} mov wa wc
        ADD                 #get scblk length} ctb wa schar
        AND
        CALL alloc          #allocate space for copy} jsr alloc
        MOV                 #save address of copy} mov xr wb
        SHR  ECX,2          #move scblk contents to copy} mvw
        REP  MOVSD
        MOV                 #unstack replace table} mov (xs)+ xr
        LEA
        ADD                 #point to chars of table} plc xr
        MOV                 #point to string to translate} mov wb xl
        ADD                 #point to chars of string} plc xl
        MOV                 #set number of chars to translate} mov wc wa
        XCHG ESI,EDI        #perform translation} trc
L0004:  MOVZX EAX,BYTE PTR [EDI]
        MOV  AL,[ESI+EAX]
        STOSB
        LOOP L0004
        XOR  ESI,ESI
        XOR  EDI,EDI
srpl8:  LEA                 #stack result} mov wb -(xs)
        MOV  DWORD PTR []
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      error point
#
srpl6:  CALL ERR_0          #} erb 171 null or unequally long 2nd, 3rd args to replace
        .byte 171
                            #} ejc
        .eject
#
#      rewind
#
        .balign 2           #entry point} ent
        NOP
s_rew:
        CALL iofcb          #call fcblk routine} jsr iofcb
        .short ERR_-172-DFFNC #} err 172 rewind argument is not a suitable name
        .short ERR_-173-DFFNC #} err 173 rewind argument is null
        .short ERR_-174-DFFNC #} err 174 rewind file does not exist
        CALL sysrw          #call system rewind function} jsr sysrw
        .short ERR_-174-DFFNC #} err 174 rewind file does not exist
        .short ERR_-175-DFFNC #} err 175 rewind file does not permit rewind
        .short ERR_-176-DFFNC #} err 176 rewind caused non-recoverable error
        JMP  exnul          #exit with null result if no error} brn exnul
                            #} ejc
        .eject
#
#      reverse
#
        .balign 2           #entry point} ent
        NOP
s_rvs:
        CALL gtstg          #load string argument} jsr gtstg
        .short ERR_-177-DFFNC #} err 177 reverse argument is not a string
        OR                  #return argument if null} bze wa exixr
        JZ   exixr
        MOV                 #else save pointer to string arg} mov xr xl
        CALL alocs          #allocate space for new scblk} jsr alocs
        LEA                 #store scblk ptr on stack as result} mov xr -(xs)
        MOV  DWORD PTR []
        ADD                 #prepare to store in new scblk} psc xr
        LEA                 #point past last char in argument} plc xl wc
#
#      loop to move chars in reverse order
#
srvs1:  DEC                 #load next char from argument} lch wb -(xl)
        MOVZX
        MOV  [ESI]          #store in result} sch wb (xr)+
        DEC                 #loop till all moved} bct wc srvs1
        JNZ  srvs1
#
#      here when complete to execute next code word
#
srvs4:                      #complete store characters} csc xr
        XOR                 #clear garbage xl} zer xl
srvs2:  MOV                 #load next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      rpad
#
        .balign 2           #entry point} ent
        NOP
s_rpd:
        CALL gtstg          #get pad character} jsr gtstg
        .short ERR_-178-DFFNC #} err 178 rpad third argument is not a string
        ADD                 #point to character (null is blank)} plc xr
        MOVZX               #load pad character} lch wb (xr)
        CALL gtsmi          #get pad length} jsr gtsmi
        .short ERR_-179-DFFNC #} err 179 rpad second argument is not integer
        .short srpd3-DFFNC  #skip if negative or large} ppm srpd3
#
#      merge to check first arg.
#
srpd1:  CALL gtstg          #get first argument (string to pad)} jsr gtstg
        .short ERR_-180-DFFNC #} err 180 rpad first argument is not a string
        CMP                 #return 1st arg if too long to pad} bge wa wc exixr
             exixr
        MOV                 #else move ptr to string to pad} mov xr xl
#
#      now we are ready for the pad
#
#      (xl)                  pointer to string to pad
#      (wb)                  pad character
#      (wc)                  length to pad string to
#
        MOV                 #copy length} mov wc wa
        CALL alocs          #allocate scblk for new string} jsr alocs
        LEA                 #save as result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #load length of argument} mov sclen(xl) wa
        SUB                 #calculate number of pad characters} sub wa wc
        ADD                 #point to chars in result string} psc xr
#
#      copy argument string
#
#        OR                  #jump if argument is null} bze wa srpd2  (Optimized)
        JZ   srpd2
        ADD                 #else point to argument chars} plc xl
        SHRD EAX,ECX,1      #move characters to result string} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        XOR                 #clear garbage xl} zer xl
#
#      loop to supply pad characters
#
srpd2:  MOV  [ESI]          #store pad character, bump ptr} sch wb (xr)+
        DEC                 #loop till all pad chars stored} bct wc srpd2
        JNZ  srpd2
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      here if 2nd arg is negative or large
#
srpd3:  XOR                 #zero pad count} zer wc
        JMP  srpd1          #merge} brn srpd1
                            #} ejc
        .eject
#
#      rtab
#
        .balign 2           #entry point} ent
        NOP
s_rtb:
        MOV                 #set pcode for integer arg case} mov =p_rtb wb
        MOV                 #set pcode for expression arg case} mov =p_rtd wa
        CALL patin          #call common routine to build node} jsr patin
        .short ERR_-181-DFFNC #} err 181 rtab argument is not integer or expression
        .short ERR_-182-DFFNC #} err 182 rtab argument is negative or too large
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      set
#
        .balign 2           #entry point} ent
        NOP
s_set:
        MOV  EAX,DWORD PTR [] #save third arg (whence)} mov (xs)+ r_io2
        MOV  DWORD PTR r_io2,EAX
        LEA
        MOV  EAX,DWORD PTR [] #save second arg (offset)} mov (xs)+ r_io1
        MOV  DWORD PTR r_io1,EAX
        LEA
        CALL iofcb          #call fcblk routine} jsr iofcb
        .short ERR_-291-DFFNC #} err 291 set first argument is not a suitable name
        .short ERR_-292-DFFNC #} err 292 set first argument is null
        .short ERR_-295-DFFNC #} err 295 set file does not exist
        MOV                 #load second arg} mov r_io1 wb
        MOV                 #load third arg} mov r_io2 wc
        CALL sysst          #call system set routine} jsr sysst
        .short ERR_-293-DFFNC #} err 293 inappropriate second argument to set
        .short ERR_-294-DFFNC #} err 294 inappropriate third argument to set
        .short ERR_-295-DFFNC #} err 295 set file does not exist
        .short ERR_-296-DFFNC #} err 296 set file does not permit setting file pointer
        .short ERR_-297-DFFNC #} err 297 set caused non-recoverable i/o error
        JMP  exint          #otherwise return position} brn exint
                            #} ejc
        .eject
#
#      tab
#
        .balign 2           #entry point} ent
        NOP
s_tab:
        MOV                 #set pcode for integer arg case} mov =p_tab wb
        MOV                 #set pcode for expression arg case} mov =p_tbd wa
        CALL patin          #call common routine to build node} jsr patin
        .short ERR_-183-DFFNC #} err 183 tab argument is not integer or expression
        .short ERR_-184-DFFNC #} err 184 tab argument is negative or too large
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      rpos
#
        .balign 2           #entry point} ent
        NOP
s_rps:
        MOV                 #set pcode for integer arg case} mov =p_rps wb
        MOV                 #set pcode for expression arg case} mov =p_rpd wa
        CALL patin          #call common routine to build node} jsr patin
        .short ERR_-185-DFFNC #} err 185 rpos argument is not integer or expression
        .short ERR_-186-DFFNC #} err 186 rpos argument is negative or too large
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      rsort
#
        .balign 2           #entry point} ent
        NOP
s_rsr:
        MOV                 #mark as rsort} mnz wa
        CALL sorta          #call sort routine} jsr sorta
        .short exfal-DFFNC  #if conversion fails, so shall we} ppm exfal
        JMP  exsid          #return, setting idval} brn exsid
                            #} ejc
        .eject
#
#      setexit
#
        .balign 2           #entry point} ent
        NOP
s_stx:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        MOV                 #load old vrblk pointer} mov stxvr wa
        XOR                 #load zero in case null arg} zer xl
        CMP                 #jump if null argument (reset call)} beq xr =nulls sstx1
             sstx1
        CALL gtnvr          #else get specified vrblk} jsr gtnvr
        .short sstx2-DFFNC  #jump if not natural variable} ppm sstx2
        MOV                 #else load label} mov vrlbl(xr) xl
        CMP                 #jump if label is not defined} beq xl =stndl sstx2
             sstx2
        CMP  DWORD PTR [],offset b_trt #jump if not trapped} bne (xl) =b_trt sstx1
             sstx1
        MOV                 #else load ptr to real label code} mov trlbl(xl) xl
#
#      here to set/reset setexit trap
#
sstx1:  MOV  DWORD PTR stxvr #store new vrblk pointer (or null)} mov xr stxvr
        MOV  DWORD PTR r_sxc #store new code ptr (or zero)} mov xl r_sxc
        CMP                 #return null if null result} beq wa =nulls exnul
             exnul
        MOV                 #else copy vrblk pointer} mov wa xr
        JMP  exvnm          #and return building nmblk} brn exvnm
#
#      here if bad argument
#
sstx2:  CALL ERR_0          #} erb 187 setexit argument is not label name or null
        .byte 187
#
#      sin
#
        .balign 2           #entry point} ent
        NOP
s_sin:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-308-DFFNC #} err 308 sin argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL sin_           #take sine} sin
        CALL OVR_           #if no overflow, return result in ra} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 323 sin argument is out of range
        .byte 67
                            #} ejc
        .eject
#
#      sqrt
#
        .balign 2           #entry point} ent
        NOP
s_sqr:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-313-DFFNC #} err 313 sqrt argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL CPR_           #negative number} rlt ssqr1
        JL   ssqr1
        CALL sqr_           #take square root} sqr
        JMP  exrea          #no overflow possible, result in ra} brn exrea
#
#      here if bad argument
#
ssqr1:  CALL ERR_1          #} erb 314 sqrt argument negative
        .byte 58
                            #} ejc
        .eject
                            #} ejc
        .eject
#
#      sort
#
        .balign 2           #entry point} ent
        NOP
s_srt:
        XOR                 #mark as sort} zer wa
        CALL sorta          #call sort routine} jsr sorta
        .short exfal-DFFNC  #if conversion fails, so shall we} ppm exfal
        JMP  exsid          #return, setting idval} brn exsid
                            #} ejc
        .eject
#
#      span
#
        .balign 2           #entry point} ent
        NOP
s_spn:
        MOV                 #set pcode for single char arg} mov =p_sps wb
        MOV                 #set pcode for multi-char arg} mov =p_spn xl
        MOV                 #set pcode for expression arg} mov =p_spd wc
        CALL patst          #call common routine to build node} jsr patst
        .short ERR_-188-DFFNC #} err 188 span argument is not a string or expression
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      size
#
        .balign 2           #entry point} ent
        NOP
s_si_:
        CALL gtstg          #load string argument} jsr gtstg
        .short ERR_-189-DFFNC #} err 189 size argument is not a string
#
#      merge with bfblk or scblk ptr in xr.  wa has length.
#
        MOV  EDX            #load length as integer} mti wa
        JMP  exint          #exit with integer result} brn exint
                            #} ejc
        .eject
#
#      stoptr
#
        .balign 2           #entry point} ent
        NOP
s_stt:
        XOR                 #indicate stoptr case} zer xl
        CALL trace          #call trace procedure} jsr trace
        .short ERR_-190-DFFNC #} err 190 stoptr first argument is not appropriate name
        .short ERR_-191-DFFNC #} err 191 stoptr second argument is not trace type
        JMP  exnul          #return null} brn exnul
                            #} ejc
        .eject
#
#      substr
#
        .balign 2           #entry point} ent
        NOP
s_sub:
        CALL gtsmi          #load third argument} jsr gtsmi
        .short ERR_-192-DFFNC #} err 192 substr third argument is not integer
        .short exfal-DFFNC  #jump if negative or too large} ppm exfal
        MOV  DWORD PTR sbssv #save third argument} mov xr sbssv
        CALL gtsmi          #load second argument} jsr gtsmi
        .short ERR_-193-DFFNC #} err 193 substr second argument is not integer
        .short exfal-DFFNC  #jump if out of range} ppm exfal
        MOV                 #save second argument} mov xr wc
        OR                  #jump if second argument zero} bze wc exfal
        JZ   exfal
        DEC                 #else decrement for ones origin} dcv wc
        CALL gtstg          #load first argument} jsr gtstg
        .short ERR_-194-DFFNC #} err 194 substr first argument is not a string
#
#      merge with bfblk or scblk ptr in xr.  wa has length
#
        MOV                 #copy second arg to wb} mov wc wb
        MOV                 #reload third argument} mov sbssv wc
        OR                  #skip if third arg given} bnz wc ssub2
        JNZ  ssub2
        MOV                 #else get string length} mov wa wc
        CMP                 #fail if improper} bgt wb wc exfal
             exfal
        SUB                 #reduce by offset to start} sub wb wc
#
#      merge
#
ssub2:  MOV                 #save string length} mov wa xl
        MOV                 #set length of substring} mov wc wa
        ADD                 #add 2nd arg to 3rd arg} add wb wc
        CMP                 #jump if improper substring} bgt wc xl exfal
             exfal
        MOV                 #copy pointer to first arg} mov xr xl
        CALL sbstr          #build substring} jsr sbstr
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      table
#
        .balign 2           #entry point} ent
        NOP
s_tbl:
        MOV                 #get initial lookup value} mov (xs)+ xl
        LEA
        ADD                 #pop second argument} ica xs
        CALL gtsmi          #load argument} jsr gtsmi
        .short ERR_-195-DFFNC #} err 195 table argument is not integer
        .short ERR_-196-DFFNC #} err 196 table argument is out of range
        OR                  #jump if non-zero} bnz wc stbl1
        JNZ  stbl1
        MOV                 #else supply default value} mov =tbnbk wc
#
#      merge here with number of headers in wc
#
stbl1:  CALL tmake          #make table} jsr tmake
        JMP  exsid          #exit setting idval} brn exsid
                            #} ejc
        .eject
#
#      tan
#
        .balign 2           #entry point} ent
        NOP
s_tan:
        MOV                 #get argument} mov (xs)+ xr
        LEA
        CALL gtrea          #convert to real} jsr gtrea
        .short ERR_-309-DFFNC #} err 309 tan argument not numeric
        LEA  EAX,DWORD PTR (4*rcval)[] #load accumulator with argument} ldr rcval(xr)
        CALL ldr_
        CALL tan_           #take tangent} tan
        CALL OVR_           #if no overflow, return result in ra} rno exrea
        JNO  exrea
        CALL ERR_1          #} erb 310 tan produced real overflow or argument is out of range
        .byte 54
                            #} ejc
        .eject
#
#      time
#
        .balign 2           #entry point} ent
        NOP
s_tim:
        CALL systm          #get timer value} jsr systm
        SUB  EDX,DWORD PTR timsx #subtract starting time} sbi timsx
        JMP  exint          #exit with integer value} brn exint
                            #} ejc
        .eject
#
#      trace
#
        .balign 2           #entry point} ent
        NOP
s_tra:
        CMP  DWORD PTR (4*num03)[],offset nulls #jump if first argument is null} beq num03(xs) =nulls str02
             str02
        MOV                 #load fourth argument} mov (xs)+ xr
        LEA
        XOR                 #tentatively set zero pointer} zer xl
        CMP                 #jump if 4th argument is null} beq xr =nulls str01
             str01
        CALL gtnvr          #else point to vrblk} jsr gtnvr
        .short str03-DFFNC  #jump if not variable name} ppm str03
        MOV                 #else save vrblk in trfnc} mov xr xl
#
#      here with vrblk or zero in xl
#
str01:  MOV                 #load third argument (tag)} mov (xs)+ xr
        LEA
        XOR                 #set zero as trtyp value for now} zer wb
        CALL trbld          #build trblk for trace call} jsr trbld
        MOV                 #move trblk pointer for trace} mov xr xl
        CALL trace          #call trace procedure} jsr trace
        .short ERR_-198-DFFNC #} err 198 trace first argument is not appropriate name
        .short ERR_-199-DFFNC #} err 199 trace second argument is not trace type
        JMP  exnul          #return null} brn exnul
#
#      here to call system trace toggle routine
#
str02:  CALL systt          #call it} jsr systt
        ADD                 #pop trace arguments} add *num04 xs
        JMP  exnul          #return} brn exnul
#
#      here for bad fourth argument
#
str03:  CALL ERR_0          #} erb 197 trace fourth arg is not function name or null
        .byte 197
                            #} ejc
        .eject
#
#      trim
#
        .balign 2           #entry point} ent
        NOP
s_trm:
        CALL gtstg          #load argument as string} jsr gtstg
        .short ERR_-200-DFFNC #} err 200 trim argument is not a string
        OR                  #return null if argument is null} bze wa exnul
        JZ   exnul
        MOV                 #copy string pointer} mov xr xl
        ADD                 #get block length} ctb wa schar
        AND
        CALL alloc          #allocate copy same size} jsr alloc
        MOV                 #save pointer to copy} mov xr wb
        SHR  ECX,2          #copy old string block to new} mvw
        REP  MOVSD
        MOV                 #restore ptr to new block} mov wb xr
        CALL trimr          #trim blanks (wb is non-zero)} jsr trimr
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      unload
#
        .balign 2           #entry point} ent
        NOP
s_unl:
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CALL gtnvr          #point to vrblk} jsr gtnvr
        .short ERR_-201-DFFNC #} err 201 unload argument is not natural variable name
        MOV                 #get ptr to undefined function} mov =stndf xl
        CALL dffnc          #undefine named function} jsr dffnc
        JMP  exnul          #return null as result} brn exnul
                            #} ttl s p i t b o l -- utility routines
        .sbttl "s p i t b o l -- utility routines"
#
#      the following section contains utility routines used for
#      various purposes throughout the system. these differ
#      from the procedures in the utility procedures section in
#      they are not in procedure form and they do not return
#      to their callers. they are accessed with a branch type
#      instruction after setting the registers to appropriate
#      parameter values.
#
#      the register values required for each routine are
#      documented at the start of each routine. registers not
#      mentioned may contain any values except that xr,xl
#      can only contain proper collectable pointers.
#
#      some of these routines will tolerate garbage pointers
#      in xl,xr on entry. this is always documented and in
#      each case, the routine clears these garbage values before
#      exiting after completing its task.
#
#      the routines have names consisting of five letters
#      and are assembled in alphabetical order.
                            #} ejc
        .eject
#      arref -- array reference
#
#      (xl)                  may be non-collectable
#      (xr)                  number of subscripts
#      (wb)                  set zero/nonzero for value/name
#                            the value in wb must be collectable
#      stack                 subscripts and array operand
#      brn  arref            jump to call function
#
#      arref continues by executing the next code word with
#      the result name or value placed on top of the stack.
#      to deal with the problem of accessing subscripts in the
#      order of stacking, xl is used as a subscript pointer
#      working below the stack pointer.
#
arref:                      #} rtn
        .global arref
        MOV                 #copy number of subscripts} mov xr wa
        MOV                 #point to stack front} mov xs xt
        SAL                 #convert to byte offset} wtb xr
        ADD                 #point to array operand on stack} add xr xt
        ADD                 #final value for stack popping} ica xt
        MOV  DWORD PTR arfxs #keep for later} mov xt arfxs
        LEA                 #load array operand pointer} mov -(xt) xr
        MOV
        MOV  DWORD PTR r_arf #keep array pointer} mov xr r_arf
        MOV                 #save pointer to subscripts} mov xt xr
        MOV                 #point xl to possible vcblk or tbblk} mov r_arf xl
        MOV                 #load first word} mov (xl) wc
        CMP                 #jump if arblk} beq wc =b_art arf01
             arf01
        CMP                 #jump if vcblk} beq wc =b_vct arf07
             arf07
        CMP                 #jump if tbblk} beq wc =b_tbt arf10
             arf10
        CALL ERR_0          #} erb 235 subscripted operand is not table or array
        .byte 235
#
#      here for array (arblk)
#
arf01:  CMP                 #jump if wrong number of dims} bne wa arndm(xl) arf09
             arf09
        MOV  EDX,DWORD PTR intv0 #get initial subscript of zero} ldi intv0
        MOV                 #point before subscripts} mov xr xt
        XOR                 #initial offset to bounds} zer wa
        JMP  arf03          #jump into loop} brn arf03
#
#      loop to compute subscripts by multiplications
#
arf02:  IMUL EDX,DWORD PTR (4*ardm2)[] #multiply total by next dimension} mli ardm2(xr)
#
#      merge here first time
#
arf03:  LEA                 #load next subscript} mov -(xt) xr
        MOV
        MOV  DWORD PTR arfsi,EDX #save current subscript} sti arfsi
        MOV  EDX,DWORD PTR (4*icval)[] #load integer value in case} ldi icval(xr)
        CMP  DWORD PTR [],offset b_icl #jump if it was an integer} beq (xr) =b_icl arf04
             arf04
                            #} ejc
        .eject
#
#      arref (continued)
#
#
        CALL gtint          #convert to integer} jsr gtint
        .short arf12-DFFNC  #jump if not integer} ppm arf12
        MOV  EDX,DWORD PTR (4*icval)[] #if ok, load integer value} ldi icval(xr)
#
#      here with integer subscript in (ia)
#
arf04:  MOV                 #point to array} mov r_arf xr
        ADD                 #offset to next bounds} add wa xr
        SUB  EDX,DWORD PTR (4*arlbd)[] #subtract low bound to compare} sbi arlbd(xr)
        JO   arf13          #out of range fail if overflow} iov arf13
        OR   EDX,EDX        #out of range fail if too small} ilt arf13
        JL   arf13
        SUB  EDX,DWORD PTR (4*ardim)[] #subtract dimension} sbi ardim(xr)
#        OR   EDX,EDX        #out of range fail if too large} ige arf13   (Optimized)
        JGE  arf13
        ADD  EDX,DWORD PTR (4*ardim)[] #else restore subscript offset} adi ardim(xr)
        ADD  EDX,DWORD PTR arfsi #add to current total} adi arfsi
        ADD                 #point to next bounds} add *ardms wa
        CMP                 #loop back if more to go} bne xt xs arf02
             arf02
#
#      here with integer subscript computed
#
        MOV                 #get as one word integer} mfi wa
        SAL                 #convert to offset} wtb wa
        MOV                 #point to arblk} mov r_arf xl
        ADD                 #add offset past bounds} add arofs(xl) wa
        ADD                 #adjust for arpro field} ica wa
#        OR                  #exit with name if name call} bnz wb arf08  (Optimized)
        JNZ  arf08
#
#      merge here to get value for value call
#
arf05:  CALL acess          #get value} jsr acess
        .short arf13-DFFNC  #fail if acess fails} ppm arf13
#
#      return value
#
arf06:  MOV                 #pop stack entries} mov arfxs xs
        XOR  EAX,EAX        #finished with array pointer} zer r_arf
        MOV  DWORD PTR r_arf,EAX
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      arref (continued)
#
#      here for vector
#
arf07:  CMP                 #error if more than 1 subscript} bne wa =num01 arf09
             arf09
        MOV                 #else load subscript} mov (xs) xr
        CALL gtint          #convert to integer} jsr gtint
        .short arf12-DFFNC  #error if not integer} ppm arf12
        MOV  EDX,DWORD PTR (4*icval)[] #else load integer value} ldi icval(xr)
        SUB  EDX,DWORD PTR intv1 #subtract for ones offset} sbi intv1
#        OR   EDX,EDX        #get subscript as one word} mfi wa arf13  (Optimized)
        JS   arf13
        MOV
        ADD                 #add offset for standard fields} add =vcvls wa
        SAL                 #convert offset to bytes} wtb wa
        CMP                 #fail if out of range subscript} bge wa vclen(xl) arf13
             arf13
        OR                  #back to get value if value call} bze wb arf05
        JZ   arf05
#
#      return name
#
arf08:  MOV                 #pop stack entries} mov arfxs xs
        XOR  EAX,EAX        #finished with array pointer} zer r_arf
        MOV  DWORD PTR r_arf,EAX
        JMP  exnam          #else exit with name} brn exnam
#
#      here if subscript count is wrong
#
arf09:  CALL ERR_0          #} erb 236 array referenced with wrong number of subscripts
        .byte 236
#
#      table
#
arf10:  CMP                 #error if more than 1 subscript} bne wa =num01 arf11
             arf11
        MOV                 #else load subscript} mov (xs) xr
        CALL tfind          #call table search routine} jsr tfind
        .short arf13-DFFNC  #fail if failed} ppm arf13
        OR                  #exit with name if name call} bnz wb arf08
        JNZ  arf08
        JMP  arf06          #else exit with value} brn arf06
#
#      here for bad table reference
#
arf11:  CALL ERR_0          #} erb 237 table referenced with more than one subscript
        .byte 237
#
#      here for bad subscript
#
arf12:  CALL ERR_0          #} erb 238 array subscript is not integer
        .byte 238
#
#      here to signal failure
#
arf13:  XOR  EAX,EAX        #finished with array pointer} zer r_arf
        MOV  DWORD PTR r_arf,EAX
        JMP  exfal          #fail} brn exfal
                            #} ejc
        .eject
#
#      cfunc -- call a function
#
#      cfunc is used to call a snobol level function. it is
#      used by the apply function (s$app), the function
#      trace routine (trxeq) and the main function call entry
#      (o$fnc, o$fns). in the latter cases, cfunc is used only
#      if the number of arguments is incorrect.
#
#      (xl)                  pointer to function block
#      (wa)                  actual number of arguments
#      (xs)                  points to stacked arguments
#      brn  cfunc            jump to call function
#
#      cfunc continues by executing the function
#
cfunc:                      #} rtn
        .global cfunc
        CMP                 #jump if too few arguments} blt wa fargs(xl) cfnc1
             cfnc1
        CMP                 #jump if correct number of args} beq wa fargs(xl) cfnc3
             cfnc3
#
#      here if too many arguments supplied, pop them off
#
        MOV                 #copy actual number} mov wa wb
        SUB                 #get number of extra args} sub fargs(xl) wb
        SAL                 #convert to bytes} wtb wb
        ADD                 #pop off unwanted arguments} add wb xs
        JMP  cfnc3          #jump to go off to function} brn cfnc3
#
#      here if too few arguments
#
cfnc1:  MOV                 #load required number of arguments} mov fargs(xl) wb
        CMP                 #jump if case of var num of args} beq wb =nini9 cfnc3
             cfnc3
        SUB                 #calculate number missing} sub wa wb
#
#      loop to supply extra null arguments
#
cfnc2:  LEA                 #stack a null argument} mov =nulls -(xs)
        MOV  DWORD PTR [],offset nulls
        DEC                 #loop till proper number stacked} bct wb cfnc2
        JNZ  cfnc2
#
#      merge here to jump to function
#
cfnc3:  JMP  DWORD PTR []   #jump through fcode field} bri (xl)
                            #} ejc
        .eject
#
#      exfal -- exit signalling snobol failure
#
#      (xl,xr)               may be non-collectable
#      brn  exfal            jump to fail
#
#      exfal continues by executing the appropriate fail goto
#
exfal:                      #} rtn
        .global exfal
        MOV                 #pop stack} mov flptr xs
        MOV                 #load failure offset} mov (xs) xr
        ADD                 #point to failure code location} add r_cod xr
        MOV  EBP            #set code pointer} lcp xr
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        MOV                 #load entry address} mov (xr) xl
        JMP                 #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      exint -- exit with integer result
#
#      (xl,xr)               may be non-collectable
#      (ia)                  integer value
#      brn  exint            jump to exit with integer
#
#      exint continues by executing the next code word
#      which it does by falling through to exixr
#
exint:                      #} rtn
        .global exint
        XOR                 #clear dud value} zer xl
        CALL icbld          #build icblk} jsr icbld
                            #} ejc
        .eject
#      exixr -- exit with result in (xr)
#
#      (xr)                  result
#      (xl)                  may be non-collectable
#      brn  exixr            jump to exit with result in (xr)
#
#      exixr continues by executing the next code word
#      which it does by falling through to exits.
exixr:                      #} rtn
        .global exixr
#
        LEA                 #stack result} mov xr -(xs)
        MOV  DWORD PTR []
#
#
#      exits -- exit with result if any stacked
#
#      (xr,xl)               may be non-collectable
#
#      brn  exits            enter exits routine
#
exits:                      #} rtn
        .global exits
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        MOV                 #load entry address} mov (xr) xl
        JMP                 #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      exnam -- exit with name in (xl,wa)
#
#      (xl)                  name base
#      (wa)                  name offset
#      (xr)                  may be non-collectable
#      brn  exnam            jump to exit with name in (xl,wa)
#
#      exnam continues by executing the next code word
#
exnam:                      #} rtn
        .global exnam
        LEA                 #stack name base} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #stack name offset} mov wa -(xs)
        MOV  DWORD PTR []
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      exnul -- exit with null result
#
#      (xl,xr)               may be non-collectable
#      brn  exnul            jump to exit with null value
#
#      exnul continues by executing the next code word
#
exnul:                      #} rtn
        .global exnul
        LEA                 #stack null value} mov =nulls -(xs)
        MOV  DWORD PTR [],offset nulls
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        MOV                 #load entry address} mov (xr) xl
        JMP                 #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      exrea -- exit with real result
#
#      (xl,xr)               may be non-collectable
#      (ra)                  real value
#      brn  exrea            jump to exit with real value
#
#      exrea continues by executing the next code word
#
exrea:                      #} rtn
        .global exrea
        XOR                 #clear dud value} zer xl
        CALL rcbld          #build rcblk} jsr rcbld
        JMP  exixr          #jump to exit with result in xr} brn exixr
                            #} ejc
        .eject
#
#      exsid -- exit setting id field
#
#      exsid is used to exit after building any of the following
#      blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.
#
#      (xr)                  ptr to block with idval field
#      (xl)                  may be non-collectable
#      brn  exsid            jump to exit after setting id field
#
#      exsid continues by executing the next code word
#
exsid:                      #} rtn
        .global exsid
        MOV                 #load current id value} mov curid wa
        CMP                 #jump if no overflow} bne wa =cfp_m exsi1
             exsi1
        XOR                 #else reset for wraparound} zer wa
#
#      here with old idval in wa
#
exsi1:  INC                 #bump id value} icv wa
        MOV  DWORD PTR curid #store for next time} mov wa curid
        MOV  DWORD PTR (4*idval)[] #store id value} mov wa idval(xr)
        JMP  exixr          #exit with result in (xr)} brn exixr
                            #} ejc
        .eject
#
#      exvnm -- exit with name of variable
#
#      exvnm exits after stacking a value which is a nmblk
#      referencing the name of a given natural variable.
#
#      (xr)                  vrblk pointer
#      (xl)                  may be non-collectable
#      brn  exvnm            exit with vrblk pointer in xr
#
exvnm:                      #} rtn
        .global exvnm
        MOV                 #copy name base pointer} mov xr xl
        MOV                 #set size of nmblk} mov *nmsi_ wa
        CALL alloc          #allocate nmblk} jsr alloc
        MOV  DWORD PTR [],offset b_nml #store type word} mov =b_nml (xr)
        MOV  DWORD PTR (4*nmbas)[] #store name base} mov xl nmbas(xr)
        MOV  DWORD PTR (4*nmofs)[],4*vrval #store name offset} mov *vrval nmofs(xr)
        JMP  exixr          #exit with result in xr} brn exixr
                            #} ejc
        .eject
#
#      flpop -- fail and pop in pattern matching
#
#      flpop pops the node and cursor on the stack and then
#      drops through into failp to cause pattern failure
#
#      (xl,xr)               may be non-collectable
#      brn  flpop            jump to fail and pop stack
#
flpop:                      #} rtn
        .global flpop
        ADD                 #pop two entries off stack} add *num02 xs
                            #} ejc
        .eject
#
#      failp -- failure in matching pattern node
#
#      failp is used after failing to match a pattern node.
#      see pattern match routines for details of use.
#
#      (xl,xr)               may be non-collectable
#      brn  failp            signal failure to match
#
#      failp continues by matching an alternative from the stack
#
failp:                      #} rtn
        .global failp
        MOV                 #load alternative node pointer} mov (xs)+ xr
        LEA
        MOV                 #restore old cursor} mov (xs)+ wb
        LEA
        MOV                 #load pcode entry pointer} mov (xr) xl
        JMP                 #jump to execute code for node} bri xl
                            #} ejc
        .eject
#
#      indir -- compute indirect reference
#
#      (wb)                  nonzero/zero for by name/value
#      brn  indir            jump to get indirect ref on stack
#
#      indir continues by executing the next code word
#
indir:                      #} rtn
        .global indir
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CMP  DWORD PTR [],offset b_nml #jump if a name} beq (xr) =b_nml indr2
             indr2
        CALL gtnvr          #else convert to variable} jsr gtnvr
        .short ERR_-239-DFFNC #} err 239 indirection operand is not name
        OR                  #skip if by value} bze wb indr1
        JZ   indr1
        LEA                 #else stack vrblk ptr} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack name offset} mov *vrval -(xs)
        MOV  DWORD PTR [],4*vrval
        MOV                 #load next code word} lcw xr
        ADD  EBP,4
        MOV                 #load entry address} mov (xr) xl
        JMP                 #jump to execute next code word} bri xl
#
#      here to get value of natural variable
#
indr1:  JMP  DWORD PTR []   #jump through vrget field of vrblk} bri (xr)
#
#      here if operand is a name
#
indr2:  MOV                 #load name base} mov nmbas(xr) xl
        MOV                 #load name offset} mov nmofs(xr) wa
        OR                  #exit if called by name} bnz wb exnam
        JNZ  exnam
        CALL acess          #else get value first} jsr acess
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        JMP  exixr          #else return with value in xr} brn exixr
                            #} ejc
        .eject
#
#      match -- initiate pattern match
#
#      (wb)                  match type code
#      brn  match            jump to initiate pattern match
#
#      match continues by executing the pattern match. see
#      pattern match routines (p$xxx) for full details.
#
match:                      #} rtn
        .global match
        MOV                 #load pattern operand} mov (xs)+ xr
        LEA
        CALL gtpat          #convert to pattern} jsr gtpat
        .short ERR_-240-DFFNC #} err 240 pattern match right operand is not pattern
        MOV                 #if ok, save pattern pointer} mov xr xl
        OR                  #jump if not match by name} bnz wb mtch1
        JNZ  mtch1
        MOV                 #else load name offset} mov (xs) wa
        LEA                 #save pattern pointer} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #load name base} mov num02(xs) xl
        CALL acess          #access subject value} jsr acess
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        MOV                 #restore pattern pointer} mov (xs) xl
        MOV  DWORD PTR []   #stack subject string val for merge} mov xr (xs)
        XOR                 #restore type code} zer wb
#
#      merge here with subject value on stack
#
mtch1:  CALL gtstg          #convert subject to string} jsr gtstg
        .short ERR_-241-DFFNC #} err 241 pattern match left operand is not a string
        LEA                 #stack match type code} mov wb -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR r_pms #if ok, store subject string pointer} mov xr r_pms
        MOV  DWORD PTR pmssl #and length} mov wa pmssl
        LEA                 #stack initial cursor (zero)} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        XOR                 #set initial cursor} zer wb
        MOV  DWORD PTR pmhbs #set history stack base ptr} mov xs pmhbs
        XOR  EAX,EAX        #reset pattern assignment flag} zer pmdfl
        MOV  DWORD PTR pmdfl,EAX
        MOV                 #set initial node pointer} mov xl xr
        CMP  DWORD PTR DWORD PTR kvanc,0 #jump if anchored} bnz kvanc mtch2
        JNZ  mtch2
#
#      here for unanchored
#
        LEA                 #stack initial node pointer} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack pointer to anchor move node} mov =nduna -(xs)
        MOV  DWORD PTR [],offset nduna
        JMP  DWORD PTR []   #start match of first node} bri (xr)
#
#      here in anchored mode
#
mtch2:  LEA                 #dummy cursor value} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        LEA                 #stack pointer to abort node} mov =ndabo -(xs)
        MOV  DWORD PTR [],offset ndabo
        JMP  DWORD PTR []   #start match of first node} bri (xr)
                            #} ejc
        .eject
#
#      retrn -- return from function
#
#      (wa)                  string pointer for return type
#      brn  retrn            jump to return from (snobol) func
#
#      retrn continues by executing the code at the return point
#      the stack is cleaned of any garbage left by other
#      routines which may have altered flptr since function
#      entry by using flprt, reserved for use only by
#      function call and return.
#
retrn:                      #} rtn
        .global retrn
        CMP  DWORD PTR DWORD PTR kvfnc,0 #jump if not level zero} bnz kvfnc rtn01
        JNZ  rtn01
        CALL ERR_0          #} erb 242 function return from level zero
        .byte 242
#
#      here if not level zero return
#
rtn01:  MOV                 #pop stack} mov flprt xs
        ADD                 #remove failure offset} ica xs
        MOV                 #pop pfblk pointer} mov (xs)+ xr
        LEA
        MOV  EAX,DWORD PTR [] #pop failure pointer} mov (xs)+ flptr
        MOV  DWORD PTR flptr,EAX
        LEA
        MOV  EAX,DWORD PTR [] #pop old flprt} mov (xs)+ flprt
        MOV  DWORD PTR flprt,EAX
        LEA
        MOV                 #pop code pointer offset} mov (xs)+ wb
        LEA
        MOV                 #pop old code block pointer} mov (xs)+ wc
        LEA
        ADD                 #make old code pointer absolute} add wc wb
        MOV  EBP            #restore old code pointer} lcp wb
        MOV  DWORD PTR r_cod #restore old code block pointer} mov wc r_cod
        DEC  DWORD PTR kvfnc #decrement function level} dcv kvfnc
        MOV                 #load trace} mov kvtra wb
        ADD                 #add ftrace} add kvftr wb
#        OR                  #jump if no tracing possible} bze wb rtn06  (Optimized)
        JZ   rtn06
#
#      here if there may be a trace
#
        LEA                 #save function return type} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #save pfblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR kvrtn #set rtntype for trace function} mov wa kvrtn
        MOV                 #load fnclevel trblk ptr (if any)} mov r_fnc xl
        CALL ktrex          #execute possible fnclevel trace} jsr ktrex
        MOV                 #load vrblk ptr (sgd13)} mov pfvbl(xr) xl
        CMP  DWORD PTR DWORD PTR kvtra,0 #jump if trace is off} bze kvtra rtn02
        JZ   rtn02
        MOV                 #else load return trace trblk ptr} mov pfrtr(xr) xr
        OR                  #jump if not return traced} bze xr rtn02
        JZ   rtn02
        DEC  DWORD PTR kvtra #else decrement trace count} dcv kvtra
        CMP  DWORD PTR DWORD PTR (4*trfnc)[],0 #jump if print trace} bze trfnc(xr) rtn03
        JZ   rtn03
        MOV                 #else set name offset} mov *vrval wa
        MOV  EAX,DWORD PTR (4*num01)[] #make sure rtntype is set right} mov num01(xs) kvrtn
        MOV  DWORD PTR kvrtn,EAX
        CALL trxeq          #execute full trace} jsr trxeq
                            #} ejc
        .eject
#
#      retrn (continued)
#
#      here to test for ftrace
#
rtn02:  CMP  DWORD PTR DWORD PTR kvftr,0 #jump if ftrace is off} bze kvftr rtn05
        JZ   rtn05
        DEC  DWORD PTR kvftr #else decrement ftrace} dcv kvftr
#
#      here for print trace of function return
#
rtn03:  CALL prtsn          #print statement number} jsr prtsn
        MOV                 #load return type} mov num01(xs) xr
        CALL prtst          #print it} jsr prtst
        MOV                 #load blank} mov =ch_bl wa
        CALL prtch          #print it} jsr prtch
        MOV                 #load pfblk ptr} mov 0(xs) xl
        MOV                 #load function vrblk ptr} mov pfvbl(xl) xl
        MOV                 #set vrblk name offset} mov *vrval wa
        CMP                 #jump if not freturn case} bne xr =scfrt rtn04
             rtn04
#
#      for freturn, just print function name
#
        CALL prtnm          #print name} jsr prtnm
        CALL prtnl          #terminate print line} jsr prtnl
        JMP  rtn05          #merge} brn rtn05
#
#      here for return or nreturn, print function name = value
#
rtn04:  CALL prtnv          #print name = value} jsr prtnv
#
#      here after completing trace
#
rtn05:  MOV                 #pop pfblk pointer} mov (xs)+ xr
        LEA
        MOV                 #pop return type string} mov (xs)+ wa
        LEA
#
#      merge here if no trace required
#
rtn06:  MOV  DWORD PTR kvrtn #set rtntype keyword} mov wa kvrtn
        MOV                 #load pointer to fn vrblk} mov pfvbl(xr) xl
                            #} ejc
        .eject
#      retrn (continued)
#
#      get value of function
#
rtn07:  MOV  DWORD PTR rtnbp #save block pointer} mov xl rtnbp
        MOV                 #load value} mov vrval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop back if trapped} beq (xl) =b_trt rtn07
             rtn07
        MOV  DWORD PTR rtnfv #else save function result value} mov xl rtnfv
        MOV  EAX,DWORD PTR [] #save original function value} mov (xs)+ rtnsv
        MOV  DWORD PTR rtnsv,EAX
        LEA
        MOV                 #pop saved pointer} mov (xs)+ xl
        LEA
        OR                  #no action if none} bze xl rtn7c
        JZ   rtn7c
        CMP  DWORD PTR DWORD PTR kvpfl,0 #jump if no profiling} bze kvpfl rtn7c
        JZ   rtn7c
        CALL prflu          #else profile last func stmt} jsr prflu
        CMP  DWORD PTR kvpfl,num02 #branch on value of profile keywd} beq kvpfl =num02 rtn7a
             rtn7a
#
#      here if &profile = 1. start time must be frigged to
#      appear earlier than it actually is, by amount used before
#      the call.
#
        MOV  EDX,DWORD PTR pfstm #load current time} ldi pfstm
        SUB  EDX,DWORD PTR (4*icval)[] #frig by subtracting saved amount} sbi icval(xl)
        JMP  rtn7b          #and merge} brn rtn7b
#
#      here if &profile = 2
#
rtn7a:  MOV  EDX,DWORD PTR (4*icval)[] #load saved time} ldi icval(xl)
#
#      both profile types merge here
#
rtn7b:  MOV  DWORD PTR pfstm,EDX #store back correct start time} sti pfstm
#
#      merge here if no profiling
#
rtn7c:  MOV                 #get number of args} mov fargs(xr) wb
        ADD                 #add number of locals} add pfnlo(xr) wb
#        OR                  #jump if no args/locals} bze wb rtn10  (Optimized)
        JZ   rtn10
        ADD                 #and point to end of pfblk} add pflen(xr) xr
#
#      loop to restore functions and locals
#
rtn08:  LEA                 #load next vrblk pointer} mov -(xr) xl
        MOV
#
#      loop to find value block
#
rtn09:  MOV                 #save block pointer} mov xl wa
        MOV                 #load pointer to next value} mov vrval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop back if trapped} beq (xl) =b_trt rtn09
             rtn09
        MOV                 #else restore last block pointer} mov wa xl
        MOV  EAX,DWORD PTR [] #restore old variable value} mov (xs)+ vrval(xl)
        MOV  DWORD PTR (4*vrval)[],EAX
        LEA
        DEC                 #loop till all processed} bct wb rtn08
        JNZ  rtn08
#
#      now restore function value and exit
#
rtn10:  MOV                 #restore ptr to last function block} mov rtnbp xl
        MOV  EAX,DWORD PTR rtnsv #restore old function value} mov rtnsv vrval(xl)
        MOV  DWORD PTR (4*vrval)[],EAX
        MOV                 #reload function result} mov rtnfv xr
        MOV                 #point to new code block} mov r_cod xl
        MOV  EAX,DWORD PTR kvstn #set lastno from stno} mov kvstn kvlst
        MOV  DWORD PTR kvlst,EAX
        MOV  EAX,DWORD PTR (4*cdstm)[] #reset proper stno value} mov cdstm(xl) kvstn
        MOV  DWORD PTR kvstn,EAX
        MOV  EAX,DWORD PTR kvlin #set lastline from line} mov kvlin kvlln
        MOV  DWORD PTR kvlln,EAX
        MOV  EAX,DWORD PTR (4*cdsln)[] #reset proper line value} mov cdsln(xl) kvlin
        MOV  DWORD PTR kvlin,EAX
        MOV                 #load return type} mov kvrtn wa
        CMP                 #exit with result in xr if return} beq wa =scrtn exixr
             exixr
        CMP                 #fail if freturn} beq wa =scfrt exfal
             exfal
                            #} ejc
        .eject
#
#      retrn (continued)
#
#      here for nreturn
#
        CMP  DWORD PTR [],offset b_nml #jump if is a name} beq (xr) =b_nml rtn11
             rtn11
        CALL gtnvr          #else try convert to variable name} jsr gtnvr
        .short ERR_-243-DFFNC #} err 243 function result in nreturn is not name
        MOV                 #if ok, copy vrblk (name base) ptr} mov xr xl
        MOV                 #set name offset} mov *vrval wa
        JMP  rtn12          #and merge} brn rtn12
#
#      here if returned result is a name
#
rtn11:  MOV                 #load name base} mov nmbas(xr) xl
        MOV                 #load name offset} mov nmofs(xr) wa
#
#      merge here with returned name in (xl,wa)
#
rtn12:  MOV                 #preserve xl} mov xl xr
        MOV                 #load next word} lcw wb
        ADD  EBP,4
        MOV                 #restore xl} mov xr xl
        CMP                 #exit if called by name} beq wb =ofne_ exnam
             exnam
        LEA                 #else save code word} mov wb -(xs)
        MOV  DWORD PTR []
        CALL acess          #get value} jsr acess
        .short exfal-DFFNC  #fail if access fails} ppm exfal
        MOV                 #if ok, copy result} mov xr xl
        MOV                 #reload next code word} mov (xs) xr
        MOV  DWORD PTR []   #store result on stack} mov xl (xs)
        MOV                 #load routine address} mov (xr) xl
        JMP                 #jump to execute next code word} bri xl
                            #} ejc
        .eject
#
#      stcov -- signal statement counter overflow
#
#      brn  stcov            jump to signal statement count oflo
#
#      permit up to 10 more statements to be obeyed so that
#      setexit trap can regain control.
#      stcov continues by issuing the error message
#
stcov:                      #} rtn
        .global stcov
        INC  DWORD PTR errft #fatal error} icv errft
        MOV  EDX,DWORD PTR intvt #get 10} ldi intvt
        ADD  EDX,DWORD PTR kvstl #add to former limit} adi kvstl
        MOV  DWORD PTR kvstl,EDX #store as new stlimit} sti kvstl
        MOV  EDX,DWORD PTR intvt #get 10} ldi intvt
        MOV  DWORD PTR kvstc,EDX #set as new count} sti kvstc
        CALL stgcc          #recompute countdown counters} jsr stgcc
        CALL ERR_0          #} erb 244 statement count exceeds value of stlimit keyword
        .byte 244
                            #} ejc
        .eject
#
#      stmgo -- start execution of new statement
#
#      (xr)                  pointer to cdblk for new statement
#      brn  stmgo            jump to execute new statement
#
#      stmgo continues by executing the next statement
#
stmgo:                      #} rtn
        .global stmgo
        MOV  DWORD PTR r_cod #set new code block pointer} mov xr r_cod
        DEC  DWORD PTR stmct #see if time to check something} dcv stmct
        CMP  DWORD PTR DWORD PTR stmct,0 #jump if so} bze stmct stgo2
        JZ   stgo2
        MOV  EAX,DWORD PTR kvstn #set lastno} mov kvstn kvlst
        MOV  DWORD PTR kvlst,EAX
        MOV  EAX,DWORD PTR (4*cdstm)[] #set stno} mov cdstm(xr) kvstn
        MOV  DWORD PTR kvstn,EAX
        MOV  EAX,DWORD PTR kvlin #set lastline} mov kvlin kvlln
        MOV  DWORD PTR kvlln,EAX
        MOV  EAX,DWORD PTR (4*cdsln)[] #set line} mov cdsln(xr) kvlin
        MOV  DWORD PTR kvlin,EAX
        ADD                 #point to first code word} add *cdcod xr
        MOV  EBP            #set code pointer} lcp xr
#
#      here to execute first code word of statement
#
stgo1:  MOV                 #load next code word} lcw xr
        ADD  EBP,4
        XOR                 #clear garbage xl} zer xl
        JMP  DWORD PTR []   #execute it} bri (xr)
#
#      check profiling, polling, stlimit, statement tracing
#
stgo2:  CMP  DWORD PTR DWORD PTR kvpfl,0 #skip if no profiling} bze kvpfl stgo3
        JZ   stgo3
        CALL prflu          #else profile the statement in kvstn} jsr prflu
#
#      here when finished with profiling
#
stgo3:  MOV  EAX,DWORD PTR kvstn #set lastno} mov kvstn kvlst
        MOV  DWORD PTR kvlst,EAX
        MOV  EAX,DWORD PTR (4*cdstm)[] #set stno} mov cdstm(xr) kvstn
        MOV  DWORD PTR kvstn,EAX
        MOV  EAX,DWORD PTR kvlin #set lastline} mov kvlin kvlln
        MOV  DWORD PTR kvlln,EAX
        MOV  EAX,DWORD PTR (4*cdsln)[] #set line} mov cdsln(xr) kvlin
        MOV  DWORD PTR kvlin,EAX
        ADD                 #point to first code word} add *cdcod xr
        MOV  EBP            #set code pointer} lcp xr
#
#      here to check for polling
#
        LEA                 #save present count start on stack} mov stmcs -(xs)
        MOV  EAX,DWORD PTR stmcs
        MOV  DWORD PTR [],EAX
        DEC  DWORD PTR polct #poll interval within stmct} dcv polct
        CMP  DWORD PTR DWORD PTR polct,0 #jump if not poll time yet} bnz polct stgo4
        JNZ  stgo4
        XOR                 #=0 for poll} zer wa
        MOV                 #statement number} mov kvstn wb
        MOV                 #make collectable} mov xr xl
        CALL syspl          #allow interactive access} jsr syspl
        .short ERR_-320-DFFNC #} err 320 user interrupt
        .short ERR_-299-DFFNC #single step} ppm
        .short ERR_-299-DFFNC #expression evaluation} ppm
        MOV                 #restore code block pointer} mov xl xr
        MOV  DWORD PTR polcs #poll interval start value} mov wa polcs
        CALL stgcc          #recompute counter values} jsr stgcc
#
#      check statement limit
#
stgo4:  MOV  EDX,DWORD PTR kvstc #get stmt count} ldi kvstc
        OR   EDX,EDX        #omit counting if negative} ilt stgo5
        JL   stgo5
        MOV  EDX,DWORD PTR [] #reload start value of counter} mti (xs)+
        LEA
        NEG  EDX            #negate} ngi
        ADD  EDX,DWORD PTR kvstc #stmt count minus counter} adi kvstc
        MOV  DWORD PTR kvstc,EDX #replace it} sti kvstc
        OR   EDX,EDX        #fail if stlimit reached} ile stcov
        JLE  stcov
        CMP  DWORD PTR DWORD PTR r_stc,0 #jump if no statement trace} bze r_stc stgo5
        JZ   stgo5
        XOR                 #clear garbage value in xr} zer xr
        MOV                 #load pointer to stcount trblk} mov r_stc xl
        CALL ktrex          #execute keyword trace} jsr ktrex
#
#      reset stmgo counter
#
stgo5:  MOV  EAX,DWORD PTR stmcs #reset counter} mov stmcs stmct
        MOV  DWORD PTR stmct,EAX
        JMP  stgo1          #fetch next code word} brn stgo1
                            #} ejc
        .eject
#
#      stopr -- terminate run
#
#      (xr)                  points to ending message
#      brn stopr             jump to terminate run
#
#      terminate run and print statistics.  on entry xr points
#      to ending message or is zero if message  printed already.
#
stopr:                      #} rtn
        .global stopr
        OR                  #skip if sysax already called} bze xr stpra
        JZ   stpra
        CALL sysax          #call after execution proc} jsr sysax
stpra:  MOV  EAX,DWORD PTR rsmem #use the reserve memory} add rsmem dname
        ADD  DWORD PTR dname,EAX
        CMP                 #skip if not normal end message} bne xr =endms stpr0
             stpr0
        CMP  DWORD PTR DWORD PTR exsts,0 #skip if exec stats suppressed} bnz exsts stpr3
        JNZ  stpr3
        XOR  EAX,EAX        #clear errors to int.ch. flag} zer erich
        MOV  DWORD PTR erich,EAX
#
#      look to see if an ending message is supplied
#
stpr0:  CALL prtpg          #eject printer} jsr prtpg
        OR                  #skip if no message} bze xr stpr1
        JZ   stpr1
        CALL prtst          #print message} jsr prtst
#
#      merge here if no message to print
#
stpr1:  CALL prtis          #print blank line} jsr prtis
        CMP  DWORD PTR DWORD PTR gbcfl,0 #if in garbage collection, skip} bnz gbcfl stpr5
        JNZ  stpr5
        MOV                 #point to message /in file xxx/} mov =stpm7 xr
        CALL prtst          #print it} jsr prtst
        MOV  DWORD PTR profs,prtmf #set column offset} mov =prtmf profs
        MOV                 #get statement number} mov kvstn wc
        CALL filnm          #get file name} jsr filnm
        MOV                 #prepare to print} mov xl xr
        CALL prtst          #print file name} jsr prtst
        CALL prtis          #print to interactive channel} jsr prtis
        MOV                 #get code pointer} mov r_cod xr
        MOV  EDX,DWORD PTR (4*cdsln)[] #get source line number} mti cdsln(xr)
        MOV                 #point to message /in line xxx/} mov =stpm6 xr
        CALL prtmx          #print it} jsr prtmx
stpr5:  MOV  EDX,DWORD PTR kvstn #get statement number} mti kvstn
        MOV                 #point to message /in statement xxx/} mov =stpm1 xr
        CALL prtmx          #print it} jsr prtmx
        CALL systm          #get current time} jsr systm
        SUB  EDX,DWORD PTR timsx #minus start time = elapsed exec tim} sbi timsx
        MOV  DWORD PTR stpti,EDX #save for later} sti stpti
        MOV                 #point to msg /execution time msec /} mov =stpm3 xr
        CALL prtmx          #print it} jsr prtmx
        MOV  EDX,DWORD PTR kvstl #get statement limit} ldi kvstl
        OR   EDX,EDX        #skip if negative} ilt stpr2
        JL   stpr2
        SUB  EDX,DWORD PTR kvstc #minus counter = course count} sbi kvstc
        MOV  DWORD PTR stpsi,EDX #save} sti stpsi
        MOV                 #refine with counter start value} mov stmcs wa
        SUB                 #minus current counter} sub stmct wa
        MOV  EDX            #convert to integer} mti wa
        ADD  EDX,DWORD PTR stpsi #add in course count} adi stpsi
        MOV  DWORD PTR stpsi,EDX #save} sti stpsi
        MOV                 #point to message /stmts executed/} mov =stpm2 xr
        CALL prtmx          #print it} jsr prtmx
        MOV  EDX,DWORD PTR stpti #reload elapsed time} ldi stpti
        IMUL EDX,DWORD PTR intth #*1000 (microsecs)} mli intth
        JO   stpr2          #jump if we cannot compute} iov stpr2
        MOV  EAX,DWORD PTR stpsi #divide by statement count} dvi stpsi
        CALL dvi_
        JO   stpr2          #jump if overflow} iov stpr2
        MOV                 #point to msg (mcsec per statement /} mov =stpm4 xr
        CALL prtmx          #print it} jsr prtmx
                            #} ejc
        .eject
#
#      stopr (continued)
#
#      merge to skip message (overflow or negative stlimit)
#
stpr2:  MOV  EDX,DWORD PTR gbcnt #load count of collections} mti gbcnt
        MOV                 #point to message /regenerations /} mov =stpm5 xr
        CALL prtmx          #print it} jsr prtmx
        CALL prtmm          #print memory usage} jsr prtmm
        CALL prtis          #one more blank for luck} jsr prtis
#
#      check if dump requested
#
stpr3:  CALL prflr          #print profile if wanted} jsr prflr
#
        MOV                 #load dump keyword} mov kvdmp xr
        CALL dumpr          #execute dump if requested} jsr dumpr
        MOV                 #get fcblk chain head} mov r_fcb xl
        MOV                 #load abend value} mov kvabe wa
        MOV                 #load code value} mov kvcod wb
        CALL sysej          #exit to system} jsr sysej
#
#      here after sysea call and suppressing error msg print
#
stpr4:                      #} rtn
        .global stpr4
        MOV  EAX,DWORD PTR rsmem #use the reserve memory} add rsmem dname
        ADD  DWORD PTR dname,EAX
        CMP  DWORD PTR DWORD PTR exsts,0 #if execution stats requested} bze exsts stpr1
        JZ   stpr1
        JMP  stpr3          #check if dump or profile needed} brn stpr3
                            #} ejc
        .eject
#
#      succp -- signal successful match of a pattern node
#
#      see pattern match routines for details
#
#      (xr)                  current node
#      (wb)                  current cursor
#      (xl)                  may be non-collectable
#      brn  succp            signal successful pattern match
#
#      succp continues by matching the successor node
#
succp:                      #} rtn
        .global succp
        MOV                 #load successor node} mov pthen(xr) xr
        MOV                 #load node code entry address} mov (xr) xl
        JMP                 #jump to match successor node} bri xl
                            #} ejc
        .eject
#
#      sysab -- print /abnormal end/ and terminate
#
sysab:                      #} rtn
        .global sysab
        MOV                 #point to message} mov =endab xr
        MOV  DWORD PTR kvabe,num01 #set abend flag} mov =num01 kvabe
        CALL prtnl          #skip to new line} jsr prtnl
        JMP  stopr          #jump to pack up} brn stopr
                            #} ejc
        .eject
#
#      systu -- print /time up/ and terminate
#
systu:                      #} rtn
        .global systu
        MOV                 #point to message} mov =endtu xr
        MOV                 #get chars /tu/} mov strtu wa
        MOV  DWORD PTR kvcod #put in kvcod} mov wa kvcod
        MOV                 #check state of timeup switch} mov timup wa
        MOV  DWORD PTR timup,ESP #set switch} mnz timup
        OR                  #stop run if already set} bnz wa stopr
        JNZ  stopr
        CALL ERR_0          #} erb 245 translation/execution time expired
        .byte 245
                            #} ttl s p i t b o l -- utility procedures
        .sbttl "s p i t b o l -- utility procedures"
#
#      the following section contains procedures which are
#      used for various purposes throughout the system.
#
#      each procedure is preceded by a description of the
#      calling sequence. usually the arguments are in registers
#      but arguments can also occur on the stack and as
#      parameters assembled after the jsr instruction.
#
#      the following considerations apply to these descriptions.
#
#      1)   the stack pointer (xs) is not changed unless the
#           change is explicitly documented in the call.
#
#      2)   registers whose entry values are not mentioned
#           may contain any value except that xl,xr may only
#           contain proper (collectable) pointer values.
#           this condition on means that the called routine
#           may if it chooses preserve xl,xr by stacking.
#
#      3)   registers not mentioned on exit contain the same
#           values as they did on entry except that values in
#           xr,xl may have been relocated by the collector.
#
#      4)   registers which are destroyed on exit may contain
#           any value except that values in xl,xr are proper
#           (collectable) pointers.
#
#      5)   the code pointer register points to the current
#           code location on entry and is unchanged on exit.
#
#      in the above description, a collectable pointer is one
#      which either points outside the dynamic region or
#      points to the start of a block in the dynamic region.
#
#      in those cases where the calling sequence contains
#      parameters which are used as alternate return points,
#      these parameters may be replaced by error codes
#      assembled with the err instruction. this will result
#      in the posting of the error if the return is taken.
#
#      the procedures all have names consisting of five letters
#      and are in alphabetical order by their names.
                            #} ejc
        .eject
#
#      acess - access variable value with trace/input checks
#
#      acess loads the value of a variable. trace and input
#      associations are tested for and executed as required.
#      acess also handles the special cases of pseudo-variables.
#
#      (xl)                  variable name base
#      (wa)                  variable name offset
#      jsr  acess            call to access value
#      ppm  loc              transfer loc if access failure
#      (xr)                  variable value
#      (wa,wb,wc)            destroyed
#      (xl,ra)               destroyed
#
#      failure can occur if an input association causes an end
#      of file condition or if the evaluation of an expression
#      associated with an expression variable fails.
#
acess:                      #entry point (recursive)} prc r 1
        .global acess
        MOV                 #copy name base} mov xl xr
        ADD                 #point to variable location} add wa xr
        MOV                 #load variable value} mov (xr) xr
#
#      loop here to check for successive trblks
#
acs02:  CMP  DWORD PTR [],offset b_trt #jump if not trapped} bne (xr) =b_trt acs18
             acs18
#
#      here if trapped
#
        CMP                 #jump if keyword variable} beq xr =trbkv acs12
             acs12
        CMP                 #jump if not expression variable} bne xr =trbev acs05
             acs05
#
#      here for expression variable, evaluate variable
#
        MOV                 #load expression pointer} mov evexp(xl) xr
        XOR                 #evaluate by value} zer wb
        CALL evalx          #evaluate expression} jsr evalx
        .short acs04-DFFNC  #jump if evaluation failure} ppm acs04
        JMP  acs02          #check value for more trblks} brn acs02
                            #} ejc
        .eject
#
#      acess (continued)
#
#      here on reading end of file
#
acs03:  ADD                 #pop trblk ptr, name base and offset} add *num03 xs
        MOV  DWORD PTR dnamp #pop unused scblk} mov xr dnamp
#
#      merge here when evaluation of expression fails
#
acs04:  POP  EAX            #take alternate (failure) return} exi 1
        JMP  EXI__1
#
#      here if not keyword or expression variable
#
acs05:  MOV                 #load trap type code} mov trtyp(xr) wb
        OR                  #jump if not input association} bnz wb acs10
        JNZ  acs10
        CMP  DWORD PTR DWORD PTR kvinp,0 #ignore input assoc if input is off} bze kvinp acs09
        JZ   acs09
#
#      here for input association
#
        LEA                 #stack name base} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #stack name offset} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #stack trblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  EAX,DWORD PTR kvtrm #temp to hold trim keyword} mov kvtrm actrm
        MOV  DWORD PTR actrm,EAX
        MOV                 #get file ctrl blk ptr or zero} mov trfpt(xr) xl
        OR                  #jump if not standard input file} bnz xl acs06
        JNZ  acs06
        CMP  DWORD PTR (4*trter)[],offset v_ter #jump if terminal} beq trter(xr) =v_ter acs21
             acs21
#
#      here to read from standard input file
#
        MOV                 #length for read buffer} mov cswin wa
        CALL alocs          #build string of appropriate length} jsr alocs
        CALL sysrd          #read next standard input image} jsr sysrd
        .short acs03-DFFNC  #jump to fail exit if end of file} ppm acs03
        JMP  acs07          #else merge with other file case} brn acs07
#
#      here for input from other than standard input file
#
acs06:  MOV                 #fcblk ptr} mov xl wa
        CALL sysil          #get input record max length (to wa)} jsr sysil
        OR                  #jump if not binary file} bnz wc acs6a
        JNZ  acs6a
        MOV  DWORD PTR actrm #disable trim for binary file} mov wc actrm
acs6a:  CALL alocs          #allocate string of correct size} jsr alocs
        MOV                 #fcblk ptr} mov xl wa
        CALL sysin          #call system input routine} jsr sysin
        .short acs03-DFFNC  #jump to fail exit if end of file} ppm acs03
        .short acs22-DFFNC  #error} ppm acs22
        .short acs23-DFFNC  #error} ppm acs23
                            #} ejc
        .eject
#
#      acess (continued)
#
#      merge here after obtaining input record
#
acs07:  MOV                 #load trim indicator} mov actrm wb
        CALL trimr          #trim record as required} jsr trimr
        MOV                 #copy result pointer} mov xr wb
        MOV                 #reload pointer to trblk} mov (xs) xr
#
#      loop to chase to end of trblk chain and store value
#
acs08:  MOV                 #save pointer to this trblk} mov xr xl
        MOV                 #load forward pointer} mov trnxt(xr) xr
        CMP  DWORD PTR [],offset b_trt #loop if this is another trblk} beq (xr) =b_trt acs08
             acs08
        MOV  DWORD PTR (4*trnxt)[] #else store result at end of chain} mov wb trnxt(xl)
        MOV                 #restore initial trblk pointer} mov (xs)+ xr
        LEA
        MOV                 #restore name offset} mov (xs)+ wa
        LEA
        MOV                 #restore name base pointer} mov (xs)+ xl
        LEA
#
#      come here to move to next trblk
#
acs09:  MOV                 #load forward ptr to next value} mov trnxt(xr) xr
        JMP  acs02          #back to check if trapped} brn acs02
#
#      here to check for access trace trblk
#
acs10:  CMP                 #loop back if not access trace} bne wb =trtac acs09
             acs09
        CMP  DWORD PTR DWORD PTR kvtra,0 #ignore access trace if trace off} bze kvtra acs09
        JZ   acs09
        DEC  DWORD PTR kvtra #else decrement trace count} dcv kvtra
        CMP  DWORD PTR DWORD PTR (4*trfnc)[],0 #jump if print trace} bze trfnc(xr) acs11
        JZ   acs11
                            #} ejc
        .eject
#
#      acess (continued)
#
#      here for full function trace
#
        CALL trxeq          #call routine to execute trace} jsr trxeq
        JMP  acs09          #jump for next trblk} brn acs09
#
#      here for case of print trace
#
acs11:  CALL prtsn          #print statement number} jsr prtsn
        CALL prtnv          #print name = value} jsr prtnv
        JMP  acs09          #jump back for next trblk} brn acs09
#
#      here for keyword variable
#
acs12:  MOV                 #load keyword number} mov kvnum(xl) xr
        CMP                 #jump if not one word value} bge xr =k_v__ acs14
             acs14
        MOV  EDX,kvabe[]    #else load value as integer} mti kvabe(xr)
#
#      common exit with keyword value as integer in (ia)
#
acs13:  CALL icbld          #build icblk} jsr icbld
        JMP  acs18          #jump to exit} brn acs18
#
#      here if not one word keyword value
#
acs14:  CMP                 #jump if special case} bge xr =k_s__ acs15
             acs15
        SUB                 #else get offset} sub =k_v__ xr
        SAL                 #convert to byte offset} wtb xr
        ADD                 #point to pattern value} add =ndabo xr
        JMP  acs18          #jump to exit} brn acs18
#
#      here if special keyword case
#
acs15:  MOV                 #load rtntype in case} mov kvrtn xl
        MOV  EDX,DWORD PTR kvstl #load stlimit in case} ldi kvstl
        SUB                 #get case number} sub =k_s__ xr
        JMP  DWORD PTR L0005[*4] #switch on keyword number} bsw xr k__n_
        DSeg_
L0005:
        .long acs16         #jump if alphabet} iff k__al acs16
        .long acs17         #rtntype} iff k__rt acs17
        .long acs19         #stcount} iff k__sc acs19
        .long acs20         #errtext} iff k__et acs20
        .long acs26         #file} iff k__fl acs26
        .long acs27         #lastfile} iff k__lf acs27
        .long acs13         #stlimit} iff k__sl acs13
        .long acs24         #lcase} iff k__lc acs24
        .long acs25         #ucase} iff k__uc acs25
        DSegEnd_            #end switch on keyword number} esw
        CSeg_
                            #} ejc
        .eject
#
#      acess (continued)
#
#      lcase
#
acs24:  MOV                 #load pointer to lcase string} mov =lcase xr
        JMP  acs18          #common return} brn acs18
#
#      ucase
#
acs25:  MOV                 #load pointer to ucase string} mov =ucase xr
        JMP  acs18          #common return} brn acs18
#
#      file
#
acs26:  MOV                 #load current stmt number} mov kvstn wc
        JMP  acs28          #merge to obtain file name} brn acs28
#
#      lastfile
#
acs27:  MOV                 #load last stmt number} mov kvlst wc
#
#      merge here to map statement number in wc to file name
#
acs28:  CALL filnm          #obtain file name for this stmt} jsr filnm
        JMP  acs17          #merge to return string in xl} brn acs17
#      alphabet
#
acs16:  MOV                 #load pointer to alphabet string} mov kvalp xl
#
#      rtntype merges here
#
acs17:  MOV                 #copy string ptr to proper reg} mov xl xr
#
#      common return point
#
acs18:  POP  EAX            #return to acess caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here for stcount (ia has stlimit)
#
acs19:  OR   EDX,EDX        #if counting suppressed} ilt acs29
        JL   acs29
        MOV                 #refine with counter start value} mov stmcs wa
        SUB                 #minus current counter} sub stmct wa
        MOV  EDX            #convert to integer} mti wa
        ADD  EDX,DWORD PTR kvstl #add stlimit} adi kvstl
acs29:  SUB  EDX,DWORD PTR kvstc #stcount = limit - left} sbi kvstc
        JMP  acs13          #merge back with integer result} brn acs13
#
#      errtext
#
acs20:  MOV                 #get errtext string} mov r_etx xr
        JMP  acs18          #merge with result} brn acs18
#
#      here to read a record from terminal
#
acs21:  MOV                 #buffer length} mov =rilen wa
        CALL alocs          #allocate buffer} jsr alocs
        CALL sysri          #read record} jsr sysri
        .short acs03-DFFNC  #endfile} ppm acs03
        JMP  acs07          #merge with record read} brn acs07
#
#      error returns
#
acs22:  MOV  DWORD PTR dnamp #pop unused scblk} mov xr dnamp
        CALL ERR_0          #} erb 202 input from file caused non-recoverable error
        .byte 202
#
acs23:  MOV  DWORD PTR dnamp #pop unused scblk} mov xr dnamp
        CALL ERR_0          #} erb 203 input file record has incorrect format
        .byte 203
                            #end procedure acess} enp
                            #} ejc
        .eject
#
#      acomp -- compare two arithmetic values
#
#      1(xs)                 first argument
#      0(xs)                 second argument
#      jsr  acomp            call to compare values
#      ppm  loc              transfer loc if arg1 is non-numeric
#      ppm  loc              transfer loc if arg2 is non-numeric
#      ppm  loc              transfer loc for arg1 lt arg2
#      ppm  loc              transfer loc for arg1 eq arg2
#      ppm  loc              transfer loc for arg1 gt arg2
#      (normal return is never given)
#      (wa,wb,wc,ia,ra)      destroyed
#      (xl,xr)               destroyed
#
acomp:                      #entry point} prc n 5
        .global acomp
        POP  PRC_+0
        CALL arith          #load arithmetic operands} jsr arith
        .short acmp7-DFFNC  #jump if first arg non-numeric} ppm acmp7
        .short acmp8-DFFNC  #jump if second arg non-numeric} ppm acmp8
        .short acmp4-DFFNC  #jump if real arguments} ppm acmp4
#
#      here for integer arguments
#
        SUB  EDX,DWORD PTR (4*icval)[] #subtract to compare} sbi icval(xl)
        JO   acmp3          #jump if overflow} iov acmp3
        OR   EDX,EDX        #else jump if arg1 lt arg2} ilt acmp5
        JL   acmp5
        OR   EDX,EDX        #jump if arg1 eq arg2} ieq acmp2
        JE   acmp2
#
#      here if arg1 gt arg2
#
acmp1:  POP  EAX            #take gt exit} exi 5
        JMP  EXI__5
#
#      here if arg1 eq arg2
#
acmp2:  POP  EAX            #take eq exit} exi 4
        JMP  EXI__4
                            #} ejc
        .eject
#
#      acomp (continued)
#
#      here for integer overflow on subtract
#
acmp3:  MOV  EDX,DWORD PTR (4*icval)[] #load second argument} ldi icval(xl)
        OR   EDX,EDX        #gt if negative} ilt acmp1
        JL   acmp1
        JMP  acmp5          #else lt} brn acmp5
#
#      here for real operands
#
acmp4:  LEA  EAX,DWORD PTR (4*rcval)[] #subtract to compare} sbr rcval(xl)
        CALL sbr_
        CALL OVR_           #jump if overflow} rov acmp6
        JO   acmp6
        CALL CPR_           #else jump if arg1 gt} rgt acmp1
        JG   acmp1
        CALL CPR_           #jump if arg1 eq arg2} req acmp2
        JE   acmp2
#
#      here if arg1 lt arg2
#
acmp5:  POP  EAX            #take lt exit} exi 3
        JMP  EXI__3
#
#      here if overflow on real subtraction
#
acmp6:  LEA  EAX,DWORD PTR (4*rcval)[] #reload arg2} ldr rcval(xl)
        CALL ldr_
        CALL CPR_           #gt if negative} rlt acmp1
        JL   acmp1
        JMP  acmp5          #else lt} brn acmp5
#
#      here if arg1 non-numeric
#
acmp7:  POP  EAX            #take error exit} exi 1
        JMP  EXI__1
#
#      here if arg2 non-numeric
#
acmp8:  POP  EAX            #take error exit} exi 2
        JMP  EXI__2
                            #end procedure acomp} enp
                            #} ejc
        .eject
#
#      alloc                 allocate block of dynamic storage
#
#      (wa)                  length required in bytes
#      jsr  alloc            call to allocate block
#      (xr)                  pointer to allocated block
#
#      a possible alternative to aov ... and following stmt is -
#      mov  dname,xr .  sub  wa,xr .  blo xr,dnamp,aloc2 .
#      mov  dnamp,xr .  add  wa,xr
#
alloc:                      #entry point} prc e 0
        .global alloc
#
#      common exit point
#
aloc1:  MOV                 #point to next available loc} mov dnamp xr
        ADD                 #point past allocated block} aov wa xr aloc2
        JC   aloc2
        CMP                 #jump if not enough room} bgt xr dname aloc2
             aloc2
        MOV  DWORD PTR dnamp #store new pointer} mov xr dnamp
        SUB                 #point back to start of allocated bk} sub wa xr
        RET                 #return to caller} exi
#
#      here if insufficient room, try a garbage collection
#
aloc2:  MOV  DWORD PTR allsv #save wb} mov wb allsv
alc2a:  XOR                 #set no upward move for gbcol} zer wb
        CALL gbcol          #garbage collect} jsr gbcol
        MOV                 #remember new sediment size} mov xr wb
#
#      see if room after gbcol or sysmm call
#
aloc3:  MOV                 #point to first available loc} mov dnamp xr
        ADD                 #point past new block} aov wa xr alc3a
        JC   alc3a
        CMP                 #jump if there is room now} blo xr dname aloc4
             aloc4
#
#      failed again, see if we can get more core
#
alc3a:  CALL sysmm          #try to get more memory} jsr sysmm
        SAL                 #convert to baus (sgd05)} wtb xr
        ADD  DWORD PTR dname #bump ptr by amount obtained} add xr dname
        OR                  #jump if got more core} bnz xr aloc3
        JNZ  aloc3
        CMP  DWORD PTR DWORD PTR dnams,0 #jump if there was no sediment} bze dnams alc3b
        JZ   alc3b
        XOR  EAX,EAX        #try collecting the sediment} zer dnams
        MOV  DWORD PTR dnams,EAX
        JMP  alc2a          #} brn alc2a
#
#      sysmm failed and there was no sediment to collect
#
alc3b:  MOV  EAX,DWORD PTR rsmem #get the reserve memory} add rsmem dname
        ADD  DWORD PTR dname,EAX
        XOR  EAX,EAX        #only permissible once} zer rsmem
        MOV  DWORD PTR rsmem,EAX
        INC  DWORD PTR errft #fatal error} icv errft
        CALL ERR_0          #} erb 204 memory overflow
        .byte 204
                            #} ejc
        .eject
#
#      here after successful garbage collection
#
aloc4:  MOV  DWORD PTR allia,EDX #save ia} sti allia
        MOV  DWORD PTR dnams #record new sediment size} mov wb dnams
        MOV                 #get dynamic end adrs} mov dname wb
        SUB                 #compute free store} sub dnamp wb
        SHR                 #convert bytes to words} btw wb
        MOV  EDX            #put free store in ia} mti wb
        IMUL EDX,DWORD PTR alfsf #multiply by free store factor} mli alfsf
        JO   aloc5          #jump if overflowed} iov aloc5
        MOV                 #dynamic end adrs} mov dname wb
        SUB                 #compute total amount of dynamic} sub dnamb wb
        SHR                 #convert to words} btw wb
        MOV  DWORD PTR aldyn #store it} mov wb aldyn
        SUB  EDX,DWORD PTR aldyn #subtract from scaled up free store} sbi aldyn
#        OR   EDX,EDX        #jump if sufficient free store} igt aloc5   (Optimized)
        JG   aloc5
        CALL sysmm          #try to get more store} jsr sysmm
        SAL                 #convert to baus (sgd05)} wtb xr
        ADD  DWORD PTR dname #adjust dynamic end adrs} add xr dname
#
#      merge to restore ia and wb
#
aloc5:  MOV  EDX,DWORD PTR allia #recover ia} ldi allia
        MOV                 #restore wb} mov allsv wb
        JMP  aloc1          #jump back to exit} brn aloc1
                            #end procedure alloc} enp
                            #} ejc
        .eject
#
#      alocs -- allocate string block
#
#      alocs is used to build a frame for a string block into
#      which the actual characters are placed by the caller.
#      all strings are created with a call to alocs (the
#      exceptions occur in trimr and s$rpl procedures).
#
#      (wa)                  length of string to be allocated
#      jsr  alocs            call to allocate scblk
#      (xr)                  pointer to resulting scblk
#      (wa)                  destroyed
#      (wc)                  character count (entry value of wa)
#
#      the resulting scblk has the type word and the length
#      filled in and the last word is cleared to zero characters
#      to ensure correct right padding of the final word.
#
alocs:                      #entry point} prc e 0
        .global alocs
        CMP                 #jump if length exceeds maxlength} bgt wa kvmxl alcs2
             alcs2
        MOV                 #else copy length} mov wa wc
        ADD                 #compute length of scblk in bytes} ctb wa scsi_
        AND
        MOV                 #point to next available location} mov dnamp xr
        ADD                 #point past block} aov wa xr alcs0
        JC   alcs0
        CMP                 #jump if there is room} blo xr dname alcs1
             alcs1
#
#      insufficient memory
#
alcs0:  XOR                 #else clear garbage xr value} zer xr
        CALL alloc          #and use standard allocator} jsr alloc
        ADD                 #point past end of block to merge} add wa xr
#
#      merge here with xr pointing beyond new block
#
alcs1:  MOV  DWORD PTR dnamp #set updated storage pointer} mov xr dnamp
        LEA                 #store zero chars in last word} zer -(xr)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        SUB                 #decrement length} dca wa
        SUB                 #point back to start of block} sub wa xr
        MOV  DWORD PTR [],offset b_scl #set type word} mov =b_scl (xr)
        MOV  DWORD PTR (4*sclen)[] #store length in chars} mov wc sclen(xr)
        RET                 #return to alocs caller} exi
#
#      come here if string is too long
#
alcs2:  CALL ERR_0          #} erb 205 string length exceeds value of maxlngth keyword
        .byte 205
                            #end procedure alocs} enp
                            #} ejc
        .eject
#
#      alost -- allocate space in static region
#
#      (wa)                  length required in bytes
#      jsr  alost            call to allocate space
#      (xr)                  pointer to allocated block
#      (wb)                  destroyed
#
#      note that the coding ensures that the resulting value
#      of state is always less than dnamb. this fact is used
#      in testing a variable name for being in the static region
#
alost:                      #entry point} prc e 0
        .global alost
#
#      merge back here after allocating new chunk
#
alst1:  MOV                 #point to current end of area} mov state xr
        ADD                 #point beyond proposed block} aov wa xr alst2
        JC   alst2
        CMP                 #jump if overlap with dynamic area} bge xr dnamb alst2
             alst2
        MOV  DWORD PTR state #else store new pointer} mov xr state
        SUB                 #point back to start of block} sub wa xr
        RET                 #return to alost caller} exi
#
#      here if no room, prepare to move dynamic storage up
#
alst2:  MOV  DWORD PTR alsta #save wa} mov wa alsta
        CMP                 #skip if requested chunk is large} bge wa *e_sts alst3
             alst3
        MOV                 #else set to get large enough chunk} mov *e_sts wa
#
#      here with amount to move up in wa
#
alst3:  CALL alloc          #allocate block to ensure room} jsr alloc
        MOV  DWORD PTR dnamp #and delete it} mov xr dnamp
        MOV                 #copy move up amount} mov wa wb
        CALL gbcol          #call gbcol to move dynamic area up} jsr gbcol
        MOV  DWORD PTR dnams #remember new sediment size} mov xr dnams
        MOV                 #restore wa} mov alsta wa
        JMP  alst1          #loop back to try again} brn alst1
                            #end procedure alost} enp
                            #} ejc
        .eject
#
#      arith -- fetch arithmetic operands
#
#      arith is used by functions and operators which expect
#      two numeric arguments (operands) which must both be
#      integer or both be real. arith fetches two arguments from
#      the stack and performs any necessary conversions.
#
#      1(xs)                 first argument (left operand)
#      0(xs)                 second argument (right operand)
#      jsr  arith            call to fetch numeric arguments
#      ppm  loc              transfer loc for opnd 1 non-numeric
#      ppm  loc              transfer loc for opnd 2 non-numeric
#      ppm  loc              transfer loc for real operands
#
#      for integer args, control returns past the parameters
#
#      (ia)                  left operand value
#      (xr)                  ptr to icblk for left operand
#      (xl)                  ptr to icblk for right operand
#      (xs)                  popped twice
#      (wa,wb,ra)            destroyed
#
#      for real arguments, control returns to the location
#      specified by the third parameter.
#
#      (ra)                  left operand value
#      (xr)                  ptr to rcblk for left operand
#      (xl)                  ptr to rcblk for right operand
#      (wa,wb,wc)            destroyed
#      (xs)                  popped twice
                            #} ejc
        .eject
#
#      arith (continued)
#
#      entry point
#
arith:                      #entry point} prc n 3
        .global arith
        POP  PRC_+4
        MOV                 #load right operand} mov (xs)+ xl
        LEA
        MOV                 #load left operand} mov (xs)+ xr
        LEA
        MOV                 #get right operand type word} mov (xl) wa
        CMP                 #jump if integer} beq wa =b_icl arth1
             arth1
        CMP                 #jump if real} beq wa =b_rcl arth4
             arth4
        LEA                 #else replace left arg on stack} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #copy left arg pointer} mov xl xr
        CALL gtnum          #convert to numeric} jsr gtnum
        .short arth6-DFFNC  #jump if unconvertible} ppm arth6
        MOV                 #else copy converted result} mov xr xl
        MOV                 #get right operand type word} mov (xl) wa
        MOV                 #reload left argument} mov (xs)+ xr
        LEA
        CMP                 #jump if right arg is real} beq wa =b_rcl arth4
             arth4
#
#      here if right arg is an integer
#
arth1:  CMP  DWORD PTR [],offset b_icl #jump if left arg not integer} bne (xr) =b_icl arth3
             arth3
#
#      exit for integer case
#
arth2:  MOV  EDX,DWORD PTR (4*icval)[] #load left operand value} ldi icval(xr)
        POP  EAX            #return to arith caller} exi
        LEA  EAX,[EAX+6]
        JMP  EAX
#
#      here for right operand integer, left operand not
#
arth3:  CALL gtnum          #convert left arg to numeric} jsr gtnum
        .short arth7-DFFNC  #jump if not convertible} ppm arth7
        CMP                 #jump back if integer-integer} beq wa =b_icl arth2
             arth2
#
#      here we must convert real-integer to real-real
#
        LEA                 #put left arg back on stack} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  EDX,DWORD PTR (4*icval)[] #load right argument value} ldi icval(xl)
        CALL ITR_           #convert to real} itr
        CALL rcbld          #get real block for right arg, merge} jsr rcbld
        MOV                 #copy right arg ptr} mov xr xl
        MOV                 #load left argument} mov (xs)+ xr
        LEA
        JMP  arth5          #merge for real-real case} brn arth5
                            #} ejc
        .eject
#
#      arith (continued)
#
#      here if right argument is real
#
arth4:  CMP  DWORD PTR [],offset b_rcl #jump if left arg real} beq (xr) =b_rcl arth5
             arth5
        CALL gtrea          #else convert to real} jsr gtrea
        .short arth7-DFFNC  #error if unconvertible} ppm arth7
#
#      here for real-real
#
arth5:  LEA  EAX,DWORD PTR (4*rcval)[] #load left operand value} ldr rcval(xr)
        CALL ldr_
        POP  EAX            #take real-real exit} exi 3
        JMP  EXI__3
#
#      here for error converting right argument
#
arth6:  ADD                 #pop unwanted left arg} ica xs
        POP  EAX            #take appropriate error exit} exi 2
        JMP  EXI__2
#
#      here for error converting left operand
#
arth7:  POP  EAX            #take appropriate error return} exi 1
        JMP  EXI__1
                            #end procedure arith} enp
                            #} ejc
        .eject
#
#      asign -- perform assignment
#
#      asign performs the assignment of a value to a variable
#      with appropriate checks for output associations and
#      value trace associations which are executed as required.
#      asign also handles the special cases of assignment to
#      pattern and expression variables.
#
#      (wb)                  value to be assigned
#      (xl)                  base pointer for variable
#      (wa)                  offset for variable
#      jsr  asign            call to assign value to variable
#      ppm  loc              transfer loc for failure
#      (xr,xl,wa,wb,wc)      destroyed
#      (ra)                  destroyed
#
#      failure occurs if the evaluation of an expression
#      associated with an expression variable fails.
#
asign:                      #entry point (recursive)} prc r 1
        .global asign
#
#      merge back here to assign result to expression variable.
#
asg01:  ADD                 #point to variable value} add wa xl
        MOV                 #load variable value} mov (xl) xr
        CMP  DWORD PTR [],offset b_trt #jump if trapped} beq (xr) =b_trt asg02
             asg02
        MOV  DWORD PTR []   #else perform assignment} mov wb (xl)
        XOR                 #clear garbage value in xl} zer xl
        POP  EAX            #and return to asign caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here if value is trapped
#
asg02:  SUB                 #restore name base} sub wa xl
        CMP                 #jump if keyword variable} beq xr =trbkv asg14
             asg14
        CMP                 #jump if not expression variable} bne xr =trbev asg04
             asg04
#
#      here for assignment to expression variable
#
        MOV                 #point to expression} mov evexp(xl) xr
        LEA                 #store value to assign on stack} mov wb -(xs)
        MOV  DWORD PTR []
        MOV                 #set for evaluation by name} mov =num01 wb
        CALL evalx          #evaluate expression by name} jsr evalx
        .short asg03-DFFNC  #jump if evaluation fails} ppm asg03
        MOV                 #else reload value to assign} mov (xs)+ wb
        LEA
        JMP  asg01          #loop back to perform assignment} brn asg01
                            #} ejc
        .eject
#
#      asign (continued)
#
#      here for failure during expression evaluation
#
asg03:  ADD                 #remove stacked value entry} ica xs
        POP  EAX            #take failure exit} exi 1
        JMP  EXI__1
#
#      here if not keyword or expression variable
#
asg04:  LEA                 #save ptr to first trblk} mov xr -(xs)
        MOV  DWORD PTR []
#
#      loop to chase down trblk chain and assign value at end
#
asg05:  MOV                 #save ptr to this trblk} mov xr wc
        MOV                 #point to next trblk} mov trnxt(xr) xr
        CMP  DWORD PTR [],offset b_trt #loop back if another trblk} beq (xr) =b_trt asg05
             asg05
        MOV                 #else point back to last trblk} mov wc xr
        MOV  DWORD PTR (4*trval)[] #store value at end of chain} mov wb trval(xr)
        MOV                 #restore ptr to first trblk} mov (xs)+ xr
        LEA
#
#      loop to process trblk entries on chain
#
asg06:  MOV                 #load type code of trblk} mov trtyp(xr) wb
        CMP                 #jump if value trace} beq wb =trtvl asg08
             asg08
        CMP                 #jump if output association} beq wb =trtou asg10
             asg10
#
#      here to move to next trblk on chain
#
asg07:  MOV                 #point to next trblk on chain} mov trnxt(xr) xr
        CMP  DWORD PTR [],offset b_trt #loop back if another trblk} beq (xr) =b_trt asg06
             asg06
        POP  EAX            #else end of chain, return to caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here to process value trace
#
asg08:  CMP  DWORD PTR DWORD PTR kvtra,0 #ignore value trace if trace off} bze kvtra asg07
        JZ   asg07
        DEC  DWORD PTR kvtra #else decrement trace count} dcv kvtra
        CMP  DWORD PTR DWORD PTR (4*trfnc)[],0 #jump if print trace} bze trfnc(xr) asg09
        JZ   asg09
        CALL trxeq          #else execute function trace} jsr trxeq
        JMP  asg07          #and loop back} brn asg07
                            #} ejc
        .eject
#
#      asign (continued)
#
#      here for print trace
#
asg09:  CALL prtsn          #print statement number} jsr prtsn
        CALL prtnv          #print name = value} jsr prtnv
        JMP  asg07          #loop back for next trblk} brn asg07
#
#      here for output association
#
asg10:  CMP  DWORD PTR DWORD PTR kvoup,0 #ignore output assoc if output off} bze kvoup asg07
        JZ   asg07
asg1b:  MOV                 #copy trblk pointer} mov xr xl
        MOV                 #point to next trblk} mov trnxt(xr) xr
        CMP  DWORD PTR [],offset b_trt #loop back if another trblk} beq (xr) =b_trt asg1b
             asg1b
        MOV                 #else point back to last trblk} mov xl xr
        LEA                 #stack value to output} mov trval(xr) -(xs)
        MOV  EAX,DWORD PTR (4*trval)[]
        MOV  DWORD PTR [],EAX
        CALL gtstg          #convert to string} jsr gtstg
        .short asg12-DFFNC  #get datatype name if unconvertible} ppm asg12
#
#      merge with string or buffer to output in xr
#
asg11:  MOV                 #fcblk ptr} mov trfpt(xl) wa
        OR                  #jump if standard output file} bze wa asg13
        JZ   asg13
#
#      here for output to file
#
asg1a:  CALL sysou          #call system output routine} jsr sysou
        .short ERR_-206-DFFNC #} err 206 output caused file overflow
        .short ERR_-207-DFFNC #} err 207 output caused non-recoverable error
        POP  EAX            #else all done, return to caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      if not printable, get datatype name instead
#
asg12:  CALL dtype          #call datatype routine} jsr dtype
        JMP  asg11          #merge} brn asg11
#
#      here to print a string to standard output or terminal
#
asg13:  CMP  DWORD PTR (4*trter)[],offset v_ter #jump if terminal output} beq trter(xl) =v_ter asg1a
             asg1a
        INC                 #signal standard output} icv wa
        JMP  asg1a          #use sysou to perform output} brn asg1a
                            #} ejc
        .eject
#
#      asign (continued)
#
#      here for keyword assignment
#
asg14:  MOV                 #load keyword number} mov kvnum(xl) xl
        CMP                 #jump if errtext} beq xl =k_etx asg19
             asg19
        MOV                 #copy value to be assigned} mov wb xr
        CALL gtint          #convert to integer} jsr gtint
        .short ERR_-208-DFFNC #} err 208 keyword value assigned is not integer
        MOV  EDX,DWORD PTR (4*icval)[] #else load value} ldi icval(xr)
        CMP                 #jump if special case of stlimit} beq xl =k_stl asg16
             asg16
        OR   EDX,EDX        #else get addr integer, test ovflow} mfi wa asg18
        JS   asg18
        MOV
        CMP                 #fail if too large} bgt wa mxlen asg18
             asg18
        CMP                 #jump if special case of errtype} beq xl =k_ert asg17
             asg17
        CMP                 #jump if special case of profile} beq xl =k_pfl asg21
             asg21
        CMP                 #jump if special case of maxlngth} beq xl =k_mxl asg24
             asg24
        CMP                 #jump if special case of fullscan} beq xl =k_fls asg26
             asg26
        CMP                 #jump unless protected} blt xl =k_p__ asg15
             asg15
        CALL ERR_0          #} erb 209 keyword in assignment is protected
        .byte 209
#
#      here to do assignment if not protected
#
asg15:  MOV  kvabe[]        #store new value} mov wa kvabe(xl)
        POP  EAX            #return to asign caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here for special case of stlimit
#
#      since stcount is maintained as (stlimit-stcount)
#      it is also necessary to modify stcount appropriately.
#
asg16:  SUB  EDX,DWORD PTR kvstl #subtract old limit} sbi kvstl
        ADD  EDX,DWORD PTR kvstc #add old counter} adi kvstc
        MOV  DWORD PTR kvstc,EDX #store course counter value} sti kvstc
        MOV  EDX,DWORD PTR kvstl #check if counting suppressed} ldi kvstl
        OR   EDX,EDX        #do not refine if so} ilt asg25
        JL   asg25
        MOV                 #refine with counter breakout} mov stmcs wa
        SUB                 #values} sub stmct wa
        MOV  EDX            #convert to integer} mti wa
        NEG  EDX            #current-start value} ngi
        ADD  EDX,DWORD PTR kvstc #add in course counter value} adi kvstc
        MOV  DWORD PTR kvstc,EDX #save refined value} sti kvstc
asg25:  MOV  EDX,DWORD PTR (4*icval)[] #reload new limit value} ldi icval(xr)
        MOV  DWORD PTR kvstl,EDX #store new limit value} sti kvstl
        CALL stgcc          #recompute countdown counters} jsr stgcc
        POP  EAX            #return to asign caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here for special case of errtype
#
asg17:  CMP                 #ok to signal if in range} ble wa =nini9 error
             error
#
#      here if value assigned is out of range
#
asg18:  CALL ERR_0          #} erb 210 keyword value assigned is negative or too large
        .byte 210
#
#      here for special case of errtext
#
asg19:  LEA                 #stack value} mov wb -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert to string} jsr gtstg
        .short ERR_-211-DFFNC #} err 211 value assigned to keyword errtext not a string
        MOV  DWORD PTR r_etx #make assignment} mov xr r_etx
        POP  EAX            #return to caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here for keyword profile
#
asg21:  CMP                 #moan if not 0,1, or 2} bgt wa =num02 asg18
             asg18
        OR                  #just assign if zero} bze wa asg15
        JZ   asg15
        CMP  DWORD PTR DWORD PTR pfdmp,0 #branch if first assignment} bze pfdmp asg22
        JZ   asg22
        CMP                 #also if same value as before} beq wa pfdmp asg23
             asg23
        CALL ERR_1          #} erb 268 inconsistent value assigned to keyword profile
        .byte 12
#
asg22:  MOV  DWORD PTR pfdmp #note value on first assignment} mov wa pfdmp
asg23:  MOV  DWORD PTR kvpfl #store new value} mov wa kvpfl
        CALL stgcc          #recompute countdown counts} jsr stgcc
        CALL systm          #get the time} jsr systm
        MOV  DWORD PTR pfstm,EDX #fudge some kind of start time} sti pfstm
        POP  EAX            #return to asign caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here for keyword maxlngth
#
asg24:  CMP                 #if acceptable value} bge wa =mnlen asg15
             asg15
        CALL ERR_1          #} erb 287 value assigned to keyword maxlngth is too small
        .byte 31
#
#      here for keyword fullscan
#
asg26:  OR                  #if acceptable value} bnz wa asg15
        JNZ  asg15
        CALL ERR_1          #} erb 274 value assigned to keyword fullscan is zero
        .byte 18
#
                            #end procedure asign} enp
                            #} ejc
        .eject
#
#      asinp -- assign during pattern match
#
#      asinp is like asign and has a similar calling sequence
#      and effect. the difference is that the global pattern
#      variables are saved and restored if required.
#
#      (xl)                  base pointer for variable
#      (wa)                  offset for variable
#      (wb)                  value to be assigned
#      jsr  asinp            call to assign value to variable
#      ppm  loc              transfer loc if failure
#      (xr,xl)               destroyed
#      (wa,wb,wc,ra)         destroyed
#
asinp:                      #entry point, recursive} prc r 1
        .global asinp
        ADD                 #point to variable} add wa xl
        MOV                 #load current contents} mov (xl) xr
        CMP  DWORD PTR [],offset b_trt #jump if trapped} beq (xr) =b_trt asnp1
             asnp1
        MOV  DWORD PTR []   #else perform assignment} mov wb (xl)
        XOR                 #clear garbage value in xl} zer xl
        POP  EAX            #return to asinp caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here if variable is trapped
#
asnp1:  SUB                 #restore base pointer} sub wa xl
        LEA                 #stack subject string length} mov pmssl -(xs)
        MOV  EAX,DWORD PTR pmssl
        MOV  DWORD PTR [],EAX
        LEA                 #stack history stack base ptr} mov pmhbs -(xs)
        MOV  EAX,DWORD PTR pmhbs
        MOV  DWORD PTR [],EAX
        LEA                 #stack subject string pointer} mov r_pms -(xs)
        MOV  EAX,DWORD PTR r_pms
        MOV  DWORD PTR [],EAX
        LEA                 #stack dot flag} mov pmdfl -(xs)
        MOV  EAX,DWORD PTR pmdfl
        MOV  DWORD PTR [],EAX
        CALL asign          #call full-blown assignment routine} jsr asign
        .short asnp2-DFFNC  #jump if failure} ppm asnp2
        MOV  EAX,DWORD PTR [] #restore dot flag} mov (xs)+ pmdfl
        MOV  DWORD PTR pmdfl,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string pointer} mov (xs)+ r_pms
        MOV  DWORD PTR r_pms,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore history stack base pointer} mov (xs)+ pmhbs
        MOV  DWORD PTR pmhbs,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string length} mov (xs)+ pmssl
        MOV  DWORD PTR pmssl,EAX
        LEA
        POP  EAX            #return to asinp caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here if failure in asign call
#
asnp2:  MOV  EAX,DWORD PTR [] #restore dot flag} mov (xs)+ pmdfl
        MOV  DWORD PTR pmdfl,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string pointer} mov (xs)+ r_pms
        MOV  DWORD PTR r_pms,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore history stack base pointer} mov (xs)+ pmhbs
        MOV  DWORD PTR pmhbs,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string length} mov (xs)+ pmssl
        MOV  DWORD PTR pmssl,EAX
        LEA
        POP  EAX            #take failure exit} exi 1
        JMP  EXI__1
                            #end procedure asinp} enp
                            #} ejc
        .eject
#
#      blkln -- determine length of block
#
#      blkln determines the length of a block in dynamic store.
#
#      (wa)                  first word of block
#      (xr)                  pointer to block
#      jsr  blkln            call to get block length
#      (wa)                  length of block in bytes
#      (xl)                  destroyed
#
#      blkln is used by the garbage collector and is not
#      permitted to call gbcol directly or indirectly.
#
#      the first word stored in the block (i.e. at xr) may
#      be anything, but the contents of wa must be correct.
#
blkln:                      #entry point} prc e 0
        .global blkln
        MOV                 #copy first word} mov wa xl
        MOVZX               #get entry id (bl_xx)} lei xl
        CMP                 #switch on block type} bsw xl bl___ bln00
        JGE  bln00
        JMP  DWORD PTR L0006[*4]
        DSeg_
L0006:
        .long bln01         #arblk} iff bl_ar bln01
        .long bln12         #cdblk} iff bl_cd bln12
        .long bln12         #exblk} iff bl_ex bln12
        .long bln07         #icblk} iff bl_ic bln07
        .long bln03         #nmblk} iff bl_nm bln03
        .long bln02         #p0blk} iff bl_p0 bln02
        .long bln03         #p1blk} iff bl_p1 bln03
        .long bln04         #p2blk} iff bl_p2 bln04
        .long bln09         #rcblk} iff bl_rc bln09
        .long bln10         #scblk} iff bl_sc bln10
        .long bln02         #seblk} iff bl_se bln02
        .long bln01         #tbblk} iff bl_tb bln01
        .long bln01         #vcblk} iff bl_vc bln01
        .long bln00         #} iff 13 bln00
        .long bln00         #} iff 14 bln00
        .long bln00         #} iff 15 bln00
        .long bln08         #pdblk} iff bl_pd bln08
        .long bln05         #trblk} iff bl_tr bln05
        .long bln00         #} iff 18 bln00
        .long bln00         #} iff 19 bln00
        .long bln00         #} iff 20 bln00
        .long bln06         #ctblk} iff bl_ct bln06
        .long bln01         #dfblk} iff bl_df bln01
        .long bln01         #efblk} iff bl_ef bln01
        .long bln03         #evblk} iff bl_ev bln03
        .long bln05         #ffblk} iff bl_ff bln05
        .long bln03         #kvblk} iff bl_kv bln03
        .long bln01         #pfblk} iff bl_pf bln01
        .long bln04         #teblk} iff bl_te bln04
        DSegEnd_            #end of jump table on block type} esw
        CSeg_
                            #} ejc
        .eject
#
#      blkln (continued)
#
#      here for blocks with length in second word
#
bln00:  MOV                 #load length} mov num01(xr) wa
        RET                 #return to blkln caller} exi
#
#      here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)
#
bln01:  MOV                 #load length from third word} mov num02(xr) wa
        RET                 #return to blkln caller} exi
#
#      here for two word blocks (p0,se)
#
bln02:  MOV                 #load length (two words)} mov *num02 wa
        RET                 #return to blkln caller} exi
#
#      here for three word blocks (nm,p1,ev,kv)
#
bln03:  MOV                 #load length (three words)} mov *num03 wa
        RET                 #return to blkln caller} exi
#
#      here for four word blocks (p2,te,bc)
#
bln04:  MOV                 #load length (four words)} mov *num04 wa
        RET                 #return to blkln caller} exi
#
#      here for five word blocks (ff,tr)
#
bln05:  MOV                 #load length} mov *num05 wa
        RET                 #return to blkln caller} exi
                            #} ejc
        .eject
#
#      blkln (continued)
#
#      here for ctblk
#
bln06:  MOV                 #set size of ctblk} mov *ctsi_ wa
        RET                 #return to blkln caller} exi
#
#      here for icblk
#
bln07:  MOV                 #set size of icblk} mov *icsi_ wa
        RET                 #return to blkln caller} exi
#
#      here for pdblk
#
bln08:  MOV                 #point to dfblk} mov pddfp(xr) xl
        MOV                 #load pdblk length from dfblk} mov dfpdl(xl) wa
        RET                 #return to blkln caller} exi
#
#      here for rcblk
#
bln09:  MOV                 #set size of rcblk} mov *rcsi_ wa
        RET                 #return to blkln caller} exi
#
#      here for scblk
#
bln10:  MOV                 #load length in characters} mov sclen(xr) wa
        ADD                 #calculate length in bytes} ctb wa scsi_
        AND
        RET                 #return to blkln caller} exi
#
#      here for length in fourth word (cd,ex)
#
bln12:  MOV                 #load length from cdlen/exlen} mov num03(xr) wa
        RET                 #return to blkln caller} exi
                            #end procedure blkln} enp
                            #} ejc
        .eject
#
#      copyb -- copy a block
#
#      (xs)                  block to be copied
#      jsr  copyb            call to copy block
#      ppm  loc              return if block has no idval field
#                            normal return if idval field
#      (xr)                  copy of block
#      (xs)                  popped
#      (xl,wa,wb,wc)         destroyed
#
copyb:                      #entry point} prc n 1
        .global copyb
        POP  PRC_+8
        MOV                 #load argument} mov (xs) xr
        CMP                 #return argument if it is null} beq xr =nulls cop10
             cop10
        MOV                 #else load type word} mov (xr) wa
        MOV                 #copy type word} mov wa wb
        CALL blkln          #get length of argument block} jsr blkln
        MOV                 #copy pointer} mov xr xl
        CALL alloc          #allocate block of same size} jsr alloc
        MOV  DWORD PTR []   #store pointer to copy} mov xr (xs)
        SHR  ECX,2          #copy contents of old block to new} mvw
        REP  MOVSD
        XOR                 #clear garbage xl} zer xl
        MOV                 #reload pointer to start of copy} mov (xs) xr
        CMP                 #jump if table} beq wb =b_tbt cop05
             cop05
        CMP                 #jump if vector} beq wb =b_vct cop01
             cop01
        CMP                 #jump if program defined} beq wb =b_pdt cop01
             cop01
        CMP                 #return copy if not array} bne wb =b_art cop10
             cop10
#
#      here for array (arblk)
#
        ADD                 #point to prototype field} add arofs(xr) xr
        JMP  cop02          #jump to merge} brn cop02
#
#      here for vector, program defined
#
cop01:  ADD                 #point to pdfld = vcvls} add *pdfld xr
#
#      merge here for arblk, vcblk, pdblk to delete trap
#      blocks from all value fields (the copy is untrapped)
#
cop02:  MOV                 #load next pointer} mov (xr) xl
#
#      loop to get value at end of trblk chain
#
cop03:  CMP  DWORD PTR [],offset b_trt #jump if not trapped} bne (xl) =b_trt cop04
             cop04
        MOV                 #else point to next value} mov trval(xl) xl
        JMP  cop03          #and loop back} brn cop03
                            #} ejc
        .eject
#
#      copyb (continued)
#
#      here with untrapped value in xl
#
cop04:  MOV  DWORD PTR []   #store real value, bump pointer} mov xl (xr)+
        LEA
        CMP                 #loop back if more to go} bne xr dnamp cop02
             cop02
        JMP  cop09          #else jump to exit} brn cop09
#
#      here to copy a table
#
cop05:  XOR  EAX,EAX        #zero id to stop dump blowing up} zer idval(xr)
        MOV  DWORD PTR (4*idval)[],EAX
        MOV                 #set size of teblk} mov *tesi_ wa
        MOV                 #set initial offset} mov *tbbuk wc
#
#      loop through buckets in table
#
cop06:  MOV                 #load table pointer} mov (xs) xr
        CMP                 #jump to exit if all done} beq wc tblen(xr) cop09
             cop09
        MOV                 #else copy offset} mov wc wb
        SUB                 #subtract link offset to merge} sub *tenxt wb
        ADD                 #next bucket header less link offset} add wb xr
        ADD                 #bump offset} ica wc
#
#      loop through teblks on one chain
#
cop07:  MOV                 #load pointer to next teblk} mov tenxt(xr) xl
        MOV  EAX,DWORD PTR [] #set end of chain pointer in case} mov (xs) tenxt(xr)
        MOV  DWORD PTR (4*tenxt)[],EAX
        CMP  DWORD PTR [],offset b_tbt #back for next bucket if chain end} beq (xl) =b_tbt cop06
             cop06
        SUB                 #point to head of previous block} sub wb xr
        LEA                 #stack ptr to previous block} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #set size of teblk} mov *tesi_ wa
        CALL alloc          #allocate new teblk} jsr alloc
        LEA                 #stack ptr to new teblk} mov xr -(xs)
        MOV  DWORD PTR []
        SHR  ECX,2          #copy old teblk to new teblk} mvw
        REP  MOVSD
        MOV                 #restore pointer to new teblk} mov (xs)+ xr
        LEA
        MOV                 #restore pointer to previous block} mov (xs)+ xl
        LEA
        ADD                 #add offset back in} add wb xl
        MOV  DWORD PTR (4*tenxt)[] #link new block to previous} mov xr tenxt(xl)
        MOV                 #copy pointer to new block} mov xr xl
#
#      loop to set real value after removing trap chain
#
cop08:  MOV                 #load value} mov teval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop back if trapped} beq (xl) =b_trt cop08
             cop08
        MOV  DWORD PTR (4*teval)[] #store untrapped value in teblk} mov xl teval(xr)
        XOR                 #zero offset within teblk} zer wb
        JMP  cop07          #back for next teblk} brn cop07
#
#      common exit point
#
cop09:  MOV                 #load pointer to block} mov (xs)+ xr
        LEA
        POP  EAX            #return} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      alternative return
#
cop10:  POP  EAX            #return} exi 1
        JMP  EXI__1
                            #} ejc
        .eject
                            #end procedure copyb} enp
#
#      cdgcg -- generate code for complex goto
#
#      used by cmpil to process complex goto tree
#
#      (wb)                  must be collectable
#      (xr)                  expression pointer
#      jsr  cdgcg            call to generate complex goto
#      (xl,xr,wa)            destroyed
#
cdgcg:                      #entry point} prc e 0
        .global cdgcg
        MOV                 #get unary goto operator} mov cmopn(xr) xl
        MOV                 #point to goto operand} mov cmrop(xr) xr
        CMP                 #jump if direct goto} beq xl =opdvd cdgc2
             cdgc2
        CALL cdgnm          #generate opnd by name if not direct} jsr cdgnm
#
#      return point
#
cdgc1:  MOV                 #goto operator} mov xl wa
        CALL cdwrd          #generate it} jsr cdwrd
        RET                 #return to caller} exi
#
#      direct goto
#
cdgc2:  CALL cdgvl          #generate operand by value} jsr cdgvl
        JMP  cdgc1          #merge to return} brn cdgc1
                            #end procedure cdgcg} enp
                            #} ejc
        .eject
#
#      cdgex -- build expression block
#
#      cdgex is passed a pointer to an expression tree (see
#      expan) and returns an expression (seblk or exblk).
#
#      (wa)                  0 if by value, 1 if by name
#      (wc)                  some collectable value
#      (wb)                  integer in range 0 le x le mxlen
#      (xl)                  ptr to expression tree
#      jsr  cdgex            call to build expression
#      (xr)                  ptr to seblk or exblk
#      (xl,wa,wb)            destroyed
#
cdgex:                      #entry point, recursive} prc r 0
        .global cdgex
        CMP  DWORD PTR [],offset b_vr_ #jump if not variable} blo (xl) =b_vr_ cdgx1
             cdgx1
#
#      here for natural variable, build seblk
#
        MOV                 #set size of seblk} mov *sesi_ wa
        CALL alloc          #allocate space for seblk} jsr alloc
        MOV  DWORD PTR [],offset b_sel #set type word} mov =b_sel (xr)
        MOV  DWORD PTR (4*sevar)[] #store vrblk pointer} mov xl sevar(xr)
        RET                 #return to cdgex caller} exi
#
#      here if not variable, build exblk
#
cdgx1:  MOV                 #copy tree pointer} mov xl xr
        LEA                 #save wc} mov wc -(xs)
        MOV  DWORD PTR []
        MOV                 #save current offset} mov cwcof xl
        OR                  #jump if by value} bze wa cdgx2
        JZ   cdgx2
        MOV                 #get type word} mov (xr) wa
        CMP                 #call by value if not cmblk} bne wa =b_cmt cdgx2
             cdgx2
        CMP  DWORD PTR (4*cmtyp)[],c__nm #jump if cmblk only by value} bge cmtyp(xr) =c__nm cdgx2
             cdgx2
                            #} ejc
        .eject
#
#      cdgex (continued)
#
#      here if expression can be evaluated by name
#
        CALL cdgnm          #generate code by name} jsr cdgnm
        MOV                 #load return by name word} mov =ornm_ wa
        JMP  cdgx3          #merge with value case} brn cdgx3
#
#      here if expression can only be evaluated by value
#
cdgx2:  CALL cdgvl          #generate code by value} jsr cdgvl
        MOV                 #load return by value word} mov =orvl_ wa
#
#      merge here to construct exblk
#
cdgx3:  CALL cdwrd          #generate return word} jsr cdwrd
        CALL exbld          #build exblk} jsr exbld
        MOV                 #restore wc} mov (xs)+ wc
        LEA
        RET                 #return to cdgex caller} exi
                            #end procedure cdgex} enp
                            #} ejc
        .eject
#
#      cdgnm -- generate code by name
#
#      cdgnm is called during the compilation process to
#      generate code by name for an expression. see cdblk
#      description for details of code generated. the input
#      to cdgnm is an expression tree as generated by expan.
#
#      cdgnm is a recursive procedure which proceeds by making
#      recursive calls to generate code for operands.
#
#      (wb)                  integer in range 0 le n le dnamb
#      (xr)                  ptr to tree generated by expan
#      (wc)                  constant flag (see below)
#      jsr  cdgnm            call to generate code by name
#      (xr,wa)               destroyed
#      (wc)                  set non-zero if non-constant
#
#      wc is set to a non-zero (collectable) value if the
#      expression for which code is generated cannot be
#      evaluated at compile time, otherwise wc is unchanged.
#
#      the code is generated in the current ccblk (see cdwrd).
#
cdgnm:                      #entry point, recursive} prc r 0
        .global cdgnm
        LEA                 #save entry xl} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #save entry wb} mov wb -(xs)
        MOV  DWORD PTR []
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        MOV                 #load type word} mov (xr) wa
        CMP                 #jump if cmblk} beq wa =b_cmt cgn04
             cgn04
        CMP                 #jump if simple variable} bhi wa =b_vr_ cgn02
             cgn02
#
#      merge here for operand yielding value (e.g. constant)
#
cgn01:  CALL ERR_0          #} erb 212 syntax error: value used where name is required
        .byte 212
#
#      here for natural variable reference
#
cgn02:  MOV                 #load variable load call} mov =olvn_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #copy vrblk pointer} mov xr wa
        CALL cdwrd          #generate vrblk pointer} jsr cdwrd
                            #} ejc
        .eject
#
#      cdgnm (continued)
#
#      here to exit with wc set correctly
#
cgn03:  MOV                 #restore entry wb} mov (xs)+ wb
        LEA
        MOV                 #restore entry xl} mov (xs)+ xl
        LEA
        RET                 #return to cdgnm caller} exi
#
#      here for cmblk
#
cgn04:  MOV                 #copy cmblk pointer} mov xr xl
        MOV                 #load cmblk type} mov cmtyp(xr) xr
        CMP                 #error if not name operand} bge xr =c__nm cgn01
             cgn01
        JMP  DWORD PTR L0007[*4] #else switch on type} bsw xr c__nm
        DSeg_
L0007:
        .long cgn05         #array reference} iff c_arr cgn05
        .long cgn08         #function call} iff c_fnc cgn08
        .long cgn09         #deferred expression} iff c_def cgn09
        .long cgn10         #indirect reference} iff c_ind cgn10
        .long cgn11         #keyword reference} iff c_key cgn11
        .long cgn08         #undefined binary op} iff c_ubo cgn08
        .long cgn08         #undefined unary op} iff c_uuo cgn08
        DSegEnd_            #end switch on cmblk type} esw
        CSeg_
#
#      here to generate code for array reference
#
cgn05:  MOV                 #point to array operand} mov *cmopn wb
#
#      loop to generate code for array operand and subscripts
#
cgn06:  CALL cmgen          #generate code for next operand} jsr cmgen
        MOV                 #load length of cmblk} mov cmlen(xl) wc
        CMP                 #loop till all generated} blt wb wc cgn06
             cgn06
#
#      generate appropriate array call
#
        MOV                 #load one-subscript case call} mov =oaon_ wa
        CMP                 #jump to exit if one subscript case} beq wc *cmar1 cgn07
             cgn07
        MOV                 #else load multi-subscript case call} mov =oamn_ wa
        CALL cdwrd          #generate call} jsr cdwrd
        MOV                 #copy cmblk length} mov wc wa
        SHR                 #convert to words} btw wa
        SUB                 #calculate number of subscripts} sub =cmvls wa
                            #} ejc
        .eject
#
#      cdgnm (continued)
#
#      here to exit generating word (non-constant)
#
cgn07:  MOV                 #set result non-constant} mnz wc
        CALL cdwrd          #generate word} jsr cdwrd
        JMP  cgn03          #back to exit} brn cgn03
#
#      here to generate code for functions and undefined oprs
#
cgn08:  MOV                 #copy cmblk pointer} mov xl xr
        CALL cdgvl          #gen code by value for call} jsr cdgvl
        MOV                 #get extra call for by name} mov =ofne_ wa
        JMP  cgn07          #back to generate and exit} brn cgn07
#
#      here to generate code for defered expression
#
cgn09:  MOV                 #check if variable} mov cmrop(xl) xr
        CMP  DWORD PTR [],offset b_vr_ #treat *variable as simple var} bhi (xr) =b_vr_ cgn02
             cgn02
        MOV                 #copy ptr to expression tree} mov xr xl
        MOV                 #return name} mov =num01 wa
        CALL cdgex          #else build exblk} jsr cdgex
        MOV                 #set call to load expr by name} mov =olex_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #copy exblk pointer} mov xr wa
        CALL cdwrd          #generate exblk pointer} jsr cdwrd
        JMP  cgn03          #back to exit} brn cgn03
#
#      here to generate code for indirect reference
#
cgn10:  MOV                 #get operand} mov cmrop(xl) xr
        CALL cdgvl          #generate code by value for it} jsr cdgvl
        MOV                 #load call for indirect by name} mov =oinn_ wa
        JMP  cgn12          #merge} brn cgn12
#
#      here to generate code for keyword reference
#
cgn11:  MOV                 #get operand} mov cmrop(xl) xr
        CALL cdgnm          #generate code by name for it} jsr cdgnm
        MOV                 #load call for keyword by name} mov =okwn_ wa
#
#      keyword, indirect merge here
#
cgn12:  CALL cdwrd          #generate code for operator} jsr cdwrd
        JMP  cgn03          #exit} brn cgn03
                            #end procedure cdgnm} enp
                            #} ejc
        .eject
#
#      cdgvl -- generate code by value
#
#      cdgvl is called during the compilation process to
#      generate code by value for an expression. see cdblk
#      description for details of the code generated. the input
#      to cdgvl is an expression tree as generated by expan.
#
#      cdgvl is a recursive procedure which proceeds by making
#      recursive calls to generate code for operands.
#
#      (wb)                  integer in range 0 le n le dnamb
#      (xr)                  ptr to tree generated by expan
#      (wc)                  constant flag (see below)
#      jsr  cdgvl            call to generate code by value
#      (xr,wa)               destroyed
#      (wc)                  set non-zero if non-constant
#
#      wc is set to a non-zero (collectable) value if the
#      expression for which code is generated cannot be
#      evaluated at compile time, otherwise wc is unchanged.
#
#      if wc is non-zero on entry, then preevaluation is not
#      allowed regardless of the nature of the operand.
#
#      the code is generated in the current ccblk (see cdwrd).
#
cdgvl:                      #entry point, recursive} prc r 0
        .global cdgvl
        MOV                 #load type word} mov (xr) wa
        CMP                 #jump if cmblk} beq wa =b_cmt cgv01
             cgv01
        CMP                 #jump if icblk, rcblk, scblk} blt wa =b_vra cgv00
             cgv00
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #jump if not system variable} bnz vrlen(xr) cgvl0
        JNZ  cgvl0
        LEA                 #stack xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #point to svblk} mov vrsvp(xr) xr
        MOV                 #get svblk property bits} mov svbit(xr) wa
        MOV                 #recover xr} mov (xs)+ xr
        LEA
        AND                 #check if constant keyword value} anb btkwv wa
        CMP                 #jump if constant keyword value} beq wa btkwv cgv00
             cgv00
#
#      here for variable value reference
#
cgvl0:  MOV                 #indicate non-constant value} mnz wc
#
#      merge here for simple constant (icblk,rcblk,scblk)
#      and for variables corresponding to constant keywords.
#
cgv00:  MOV                 #copy ptr to var or constant} mov xr wa
        CALL cdwrd          #generate as code word} jsr cdwrd
        RET                 #return to caller} exi
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here for tree node (cmblk)
#
cgv01:  LEA                 #save entry wb} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #save entry xl} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #save entry constant flag} mov wc -(xs)
        MOV  DWORD PTR []
        LEA                 #save initial code offset} mov cwcof -(xs)
        MOV  EAX,DWORD PTR cwcof
        MOV  DWORD PTR [],EAX
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
#
#      prepare to generate code for cmblk. wc is set to the
#      value of cswno (zero if -optimise, 1 if -noopt) to
#      start with and is reset non-zero for any non-constant
#      code generated. if it is still zero after generating all
#      the cmblk code, then its value is computed as the result.
#
        MOV                 #copy cmblk pointer} mov xr xl
        MOV                 #load cmblk type} mov cmtyp(xr) xr
        MOV                 #reset constant flag} mov cswno wc
        CMP                 #jump if not predicate value} ble xr =c_pr_ cgv02
             cgv02
        MOV                 #else force non-constant case} mnz wc
#
#      here with wc set appropriately
#
cgv02:  JMP  DWORD PTR L0008[*4] #switch to appropriate generator} bsw xr c__nv
        DSeg_
L0008:
        .long cgv03         #array reference} iff c_arr cgv03
        .long cgv05         #function call} iff c_fnc cgv05
        .long cgv14         #deferred expression} iff c_def cgv14
        .long cgv31         #indirect reference} iff c_ind cgv31
        .long cgv27         #keyword reference} iff c_key cgv27
        .long cgv29         #undefined binop} iff c_ubo cgv29
        .long cgv30         #undefined unop} iff c_uuo cgv30
        .long cgv18         #binops with val opds} iff c_bvl cgv18
        .long cgv19         #unops with valu opnd} iff c_uvl cgv19
        .long cgv18         #alternation} iff c_alt cgv18
        .long cgv24         #concatenation} iff c_cnc cgv24
        .long cgv24         #concatenation (not pattern match)} iff c_cnp cgv24
        .long cgv27         #unops with name opnd} iff c_unm cgv27
        .long cgv26         #binary _ and .} iff c_bvn cgv26
        .long cgv21         #assignment} iff c_ass cgv21
        .long cgv31         #interrogation} iff c_int cgv31
        .long cgv28         #negation} iff c_neg cgv28
        .long cgv15         #selection} iff c_sel cgv15
        .long cgv18         #pattern match} iff c_pmt cgv18
        DSegEnd_            #end switch on cmblk type} esw
        CSeg_
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here to generate code for array reference
#
cgv03:  MOV                 #set offset to array operand} mov *cmopn wb
#
#      loop to generate code for array operand and subscripts
#
cgv04:  CALL cmgen          #gen value code for next operand} jsr cmgen
        MOV                 #load cmblk length} mov cmlen(xl) wc
        CMP                 #loop back if more to go} blt wb wc cgv04
             cgv04
#
#      generate call to appropriate array reference routine
#
        MOV                 #set one subscript call in case} mov =oaov_ wa
        CMP                 #jump to exit if 1-sub case} beq wc *cmar1 cgv32
             cgv32
        MOV                 #else set call for multi-subscripts} mov =oamv_ wa
        CALL cdwrd          #generate call} jsr cdwrd
        MOV                 #copy length of cmblk} mov wc wa
        SUB                 #subtract standard length} sub *cmvls wa
        SHR                 #get number of words} btw wa
        JMP  cgv32          #jump to generate subscript count} brn cgv32
#
#      here to generate code for function call
#
cgv05:  MOV                 #set offset to first argument} mov *cmvls wb
#
#      loop to generate code for arguments
#
cgv06:  CMP                 #jump if all generated} beq wb cmlen(xl) cgv07
             cgv07
        CALL cmgen          #else gen value code for next arg} jsr cmgen
        JMP  cgv06          #back to generate next argument} brn cgv06
#
#      here to generate actual function call
#
cgv07:  SUB                 #get number of arg ptrs (bytes)} sub *cmvls wb
        SHR                 #convert bytes to words} btw wb
        MOV                 #load function vrblk pointer} mov cmopn(xl) xr
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #jump if not system function} bnz vrlen(xr) cgv12
        JNZ  cgv12
        MOV                 #load svblk ptr if system var} mov vrsvp(xr) xl
        MOV                 #load bit mask} mov svbit(xl) wa
        AND                 #test for fast function call allowed} anb btffc wa
#        OR                  #jump if not} zrb wa cgv12  (Optimized)
        JZ   cgv12
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here if fast function call is allowed
#
        MOV                 #reload bit indicators} mov svbit(xl) wa
        AND                 #test for preevaluation ok} anb btpre wa
#        OR                  #jump if preevaluation permitted} nzb wa cgv08  (Optimized)
        JNZ  cgv08
        MOV                 #else set result non-constant} mnz wc
#
#      test for correct number of args for fast call
#
cgv08:  MOV                 #load ptr to svfnc field} mov vrfnc(xr) xl
        MOV                 #load svnar field value} mov fargs(xl) wa
        CMP                 #jump if argument count is correct} beq wa wb cgv11
             cgv11
        CMP                 #jump if too few arguments given} bhi wa wb cgv09
             cgv09
#
#      here if too many arguments, prepare to generate o$pops
#
        SUB                 #get number of extra args} sub wa wb
        MOV                 #set pop call} mov =opop_ wa
        JMP  cgv10          #jump to common loop} brn cgv10
#
#      here if too few arguments, prepare to generate nulls
#
cgv09:  SUB                 #get number of missing arguments} sub wb wa
        MOV                 #load as count to control loop} lct wb wa
        MOV                 #load ptr to null constant} mov =nulls wa
#
#      loop to generate calls to fix argument count
#
cgv10:  CALL cdwrd          #generate one call} jsr cdwrd
        DEC                 #loop till all generated} bct wb cgv10
        JNZ  cgv10
#
#      here after adjusting arg count as required
#
cgv11:  MOV                 #copy pointer to svfnc field} mov xl wa
        JMP  cgv36          #jump to generate call} brn cgv36
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      come here if fast call is not permitted
#
cgv12:  MOV                 #set one arg call in case} mov =ofns_ wa
        CMP                 #jump if one arg case} beq wb =num01 cgv13
             cgv13
        MOV                 #else load call for more than 1 arg} mov =ofnc_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #copy argument count} mov wb wa
#
#      one arg case merges here
#
cgv13:  CALL cdwrd          #generate =o_fns or arg count} jsr cdwrd
        MOV                 #copy vrblk pointer} mov xr wa
        JMP  cgv32          #jump to generate vrblk ptr} brn cgv32
#
#      here for deferred expression
#
cgv14:  MOV                 #point to expression tree} mov cmrop(xl) xl
        XOR                 #return value} zer wa
        CALL cdgex          #build exblk or seblk} jsr cdgex
        MOV                 #copy block ptr} mov xr wa
        CALL cdwrd          #generate ptr to exblk or seblk} jsr cdwrd
        JMP  cgv34          #jump to exit, constant test} brn cgv34
#
#      here to generate code for selection
#
cgv15:  LEA                 #zero ptr to chain of forward jumps} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        LEA                 #zero ptr to prev o_slc forward ptr} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        MOV                 #point to first alternative} mov *cmvls wb
        MOV                 #set initial code word} mov =osla_ wa
#
#      0(xs)                 is the offset to the previous word
#                            which requires filling in with an
#                            offset to the following o$slc,o$sld
#
#      1(xs)                 is the head of a chain of offset
#                            pointers indicating those locations
#                            to be filled with offsets past
#                            the end of all the alternatives
#
cgv16:  CALL cdwrd          #generate o_slc (o_sla first time)} jsr cdwrd
        MOV  EAX,DWORD PTR cwcof #set current loc as ptr to fill in} mov cwcof (xs)
        MOV  DWORD PTR [],EAX
        CALL cdwrd          #generate garbage word there for now} jsr cdwrd
        CALL cmgen          #gen value code for alternative} jsr cmgen
        MOV                 #load o_slb pointer} mov =oslb_ wa
        CALL cdwrd          #generate o_slb call} jsr cdwrd
        MOV                 #load old chain ptr} mov num01(xs) wa
        MOV  EAX,DWORD PTR cwcof #set current loc as new chain head} mov cwcof num01(xs)
        MOV  DWORD PTR (4*num01)[],EAX
        CALL cdwrd          #generate forward chain link} jsr cdwrd
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      now to fill in the skip offset to o$slc,o$sld
#
        MOV                 #load offset to word to plug} mov (xs) xr
        ADD                 #point to actual location to plug} add r_ccb xr
        MOV  EAX,DWORD PTR cwcof #plug proper offset in} mov cwcof (xr)
        MOV  DWORD PTR [],EAX
        MOV                 #load o_slc ptr for next alternative} mov =oslc_ wa
        MOV                 #copy offset (destroy garbage xr)} mov wb xr
        ADD                 #bump extra time for test} ica xr
        CMP                 #loop back if not last alternative} blt xr cmlen(xl) cgv16
             cgv16
#
#      here to generate code for last alternative
#
        MOV                 #get header call} mov =osld_ wa
        CALL cdwrd          #generate o_sld call} jsr cdwrd
        CALL cmgen          #generate code for last alternative} jsr cmgen
        ADD                 #pop offset ptr} ica xs
        MOV                 #load chain ptr} mov (xs)+ xr
        LEA
#
#      loop to plug offsets past structure
#
cgv17:  ADD                 #make next ptr absolute} add r_ccb xr
        MOV                 #load forward ptr} mov (xr) wa
        MOV  EAX,DWORD PTR cwcof #plug required offset} mov cwcof (xr)
        MOV  DWORD PTR [],EAX
        MOV                 #copy forward ptr} mov wa xr
        OR                  #loop back if more to go} bnz wa cgv17
        JNZ  cgv17
        JMP  cgv33          #else jump to exit (not constant)} brn cgv33
#
#      here for binary ops with value operands
#
cgv18:  MOV                 #load left operand pointer} mov cmlop(xl) xr
        CALL cdgvl          #gen value code for left operand} jsr cdgvl
#
#      here for unary ops with value operand (binops merge)
#
cgv19:  MOV                 #load right (only) operand ptr} mov cmrop(xl) xr
        CALL cdgvl          #gen code by value} jsr cdgvl
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      merge here to generate operator call from cmopn field
#
cgv20:  MOV                 #load operator call pointer} mov cmopn(xl) wa
        JMP  cgv36          #jump to generate it with cons test} brn cgv36
#
#      here for assignment
#
cgv21:  MOV                 #load left operand pointer} mov cmlop(xl) xr
        CMP  DWORD PTR [],offset b_vr_ #jump if not variable} blo (xr) =b_vr_ cgv22
             cgv22
#
#      here for assignment to simple variable
#
        MOV                 #load right operand ptr} mov cmrop(xl) xr
        CALL cdgvl          #generate code by value} jsr cdgvl
        MOV                 #reload left operand vrblk ptr} mov cmlop(xl) wa
        ADD                 #point to vrsto field} add *vrsto wa
        JMP  cgv32          #jump to generate store ptr} brn cgv32
#
#      here if not simple variable assignment
#
cgv22:  CALL expap          #test for pattern match on left side} jsr expap
        .short cgv23-DFFNC  #jump if not pattern match} ppm cgv23
#
#      here for pattern replacement
#
        MOV  EAX,DWORD PTR (4*cmrop)[] #save pattern ptr in safe place} mov cmrop(xr) cmlop(xl)
        MOV  DWORD PTR (4*cmlop)[],EAX
        MOV                 #load subject ptr} mov cmlop(xr) xr
        CALL cdgnm          #gen code by name for subject} jsr cdgnm
        MOV                 #load pattern ptr} mov cmlop(xl) xr
        CALL cdgvl          #gen code by value for pattern} jsr cdgvl
        MOV                 #load match by name call} mov =opmn_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #load replacement value ptr} mov cmrop(xl) xr
        CALL cdgvl          #gen code by value} jsr cdgvl
        MOV                 #load replace call} mov =orpl_ wa
        JMP  cgv32          #jump to gen and exit (not constant)} brn cgv32
#
#      here for assignment to complex variable
#
cgv23:  MOV                 #inhibit pre-evaluation} mnz wc
        CALL cdgnm          #gen code by name for left side} jsr cdgnm
        JMP  cgv31          #merge with unop circuit} brn cgv31
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here for concatenation
#
cgv24:  MOV                 #load left operand ptr} mov cmlop(xl) xr
        CMP  DWORD PTR [],offset b_cmt #ordinary binop if not cmblk} bne (xr) =b_cmt cgv18
             cgv18
        MOV                 #load cmblk type code} mov cmtyp(xr) wb
        CMP                 #special case if interrogation} beq wb =c_int cgv25
             cgv25
        CMP                 #or negation} beq wb =c_neg cgv25
             cgv25
        CMP                 #else ordinary binop if not function} bne wb =c_fnc cgv18
             cgv18
        MOV                 #else load function vrblk ptr} mov cmopn(xr) xr
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #ordinary binop if not system var} bnz vrlen(xr) cgv18
        JNZ  cgv18
        MOV                 #else point to svblk} mov vrsvp(xr) xr
        MOV                 #load bit indicators} mov svbit(xr) wa
        AND                 #test for predicate function} anb btprd wa
#        OR                  #ordinary binop if not} zrb wa cgv18  (Optimized)
        JZ   cgv18
#
#      here if left arg of concatenation is predicate function
#
cgv25:  MOV                 #reload left arg} mov cmlop(xl) xr
        CALL cdgvl          #gen code by value} jsr cdgvl
        MOV                 #load pop call} mov =opop_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #load right operand} mov cmrop(xl) xr
        CALL cdgvl          #gen code by value as result code} jsr cdgvl
        JMP  cgv33          #exit (not constant)} brn cgv33
#
#      here to generate code for pattern, immediate assignment
#
cgv26:  MOV                 #load left operand} mov cmlop(xl) xr
        CALL cdgvl          #gen code by value, merge} jsr cdgvl
#
#      here for unops with arg by name (binary $ . merge)
#
cgv27:  MOV                 #load right operand ptr} mov cmrop(xl) xr
        CALL cdgnm          #gen code by name for right arg} jsr cdgnm
        MOV                 #get operator code word} mov cmopn(xl) xr
        CMP  DWORD PTR [],offset o_kwv #gen call unless keyword value} bne (xr) =o_kwv cgv20
             cgv20
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here for keyword by value. this is constant only if
#      the operand is one of the special system variables with
#      the svckw bit set to indicate a constant keyword value.
#      note that the only constant operand by name is a variable
#
        OR                  #gen call if non-constant (not var)} bnz wc cgv20
        JNZ  cgv20
        MOV                 #else set non-constant in case} mnz wc
        MOV                 #load ptr to operand vrblk} mov cmrop(xl) xr
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #gen (non-constant) if not sys var} bnz vrlen(xr) cgv20
        JNZ  cgv20
        MOV                 #else load ptr to svblk} mov vrsvp(xr) xr
        MOV                 #load bit mask} mov svbit(xr) wa
        AND                 #test for constant keyword} anb btckw wa
#        OR                  #go gen if not constant} zrb wa cgv20  (Optimized)
        JZ   cgv20
        XOR                 #else set result constant} zer wc
        JMP  cgv20          #and jump back to generate call} brn cgv20
#
#      here to generate code for negation
#
cgv28:  MOV                 #get initial word} mov =onta_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #save next offset} mov cwcof wb
        CALL cdwrd          #generate gunk word for now} jsr cdwrd
        MOV                 #load right operand ptr} mov cmrop(xl) xr
        CALL cdgvl          #gen code by value} jsr cdgvl
        MOV                 #load end of evaluation call} mov =ontb_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #copy offset to word to plug} mov wb xr
        ADD                 #point to actual word to plug} add r_ccb xr
        MOV  EAX,DWORD PTR cwcof #plug word with current offset} mov cwcof (xr)
        MOV  DWORD PTR [],EAX
        MOV                 #load final call} mov =ontc_ wa
        JMP  cgv32          #jump to generate it (not constant)} brn cgv32
#
#      here to generate code for undefined binary operator
#
cgv29:  MOV                 #load left operand ptr} mov cmlop(xl) xr
        CALL cdgvl          #generate code by value} jsr cdgvl
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here to generate code for undefined unary operator
#
cgv30:  MOV                 #set unop code + 1} mov =c_uo_ wb
        SUB                 #set number of args (1 or 2)} sub cmtyp(xl) wb
#
#      merge here for undefined operators
#
        MOV                 #load right (only) operand pointer} mov cmrop(xl) xr
        CALL cdgvl          #gen value code for right operand} jsr cdgvl
        MOV                 #load pointer to operator dv} mov cmopn(xl) xr
        MOV                 #load pointer offset} mov dvopn(xr) xr
        SAL                 #convert word offset to bytes} wtb xr
        ADD                 #point to proper function ptr} add =r_uba xr
        SUB                 #set standard function offset} sub *vrfnc xr
        JMP  cgv12          #merge with function call circuit} brn cgv12
#
#      here to generate code for interrogation, indirection
#
cgv31:  MOV                 #set non constant} mnz wc
        JMP  cgv19          #merge} brn cgv19
#
#      here to exit generating a word, result not constant
#
cgv32:  CALL cdwrd          #generate word, merge} jsr cdwrd
#
#      here to exit with no word generated, not constant
#
cgv33:  MOV                 #indicate result is not constant} mnz wc
#
#      common exit point
#
cgv34:  ADD                 #pop initial code offset} ica xs
        MOV                 #restore old constant flag} mov (xs)+ wa
        LEA
        MOV                 #restore entry xl} mov (xs)+ xl
        LEA
        MOV                 #restore entry wb} mov (xs)+ wb
        LEA
        OR                  #jump if not constant} bnz wc cgv35
        JNZ  cgv35
        MOV                 #else restore entry constant flag} mov wa wc
#
#      here to return after dealing with wc setting
#
cgv35:  RET                 #return to cdgvl caller} exi
#
#      exit here to generate word and test for constant
#
cgv36:  CALL cdwrd          #generate word} jsr cdwrd
        OR                  #jump to exit if not constant} bnz wc cgv34
        JNZ  cgv34
                            #} ejc
        .eject
#
#      cdgvl (continued)
#
#      here to preevaluate constant sub-expression
#
        MOV                 #load call to return value} mov =orvl_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV                 #load initial code offset} mov (xs) xl
        CALL exbld          #build exblk for expression} jsr exbld
        XOR                 #set to evaluate by value} zer wb
        CALL evalx          #evaluate expression} jsr evalx
        .short ERR_-299-DFFNC #should not fail} ppm
        MOV                 #load type word of result} mov (xr) wa
        CMP                 #jump if not pattern} blo wa =p_aaa cgv37
             cgv37
        MOV                 #else load special pattern load call} mov =olpt_ wa
        CALL cdwrd          #generate it} jsr cdwrd
#
#      merge here to generate pointer to resulting constant
#
cgv37:  MOV                 #copy constant pointer} mov xr wa
        CALL cdwrd          #generate ptr} jsr cdwrd
        XOR                 #set result constant} zer wc
        JMP  cgv34          #jump back to exit} brn cgv34
                            #end procedure cdgvl} enp
                            #} ejc
        .eject
#
#      cdwrd -- generate one word of code
#
#      cdwrd writes one word into the current code block under
#      construction. a new, larger, block is allocated if there
#      is insufficient room in the current block. cdwrd ensures
#      that there are at least four words left in the block
#      after entering the new word. this guarantees that any
#      extra space at the end can be split off as a ccblk.
#
#      (wa)                  word to be generated
#      jsr  cdwrd            call to generate word
#
cdwrd:                      #entry point} prc e 0
        .global cdwrd
        LEA                 #save entry xr} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #save code word to be generated} mov wa -(xs)
        MOV  DWORD PTR []
#
#      merge back here after allocating larger block
#
cdwd1:  MOV                 #load ptr to ccblk being built} mov r_ccb xr
        OR                  #jump if block allocated} bnz xr cdwd2
        JNZ  cdwd2
#
#      here we allocate an entirely fresh block
#
        MOV                 #load initial length} mov *e_cbs wa
        CALL alloc          #allocate ccblk} jsr alloc
        MOV  DWORD PTR [],offset b_cct #store type word} mov =b_cct (xr)
        MOV  DWORD PTR cwcof,4*cccod #set initial offset} mov *cccod cwcof
        MOV  DWORD PTR (4*cclen)[] #store block length} mov wa cclen(xr)
        XOR  EAX,EAX        #zero line number} zer ccsln(xr)
        MOV  DWORD PTR (4*ccsln)[],EAX
        MOV  DWORD PTR r_ccb #store ptr to new block} mov xr r_ccb
#
#      here we have a block we can use
#
cdwd2:  MOV                 #load current offset} mov cwcof wa
        ADD                 #adjust for test (five words)} add *num05 wa
        CMP                 #jump if room in this block} blo wa cclen(xr) cdwd4
             cdwd4
#
#      here if no room in current block
#
        CMP                 #jump if already at max size} bge wa mxlen cdwd5
             cdwd5
        ADD                 #else get new size} add *e_cbs wa
        LEA                 #save entry xl} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #copy pointer} mov xr xl
        CMP                 #jump if not too large} blt wa mxlen cdwd3
             cdwd3
        MOV                 #else reset to max allowed size} mov mxlen wa
                            #} ejc
        .eject
#
#      cdwrd (continued)
#
#      here with new block size in wa
#
cdwd3:  CALL alloc          #allocate new block} jsr alloc
        MOV  DWORD PTR r_ccb #store pointer to new block} mov xr r_ccb
        MOV  DWORD PTR [],offset b_cct #store type word in new block} mov =b_cct (xr)+
        LEA
        MOV  DWORD PTR []   #store block length} mov wa (xr)+
        LEA
        MOV  EAX,DWORD PTR (4*ccsln)[] #copy source line number word} mov ccsln(xl) (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        ADD                 #point to ccuse,cccod fields in old} add *ccuse xl
        MOV                 #load ccuse value} mov (xl) wa
        SHR  ECX,2          #copy useful words from old block} mvw
        REP  MOVSD
        MOV                 #restore xl} mov (xs)+ xl
        LEA
        JMP  cdwd1          #merge back to try again} brn cdwd1
#
#      here with room in current block
#
cdwd4:  MOV                 #load current offset} mov cwcof wa
        ADD                 #get new offset} ica wa
        MOV  DWORD PTR cwcof #store new offset} mov wa cwcof
        MOV  DWORD PTR (4*ccuse)[] #store in ccblk for gbcol} mov wa ccuse(xr)
        SUB                 #restore ptr to this word} dca wa
        ADD                 #point to current entry} add wa xr
        MOV                 #reload word to generate} mov (xs)+ wa
        LEA
        MOV  DWORD PTR []   #store word in block} mov wa (xr)
        MOV                 #restore entry xr} mov (xs)+ xr
        LEA
        RET                 #return to caller} exi
#
#      here if compiled code is too long for cdblk
#
cdwd5:  CALL ERR_0          #} erb 213 syntax error: statement is too complicated.
        .byte 213
                            #end procedure cdwrd} enp
                            #} ejc
        .eject
#
#      cmgen -- generate code for cmblk ptr
#
#      cmgen is a subsidiary procedure used to generate value
#      code for a cmblk ptr from the main code generators.
#
#      (xl)                  cmblk pointer
#      (wb)                  offset to pointer in cmblk
#      jsr  cmgen            call to generate code
#      (xr,wa)               destroyed
#      (wb)                  bumped by one word
#
cmgen:                      #entry point, recursive} prc r 0
        .global cmgen
        MOV                 #copy cmblk pointer} mov xl xr
        ADD                 #point to cmblk pointer} add wb xr
        MOV                 #load cmblk pointer} mov (xr) xr
        CALL cdgvl          #generate code by value} jsr cdgvl
        ADD                 #bump offset} ica wb
        RET                 #return to caller} exi
                            #end procedure cmgen} enp
                            #} ejc
        .eject
#
#      cmpil (compile source code)
#
#      cmpil is used to convert snobol4 source code to internal
#      form (see cdblk format). it is used both for the initial
#      compile and at run time by the code and convert functions
#      this procedure has control for the entire duration of
#      initial compilation. an error in any procedure called
#      during compilation will lead first to the error section
#      and ultimately back here for resumed compilation. the
#      re-entry points after an error are specially labelled -
#
#      cmpce                 resume after control card error
#      cmple                 resume after label error
#      cmpse                 resume after statement error
#
#      jsr  cmpil            call to compile code
#      (xr)                  ptr to cdblk for entry statement
#      (xl,wa,wb,wc,ra)      destroyed
#
#      the following global variables are referenced
#
#      cmpln                 line number of first line of
#                            statement to be compiled
#
#      cmpsn                 number of next statement
#                            to be compiled.
#
#      cswxx                 control card switch values are
#                            changed when relevant control
#                            cards are met.
#
#      cwcof                 offset to next word in code block
#                            being built (see cdwrd).
#
#      lstsn                 number of statement most recently
#                            compiled (initially set to zero).
#
#      r$cim                 current (initial) compiler image
#                            (zero for initial compile call)
#
#      r$cni                 used to point to following image.
#                            (see readr procedure).
#
#      scngo                 goto switch for scane procedure
#
#      scnil                 length of current image excluding
#                            characters removed by -input.
#
#      scnpt                 current scan offset, see scane.
#
#      scnrs                 rescan switch for scane procedure.
#
#      scnse                 offset (in r$cim) of most recently
#                            scanned element. set zero if not
#                            currently scanning items
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      stage               stgic  initial compile in progress
#                          stgxc  code/convert compile
#                          stgev  building exblk for eval
#                          stgxt  execute time (outside compile)
#                          stgce  initial compile after end line
#                          stgxe  execute compile after end line
#
#      cmpil also uses a fixed number of locations on the
#      main stack as follows. (the definitions of the actual
#      offsets are in the definitions section).
#
#      cmstm(xs)             pointer to expan tree for body of
#                            statement (see expan procedure).
#
#      cmsgo(xs)             pointer to tree representation of
#                            success goto (see procedure scngo)
#                            zero if no success goto is given
#
#      cmfgo(xs)             like cmsgo for failure goto.
#
#      cmcgo(xs)             set non-zero only if there is a
#                            conditional goto. used for -fail,
#                            -nofail code generation.
#
#      cmpcd(xs)             pointer to cdblk for previous
#                            statement. zero for 1st statement.
#
#      cmffp(xs)             set non-zero if cdfal in previous
#                            cdblk needs filling with forward
#                            pointer, else set to zero.
#
#      cmffc(xs)             same as cmffp for current cdblk
#
#      cmsop(xs)             offset to word in previous cdblk
#                            to be filled in with forward ptr
#                            to next cdblk for success goto.
#                            zero if no fill in is required.
#
#      cmsoc(xs)             same as cmsop for current cdblk.
#
#      cmlbl(xs)             pointer to vrblk for label of
#                            current statement. zero if no label
#
#      cmtra(xs)             pointer to cdblk for entry stmnt.
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      entry point
#
cmpil:                      #entry point} prc e 0
        .global cmpil
        MOV                 #set number of stack work locations} lct wb =cmnen
#
#      loop to initialize stack working locations
#
cmp00:  LEA                 #store a zero, make one entry} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        DEC                 #loop back until all set} bct wb cmp00
        JNZ  cmp00
        MOV  DWORD PTR cmpxs #save stack pointer for error sec} mov xs cmpxs
                            #save s-r stack pointer if any} sss cmpss
#
#      loop through statements
#
cmp01:  MOV                 #set scan pointer offset} mov scnpt wb
        MOV  DWORD PTR scnse #set start of element location} mov wb scnse
        MOV                 #point to compile error call} mov =ocer_ wa
        CALL cdwrd          #generate as temporary cdfal} jsr cdwrd
        CMP                 #jump if chars left on this image} blt wb scnil cmp04
             cmp04
#
#      loop here after comment or control card
#      also special entry after control card error
#
cmpce:  XOR                 #clear possible garbage xr value} zer xr
        CMP  DWORD PTR DWORD PTR cnind,0 #if within include file} bnz cnind cmpc2
        JNZ  cmpc2
        CMP  DWORD PTR stage,stgic #skip unless initial compile} bne stage =stgic cmp02
             cmp02
cmpc2:  CALL readr          #read next input image} jsr readr
        OR                  #jump if no input available} bze xr cmp09
        JZ   cmp09
        CALL nexts          #acquire next source image} jsr nexts
        MOV  EAX,DWORD PTR cmpsn #store stmt no for use by listr} mov cmpsn lstsn
        MOV  DWORD PTR lstsn,EAX
        MOV  EAX,DWORD PTR rdcln #store line number at start of stmt} mov rdcln cmpln
        MOV  DWORD PTR cmpln,EAX
        XOR  EAX,EAX        #reset scan pointer} zer scnpt
        MOV  DWORD PTR scnpt,EAX
        JMP  cmp04          #go process image} brn cmp04
#
#      for execute time compile, permit embedded control cards
#      and comments (by skipping to next semi-colon)
#
cmp02:  MOV                 #get current image} mov r_cim xr
        MOV                 #get current offset} mov scnpt wb
        LEA                 #prepare to get chars} plc xr wb
#
#      skip to semi-colon
#
cmp03:  MOV  EAX,DWORD PTR scnpt #end loop if end of image} bge scnpt scnil cmp09
        CMP  EAX,DWORD PTR scnil
             cmp09
        MOVZX               #get char} lch wc (xr)+
        INC
        INC  DWORD PTR scnpt #advance offset} icv scnpt
        CMP                 #loop if not semi-colon} bne wc =ch_sm cmp03
             cmp03
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here with image available to scan. note that if the input
#      string is null, then everything is ok since null is
#      actually assembled as a word of blanks.
#
cmp04:  MOV                 #point to current image} mov r_cim xr
        MOV                 #load current offset} mov scnpt wb
        MOV                 #copy for label scan} mov wb wa
        LEA                 #point to first character} plc xr wb
        MOVZX               #load first character} lch wc (xr)+
        INC
        CMP                 #no label if semicolon} beq wc =ch_sm cmp12
             cmp12
        CMP                 #loop back if comment card} beq wc =ch_as cmpce
             cmpce
        CMP                 #jump if control card} beq wc =ch_mn cmp32
             cmp32
        MOV  EAX,DWORD PTR r_cim #about to destroy r_cim} mov r_cim r_cmp
        MOV  DWORD PTR r_cmp,EAX
        MOV                 #point to label work string} mov =cmlab xl
        MOV  DWORD PTR r_cim #scane is to scan work string} mov xl r_cim
        ADD                 #point to first character position} psc xl
        MOV  [ESI]          #store char just loaded} sch wc (xl)+
        MOV                 #get a semicolon} mov =ch_sm wc
        MOV  [ESI],=ch_sm   #store after first char} sch wc (xl)
        XOR                 #clear pointer} zer xl
        XOR  EAX,EAX        #start at first character} zer scnpt
        MOV  DWORD PTR scnpt,EAX
        LEA                 #preserve image length} mov scnil -(xs)
        MOV  EAX,DWORD PTR scnil
        MOV  DWORD PTR [],EAX
        MOV  DWORD PTR scnil,num02 #read 2 chars at most} mov =num02 scnil
        CALL scane          #scan first char for type} jsr scane
        MOV  EAX,DWORD PTR [] #restore image length} mov (xs)+ scnil
        MOV  DWORD PTR scnil,EAX
        LEA
        MOV                 #note return code} mov xl wc
        MOV                 #get old r_cim} mov r_cmp xl
        MOV  DWORD PTR r_cim #put it back} mov xl r_cim
        MOV  DWORD PTR scnpt #reinstate offset} mov wb scnpt
        CMP  DWORD PTR DWORD PTR scnbl,0 #blank seen - cant be label} bnz scnbl cmp12
        JNZ  cmp12
        MOV                 #point to current image} mov xl xr
        LEA                 #point to first char again} plc xr wb
        CMP                 #ok if letter} beq wc =t_var cmp06
             cmp06
        CMP                 #ok if digit} beq wc =t_con cmp06
             cmp06
#
#      drop in or jump from error section if scane failed
#
cmple:  MOV  EAX,DWORD PTR r_cmp #point to bad line} mov r_cmp r_cim
        MOV  DWORD PTR r_cim,EAX
        CALL ERR_0          #} erb 214 bad label or misplaced continuation line
        .byte 214
#
#      loop to scan label
#
cmp05:  CMP                 #skip if semicolon} beq wc =ch_sm cmp07
             cmp07
        INC                 #bump offset} icv wa
        CMP                 #jump if end of image (label end)} beq wa scnil cmp07
             cmp07
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      enter loop at this point
#
cmp06:  MOVZX               #else load next character} lch wc (xr)+
        INC
        CMP                 #jump if horizontal tab} beq wc =ch_ht cmp07
             cmp07
        CMP                 #loop back if non-blank} bne wc =ch_bl cmp05
             cmp05
#
#      here after scanning out label
#
cmp07:  MOV  DWORD PTR scnpt #save updated scan offset} mov wa scnpt
        SUB                 #get length of label} sub wb wa
#        OR                  #skip if label length zero} bze wa cmp12  (Optimized)
        JZ   cmp12
        XOR                 #clear garbage xr value} zer xr
        CALL sbstr          #build scblk for label name} jsr sbstr
        CALL gtnvr          #locate/contruct vrblk} jsr gtnvr
        .short ERR_-299-DFFNC #dummy (impossible) error return} ppm
        MOV  DWORD PTR (4*cmlbl)[] #store label pointer} mov xr cmlbl(xs)
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #jump if not system label} bnz vrlen(xr) cmp11
        JNZ  cmp11
        CMP  DWORD PTR (4*vrsvp)[],offset v_end #jump if not end label} bne vrsvp(xr) =v_end cmp11
             cmp11
#
#      here for end label scanned out
#
        ADD  DWORD PTR stage,stgnd #adjust stage appropriately} add =stgnd stage
        CALL scane          #scan out next element} jsr scane
        CMP                 #jump if end of image} beq xl =t_smc cmp10
             cmp10
        CMP                 #else error if not variable} bne xl =t_var cmp08
             cmp08
#
#      here check for valid initial transfer
#
        CMP  DWORD PTR (4*vrlbl)[],offset stndl #jump if not defined (error)} beq vrlbl(xr) =stndl cmp08
             cmp08
        MOV  EAX,DWORD PTR (4*vrlbl)[] #else set initial entry pointer} mov vrlbl(xr) cmtra(xs)
        MOV  DWORD PTR (4*cmtra)[],EAX
        CALL scane          #scan next element} jsr scane
        CMP                 #jump if ok (end of image)} beq xl =t_smc cmp10
             cmp10
#
#      here for bad transfer label
#
cmp08:  CALL ERR_0          #} erb 215 syntax error: undefined or erroneous entry label
        .byte 215
#
#      here for end of input (no end label detected)
#
cmp09:  XOR                 #clear garbage xr value} zer xr
        ADD  DWORD PTR stage,stgnd #adjust stage appropriately} add =stgnd stage
        CMP  DWORD PTR stage,stgxe #jump if code call (ok)} beq stage =stgxe cmp10
             cmp10
        CALL ERR_0          #} erb 216 syntax error: missing end line
        .byte 216
#
#      here after processing end line (merge here on end error)
#
cmp10:  MOV                 #set stop call pointer} mov =ostp_ wa
        CALL cdwrd          #generate as statement call} jsr cdwrd
        JMP  cmpse          #jump to generate as failure} brn cmpse
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here after processing label other than end
#
cmp11:  CMP  DWORD PTR stage,stgic #jump if code call - redef. ok} bne stage =stgic cmp12
             cmp12
        CMP  DWORD PTR (4*vrlbl)[],offset stndl #else check for redefinition} beq vrlbl(xr) =stndl cmp12
             cmp12
        XOR  EAX,EAX        #leave first label decln undisturbed} zer cmlbl(xs)
        MOV  DWORD PTR (4*cmlbl)[],EAX
        CALL ERR_0          #} erb 217 syntax error: duplicate label
        .byte 217
#
#      here after dealing with label
#      null statements and statements just containing a
#      constant subject are optimized out by resetting the
#      current ccblk to empty.
#
cmp12:  XOR                 #set flag for statement body} zer wb
        CALL expan          #get tree for statement body} jsr expan
        MOV  DWORD PTR (4*cmstm)[] #store for later use} mov xr cmstm(xs)
        XOR  EAX,EAX        #clear success goto pointer} zer cmsgo(xs)
        MOV  DWORD PTR (4*cmsgo)[],EAX
        XOR  EAX,EAX        #clear failure goto pointer} zer cmfgo(xs)
        MOV  DWORD PTR (4*cmfgo)[],EAX
        XOR  EAX,EAX        #clear conditional goto flag} zer cmcgo(xs)
        MOV  DWORD PTR (4*cmcgo)[],EAX
        CALL scane          #scan next element} jsr scane
        CMP                 #jump if colon (goto)} beq xl =t_col cmp13
             cmp13
        CMP  DWORD PTR DWORD PTR cswno,0 #jump if not optimizing} bnz cswno cmp18
        JNZ  cmp18
        CMP  DWORD PTR DWORD PTR (4*cmlbl)[],0 #jump if label present} bnz cmlbl(xs) cmp18
        JNZ  cmp18
        MOV                 #load tree ptr for statement body} mov cmstm(xs) xr
        MOV                 #load type word} mov (xr) wa
        CMP                 #jump if cmblk} beq wa =b_cmt cmp18
             cmp18
        CMP                 #jump if not icblk, scblk, or rcblk} bge wa =b_vra cmp18
             cmp18
        MOV                 #load ptr to ccblk} mov r_ccb xl
        MOV  DWORD PTR (4*ccuse)[],4*cccod #reset use offset in ccblk} mov *cccod ccuse(xl)
        MOV  DWORD PTR cwcof,4*cccod #and in global} mov *cccod cwcof
        INC  DWORD PTR cmpsn #bump statement number} icv cmpsn
        JMP  cmp01          #generate no code for statement} brn cmp01
#
#      loop to process goto fields
#
cmp13:  MOV  DWORD PTR scngo,ESP #set goto flag} mnz scngo
        CALL scane          #scan next element} jsr scane
        CMP                 #jump if no fields left} beq xl =t_smc cmp31
             cmp31
        CMP                 #jump if s for success goto} beq xl =t_sgo cmp14
             cmp14
        CMP                 #jump if f for failure goto} beq xl =t_fgo cmp16
             cmp16
#
#      here for unconditional goto (i.e. not f or s)
#
        MOV  DWORD PTR scnrs,ESP #set to rescan element not f,s} mnz scnrs
        CALL scngf          #scan out goto field} jsr scngf
        CMP  DWORD PTR DWORD PTR (4*cmfgo)[],0 #error if fgoto already} bnz cmfgo(xs) cmp17
        JNZ  cmp17
        MOV  DWORD PTR (4*cmfgo)[] #else set as fgoto} mov xr cmfgo(xs)
        JMP  cmp15          #merge with sgoto circuit} brn cmp15
#
#      here for success goto
#
cmp14:  CALL scngf          #scan success goto field} jsr scngf
        MOV  DWORD PTR (4*cmcgo)[],num01 #set conditional goto flag} mov =num01 cmcgo(xs)
#
#      uncontional goto merges here
#
cmp15:  CMP  DWORD PTR DWORD PTR (4*cmsgo)[],0 #error if sgoto already given} bnz cmsgo(xs) cmp17
        JNZ  cmp17
        MOV  DWORD PTR (4*cmsgo)[] #else set sgoto} mov xr cmsgo(xs)
        JMP  cmp13          #loop back for next goto field} brn cmp13
#
#      here for failure goto
#
cmp16:  CALL scngf          #scan goto field} jsr scngf
        MOV  DWORD PTR (4*cmcgo)[],num01 #set conditonal goto flag} mov =num01 cmcgo(xs)
        CMP  DWORD PTR DWORD PTR (4*cmfgo)[],0 #error if fgoto already given} bnz cmfgo(xs) cmp17
        JNZ  cmp17
        MOV  DWORD PTR (4*cmfgo)[] #else store fgoto pointer} mov xr cmfgo(xs)
        JMP  cmp13          #loop back for next field} brn cmp13
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here for duplicated goto field
#
cmp17:  CALL ERR_0          #} erb 218 syntax error: duplicated goto field
        .byte 218
#
#      here to generate code
#
cmp18:  XOR  EAX,EAX        #stop positional error flags} zer scnse
        MOV  DWORD PTR scnse,EAX
        MOV                 #load tree ptr for statement body} mov cmstm(xs) xr
        XOR                 #collectable value for wb for cdgvl} zer wb
        XOR                 #reset constant flag for cdgvl} zer wc
        CALL expap          #test for pattern match} jsr expap
        .short cmp19-DFFNC  #jump if not pattern match} ppm cmp19
        MOV  DWORD PTR (4*cmopn)[],offset opms_ #else set pattern match pointer} mov =opms_ cmopn(xr)
        MOV  DWORD PTR (4*cmtyp)[],c_pmt #} mov =c_pmt cmtyp(xr)
#
#      here after dealing with special pattern match case
#
cmp19:  CALL cdgvl          #generate code for body of statement} jsr cdgvl
        MOV                 #load sgoto pointer} mov cmsgo(xs) xr
        MOV                 #copy it} mov xr wa
        OR                  #jump if no success goto} bze xr cmp21
        JZ   cmp21
        XOR  EAX,EAX        #clear success offset fillin ptr} zer cmsoc(xs)
        MOV  DWORD PTR (4*cmsoc)[],EAX
        CMP                 #jump if complex goto} bhi xr state cmp20
             cmp20
#
#      here for simple success goto (label)
#
        ADD                 #point to vrtra field as required} add *vrtra wa
        CALL cdwrd          #generate success goto} jsr cdwrd
        JMP  cmp22          #jump to deal with fgoto} brn cmp22
#
#      here for complex success goto
#
cmp20:  CMP                 #no code if same as fgoto} beq xr cmfgo(xs) cmp22
             cmp22
        XOR                 #else set ok value for cdgvl in wb} zer wb
        CALL cdgcg          #generate code for success goto} jsr cdgcg
        JMP  cmp22          #jump to deal with fgoto} brn cmp22
#
#      here for no success goto
#
cmp21:  MOV  EAX,DWORD PTR cwcof #set success fill in offset} mov cwcof cmsoc(xs)
        MOV  DWORD PTR (4*cmsoc)[],EAX
        MOV                 #point to compile error call} mov =ocer_ wa
        CALL cdwrd          #generate as temporary value} jsr cdwrd
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      here to deal with failure goto
#
cmp22:  MOV                 #load failure goto pointer} mov cmfgo(xs) xr
        MOV                 #copy it} mov xr wa
        XOR  EAX,EAX        #set no fill in required yet} zer cmffc(xs)
        MOV  DWORD PTR (4*cmffc)[],EAX
        OR                  #jump if no failure goto given} bze xr cmp23
        JZ   cmp23
        ADD                 #point to vrtra field in case} add *vrtra wa
        CMP                 #jump to gen if simple fgoto} blo xr state cmpse
             cmpse
#
#      here for complex failure goto
#
        MOV                 #save offset to o_gof call} mov cwcof wb
        MOV                 #point to failure goto call} mov =ogof_ wa
        CALL cdwrd          #generate} jsr cdwrd
        MOV                 #point to fail in fail word} mov =ofif_ wa
        CALL cdwrd          #generate} jsr cdwrd
        CALL cdgcg          #generate code for failure goto} jsr cdgcg
        MOV                 #copy offset to o_gof for cdfal} mov wb wa
        MOV                 #set complex case cdtyp} mov =b_cdc wb
        JMP  cmp25          #jump to build cdblk} brn cmp25
#
#      here if no failure goto given
#
cmp23:  MOV                 #load unexpected failure call in cas} mov =ounf_ wa
        MOV                 #get -nofail flag} mov cswfl wc
        OR                  #check if conditional goto} orb cmcgo(xs) wc
#        OR                  #jump if -nofail and no cond. goto} zrb wc cmpse  (Optimized)
        JZ   cmpse
        MOV  DWORD PTR (4*cmffc)[],ESP #else set fill in flag} mnz cmffc(xs)
        MOV                 #and set compile error for temporary} mov =ocer_ wa
#
#      merge here with cdfal value in wa, simple cdblk
#      also special entry after statement error
#
cmpse:  MOV                 #set cdtyp for simple case} mov =b_cds wb
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      merge here to build cdblk
#
#      (wa)                  cdfal value to be generated
#      (wb)                  cdtyp value to be generated
#
#      at this stage, we chop off an appropriate chunk of the
#      current ccblk and convert it into a cdblk. the remainder
#      of the ccblk is reformatted to be the new ccblk.
#
cmp25:  MOV                 #point to ccblk} mov r_ccb xr
        MOV                 #get possible label pointer} mov cmlbl(xs) xl
        OR                  #skip if no label} bze xl cmp26
        JZ   cmp26
        XOR  EAX,EAX        #clear flag for next statement} zer cmlbl(xs)
        MOV  DWORD PTR (4*cmlbl)[],EAX
        MOV  DWORD PTR (4*vrlbl)[] #put cdblk ptr in vrblk label field} mov xr vrlbl(xl)
#
#      merge after doing label
#
cmp26:  MOV  DWORD PTR []   #set type word for new cdblk} mov wb (xr)
        MOV  DWORD PTR (4*cdfal)[] #set failure word} mov wa cdfal(xr)
        MOV                 #copy pointer to ccblk} mov xr xl
        MOV                 #load length gen (= new cdlen)} mov ccuse(xr) wb
        MOV                 #load total ccblk length} mov cclen(xr) wc
        ADD                 #point past cdblk} add wb xl
        SUB                 #get length left for chop off} sub wb wc
        MOV  DWORD PTR [],offset b_cct #set type code for new ccblk at end} mov =b_cct (xl)
        MOV  DWORD PTR (4*ccuse)[],4*cccod #set initial code offset} mov *cccod ccuse(xl)
        MOV  DWORD PTR cwcof,4*cccod #reinitialise cwcof} mov *cccod cwcof
        MOV  DWORD PTR (4*cclen)[] #set new length} mov wc cclen(xl)
        MOV  DWORD PTR r_ccb #set new ccblk pointer} mov xl r_ccb
        XOR  EAX,EAX        #initialize new line number} zer ccsln(xl)
        MOV  DWORD PTR (4*ccsln)[],EAX
        MOV  EAX,DWORD PTR cmpln #set line number in old block} mov cmpln cdsln(xr)
        MOV  DWORD PTR (4*cdsln)[],EAX
        MOV  EAX,DWORD PTR cmpsn #set statement number} mov cmpsn cdstm(xr)
        MOV  DWORD PTR (4*cdstm)[],EAX
        INC  DWORD PTR cmpsn #bump statement number} icv cmpsn
#
#      set pointers in previous code block as required
#
        MOV                 #load ptr to previous cdblk} mov cmpcd(xs) xl
        CMP  DWORD PTR DWORD PTR (4*cmffp)[],0 #jump if no failure fill in required} bze cmffp(xs) cmp27
        JZ   cmp27
        MOV  DWORD PTR (4*cdfal)[] #else set failure ptr in previous} mov xr cdfal(xl)
#
#      here to deal with success forward pointer
#
cmp27:  MOV                 #load success offset} mov cmsop(xs) wa
        OR                  #jump if no fill in required} bze wa cmp28
        JZ   cmp28
        ADD                 #else point to fill in location} add wa xl
        MOV  DWORD PTR []   #store forward pointer} mov xr (xl)
        XOR                 #clear garbage xl value} zer xl
                            #} ejc
        .eject
#
#      cmpil (continued)
#
#      now set fill in pointers for this statement
#
cmp28:  MOV  EAX,DWORD PTR (4*cmffc)[] #copy failure fill in flag} mov cmffc(xs) cmffp(xs)
        MOV  DWORD PTR (4*cmffp)[],EAX
        MOV  EAX,DWORD PTR (4*cmsoc)[] #copy success fill in offset} mov cmsoc(xs) cmsop(xs)
        MOV  DWORD PTR (4*cmsop)[],EAX
        MOV  DWORD PTR (4*cmpcd)[] #save ptr to this cdblk} mov xr cmpcd(xs)
        CMP  DWORD PTR DWORD PTR (4*cmtra)[],0 #jump if initial entry already set} bnz cmtra(xs) cmp29
        JNZ  cmp29
        MOV  DWORD PTR (4*cmtra)[] #else set ptr here as default} mov xr cmtra(xs)
#
#      here after compiling one statement
#
cmp29:  CMP  DWORD PTR stage,stgce #jump if not end line just done} blt stage =stgce cmp01
             cmp01
        CMP  DWORD PTR DWORD PTR cswls,0 #skip if -nolist} bze cswls cmp30
        JZ   cmp30
        CALL listr          #list last line} jsr listr
#
#      return
#
cmp30:  MOV                 #load initial entry cdblk pointer} mov cmtra(xs) xr
        ADD                 #pop work locations off stack} add *cmnen xs
        RET                 #and return to cmpil caller} exi
#
#      here at end of goto field
#
cmp31:  MOV                 #get fail goto} mov cmfgo(xs) wb
        OR                  #or in success goto} orb cmsgo(xs) wb
#        OR                  #ok if non-null field} bnz wb cmp18  (Optimized)
        JNZ  cmp18
        CALL ERR_0          #} erb 219 syntax error: empty goto field
        .byte 219
#
#      control card found
#
cmp32:  INC                 #point past ch_mn} icv wb
        CALL cncrd          #process control card} jsr cncrd
        XOR  EAX,EAX        #clear start of element loc.} zer scnse
        MOV  DWORD PTR scnse,EAX
        JMP  cmpce          #loop for next statement} brn cmpce
                            #end procedure cmpil} enp
                            #} ejc
        .eject
#
#      cncrd -- control card processor
#
#      called to deal with control cards
#
#      r$cim                 points to current image
#      (wb)                  offset to 1st char of control card
#      jsr  cncrd            call to process control cards
#      (xl,xr,wa,wb,wc,ia)   destroyed
#
cncrd:                      #entry point} prc e 0
        .global cncrd
        MOV  DWORD PTR scnpt #offset for control card scan} mov wb scnpt
        MOV                 #number of chars for comparison} mov =ccnoc wa
        ADD                 #convert to word count} ctw wa 0
        SHR
        MOV  DWORD PTR cnswc #save word count} mov wa cnswc
#
#      loop here if more than one control card
#
cnc01:  MOV  EAX,DWORD PTR scnpt #return if end of image} bge scnpt scnil cnc09
        CMP  EAX,DWORD PTR scnil
             cnc09
        MOV                 #point to image} mov r_cim xr
        ADD                 #char ptr for first char} plc xr scnpt
        ADD
        MOVZX               #get first char} lch wa (xr)+
        INC
        CMP                 #fold to upper case} flc wa
        JB   SHORT L0009
        CMP
        JA   SHORT L0009
        SUB
L0009:
        CMP                 #special case of -inxxx} beq wa =ch_li cnc07
             cnc07
cnc0a:  MOV  DWORD PTR scncc,ESP #set flag for scane} mnz scncc
        CALL scane          #scan card name} jsr scane
        XOR  EAX,EAX        #clear scane flag} zer scncc
        MOV  DWORD PTR scncc,EAX
        OR                  #fail unless control card name} bnz xl cnc06
        JNZ  cnc06
        MOV                 #no. of chars to be compared} mov =ccnoc wa
        CMP  DWORD PTR (4*sclen)[] #fail if too few chars} blt sclen(xr) wa cnc08
             cnc08
        MOV                 #point to control card name} mov xr xl
        XOR                 #zero offset for substring} zer wb
        CALL sbstr          #extract substring for comparison} jsr sbstr
        MOV                 #reload length} mov sclen(xr) wa
        CALL flstg          #fold to upper case} jsr flstg
        MOV  DWORD PTR cnscc #keep control card substring ptr} mov xr cnscc
        MOV                 #point to list of standard names} mov =ccnms xr
        XOR                 #initialise name offset} zer wb
        MOV                 #number of standard names} lct wc =cc_nc
#
#      try to match name
#
cnc02:  MOV                 #point to name} mov cnscc xl
        MOV                 #counter for inner loop} lct wa cnswc
        JMP  cnc04          #jump into loop} brn cnc04
#
#      inner loop to match card name chars
#
cnc03:  ADD                 #bump standard names ptr} ica xr
        ADD                 #bump name pointer} ica xl
#
#      here to initiate the loop
#
cnc04:  MOV  EAX,DWORD PTR (4*schar)[] #comp. up to cfp_c chars at once} cne schar(xl) (xr) cnc05
        CMP  EAX,DWORD PTR []
        JNZ  cnc05
        DEC                 #loop if more words to compare} bct wa cnc03
        JNZ  cnc03
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      matched - branch on card offset
#
        MOV                 #get name offset} mov wb xl
        CMP                 #switch} bsw xl cc_nc cnc08
        JGE  cnc08
        JMP  DWORD PTR L0010[*4]
        DSeg_
L0010:
        .long cnc37         #-case} iff cc_ca cnc37
        .long cnc10         #-double} iff cc_do cnc10
        .long cnc08         #} iff 2 cnc08
        .long cnc11         #-dump} iff cc_du cnc11
        .long cnc41         #-copy} iff cc_cp cnc41
        .long cnc12         #-eject} iff cc_ej cnc12
        .long cnc13         #-errors} iff cc_er cnc13
        .long cnc14         #-execute} iff cc_ex cnc14
        .long cnc15         #-fail} iff cc_fa cnc15
        .long cnc41         #-include} iff cc_in cnc41
        .long cnc44         #-line} iff cc_ln cnc44
        .long cnc16         #-list} iff cc_li cnc16
        .long cnc17         #-noerrors} iff cc_nr cnc17
        .long cnc18         #-noexecute} iff cc_nx cnc18
        .long cnc19         #-nofail} iff cc_nf cnc19
        .long cnc20         #-nolist} iff cc_nl cnc20
        .long cnc21         #-noopt} iff cc_no cnc21
        .long cnc22         #-noprint} iff cc_np cnc22
        .long cnc24         #-optimise} iff cc_op cnc24
        .long cnc25         #-print} iff cc_pr cnc25
        .long cnc27         #-single} iff cc_si cnc27
        .long cnc28         #-space} iff cc_sp cnc28
        .long cnc31         #-stitle} iff cc_st cnc31
        .long cnc32         #-title} iff cc_ti cnc32
        .long cnc36         #-trace} iff cc_tr cnc36
        DSegEnd_            #end switch} esw
        CSeg_
#
#      not matched yet. align std names ptr and try again
#
cnc05:  ADD                 #bump standard names ptr} ica xr
        DEC                 #loop} bct wa cnc05
        JNZ  cnc05
        INC                 #bump names offset} icv wb
        DEC                 #continue if more names} bct wc cnc02
        JNZ  cnc02
        JMP  cnc08          #ignore unrecognized control card} brn cnc08
#
#      invalid control card name
#
cnc06:  CALL ERR_0          #} erb 247 invalid control statement
        .byte 247
#
#      special processing for -inxxx
#
cnc07:  MOVZX               #get next char} lch wa (xr)+
        INC
        CMP                 #fold to upper case} flc wa
        JB   SHORT L0011
        CMP
        JA   SHORT L0011
        SUB
L0011:
        CMP                 #if not letter n} bne wa =ch_ln cnc0a
             cnc0a
        MOVZX               #get third char} lch wa (xr)
        CMP                 #if not digit} blt wa =ch_d0 cnc0a
             cnc0a
        CMP                 #if not digit} bgt wa =ch_d9 cnc0a
             cnc0a
        ADD  DWORD PTR scnpt,num02 #bump offset past -in} add =num02 scnpt
        CALL scane          #scan integer after -in} jsr scane
        LEA                 #stack scanned item} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtsmi          #check if integer} jsr gtsmi
        .short cnc06-DFFNC  #fail if not integer} ppm cnc06
        .short cnc06-DFFNC  #fail if negative or large} ppm cnc06
        MOV  DWORD PTR cswin #keep integer} mov xr cswin
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      check for more control cards before returning
#
cnc08:  MOV                 #preserve in case xeq time compile} mov scnpt wa
        CALL scane          #look for comma} jsr scane
        CMP                 #loop if comma found} beq xl =t_cma cnc01
             cnc01
        MOV  DWORD PTR scnpt #restore scnpt in case xeq time} mov wa scnpt
#
#      return point
#
cnc09:  RET                 #return} exi
#
#      -double
#
cnc10:  MOV  DWORD PTR cswdb,ESP #set switch} mnz cswdb
        JMP  cnc08          #merge} brn cnc08
#
#      -dump
#      this is used for system debugging . it has the effect of
#      producing a core dump at compilation time
#
cnc11:  CALL sysdm          #call dumper} jsr sysdm
        JMP  cnc09          #finished} brn cnc09
#
#      -eject
#
cnc12:  CMP  DWORD PTR DWORD PTR cswls,0 #return if -nolist} bze cswls cnc09
        JZ   cnc09
        CALL prtps          #eject} jsr prtps
        CALL listt          #list title} jsr listt
        JMP  cnc09          #finished} brn cnc09
#
#      -errors
#
cnc13:  XOR  EAX,EAX        #clear switch} zer cswer
        MOV  DWORD PTR cswer,EAX
        JMP  cnc08          #merge} brn cnc08
#
#      -execute
#
cnc14:  XOR  EAX,EAX        #clear switch} zer cswex
        MOV  DWORD PTR cswex,EAX
        JMP  cnc08          #merge} brn cnc08
#
#      -fail
#
cnc15:  MOV  DWORD PTR cswfl,ESP #set switch} mnz cswfl
        JMP  cnc08          #merge} brn cnc08
#
#      -list
#
cnc16:  MOV  DWORD PTR cswls,ESP #set switch} mnz cswls
        CMP  DWORD PTR stage,stgic #done if compile time} beq stage =stgic cnc08
             cnc08
#
#      list code line if execute time compile
#
        XOR  EAX,EAX        #permit listing} zer lstpf
        MOV  DWORD PTR lstpf,EAX
        CALL listr          #list line} jsr listr
        JMP  cnc08          #merge} brn cnc08
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      -noerrors
#
cnc17:  MOV  DWORD PTR cswer,ESP #set switch} mnz cswer
        JMP  cnc08          #merge} brn cnc08
#
#      -noexecute
#
cnc18:  MOV  DWORD PTR cswex,ESP #set switch} mnz cswex
        JMP  cnc08          #merge} brn cnc08
#
#      -nofail
#
cnc19:  XOR  EAX,EAX        #clear switch} zer cswfl
        MOV  DWORD PTR cswfl,EAX
        JMP  cnc08          #merge} brn cnc08
#
#      -nolist
#
cnc20:  XOR  EAX,EAX        #clear switch} zer cswls
        MOV  DWORD PTR cswls,EAX
        JMP  cnc08          #merge} brn cnc08
#
#      -nooptimise
#
cnc21:  MOV  DWORD PTR cswno,ESP #set switch} mnz cswno
        JMP  cnc08          #merge} brn cnc08
#
#      -noprint
#
cnc22:  XOR  EAX,EAX        #clear switch} zer cswpr
        MOV  DWORD PTR cswpr,EAX
        JMP  cnc08          #merge} brn cnc08
#
#      -optimise
#
cnc24:  XOR  EAX,EAX        #clear switch} zer cswno
        MOV  DWORD PTR cswno,EAX
        JMP  cnc08          #merge} brn cnc08
#
#      -print
#
cnc25:  MOV  DWORD PTR cswpr,ESP #set switch} mnz cswpr
        JMP  cnc08          #merge} brn cnc08
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      -single
#
cnc27:  XOR  EAX,EAX        #clear switch} zer cswdb
        MOV  DWORD PTR cswdb,EAX
        JMP  cnc08          #merge} brn cnc08
#
#      -space
#
cnc28:  CMP  DWORD PTR DWORD PTR cswls,0 #return if -nolist} bze cswls cnc09
        JZ   cnc09
        CALL scane          #scan integer after -space} jsr scane
        MOV                 #1 space in case} mov =num01 wc
        CMP                 #jump if no integer} beq xr =t_smc cnc29
             cnc29
        LEA                 #stack it} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtsmi          #check integer} jsr gtsmi
        .short cnc06-DFFNC  #fail if not integer} ppm cnc06
        .short cnc06-DFFNC  #fail if negative or large} ppm cnc06
        OR                  #jump if non zero} bnz wc cnc29
        JNZ  cnc29
        MOV                 #else 1 space} mov =num01 wc
#
#      merge with count of lines to skip
#
cnc29:  ADD  DWORD PTR lstlc #bump line count} add wc lstlc
        MOV  EAX,DWORD PTR lstlc #jump if fits on page} blt lstlc lstnp cnc30
        CMP  EAX,DWORD PTR lstnp
             cnc30
        CALL prtps          #eject} jsr prtps
        CALL listt          #list title} jsr listt
        JMP  cnc09          #merge} brn cnc09
#
#      skip lines
#
cnc30:  CALL prtnl          #print a blank} jsr prtnl
        DEC                 #loop} bct wc cnc30
        JNZ  cnc30
        JMP  cnc09          #merge} brn cnc09
                            #} ejc
        .eject
#
#      cncrd (continued)
#
#      -stitl
#
cnc31:  MOV  DWORD PTR cnr_t,offset r_stl #ptr to r_stl} mov =r_stl cnr_t
        JMP  cnc33          #merge} brn cnc33
#
#      -title
#
cnc32:  MOV  DWORD PTR r_stl,offset nulls #clear subtitle} mov =nulls r_stl
        MOV  DWORD PTR cnr_t,offset r_ttl #ptr to r_ttl} mov =r_ttl cnr_t
#
#      common processing for -title, -stitl
#
cnc33:  MOV                 #null in case needed} mov =nulls xr
        MOV  DWORD PTR cnttl,ESP #set flag for next listr call} mnz cnttl
        MOV                 #offset to title/subtitle} mov =ccofs wb
        MOV                 #input image length} mov scnil wa
        CMP                 #jump if no chars left} blo wa wb cnc34
             cnc34
        SUB                 #no of chars to extract} sub wb wa
        MOV                 #point to image} mov r_cim xl
        CALL sbstr          #get title/subtitle} jsr sbstr
#
#      store title/subtitle
#
cnc34:  MOV                 #point to storage location} mov cnr_t xl
        MOV  DWORD PTR []   #store title/subtitle} mov xr (xl)
        CMP                 #return if stitl} beq xl =r_stl cnc09
             cnc09
        CMP  DWORD PTR DWORD PTR precl,0 #return if extended listing} bnz precl cnc09
        JNZ  cnc09
        CMP  DWORD PTR DWORD PTR prich,0 #return if regular printer} bze prich cnc09
        JZ   cnc09
        MOV                 #get length of title} mov sclen(xr) xl
        MOV                 #copy it} mov xl wa
        OR                  #jump if null} bze xl cnc35
        JZ   cnc35
        ADD                 #increment} add =num10 xl
        CMP                 #use default lstp0 val if too long} bhi xl prlen cnc09
             cnc09
        ADD                 #point just past title} add =num04 wa
#
#      store offset to page nn message for short title
#
cnc35:  MOV  DWORD PTR lstpo #store offset} mov wa lstpo
        JMP  cnc09          #return} brn cnc09
#
#      -trace
#      provided for system debugging.  toggles the system label
#      trace switch at compile time
#
cnc36:  CALL systt          #toggle switch} jsr systt
        JMP  cnc08          #merge} brn cnc08
#
#      -case
#      sets value of kvcas so that names are folded or not
#      during compilation.
#
cnc37:  CALL scane          #scan integer after -case} jsr scane
        XOR                 #get 0 in case none there} zer wc
        CMP                 #skip if no integer} beq xl =t_smc cnc38
             cnc38
        LEA                 #stack it} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtsmi          #check integer} jsr gtsmi
        .short cnc06-DFFNC  #fail if not integer} ppm cnc06
        .short cnc06-DFFNC  #fail if negative or too large} ppm cnc06
cnc38:  MOV  DWORD PTR kvcas #store new case value} mov wc kvcas
        JMP  cnc09          #merge} brn cnc09
#
#      -include
#
cnc41:  MOV  DWORD PTR scncc,ESP #set flag for scane} mnz scncc
        CALL scane          #scan quoted file name} jsr scane
        XOR  EAX,EAX        #clear scane flag} zer scncc
        MOV  DWORD PTR scncc,EAX
        CMP                 #if not constant} bne xl =t_con cnc06
             cnc06
        CMP  DWORD PTR [],offset b_scl #if not string constant} bne (xr) =b_scl cnc06
             cnc06
        MOV  DWORD PTR r_ifn #save file name} mov xr r_ifn
        MOV                 #examine include file name table} mov r_inc xl
        XOR                 #lookup by value} zer wb
        CALL tfind          #do lookup} jsr tfind
        .short ERR_-299-DFFNC #never fails} ppm
        CMP                 #ignore if already in table} beq xr =inton cnc09
             cnc09
        MOV                 #set for trim} mnz wb
        MOV                 #file name} mov r_ifn xr
        CALL trimr          #remove trailing blanks} jsr trimr
        MOV                 #include file name table} mov r_inc xl
        MOV                 #lookup by name this time} mnz wb
        CALL tfind          #do lookup} jsr tfind
        .short ERR_-299-DFFNC #never fails} ppm
        MOV  DWORD PTR (4*teval)[],offset inton #make table value integer 1} mov =inton teval(xl)
        INC  DWORD PTR cnind #increase nesting level} icv cnind
        MOV                 #load new nest level} mov cnind wa
        CMP                 #fail if excessive nesting} bgt wa =ccinm cnc42
             cnc42
#
#      record the name and line number of the current input file
#
        MOV                 #array of nested file names} mov r_ifa xl
        ADD                 #compute offset in words} add =vcvlb wa
        SAL                 #convert to bytes} wtb wa
        ADD                 #point to element} add wa xl
        MOV  EAX,DWORD PTR r_sfc #record current file name} mov r_sfc (xl)
        MOV  DWORD PTR [],EAX
        MOV                 #preserve nesting byte offset} mov wa xl
        MOV  EDX,DWORD PTR rdnln #fetch source line number as integer} mti rdnln
        CALL icbld          #convert to icblk} jsr icbld
        ADD                 #entry in nested line number array} add r_ifl xl
        MOV  DWORD PTR []   #record in array} mov xr (xl)
#
#      here to switch to include file named in r$ifn
#
        MOV                 #max read length} mov cswin wa
        MOV                 #include file name} mov r_ifn xl
        CALL alocs          #get buffer for complete file name} jsr alocs
        CALL sysif          #open include file} jsr sysif
        .short cnc43-DFFNC  #could not open} ppm cnc43
#
#      make note of the complete file name for error messages
#
        XOR                 #do not trim trailing blanks} zer wb
        CALL trimr          #adjust scblk for actual length} jsr trimr
        MOV  DWORD PTR r_sfc #save ptr to file name} mov xr r_sfc
        MOV  EDX,DWORD PTR cmpsn #current statement as integer} mti cmpsn
        CALL icbld          #build icblk for stmt number} jsr icbld
        MOV                 #file name table} mov r_sfn xl
        MOV                 #lookup statement number by name} mnz wb
        CALL tfind          #allocate new teblk} jsr tfind
        .short ERR_-299-DFFNC #always possible to allocate block} ppm
        MOV  EAX,DWORD PTR r_sfc #record file name as entry value} mov r_sfc teval(xl)
        MOV  DWORD PTR (4*teval)[],EAX
        XOR  EAX,EAX        #restart line counter for new file} zer rdnln
        MOV  DWORD PTR rdnln,EAX
        CMP  DWORD PTR stage,stgic #if initial compile} beq stage =stgic cnc09
             cnc09
        CMP  DWORD PTR cnind,num01 #if not first execute-time nesting} bne cnind =num01 cnc09
             cnc09
#
#      here for -include during execute-time compile
#
        MOV  EAX,DWORD PTR r_cim #remember code argument string} mov r_cim r_ici
        MOV  DWORD PTR r_ici,EAX
        MOV  EAX,DWORD PTR scnpt #save position in string} mov scnpt cnspt
        MOV  DWORD PTR cnspt,EAX
        MOV  EAX,DWORD PTR scnil #and length of string} mov scnil cnsil
        MOV  DWORD PTR cnsil,EAX
        JMP  cnc09          #all done, merge} brn cnc09
#
#      here for excessive include file nesting
#
cnc42:  CALL ERR_1          #} erb 284 excessively nested include files
        .byte 28
#
#      here if include file could not be opened
#
cnc43:  MOV  DWORD PTR dnamp #release allocated scblk} mov xr dnamp
        CALL ERR_1          #} erb 285 include file cannot be opened
        .byte 29
#
#
#      -line n filename
#
cnc44:  CALL scane          #scan integer after -line} jsr scane
        CMP                 #jump if no line number} bne xl =t_con cnc06
             cnc06
        CMP  DWORD PTR [],offset b_icl #jump if not integer} bne (xr) =b_icl cnc06
             cnc06
        MOV  EDX,DWORD PTR (4*icval)[] #fetch integer line number} ldi icval(xr)
        OR   EDX,EDX        #error if negative or zero} ile cnc06
        JLE  cnc06
        CMP  DWORD PTR stage,stgic #skip if initial compile} beq stage =stgic cnc45
             cnc45
        MOV  DWORD PTR cmpln,EDX #set directly for other compiles} mfi cmpln
        JMP  cnc46          #no need to set rdnln} brn cnc46
cnc45:  SUB  EDX,DWORD PTR intv1 #adjust number by one} sbi intv1
        MOV  DWORD PTR rdnln,EDX #save line number} mfi rdnln
cnc46:  MOV  DWORD PTR scncc,ESP #set flag for scane} mnz scncc
        CALL scane          #scan quoted file name} jsr scane
        XOR  EAX,EAX        #clear scane flag} zer scncc
        MOV  DWORD PTR scncc,EAX
        CMP                 #done if no file name} beq xl =t_smc cnc47
             cnc47
        CMP                 #error if not constant} bne xl =t_con cnc06
             cnc06
        CMP  DWORD PTR [],offset b_scl #if not string constant} bne (xr) =b_scl cnc06
             cnc06
        CALL newfn          #record new file name} jsr newfn
        JMP  cnc09          #merge} brn cnc09
#
#      here if file name not present
#
cnc47:  DEC  DWORD PTR scnpt #set to rescan the terminator} dcv scnpt
        JMP  cnc09          #merge} brn cnc09
                            #end procedure cncrd} enp
                            #} ejc
        .eject
#
#      dffnc -- define function
#
#      dffnc is called whenever a new function is assigned to
#      a variable. it deals with external function use counts.
#
#      (xr)                  pointer to vrblk
#      (xl)                  pointer to new function block
#      jsr  dffnc            call to define function
#      (wa,wb)               destroyed
#
dffnc:                      #entry point} prc e 0
        .global dffnc
        CMP  DWORD PTR [],offset b_efc #skip if new function not external} bne (xl) =b_efc dffn1
             dffn1
        INC  DWORD PTR (4*efuse)[] #else increment its use count} icv efuse(xl)
#
#      here after dealing with new function use count
#
dffn1:  MOV                 #save vrblk pointer} mov xr wa
        MOV                 #load old function pointer} mov vrfnc(xr) xr
        CMP  DWORD PTR [],offset b_efc #jump if old function not external} bne (xr) =b_efc dffn2
             dffn2
        MOV                 #else get use count} mov efuse(xr) wb
        DEC                 #decrement} dcv wb
        MOV  DWORD PTR (4*efuse)[] #store decremented value} mov wb efuse(xr)
        OR                  #jump if use count still non-zero} bnz wb dffn2
        JNZ  dffn2
        CALL sysul          #else call system unload function} jsr sysul
#
#      here after dealing with old function use count
#
dffn2:  MOV                 #restore vrblk pointer} mov wa xr
        MOV                 #copy function block ptr} mov xl wa
        CMP                 #skip checks if opsyn op definition} blt xr =r_yyy dffn3
             dffn3
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #jump if not system variable} bnz vrlen(xr) dffn3
        JNZ  dffn3
#
#      for system variable, check for illegal redefinition
#
        MOV                 #point to svblk} mov vrsvp(xr) xl
        MOV                 #load bit indicators} mov svbit(xl) wb
        AND                 #is it a system function} anb btfnc wb
#        OR                  #redef ok if not} zrb wb dffn3  (Optimized)
        JZ   dffn3
        CALL ERR_0          #} erb 248 attempted redefinition of system function
        .byte 248
#
#      here if redefinition is permitted
#
dffn3:  MOV  DWORD PTR (4*vrfnc)[] #store new function pointer} mov wa vrfnc(xr)
        MOV                 #restore function block pointer} mov wa xl
        RET                 #return to dffnc caller} exi
                            #end procedure dffnc} enp
                            #} ejc
        .eject
#
#      dtach -- detach i/o associated names
#
#      detaches trblks from i/o associated variables, removes
#      entry from iochn chain attached to filearg1 vrblk and may
#      remove vrblk access and store traps.
#      input, output, terminal are handled specially.
#
#      (xl)                  i/o assoc. vbl name base ptr
#      (wa)                  offset to name
#      jsr  dtach            call for detach operation
#      (xl,xr,wa,wb,wc)      destroyed
#
dtach:                      #entry point} prc e 0
        .global dtach
        MOV  DWORD PTR dtcnb #store name base (gbcol not called)} mov xl dtcnb
        ADD                 #point to name location} add wa xl
        MOV  DWORD PTR dtcnm #store it} mov xl dtcnm
#
#      loop to search for i/o trblk
#
dtch1:  MOV                 #copy name pointer} mov xl xr
#
#      continue after block deletion
#
dtch2:  MOV                 #point to next value} mov (xl) xl
        CMP  DWORD PTR [],offset b_trt #jump at chain end} bne (xl) =b_trt dtch6
             dtch6
        MOV                 #get trap block type} mov trtyp(xl) wa
        CMP                 #jump if input} beq wa =trtin dtch3
             dtch3
        CMP                 #jump if output} beq wa =trtou dtch3
             dtch3
        ADD                 #point to next link} add *trnxt xl
        JMP  dtch1          #loop} brn dtch1
#
#      delete an old association
#
dtch3:  MOV  EAX,DWORD PTR (4*trval)[] #delete trblk} mov trval(xl) (xr)
        MOV  DWORD PTR [],EAX
        MOV                 #dump xl ...} mov xl wa
        MOV                 #... and xr} mov xr wb
        MOV                 #point to trtrf trap block} mov trtrf(xl) xl
        OR                  #jump if no iochn} bze xl dtch5
        JZ   dtch5
        CMP  DWORD PTR [],offset b_trt #jump if input, output, terminal} bne (xl) =b_trt dtch5
             dtch5
#
#      loop to search iochn chain for name ptr
#
dtch4:  MOV                 #remember link ptr} mov xl xr
        MOV                 #point to next link} mov trtrf(xl) xl
        OR                  #jump if end of chain} bze xl dtch5
        JZ   dtch5
        MOV                 #get name base} mov ionmb(xl) wc
        ADD                 #add offset} add ionmo(xl) wc
        CMP                 #loop if no match} bne wc dtcnm dtch4
             dtch4
        MOV  EAX,DWORD PTR (4*trtrf)[] #remove name from chain} mov trtrf(xl) trtrf(xr)
        MOV  DWORD PTR (4*trtrf)[],EAX
                            #} ejc
        .eject
#
#      dtach (continued)
#
#      prepare to resume i/o trblk scan
#
dtch5:  MOV                 #recover xl ...} mov wa xl
        MOV                 #... and xr} mov wb xr
        ADD                 #point to value field} add *trval xl
        JMP  dtch2          #continue} brn dtch2
#
#      exit point
#
dtch6:  MOV                 #possible vrblk ptr} mov dtcnb xr
        CALL setvr          #reset vrblk if necessary} jsr setvr
        RET                 #return} exi
                            #end procedure dtach} enp
                            #} ejc
        .eject
#
#      dtype -- get datatype name
#
#      (xr)                  object whose datatype is required
#      jsr  dtype            call to get datatype
#      (xr)                  result datatype
#
dtype:                      #entry point} prc e 0
        .global dtype
        CMP  DWORD PTR [],offset b_pdt #jump if prog.defined} beq (xr) =b_pdt dtyp1
             dtyp1
        MOV                 #load type word} mov (xr) xr
        MOVZX               #get entry point id (block code)} lei xr
        SAL                 #convert to byte offset} wtb xr
        MOV                 #load table entry} mov scnmt(xr) xr
        RET                 #exit to dtype caller} exi
#
#      here if program defined
#
dtyp1:  MOV                 #point to dfblk} mov pddfp(xr) xr
        MOV                 #get datatype name from dfblk} mov dfnam(xr) xr
        RET                 #return to dtype caller} exi
                            #end procedure dtype} enp
                            #} ejc
        .eject
#
#      dumpr -- print dump of storage
#
#      (xr)                  dump argument (see below)
#      jsr  dumpr            call to print dump
#      (xr,xl)               destroyed
#      (wa,wb,wc,ra)         destroyed
#
#      the dump argument has the following significance
#
#      dmarg = 0             no dump printed
#      dmarg = 1             partial dump (nat vars, keywords)
#      dmarg = 2             full dump (arrays, tables, etc.)
#      dmarg = 3             full dump + null variables
#      dmarg ge 4            core dump
#
#      since dumpr scrambles store, it is not permissible to
#      collect in mid-dump. hence a collect is done initially
#      and then if store runs out an error message is produced.
#
dumpr:                      #entry point} prc e 0
        .global dumpr
        OR                  #skip dump if argument is zero} bze xr dmp28
        JZ   dmp28
        CMP                 #jump if core dump required} bgt xr =num03 dmp29
             dmp29
        XOR                 #clear xl} zer xl
        XOR                 #zero move offset} zer wb
        MOV  DWORD PTR dmarg #save dump argument} mov xr dmarg
        XOR  EAX,EAX        #collect sediment too} zer dnams
        MOV  DWORD PTR dnams,EAX
        CALL gbcol          #collect garbage} jsr gbcol
        CALL prtpg          #eject printer} jsr prtpg
        MOV                 #point to heading for variables} mov =dmhdv xr
        CALL prtst          #print it} jsr prtst
        CALL prtnl          #terminate print line} jsr prtnl
        CALL prtnl          #and print a blank line} jsr prtnl
#
#      first all natural variable blocks (vrblk) whose values
#      are non-null are linked in lexical order using dmvch as
#      the chain head and chaining through the vrget fields.
#      note that this scrambles store if the process is
#      interrupted before completion e.g. by exceeding time  or
#      print limits. since the subsequent core dumps and
#      failures if execution is resumed are very confusing, the
#      execution time error routine checks for this event and
#      attempts an unscramble. similar precautions should be
#      observed if translate time dumping is implemented.
#
        XOR  EAX,EAX        #set null chain to start} zer dmvch
        MOV  DWORD PTR dmvch,EAX
        MOV                 #point to hash table} mov hshtb wa
#
#      loop through headers in hash table
#
dmp00:  MOV                 #copy hash bucket pointer} mov wa xr
        ADD                 #bump pointer} ica wa
        SUB                 #set offset to merge} sub *vrnxt xr
#
#      loop through vrblks on one chain
#
dmp01:  MOV                 #point to next vrblk on chain} mov vrnxt(xr) xr
        OR                  #jump if end of this hash chain} bze xr dmp09
        JZ   dmp09
        MOV                 #else copy vrblk pointer} mov xr xl
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      loop to find value and skip if null
#
dmp02:  MOV                 #load value} mov vrval(xl) xl
        CMP  DWORD PTR dmarg,num03 #skip null value check if dump(3)} beq dmarg =num03 dmp2a
             dmp2a
        CMP                 #loop for next vrblk if null value} beq xl =nulls dmp01
             dmp01
dmp2a:  CMP  DWORD PTR [],offset b_trt #loop back if value is trapped} beq (xl) =b_trt dmp02
             dmp02
#
#      non-null value, prepare to search chain
#
        MOV                 #save vrblk pointer} mov xr wc
        ADD                 #adjust ptr to be like scblk ptr} add *vrsof xr
        CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #jump if non-system variable} bnz sclen(xr) dmp03
        JNZ  dmp03
        MOV                 #else load ptr to name in svblk} mov vrsvo(xr) xr
#
#      here with name pointer for new block in xr
#
dmp03:  MOV                 #save pointer to chars} mov xr wb
        MOV  DWORD PTR dmpsv #save hash bucket pointer} mov wa dmpsv
        MOV                 #point to chain head} mov =dmvch wa
#
#      loop to search chain for correct insertion point
#
dmp04:  MOV  DWORD PTR dmpch #save chain pointer} mov wa dmpch
        MOV                 #copy it} mov wa xl
        MOV                 #load pointer to next entry} mov (xl) xr
        OR                  #jump if end of chain to insert} bze xr dmp08
        JZ   dmp08
        ADD                 #else get name ptr for chained vrblk} add *vrsof xr
        CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #jump if not system variable} bnz sclen(xr) dmp05
        JNZ  dmp05
        MOV                 #else point to name in svblk} mov vrsvo(xr) xr
#
#      here prepare to compare the names
#
#      (wa)                  scratch
#      (wb)                  pointer to string of entering vrblk
#      (wc)                  pointer to entering vrblk
#      (xr)                  pointer to string of current block
#      (xl)                  scratch
#
dmp05:  MOV                 #point to entering vrblk string} mov wb xl
        MOV                 #load its length} mov sclen(xl) wa
        ADD                 #point to chars of entering string} plc xl
        CMP                 #jump if entering length high} bhi wa sclen(xr) dmp06
             dmp06
        ADD                 #else point to chars of old string} plc xr
        REPE CMPSB          #compare, insert if new is llt old} cmc dmp08 dmp07
        MOV  ESI,0
        MOV  EDI,ESI
        JA   dmp07
        JB   dmp08
        JMP  dmp08          #or if leq (we had shorter length)} brn dmp08
#
#      here when new length is longer than old length
#
dmp06:  MOV                 #load shorter length} mov sclen(xr) wa
        ADD                 #point to chars of old string} plc xr
        REPE CMPSB          #compare, insert if new one low} cmc dmp08 dmp07
        MOV  ESI,0
        MOV  EDI,ESI
        JA   dmp07
        JB   dmp08
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      here we move out on the chain
#
dmp07:  MOV                 #copy chain pointer} mov dmpch xl
        MOV                 #move to next entry on chain} mov (xl) wa
        JMP  dmp04          #loop back} brn dmp04
#
#      here after locating the proper insertion point
#
dmp08:  MOV                 #copy chain pointer} mov dmpch xl
        MOV                 #restore hash bucket pointer} mov dmpsv wa
        MOV                 #restore vrblk pointer} mov wc xr
        MOV  EAX,DWORD PTR [] #link vrblk to rest of chain} mov (xl) vrget(xr)
        MOV  DWORD PTR (4*vrget)[],EAX
        MOV  DWORD PTR []   #link vrblk into current chain loc} mov xr (xl)
        JMP  dmp01          #loop back for next vrblk} brn dmp01
#
#      here after processing all vrblks on one chain
#
dmp09:  CMP                 #loop back if more buckets to go} bne wa hshte dmp00
             dmp00
#
#      loop to generate dump of natural variable values
#
dmp10:  MOV                 #load pointer to next entry on chain} mov dmvch xr
        OR                  #jump if end of chain} bze xr dmp11
        JZ   dmp11
        MOV  EAX,DWORD PTR [] #else update chain ptr to next entry} mov (xr) dmvch
        MOV  DWORD PTR dmvch,EAX
        CALL setvr          #restore vrget field} jsr setvr
        MOV                 #copy vrblk pointer (name base)} mov xr xl
        MOV                 #set offset for vrblk name} mov *vrval wa
        CALL prtnv          #print name = value} jsr prtnv
        JMP  dmp10          #loop back till all printed} brn dmp10
#
#      prepare to print keywords
#
dmp11:  CALL prtnl          #print blank line} jsr prtnl
        CALL prtnl          #and another} jsr prtnl
        MOV                 #point to keyword heading} mov =dmhdk xr
        CALL prtst          #print heading} jsr prtst
        CALL prtnl          #end line} jsr prtnl
        CALL prtnl          #print one blank line} jsr prtnl
        MOV                 #point to list of keyword svblk ptrs} mov =vdmkw xl
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      loop to dump keyword values
#
dmp12:  MOV                 #load next svblk ptr from table} mov (xl)+ xr
        LEA
        OR                  #jump if end of list} bze xr dmp13
        JZ   dmp13
        CMP                 #&compare ignored if not implemented} beq xr =num01 dmp12
             dmp12
        MOV                 #load ampersand} mov =ch_am wa
        CALL prtch          #print ampersand} jsr prtch
        CALL prtst          #print keyword name} jsr prtst
        MOV                 #load name length from svblk} mov svlen(xr) wa
        ADD                 #get length of name} ctb wa svchs
        AND
        ADD                 #point to svknm field} add wa xr
        MOV  EAX,DWORD PTR [] #store in dummy kvblk} mov (xr) dmpkn
        MOV  DWORD PTR dmpkn,EAX
        MOV                 #point to blank-equal-blank} mov =tmbeb xr
        CALL prtst          #print it} jsr prtst
        MOV  DWORD PTR dmpsv #save table pointer} mov xl dmpsv
        MOV                 #point to dummy kvblk} mov =dmpkb xl
        MOV  DWORD PTR [],offset b_kvt #build type word} mov =b_kvt (xl)
        MOV  DWORD PTR (4*kvvar)[],offset trbkv #build ptr to dummy trace block} mov =trbkv kvvar(xl)
        MOV                 #set zero offset} mov *kvvar wa
        CALL acess          #get keyword value} jsr acess
        .short ERR_-299-DFFNC #failure is impossible} ppm
        CALL prtvl          #print keyword value} jsr prtvl
        CALL prtnl          #terminate print line} jsr prtnl
        MOV                 #restore table pointer} mov dmpsv xl
        JMP  dmp12          #loop back till all printed} brn dmp12
#
#      here after completing partial dump
#
dmp13:  CMP  DWORD PTR dmarg,num01 #exit if partial dump complete} beq dmarg =num01 dmp27
             dmp27
        MOV                 #else point to first dynamic block} mov dnamb xr
#
#      loop through blocks in dynamic storage
#
dmp14:  CMP                 #jump if end of used region} beq xr dnamp dmp27
             dmp27
        MOV                 #else load first word of block} mov (xr) wa
        CMP                 #jump if vector} beq wa =b_vct dmp16
             dmp16
        CMP                 #jump if array} beq wa =b_art dmp17
             dmp17
        CMP                 #jump if program defined} beq wa =b_pdt dmp18
             dmp18
        CMP                 #jump if table} beq wa =b_tbt dmp19
             dmp19
#
#      merge here to move to next block
#
dmp15:  CALL blkln          #get length of block} jsr blkln
        ADD                 #point past this block} add wa xr
        JMP  dmp14          #loop back for next block} brn dmp14
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      here for vector
#
dmp16:  MOV                 #set offset to first value} mov *vcvls wb
        JMP  dmp19          #jump to merge} brn dmp19
#
#      here for array
#
dmp17:  MOV                 #set offset to arpro field} mov arofs(xr) wb
        ADD                 #bump to get offset to values} ica wb
        JMP  dmp19          #jump to merge} brn dmp19
#
#      here for program defined
#
dmp18:  MOV                 #point to values, merge} mov *pdfld wb
#
#      here for table (others merge)
#
dmp19:  CMP  DWORD PTR DWORD PTR (4*idval)[],0 #ignore block if zero id value} bze idval(xr) dmp15
        JZ   dmp15
        CALL blkln          #else get block length} jsr blkln
        MOV                 #copy block pointer} mov xr xl
        MOV  DWORD PTR dmpsv #save length} mov wa dmpsv
        MOV                 #copy offset to first value} mov wb wa
        CALL prtnl          #print blank line} jsr prtnl
        MOV  DWORD PTR dmpsa #preserve offset} mov wa dmpsa
        CALL prtvl          #print block value (for title)} jsr prtvl
        MOV                 #recover offset} mov dmpsa wa
        CALL prtnl          #end print line} jsr prtnl
        CMP  DWORD PTR [],offset b_tbt #jump if table} beq (xr) =b_tbt dmp22
             dmp22
        SUB                 #point before first word} dca wa
#
#      loop to print contents of array, vector, or program def
#
dmp20:  MOV                 #copy block pointer} mov xl xr
        ADD                 #bump offset} ica wa
        ADD                 #point to next value} add wa xr
        CMP                 #exit if end (xr past block)} beq wa dmpsv dmp14
             dmp14
        SUB                 #subtract offset to merge into loop} sub *vrval xr
#
#      loop to find value and ignore nulls
#
dmp21:  MOV                 #load next value} mov vrval(xr) xr
        CMP  DWORD PTR dmarg,num03 #skip null value check if dump(3)} beq dmarg =num03 dmp2b
             dmp2b
        CMP                 #loop back if null value} beq xr =nulls dmp20
             dmp20
dmp2b:  CMP  DWORD PTR [],offset b_trt #loop back if trapped} beq (xr) =b_trt dmp21
             dmp21
        CALL prtnv          #else print name = value} jsr prtnv
        JMP  dmp20          #loop back for next field} brn dmp20
                            #} ejc
        .eject
#
#      dumpr (continued)
#
#      here to dump a table
#
dmp22:  MOV                 #set offset to first bucket} mov *tbbuk wc
        MOV                 #set name offset for all teblks} mov *teval wa
#
#      loop through table buckets
#
dmp23:  LEA                 #save tbblk pointer} mov xl -(xs)
        MOV  DWORD PTR []
        ADD                 #point to next bucket header} add wc xl
        ADD                 #bump bucket offset} ica wc
        SUB                 #subtract offset to merge into loop} sub *tenxt xl
#
#      loop to process teblks on one chain
#
dmp24:  MOV                 #point to next teblk} mov tenxt(xl) xl
        CMP                 #jump if end of chain} beq xl (xs) dmp26
             dmp26
        MOV                 #else copy teblk pointer} mov xl xr
#
#      loop to find value and ignore if null
#
dmp25:  MOV                 #load next value} mov teval(xr) xr
        CMP                 #ignore if null value} beq xr =nulls dmp24
             dmp24
        CMP  DWORD PTR [],offset b_trt #loop back if trapped} beq (xr) =b_trt dmp25
             dmp25
        MOV  DWORD PTR dmpsv #else save offset pointer} mov wc dmpsv
        CALL prtnv          #print name = value} jsr prtnv
        MOV                 #reload offset} mov dmpsv wc
        JMP  dmp24          #loop back for next teblk} brn dmp24
#
#      here to move to next hash chain
#
dmp26:  MOV                 #restore tbblk pointer} mov (xs)+ xl
        LEA
        CMP                 #loop back if more buckets to go} bne wc tblen(xl) dmp23
             dmp23
        MOV                 #else copy table pointer} mov xl xr
        ADD                 #point to following block} add wc xr
        JMP  dmp14          #loop back to process next block} brn dmp14
#
#      here after completing dump
#
dmp27:  CALL prtpg          #eject printer} jsr prtpg
#
#      merge here if no dump given (dmarg=0)
#
dmp28:  RET                 #return to dump caller} exi
#
#      call system core dump routine
#
dmp29:  CALL sysdm          #call it} jsr sysdm
        JMP  dmp28          #return} brn dmp28
                            #end procedure dumpr} enp
                            #} ejc
        .eject
#
#      ermsg -- print error code and error message
#
#      kvert                 error code
#      jsr  ermsg            call to print message
#      (xr,xl,wa,wb,wc,ia)   destroyed
#
ermsg:                      #entry point} prc e 0
        .global ermsg
        MOV                 #load error code} mov kvert wa
        MOV                 #point to error message /error/} mov =ermms xr
        CALL prtst          #print it} jsr prtst
        CALL ertex          #get error message text} jsr ertex
        ADD                 #bump error code for print} add =thsnd wa
        MOV  EDX            #fail code in int acc} mti wa
        MOV                 #save current buffer position} mov profs wb
        CALL prtin          #print code (now have error1xxx)} jsr prtin
        MOV                 #point to print buffer} mov prbuf xl
        LEA                 #point to the 1} psc xl wb
        MOV                 #load a blank} mov =ch_bl wa
        MOV  [ESI],=ch_bl   #store blank over 1 (error xxx)} sch wa (xl)
        XOR                 #clear garbage pointer in xl} zer xl
        MOV                 #keep error text} mov xr wa
        MOV                 #point to / -- /} mov =ermns xr
        CALL prtst          #print it} jsr prtst
        MOV                 #get error text again} mov wa xr
        CALL prtst          #print error message text} jsr prtst
        CALL prtis          #print line} jsr prtis
        CALL prtis          #print blank line} jsr prtis
        RET                 #return to ermsg caller} exi
                            #end procedure ermsg} enp
                            #} ejc
        .eject
#
#      ertex -- get error message text
#
#      (wa)                  error code
#      jsr  ertex            call to get error text
#      (xr)                  ptr to error text in dynamic
#      (r$etx)               copy of ptr to error text
#      (xl,wc,ia)            destroyed
#
ertex:                      #entry point} prc e 0
        .global ertex
        MOV  DWORD PTR ertwa #save wa} mov wa ertwa
        MOV  DWORD PTR ertwb #save wb} mov wb ertwb
        CALL sysem          #get failure message text} jsr sysem
        MOV                 #copy pointer to it} mov xr xl
        MOV                 #get length of string} mov sclen(xr) wa
        OR                  #jump if null} bze wa ert02
        JZ   ert02
        XOR                 #offset of zero} zer wb
        CALL sbstr          #copy into dynamic store} jsr sbstr
        MOV  DWORD PTR r_etx #store for relocation} mov xr r_etx
#
#      return
#
ert01:  MOV                 #restore wb} mov ertwb wb
        MOV                 #restore wa} mov ertwa wa
        RET                 #return to caller} exi
#
#      return errtext contents instead of null
#
ert02:  MOV                 #get errtext} mov r_etx xr
        JMP  ert01          #return} brn ert01
                            #} enp
                            #} ejc
        .eject
#
#      evali -- evaluate integer argument
#
#      evali is used by pattern primitives len,tab,rtab,pos,rpos
#      when their argument is an expression value.
#
#      (xr)                  node pointer
#      (wb)                  cursor
#      jsr  evali            call to evaluate integer
#      ppm  loc              transfer loc for non-integer arg
#      ppm  loc              transfer loc for out of range arg
#      ppm  loc              transfer loc for evaluation failure
#      ppm  loc              transfer loc for successful eval
#      (the normal return is never taken)
#      (xr)                  ptr to node with integer argument
#      (wc,xl,ra)            destroyed
#
#      on return, the node pointed to has the integer argument
#      in parm1 and the proper successor pointer in pthen.
#      this allows merging with the normal (integer arg) case.
#
evali:                      #entry point (recursive)} prc r 4
        .global evali
        CALL evalp          #evaluate expression} jsr evalp
        .short evli1-DFFNC  #jump on failure} ppm evli1
        LEA                 #stack result for gtsmi} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #load successor pointer} mov pthen(xr) xl
        MOV  DWORD PTR evlio #save original node pointer} mov xr evlio
        MOV  DWORD PTR evlif #zero if simple argument} mov wc evlif
        CALL gtsmi          #convert arg to small integer} jsr gtsmi
        .short evli2-DFFNC  #jump if not integer} ppm evli2
        .short evli3-DFFNC  #jump if out of range} ppm evli3
        MOV  DWORD PTR evliv #store result in special dummy node} mov xr evliv
        MOV                 #point to dummy node with result} mov =evlin xr
        MOV  DWORD PTR [],offset p_len #dummy pattern block pcode} mov =p_len (xr)
        MOV  DWORD PTR (4*pthen)[] #store successor pointer} mov xl pthen(xr)
        POP  EAX            #take successful exit} exi 4
        JMP  EXI__4
#
#      here if evaluation fails
#
evli1:  POP  EAX            #take failure return} exi 3
        JMP  EXI__3
#
#      here if argument is not integer
#
evli2:  POP  EAX            #take non-integer error exit} exi 1
        JMP  EXI__1
#
#      here if argument is out of range
#
evli3:  POP  EAX            #take out-of-range error exit} exi 2
        JMP  EXI__2
                            #end procedure evali} enp
                            #} ejc
        .eject
#
#      evalp -- evaluate expression during pattern match
#
#      evalp is used to evaluate an expression (by value) during
#      a pattern match. the effect is like evalx, but pattern
#      variables are stacked and restored if necessary.
#
#      evalp also differs from evalx in that if the result is
#      an expression it is reevaluated. this occurs repeatedly.
#
#      to support optimization of pos and rpos, evalp uses wc
#      to signal the caller for the case of a simple vrblk
#      that is not an expression and is not trapped.  because
#      this case cannot have any side effects, optimization is
#      possible.
#
#      (xr)                  node pointer
#      (wb)                  pattern match cursor
#      jsr  evalp            call to evaluate expression
#      ppm  loc              transfer loc if evaluation fails
#      (xl)                  result
#      (wa)                  first word of result block
#      (wc)                  zero if simple vrblk, else non-zero
#      (xr,wb)               destroyed (failure case only)
#      (ra)                  destroyed
#
#      the expression pointer is stored in parm1 of the node
#
#      control returns to failp on failure of evaluation
#
evalp:                      #entry point (recursive)} prc r 1
        .global evalp
        MOV                 #load expression pointer} mov parm1(xr) xl
        CMP  DWORD PTR [],offset b_exl #jump if exblk case} beq (xl) =b_exl evlp1
             evlp1
#
#      here for case of seblk
#
#      we can give a fast return if the value of the vrblk is
#      not an expression and is not trapped.
#
        MOV                 #load vrblk pointer} mov sevar(xl) xl
        MOV                 #load value of vrblk} mov vrval(xl) xl
        MOV                 #load first word of value} mov (xl) wa
        CMP                 #jump if not seblk, trblk or exblk} bhi wa =b_t__ evlp3
             evlp3
#
#      here for exblk or seblk with expr value or trapped value
#
evlp1:  CMP  ESP,LOWSPMIN   #check for stack space} chk
        JB   SEC06
        LEA                 #stack node pointer} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack subject string pointer} mov r_pms -(xs)
        MOV  EAX,DWORD PTR r_pms
        MOV  DWORD PTR [],EAX
        LEA                 #stack subject string length} mov pmssl -(xs)
        MOV  EAX,DWORD PTR pmssl
        MOV  DWORD PTR [],EAX
        LEA                 #stack dot flag} mov pmdfl -(xs)
        MOV  EAX,DWORD PTR pmdfl
        MOV  DWORD PTR [],EAX
        LEA                 #stack history stack base pointer} mov pmhbs -(xs)
        MOV  EAX,DWORD PTR pmhbs
        MOV  DWORD PTR [],EAX
        MOV                 #load expression pointer} mov parm1(xr) xr
                            #} ejc
        .eject
#
#      evalp (continued)
#
#      loop back here to reevaluate expression result
#
evlp2:  XOR                 #set flag for by value} zer wb
        CALL evalx          #evaluate expression} jsr evalx
        .short evlp4-DFFNC  #jump on failure} ppm evlp4
        MOV                 #else load first word of value} mov (xr) wa
        CMP                 #loop back to reevaluate expression} blo wa =b_e__ evlp2
             evlp2
#
#      here to restore pattern values after successful eval
#
        MOV                 #copy result pointer} mov xr xl
        MOV  EAX,DWORD PTR [] #restore history stack base pointer} mov (xs)+ pmhbs
        MOV  DWORD PTR pmhbs,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore dot flag} mov (xs)+ pmdfl
        MOV  DWORD PTR pmdfl,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string length} mov (xs)+ pmssl
        MOV  DWORD PTR pmssl,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string pointer} mov (xs)+ r_pms
        MOV  DWORD PTR r_pms,EAX
        LEA
        MOV                 #restore cursor} mov (xs)+ wb
        LEA
        MOV                 #restore node pointer} mov (xs)+ xr
        LEA
        MOV                 #non-zero for simple vrblk} mov xr wc
        POP  EAX            #return to evalp caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here to return after simple vrblk case
#
evlp3:  XOR                 #simple vrblk, no side effects} zer wc
        POP  EAX            #return to evalp caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here for failure during evaluation
#
evlp4:  MOV  EAX,DWORD PTR [] #restore history stack base pointer} mov (xs)+ pmhbs
        MOV  DWORD PTR pmhbs,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore dot flag} mov (xs)+ pmdfl
        MOV  DWORD PTR pmdfl,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string length} mov (xs)+ pmssl
        MOV  DWORD PTR pmssl,EAX
        LEA
        MOV  EAX,DWORD PTR [] #restore subject string pointer} mov (xs)+ r_pms
        MOV  DWORD PTR r_pms,EAX
        LEA
        ADD                 #remove node ptr, cursor} add *num02 xs
        POP  EAX            #take failure exit} exi 1
        JMP  EXI__1
                            #end procedure evalp} enp
                            #} ejc
        .eject
#
#      evals -- evaluate string argument
#
#      evals is used by span, any, notany, break, breakx when
#      they are passed an expression argument.
#
#      (xr)                  node pointer
#      (wb)                  cursor
#      jsr  evals            call to evaluate string
#      ppm  loc              transfer loc for non-string arg
#      ppm  loc              transfer loc for evaluation failure
#      ppm  loc              transfer loc for successful eval
#      (the normal return is never taken)
#      (xr)                  ptr to node with parms set
#      (xl,wc,ra)            destroyed
#
#      on return, the node pointed to has a character table
#      pointer in parm1 and a bit mask in parm2. the proper
#      successor is stored in pthen of this node. thus it is
#      ok for merging with the normal (multi-char string) case.
#
evals:                      #entry point (recursive)} prc r 3
        .global evals
        CALL evalp          #evaluate expression} jsr evalp
        .short evls1-DFFNC  #jump if evaluation fails} ppm evls1
        LEA                 #save successor pointer} mov pthen(xr) -(xs)
        MOV  EAX,DWORD PTR (4*pthen)[]
        MOV  DWORD PTR [],EAX
        LEA                 #save cursor} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack result ptr for patst} mov xl -(xs)
        MOV  DWORD PTR []
        XOR                 #dummy pcode for one char string} zer wb
        XOR                 #dummy pcode for expression arg} zer wc
        MOV                 #appropriate pcode for our use} mov =p_brk xl
        CALL patst          #call routine to build node} jsr patst
        .short evls2-DFFNC  #jump if not string} ppm evls2
        MOV                 #restore cursor} mov (xs)+ wb
        LEA
        MOV  EAX,DWORD PTR [] #store successor pointer} mov (xs)+ pthen(xr)
        MOV  DWORD PTR (4*pthen)[],EAX
        LEA
        POP  EAX            #take success return} exi 3
        JMP  EXI__3
#
#      here if evaluation fails
#
evls1:  POP  EAX            #take failure return} exi 2
        JMP  EXI__2
#
#      here if argument is not string
#
evls2:  ADD                 #pop successor and cursor} add *num02 xs
        POP  EAX            #take non-string error exit} exi 1
        JMP  EXI__1
                            #end procedure evals} enp
                            #} ejc
        .eject
#
#      evalx -- evaluate expression
#
#      evalx is called to evaluate an expression
#
#      (xr)                  pointer to exblk or seblk
#      (wb)                  0 if by value, 1 if by name
#      jsr  evalx            call to evaluate expression
#      ppm  loc              transfer loc if evaluation fails
#      (xr)                  result if called by value
#      (xl,wa)               result name base,offset if by name
#      (xr)                  destroyed (name case only)
#      (xl,wa)               destroyed (value case only)
#      (wb,wc,ra)            destroyed
#
evalx:                      #entry point, recursive} prc r 1
        .global evalx
        CMP  DWORD PTR [],offset b_exl #jump if exblk case} beq (xr) =b_exl evlx2
             evlx2
#
#      here for seblk
#
        MOV                 #load vrblk pointer (name base)} mov sevar(xr) xl
        MOV                 #set name offset} mov *vrval wa
        OR                  #jump if called by name} bnz wb evlx1
        JNZ  evlx1
        CALL acess          #call routine to access value} jsr acess
        .short evlx9-DFFNC  #jump if failure on access} ppm evlx9
#
#      merge here to exit for seblk case
#
evlx1:  POP  EAX            #return to evalx caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
                            #} ejc
        .eject
#
#      evalx (continued)
#
#      here for full expression (exblk) case
#
#      if an error occurs in the expression code at execution
#      time, control is passed via error section to exfal
#      without returning to this routine.
#      the following entries are made on the stack before
#      giving control to the expression code
#
#                            evalx return point
#                            saved value of r$cod
#                            code pointer (-r$cod)
#                            saved value of flptr
#                            0 if by value, 1 if by name
#      flptr --------------- *exflc, fail offset in exblk
#
evlx2:  MOV                 #get code pointer} scp wc
        MOV                 #load code block pointer} mov r_cod wa
        SUB                 #get code pointer as offset} sub wa wc
        LEA                 #stack old code block pointer} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #stack relative code offset} mov wc -(xs)
        MOV  DWORD PTR []
        LEA                 #stack old failure pointer} mov flptr -(xs)
        MOV  EAX,DWORD PTR flptr
        MOV  DWORD PTR [],EAX
        LEA                 #stack name/value indicator} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack new fail offset} mov *exflc -(xs)
        MOV  DWORD PTR [],4*exflc
        MOV  EAX,DWORD PTR flptr #keep in case of error} mov flptr gtcef
        MOV  DWORD PTR gtcef,EAX
        MOV  EAX,DWORD PTR r_cod #keep code block pointer similarly} mov r_cod r_gtc
        MOV  DWORD PTR r_gtc,EAX
        MOV  DWORD PTR flptr #set new failure pointer} mov xs flptr
        MOV  DWORD PTR r_cod #set new code block pointer} mov xr r_cod
        MOV  EAX,DWORD PTR kvstn #remember stmnt number} mov kvstn exstm(xr)
        MOV  DWORD PTR (4*exstm)[],EAX
        ADD                 #point to first code word} add *excod xr
        MOV  EBP            #set code pointer} lcp xr
        CMP  DWORD PTR stage,stgxt #jump if not execution time} bne stage =stgxt evlx0
             evlx0
        MOV  DWORD PTR stage,stgee #evaluating expression} mov =stgee stage
#
#      here to execute first code word of expression
#
evlx0:  XOR                 #clear garbage xl} zer xl
        MOV                 #load first code word} lcw xr
        ADD  EBP,4
        JMP  DWORD PTR []   #execute it} bri (xr)
                            #} ejc
        .eject
#
#      evalx (continued)
#
#      come here if successful return by value (see o$rvl)
#
evlx3:  MOV                 #load value} mov (xs)+ xr
        LEA
        CMP  DWORD PTR DWORD PTR (4*num01)[],0 #jump if called by value} bze num01(xs) evlx5
        JZ   evlx5
        CALL ERR_0          #} erb 249 expression evaluated by name returned value
        .byte 249
#
#      here for expression returning by name (see o$rnm)
#
evlx4:  MOV                 #load name offset} mov (xs)+ wa
        LEA
        MOV                 #load name base} mov (xs)+ xl
        LEA
        CMP  DWORD PTR DWORD PTR (4*num01)[],0 #jump if called by name} bnz num01(xs) evlx5
        JNZ  evlx5
        CALL acess          #else access value first} jsr acess
        .short evlx6-DFFNC  #jump if failure during access} ppm evlx6
#
#      here after loading correct result into xr or xl,wa
#
evlx5:  XOR                 #note successful} zer wb
        JMP  evlx7          #merge} brn evlx7
#
#      here for failure in expression evaluation (see o$fex)
#
evlx6:  MOV                 #note unsuccessful} mnz wb
#
#      restore environment
#
evlx7:  CMP  DWORD PTR stage,stgee #skip if was not previously xt} bne stage =stgee evlx8
             evlx8
        MOV  DWORD PTR stage,stgxt #execute time} mov =stgxt stage
#
#      merge with stage set up
#
evlx8:  ADD                 #pop name/value indicator, *exfal} add *num02 xs
        MOV  EAX,DWORD PTR [] #restore old failure pointer} mov (xs)+ flptr
        MOV  DWORD PTR flptr,EAX
        LEA
        MOV                 #load code offset} mov (xs)+ wc
        LEA
        ADD                 #make code pointer absolute} add (xs) wc
        MOV  EAX,DWORD PTR [] #restore old code block pointer} mov (xs)+ r_cod
        MOV  DWORD PTR r_cod,EAX
        LEA
        MOV  EBP            #restore old code pointer} lcp wc
        OR                  #jump for successful return} bze wb evlx1
        JZ   evlx1
#
#      merge here for failure in seblk case
#
evlx9:  POP  EAX            #take failure exit} exi 1
        JMP  EXI__1
                            #end of procedure evalx} enp
                            #} ejc
        .eject
#
#      exbld -- build exblk
#
#      exbld is used to build an expression block from the
#      code compiled most recently in the current ccblk.
#
#      (xl)                  offset in ccblk to start of code
#      (wb)                  integer in range 0 le n le mxlen
#      jsr  exbld            call to build exblk
#      (xr)                  ptr to constructed exblk
#      (wa,wb,xl)            destroyed
#
exbld:                      #entry point} prc e 0
        .global exbld
        MOV                 #copy offset to start of code} mov xl wa
        SUB                 #calc reduction in offset in exblk} sub *excod wa
        LEA                 #stack for later} mov wa -(xs)
        MOV  DWORD PTR []
        MOV                 #load final offset} mov cwcof wa
        SUB                 #compute length of code} sub xl wa
        ADD                 #add space for standard fields} add *exsi_ wa
        CALL alloc          #allocate space for exblk} jsr alloc
        LEA                 #save pointer to exblk} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR (4*extyp)[],offset b_exl #store type word} mov =b_exl extyp(xr)
        XOR  EAX,EAX        #zeroise stmnt number field} zer exstm(xr)
        MOV  DWORD PTR (4*exstm)[],EAX
        MOV  EAX,DWORD PTR cmpln #set line number field} mov cmpln exsln(xr)
        MOV  DWORD PTR (4*exsln)[],EAX
        MOV  DWORD PTR (4*exlen)[] #store length} mov wa exlen(xr)
        MOV  DWORD PTR (4*exflc)[],offset ofex_ #store failure word} mov =ofex_ exflc(xr)
        ADD                 #set xr for mvw} add *exsi_ xr
        MOV  DWORD PTR cwcof #reset offset to start of code} mov xl cwcof
        ADD                 #point to start of code} add r_ccb xl
        SUB                 #length of code to move} sub *exsi_ wa
        LEA                 #stack length of code} mov wa -(xs)
        MOV  DWORD PTR []
        SHR  ECX,2          #move code to exblk} mvw
        REP  MOVSD
        MOV                 #get length of code} mov (xs)+ wa
        LEA
        SHR                 #convert byte count to word count} btw wa
        MOV                 #copy exblk ptr, dont unstack} mov (xs) xl
        ADD                 #point to code itself} add *excod xl
        MOV                 #get reduction in offset} mov num01(xs) wb
#
#      this loop searches for negation and selection code so
#      that the offsets computed whilst code was in code block
#      can be transformed to reduced values applicable in an
#      exblk.
#
exbl1:  MOV                 #get next code word} mov (xl)+ xr
        LEA
        CMP                 #jump if selection found} beq xr =osla_ exbl3
             exbl3
        CMP                 #jump if negation found} beq xr =onta_ exbl3
             exbl3
        DEC                 #loop to end of code} bct wa exbl1
        JNZ  exbl1
#
#      no selection found or merge to exit on termination
#
exbl2:  MOV                 #pop exblk ptr into xr} mov (xs)+ xr
        LEA
        MOV                 #pop reduction constant} mov (xs)+ xl
        LEA
        RET                 #return to caller} exi
                            #} ejc
        .eject
#
#      exbld (continued)
#
#      selection or negation found
#      reduce the offsets as needed. offsets occur in words
#      following code words -
#           =onta$, =osla$, =oslb$, =oslc$
#
exbl3:  SUB  DWORD PTR []   #adjust offset} sub wb (xl)+
        LEA
        DEC                 #decrement count} bct wa exbl4
        JNZ  exbl4
#
exbl4:  DEC                 #decrement count} bct wa exbl5
        JNZ  exbl5
#
#      continue search for more offsets
#
exbl5:  MOV                 #get next code word} mov (xl)+ xr
        LEA
        CMP                 #jump if offset found} beq xr =osla_ exbl3
             exbl3
        CMP                 #jump if offset found} beq xr =oslb_ exbl3
             exbl3
        CMP                 #jump if offset found} beq xr =oslc_ exbl3
             exbl3
        CMP                 #jump if offset found} beq xr =onta_ exbl3
             exbl3
        DEC                 #loop} bct wa exbl5
        JNZ  exbl5
        JMP  exbl2          #merge to return} brn exbl2
                            #end procedure exbld} enp
                            #} ejc
        .eject
#
#      expan -- analyze expression
#
#      the expression analyzer (expan) procedure is used to scan
#      an expression and convert it into a tree representation.
#      see the description of cmblk in the structures section
#      for detailed format of tree blocks.
#
#      the analyzer uses a simple precedence scheme in which
#      operands and operators are placed on a single stack
#      and condensations are made when low precedence operators
#      are stacked after a higher precedence operator. a global
#      variable (in wb) keeps track of the level as follows.
#
#      0    scanning outer level of statement or expression
#      1    scanning outer level of normal goto
#      2    scanning outer level of direct goto
#      3    scanning inside array brackets
#      4    scanning inside grouping parentheses
#      5    scanning inside function parentheses
#
#      this variable is saved on the stack on encountering a
#      grouping and restored at the end of the grouping.
#
#      another global variable (in wc) counts the number of
#      items at one grouping level and is incremented for each
#      comma encountered. it is stacked with the level indicator
#
#      the scan is controlled by a three state finite machine.
#      a global variable stored in wa is the current state.
#
#      wa=0                  nothing scanned at this level
#      wa=1                  operand expected
#      wa=2                  operator expected
#
#      (wb)                  call type (see below)
#      jsr  expan            call to analyze expression
#      (xr)                  pointer to resulting tree
#      (xl,wa,wb,wc,ra)      destroyed
#
#      the entry value of wb indicates the call type as follows.
#
#      0    scanning either the main body of a statement or the
#           text of an expression (from eval call). valid
#           terminators are colon, semicolon. the rescan flag is
#           set to return the terminator on the next scane call.
#
#      1    scanning a normal goto. the only valid
#           terminator is a right paren.
#
#      2    scanning a direct goto. the only valid
#           terminator is a right bracket.
                            #} ejc
        .eject
#
#      expan (continued)
#
#      entry point
#
expan:                      #entry point} prc e 0
        .global expan
        LEA                 #set top of stack indicator} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        XOR                 #set initial state to zero} zer wa
        XOR                 #zero counter value} zer wc
#
#      loop here for successive entries
#
exp01:  CALL scane          #scan next element} jsr scane
        ADD                 #add state to syntax code} add wa xl
        JMP  DWORD PTR L0012[*4] #switch on element type/state} bsw xl t_nes
        DSeg_
L0012:
        .long exp27         #unop, s=0} iff t_uo0 exp27
        .long exp27         #unop, s=1} iff t_uo1 exp27
        .long exp04         #unop, s=2} iff t_uo2 exp04
        .long exp06         #left paren, s=0} iff t_lp0 exp06
        .long exp06         #left paren, s=1} iff t_lp1 exp06
        .long exp04         #left paren, s=2} iff t_lp2 exp04
        .long exp08         #left brkt, s=0} iff t_lb0 exp08
        .long exp08         #left brkt, s=1} iff t_lb1 exp08
        .long exp09         #left brkt, s=2} iff t_lb2 exp09
        .long exp02         #comma, s=0} iff t_cm0 exp02
        .long exp05         #comma, s=1} iff t_cm1 exp05
        .long exp11         #comma, s=2} iff t_cm2 exp11
        .long exp10         #function, s=0} iff t_fn0 exp10
        .long exp10         #function, s=1} iff t_fn1 exp10
        .long exp04         #function, s=2} iff t_fn2 exp04
        .long exp03         #variable, s=0} iff t_va0 exp03
        .long exp03         #variable, state one} iff t_va1 exp03
        .long exp04         #variable, s=2} iff t_va2 exp04
        .long exp03         #constant, s=0} iff t_co0 exp03
        .long exp03         #constant, s=1} iff t_co1 exp03
        .long exp04         #constant, s=2} iff t_co2 exp04
        .long exp05         #binop, s=0} iff t_bo0 exp05
        .long exp05         #binop, s=1} iff t_bo1 exp05
        .long exp26         #binop, s=2} iff t_bo2 exp26
        .long exp02         #right paren, s=0} iff t_rp0 exp02
        .long exp05         #right paren, s=1} iff t_rp1 exp05
        .long exp12         #right paren, s=2} iff t_rp2 exp12
        .long exp02         #right brkt, s=0} iff t_rb0 exp02
        .long exp05         #right brkt, s=1} iff t_rb1 exp05
        .long exp18         #right brkt, s=2} iff t_rb2 exp18
        .long exp02         #colon, s=0} iff t_cl0 exp02
        .long exp05         #colon, s=1} iff t_cl1 exp05
        .long exp19         #colon, s=2} iff t_cl2 exp19
        .long exp02         #semicolon, s=0} iff t_sm0 exp02
        .long exp05         #semicolon, s=1} iff t_sm1 exp05
        .long exp19         #semicolon, s=2} iff t_sm2 exp19
        DSegEnd_            #end switch on element type/state} esw
        CSeg_
                            #} ejc
        .eject
#
#      expan (continued)
#
#      here for rbr,rpr,col,smc,cma in state 0
#
#      set to rescan the terminator encountered and create
#      a null constant (case of omitted null)
#
exp02:  MOV  DWORD PTR scnrs,ESP #set to rescan element} mnz scnrs
        MOV                 #point to null, merge} mov =nulls xr
#
#      here for var or con in states 0,1
#
#      stack the variable/constant and set state=2
#
exp03:  LEA                 #stack pointer to operand} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #set state 2} mov =num02 wa
        JMP  exp01          #jump for next element} brn exp01
#
#      here for var,con,lpr,fnc,uop in state 2
#
#      we rescan the element and create a concatenation operator
#      this is the case of the blank concatenation operator.
#
exp04:  MOV  DWORD PTR scnrs,ESP #set to rescan element} mnz scnrs
        MOV                 #point to concat operator dv} mov =opdvc xr
        OR                  #ok if at top level} bze wb exp4a
        JZ   exp4a
        MOV                 #else point to unmistakable concat.} mov =opdvp xr
#
#      merge here when xr set up with proper concatenation dvblk
#
exp4a:  CMP  DWORD PTR DWORD PTR scnbl,0 #merge bop if blanks, else error} bnz scnbl exp26
        JNZ  exp26
#      dcv  scnse            adjust start of element location
        CALL ERR_0          #} erb 220 syntax error: missing operator
        .byte 220
#
#      here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)
#
#      this is an erronous contruction
#
#exp05 dcv  scnse            adjust start of element location
exp05:  CALL ERR_0          #} erb 221 syntax error: missing operand
        .byte 221
#
#      here for lpr (s=0,1)
#
exp06:  MOV                 #set new level indicator} mov =num04 xl
        XOR                 #set zero value for cmopn} zer xr
                            #} ejc
        .eject
#
#      expan (continued)
#
#      merge here to store old level on stack and start new one
#
exp07:  LEA                 #stack cmopn value} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack old counter} mov wc -(xs)
        MOV  DWORD PTR []
        LEA                 #stack old level indicator} mov wb -(xs)
        MOV  DWORD PTR []
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        XOR                 #set new state to zero} zer wa
        MOV                 #set new level indicator} mov xl wb
        MOV                 #initialize new counter} mov =num01 wc
        JMP  exp01          #jump to scan next element} brn exp01
#
#      here for lbr (s=0,1)
#
#      this is an illegal use of left bracket
#
exp08:  CALL ERR_0          #} erb 222 syntax error: invalid use of left bracket
        .byte 222
#
#      here for lbr (s=2)
#
#      set new level and start to scan subscripts
#
exp09:  MOV                 #load array ptr for cmopn} mov (xs)+ xr
        LEA
        MOV                 #set new level indicator} mov =num03 xl
        JMP  exp07          #jump to stack old and start new} brn exp07
#
#      here for fnc (s=0,1)
#
#      stack old level and start to scan arguments
#
exp10:  MOV                 #set new lev indic (xr=vrblk=cmopn)} mov =num05 xl
        JMP  exp07          #jump to stack old and start new} brn exp07
#
#      here for cma (s=2)
#
#      increment argument count and continue
#
exp11:  INC                 #increment counter} icv wc
        CALL expdm          #dump operators at this level} jsr expdm
        LEA                 #set new level for parameter} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        XOR                 #set new state} zer wa
        CMP                 #loop back unless outer level} bgt wb =num02 exp01
             exp01
        CALL ERR_0          #} erb 223 syntax error: invalid use of comma
        .byte 223
                            #} ejc
        .eject
#
#      expan (continued)
#
#      here for rpr (s=2)
#
#      at outer level in a normal goto this is a terminator
#      otherwise it must terminate a function or grouping
#
exp12:  CMP                 #end of normal goto} beq wb =num01 exp20
             exp20
        CMP                 #end of function arguments} beq wb =num05 exp13
             exp13
        CMP                 #end of grouping / selection} beq wb =num04 exp14
             exp14
        CALL ERR_0          #} erb 224 syntax error: unbalanced right parenthesis
        .byte 224
#
#      here at end of function arguments
#
exp13:  MOV                 #set cmtyp value for function} mov =c_fnc xl
        JMP  exp15          #jump to build cmblk} brn exp15
#
#      here for end of grouping
#
exp14:  CMP                 #jump if end of grouping} beq wc =num01 exp17
             exp17
        MOV                 #else set cmtyp for selection} mov =c_sel xl
#
#      merge here to build cmblk for level just scanned and
#      to pop up to the previous scan level before continuing.
#
exp15:  CALL expdm          #dump operators at this level} jsr expdm
        MOV                 #copy count} mov wc wa
        ADD                 #add for standard fields at start} add =cmvls wa
        SAL                 #convert length to bytes} wtb wa
        CALL alloc          #allocate space for cmblk} jsr alloc
        MOV  DWORD PTR [],offset b_cmt #store type code for cmblk} mov =b_cmt (xr)
        MOV  DWORD PTR (4*cmtyp)[] #store cmblk node type indicator} mov xl cmtyp(xr)
        MOV  DWORD PTR (4*cmlen)[] #store length} mov wa cmlen(xr)
        ADD                 #point past end of block} add wa xr
#
#      loop to move remaining words to cmblk
#
exp16:  LEA                 #move one operand ptr from stack} mov (xs)+ -(xr)
        MOV  EAX,DWORD PTR []
        MOV  DWORD PTR [],EAX
        LEA
        MOV                 #pop to old level indicator} mov (xs)+ wb
        LEA
        DEC                 #loop till all moved} bct wc exp16
        JNZ  exp16
                            #} ejc
        .eject
#
#      expan (continued)
#
#      complete cmblk and stack pointer to it on stack
#
        SUB                 #point back to start of block} sub *cmvls xr
        MOV                 #restore old counter} mov (xs)+ wc
        LEA
        MOV  EAX,DWORD PTR [] #store operand ptr in cmblk} mov (xs) cmopn(xr)
        MOV  DWORD PTR (4*cmopn)[],EAX
        MOV  DWORD PTR []   #stack cmblk pointer} mov xr (xs)
        MOV                 #set new state} mov =num02 wa
        JMP  exp01          #back for next element} brn exp01
#
#      here at end of a parenthesized expression
#
exp17:  CALL expdm          #dump operators at this level} jsr expdm
        MOV                 #restore xr} mov (xs)+ xr
        LEA
        MOV                 #restore outer level} mov (xs)+ wb
        LEA
        MOV                 #restore outer count} mov (xs)+ wc
        LEA
        MOV  DWORD PTR []   #store opnd over unused cmopn val} mov xr (xs)
        MOV                 #set new state} mov =num02 wa
        JMP  exp01          #back for next ele8ent} brn exp01
#
#      here for rbr (s=2)
#
#      at outer level in a direct goto, this is a terminator.
#      otherwise it must terminate a subscript list.
#
exp18:  MOV                 #set cmtyp for array reference} mov =c_arr xl
        CMP                 #jump to build cmblk if end arrayref} beq wb =num03 exp15
             exp15
        CMP                 #jump if end of direct goto} beq wb =num02 exp20
             exp20
        CALL ERR_0          #} erb 225 syntax error: unbalanced right bracket
        .byte 225
                            #} ejc
        .eject
#
#      expan (continued)
#
#      here for col,smc (s=2)
#
#      error unless terminating statement body at outer level
#
exp19:  MOV  DWORD PTR scnrs,ESP #rescan terminator} mnz scnrs
        MOV                 #copy level indicator} mov wb xl
        JMP  DWORD PTR L0013[*4] #switch on level indicator} bsw xl 6
        DSeg_
L0013:
        .long exp20         #normal outer level} iff 0 exp20
        .long exp22         #fail if normal goto} iff 1 exp22
        .long exp23         #fail if direct goto} iff 2 exp23
        .long exp24         #fail array brackets} iff 3 exp24
        .long exp21         #fail if in grouping} iff 4 exp21
        .long exp21         #fail function args} iff 5 exp21
        DSegEnd_            #end switch on level} esw
        CSeg_
#
#      here at normal end of expression
#
exp20:  CALL expdm          #dump remaining operators} jsr expdm
        MOV                 #load tree pointer} mov (xs)+ xr
        LEA
        ADD                 #pop off bottom of stack marker} ica xs
        RET                 #return to expan caller} exi
#
#      missing right paren
#
exp21:  CALL ERR_0          #} erb 226 syntax error: missing right paren
        .byte 226
#
#      missing right paren in goto field
#
exp22:  CALL ERR_0          #} erb 227 syntax error: right paren missing from goto
        .byte 227
#
#      missing bracket in goto
#
exp23:  CALL ERR_0          #} erb 228 syntax error: right bracket missing from goto
        .byte 228
#
#      missing array bracket
#
exp24:  CALL ERR_0          #} erb 229 syntax error: missing right array bracket
        .byte 229
                            #} ejc
        .eject
#
#      expan (continued)
#
#      loop here when an operator causes an operator dump
#
exp25:  MOV  DWORD PTR expsv #} mov xr expsv
        CALL expop          #pop one operator} jsr expop
        MOV                 #restore op dv pointer and merge} mov expsv xr
#
#      here for bop (s=2)
#
#      remove operators (condense) from stack until no more
#      left at this level or top one has lower precedence.
#      loop here till this condition is met.
#
exp26:  MOV                 #load operator dvptr from stack} mov num01(xs) xl
        CMP                 #jump if bottom of stack level} ble xl =num05 exp27
             exp27
        MOV  EAX,DWORD PTR (4*dvrpr)[] #else pop if new prec is lo} blt dvrpr(xr) dvlpr(xl) exp25
        CMP  EAX,DWORD PTR (4*dvlpr)[]
             exp25
#
#      here for uop (s=0,1)
#
#      binary operator merges after precedence check
#
#      the operator dv is stored on the stack and the scan
#      continues after setting the scan state to one.
#
exp27:  LEA                 #stack operator dvptr on stack} mov xr -(xs)
        MOV  DWORD PTR []
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        MOV                 #set new state} mov =num01 wa
        CMP                 #back for next element unless =} bne xr =opdvs exp01
             exp01
#
#      here for special case of binary =. the syntax allows a
#      null right argument for this operator to be left
#      out. accordingly we reset to state zero to get proper
#      action on a terminator (supply a null constant).
#
        XOR                 #set state zero} zer wa
        JMP  exp01          #jump for next element} brn exp01
                            #end procedure expan} enp
                            #} ejc
        .eject
#
#      expap -- test for pattern match tree
#
#      expap is passed an expression tree to determine if it
#      is a pattern match. the following are recogized as
#      matches in the context of this call.
#
#      1)   an explicit use of binary question mark
#      2)   a concatenation
#      3)   an alternation whose left operand is a concatenation
#
#      (xr)                  ptr to expan tree
#      jsr  expap            call to test for pattern match
#      ppm  loc              transfer loc if not a pattern match
#      (wa)                  destroyed
#      (xr)                  unchanged (if not match)
#      (xr)                  ptr to binary operator blk if match
#
expap:                      #entry point} prc e 1
        .global expap
        LEA                 #save xl} mov xl -(xs)
        MOV  DWORD PTR []
        CMP  DWORD PTR [],offset b_cmt #no match if not complex} bne (xr) =b_cmt expp2
             expp2
        MOV                 #else load type code} mov cmtyp(xr) wa
        CMP                 #concatenation is a match} beq wa =c_cnc expp1
             expp1
        CMP                 #binary question mark is a match} beq wa =c_pmt expp1
             expp1
        CMP                 #else not match unless alternation} bne wa =c_alt expp2
             expp2
#
#      here for alternation. change (a b) / c to a qm (b / c)
#
        MOV                 #load left operand pointer} mov cmlop(xr) xl
        CMP  DWORD PTR [],offset b_cmt #not match if left opnd not complex} bne (xl) =b_cmt expp2
             expp2
        CMP  DWORD PTR (4*cmtyp)[],c_cnc #not match if left op not conc} bne cmtyp(xl) =c_cnc expp2
             expp2
        MOV  EAX,DWORD PTR (4*cmrop)[] #xr points to (b / c)} mov cmrop(xl) cmlop(xr)
        MOV  DWORD PTR (4*cmlop)[],EAX
        MOV  DWORD PTR (4*cmrop)[] #set xl opnds to a, (b / c)} mov xr cmrop(xl)
        MOV                 #point to this altered node} mov xl xr
#
#      exit here for pattern match
#
expp1:  MOV                 #restore entry xl} mov (xs)+ xl
        LEA
        POP  EAX            #give pattern match return} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      exit here if not pattern match
#
expp2:  MOV                 #restore entry xl} mov (xs)+ xl
        LEA
        POP  EAX            #give non-match return} exi 1
        JMP  EXI__1
                            #end procedure expap} enp
                            #} ejc
        .eject
#
#      expdm -- dump operators at current level (for expan)
#
#      expdm uses expop to condense all operators at this syntax
#      level. the stack bottom is recognized from the level
#      value which is saved on the top of the stack.
#
#      jsr  expdm            call to dump operators
#      (xs)                  popped as required
#      (xr,wa)               destroyed
#
expdm:                      #entry point} prc n 0
        .global expdm
        POP  PRC_+12
        MOV  DWORD PTR r_exs #save xl value} mov xl r_exs
#
#      loop to dump operators
#
exdm1:  CMP  DWORD PTR (4*num01)[],num05 #jump if stack bottom (saved level} ble num01(xs) =num05 exdm2
             exdm2
        CALL expop          #else pop one operator} jsr expop
        JMP  exdm1          #and loop back} brn exdm1
#
#      here after popping all operators
#
exdm2:  MOV                 #restore xl} mov r_exs xl
        XOR  EAX,EAX        #release save location} zer r_exs
        MOV  DWORD PTR r_exs,EAX
        RET                 #return to expdm caller} exi
                            #end procedure expdm} enp
                            #} ejc
        .eject
#
#      expop-- pop operator (for expan)
#
#      expop is used by the expan routine to condense one
#      operator from the top of the syntax stack. an appropriate
#      cmblk is built for the operator (unary or binary) and a
#      pointer to this cmblk is stacked.
#
#      expop is also used by scngf (goto field scan) procedure
#
#      jsr  expop            call to pop operator
#      (xs)                  popped appropriately
#      (xr,xl,wa)            destroyed
#
expop:                      #entry point} prc n 0
        .global expop
        POP  PRC_+16
        MOV                 #load operator dv pointer} mov num01(xs) xr
        CMP  DWORD PTR (4*dvlpr)[],lluno #jump if unary} beq dvlpr(xr) =lluno expo2
             expo2
#
#      here for binary operator
#
        MOV                 #set size of binary operator cmblk} mov *cmbs_ wa
        CALL alloc          #allocate space for cmblk} jsr alloc
        MOV  EAX,DWORD PTR [] #pop and store right operand ptr} mov (xs)+ cmrop(xr)
        MOV  DWORD PTR (4*cmrop)[],EAX
        LEA
        MOV                 #pop and load operator dv ptr} mov (xs)+ xl
        LEA
        MOV  EAX,DWORD PTR [] #store left operand pointer} mov (xs) cmlop(xr)
        MOV  DWORD PTR (4*cmlop)[],EAX
#
#      common exit point
#
expo1:  MOV  DWORD PTR [],offset b_cmt #store type code for cmblk} mov =b_cmt (xr)
        MOV  EAX,DWORD PTR (4*dvtyp)[] #store cmblk node type code} mov dvtyp(xl) cmtyp(xr)
        MOV  DWORD PTR (4*cmtyp)[],EAX
        MOV  DWORD PTR (4*cmopn)[] #store dvptr (=ptr to dac o_xxx)} mov xl cmopn(xr)
        MOV  DWORD PTR (4*cmlen)[] #store cmblk length} mov wa cmlen(xr)
        MOV  DWORD PTR []   #store resulting node ptr on stack} mov xr (xs)
        RET                 #return to expop caller} exi
#
#      here for unary operator
#
expo2:  MOV                 #set size of unary operator cmblk} mov *cmus_ wa
        CALL alloc          #allocate space for cmblk} jsr alloc
        MOV  EAX,DWORD PTR [] #pop and store operand pointer} mov (xs)+ cmrop(xr)
        MOV  DWORD PTR (4*cmrop)[],EAX
        LEA
        MOV                 #load operator dv pointer} mov (xs) xl
        JMP  expo1          #merge back to exit} brn expo1
                            #end procedure expop} enp
                            #} ejc
        .eject
#
#      filnm -- obtain file name from statement number
#
#      filnm takes a statement number and examines the file name
#      table pointed to by r$sfn to find the name of the file
#      containing the given statement.  table entries are
#      arranged in order of ascending statement number (there
#      is only one hash bucket in this table).  elements are
#      added to the table each time there is a change in
#      file name, recording the then current statement number.
#
#      to find the file name, the linked list of teblks is
#      scanned for an element containing a subscript (statement
#      number) greater than the argument statement number, or
#      the end of chain.  when this condition is met, the
#      previous teblk contains the desired file name as its
#      value entry.
#
#      (wc)                  statement number
#      jsr  filnm            call to obtain file name
#      (xl)                  file name (scblk)
#      (ia)                  destroyed
#
filnm:                      #entry point} prc e 0
        .global filnm
        LEA                 #preserve wb} mov wb -(xs)
        MOV  DWORD PTR []
        OR                  #return nulls if stno is zero} bze wc filn3
        JZ   filn3
        MOV                 #file name table} mov r_sfn xl
        OR                  #if no table} bze xl filn3
        JZ   filn3
        MOV                 #get bucket entry} mov tbbuk(xl) wb
        CMP                 #jump if no teblks on chain} beq wb r_sfn filn3
             filn3
        LEA                 #preserve xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #previous block pointer} mov wb xr
        LEA                 #preserve stmt number} mov wc -(xs)
        MOV  DWORD PTR []
#
#      loop through teblks on hash chain
#
filn1:  MOV                 #next element to examine} mov xr xl
        MOV                 #load subscript value (an icblk)} mov tesub(xl) xr
        MOV  EDX,DWORD PTR (4*icval)[] #load the statement number} ldi icval(xr)
        MOV                 #convert to address constant} mfi wc
        CMP  DWORD PTR []   #compare arg with teblk stmt number} blt (xs) wc filn2
             filn2
#
#      here if desired stmt number is ge teblk stmt number
#
        MOV                 #save previous entry pointer} mov xl wb
        MOV                 #point to next teblk on chain} mov tenxt(xl) xr
        CMP                 #jump if there is one} bne xr r_sfn filn1
             filn1
#
#      here if chain exhausted or desired block found.
#
filn2:  MOV                 #previous teblk} mov wb xl
        MOV                 #get ptr to file name scblk} mov teval(xl) xl
        MOV                 #restore stmt number} mov (xs)+ wc
        LEA
        MOV                 #restore xr} mov (xs)+ xr
        LEA
        MOV                 #restore wb} mov (xs)+ wb
        LEA
        RET                 #} exi
#
#      no table or no table entries
#
filn3:  MOV                 #restore wb} mov (xs)+ wb
        LEA
        MOV                 #return null string} mov =nulls xl
        RET                 #} exi
                            #} enp
                            #} ejc
        .eject
#
#
#      flstg -- fold string to upper case
#
#      flstg folds a character string containing lower case
#      characcters to one containing upper case characters.
#      folding is only done if &case (kvcas) is not zero.
#
#      (xr)                  string argument
#      (wa)                  length of string
#      jsr  flstg            call to fold string
#      (xr)                  result string (possibly original)
#      (wc)                  destroyed
#
flstg:                      #entry point} prc e 0
        .global flstg
        CMP  DWORD PTR DWORD PTR kvcas,0 #skip if &case is 0} bze kvcas fst99
        JZ   fst99
        LEA                 #save xl across call} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #save original scblk ptr} mov xr -(xs)
        MOV  DWORD PTR []
        CALL alocs          #allocate new string block} jsr alocs
        MOV                 #point to original scblk} mov (xs) xl
        LEA                 #save pointer to new scblk} mov xr -(xs)
        MOV  DWORD PTR []
        ADD                 #point to original chars} plc xl
        ADD                 #point to new chars} psc xr
        LEA                 #init did fold flag} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
fst01:  MOVZX               #load character} lch wa (xl)+
        INC
        CMP                 #skip if less than lc a} blt wa =ch__a fst02
             fst02
        CMP                 #skip if greater than lc z} bgt wa =ch___ fst02
             fst02
        CMP                 #fold character to upper case} flc wa
        JB   SHORT L0014
        CMP
        JA   SHORT L0014
        SUB
L0014:
        MOV  DWORD PTR [],ESP #set did fold character flag} mnz (xs)
fst02:  MOV  [ESI]          #store (possibly folded) character} sch wa (xr)+
        DEC                 #loop thru entire string} bct wc fst01
        JNZ  fst01
        MOV                 #see if any change} mov (xs)+ xr
        LEA
        OR                  #skip if folding done (no change)} bnz xr fst10
        JNZ  fst10
        MOV  EAX,DWORD PTR [] #do not need new scblk} mov (xs)+ dnamp
        MOV  DWORD PTR dnamp,EAX
        LEA
        MOV                 #return original scblk} mov (xs)+ xr
        LEA
        JMP  fst20          #merge below} brn fst20
fst10:  MOV                 #return new scblk} mov (xs)+ xr
        LEA
        ADD                 #throw away original scblk pointer} ica xs
fst20:  MOV                 #reload string length} mov sclen(xr) wa
        MOV                 #restore xl} mov (xs)+ xl
        LEA
fst99:  RET                 #return} exi
                            #} enp
                            #} ejc
        .eject
#
#      gbcol -- perform garbage collection
#
#      gbcol performs a garbage collection on the dynamic region
#      all blocks which are no longer in use are eliminated
#      by moving blocks which are in use down and resetting
#      dnamp, the pointer to the next available location.
#
#      (wb)                  move offset (see below)
#      jsr  gbcol            call to collect garbage
#      (xr)                  sediment size after collection
#
#      the following conditions must be met at the time when
#      gbcol is called.
#
#      1)   all pointers to blocks in the dynamic area must be
#           accessible to the garbage collector. this means
#           that they must occur in one of the following.
#
#           a)               main stack, with current top
#                            element being indicated by xs
#
#           b)               in relocatable fields of vrblks.
#
#           c)               in register xl at the time of call
#
#           e)               in the special region of working
#                            storage where names begin with r$.
#
#      2)   all pointers must point to the start of blocks with
#           the sole exception of the contents of the code
#           pointer register which points into the r$cod block.
#
#      3)   no location which appears to contain a pointer
#           into the dynamic region may occur unless it is in
#           fact a pointer to the start of the block. however
#           pointers outside this area may occur and will
#           not be changed by the garbage collector.
#           it is especially important to make sure that xl
#           does not contain a garbage value from some process
#           carried out before the call to the collector.
#
#      gbcol has the capability of moving the final compacted
#      result up in memory (with addresses adjusted accordingly)
#      this is used to add space to the static region. the
#      entry value of wb is the number of bytes to move up.
#      the caller must guarantee that there is enough room.
#      furthermore the value in wb if it is non-zero, must be at
#      least 256 so that the mwb instruction conditions are met.
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      the algorithm, which is a modification of the lisp-2
#      garbage collector devised by r.dewar and k.belcher
#      takes three passes as follows.
#
#      1)   all pointers in memory are scanned and blocks in use
#           determined from this scan. note that this procedure
#           is recursive and uses the main stack for linkage.
#           the marking process is thus similar to that used in
#           a standard lisp collector. however the method of
#           actually marking the blocks is different.
#
#           the first field of a block normally contains a
#           code entry point pointer. such an entry pointer
#           can be distinguished from the address of any pointer
#           to be processed by the collector. during garbage
#           collection, this word is used to build a back chain
#           of pointers through fields which point to the block.
#           the end of the chain is marked by the occurence
#           of the word which used to be in the first word of
#           the block. this backchain serves both as a mark
#           indicating that the block is in use and as a list of
#           references for the relocation phase.
#
#      2)   storage is scanned sequentially to discover which
#           blocks are currently in use as indicated by the
#           presence of a backchain. two pointers are maintained
#           one scans through looking at each block. the other
#           is incremented only for blocks found to be in use.
#           in this way, the eventual location of each block can
#           be determined without actually moving any blocks.
#           as each block which is in use is processed, the back
#           chain is used to reset all pointers which point to
#           this block to contain its new address, i.e. the
#           address it will occupy after the blocks are moved.
#           the first word of the block, taken from the end of
#           the chain is restored at this point.
#
#           during pass 2, the collector builds blocks which
#           describe the regions of storage which are to be
#           moved in the third pass. there is one descriptor for
#           each contiguous set of good blocks. the descriptor
#           is built just behind the block to be moved and
#           contains a pointer to the next block and the number
#           of words to be moved.
#
#      3)   in the third and final pass, the move descriptor
#           blocks built in pass two are used to actually move
#           the blocks down to the bottom of the dynamic region.
#           the collection is then complete and the next
#           available location pointer is reset.
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      the garbage collector also recognizes the concept of
#      sediment.  sediment is defined as long-lived objects
#      which percipitate to the bottom of dynamic storage.
#      moving these objects during repeated collections is
#      inefficient.  it also contributes to thrashing on
#      systems with virtual memory.  in a typical worst-case
#      situation, there may be several megabytes of live objects
#      in the sediment, and only a few dead objects in need of
#      collection.  without recognising sediment, the standard
#      collector would move those megabytes of objects downward
#      to squeeze out the dead objects.  this type of move
#      would result in excessive thrasing for very little memory
#      gain.
#
#      scanning of blocks in the sediment cannot be avoided
#      entirely, because these blocks may contain pointers to
#      live objects above the sediment.  however, sediment
#      blocks need not be linked to a back chain as described
#      in pass one above.  since these blocks will not be moved,
#      pointers to them do not need to be adjusted.  eliminating
#      unnecessary back chain links increases locality of
#      reference, improving virtual memory performance.
#
#      because back chains are used to mark blocks whose con-
#      tents have been processed, a different marking system
#      is needed for blocks in the sediment.  since block type
#      words point to odd-parity entry addresses, merely incre-
#      menting the type word serves to mark the block as pro-
#      cessed.  during pass three, the type words are decre-
#      mented to restore them to their original value.
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#
#      the variable dnams contains the number of bytes of memory
#      currently in the sediment.  setting dnams to zero will
#      eliminate the sediment and force it to be included in a
#      full garbage collection.  gbcol returns a suggested new
#      value for dnams (usually dnamp-dnamb) in xr which the
#      caller can store in dnams if it wishes to maintain the
#      sediment.  that is, data remaining after a garbage
#      collection is considered to be sediment.  if one accepts
#      the common lore that most objects are either very short-
#      or very long-lived, then this naive setting of dnams
#      probably includes some short-lived objects toward the end
#      of the sediment.
#
#      knowing when to reset dnams to zero to collect the sedi-
#      ment is not precisely known.  we force it to zero prior
#      to producing a dump, when gbcol is invoked by collect()
#      (so that the sediment is invisible to the user), when
#      sysmm is unable to obtain additional memory, and when
#      gbcol is called to relocate the dynamic area up in memory
#      (to make room for enlarging the static area).  if there
#      are no other reset situations, this leads to the inexo-
#      rable growth of the sediment, possible forcing a modest
#      program to begin to use virtual memory that it otherwise
#      would not.
#
#      as we scan sediment blocks in pass three, we maintain
#      aggregate counts of the amount of dead and live storage,
#      which is used to decide when to reset dnams.  when the
#      ratio of free storage found in the sediment to total
#      sediment size exceeds a threshold, the sediment is marked
#      for collection on the next gbcol call.
#
                            #} ejc
        .eject
#
#      gbcol (continued)
#
gbcol:                      #entry point} prc e 0
        .global gbcol
        CMP  DWORD PTR DWORD PTR dmvch,0 #fail if in mid-dump} bnz dmvch gbc14
        JNZ  gbc14
        MOV  DWORD PTR gbcfl,ESP #note gbcol entered} mnz gbcfl
        MOV  DWORD PTR gbsva #save entry wa} mov wa gbsva
        MOV  DWORD PTR gbsvb #save entry wb} mov wb gbsvb
        MOV  DWORD PTR gbsvc #save entry wc} mov wc gbsvc
        LEA                 #save entry xl} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #get code pointer value} scp wa
        SUB                 #make relative} sub r_cod wa
        MOV  EBP            #and restore} lcp wa
        OR                  #check there is no move offset} bze wb gbc0a
        JZ   gbc0a
        XOR  EAX,EAX        #collect sediment if must move it} zer dnams
        MOV  DWORD PTR dnams,EAX
gbc0a:  MOV                 #start of dynamic area} mov dnamb wa
        ADD                 #size of sediment} add dnams wa
        MOV  DWORD PTR gbcsd #first location past sediment} mov wa gbcsd
#
#      inform sysgc that collection to commence
#
        MOV                 #non-zero flags start of collection} mnz xr
        MOV                 #start of dynamic area} mov dnamb wa
        MOV                 #next available location} mov dnamp wb
        MOV                 #last available location + 1} mov dname wc
        CALL sysgc          #inform of collection} jsr sysgc
#
#      process stack entries
#
        MOV                 #point to stack front} mov xs xr
        MOV                 #point past end of stack} mov stbas xl
        CMP                 #ok if d-stack} bge xl xr gbc00
             gbc00
        MOV                 #reverse if ...} mov xl xr
        MOV                 #... u-stack} mov xs xl
#
#      process the stack
#
gbc00:  CALL gbcpf          #process pointers on stack} jsr gbcpf
#
#      process special work locations
#
        MOV                 #point to start of relocatable locs} mov =r_aaa xr
        MOV                 #point past end of relocatable locs} mov =r_yyy xl
        CALL gbcpf          #process work fields} jsr gbcpf
#
#      prepare to process variable blocks
#
        MOV                 #point to first hash slot pointer} mov hshtb wa
#
#      loop through hash slots
#
gbc01:  MOV                 #point to next slot} mov wa xl
        ADD                 #bump bucket pointer} ica wa
        MOV  DWORD PTR gbcnm #save bucket pointer} mov wa gbcnm
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      loop through variables on one hash chain
#
gbc02:  MOV                 #load ptr to next vrblk} mov (xl) xr
        OR                  #jump if end of chain} bze xr gbc03
        JZ   gbc03
        MOV                 #else copy vrblk pointer} mov xr xl
        ADD                 #point to first reloc fld} add *vrval xr
        ADD                 #point past last (and to link ptr)} add *vrnxt xl
        CALL gbcpf          #process reloc fields in vrblk} jsr gbcpf
        JMP  gbc02          #loop back for next block} brn gbc02
#
#      here at end of one hash chain
#
gbc03:  MOV                 #restore bucket pointer} mov gbcnm wa
        CMP                 #loop back if more buckets to go} bne wa hshte gbc01
             gbc01
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      now we are ready to start pass two. registers are used
#      as follows in pass two.
#
#      (xr)                  scans through all blocks
#      (wc)                  pointer to eventual location
#
#      the move description blocks built in this pass have
#      the following format.
#
#      word 1                pointer to next move block,
#                            zero if end of chain of blocks
#
#      word 2                length of blocks to be moved in
#                            bytes. set to the address of the
#                            first byte while actually scanning
#                            the blocks.
#
#      the first entry on this chain is a special entry
#      consisting of the two words gbcnm and gbcns. after
#      building the chain of move descriptors, gbcnm points to
#      the first real move block, and gbcns is the length of
#      blocks in use at the start of storage which need not
#      be moved since they are in the correct position.
#
        MOV                 #point to first block} mov dnamb xr
        XOR                 #accumulate size of dead blocks} zer wb
gbc04:  CMP                 #jump if end of sediment} beq xr gbcsd gbc4c
             gbc4c
        MOV                 #else get first word} mov (xr) wa
        TEST                #jump if entry pointer (unused)} bod wa gbc4b
        JNE  gbc4b
        DEC                 #restore entry pointer} dcv wa
        MOV  DWORD PTR []   #restore first word} mov wa (xr)
        CALL blkln          #get length of this block} jsr blkln
        ADD                 #bump actual pointer} add wa xr
        JMP  gbc04          #continue scan through sediment} brn gbc04
#
#      here for unused sediment block
#
gbc4b:  CALL blkln          #get length of this block} jsr blkln
        ADD                 #bump actual pointer} add wa xr
        ADD                 #count size of unused blocks} add wa wb
        JMP  gbc04          #continue scan through sediment} brn gbc04
#
#      here at end of sediment.  remember size of free blocks
#      within the sediment.  this will be used later to decide
#      how to set the sediment size returned to caller.
#
#      then scan rest of dynamic area above sediment.
#
#      (wb) = aggregate size of free blocks in sediment
#      (xr) = first location past sediment
#
gbc4c:  MOV  DWORD PTR gbcsf #size of sediment free space} mov wb gbcsf
        MOV                 #set as first eventual location} mov xr wc
        ADD                 #add offset for eventual move up} add gbsvb wc
        XOR  EAX,EAX        #clear initial forward pointer} zer gbcnm
        MOV  DWORD PTR gbcnm,EAX
        MOV  DWORD PTR gbclm,offset gbcnm #initialize ptr to last move block} mov =gbcnm gbclm
        MOV  DWORD PTR gbcns #initialize first address} mov xr gbcns
#
#      loop through a series of blocks in use
#
gbc05:  CMP                 #jump if end of used region} beq xr dnamp gbc07
             gbc07
        MOV                 #else get first word} mov (xr) wa
        TEST                #jump if entry pointer (unused)} bod wa gbc07
        JNE  gbc07
#
#      here for block in use, loop to relocate references
#
gbc06:  MOV                 #copy pointer} mov wa xl
        MOV                 #load forward pointer} mov (xl) wa
        MOV  DWORD PTR []   #relocate reference} mov wc (xl)
        TEST                #loop back if not end of chain} bev wa gbc06
        JE   gbc06
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      at end of chain, restore first word and bump past
#
        MOV  DWORD PTR []   #restore first word} mov wa (xr)
        CALL blkln          #get length of this block} jsr blkln
        ADD                 #bump actual pointer} add wa xr
        ADD                 #bump eventual pointer} add wa wc
        JMP  gbc05          #loop back for next block} brn gbc05
#
#      here at end of a series of blocks in use
#
gbc07:  MOV                 #copy pointer past last block} mov xr wa
        MOV                 #point to previous move block} mov gbclm xl
        SUB                 #subtract starting address} sub num01(xl) wa
        MOV  DWORD PTR (4*num01)[] #store length of block to be moved} mov wa num01(xl)
#
#      loop through a series of blocks not in use
#
gbc08:  CMP                 #jump if end of used region} beq xr dnamp gbc10
             gbc10
        MOV                 #else load first word of next block} mov (xr) wa
        TEST                #jump if in use} bev wa gbc09
        JE   gbc09
        CALL blkln          #else get length of next block} jsr blkln
        ADD                 #push pointer} add wa xr
        JMP  gbc08          #and loop back} brn gbc08
#
#      here for a block in use after processing a series of
#      blocks which were not in use, build new move block.
#
gbc09:  SUB                 #point 2 words behind for move block} sub *num02 xr
        MOV                 #point to previous move block} mov gbclm xl
        MOV  DWORD PTR []   #set forward ptr in previous block} mov xr (xl)
        XOR  EAX,EAX        #zero forward ptr of new block} zer (xr)
        MOV  DWORD PTR [],EAX
        MOV  DWORD PTR gbclm #remember address of this block} mov xr gbclm
        MOV                 #copy ptr to move block} mov xr xl
        ADD                 #point back to block in use} add *num02 xr
        MOV  DWORD PTR (4*num01)[] #store starting address} mov xr num01(xl)
        JMP  gbc06          #jump to process block in use} brn gbc06
                            #} ejc
        .eject
#
#      gbcol (continued)
#
#      here for pass three -- actually move the blocks down
#
#      (xl)                  pointer to old location
#      (xr)                  pointer to new location
#
gbc10:  MOV                 #point to storage above sediment} mov gbcsd xr
        ADD                 #bump past unmoved blocks at start} add gbcns xr
#
#      loop through move descriptors
#
gbc11:  MOV                 #point to next move block} mov gbcnm xl
        OR                  #jump if end of chain} bze xl gbc12
        JZ   gbc12
        MOV  EAX,DWORD PTR [] #move pointer down chain} mov (xl)+ gbcnm
        MOV  DWORD PTR gbcnm,EAX
        LEA
        MOV                 #get length to move} mov (xl)+ wa
        LEA
        SHR  ECX,2          #perform move} mvw
        REP  MOVSD
        JMP  gbc11          #loop back} brn gbc11
#
#      now test for move up
#
gbc12:  MOV  DWORD PTR dnamp #set next available loc ptr} mov xr dnamp
        MOV                 #reload move offset} mov gbsvb wb
        OR                  #jump if no move required} bze wb gbc13
        JZ   gbc13
        MOV                 #else copy old top of core} mov xr xl
        ADD                 #point to new top of core} add wb xr
        MOV  DWORD PTR dnamp #save new top of core pointer} mov xr dnamp
        MOV                 #copy old top} mov xl wa
        SUB                 #minus old bottom = length} sub dnamb wa
        ADD  DWORD PTR dnamb #bump bottom to get new value} add wb dnamb
        SHR  ECX,2          #perform move (backwards)} mwb
        STD
        LEA  ESI,[ESI-4]
        LEA  EDI,[EDI-4]
        REP  MOVSD
        CLD
#
#      merge here to exit
#
gbc13:  XOR                 #clear garbage value in xr} zer xr
        MOV  DWORD PTR gbcfl #note exit from gbcol} mov xr gbcfl
        MOV                 #start of dynamic area} mov dnamb wa
        MOV                 #next available location} mov dnamp wb
        MOV                 #last available location + 1} mov dname wc
        CALL sysgc          #inform sysgc of completion} jsr sysgc
#
#      decide whether to mark sediment for collection next time.
#      this is done by examining the ratio of previous sediment
#      free space to the new sediment size.
#
        MOV  DWORD PTR gbcia,EDX #save ia} sti gbcia
        XOR                 #presume no sediment will remain} zer xr
        MOV                 #free space in sediment} mov gbcsf wb
        SHR                 #convert bytes to words} btw wb
        MOV  EDX            #put sediment free store in ia} mti wb
        IMUL EDX,DWORD PTR gbsed #multiply by sediment factor} mli gbsed
        JO   gb13a          #jump if overflowed} iov gb13a
        MOV                 #end of dynamic area in use} mov dnamp wb
        SUB                 #minus start is sediment remaining} sub dnamb wb
        SHR                 #convert to words} btw wb
        MOV  DWORD PTR gbcsf #store it} mov wb gbcsf
        SUB  EDX,DWORD PTR gbcsf #subtract from scaled up free store} sbi gbcsf
#        OR   EDX,EDX        #jump if large free store in sedimnt} igt gb13a   (Optimized)
        JG   gb13a
        MOV                 #below threshold, return sediment} mov dnamp xr
        SUB                 #for use by caller} sub dnamb xr
gb13a:  MOV  EDX,DWORD PTR gbcia #restore ia} ldi gbcia
        MOV                 #restore wa} mov gbsva wa
        MOV                 #restore wb} mov gbsvb wb
        MOV                 #get code pointer} scp wc
        ADD                 #make absolute again} add r_cod wc
        MOV  EBP            #and replace absolute value} lcp wc
        MOV                 #restore wc} mov gbsvc wc
        MOV                 #restore entry xl} mov (xs)+ xl
        LEA
        INC  DWORD PTR gbcnt #increment count of collections} icv gbcnt
        RET                 #exit to gbcol caller} exi
#
#      garbage collection not allowed whilst dumping
#
gbc14:  INC  DWORD PTR errft #fatal error} icv errft
        CALL ERR_0          #} erb 250 insufficient memory to complete dump
        .byte 250
                            #end procedure gbcol} enp
                            #} ejc
        .eject
#
#      gbcpf -- process fields for garbage collector
#
#      this procedure is used by the garbage collector to
#      process fields in pass one. see gbcol for full details.
#
#      (xr)                  ptr to first location to process
#      (xl)                  ptr past last location to process
#      jsr  gbcpf            call to process fields
#      (xr,wa,wb,wc,ia)      destroyed
#
#      note that although this procedure uses a recursive
#      approach, it controls its own stack and is not recursive.
#
gbcpf:                      #entry point} prc e 0
        .global gbcpf
        LEA                 #set zero to mark bottom of stack} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        LEA                 #save end pointer} mov xl -(xs)
        MOV  DWORD PTR []
#
#      merge here to go down a level and start a new loop
#
#      1(xs)                 next lvl field ptr (0 at outer lvl)
#      0(xs)                 ptr past last field to process
#      (xr)                  ptr to first field to process
#
#      loop to process successive fields
#
gpf01:  MOV                 #load field contents} mov (xr) xl
        MOV                 #save field pointer} mov xr wc
        CMP                 #jump if not ptr into dynamic area} blt xl dnamb gpf2a
             gpf2a
        CMP                 #jump if not ptr into dynamic area} bge xl dnamp gpf2a
             gpf2a
#
#      here we have a ptr to a block in the dynamic area.
#      link this field onto the reference backchain.
#
        MOV                 #load ptr to chain (or entry ptr)} mov (xl) wa
        CMP                 #do not chain if within sediment} blt xl gbcsd gpf1a
             gpf1a
        MOV  DWORD PTR []   #set this field as new head of chain} mov xr (xl)
        MOV  DWORD PTR []   #set forward pointer} mov wa (xr)
#
#      now see if this block has been processed before
#
gpf1a:  TEST                #jump if not already processed} bod wa gpf03
        JNE  gpf03
#
#      here to restore pointer in xr to field just processed
#
gpf02:  MOV                 #restore field pointer} mov wc xr
#
#      here to move to next field
#
gpf2a:  ADD                 #bump to next field} ica xr
        CMP                 #loop back if more to go} bne xr (xs) gpf01
             gpf01
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      here we pop up a level after finishing a block
#
        MOV                 #restore pointer past end} mov (xs)+ xl
        LEA
        MOV                 #restore block pointer} mov (xs)+ xr
        LEA
        OR                  #continue loop unless outer levl} bnz xr gpf2a
        JNZ  gpf2a
        RET                 #return to caller if outer level} exi
#
#      here to process an active block which has not been done
#
#
#      since sediment blocks are not marked by putting them on
#      the back chain, they must be explicitly marked in another
#      manner.  if odd parity entry points are present, mark by
#      temporarily converting to even parity.  if odd parity not
#      available, the entry point is adjusted by the value in
#      gbcmk.
#
gpf03:  CMP                 #if not within sediment} bge xl gbcsd gpf3a
             gpf3a
        INC  DWORD PTR []   #mark by making entry point even} icv (xl)
gpf3a:  MOV                 #copy block pointer} mov xl xr
        MOV                 #copy first word of block} mov wa xl
        MOVZX               #load entry point id (bl_xx)} lei xl
#
#      block type switch. note that blocks with no relocatable
#      fields just return to gpf02 here to continue to next fld.
#
        JMP  DWORD PTR L0015[*4] #switch on block type} bsw xl bl___
        DSeg_
L0015:
        .long gpf06         #arblk} iff bl_ar gpf06
        .long gpf19         #cdblk} iff bl_cd gpf19
        .long gpf17         #exblk} iff bl_ex gpf17
        .long gpf02         #icblk} iff bl_ic gpf02
        .long gpf10         #nmblk} iff bl_nm gpf10
        .long gpf10         #p0blk} iff bl_p0 gpf10
        .long gpf12         #p1blk} iff bl_p1 gpf12
        .long gpf12         #p2blk} iff bl_p2 gpf12
        .long gpf02         #rcblk} iff bl_rc gpf02
        .long gpf02         #scblk} iff bl_sc gpf02
        .long gpf02         #seblk} iff bl_se gpf02
        .long gpf08         #tbblk} iff bl_tb gpf08
        .long gpf08         #vcblk} iff bl_vc gpf08
        .long gpf02         #xnblk} iff bl_xn gpf02
        .long gpf09         #xrblk} iff bl_xr gpf09
        .long gpf02         #bcblk - dummy to fill out iffs} iff bl_bc gpf02
        .long gpf13         #pdblk} iff bl_pd gpf13
        .long gpf16         #trblk} iff bl_tr gpf16
        .long gpf02         #bfblk} iff bl_bf gpf02
        .long gpf07         #ccblk} iff bl_cc gpf07
        .long gpf04         #cmblk} iff bl_cm gpf04
        .long gpf02         #ctblk} iff bl_ct gpf02
        .long gpf02         #dfblk} iff bl_df gpf02
        .long gpf02         #efblk} iff bl_ef gpf02
        .long gpf10         #evblk} iff bl_ev gpf10
        .long gpf11         #ffblk} iff bl_ff gpf11
        .long gpf02         #kvblk} iff bl_kv gpf02
        .long gpf14         #pfblk} iff bl_pf gpf14
        .long gpf15         #teblk} iff bl_te gpf15
        DSegEnd_            #end of jump table} esw
        CSeg_
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      cmblk
#
gpf04:  MOV                 #load length} mov cmlen(xr) wa
        MOV                 #set offset} mov *cmtyp wb
#
#      here to push down to new level
#
#      (wc)                  field ptr at previous level
#      (xr)                  ptr to new block
#      (wa)                  length (reloc flds + flds at start)
#      (wb)                  offset to first reloc field
#
gpf05:  ADD                 #point past last reloc field} add xr wa
        ADD                 #point to first reloc field} add wb xr
        LEA                 #stack old field pointer} mov wc -(xs)
        MOV  DWORD PTR []
        LEA                 #stack new limit pointer} mov wa -(xs)
        MOV  DWORD PTR []
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        JMP  gpf01          #if ok, back to process} brn gpf01
#
#      arblk
#
gpf06:  MOV                 #load length} mov arlen(xr) wa
        MOV                 #set offset to 1st reloc fld (arpro)} mov arofs(xr) wb
        JMP  gpf05          #all set} brn gpf05
#
#      ccblk
#
gpf07:  MOV                 #set length in use} mov ccuse(xr) wa
        MOV                 #1st word (make sure at least one)} mov *ccuse wb
        JMP  gpf05          #all set} brn gpf05
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      cdblk
#
gpf19:  MOV                 #load length} mov cdlen(xr) wa
        MOV                 #set offset} mov *cdfal wb
        JMP  gpf05          #jump back} brn gpf05
#
#      tbblk, vcblk
#
gpf08:  MOV                 #load length} mov offs2(xr) wa
        MOV                 #set offset} mov *offs3 wb
        JMP  gpf05          #jump back} brn gpf05
#
#      xrblk
#
gpf09:  MOV                 #load length} mov xrlen(xr) wa
        MOV                 #set offset} mov *xrptr wb
        JMP  gpf05          #jump back} brn gpf05
#
#      evblk, nmblk, p0blk
#
gpf10:  MOV                 #point past second field} mov *offs2 wa
        MOV                 #offset is one (only reloc fld is 2)} mov *offs1 wb
        JMP  gpf05          #all set} brn gpf05
#
#      ffblk
#
gpf11:  MOV                 #set length} mov *ffofs wa
        MOV                 #set offset} mov *ffnxt wb
        JMP  gpf05          #all set} brn gpf05
#
#      p1blk, p2blk
#
gpf12:  MOV                 #length (parm2 is non-relocatable)} mov *parm2 wa
        MOV                 #set offset} mov *pthen wb
        JMP  gpf05          #all set} brn gpf05
                            #} ejc
        .eject
#
#      gbcpf (continued)
#
#      pdblk
#
gpf13:  MOV                 #load ptr to dfblk} mov pddfp(xr) xl
        MOV                 #get pdblk length} mov dfpdl(xl) wa
        MOV                 #set offset} mov *pdfld wb
        JMP  gpf05          #all set} brn gpf05
#
#      pfblk
#
gpf14:  MOV                 #length past last reloc} mov *pfarg wa
        MOV                 #offset to first reloc} mov *pfcod wb
        JMP  gpf05          #all set} brn gpf05
#
#      teblk
#
gpf15:  MOV                 #set length} mov *tesi_ wa
        MOV                 #and offset} mov *tesub wb
        JMP  gpf05          #all set} brn gpf05
#
#      trblk
#
gpf16:  MOV                 #set length} mov *trsi_ wa
        MOV                 #and offset} mov *trval wb
        JMP  gpf05          #all set} brn gpf05
#
#      exblk
#
gpf17:  MOV                 #load length} mov exlen(xr) wa
        MOV                 #set offset} mov *exflc wb
        JMP  gpf05          #jump back} brn gpf05
                            #end procedure gbcpf} enp
                            #} ejc
        .eject
#
#      gtarr -- get array
#
#      gtarr is passed an object and returns an array if possibl
#
#      (xr)                  value to be converted
#      (wa)                  0 to place table addresses in array
#                            non-zero for keys/values in array
#      jsr  gtarr            call to get array
#      ppm  loc              transfer loc for all null table
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  resulting array
#      (xl,wa,wb,wc)         destroyed
#
gtarr:                      #entry point} prc e 2
        .global gtarr
        MOV  DWORD PTR gtawa #save wa indicator} mov wa gtawa
        MOV                 #load type word} mov (xr) wa
        CMP                 #exit if already an array} beq wa =b_art gtar8
             gtar8
        CMP                 #exit if already an array} beq wa =b_vct gtar8
             gtar8
        CMP                 #else fail if not a table (sgd02)} bne wa =b_tbt gta9a
             gta9a
#
#      here we convert a table to an array
#
        LEA                 #replace tbblk pointer on stack} mov xr -(xs)
        MOV  DWORD PTR []
        XOR                 #signal first pass} zer xr
        XOR                 #zero non-null element count} zer wb
#
#      the following code is executed twice. on the first pass,
#      signalled by xr=0, the number of non-null elements in
#      the table is counted in wb. in the second pass, where
#      xr is a pointer into the arblk, the name and value are
#      entered into the current arblk location provided gtawa
#      is non-zero.  if gtawa is zero, the address of the teblk
#      is entered into the arblk twice (c3.762).
#
gtar1:  MOV                 #point to table} mov (xs) xl
        ADD                 #point past last bucket} add tblen(xl) xl
        SUB                 #set first bucket offset} sub *tbbuk xl
        MOV                 #copy adjusted pointer} mov xl wa
#
#      loop through buckets in table block
#      next three lines of code rely on tenxt having a value
#      1 less than tbbuk.
#
gtar2:  MOV                 #copy bucket pointer} mov wa xl
        SUB                 #decrement bucket pointer} dca wa
#
#      loop through teblks on one bucket chain
#
gtar3:  MOV                 #point to next teblk} mov tenxt(xl) xl
        CMP                 #jump if chain end (tbblk ptr)} beq xl (xs) gtar6
             gtar6
        MOV  DWORD PTR cnvtp #else save teblk pointer} mov xl cnvtp
#
#      loop to find value down trblk chain
#
gtar4:  MOV                 #load value} mov teval(xl) xl
        CMP  DWORD PTR [],offset b_trt #loop till value found} beq (xl) =b_trt gtar4
             gtar4
        MOV                 #copy value} mov xl wc
        MOV                 #restore teblk pointer} mov cnvtp xl
                            #} ejc
        .eject
#
#      gtarr (continued)
#
#      now check for null and test cases
#
        CMP                 #loop back to ignore null value} beq wc =nulls gtar3
             gtar3
        OR                  #jump if second pass} bnz xr gtar5
        JNZ  gtar5
        INC                 #for the first pass, bump count} icv wb
        JMP  gtar3          #and loop back for next teblk} brn gtar3
#
#      here in second pass
#
gtar5:  CMP  DWORD PTR DWORD PTR gtawa,0 #jump if address wanted} bze gtawa gta5a
        JZ   gta5a
        MOV  EAX,DWORD PTR (4*tesub)[] #store subscript name} mov tesub(xl) (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        MOV  DWORD PTR []   #store value in arblk} mov wc (xr)+
        LEA
        JMP  gtar3          #loop back for next teblk} brn gtar3
#
#      here to record teblk address in arblk.  this allows
#      a sort routine to sort by ascending address.
#
gta5a:  MOV  DWORD PTR []   #store teblk address in name} mov xl (xr)+
        LEA
        MOV  DWORD PTR []   #and value slots} mov xl (xr)+
        LEA
        JMP  gtar3          #loop back for next teblk} brn gtar3
#
#      here after scanning teblks on one chain
#
gtar6:  CMP                 #loop back if more buckets to go} bne wa (xs) gtar2
             gtar2
        OR                  #else jump if second pass} bnz xr gtar7
        JNZ  gtar7
#
#      here after counting non-null elements
#
        OR                  #fail if no non-null elements} bze wb gtar9
        JZ   gtar9
        MOV                 #else copy count} mov wb wa
        ADD                 #double (two words/element)} add wb wa
        ADD                 #add space for standard fields} add =arvl2 wa
        SAL                 #convert length to bytes} wtb wa
        CMP                 #error if too long for array} bgt wa mxlen gta9b
             gta9b
        CALL alloc          #else allocate space for arblk} jsr alloc
        MOV  DWORD PTR [],offset b_art #store type word} mov =b_art (xr)
        XOR  EAX,EAX        #zero id for the moment} zer idval(xr)
        MOV  DWORD PTR (4*idval)[],EAX
        MOV  DWORD PTR (4*arlen)[] #store length} mov wa arlen(xr)
        MOV  DWORD PTR (4*arndm)[],num02 #set dimensions = 2} mov =num02 arndm(xr)
        MOV  EDX,DWORD PTR intv1 #get integer one} ldi intv1
        MOV  DWORD PTR (4*arlbd)[],EDX #store as lbd 1} sti arlbd(xr)
        MOV  DWORD PTR (4*arlb2)[],EDX #store as lbd 2} sti arlb2(xr)
        MOV  EDX,DWORD PTR intv2 #load integer two} ldi intv2
        MOV  DWORD PTR (4*ardm2)[],EDX #store as dim 2} sti ardm2(xr)
        MOV  EDX            #get element count as integer} mti wb
        MOV  DWORD PTR (4*ardim)[],EDX #store as dim 1} sti ardim(xr)
        XOR  EAX,EAX        #zero prototype field for now} zer arpr2(xr)
        MOV  DWORD PTR (4*arpr2)[],EAX
        MOV  DWORD PTR (4*arofs)[],4*arpr2 #set offset field (signal pass 2)} mov *arpr2 arofs(xr)
        MOV                 #save arblk pointer} mov xr wb
        ADD                 #point to first element location} add *arvl2 xr
        JMP  gtar1          #jump back to fill in elements} brn gtar1
                            #} ejc
        .eject
#
#      gtarr (continued)
#
#      here after filling in element values
#
gtar7:  MOV                 #restore arblk pointer} mov wb xr
        MOV  DWORD PTR []   #store as result} mov wb (xs)
#
#      now we need the array prototype which is of the form nn,2
#      this is obtained by building the string for nn02 and
#      changing the zero to a comma before storing it.
#
        MOV  EDX,DWORD PTR (4*ardim)[] #get number of elements (nn)} ldi ardim(xr)
        IMUL EDX,DWORD PTR intvh #multiply by 100} mli intvh
        ADD  EDX,DWORD PTR intv2 #add 2 (nn02)} adi intv2
        CALL icbld          #build integer} jsr icbld
        LEA                 #store ptr for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert to string} jsr gtstg
        .short ERR_-299-DFFNC #convert fail is impossible} ppm
        MOV                 #copy string pointer} mov xr xl
        MOV                 #reload arblk pointer} mov (xs)+ xr
        LEA
        MOV  DWORD PTR (4*arpr2)[] #store prototype ptr (nn02)} mov xl arpr2(xr)
        SUB                 #adjust length to point to zero} sub =num02 wa
        LEA                 #point to zero} psc xl wa
        MOV                 #load a comma} mov =ch_cm wb
        MOV  [ESI],=ch_cm   #store a comma over the zero} sch wb (xl)
#
#      normal return
#
gtar8:  POP  EAX            #return to caller} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      null table non-conversion return
#
gtar9:  MOV                 #restore stack for conv err (sgd02)} mov (xs)+ xr
        LEA
        POP  EAX            #return} exi 1
        JMP  EXI__1
#
#      impossible conversion return
#
gta9a:  POP  EAX            #return} exi 2
        JMP  EXI__2
#
#      array size too large
#
gta9b:  CALL ERR_1          #} erb 260 conversion array size exceeds maximum permitted
        .byte 4
                            #procedure gtarr} enp
                            #} ejc
        .eject
#
#      gtcod -- convert to code
#
#      (xr)                  object to be converted
#      jsr  gtcod            call to convert to code
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to resulting cdblk
#      (xl,wa,wb,wc,ra)      destroyed
#
#      if a spitbol error occurs during compilation or pre-
#      evaluation, control is passed via error section to exfal
#      without returning to this routine.
#
gtcod:                      #entry point} prc e 1
        .global gtcod
        CMP  DWORD PTR [],offset b_cds #jump if already code} beq (xr) =b_cds gtcd1
             gtcd1
        CMP  DWORD PTR [],offset b_cdc #jump if already code} beq (xr) =b_cdc gtcd1
             gtcd1
#
#      here we must generate a cdblk by compilation
#
        LEA                 #stack argument for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert argument to string} jsr gtstg
        .short gtcd2-DFFNC  #jump if non-convertible} ppm gtcd2
        MOV  EAX,DWORD PTR flptr #save fail ptr in case of error} mov flptr gtcef
        MOV  DWORD PTR gtcef,EAX
        MOV  EAX,DWORD PTR r_cod #also save code ptr} mov r_cod r_gtc
        MOV  DWORD PTR r_gtc,EAX
        MOV  DWORD PTR r_cim #else set image pointer} mov xr r_cim
        MOV  DWORD PTR scnil #set image length} mov wa scnil
        XOR  EAX,EAX        #set scan pointer} zer scnpt
        MOV  DWORD PTR scnpt,EAX
        MOV  DWORD PTR stage,stgxc #set stage for execute compile} mov =stgxc stage
        MOV  EAX,DWORD PTR cmpsn #in case listr called} mov cmpsn lstsn
        MOV  DWORD PTR lstsn,EAX
        INC  DWORD PTR cmpln #bump line number} icv cmpln
        CALL cmpil          #compile string} jsr cmpil
        MOV  DWORD PTR stage,stgxt #reset stage for execute time} mov =stgxt stage
        XOR  EAX,EAX        #clear image} zer r_cim
        MOV  DWORD PTR r_cim,EAX
#
#      merge here if no convert required
#
gtcd1:  POP  EAX            #give normal gtcod return} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here if unconvertible
#
gtcd2:  POP  EAX            #give error return} exi 1
        JMP  EXI__1
                            #end procedure gtcod} enp
                            #} ejc
        .eject
#
#      gtexp -- convert to expression
#
#      (wb)                  0 if by value, 1 if by name
#      (xr)                  input value to be converted
#      jsr  gtexp            call to convert to expression
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to result exblk or seblk
#      (xl,wa,wb,wc,ra)      destroyed
#
#      if a spitbol error occurs during compilation or pre-
#      evaluation, control is passed via error section to exfal
#      without returning to this routine.
#
gtexp:                      #entry point} prc e 1
        .global gtexp
        CMP  DWORD PTR [],offset b_e__ #jump if already an expression} blo (xr) =b_e__ gtex1
             gtex1
        LEA                 #store argument for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert argument to string} jsr gtstg
        .short gtex2-DFFNC  #jump if unconvertible} ppm gtex2
#
#      check the last character of the string for colon or
#      semicolon.  these characters can legitimately end an
#      expression in open code, so expan will not detect them
#      as errors, but they are invalid as terminators for a
#      string that is being converted to expression form.
#
        MOV                 #copy input string pointer} mov xr xl
        LEA                 #point one past the string end} plc xl wa
        DEC                 #fetch the last character} lch xl -(xl)
        MOVZX
        CMP                 #error if it is a semicolon} beq xl =ch_cl gtex2
             gtex2
        CMP                 #or if it is a colon} beq xl =ch_sm gtex2
             gtex2
#
#      here we convert a string by compilation
#
        MOV  DWORD PTR r_cim #set input image pointer} mov xr r_cim
        XOR  EAX,EAX        #set scan pointer} zer scnpt
        MOV  DWORD PTR scnpt,EAX
        MOV  DWORD PTR scnil #set input image length} mov wa scnil
        LEA                 #save value/name flag} mov wb -(xs)
        MOV  DWORD PTR []
        XOR                 #set code for normal scan} zer wb
        MOV  EAX,DWORD PTR flptr #save fail ptr in case of error} mov flptr gtcef
        MOV  DWORD PTR gtcef,EAX
        MOV  EAX,DWORD PTR r_cod #also save code ptr} mov r_cod r_gtc
        MOV  DWORD PTR r_gtc,EAX
        MOV  DWORD PTR stage,stgev #adjust stage for compile} mov =stgev stage
        MOV  DWORD PTR scntp,t_uok #indicate unary operator acceptable} mov =t_uok scntp
        CALL expan          #build tree for expression} jsr expan
        XOR  EAX,EAX        #reset rescan flag} zer scnrs
        MOV  DWORD PTR scnrs,EAX
        MOV                 #restore value/name flag} mov (xs)+ wa
        LEA
        MOV  EAX,DWORD PTR scnpt #error if not end of image} bne scnpt scnil gtex2
        CMP  EAX,DWORD PTR scnil
             gtex2
        XOR                 #set ok value for cdgex call} zer wb
        MOV                 #copy tree pointer} mov xr xl
        CALL cdgex          #build expression block} jsr cdgex
        XOR  EAX,EAX        #clear pointer} zer r_cim
        MOV  DWORD PTR r_cim,EAX
        MOV  DWORD PTR stage,stgxt #restore stage for execute time} mov =stgxt stage
#
#      merge here if no conversion required
#
gtex1:  POP  EAX            #return to gtexp caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here if unconvertible
#
gtex2:  POP  EAX            #take error exit} exi 1
        JMP  EXI__1
                            #end procedure gtexp} enp
                            #} ejc
        .eject
#
#      gtint -- get integer value
#
#      gtint is passed an object and returns an integer after
#      performing any necessary conversions.
#
#      (xr)                  value to be converted
#      jsr  gtint            call to convert to integer
#      ppm  loc              transfer loc for convert impossible
#      (xr)                  resulting integer
#      (wc,ra)               destroyed
#      (wa,wb)               destroyed (only on conversion err)
#      (xr)                  unchanged (on convert error)
#
gtint:                      #entry point} prc e 1
        .global gtint
        CMP  DWORD PTR [],offset b_icl #jump if already an integer} beq (xr) =b_icl gtin2
             gtin2
        MOV  DWORD PTR gtina #else save wa} mov wa gtina
        MOV  DWORD PTR gtinb #save wb} mov wb gtinb
        CALL gtnum          #convert to numeric} jsr gtnum
        .short gtin3-DFFNC  #jump if unconvertible} ppm gtin3
        CMP                 #jump if integer} beq wa =b_icl gtin1
             gtin1
#
#      here we convert a real to integer
#
        LEA  EAX,DWORD PTR (4*rcval)[] #load real value} ldr rcval(xr)
        CALL ldr_
        CALL RTI_           #convert to integer (err if ovflow)} rti gtin3
        JC   gtin3
        CALL icbld          #if ok build icblk} jsr icbld
#
#      here after successful conversion to integer
#
gtin1:  MOV                 #restore wa} mov gtina wa
        MOV                 #restore wb} mov gtinb wb
#
#      common exit point
#
gtin2:  POP  EAX            #return to gtint caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here on conversion error
#
gtin3:  POP  EAX            #take convert error exit} exi 1
        JMP  EXI__1
                            #end procedure gtint} enp
                            #} ejc
        .eject
#
#      gtnum -- get numeric value
#
#      gtnum is given an object and returns either an integer
#      or a real, performing any necessary conversions.
#
#      (xr)                  object to be converted
#      jsr  gtnum            call to convert to numeric
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to result (int or real)
#      (wa)                  first word of result block
#      (wb,wc,ra)            destroyed
#      (xr)                  unchanged (on convert error)
#
gtnum:                      #entry point} prc e 1
        .global gtnum
        MOV                 #load first word of block} mov (xr) wa
        CMP                 #jump if integer (no conversion)} beq wa =b_icl gtn34
             gtn34
        CMP                 #jump if real (no conversion)} beq wa =b_rcl gtn34
             gtn34
#
#      at this point the only possibility is to convert a string
#      to an integer or real as appropriate.
#
        LEA                 #stack argument in case convert err} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack argument for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert argument to string} jsr gtstg
        .short gtn36-DFFNC  #jump if unconvertible} ppm gtn36
#
#      initialize numeric conversion
#
        MOV  EDX,DWORD PTR intv0 #initialize integer result to zero} ldi intv0
        OR                  #jump to exit with zero if null} bze wa gtn32
        JZ   gtn32
        XOR  EAX,EAX        #tentatively indicate result +} zer gtnnf
        MOV  DWORD PTR gtnnf,EAX
        MOV  DWORD PTR gtnex,EDX #initialise exponent to zero} sti gtnex
        XOR  EAX,EAX        #zero scale in case real} zer gtnsc
        MOV  DWORD PTR gtnsc,EAX
        XOR  EAX,EAX        #reset flag for dec point found} zer gtndf
        MOV  DWORD PTR gtndf,EAX
        XOR  EAX,EAX        #reset flag for digits found} zer gtnrd
        MOV  DWORD PTR gtnrd,EAX
        MOV  EAX,offset DWORD PTR reav0 #zero real accum in case real} ldr reav0
        CALL ldr_
        ADD                 #point to argument characters} plc xr
#
#      merge back here after ignoring leading blank
#
gtn01:  MOVZX               #load first character} lch wb (xr)+
        INC
        CMP                 #jump if not digit} blt wb =ch_d0 gtn02
             gtn02
        CMP                 #jump if first char is a digit} ble wb =ch_d9 gtn06
             gtn06
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here if first digit is non-digit
#
gtn02:  CMP                 #jump if non-blank} bne wb =ch_bl gtn03
             gtn03
gtna2:  DEC                 #else decr count and loop back} bct wa gtn01
        JNZ  gtn01
        JMP  gtn07          #jump to return zero if all blanks} brn gtn07
#
#      here for first character non-blank, non-digit
#
gtn03:  CMP                 #jump if plus sign} beq wb =ch_pl gtn04
             gtn04
        CMP                 #horizontal tab equiv to blank} beq wb =ch_ht gtna2
             gtna2
        CMP                 #jump if not minus (may be real)} bne wb =ch_mn gtn12
             gtn12
        MOV  DWORD PTR gtnnf,ESP #if minus sign, set negative flag} mnz gtnnf
#
#      merge here after processing sign
#
gtn04:  DEC                 #jump if chars left} bct wa gtn05
        JNZ  gtn05
        JMP  gtn36          #else error} brn gtn36
#
#      loop to fetch characters of an integer
#
gtn05:  MOVZX               #load next character} lch wb (xr)+
        INC
        CMP                 #jump if not a digit} blt wb =ch_d0 gtn08
             gtn08
        CMP                 #jump if not a digit} bgt wb =ch_d9 gtn08
             gtn08
#
#      merge here for first digit
#
gtn06:  MOV  DWORD PTR gtnsi,EDX #save current value} sti gtnsi
        IMUL EDX,10         #current*10-(new dig) jump if ovflow} cvm gtn35
        JO   gtn35
        SUB  EBX,CH_D0
        SUB  EDX,EBX
        JO   gtn35
        MOV  DWORD PTR gtnrd,ESP #set digit read flag} mnz gtnrd
        DEC                 #else loop back if more chars} bct wa gtn05
        JNZ  gtn05
#
#      here to exit with converted integer value
#
gtn07:  CMP  DWORD PTR DWORD PTR gtnnf,0 #jump if negative (all set)} bnz gtnnf gtn32
        JNZ  gtn32
        NEG  EDX            #else negate} ngi
        JNO  gtn32          #jump if no overflow} ino gtn32
        JMP  gtn36          #else signal error} brn gtn36
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here for a non-digit character while attempting to
#      convert an integer, check for trailing blanks or real.
#
gtn08:  CMP                 #jump if a blank} beq wb =ch_bl gtna9
             gtna9
        CMP                 #jump if horizontal tab} beq wb =ch_ht gtna9
             gtna9
        CALL ITR_           #else convert integer to real} itr
        CALL ngr_           #negate to get positive value} ngr
        JMP  gtn12          #jump to try for real} brn gtn12
#
#      here we scan out blanks to end of string
#
gtn09:  MOVZX               #get next char} lch wb (xr)+
        INC
        CMP                 #jump if horizontal tab} beq wb =ch_ht gtna9
             gtna9
        CMP                 #error if non-blank} bne wb =ch_bl gtn36
             gtn36
gtna9:  DEC                 #loop back if more chars to check} bct wa gtn09
        JNZ  gtn09
        JMP  gtn07          #return integer if all blanks} brn gtn07
#
#      loop to collect mantissa of real
#
gtn10:  MOVZX               #load next character} lch wb (xr)+
        INC
        CMP                 #jump if non-numeric} blt wb =ch_d0 gtn12
             gtn12
        CMP                 #jump if non-numeric} bgt wb =ch_d9 gtn12
             gtn12
#
#      merge here to collect first real digit
#
gtn11:  SUB                 #convert digit to number} sub =ch_d0 wb
        MOV  EAX,offset DWORD PTR reavt #multiply real by 10.0} mlr reavt
        CALL mlr_
        CALL OVR_           #convert error if overflow} rov gtn36
        JO   gtn36
        MOV  EAX,offset DWORD PTR gtnsr #save result} str gtnsr
        CALL str_
        MOV  EDX            #get new digit as integer} mti wb
        CALL ITR_           #convert new digit to real} itr
        MOV  EAX,offset DWORD PTR gtnsr #add to get new total} adr gtnsr
        CALL adr_
        MOV  EAX,DWORD PTR gtndf #increment scale if after dec point} add gtndf gtnsc
        ADD  DWORD PTR gtnsc,EAX
        MOV  DWORD PTR gtnrd,ESP #set digit found flag} mnz gtnrd
        DEC                 #loop back if more chars} bct wa gtn10
        JNZ  gtn10
        JMP  gtn22          #else jump to scale} brn gtn22
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here if non-digit found while collecting a real
#
gtn12:  CMP                 #jump if not dec point} bne wb =ch_dt gtn13
             gtn13
        CMP  DWORD PTR DWORD PTR gtndf,0 #if dec point, error if one already} bnz gtndf gtn36
        JNZ  gtn36
        MOV  DWORD PTR gtndf,num01 #else set flag for dec point} mov =num01 gtndf
        DEC                 #loop back if more chars} bct wa gtn10
        JNZ  gtn10
        JMP  gtn22          #else jump to scale} brn gtn22
#
#      here if not decimal point
#
gtn13:  CMP                 #jump if e for exponent} beq wb =ch_le gtn15
             gtn15
        CMP                 #jump if d for exponent} beq wb =ch_ld gtn15
             gtn15
        CMP                 #jump if e for exponent} beq wb =ch__e gtn15
             gtn15
        CMP                 #jump if d for exponent} beq wb =ch__d gtn15
             gtn15
#
#      here check for trailing blanks
#
gtn14:  CMP                 #jump if blank} beq wb =ch_bl gtnb4
             gtnb4
        CMP                 #jump if horizontal tab} beq wb =ch_ht gtnb4
             gtnb4
        JMP  gtn36          #error if non-blank} brn gtn36
#
gtnb4:  MOVZX               #get next character} lch wb (xr)+
        INC
        DEC                 #loop back to check if more} bct wa gtn14
        JNZ  gtn14
        JMP  gtn22          #else jump to scale} brn gtn22
#
#      here to read and process an exponent
#
gtn15:  XOR  EAX,EAX        #set exponent sign positive} zer gtnes
        MOV  DWORD PTR gtnes,EAX
        MOV  EDX,DWORD PTR intv0 #initialize exponent to zero} ldi intv0
        MOV  DWORD PTR gtndf,ESP #reset no dec point indication} mnz gtndf
        DEC                 #jump skipping past e or d} bct wa gtn16
        JNZ  gtn16
        JMP  gtn36          #error if null exponent} brn gtn36
#
#      check for exponent sign
#
gtn16:  MOVZX               #load first exponent character} lch wb (xr)+
        INC
        CMP                 #jump if plus sign} beq wb =ch_pl gtn17
             gtn17
        CMP                 #else jump if not minus sign} bne wb =ch_mn gtn19
             gtn19
        MOV  DWORD PTR gtnes,ESP #set sign negative if minus sign} mnz gtnes
#
#      merge here after processing exponent sign
#
gtn17:  DEC                 #jump if chars left} bct wa gtn18
        JNZ  gtn18
        JMP  gtn36          #else error} brn gtn36
#
#      loop to convert exponent digits
#
gtn18:  MOVZX               #load next character} lch wb (xr)+
        INC
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      merge here for first exponent digit
#
gtn19:  CMP                 #jump if not digit} blt wb =ch_d0 gtn20
             gtn20
        CMP                 #jump if not digit} bgt wb =ch_d9 gtn20
             gtn20
        IMUL EDX,10         #else current*10, subtract new digit} cvm gtn36
        JO   gtn36
        SUB  EBX,CH_D0
        SUB  EDX,EBX
        JO   gtn36
        DEC                 #loop back if more chars} bct wa gtn18
        JNZ  gtn18
        JMP  gtn21          #jump if exponent field is exhausted} brn gtn21
#
#      here to check for trailing blanks after exponent
#
gtn20:  CMP                 #jump if blank} beq wb =ch_bl gtnc0
             gtnc0
        CMP                 #jump if horizontal tab} beq wb =ch_ht gtnc0
             gtnc0
        JMP  gtn36          #error if non-blank} brn gtn36
#
gtnc0:  MOVZX               #get next character} lch wb (xr)+
        INC
        DEC                 #loop back till all blanks scanned} bct wa gtn20
        JNZ  gtn20
#
#      merge here after collecting exponent
#
gtn21:  MOV  DWORD PTR gtnex,EDX #save collected exponent} sti gtnex
        CMP  DWORD PTR DWORD PTR gtnes,0 #jump if it was negative} bnz gtnes gtn22
        JNZ  gtn22
        NEG  EDX            #else complement} ngi
        JO   gtn36          #error if overflow} iov gtn36
        MOV  DWORD PTR gtnex,EDX #and store positive exponent} sti gtnex
#
#      merge here with exponent (0 if none given)
#
gtn22:  CMP  DWORD PTR DWORD PTR gtnrd,0 #error if not digits collected} bze gtnrd gtn36
        JZ   gtn36
        CMP  DWORD PTR DWORD PTR gtndf,0 #error if no exponent or dec point} bze gtndf gtn36
        JZ   gtn36
        MOV  EDX,DWORD PTR gtnsc #else load scale as integer} mti gtnsc
        SUB  EDX,DWORD PTR gtnex #subtract exponent} sbi gtnex
        JO   gtn36          #error if overflow} iov gtn36
        OR   EDX,EDX        #jump if we must scale up} ilt gtn26
        JL   gtn26
#
#      here we have a negative exponent, so scale down
#
        OR   EDX,EDX        #load scale factor, err if ovflow} mfi wa gtn36
        JS   gtn36
        MOV
#
#      loop to scale down in steps of 10**10
#
gtn23:  CMP                 #jump if 10 or less to go} ble wa =num10 gtn24
             gtn24
        MOV  EAX,offset DWORD PTR reatt #else divide by 10**10} dvr reatt
        CALL dvr_
        SUB                 #decrement scale} sub =num10 wa
        JMP  gtn23          #and loop back} brn gtn23
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here scale rest of way from powers of ten table
#
gtn24:  OR                  #jump if scaled} bze wa gtn30
        JZ   gtn30
        MOV                 #else get indexing factor} lct wb =cfp_r
        MOV                 #point to powers of ten table} mov =reav1 xr
        SAL                 #convert remaining scale to byte ofs} wtb wa
#
#      loop to point to powers of ten table entry
#
gtn25:  ADD                 #bump pointer} add wa xr
        DEC                 #once for each value word} bct wb gtn25
        JNZ  gtn25
        LEA  EAX,DWORD PTR [] #scale down as required} dvr (xr)
        CALL dvr_
        JMP  gtn30          #and jump} brn gtn30
#
#      come here to scale result up (positive exponent)
#
gtn26:  NEG  EDX            #get absolute value of exponent} ngi
        JO   gtn36          #error if overflow} iov gtn36
        OR   EDX,EDX        #acquire scale, error if ovflow} mfi wa gtn36
        JS   gtn36
        MOV
#
#      loop to scale up in steps of 10**10
#
gtn27:  CMP                 #jump if 10 or less to go} ble wa =num10 gtn28
             gtn28
        MOV  EAX,offset DWORD PTR reatt #else multiply by 10**10} mlr reatt
        CALL mlr_
        CALL OVR_           #error if overflow} rov gtn36
        JO   gtn36
        SUB                 #else decrement scale} sub =num10 wa
        JMP  gtn27          #and loop back} brn gtn27
#
#      here to scale up rest of way with table
#
gtn28:  OR                  #jump if scaled} bze wa gtn30
        JZ   gtn30
        MOV                 #else get indexing factor} lct wb =cfp_r
        MOV                 #point to powers of ten table} mov =reav1 xr
        SAL                 #convert remaining scale to byte ofs} wtb wa
#
#      loop to point to proper entry in powers of ten table
#
gtn29:  ADD                 #bump pointer} add wa xr
        DEC                 #once for each word in value} bct wb gtn29
        JNZ  gtn29
        LEA  EAX,DWORD PTR [] #scale up} mlr (xr)
        CALL mlr_
        CALL OVR_           #error if overflow} rov gtn36
        JO   gtn36
                            #} ejc
        .eject
#
#      gtnum (continued)
#
#      here with real value scaled and ready except for sign
#
gtn30:  CMP  DWORD PTR DWORD PTR gtnnf,0 #jump if positive} bze gtnnf gtn31
        JZ   gtn31
        CALL ngr_           #else negate} ngr
#
#      here with properly signed real value in (ra)
#
gtn31:  CALL rcbld          #build real block} jsr rcbld
        JMP  gtn33          #merge to exit} brn gtn33
#
#      here with properly signed integer value in (ia)
#
gtn32:  CALL icbld          #build icblk} jsr icbld
#
#      real merges here
#
gtn33:  MOV                 #load first word of result block} mov (xr) wa
        ADD                 #pop argument off stack} ica xs
#
#      common exit point
#
gtn34:  POP  EAX            #return to gtnum caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      come here if overflow occurs during collection of integer
#      have to restore wb which cvm may have destroyed.
#
gtn35:  DEC                 #reload current character} lch wb -(xr)
        MOVZX
        MOVZX               #bump character pointer} lch wb (xr)+
        INC
        MOV  EDX,DWORD PTR gtnsi #reload integer so far} ldi gtnsi
        CALL ITR_           #convert to real} itr
        CALL ngr_           #make value positive} ngr
        JMP  gtn11          #merge with real circuit} brn gtn11
#
#      here for unconvertible to string or conversion error
#
gtn36:  MOV                 #reload original argument} mov (xs)+ xr
        LEA
        POP  EAX            #take convert-error exit} exi 1
        JMP  EXI__1
                            #end procedure gtnum} enp
                            #} ejc
        .eject
#
#      gtnvr -- convert to natural variable
#
#      gtnvr locates a variable block (vrblk) given either an
#      appropriate name (nmblk) or a non-null string (scblk).
#
#      (xr)                  argument
#      jsr  gtnvr            call to convert to natural variable
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to vrblk
#      (wa,wb)               destroyed (conversion error only)
#      (wc)                  destroyed
#
gtnvr:                      #entry point} prc e 1
        .global gtnvr
        CMP  DWORD PTR [],offset b_nml #jump if not name} bne (xr) =b_nml gnv02
             gnv02
        MOV                 #else load name base if name} mov nmbas(xr) xr
        CMP                 #skip if vrblk (in static region)} blo xr state gnv07
             gnv07
#
#      common error exit
#
gnv01:  POP  EAX            #take convert-error exit} exi 1
        JMP  EXI__1
#
#      here if not name
#
gnv02:  MOV  DWORD PTR gnvsa #save wa} mov wa gnvsa
        MOV  DWORD PTR gnvsb #save wb} mov wb gnvsb
        LEA                 #stack argument for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert argument to string} jsr gtstg
        .short gnv01-DFFNC  #jump if conversion error} ppm gnv01
        OR                  #null string is an error} bze wa gnv01
        JZ   gnv01
        CALL flstg          #fold lower case to upper case} jsr flstg
        LEA                 #save xl} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #stack string ptr for later} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #copy string pointer} mov xr wb
        ADD                 #point to characters of string} add *schar wb
        MOV  DWORD PTR gnvst #save pointer to characters} mov wb gnvst
        MOV                 #copy length} mov wa wb
        ADD                 #get number of words in name} ctw wb 0
        SHR
        MOV  DWORD PTR gnvnw #save for later} mov wb gnvnw
        CALL hashs          #compute hash index for string} jsr hashs
        MOV  EAX,DWORD PTR hshnb #compute hash offset by taking mod} rmi hshnb
        CALL rmi_
        MOV                 #get as offset} mfi wc
        SAL                 #convert offset to bytes} wtb wc
        ADD                 #point to proper hash chain} add hshtb wc
        SUB                 #subtract offset to merge into loop} sub *vrnxt wc
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      loop to search hash chain
#
gnv03:  MOV                 #copy hash chain pointer} mov wc xl
        MOV                 #point to next vrblk on chain} mov vrnxt(xl) xl
        OR                  #jump if end of chain} bze xl gnv08
        JZ   gnv08
        MOV                 #save pointer to this vrblk} mov xl wc
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #jump if not system variable} bnz vrlen(xl) gnv04
        JNZ  gnv04
        MOV                 #else point to svblk} mov vrsvp(xl) xl
        SUB                 #adjust offset for merge} sub *vrsof xl
#
#      merge here with string ptr (like vrblk) in xl
#
gnv04:  CMP                 #back for next vrblk if lengths ne} bne wa vrlen(xl) gnv03
             gnv03
        ADD                 #else point to chars of chain entry} add *vrchs xl
        MOV                 #get word counter to control loop} lct wb gnvnw
        MOV                 #point to chars of new name} mov gnvst xr
#
#      loop to compare characters of the two names
#
gnv05:  MOV  EAX,DWORD PTR [] #jump if no match for next vrblk} cne (xr) (xl) gnv03
        CMP  EAX,DWORD PTR []
        JNZ  gnv03
        ADD                 #bump new name pointer} ica xr
        ADD                 #bump vrblk in chain name pointer} ica xl
        DEC                 #else loop till all compared} bct wb gnv05
        JNZ  gnv05
        MOV                 #we have found a match, get vrblk} mov wc xr
#
#      exit point after finding vrblk or building new one
#
gnv06:  MOV                 #restore wa} mov gnvsa wa
        MOV                 #restore wb} mov gnvsb wb
        ADD                 #pop string pointer} ica xs
        MOV                 #restore xl} mov (xs)+ xl
        LEA
#
#      common exit point
#
gnv07:  POP  EAX            #return to gtnvr caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      not found, prepare to search system variable table
#
gnv08:  XOR                 #clear garbage xr pointer} zer xr
        MOV  DWORD PTR gnvhe #save ptr to end of hash chain} mov wc gnvhe
        CMP                 #cannot be system var if length gt 9} bgt wa =num09 gnv14
             gnv14
        MOV                 #else copy length} mov wa xl
        SAL                 #convert to byte offset} wtb xl
        MOV                 #point to first svblk of this length} mov vsrch(xl) xl
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      loop to search entries in standard variable table
#
gnv09:  MOV  DWORD PTR gnvsp #save table pointer} mov xl gnvsp
        MOV                 #load svbit bit string} mov (xl)+ wc
        LEA
        MOV                 #load length from table entry} mov (xl)+ wb
        LEA
        CMP                 #jump if end of right length entries} bne wa wb gnv14
             gnv14
        MOV                 #get word counter to control loop} lct wb gnvnw
        MOV                 #point to chars of new name} mov gnvst xr
#
#      loop to check for matching names
#
gnv10:  MOV  EAX,DWORD PTR [] #jump if name mismatch} cne (xr) (xl) gnv11
        CMP  EAX,DWORD PTR []
        JNZ  gnv11
        ADD                 #else bump new name pointer} ica xr
        ADD                 #bump svblk pointer} ica xl
        DEC                 #else loop until all checked} bct wb gnv10
        JNZ  gnv10
#
#      here we have a match in the standard variable table
#
        XOR                 #set vrlen value zero} zer wc
        MOV                 #set standard size} mov *vrsi_ wa
        JMP  gnv15          #jump to build vrblk} brn gnv15
#
#      here if no match with table entry in svblks table
#
gnv11:  ADD                 #bump past word of chars} ica xl
        DEC                 #loop back if more to go} bct wb gnv11
        JNZ  gnv11
        SHR                 #remove uninteresting bits} rsh wc svnbt
#
#      loop to bump table ptr for each flagged word
#
gnv12:  MOV                 #load bit to test} mov bits1 wb
        AND                 #test for word present} anb wc wb
#        OR                  #jump if not present} zrb wb gnv13  (Optimized)
        JZ   gnv13
        ADD                 #else bump table pointer} ica xl
#
#      here after dealing with one word (one bit)
#
gnv13:  SHR                 #remove bit already processed} rsh wc 1
#        OR                  #loop back if more bits to test} nzb wc gnv12  (Optimized)
        JNZ  gnv12
        JMP  gnv09          #else loop back for next svblk} brn gnv09
#
#      here if not system variable
#
gnv14:  MOV                 #copy vrlen value} mov wa wc
        MOV                 #load standard size -chars} mov =vrchs wa
        ADD                 #adjust for chars of name} add gnvnw wa
        SAL                 #convert length to bytes} wtb wa
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      merge here to build vrblk
#
gnv15:  CALL alost          #allocate space for vrblk (static)} jsr alost
        MOV                 #save vrblk pointer} mov xr wb
        MOV                 #point to model variable block} mov =stnvr xl
        MOV                 #set length of standard fields} mov *vrlen wa
        SHR  ECX,2          #set initial fields of new block} mvw
        REP  MOVSD
        MOV                 #load pointer to end of hash chain} mov gnvhe xl
        MOV  DWORD PTR (4*vrnxt)[] #add new block to end of chain} mov wb vrnxt(xl)
        MOV  DWORD PTR []   #set vrlen field, bump ptr} mov wc (xr)+
        LEA
        MOV                 #get length in words} mov gnvnw wa
        SAL                 #convert to length in bytes} wtb wa
        OR                  #jump if system variable} bze wc gnv16
        JZ   gnv16
#
#      here for non-system variable -- set chars of name
#
        MOV                 #point back to string name} mov (xs) xl
        ADD                 #point to chars of name} add *schar xl
        SHR  ECX,2          #move characters into place} mvw
        REP  MOVSD
        MOV                 #restore vrblk pointer} mov wb xr
        JMP  gnv06          #jump back to exit} brn gnv06
#
#      here for system variable case to fill in fields where
#      necessary from the fields present in the svblk.
#
gnv16:  MOV                 #load pointer to svblk} mov gnvsp xl
        MOV  DWORD PTR []   #set svblk ptr in vrblk} mov xl (xr)
        MOV                 #restore vrblk pointer} mov wb xr
        MOV                 #load bit indicators} mov svbit(xl) wb
        ADD                 #point to characters of name} add *svchs xl
        ADD                 #point past characters} add wa xl
#
#      skip past keyword number (svknm) if present
#
        MOV                 #load test bit} mov btknm wc
        AND                 #and to test} anb wb wc
#        OR                  #jump if no keyword number} zrb wc gnv17  (Optimized)
        JZ   gnv17
        ADD                 #else bump pointer} ica xl
                            #} ejc
        .eject
#
#      gtnvr (continued)
#
#      here test for function (svfnc and svnar)
#
gnv17:  MOV                 #get test bit} mov btfnc wc
        AND                 #and to test} anb wb wc
#        OR                  #skip if no system function} zrb wc gnv18  (Optimized)
        JZ   gnv18
        MOV  DWORD PTR (4*vrfnc)[] #else point vrfnc to svfnc field} mov xl vrfnc(xr)
        ADD                 #and bump past svfnc, svnar fields} add *num02 xl
#
#      now test for label (svlbl)
#
gnv18:  MOV                 #get test bit} mov btlbl wc
        AND                 #and to test} anb wb wc
#        OR                  #jump if bit is off (no system labl)} zrb wc gnv19  (Optimized)
        JZ   gnv19
        MOV  DWORD PTR (4*vrlbl)[] #else point vrlbl to svlbl field} mov xl vrlbl(xr)
        ADD                 #bump past svlbl field} ica xl
#
#      now test for value (svval)
#
gnv19:  MOV                 #load test bit} mov btval wc
        AND                 #and to test} anb wb wc
#        OR                  #all done if no value} zrb wc gnv06  (Optimized)
        JZ   gnv06
        MOV  EAX,DWORD PTR [] #else set initial value} mov (xl) vrval(xr)
        MOV  DWORD PTR (4*vrval)[],EAX
        MOV  DWORD PTR (4*vrsto)[],offset b_vre #set error store access} mov =b_vre vrsto(xr)
        JMP  gnv06          #merge back to exit to caller} brn gnv06
                            #end procedure gtnvr} enp
                            #} ejc
        .eject
#
#      gtpat -- get pattern
#
#      gtpat is passed an object in (xr) and returns a
#      pattern after performing any necessary conversions
#
#      (xr)                  input argument
#      jsr  gtpat            call to convert to pattern
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  resulting pattern
#      (wa)                  destroyed
#      (wb)                  destroyed (only on convert error)
#      (xr)                  unchanged (only on convert error)
#
gtpat:                      #entry point} prc e 1
        .global gtpat
        CMP  DWORD PTR [],offset p_aaa #jump if pattern already} bhi (xr) =p_aaa gtpt5
             gtpt5
#
#      here if not pattern, try for string
#
        MOV  DWORD PTR gtpsb #save wb} mov wb gtpsb
        LEA                 #stack argument for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert argument to string} jsr gtstg
        .short gtpt2-DFFNC  #jump if impossible} ppm gtpt2
#
#      here we have a string
#
        OR                  #jump if non-null} bnz wa gtpt1
        JNZ  gtpt1
#
#      here for null string. generate pointer to null pattern.
#
        MOV                 #point to nothen node} mov =ndnth xr
        JMP  gtpt4          #jump to exit} brn gtpt4
                            #} ejc
        .eject
#
#      gtpat (continued)
#
#      here for non-null string
#
gtpt1:  MOV                 #load pcode for multi-char string} mov =p_str wb
        CMP                 #jump if multi-char string} bne wa =num01 gtpt3
             gtpt3
#
#      here for one character string, share one character any
#
        ADD                 #point to character} plc xr
        MOVZX               #load character} lch wa (xr)
        MOV                 #set as parm1} mov wa xr
        MOV                 #point to pcode for 1-char any} mov =p_ans wb
        JMP  gtpt3          #jump to build node} brn gtpt3
#
#      here if argument is not convertible to string
#
gtpt2:  MOV                 #set pcode for expression in case} mov =p_exa wb
        CMP  DWORD PTR [],offset b_e__ #jump to build node if expression} blo (xr) =b_e__ gtpt3
             gtpt3
#
#      here we have an error (conversion impossible)
#
        POP  EAX            #take convert error exit} exi 1
        JMP  EXI__1
#
#      merge here to build node for string or expression
#
gtpt3:  CALL pbild          #call routine to build pattern node} jsr pbild
#
#      common exit after successful conversion
#
gtpt4:  MOV                 #restore wb} mov gtpsb wb
#
#      merge here to exit if no conversion required
#
gtpt5:  POP  EAX            #return to gtpat caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
                            #end procedure gtpat} enp
                            #} ejc
        .eject
#
#      gtrea -- get real value
#
#      gtrea is passed an object and returns a real value
#      performing any necessary conversions.
#
#      (xr)                  object to be converted
#      jsr  gtrea            call to convert object to real
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to resulting real
#      (wa,wb,wc,ra)         destroyed
#      (xr)                  unchanged (convert error only)
#
gtrea:                      #entry point} prc e 1
        .global gtrea
        MOV                 #get first word of block} mov (xr) wa
        CMP                 #jump if real} beq wa =b_rcl gtre2
             gtre2
        CALL gtnum          #else convert argument to numeric} jsr gtnum
        .short gtre3-DFFNC  #jump if unconvertible} ppm gtre3
        CMP                 #jump if real was returned} beq wa =b_rcl gtre2
             gtre2
#
#      here for case of an integer to convert to real
#
gtre1:  MOV  EDX,DWORD PTR (4*icval)[] #load integer} ldi icval(xr)
        CALL ITR_           #convert to real} itr
        CALL rcbld          #build rcblk} jsr rcbld
#
#      exit with real
#
gtre2:  POP  EAX            #return to gtrea caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here on conversion error
#
gtre3:  POP  EAX            #take convert error exit} exi 1
        JMP  EXI__1
                            #end procedure gtrea} enp
                            #} ejc
        .eject
#
#      gtsmi -- get small integer
#
#      gtsmi is passed a snobol object and returns an address
#      integer in the range (0 le n le dnamb). such a value can
#      only be derived from an integer in the appropriate range.
#      small integers never appear as snobol values. however,
#      they are used internally for a variety of purposes.
#
#      -(xs)                 argument to convert (on stack)
#      jsr  gtsmi            call to convert to small integer
#      ppm  loc              transfer loc for not integer
#      ppm  loc              transfer loc for lt 0, gt dnamb
#      (xr,wc)               resulting small int (two copies)
#      (xs)                  popped
#      (ra)                  destroyed
#      (wa,wb)               destroyed (on convert error only)
#      (xr)                  input arg (convert error only)
#
gtsmi:                      #entry point} prc n 2
        .global gtsmi
        POP  PRC_+20
        MOV                 #load argument} mov (xs)+ xr
        LEA
        CMP  DWORD PTR [],offset b_icl #skip if already an integer} beq (xr) =b_icl gtsm1
             gtsm1
#
#      here if not an integer
#
        CALL gtint          #convert argument to integer} jsr gtint
        .short gtsm2-DFFNC  #jump if convert is impossible} ppm gtsm2
#
#      merge here with integer
#
gtsm1:  MOV  EDX,DWORD PTR (4*icval)[] #load integer value} ldi icval(xr)
        OR   EDX,EDX        #move as one word, jump if ovflow} mfi wc gtsm3
        JS   gtsm3
        MOV
        CMP                 #or if too large} bgt wc mxlen gtsm3
             gtsm3
        MOV                 #copy result to xr} mov wc xr
        POP  EAX            #return to gtsmi caller} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      here if unconvertible to integer
#
gtsm2:  POP  EAX            #take non-integer error exit} exi 1
        JMP  EXI__1
#
#      here if out of range
#
gtsm3:  POP  EAX            #take out-of-range error exit} exi 2
        JMP  EXI__2
                            #end procedure gtsmi} enp
                            #} ejc
        .eject
#
#      gtstg -- get string
#
#      gtstg is passed an object and returns a string with
#      any necessary conversions performed.
#
#      -(xs)                 input argument (on stack)
#      jsr  gtstg            call to convert to string
#      ppm  loc              transfer loc if convert impossible
#      (xr)                  pointer to resulting string
#      (wa)                  length of string in characters
#      (xs)                  popped
#      (ra)                  destroyed
#      (xr)                  input arg (convert error only)
#
gtstg:                      #entry point} prc n 1
        .global gtstg
        POP  PRC_+24
        MOV                 #load argument, pop stack} mov (xs)+ xr
        LEA
        CMP  DWORD PTR [],offset b_scl #jump if already a string} beq (xr) =b_scl gts30
             gts30
#
#      here if not a string already
#
gts01:  LEA                 #restack argument in case error} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #save xl} mov xl -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR gtsvb #save wb} mov wb gtsvb
        MOV  DWORD PTR gtsvc #save wc} mov wc gtsvc
        MOV                 #load first word of block} mov (xr) wa
        CMP                 #jump to convert integer} beq wa =b_icl gts05
             gts05
        CMP                 #jump to convert real} beq wa =b_rcl gts10
             gts10
        CMP                 #jump to convert name} beq wa =b_nml gts03
             gts03
#
#      here on conversion error
#
gts02:  MOV                 #restore xl} mov (xs)+ xl
        LEA
        MOV                 #reload input argument} mov (xs)+ xr
        LEA
        POP  EAX            #take convert error exit} exi 1
        JMP  EXI__1
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      here to convert a name (only possible if natural var)
#
gts03:  MOV                 #load name base} mov nmbas(xr) xl
        CMP                 #error if not natural var (static)} bhi xl state gts02
             gts02
        ADD                 #else point to possible string name} add *vrsof xl
        MOV                 #load length} mov sclen(xl) wa
        OR                  #jump if not system variable} bnz wa gts04
        JNZ  gts04
        MOV                 #else point to svblk} mov vrsvo(xl) xl
        MOV                 #and load name length} mov svlen(xl) wa
#
#      merge here with string in xr, length in wa
#
gts04:  XOR                 #set offset to zero} zer wb
        CALL sbstr          #use sbstr to copy string} jsr sbstr
        JMP  gts29          #jump to exit} brn gts29
#
#      come here to convert an integer
#
gts05:  MOV  EDX,DWORD PTR (4*icval)[] #load integer value} ldi icval(xr)
        MOV  DWORD PTR gtssf,num01 #set sign flag negative} mov =num01 gtssf
        OR   EDX,EDX        #skip if integer is negative} ilt gts06
        JL   gts06
        NEG  EDX            #else negate integer} ngi
        XOR  EAX,EAX        #and reset negative flag} zer gtssf
        MOV  DWORD PTR gtssf,EAX
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      here with sign flag set and sign forced negative as
#      required by the cvd instruction.
#
gts06:  MOV                 #point to result work area} mov gtswk xr
        MOV                 #initialize counter to max length} mov =nstmx wb
        LEA                 #prepare to store (right-left)} psc xr wb
#
#      loop to convert digits into work area
#
gts07:  CALL CVD_           #convert one digit into wa} cvd
        MOV  [ESI]          #store in work area} sch wa -(xr)
        DEC                 #decrement counter} dcv wb
        OR   EDX,EDX        #loop if more digits to go} ine gts07
        JNE  gts07
#
#      merge here after converting integer or real into work
#      area. wb is set to nstmx - (number of chars in result).
#
gts08:  MOV                 #get max number of characters} mov =nstmx wa
        SUB                 #compute length of result} sub wb wa
        MOV                 #remember length for move later on} mov wa xl
        ADD                 #add one for negative sign if needed} add gtssf wa
        CALL alocs          #allocate string for result} jsr alocs
        MOV                 #save result pointer for the moment} mov xr wc
        ADD                 #point to chars of result block} psc xr
        CMP  DWORD PTR DWORD PTR gtssf,0 #skip if positive} bze gtssf gts09
        JZ   gts09
        MOV                 #else load negative sign} mov =ch_mn wa
        MOV  [ESI],=ch_mn   #and store it} sch wa (xr)+
#
#      here after dealing with sign
#
gts09:  MOV                 #recall length to move} mov xl wa
        MOV                 #point to result work area} mov gtswk xl
        LEA                 #point to first result character} plc xl wb
        SHRD EAX,ECX,1      #move chars to result string} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        MOV                 #restore result pointer} mov wc xr
        JMP  gts29          #jump to exit} brn gts29
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      here to convert a real
#
gts10:  LEA  EAX,DWORD PTR (4*rcval)[] #load real} ldr rcval(xr)
        CALL ldr_
        XOR  EAX,EAX        #reset negative flag} zer gtssf
        MOV  DWORD PTR gtssf,EAX
        CALL CPR_           #skip if zero} req gts31
        JE   gts31
        CALL CPR_           #jump if real is positive} rge gts11
        JGE  gts11
        MOV  DWORD PTR gtssf,num01 #else set negative flag} mov =num01 gtssf
        CALL ngr_           #and get absolute value of real} ngr
#
#      now scale the real to the range (0.1 le x lt 1.0)
#
gts11:  MOV  EDX,DWORD PTR intv0 #initialize exponent to zero} ldi intv0
#
#      loop to scale up in steps of 10**10
#
gts12:  MOV  EAX,offset DWORD PTR gtsrs #save real value} str gtsrs
        CALL str_
        MOV  EAX,offset DWORD PTR reap1 #subtract 0.1 to compare} sbr reap1
        CALL sbr_
        CALL CPR_           #jump if scale up not required} rge gts13
        JGE  gts13
        MOV  EAX,offset DWORD PTR gtsrs #else reload value} ldr gtsrs
        CALL ldr_
        MOV  EAX,offset DWORD PTR reatt #multiply by 10**10} mlr reatt
        CALL mlr_
        SUB  EDX,DWORD PTR intvt #decrement exponent by 10} sbi intvt
        JMP  gts12          #loop back to test again} brn gts12
#
#      test for scale down required
#
gts13:  MOV  EAX,offset DWORD PTR gtsrs #reload value} ldr gtsrs
        CALL ldr_
        MOV  EAX,offset DWORD PTR reav1 #subtract 1.0} sbr reav1
        CALL sbr_
        CALL CPR_           #jump if no scale down required} rlt gts17
        JL   gts17
        MOV  EAX,offset DWORD PTR gtsrs #else reload value} ldr gtsrs
        CALL ldr_
#
#      loop to scale down in steps of 10**10
#
gts14:  MOV  EAX,offset DWORD PTR reatt #subtract 10**10 to compare} sbr reatt
        CALL sbr_
        CALL CPR_           #jump if large step not required} rlt gts15
        JL   gts15
        MOV  EAX,offset DWORD PTR gtsrs #else restore value} ldr gtsrs
        CALL ldr_
        MOV  EAX,offset DWORD PTR reatt #divide by 10**10} dvr reatt
        CALL dvr_
        MOV  EAX,offset DWORD PTR gtsrs #store new value} str gtsrs
        CALL str_
        ADD  EDX,DWORD PTR intvt #increment exponent by 10} adi intvt
        JMP  gts14          #loop back} brn gts14
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      at this point we have (1.0 le x lt 10**10)
#      complete scaling with powers of ten table
#
gts15:  MOV                 #point to powers of ten table} mov =reav1 xr
#
#      loop to locate correct entry in table
#
gts16:  MOV  EAX,offset DWORD PTR gtsrs #reload value} ldr gtsrs
        CALL ldr_
        ADD  EDX,DWORD PTR intv1 #increment exponent} adi intv1
        ADD                 #point to next entry in table} add *cfp_r xr
        LEA  EAX,DWORD PTR [] #subtract it to compare} sbr (xr)
        CALL sbr_
        CALL CPR_           #loop till we find a larger entry} rge gts16
        JGE  gts16
        MOV  EAX,offset DWORD PTR gtsrs #then reload the value} ldr gtsrs
        CALL ldr_
        LEA  EAX,DWORD PTR [] #and complete scaling} dvr (xr)
        CALL dvr_
        MOV  EAX,offset DWORD PTR gtsrs #store value} str gtsrs
        CALL str_
#
#      we are now scaled, so round by adding 0.5 * 10**(-cfp$s)
#
gts17:  MOV  EAX,offset DWORD PTR gtsrs #get value again} ldr gtsrs
        CALL ldr_
        MOV  EAX,offset DWORD PTR gtsrn #add rounding factor} adr gtsrn
        CALL adr_
        MOV  EAX,offset DWORD PTR gtsrs #store result} str gtsrs
        CALL str_
#
#      the rounding operation may have pushed us up past
#      1.0 again, so check one more time.
#
        MOV  EAX,offset DWORD PTR reav1 #subtract 1.0 to compare} sbr reav1
        CALL sbr_
        CALL CPR_           #skip if ok} rlt gts18
        JL   gts18
        ADD  EDX,DWORD PTR intv1 #else increment exponent} adi intv1
        MOV  EAX,offset DWORD PTR gtsrs #reload value} ldr gtsrs
        CALL ldr_
        MOV  EAX,offset DWORD PTR reavt #divide by 10.0 to rescale} dvr reavt
        CALL dvr_
        JMP  gts19          #jump to merge} brn gts19
#
#      here if rounding did not muck up scaling
#
gts18:  MOV  EAX,offset DWORD PTR gtsrs #reload rounded value} ldr gtsrs
        CALL ldr_
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      now we have completed the scaling as follows
#
#      (ia)                  signed exponent
#      (ra)                  scaled real (absolute value)
#
#      if the exponent is negative or greater than cfp$s, then
#      we convert the number in the form.
#
#      (neg sign) 0 . (cpf$s digits) e (exp sign) (exp digits)
#
#      if the exponent is positive and less than or equal to
#      cfp$s, the number is converted in the form.
#
#      (neg sign) (exponent digits) . (cfp$s-exponent digits)
#
#      in both cases, the formats obtained from the above
#      rules are modified by deleting trailing zeros after the
#      decimal point. there are no leading zeros in the exponent
#      and the exponent sign is always present.
#
gts19:  MOV                 #set num dec digits = cfp_s} mov =cfp_s xl
        MOV  DWORD PTR gtses,ch_mn #set exponent sign negative} mov =ch_mn gtses
        OR   EDX,EDX        #all set if exponent is negative} ilt gts21
        JL   gts21
        MOV                 #else fetch exponent} mfi wa
        CMP                 #skip if we can use special format} ble wa =cfp_s gts20
             gts20
        MOV  EDX            #else restore exponent} mti wa
        NEG  EDX            #set negative for cvd} ngi
        MOV  DWORD PTR gtses,ch_pl #set plus sign for exponent sign} mov =ch_pl gtses
        JMP  gts21          #jump to generate exponent} brn gts21
#
#      here if we can use the format without an exponent
#
gts20:  SUB                 #compute digits after decimal point} sub wa xl
        MOV  EDX,DWORD PTR intv0 #reset exponent to zero} ldi intv0
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      merge here as follows
#
#      (ia)                  exponent absolute value
#      gtses                 character for exponent sign
#      (ra)                  positive fraction
#      (xl)                  number of digits after dec point
#
gts21:  MOV                 #point to work area} mov gtswk xr
        MOV                 #set character ctr to max length} mov =nstmx wb
        LEA                 #prepare to store (right to left)} psc xr wb
        OR   EDX,EDX        #skip exponent if it is zero} ieq gts23
        JE   gts23
#
#      loop to generate digits of exponent
#
gts22:  CALL CVD_           #convert a digit into wa} cvd
        MOV  [ESI]          #store in work area} sch wa -(xr)
        DEC                 #decrement counter} dcv wb
        OR   EDX,EDX        #loop back if more digits to go} ine gts22
        JNE  gts22
#
#      here generate exponent sign and e
#
        MOV                 #load exponent sign} mov gtses wa
        MOV  [ESI],gtses    #store in work area} sch wa -(xr)
        MOV                 #get character letter e} mov =ch_le wa
        MOV  [ESI],=ch_le   #store in work area} sch wa -(xr)
        SUB                 #decrement counter for sign and e} sub =num02 wb
#
#      here to generate the fraction
#
gts23:  MOV  EAX,offset DWORD PTR gtssc #convert real to integer (10**cfp_s)} mlr gtssc
        CALL mlr_
        CALL RTI_           #get integer (overflow impossible)} rti
        NEG  EDX            #negate as required by cvd} ngi
#
#      loop to suppress trailing zeros
#
gts24:  OR                  #jump if no digits left to do} bze xl gts27
        JZ   gts27
        CALL CVD_           #else convert one digit} cvd
        CMP                 #jump if not a zero} bne wa =ch_d0 gts26
             gts26
        DEC                 #decrement counter} dcv xl
        JMP  gts24          #loop back for next digit} brn gts24
                            #} ejc
        .eject
#
#      gtstg (continued)
#
#      loop to generate digits after decimal point
#
gts25:  CALL CVD_           #convert a digit into wa} cvd
#
#      merge here first time
#
gts26:  MOV  [ESI]          #store digit} sch wa -(xr)
        DEC                 #decrement counter} dcv wb
        DEC                 #decrement counter} dcv xl
#        OR                  #loop back if more to go} bnz xl gts25  (Optimized)
        JNZ  gts25
#
#      here generate the decimal point
#
gts27:  MOV                 #load decimal point} mov =ch_dt wa
        MOV  [ESI],=ch_dt   #store in work area} sch wa -(xr)
        DEC                 #decrement counter} dcv wb
#
#      here generate the digits before the decimal point
#
gts28:  CALL CVD_           #convert a digit into wa} cvd
        MOV  [ESI],=ch_dt   #store in work area} sch wa -(xr)
        DEC                 #decrement counter} dcv wb
        OR   EDX,EDX        #loop back if more to go} ine gts28
        JNE  gts28
        JMP  gts08          #else jump back to exit} brn gts08
#
#      exit point after successful conversion
#
gts29:  MOV                 #restore xl} mov (xs)+ xl
        LEA
        ADD                 #pop argument} ica xs
        MOV                 #restore wb} mov gtsvb wb
        MOV                 #restore wc} mov gtsvc wc
#
#      merge here if no conversion required
#
gts30:  MOV                 #load string length} mov sclen(xr) wa
        POP  EAX            #return to caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here to return string for real zero
#
gts31:  MOV                 #point to string} mov =scre0 xl
        MOV                 #2 chars} mov =num02 wa
        XOR                 #zero offset} zer wb
        CALL sbstr          #copy string} jsr sbstr
        JMP  gts29          #return} brn gts29
                            #end procedure gtstg} enp
                            #} ejc
        .eject
#
#      gtvar -- get variable for i/o/trace association
#
#      gtvar is used to point to an actual variable location
#      for the detach,input,output,trace,stoptr system functions
#
#      (xr)                  argument to function
#      jsr  gtvar            call to locate variable pointer
#      ppm  loc              transfer loc if not ok variable
#      (xl,wa)               name base,offset of variable
#      (xr,ra)               destroyed
#      (wb,wc)               destroyed (convert error only)
#      (xr)                  input arg (convert error only)
#
gtvar:                      #entry point} prc e 1
        .global gtvar
        CMP  DWORD PTR [],offset b_nml #jump if not a name} bne (xr) =b_nml gtvr2
             gtvr2
        MOV                 #else load name offset} mov nmofs(xr) wa
        MOV                 #load name base} mov nmbas(xr) xl
        CMP  DWORD PTR [],offset b_evt #error if expression variable} beq (xl) =b_evt gtvr1
             gtvr1
        CMP  DWORD PTR [],offset b_kvt #all ok if not keyword variable} bne (xl) =b_kvt gtvr3
             gtvr3
#
#      here on conversion error
#
gtvr1:  POP  EAX            #take convert error exit} exi 1
        JMP  EXI__1
#
#      here if not a name, try convert to natural variable
#
gtvr2:  MOV  DWORD PTR gtvrc #save wc} mov wc gtvrc
        CALL gtnvr          #locate vrblk if possible} jsr gtnvr
        .short gtvr1-DFFNC  #jump if convert error} ppm gtvr1
        MOV                 #else copy vrblk name base} mov xr xl
        MOV                 #and set offset} mov *vrval wa
        MOV                 #restore wc} mov gtvrc wc
#
#      here for name obtained
#
gtvr3:  CMP                 #all ok if not natural variable} bhi xl state gtvr4
             gtvr4
        CMP  DWORD PTR (4*vrsto)[],offset b_vre #error if protected variable} beq vrsto(xl) =b_vre gtvr1
             gtvr1
#
#      common exit point
#
gtvr4:  POP  EAX            #return to caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
                            #end procedure gtvar} enp
                            #} ejc
        .eject
#
#      hashs -- compute hash index for string
#
#      hashs is used to convert a string to a unique integer
#      value. the resulting hash value is a positive integer
#      in the range 0 to cfp$m
#
#      (xr)                  string to be hashed
#      jsr  hashs            call to hash string
#      (ia)                  hash value
#      (xr,wb,wc)            destroyed
#
#      the hash function used is as follows.
#
#      start with the length of the string (sgd07)
#
#      take the first e$hnw words of the characters from
#      the string or all the words if fewer than e$hnw.
#
#      compute the exclusive or of all these words treating
#      them as one word bit string values.
#
#      move the result as an integer with the mti instruction.
#
hashs:                      #entry point} prc e 0
        .global hashs
        MOV                 #load string length in characters} mov sclen(xr) wc
        MOV                 #initialize with length} mov wc wb
        OR                  #jump if null string} bze wc hshs3
        JZ   hshs3
        XCHG wb             #correct byte ordering if necessary} zgb wb
        ROL
        XCHG wb
        ADD                 #get number of words of chars} ctw wc 0
        SHR
        ADD                 #point to characters of string} add *schar xr
        CMP                 #use whole string if short} blo wc =e_hnw hshs1
             hshs1
        MOV                 #else set to involve first e_hnw wds} mov =e_hnw wc
#
#      here with count of words to check in wc
#
hshs1:                      #set counter to control loop} lct wc wc
#
#      loop to compute exclusive or
#
hshs2:  XOR                 #exclusive or next word of chars} xob (xr)+ wb
        LEA
        DEC                 #loop till all processed} bct wc hshs2
        JNZ  hshs2
#
#      merge here with exclusive or in wb
#
hshs3:  XCHG hshs2          #zeroise undefined bits} zgb wb
        ROL
        XCHG hshs2
        AND                 #ensure in range 0 to cfp_m} anb bitsm wb
        MOV  EDX            #move result as integer} mti wb
        XOR                 #clear garbage value in xr} zer xr
        RET                 #return to hashs caller} exi
                            #end procedure hashs} enp
                            #} ejc
        .eject
#
#      icbld -- build integer block
#
#      (ia)                  integer value for icblk
#      jsr  icbld            call to build integer block
#      (xr)                  pointer to result icblk
#      (wa)                  destroyed
#
icbld:                      #entry point} prc e 0
        .global icbld
        OR   EDX,EDX        #copy small integers} mfi xr icbl1
        JS   icbl1
        MOV
        CMP                 #jump if 0,1 or 2} ble xr =num02 icbl3
             icbl3
#
#      construct icblk
#
icbl1:  MOV                 #load pointer to next available loc} mov dnamp xr
        ADD                 #point past new icblk} add *icsi_ xr
        CMP                 #jump if there is room} blo xr dname icbl2
             icbl2
        MOV                 #else load length of icblk} mov *icsi_ wa
        CALL alloc          #use standard allocator to get block} jsr alloc
        ADD                 #point past block to merge} add wa xr
#
#      merge here with xr pointing past the block obtained
#
icbl2:  MOV  DWORD PTR dnamp #set new pointer} mov xr dnamp
        SUB                 #point back to start of block} sub *icsi_ xr
        MOV  DWORD PTR [],offset b_icl #store type word} mov =b_icl (xr)
        MOV  DWORD PTR (4*icval)[],EDX #store integer value in icblk} sti icval(xr)
        RET                 #return to icbld caller} exi
#
#      optimise by not building icblks for small integers
#
icbl3:  SAL                 #convert integer to offset} wtb xr
        MOV                 #point to pre-built icblk} mov intab(xr) xr
        RET                 #return} exi
                            #end procedure icbld} enp
                            #} ejc
        .eject
#
#      ident -- compare two values
#
#      ident compares two values in the sense of the ident
#      differ functions available at the snobol level.
#
#      (xr)                  first argument
#      (xl)                  second argument
#      jsr  ident            call to compare arguments
#      ppm  loc              transfer loc if ident
#      (normal return if differ)
#      (xr,xl,wc,ra)         destroyed
#
ident:                      #entry point} prc e 1
        .global ident
        CMP                 #jump if same pointer (ident)} beq xr xl iden7
             iden7
        MOV                 #else load arg 1 type word} mov (xr) wc
        CMP                 #differ if arg 2 type word differ} bne wc (xl) iden1
             iden1
        CMP                 #jump if strings} beq wc =b_scl iden2
             iden2
        CMP                 #jump if integers} beq wc =b_icl iden4
             iden4
        CMP                 #jump if reals} beq wc =b_rcl iden5
             iden5
        CMP                 #jump if names} beq wc =b_nml iden6
             iden6
#
#      for all other datatypes, must be differ if xr ne xl
#
#      merge here for differ
#
iden1:  POP  EAX            #take differ exit} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here for strings, ident only if lengths and chars same
#
iden2:  MOV                 #load arg 1 length} mov sclen(xr) wc
        CMP                 #differ if lengths differ} bne wc sclen(xl) iden1
             iden1
#
#      buffer and string comparisons merge here
#
idn2a:  ADD                 #point to chars of arg 1} add *schar xr
        ADD                 #point to chars of arg 2} add *schar xl
        ADD                 #get number of words in strings} ctw wc 0
        SHR
#
#      loop to compare characters. note that wc cannot be zero
#      since all null strings point to nulls and give xl=xr.
#
iden3:  MOV  EAX,DWORD PTR [] #differ if chars do not match} cne (xr) (xl) iden8
        CMP  EAX,DWORD PTR []
        JNZ  iden8
        ADD                 #else bump arg one pointer} ica xr
        ADD                 #bump arg two pointer} ica xl
        DEC                 #loop back till all checked} bct wc iden3
        JNZ  iden3
                            #} ejc
        .eject
#
#      ident (continued)
#
#      here to exit for case of two ident strings
#
        XOR                 #clear garbage value in xl} zer xl
        XOR                 #clear garbage value in xr} zer xr
        POP  EAX            #take ident exit} exi 1
        JMP  EXI__1
#
#      here for integers, ident if same values
#
iden4:  MOV  EDX,DWORD PTR (4*icval)[] #load arg 1} ldi icval(xr)
        SUB  EDX,DWORD PTR (4*icval)[] #subtract arg 2 to compare} sbi icval(xl)
        JO   iden1          #differ if overflow} iov iden1
        OR   EDX,EDX        #differ if result is not zero} ine iden1
        JNE  iden1
        POP  EAX            #take ident exit} exi 1
        JMP  EXI__1
#
#      here for reals, ident if same values
#
iden5:  LEA  EAX,DWORD PTR (4*rcval)[] #load arg 1} ldr rcval(xr)
        CALL ldr_
        LEA  EAX,DWORD PTR (4*rcval)[] #subtract arg 2 to compare} sbr rcval(xl)
        CALL sbr_
        CALL OVR_           #differ if overflow} rov iden1
        JO   iden1
        CALL CPR_           #differ if result is not zero} rne iden1
        JNE  iden1
        POP  EAX            #take ident exit} exi 1
        JMP  EXI__1
#
#      here for names, ident if bases and offsets same
#
iden6:  MOV  EAX,DWORD PTR (4*nmofs)[] #differ if different offset} bne nmofs(xr) nmofs(xl) iden1
        CMP  EAX,DWORD PTR (4*nmofs)[]
             iden1
        MOV  EAX,DWORD PTR (4*nmbas)[] #differ if different base} bne nmbas(xr) nmbas(xl) iden1
        CMP  EAX,DWORD PTR (4*nmbas)[]
             iden1
#
#      merge here to signal ident for identical pointers
#
iden7:  POP  EAX            #take ident exit} exi 1
        JMP  EXI__1
#
#      here for differ strings
#
iden8:  XOR                 #clear garbage ptr in xr} zer xr
        XOR                 #clear garbage ptr in xl} zer xl
        POP  EAX            #return to caller (differ)} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
                            #end procedure ident} enp
                            #} ejc
        .eject
#
#      inout - used to initialise input and output variables
#
#      (xl)                  pointer to vbl name string
#      (wb)                  trblk type
#      jsr  inout            call to perform initialisation
#      (xl)                  vrblk ptr
#      (xr)                  trblk ptr
#      (wa,wc)               destroyed
#
#      note that trter (= trtrf) field of standard i/o variables
#      points to corresponding svblk not to a trblk as is the
#      case for ordinary variables.
#
inout:                      #entry point} prc e 0
        .global inout
        LEA                 #stack trblk type} mov wb -(xs)
        MOV  DWORD PTR []
        MOV                 #get name length} mov sclen(xl) wa
        XOR                 #point to start of name} zer wb
        CALL sbstr          #build a proper scblk} jsr sbstr
        CALL gtnvr          #build vrblk} jsr gtnvr
        .short ERR_-299-DFFNC #no error return} ppm
        MOV                 #save vrblk pointer} mov xr wc
        MOV                 #get trter field} mov (xs)+ wb
        LEA
        XOR                 #zero trfpt} zer xl
        CALL trbld          #build trblk} jsr trbld
        MOV                 #recall vrblk pointer} mov wc xl
        MOV  EAX,DWORD PTR (4*vrsvp)[] #store svblk pointer} mov vrsvp(xl) trter(xr)
        MOV  DWORD PTR (4*trter)[],EAX
        MOV  DWORD PTR (4*vrval)[] #store trblk ptr in vrblk} mov xr vrval(xl)
        MOV  DWORD PTR (4*vrget)[],offset b_vra #set trapped access} mov =b_vra vrget(xl)
        MOV  DWORD PTR (4*vrsto)[],offset b_vrv #set trapped store} mov =b_vrv vrsto(xl)
        RET                 #return to caller} exi
                            #end procedure inout} enp
                            #} ejc
        .eject
#
#      insta - used to initialize structures in static region
#
#      (xr)                  pointer to starting static location
#      jsr  insta            call to initialize static structure
#      (xr)                  ptr to next free static location
#      (wa,wb,wc)            destroyed
#
#      note that this procedure establishes the pointers
#      prbuf, gtswk, and kvalp.
#
insta:                      #entry point} prc e 0
        .global insta
#
#      initialize print buffer with blank words
#
        MOV                 #no. of chars in print bfr} mov prlen wc
        MOV  DWORD PTR prbuf #print bfr is put at static start} mov xr prbuf
        MOV  DWORD PTR [],offset b_scl #store string type code} mov =b_scl (xr)+
        LEA
        MOV  DWORD PTR []   #and string length} mov wc (xr)+
        LEA
        ADD                 #get number of words in buffer} ctw wc 0
        SHR
        MOV  DWORD PTR prlnw #store for buffer clear} mov wc prlnw
#
#      loop to clear buffer
#
inst1:  MOV  EAX,DWORD PTR nullw #store blank} mov nullw (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop} bct wc inst1
        JNZ  inst1
#
#      allocate work area for gtstg conversion procedure
#
        MOV                 #get max num chars in output number} mov =nstmx wa
        ADD                 #no of bytes needed} ctb wa scsi_
        AND
        MOV  DWORD PTR gtswk #store bfr adrs} mov xr gtswk
        ADD                 #bump for work bfr} add wa xr
#
#      build alphabet string for alphabet keyword and replace
#
        MOV  DWORD PTR kvalp #save alphabet pointer} mov xr kvalp
        MOV  DWORD PTR [],offset b_scl #string blk type} mov =b_scl (xr)
        MOV                 #no of chars in alphabet} mov =cfp_a wc
        MOV  DWORD PTR (4*sclen)[] #store as string length} mov wc sclen(xr)
        MOV                 #copy char count} mov wc wb
        ADD                 #no. of bytes needed} ctb wb scsi_
        AND
        ADD                 #current end address for static} add xr wb
        MOV                 #save adrs past alphabet string} mov wb wa
        ADD                 #point to chars of string} psc xr
        XOR                 #set initial character value} zer wb
#
#      loop to enter character codes in order
#
inst2:  MOV  [ESI]          #store next code} sch wb (xr)+
        INC                 #bump code value} icv wb
        DEC                 #loop till all stored} bct wc inst2
        JNZ  inst2
        MOV                 #return current static ptr} mov wa xr
        RET                 #return to caller} exi
                            #end procedure insta} enp
                            #} ejc
        .eject
#
#      iofcb -- get input/output fcblk pointer
#
#      used by endfile, eject and rewind to find the fcblk
#      (if any) corresponding to their argument.
#
#      -(xs)                 argument
#      jsr  iofcb            call to find fcblk
#      ppm  loc              arg is an unsuitable name
#      ppm  loc              arg is null string
#      ppm  loc              arg file not found
#      (xs)                  popped
#      (xl)                  ptr to filearg1 vrblk
#      (xr)                  argument
#      (wa)                  fcblk ptr or 0
#      (wb,wc)               destroyed
#
iofcb:                      #entry point} prc n 3
        .global iofcb
        POP  PRC_+28
        CALL gtstg          #get arg as string} jsr gtstg
        .short iofc2-DFFNC  #fail} ppm iofc2
        MOV                 #copy string ptr} mov xr xl
        CALL gtnvr          #get as natural variable} jsr gtnvr
        .short iofc3-DFFNC  #fail if null} ppm iofc3
        MOV                 #copy string pointer again} mov xl wb
        MOV                 #copy vrblk ptr for return} mov xr xl
        XOR                 #in case no trblk found} zer wa
#
#      loop to find file arg1 trblk
#
iofc1:  MOV                 #get possible trblk ptr} mov vrval(xr) xr
        CMP  DWORD PTR [],offset b_trt #fail if end of chain} bne (xr) =b_trt iofc4
             iofc4
        CMP  DWORD PTR (4*trtyp)[],trtfc #loop if not file arg trblk} bne trtyp(xr) =trtfc iofc1
             iofc1
        MOV                 #get fcblk ptr} mov trfpt(xr) wa
        MOV                 #copy arg} mov wb xr
        POP  EAX            #return} exi
        LEA  EAX,[EAX+6]
        JMP  EAX
#
#      fail return
#
iofc2:  POP  EAX            #fail} exi 1
        JMP  EXI__1
#
#      null arg
#
iofc3:  POP  EAX            #null arg return} exi 2
        JMP  EXI__2
#
#      file not found
#
iofc4:  POP  EAX            #file not found return} exi 3
        JMP  EXI__3
                            #end procedure iofcb} enp
                            #} ejc
        .eject
#
#      ioppf -- process filearg2 for ioput
#
#      (r$xsc)               filearg2 ptr
#      jsr  ioppf            call to process filearg2
#      (xl)                  filearg1 ptr
#      (xr)                  file arg2 ptr
#      -(xs)...-(xs)         fields extracted from filearg2
#      (wc)                  no. of fields extracted
#      (wb)                  input/output flag
#      (wa)                  fcblk ptr or 0
#
ioppf:                      #entry point} prc n 0
        .global ioppf
        POP  PRC_+32
        XOR                 #to count fields extracted} zer wb
#
#      loop to extract fields
#
iopp1:  MOV                 #get delimiter} mov =iodel xl
        MOV                 #copy it} mov xl wc
        XOR                 #retain leading blanks in filearg2} zer wa
        CALL xscan          #get next field} jsr xscan
        LEA                 #stack it} mov xr -(xs)
        MOV  DWORD PTR []
        INC                 #increment count} icv wb
#        OR                  #loop} bnz wa iopp1  (Optimized)
        JNZ  iopp1
        MOV                 #count of fields} mov wb wc
        MOV                 #i/o marker} mov ioptt wb
        MOV                 #fcblk ptr or 0} mov r_iof wa
        MOV                 #file arg2 ptr} mov r_io2 xr
        MOV                 #filearg1} mov r_io1 xl
        RET                 #return} exi
                            #end procedure ioppf} enp
                            #} ejc
        .eject
#
#      ioput -- routine used by input and output
#
#      ioput sets up input/output  associations. it builds
#      such trace and file control blocks as are necessary and
#      calls sysfc,sysio to perform checks on the
#      arguments and to open the files.
#
#         +-----------+   +---------------+       +-----------+
#      +-.i           i   i               i------.i   =b$xrt  i
#      i  +-----------+   +---------------+       +-----------+
#      i  /           /        (r$fcb)            i    *4     i
#      i  /           /                           +-----------+
#      i  +-----------+   +---------------+       i           i-
#      i  i   name    +--.i    =b$trt     i       +-----------+
#      i  /           /   +---------------+       i           i
#      i   (first arg)    i =trtin/=trtou i       +-----------+
#      i                  +---------------+             i
#      i                  i     value     i             i
#      i                  +---------------+             i
#      i                  i(trtrf) 0   or i--+          i
#      i                  +---------------+  i          i
#      i                  i(trfpt) 0   or i----+        i
#      i                  +---------------+  i i        i
#      i                     (i/o trblk)     i i        i
#      i  +-----------+                      i i        i
#      i  i           i                      i i        i
#      i  +-----------+                      i i        i
#      i  i           i                      i i        i
#      i  +-----------+   +---------------+  i i        i
#      i  i           +--.i    =b$trt     i.-+ i        i
#      i  +-----------+   +---------------+    i        i
#      i  /           /   i    =trtfc     i    i        i
#      i  /           /   +---------------+    i        i
#      i    (filearg1     i     value     i    i        i
#      i         vrblk)   +---------------+    i        i
#      i                  i(trtrf) 0   or i--+ i        .
#      i                  +---------------+  i .  +-----------+
#      i                  i(trfpt) 0   or i------./   fcblk   /
#      i                  +---------------+  i    +-----------+
#      i                       (trtrf)       i
#      i                                     i
#      i                                     i
#      i                  +---------------+  i
#      i                  i    =b$xrt     i.-+
#      i                  +---------------+
#      i                  i      *5       i
#      i                  +---------------+
#      +------------------i               i
#                         +---------------+       +-----------+
#                         i(trtrf) o   or i------.i  =b$xrt   i
#                         +---------------+       +-----------+
#                         i  name offset  i       i    etc    i
#                         +---------------+
#                           (iochn - chain of name pointers)
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      no additional trap blocks are used for standard input/out
#      files. otherwise an i/o trap block is attached to second
#      arg (filearg1) vrblk. see diagram above for details of
#      the structure built.
#
#      -(xs)                 1st arg (vbl to be associated)
#      -(xs)                 2nd arg (file arg1)
#      -(xs)                 3rd arg (file arg2)
#      (wb)                  0 for input, 3 for output assoc.
#      jsr  ioput            call for input/output association
#      ppm  loc              3rd arg not a string
#      ppm  loc              2nd arg not a suitable name
#      ppm  loc              1st arg not a suitable name
#      ppm  loc              inappropriate file spec for i/o
#      ppm  loc              i/o file does not exist
#      ppm  loc              i/o file cannot be read/written
#      ppm  loc              i/o fcblk currently in use
#      (xs)                  popped
#      (xl,xr,wa,wb,wc)      destroyed
#
ioput:                      #entry point} prc n 7
        .global ioput
        POP  PRC_+36
        XOR  EAX,EAX        #in case no trtrf block used} zer r_iot
        MOV  DWORD PTR r_iot,EAX
        XOR  EAX,EAX        #in case no fcblk alocated} zer r_iof
        MOV  DWORD PTR r_iof,EAX
        XOR  EAX,EAX        #in case sysio fails} zer r_iop
        MOV  DWORD PTR r_iop,EAX
        MOV  DWORD PTR ioptt #store i/o trace type} mov wb ioptt
        CALL xscni          #prepare to scan filearg2} jsr xscni
        .short iop13-DFFNC  #fail} ppm iop13
        .short iopa0-DFFNC  #null file arg2} ppm iopa0
#
iopa0:  MOV  DWORD PTR r_io2 #keep file arg2} mov xr r_io2
        MOV                 #copy length} mov wa xl
        CALL gtstg          #convert filearg1 to string} jsr gtstg
        .short iop14-DFFNC  #fail} ppm iop14
        MOV  DWORD PTR r_io1 #keep filearg1 ptr} mov xr r_io1
        CALL gtnvr          #convert to natural variable} jsr gtnvr
        .short iop00-DFFNC  #jump if null} ppm iop00
        JMP  iop04          #jump to process non-null args} brn iop04
#
#      null filearg1
#
iop00:  OR                  #skip if both args null} bze xl iop01
        JZ   iop01
        CALL ioppf          #process filearg2} jsr ioppf
        CALL sysfc          #call for filearg2 check} jsr sysfc
        .short iop16-DFFNC  #fail} ppm iop16
        .short iop26-DFFNC  #fail} ppm iop26
        JMP  iop11          #complete file association} brn iop11
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      here with 0 or fcblk ptr in (xl)
#
iop01:  MOV                 #get trace type} mov ioptt wb
        MOV                 #get 0 or trtrf ptr} mov r_iot xr
        CALL trbld          #build trblk} jsr trbld
        MOV                 #copy trblk pointer} mov xr wc
        MOV                 #get variable from stack} mov (xs)+ xr
        LEA
        LEA                 #make trblk collectable} mov wc -(xs)
        MOV  DWORD PTR []
        CALL gtvar          #point to variable} jsr gtvar
        .short iop15-DFFNC  #fail} ppm iop15
        MOV                 #recover trblk pointer} mov (xs)+ wc
        LEA
        MOV  DWORD PTR r_ion #save name pointer} mov xl r_ion
        MOV                 #copy name pointer} mov xl xr
        ADD                 #point to variable} add wa xr
        SUB                 #subtract offset,merge into loop} sub *vrval xr
#
#      loop to end of trblk chain if any
#
iop02:  MOV                 #copy blk ptr} mov xr xl
        MOV                 #load ptr to next trblk} mov vrval(xr) xr
        CMP  DWORD PTR [],offset b_trt #jump if not trapped} bne (xr) =b_trt iop03
             iop03
        MOV  EAX,DWORD PTR (4*trtyp)[] #loop if not same assocn} bne trtyp(xr) ioptt iop02
        CMP  EAX,DWORD PTR ioptt
             iop02
        MOV                 #get value and delete old trblk} mov trnxt(xr) xr
#
#      ioput (continued)
#
#      store new association
#
iop03:  MOV  DWORD PTR (4*vrval)[] #link to this trblk} mov wc vrval(xl)
        MOV                 #copy pointer} mov wc xl
        MOV  DWORD PTR (4*trnxt)[] #store value in trblk} mov xr trnxt(xl)
        MOV                 #restore possible vrblk pointer} mov r_ion xr
        MOV                 #keep offset to name} mov wa wb
        CALL setvr          #if vrblk, set vrget,vrsto} jsr setvr
        MOV                 #get 0 or trtrf ptr} mov r_iot xr
        OR                  #jump if trtrf block exists} bnz xr iop19
        JNZ  iop19
        POP  EAX            #return to caller} exi
        LEA  EAX,[EAX+14]
        JMP  EAX
#
#      non standard file
#      see if an fcblk has already been allocated.
#
iop04:  XOR                 #in case no fcblk found} zer wa
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      search possible trblk chain to pick up the fcblk
#
iop05:  MOV                 #remember blk ptr} mov xr wb
        MOV                 #chain along} mov vrval(xr) xr
        CMP  DWORD PTR [],offset b_trt #jump if end of trblk chain} bne (xr) =b_trt iop06
             iop06
        CMP  DWORD PTR (4*trtyp)[],trtfc #loop if more to go} bne trtyp(xr) =trtfc iop05
             iop05
        MOV  DWORD PTR r_iot #point to file arg1 trblk} mov xr r_iot
        MOV                 #get fcblk ptr from trblk} mov trfpt(xr) wa
#
#      wa = 0 or fcblk ptr
#      wb = ptr to preceding blk to which any trtrf block
#           for file arg1 must be chained.
#
iop06:  MOV  DWORD PTR r_iof #keep possible fcblk ptr} mov wa r_iof
        MOV  DWORD PTR r_iop #keep preceding blk ptr} mov wb r_iop
        CALL ioppf          #process filearg2} jsr ioppf
        CALL sysfc          #see if fcblk required} jsr sysfc
        .short iop16-DFFNC  #fail} ppm iop16
        .short iop26-DFFNC  #fail} ppm iop26
        OR                  #skip if no new fcblk wanted} bze wa iop12
        JZ   iop12
        CMP                 #jump if fcblk in dynamic} blt wc =num02 iop6a
             iop6a
        CALL alost          #get it in static} jsr alost
        JMP  iop6b          #skip} brn iop6b
#
#      obtain fcblk in dynamic
#
iop6a:  CALL alloc          #get space for fcblk} jsr alloc
#
#      merge
#
iop6b:  MOV                 #point to fcblk} mov xr xl
        MOV                 #copy its length} mov wa wb
        SHR                 #get count as words (sgd apr80)} btw wb
#
#      clear fcblk
#
iop07:  XOR  EAX,EAX        #clear a word} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #loop} bct wb iop07
        JNZ  iop07
        CMP                 #skip if in static - dont set fields} beq wc =num02 iop09
             iop09
        MOV  DWORD PTR [],offset b_xnt #store xnblk code in case} mov =b_xnt (xl)
        MOV  DWORD PTR (4*num01)[] #store length} mov wa num01(xl)
        OR                  #jump if xnblk wanted} bnz wc iop09
        JNZ  iop09
        MOV  DWORD PTR [],offset b_xrt #xrblk code requested} mov =b_xrt (xl)
#
                            #} ejc
        .eject
#      ioput (continued)
#
#      complete fcblk initialisation
#
iop09:  MOV                 #get possible trblk ptr} mov r_iot xr
        MOV  DWORD PTR r_iof #store fcblk ptr} mov xl r_iof
        OR                  #jump if trblk already found} bnz xr iop10
        JNZ  iop10
#
#      a new trblk is needed
#
        MOV                 #trtyp for fcblk trap blk} mov =trtfc wb
        CALL trbld          #make the block} jsr trbld
        MOV  DWORD PTR r_iot #copy trtrf ptr} mov xr r_iot
        MOV                 #point to preceding blk} mov r_iop xl
        MOV  EAX,DWORD PTR (4*vrval)[] #copy value field to trblk} mov vrval(xl) vrval(xr)
        MOV  DWORD PTR (4*vrval)[],EAX
        MOV  DWORD PTR (4*vrval)[] #link new trblk into chain} mov xr vrval(xl)
        MOV                 #point to predecessor blk} mov xl xr
        CALL setvr          #set trace intercepts} jsr setvr
        MOV                 #recover trblk ptr} mov vrval(xr) xr
        JMP  iop1a          #store fcblk ptr} brn iop1a
#
#      here if existing trblk
#
iop10:  XOR  EAX,EAX        #do not release if sysio fails} zer r_iop
        MOV  DWORD PTR r_iop,EAX
#
#      xr is ptr to trblk, xl is fcblk ptr or 0
#
iop1a:  MOV  EAX,DWORD PTR r_iof #store fcblk ptr} mov r_iof trfpt(xr)
        MOV  DWORD PTR (4*trfpt)[],EAX
#
#      call sysio to complete file accessing
#
iop11:  MOV                 #copy fcblk ptr or 0} mov r_iof wa
        MOV                 #get input/output flag} mov ioptt wb
        MOV                 #get file arg2} mov r_io2 xr
        MOV                 #get file arg1} mov r_io1 xl
        CALL sysio          #associate to the file} jsr sysio
        .short iop17-DFFNC  #fail} ppm iop17
        .short iop18-DFFNC  #fail} ppm iop18
        CMP  DWORD PTR DWORD PTR r_iot,0 #not std input if non-null trtrf blk} bnz r_iot iop01
        JNZ  iop01
        CMP  DWORD PTR DWORD PTR ioptt,0 #jump if output} bnz ioptt iop01
        JNZ  iop01
        OR                  #no change to standard read length} bze wc iop01
        JZ   iop01
        MOV  DWORD PTR cswin #store new read length for std file} mov wc cswin
        JMP  iop01          #merge to finish the task} brn iop01
#
#      sysfc may have returned a pointer to a private fcblk
#
iop12:  OR                  #jump if private fcblk} bnz xl iop09
        JNZ  iop09
        JMP  iop11          #finish the association} brn iop11
#
#      failure returns
#
iop13:  POP  EAX            #3rd arg not a string} exi 1
        JMP  EXI__1
iop14:  POP  EAX            #2nd arg unsuitable} exi 2
        JMP  EXI__2
iop15:  ADD                 #discard trblk pointer} ica xs
        POP  EAX            #1st arg unsuitable} exi 3
        JMP  EXI__3
iop16:  POP  EAX            #file spec wrong} exi 4
        JMP  EXI__4
iop26:  POP  EAX            #fcblk in use} exi 7
        JMP  EXI__7
#
#      i/o file does not exist
#
iop17:  MOV                 #is there a trblk to release} mov r_iop xr
        OR                  #if not} bze xr iopa7
        JZ   iopa7
        MOV                 #point to trblk} mov vrval(xr) xl
        MOV  EAX,DWORD PTR (4*vrval)[] #unsplice it} mov vrval(xl) vrval(xr)
        MOV  DWORD PTR (4*vrval)[],EAX
        CALL setvr          #adjust trace intercepts} jsr setvr
iopa7:  POP  EAX            #i/o file does not exist} exi 5
        JMP  EXI__5
#
#      i/o file cannot be read/written
#
iop18:  MOV                 #is there a trblk to release} mov r_iop xr
        OR                  #if not} bze xr iopa7
        JZ   iopa7
        MOV                 #point to trblk} mov vrval(xr) xl
        MOV  EAX,DWORD PTR (4*vrval)[] #unsplice it} mov vrval(xl) vrval(xr)
        MOV  DWORD PTR (4*vrval)[],EAX
        CALL setvr          #adjust trace intercepts} jsr setvr
iopa8:  POP  EAX            #i/o file cannot be read/written} exi 6
        JMP  EXI__6
                            #} ejc
        .eject
#
#      ioput (continued)
#
#      add to iochn chain of associated variables unless
#      already present.
#
iop19:  MOV                 #wc = name base, wb = name offset} mov r_ion wc
#
#      search loop
#
iop20:  MOV                 #next link of chain} mov trtrf(xr) xr
        OR                  #not found} bze xr iop21
        JZ   iop21
        CMP                 #no match} bne wc ionmb(xr) iop20
             iop20
        CMP                 #exit if matched} beq wb ionmo(xr) iop22
             iop22
        JMP  iop20          #loop} brn iop20
#
#      not found
#
iop21:  MOV                 #space needed} mov *num05 wa
        CALL alloc          #get it} jsr alloc
        MOV  DWORD PTR [],offset b_xrt #store xrblk code} mov =b_xrt (xr)
        MOV  DWORD PTR (4*num01)[] #store length} mov wa num01(xr)
        MOV  DWORD PTR (4*ionmb)[] #store name base} mov wc ionmb(xr)
        MOV  DWORD PTR (4*ionmo)[] #store name offset} mov wb ionmo(xr)
        MOV                 #point to trtrf blk} mov r_iot xl
        MOV                 #get ptr field contents} mov trtrf(xl) wa
        MOV  DWORD PTR (4*trtrf)[] #store ptr to new block} mov xr trtrf(xl)
        MOV  DWORD PTR (4*trtrf)[] #complete the linking} mov wa trtrf(xr)
#
#      insert fcblk on fcblk chain for sysej, sysxi
#
iop22:  CMP  DWORD PTR DWORD PTR r_iof,0 #skip if no fcblk} bze r_iof iop25
        JZ   iop25
        MOV                 #ptr to head of existing chain} mov r_fcb xl
#
#      see if fcblk already on chain
#
iop23:  OR                  #not on if end of chain} bze xl iop24
        JZ   iop24
        MOV  EAX,DWORD PTR (4*num03)[] #dont duplicate if find it} beq num03(xl) r_iof iop25
        CMP  EAX,DWORD PTR r_iof
             iop25
        MOV                 #get next link} mov num02(xl) xl
        JMP  iop23          #loop} brn iop23
#
#      not found so add an entry for this fcblk
#
iop24:  MOV                 #space needed} mov *num04 wa
        CALL alloc          #get it} jsr alloc
        MOV  DWORD PTR [],offset b_xrt #store block code} mov =b_xrt (xr)
        MOV  DWORD PTR (4*num01)[] #store length} mov wa num01(xr)
        MOV  EAX,DWORD PTR r_fcb #store previous link in this node} mov r_fcb num02(xr)
        MOV  DWORD PTR (4*num02)[],EAX
        MOV  EAX,DWORD PTR r_iof #store fcblk ptr} mov r_iof num03(xr)
        MOV  DWORD PTR (4*num03)[],EAX
        MOV  DWORD PTR r_fcb #insert node into fcblk chain} mov xr r_fcb
#
#      return
#
iop25:  POP  EAX            #return to caller} exi
        LEA  EAX,[EAX+14]
        JMP  EAX
                            #end procedure ioput} enp
                            #} ejc
        .eject
#
#      ktrex -- execute keyword trace
#
#      ktrex is used to execute a possible keyword trace. it
#      includes the test on trace and tests for trace active.
#
#      (xl)                  ptr to trblk (or 0 if untraced)
#      jsr  ktrex            call to execute keyword trace
#      (xl,wa,wb,wc)         destroyed
#      (ra)                  destroyed
#
ktrex:                      #entry point (recursive)} prc r 0
        .global ktrex
        OR                  #immediate exit if keyword untraced} bze xl ktrx3
        JZ   ktrx3
        CMP  DWORD PTR DWORD PTR kvtra,0 #immediate exit if trace = 0} bze kvtra ktrx3
        JZ   ktrx3
        DEC  DWORD PTR kvtra #else decrement trace} dcv kvtra
        LEA                 #save xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #copy trblk pointer} mov xl xr
        MOV                 #load vrblk pointer (nmbas)} mov trkvr(xr) xl
        MOV                 #set name offset} mov *vrval wa
        CMP  DWORD PTR DWORD PTR (4*trfnc)[],0 #jump if print trace} bze trfnc(xr) ktrx1
        JZ   ktrx1
        CALL trxeq          #else execute full trace} jsr trxeq
        JMP  ktrx2          #and jump to exit} brn ktrx2
#
#      here for print trace
#
ktrx1:  LEA                 #stack vrblk ptr for kwnam} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #stack offset for kwnam} mov wa -(xs)
        MOV  DWORD PTR []
        CALL prtsn          #print statement number} jsr prtsn
        MOV                 #load ampersand} mov =ch_am wa
        CALL prtch          #print ampersand} jsr prtch
        CALL prtnm          #print keyword name} jsr prtnm
        MOV                 #point to blank-equal-blank} mov =tmbeb xr
        CALL prtst          #print blank-equal-blank} jsr prtst
        CALL kwnam          #get keyword pseudo-variable name} jsr kwnam
        MOV  DWORD PTR dnamp #reset ptr to delete kvblk} mov xr dnamp
        CALL acess          #get keyword value} jsr acess
        .short ERR_-299-DFFNC #failure is impossible} ppm
        CALL prtvl          #print keyword value} jsr prtvl
        CALL prtnl          #terminate print line} jsr prtnl
#
#      here to exit after completing trace
#
ktrx2:  MOV                 #restore entry xr} mov (xs)+ xr
        LEA
#
#      merge here to exit if no trace required
#
ktrx3:  RET                 #return to ktrex caller} exi
                            #end procedure ktrex} enp
                            #} ejc
        .eject
#
#      kwnam -- get pseudo-variable name for keyword
#
#      1(xs)                 name base for vrblk
#      0(xs)                 offset (should be *vrval)
#      jsr  kwnam            call to get pseudo-variable name
#      (xs)                  popped twice
#      (xl,wa)               resulting pseudo-variable name
#      (xr,wa,wb)            destroyed
#
kwnam:                      #entry point} prc n 0
        .global kwnam
        POP  PRC_+40
        ADD                 #ignore name offset} ica xs
        MOV                 #load name base} mov (xs)+ xr
        LEA
        CMP                 #jump if not natural variable name} bge xr state kwnm1
             kwnm1
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #error if not system variable} bnz vrlen(xr) kwnm1
        JNZ  kwnm1
        MOV                 #else point to svblk} mov vrsvp(xr) xr
        MOV                 #load bit mask} mov svbit(xr) wa
        AND                 #and with keyword bit} anb btknm wa
#        OR                  #error if no keyword association} zrb wa kwnm1  (Optimized)
        JZ   kwnm1
        MOV                 #else load name length in characters} mov svlen(xr) wa
        ADD                 #compute offset to field we want} ctb wa svchs
        AND
        ADD                 #point to svknm field} add wa xr
        MOV                 #load svknm value} mov (xr) wb
        MOV                 #set size of kvblk} mov *kvsi_ wa
        CALL alloc          #allocate kvblk} jsr alloc
        MOV  DWORD PTR [],offset b_kvt #store type word} mov =b_kvt (xr)
        MOV  DWORD PTR (4*kvnum)[] #store keyword number} mov wb kvnum(xr)
        MOV  DWORD PTR (4*kvvar)[],offset trbkv #set dummy trblk pointer} mov =trbkv kvvar(xr)
        MOV                 #copy kvblk pointer} mov xr xl
        MOV                 #set proper offset} mov *kvvar wa
        RET                 #return to kvnam caller} exi
#
#      here if not keyword name
#
kwnm1:  CALL ERR_0          #} erb 251 keyword operand is not name of defined keyword
        .byte 251
                            #end procedure kwnam} enp
                            #} ejc
        .eject
#
#      lcomp-- compare two strings lexically
#
#      1(xs)                 first argument
#      0(xs)                 second argument
#      jsr  lcomp            call to compare aruments
#      ppm  loc              transfer loc for arg1 not string
#      ppm  loc              transfer loc for arg2 not string
#      ppm  loc              transfer loc if arg1 llt arg2
#      ppm  loc              transfer loc if arg1 leq arg2
#      ppm  loc              transfer loc if arg1 lgt arg2
#      (the normal return is never taken)
#      (xs)                  popped twice
#      (xr,xl)               destroyed
#      (wa,wb,wc,ra)         destroyed
#
lcomp:                      #entry point} prc n 5
        .global lcomp
        POP  PRC_+44
        CALL gtstg          #convert second arg to string} jsr gtstg
        .short lcmp6-DFFNC  #jump if second arg not string} ppm lcmp6
        MOV                 #else save pointer} mov xr xl
        MOV                 #and length} mov wa wc
        CALL gtstg          #convert first argument to string} jsr gtstg
        .short lcmp5-DFFNC  #jump if not string} ppm lcmp5
        MOV                 #save arg 1 length} mov wa wb
        ADD                 #point to chars of arg 1} plc xr
        ADD                 #point to chars of arg 2} plc xl
        CMP                 #jump if arg 1 length is smaller} blo wa wc lcmp1
             lcmp1
        MOV                 #else set arg 2 length as smaller} mov wc wa
#
#      here with smaller length in (wa)
#
lcmp1:  OR                  #if null string, compare lengths} bze wa lcmp7
        JZ   lcmp7
        REPE CMPSB          #compare strings, jump if unequal} cmc lcmp4 lcmp3
        MOV  ESI,0
        MOV  EDI,ESI
        JA   lcmp3
        JB   lcmp4
lcmp7:  CMP                 #if equal, jump if lengths unequal} bne wb wc lcmp2
             lcmp2
        POP  EAX            #else identical strings, leq exit} exi 4
        JMP  EXI__4
                            #} ejc
        .eject
#
#      lcomp (continued)
#
#      here if initial strings identical, but lengths unequal
#
lcmp2:  CMP                 #jump if arg 1 length gt arg 2 leng} bhi wb wc lcmp4
             lcmp4
#
#      here if first arg llt second arg
#
lcmp3:  POP  EAX            #take llt exit} exi 3
        JMP  EXI__3
#
#      here if first arg lgt second arg
#
lcmp4:  POP  EAX            #take lgt exit} exi 5
        JMP  EXI__5
#
#      here if first arg is not a string
#
lcmp5:  POP  EAX            #take bad first arg exit} exi 1
        JMP  EXI__1
#
#      here for second arg not a string
#
lcmp6:  POP  EAX            #take bad second arg error exit} exi 2
        JMP  EXI__2
                            #end procedure lcomp} enp
                            #} ejc
        .eject
#
#      listr -- list source line
#
#      listr is used to list a source line during the initial
#      compilation. it is called from scane and scanl.
#
#      jsr  listr            call to list line
#      (xr,xl,wa,wb,wc)      destroyed
#
#      global locations used by listr
#
#      cnttl                 flag for -title, -stitl
#
#      erlst                 if listing on account of an error
#
#      lstid                 include depth of current image
#
#      lstlc                 count lines on current page
#
#      lstnp                 max number of lines/page
#
#      lstpf                 set non-zero if the current source
#                            line has been listed, else zero.
#
#      lstpg                 compiler listing page number
#
#      lstsn                 set if stmnt num to be listed
#
#      r$cim                 pointer to current input line.
#
#      r$ttl                 title for source listing
#
#      r$stl                 ptr to sub-title string
#
#      entry point
#
listr:                      #entry point} prc e 0
        .global listr
        CMP  DWORD PTR DWORD PTR cnttl,0 #jump if -title or -stitl} bnz cnttl list5
        JNZ  list5
        CMP  DWORD PTR DWORD PTR lstpf,0 #immediate exit if already listed} bnz lstpf list4
        JNZ  list4
        MOV  EAX,DWORD PTR lstlc #jump if no room} bge lstlc lstnp list6
        CMP  EAX,DWORD PTR lstnp
             list6
#
#      here after printing title (if needed)
#
list0:  MOV                 #load pointer to current image} mov r_cim xr
        OR                  #jump if no image to print} bze xr list4
        JZ   list4
        ADD                 #point to characters} plc xr
        MOVZX               #load first character} lch wa (xr)
        MOV                 #load statement number} mov lstsn xr
        OR                  #jump if no statement number} bze xr list2
        JZ   list2
        MOV  EDX            #else get stmnt number as integer} mti xr
        CMP  DWORD PTR stage,stgic #skip if execute time} bne stage =stgic list1
             list1
        CMP                 #no stmnt number list if comment} beq wa =ch_as list2
             list2
        CMP                 #no stmnt no. if control card} beq wa =ch_mn list2
             list2
#
#      print statement number
#
list1:  CALL prtin          #else print statement number} jsr prtin
        XOR  EAX,EAX        #and clear for next time in} zer lstsn
        MOV  DWORD PTR lstsn,EAX
#
#      here to test for printing include depth
#
list2:  MOV                 #include depth of image} mov lstid xr
        OR                  #if not from an include file} bze xr list8
        JZ   list8
        MOV                 #position for start of statement} mov =stnpd wa
        SUB                 #position to place include depth} sub =num03 wa
        MOV  DWORD PTR profs #set as starting position} mov wa profs
        MOV  EDX            #include depth as integer} mti xr
        CALL prtin          #print include depth} jsr prtin
                            #} ejc
        .eject
#
#      listr (continued)
#
#      here after printing statement number and include depth
#
list8:  MOV  DWORD PTR profs,stnpd #point past statement number} mov =stnpd profs
        MOV                 #load pointer to current image} mov r_cim xr
        CALL prtst          #print it} jsr prtst
        INC  DWORD PTR lstlc #bump line counter} icv lstlc
        CMP  DWORD PTR DWORD PTR erlst,0 #jump if error copy to int.ch.} bnz erlst list3
        JNZ  list3
        CALL prtnl          #terminate line} jsr prtnl
        CMP  DWORD PTR DWORD PTR cswdb,0 #jump if -single mode} bze cswdb list3
        JZ   list3
        CALL prtnl          #else add a blank line} jsr prtnl
        INC  DWORD PTR lstlc #and bump line counter} icv lstlc
#
#      here after printing source image
#
list3:  MOV  DWORD PTR lstpf,ESP #set flag for line printed} mnz lstpf
#
#      merge here to exit
#
list4:  RET                 #return to listr caller} exi
#
#      print title after -title or -stitl card
#
list5:  XOR  EAX,EAX        #clear flag} zer cnttl
        MOV  DWORD PTR cnttl,EAX
#
#      eject to new page and list title
#
list6:  CALL prtps          #eject} jsr prtps
        CMP  DWORD PTR DWORD PTR prich,0 #skip if listing to regular printer} bze prich list7
        JZ   list7
        CMP  DWORD PTR r_ttl,offset nulls #terminal listing omits null title} beq r_ttl =nulls list0
             list0
#
#      list title
#
list7:  CALL listt          #list title} jsr listt
        JMP  list0          #merge} brn list0
                            #end procedure listr} enp
                            #} ejc
        .eject
#
#      listt -- list title and subtitle
#
#      used during compilation to print page heading
#
#      jsr  listt            call to list title
#      (xr,wa)               destroyed
#
listt:                      #entry point} prc e 0
        .global listt
        MOV                 #point to source listing title} mov r_ttl xr
        CALL prtst          #print title} jsr prtst
        MOV  EAX,DWORD PTR lstpo #set offset} mov lstpo profs
        MOV  DWORD PTR profs,EAX
        MOV                 #set page message} mov =lstms xr
        CALL prtst          #print page message} jsr prtst
        INC  DWORD PTR lstpg #bump page number} icv lstpg
        MOV  EDX,DWORD PTR lstpg #load page number as integer} mti lstpg
        CALL prtin          #print page number} jsr prtin
        CALL prtnl          #terminate title line} jsr prtnl
        ADD  DWORD PTR lstlc,num02 #count title line and blank line} add =num02 lstlc
#
#      print sub-title (if any)
#
        MOV                 #load pointer to sub-title} mov r_stl xr
        OR                  #jump if no sub-title} bze xr lstt1
        JZ   lstt1
        CALL prtst          #else print sub-title} jsr prtst
        CALL prtnl          #terminate line} jsr prtnl
        INC  DWORD PTR lstlc #bump line count} icv lstlc
#
#      return point
#
lstt1:  CALL prtnl          #print a blank line} jsr prtnl
        RET                 #return to caller} exi
                            #end procedure listt} enp
                            #} ejc
        .eject
#
#      newfn -- record new source file name
#
#      newfn is used after switching to a new include file, or
#      after a -line statement which contains a file name.
#
#      (xr)                  file name scblk
#      jsr  newfn
#      (wa,wb,wc,xl,xr,ra)   destroyed
#
#      on return, the table that maps statement numbers to file
#      names has been updated to include this new file name and
#      the current statement number.  the entry is made only if
#      the file name had changed from its previous value.
#
newfn:                      #entry point} prc e 0
        .global newfn
        LEA                 #save new name} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #load previous name} mov r_sfc xl
        CALL ident          #check for equality} jsr ident
        .short nwfn1-DFFNC  #jump if identical} ppm nwfn1
        MOV                 #different, restore name} mov (xs)+ xr
        LEA
        MOV  DWORD PTR r_sfc #record current file name} mov xr r_sfc
        MOV                 #get current statement} mov cmpsn wb
        MOV  EDX            #convert to integer} mti wb
        CALL icbld          #build icblk for stmt number} jsr icbld
        MOV                 #file name table} mov r_sfn xl
        MOV                 #lookup statement number by name} mnz wb
        CALL tfind          #allocate new teblk} jsr tfind
        .short ERR_-299-DFFNC #always possible to allocate block} ppm
        MOV  EAX,DWORD PTR r_sfc #record file name as entry value} mov r_sfc teval(xl)
        MOV  DWORD PTR (4*teval)[],EAX
        RET                 #} exi
#
#     here if new name and old name identical
#
nwfn1:  ADD                 #pop stack} ica xs
        RET                 #} exi
                            #} ejc
        .eject
#
#      nexts -- acquire next source image
#
#      nexts is used to acquire the next source image at compile
#      time. it assumes that a prior call to readr has input
#      a line image (see procedure readr). before the current
#      image is finally lost it may be listed here.
#
#      jsr  nexts            call to acquire next input line
#      (xr,xl,wa,wb,wc)      destroyed
#
#      global values affected
#
#      lstid                 include depth of next image
#
#      r$cni                 on input, next image. on
#                            exit reset to zero
#
#      r$cim                 on exit, set to point to image
#
#      rdcln                 current ln set from next line num
#
#      scnil                 input image length on exit
#
#      scnse                 reset to zero on exit
#
#      lstpf                 set on exit if line is listed
#
nexts:                      #entry point} prc e 0
        .global nexts
        CMP  DWORD PTR DWORD PTR cswls,0 #jump if -nolist} bze cswls nxts2
        JZ   nxts2
        MOV                 #point to image} mov r_cim xr
        OR                  #jump if no image} bze xr nxts2
        JZ   nxts2
        ADD                 #get char ptr} plc xr
        MOVZX               #get first char} lch wa (xr)
        CMP                 #jump if not ctrl card} bne wa =ch_mn nxts1
             nxts1
        CMP  DWORD PTR DWORD PTR cswpr,0 #jump if -noprint} bze cswpr nxts2
        JZ   nxts2
#
#      here to call lister
#
nxts1:  CALL listr          #list line} jsr listr
#
#      here after possible listing
#
nxts2:  MOV                 #point to next image} mov r_cni xr
        MOV  DWORD PTR r_cim #set as next image} mov xr r_cim
        MOV  EAX,DWORD PTR rdnln #set as current line number} mov rdnln rdcln
        MOV  DWORD PTR rdcln,EAX
        MOV  EAX,DWORD PTR cnind #set as current include depth} mov cnind lstid
        MOV  DWORD PTR lstid,EAX
        XOR  EAX,EAX        #clear next image pointer} zer r_cni
        MOV  DWORD PTR r_cni,EAX
        MOV                 #get input image length} mov sclen(xr) wa
        MOV                 #get max allowable length} mov cswin wb
        CMP                 #skip if not too long} blo wa wb nxts3
             nxts3
        MOV                 #else truncate} mov wb wa
#
#      here with length in (wa)
#
nxts3:  MOV  DWORD PTR scnil #use as record length} mov wa scnil
        XOR  EAX,EAX        #reset scnse} zer scnse
        MOV  DWORD PTR scnse,EAX
        XOR  EAX,EAX        #set line not listed yet} zer lstpf
        MOV  DWORD PTR lstpf,EAX
        RET                 #return to nexts caller} exi
                            #end procedure nexts} enp
                            #} ejc
        .eject
#
#      patin -- pattern construction for len,pos,rpos,tab,rtab
#
#      these pattern types all generate a similar node type. so
#      the construction code is shared. see functions section
#      for actual entry points for these five functions.
#
#      (wa)                  pcode for expression arg case
#      (wb)                  pcode for integer arg case
#      jsr  patin            call to build pattern node
#      ppm  loc              transfer loc for not integer or exp
#      ppm  loc              transfer loc for int out of range
#      (xr)                  pointer to constructed node
#      (xl,wa,wb,wc,ia)      destroyed
#
patin:                      #entry point} prc n 2
        .global patin
        POP  PRC_+48
        MOV                 #preserve expression arg pcode} mov wa xl
        CALL gtsmi          #try to convert arg as small integer} jsr gtsmi
        .short ptin2-DFFNC  #jump if not integer} ppm ptin2
        .short ptin3-DFFNC  #jump if out of range} ppm ptin3
#
#      common successful exit point
#
ptin1:  CALL pbild          #build pattern node} jsr pbild
        POP  EAX            #return to caller} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      here if argument is not an integer
#
ptin2:  MOV                 #copy expr arg case pcode} mov xl wb
        CMP  DWORD PTR [],offset b_e__ #all ok if expression arg} blo (xr) =b_e__ ptin1
             ptin1
        POP  EAX            #else take error exit for wrong type} exi 1
        JMP  EXI__1
#
#      here for error of out of range integer argument
#
ptin3:  POP  EAX            #take out-of-range error exit} exi 2
        JMP  EXI__2
                            #end procedure patin} enp
                            #} ejc
        .eject
#
#      patst -- pattern construction for any,notany,
#               break,span and breakx pattern functions.
#
#      these pattern functions build similar types of nodes and
#      the construction code is shared. see functions section
#      for actual entry points for these five pattern functions.
#
#      0(xs)                 string argument
#      (wb)                  pcode for one char argument
#      (xl)                  pcode for multi-char argument
#      (wc)                  pcode for expression argument
#      jsr  patst            call to build node
#      ppm  loc              if not string or expr (or null)
#      (xs)                  popped past string argument
#      (xr)                  pointer to constructed node
#      (xl)                  destroyed
#      (wa,wb,wc,ra)         destroyed
#
#      note that there is a special call to patst in the evals
#      procedure with a slightly different form. see evals
#      for details of the form of this call.
#
patst:                      #entry point} prc n 1
        .global patst
        POP  PRC_+52
        CALL gtstg          #convert argument as string} jsr gtstg
        .short pats7-DFFNC  #jump if not string} ppm pats7
        OR                  #jump if null string (catspaw)} bze wa pats7
        JZ   pats7
        CMP                 #jump if not one char string} bne wa =num01 pats2
             pats2
#
#      here for one char string case
#
        OR                  #treat as multi-char if evals call} bze wb pats2
        JZ   pats2
        ADD                 #point to character} plc xr
        MOVZX               #load character} lch xr (xr)
#
#      common exit point after successful construction
#
pats1:  CALL pbild          #call routine to build node} jsr pbild
        POP  EAX            #return to patst caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
                            #} ejc
        .eject
#
#      patst (continued)
#
#      here for multi-character string case
#
pats2:  LEA                 #save multi-char pcode} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #load current mask bit} mov ctmsk wc
        CMP                 #jump if same as last string c3.738} beq xr r_cts pats6
             pats6
        LEA                 #save string pointer} mov xr -(xs)
        MOV  DWORD PTR []
        SHL                 #shift to next position} lsh wc 1
#        OR                  #skip if position left in this tbl} nzb wc pats4  (Optimized)
        JNZ  pats4
#
#      here we must allocate a new character table
#
        MOV                 #set size of ctblk} mov *ctsi_ wa
        CALL alloc          #allocate ctblk} jsr alloc
        MOV  DWORD PTR r_ctp #store ptr to new ctblk} mov xr r_ctp
        MOV  DWORD PTR [],offset b_ctt #store type code, bump ptr} mov =b_ctt (xr)+
        LEA
        MOV                 #set number of words to clear} lct wb =cfp_a
        MOV                 #load all zero bits} mov bits0 wc
#
#      loop to clear all bits in table to zeros
#
pats3:  MOV  DWORD PTR []   #move word of zero bits} mov wc (xr)+
        LEA
        DEC                 #loop till all cleared} bct wb pats3
        JNZ  pats3
        MOV                 #set initial bit position} mov bits1 wc
#
#      merge here with bit position available
#
pats4:  MOV  DWORD PTR ctmsk #save parm2 (new bit position)} mov wc ctmsk
        MOV                 #restore pointer to argument string} mov (xs)+ xl
        LEA
        MOV  DWORD PTR r_cts #save for next time   c3.738} mov xl r_cts
        MOV                 #load string length} mov sclen(xl) wb
        OR                  #jump if null string case} bze wb pats6
        JZ   pats6
        ADD                 #point to characters in argument} plc xl
                            #} ejc
        .eject
#
#      patst (continued)
#
#      loop to set bits in column of table
#
pats5:  MOVZX               #load next character} lch wa (xl)+
        INC
        SAL                 #convert to byte offset} wtb wa
        MOV                 #point to ctblk} mov r_ctp xr
        ADD                 #point to ctblk entry} add wa xr
        MOV                 #copy bit mask} mov wc wa
        OR                  #or in bits already set} orb ctchs(xr) wa
        MOV  DWORD PTR (4*ctchs)[] #store resulting bit string} mov wa ctchs(xr)
        DEC                 #loop till all bits set} bct wb pats5
        JNZ  pats5
#
#      complete processing for multi-char string case
#
pats6:  MOV                 #load ctblk ptr as parm1 for pbild} mov r_ctp xr
        XOR                 #clear garbage ptr in xl} zer xl
        MOV                 #load pcode for multi-char str case} mov (xs)+ wb
        LEA
        JMP  pats1          #back to exit (wc=bitstring=parm2)} brn pats1
#
#      here if argument is not a string
#
#      note that the call from evals cannot pass an expression
#      since evalp always reevaluates expressions.
#
pats7:  MOV                 #set pcode for expression argument} mov wc wb
        CMP  DWORD PTR [],offset b_e__ #jump to exit if expression arg} blo (xr) =b_e__ pats1
             pats1
        POP  EAX            #else take wrong type error exit} exi 1
        JMP  EXI__1
                            #end procedure patst} enp
                            #} ejc
        .eject
#
#      pbild -- build pattern node
#
#      (xr)                  parm1 (only if required)
#      (wb)                  pcode for node
#      (wc)                  parm2 (only if required)
#      jsr  pbild            call to build node
#      (xr)                  pointer to constructed node
#      (wa)                  destroyed
#
pbild:                      #entry point} prc e 0
        .global pbild
        LEA                 #stack possible parm1} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #copy pcode} mov wb xr
        MOVZX               #load entry point id (bl_px)} lei xr
        CMP                 #jump if one parameter} beq xr =bl_p1 pbld1
             pbld1
        CMP                 #jump if no parameters} beq xr =bl_p0 pbld3
             pbld3
#
#      here for two parameter case
#
        MOV                 #set size of p2blk} mov *pcsi_ wa
        CALL alloc          #allocate block} jsr alloc
        MOV  DWORD PTR (4*parm2)[] #store second parameter} mov wc parm2(xr)
        JMP  pbld2          #merge with one parm case} brn pbld2
#
#      here for one parameter case
#
pbld1:  MOV                 #set size of p1blk} mov *pbsi_ wa
        CALL alloc          #allocate node} jsr alloc
#
#      merge here from two parm case
#
pbld2:  MOV  EAX,DWORD PTR [] #store first parameter} mov (xs) parm1(xr)
        MOV  DWORD PTR (4*parm1)[],EAX
        JMP  pbld4          #merge with no parameter case} brn pbld4
#
#      here for case of no parameters
#
pbld3:  MOV                 #set size of p0blk} mov *pasi_ wa
        CALL alloc          #allocate node} jsr alloc
#
#      merge here from other cases
#
pbld4:  MOV  DWORD PTR []   #store pcode} mov wb (xr)
        ADD                 #pop first parameter} ica xs
        MOV  DWORD PTR (4*pthen)[],offset ndnth #set nothen successor pointer} mov =ndnth pthen(xr)
        RET                 #return to pbild caller} exi
                            #end procedure pbild} enp
                            #} ejc
        .eject
#
#      pconc -- concatenate two patterns
#
#      (xl)                  ptr to right pattern
#      (xr)                  ptr to left pattern
#      jsr  pconc            call to concatenate patterns
#      (xr)                  ptr to concatenated pattern
#      (xl,wa,wb,wc)         destroyed
#
#
#      to concatenate two patterns, all successors in the left
#      pattern which point to the nothen node must be changed to
#      point to the right pattern. however, this modification
#      must be performed on a copy of the left argument rather
#      than the left argument itself, since the left argument
#      may be pointed to by some other variable value.
#
#      accordingly, it is necessary to copy the left argument.
#      this is not a trivial process since we must avoid copying
#      nodes more than once and the pattern is a graph structure
#      the following algorithm is employed.
#
#      the stack is used to store a list of nodes which
#      have already been copied. the format of the entries on
#      this list consists of a two word block. the first word
#      is the old address and the second word is the address
#      of the copy. this list is searched by the pcopy
#      routine to avoid making duplicate copies. a trick is
#      used to accomplish the concatenation at the same time.
#      a special entry is made to start with on the stack. this
#      entry records that the nothen node has been copied
#      already and the address of its copy is the right pattern.
#      this automatically performs the correct replacements.
#
pconc:                      #entry point} prc e 0
        .global pconc
        LEA                 #make room for one entry at bottom} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        MOV                 #store pointer to start of list} mov xs wc
        LEA                 #stack nothen node as old node} mov =ndnth -(xs)
        MOV  DWORD PTR [],offset ndnth
        LEA                 #store right arg as copy of nothen} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #initialize pointer to stack entries} mov xs xt
        CALL pcopy          #copy first node of left arg} jsr pcopy
        MOV  DWORD PTR (4*num02)[] #store as result under list} mov wa num02(xt)
                            #} ejc
        .eject
#
#      pconc (continued)
#
#      the following loop scans entries in the list and makes
#      sure that their successors have been copied.
#
pcnc1:  CMP                 #jump if all entries processed} beq xt xs pcnc2
             pcnc2
        LEA                 #else load next old address} mov -(xt) xr
        MOV
        MOV                 #load pointer to successor} mov pthen(xr) xr
        CALL pcopy          #copy successor node} jsr pcopy
        LEA                 #load pointer to new node (copy)} mov -(xt) xr
        MOV
        MOV  DWORD PTR (4*pthen)[] #store ptr to new successor} mov wa pthen(xr)
#
#      now check for special case of alternation node where
#      parm1 points to a node and must be copied like pthen.
#
        CMP  DWORD PTR [],offset p_alt #loop back if not} bne (xr) =p_alt pcnc1
             pcnc1
        MOV                 #else load pointer to alternative} mov parm1(xr) xr
        CALL pcopy          #copy it} jsr pcopy
        MOV                 #restore ptr to new node} mov (xt) xr
        MOV  DWORD PTR (4*parm1)[] #store ptr to copied alternative} mov wa parm1(xr)
        JMP  pcnc1          #loop back for next entry} brn pcnc1
#
#      here at end of copy process
#
pcnc2:  MOV                 #restore stack pointer} mov wc xs
        MOV                 #load pointer to copy} mov (xs)+ xr
        LEA
        RET                 #return to pconc caller} exi
                            #end procedure pconc} enp
                            #} ejc
        .eject
#
#      pcopy -- copy a pattern node
#
#      pcopy is called from the pconc procedure to copy a single
#      pattern node. the copy is only carried out if the node
#      has not been copied already.
#
#      (xr)                  pointer to node to be copied
#      (xt)                  ptr to current loc in copy list
#      (wc)                  pointer to list of copied nodes
#      jsr  pcopy            call to copy a node
#      (wa)                  pointer to copy
#      (wb,xr)               destroyed
#
pcopy:                      #entry point} prc n 0
        .global pcopy
        POP  PRC_+56
        MOV                 #save xt} mov xt wb
        MOV                 #point to start of list} mov wc xt
#
#      loop to search list of nodes copied already
#
pcop1:  SUB                 #point to next entry on list} dca xt
        CMP                 #jump if match} beq xr (xt) pcop2
             pcop2
        SUB                 #else skip over copied address} dca xt
        CMP                 #loop back if more to test} bne xt xs pcop1
             pcop1
#
#      here if not in list, perform copy
#
        MOV                 #load first word of block} mov (xr) wa
        CALL blkln          #get length of block} jsr blkln
        MOV                 #save pointer to old node} mov xr xl
        CALL alloc          #allocate space for copy} jsr alloc
        LEA                 #store old address on list} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #store new address on list} mov xr -(xs)
        MOV  DWORD PTR []
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
        SHR  ECX,2          #move words from old block to copy} mvw
        REP  MOVSD
        MOV                 #load pointer to copy} mov (xs) wa
        JMP  pcop3          #jump to exit} brn pcop3
#
#      here if we find entry in list
#
pcop2:  LEA                 #load address of copy from list} mov -(xt) wa
        MOV
#
#      common exit point
#
pcop3:  MOV                 #restore xt} mov wb xt
        RET                 #return to pcopy caller} exi
                            #end procedure pcopy} enp
                            #} ejc
        .eject
#
#      prflr -- print profile
#      prflr is called to print the contents of the profile
#      table in a fairly readable tabular format.
#
#      jsr  prflr            call to print profile
#      (wa,ia)               destroyed
#
prflr:                      #} prc e 0
        .global prflr
        CMP  DWORD PTR DWORD PTR pfdmp,0 #no printing if no profiling done} bze pfdmp prfl4
        JZ   prfl4
        LEA                 #preserve entry xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR pfsvw #and also wb} mov wb pfsvw
        CALL prtpg          #eject} jsr prtpg
        MOV                 #load msg /program profile/} mov =pfms1 xr
        CALL prtst          #and print it} jsr prtst
        CALL prtnl          #followed by newline} jsr prtnl
        CALL prtnl          #and another} jsr prtnl
        MOV                 #point to first hdr} mov =pfms2 xr
        CALL prtst          #print it} jsr prtst
        CALL prtnl          #new line} jsr prtnl
        MOV                 #second hdr} mov =pfms3 xr
        CALL prtst          #print it} jsr prtst
        CALL prtnl          #new line} jsr prtnl
        CALL prtnl          #and another blank line} jsr prtnl
        XOR                 #initial stmt count} zer wb
        MOV                 #point to table origin} mov pftbl xr
        ADD                 #bias past xnblk header (sgd07)} add *xndta xr
#
#      loop here to print successive entries
#
prfl1:  INC                 #bump stmt nr} icv wb
        MOV  EDX,DWORD PTR [] #load nr of executions} ldi (xr)
        OR   EDX,EDX        #no printing if zero} ieq prfl3
        JE   prfl3
        MOV  DWORD PTR profs,pfpd1 #point where to print} mov =pfpd1 profs
        CALL prtin          #and print it} jsr prtin
        XOR  EAX,EAX        #back to start of line} zer profs
        MOV  DWORD PTR profs,EAX
        MOV  EDX            #load stmt nr} mti wb
        CALL prtin          #print it there} jsr prtin
        MOV  DWORD PTR profs,pfpd2 #and pad past count} mov =pfpd2 profs
        MOV  EDX,DWORD PTR (4*cfp_i)[] #load total exec time} ldi cfp_i(xr)
        CALL prtin          #print that too} jsr prtin
        MOV  EDX,DWORD PTR (4*cfp_i)[] #reload time} ldi cfp_i(xr)
        IMUL EDX,DWORD PTR intth #convert to microsec} mli intth
        JO   prfl2          #omit next bit if overflow} iov prfl2
        MOV  EAX,DWORD PTR [] #divide by executions} dvi (xr)
        CALL dvi_
        MOV  DWORD PTR profs,pfpd3 #pad last print} mov =pfpd3 profs
        CALL prtin          #and print mcsec/execn} jsr prtin
#
#      merge after printing time
#
prfl2:  CALL prtnl          #thats another line} jsr prtnl
#
#      here to go to next entry
#
prfl3:  ADD                 #bump index ptr (sgd07)} add *pf_i2 xr
        CMP                 #loop if more stmts} blt wb pfnte prfl1
             prfl1
        MOV                 #restore callers xr} mov (xs)+ xr
        LEA
        MOV                 #and wb too} mov pfsvw wb
#
#      here to exit
#
prfl4:  RET                 #return} exi
                            #end of prflr} enp
                            #} ejc
        .eject
#
#      prflu -- update an entry in the profile table
#
#      on entry, kvstn contains nr of stmt to profile
#
#      jsr  prflu            call to update entry
#      (ia)                  destroyed
#
prflu:                      #} prc e 0
        .global prflu
        CMP  DWORD PTR DWORD PTR pffnc,0 #skip if just entered function} bnz pffnc pflu4
        JNZ  pflu4
        LEA                 #preserve entry xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR pfsvw #save wa (sgd07)} mov wa pfsvw
        CMP  DWORD PTR DWORD PTR pftbl,0 #branch if table allocated} bnz pftbl pflu2
        JNZ  pflu2
#
#      here if space for profile table not yet allocated.
#      calculate size needed, allocate a static xnblk, and
#      initialize it all to zero.
#      the time taken for this will be attributed to the current
#      statement (assignment to keywd profile), but since the
#      timing for this statement is up the pole anyway, this
#      doesnt really matter...
#
        SUB  DWORD PTR pfnte,num01 #adjust for extra count (sgd07)} sub =num01 pfnte
        MOV  EDX,DWORD PTR pfi2a #convrt entry size to int} mti pfi2a
        MOV  DWORD PTR pfste,EDX #and store safely for later} sti pfste
        MOV  EDX,DWORD PTR pfnte #load table length as integer} mti pfnte
        IMUL EDX,DWORD PTR pfste #multiply by entry size} mli pfste
        MOV                 #get back address-style} mfi wa
        ADD                 #add on 2 word overhead} add =num02 wa
        SAL                 #convert the whole lot to bytes} wtb wa
        CALL alost          #gimme the space} jsr alost
        MOV  DWORD PTR pftbl #save block pointer} mov xr pftbl
        MOV  DWORD PTR [],offset b_xnt #put block type and ...} mov =b_xnt (xr)+
        LEA
        MOV  DWORD PTR []   #... length into header} mov wa (xr)+
        LEA
        MOV                 #get back nr of wds in data area} mfi wa
#
#      loop here to zero the block data
#
pflu1:  XOR  EAX,EAX        #blank a word} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        DEC                 #and alllllll the rest} bct wa pflu1
        JNZ  pflu1
#
#      end of allocation. merge back into routine
#
pflu2:  MOV  EDX,DWORD PTR kvstn #load nr of stmt just ended} mti kvstn
        SUB  EDX,DWORD PTR intv1 #make into index offset} sbi intv1
        IMUL EDX,DWORD PTR pfste #make offset of table entry} mli pfste
        MOV                 #convert to address} mfi wa
        SAL                 #get as baus} wtb wa
        ADD                 #offset includes table header} add *num02 wa
        MOV                 #get table start} mov pftbl xr
        CMP                 #if out of table, skip it} bge wa num01(xr) pflu3
             pflu3
        ADD                 #else point to entry} add wa xr
        MOV  EDX,DWORD PTR [] #get nr of executions so far} ldi (xr)
        ADD  EDX,DWORD PTR intv1 #nudge up one} adi intv1
        MOV  DWORD PTR [],EDX #and put back} sti (xr)
        CALL systm          #get time now} jsr systm
        MOV  DWORD PTR pfetm,EDX #stash ending time} sti pfetm
        SUB  EDX,DWORD PTR pfstm #subtract start time} sbi pfstm
        ADD  EDX,DWORD PTR (4*cfp_i)[] #add cumulative time so far} adi cfp_i(xr)
        MOV  DWORD PTR (4*cfp_i)[],EDX #and put back new total} sti cfp_i(xr)
        MOV  EDX,DWORD PTR pfetm #load end time of this stmt ...} ldi pfetm
        MOV  DWORD PTR pfstm,EDX #... which is start time of next} sti pfstm
#
#      merge here to exit
#
pflu3:  MOV                 #restore callers xr} mov (xs)+ xr
        LEA
        MOV                 #restore saved reg} mov pfsvw wa
        RET                 #and return} exi
#
#      here if profile is suppressed because a program defined
#      function is about to be entered, and so the current stmt
#      has not yet finished
#
pflu4:  XOR  EAX,EAX        #reset the condition flag} zer pffnc
        MOV  DWORD PTR pffnc,EAX
        RET                 #and immediate return} exi
                            #end of procedure prflu} enp
                            #} ejc
        .eject
#
#      prpar - process print parameters
#
#      (wc)                  if nonzero associate terminal only
#      jsr  prpar            call to process print parameters
#      (xl,xr,wa,wb,wc)      destroyed
#
#      since memory allocation is undecided on initial call,
#      terminal cannot be associated. the entry with wc non-zero
#      is provided so a later call can be made to complete this.
#
prpar:                      #entry point} prc e 0
        .global prpar
        OR                  #jump to associate terminal} bnz wc prpa8
        JNZ  prpa8
        CALL syspp          #get print parameters} jsr syspp
        OR                  #jump if lines/page specified} bnz wb prpa1
        JNZ  prpa1
        MOV                 #else use a large value} mov =cfp_m wb
        SHR                 #but not too large} rsh wb 1
#
#      store line count/page
#
prpa1:  MOV  DWORD PTR lstnp #store number of lines/page} mov wb lstnp
        MOV  DWORD PTR lstlc #pretend page is full initially} mov wb lstlc
        XOR  EAX,EAX        #clear page number} zer lstpg
        MOV  DWORD PTR lstpg,EAX
        MOV                 #get prior length if any} mov prlen wb
        OR                  #skip if no length} bze wb prpa2
        JZ   prpa2
        CMP                 #skip storing if too big} bgt wa wb prpa3
             prpa3
#
#      store print buffer length
#
prpa2:  MOV  DWORD PTR prlen #store value} mov wa prlen
#
#      process bits options
#
prpa3:  MOV                 #bit 3 mask} mov bits3 wb
        AND                 #get -nolist bit} anb wc wb
#        OR                  #skip if clear} zrb wb prpa4  (Optimized)
        JZ   prpa4
        XOR  EAX,EAX        #set -nolist} zer cswls
        MOV  DWORD PTR cswls,EAX
#
#      check if fail reports goto interactive channel
#
prpa4:  MOV                 #bit 1 mask} mov bits1 wb
        AND                 #get bit} anb wc wb
        MOV  DWORD PTR erich #store int. chan. error flag} mov wb erich
        MOV                 #bit 2 mask} mov bits2 wb
        AND                 #get bit} anb wc wb
        MOV  DWORD PTR prich #flag for std printer on int. chan.} mov wb prich
        MOV                 #bit 4 mask} mov bits4 wb
        AND                 #get bit} anb wc wb
        MOV  DWORD PTR cpsts #flag for compile stats suppressn.} mov wb cpsts
        MOV                 #bit 5 mask} mov bits5 wb
        AND                 #get bit} anb wc wb
        MOV  DWORD PTR exsts #flag for exec stats suppression} mov wb exsts
                            #} ejc
        .eject
#
#      prpar (continued)
#
        MOV                 #bit 6 mask} mov bits6 wb
        AND                 #get bit} anb wc wb
        MOV  DWORD PTR precl #extended/compact listing flag} mov wb precl
        SUB                 #point 8 chars from line end} sub =num08 wa
#        OR                  #jump if not extended} zrb wb prpa5  (Optimized)
        JZ   prpa5
        MOV  DWORD PTR lstpo #store for listing page headings} mov wa lstpo
#
#       continue option processing
#
prpa5:  MOV                 #bit 7 mask} mov bits7 wb
        AND                 #get bit 7} anb wc wb
        MOV  DWORD PTR cswex #set -noexecute if non-zero} mov wb cswex
        MOV                 #bit 10 mask} mov bit10 wb
        AND                 #get bit 10} anb wc wb
        MOV  DWORD PTR headp #pretend printed to omit headers} mov wb headp
        MOV                 #bit 9 mask} mov bits9 wb
        AND                 #get bit 9} anb wc wb
        MOV  DWORD PTR prsto #keep it as std listing option} mov wb prsto
        MOV                 #copy flags} mov wc wb
        SHR                 #right justify bit 13} rsh wb 12
        AND                 #get bit} anb bits1 wb
        MOV  DWORD PTR kvcas #set -case} mov wb kvcas
        MOV                 #bit 12 mask} mov bit12 wb
        AND                 #get bit 12} anb wc wb
        MOV  DWORD PTR cswer #keep it as errors/noerrors option} mov wb cswer
        OR                  #skip if clear} zrb wb prpa6
        JZ   prpa6
        MOV                 #get print buffer length} mov prlen wa
        SUB                 #point 8 chars from line end} sub =num08 wa
        MOV  DWORD PTR lstpo #store page offset} mov wa lstpo
#
#      check for -print/-noprint
#
prpa6:  MOV                 #bit 11 mask} mov bit11 wb
        AND                 #get bit 11} anb wc wb
        MOV  DWORD PTR cswpr #set -print if non-zero} mov wb cswpr
#
#      check for terminal
#
        AND                 #see if terminal to be activated} anb bits8 wc
#        OR                  #jump if terminal required} bnz wc prpa8  (Optimized)
        JNZ  prpa8
        CMP  DWORD PTR DWORD PTR initr,0 #jump if no terminal to detach} bze initr prpa9
        JZ   prpa9
        MOV                 #ptr to /terminal/} mov =v_ter xl
        CALL gtnvr          #get vrblk pointer} jsr gtnvr
        .short ERR_-299-DFFNC #cant fail} ppm
        MOV  DWORD PTR (4*vrval)[],offset nulls #clear value of terminal} mov =nulls vrval(xr)
        CALL setvr          #remove association} jsr setvr
        JMP  prpa9          #return} brn prpa9
#
#      associate terminal
#
prpa8:  MOV  DWORD PTR initr,ESP #note terminal associated} mnz initr
        CMP  DWORD PTR DWORD PTR dnamb,0 #cant if memory not organised} bze dnamb prpa9
        JZ   prpa9
        MOV                 #point to terminal string} mov =v_ter xl
        MOV                 #output trace type} mov =trtou wb
        CALL inout          #attach output trblk to vrblk} jsr inout
        LEA                 #stack trblk ptr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #point to terminal string} mov =v_ter xl
        MOV                 #input trace type} mov =trtin wb
        CALL inout          #attach input trace blk} jsr inout
        MOV  EAX,DWORD PTR [] #add output trblk to chain} mov (xs)+ vrval(xr)
        MOV  DWORD PTR (4*vrval)[],EAX
        LEA
#
#      return point
#
prpa9:  RET                 #return} exi
                            #end procedure prpar} enp
                            #} ejc
        .eject
#
#      prtch -- print a character
#
#      prtch is used to print a single character
#
#      (wa)                  character to be printed
#      jsr  prtch            call to print character
#
prtch:                      #entry point} prc e 0
        .global prtch
        LEA                 #save xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  EAX,DWORD PTR profs #jump if room in buffer} bne profs prlen prch1
        CMP  EAX,DWORD PTR prlen
             prch1
        CALL prtnl          #else print this line} jsr prtnl
#
#      here after making sure we have room
#
prch1:  MOV                 #point to print buffer} mov prbuf xr
        ADD                 #point to next character location} psc xr profs
        ADD
        MOV  [ESI]          #store new character} sch wa (xr)
        INC  DWORD PTR profs #bump pointer} icv profs
        MOV                 #restore entry xr} mov (xs)+ xr
        LEA
        RET                 #return to prtch caller} exi
                            #end procedure prtch} enp
                            #} ejc
        .eject
#
#      prtic -- print to interactive channel
#
#      prtic is called to print the contents of the standard
#      print buffer to the interactive channel. it is only
#      called after prtst has set up the string for printing.
#      it does not clear the buffer.
#
#      jsr  prtic            call for print
#      (wa,wb)               destroyed
#
prtic:                      #entry point} prc e 0
        .global prtic
        LEA                 #save xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #point to buffer} mov prbuf xr
        MOV                 #no of chars} mov profs wa
        CALL syspi          #print} jsr syspi
        .short prtc2-DFFNC  #fail return} ppm prtc2
#
#      return
#
prtc1:  MOV                 #restore xr} mov (xs)+ xr
        LEA
        RET                 #return} exi
#
#      error occured
#
prtc2:  XOR  EAX,EAX        #prevent looping} zer erich
        MOV  DWORD PTR erich,EAX
        CALL ERR_0          #} erb 252 error on printing to interactive channel
        .byte 252
        JMP  prtc1          #return} brn prtc1
                            #procedure prtic} enp
                            #} ejc
        .eject
#
#      prtis -- print to interactive and standard printer
#
#      prtis puts a line from the print buffer onto the
#      interactive channel (if any) and the standard printer.
#      it always prints to the standard printer but does
#      not duplicate lines if the standard printer is
#      interactive.  it clears down the print buffer.
#
#      jsr  prtis            call for printing
#      (wa,wb)               destroyed
#
prtis:                      #entry point} prc e 0
        .global prtis
        CMP  DWORD PTR DWORD PTR prich,0 #jump if standard printer is int.ch.} bnz prich prts1
        JNZ  prts1
        CMP  DWORD PTR DWORD PTR erich,0 #skip if not doing int. error reps.} bze erich prts1
        JZ   prts1
        CALL prtic          #print to interactive channel} jsr prtic
#
#      merge and exit
#
prts1:  CALL prtnl          #print to standard printer} jsr prtnl
        RET                 #return} exi
                            #end procedure prtis} enp
                            #} ejc
        .eject
#
#      prtin -- print an integer
#
#      prtin prints the integer value which is in the integer
#      accumulator. blocks built in dynamic storage
#      during this process are immediately deleted.
#
#      (ia)                  integer value to be printed
#      jsr  prtin            call to print integer
#      (ia,ra)               destroyed
#
prtin:                      #entry point} prc e 0
        .global prtin
        LEA                 #save xr} mov xr -(xs)
        MOV  DWORD PTR []
        CALL icbld          #build integer block} jsr icbld
        CMP                 #jump if icblk below dynamic} blo xr dnamb prti1
             prti1
        CMP                 #jump if above dynamic} bhi xr dnamp prti1
             prti1
        MOV  DWORD PTR dnamp #immediately delete it} mov xr dnamp
#
#      delete icblk from dynamic store
#
prti1:  LEA                 #stack ptr for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert to string} jsr gtstg
        .short ERR_-299-DFFNC #convert error is impossible} ppm
        MOV  DWORD PTR dnamp #reset pointer to delete scblk} mov xr dnamp
        CALL prtst          #print integer string} jsr prtst
        MOV                 #restore entry xr} mov (xs)+ xr
        LEA
        RET                 #return to prtin caller} exi
                            #end procedure prtin} enp
                            #} ejc
        .eject
#
#      prtmi -- print message and integer
#
#      prtmi is used to print messages together with an integer
#      value starting in column 15 (used by the routines at
#      the end of compilation).
#
#      jsr  prtmi            call to print message and integer
#
prtmi:                      #entry point} prc e 0
        .global prtmi
        CALL prtst          #print string message} jsr prtst
        MOV  DWORD PTR profs,prtmf #set column offset} mov =prtmf profs
        CALL prtin          #print integer} jsr prtin
        CALL prtnl          #print line} jsr prtnl
        RET                 #return to prtmi caller} exi
                            #end procedure prtmi} enp
                            #} ejc
        .eject
#
#      prtmm -- print memory used and available
#
#      prtmm is used to provide memory usage information in
#      both the end-of-compile and end-of-run statistics.
#
#      jsr  prtmm            call to print memory stats
#
prtmm:                      #} prc e 0
        .global prtmm
        MOV                 #next available loc} mov dnamp wa
        SUB                 #minus start} sub statb wa
        MOV  EDX            #convert to integer} mti wa
        MOV                 #point to /memory used (words)/} mov =encm1 xr
        CALL prtmi          #print message} jsr prtmi
        MOV                 #end of memory} mov dname wa
        SUB                 #minus next available loc} sub dnamp wa
        MOV  EDX            #convert to integer} mti wa
        MOV                 #point to /memory available (words)/} mov =encm2 xr
        CALL prtmi          #print line} jsr prtmi
        RET                 #return to prtmm caller} exi
                            #end of procedure prtmm} enp
                            #} ejc
        .eject
#
#      prtmx  -- as prtmi with extra copy to interactive chan.
#
#      jsr  prtmx            call for printing
#      (wa,wb)               destroyed
#
prtmx:                      #entry point} prc e 0
        .global prtmx
        CALL prtst          #print string message} jsr prtst
        MOV  DWORD PTR profs,prtmf #set column offset} mov =prtmf profs
        CALL prtin          #print integer} jsr prtin
        CALL prtis          #print line} jsr prtis
        RET                 #return} exi
                            #end procedure prtmx} enp
                            #} ejc
        .eject
#
#      prtnl -- print new line (end print line)
#
#      prtnl prints the contents of the print buffer, resets
#      the buffer to all blanks and resets the print pointer.
#
#      jsr  prtnl            call to print line
#
prtnl:                      #entry point} prc r 0
        .global prtnl
        CMP  DWORD PTR DWORD PTR headp,0 #were headers printed} bnz headp prnl0
        JNZ  prnl0
        CALL prtps          #no - print them} jsr prtps
#
#      call syspr
#
prnl0:  LEA                 #save entry xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR prtsa #save wa} mov wa prtsa
        MOV  DWORD PTR prtsb #save wb} mov wb prtsb
        MOV                 #load pointer to buffer} mov prbuf xr
        MOV                 #load number of chars in buffer} mov profs wa
        CALL syspr          #call system print routine} jsr syspr
        .short prnl2-DFFNC  #jump if failed} ppm prnl2
        MOV                 #load length of buffer in words} lct wa prlnw
        ADD                 #point to chars of buffer} add *schar xr
        MOV                 #get word of blanks} mov nullw wb
#
#      loop to blank buffer
#
prnl1:  MOV  DWORD PTR []   #store word of blanks, bump ptr} mov wb (xr)+
        LEA
        DEC                 #loop till all blanked} bct wa prnl1
        JNZ  prnl1
#
#      exit point
#
        MOV                 #restore wb} mov prtsb wb
        MOV                 #restore wa} mov prtsa wa
        MOV                 #restore entry xr} mov (xs)+ xr
        LEA
        XOR  EAX,EAX        #reset print buffer pointer} zer profs
        MOV  DWORD PTR profs,EAX
        RET                 #return to prtnl caller} exi
#
#      file full or no output file for load module
#
prnl2:  CMP  DWORD PTR DWORD PTR prtef,0 #jump if not first time} bnz prtef prnl3
        JNZ  prnl3
        MOV  DWORD PTR prtef,ESP #mark first occurrence} mnz prtef
        CALL ERR_0          #} erb 253 print limit exceeded on standard output channel
        .byte 253
#
#      stop at once
#
prnl3:  MOV                 #ending code} mov =nini8 wb
        MOV                 #statement number} mov kvstn wa
        MOV                 #get fcblk chain head} mov r_fcb xl
        CALL sysej          #stop} jsr sysej
                            #end procedure prtnl} enp
                            #} ejc
        .eject
#
#      prtnm -- print variable name
#
#      prtnm is used to print a character representation of the
#      name of a variable (not a value of datatype name)
#      names of pseudo-variables may not be passed to prtnm.
#
#      (xl)                  name base
#      (wa)                  name offset
#      jsr  prtnm            call to print name
#      (wb,wc,ra)            destroyed
#
prtnm:                      #entry point (recursive, see prtvl)} prc r 0
        .global prtnm
        LEA                 #save wa (offset is collectable)} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #save entry xr} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #save name base} mov xl -(xs)
        MOV  DWORD PTR []
        CMP                 #jump if not natural variable} bhi xl state prn02
             prn02
#
#      here for natural variable name, recognized by the fact
#      that the name base points into the static area.
#
        MOV                 #point to vrblk} mov xl xr
        CALL prtvn          #print name of variable} jsr prtvn
#
#      common exit point
#
prn01:  MOV                 #restore name base} mov (xs)+ xl
        LEA
        MOV                 #restore entry value of xr} mov (xs)+ xr
        LEA
        MOV                 #restore wa} mov (xs)+ wa
        LEA
        RET                 #return to prtnm caller} exi
#
#      here for case of non-natural variable
#
prn02:  MOV                 #copy name offset} mov wa wb
        CMP  DWORD PTR [],offset b_pdt #jump if array or table} bne (xl) =b_pdt prn03
             prn03
#
#      for program defined datatype, prt fld name, left paren
#
        MOV                 #load pointer to dfblk} mov pddfp(xl) xr
        ADD                 #add name offset} add wa xr
        MOV                 #load vrblk pointer for field} mov pdfof(xr) xr
        CALL prtvn          #print field name} jsr prtvn
        MOV                 #load left paren} mov =ch_pp wa
        CALL prtch          #print character} jsr prtch
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      now we print an identifying name for the object if one
#      can be found. the following code searches for a natural
#      variable which contains this object as value. if such a
#      variable is found, its name is printed, else the value
#      of the object (as printed by prtvl) is used instead.
#
#      first we point to the parent tbblk if this is the case of
#      a table element. to do this, chase down the trnxt chain.
#
prn03:  CMP  DWORD PTR [],offset b_tet #jump if we got there (or not te)} bne (xl) =b_tet prn04
             prn04
        MOV                 #else move out on chain} mov tenxt(xl) xl
        JMP  prn03          #and loop back} brn prn03
#
#      now we are ready for the search. to speed things up in
#      the case of calls from dump where the same name base
#      will occur repeatedly while dumping an array or table,
#      we remember the last vrblk pointer found in prnmv. so
#      first check to see if we have this one again.
#
prn04:  MOV                 #point to vrblk we found last time} mov prnmv xr
        MOV                 #point to hash table in case not} mov hshtb wa
        JMP  prn07          #jump into search for special check} brn prn07
#
#      loop through hash slots
#
prn05:  MOV                 #copy slot pointer} mov wa xr
        ADD                 #bump slot pointer} ica wa
        SUB                 #introduce standard vrblk offset} sub *vrnxt xr
#
#      loop through vrblks on one hash chain
#
prn06:  MOV                 #point to next vrblk on hash chain} mov vrnxt(xr) xr
#
#      merge here first time to check block we found last time
#
prn07:  MOV                 #copy vrblk pointer} mov xr wc
        OR                  #jump if chain end (or prnmv zero)} bze wc prn09
        JZ   prn09
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      loop to find value (chase down possible trblk chain)
#
prn08:  MOV                 #load value} mov vrval(xr) xr
        CMP  DWORD PTR [],offset b_trt #loop if that was a trblk} beq (xr) =b_trt prn08
             prn08
#
#      now we have the value, is this the block we want
#
        CMP                 #jump if this matches the name base} beq xr xl prn10
             prn10
        MOV                 #else point back to that vrblk} mov wc xr
        JMP  prn06          #and loop back} brn prn06
#
#      here to move to next hash slot
#
prn09:  CMP                 #loop back if more to go} blt wa hshte prn05
             prn05
        MOV                 #else not found, copy value pointer} mov xl xr
        CALL prtvl          #print value} jsr prtvl
        JMP  prn11          #and merge ahead} brn prn11
#
#      here when we find a matching entry
#
prn10:  MOV                 #copy vrblk pointer} mov wc xr
        MOV  DWORD PTR prnmv #save for next time in} mov xr prnmv
        CALL prtvn          #print variable name} jsr prtvn
#
#      merge here if no entry found
#
prn11:  MOV                 #load first word of name base} mov (xl) wc
        CMP                 #jump if not program defined} bne wc =b_pdt prn13
             prn13
#
#      for program defined datatype, add right paren and exit
#
        MOV                 #load right paren, merge} mov =ch_rp wa
#
#      merge here to print final right paren or bracket
#
prn12:  CALL prtch          #print final character} jsr prtch
        MOV                 #restore name offset} mov wb wa
        JMP  prn01          #merge back to exit} brn prn01
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      here for array or table
#
prn13:  MOV                 #load left bracket} mov =ch_bb wa
        CALL prtch          #and print it} jsr prtch
        MOV                 #restore block pointer} mov (xs) xl
        MOV                 #load type word again} mov (xl) wc
        CMP                 #jump if not table} bne wc =b_tet prn15
             prn15
#
#      here for table, print subscript value
#
        MOV                 #load subscript value} mov tesub(xl) xr
        MOV                 #save name offset} mov wb xl
        CALL prtvl          #print subscript value} jsr prtvl
        MOV                 #restore name offset} mov xl wb
#
#      merge here from array case to print right bracket
#
prn14:  MOV                 #load right bracket} mov =ch_rb wa
        JMP  prn12          #merge back to print it} brn prn12
#
#      here for array or vector, to print subscript(s)
#
prn15:  MOV                 #copy name offset} mov wb wa
        SHR                 #convert to words} btw wa
        CMP                 #jump if arblk} beq wc =b_art prn16
             prn16
#
#      here for vector
#
        SUB                 #adjust for standard fields} sub =vcvlb wa
        MOV  EDX            #move to integer accum} mti wa
        CALL prtin          #print linear subscript} jsr prtin
        JMP  prn14          #merge back for right bracket} brn prn14
                            #} ejc
        .eject
#
#      prtnm (continued)
#
#      here for array. first calculate absolute subscript
#      offsets by successive divisions by the dimension values.
#      this must be done right to left since the elements are
#      stored row-wise. the subscripts are stacked as integers.
#
prn16:  MOV                 #load length of bounds info} mov arofs(xl) wc
        ADD                 #adjust for arpro field} ica wc
        SHR                 #convert to words} btw wc
        SUB                 #get linear zero-origin subscript} sub wc wa
        MOV  EDX            #get integer value} mti wa
        MOV                 #set num of dimensions as loop count} lct wa arndm(xl)
        ADD                 #point past bounds information} add arofs(xl) xl
        SUB                 #set ok offset for proper ptr later} sub *arlbd xl
#
#      loop to stack subscript offsets
#
prn17:  SUB                 #point to next set of bounds} sub *ardms xl
        MOV  DWORD PTR prnsi,EDX #save current offset} sti prnsi
        MOV  EAX,DWORD PTR (4*ardim)[] #get remainder on dividing by dimens} rmi ardim(xl)
        CALL rmi_
        LEA                 #store on stack (one word)} mfi -(xs)
        MOV  DWORD PTR [],EDX
        MOV  EDX,DWORD PTR prnsi #reload argument} ldi prnsi
        MOV  EAX,DWORD PTR (4*ardim)[] #divide to get quotient} dvi ardim(xl)
        CALL dvi_
        DEC                 #loop till all stacked} bct wa prn17
        JNZ  prn17
        XOR                 #set offset to first set of bounds} zer xr
        MOV                 #load count of dims to control loop} lct wb arndm(xl)
        JMP  prn19          #jump into print loop} brn prn19
#
#      loop to print subscripts from stack adjusting by adding
#      the appropriate low bound value from the arblk
#
prn18:  MOV                 #load a comma} mov =ch_cm wa
        CALL prtch          #print it} jsr prtch
#
#      merge here first time in (no comma required)
#
prn19:  MOV  EDX,DWORD PTR [] #load subscript offset as integer} mti (xs)+
        LEA
        ADD                 #point to current lbd} add xr xl
        ADD  EDX,DWORD PTR (4*arlbd)[] #add lbd to get signed subscript} adi arlbd(xl)
        SUB                 #point back to start of arblk} sub xr xl
        CALL prtin          #print subscript} jsr prtin
        ADD                 #bump offset to next bounds} add *ardms xr
        DEC                 #loop back till all printed} bct wb prn18
        JNZ  prn18
        JMP  prn14          #merge back to print right bracket} brn prn14
                            #end procedure prtnm} enp
                            #} ejc
        .eject
#
#      prtnv -- print name value
#
#      prtnv is used by the trace and dump routines to print
#      a line of the form
#
#      name = value
#
#      note that the name involved can never be a pseudo-var
#
#      (xl)                  name base
#      (wa)                  name offset
#      jsr  prtnv            call to print name = value
#      (wb,wc,ra)            destroyed
#
prtnv:                      #entry point} prc e 0
        .global prtnv
        CALL prtnm          #print argument name} jsr prtnm
        LEA                 #save entry xr} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #save name offset (collectable)} mov wa -(xs)
        MOV  DWORD PTR []
        MOV                 #point to blank equal blank} mov =tmbeb xr
        CALL prtst          #print it} jsr prtst
        MOV                 #copy name base} mov xl xr
        ADD                 #point to value} add wa xr
        MOV                 #load value pointer} mov (xr) xr
        CALL prtvl          #print value} jsr prtvl
        CALL prtnl          #terminate line} jsr prtnl
        MOV                 #restore name offset} mov (xs)+ wa
        LEA
        MOV                 #restore entry xr} mov (xs)+ xr
        LEA
        RET                 #return to caller} exi
                            #end procedure prtnv} enp
                            #} ejc
        .eject
#
#      prtpg  -- print a page throw
#
#      prints a page throw or a few blank lines on the standard
#      listing channel depending on the listing options chosen.
#
#      jsr  prtpg            call for page eject
#
prtpg:                      #entry point} prc e 0
        .global prtpg
        CMP  DWORD PTR stage,stgxt #jump if execution time} beq stage =stgxt prp01
             prp01
        CMP  DWORD PTR DWORD PTR lstlc,0 #return if top of page already} bze lstlc prp06
        JZ   prp06
        XOR  EAX,EAX        #clear line count} zer lstlc
        MOV  DWORD PTR lstlc,EAX
#
#      check type of listing
#
prp01:  LEA                 #preserve xr} mov xr -(xs)
        MOV  DWORD PTR []
        CMP  DWORD PTR DWORD PTR prstd,0 #eject if flag set} bnz prstd prp02
        JNZ  prp02
        CMP  DWORD PTR DWORD PTR prich,0 #jump if interactive listing channel} bnz prich prp03
        JNZ  prp03
        CMP  DWORD PTR DWORD PTR precl,0 #jump if compact listing} bze precl prp03
        JZ   prp03
#
#      perform an eject
#
prp02:  CALL sysep          #eject} jsr sysep
        JMP  prp04          #merge} brn prp04
#
#      compact or interactive channel listing. cant print
#      blanks until check made for headers printed and flag set.
#
#
prp03:  MOV                 #remember headp} mov headp xr
        MOV  DWORD PTR headp,ESP #set to avoid repeated prtpg calls} mnz headp
        CALL prtnl          #print blank line} jsr prtnl
        CALL prtnl          #print blank line} jsr prtnl
        CALL prtnl          #print blank line} jsr prtnl
        MOV  DWORD PTR lstlc,num03 #count blank lines} mov =num03 lstlc
        MOV  DWORD PTR headp #restore header flag} mov xr headp
                            #} ejc
        .eject
#
#      prptg (continued)
#
#      print the heading
#
prp04:  CMP  DWORD PTR DWORD PTR headp,0 #jump if header listed} bnz headp prp05
        JNZ  prp05
        MOV  DWORD PTR headp,ESP #mark headers printed} mnz headp
        LEA                 #keep xl} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #point to listing header} mov =headr xr
        CALL prtst          #place it} jsr prtst
        CALL sysid          #get system identification} jsr sysid
        CALL prtst          #append extra chars} jsr prtst
        CALL prtnl          #print it} jsr prtnl
        MOV                 #extra header line} mov xl xr
        CALL prtst          #place it} jsr prtst
        CALL prtnl          #print it} jsr prtnl
        CALL prtnl          #print a blank} jsr prtnl
        CALL prtnl          #and another} jsr prtnl
        ADD  DWORD PTR lstlc,num04 #four header lines printed} add =num04 lstlc
        MOV                 #restore xl} mov (xs)+ xl
        LEA
#
#      merge if header not printed
#
prp05:  MOV                 #restore xr} mov (xs)+ xr
        LEA
#
#      return
#
prp06:  RET                 #return} exi
                            #end procedure prtpg} enp
                            #} ejc
        .eject
#
#      prtps - print page with test for standard listing option
#
#      if the standard listing option is selected, insist that
#      an eject be done
#
#      jsr  prtps            call for eject
#
prtps:                      #entry point} prc e 0
        .global prtps
        MOV  EAX,DWORD PTR prsto #copy option flag} mov prsto prstd
        MOV  DWORD PTR prstd,EAX
        CALL prtpg          #print page} jsr prtpg
        XOR  EAX,EAX        #clear flag} zer prstd
        MOV  DWORD PTR prstd,EAX
        RET                 #return} exi
                            #end procedure prtps} enp
                            #} ejc
        .eject
#
#      prtsn -- print statement number
#
#      prtsn is used to initiate a print trace line by printing
#      asterisks and the current statement number. the actual
#      format of the output generated is.
#
#      ***nnnnn**** iii.....iiii
#
#      nnnnn is the statement number with leading zeros replaced
#      by asterisks (e.g. *******9****)
#
#      iii...iii represents a variable length output consisting
#      of a number of letter i characters equal to fnclevel.
#
#      jsr  prtsn            call to print statement number
#      (wc)                  destroyed
#
prtsn:                      #entry point} prc e 0
        .global prtsn
        LEA                 #save entry xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  DWORD PTR prsna #save entry wa} mov wa prsna
        MOV                 #point to asterisks} mov =tmasb xr
        CALL prtst          #print asterisks} jsr prtst
        MOV  DWORD PTR profs,num04 #point into middle of asterisks} mov =num04 profs
        MOV  EDX,DWORD PTR kvstn #load statement number as integer} mti kvstn
        CALL prtin          #print integer statement number} jsr prtin
        MOV  DWORD PTR profs,prsnf #point past asterisks plus blank} mov =prsnf profs
        MOV                 #get fnclevel} mov kvfnc xr
        MOV                 #set letter i} mov =ch_li wa
#
#      loop to generate letter i fnclevel times
#
prsn1:  OR                  #jump if all set} bze xr prsn2
        JZ   prsn2
        CALL prtch          #else print an i} jsr prtch
        DEC                 #decrement counter} dcv xr
        JMP  prsn1          #loop back} brn prsn1
#
#      merge with all letter i characters generated
#
prsn2:  MOV                 #get blank} mov =ch_bl wa
        CALL prtch          #print blank} jsr prtch
        MOV                 #restore entry wa} mov prsna wa
        MOV                 #restore entry xr} mov (xs)+ xr
        LEA
        RET                 #return to prtsn caller} exi
                            #end procedure prtsn} enp
                            #} ejc
        .eject
#
#      prtst -- print string
#
#      prtst places a string of characters in the print buffer
#
#      see prtnl for global locations used
#
#      note that the first word of the block (normally b$scl)
#      is not used and need not be set correctly (see prtvn)
#
#      (xr)                  string to be printed
#      jsr  prtst            call to print string
#      (profs)               updated past chars placed
#
prtst:                      #entry point} prc r 0
        .global prtst
        CMP  DWORD PTR DWORD PTR headp,0 #were headers printed} bnz headp prst0
        JNZ  prst0
        CALL prtps          #no - print them} jsr prtps
#
#      call syspr
#
prst0:  MOV  DWORD PTR prsva #save wa} mov wa prsva
        MOV  DWORD PTR prsvb #save wb} mov wb prsvb
        XOR                 #set chars printed count to zero} zer wb
#
#      loop to print successive lines for long string
#
prst1:  MOV                 #load string length} mov sclen(xr) wa
        SUB                 #subtract count of chars already out} sub wb wa
#        OR                  #jump to exit if none left} bze wa prst4  (Optimized)
        JZ   prst4
        LEA                 #else stack entry xl} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #save argument} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #copy for eventual move} mov xr xl
        MOV                 #load print buffer length} mov prlen xr
        SUB                 #get chars left in print buffer} sub profs xr
#        OR                  #skip if room left on this line} bnz xr prst2  (Optimized)
        JNZ  prst2
        CALL prtnl          #else print this line} jsr prtnl
        MOV                 #and set full width available} mov prlen xr
                            #} ejc
        .eject
#
#      prtst (continued)
#
#      here with chars to print and some room in buffer
#
prst2:  CMP                 #jump if room for rest of string} blo wa xr prst3
             prst3
        MOV                 #else set to fill line} mov xr wa
#
#      merge here with character count in wa
#
prst3:  MOV                 #point to print buffer} mov prbuf xr
        LEA                 #point to location in string} plc xl wb
        ADD                 #point to location in buffer} psc xr profs
        ADD
        ADD                 #bump string chars count} add wa wb
        ADD  DWORD PTR profs #bump buffer pointer} add wa profs
        MOV  DWORD PTR prsvc #preserve char counter} mov wb prsvc
        SHRD EAX,ECX,1      #move characters to buffer} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        MOV                 #recover char counter} mov prsvc wb
        MOV                 #restore argument pointer} mov (xs)+ xr
        LEA
        MOV                 #restore entry xl} mov (xs)+ xl
        LEA
        JMP  prst1          #loop back to test for more} brn prst1
#
#      here to exit after printing string
#
prst4:  MOV                 #restore entry wb} mov prsvb wb
        MOV                 #restore entry wa} mov prsva wa
        RET                 #return to prtst caller} exi
                            #end procedure prtst} enp
                            #} ejc
        .eject
#
#      prttr -- print to terminal
#
#      called to print contents of standard print buffer to
#      online terminal. clears buffer down and resets profs.
#
#      jsr  prttr            call for print
#      (wa,wb)               destroyed
#
prttr:                      #entry point} prc e 0
        .global prttr
        LEA                 #save xr} mov xr -(xs)
        MOV  DWORD PTR []
        CALL prtic          #print buffer contents} jsr prtic
        MOV                 #point to print bfr to clear it} mov prbuf xr
        MOV                 #get buffer length} lct wa prlnw
        ADD                 #point past scblk header} add *schar xr
        MOV                 #get blanks} mov nullw wb
#
#      loop to clear buffer
#
prtt1:  MOV  DWORD PTR []   #clear a word} mov wb (xr)+
        LEA
        DEC                 #loop} bct wa prtt1
        JNZ  prtt1
        XOR  EAX,EAX        #reset profs} zer profs
        MOV  DWORD PTR profs,EAX
        MOV                 #restore xr} mov (xs)+ xr
        LEA
        RET                 #return} exi
                            #end procedure prttr} enp
                            #} ejc
        .eject
#
#      prtvl -- print a value
#
#      prtvl places an appropriate character representation of
#      a data value in the print buffer for dump/trace use.
#
#      (xr)                  value to be printed
#      jsr  prtvl            call to print value
#      (wa,wb,wc,ra)         destroyed
#
prtvl:                      #entry point, recursive} prc r 0
        .global prtvl
        LEA                 #save entry xl} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #save argument} mov xr -(xs)
        MOV  DWORD PTR []
        CMP  ESP,LOWSPMIN   #check for stack overflow} chk
        JB   SEC06
#
#      loop back here after finding a trap block (trblk)
#
prv01:  MOV  EAX,DWORD PTR (4*idval)[] #copy idval (if any)} mov idval(xr) prvsi
        MOV  DWORD PTR prvsi,EAX
        MOV                 #load first word of block} mov (xr) xl
        MOVZX               #load entry point id} lei xl
        CMP                 #switch on block type} bsw xl bl__t prv02
        JGE  prv02
        JMP  DWORD PTR L0016[*4]
        DSeg_
L0016:
        .long prv05         #arblk} iff bl_ar prv05
        .long prv02         #} iff 1 prv02
        .long prv02         #} iff 2 prv02
        .long prv08         #icblk} iff bl_ic prv08
        .long prv09         #nmblk} iff bl_nm prv09
        .long prv02         #} iff 5 prv02
        .long prv02         #} iff 6 prv02
        .long prv02         #} iff 7 prv02
        .long prv08         #rcblk} iff bl_rc prv08
        .long prv11         #scblk} iff bl_sc prv11
        .long prv12         #seblk} iff bl_se prv12
        .long prv13         #tbblk} iff bl_tb prv13
        .long prv13         #vcblk} iff bl_vc prv13
        .long prv02         #} iff 13 prv02
        .long prv02         #} iff 14 prv02
        .long prv02         #} iff 15 prv02
        .long prv10         #pdblk} iff bl_pd prv10
        .long prv04         #trblk} iff bl_tr prv04
        DSegEnd_            #end of switch on block type} esw
        CSeg_
#
#      here for blocks for which we just print datatype name
#
prv02:  CALL dtype          #get datatype name} jsr dtype
        CALL prtst          #print datatype name} jsr prtst
#
#      common exit point
#
prv03:  MOV                 #reload argument} mov (xs)+ xr
        LEA
        MOV                 #restore xl} mov (xs)+ xl
        LEA
        RET                 #return to prtvl caller} exi
#
#      here for trblk
#
prv04:  MOV                 #load real value} mov trval(xr) xr
        JMP  prv01          #and loop back} brn prv01
                            #} ejc
        .eject
#
#      prtvl (continued)
#
#      here for array (arblk)
#
#      print array ( prototype ) blank number idval
#
prv05:  MOV                 #preserve argument} mov xr xl
        MOV                 #point to datatype name (array)} mov =scarr xr
        CALL prtst          #print it} jsr prtst
        MOV                 #load left paren} mov =ch_pp wa
        CALL prtch          #print left paren} jsr prtch
        ADD                 #point to prototype} add arofs(xl) xl
        MOV                 #load prototype} mov (xl) xr
        CALL prtst          #print prototype} jsr prtst
#
#      vcblk, tbblk, bcblk merge here for ) blank number idval
#
prv06:  MOV                 #load right paren} mov =ch_rp wa
        CALL prtch          #print right paren} jsr prtch
#
#      pdblk merges here to print blank number idval
#
prv07:  MOV                 #load blank} mov =ch_bl wa
        CALL prtch          #print it} jsr prtch
        MOV                 #load number sign} mov =ch_nm wa
        CALL prtch          #print it} jsr prtch
        MOV  EDX,DWORD PTR prvsi #get idval} mti prvsi
        CALL prtin          #print id number} jsr prtin
        JMP  prv03          #back to exit} brn prv03
#
#      here for integer (icblk), real (rcblk)
#
#      print character representation of value
#
prv08:  LEA                 #stack argument for gtstg} mov xr -(xs)
        MOV  DWORD PTR []
        CALL gtstg          #convert to string} jsr gtstg
        .short ERR_-299-DFFNC #error return is impossible} ppm
        CALL prtst          #print the string} jsr prtst
        MOV  DWORD PTR dnamp #delete garbage string from storage} mov xr dnamp
        JMP  prv03          #back to exit} brn prv03
                            #} ejc
        .eject
#
#      prtvl (continued)
#
#      name (nmblk)
#
#      for pseudo-variable, just print datatype name (name)
#      for all other names, print dot followed by name rep
#
prv09:  MOV                 #load name base} mov nmbas(xr) xl
        MOV                 #load first word of block} mov (xl) wa
        CMP                 #just print name if keyword} beq wa =b_kvt prv02
             prv02
        CMP                 #just print name if expression var} beq wa =b_evt prv02
             prv02
        MOV                 #else get dot} mov =ch_dt wa
        CALL prtch          #and print it} jsr prtch
        MOV                 #load name offset} mov nmofs(xr) wa
        CALL prtnm          #print name} jsr prtnm
        JMP  prv03          #back to exit} brn prv03
#
#      program datatype (pdblk)
#
#      print datatype name ch$bl ch$nm idval
#
prv10:  CALL dtype          #get datatype name} jsr dtype
        CALL prtst          #print datatype name} jsr prtst
        JMP  prv07          #merge back to print id} brn prv07
#
#      here for string (scblk)
#
#      print quote string-characters quote
#
prv11:  MOV                 #load single quote} mov =ch_sq wa
        CALL prtch          #print quote} jsr prtch
        CALL prtst          #print string value} jsr prtst
        CALL prtch          #print another quote} jsr prtch
        JMP  prv03          #back to exit} brn prv03
                            #} ejc
        .eject
#
#      prtvl (continued)
#
#      here for simple expression (seblk)
#
#      print asterisk variable-name
#
prv12:  MOV                 #load asterisk} mov =ch_as wa
        CALL prtch          #print asterisk} jsr prtch
        MOV                 #load variable pointer} mov sevar(xr) xr
        CALL prtvn          #print variable name} jsr prtvn
        JMP  prv03          #jump back to exit} brn prv03
#
#      here for table (tbblk) and array (vcblk)
#
#      print datatype ( prototype ) blank number idval
#
prv13:  MOV                 #preserve argument} mov xr xl
        CALL dtype          #get datatype name} jsr dtype
        CALL prtst          #print datatype name} jsr prtst
        MOV                 #load left paren} mov =ch_pp wa
        CALL prtch          #print left paren} jsr prtch
        MOV                 #load length of block (=vclen)} mov tblen(xl) wa
        SHR                 #convert to word count} btw wa
        SUB                 #allow for standard fields} sub =tbsi_ wa
        CMP  DWORD PTR [],offset b_tbt #jump if table} beq (xl) =b_tbt prv14
             prv14
        ADD                 #for vcblk, adjust size} add =vctbd wa
#
#      print prototype
#
prv14:  MOV  EDX            #move as integer} mti wa
        CALL prtin          #print integer prototype} jsr prtin
        JMP  prv06          #merge back for rest} brn prv06
                            #end procedure prtvl} enp
                            #} ejc
        .eject
#
#      prtvn -- print natural variable name
#
#      prtvn prints the name of a natural variable
#
#      (xr)                  pointer to vrblk
#      jsr  prtvn            call to print variable name
#
prtvn:                      #entry point} prc e 0
        .global prtvn
        LEA                 #stack vrblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        ADD                 #point to possible string name} add *vrsof xr
        CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #jump if not system variable} bnz sclen(xr) prvn1
        JNZ  prvn1
        MOV                 #point to svblk with name} mov vrsvo(xr) xr
#
#      merge here with dummy scblk pointer in xr
#
prvn1:  CALL prtst          #print string name of variable} jsr prtst
        MOV                 #restore vrblk pointer} mov (xs)+ xr
        LEA
        RET                 #return to prtvn caller} exi
                            #end procedure prtvn} enp
                            #} ejc
        .eject
#
#      rcbld -- build a real block
#
#      (ra)                  real value for rcblk
#      jsr  rcbld            call to build real block
#      (xr)                  pointer to result rcblk
#      (wa)                  destroyed
#
rcbld:                      #entry point} prc e 0
        .global rcbld
        MOV                 #load pointer to next available loc} mov dnamp xr
        ADD                 #point past new rcblk} add *rcsi_ xr
        CMP                 #jump if there is room} blo xr dname rcbl1
             rcbl1
        MOV                 #else load rcblk length} mov *rcsi_ wa
        CALL alloc          #use standard allocator to get block} jsr alloc
        ADD                 #point past block to merge} add wa xr
#
#      merge here with xr pointing past the block obtained
#
rcbl1:  MOV  DWORD PTR dnamp #set new pointer} mov xr dnamp
        SUB                 #point back to start of block} sub *rcsi_ xr
        MOV  DWORD PTR [],offset b_rcl #store type word} mov =b_rcl (xr)
        LEA  EAX,DWORD PTR (4*rcval)[] #store real value in rcblk} str rcval(xr)
        CALL str_
        RET                 #return to rcbld caller} exi
                            #end procedure rcbld} enp
                            #} ejc
        .eject
#
#      readr -- read next source image at compile time
#
#      readr is used to read the next source image. to process
#      continuation cards properly, the compiler must read one
#      line ahead. thus readr does not destroy the current image
#      see also the nexts routine which actually gets the image.
#
#      jsr  readr            call to read next image
#      (xr)                  ptr to next image (0 if none)
#      (r$cni)               copy of pointer
#      (wa,wb,wc,xl)         destroyed
#
readr:                      #entry point} prc e 0
        .global readr
        MOV                 #get ptr to next image} mov r_cni xr
        OR                  #exit if already read} bnz xr read3
        JNZ  read3
        CMP  DWORD PTR DWORD PTR cnind,0 #if within include file} bnz cnind reada
        JNZ  reada
        CMP  DWORD PTR stage,stgic #exit if not initial compile} bne stage =stgic read3
             read3
reada:  MOV                 #max read length} mov cswin wa
        XOR                 #clear any dud value in xl} zer xl
        CALL alocs          #allocate buffer} jsr alocs
        CALL sysrd          #read input image} jsr sysrd
        .short read4-DFFNC  #jump if eof or new file name} ppm read4
        INC  DWORD PTR rdnln #increment next line number} icv rdnln
        DEC  DWORD PTR polct #test if time to poll interface} dcv polct
        CMP  DWORD PTR DWORD PTR polct,0 #not yet} bnz polct read0
        JNZ  read0
        XOR                 #=0 for poll} zer wa
        MOV                 #line number} mov rdnln wb
        CALL syspl          #allow interactive access} jsr syspl
        .short ERR_-320-DFFNC #} err 320 user interrupt
        .short ERR_-299-DFFNC #single step} ppm
        .short ERR_-299-DFFNC #expression evaluation} ppm
        MOV  DWORD PTR polcs #new countdown start value} mov wa polcs
        MOV  DWORD PTR polct #new counter value} mov wa polct
read0:  MOV  EAX,DWORD PTR (4*sclen)[] #use smaller of string lnth ...} ble sclen(xr) cswin read1
        CMP  EAX,DWORD PTR cswin
             read1
        MOV  EAX,DWORD PTR cswin #... and xxx of -inxxx} mov cswin sclen(xr)
        MOV  DWORD PTR (4*sclen)[],EAX
#
#      perform the trim
#
read1:  MOV                 #set trimr to perform trim} mnz wb
        CALL trimr          #trim trailing blanks} jsr trimr
#
#      merge here after read
#
read2:  MOV  DWORD PTR r_cni #store copy of pointer} mov xr r_cni
#
#      merge here if no read attempted
#
read3:  RET                 #return to readr caller} exi
#
#      here on end of file or new source file name.
#      if this is a new source file name, the r$sfn table will
#      be augmented with a new table entry consisting of the
#      current compiler statement number as subscript, and the
#      file name as value.
#
read4:  CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #jump if true end of file} bze sclen(xr) read5
        JZ   read5
        XOR                 #new source file name} zer wb
        MOV  DWORD PTR rdnln #restart line counter for new file} mov wb rdnln
        CALL trimr          #remove unused space in block} jsr trimr
        CALL newfn          #record new file name} jsr newfn
        JMP  reada          #now reissue read for record data} brn reada
#
#      here on end of file
#
read5:  MOV  DWORD PTR dnamp #pop unused scblk} mov xr dnamp
        CMP  DWORD PTR DWORD PTR cnind,0 #jump if not within an include file} bze cnind read6
        JZ   read6
        XOR                 #eof within include file} zer xl
        CALL sysif          #switch stream back to previous file} jsr sysif
        .short ERR_-299-DFFNC #} ppm
        MOV                 #restore prev line number, file name} mov cnind wa
        ADD                 #vector offset in words} add =vcvlb wa
        SAL                 #convert to bytes} wtb wa
        MOV                 #file name array} mov r_ifa xr
        ADD                 #ptr to element} add wa xr
        MOV  EAX,DWORD PTR [] #change source file name} mov (xr) r_sfc
        MOV  DWORD PTR r_sfc,EAX
        MOV  DWORD PTR [],offset nulls #release scblk} mov =nulls (xr)
        MOV                 #line number array} mov r_ifl xr
        ADD                 #ptr to element} add wa xr
        MOV                 #icblk containing saved line number} mov (xr) xl
        MOV  EDX,DWORD PTR (4*icval)[] #line number integer} ldi icval(xl)
        MOV  DWORD PTR rdnln,EDX #change source line number} mfi rdnln
        MOV  DWORD PTR [],offset inton #release icblk} mov =inton (xr)
        DEC  DWORD PTR cnind #decrement nesting level} dcv cnind
        MOV                 #current statement number} mov cmpsn wb
        INC                 #anticipate end of previous stmt} icv wb
        MOV  EDX            #convert to integer} mti wb
        CALL icbld          #build icblk for stmt number} jsr icbld
        MOV                 #file name table} mov r_sfn xl
        MOV                 #lookup statement number by name} mnz wb
        CALL tfind          #allocate new teblk} jsr tfind
        .short ERR_-299-DFFNC #always possible to allocate block} ppm
        MOV  EAX,DWORD PTR r_sfc #record file name as entry value} mov r_sfc teval(xl)
        MOV  DWORD PTR (4*teval)[],EAX
        CMP  DWORD PTR stage,stgic #if initial compile, reissue read} beq stage =stgic reada
             reada
        CMP  DWORD PTR DWORD PTR cnind,0 #still reading from include file} bnz cnind reada
        JNZ  reada
#
#      outer nesting of execute-time compile of -include
#      resume with any string remaining prior to -include.
#
        MOV                 #restore code argument string} mov r_ici xl
        XOR  EAX,EAX        #release original string} zer r_ici
        MOV  DWORD PTR r_ici,EAX
        MOV                 #get length of string} mov cnsil wa
        MOV                 #offset of characters left} mov cnspt wb
        SUB                 #number of characters left} sub wb wa
        MOV  DWORD PTR scnil #set new scan length} mov wa scnil
        XOR  EAX,EAX        #scan from start of substring} zer scnpt
        MOV  DWORD PTR scnpt,EAX
        CALL sbstr          #create substring of remainder} jsr sbstr
        MOV  DWORD PTR r_cim #set scan image} mov xr r_cim
        JMP  read2          #return} brn read2
read6:  XOR                 #zero ptr as result} zer xr
        JMP  read2          #merge} brn read2
                            #end procedure readr} enp
                            #} ejc
        .eject
#
#      sbstr -- build a substring
#
#      (xl)                  ptr to scblk/bfblk with chars
#      (wa)                  number of chars in substring
#      (wb)                  offset to first char in scblk
#      jsr  sbstr            call to build substring
#      (xr)                  ptr to new scblk with substring
#      (xl)                  zero
#      (wa,wb,wc,xl,ia)      destroyed
#
#      note that sbstr is called with a dummy string pointer
#      (pointing into a vrblk or svblk) to copy the name of a
#      variable as a standard string value.
#
sbstr:                      #entry point} prc e 0
        .global sbstr
        OR                  #jump if null substring} bze wa sbst2
        JZ   sbst2
        CALL alocs          #else allocate scblk} jsr alocs
        MOV                 #move number of characters} mov wc wa
        MOV                 #save ptr to new scblk} mov xr wc
        LEA                 #prepare to load chars from old blk} plc xl wb
        ADD                 #prepare to store chars in new blk} psc xr
        SHRD EAX,ECX,1      #move characters to new string} mvc
        SHR  ECX,2
        REP  MOVSD
        ADC  ECX,ECX
        REP  MOVSW
        SHLD ECX,EAX,1
        REP  MOVSB
        MOV                 #then restore scblk pointer} mov wc xr
#
#      return point
#
sbst1:  XOR                 #clear garbage pointer in xl} zer xl
        RET                 #return to sbstr caller} exi
#
#      here for null substring
#
sbst2:  MOV                 #set null string as result} mov =nulls xr
        JMP  sbst1          #return} brn sbst1
                            #end procedure sbstr} enp
                            #} ejc
        .eject
#
#      stgcc -- compute counters for stmt startup testing
#
#      jsr  stgcc            call to recompute counters
#      (wa,wb)               destroyed
#
#      on exit, stmcs and stmct contain the counter value to
#      tested in stmgo.
#
#
stgcc:                      #} prc e 0
        .global stgcc
        MOV                 #assume no profiling or stcount tracing} mov polcs wa
        MOV                 #poll each time polcs expires} mov =num01 wb
        MOV  EDX,DWORD PTR kvstl #get stmt limit} ldi kvstl
        CMP  DWORD PTR DWORD PTR kvpfl,0 #jump if profiling enabled} bnz kvpfl stgc1
        JNZ  stgc1
        OR   EDX,EDX        #no stcount tracing if negative} ilt stgc3
        JL   stgc3
        CMP  DWORD PTR DWORD PTR r_stc,0 #jump if not stcount tracing} bze r_stc stgc2
        JZ   stgc2
#
#      here if profiling or if stcount tracing enabled
#
stgc1:  MOV                 #count polcs times within stmg} mov wa wb
        MOV                 #break out of stmgo on each stmt} mov =num01 wa
        JMP  stgc3          #} brn stgc3
#
#      check that stmcs does not exceed kvstl
#
stgc2:  MOV  EDX            #breakout count start value} mti wa
        SUB  EDX,DWORD PTR kvstl #proposed stmcs minus stmt limit} sbi kvstl
#        OR   EDX,EDX        #jump if stmt count does not limit} ile stgc3   (Optimized)
        JLE  stgc3
        MOV  EDX,DWORD PTR kvstl #stlimit limits breakcount count} ldi kvstl
        MOV                 #use it instead} mfi wa
#
#      re-initialize counter
#
stgc3:  MOV  DWORD PTR stmcs #update breakout count start value} mov wa stmcs
        MOV  DWORD PTR stmct #reset breakout counter} mov wa stmct
        MOV  DWORD PTR polct #} mov wb polct
        RET                 #} exi
                            #} ejc
        .eject
#
#      tfind -- locate table element
#
#      (xr)                  subscript value for element
#      (xl)                  pointer to table
#      (wb)                  zero by value, non-zero by name
#      jsr  tfind            call to locate element
#      ppm  loc              transfer location if access fails
#      (xr)                  element value (if by value)
#      (xr)                  destroyed (if by name)
#      (xl,wa)               teblk name (if by name)
#      (xl,wa)               destroyed (if by value)
#      (wc,ra)               destroyed
#
#      note that if a call by value specifies a non-existent
#      subscript, the default value is returned without building
#      a new teblk.
#
tfind:                      #entry point} prc e 1
        .global tfind
        LEA                 #save name/value indicator} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #save subscript value} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #save table pointer} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #load length of tbblk} mov tblen(xl) wa
        SHR                 #convert to word count} btw wa
        SUB                 #get number of buckets} sub =tbbuk wa
        MOV  EDX            #convert to integer value} mti wa
        MOV  DWORD PTR tfnsi,EDX #save for later} sti tfnsi
        MOV                 #load first word of subscript} mov (xr) xl
        MOVZX               #load block entry id (bl_xx)} lei xl
        CMP                 #switch on block type} bsw xl bl__d tfn00
        JGE  tfn00
        JMP  DWORD PTR L0017[*4]
        DSeg_
L0017:
        .long tfn00         #} iff 0 tfn00
        .long tfn00         #} iff 1 tfn00
        .long tfn00         #} iff 2 tfn00
        .long tfn02         #jump if integer} iff bl_ic tfn02
        .long tfn04         #jump if name} iff bl_nm tfn04
        .long tfn03         #jump if pattern} iff bl_p0 tfn03
        .long tfn03         #jump if pattern} iff bl_p1 tfn03
        .long tfn03         #jump if pattern} iff bl_p2 tfn03
        .long tfn02         #real} iff bl_rc tfn02
        .long tfn05         #jump if string} iff bl_sc tfn05
        .long tfn00         #} iff 10 tfn00
        .long tfn00         #} iff 11 tfn00
        .long tfn00         #} iff 12 tfn00
        .long tfn00         #} iff 13 tfn00
        .long tfn00         #} iff 14 tfn00
        .long tfn00         #} iff 15 tfn00
        .long tfn00         #} iff 16 tfn00
        DSegEnd_            #end switch on block type} esw
        CSeg_
#
#      here for blocks for which we use the second word of the
#      block as the hash source (see block formats for details).
#
tfn00:  MOV                 #load second word} mov 1(xr) wa
#
#      merge here with one word hash source in wa
#
tfn01:  MOV  EDX            #convert to integer} mti wa
        JMP  tfn06          #jump to merge} brn tfn06
                            #} ejc
        .eject
#
#      tfind (continued)
#
#      here for integer or real
#      possibility of overflow exist on twos complement
#      machine if hash source is most negative integer or is
#      a real having the same bit pattern.
#
#
tfn02:  MOV  EDX,DWORD PTR (4*1)[] #load value as hash source} ldi 1(xr)
        OR   EDX,EDX        #ok if positive or zero} ige tfn06
        JGE  tfn06
        NEG  EDX            #make positive} ngi
        JO   tfn06          #clear possible overflow} iov tfn06
        JMP  tfn06          #merge} brn tfn06
#
#      for pattern, use first word (pcode) as source
#
tfn03:  MOV                 #load first word as hash source} mov (xr) wa
        JMP  tfn01          #merge back} brn tfn01
#
#      for name, use offset as hash source
#
tfn04:  MOV                 #load offset as hash source} mov nmofs(xr) wa
        JMP  tfn01          #merge back} brn tfn01
#
#      here for string
#
tfn05:  CALL hashs          #call routine to compute hash} jsr hashs
#
#      merge here with hash source in (ia)
#
tfn06:  MOV  EAX,DWORD PTR tfnsi #compute hash index by remaindering} rmi tfnsi
        CALL rmi_
        MOV                 #get as one word integer} mfi wc
        SAL                 #convert to byte offset} wtb wc
        MOV                 #get table ptr again} mov (xs) xl
        ADD                 #point to proper bucket} add wc xl
        MOV                 #load first teblk pointer} mov tbbuk(xl) xr
        CMP                 #jump if no teblks on chain} beq xr (xs) tfn10
             tfn10
#
#      loop through teblks on hash chain
#
tfn07:  MOV                 #save teblk pointer} mov xr wb
        MOV                 #load subscript value} mov tesub(xr) xr
        MOV                 #load input argument subscript val} mov 1(xs) xl
        CALL ident          #compare them} jsr ident
        .short tfn08-DFFNC  #jump if equal (ident)} ppm tfn08
#
#      here if no match with that teblk
#
        MOV                 #restore teblk pointer} mov wb xl
        MOV                 #point to next teblk on chain} mov tenxt(xl) xr
        CMP                 #jump if there is one} bne xr (xs) tfn07
             tfn07
#
#      here if no match with any teblk on chain
#
        MOV                 #set offset to link field (xl base)} mov *tenxt wc
        JMP  tfn11          #jump to merge} brn tfn11
                            #} ejc
        .eject
#
#      tfind (continued)
#
#      here we have found a matching element
#
tfn08:  MOV                 #restore teblk pointer} mov wb xl
        MOV                 #set teblk name offset} mov *teval wa
        MOV                 #restore name/value indicator} mov 2(xs) wb
        OR                  #jump if called by name} bnz wb tfn09
        JNZ  tfn09
        CALL acess          #else get value} jsr acess
        .short tfn12-DFFNC  #jump if reference fails} ppm tfn12
        XOR                 #restore name/value indicator} zer wb
#
#      common exit for entry found
#
tfn09:  ADD                 #pop stack entries} add *num03 xs
        POP  EAX            #return to tfind caller} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here if no teblks on the hash chain
#
tfn10:  ADD                 #get offset to bucket ptr} add *tbbuk wc
        MOV                 #set tbblk ptr as base} mov (xs) xl
#
#      merge here with (xl,wc) base,offset of final link
#
tfn11:  MOV                 #tbblk pointer} mov (xs) xr
        MOV                 #load default value in case} mov tbinv(xr) xr
        MOV                 #load name/value indicator} mov 2(xs) wb
        OR                  #exit with default if value call} bze wb tfn09
        JZ   tfn09
        MOV                 #copy default value} mov xr wb
#
#      here we must build a new teblk
#
        MOV                 #set size of teblk} mov *tesi_ wa
        CALL alloc          #allocate teblk} jsr alloc
        ADD                 #point to hash link} add wc xl
        MOV  DWORD PTR []   #link new teblk at end of chain} mov xr (xl)
        MOV  DWORD PTR [],offset b_tet #store type word} mov =b_tet (xr)
        MOV  DWORD PTR (4*teval)[] #set default as initial value} mov wb teval(xr)
        MOV  EAX,DWORD PTR [] #set tbblk ptr to mark end of chain} mov (xs)+ tenxt(xr)
        MOV  DWORD PTR (4*tenxt)[],EAX
        LEA
        MOV  EAX,DWORD PTR [] #store subscript value} mov (xs)+ tesub(xr)
        MOV  DWORD PTR (4*tesub)[],EAX
        LEA
        MOV                 #restore name/value indicator} mov (xs)+ wb
        LEA
        MOV                 #copy teblk pointer (name base)} mov xr xl
        MOV                 #set offset} mov *teval wa
        POP  EAX            #return to caller with new teblk} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      acess fail return
#
tfn12:  POP  EAX            #alternative return} exi 1
        JMP  EXI__1
                            #end procedure tfind} enp
                            #} ejc
        .eject
#
#      tmake -- make new table
#
#      (xl)                  initial lookup value
#      (wc)                  number of buckets desired
#      jsr  tmake            call to make new table
#      (xr)                  new table
#      (wa,wb)               destroyed
#
tmake:                      #} prc e 0
        .global tmake
        MOV                 #copy number of headers} mov wc wa
        ADD                 #adjust for standard fields} add =tbsi_ wa
        SAL                 #convert length to bytes} wtb wa
        CALL alloc          #allocate space for tbblk} jsr alloc
        MOV                 #copy pointer to tbblk} mov xr wb
        MOV  DWORD PTR [],offset b_tbt #store type word} mov =b_tbt (xr)+
        LEA
        XOR  EAX,EAX        #zero id for the moment} zer (xr)+
        MOV  DWORD PTR [],EAX
        LEA
        MOV  DWORD PTR []   #store length (tblen)} mov wa (xr)+
        LEA
        MOV  DWORD PTR []   #store initial lookup value} mov xl (xr)+
        LEA
#
#      loop to initialize all bucket pointers
#
tma01:  MOV  DWORD PTR []   #store tbblk ptr in bucket header} mov wb (xr)+
        LEA
        DEC                 #loop till all stored} bct wc tma01
        JNZ  tma01
        MOV                 #recall pointer to tbblk} mov wb xr
        RET                 #} exi
                            #} enp
                            #} ejc
        .eject
#
#      vmake -- create a vector
#
#      (wa)                  number of elements in vector
#      (xl)                  default value for vector elements
#      jsr  vmake            call to create vector
#      ppm  loc              if vector too large
#
#      (xr)                  pointer to vcblk
#      (wa,wb,wc,xl)         destroyed
#
vmake:                      #entry point} prc e 1
        .global vmake
        MOV                 #copy elements for loop later on} lct wb wa
        ADD                 #add space for standard fields} add =vcsi_ wa
        SAL                 #convert length to bytes} wtb wa
        CMP                 #fail if too large} bgt wa mxlen vmak2
             vmak2
        CALL alloc          #allocate space for vcblk} jsr alloc
        MOV  DWORD PTR [],offset b_vct #store type word} mov =b_vct (xr)
        XOR  EAX,EAX        #initialize idval} zer idval(xr)
        MOV  DWORD PTR (4*idval)[],EAX
        MOV  DWORD PTR (4*vclen)[] #set length} mov wa vclen(xr)
        MOV                 #copy default value} mov xl wc
        MOV                 #copy vcblk pointer} mov xr xl
        ADD                 #point to first element value} add *vcvls xl
#
#      loop to set vector elements to default value
#
vmak1:  MOV  DWORD PTR []   #store one value} mov wc (xl)+
        LEA
        DEC                 #loop till all stored} bct wb vmak1
        JNZ  vmak1
        POP  EAX            #success return} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      here if desired vector size too large
#
vmak2:  POP  EAX            #fail return} exi 1
        JMP  EXI__1
                            #} enp
                            #} ejc
        .eject
#
#      scane -- scan an element
#
#      scane is called at compile time (by expan ,cmpil,cncrd)
#      to scan one element from the input image.
#
#      (scncc)               non-zero if called from cncrd
#      jsr  scane            call to scan element
#      (xr)                  result pointer (see below)
#      (xl)                  syntax type code (t$xxx)
#
#      the following global locations are used.
#
#      r$cim                 pointer to string block (scblk)
#                            for current input image.
#
#      r$cni                 pointer to next input image string
#                            pointer (zero if none).
#
#      r$scp                 save pointer (exit xr) from last
#                            call in case rescan is set.
#
#      scnbl                 this location is set non-zero on
#                            exit if scane scanned past blanks
#                            before locating the current element
#                            the end of a line counts as blanks.
#
#      scncc                 cncrd sets this non-zero to scan
#                            control card names and clears it
#                            on return
#
#      scnil                 length of current input image
#
#      scngo                 if set non-zero on entry, f and s
#                            are returned as separate syntax
#                            types (not letters) (goto pro-
#                            cessing). scngo is reset on exit.
#
#      scnpt                 offset to current loc in r$cim
#
#      scnrs                 if set non-zero on entry, scane
#                            returns the same result as on the
#                            last call (rescan). scnrs is reset
#                            on exit from any call to scane.
#
#      scntp                 save syntax type from last
#                            call (in case rescan is set).
                            #} ejc
        .eject
#
#      scane (continued)
#
#
#
#      element scanned       xl        xr
#      ---------------       --        --
#
#      control card name     0         pointer to scblk for name
#
#      unary operator        t$uop     ptr to operator dvblk
#
#      left paren            t$lpr     t$lpr
#
#      left bracket          t$lbr     t$lbr
#
#      comma                 t$cma     t$cma
#
#      function call         t$fnc     ptr to function vrblk
#
#      variable              t$var     ptr to vrblk
#
#      string constant       t$con     ptr to scblk
#
#      integer constant      t$con     ptr to icblk
#
#      real constant         t$con     ptr to rcblk
#
#      binary operator       t$bop     ptr to operator dvblk
#
#      right paren           t$rpr     t$rpr
#
#      right bracket         t$rbr     t$rbr
#
#      colon                 t$col     t$col
#
#      semi-colon            t$smc     t$smc
#
#      f (scngo ne 0)        t$fgo     t$fgo
#
#      s (scngo ne 0)        t$sgo     t$sgo
                            #} ejc
        .eject
#
#      scane (continued)
#
#      entry point
#
scane:                      #entry point} prc e 0
        .global scane
        XOR  EAX,EAX        #reset blanks flag} zer scnbl
        MOV  DWORD PTR scnbl,EAX
        MOV  DWORD PTR scnsa #save wa} mov wa scnsa
        MOV  DWORD PTR scnsb #save wb} mov wb scnsb
        MOV  DWORD PTR scnsc #save wc} mov wc scnsc
        CMP  DWORD PTR DWORD PTR scnrs,0 #jump if no rescan} bze scnrs scn03
        JZ   scn03
#
#      here for rescan request
#
        MOV                 #set previous returned scan type} mov scntp xl
        MOV                 #set previous returned pointer} mov r_scp xr
        XOR  EAX,EAX        #reset rescan switch} zer scnrs
        MOV  DWORD PTR scnrs,EAX
        JMP  scn13          #jump to exit} brn scn13
#
#      come here to read new image to test for continuation
#
scn01:  CALL readr          #read next image} jsr readr
        MOV                 #set wb for not reading name} mov *dvubs wb
        OR                  #treat as semi-colon if none} bze xr scn30
        JZ   scn30
        ADD                 #else point to first character} plc xr
        MOVZX               #load first character} lch wc (xr)
        CMP                 #jump if dot for continuation} beq wc =ch_dt scn02
             scn02
        CMP                 #else treat as semicolon unless plus} bne wc =ch_pl scn30
             scn30
#
#      here for continuation line
#
scn02:  CALL nexts          #acquire next source image} jsr nexts
        MOV  DWORD PTR scnpt,num01 #set scan pointer past continuation} mov =num01 scnpt
        MOV  DWORD PTR scnbl,ESP #set blanks flag} mnz scnbl
                            #} ejc
        .eject
#
#      scane (continued)
#
#      merge here to scan next element on current line
#
scn03:  MOV                 #load current offset} mov scnpt wa
        CMP                 #check continuation if end} beq wa scnil scn01
             scn01
        MOV                 #point to current line} mov r_cim xl
        LEA                 #point to current character} plc xl wa
        MOV  DWORD PTR scnse #set start of element location} mov wa scnse
        MOV                 #point to operator dv list} mov =opdvs wc
        MOV                 #set constant for operator circuit} mov *dvubs wb
        JMP  scn06          #start scanning} brn scn06
#
#      loop here to ignore leading blanks and tabs
#
scn05:  OR                  #jump if trailing} bze wb scn10
        JZ   scn10
        INC  DWORD PTR scnse #increment start of element} icv scnse
        CMP                 #jump if end of image} beq wa scnil scn01
             scn01
        MOV  DWORD PTR scnbl,ESP #note blanks seen} mnz scnbl
#
#      the following jump is used repeatedly for scanning out
#      the characters of a numeric constant or variable name.
#      the registers are used as follows.
#
#      (xr)                  scratch
#      (xl)                  ptr to next character
#      (wa)                  current scan offset
#      (wb)                  *dvubs (0 if scanning name,const)
#      (wc)                  =opdvs (0 if scanning constant)
#
scn06:  MOVZX               #get next character} lch xr (xl)+
        INC
        INC                 #bump scan offset} icv wa
        MOV  DWORD PTR scnpt #store offset past char scanned} mov wa scnpt
        CMP                 #switch on scanned character} bsw xr cfp_u scn07
        JGE  scn07
        JMP  DWORD PTR L0018[*4]
        DSeg_
L0018:
#
#      switch table for switch on character
#
                            #} ejc
        .eject
#
#      scane (continued)
#
                            #} ejc
        .eject
#
#      scane (continued)
#
        .long scn07         #} iff 0 scn07
        .long scn07         #} iff 1 scn07
        .long scn07         #} iff 2 scn07
        .long scn07         #} iff 3 scn07
        .long scn07         #} iff 4 scn07
        .long scn07         #} iff 5 scn07
        .long scn07         #} iff 6 scn07
        .long scn07         #} iff 7 scn07
        .long scn07         #} iff 8 scn07
        .long scn05         #horizontal tab} iff ch_ht scn05
        .long scn07         #} iff 10 scn07
        .long scn07         #} iff 11 scn07
        .long scn07         #} iff 12 scn07
        .long scn07         #} iff 13 scn07
        .long scn07         #} iff 14 scn07
        .long scn07         #} iff 15 scn07
        .long scn07         #} iff 16 scn07
        .long scn07         #} iff 17 scn07
        .long scn07         #} iff 18 scn07
        .long scn07         #} iff 19 scn07
        .long scn07         #} iff 20 scn07
        .long scn07         #} iff 21 scn07
        .long scn07         #} iff 22 scn07
        .long scn07         #} iff 23 scn07
        .long scn07         #} iff 24 scn07
        .long scn07         #} iff 25 scn07
        .long scn07         #} iff 26 scn07
        .long scn07         #} iff 27 scn07
        .long scn07         #} iff 28 scn07
        .long scn07         #} iff 29 scn07
        .long scn07         #} iff 30 scn07
        .long scn07         #} iff 31 scn07
        .long scn05         #blank} iff ch_bl scn05
        .long scn37         #exclamation mark} iff ch_ex scn37
        .long scn17         #double quote} iff ch_dq scn17
        .long scn41         #number sign} iff ch_nm scn41
        .long scn36         #dollar} iff ch_dl scn36
        .long scn38         #percent} iff ch_pc scn38
        .long scn44         #ampersand} iff ch_am scn44
        .long scn16         #single quote} iff ch_sq scn16
        .long scn25         #left paren} iff ch_pp scn25
        .long scn26         #right paren} iff ch_rp scn26
        .long scn49         #asterisk} iff ch_as scn49
        .long scn33         #plus} iff ch_pl scn33
        .long scn31         #comma} iff ch_cm scn31
        .long scn34         #minus} iff ch_mn scn34
        .long scn32         #dot} iff ch_dt scn32
        .long scn40         #slash} iff ch_sl scn40
        .long scn08         #digit 0} iff ch_d0 scn08
        .long scn08         #digit 1} iff ch_d1 scn08
        .long scn08         #digit 2} iff ch_d2 scn08
        .long scn08         #digit 3} iff ch_d3 scn08
        .long scn08         #digit 4} iff ch_d4 scn08
        .long scn08         #digit 5} iff ch_d5 scn08
        .long scn08         #digit 6} iff ch_d6 scn08
        .long scn08         #digit 7} iff ch_d7 scn08
        .long scn08         #digit 8} iff ch_d8 scn08
        .long scn08         #digit 9} iff ch_d9 scn08
        .long scn29         #colon} iff ch_cl scn29
        .long scn30         #semi-colon} iff ch_sm scn30
        .long scn28         #left bracket} iff ch_bb scn28
        .long scn46         #equal} iff ch_eq scn46
        .long scn27         #right bracket} iff ch_rb scn27
        .long scn45         #question mark} iff ch_qu scn45
        .long scn42         #at} iff ch_at scn42
        .long scn09         #letter a} iff ch_la scn09
        .long scn09         #letter b} iff ch_lb scn09
        .long scn09         #letter c} iff ch_lc scn09
        .long scn09         #letter d} iff ch_ld scn09
        .long scn09         #letter e} iff ch_le scn09
        .long scn20         #letter f} iff ch_lf scn20
        .long scn09         #letter g} iff ch_lg scn09
        .long scn09         #letter h} iff ch_lh scn09
        .long scn09         #letter i} iff ch_li scn09
        .long scn09         #letter j} iff ch_lj scn09
        .long scn09         #letter k} iff ch_lk scn09
        .long scn09         #letter l} iff ch_ll scn09
        .long scn09         #letter m} iff ch_lm scn09
        .long scn09         #letter n} iff ch_ln scn09
        .long scn09         #letter o} iff ch_lo scn09
        .long scn09         #letter p} iff ch_lp scn09
        .long scn09         #letter q} iff ch_lq scn09
        .long scn09         #letter r} iff ch_lr scn09
        .long scn21         #letter s} iff ch_ls scn21
        .long scn09         #letter t} iff ch_lt scn09
        .long scn09         #letter u} iff ch_lu scn09
        .long scn09         #letter v} iff ch_lv scn09
        .long scn09         #letter w} iff ch_lw scn09
        .long scn09         #letter x} iff ch_lx scn09
        .long scn09         #letter y} iff ch_ly scn09
        .long scn09         #letter z} iff ch_l_ scn09
        .long scn28         #left bracket} iff ch_ob scn28
        .long scn07         #} iff 92 scn07
        .long scn27         #right bracket} iff ch_cb scn27
        .long scn37         #up arrow} iff ch_ey scn37
        .long scn24         #underline} iff ch_un scn24
        .long scn07         #} iff 96 scn07
        .long scn09         #shifted a} iff ch__a scn09
        .long scn09         #shifted b} iff ch__b scn09
        .long scn09         #shifted c} iff ch__c scn09
        .long scn09         #shifted d} iff ch__d scn09
        .long scn09         #shifted e} iff ch__e scn09
        .long scn20         #shifted f} iff ch__f scn20
        .long scn09         #shifted g} iff ch__g scn09
        .long scn09         #shifted h} iff ch__h scn09
        .long scn09         #shifted i} iff ch__i scn09
        .long scn09         #shifted j} iff ch__j scn09
        .long scn09         #shifted k} iff ch__k scn09
        .long scn09         #shifted l} iff ch__l scn09
        .long scn09         #shifted m} iff ch__m scn09
        .long scn09         #shifted n} iff ch__n scn09
        .long scn09         #shifted o} iff ch__o scn09
        .long scn09         #shifted p} iff ch__p scn09
        .long scn09         #shifted q} iff ch__q scn09
        .long scn09         #shifted r} iff ch__r scn09
        .long scn21         #shifted s} iff ch__s scn21
        .long scn09         #shifted t} iff ch__t scn09
        .long scn09         #shifted u} iff ch__u scn09
        .long scn09         #shifted v} iff ch__v scn09
        .long scn09         #shifted w} iff ch__w scn09
        .long scn09         #shifted x} iff ch__x scn09
        .long scn09         #shifted y} iff ch__y scn09
        .long scn09         #shifted z} iff ch___ scn09
        .long scn07         #} iff 123 scn07
        .long scn43         #vertical bar} iff ch_br scn43
        .long scn07         #} iff 125 scn07
        .long scn35         #not} iff ch_nt scn35
        .long scn07         #} iff 127 scn07
        DSegEnd_            #end switch on character} esw
        CSeg_
#
#      here for illegal character (underline merges)
#
scn07:  OR                  #jump if scanning name or constant} bze wb scn10
        JZ   scn10
        CALL ERR_0          #} erb 230 syntax error: illegal character
        .byte 230
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here for digits 0-9
#
scn08:  OR                  #keep scanning if name/constant} bze wb scn09
        JZ   scn09
        XOR                 #else set flag for scanning constant} zer wc
#
#      here for letter. loop here when scanning name/constant
#
scn09:  CMP                 #jump if end of image} beq wa scnil scn11
             scn11
        XOR                 #set flag for scanning name/const} zer wb
        JMP  scn06          #merge back to continue scan} brn scn06
#
#      come here for delimiter ending name or constant
#
scn10:  DEC                 #reset offset to point to delimiter} dcv wa
#
#      come here after finishing scan of name or constant
#
scn11:  MOV  DWORD PTR scnpt #store updated scan offset} mov wa scnpt
        MOV                 #point to start of element} mov scnse wb
        SUB                 #get number of characters} sub wb wa
        MOV                 #point to line image} mov r_cim xl
        OR                  #jump if name} bnz wc scn15
        JNZ  scn15
#
#      here after scanning out numeric constant
#
        CALL sbstr          #get string for constant} jsr sbstr
        MOV  DWORD PTR dnamp #delete from storage (not needed)} mov xr dnamp
        CALL gtnum          #convert to numeric} jsr gtnum
        .short scn14-DFFNC  #jump if conversion failure} ppm scn14
#
#      merge here to exit with constant
#
scn12:  MOV                 #set result type of constant} mov =t_con xl
                            #} ejc
        .eject
#
#      scane (continued)
#
#      common exit point (xr,xl) set
#
scn13:  MOV                 #restore wa} mov scnsa wa
        MOV                 #restore wb} mov scnsb wb
        MOV                 #restore wc} mov scnsc wc
        MOV  DWORD PTR r_scp #save xr in case rescan} mov xr r_scp
        MOV  DWORD PTR scntp #save xl in case rescan} mov xl scntp
        XOR  EAX,EAX        #reset possible goto flag} zer scngo
        MOV  DWORD PTR scngo,EAX
        RET                 #return to scane caller} exi
#
#      here if conversion error on numeric item
#
scn14:  CALL ERR_0          #} erb 231 syntax error: invalid numeric item
        .byte 231
#
#      here after scanning out variable name
#
scn15:  CALL sbstr          #build string name of variable} jsr sbstr
        CMP  DWORD PTR DWORD PTR scncc,0 #return if cncrd call} bnz scncc scn13
        JNZ  scn13
        CALL gtnvr          #locate/build vrblk} jsr gtnvr
        .short ERR_-299-DFFNC #dummy (unused) error return} ppm
        MOV                 #set type as variable} mov =t_var xl
        JMP  scn13          #back to exit} brn scn13
#
#      here for single quote (start of string constant)
#
scn16:  OR                  #terminator if scanning name or cnst} bze wb scn10
        JZ   scn10
        MOV                 #set terminator as single quote} mov =ch_sq wb
        JMP  scn18          #merge} brn scn18
#
#      here for double quote (start of string constant)
#
scn17:  OR                  #terminator if scanning name or cnst} bze wb scn10
        JZ   scn10
        MOV                 #set double quote terminator, merge} mov =ch_dq wb
#
#      loop to scan out string constant
#
scn18:  CMP                 #error if end of image} beq wa scnil scn19
             scn19
        MOVZX               #else load next character} lch wc (xl)+
        INC
        INC                 #bump offset} icv wa
        CMP                 #loop back if not terminator} bne wc wb scn18
             scn18
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here after scanning out string constant
#
        MOV                 #point to first character} mov scnpt wb
        MOV  DWORD PTR scnpt #save offset past final quote} mov wa scnpt
        DEC                 #point back past last character} dcv wa
        SUB                 #get number of characters} sub wb wa
        MOV                 #point to input image} mov r_cim xl
        CALL sbstr          #build substring value} jsr sbstr
        JMP  scn12          #back to exit with constant result} brn scn12
#
#      here if no matching quote found
#
scn19:  MOV  DWORD PTR scnpt #set updated scan pointer} mov wa scnpt
        CALL ERR_0          #} erb 232 syntax error: unmatched string quote
        .byte 232
#
#      here for f (possible failure goto)
#
scn20:  MOV                 #set return code for fail goto} mov =t_fgo xr
        JMP  scn22          #jump to merge} brn scn22
#
#      here for s (possible success goto)
#
scn21:  MOV                 #set success goto as return code} mov =t_sgo xr
#
#      special goto cases merge here
#
scn22:  CMP  DWORD PTR DWORD PTR scngo,0 #treat as normal letter if not goto} bze scngo scn09
        JZ   scn09
#
#      merge here for special character exit
#
scn23:  OR                  #jump if end of name/constant} bze wb scn10
        JZ   scn10
        MOV                 #else copy code} mov xr xl
        JMP  scn13          #and jump to exit} brn scn13
#
#      here for underline
#
scn24:  OR                  #part of name if scanning name} bze wb scn09
        JZ   scn09
        JMP  scn07          #else illegal} brn scn07
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here for left paren
#
scn25:  MOV                 #set left paren return code} mov =t_lpr xr
        OR                  #return left paren unless name} bnz wb scn23
        JNZ  scn23
        OR                  #delimiter if scanning constant} bze wc scn10
        JZ   scn10
#
#      here for left paren after name (function call)
#
        MOV                 #point to start of name} mov scnse wb
        MOV  DWORD PTR scnpt #set pointer past left paren} mov wa scnpt
        DEC                 #point back past last char of name} dcv wa
        SUB                 #get name length} sub wb wa
        MOV                 #point to input image} mov r_cim xl
        CALL sbstr          #get string name for function} jsr sbstr
        CALL gtnvr          #locate/build vrblk} jsr gtnvr
        .short ERR_-299-DFFNC #dummy (unused) error return} ppm
        MOV                 #set code for function call} mov =t_fnc xl
        JMP  scn13          #back to exit} brn scn13
#
#      processing for special characters
#
scn26:  MOV                 #right paren, set code} mov =t_rpr xr
        JMP  scn23          #take special character exit} brn scn23
#
scn27:  MOV                 #right bracket, set code} mov =t_rbr xr
        JMP  scn23          #take special character exit} brn scn23
#
scn28:  MOV                 #left bracket, set code} mov =t_lbr xr
        JMP  scn23          #take special character exit} brn scn23
#
scn29:  MOV                 #colon, set code} mov =t_col xr
        JMP  scn23          #take special character exit} brn scn23
#
scn30:  MOV                 #semi-colon, set code} mov =t_smc xr
        JMP  scn23          #take special character exit} brn scn23
#
scn31:  MOV                 #comma, set code} mov =t_cma xr
        JMP  scn23          #take special character exit} brn scn23
                            #} ejc
        .eject
#
#      scane (continued)
#
#      here for operators. on entry, wc points to the table of
#      operator dope vectors and wb is the increment to step
#      to the next pair (binary/unary) of dope vectors in the
#      list. on reaching scn46, the pointer has been adjusted to
#      point to the appropriate pair of dope vectors.
#      the first three entries are special since they can occur
#      as part of a variable name (.) or constant (.+-).
#
scn32:  OR                  #dot can be part of name or constant} bze wb scn09
        JZ   scn09
        ADD                 #else bump pointer} add wb wc
#
scn33:  OR                  #plus can be part of constant} bze wc scn09
        JZ   scn09
        OR                  #plus cannot be part of name} bze wb scn48
        JZ   scn48
        ADD                 #else bump pointer} add wb wc
#
scn34:  OR                  #minus can be part of constant} bze wc scn09
        JZ   scn09
        OR                  #minus cannot be part of name} bze wb scn48
        JZ   scn48
        ADD                 #else bump pointer} add wb wc
#
scn35:  ADD                 #not} add wb wc
scn36:  ADD                 #dollar} add wb wc
scn37:  ADD                 #exclamation} add wb wc
scn38:  ADD                 #percent} add wb wc
scn39:  ADD                 #asterisk} add wb wc
scn40:  ADD                 #slash} add wb wc
scn41:  ADD                 #number sign} add wb wc
scn42:  ADD                 #at sign} add wb wc
scn43:  ADD                 #vertical bar} add wb wc
scn44:  ADD                 #ampersand} add wb wc
scn45:  ADD                 #question mark} add wb wc
#
#      all operators come here (equal merges directly)
#      (wc) points to the binary/unary pair of operator dvblks.
#
scn46:  OR                  #operator terminates name/constant} bze wb scn10
        JZ   scn10
        MOV                 #else copy dv pointer} mov wc xr
        MOVZX               #load next character} lch wc (xl)
        MOV                 #set binary op in case} mov =t_bop xl
        CMP                 #should be binary if image end} beq wa scnil scn47
             scn47
        CMP                 #should be binary if followed by blk} beq wc =ch_bl scn47
             scn47
        CMP                 #jump if horizontal tab} beq wc =ch_ht scn47
             scn47
        CMP                 #semicolon can immediately follow =} beq wc =ch_sm scn47
             scn47
        CMP                 #colon can immediately follow =} beq wc =ch_cl scn47
             scn47
        CMP                 #right paren can immediately follow =} beq wc =ch_rp scn47
             scn47
        CMP                 #right bracket can immediately follow =} beq wc =ch_rb scn47
             scn47
        CMP                 #right bracket can immediately follow =} beq wc =ch_cb scn47
             scn47
#
#      here for unary operator
#
        ADD                 #point to dv for unary op} add *dvbs_ xr
        MOV                 #set type for unary operator} mov =t_uop xl
        CMP  DWORD PTR scntp,t_uok #ok unary if ok preceding element} ble scntp =t_uok scn13
             scn13
                            #} ejc
        .eject
#
#      scane (continued)
#
#      merge here to require preceding blanks
#
scn47:  CMP  DWORD PTR DWORD PTR scnbl,0 #all ok if preceding blanks, exit} bnz scnbl scn13
        JNZ  scn13
#
#      fail operator in this position
#
scn48:  CALL ERR_0          #} erb 233 syntax error: invalid use of operator
        .byte 233
#
#      here for asterisk, could be ** substitute for exclamation
#
scn49:  OR                  #end of name if scanning name} bze wb scn10
        JZ   scn10
        CMP                 #not ** if * at image end} beq wa scnil scn39
             scn39
        MOV                 #else save offset past first *} mov wa xr
        MOV  DWORD PTR scnof #save another copy} mov wa scnof
        MOVZX               #load next character} lch wa (xl)+
        INC
        CMP                 #not ** if next char not *} bne wa =ch_as scn50
             scn50
        INC                 #else step offset past second *} icv xr
        CMP                 #ok exclam if end of image} beq xr scnil scn51
             scn51
        MOVZX               #else load next character} lch wa (xl)
        CMP                 #exclamation if blank} beq wa =ch_bl scn51
             scn51
        CMP                 #exclamation if horizontal tab} beq wa =ch_ht scn51
             scn51
#
#      unary *
#
scn50:  MOV                 #recover stored offset} mov scnof wa
        MOV                 #point to line again} mov r_cim xl
        LEA                 #point to current char} plc xl wa
        JMP  scn39          #merge with unary *} brn scn39
#
#      here for ** as substitute for exclamation
#
scn51:  MOV  DWORD PTR scnpt #save scan pointer past 2nd *} mov xr scnpt
        MOV                 #copy scan pointer} mov xr wa
        JMP  scn37          #merge with exclamation} brn scn37
                            #end procedure scane} enp
                            #} ejc
        .eject
#
#      scngf -- scan goto field
#
#      scngf is called from cmpil to scan and analyze a goto
#      field including the surrounding brackets or parentheses.
#      for a normal goto, the result returned is either a vrblk
#      pointer for a simple label operand, or a pointer to an
#      expression tree with a special outer unary operator
#      (o$goc). for a direct goto, the result returned is a
#      pointer to an expression tree with the special outer
#      unary operator o$god.
#
#      jsr  scngf            call to scan goto field
#      (xr)                  result (see above)
#      (xl,wa,wb,wc)         destroyed
#
scngf:                      #entry point} prc e 0
        .global scngf
        CALL scane          #scan initial element} jsr scane
        CMP                 #skip if left paren (normal goto)} beq xl =t_lpr scng1
             scng1
        CMP                 #skip if left bracket (direct goto)} beq xl =t_lbr scng2
             scng2
        CALL ERR_0          #} erb 234 syntax error: goto field incorrect
        .byte 234
#
#      here for left paren (normal goto)
#
scng1:  MOV                 #set expan flag for normal goto} mov =num01 wb
        CALL expan          #analyze goto field} jsr expan
        MOV                 #point to opdv for complex goto} mov =opdvn wa
        CMP                 #jump if not in static (sgd15)} ble xr statb scng3
             scng3
        CMP                 #jump to exit if simple label name} blo xr state scng4
             scng4
        JMP  scng3          #complex goto - merge} brn scng3
#
#      here for left bracket (direct goto)
#
scng2:  MOV                 #set expan flag for direct goto} mov =num02 wb
        CALL expan          #scan goto field} jsr expan
        MOV                 #set opdv pointer for direct goto} mov =opdvd wa
                            #} ejc
        .eject
#
#      scngf (continued)
#
#      merge here to build outer unary operator block
#
scng3:  LEA                 #stack operator dv pointer} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #stack pointer to expression tree} mov xr -(xs)
        MOV  DWORD PTR []
        CALL expop          #pop operator off} jsr expop
        MOV                 #reload new expression tree pointer} mov (xs)+ xr
        LEA
#
#      common exit point
#
scng4:  RET                 #return to caller} exi
                            #end procedure scngf} enp
                            #} ejc
        .eject
#
#      setvr -- set vrget,vrsto fields of vrblk
#
#      setvr sets the proper values in the vrget and vrsto
#      fields of a vrblk. it is called whenever trblks are
#      added or subtracted (trace,stoptr,input,output,detach)
#
#      (xr)                  pointer to vrblk
#      jsr  setvr            call to set fields
#      (xl,wa)               destroyed
#
#      note that setvr ignores the call if xr does not point
#      into the static region (i.e. is some other name base)
#
setvr:                      #entry point} prc e 0
        .global setvr
        CMP                 #exit if not natural variable} bhi xr state setv1
             setv1
#
#      here if we have a vrblk
#
        MOV                 #copy vrblk pointer} mov xr xl
        MOV  DWORD PTR (4*vrget)[],offset b_vrl #store normal get value} mov =b_vrl vrget(xr)
        CMP  DWORD PTR (4*vrsto)[],offset b_vre #skip if protected variable} beq vrsto(xr) =b_vre setv1
             setv1
        MOV  DWORD PTR (4*vrsto)[],offset b_vrs #store normal store value} mov =b_vrs vrsto(xr)
        MOV                 #point to next entry on chain} mov vrval(xl) xl
        CMP  DWORD PTR [],offset b_trt #jump if end of trblk chain} bne (xl) =b_trt setv1
             setv1
        MOV  DWORD PTR (4*vrget)[],offset b_vra #store trapped routine address} mov =b_vra vrget(xr)
        MOV  DWORD PTR (4*vrsto)[],offset b_vrv #set trapped routine address} mov =b_vrv vrsto(xr)
#
#      merge here to exit to caller
#
setv1:  RET                 #return to setvr caller} exi
                            #end procedure setvr} enp
                            #} ejc
        .eject
#
#      sorta -- sort array
#
#      routine to sort an array or table on same basis as in
#      sitbol. a table is converted to an array, leaving two
#      dimensional arrays and vectors as cases to be considered.
#      whole rows of arrays are permuted according to the
#      ordering of the keys they contain, and the stride
#      referred to, is the the length of a row. it is one
#      for a vector.
#      the sort used is heapsort, fundamentals of data structure
#      horowitz and sahni, pitman 1977, page 347.
#      it is an order n*log(n) algorithm. in order
#      to make it stable, comparands may not compare equal. this
#      is achieved by sorting a copy array (referred to as the
#      sort array) containing at its high address end, byte
#      offsets to the rows to be sorted held in the original
#      array (referred to as the key array). sortc, the
#      comparison routine, accesses the keys through these
#      offsets and in the case of equality, resolves it by
#      comparing the offsets themselves. the sort permutes the
#      offsets which are then used in a final operation to copy
#      the actual items into the new array in sorted order.
#      references to zeroth item are to notional item
#      preceding first actual item.
#      reverse sorting for rsort is done by having the less than
#      test for keys effectively be replaced by a
#      greater than test.
#
#      1(xs)                 first arg - array or table
#      0(xs)                 2nd arg - index or pdtype name
#      (wa)                  0 , non-zero for sort , rsort
#      jsr  sorta            call to sort array
#      ppm  loc              transfer loc if table is empty
#      (xr)                  sorted array
#      (xl,wa,wb,wc)         destroyed
                            #} ejc
        .eject
#
#      sorta (continued)
#
sorta:                      #entry point} prc n 1
        .global sorta
        POP  PRC_+60
        MOV  DWORD PTR srtsr #sort/rsort indicator} mov wa srtsr
        MOV  DWORD PTR srtst,4*num01 #default stride of 1} mov *num01 srtst
        XOR  EAX,EAX        #default zero offset to sort key} zer srtof
        MOV  DWORD PTR srtof,EAX
        MOV  DWORD PTR srtdf,offset nulls #clear datatype field name} mov =nulls srtdf
        MOV  EAX,DWORD PTR [] #unstack argument 2} mov (xs)+ r_sxr
        MOV  DWORD PTR r_sxr,EAX
        LEA
        MOV                 #get first argument} mov (xs)+ xr
        LEA
        MOV                 #use key/values of table entries} mnz wa
        CALL gtarr          #convert to array} jsr gtarr
        .short srt18-DFFNC  #signal that table is empty} ppm srt18
        .short srt16-DFFNC  #error if non-convertable} ppm srt16
        LEA                 #stack ptr to resulting key array} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #another copy for copyb} mov xr -(xs)
        MOV  DWORD PTR []
        CALL copyb          #get copy array for sorting into} jsr copyb
        .short ERR_-299-DFFNC #cant fail} ppm
        LEA                 #stack pointer to sort array} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get second arg} mov r_sxr xr
        MOV                 #get ptr to key array} mov num01(xs) xl
        CMP  DWORD PTR [],offset b_vct #jump if arblk} bne (xl) =b_vct srt02
             srt02
        CMP                 #jump if null second arg} beq xr =nulls srt01
             srt01
        CALL gtnvr          #get vrblk ptr for it} jsr gtnvr
        .short ERR_-257-DFFNC #} err 257 erroneous 2nd arg in sort/rsort of vector
        MOV  DWORD PTR srtdf #store datatype field name vrblk} mov xr srtdf
#
#      compute n and offset to item a(0) in vector case
#
srt01:  MOV                 #offset to a(0)} mov *vclen wc
        MOV                 #offset to first item} mov *vcvls wb
        MOV                 #get block length} mov vclen(xl) wa
        SUB                 #get no. of entries, n (in bytes)} sub *vcsi_ wa
        JMP  srt04          #merge} brn srt04
#
#      here for array
#
srt02:  MOV  EDX,DWORD PTR (4*ardim)[] #get possible dimension} ldi ardim(xl)
        MOV                 #convert to short integer} mfi wa
        SAL                 #further convert to baus} wtb wa
        MOV                 #offset to first value if one} mov *arvls wb
        MOV                 #offset before values if one dim.} mov *arpro wc
        CMP  DWORD PTR (4*arndm)[],num01 #jump in fact if one dim.} beq arndm(xl) =num01 srt04
             srt04
        CMP  DWORD PTR (4*arndm)[],num02 #fail unless two dimens} bne arndm(xl) =num02 srt16
             srt16
        MOV  EDX,DWORD PTR (4*arlb2)[] #get lower bound 2 as default} ldi arlb2(xl)
        CMP                 #jump if default second arg} beq xr =nulls srt03
             srt03
        CALL gtint          #convert to integer} jsr gtint
        .short srt17-DFFNC  #fail} ppm srt17
        MOV  EDX,DWORD PTR (4*icval)[] #get actual integer value} ldi icval(xr)
                            #} ejc
        .eject
#
#      sorta (continued)
#
#      here with sort column index in ia in array case
#
srt03:  SUB  EDX,DWORD PTR (4*arlb2)[] #subtract low bound} sbi arlb2(xl)
        JO   srt17          #fail if overflow} iov srt17
        OR   EDX,EDX        #fail if below low bound} ilt srt17
        JL   srt17
        SUB  EDX,DWORD PTR (4*ardm2)[] #check against dimension} sbi ardm2(xl)
#        OR   EDX,EDX        #fail if too large} ige srt17   (Optimized)
        JGE  srt17
        ADD  EDX,DWORD PTR (4*ardm2)[] #restore value} adi ardm2(xl)
        MOV                 #get as small integer} mfi wa
        SAL                 #offset within row to key} wtb wa
        MOV  DWORD PTR srtof #keep offset} mov wa srtof
        MOV  EDX,DWORD PTR (4*ardm2)[] #second dimension is row length} ldi ardm2(xl)
        MOV                 #convert to short integer} mfi wa
        MOV                 #copy row length} mov wa xr
        SAL                 #convert to bytes} wtb wa
        MOV  DWORD PTR srtst #store as stride} mov wa srtst
        MOV  EDX,DWORD PTR (4*ardim)[] #get number of rows} ldi ardim(xl)
        MOV                 #as a short integer} mfi wa
        SAL                 #convert n to baus} wtb wa
        MOV                 #offset past array end} mov arlen(xl) wc
        SUB                 #adjust, giving space for n offsets} sub wa wc
        SUB                 #point to a(0)} dca wc
        MOV                 #offset to word before first item} mov arofs(xl) wb
        ADD                 #offset to first item} ica wb
#
#      separate pre-processing for arrays and vectors done.
#      to simplify later key comparisons, removal of any trblk
#      trap blocks from entries in key array is effected.
#
#      (xl) = 1(xs) = pointer to key array
#      (xs) = pointer to sort array
#      wa = number of items, n (converted to bytes).
#      wb = offset to first item of arrays.
#      wc = offset to a(0)
#
srt04:  CMP                 #return if only a single item} ble wa *num01 srt15
             srt15
        MOV  DWORD PTR srtsn #store number of items (in baus)} mov wa srtsn
        MOV  DWORD PTR srtso #store offset to a(0)} mov wc srtso
        MOV                 #length of array or vec (=vclen)} mov arlen(xl) wc
        ADD                 #point past end of array or vector} add xl wc
        MOV  DWORD PTR srtsf #store offset to first row} mov wb srtsf
        ADD                 #point to first item in key array} add wb xl
#
#      loop through array
#
srt05:  MOV                 #get an entry} mov (xl) xr
#
#      hunt along trblk chain
#
srt06:  CMP  DWORD PTR [],offset b_trt #jump out if not trblk} bne (xr) =b_trt srt07
             srt07
        MOV                 #get value field} mov trval(xr) xr
        JMP  srt06          #loop} brn srt06
                            #} ejc
        .eject
#
#      sorta (continued)
#
#      xr is value from end of chain
#
srt07:  MOV  DWORD PTR []   #store as array entry} mov xr (xl)+
        LEA
        CMP                 #loop if not done} blt xl wc srt05
             srt05
        MOV                 #get adrs of sort array} mov (xs) xl
        MOV                 #initial offset to first key} mov srtsf xr
        MOV                 #get stride} mov srtst wb
        ADD                 #offset to a(0)} add srtso xl
        ADD                 #point to a(1)} ica xl
        MOV                 #get n} mov srtsn wc
        SHR                 #convert from bytes} btw wc
        MOV  DWORD PTR srtnr #store as row count} mov wc srtnr
#
#      store key offsets at top of sort array
#
srt08:  MOV  DWORD PTR []   #store an offset} mov xr (xl)+
        LEA
        ADD                 #bump offset by stride} add wb xr
        DEC                 #loop through rows} bct wc srt08
        JNZ  srt08
#
#      perform the sort on offsets in sort array.
#
#      (srtsn)               number of items to sort, n (bytes)
#      (srtso)               offset to a(0)
#
srt09:  MOV                 #get n} mov srtsn wa
        MOV                 #get number of rows} mov srtnr wc
        SHR                 #i = n / 2 (wc=i, index into array)} rsh wc 1
        SAL                 #convert back to bytes} wtb wc
#
#      loop to form initial heap
#
srt10:  CALL sorth          #sorth(i,n)} jsr sorth
        SUB                 #i = i - 1} dca wc
#        OR                  #loop if i gt 0} bnz wc srt10  (Optimized)
        JNZ  srt10
        MOV                 #i = n} mov wa wc
#
#      sorting loop. at this point, a(1) is the largest
#      item, since algorithm initialises it as, and then maintains
#      it as, root of tree.
#
srt11:  SUB                 #i = i - 1 (n - 1 initially)} dca wc
#        OR                  #jump if done} bze wc srt12  (Optimized)
        JZ   srt12
        MOV                 #get sort array address} mov (xs) xr
        ADD                 #point to a(0)} add srtso xr
        MOV                 #a(0) address} mov xr xl
        ADD                 #a(i) address} add wc xl
        MOV                 #copy a(i+1)} mov num01(xl) wb
        MOV  EAX,DWORD PTR (4*num01)[] #move a(1) to a(i+1)} mov num01(xr) num01(xl)
        MOV  DWORD PTR (4*num01)[],EAX
        MOV  DWORD PTR (4*num01)[] #complete exchange of a(1), a(i+1)} mov wb num01(xr)
        MOV                 #n = i for sorth} mov wc wa
        MOV                 #i = 1 for sorth} mov *num01 wc
        CALL sorth          #sorth(1,n)} jsr sorth
        MOV                 #restore wc} mov wa wc
        JMP  srt11          #loop} brn srt11
                            #} ejc
        .eject
#
#      sorta (continued)
#
#      offsets have been permuted into required order by sort.
#      copy array elements over them.
#
srt12:  MOV                 #base adrs of key array} mov (xs) xr
        MOV                 #copy it} mov xr wc
        ADD                 #offset of a(0)} add srtso wc
        ADD                 #adrs of first row of sort array} add srtsf xr
        MOV                 #get stride} mov srtst wb
#
#      copying loop for successive items. sorted offsets are
#      held at end of sort array.
#
srt13:  ADD                 #adrs of next of sorted offsets} ica wc
        MOV                 #copy it for access} mov wc xl
        MOV                 #get offset} mov (xl) xl
        ADD                 #add key array base adrs} add num01(xs) xl
        MOV                 #get count of characters in row} mov wb wa
        SHR  ECX,2          #copy a complete row} mvw
        REP  MOVSD
        DEC  DWORD PTR srtnr #decrement row count} dcv srtnr
        CMP  DWORD PTR DWORD PTR srtnr,0 #repeat till all rows done} bnz srtnr srt13
        JNZ  srt13
#
#      return point
#
srt15:  MOV                 #pop result array ptr} mov (xs)+ xr
        LEA
        ADD                 #pop key array ptr} ica xs
        XOR  EAX,EAX        #clear junk} zer r_sxl
        MOV  DWORD PTR r_sxl,EAX
        XOR  EAX,EAX        #clear junk} zer r_sxr
        MOV  DWORD PTR r_sxr,EAX
        POP  EAX            #return} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      error point
#
srt16:  CALL ERR_1          #} erb 256 sort/rsort 1st arg not suitable array or table
        .byte 0
srt17:  CALL ERR_1          #} erb 258 sort/rsort 2nd arg out of range or non-integer
        .byte 2
#
#      return point if input table is empty
#
srt18:  POP  EAX            #return indication of null table} exi 1
        JMP  EXI__1
                            #end procudure sorta} enp
                            #} ejc
        .eject
#
#      sortc --  compare sort keys
#
#      compare two sort keys given their offsets. if
#      equal, compare key offsets to give stable sort.
#      note that if srtsr is non-zero (request for reverse
#      sort), the quoted returns are inverted.
#      for objects of differing datatypes, the entry point
#      identifications are compared.
#
#      (xl)                  base adrs for keys
#      (wa)                  offset to key 1 item
#      (wb)                  offset to key 2 item
#      (srtsr)               zero/non-zero for sort/rsort
#      (srtof)               offset within row to comparands
#      jsr  sortc            call to compare keys
#      ppm  loc              key1 less than key2
#                            normal return, key1 gt than key2
#      (xl,xr,wa,wb)         destroyed
#
sortc:                      #entry point} prc e 1
        .global sortc
        MOV  DWORD PTR srts1 #save offset 1} mov wa srts1
        MOV  DWORD PTR srts2 #save offset 2} mov wb srts2
        MOV  DWORD PTR srtsc #save wc} mov wc srtsc
        ADD                 #add offset to comparand field} add srtof xl
        MOV                 #copy base + offset} mov xl xr
        ADD                 #add key1 offset} add wa xl
        ADD                 #add key2 offset} add wb xr
        MOV                 #get key1} mov (xl) xl
        MOV                 #get key2} mov (xr) xr
        CMP  DWORD PTR srtdf,offset nulls #jump if datatype field name used} bne srtdf =nulls src12
             src12
                            #} ejc
        .eject
#
#      sortc (continued)
#
#      merge after dealing with field name. try for strings.
#
src01:  MOV                 #get type code} mov (xl) wc
        CMP                 #skip if not same datatype} bne wc (xr) src02
             src02
        CMP                 #jump if both strings} beq wc =b_scl src09
             src09
        CMP                 #jump if both integers} beq wc =b_icl src14
             src14
#
#      datatypes different.  now try for numeric
#
src02:  MOV  DWORD PTR r_sxl #keep arg1} mov xl r_sxl
        MOV  DWORD PTR r_sxr #keep arg2} mov xr r_sxr
        CMP                 #do not allow conversion to number} beq wc =b_scl src11
             src11
        CMP  DWORD PTR [],offset b_scl #if either arg is a string} beq (xr) =b_scl src11
             src11
src14:  LEA                 #stack} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #args} mov xr -(xs)
        MOV  DWORD PTR []
        CALL acomp          #compare objects} jsr acomp
        .short src10-DFFNC  #not numeric} ppm src10
        .short src10-DFFNC  #not numeric} ppm src10
        .short src03-DFFNC  #key1 less} ppm src03
        .short src08-DFFNC  #keys equal} ppm src08
        .short src05-DFFNC  #key1 greater} ppm src05
#
#      return if key1 smaller (sort), greater (rsort)
#
src03:  CMP  DWORD PTR DWORD PTR srtsr,0 #jump if rsort} bnz srtsr src06
        JNZ  src06
#
src04:  MOV                 #restore wc} mov srtsc wc
        POP  EAX            #return} exi 1
        JMP  EXI__1
#
#      return if key1 greater (sort), smaller (rsort)
#
src05:  CMP  DWORD PTR DWORD PTR srtsr,0 #jump if rsort} bnz srtsr src04
        JNZ  src04
#
src06:  MOV                 #restore wc} mov srtsc wc
        POP  EAX            #return} exi
        LEA  EAX,[EAX+2]
        JMP  EAX
#
#      keys are of same datatype
#
src07:  CMP                 #item first created is less} blt xl xr src03
             src03
        CMP                 #addresses rise in order of creation} bgt xl xr src05
             src05
#
#      drop through or merge for identical or equal objects
#
src08:  MOV  EAX,DWORD PTR srts1 #test offsets or key addrss instead} blt srts1 srts2 src04
        CMP  EAX,DWORD PTR srts2
             src04
        JMP  src06          #offset 1 greater} brn src06
                            #} ejc
        .eject
#
#      sortc (continued)
#
#      strings
#
src09:  LEA                 #stack} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #args} mov xr -(xs)
        MOV  DWORD PTR []
        CALL lcomp          #compare objects} jsr lcomp
        .short ERR_-299-DFFNC #cant} ppm
        .short ERR_-299-DFFNC #fail} ppm
        .short src03-DFFNC  #key1 less} ppm src03
        .short src08-DFFNC  #keys equal} ppm src08
        .short src05-DFFNC  #key1 greater} ppm src05
#
#      arithmetic comparison failed - recover args
#
src10:  MOV                 #get arg1} mov r_sxl xl
        MOV                 #get arg2} mov r_sxr xr
        MOV                 #get type of key1} mov (xl) wc
        CMP                 #jump if keys of same type} beq wc (xr) src07
             src07
#
#      here to compare datatype ids
#
src11:  MOV                 #get block type word} mov wc xl
        MOV                 #get block type word} mov (xr) xr
        MOVZX               #entry point id for key1} lei xl
        MOVZX               #entry point id for key2} lei xr
        CMP                 #jump if key1 gt key2} bgt xl xr src05
             src05
        JMP  src03          #key1 lt key2} brn src03
#
#      datatype field name used
#
src12:  CALL sortf          #call routine to find field 1} jsr sortf
        LEA                 #stack item pointer} mov xl -(xs)
        MOV  DWORD PTR []
        MOV                 #get key2} mov xr xl
        CALL sortf          #find field 2} jsr sortf
        MOV                 #place as key2} mov xl xr
        MOV                 #recover key1} mov (xs)+ xl
        LEA
        JMP  src01          #merge} brn src01
                            #procedure sortc} enp
                            #} ejc
        .eject
#
#      sortf -- find field for sortc
#
#      routine used by sortc to obtain item corresponding
#      to a given field name, if this exists, in a programmer
#      defined object passed as argument.
#      if such a match occurs, record is kept of datatype
#      name, field name and offset to field in order to
#      short-circuit later searches on same type. note that
#      dfblks are stored in static and hence cannot be moved.
#
#      (srtdf)               vrblk pointer of field name
#      (xl)                  possible pdblk pointer
#      jsr  sortf            call to search for field name
#      (xl)                  item found or original pdblk ptr
#      (wc)                  destroyed
#
sortf:                      #entry point} prc e 0
        .global sortf
        CMP  DWORD PTR [],offset b_pdt #return if not pdblk} bne (xl) =b_pdt srtf3
             srtf3
        LEA                 #keep xr} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #get possible former dfblk ptr} mov srtfd xr
        OR                  #jump if not} bze xr srtf4
        JZ   srtf4
        CMP                 #jump if not right datatype} bne xr pddfp(xl) srtf4
             srtf4
        MOV  EAX,DWORD PTR srtdf #jump if not right field name} bne srtdf srtff srtf4
        CMP  EAX,DWORD PTR srtff
             srtf4
        ADD                 #add offset to required field} add srtfo xl
#
#      here with xl pointing to found field
#
srtf1:  MOV                 #get item from field} mov (xl) xl
#
#      return point
#
srtf2:  MOV                 #restore xr} mov (xs)+ xr
        LEA
#
srtf3:  RET                 #return} exi
                            #} ejc
        .eject
#
#      sortf (continued)
#
#      conduct a search
#
srtf4:  MOV                 #copy original pointer} mov xl xr
        MOV                 #point to dfblk} mov pddfp(xr) xr
        MOV  DWORD PTR srtfd #keep a copy} mov xr srtfd
        MOV                 #get number of fields} mov fargs(xr) wc
        SAL                 #convert to bytes} wtb wc
        ADD                 #point past last field} add dflen(xr) xr
#
#      loop to find name in pdfblk
#
srtf5:  SUB                 #count down} dca wc
        SUB                 #point in front} dca xr
        MOV  EAX,DWORD PTR [] #skip out if found} beq (xr) srtdf srtf6
        CMP  EAX,DWORD PTR srtdf
             srtf6
        OR                  #loop} bnz wc srtf5
        JNZ  srtf5
        JMP  srtf2          #return - not found} brn srtf2
#
#      found
#
srtf6:  MOV  EAX,DWORD PTR [] #keep field name ptr} mov (xr) srtff
        MOV  DWORD PTR srtff,EAX
        ADD                 #add offset to first field} add *pdfld wc
        MOV  DWORD PTR srtfo #store as field offset} mov wc srtfo
        ADD                 #point to field} add wc xl
        JMP  srtf1          #return} brn srtf1
                            #procedure sortf} enp
                            #} ejc
        .eject
#
#      sorth -- heap routine for sorta
#
#      this routine constructs a heap from elements of array, a.
#      in this application, the elements are offsets to keys in
#      a key array.
#
#      (xs)                  pointer to sort array base
#      1(xs)                 pointer to key array base
#      (wa)                  max array index, n (in bytes)
#      (wc)                  offset j in a to root (in *1 to *n)
#      jsr  sorth            call sorth(j,n) to make heap
#      (xl,xr,wb)            destroyed
#
sorth:                      #entry point} prc n 0
        .global sorth
        POP  PRC_+64
        MOV  DWORD PTR srtsn #save n} mov wa srtsn
        MOV  DWORD PTR srtwc #keep wc} mov wc srtwc
        MOV                 #sort array base adrs} mov (xs) xl
        ADD                 #add offset to a(0)} add srtso xl
        ADD                 #point to a(j)} add wc xl
        MOV  EAX,DWORD PTR [] #get offset to root} mov (xl) srtrt
        MOV  DWORD PTR srtrt,EAX
        ADD                 #double j - cant exceed n} add wc wc
#
#      loop to move down tree using doubled index j
#
srh01:  CMP                 #done if j gt n} bgt wc srtsn srh03
             srh03
        CMP                 #skip if j equals n} beq wc srtsn srh02
             srh02
        MOV                 #sort array base adrs} mov (xs) xr
        MOV                 #key array base adrs} mov num01(xs) xl
        ADD                 #point to a(0)} add srtso xr
        ADD                 #adrs of a(j)} add wc xr
        MOV                 #get a(j+1)} mov num01(xr) wa
        MOV                 #get a(j)} mov (xr) wb
#
#      compare sons. (wa) right son, (wb) left son
#
        CALL sortc          #compare keys - lt(a(j+1),a(j))} jsr sortc
        .short srh02-DFFNC  #a(j+1) lt a(j)} ppm srh02
        ADD                 #point to greater son, a(j+1)} ica wc
                            #} ejc
        .eject
#
#      sorth (continued)
#
#      compare root with greater son
#
srh02:  MOV                 #key array base adrs} mov num01(xs) xl
        MOV                 #get sort array address} mov (xs) xr
        ADD                 #adrs of a(0)} add srtso xr
        MOV                 #copy this adrs} mov xr wb
        ADD                 #adrs of greater son, a(j)} add wc xr
        MOV                 #get a(j)} mov (xr) wa
        MOV                 #point back to a(0)} mov wb xr
        MOV                 #get root} mov srtrt wb
        CALL sortc          #compare them - lt(a(j),root)} jsr sortc
        .short srh03-DFFNC  #father exceeds sons - done} ppm srh03
        MOV                 #get sort array adrs} mov (xs) xr
        ADD                 #point to a(0)} add srtso xr
        MOV                 #copy it} mov xr xl
        MOV                 #copy j} mov wc wa
        SHR                 #convert to words} btw wc
        SHR                 #get j/2} rsh wc 1
        SAL                 #convert back to bytes} wtb wc
        ADD                 #point to a(j)} add wa xl
        ADD                 #adrs of a(j/2)} add wc xr
        MOV  EAX,DWORD PTR [] #a(j/2) = a(j)} mov (xl) (xr)
        MOV  DWORD PTR [],EAX
        MOV                 #recover j} mov wa wc
        ADD                 #j = j*2. done if too big} aov wc wc srh03
        JC   srh03
        JMP  srh01          #loop} brn srh01
#
#      finish by copying root offset back into array
#
srh03:  SHR                 #convert to words} btw wc
        SHR                 #j = j/2} rsh wc 1
        SAL                 #convert back to bytes} wtb wc
        MOV                 #sort array adrs} mov (xs) xr
        ADD                 #adrs of a(0)} add srtso xr
        ADD                 #adrs of a(j/2)} add wc xr
        MOV  EAX,DWORD PTR srtrt #a(j/2) = root} mov srtrt (xr)
        MOV  DWORD PTR [],EAX
        MOV                 #restore wa} mov srtsn wa
        MOV                 #restore wc} mov srtwc wc
        RET                 #return} exi
                            #end procedure sorth} enp
                            #} ejc
        .eject
#
#      trace -- set/reset a trace association
#
#      this procedure is shared by trace and stoptr to
#      either initiate or stop a trace respectively.
#
#      (xl)                  trblk ptr (trace) or zero (stoptr)
#      1(xs)                 first argument (name)
#      0(xs)                 second argument (trace type)
#      jsr  trace            call to set/reset trace
#      ppm  loc              transfer loc if 1st arg is bad name
#      ppm  loc              transfer loc if 2nd arg is bad type
#      (xs)                  popped
#      (xl,xr,wa,wb,wc,ia)   destroyed
#
trace:                      #entry point} prc n 2
        .global trace
        POP  PRC_+68
        CALL gtstg          #get trace type string} jsr gtstg
        .short trc15-DFFNC  #jump if not string} ppm trc15
        ADD                 #else point to string} plc xr
        MOVZX               #load first character} lch wa (xr)
        CMP                 #fold to upper case} flc wa
        JB   SHORT L0019
        CMP
        JA   SHORT L0019
        SUB
L0019:
        MOV                 #load name argument} mov (xs) xr
        MOV  DWORD PTR []   #stack trblk ptr or zero} mov xl (xs)
        MOV                 #set trtyp for access trace} mov =trtac wc
        CMP                 #jump if a (access)} beq wa =ch_la trc10
             trc10
        MOV                 #set trtyp for value trace} mov =trtvl wc
        CMP                 #jump if v (value)} beq wa =ch_lv trc10
             trc10
        CMP                 #jump if blank (value)} beq wa =ch_bl trc10
             trc10
#
#      here for l,k,f,c,r
#
        CMP                 #jump if f (function)} beq wa =ch_lf trc01
             trc01
        CMP                 #jump if r (return)} beq wa =ch_lr trc01
             trc01
        CMP                 #jump if l (label)} beq wa =ch_ll trc03
             trc03
        CMP                 #jump if k (keyword)} beq wa =ch_lk trc06
             trc06
        CMP                 #else error if not c (call)} bne wa =ch_lc trc15
             trc15
#
#      here for f,c,r
#
trc01:  CALL gtnvr          #point to vrblk for name} jsr gtnvr
        .short trc16-DFFNC  #jump if bad name} ppm trc16
        ADD                 #pop stack} ica xs
        MOV                 #point to function block} mov vrfnc(xr) xr
        CMP  DWORD PTR [],offset b_pfc #error if not program function} bne (xr) =b_pfc trc17
             trc17
        CMP                 #jump if r (return)} beq wa =ch_lr trc02
             trc02
                            #} ejc
        .eject
#
#      trace (continued)
#
#      here for f,c to set/reset call trace
#
        MOV  DWORD PTR (4*pfctr)[] #set/reset call trace} mov xl pfctr(xr)
        CMP                 #exit with null if c (call)} beq wa =ch_lc exnul
             exnul
#
#      here for f,r to set/reset return trace
#
trc02:  MOV  DWORD PTR (4*pfrtr)[] #set/reset return trace} mov xl pfrtr(xr)
        POP  EAX            #return} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      here for l to set/reset label trace
#
trc03:  CALL gtnvr          #point to vrblk} jsr gtnvr
        .short trc16-DFFNC  #jump if bad name} ppm trc16
        MOV                 #load label pointer} mov vrlbl(xr) xl
        CMP  DWORD PTR [],offset b_trt #jump if no old trace} bne (xl) =b_trt trc04
             trc04
        MOV                 #else delete old trace association} mov trlbl(xl) xl
#
#      here with old label trace association deleted
#
trc04:  CMP                 #error if undefined label} beq xl =stndl trc16
             trc16
        MOV                 #get trblk ptr again} mov (xs)+ wb
        LEA
        OR                  #jump if stoptr case} bze wb trc05
        JZ   trc05
        MOV  DWORD PTR (4*vrlbl)[] #else set new trblk pointer} mov wb vrlbl(xr)
        MOV  DWORD PTR (4*vrtra)[],offset b_vrt #set label trace routine address} mov =b_vrt vrtra(xr)
        MOV                 #copy trblk pointer} mov wb xr
        MOV  DWORD PTR (4*trlbl)[] #store real label in trblk} mov xl trlbl(xr)
        POP  EAX            #return} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      here for stoptr case for label
#
trc05:  MOV  DWORD PTR (4*vrlbl)[] #store label ptr back in vrblk} mov xl vrlbl(xr)
        MOV  DWORD PTR (4*vrtra)[],offset b_vrg #store normal transfer address} mov =b_vrg vrtra(xr)
        POP  EAX            #return} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
                            #} ejc
        .eject
#
#      trace (continued)
#
#      here for k (keyword)
#
trc06:  CALL gtnvr          #point to vrblk} jsr gtnvr
        .short trc16-DFFNC  #error if not natural var} ppm trc16
        CMP  DWORD PTR DWORD PTR (4*vrlen)[],0 #error if not system var} bnz vrlen(xr) trc16
        JNZ  trc16
        ADD                 #pop stack} ica xs
#        OR                  #jump if stoptr case} bze xl trc07  (Optimized)
        JZ   trc07
        MOV  DWORD PTR (4*trkvr)[] #store vrblk ptr in trblk for ktrex} mov xr trkvr(xl)
#
#      merge here with trblk set up in wb (or zero)
#
trc07:  MOV                 #point to svblk} mov vrsvp(xr) xr
        CMP                 #jump if errtype} beq xr =v_ert trc08
             trc08
        CMP                 #jump if stcount} beq xr =v_stc trc09
             trc09
        CMP                 #else error if not fnclevel} bne xr =v_fnc trc17
             trc17
#
#      fnclevel
#
        MOV  DWORD PTR r_fnc #set/reset fnclevel trace} mov xl r_fnc
        POP  EAX            #return} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      errtype
#
trc08:  MOV  DWORD PTR r_ert #set/reset errtype trace} mov xl r_ert
        POP  EAX            #return} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      stcount
#
trc09:  MOV  DWORD PTR r_stc #set/reset stcount trace} mov xl r_stc
        CALL stgcc          #update countdown counters} jsr stgcc
        POP  EAX            #return} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
                            #} ejc
        .eject
#
#      trace (continued)
#
#      a,v merge here with trtyp value in wc
#
trc10:  CALL gtvar          #locate variable} jsr gtvar
        .short trc16-DFFNC  #error if not appropriate name} ppm trc16
        MOV                 #get new trblk ptr again} mov (xs)+ wb
        LEA
        ADD                 #point to variable location} add xl wa
        MOV                 #copy variable pointer} mov wa xr
#
#      loop to search trblk chain
#
trc11:  MOV                 #point to next entry} mov (xr) xl
        CMP  DWORD PTR [],offset b_trt #jump if not trblk} bne (xl) =b_trt trc13
             trc13
        CMP                 #jump if too far out on chain} blt wc trtyp(xl) trc13
             trc13
        CMP                 #jump if this matches our type} beq wc trtyp(xl) trc12
             trc12
        ADD                 #else point to link field} add *trnxt xl
        MOV                 #copy pointer} mov xl xr
        JMP  trc11          #and loop back} brn trc11
#
#      here to delete an old trblk of the type we were given
#
trc12:  MOV                 #get ptr to next block or value} mov trnxt(xl) xl
        MOV  DWORD PTR []   #store to delete this trblk} mov xl (xr)
#
#      here after deleting any old association of this type
#
trc13:  OR                  #jump if stoptr case} bze wb trc14
        JZ   trc14
        MOV  DWORD PTR []   #else link new trblk in} mov wb (xr)
        MOV                 #copy trblk pointer} mov wb xr
        MOV  DWORD PTR (4*trnxt)[] #store forward pointer} mov xl trnxt(xr)
        MOV  DWORD PTR (4*trtyp)[] #store appropriate trap type code} mov wc trtyp(xr)
#
#      here to make sure vrget,vrsto are set properly
#
trc14:  MOV                 #recall possible vrblk pointer} mov wa xr
        SUB                 #point back to vrblk} sub *vrval xr
        CALL setvr          #set fields if vrblk} jsr setvr
        POP  EAX            #return} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      here for bad trace type
#
trc15:  POP  EAX            #take bad trace type error exit} exi 2
        JMP  EXI__2
#
#      pop stack before failing
#
trc16:  ADD                 #pop stack} ica xs
#
#      here for bad name argument
#
trc17:  POP  EAX            #take bad name error exit} exi 1
        JMP  EXI__1
                            #end procedure trace} enp
                            #} ejc
        .eject
#
#      trbld -- build trblk
#
#      trblk is used by the input, output and trace functions
#      to construct a trblk (trap block)
#
#      (xr)                  trtag or trter
#      (xl)                  trfnc or trfpt
#      (wb)                  trtyp
#      jsr  trbld            call to build trblk
#      (xr)                  pointer to trblk
#      (wa)                  destroyed
#
trbld:                      #entry point} prc e 0
        .global trbld
        LEA                 #stack trtag (or trfnm)} mov xr -(xs)
        MOV  DWORD PTR []
        MOV                 #set size of trblk} mov *trsi_ wa
        CALL alloc          #allocate trblk} jsr alloc
        MOV  DWORD PTR [],offset b_trt #store first word} mov =b_trt (xr)
        MOV  DWORD PTR (4*trfnc)[] #store trfnc (or trfpt)} mov xl trfnc(xr)
        MOV  EAX,DWORD PTR [] #store trtag (or trfnm)} mov (xs)+ trtag(xr)
        MOV  DWORD PTR (4*trtag)[],EAX
        LEA
        MOV  DWORD PTR (4*trtyp)[] #store type} mov wb trtyp(xr)
        MOV  DWORD PTR (4*trval)[],offset nulls #for now, a null value} mov =nulls trval(xr)
        RET                 #return to caller} exi
                            #end procedure trbld} enp
                            #} ejc
        .eject
#
#      trimr -- trim trailing blanks
#
#      trimr is passed a pointer to an scblk which must be the
#      last block in dynamic storage. trailing blanks are
#      trimmed off and the dynamic storage pointer reset to
#      the end of the (possibly) shortened block.
#
#      (wb)                  non-zero to trim trailing blanks
#      (xr)                  pointer to string to trim
#      jsr  trimr            call to trim string
#      (xr)                  pointer to trimmed string
#      (xl,wa,wb,wc)         destroyed
#
#      the call with wb zero still performs the end zero pad
#      and dnamp readjustment. it is used from acess if kvtrm=0.
#
trimr:                      #entry point} prc e 0
        .global trimr
        MOV                 #copy string pointer} mov xr xl
        MOV                 #load string length} mov sclen(xr) wa
        OR                  #jump if null input} bze wa trim2
        JZ   trim2
        LEA                 #else point past last character} plc xl wa
        OR                  #jump if no trim} bze wb trim3
        JZ   trim3
        MOV                 #load blank character} mov =ch_bl wc
#
#      loop through characters from right to left
#
trim0:  DEC                 #load next character} lch wb -(xl)
        MOVZX
        CMP                 #jump if horizontal tab} beq wb =ch_ht trim1
             trim1
        CMP                 #jump if non-blank found} bne wb wc trim3
             trim3
trim1:  DEC                 #else decrement character count} dcv wa
#        OR                  #loop back if more to check} bnz wa trim0  (Optimized)
        JNZ  trim0
#
#      here if result is null (null or all-blank input)
#
trim2:  MOV  DWORD PTR dnamp #wipe out input string block} mov xr dnamp
        MOV                 #load null result} mov =nulls xr
        JMP  trim5          #merge to exit} brn trim5
                            #} ejc
        .eject
#
#      trimr (continued)
#
#      here with non-blank found (merge for no trim)
#
trim3:  MOV  DWORD PTR (4*sclen)[] #set new length} mov wa sclen(xr)
        MOV                 #copy string pointer} mov xr xl
        LEA                 #ready for storing blanks} psc xl wa
        ADD                 #get length of block in bytes} ctb wa schar
        AND
        ADD                 #point past new block} add xr wa
        MOV  DWORD PTR dnamp #set new top of storage pointer} mov wa dnamp
        MOV                 #get count of chars in word} lct wa =cfp_c
        XOR                 #set zero char} zer wc
#
#      loop to zero pad last word of characters
#
trim4:  MOV  [ESI]          #store zero character} sch wc (xl)+
        DEC                 #loop back till all stored} bct wa trim4
        JNZ  trim4
#
#      common exit point
#
trim5:  XOR                 #clear garbage xl pointer} zer xl
        RET                 #return to caller} exi
                            #end procedure trimr} enp
                            #} ejc
        .eject
#
#      trxeq -- execute function type trace
#
#      trxeq is used to execute a trace when a fourth argument
#      has been supplied. trace has already been decremented.
#
#      (xr)                  pointer to trblk
#      (xl,wa)               name base,offset for variable
#      jsr  trxeq            call to execute trace
#      (wb,wc,ra)            destroyed
#
#      the following stack entries are made before passing
#      control to the trace function using the cfunc routine.
#
#                            trxeq return point word(s)
#                            saved value of trace keyword
#                            trblk pointer
#                            name base
#                            name offset
#                            saved value of r$cod
#                            saved code ptr (-r$cod)
#                            saved value of flptr
#      flptr --------------- zero (dummy fail offset)
#                            nmblk for variable name
#      xs ------------------ trace tag
#
#      r$cod and the code ptr are set to dummy values which
#      cause control to return to the trxeq procedure on success
#      or failure (trxeq ignores a failure condition).
#
trxeq:                      #entry point (recursive)} prc r 0
        .global trxeq
        MOV                 #load code block pointer} mov r_cod wc
        MOV                 #get current code pointer} scp wb
        SUB                 #make code pointer into offset} sub wc wb
        LEA                 #stack trace keyword value} mov kvtra -(xs)
        MOV  EAX,DWORD PTR kvtra
        MOV  DWORD PTR [],EAX
        LEA                 #stack trblk pointer} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack name base} mov xl -(xs)
        MOV  DWORD PTR []
        LEA                 #stack name offset} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #stack code block pointer} mov wc -(xs)
        MOV  DWORD PTR []
        LEA                 #stack code pointer offset} mov wb -(xs)
        MOV  DWORD PTR []
        LEA                 #stack old failure pointer} mov flptr -(xs)
        MOV  EAX,DWORD PTR flptr
        MOV  DWORD PTR [],EAX
        LEA                 #set dummy fail offset} zer -(xs)
        XOR  EAX,EAX
        MOV  DWORD PTR [],EAX
        MOV  DWORD PTR flptr #set new failure pointer} mov xs flptr
        XOR  EAX,EAX        #reset trace keyword to zero} zer kvtra
        MOV  DWORD PTR kvtra,EAX
        MOV                 #load new (dummy) code blk pointer} mov =trxdc wc
        MOV  DWORD PTR r_cod #set as code block pointer} mov wc r_cod
        MOV  EBP            #and new code pointer} lcp wc
                            #} ejc
        .eject
#
#      trxeq (continued)
#
#      now prepare arguments for function
#
        MOV                 #save name offset} mov wa wb
        MOV                 #load nmblk size} mov *nmsi_ wa
        CALL alloc          #allocate space for nmblk} jsr alloc
        MOV  DWORD PTR [],offset b_nml #set type word} mov =b_nml (xr)
        MOV  DWORD PTR (4*nmbas)[] #store name base} mov xl nmbas(xr)
        MOV  DWORD PTR (4*nmofs)[] #store name offset} mov wb nmofs(xr)
        MOV                 #reload pointer to trblk} mov 6(xs) xl
        LEA                 #stack nmblk pointer (1st argument)} mov xr -(xs)
        MOV  DWORD PTR []
        LEA                 #stack trace tag (2nd argument)} mov trtag(xl) -(xs)
        MOV  EAX,DWORD PTR (4*trtag)[]
        MOV  DWORD PTR [],EAX
        MOV                 #load trace vrblk pointer} mov trfnc(xl) xl
        MOV                 #load trace function pointer} mov vrfnc(xl) xl
        CMP                 #jump if not a defined function} beq xl =stndf trxq2
             trxq2
        MOV                 #set number of arguments to two} mov =num02 wa
        JMP  cfunc          #jump to call function} brn cfunc
#
#      see o$txr for details of return to this point
#
trxq1:  MOV                 #point back to our stack entries} mov flptr xs
        ADD                 #pop off garbage fail offset} ica xs
        MOV  EAX,DWORD PTR [] #restore old failure pointer} mov (xs)+ flptr
        MOV  DWORD PTR flptr,EAX
        LEA
        MOV                 #reload code offset} mov (xs)+ wb
        LEA
        MOV                 #load old code base pointer} mov (xs)+ wc
        LEA
        MOV                 #copy cdblk pointer} mov wc xr
        MOV  EAX,DWORD PTR (4*cdstm)[] #restore stmnt no} mov cdstm(xr) kvstn
        MOV  DWORD PTR kvstn,EAX
        MOV                 #reload name offset} mov (xs)+ wa
        LEA
        MOV                 #reload name base} mov (xs)+ xl
        LEA
        MOV                 #reload trblk pointer} mov (xs)+ xr
        LEA
        MOV  EAX,DWORD PTR [] #restore trace keyword value} mov (xs)+ kvtra
        MOV  DWORD PTR kvtra,EAX
        LEA
        ADD                 #recompute absolute code pointer} add wc wb
        MOV  EBP            #restore code pointer} lcp wb
        MOV  DWORD PTR r_cod #and code block pointer} mov wc r_cod
        RET                 #return to trxeq caller} exi
#
#      here if the target function is not defined
#
trxq2:  CALL ERR_0          #} erb 197 trace fourth arg is not function name or null
        .byte 197
#
                            #end procedure trxeq} enp
                            #} ejc
        .eject
#
#      xscan -- execution function argument scan
#
#      xscan scans out one token in a prototype argument in
#      array,clear,data,define,load function calls. xscan
#      calls must be preceded by a call to the initialization
#      procedure xscni. the following variables are used.
#
#      r$xsc                 pointer to scblk for function arg
#      xsofs                 offset (num chars scanned so far)
#
#      (wa)                  non-zero to skip and trim blanks
#      (wc)                  delimiter one (ch$xx)
#      (xl)                  delimiter two (ch$xx)
#      jsr  xscan            call to scan next item
#      (xr)                  pointer to scblk for token scanned
#      (wa)                  completion code (see below)
#      (wc,xl)               destroyed
#
#      the scan starts from the current position and continues
#      until one of the following three conditions occurs.
#
#      1)   delimiter one is encountered  (wa set to 1)
#
#      2)   delimiter two encountered  (wa set to 2)
#
#      3)   end of string encountered  (wa set to 0)
#
#      the result is a string containing all characters scanned
#      up to but not including any delimiter character.
#      the pointer is left pointing past the delimiter.
#
#      if only one delimiter is to be detected, delimiter one
#      and delimiter two should be set to the same value.
#
#      in the case where the end of string is encountered, the
#      string includes all the characters to the end of the
#      string. no further calls can be made to xscan until
#      xscni is called to initialize a new argument scan
                            #} ejc
        .eject
#
#      xscan (continued)
#
xscan:                      #entry point} prc e 0
        .global xscan
        MOV  DWORD PTR xscwb #preserve wb} mov wb xscwb
        LEA                 #record blank skip flag} mov wa -(xs)
        MOV  DWORD PTR []
        LEA                 #and second copy} mov wa -(xs)
        MOV  DWORD PTR []
        MOV                 #point to argument string} mov r_xsc xr
        MOV                 #load string length} mov sclen(xr) wa
        MOV                 #load current offset} mov xsofs wb
        SUB                 #get number of remaining characters} sub wb wa
#        OR                  #jump if no characters left} bze wa xscn3  (Optimized)
        JZ   xscn3
        LEA                 #point to current character} plc xr wb
#
#      loop to search for delimiter
#
xscn1:  MOVZX               #load next character} lch wb (xr)+
        INC
        CMP                 #jump if delimiter one found} beq wb wc xscn4
             xscn4
        CMP                 #jump if delimiter two found} beq wb xl xscn5
             xscn5
        CMP  DWORD PTR DWORD PTR [],0 #jump if not skipping blanks} bze (xs) xscn2
        JZ   xscn2
        INC  DWORD PTR xsofs #assume blank and delete it} icv xsofs
        CMP                 #jump if horizontal tab} beq wb =ch_ht xscn2
             xscn2
        CMP                 #jump if blank} beq wb =ch_bl xscn2
             xscn2
        DEC  DWORD PTR xsofs #undelete non-blank character} dcv xsofs
        XOR  EAX,EAX        #and discontinue blank checking} zer (xs)
        MOV  DWORD PTR [],EAX
#
#      here after performing any leading blank trimming.
#
xscn2:  DEC                 #decrement count of chars left} dcv wa
#        OR                  #loop back if more chars to go} bnz wa xscn1  (Optimized)
        JNZ  xscn1
#
#      here for runout
#
xscn3:  MOV                 #point to string block} mov r_xsc xl
        MOV                 #get string length} mov sclen(xl) wa
        MOV                 #load offset} mov xsofs wb
        SUB                 #get substring length} sub wb wa
        XOR  EAX,EAX        #clear string ptr for collector} zer r_xsc
        MOV  DWORD PTR r_xsc,EAX
        XOR  EAX,EAX        #set zero (runout) return code} zer xscrt
        MOV  DWORD PTR xscrt,EAX
        JMP  xscn7          #jump to exit} brn xscn7
                            #} ejc
        .eject
#
#      xscan (continued)
#
#      here if delimiter one found
#
xscn4:  MOV  DWORD PTR xscrt,num01 #set return code} mov =num01 xscrt
        JMP  xscn6          #jump to merge} brn xscn6
#
#      here if delimiter two found
#
xscn5:  MOV  DWORD PTR xscrt,num02 #set return code} mov =num02 xscrt
#
#      merge here after detecting a delimiter
#
xscn6:  MOV                 #reload pointer to string} mov r_xsc xl
        MOV                 #get original length of string} mov sclen(xl) wc
        SUB                 #minus chars left = chars scanned} sub wa wc
        MOV                 #move to reg for sbstr} mov wc wa
        MOV                 #set offset} mov xsofs wb
        SUB                 #compute length for sbstr} sub wb wa
        INC                 #adjust new cursor past delimiter} icv wc
        MOV  DWORD PTR xsofs #store new offset} mov wc xsofs
#
#      common exit point
#
xscn7:  XOR                 #clear garbage character ptr in xr} zer xr
        CALL sbstr          #build sub-string} jsr sbstr
        ADD                 #remove copy of blank flag} ica xs
        MOV                 #original blank skip/trim flag} mov (xs)+ wb
        LEA
        CMP  DWORD PTR DWORD PTR (4*sclen)[],0 #cannot trim the null string} bze sclen(xr) xscn8
        JZ   xscn8
        CALL trimr          #trim trailing blanks if requested} jsr trimr
#
#      final exit point
#
xscn8:  MOV                 #load return code} mov xscrt wa
        MOV                 #restore wb} mov xscwb wb
        RET                 #return to xscan caller} exi
                            #end procedure xscan} enp
                            #} ejc
        .eject
#
#      xscni -- execution function argument scan
#
#      xscni initializes the scan used for prototype arguments
#      in the clear, define, load, data, array functions. see
#      xscan for the procedure which is used after this call.
#
#      -(xs)                 argument to be scanned (on stack)
#      jsr  xscni            call to scan argument
#      ppm  loc              transfer loc if arg is not string
#      ppm  loc              transfer loc if argument is null
#      (xs)                  popped
#      (xr,r$xsc)            argument (scblk ptr)
#      (wa)                  argument length
#      (ia,ra)               destroyed
#
xscni:                      #entry point} prc n 2
        .global xscni
        POP  PRC_+72
        CALL gtstg          #fetch argument as string} jsr gtstg
        .short xsci1-DFFNC  #jump if not convertible} ppm xsci1
        MOV  DWORD PTR r_xsc #else store scblk ptr for xscan} mov xr r_xsc
        XOR  EAX,EAX        #set offset to zero} zer xsofs
        MOV  DWORD PTR xsofs,EAX
        OR                  #jump if null string} bze wa xsci2
        JZ   xsci2
        POP  EAX            #return to xscni caller} exi
        LEA  EAX,[EAX+4]
        JMP  EAX
#
#      here if argument is not a string
#
xsci1:  POP  EAX            #take not-string error exit} exi 1
        JMP  SHORT EXI__1 # (Jump shortened)
#
#      here for null string
#
xsci2:  POP  EAX            #take null-string error exit} exi 2
        JMP  SHORT EXI__2 # (Jump shortened)
                            #end procedure xscni} enp
                            #} ttl s p i t b o l -- stack overflow section
        .sbttl "s p i t b o l -- stack overflow section"
#
#      control comes here if the main stack overflows
#
                            #start of stack overflow section} sec
EXI__1: MOVSX EAX,WORD PTR [EAX+0]
        ADD  EAX,offset DFFNC
        PUSH EAX
        XOR  EAX,EAX
        RET
EXI__2: MOVSX EAX,WORD PTR [EAX+2]
        ADD  EAX,offset DFFNC
        PUSH EAX
        XOR  EAX,EAX
        RET
EXI__3: MOVSX EAX,WORD PTR [EAX+4]
        ADD  EAX,offset DFFNC
        PUSH EAX
        XOR  EAX,EAX
        RET
EXI__4: MOVSX EAX,WORD PTR [EAX+6]
        ADD  EAX,offset DFFNC
        PUSH EAX
        XOR  EAX,EAX
        RET
EXI__5: MOVSX EAX,WORD PTR [EAX+8]
        ADD  EAX,offset DFFNC
        PUSH EAX
        XOR  EAX,EAX
        RET
EXI__6: MOVSX EAX,WORD PTR [EAX+10]
        ADD  EAX,offset DFFNC
        PUSH EAX
        XOR  EAX,EAX
        RET
EXI__7: MOVSX EAX,WORD PTR [EAX+12]
        ADD  EAX,offset DFFNC
        PUSH EAX
        XOR  EAX,EAX
        RET
        .global SEC06
SEC06:
#
        ADD  DWORD PTR errft,num04 #force conclusive fatal error} add =num04 errft
        MOV                 #pop stack to avoid more fails} mov flptr xs
        CMP  DWORD PTR DWORD PTR gbcfl,0 #jump if garbage collecting} bnz gbcfl stak1
        JNZ  stak1
        CALL ERR_0          #} erb 246 stack overflow
        .byte 246
#
#      no chance of recovery in mid garbage collection
#
stak1:  MOV                 #point to message} mov =endso xr
        XOR  EAX,EAX        #memory is undumpable} zer kvdmp
        MOV  DWORD PTR kvdmp,EAX
        JMP  stopr          #give up} brn stopr
                            #} ttl s p i t b o l -- error section
        .sbttl "s p i t b o l -- error section"
#
#      this section of code is entered whenever a procedure
#      return via an err parameter or an erb opcode is obeyed.
#
#      (wa)                  is the error code
#
#      the global variable stage indicates the point at which
#      the error occured as follows.
#
#      stage=stgic           error during initial compile
#
#      stage=stgxc           error during compile at execute
#                            time (code, convert function calls)
#
#      stage=stgev           error during compilation of
#                            expression at execution time
#                            (eval, convert function call).
#
#      stage=stgxt           error at execute time. compiler
#                            not active.
#
#      stage=stgce           error during initial compile after
#                            scanning out the end line.
#
#      stage=stgxe           error during compile at execute
#                            time after scanning end line.
#
#      stage=stgee           error during expression evaluation
#
                            #start of error section} sec
ERR_0:  POP  EAX
        MOVZX EAX,BYTE PTR [EAX]
        JMP  SHORT ERR_1A
ERR_1:  POP  EAX
        MOVZX EAX,BYTE PTR [EAX]
        ADD  EAX,256
ERR_1A: JMP  ERR_
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
        INC  EAX
ERR_:   XCHG ECX,EAX
        .global SEC07
SEC07:
#
error:  CMP  DWORD PTR r_cim,offset cmlab #jump if error in scanning label} beq r_cim =cmlab cmple
             cmple
        MOV  DWORD PTR kvert #save error code} mov wa kvert
        XOR  EAX,EAX        #reset rescan switch for scane} zer scnrs
        MOV  DWORD PTR scnrs,EAX
        XOR  EAX,EAX        #reset goto switch for scane} zer scngo
        MOV  DWORD PTR scngo,EAX
        MOV  DWORD PTR polcs,num01 #reset poll count} mov =num01 polcs
        MOV  DWORD PTR polct,num01 #reset poll count} mov =num01 polct
        MOV                 #load current stage} mov stage xr
        JMP  DWORD PTR L0020[*4] #jump to appropriate error circuit} bsw xr stgno
        DSeg_
L0020:
        .long err01         #initial compile} iff stgic err01
        .long err04         #execute time compile} iff stgxc err04
        .long err04         #eval compiling expr.} iff stgev err04
        .long err05         #execute time} iff stgxt err05
        .long err01         #compile - after end} iff stgce err01
        .long err04         #xeq compile-past end} iff stgxe err04
        .long err04         #eval evaluating expr} iff stgee err04
        DSegEnd_            #end switch on error type} esw
        CSeg_
                            #} ejc
        .eject
#
#      error during initial compile
#
#      the error message is printed as part of the compiler
#      output. this printout includes the offending line (if not
#      printed already) and an error flag under the appropriate
#      column as indicated by scnse unless scnse is set to zero.
#
#      after printing the message, the generated code is
#      modified to an error call and control is returned to
#      the cmpil procedure after resetting the stack pointer.
#
#      if the error occurs after the end line, control returns
#      in a slightly different manner to ensure proper cleanup.
#
err01:  MOV                 #reset stack pointer} mov cmpxs xs
                            #restore s-r stack ptr for cmpil} ssl cmpss
        CMP  DWORD PTR DWORD PTR errsp,0 #jump if error suppress flag set} bnz errsp err03
        JNZ  err03
        MOV                 #current statement} mov cmpsn wc
        CALL filnm          #obtain file name for this statement} jsr filnm
        MOV                 #column number} mov scnse wb
        MOV                 #line number} mov rdcln wc
        MOV                 #} mov stage xr
        CALL sysea          #advise system of error} jsr sysea
        .short erra3-DFFNC  #if system does not want print} ppm erra3
        LEA                 #save any provided print message} mov xr -(xs)
        MOV  DWORD PTR []
        MOV  EAX,DWORD PTR erich #set flag for listr} mov erich erlst
        MOV  DWORD PTR erlst,EAX
        CALL listr          #list line} jsr listr
        CALL prtis          #terminate listing} jsr prtis
        XOR  EAX,EAX        #clear listr flag} zer erlst
        MOV  DWORD PTR erlst,EAX
        MOV                 #load scan element offset} mov scnse wa
        OR                  #skip if not set} bze wa err02
        JZ   err02
        MOV                 #loop counter} lct wb wa
        INC                 #increase for ch_ex} icv wa
        MOV                 #point to bad statement} mov r_cim xl
        CALL alocs          #string block for error flag} jsr alocs
        MOV                 #remember string ptr} mov xr wa
        ADD                 #ready for character storing} psc xr
        ADD                 #ready to get chars} plc xl
#
#      loop to replace all chars but tabs by blanks
#
erra1:  MOVZX               #get next char} lch wc (xl)+
        INC
        CMP                 #skip if tab} beq wc =ch_ht erra2
             erra2
        MOV                 #get a blank} mov =ch_bl wc
                            #} ejc
        .eject
#
#      merge to store blank or tab in error line
#
erra2:  MOV  [ESI],=ch_bl   #store char} sch wc (xr)+
        DEC                 #loop} bct wb erra1
        JNZ  erra1
        MOV                 #exclamation mark} mov =ch_ex xl
        MOV  EAX            #store at end of error line} sch xl (xr)
        MOV  [],AL
        MOV  DWORD PTR profs,stnpd #allow for statement number} mov =stnpd profs
        MOV                 #point to error line} mov wa xr
        CALL prtst          #print error line} jsr prtst
#
#      here after placing error flag as required
#
err02:  CALL prtis          #print blank line} jsr prtis
        MOV                 #restore any sysea message} mov (xs)+ xr
        LEA
        OR                  #did sysea provide message to print} bze xr erra0
        JZ   erra0
        CALL prtst          #print sysea message} jsr prtst
erra0:  CALL ermsg          #generate flag and error message} jsr ermsg
        ADD  DWORD PTR lstlc,num03 #bump page ctr for blank, error, blk} add =num03 lstlc
erra3:  XOR                 #in case of fatal error} zer xr
        CMP  DWORD PTR errft,num03 #pack up if several fatals} bhi errft =num03 stopr
             stopr
#
#      count error, inhibit execution if required
#
        INC  DWORD PTR cmerc #bump error count} icv cmerc
        MOV  EAX,DWORD PTR cswer #inhibit xeq if -noerrors} add cswer noxeq
        ADD  DWORD PTR noxeq,EAX
        CMP  DWORD PTR stage,stgic #special return if after end line} bne stage =stgic cmp10
             cmp10
                            #} ejc
        .eject
#
#      loop to scan to end of statement
#
err03:  MOV                 #point to start of image} mov r_cim xr
        ADD                 #point to first char} plc xr
        MOVZX               #get first char} lch xr (xr)
        CMP                 #jump if error in control card} beq xr =ch_mn cmpce
             cmpce
        XOR  EAX,EAX        #clear rescan flag} zer scnrs
        MOV  DWORD PTR scnrs,EAX
        MOV  DWORD PTR errsp,ESP #set error suppress flag} mnz errsp
        CALL scane          #scan next element} jsr scane
        CMP                 #loop back if not statement end} bne xl =t_smc err03
             err03
        XOR  EAX,EAX        #clear error suppress flag} zer errsp
        MOV  DWORD PTR errsp,EAX
#
#      generate error call in code and return to cmpil
#
        MOV  DWORD PTR cwcof,4*cdcod #reset offset in ccblk} mov *cdcod cwcof
        MOV                 #load compile error call} mov =ocer_ wa
        CALL cdwrd          #generate it} jsr cdwrd
        MOV  EAX,DWORD PTR cwcof #set success fill in offset} mov cwcof cmsoc(xs)
        MOV  DWORD PTR (4*cmsoc)[],EAX
        MOV  DWORD PTR (4*cmffc)[],ESP #set failure fill in flag} mnz cmffc(xs)
        CALL cdwrd          #generate succ. fill in word} jsr cdwrd
        JMP  cmpse          #merge to generate error as cdfal} brn cmpse
#
#      error during execute time compile or expression evaluatio
#
#      execute time compilation is initiated through gtcod or
#      gtexp which are called by compile, code or eval.
#      before causing statement failure through exfal it is
#      helpful to set keyword errtext and for generality
#      these errors may be handled by the setexit mechanism.
#
err04:  CMP  DWORD PTR errft,num03 #abort if too many fatal errors} bge errft =num03 labo1
             labo1
        CMP  DWORD PTR kvert,nm320 #treat user interrupt specially} beq kvert =nm320 err06
             err06
        XOR  EAX,EAX        #forget garbage code block} zer r_ccb
        MOV  DWORD PTR r_ccb,EAX
        MOV  DWORD PTR cwcof,4*cccod #set initial offset (mbe catspaw)} mov *cccod cwcof
                            #restore main prog s-r stack ptr} ssl iniss
        CALL ertex          #get fail message text} jsr ertex
        SUB                 #ensure stack ok on loop start} dca xs
#
#      pop stack until find flptr for most deeply nested prog.
#      defined function call or call of eval / code.
#
erra4:  ADD                 #pop stack} ica xs
        CMP                 #jump if prog defined fn call found} beq xs flprt errc4
             errc4
        CMP                 #loop if not eval or code call yet} bne xs gtcef erra4
             erra4
        MOV  DWORD PTR stage,stgxt #re-set stage for execute} mov =stgxt stage
        MOV  EAX,DWORD PTR r_gtc #recover code ptr} mov r_gtc r_cod
        MOV  DWORD PTR r_cod,EAX
        MOV  DWORD PTR flptr #restore fail pointer} mov xs flptr
        XOR  EAX,EAX        #forget possible image} zer r_cim
        MOV  DWORD PTR r_cim,EAX
        XOR  EAX,EAX        #forget possible include} zer cnind
        MOV  DWORD PTR cnind,EAX
#
#      test errlimit
#
errb4:  CMP  DWORD PTR DWORD PTR kverl,0 #jump if errlimit non-zero} bnz kverl err07
        JNZ  err07
        JMP  exfal          #fail} brn exfal
#
#      return from prog. defined function is outstanding
#
errc4:  MOV                 #restore stack from flptr} mov flptr xs
        JMP  errb4          #merge} brn errb4
                            #} ejc
        .eject
#
#      error at execute time.
#
#      the action taken on an error is as follows.
#
#      if errlimit keyword is zero, an abort is signalled,
#      see coding for system label abort at l$abo.
#
#      otherwise, errlimit is decremented and an errtype trace
#      generated if required. control returns either via a jump
#      to continue (to take the failure exit) or a specified
#      setexit trap is executed and control passes to the trap.
#      if 3 or more fatal errors occur an abort is signalled
#      regardless of errlimit and setexit - looping is all too
#      probable otherwise. fatal errors include stack overflow
#      and exceeding stlimit.
#
err05:                      #restore main prog s-r stack ptr} ssl iniss
        CMP  DWORD PTR DWORD PTR dmvch,0 #jump if in mid-dump} bnz dmvch err08
        JNZ  err08
#
#      merge here from err08 and err04 (error 320)
#
err06:  CMP  DWORD PTR DWORD PTR kverl,0 #abort if errlimit is zero} bze kverl labo1
        JZ   labo1
        CALL ertex          #get fail message text} jsr ertex
#
#      merge from err04
#
err07:  CMP  DWORD PTR errft,num03 #abort if too many fatal errors} bge errft =num03 labo1
             labo1
        DEC  DWORD PTR kverl #decrement errlimit} dcv kverl
        MOV                 #load errtype trace pointer} mov r_ert xl
        CALL ktrex          #generate errtype trace if required} jsr ktrex
        MOV                 #get current code block} mov r_cod wa
        MOV  DWORD PTR r_cnt #set cdblk ptr for continuation} mov wa r_cnt
        MOV                 #current code pointer} scp wb
        SUB                 #offset within code block} sub wa wb
        MOV  DWORD PTR stxoc #save code ptr offset for scontinue} mov wb stxoc
        MOV                 #set ptr to failure offset} mov flptr xr
        MOV  EAX,DWORD PTR [] #save failure offset for continue} mov (xr) stxof
        MOV  DWORD PTR stxof,EAX
        MOV                 #load setexit cdblk pointer} mov r_sxc xr
        OR                  #continue if no setexit trap} bze xr lcnt1
        JZ   lcnt1
        XOR  EAX,EAX        #else reset trap} zer r_sxc
        MOV  DWORD PTR r_sxc,EAX
        MOV  DWORD PTR stxvr,offset nulls #reset setexit arg to null} mov =nulls stxvr
        MOV                 #load ptr to code block routine} mov (xr) xl
        JMP                 #execute first trap statement} bri xl
#
#      interrupted partly through a dump whilst store is in a
#      mess so do a tidy up operation. see dumpr for details.
#
err08:  MOV                 #chain head for affected vrblks} mov dmvch xr
        OR                  #done if zero} bze xr err06
        JZ   err06
        MOV  EAX,DWORD PTR [] #set next link as chain head} mov (xr) dmvch
        MOV  DWORD PTR dmvch,EAX
        CALL setvr          #restore vrget field} jsr setvr
#
#      label to mark end of code
#
s_yyy:  JMP  err08          #loop through chain} brn err08
                            #} ttl s p i t b o l -- here endeth the code
        .sbttl "s p i t b o l -- here endeth the code"
#
#      end of assembly
#
        .end                #end macro-spitbol assembly} end
