; copyright 1987-2012 robert b. k. dewar and mark emmer.
;
; copyright 2012-2015 david shields
;
; this file is part of macro spitbol.
;
;     macro spitbol is free software: you can redistribute it and/or modify
;     it under the terms of the gnu general public license as published by
;     the free software foundation, either version 2 of the license, or
;     (at your option) any later version.
;
;     macro spitbol is distributed in the hope that it will be useful,
;     but without any warranty; without even the implied warranty of
;     merchantability or fitness for a particular purpose.  see the
;     gnu general public license for more details.
;
;     you should have received a copy of the gnu general public license
;     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
;
;      spitbol conditional assembly symbols for use by token.spt
;      ---------------------------------------------------------
;
;      this file of conditional symbols will override the conditional
;      definitions contained in the spitbol minimal file.   in addition,
;      lines beginning with ">" are treated as spitbol statements and
;      immediately executed.
;
;      for linux spitbol-x86
;
;      in the spitbol translator, the following conditional
;      assembly symbols are referred to. to incorporate the
;      features referred to, the minimal source should be
;      prefaced by suitable conditional assembly symbol
;      definitions.
;      in all cases it is permissible to default the definitions
;      in which case the additional features will be omitted
;      from the target code.
;
;
;                            conditional options
;                            since .undef not allowed if symbol not
;                            defined, a full comment line indicates
;                            symbol initially not defined.
;
;      .cavt                 define to include vertical tab
;      .ccmc                 define to include syscm function
;      .ceng                 define to include engine features
;      .cnci                 define to enable sysci routine
;      .cncr                 define to enable syscr routine
;      .cnex                 define to omit exit() code.
;      .cnld                 define to omit load() code.
;      .cnpf                 define to omit profile stuff
;def   .cnra                 define to omit all real arithmetic
;      .cnsr                 define to omit sort, rsort
;      .crpp                 define if return points have odd parity
;      .cs16                 define to initialize stlim to 32767
;      .csn5                 define to pad stmt nos to 5 chars
;      .csn6                 define to pad stmt nos to 6 chars
;      .ctmd                 define if systm unit is decisecond
;      .cusr                 define to have set() use real values
;                             (must also #define setreal 1 in systype.h)
;
||ttl|27,l i c e n s e -- software license for this program||||    1
;
;     copyright 1983-2012 robert b. k. dewar
;     copyright 2012-2015 david shields
;
;     this file is part of macro spitbol.
;
;     macro spitbol is free software: you can redistribute it and/or modify
;     it under the terms of the gnu general public license as published by
;     the free software foundation, either version 2 of the license, or
;     (at your option) any later version.
;
;     macro spitbol is distributed in the hope that it will be useful,
;     but without any warranty; without even the implied warranty of
;     merchantability or fitness for a particular purpose.  see the
;     gnu general public license for more details.
;
;     you should have received a copy of the gnu general public license
;     along with macro spitbol.	 if not, see <http://www.gnu.org/licenses/>.
;
||ttl|27,s p i t b o l -- notes to implementors||||   21
;
;      m a c r o   s p i t b o l     v e r s i o n   13.01
;      ---------------------------------------------------
;
;      date of release	-  january 2013
;
;      macro spitbol is maintained by
;	    dr. david shields
;	    260 garth rd apt 3h4
;	    scarsdale, ny 10583
;      e-mail - thedaveshields at gmail dot com
;
;      version 3.7 was maintained by
;	    mark emmer
;	    catspaw, inc.
;	    p.o. box 1123
;	    salida, colorado 81021
;	    u.s.a
;      e-mail - marke at snobol4 dot com
;
;      versions 2.6 through 3.4 were maintained by
;	    dr. a. p. mccann (deceased)
;	    department of computer studies
;	    university of leeds
;	    leeds ls2 9jt
;	    england.
;
;      from 1979 through early 1983 a number of fixes and
;      enhancements were made by steve duff and robert goldberg.
;
;
||ttl|27,s p i t b o l - revision history||||   53
||ejc|||||   54
;      r e v i s i o n	 h i s t o r y
;      -------------------------------
;
;      version 13.01 (january 2013, david shields)
;
;      this version has the same functionality as the previous release, but with
;      many internal code changes.
;      support for x86-64 has been added, but is not currently working.
;      the description of the minimal language formerly found here as comments
;      is now to be found in the file minimal-reference-manual.html
;
;      version 3.8 (june 2012, david shields)
;      --------------------------------------
;
;      this version is very close to v3.7, with the
;	       same functionality.
;
;	       the source is now maintained using git, so going forward
;	       the detailed revision history will be recorded in the git
;	       commit logs, not in this file.
;
||ttl|27,s p i t b o l  -- basic information||||   76
||ejc|||||   77
;
;      general structure
;      -----------------
;
;      this program is a translator for a version of the snobol4
;      programming language. language details are contained in
;      the manual macro spitbol by dewar and mccann, technical
;      report 90, university of leeds 1976.
;      the implementation is discussed in dewar and mccann,
;      macro spitbol - a snobol4 compiler, software practice and
;      experience, 7, 95-113, 1977.
;      the language is as implemented by the btl translator
;      (griswold, poage and polonsky, prentice hall, 1971)
;      with the following principal exceptions.
;
;      1)   redefinition of standard system functions and
;	    operators is not permitted.
;
;      2)   the value function is not provided.
;
;      3)   access tracing is provided in addition to the
;	    other standard trace modes.
;
;      4)   the keyword stfcount is not provided.
;
;      5)   the keyword fullscan is not provided and all pattern
;	    matching takes place in fullscan mode (i.e. with no
;	    heuristics applied).
;
;      6)   a series of expressions separated by commas may
;	    be grouped within parentheses to provide a selection
;	    capability. the semantics are that the selection
;	    assumes the value of the first expression within it
;	    which succeeds as they are evaluated from the left.
;	    if no expression succeeds the entire statement fails
;
;      7)   an explicit pattern matching operator is provided.
;	    this is the binary query (see gimpel sigplan oct 74)
;
;      8)   the assignment operator is introduced as in the
;	    gimpel reference.
;
;      9)   the exit function is provided for generating load
;	    modules - cf. gimpels sitbol.
;
;
;      the method used in this program is to translate the
;      source code into an internal pseudo-code (see following
;      section). an interpretor is then used to execute this
;      generated pseudo-code. the nature of the snobol4 language
;      is such that the latter task is much more complex than
;      the actual translation phase. accordingly, nearly all the
;      code in the program section is concerned with the actual
;      execution of the snobol4 program.
||ejc|||||  132
;
;      interpretive code format
;      ------------------------
;
;      the interpretive pseudo-code consists of a series of
;      address pointers. the exact format of the code is
;      described in connection with the cdblk format. the
;      purpose of this section is to give general insight into
;      the interpretive approach involved.
;
;      the basic form of the code is related to reverse polish.
;      in other words, the operands precede the operators which
;      are zero address operators. there are some exceptions to
;      these rules, notably the unary not operator and the
;      selection construction which clearly require advance
;      knowledge of the operator involved.
;
;      the operands are moved to the top of the main stack and
;      the operators are applied to the top stack entries. like
;      other versions of spitbol, this processor depends on
;      knowing whether operands are required by name or by value
;      and moves the appropriate object to the stack. thus no
;      name/value checks are included in the operator circuits.
;
;      the actual pointers in the code point to a block whose
;      first word is the address of the interpretor routine
;      to be executed for the code word.
;
;      in the case of operators, the pointer is to a word which
;      contains the address of the operator to be executed. in
;      the case of operands such as constants, the pointer is to
;      the operand itself. accordingly, all operands contain
;      a field which points to the routine to load the value of
;      the operand onto the stack. in the case of a variable,
;      there are three such pointers. one to load the value,
;      one to store the value and a third to jump to the label.
;
;      the handling of failure returns deserves special comment.
;      the location flptr contains the pointer to the location
;      on the main stack which contains the failure return
;      which is in the form of a byte offset in the current
;      code block (cdblk or exblk). when a failure occurs, the
;      stack is popped as indicated by the setting of flptr and
;      control is passed to the appropriate location in the
;      current code block with the stack pointer pointing to the
;      failure offset on the stack and flptr unchanged.
||ejc|||||  179
;
;      internal data representations
;      -----------------------------
;
;      representation of values
;
;      a value is represented by a pointer to a block which
;      describes the type and particulars of the data value.
;      in general, a variable is a location containing such a
;      pointer (although in the case of trace associations this
;      is modified, see description of trblk).
;
;      the following is a list of possible datatypes showing the
;      type of block used to hold the value. the details of
;      each block format are given later.
;
;      datatype		     block type
;      --------		     ----------
;
;      array		     arblk or vcblk
;
;      code		     cdblk
;
;      expression	     exblk or seblk
;
;      integer		     icblk
;
;      name		     nmblk
;
;      pattern		     p0blk or p1blk or p2blk
;
;      real		     rcblk
;
;      string		     scblk
;
;      table		     tbblk
;
;      program datatype	     pdblk
||ejc|||||  218
;
;      representation of variables
;      ---------------------------
;
;      during the course of evaluating expressions, it is
;      necessary to generate names of variables (for example
;      on the left side of a binary equals operator). these are
;      not to be confused with objects of datatype name which
;      are in fact values.
;
;      from a logical point of view, such names could be simply
;      represented by a pointer to the appropriate value cell.
;      however in the case of arrays and program defined
;      datatypes, this would violate the rule that there must be
;      no pointers into the middle of a block in dynamic store.
;      accordingly, a name is always represented by a base and
;      offset. the base points to the start of the block
;      containing the variable value and the offset is the
;      offset within this block in bytes. thus the address
;      of the actual variable is determined by adding the base
;      and offset values.
;
;      the following are the instances of variables represented
;      in this manner.
;
;      1)   natural variable base is ptr to vrblk
;			     offset is *vrval
;
;      2)   table element    base is ptr to teblk
;			     offset is *teval
;
;      3)   array element    base is ptr to arblk
;			     offset is offset to element
;
;      4)   vector element   base is ptr to vcblk
;			     offset is offset to element
;
;      5)   prog def dtp     base is ptr to pdblk
;			     offset is offset to field value
;
;      in addition there are two cases of objects which are
;      like variables but cannot be handled in this manner.
;      these are called pseudo-variables and are represented
;      with a special base pointer as follows=
;
;      expression variable   ptr to evblk (see evblk)
;
;      keyword variable	     ptr to kvblk (see kvblk)
;
;      pseudo-variables are handled as special cases by the
;      access procedure (acess) and the assignment procedure
;      (asign). see these two procedures for details.
||ejc|||||  271
;
;      organization of data area
;      -------------------------
;
;      the data area is divided into two regions.
;
;      static area
;
;      the static area builds up from the bottom and contains
;      data areas which are allocated dynamically but are never
;      deleted or moved around. the macro-program itself
;      uses the static area for the following.
;
;      1)   all variable blocks (vrblk).
;
;      2)   the hash table for variable blocks.
;
;      3)   miscellaneous buffers and work areas (see program
;	    initialization section).
;
;      in addition, the system procedures may use this area for
;      input/output buffers, external functions etc. space in
;      the static region is allocated by calling procedure alost
;
;      the following global variables define the current
;      location and size of the static area.
;
;      statb		     address of start of static area
;      state		     address+1 of last word in area.
;
;      the minimum size of static is given approximately by
;	    12 + *e_hnb + *e_sts + space for alphabet string
;	    and standard print buffer.
||ejc|||||  305
;      dynamic area
;
;      the dynamic area is built upwards in memory after the
;      static region. data in this area must all be in standard
;      block formats so that it can be processed by the garbage
;      collector (procedure gbcol). gbcol compacts blocks down
;      in this region as required by space exhaustion and can
;      also move all blocks up to allow for expansion of the
;      static region.
;      with the exception of tables and arrays, no spitbol
;      object once built in dynamic memory is ever subsequently
;      modified. observing this rule necessitates a copying
;      action during string and pattern concatenation.
;
;      garbage collection is fundamental to the allocation of
;      space for values. spitbol uses a very efficient garbage
;      collector which insists that pointers into dynamic store
;      should be identifiable without use of bit tables,
;      marker bits etc. to satisfy this requirement, dynamic
;      memory must not start at too low an address and lengths
;      of arrays, tables, strings, code and expression blocks
;      may not exceed the numerical value of the lowest dynamic
;      address.
;
;      to avoid either penalizing users with modest
;      requirements or restricting those with greater needs on
;      host systems where dynamic memory is allocated in low
;      addresses, the minimum dynamic address may be specified
;      sufficiently high to permit arbitrarily large spitbol
;      objects to be created (with the possibility in extreme
;      cases of wasting large amounts of memory below the
;      start address). this minimum value is made available
;      in variable mxlen by a system routine, sysmx.
;      alternatively sysmx may indicate that a
;      default may be used in which dynamic is placed
;      at the lowest possible address following static.
;
;      the following global work cells define the location and
;      length of the dynamic area.
;
;      dnamb		     start of dynamic area
;      dnamp		     next available location
;      dname		     last available location + 1
;
;      dnamb is always higher than state since the alost
;      procedure maintains some expansion space above state.
;      *** dnamb must never be permitted to have a value less
;      than that in mxlen ***
;
;      space in the dynamic region is allocated by the alloc
;      procedure. the dynamic region may be used by system
;      procedures provided that all the rules are obeyed.
;      some of the rules are subtle so it is preferable for
;      osint to manage its own memory needs. spitbol procs
;      obey rules to ensure that no action can cause a garbage
;      collection except at such times as contents of xl, xr
;      and the stack are +clean+ (see comment before utility
;      procedures and in gbcol for more detail). note
;      that calls of alost may cause garbage collection (shift
;      of memory to free space). spitbol procs which call
;      system routines assume that they cannot precipitate
;      collection and this must be respected.
||ejc|||||  368
;
;      register usage
;      --------------
;
;      (cp)		     code pointer register. used to
;			     hold a pointer to the current
;			     location in the interpretive pseudo
;			     code (i.e. ptr into a cdblk).
;
;      (xl,xr)		     general index registers. usually
;			     used to hold pointers to blocks in
;			     dynamic storage. an important
;			     restriction is that the value in
;			     xl must be collectable for
;			     a garbage collect call. a value
;			     is collectable if it either points
;			     outside the dynamic area, or if it
;			     points to the start of a block in
;			     the dynamic area.
;
;      (xs)		     stack pointer. used to point to
;			     the stack front. the stack may
;			     build up or down and is used
;			     to stack subroutine return points
;			     and other recursively saved data.
;
;      (xt)		     an alternative name for xl during
;			     its use in accessing stacked items.
;
;      (wa,wb,wc)	     general work registers. cannot be
;			     used for indexing, but may hold
;			     various types of data.
;
;      (ia)		     used for all signed integer
;			     arithmetic, both that used by the
;			     translator and that arising from
;			     use of snobol4 arithmetic operators
;
;      (ra)		     real accumulator. used for all
;			     floating point arithmetic.
||ejc|||||  409
;
;      spitbol conditional assembly symbols
;      ------------------------------------
;
;      in the spitbol translator, the following conditional
;      assembly symbols are referred to. to incorporate the
;      features referred to, the minimal source should be
;      prefaced by suitable conditional assembly symbol
;      definitions.
;      in all cases it is permissible to default the definitions
;      in which case the additional features will be omitted
;      from the target code.
;
;      .caex		     define to allow up arrow for expon.
;      .caht		     define to include horizontal tab
;      .casl		     define to include 26 shifted lettrs
;      .cavt		     define to include vertical tab
;      .cbyt		     define for statistics in bytes
;      .ccmc		     define to include syscm function
;      .ccmk		     define to include compare keyword
;      .cepp		     define if entrys have odd parity
;      .cera		     define to include sysea function
;      .cexp		     define if spitbol pops sysex args
;      .cgbc		     define to include sysgc function
;      .cicc		     define to ignore bad control cards
;      .cinc		     define to add -include control card
;      .ciod		     define to not use default delimiter
;			       in processing 3rd arg of input()
;			       and output()
;      .cmth		     define to include math functions
;      .cnbf		     define to omit buffer extension
;      .cnbt		     define to omit batch initialisation
;      .cnci		     define to enable sysci routine
;      .cncr		     define to enable syscr routine
;      .cnex		     define to omit exit() code.
;      .cnld		     define to omit load() code.
;      .cnlf		     define to add file type for load()
;      .cnpf		     define to omit profile stuff
;      .cnra		     define to omit all real arithmetic
;      .cnsc		     define to no numeric-string compare
;      .cnsr		     define to omit sort, rsort
;      .cpol		     define if interface polling desired
;      .crel		     define to include reloc routines
;      .crpp		     define if returns have odd parity
;      .cs16		     define to initialize stlim to 32767
;      .cs32		     define to init stlim to 2147483647
;			     omit to take default of 50000
;      .csax		     define if sysax is to be called
;      .csed		     define to use sediment in gbcol
;      .csfn		     define to track source file names
;      .csln		     define if line number in code block
;      .csn5		     define to pad stmt nos to 5 chars
;      .csn6		     define to pad stmt nos to 6 chars
;      .csn8		     define to pad stmt nos to 8 chars
;      .csou		     define if output, terminal to sysou
;      .ctet		     define to table entry trace wanted
;      .ctmd		     define if systm unit is decisecond
;      .cucf		     define to include cfp_u
;      .cuej		     define to suppress needless ejects
;      .culk		     define to include &l/ucase keywords
;      .culc		     define to include &case (lc names)
;			     if cucl defined, must support
;			     minimal op flc wreg that folds
;			     argument to lower case
;      .cust		     define to include set() code
;
;			     conditional options
;			     since .undef not allowed if symbol
;			     not defined, a full comment line
;			     indicates symbol initially not
;			     defined.
;
;      .cbyt		     define for statistics in bytes
;      .ccmc		     define to include syscm function
;      .ccmk		     define to include compare keyword
;      .cepp		     define if entrys have odd parity
;      .cera		     define to include sysea function
;      .cexp		     define if spitbol pops sysex args
;      .cicc		     define to ignore bad control cards
;      .cinc		     define to add -include control card
;			     in processing 3rd arg of input()
;			     and output()
;      .cmth		     define to include math functions
;      .cnci		     define to enable sysci routine
;      .cncr		     define to enable syscr routine
;      .cnex		     define to omit exit() code.
;      .cnlf		     define to add file type to load()
;      .cnpf		     define to omit profile stuff
;      .cnra		     define to omit all real arithmetic
;      .cnsc		     define if no numeric-string compare
;      .cnsr		     define to omit sort, rsort
;      .cpol		     define if interface polling desired
;      .crel		     define to include reloc routines
;      .crpp		     define if returns have odd parity
;      .cs16		     define to initialize stlim to 32767
;      .cs32		     define to init stlim to 2147483647
;      .csed		     define to use sediment in gbcol
;      .csfn		     define to track source file names
;      .csln		     define if line number in code block
;      .csn5		     define to pad stmt nos to 5 chars
;      .csn6		     define to pad stmt nos to 6 chars
;      .csou		     define if output, terminal to sysou
;      .ctmd		     define if systm unit is decisecond
;
;      force definition of .ccmk if .ccmc is defined
;
||ttl|27,s p i t b o l -- procedures section||||  536
;
;      this section starts with descriptions of the operating
;      system dependent procedures which are used by the spitbol
;      translator. all such procedures have five letter names
;      beginning with sys. they are listed in alphabetical
;      order.
;      all procedures have a  specification consisting of a
;      model call, preceded by a possibly empty list of register
;      contents giving parameters available to the procedure and
;      followed by a possibly empty list of register contents
;      required on return from the call or which may have had
;      their contents destroyed. only those registers explicitly
;      mentioned in the list after the call may have their
;      values changed.
;      the segment of code providing the external procedures is
;      conveniently referred to as osint (operating system
;      interface). the sysxx procedures it contains provide
;      facilities not usually available as primitives in
;      assembly languages. for particular target machines,
;      implementors may choose for some minimal opcodes which
;      do not have reasonably direct translations, to use calls
;      of additional procedures which they provide in osint.
;      e.g. mwb or trc might be translated as jsr sysmb,
;      jsr systc in some implementations.
;
;      in the descriptions, reference is made to --blk
;      formats (-- = a pair of letters). see the spitbol
;      definitions section for detailed descriptions of all
;      such block formats except fcblk for which sysfc should
;      be consulted.
;
;      section 0 contains inp,inr specifications of internal
;      procedures,routines. this gives a single pass translator
;      information making it easy to generate alternative calls
;      in the translation of jsr-s for procedures of different
;      types if this proves necessary.
;
||sec||||; start of procedures section|  574
||ejc|||||  576
;
;      sysax -- after execution
;
|sysax|exp|1,0|||; define external entry point|  580
;
;      if the conditional assembly symbol .csax is defined,
;      this routine is called immediately after execution and
;      before printing of execution statistics or dump output.
;      purpose of call is for implementor to determine and
;      if the call is not required it will be omitted if .csax
;      is undefined. in this case sysax need not be coded.
;
;      jsr  sysax	     call after execution
||ejc|||||  592
;
;      sysbs -- backspace file
;
|sysbs|exp|1,3|||; define external entry point|  597
;
;      sysbs is used to implement the snobol4 function backspace
;      if the conditional assembly symbol .cbsp is defined.
;      the meaning is system dependent.	 in general, backspace
;      repositions the file one record closer to the beginning
;      of file, such that a subsequent read or write will
;      operate on the previous record.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     backspace argument (scblk ptr)
;      jsr  sysbs	     call to backspace
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if backspace not allowed
;      ppm  loc		     return here if i/o error
;      (wa,wb)		     destroyed
;
;      the second error return is used for files for which
;      backspace is not permitted. for example, it may be expected
;      files on character devices are in this category.
||ejc|||||  617
;
;      sysbx -- before execution
;
|sysbx|exp|1,0|||; define external entry point|  622
;
;      called after initial spitbol compilation and before
;      commencing execution in case osint needs
;      to assign files or perform other necessary services.
;      osint may also choose to send a message to online
;      terminal (if any) indicating that execution is starting.
;
;      jsr  sysbx	     call before execution starts
||ejc|||||  631
;
;      sysdc -- date check
;
|sysdc|exp|1,0|||; define external entry point|  725
;
;      sysdc is called to check that the expiry date for a trial
;      version of spitbol is unexpired.
;
;      jsr  sysdc	     call to check date
;      return only if date is ok
||ejc|||||  732
;
;      sysdm  -- dump core
;
|sysdm|exp|1,0|||; define external entry point|  736
;
;      sysdm is called by a spitbol program call of dump(n) with
;      n ge 4.	its purpose is to provide a core dump.
;      n could hold an encoding of the start adrs for dump and
;      amount to be dumped e.g.	 n = 256*a + s , s = start adrs
;      in kilowords,  a = kilowords to dump
;
;      (xr)		     parameter n of call dump(n)
;      jsr  sysdm	     call to enter routine
||ejc|||||  746
;
;      sysdt -- get current date
;
|sysdt|exp|1,0|||; define external entry point|  750
;
;      sysdt is used to obtain the current date. the date is
;      returned as a character string in any format appropriate
;      to the operating system in use. it may also contain the
;      current time of day. sysdt is used to implement the
;      snobol4 function date().
;
;      (xr)		     parameter n of call date(n)
;      jsr  sysdt	     call to get date
;      (xl)		     pointer to block containing date
;
;      the format of the block is like an scblk except that
;      the first word need not be set. the result is copied
;      into spitbol dynamic memory on return.
||ejc|||||  766
;
;      sysea -- inform osint of compilation and runtime errors
;
|sysea|exp|1,1|||; define external entry point|  770
;
;      provides means for interface to take special actions on
;      errors
;
;      (wa)		     error code
;      (wb)		     line number
;      (wc)		     column number
;      (xr)		     system stage
;      (xl)		     file name (scblk)
;      jsr  sysea	     call to sysea function
;      ppm  loc		     suppress printing of error message
;      (xr)		     message to print (scblk) or 0
;
;      sysea may not return if interface chooses to retain
;      control.	 closing files via the fcb chain will be the
;      responsibility of the interface.
;
;      all registers preserved
||ejc|||||  792
;
;      sysef -- eject file
;
|sysef|exp|1,3|||; define external entry point|  796
;
;      sysef is used to write a page eject to a named file. it
;      may only be used for files where this concept makes
;      sense. note that sysef is not normally used for the
;      standard output file (see sysep).
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     eject argument (scblk ptr)
;      jsr  sysef	     call to eject file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if inappropriate file
;      ppm  loc		     return here if i/o error
||ejc|||||  809
;
;      sysej -- end of job
;
|sysej|exp|1,0|||; define external entry point|  813
;
;      sysej is called once at the end of execution to
;      terminate the run. the significance of the abend and
;      code values is system dependent. in general, the code
;      value should be made available for testing, and the
;      abend value should cause some post-mortem action such as
;      a dump. note that sysej does not return to its caller.
;      see sysxi for details of fcblk chain
;
;      (wa)		     value of abend keyword
;      (wb)		     value of code keyword
;      (xl)		     o or ptr to head of fcblk chain
;      jsr  sysej	     call to end job
;
;      the following special values are used as codes in (wb)
;      999  execution suppressed
;      998  standard output file full or unavailable in a sysxi
;	    load module. in these cases (wa) contains the number
;	    of the statement causing premature termination.
||ejc|||||  833
;
;      sysem -- get error message text
;
|sysem|exp|1,0|||; define external entry point|  837
;
;      sysem is used to obtain the text of err, erb calls in the
;      source program given the error code number. it is allowed
;      to return a null string if this facility is unavailable.
;
;      (wa)		     error code number
;      jsr  sysem	     call to get text
;      (xr)		     text of message
;
;      the returned value is a pointer to a block in scblk
;      format except that the first word need not be set. the
;      string is copied into dynamic memory on return.
;      if the null string is returned either because sysem does
;      not provide error message texts or because wa is out of
;      range, spitbol will print the string stored in errtext
;      keyword.
||ejc|||||  854
;
;      sysen -- endfile
;
|sysen|exp|1,3|||; define external entry point|  858
;
;      sysen is used to implement the snobol4 function endfile.
;      the meaning is system dependent. in general, endfile
;      implies that no further i/o operations will be performed,
;      but does not guarantee this to be the case. the file
;      should be closed after the call, a subsequent read
;      or write may reopen the file at the start or it may be
;      necessary to reopen the file via sysio.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     endfile argument (scblk ptr)
;      jsr  sysen	     call to endfile
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if endfile not allowed
;      ppm  loc		     return here if i/o error
;      (wa,wb)		     destroyed
;
;      the second error return is used for files for which
;      endfile is not permitted. for example, it may be expected
;      that the standard input and output files are in this
;      category.
||ejc|||||  880
;
;      sysep -- eject printer page
;
|sysep|exp|1,0|||; define external entry point|  884
;
;      sysep is called to perform a page eject on the standard
;      printer output file (corresponding to syspr output).
;
;      jsr  sysep	     call to eject printer output
||ejc|||||  890
;
;      sysex -- call external function
;
|sysex|exp|1,3|||; define external entry point|  894
;
;      sysex is called to pass control to an external function
;      previously loaded with a call to sysld.
;
;      (xs)		     pointer to arguments on stack
;      (xl)		     pointer to control block (efblk)
;      (wa)		     number of arguments on stack
;      jsr  sysex	     call to pass control to function
;      ppm  loc		     return here if function call fails
;      ppm  loc		     return here if insufficient memory
;      ppm  loc		     return here if bad argument type
;      (xr)		     result returned
;
;      the arguments are stored on the stack with
;      the last argument at 0(xs). on return, xs
;      is popped past the arguments.
;
;      the form of the arguments as passed is that used in the
;      spitbol translator (see definitions and data structures
;      section). the control block format is also described
;      (under efblk) in this section.
;
;      there are two ways of returning a result.
;
;      1)   return a pointer to a block in dynamic storage. this
;	    block must be in exactly correct format, including
;	    the first word. only functions written with intimate
;	    knowledge of the system will return in this way.
;
;      2)   string, integer and real results may be returned by
;	    pointing to a pseudo-block outside dynamic memory.
;	    this block is in icblk, rcblk or scblk format except
;	    that the first word will be overwritten
;	    by a type word on return and so need not
;	    be correctly set. such a result is
;	    copied into main storage before proceeding.
;	    unconverted results may similarly be returned in a
;	    pseudo-block which is in correct format including
;	    type word recognisable by garbage collector since
;	    block is copied into dynamic memory.
||ejc|||||  939
;
;      sysfc -- file control block routine
;
|sysfc|exp|1,2|||; define external entry point|  943
;
;      see also sysio
;      input and output have 3 arguments referred to as shown
;	    input(variable name,file arg1,file arg2)
;	    output(variable name,file arg1,file arg2)
;      file arg1 may be an integer or string used to identify
;      an i/o channel. it is converted to a string for checking.
;      the exact significance of file arg2
;      is not rigorously prescribed but to improve portability,
;      the scheme described in the spitbol user manual
;      should be adopted when possible. the preferred form is
;      a string _f_,r_r_,c_c_,i_i_,...,z_z_  where
;      _f_ is an optional file name which is placed first.
;	remaining items may be omitted or included in any order.
;      _r_ is maximum record length
;      _c_ is a carriage control character or character string
;      _i_ is some form of channel identification used in the
;	  absence of _f_ to associate the variable
;	  with a file allocated dynamically by jcl commands at
;	  spitbol load time.
;      ,...,z_z_ are additional fields.
;      if , (comma) cannot be used as a delimiter, .ciod
;      should be defined to introduce by conditional assembly
;      another delimiter (see
;	 iodel	equ  *
;      early in definitions section).
;      sysfc is called when a variable is input or output
;      associated to check file arg1 and file arg2 and
;      to  report whether an fcblk (file control
;      block) is necessary and if so what size it should be.
;      this makes it possible for spitbol rather than osint to
;      allocate such a block in dynamic memory if required
;      or alternatively in static memory.
;      the significance of an fcblk , if one is requested, is
;      entirely up to the system interface. the only restriction
;      is that if the fcblk should appear to lie in dynamic
;      memory, pointers to it should be proper pointers to
;      the start of a recognisable and garbage collectable
;      block (this condition will be met if sysfc requests
;      spitbol to provide an fcblk).
;      an option is provided for osint to return a pointer in
;      xl to an fcblk which it privately allocated. this ptr
;      will be made available when i/o occurs later.
;      private fcblks may have arbitrary contents and spitbol
;      stores nothing in them.
||ejc|||||  989
;      the requested size for an fcblk in dynamic memory
;      should allow a 2 word overhead for block type and
;      length fields. information subsequently stored in the
;      remaining words may be arbitrary if an xnblk (external
;      non-relocatable block) is requested. if the request is
;      for an xrblk (external relocatable block) the
;      contents of words should be collectable (i.e. any
;      apparent pointers into dynamic should be genuine block
;      pointers). these restrictions do not apply if an fcblk
;      is allocated outside dynamic or is not allocated at all.
;      if an fcblk is requested, its fields will be initialised
;      to zero before entry to sysio with the exception of
;      words 0 and 1 in which the block type and length
;      fields are placed for fcblks in dynamic memory only.
;      for the possible use of sysej and sysxi, if fcblks
;      are used, a chain is built so that they may all be
;      found - see sysxi for details.
;      if both file arg1 and file arg2 are null, calls of sysfc
;      and sysio are omitted.
;      if file arg1 is null (standard input/output file), sysfc
;      is called to check non-null file arg2 but any request
;      for an fcblk will be ignored, since spitbol handles the
;      standard files specially and cannot readily keep fcblk
;      pointers for them.
;      filearg1 is type checked by spitbol so further checking
;      may be unneccessary in many implementations.
;      file arg2 is passed so that sysfc may analyse and
;      check it. however to assist in this, spitbol also passes
;      on the stack the components of this argument with
;      file name, _f_ (otherwise null) extracted and stacked
;      first.
;      the other fields, if any, are extracted as substrings,
;      pointers to them are stacked and a count of all items
;      stacked is placed in wc. if an fcblk was earlier
;      allocated and pointed to via file arg1, sysfc is also
;      passed a pointer to this fcblk.
;
;      (xl)		     file arg1 scblk ptr (2nd arg)
;      (xr)		     filearg2 (3rd arg) or null
;      -(xs)...-(xs)	     scblks for _f_,_r_,_c_,...
;      (wc)		     no. of stacked scblks above
;      (wa)		     existing file arg1 fcblk ptr or 0
;      (wb)		     0/3 for input/output assocn
;      jsr  sysfc	     call to check need for fcblk
;      ppm  loc		     invalid file argument
;      ppm  loc		     fcblk already in use
;      (xs)		     popped (wc) times
;      (wa non zero)	     byte size of requested fcblk
;      (wa=0,xl non zero)    private fcblk ptr in xl
;      (wa=xl=0)	     no fcblk wanted, no private fcblk
;      (wc)		     0/1/2 request alloc of xrblk/xnblk
;			     /static block for use as fcblk
;      (wb)		     destroyed
||ejc||||| 1044
;
;      sysgc -- inform interface of garbage collections
;
|sysgc|exp|1,0|||; define external entry point| 1048
;
;      provides means for interface to take special actions
;      prior to and after a garbage collection.
;
;      possible usages-
;      1. provide visible screen icon of garbage collection
;	  in progress
;      2. inform virtual memory manager to ignore page access
;	  patterns during garbage collection.  such accesses
;	  typically destroy the page working set accumulated
;	  by the program.
;      3. inform virtual memory manager that contents of memory
;	  freed by garbage collection can be discarded.
;
;      (xr)		     non-zero if beginning gc
;			     =0 if completing gc
;      (wa)		     dnamb=start of dynamic area
;      (wb)		     dnamp=next available location
;      (wc)		     dname=last available location + 1
;      jsr  sysgc	     call to sysgc function
;      all registers preserved
||ejc||||| 1072
;
;      syshs -- give access to host computer features
;
|syshs|exp|1,8|||; define external entry point| 1076
;
;      provides means for implementing special features
;      on different host computers. the only defined entry is
;      that where all arguments are null in which case syshs
;      returns an scblk containing name of computer,
;      name of operating system and name of site separated by
;      colons. the scblk need not have a correct first field
;      as this is supplied on copying string to dynamic memory.
;      spitbol does no argument checking but does provide a
;      single error return for arguments checked as erroneous
;      by osint. it also provides a single execution error
;      return. if these are inadequate, use may be made of the
;      minimal error section direct as described in minimal
;      documentation, section 10.
;      several non-error returns are provided. the first
;      corresponds to the defined entry or, for implementation
;      defined entries, any string may be returned. the others
;      permit respectively,  return a null result, return with a
;      result to be stacked which is pointed at by xr, and a
;      return causing spitbol statement failure. if a returned
;      result is in dynamic memory it must obey garbage
;      collector rules. the only results copied on return
;      are strings returned via ppm loc3 return.
;
;      (wa)		     argument 1
;      (xl)		     argument 2
;      (xr)		     argument 3
;      (wb)		     argument 4
;      (wc)		     argument 5
;      jsr  syshs	     call to get host information
;      ppm  loc1	     erroneous arg
;      ppm  loc2	     execution error
;      ppm  loc3	     scblk ptr in xl or 0 if unavailable
;      ppm  loc4	     return a null result
;      ppm  loc5	     return result in xr
;      ppm  loc6	     cause statement failure
;      ppm  loc7	     return string at xl, length wa
;      ppm  loc8	     return copy of result in xr
||ejc||||| 1115
;
;      sysid -- return system identification
;
|sysid|exp|1,0|||; define external entry point| 1119
;
;      this routine should return strings to head the standard
;      printer output. the first string will be appended to
;      a heading line of the form
;	    macro spitbol version v.v
;      supplied by spitbol itself. v.v are digits giving the
;      major version number and generally at least a minor
;      version number relating to osint should be supplied to
;      give say
;	    macro spitbol version v.v(m.m)
;      the second string should identify at least the machine
;      and operating system.  preferably it should include
;      the date and time of the run.
;      optionally the strings may include site name of the
;      the implementor and/or machine on which run takes place,
;      unique site or copy number and other information as
;      appropriate without making it so long as to be a
;      nuisance to users.
;      the first words of the scblks pointed at need not be
;      correctly set.
;
;      jsr  sysid	     call for system identification
;      (xr)		     scblk ptr for addition to header
;      (xl)		     scblk ptr for second header
||ejc||||| 1144
;
;      sysif -- switch to new include file
;
|sysif|exp|1,1|||; define external entry point| 1149
;
;      sysif is used for include file processing, both to inform
;      the interface when a new include file is desired, and
;      when the end of file of an include file has been reached
;      and it is desired to return to reading from the previous
;      nested file.
;
;      it is the responsibility of sysif to remember the file
;      access path to the present input file before switching to
;      the new include file.
;
;      (xl)		     ptr to scblk or zero
;      (xr)		     ptr to vacant scblk of length cswin
;			     (xr not used if xl is zero)
;      jsr  sysif	     call to change files
;      ppm  loc		     unable to open file
;      (xr)		     scblk with full path name of file
;			     (xr not used if input xl is zero)
;
;      register xl points to an scblk containing the name of the
;      include file to which the interface should switch.  data
;      is fetched from the file upon the next call to sysrd.
;
;      sysif may have the ability to search multiple libraries
;      for the include file named in (xl).  it is therefore
;      required that the full path name of the file where the
;      file was finally located be returned in (xr).  it is this
;      name that is recorded along with the source statements,
;      and will accompany subsequent error messages.
;
;      register xl is zero to mark conclusion of use of an
;      include file.
||ejc||||| 1182
;
;      sysil -- get input record length
;
|sysil|exp|1,0|||; define external entry point| 1187
;
;      sysil is used to get the length of the next input record
;      from a file previously input associated with a sysio
;      call. the length returned is used to establish a buffer
;      for a subsequent sysin call.  sysil also indicates to the
;      caller if this is a binary or text file.
;
;      (wa)		     ptr to fcblk or zero
;      jsr  sysil	     call to get record length
;      (wa)		     length or zero if file closed
;      (wc)		     zero if binary, non-zero if text
;
;      no harm is done if the value returned is too long since
;      unused space will be reclaimed after the sysin call.
;
;      note that it is the sysil call (not the sysio call) which
;      causes the file to be opened as required for the first
;      record input from the file.
||ejc||||| 1206
;
;      sysin -- read input record
;
|sysin|exp|1,3|||; define external entry point| 1210
;
;      sysin is used to read a record from the file which was
;      referenced in a prior call to sysil (i.e. these calls
;      always occur in pairs). the buffer provided is an
;      scblk for a string of length set from the sysil call.
;      if the actual length read is less than this, the length
;      field of the scblk must be modified before returning
;      unless buffer is right padded with zeroes.
;      it is also permissible to take any of the alternative
;      returns after scblk length has been modified.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     pointer to buffer (scblk ptr)
;      jsr  sysin	     call to read record
;      ppm  loc		     endfile or no i/p file after sysxi
;      ppm  loc		     return here if i/o error
;      ppm  loc		     return here if record format error
;      (wa,wb,wc)	     destroyed
||ejc||||| 1229
;
;      sysio -- input/output file association
;
|sysio|exp|1,2|||; define external entry point| 1233
;
;      see also sysfc.
;      sysio is called in response to a snobol4 input or output
;      function call except when file arg1 and file arg2
;      are both null.
;      its call always follows immediately after a call
;      of sysfc. if sysfc requested allocation
;      of an fcblk, its address will be in wa.
;      for input files, non-zero values of _r_ should be
;      copied to wc for use in allocating input buffers. if _r_
;      is defaulted or not implemented, wc should be zeroised.
;      once a file has been opened, subsequent input(),output()
;      calls in which the second argument is identical with that
;      in a previous call, merely associate the additional
;      variable name (first argument) to the file and do not
;      result in re-opening the file.
;      in subsequent associated accesses to the file a pointer
;      to any fcblk allocated will be made available.
;
;      (xl)		     file arg1 scblk ptr (2nd arg)
;      (xr)		     file arg2 scblk ptr (3rd arg)
;      (wa)		     fcblk ptr (0 if none)
;      (wb)		     0 for input, 3 for output
;      jsr  sysio	     call to associate file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return if input/output not allowed
;      (xl)		     fcblk pointer (0 if none)
;      (wc)		     0 (for default) or max record lngth
;      (wa,wb)		     destroyed
;
;      the second error return is used if the file named exists
;      but input/output from the file is not allowed. for
;      example, the standard output file may be in this category
;      as regards input association.
||ejc||||| 1268
;
;      sysld -- load external function
;
|sysld|exp|1,3|||; define external entry point| 1272
;
;      sysld is called in response to the use of the snobol4
;      load function. the named function is loaded (whatever
;      this means), and a pointer is returned. the pointer will
;      be used on subsequent calls to the function (see sysex).
;
;      (xr)		     pointer to function name (scblk)
;      (xl)		     pointer to library name (scblk)
;      jsr  sysld	     call to load function
;      ppm  loc		     return here if func does not exist
;      ppm  loc		     return here if i/o error
;      ppm  loc		     return here if insufficient memory
;      (xr)		     pointer to loaded code
;
;      the significance of the pointer returned is up to the
;      system interface routine. the only restriction is that
;      if the pointer is within dynamic storage, it must be
;      a proper block pointer.
||ejc||||| 1291
;
;      sysmm -- get more memory
;
|sysmm|exp|1,0|||; define external entry point| 1295
;
;      sysmm is called in an attempt to allocate more dynamic
;      memory. this memory must be allocated contiguously with
;      the current dynamic data area.
;
;      the amount allocated is up to the system to decide. any
;      value is acceptable including zero if allocation is
;      impossible.
;
;      jsr  sysmm	     call to get more memory
;      (xr)		     number of additional words obtained
||ejc||||| 1307
;
;      sysmx -- supply mxlen
;
|sysmx|exp|1,0|||; define external entry point| 1311
;
;      because of the method of garbage collection, no spitbol
;      object is allowed to occupy more bytes of memory than
;      the integer giving the lowest address of dynamic
;      (garbage collectable) memory. mxlen is the name used to
;      refer to this maximum length of an object and for most
;      users of most implementations, provided dynamic memory
;      starts at an address of at least a few thousand words,
;      there is no problem.
;      if the default starting address is less than say 10000 or
;      20000, then a load time option should be provided where a
;      user can request that he be able to create larger
;      objects. this routine informs spitbol of this request if
;      any. the value returned is either an integer
;      representing the desired value of mxlen (and hence the
;      minimum dynamic store address which may result in
;      non-use of some store) or zero if a default is acceptable
;      in which mxlen is set to the lowest address allocated
;      to dynamic store before compilation starts.
;      if a non-zero value is returned, this is used for keyword
;      maxlngth. otherwise the initial low address of dynamic
;      memory is used for this keyword.
;
;      jsr  sysmx	     call to get mxlen
;      (wa)		     either mxlen or 0 for default
||ejc||||| 1337
;
;      sysou -- output record
;
|sysou|exp|1,2|||; define external entry point| 1341
;
;      sysou is used to write a record to a file previously
;      associated with a sysio call.
;
;      (wa)		     ptr to fcblk
;			     or 0 for terminal or 1 for output
;      (xr)		     record to be written (scblk)
;      jsr  sysou	     call to output record
;      ppm  loc		     file full or no file after sysxi
;      ppm  loc		     return here if i/o error
;      (wa,wb,wc)	     destroyed
;
;      note that it is the sysou call (not the sysio call) which
;      causes the file to be opened as required for the first
;      record output to the file.
||ejc||||| 1363
;
;      syspi -- print on interactive channel
;
|syspi|exp|1,1|||; define external entry point| 1367
;
;      if spitbol is run from an online terminal, osint can
;      request that messages such as copies of compilation
;      errors be sent to the terminal (see syspp). if relevant
;      reply was made by syspp then syspi is called to send such
;      messages to the interactive channel.
;      syspi is also used for sending output to the terminal
;      through the special variable name, terminal.
;
;      (xr)		     ptr to line buffer (scblk)
;      (wa)		     line length
;      jsr  syspi	     call to print line
;      ppm  loc		     failure return
;      (wa,wb)		     destroyed
||ejc||||| 1383
;
;      syspl -- provide interactive control of spitbol
;
|syspl|exp|1,3|||; define external entry point| 1387
;
;      provides means for interface to take special actions,
;      such as interrupting execution, breakpointing, stepping,
;      and expression evaluation.  these last three options are
;      not presently implemented by the code calling syspl.
;
;
;      (wa)		     opcode as follows-
;			     =0 poll to allow osint to interrupt
;			     =1 breakpoint hit
;			     =2 completion of statement stepping
;			     =3 expression evaluation result
;      (wb)		     statement number
;      r_fcb		     o or ptr to head of fcblk chain
;      jsr  syspl	     call to syspl function
;      ppm  loc		     user interruption
;      ppm  loc		     step one statement
;      ppm  loc		     evaluate expression
;      ---		     resume execution
;			     (wa) = new polling interval
;
||ejc||||| 1410
;
;      syspp -- obtain print parameters
;
|syspp|exp|1,0|||; define external entry point| 1414
;
;      syspp is called once during compilation to obtain
;      parameters required for correct printed output format
;      and to select other options. it may also be called again
;      after sysxi when a load module is resumed. in this
;      case the value returned in wa may be less than or equal
;      to that returned in initial call but may not be
;      greater.
;      the information returned is -
;      1.   line length in chars for standard print file
;      2.   no of lines/page. 0 is preferable for a non-paged
;	    device (e.g. online terminal) in which case listing
;	    page throws are suppressed and page headers
;	    resulting from -title,-stitl lines are kept short.
;      3.   an initial -nolist option to suppress listing unless
;	    the program contains an explicit -list.
;      4.   options to suppress listing of compilation and/or
;	    execution stats (useful for established programs) -
;	    combined with 3. gives possibility of listing
;	    file never being opened.
;      5.   option to have copies of errors sent to an
;	    interactive channel in addition to standard printer.
;      6.   option to keep page headers short (e.g. if listing
;	    to an online terminal).
;      7.   an option to choose extended or compact listing
;	    format. in the former a page eject and in the latter
;	    a few line feeds precede the printing of each
;	    of-- listing, compilation statistics, execution
;	    output and execution statistics.
;      8.   an option to suppress execution as though a
;	    -noexecute card were supplied.
;      9.   an option to request that name /terminal/  be pre-
;	    associated to an online terminal via syspi and sysri
;      10.  an intermediate (standard) listing option requiring
;	    that page ejects occur in source listings. redundant
;	    if extended option chosen but partially extends
;	    compact option.
;      11.  option to suppress sysid identification.
;
;      jsr  syspp	     call to get print parameters
;      (wa)		     print line length in chars
;      (wb)		     number of lines/page
;      (wc)		     bits value ...mlkjihgfedcba where
;			     a = 1 to send error copy to int.ch.
;			     b = 1 means std printer is int. ch.
;			     c = 1 for -nolist option
;			     d = 1 to suppress compiln. stats
;
;			     e = 1 to suppress execn. stats
;			     f = 1/0 for extnded/compact listing
;			     g = 1 for -noexecute
;			     h = 1 pre-associate /terminal/
;
;			     i = 1 for standard listing option.
;			     j = 1 suppresses listing header
;			     k = 1 for -print
;			     l = 1 for -noerrors
;
;			     m = 1 for -case 1
||ejc||||| 1476
;
;      syspr -- print line on standard output file
;
|syspr|exp|1,1|||; define external entry point| 1480
;
;      syspr is used to print a single line on the standard
;      output file.
;
;      (xr)		     pointer to line buffer (scblk)
;      (wa)		     line length
;      jsr  syspr	     call to print line
;      ppm  loc		     too much o/p or no file after sysxi
;      (wa,wb)		     destroyed
;
;      the buffer pointed to is the length obtained from the
;      syspp call and is filled out with trailing blanks. the
;      value in wa is the actual line length which may be less
;      than the maximum line length possible. there is no space
;      control associated with the line, all lines are printed
;      single spaced. note that null lines (wa=0) are possible
;      in which case a blank line is to be printed.
;
;      the error exit is used for systems which limit the amount
;      of printed output. if possible, printing should be
;      permitted after this condition has been signalled once to
;      allow for dump and other diagnostic information.
;      assuming this to be possible, spitbol may make more syspr
;      calls. if the error return occurs another time, execution
;      is terminated by a call of sysej with ending code 998.
||ejc||||| 1506
;
;      sysrd -- read record from standard input file
;
|sysrd|exp|1,1|||; define external entry point| 1510
;
;      sysrd is used to read a record from the standard input
;      file. the buffer provided is an scblk for a string the
;      length of which in characters is given in wc, this
;      corresponding to the maximum length of string which
;      spitbol is prepared to receive. at compile time it
;      corresponds to xxx in the most recent -inxxx card
;      (default 72) and at execution time to the most recent
;      ,r_r_ (record length) in the third arg of an input()
;      statement for the standard input file (default 80).
;      if fewer than (wc) characters are read, the length
;      field of the scblk must be adjusted before returning
;      unless the buffer is right padded with zeroes.
;      it is also permissible to take the alternative return
;      after such an adjustment has been made.
;      spitbol may continue to make calls after an endfile
;      return so this routine should be prepared to make
;      repeated endfile returns.
;
;      (xr)		     pointer to buffer (scblk ptr)
;      (wc)		     length of buffer in characters
;      jsr  sysrd	     call to read line
;      ppm  loc		     endfile or no i/p file after sysxi
;			     or input file name change.	 if
;			     the former, scblk length is zero.
;			     if input file name change, length
;			     is non-zero. caller should re-issue
;			     sysrd to obtain input record.
;      (wa,wb,wc)	     destroyed
||ejc||||| 1542
;
;      sysri -- read record from interactive channel
;
|sysri|exp|1,1|||; define external entry point| 1546
;
;      reads a record from online terminal for spitbol variable,
;      terminal. if online terminal is unavailable then code the
;      endfile return only.
;      the buffer provided is of length 258 characters. sysri
;      should replace the count in the second word of the scblk
;      by the actual character count unless buffer is right
;      padded with zeroes.
;      it is also permissible to take the alternative
;      return after adjusting the count.
;      the end of file return may be used if this makes
;      sense on the target machine (e.g. if there is an
;      eof character.)
;
;      (xr)		     ptr to 258 char buffer (scblk ptr)
;      jsr  sysri	     call to read line from terminal
;      ppm  loc		     end of file return
;      (wa,wb,wc)	     may be destroyed
||ejc||||| 1565
;
;      sysrw -- rewind file
;
|sysrw|exp|1,3|||; define external entry point| 1569
;
;      sysrw is used to rewind a file i.e. reposition the file
;      at the start before the first record. the file should be
;      closed and the next read or write call will open the
;      file at the start.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     rewind arg (scblk ptr)
;      jsr  sysrw	     call to rewind file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if rewind not allowed
;      ppm  loc		     return here if i/o error
||ejc||||| 1582
;
;      sysst -- set file pointer
;
|sysst|exp|1,0|||; define external entry point| 1587
;
;      sysst is called to change the position of a file
;      pointer. this is accomplished in a system dependent
;      manner, and thus the 2nd and 3rd arguments are passed
;      unconverted.
;
;      (wa)		     fcblk pointer
;      (wb)		     2nd argument
;      (wc)		     3rd argument
;      jsr  sysst	     call to set file pointer
;      ppm  loc		     return here if invalid 2nd arg
;      ppm  loc		     return here if invalid 3rd arg
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if set not allowed
;      ppm  loc		     return here if i/o error
;
||ejc||||| 1604
;
;      systm -- get execution time so far
;
|systm|exp|1,0|||; define external entry point| 1609
;
;      systm is used to obtain the amount of execution time
;      used so far since spitbol was given control. the units
;      are described as milliseconds in the spitbol output, but
;      the exact meaning is system dependent. where appropriate,
;      this value should relate to processor rather than clock
;      timing values.
;      if the symbol .ctmd is defined, the units are described
;      as deciseconds (0.1 second).
;
;      jsr  systm	     call to get timer value
;      (ia)		     time so far in milliseconds
;			     (deciseconds if .ctmd defined)
||ejc||||| 1623
;
;      systt -- trace toggle
;
|systt|exp|1,0|||; define external entry point| 1627
;
;      called by spitbol function trace() with no args to
;      toggle the system trace switch.	this permits tracing of
;      labels in spitbol code to be turned on or off.
;
;      jsr  systt	     call to toggle trace switch
||ejc||||| 1634
;
;      sysul -- unload external function
;
|sysul|exp|1,0|||; define external entry point| 1638
;
;      sysul is used to unload a function previously
;      loaded with a call to sysld.
;
;      (xr)		     ptr to control block (efblk)
;      jsr  sysul	     call to unload function
;
;      the function cannot be called following a sysul call
;      until another sysld call is made for the same function.
;
;      the efblk contains the function code pointer and also a
;      pointer to the vrblk containing the function name (see
;      definitions and data structures section).
||ejc||||| 1654
;
;      sysxi -- exit to produce load module
;
|sysxi|exp|1,2|||; define external entry point| 1658
;
;      when sysxi is called, xl contains either a string pointer
;      or zero. in the former case, the string gives the
;      character name of a program. the intention is that
;      spitbol execution should be terminated forthwith and
;      the named program loaded and executed. this type of chain
;      execution is very system dependent and implementors may
;      choose to omit it or find it impossible to provide.
;      if (xl) is zero,ia contains one of the following integers
;
;      -1, -2, -3, -4
;	    create if possible a load module containing only the
;	    impure area of memory which needs to be loaded with
;	    a compatible pure segment for subsequent executions.
;	    version numbers to check compatibility should be
;	    kept in both segments and checked on loading.
;	    to assist with this check, (xr) on entry is a
;	    pointer to an scblk containing the spitbol major
;	    version number v.v (see sysid).  the file thus
;	    created is called a save file.
;
;      0    if possible, return control to job control
;	    command level. the effect if available will be
;	    system dependent.
;
;      +1, +2, +3, +4
;	    create if possible a load module from all of
;	    memory. it should be possible to load and execute
;	    this module directly.
;
;      in the case of saved load modules, the status of open
;      files is not preserved and implementors may choose to
;      offer means of attaching files before execution of load
;      modules starts or leave it to the user to include
;      suitable input(), output() calls in his program.
;      sysxi should make a note that no i/o channels,
;      including standard files, have files attached so that
;      calls of sysin, sysou, syspr, sysrd should fail unless
;      new associations are made for the load module.
;      at least in the case of the standard output file, it is
;      recommended that either the user be required to attach
;      a file or that a default file is attached, since the
;      problem of error messages generated by the load module
;      is otherwise severe. as a last resort, if spitbol
;      attempts to write to the standard output file and gets a
;      reply indicating that such ouput is unacceptable it stops
;      by using an entry to sysej with ending code 998.
;      as described below, passing of some arguments makes it
;      clear that load module will use a standard output file.
;
;      if use is made of fcblks for i/o association, spitbol
;      builds a chain so that those in use may be found in sysxi
;      and sysej. the nodes are 4 words long. third word
;      contains link to next node or 0, fourth word contains
;      fcblk pointer.
||ejc||||| 1714
;
;      sysxi (continued)
;
;      (xl)		     zero or scblk ptr to first argument
;      (xr)		     ptr to v.v scblk
;      (ia)		     signed integer argument
;      (wa)		     scblk ptr to second argument
;      (wb)		     0 or ptr to head of fcblk chain
;      jsr  sysxi	     call to exit
;      ppm  loc		     requested action not possible
;      ppm  loc		     action caused irrecoverable error
;      (wb,wc,ia,xr,xl,cp)   should be preserved over call
;      (wa)		     0 in all cases except sucessful
;			     performance of exit(4) or exit(-4),
;			     in which case 1 should be returned.
;
;      loading and running the load module or returning from
;      jcl command level causes execution to resume at the point
;      after the error returns which follow the call of sysxi.
;      the value passed as exit argument is used to indicate
;      options required on resumption of load module.
;      +1 or -1 require that on resumption, sysid and syspp be
;      called and a heading printed on the standard output file.
;      +2 or -2 indicate that syspp will be called but not sysid
;      and no heading will be put on standard output file.
;      above options have the obvious implication that a
;      standard o/p file must be provided for the load module.
;      +3, +4, -3 or -4 indicate calls of neither sysid nor
;      syspp and no heading will be placed on standard output
;      file.
;      +4 or -4 indicate that execution is to continue after
;      creation of the save file or load module, although all
;      files will be closed by the sysxi action.  this permits
;      the user to checkpoint long-running programs while
;      continuing execution.
;
;      no return from sysxi is possible if another program
;      is loaded and entered.
||ejc||||| 1754
;
;      introduce the internal procedures.
;
|acess|inp|25,r|1,1||;| 1758
|acomp|inp|25,n|1,5||;| 1759
|alloc|inp|25,e|1,0||;| 1760
|alocs|inp|25,e|1,0||;| 1765
|alost|inp|25,e|1,0||;| 1766
|arith|inp|25,n|1,3||;| 1774
|asign|inp|25,r|1,1||;| 1776
|asinp|inp|25,r|1,1||;| 1777
|blkln|inp|25,e|1,0||;| 1778
|cdgcg|inp|25,e|1,0||;| 1779
|cdgex|inp|25,r|1,0||;| 1780
|cdgnm|inp|25,r|1,0||;| 1781
|cdgvl|inp|25,r|1,0||;| 1782
|cdwrd|inp|25,e|1,0||;| 1783
|cmgen|inp|25,r|1,0||;| 1784
|cmpil|inp|25,e|1,0||;| 1785
|cncrd|inp|25,e|1,0||;| 1786
|copyb|inp|25,n|1,1||;| 1787
|dffnc|inp|25,e|1,0||;| 1788
|dtach|inp|25,e|1,0||;| 1789
|dtype|inp|25,e|1,0||;| 1790
|dumpr|inp|25,e|1,0||;| 1791
|ermsg|inp|25,e|1,0||;| 1796
|ertex|inp|25,e|1,0||;| 1797
|evali|inp|25,r|1,4||;| 1798
|evalp|inp|25,r|1,1||;| 1799
|evals|inp|25,r|1,3||;| 1800
|evalx|inp|25,r|1,1||;| 1801
|exbld|inp|25,e|1,0||;| 1802
|expan|inp|25,e|1,0||;| 1803
|expap|inp|25,e|1,1||;| 1804
|expdm|inp|25,n|1,0||;| 1805
|expop|inp|25,n|1,0||;| 1806
|filnm|inp|25,e|1,0||;| 1808
|flstg|inp|25,e|1,0||;| 1811
|gbcol|inp|25,e|1,0||;| 1813
|gbcpf|inp|25,e|1,0||;| 1814
|gtarr|inp|25,e|1,2||;| 1815
||ejc||||| 1816
|gtcod|inp|25,e|1,1||;| 1817
|gtexp|inp|25,e|1,1||;| 1818
|gtint|inp|25,e|1,1||;| 1819
|gtnum|inp|25,e|1,1||;| 1820
|gtnvr|inp|25,e|1,1||;| 1821
|gtpat|inp|25,e|1,1||;| 1822
|gtrea|inp|25,e|1,1||;| 1825
|gtsmi|inp|25,n|1,2||;| 1827
|gtstg|inp|25,n|1,1||;| 1832
|gtvar|inp|25,e|1,1||;| 1833
|hashs|inp|25,e|1,0||;| 1834
|icbld|inp|25,e|1,0||;| 1835
|ident|inp|25,e|1,1||;| 1836
|inout|inp|25,e|1,0||;| 1837
|insta|inp|25,e|1,0||;| 1842
|iofcb|inp|25,n|1,3||;| 1843
|ioppf|inp|25,n|1,0||;| 1844
|ioput|inp|25,n|1,7||;| 1845
|ktrex|inp|25,r|1,0||;| 1846
|kwnam|inp|25,n|1,0||;| 1847
|lcomp|inp|25,n|1,5||;| 1848
|listr|inp|25,e|1,0||;| 1849
|listt|inp|25,e|1,0||;| 1850
|newfn|inp|25,e|1,0||;| 1852
|nexts|inp|25,e|1,0||;| 1854
|patin|inp|25,n|1,2||;| 1855
|patst|inp|25,n|1,1||;| 1856
|pbild|inp|25,e|1,0||;| 1857
|pconc|inp|25,e|1,0||;| 1858
|pcopy|inp|25,n|1,0||;| 1859
|prflr|inp|25,e|1,0||;| 1862
|prflu|inp|25,e|1,0||;| 1863
|prpar|inp|25,e|1,0||;| 1865
|prtch|inp|25,e|1,0||;| 1866
|prtic|inp|25,e|1,0||;| 1867
|prtis|inp|25,e|1,0||;| 1868
|prtin|inp|25,e|1,0||;| 1869
|prtmi|inp|25,e|1,0||;| 1870
|prtmm|inp|25,e|1,0||;| 1871
|prtmx|inp|25,e|1,0||;| 1872
|prtnl|inp|25,r|1,0||;| 1873
|prtnm|inp|25,r|1,0||;| 1874
|prtnv|inp|25,e|1,0||;| 1875
|prtpg|inp|25,e|1,0||;| 1876
|prtps|inp|25,e|1,0||;| 1877
|prtsn|inp|25,e|1,0||;| 1878
|prtst|inp|25,r|1,0||;| 1879
||ejc||||| 1880
|prttr|inp|25,e|1,0||;| 1881
|prtvl|inp|25,r|1,0||;| 1882
|prtvn|inp|25,e|1,0||;| 1883
|rcbld|inp|25,e|1,0||;| 1886
|readr|inp|25,e|1,0||;| 1888
|relaj|inp|25,e|1,0||;| 1890
|relcr|inp|25,e|1,0||;| 1891
|reldn|inp|25,e|1,0||;| 1892
|reloc|inp|25,e|1,0||;| 1893
|relst|inp|25,e|1,0||;| 1894
|relws|inp|25,e|1,0||;| 1895
|rstrt|inp|25,e|1,0||;| 1897
|sbstr|inp|25,e|1,0||;| 1901
|scane|inp|25,e|1,0||;| 1902
|scngf|inp|25,e|1,0||;| 1903
|setvr|inp|25,e|1,0||;| 1904
|sorta|inp|25,n|1,1||;| 1907
|sortc|inp|25,e|1,1||;| 1908
|sortf|inp|25,e|1,0||;| 1909
|sorth|inp|25,n|1,0||;| 1910
|start|inp|25,e|1,0||;| 1912
|stgcc|inp|25,e|1,0||;| 1913
|tfind|inp|25,e|1,1||;| 1914
|tmake|inp|25,e|1,0||;| 1915
|trace|inp|25,n|1,2||;| 1916
|trbld|inp|25,e|1,0||;| 1917
|trimr|inp|25,e|1,0||;| 1918
|trxeq|inp|25,r|1,0||;| 1919
|vmake|inp|25,e|1,1||;| 1920
|xscan|inp|25,e|1,0||;| 1921
|xscni|inp|25,n|1,2||;| 1922
;
;      introduce the internal routines
;
|arref|inr||||| 1926
|cfunc|inr||||| 1927
|exfal|inr||||| 1928
|exint|inr||||| 1929
|exits|inr||||| 1930
|exixr|inr||||| 1931
|exnam|inr||||| 1932
|exnul|inr||||| 1933
|exrea|inr||||| 1936
|exsid|inr||||| 1938
|exvnm|inr||||| 1939
|failp|inr||||| 1940
|flpop|inr||||| 1941
|indir|inr||||| 1942
|match|inr||||| 1943
|retrn|inr||||| 1944
|stcov|inr||||| 1945
|stmgo|inr||||| 1946
|stopr|inr||||| 1947
|succp|inr||||| 1948
|sysab|inr||||| 1949
|systu|inr||||| 1950
||ttl|27,s p i t b o l -- definitions and data structures|||| 1951
;      this section contains all symbol definitions and also
;      pictures of all data structures used in the system.
;
||sec||||; start of definitions section| 1955
;
;      definitions of machine parameters
;
;      the minimal translator should supply appropriate values
;      for the particular target machine for all the
;      equ  *
;      definitions given at the start of this section.
;      note that even if conditional assembly is used to omit
;      some feature (e.g. real arithmetic) a full set of cfp_-
;      values must be supplied. use dummy values if genuine
;      ones are not needed.
;
|cfp_a|equ|24,256|||; number of characters in alphabet| 1968
;
|cfp_b|equ|24,8|||; bytes/word addressing factor| 1970
;
|cfp_c|equ|24,8|||; number of characters per word| 1972
;
|cfp_f|equ|24,16|||; offset in bytes to chars in| 1974
;			     scblk. see scblk format.
;
|cfp_i|equ|24,1|||; number of words in integer constant| 1977
;
|cfp_m|equ|24,9223372036854775807|||; max positive integer in one word| 1979
;
|cfp_n|equ|24,64|||; number of bits in one word| 1981
;
;      the following definitions require the supply of either
;      a single parameter if real arithmetic is omitted or
;      three parameters if real arithmetic is included.
;
;
|cfp_r|equ|24,1|||; number of words in real constant| 1991
;
|cfp_s|equ|24,9|||; number of sig digs for real output| 1993
;
|cfp_x|equ|24,3|||; max digits in real exponent| 1995
;
|mxdgs|equ|24,cfp_s+cfp_x|||; max digits in real number| 2006
;
;
;      max space for real (for +0.e+) needs five more places
;
|nstmx|equ|24,mxdgs+5|||; max space for real| 2011
;
;      the following definition for cfp_u supplies a realistic
;      upper bound on the size of the alphabet.	 cfp_u is used
;      to save space in the scane bsw-iff-esw table and to ease
;      translation storage requirements.
;
|cfp_u|equ|24,128|||; realistic upper bound on alphabet| 2021
||ejc||||| 2023
;
;      environment parameters
;
;      the spitbol program is essentially independent of
;      the definitions of these parameters. however, the
;      efficiency of the system may be affected. consequently,
;      these parameters may require tuning for a given version
;      the values given in comments have been successfully used.
;
;      e_srs is the number of words to reserve at the end of
;      storage for end of run processing. it should be
;      set as small as possible without causing memory overflow
;      in critical situations (e.g. memory overflow termination)
;      and should thus reserve sufficient space at least for
;      an scblk containing say 30 characters.
;
|e_srs|equ|24,100|||; 30 words| 2040
;
;      e_sts is the number of words grabbed in a chunk when
;      storage is allocated in the static region. the minimum
;      permitted value is 256/cfp_b. larger values will lead
;      to increased efficiency at the cost of wasting memory.
;
|e_sts|equ|24,1000|||; 500 words| 2047
;
;      e_cbs is the size of code block allocated initially and
;      the expansion increment if overflow occurs. if this value
;      is too small or too large, excessive garbage collections
;      will occur during compilation and memory may be lost
;      in the case of a too large value.
;
|e_cbs|equ|24,500|||; 500 words| 2055
;
;      e_hnb is the number of bucket headers in the variable
;      hash table. it should always be odd. larger values will
;      speed up compilation and indirect references at the
;      expense of additional storage for the hash table itself.
;
|e_hnb|equ|24,257|||; 127 bucket headers| 2062
;
;      e_hnw is the maximum number of words of a string
;      name which participate in the string hash algorithm.
;      larger values give a better hash at the expense of taking
;      longer to compute the hash. there is some optimal value.
;
|e_hnw|equ|24,3|||; 6 words| 2069
;
;      e_fsp.  if the amount of free space left after a garbage
;      collection is small compared to the total amount of space
;      in use garbage collector thrashing is likely to occur as
;      this space is used up.  e_fsp is a measure of the
;      minimum percentage of dynamic memory left as free space
;      before the system routine sysmm is called to try to
;      obtain more memory.
;
|e_fsp|equ|24,15|||; 15 percent| 2079
;
;      e_sed.  if the amount of free space left in the sediment
;      after a garbage collection is a significant fraction of
;      the new sediment size, the sediment is marked for
;      collection on the next call to the garbage collector.
;
|e_sed|equ|24,25|||; 25 percent| 2087
||ejc||||| 2089
;
;      definitions of codes for letters
;
|ch_la|equ|24,97|||; letter a| 2093
|ch_lb|equ|24,98|||; letter b| 2094
|ch_lc|equ|24,99|||; letter c| 2095
|ch_ld|equ|24,100|||; letter d| 2096
|ch_le|equ|24,101|||; letter e| 2097
|ch_lf|equ|24,102|||; letter f| 2098
|ch_lg|equ|24,103|||; letter g| 2099
|ch_lh|equ|24,104|||; letter h| 2100
|ch_li|equ|24,105|||; letter i| 2101
|ch_lj|equ|24,106|||; letter j| 2102
|ch_lk|equ|24,107|||; letter k| 2103
|ch_ll|equ|24,108|||; letter l| 2104
|ch_lm|equ|24,109|||; letter m| 2105
|ch_ln|equ|24,110|||; letter n| 2106
|ch_lo|equ|24,111|||; letter o| 2107
|ch_lp|equ|24,112|||; letter p| 2108
|ch_lq|equ|24,113|||; letter q| 2109
|ch_lr|equ|24,114|||; letter r| 2110
|ch_ls|equ|24,115|||; letter s| 2111
|ch_lt|equ|24,116|||; letter t| 2112
|ch_lu|equ|24,117|||; letter u| 2113
|ch_lv|equ|24,118|||; letter v| 2114
|ch_lw|equ|24,119|||; letter w| 2115
|ch_lx|equ|24,120|||; letter x| 2116
|ch_ly|equ|24,121|||; letter y| 2117
|ch_l_|equ|24,122|||; letter z| 2118
;
;      definitions of codes for digits
;
|ch_d0|equ|24,48|||; digit 0| 2122
|ch_d1|equ|24,49|||; digit 1| 2123
|ch_d2|equ|24,50|||; digit 2| 2124
|ch_d3|equ|24,51|||; digit 3| 2125
|ch_d4|equ|24,52|||; digit 4| 2126
|ch_d5|equ|24,53|||; digit 5| 2127
|ch_d6|equ|24,54|||; digit 6| 2128
|ch_d7|equ|24,55|||; digit 7| 2129
|ch_d8|equ|24,56|||; digit 8| 2130
|ch_d9|equ|24,57|||; digit 9| 2131
||ejc||||| 2132
;
;      definitions of codes for special characters
;
;      the names of these characters are related to their
;      original representation in the ebcdic set corresponding
;      to the description in standard snobol4 manuals and texts.
;
|ch_am|equ|24,38|||; keyword operator (ampersand)| 2140
|ch_as|equ|24,42|||; multiplication symbol (asterisk)| 2141
|ch_at|equ|24,64|||; cursor position operator (at)| 2142
|ch_bb|equ|24,60|||; left array bracket (less than)| 2143
|ch_bl|equ|24,32|||; blank| 2144
|ch_br|equ|24,124|||; alternation operator (vertical bar)| 2145
|ch_cl|equ|24,58|||; goto symbol (colon)| 2146
|ch_cm|equ|24,44|||; comma| 2147
|ch_dl|equ|24,36|||; indirection operator (dollar)| 2148
|ch_dt|equ|24,46|||; name operator (dot)| 2149
|ch_dq|equ|24,34|||; double quote| 2150
|ch_eq|equ|24,61|||; equal sign| 2151
|ch_ex|equ|24,33|||; exponentiation operator (exclm)| 2152
|ch_mn|equ|24,45|||; minus sign / hyphen| 2153
|ch_nm|equ|24,35|||; number sign| 2154
|ch_nt|equ|24,126|||; negation operator (not)| 2155
|ch_pc|equ|24,37|||; percent| 2156
|ch_pl|equ|24,43|||; plus sign| 2157
|ch_pp|equ|24,40|||; left parenthesis| 2158
|ch_rb|equ|24,62|||; right array bracket (grtr than)| 2159
|ch_rp|equ|24,41|||; right parenthesis| 2160
|ch_qu|equ|24,63|||; interrogation operator (question)| 2161
|ch_sl|equ|24,47|||; slash| 2162
|ch_sm|equ|24,59|||; semicolon| 2163
|ch_sq|equ|24,39|||; single quote| 2164
|ch_u_|equ|24,95|||; special identifier char (underline)| 2165
|ch_ob|equ|24,91|||; opening bracket| 2166
|ch_cb|equ|24,93|||; closing bracket| 2167
||ejc||||| 2168
;
;      remaining chars are optional additions to the standards.
;
;      tab characters - syntactically equivalent to blank
;
|ch_ht|equ|24,9|||; horizontal tab| 2175
;
;      up arrow same as exclamation mark for exponentiation
;
|ch_ey|equ|24,94|||; up arrow| 2184
;
;      lower case or shifted case alphabetic chars
;
|ch_ua|equ|24,65|||; shifted a| 2190
|ch_ub|equ|24,66|||; shifted b| 2191
|ch_uc|equ|24,67|||; shifted c| 2192
|ch_ud|equ|24,68|||; shifted d| 2193
|ch_ue|equ|24,69|||; shifted e| 2194
|ch_uf|equ|24,70|||; shifted f| 2195
|ch_ug|equ|24,71|||; shifted g| 2196
|ch_uh|equ|24,72|||; shifted h| 2197
|ch_ui|equ|24,73|||; shifted i| 2198
|ch_uj|equ|24,74|||; shifted j| 2199
|ch_uk|equ|24,75|||; shifted k| 2200
|ch_ul|equ|24,76|||; shifted l| 2201
|ch_um|equ|24,77|||; shifted m| 2202
|ch_un|equ|24,78|||; shifted n| 2203
|ch_uo|equ|24,79|||; shifted o| 2204
|ch_up|equ|24,80|||; shifted p| 2205
|ch_uq|equ|24,81|||; shifted q| 2206
|ch_ur|equ|24,82|||; shifted r| 2207
|ch_us|equ|24,83|||; shifted s| 2208
|ch_ut|equ|24,84|||; shifted t| 2209
|ch_uu|equ|24,85|||; shifted u| 2210
|ch_uv|equ|24,86|||; shifted v| 2211
|ch_uw|equ|24,87|||; shifted w| 2212
|ch_ux|equ|24,88|||; shifted x| 2213
|ch_uy|equ|24,89|||; shifted y| 2214
|ch_uz|equ|24,90|||; shifted z| 2215
;      if a delimiter other than ch_cm must be used in
;      the third argument of input(),output() then .ciod should
;      be defined and a parameter supplied for iodel.
;
|iodel|equ|24,32|||;| 2222
||ejc||||| 2226
;
;      data block formats and definitions
;
;      the following sections describe the detailed format of
;      all possible data blocks in static and dynamic memory.
;
;      every block has a name of the form xxblk where xx is a
;      unique two character identifier. the first word of every
;      block must contain a pointer to a program location in the
;      interpretor which is immediately preceded by an address
;      constant containing the value bl_xx where xx is the block
;      identifier. this provides a uniform mechanism for
;      distinguishing between the various block types.
;
;      in some cases, the contents of the first word is constant
;      for a given block type and merely serves as a pointer
;      to the identifying address constant. however, in other
;      cases there are several possibilities for the first
;      word in which case each of the several program entry
;      points must be preceded by the appropriate constant.
;
;      in each block, some of the fields are relocatable. this
;      means that they may contain a pointer to another block
;      in the dynamic area. (to be more precise, if they contain
;      a pointer within the dynamic area, then it is a pointer
;      to a block). such fields must be modified by the garbage
;      collector (procedure gbcol) whenever blocks are compacted
;      in the dynamic region. the garbage collector (actually
;      procedure gbcpf) requires that all such relocatable
;      fields in a block must be contiguous.
||ejc||||| 2257
;
;      the description format uses the following scheme.
;
;      1)   block title and two character identifier
;
;      2)   description of basic use of block and indication
;	    of circumstances under which it is constructed.
;
;      3)   picture of the block format. in these pictures low
;	    memory addresses are at the top of the page. fixed
;	    length fields are surrounded by i (letter i). fields
;	    which are fixed length but whose length is dependent
;	    on a configuration parameter are surrounded by *
;	    (asterisk). variable length fields are surrounded
;	    by / (slash).
;
;      4)   definition of symbolic offsets to fields in
;	    block and of the size of the block if fixed length
;	    or of the size of the fixed length fields if the
;	    block is variable length.
;	    note that some routines such as gbcpf assume
;	    certain offsets are equal. the definitions
;	    given here enforce this.  make changes to
;	    them only with due care.
;
;      definitions of common offsets
;
|offs1|equ|24,1|||;| 2285
|offs2|equ|24,2|||;| 2286
|offs3|equ|24,3|||;| 2287
;
;      5)   detailed comments on the significance and formats
;	    of the various fields.
;
;      the order is alphabetical by identification code.
||ejc||||| 2293
;
;      definitions of block codes
;
;      this table provides a unique identification code for
;      each separate block type. the first word of a block in
;      the dynamic area always contains the address of a program
;      entry point. the block code is used as the entry point id
;      the order of these codes dictates the order of the table
;      used by the datatype function (scnmt in the constant sec)
;
;      block codes for accessible datatypes
;
;      note that real and buffer types are always included, even
;      if they are conditionally excluded elsewhere.  this main-
;      tains block type codes across all versions of spitbol,
;      providing consistancy for external functions.  but note
;      that the bcblk is out of alphabetic order, placed at the
;      end of the list so as not to change the block type
;      ordering in use in existing external functions.
;
|bl_ar|equ|24,0|||; arblk	    array| 2314
|bl_cd|equ|24,bl_ar+1|||; cdblk	    code| 2315
|bl_ex|equ|24,bl_cd+1|||; exblk	    expression| 2316
|bl_ic|equ|24,bl_ex+1|||; icblk	    integer| 2317
|bl_nm|equ|24,bl_ic+1|||; nmblk	    name| 2318
|bl_p0|equ|24,bl_nm+1|||; p0blk	    pattern| 2319
|bl_p1|equ|24,bl_p0+1|||; p1blk	    pattern| 2320
|bl_p2|equ|24,bl_p1+1|||; p2blk	    pattern| 2321
|bl_rc|equ|24,bl_p2+1|||; rcblk	    real| 2322
|bl_sc|equ|24,bl_rc+1|||; scblk	    string| 2323
|bl_se|equ|24,bl_sc+1|||; seblk	    expression| 2324
|bl_tb|equ|24,bl_se+1|||; tbblk	    table| 2325
|bl_vc|equ|24,bl_tb+1|||; vcblk	    array| 2326
|bl_xn|equ|24,bl_vc+1|||; xnblk	    external| 2327
|bl_xr|equ|24,bl_xn+1|||; xrblk	    external| 2328
|bl_bc|equ|24,bl_xr+1|||; bcblk	    buffer| 2329
|bl_pd|equ|24,bl_bc+1|||; pdblk	    program defined datatype| 2330
;
|bl__d|equ|24,bl_pd+1|||; number of block codes for data| 2332
;
;      other block codes
;
|bl_tr|equ|24,bl_pd+1|||; trblk| 2336
|bl_bf|equ|24,bl_tr+1|||; bfblk| 2337
|bl_cc|equ|24,bl_bf+1|||; ccblk| 2338
|bl_cm|equ|24,bl_cc+1|||; cmblk| 2339
|bl_ct|equ|24,bl_cm+1|||; ctblk| 2340
|bl_df|equ|24,bl_ct+1|||; dfblk| 2341
|bl_ef|equ|24,bl_df+1|||; efblk| 2342
|bl_ev|equ|24,bl_ef+1|||; evblk| 2343
|bl_ff|equ|24,bl_ev+1|||; ffblk| 2344
|bl_kv|equ|24,bl_ff+1|||; kvblk| 2345
|bl_pf|equ|24,bl_kv+1|||; pfblk| 2346
|bl_te|equ|24,bl_pf+1|||; teblk| 2347
;
|bl__i|equ|24,0|||; default identification code| 2349
|bl__t|equ|24,bl_tr+1|||; code for data or trace block| 2350
|bl___|equ|24,bl_te+1|||; number of block codes| 2351
||ejc||||| 2352
;
;      field references
;
;      references to the fields of data blocks are symbolic
;      (i.e. use the symbolic offsets) with the following
;      exceptions.
;
;      1)   references to the first word are usually not
;	    symbolic since they use the (x) operand format.
;
;      2)   the code which constructs a block is often not
;	    symbolic and should be changed if the corresponding
;	    block format is modified.
;
;      3)   the plc and psc instructions imply an offset
;	    corresponding to the definition of cfp_f.
;
;      4)   there are non-symbolic references (easily changed)
;	    in the garbage collector (procedures gbcpf, blkln).
;
;      5)   the fields idval, fargs appear in several blocks
;	    and any changes must be made in parallel to all
;	    blocks containing the fields. the actual references
;	    to these fields are symbolic with the above
;	    listed exceptions.
;
;      6)   several spots in the code assume that the
;	    definitions of the fields vrval, teval, trnxt are
;	    the same (these are sections of code which search
;	    out along a trblk chain from a variable).
;
;      7)   references to the fields of an array block in the
;	    array reference routine arref are non-symbolic.
;
;      apart from the exceptions listed, references are symbolic
;      as far as possible and modifying the order or number
;      of fields will not require changes.
||ejc||||| 2390
;
;      common fields for function blocks
;
;      blocks which represent callable functions have two
;      common fields at the start of the block as follows.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    /					 /
;	    /	    rest of function block	 /
;	    /					 /
;	    +------------------------------------+
;
|fcode|equ|24,0|||; pointer to code for function| 2407
|fargs|equ|24,1|||; number of arguments| 2408
;
;      fcode is a pointer to the location in the interpretor
;      program which processes this type of function call.
;
;      fargs is the expected number of arguments. the actual
;      number of arguments is adjusted to this amount by
;      deleting extra arguments or supplying trailing nulls
;      for missing ones before transferring though fcode.
;      a value of 999 may be used in this field to indicate a
;      variable number of arguments (see svblk field svnar).
;
;      the block types which follow this scheme are.
;
;      ffblk		     field function
;      dfblk		     datatype function
;      pfblk		     program defined function
;      efblk		     external loaded function
||ejc||||| 2426
;
;      identification field
;
;
;      id   field
;
;      certain program accessible objects (those which contain
;      other data values and can be copied) are given a unique
;      identification number (see exsid). this id value is an
;      address integer value which is always stored in word two.
;
|idval|equ|24,1|||; id value field| 2438
;
;      the blocks containing an idval field are.
;
;      arblk		     array
;      pdblk		     program defined datatype
;      tbblk		     table
;      vcblk		     vector block (array)
;
;      note that a zero idval means that the block is only
;      half built and should not be dumped (see dumpr).
||ejc||||| 2453
;
;      array block (arblk)
;
;      an array block represents an array value other than one
;      with one dimension whose lower bound is one (see vcblk).
;      an arblk is built with a call to the functions convert
;      (s_cnv) or array (s_arr).
;
;	    +------------------------------------+
;	    i		     artyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     arlen		 i
;	    +------------------------------------+
;	    i		     arofs		 i
;	    +------------------------------------+
;	    i		     arndm		 i
;	    +------------------------------------+
;	    *		     arlbd		 *
;	    +------------------------------------+
;	    *		     ardim		 *
;	    +------------------------------------+
;	    *					 *
;	    * above 2 flds repeated for each dim *
;	    *					 *
;	    +------------------------------------+
;	    i		     arpro		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     arvls		 /
;	    /					 /
;	    +------------------------------------+
||ejc||||| 2487
;
;      array block (continued)
;
|artyp|equ|24,0|||; pointer to dummy routine b_art| 2491
|arlen|equ|24,idval+1|||; length of arblk in bytes| 2492
|arofs|equ|24,arlen+1|||; offset in arblk to arpro field| 2493
|arndm|equ|24,arofs+1|||; number of dimensions| 2494
|arlbd|equ|24,arndm+1|||; low bound (first subscript)| 2495
|ardim|equ|24,arlbd+cfp_i|||; dimension (first subscript)| 2496
|arlb2|equ|24,ardim+cfp_i|||; low bound (second subscript)| 2497
|ardm2|equ|24,arlb2+cfp_i|||; dimension (second subscript)| 2498
|arpro|equ|24,ardim+cfp_i|||; array prototype (one dimension)| 2499
|arvls|equ|24,arpro+1|||; start of values (one dimension)| 2500
|arpr2|equ|24,ardm2+cfp_i|||; array prototype (two dimensions)| 2501
|arvl2|equ|24,arpr2+1|||; start of values (two dimensions)| 2502
|arsi_|equ|24,arlbd|||; number of standard fields in block| 2503
|ardms|equ|24,arlb2-arlbd|||; size of info for one set of bounds| 2504
;
;      the bounds and dimension fields are signed integer
;      values and each occupy cfp_i words in the arblk.
;
;      the length of an arblk in bytes may not exceed mxlen.
;      this is required to keep name offsets garbage collectable
;
;      the actual values are arranged in row-wise order and
;      can contain a data pointer or a pointer to a trblk.
||ejc||||| 2590
;
;      code construction block (ccblk)
;
;      at any one moment there is at most one ccblk into
;      which the compiler is currently storing code (cdwrd).
;
;	    +------------------------------------+
;	    i		     cctyp		 i
;	    +------------------------------------+
;	    i		     cclen		 i
;	    +------------------------------------+
;	    i		     ccsln		 i
;	    +------------------------------------+
;	    i		     ccuse		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     cccod		 /
;	    /					 /
;	    +------------------------------------+
;
|cctyp|equ|24,0|||; pointer to dummy routine b_cct| 2613
|cclen|equ|24,cctyp+1|||; length of ccblk in bytes| 2614
|ccsln|equ|24,cclen+1|||; source line number| 2616
|ccuse|equ|24,ccsln+1|||; offset past last used word (bytes)| 2617
|cccod|equ|24,ccuse+1|||; start of generated code in block| 2621
;
;      the reason that the ccblk is a separate block type from
;      the usual cdblk is that the garbage collector must
;      only process those fields which have been set (see gbcpf)
||ejc||||| 2626
;
;      code block (cdblk)
;
;      a code block is built for each statement compiled during
;      the initial compilation or by subsequent calls to code.
;
;	    +------------------------------------+
;	    i		     cdjmp		 i
;	    +------------------------------------+
;	    i		     cdstm		 i
;	    +------------------------------------+
;	    i		     cdsln		 i
;	    +------------------------------------+
;	    i		     cdlen		 i
;	    +------------------------------------+
;	    i		     cdfal		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     cdcod		 /
;	    /					 /
;	    +------------------------------------+
;
|cdjmp|equ|24,0|||; ptr to routine to execute statement| 2651
|cdstm|equ|24,cdjmp+1|||; statement number| 2652
|cdsln|equ|24,cdstm+1|||; source line number| 2654
|cdlen|equ|24,cdsln+1|||; length of cdblk in bytes| 2655
|cdfal|equ|24,cdlen+1|||; failure exit (see below)| 2656
|cdcod|equ|24,cdfal+1|||; executable pseudo-code| 2661
|cdsi_|equ|24,cdcod|||; number of standard fields in cdblk| 2662
;
;      cdstm is the statement number of the current statement.
;
;      cdjmp, cdfal are set as follows.
;
;      1)   if the failure exit is the next statement
;
;	    cdjmp = b_cds
;	    cdfal = ptr to cdblk for next statement
;
;      2)   if the failure exit is a simple label name
;
;	    cdjmp = b_cds
;	    cdfal is a ptr to the vrtra field of the vrblk
;
;      3)   if there is no failure exit (-nofail mode)
;
;	    cdjmp = b_cds
;	    cdfal = o_unf
;
;      4)   if the failure exit is complex or direct
;
;	    cdjmp = b_cdc
;	    cdfal is the offset to the o_gof word
||ejc||||| 2687
;
;      code block (continued)
;
;      cdcod is the start of the actual code. first we describe
;      the code generated for an expression. in an expression,
;      elements are fetched by name or by value. for example,
;      the binary equal operator fetches its left argument
;      by name and its right argument by value. these two
;      cases generate quite different code and are described
;      separately. first we consider the code by value case.
;
;      generation of code by value for expressions elements.
;
;      expression	     pointer to exblk or seblk
;
;      integer constant	     pointer to icblk
;
;      null constant	     pointer to nulls
;
;      pattern		     (resulting from preevaluation)
;			     =o_lpt
;			     pointer to p0blk,p1blk or p2blk
;
;      real constant	     pointer to rcblk
;
;      string constant	     pointer to scblk
;
;      variable		     pointer to vrget field of vrblk
;
;      addition		     value code for left operand
;			     value code for right operand
;			     =o_add
;
;      affirmation	     value code for operand
;			     =o_aff
;
;      alternation	     value code for left operand
;			     value code for right operand
;			     =o_alt
;
;      array reference	     (case of one subscript)
;			     value code for array operand
;			     value code for subscript operand
;			     =o_aov
;
;			     (case of more than one subscript)
;			     value code for array operand
;			     value code for first subscript
;			     value code for second subscript
;			     ...
;			     value code for last subscript
;			     =o_amv
;			     number of subscripts
||ejc||||| 2741
;
;      code block (continued)
;
;      assignment	     (to natural variable)
;			     value code for right operand
;			     pointer to vrsto field of vrblk
;
;			     (to any other variable)
;			     name code for left operand
;			     value code for right operand
;			     =o_ass
;
;      compile error	     =o_cer
;
;
;      complementation	     value code for operand
;			     =o_com
;
;      concatenation	     (case of pred func left operand)
;			     value code for left operand
;			     =o_pop
;			     value code for right operand
;
;			     (all other cases)
;			     value code for left operand
;			     value code for right operand
;			     =o_cnc
;
;      cursor assignment     name code for operand
;			     =o_cas
;
;      division		     value code for left operand
;			     value code for right operand
;			     =o_dvd
;
;      exponentiation	     value code for left operand
;			     value code for right operand
;			     =o_exp
;
;      function call	     (case of call to system function)
;			     value code for first argument
;			     value code for second argument
;			     ...
;			     value code for last argument
;			     pointer to svfnc field of svblk
;
||ejc||||| 2788
;
;      code block (continued)
;
;      function call	     (case of non-system function 1 arg)
;			     value code for argument
;			     =o_fns
;			     pointer to vrblk for function
;
;			     (non-system function, gt 1 arg)
;			     value code for first argument
;			     value code for second argument
;			     ...
;			     value code for last argument
;			     =o_fnc
;			     number of arguments
;			     pointer to vrblk for function
;
;      immediate assignment  value code for left operand
;			     name code for right operand
;			     =o_ima
;
;      indirection	     value code for operand
;			     =o_inv
;
;      interrogation	     value code for operand
;			     =o_int
;
;      keyword reference     name code for operand
;			     =o_kwv
;
;      multiplication	     value code for left operand
;			     value code for right operand
;			     =o_mlt
;
;      name reference	     (natural variable case)
;			     pointer to nmblk for name
;
;			     (all other cases)
;			     name code for operand
;			     =o_nam
;
;      negation		     =o_nta
;			     cdblk offset of o_ntc word
;			     value code for operand
;			     =o_ntb
;			     =o_ntc
||ejc||||| 2835
;
;      code block (continued)
;
;      pattern assignment    value code for left operand
;			     name code for right operand
;			     =o_pas
;
;      pattern match	     value code for left operand
;			     value code for right operand
;			     =o_pmv
;
;      pattern replacement   name code for subject
;			     value code for pattern
;			     =o_pmn
;			     value code for replacement
;			     =o_rpl
;
;      selection	     (for first alternative)
;			     =o_sla
;			     cdblk offset to next o_slc word
;			     value code for first alternative
;			     =o_slb
;			     cdblk offset past alternatives
;
;			     (for subsequent alternatives)
;			     =o_slc
;			     cdblk offset to next o_slc,o_sld
;			     value code for alternative
;			     =o_slb
;			     offset in cdblk past alternatives
;
;			     (for last alternative)
;			     =o_sld
;			     value code for last alternative
;
;      subtraction	     value code for left operand
;			     value code for right operand
;			     =o_sub
||ejc||||| 2874
;
;      code block (continued)
;
;      generation of code by name for expression elements.
;
;      variable		     =o_lvn
;			     pointer to vrblk
;
;      expression	     (case of *natural variable)
;			     =o_lvn
;			     pointer to vrblk
;
;			     (all other cases)
;			     =o_lex
;			     pointer to exblk
;
;
;      array reference	     (case of one subscript)
;			     value code for array operand
;			     value code for subscript operand
;			     =o_aon
;
;			     (case of more than one subscript)
;			     value code for array operand
;			     value code for first subscript
;			     value code for second subscript
;			     ...
;			     value code for last subscript
;			     =o_amn
;			     number of subscripts
;
;      compile error	     =o_cer
;
;      function call	     (same code as for value call)
;			     =o_fne
;
;      indirection	     value code for operand
;			     =o_inn
;
;      keyword reference     name code for operand
;			     =o_kwn
;
;      any other operand is an error in a name position
;
;      note that in this description, =o_xxx refers to the
;      generation of a word containing the address of another
;      word which contains the entry point address o_xxx.
||ejc||||| 2922
;
;      code block (continued)
;
;      now we consider the overall structure of the code block
;      for a statement with possible goto fields.
;
;      first comes the code for the statement body.
;      the statement body is an expression to be evaluated
;      by value although the value is not actually required.
;      normal value code is generated for the body of the
;      statement except in the case of a pattern match by
;      value, in which case the following is generated.
;
;			     value code for left operand
;			     value code for right operand
;			     =o_pms
;
;      next we have the code for the success goto. there are
;      several cases as follows.
;
;      1)   no success goto  ptr to cdblk for next statement
;
;      2)   simple label     ptr to vrtra field of vrblk
;
;      3)   complex goto     (code by name for goto operand)
;			     =o_goc
;
;      4)   direct goto	     (code by value for goto operand)
;			     =o_god
;
;      following this we generate code for the failure goto if
;      it is direct or if it is complex, simple failure gotos
;      having been handled by an appropriate setting of the
;      cdfal field of the cdblk. the generated code is one
;      of the following.
;
;      1)   complex fgoto    =o_fif
;			     =o_gof
;			     name code for goto operand
;			     =o_goc
;
;      2)   direct fgoto     =o_fif
;			     =o_gof
;			     value code for goto operand
;			     =o_god
;
;      an optimization occurs if the success and failure gotos
;      are identical and either complex or direct. in this case,
;      no code is generated for the success goto and control
;      is allowed to fall into the failure goto on success.
||ejc||||| 2973
;
;      compiler block (cmblk)
;
;      a compiler block (cmblk) is built by expan to represent
;      one node of a tree structured expression representation.
;
;	    +------------------------------------+
;	    i		     cmidn		 i
;	    +------------------------------------+
;	    i		     cmlen		 i
;	    +------------------------------------+
;	    i		     cmtyp		 i
;	    +------------------------------------+
;	    i		     cmopn		 i
;	    +------------------------------------+
;	    /		cmvls or cmrop		 /
;	    /					 /
;	    /		     cmlop		 /
;	    /					 /
;	    +------------------------------------+
;
|cmidn|equ|24,0|||; pointer to dummy routine b_cmt| 2995
|cmlen|equ|24,cmidn+1|||; length of cmblk in bytes| 2996
|cmtyp|equ|24,cmlen+1|||; type (c_xxx, see list below)| 2997
|cmopn|equ|24,cmtyp+1|||; operand pointer (see below)| 2998
|cmvls|equ|24,cmopn+1|||; operand value pointers (see below)| 2999
|cmrop|equ|24,cmvls|||; right (only) operator operand| 3000
|cmlop|equ|24,cmvls+1|||; left operator operand| 3001
|cmsi_|equ|24,cmvls|||; number of standard fields in cmblk| 3002
|cmus_|equ|24,cmsi_+1|||; size of unary operator cmblk| 3003
|cmbs_|equ|24,cmsi_+2|||; size of binary operator cmblk| 3004
|cmar1|equ|24,cmvls+1|||; array subscript pointers| 3005
;
;      the cmopn and cmvls fields are set as follows
;
;      array reference	     cmopn = ptr to array operand
;			     cmvls = ptrs to subscript operands
;
;      function call	     cmopn = ptr to vrblk for function
;			     cmvls = ptrs to argument operands
;
;      selection	     cmopn = zero
;			     cmvls = ptrs to alternate operands
;
;      unary operator	     cmopn = ptr to operator dvblk
;			     cmrop = ptr to operand
;
;      binary operator	     cmopn = ptr to operator dvblk
;			     cmrop = ptr to right operand
;			     cmlop = ptr to left operand
||ejc||||| 3024
;
;      cmtyp is set to indicate the type of expression element
;      as shown by the following table of definitions.
;
|c_arr|equ|24,0|||; array reference| 3029
|c_fnc|equ|24,c_arr+1|||; function call| 3030
|c_def|equ|24,c_fnc+1|||; deferred expression (unary *)| 3031
|c_ind|equ|24,c_def+1|||; indirection (unary _)| 3032
|c_key|equ|24,c_ind+1|||; keyword reference (unary ampersand)| 3033
|c_ubo|equ|24,c_key+1|||; undefined binary operator| 3034
|c_uuo|equ|24,c_ubo+1|||; undefined unary operator| 3035
|c_uo_|equ|24,c_uuo+1|||; test value (=c_uuo+1=c_ubo+2)| 3036
|c__nm|equ|24,c_uuo+1|||; number of codes for name operands| 3037
;
;      the remaining types indicate expression elements which
;      can only be evaluated by value (not by name).
;
|c_bvl|equ|24,c_uuo+1|||; binary op with value operands| 3042
|c_uvl|equ|24,c_bvl+1|||; unary operator with value operand| 3043
|c_alt|equ|24,c_uvl+1|||; alternation (binary bar)| 3044
|c_cnc|equ|24,c_alt+1|||; concatenation| 3045
|c_cnp|equ|24,c_cnc+1|||; concatenation, not pattern match| 3046
|c_unm|equ|24,c_cnp+1|||; unary op with name operand| 3047
|c_bvn|equ|24,c_unm+1|||; binary op (operands by value, name)| 3048
|c_ass|equ|24,c_bvn+1|||; assignment| 3049
|c_int|equ|24,c_ass+1|||; interrogation| 3050
|c_neg|equ|24,c_int+1|||; negation (unary not)| 3051
|c_sel|equ|24,c_neg+1|||; selection| 3052
|c_pmt|equ|24,c_sel+1|||; pattern match| 3053
;
|c_pr_|equ|24,c_bvn|||; last preevaluable code| 3055
|c__nv|equ|24,c_pmt+1|||; number of different cmblk types| 3056
||ejc||||| 3057
;
;      character table block (ctblk)
;
;      a character table block is used to hold logical character
;      tables for use with any,notany,span,break,breakx
;      patterns. each character table can be used to store
;      cfp_n distinct tables as bit columns. a bit column
;      allocated for each argument of more than one character
;      in length to one of the above listed pattern primitives.
;
;	    +------------------------------------+
;	    i		     cttyp		 i
;	    +------------------------------------+
;	    *					 *
;	    *					 *
;	    *		     ctchs		 *
;	    *					 *
;	    *					 *
;	    +------------------------------------+
;
|cttyp|equ|24,0|||; pointer to dummy routine b_ctt| 3078
|ctchs|equ|24,cttyp+1|||; start of character table words| 3079
|ctsi_|equ|24,ctchs+cfp_a|||; number of words in ctblk| 3080
;
;      ctchs is cfp_a words long and consists of a one word
;      bit string value for each possible character in the
;      internal alphabet. each of the cfp_n possible bits in
;      a bitstring is used to form a column of bit indicators.
;      a bit is set on if the character is in the table and off
;      if the character is not present.
||ejc||||| 3088
;
;      datatype function block (dfblk)
;
;      a datatype function is used to control the construction
;      of a program defined datatype object. a call to the
;      system function data builds a dfblk for the datatype name
;
;      note that these blocks are built in static because pdblk
;      length is got from dflen field.	if dfblk was in dynamic
;      store this would cause trouble during pass two of garbage
;      collection.  scblk referred to by dfnam field is also put
;      in static so that there are no reloc. fields. this cuts
;      garbage collection task appreciably for pdblks which are
;      likely to be present in large numbers.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     dflen		 i
;	    +------------------------------------+
;	    i		     dfpdl		 i
;	    +------------------------------------+
;	    i		     dfnam		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     dffld		 /
;	    /					 /
;	    +------------------------------------+
;
|dflen|equ|24,fargs+1|||; length of dfblk in bytes| 3120
|dfpdl|equ|24,dflen+1|||; length of corresponding pdblk| 3121
|dfnam|equ|24,dfpdl+1|||; pointer to scblk for datatype name| 3122
|dffld|equ|24,dfnam+1|||; start of vrblk ptrs for field names| 3123
|dfflb|equ|24,dffld-1|||; offset behind dffld for field func| 3124
|dfsi_|equ|24,dffld|||; number of standard fields in dfblk| 3125
;
;      the fcode field points to the routine b_dfc
;
;      fargs (the number of arguments) is the number of fields.
||ejc||||| 3130
;
;      dope vector block (dvblk)
;
;      a dope vector is assembled for each possible operator in
;      the snobol4 language as part of the constant section.
;
;	    +------------------------------------+
;	    i		     dvopn		 i
;	    +------------------------------------+
;	    i		     dvtyp		 i
;	    +------------------------------------+
;	    i		     dvlpr		 i
;	    +------------------------------------+
;	    i		     dvrpr		 i
;	    +------------------------------------+
;
|dvopn|equ|24,0|||; entry address (ptr to o_xxx)| 3147
|dvtyp|equ|24,dvopn+1|||; type code (c_xxx, see cmblk)| 3148
|dvlpr|equ|24,dvtyp+1|||; left precedence (llxxx, see below)| 3149
|dvrpr|equ|24,dvlpr+1|||; right precedence (rrxxx, see below)| 3150
|dvus_|equ|24,dvlpr+1|||; size of unary operator dv| 3151
|dvbs_|equ|24,dvrpr+1|||; size of binary operator dv| 3152
|dvubs|equ|24,dvus_+dvbs_|||; size of unop + binop (see scane)| 3153
;
;      the contents of the dvtyp field is copied into the cmtyp
;      field of the cmblk for the operator if it is used.
;
;      the cmopn field of an operator cmblk points to the dvblk
;      itself, providing the required entry address pointer ptr.
;
;      for normally undefined operators, the dvopn (and cmopn)
;      fields contain a word offset from r_uba of the function
;      block pointer for the operator (instead of o_xxx ptr).
;      for certain special operators, the dvopn field is not
;      required at all and is assembled as zero.
;
;      the left precedence is used in comparing an operator to
;      the left of some other operator. it therefore governs the
;      precedence of the operator towards its right operand.
;
;      the right precedence is used in comparing an operator to
;      the right of some other operator. it therefore governs
;      the precedence of the operator towards its left operand.
;
;      higher precedence values correspond to a tighter binding
;      capability. thus we have the left precedence lower
;      (higher) than the right precedence for right (left)
;      associative binary operators.
;
;      the left precedence of unary operators is set to an
;      arbitrary high value. the right value is not required and
;      consequently the dvrpr field is omitted for unary ops.
||ejc||||| 3183
;
;      table of operator precedence values
;
|rrass|equ|24,10|||; right	    equal| 3187
|llass|equ|24,00|||; left	    equal| 3188
|rrpmt|equ|24,20|||; right	    question mark| 3189
|llpmt|equ|24,30|||; left	    question mark| 3190
|rramp|equ|24,40|||; right	    ampersand| 3191
|llamp|equ|24,50|||; left	    ampersand| 3192
|rralt|equ|24,70|||; right	    vertical bar| 3193
|llalt|equ|24,60|||; left	    vertical bar| 3194
|rrcnc|equ|24,90|||; right	    blank| 3195
|llcnc|equ|24,80|||; left	    blank| 3196
|rrats|equ|24,110|||; right	    at| 3197
|llats|equ|24,100|||; left	    at| 3198
|rrplm|equ|24,120|||; right	    plus, minus| 3199
|llplm|equ|24,130|||; left	    plus, minus| 3200
|rrnum|equ|24,140|||; right	    number| 3201
|llnum|equ|24,150|||; left	    number| 3202
|rrdvd|equ|24,160|||; right	    slash| 3203
|lldvd|equ|24,170|||; left	    slash| 3204
|rrmlt|equ|24,180|||; right	    asterisk| 3205
|llmlt|equ|24,190|||; left	    asterisk| 3206
|rrpct|equ|24,200|||; right	    percent| 3207
|llpct|equ|24,210|||; left	    percent| 3208
|rrexp|equ|24,230|||; right	    exclamation| 3209
|llexp|equ|24,220|||; left	    exclamation| 3210
|rrdld|equ|24,240|||; right	    dollar, dot| 3211
|lldld|equ|24,250|||; left	    dollar, dot| 3212
|rrnot|equ|24,270|||; right	    not| 3213
|llnot|equ|24,260|||; left	    not| 3214
|lluno|equ|24,999|||; left	    all unary operators| 3215
;
;      precedences are the same as in btl snobol4 with the
;      following exceptions.
;
;      1)   binary question mark is lowered and made left assoc-
;	    iative to reflect its new use for pattern matching.
;
;      2)   alternation and concatenation are made right
;	    associative for greater efficiency in pattern
;	    construction and matching respectively. this change
;	    is transparent to the snobol4 programmer.
;
;      3)   the equal sign has been added as a low precedence
;	    operator which is right associative to reflect its
;	    more general usage in this version of snobol4.
||ejc||||| 3231
;
;      external function block (efblk)
;
;      an external function block is used to control the calling
;      of an external function. it is built by a call to load.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     eflen		 i
;	    +------------------------------------+
;	    i		     efuse		 i
;	    +------------------------------------+
;	    i		     efcod		 i
;	    +------------------------------------+
;	    i		     efvar		 i
;	    +------------------------------------+
;	    i		     efrsl		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     eftar		 /
;	    /					 /
;	    +------------------------------------+
;
|eflen|equ|24,fargs+1|||; length of efblk in bytes| 3258
|efuse|equ|24,eflen+1|||; use count (for opsyn)| 3259
|efcod|equ|24,efuse+1|||; ptr to code (from sysld)| 3260
|efvar|equ|24,efcod+1|||; ptr to associated vrblk| 3261
|efrsl|equ|24,efvar+1|||; result type (see below)| 3262
|eftar|equ|24,efrsl+1|||; argument types (see below)| 3263
|efsi_|equ|24,eftar|||; number of standard fields in efblk| 3264
;
;      the fcode field points to the routine b_efc.
;
;      efuse is used to keep track of multiple use when opsyn
;      is employed. the function is automatically unloaded
;      when there are no more references to the function.
;
;      efrsl and eftar are type codes as follows.
;
;	    0		     type is unconverted
;	    1		     type is string
;	    2		     type is integer
;	    3		     type is real
;	    4		     type is file
||ejc||||| 3287
;
;      expression variable block (evblk)
;
;      in this version of spitbol, an expression can be used in
;      any position which would normally expect a name (for
;      example on the left side of equals or as the right
;      argument of binary dot). this corresponds to the creation
;      of a pseudo-variable which is represented by a pointer to
;      an expression variable block as follows.
;
;	    +------------------------------------+
;	    i		     evtyp		 i
;	    +------------------------------------+
;	    i		     evexp		 i
;	    +------------------------------------+
;	    i		     evvar		 i
;	    +------------------------------------+
;
|evtyp|equ|24,0|||; pointer to dummy routine b_evt| 3306
|evexp|equ|24,evtyp+1|||; pointer to exblk for expression| 3307
|evvar|equ|24,evexp+1|||; pointer to trbev dummy trblk| 3308
|evsi_|equ|24,evvar+1|||; size of evblk| 3309
;
;      the name of an expression variable is represented by a
;      base pointer to the evblk and an offset of evvar. this
;      value appears to be trapped by the dummy trbev block.
;
;      note that there is no need to allow for the case of an
;      expression variable which references an seblk since a
;      variable which is of the form *var is equivalent to var.
||ejc||||| 3318
;
;      expression block (exblk)
;
;      an expression block is built for each expression
;      referenced in a program or created by eval or convert
;      during execution of a program.
;
;	    +------------------------------------+
;	    i		     extyp		 i
;	    +------------------------------------+
;	    i		     exstm		 i
;	    +------------------------------------+
;	    i		     exsln		 i
;	    +------------------------------------+
;	    i		     exlen		 i
;	    +------------------------------------+
;	    i		     exflc		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     excod		 /
;	    /					 /
;	    +------------------------------------+
;
|extyp|equ|24,0|||; ptr to routine b_exl to load expr| 3344
|exstm|equ|24,cdstm|||; stores stmnt no. during evaluation| 3345
|exsln|equ|24,exstm+1|||; stores line no. during evaluation| 3347
|exlen|equ|24,exsln+1|||; length of exblk in bytes| 3348
|exflc|equ|24,exlen+1|||; failure code (=o_fex)| 3352
|excod|equ|24,exflc+1|||; pseudo-code for expression| 3353
|exsi_|equ|24,excod|||; number of standard fields in exblk| 3354
;
;      there are two cases for excod depending on whether the
;      expression can be evaluated by name (see description
;      of cdblk for details of code for expressions).
;
;      if the expression can be evaluated by name we have.
;
;			     (code for expr by name)
;			     =o_rnm
;
;      if the expression can only be evaluated by value.
;
;			     (code for expr by value)
;			     =o_rvl
||ejc||||| 3369
;
;      field function block (ffblk)
;
;      a field function block is used to control the selection
;      of a field from a program defined datatype block.
;      a call to data creates an ffblk for each field.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     ffdfp		 i
;	    +------------------------------------+
;	    i		     ffnxt		 i
;	    +------------------------------------+
;	    i		     ffofs		 i
;	    +------------------------------------+
;
|ffdfp|equ|24,fargs+1|||; pointer to associated dfblk| 3389
|ffnxt|equ|24,ffdfp+1|||; ptr to next ffblk on chain or zero| 3390
|ffofs|equ|24,ffnxt+1|||; offset (bytes) to field in pdblk| 3391
|ffsi_|equ|24,ffofs+1|||; size of ffblk in words| 3392
;
;      the fcode field points to the routine b_ffc.
;
;      fargs always contains one.
;
;      ffdfp is used to verify that the correct program defined
;      datatype is being accessed by this call.
;      ffdfp is non-reloc. because dfblk is in static
;
;      ffofs is used to select the appropriate field. note that
;      it is an actual offset (not a field number)
;
;      ffnxt is used to point to the next ffblk of the same name
;      in the case where there are several fields of the same
;      name for different datatypes. zero marks the end of chain
||ejc||||| 3408
;
;      integer constant block (icblk)
;
;      an icblk is created for every integer referenced or
;      created by a program. note however that certain internal
;      integer values are stored as addresses (e.g. the length
;      field in a string constant block)
;
;	    +------------------------------------+
;	    i		     icget		 i
;	    +------------------------------------+
;	    *		     icval		 *
;	    +------------------------------------+
;
|icget|equ|24,0|||; ptr to routine b_icl to load int| 3423
|icval|equ|24,icget+1|||; integer value| 3424
|icsi_|equ|24,icval+cfp_i|||; size of icblk| 3425
;
;      the length of the icval field is cfp_i.
||ejc||||| 3428
;
;      keyword variable block (kvblk)
;
;      a kvblk is used to represent a keyword pseudo-variable.
;      a kvblk is built for each keyword reference (kwnam).
;
;	    +------------------------------------+
;	    i		     kvtyp		 i
;	    +------------------------------------+
;	    i		     kvvar		 i
;	    +------------------------------------+
;	    i		     kvnum		 i
;	    +------------------------------------+
;
|kvtyp|equ|24,0|||; pointer to dummy routine b_kvt| 3443
|kvvar|equ|24,kvtyp+1|||; pointer to dummy block trbkv| 3444
|kvnum|equ|24,kvvar+1|||; keyword number| 3445
|kvsi_|equ|24,kvnum+1|||; size of kvblk| 3446
;
;      the name of a keyword variable is represented by a
;      base pointer to the kvblk and an offset of kvvar. the
;      value appears to be trapped by the pointer to trbkv.
||ejc||||| 3451
;
;      name block (nmblk)
;
;      a name block is used wherever a name must be stored as
;      a value following use of the unary dot operator.
;
;	    +------------------------------------+
;	    i		     nmtyp		 i
;	    +------------------------------------+
;	    i		     nmbas		 i
;	    +------------------------------------+
;	    i		     nmofs		 i
;	    +------------------------------------+
;
|nmtyp|equ|24,0|||; ptr to routine b_nml to load name| 3466
|nmbas|equ|24,nmtyp+1|||; base pointer for variable| 3467
|nmofs|equ|24,nmbas+1|||; offset for variable| 3468
|nmsi_|equ|24,nmofs+1|||; size of nmblk| 3469
;
;      the actual field representing the contents of the name
;      is found nmofs bytes past the address in nmbas.
;
;      the name is split into base and offset form to avoid
;      creation of a pointer into the middle of a block which
;      could not be handled properly by the garbage collector.
;
;      a name may be built for any variable (see section on
;      representations of variables) this includes the
;      cases of pseudo-variables.
||ejc||||| 3481
;
;      pattern block, no parameters (p0blk)
;
;      a p0blk is used to represent pattern nodes which do
;      not require the use of any parameter values.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;
|pcode|equ|24,0|||; ptr to match routine (p_xxx)| 3494
|pthen|equ|24,pcode+1|||; pointer to subsequent node| 3495
|pasi_|equ|24,pthen+1|||; size of p0blk| 3496
;
;      pthen points to the pattern block for the subsequent
;      node to be matched. this is a pointer to the pattern
;      block ndnth if there is no subsequent (end of pattern)
;
;      pcode is a pointer to the match routine for the node.
||ejc||||| 3503
;
;      pattern block (one parameter)
;
;      a p1blk is used to represent pattern nodes which
;      require one parameter value.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;
|parm1|equ|24,pthen+1|||; first parameter value| 3518
|pbsi_|equ|24,parm1+1|||; size of p1blk in words| 3519
;
;      see p0blk for definitions of pcode, pthen
;
;      parm1 contains a parameter value used in matching the
;      node. for example, in a len pattern, it is the integer
;      argument to len. the details of the use of the parameter
;      field are included in the description of the individual
;      match routines. parm1 is always an address pointer which
;      is processed by the garbage collector.
||ejc||||| 3529
;
;      pattern block (two parameters)
;
;      a p2blk is used to represent pattern nodes which
;      require two parameter values.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;	    i		     parm2		 i
;	    +------------------------------------+
;
|parm2|equ|24,parm1+1|||; second parameter value| 3546
|pcsi_|equ|24,parm2+1|||; size of p2blk in words| 3547
;
;      see p1blk for definitions of pcode, pthen, parm1
;
;      parm2 is a parameter which performs the same sort of
;      function as parm1 (see description of p1blk).
;
;      parm2 is a non-relocatable field and is not
;      processed by the garbage collector. accordingly, it may
;      not contain a pointer to a block in dynamic memory.
||ejc||||| 3557
;
;      program-defined datatype block
;
;      a pdblk represents the data item formed by a call to a
;      datatype function as defined by the system function data.
;
;	    +------------------------------------+
;	    i		     pdtyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     pddfp		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     pdfld		 /
;	    /					 /
;	    +------------------------------------+
;
|pdtyp|equ|24,0|||; ptr to dummy routine b_pdt| 3576
|pddfp|equ|24,idval+1|||; ptr to associated dfblk| 3577
|pdfld|equ|24,pddfp+1|||; start of field value pointers| 3578
|pdfof|equ|24,dffld-pdfld|||; difference in offset to field ptrs| 3579
|pdsi_|equ|24,pdfld|||; size of standard fields in pdblk| 3580
|pddfs|equ|24,dfsi_-pdsi_|||; difference in dfblk, pdblk sizes| 3581
;
;      the pddfp pointer may be used to determine the datatype
;      and the names of the fields if required. the dfblk also
;      contains the length of the pdblk in bytes (field dfpdl).
;      pddfp is non-reloc. because dfblk is in static
;
;      pdfld values are stored in order from left to right.
;      they contain values or pointers to trblk chains.
||ejc||||| 3590
;
;      program defined function block (pfblk)
;
;      a pfblk is created for each call to the define function
;      and a pointer to the pfblk placed in the proper vrblk.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     pflen		 i
;	    +------------------------------------+
;	    i		     pfvbl		 i
;	    +------------------------------------+
;	    i		     pfnlo		 i
;	    +------------------------------------+
;	    i		     pfcod		 i
;	    +------------------------------------+
;	    i		     pfctr		 i
;	    +------------------------------------+
;	    i		     pfrtr		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     pfarg		 /
;	    /					 /
;	    +------------------------------------+
;
|pflen|equ|24,fargs+1|||; length of pfblk in bytes| 3619
|pfvbl|equ|24,pflen+1|||; pointer to vrblk for function name| 3620
|pfnlo|equ|24,pfvbl+1|||; number of locals| 3621
|pfcod|equ|24,pfnlo+1|||; ptr to vrblk for entry label| 3622
|pfctr|equ|24,pfcod+1|||; trblk ptr if call traced else 0| 3623
|pfrtr|equ|24,pfctr+1|||; trblk ptr if return traced else 0| 3624
|pfarg|equ|24,pfrtr+1|||; vrblk ptrs for arguments and locals| 3625
|pfagb|equ|24,pfarg-1|||; offset behind pfarg for arg, local| 3626
|pfsi_|equ|24,pfarg|||; number of standard fields in pfblk| 3627
;
;      the fcode field points to the routine b_pfc.
;
;      pfarg is stored in the following order.
;
;	    arguments (left to right)
;	    locals (left to right)
||ejc||||| 3637
;
;      real constant block (rcblk)
;
;      an rcblk is created for every real referenced or
;      created by a program.
;
;	    +------------------------------------+
;	    i		     rcget		 i
;	    +------------------------------------+
;	    *		     rcval		 *
;	    +------------------------------------+
;
|rcget|equ|24,0|||; ptr to routine b_rcl to load real| 3650
|rcval|equ|24,rcget+1|||; real value| 3651
|rcsi_|equ|24,rcval+cfp_r|||; size of rcblk| 3652
;
;      the length of the rcval field is cfp_r.
||ejc||||| 3656
;
;      string constant block (scblk)
;
;      an scblk is built for every string referenced or created
;      by a program.
;
;	    +------------------------------------+
;	    i		     scget		 i
;	    +------------------------------------+
;	    i		     sclen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     schar		 /
;	    /					 /
;	    +------------------------------------+
;
|scget|equ|24,0|||; ptr to routine b_scl to load string| 3673
|sclen|equ|24,scget+1|||; length of string in characters| 3674
|schar|equ|24,sclen+1|||; characters of string| 3675
|scsi_|equ|24,schar|||; size of standard fields in scblk| 3676
;
;      the characters of the string are stored left justified.
;      the final word is padded on the right with zeros.
;      (i.e. the character whose internal code is zero).
;
;      the value of sclen may not exceed mxlen. this ensures
;      that character offsets (e.g. the pattern match cursor)
;      can be correctly processed by the garbage collector.
;
;      note that the offset to the characters of the string
;      is given in bytes by cfp_f and that this value is
;      automatically allowed for in plc, psc.
;      note that for a spitbol scblk, the value of cfp_f
;      is given by cfp_b*schar.
||ejc||||| 3691
;
;      simple expression block (seblk)
;
;      an seblk is used to represent an expression of the form
;      *(natural variable). all other expressions are exblks.
;
;	    +------------------------------------+
;	    i		     setyp		 i
;	    +------------------------------------+
;	    i		     sevar		 i
;	    +------------------------------------+
;
|setyp|equ|24,0|||; ptr to routine b_sel to load expr| 3704
|sevar|equ|24,setyp+1|||; ptr to vrblk for variable| 3705
|sesi_|equ|24,sevar+1|||; length of seblk in words| 3706
||ejc||||| 3707
;
;      standard variable block (svblk)
;
;      an svblk is assembled in the constant section for each
;      variable which satisfies one of the following conditions.
;
;      1)   it is the name of a system function
;      2)   it has an initial value
;      3)   it has a keyword association
;      4)   it has a standard i/o association
;      6)   it has a standard label association
;
;      if vrblks are constructed for any of these variables,
;      then the vrsvp field points to the svblk (see vrblk)
;
;	    +------------------------------------+
;	    i		     svbit		 i
;	    +------------------------------------+
;	    i		     svlen		 i
;	    +------------------------------------+
;	    /		     svchs		 /
;	    +------------------------------------+
;	    i		     svknm		 i
;	    +------------------------------------+
;	    i		     svfnc		 i
;	    +------------------------------------+
;	    i		     svnar		 i
;	    +------------------------------------+
;	    i		     svlbl		 i
;	    +------------------------------------+
;	    i		     svval		 i
;	    +------------------------------------+
||ejc||||| 3740
;
;      standard variable block (continued)
;
|svbit|equ|24,0|||; bit string indicating attributes| 3744
|svlen|equ|24,1|||; (=sclen) length of name in chars| 3745
|svchs|equ|24,2|||; (=schar) characters of name| 3746
|svsi_|equ|24,2|||; number of standard fields in svblk| 3747
|svpre|equ|24,1|||; set if preevaluation permitted| 3748
|svffc|equ|24,svpre+svpre|||; set on if fast call permitted| 3749
|svckw|equ|24,svffc+svffc|||; set on if keyword value constant| 3750
|svprd|equ|24,svckw+svckw|||; set on if predicate function| 3751
|svnbt|equ|24,4|||; number of bits to right of svknm| 3752
|svknm|equ|24,svprd+svprd|||; set on if keyword association| 3753
|svfnc|equ|24,svknm+svknm|||; set on if system function| 3754
|svnar|equ|24,svfnc+svfnc|||; set on if system function| 3755
|svlbl|equ|24,svnar+svnar|||; set on if system label| 3756
|svval|equ|24,svlbl+svlbl|||; set on if predefined value| 3757
;
;      note that the last five bits correspond in order
;      to the fields which are present (see procedure gtnvr).
;
;      the following definitions are used in the svblk table
;
|svfnf|equ|24,svfnc+svnar|||; function with no fast call| 3764
|svfnn|equ|24,svfnf+svffc|||; function with fast call, no preeval| 3765
|svfnp|equ|24,svfnn+svpre|||; function allowing preevaluation| 3766
|svfpr|equ|24,svfnn+svprd|||; predicate function| 3767
|svfnk|equ|24,svfnn+svknm|||; no preeval func + keyword| 3768
|svkwv|equ|24,svknm+svval|||; keyword + value| 3769
|svkwc|equ|24,svckw+svknm|||; keyword with constant value| 3770
|svkvc|equ|24,svkwv+svckw|||; constant keyword + value| 3771
|svkvl|equ|24,svkvc+svlbl|||; constant keyword + value + label| 3772
|svfpk|equ|24,svfnp+svkvc|||; preeval fcn + const keywd + val| 3773
;
;      the svpre bit allows the compiler to preevaluate a call
;      to the associated system function if all the arguments
;      are themselves constants. functions in this category
;      must have no side effects and must never cause failure.
;      the call may generate an error condition.
;
;      the svffc bit allows the compiler to generate the special
;      fast call after adjusting the number of arguments. only
;      the item and apply functions fall outside this category.
;
;      the svckw bit is set if the associated keyword value is
;      a constant, thus allowing preevaluation for a value call.
;
;      the svprd bit is set on for all predicate functions to
;      enable the special concatenation code optimization.
||ejc||||| 3790
;
;      svblk (continued)
;
;      svknm		     keyword number
;
;	    svknm is present only for a standard keyword assoc.
;	    it contains a keyword number as defined by the
;	    keyword number table given later on.
;
;      svfnc		     system function pointer
;
;	    svfnc is present only for a system function assoc.
;	    it is a pointer to the actual code for the system
;	    function. the generated code for a fast call is a
;	    pointer to the svfnc field of the svblk for the
;	    function. the vrfnc field of the vrblk points to
;	    this same field, in which case, it serves as the
;	    fcode field for the function call.
;
;      svnar		     number of function arguments
;
;	    svnar is present only for a system function assoc.
;	    it is the number of arguments required for a call
;	    to the system function. the compiler uses this
;	    value to adjust the number of arguments in a fast
;	    call and in the case of a function called through
;	    the vrfnc field of the vrblk, the svnar field
;	    serves as the fargs field for o_fnc. a special
;	    case occurs if this value is set to 999. this is
;	    used to indicate that the function has a variable
;	    number of arguments and causes o_fnc to pass control
;	    without adjusting the argument count. the only
;	    predefined functions using this are apply and item.
;
;      svlbl		     system label pointer
;
;	    svlbl is present only for a standard label assoc.
;	    it is a pointer to a system label routine (l_xxx).
;	    the vrlbl field of the corresponding vrblk points to
;	    the svlbl field of the svblk.
;
;      svval		     system value pointer
;
;	    svval is present only for a standard value.
;	    it is a pointer to the pattern node (ndxxx) which
;	    is the standard initial value of the variable.
;	    this value is copied to the vrval field of the vrblk
||ejc||||| 3838
;
;      svblk (continued)
;
;      keyword number table
;
;      the following table gives symbolic names for keyword
;      numbers. these values are stored in the svknm field of
;      svblks and in the kvnum field of kvblks. see also
;      procedures asign, acess and kwnam.
;
;      unprotected keywords with one word integer values
;
|k_abe|equ|24,0|||; abend| 3851
|k_anc|equ|24,k_abe+cfp_b|||; anchor| 3852
|k_cas|equ|24,k_anc+cfp_b|||; case| 3854
|k_cod|equ|24,k_cas+cfp_b|||; code| 3855
|k_com|equ|24,k_cod+cfp_b|||; compare| 3860
|k_dmp|equ|24,k_com+cfp_b|||; dump| 3861
|k_erl|equ|24,k_dmp+cfp_b|||; errlimit| 3865
|k_ert|equ|24,k_erl+cfp_b|||; errtype| 3866
|k_ftr|equ|24,k_ert+cfp_b|||; ftrace| 3867
|k_fls|equ|24,k_ftr+cfp_b|||; fullscan| 3868
|k_inp|equ|24,k_fls+cfp_b|||; input| 3869
|k_mxl|equ|24,k_inp+cfp_b|||; maxlength| 3870
|k_oup|equ|24,k_mxl+cfp_b|||; output| 3871
|k_pfl|equ|24,k_oup+cfp_b|||; profile| 3875
|k_tra|equ|24,k_pfl+cfp_b|||; trace| 3876
|k_trm|equ|24,k_tra+cfp_b|||; trim| 3878
;
;      protected keywords with one word integer values
;
|k_fnc|equ|24,k_trm+cfp_b|||; fnclevel| 3882
|k_lst|equ|24,k_fnc+cfp_b|||; lastno| 3883
|k_lln|equ|24,k_lst+cfp_b|||; lastline| 3885
|k_lin|equ|24,k_lln+cfp_b|||; line| 3886
|k_stn|equ|24,k_lin+cfp_b|||; stno| 3887
;
;      keywords with constant pattern values
;
|k_abo|equ|24,k_stn+cfp_b|||; abort| 3894
|k_arb|equ|24,k_abo+pasi_|||; arb| 3895
|k_bal|equ|24,k_arb+pasi_|||; bal| 3896
|k_fal|equ|24,k_bal+pasi_|||; fail| 3897
|k_fen|equ|24,k_fal+pasi_|||; fence| 3898
|k_rem|equ|24,k_fen+pasi_|||; rem| 3899
|k_suc|equ|24,k_rem+pasi_|||; succeed| 3900
||ejc||||| 3901
;
;      keyword number table (continued)
;
;      special keywords
;
|k_alp|equ|24,k_suc+1|||; alphabet| 3907
|k_rtn|equ|24,k_alp+1|||; rtntype| 3908
|k_stc|equ|24,k_rtn+1|||; stcount| 3909
|k_etx|equ|24,k_stc+1|||; errtext| 3910
|k_fil|equ|24,k_etx+1|||; file| 3912
|k_lfl|equ|24,k_fil+1|||; lastfile| 3913
|k_stl|equ|24,k_lfl+1|||; stlimit| 3914
|k_lcs|equ|24,k_stl+1|||; lcase| 3919
|k_ucs|equ|24,k_lcs+1|||; ucase| 3920
;
;      relative offsets of special keywords
;
|k__al|equ|24,k_alp-k_alp|||; alphabet| 3925
|k__rt|equ|24,k_rtn-k_alp|||; rtntype| 3926
|k__sc|equ|24,k_stc-k_alp|||; stcount| 3927
|k__et|equ|24,k_etx-k_alp|||; errtext| 3928
|k__fl|equ|24,k_fil-k_alp|||; file| 3930
|k__lf|equ|24,k_lfl-k_alp|||; lastfile| 3931
|k__sl|equ|24,k_stl-k_alp|||; stlimit| 3933
|k__lc|equ|24,k_lcs-k_alp|||; lcase| 3935
|k__uc|equ|24,k_ucs-k_alp|||; ucase| 3936
|k__n_|equ|24,k__uc+1|||; number of special cases| 3937
;
;      symbols used in asign and acess procedures
;
|k_p__|equ|24,k_fnc|||; first protected keyword| 3944
|k_v__|equ|24,k_abo|||; first keyword with constant value| 3945
|k_s__|equ|24,k_alp|||; first keyword with special acess| 3946
||ejc||||| 3947
;
;      format of a table block (tbblk)
;
;      a table block is used to represent a table value.
;      it is built by a call to the table or convert functions.
;
;	    +------------------------------------+
;	    i		     tbtyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     tblen		 i
;	    +------------------------------------+
;	    i		     tbinv		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     tbbuk		 /
;	    /					 /
;	    +------------------------------------+
;
|tbtyp|equ|24,0|||; pointer to dummy routine b_tbt| 3968
|tblen|equ|24,offs2|||; length of tbblk in bytes| 3969
|tbinv|equ|24,offs3|||; default initial lookup value| 3970
|tbbuk|equ|24,tbinv+1|||; start of hash bucket pointers| 3971
|tbsi_|equ|24,tbbuk|||; size of standard fields in tbblk| 3972
|tbnbk|equ|24,11|||; default no. of buckets| 3973
;
;      the table block is a hash table which points to chains
;      of table element blocks representing the elements
;      in the table which hash into the same bucket.
;
;      tbbuk entries either point to the first teblk on the
;      chain or they point to the tbblk itself to indicate the
;      end of the chain.
||ejc||||| 3982
;
;      table element block (teblk)
;
;      a table element is used to represent a single entry in
;      a table (see description of tbblk format for hash table)
;
;	    +------------------------------------+
;	    i		     tetyp		 i
;	    +------------------------------------+
;	    i		     tesub		 i
;	    +------------------------------------+
;	    i		     teval		 i
;	    +------------------------------------+
;	    i		     tenxt		 i
;	    +------------------------------------+
;
|tetyp|equ|24,0|||; pointer to dummy routine b_tet| 3999
|tesub|equ|24,tetyp+1|||; subscript value| 4000
|teval|equ|24,tesub+1|||; (=vrval) table element value| 4001
|tenxt|equ|24,teval+1|||; link to next teblk| 4002
;      see s_cnv where relation is assumed with tenxt and tbbuk
|tesi_|equ|24,tenxt+1|||; size of teblk in words| 4004
;
;      tenxt points to the next teblk on the hash chain from the
;      tbbuk chain for this hash index. at the end of the chain,
;      tenxt points back to the start of the tbblk.
;
;      teval contains a data pointer or a trblk pointer.
;
;      tesub contains a data pointer.
||ejc||||| 4013
;
;      trap block (trblk)
;
;      a trap block is used to represent a trace or input or
;      output association in response to a call to the trace
;      input or output system functions. see below for details
;
;	    +------------------------------------+
;	    i		     tridn		 i
;	    +------------------------------------+
;	    i		     trtyp		 i
;	    +------------------------------------+
;	    i  trval or trlbl or trnxt or trkvr	 i
;	    +------------------------------------+
;	    i	    trtag or trter or trtrf	 i
;	    +------------------------------------+
;	    i		 trfnc or trfpt		 i
;	    +------------------------------------+
;
|tridn|equ|24,0|||; pointer to dummy routine b_trt| 4033
|trtyp|equ|24,tridn+1|||; trap type code| 4034
|trval|equ|24,trtyp+1|||; value of trapped variable (=vrval)| 4035
|trnxt|equ|24,trval|||; ptr to next trblk on trblk chain| 4036
|trlbl|equ|24,trval|||; ptr to actual label (traced label)| 4037
|trkvr|equ|24,trval|||; vrblk pointer for keyword trace| 4038
|trtag|equ|24,trval+1|||; trace tag| 4039
|trter|equ|24,trtag|||; ptr to terminal vrblk or null| 4040
|trtrf|equ|24,trtag|||; ptr to trblk holding fcblk ptr| 4041
|trfnc|equ|24,trtag+1|||; trace function vrblk (zero if none)| 4042
|trfpt|equ|24,trfnc|||; fcblk ptr for sysio| 4043
|trsi_|equ|24,trfnc+1|||; number of words in trblk| 4044
;
|trtin|equ|24,0|||; trace type for input association| 4046
|trtac|equ|24,trtin+1|||; trace type for access trace| 4047
|trtvl|equ|24,trtac+1|||; trace type for value trace| 4048
|trtou|equ|24,trtvl+1|||; trace type for output association| 4049
|trtfc|equ|24,trtou+1|||; trace type for fcblk identification| 4050
||ejc||||| 4051
;
;      trap block (continued)
;
;      variable input association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtin
;	    trnxt points to next trblk or trval has variable val
;	    trter is a pointer to svblk if association is
;	    for input, terminal, else it is null.
;	    trtrf points to the trap block which in turn points
;	    to an fcblk used for i/o association.
;	    trfpt is the fcblk ptr returned by sysio.
;
;      variable access trace association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtac
;	    trnxt points to next trblk or trval has variable val
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      variable value trace association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtvl
;	    trnxt points to next trblk or trval has variable val
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
||ejc||||| 4093
;      trap block (continued)
;
;      variable output association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtou
;	    trnxt points to next trblk or trval has variable val
;	    trter is a pointer to svblk if association is
;	    for output, terminal, else it is null.
;	    trtrf points to the trap block which in turn points
;	    to an fcblk used for i/o association.
;	    trfpt is the fcblk ptr returned by sysio.
;
;      function call trace
;
;	    the pfctr field of the corresponding pfblk is set
;	    to point to a trblk.
;
;	    trtyp is set to trtin
;	    trnxt is zero
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      function return trace
;
;	    the pfrtr field of the corresponding pfblk is set
;	    to point to a trblk
;
;	    trtyp is set to trtin
;	    trnxt is zero
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      label trace
;
;	    the vrlbl of the vrblk for the label is
;	    changed to point to a trblk and the vrtra field is
;	    set to b_vrt to activate the check.
;
;	    trtyp is set to trtin
;	    trlbl points to the actual label (cdblk) value
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
||ejc||||| 4141
;
;      trap block (continued)
;
;      keyword trace
;
;	    keywords which can be traced possess a unique
;	    location which is zero if there is no trace and
;	    points to a trblk if there is a trace. the locations
;	    are as follows.
;
;	    r_ert	     errtype
;	    r_fnc	     fnclevel
;	    r_stc	     stcount
;
;	    the format of the trblk is as follows.
;
;	    trtyp is set to trtin
;	    trkvr is a pointer to the vrblk for the keyword
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      input/output file arg1 trap block
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case of
;	    a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv. this trap block is used
;	    to hold a pointer to the fcblk which an
;	    implementation may request to hold information
;	    about a file.
;
;	    trtyp is set to trtfc
;	    trnext points to next trblk or trval is variable val
;	    trfnm is 0
;	    trfpt is the fcblk pointer.
;
;      note that when multiple traps are set on a variable
;      the order is in ascending value of trtyp field.
;
;      input association (if present)
;      access trace (if present)
;      value trace (if present)
;      output association (if present)
;
;      the actual value of the variable is stored in the trval
;      field of the last trblk on the chain.
;
;      this implementation does not permit trace or i/o
;      associations to any of the pseudo-variables.
||ejc||||| 4191
;
;      vector block (vcblk)
;
;      a vcblk is used to represent an array value which has
;      one dimension whose lower bound is one. all other arrays
;      are represented by arblks. a vcblk is created by the
;      system function array (s_arr) when passed an integer arg.
;
;	    +------------------------------------+
;	    i		     vctyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     vclen		 i
;	    +------------------------------------+
;	    i		     vcvls		 i
;	    +------------------------------------+
;
|vctyp|equ|24,0|||; pointer to dummy routine b_vct| 4210
|vclen|equ|24,offs2|||; length of vcblk in bytes| 4211
|vcvls|equ|24,offs3|||; start of vector values| 4212
|vcsi_|equ|24,vcvls|||; size of standard fields in vcblk| 4213
|vcvlb|equ|24,vcvls-1|||; offset one word behind vcvls| 4214
|vctbd|equ|24,tbsi_-vcsi_|||; difference in sizes - see prtvl| 4215
;
;      vcvls are either data pointers or trblk pointers
;
;      the dimension can be deduced from vclen.
||ejc||||| 4220
;
;      variable block (vrblk)
;
;      a variable block is built in the static memory area
;      for every variable referenced or created by a program.
;      the order of fields is assumed in the model vrblk stnvr.
;
;      note that since these blocks only occur in the static
;      region, it is permissible to point to any word in
;      the block and this is used to provide three distinct
;      access points from the generated code as follows.
;
;      1)   point to vrget (first word of vrblk) to load the
;	    value of the variable onto the main stack.
;
;      2)   point to vrsto (second word of vrblk) to store the
;	    top stack element as the value of the variable.
;
;      3)   point to vrtra (fourth word of vrblk) to jump to
;	    the label associated with the variable name.
;
;	    +------------------------------------+
;	    i		     vrget		 i
;	    +------------------------------------+
;	    i		     vrsto		 i
;	    +------------------------------------+
;	    i		     vrval		 i
;	    +------------------------------------+
;	    i		     vrtra		 i
;	    +------------------------------------+
;	    i		     vrlbl		 i
;	    +------------------------------------+
;	    i		     vrfnc		 i
;	    +------------------------------------+
;	    i		     vrnxt		 i
;	    +------------------------------------+
;	    i		     vrlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		 vrchs = vrsvp		 /
;	    /					 /
;	    +------------------------------------+
||ejc||||| 4263
;
;      variable block (continued)
;
|vrget|equ|24,0|||; pointer to routine to load value| 4267
|vrsto|equ|24,vrget+1|||; pointer to routine to store value| 4268
|vrval|equ|24,vrsto+1|||; variable value| 4269
|vrvlo|equ|24,vrval-vrsto|||; offset to value from store field| 4270
|vrtra|equ|24,vrval+1|||; pointer to routine to jump to label| 4271
|vrlbl|equ|24,vrtra+1|||; pointer to code for label| 4272
|vrlbo|equ|24,vrlbl-vrtra|||; offset to label from transfer field| 4273
|vrfnc|equ|24,vrlbl+1|||; pointer to function block| 4274
|vrnxt|equ|24,vrfnc+1|||; pointer to next vrblk on hash chain| 4275
|vrlen|equ|24,vrnxt+1|||; length of name (or zero)| 4276
|vrchs|equ|24,vrlen+1|||; characters of name (vrlen gt 0)| 4277
|vrsvp|equ|24,vrlen+1|||; ptr to svblk (vrlen eq 0)| 4278
|vrsi_|equ|24,vrchs+1|||; number of standard fields in vrblk| 4279
|vrsof|equ|24,vrlen-sclen|||; offset to dummy scblk for name| 4280
|vrsvo|equ|24,vrsvp-vrsof|||; pseudo-offset to vrsvp field| 4281
;
;      vrget = b_vrl if not input associated or access traced
;      vrget = b_vra if input associated or access traced
;
;      vrsto = b_vrs if not output associated or value traced
;      vrsto = b_vrv if output associated or value traced
;      vrsto = b_vre if value is protected pattern value
;
;      vrval points to the appropriate value unless the
;      variable is i/o/trace associated in which case, vrval
;      points to an appropriate trblk (trap block) chain.
;
;      vrtra = b_vrg if the label is not traced
;      vrtra = b_vrt if the label is traced
;
;      vrlbl points to a cdblk if there is a label
;      vrlbl points to the svblk svlbl field for a system label
;      vrlbl points to stndl for an undefined label
;      vrlbl points to a trblk if the label is traced
;
;      vrfnc points to a ffblk for a field function
;      vrfnc points to a dfblk for a datatype function
;      vrfnc points to a pfblk for a program defined function
;      vrfnc points to a efblk for an external loaded function
;      vrfnc points to svfnc (svblk) for a system function
;      vrfnc points to stndf if the function is undefined
;
;      vrnxt points to the next vrblk on this chain unless
;      this is the end of the chain in which case it is zero.
;
;      vrlen is the name length for a non-system variable.
;      vrlen is zero for a system variable.
;
;      vrchs is the name (ljrz) if vrlen is non-zero.
;      vrsvp is a ptr to the svblk if vrlen is zero.
||ejc||||| 4317
;
;      format of a non-relocatable external block (xnblk)
;
;      an xnblk is a block representing an unknown (external)
;      data value. the block contains no pointers to other
;      relocatable blocks. an xnblk is used by external function
;      processing or possibly for system i/o routines etc.
;      the macro-system itself does not use xnblks.
;      this type of block may be used as a file control block.
;      see sysfc,sysin,sysou,s_inp,s_oup for details.
;
;	    +------------------------------------+
;	    i		     xntyp		 i
;	    +------------------------------------+
;	    i		     xnlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     xndta		 /
;	    /					 /
;	    +------------------------------------+
;
|xntyp|equ|24,0|||; pointer to dummy routine b_xnt| 4339
|xnlen|equ|24,xntyp+1|||; length of xnblk in bytes| 4340
|xndta|equ|24,xnlen+1|||; data words| 4341
|xnsi_|equ|24,xndta|||; size of standard fields in xnblk| 4342
;
;      note that the term non-relocatable refers to the contents
;      and not the block itself. an xnblk can be moved around if
;      it is built in the dynamic memory area.
||ejc||||| 4347
;
;      relocatable external block (xrblk)
;
;      an xrblk is a block representing an unknown (external)
;      data value. the data area in this block consists only
;      of address values and any addresses pointing into the
;      dynamic memory area must point to the start of other
;      data blocks. see also description of xnblk.
;      this type of block may be used as a file control block.
;      see sysfc,sysin,sysou,s_inp,s_oup for details.
;
;	    +------------------------------------+
;	    i		     xrtyp		 i
;	    +------------------------------------+
;	    i		     xrlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     xrptr		 /
;	    /					 /
;	    +------------------------------------+
;
|xrtyp|equ|24,0|||; pointer to dummy routine b_xrt| 4369
|xrlen|equ|24,xrtyp+1|||; length of xrblk in bytes| 4370
|xrptr|equ|24,xrlen+1|||; start of address pointers| 4371
|xrsi_|equ|24,xrptr|||; size of standard fields in xrblk| 4372
||ejc||||| 4373
;
;      s_cnv (convert) function switch constants.  the values
;      are tied to the order of the entries in the svctb table
;      and hence to the branch table in s_cnv.
;
|cnvst|equ|24,8|||; max standard type code for convert| 4379
|cnvrt|equ|24,cnvst+1|||; convert code for reals| 4383
|cnvbt|equ|24,cnvrt|||; no buffers - same as real code| 4386
|cnvtt|equ|24,cnvbt+1|||; bsw code for convert| 4390
;
;      input image length
;
|iniln|equ|24,1024|||; default image length for compiler| 4394
|inils|equ|24,1024|||; image length if -sequ in effect| 4395
;
|ionmb|equ|24,2|||; name base used for iochn in sysio| 4397
|ionmo|equ|24,4|||; name offset used for iochn in sysio| 4398
;
;      minimum value for keyword maxlngth
;      should be larger than iniln
;
|mnlen|equ|24,1024|||; min value allowed keyword maxlngth| 4403
|mxern|equ|24,329|||; err num inadequate startup memory| 4404
;
;      in general, meaningful mnemonics should be used for
;      offsets. however for small integers used often in
;      literals the following general definitions are provided.
;
|num01|equ|24,1|||;| 4410
|num02|equ|24,2|||;| 4411
|num03|equ|24,3|||;| 4412
|num04|equ|24,4|||;| 4413
|num05|equ|24,5|||;| 4414
|num06|equ|24,6|||;| 4415
|num07|equ|24,7|||;| 4416
|num08|equ|24,8|||;| 4417
|num09|equ|24,9|||;| 4418
|num10|equ|24,10|||;| 4419
|num25|equ|24,25|||;| 4420
|nm320|equ|24,320|||;| 4421
|nm321|equ|24,321|||;| 4422
|nini8|equ|24,998|||;| 4423
|nini9|equ|24,999|||;| 4424
|thsnd|equ|24,1000|||;| 4425
||ejc||||| 4426
;
;      numbers of undefined spitbol operators
;
|opbun|equ|24,5|||; no. of binary undefined ops| 4430
|opuun|equ|24,6|||; no of unary undefined ops| 4431
;
;      offsets used in prtsn, prtmi and acess
;
|prsnf|equ|24,13|||; offset used in prtsn| 4435
|prtmf|equ|24,21|||; offset to col 21 (prtmi)| 4436
|rilen|equ|24,1024|||; buffer length for sysri| 4437
;
;      codes for stages of processing
;
|stgic|equ|24,0|||; initial compile| 4441
|stgxc|equ|24,stgic+1|||; execution compile (code)| 4442
|stgev|equ|24,stgxc+1|||; expression eval during execution| 4443
|stgxt|equ|24,stgev+1|||; execution time| 4444
|stgce|equ|24,stgxt+1|||; initial compile after end line| 4445
|stgxe|equ|24,stgce+1|||; exec. compile after end line| 4446
|stgnd|equ|24,stgce-stgic|||; difference in stage after end| 4447
|stgee|equ|24,stgxe+1|||; eval evaluating expression| 4448
|stgno|equ|24,stgee+1|||; number of codes| 4449
||ejc||||| 4450
;
;
;      statement number pad count for listr
;
|stnpd|equ|24,8|||; statement no. pad count| 4459
;
;      syntax type codes
;
;      these codes are returned from the scane procedure.
;
;      they are spaced 3 apart for the benefit of expan.
;
|t_uop|equ|24,0|||; unary operator| 4471
|t_lpr|equ|24,t_uop+3|||; left paren| 4472
|t_lbr|equ|24,t_lpr+3|||; left bracket| 4473
|t_cma|equ|24,t_lbr+3|||; comma| 4474
|t_fnc|equ|24,t_cma+3|||; function call| 4475
|t_var|equ|24,t_fnc+3|||; variable| 4476
|t_con|equ|24,t_var+3|||; constant| 4477
|t_bop|equ|24,t_con+3|||; binary operator| 4478
|t_rpr|equ|24,t_bop+3|||; right paren| 4479
|t_rbr|equ|24,t_rpr+3|||; right bracket| 4480
|t_col|equ|24,t_rbr+3|||; colon| 4481
|t_smc|equ|24,t_col+3|||; semi-colon| 4482
;
;      the following definitions are used only in the goto field
;
|t_fgo|equ|24,t_smc+1|||; failure goto| 4486
|t_sgo|equ|24,t_fgo+1|||; success goto| 4487
;
;      the above codes are grouped so that codes for elements
;      which can legitimately immediately precede a unary
;      operator come first to facilitate operator syntax check.
;
|t_uok|equ|24,t_fnc|||; last code ok before unary operator| 4493
||ejc||||| 4494
;
;      definitions of values for expan jump table
;
|t_uo0|equ|24,t_uop+0|||; unary operator, state zero| 4498
|t_uo1|equ|24,t_uop+1|||; unary operator, state one| 4499
|t_uo2|equ|24,t_uop+2|||; unary operator, state two| 4500
|t_lp0|equ|24,t_lpr+0|||; left paren, state zero| 4501
|t_lp1|equ|24,t_lpr+1|||; left paren, state one| 4502
|t_lp2|equ|24,t_lpr+2|||; left paren, state two| 4503
|t_lb0|equ|24,t_lbr+0|||; left bracket, state zero| 4504
|t_lb1|equ|24,t_lbr+1|||; left bracket, state one| 4505
|t_lb2|equ|24,t_lbr+2|||; left bracket, state two| 4506
|t_cm0|equ|24,t_cma+0|||; comma, state zero| 4507
|t_cm1|equ|24,t_cma+1|||; comma, state one| 4508
|t_cm2|equ|24,t_cma+2|||; comma, state two| 4509
|t_fn0|equ|24,t_fnc+0|||; function call, state zero| 4510
|t_fn1|equ|24,t_fnc+1|||; function call, state one| 4511
|t_fn2|equ|24,t_fnc+2|||; function call, state two| 4512
|t_va0|equ|24,t_var+0|||; variable, state zero| 4513
|t_va1|equ|24,t_var+1|||; variable, state one| 4514
|t_va2|equ|24,t_var+2|||; variable, state two| 4515
|t_co0|equ|24,t_con+0|||; constant, state zero| 4516
|t_co1|equ|24,t_con+1|||; constant, state one| 4517
|t_co2|equ|24,t_con+2|||; constant, state two| 4518
|t_bo0|equ|24,t_bop+0|||; binary operator, state zero| 4519
|t_bo1|equ|24,t_bop+1|||; binary operator, state one| 4520
|t_bo2|equ|24,t_bop+2|||; binary operator, state two| 4521
|t_rp0|equ|24,t_rpr+0|||; right paren, state zero| 4522
|t_rp1|equ|24,t_rpr+1|||; right paren, state one| 4523
|t_rp2|equ|24,t_rpr+2|||; right paren, state two| 4524
|t_rb0|equ|24,t_rbr+0|||; right bracket, state zero| 4525
|t_rb1|equ|24,t_rbr+1|||; right bracket, state one| 4526
|t_rb2|equ|24,t_rbr+2|||; right bracket, state two| 4527
|t_cl0|equ|24,t_col+0|||; colon, state zero| 4528
|t_cl1|equ|24,t_col+1|||; colon, state one| 4529
|t_cl2|equ|24,t_col+2|||; colon, state two| 4530
|t_sm0|equ|24,t_smc+0|||; semicolon, state zero| 4531
|t_sm1|equ|24,t_smc+1|||; semicolon, state one| 4532
|t_sm2|equ|24,t_smc+2|||; semicolon, state two| 4533
;
|t_nes|equ|24,t_sm2+1|||; number of entries in branch table| 4535
||ejc||||| 4536
;
;	definition of offsets used in control card processing
;
|cc_ca|equ|24,0|||; -case| 4541
|cc_do|equ|24,cc_ca+1|||; -double| 4542
|cc_co|equ|24,cc_do+1|||; -compare| 4547
|cc_du|equ|24,cc_co+1|||; -dump| 4548
|cc_cp|equ|24,cc_du+1|||; -copy| 4553
|cc_ej|equ|24,cc_cp+1|||; -eject| 4554
|cc_er|equ|24,cc_ej+1|||; -errors| 4558
|cc_ex|equ|24,cc_er+1|||; -execute| 4559
|cc_fa|equ|24,cc_ex+1|||; -fail| 4560
|cc_in|equ|24,cc_fa+1|||; -include| 4562
|cc_ln|equ|24,cc_in+1|||; -line| 4564
|cc_li|equ|24,cc_ln+1|||; -list| 4565
|cc_nr|equ|24,cc_li+1|||; -noerrors| 4577
|cc_nx|equ|24,cc_nr+1|||; -noexecute| 4578
|cc_nf|equ|24,cc_nx+1|||; -nofail| 4579
|cc_nl|equ|24,cc_nf+1|||; -nolist| 4580
|cc_no|equ|24,cc_nl+1|||; -noopt| 4581
|cc_np|equ|24,cc_no+1|||; -noprint| 4582
|cc_op|equ|24,cc_np+1|||; -optimise| 4583
|cc_pr|equ|24,cc_op+1|||; -print| 4584
|cc_si|equ|24,cc_pr+1|||; -single| 4585
|cc_sp|equ|24,cc_si+1|||; -space| 4586
|cc_st|equ|24,cc_sp+1|||; -stitl| 4587
|cc_ti|equ|24,cc_st+1|||; -title| 4588
|cc_tr|equ|24,cc_ti+1|||; -trace| 4589
|cc_nc|equ|24,cc_tr+1|||; number of control cards| 4590
|ccnoc|equ|24,4|||; no. of chars included in match| 4591
|ccofs|equ|24,7|||; offset to start of title/subtitle| 4592
|ccinm|equ|24,9|||; max depth of include file nesting| 4594
||ejc||||| 4596
;
;      definitions of stack offsets used in cmpil procedure
;
;      see description at start of cmpil procedure for details
;      of use of these locations on the stack.
;
|cmstm|equ|24,0|||; tree for statement body| 4603
|cmsgo|equ|24,cmstm+1|||; tree for success goto| 4604
|cmfgo|equ|24,cmsgo+1|||; tree for fail goto| 4605
|cmcgo|equ|24,cmfgo+1|||; conditional goto flag| 4606
|cmpcd|equ|24,cmcgo+1|||; previous cdblk pointer| 4607
|cmffp|equ|24,cmpcd+1|||; failure fill in flag for previous| 4608
|cmffc|equ|24,cmffp+1|||; failure fill in flag for current| 4609
|cmsop|equ|24,cmffc+1|||; success fill in offset for previous| 4610
|cmsoc|equ|24,cmsop+1|||; success fill in offset for current| 4611
|cmlbl|equ|24,cmsoc+1|||; ptr to vrblk for current label| 4612
|cmtra|equ|24,cmlbl+1|||; ptr to entry cdblk| 4613
;
|cmnen|equ|24,cmtra+1|||; count of stack entries for cmpil| 4615
;
;      a few constants used by the profiler
|pfpd1|equ|24,8|||; pad positions ...| 4620
|pfpd2|equ|24,20|||; ... for profile ...| 4621
|pfpd3|equ|24,32|||; ... printout| 4622
|pf_i2|equ|24,cfp_i+cfp_i|||; size of table entry (2 ints)| 4623
||ejc||||| 4626
;
;      definition of limits and adjustments that are built by
;      relcr for use by the routines that relocate pointers
;      after a save file is reloaded.  see reloc etc. for usage.
;
;      a block of information is built that is used in
;      relocating pointers.  there are rnsi_ instances
;      of a rssi_ word structure.  each instance corresponds
;      to one of the regions that a pointer might point into.
;
;      each structure takes the form:
;
;	    +------------------------------------+
;	    i	 address past end of section	 i
;	    +------------------------------------+
;	    i  adjustment from old to new adrs	 i
;	    +------------------------------------+
;	    i	 address of start of section	 i
;	    +------------------------------------+
;
;      the instances are ordered thusly:
;
;	    +------------------------------------+
;	    i		dynamic storage		 i
;	    +------------------------------------+
;	    i		static storage		 i
;	    +------------------------------------+
;	    i	    working section globals	 i
;	    +------------------------------------+
;	    i	       constant section		 i
;	    +------------------------------------+
;	    i		 code section		 i
;	    +------------------------------------+
;
;      symbolic names for these locations as offsets from
;      the first entry are provided here.
;
;      definitions within a section
;
|rlend|equ|24,0|||; end| 4666
|rladj|equ|24,rlend+1|||; adjustment| 4667
|rlstr|equ|24,rladj+1|||; start| 4668
|rssi_|equ|24,rlstr+1|||; size of section| 4669
|rnsi_|equ|24,5|||; number of structures| 4670
;
;      overall definitions of all structures
;
|rldye|equ|24,0|||; dynamic region end| 4674
|rldya|equ|24,rldye+1|||; dynamic region adjustment| 4675
|rldys|equ|24,rldya+1|||; dynamic region start| 4676
|rlste|equ|24,rldys+1|||; static region end| 4677
|rlsta|equ|24,rlste+1|||; static region adjustment| 4678
|rlsts|equ|24,rlsta+1|||; static region start| 4679
|rlwke|equ|24,rlsts+1|||; working section globals end| 4680
|rlwka|equ|24,rlwke+1|||; working section globals adjustment| 4681
|rlwks|equ|24,rlwka+1|||; working section globals start| 4682
|rlcne|equ|24,rlwks+1|||; constants section end| 4683
|rlcna|equ|24,rlcne+1|||; constants section adjustment| 4684
|rlcns|equ|24,rlcna+1|||; constants section start| 4685
|rlcde|equ|24,rlcns+1|||; code section end| 4686
|rlcda|equ|24,rlcde+1|||; code section adjustment| 4687
|rlcds|equ|24,rlcda+1|||; code section start| 4688
|rlsi_|equ|24,rlcds+1|||; number of fields in structure| 4689
;
||ttl|27,s p i t b o l -- constant section|||| 4692
;
;      this section consists entirely of assembled constants.
;
;      all label names are five letters. the order is
;      approximately alphabetical, but in some cases (always
;      documented), constants must be placed in some special
;      order which must not be disturbed.
;
;      it must also be remembered that there is a requirement
;      for no forward references which also disturbs the
;      alphabetical order in some cases.
;
||sec||||; start of constant section| 4705
;
;      start of constant section
;
|c_aaa|dac|1,0|||; first location of constant section| 4709
;
;      free store percentage (used by alloc)
;
|alfsp|dac|2,e_fsp|||; free store percentage| 4713
;
;      bit constants for general use
;
|bits0|dbc|1,0|||; all zero bits| 4717
|bits1|dbc|1,1|||; one bit in low order position| 4718
|bits2|dbc|1,2|||; bit in position 2| 4719
|bits3|dbc|1,4|||; bit in position 3| 4720
|bits4|dbc|1,8|||; bit in position 4| 4721
|bits5|dbc|1,16|||; bit in position 5| 4722
|bits6|dbc|1,32|||; bit in position 6| 4723
|bits7|dbc|1,64|||; bit in position 7| 4724
|bits8|dbc|1,128|||; bit in position 8| 4725
|bits9|dbc|1,256|||; bit in position 9| 4726
|bit10|dbc|1,512|||; bit in position 10| 4727
|bit11|dbc|1,1024|||; bit in position 11| 4728
|bit12|dbc|1,2048|||; bit in position 12| 4729
;bitsm	dbc  cfp_m	      mask for max integer
|bitsm|dbc|1,0|||; mask for max integer (value filled in at runtime)| 4731
;
;      bit constants for svblk (svbit field) tests
;
|btfnc|dbc|2,svfnc|||; bit to test for function| 4735
|btknm|dbc|2,svknm|||; bit to test for keyword number| 4736
|btlbl|dbc|2,svlbl|||; bit to test for label| 4737
|btffc|dbc|2,svffc|||; bit to test for fast call| 4738
|btckw|dbc|2,svckw|||; bit to test for constant keyword| 4739
|btkwv|dbc|2,svkwv|||; bits to test for keword with value| 4740
|btprd|dbc|2,svprd|||; bit to test for predicate function| 4741
|btpre|dbc|2,svpre|||; bit to test for preevaluation| 4742
|btval|dbc|2,svval|||; bit to test for value| 4743
||ejc||||| 4744
;
;      list of names used for control card processing
;
|ccnms|dtc|27,/case/|||| 4749
||dtc|27,/doub/|||| 4750
||dtc|27,/comp/|||| 4755
||dtc|27,/dump/|||| 4757
||dtc|27,/copy/|||| 4759
||dtc|27,/ejec/|||| 4761
||dtc|27,/erro/|||| 4762
||dtc|27,/exec/|||| 4763
||dtc|27,/fail/|||| 4764
||dtc|27,/incl/|||| 4766
||dtc|27,/line/|||| 4769
||dtc|27,/list/|||| 4771
||dtc|27,/noer/|||| 4772
||dtc|27,/noex/|||| 4773
||dtc|27,/nofa/|||| 4774
||dtc|27,/noli/|||| 4775
||dtc|27,/noop/|||| 4776
||dtc|27,/nopr/|||| 4777
||dtc|27,/opti/|||| 4778
||dtc|27,/prin/|||| 4779
||dtc|27,/sing/|||| 4780
||dtc|27,/spac/|||| 4781
||dtc|27,/stit/|||| 4782
||dtc|27,/titl/|||| 4783
||dtc|27,/trac/|||| 4784
;
;      header messages for dumpr procedure (scblk format)
;
|dmhdk|dac|6,b_scl|||; dump of keyword values| 4788
||dac|1,22|||;| 4789
||dtc|27,/dump of keyword values/|||| 4790
;
|dmhdv|dac|6,b_scl|||; dump of natural variables| 4792
||dac|1,25|||;| 4793
||dtc|27,/dump of natural variables/|||| 4794
||ejc||||| 4795
;
;      message text for compilation statistics
;
|encm1|dac|6,b_scl|||;| 4799
||dac|1,19|||;| 4801
||dtc|27,/memory used (bytes)/|||| 4802
;
|encm2|dac|6,b_scl|||;| 4804
||dac|1,19|||;| 4805
||dtc|27,/memory left (bytes)/|||| 4806
;
|encm3|dac|6,b_scl|||;| 4816
||dac|1,11|||;| 4817
||dtc|27,/comp errors/|||| 4818
;
|encm4|dac|6,b_scl|||;| 4820
||dac|1,20|||;| 4825
||dtc|27,/comp time (millisec)/|||| 4826
;
|encm5|dac|6,b_scl|||; execution suppressed| 4829
||dac|1,20|||;| 4830
||dtc|27,/execution suppressed/|||| 4831
;
;      string constant for abnormal end
;
|endab|dac|6,b_scl|||;| 4835
||dac|1,12|||;| 4836
||dtc|27,/abnormal end/|||| 4837
||ejc||||| 4838
;
;      memory overflow during initialisation
;
|endmo|dac|6,b_scl|||;| 4842
|endml|dac|1,15|||;| 4843
||dtc|27,/memory overflow/|||| 4844
;
;      string constant for message issued by l_end
;
|endms|dac|6,b_scl|||;| 4848
||dac|1,10|||;| 4849
||dtc|27,/normal end/|||| 4850
;
;      fail message for stack fail section
;
|endso|dac|6,b_scl|||; stack overflow in garbage collector| 4854
||dac|1,36|||;| 4855
||dtc|27,/stack overflow in garbage collection/|||| 4856
;
;      string constant for time up
;
|endtu|dac|6,b_scl|||;| 4860
||dac|1,15|||;| 4861
||dtc|27,/error - time up/|||| 4862
||ejc||||| 4863
;
;      string constant for error message (error section)
;
|ermms|dac|6,b_scl|||; error| 4867
||dac|1,5|||;| 4868
||dtc|27,/error/|||| 4869
;
|ermns|dac|6,b_scl|||; string / -- /| 4871
||dac|1,4|||;| 4872
||dtc|27,/ -- /|||| 4873
;
;      string constant for page numbering
;
|lstms|dac|6,b_scl|||; page| 4877
||dac|1,5|||;| 4878
||dtc|27,/page /|||| 4879
;
;      listing header message
;
|headr|dac|6,b_scl|||;| 4883
||dac|1,27|||;| 4884
||dtc|27,/macro spitbol version 15.01/|||| 4885
;
|headv|dac|6,b_scl|||; for exit() version no. check| 4887
||dac|1,5|||;| 4888
||dtc|27,/15.01/|||| 4889
;      free store percentage (used by gbcol)
;
|gbsdp|dac|2,e_sed|||; sediment percentage| 4893
;
;      integer constants for general use
;      icbld optimisation uses the first three.
;
|int_r|dac|6,b_icl|||;| 4899
|intv0|dic|16,+0|||; 0| 4900
|inton|dac|6,b_icl|||;| 4901
|intv1|dic|16,+1|||; 1| 4902
|inttw|dac|6,b_icl|||;| 4903
|intv2|dic|16,+2|||; 2| 4904
|intvt|dic|16,+10|||; 10| 4905
|intvh|dic|16,+100|||; 100| 4906
|intth|dic|16,+1000|||; 1000| 4907
;
;      table used in icbld optimisation
;
|intab|dac|4,int_r|||; pointer to 0| 4911
||dac|4,inton|||; pointer to 1| 4912
||dac|4,inttw|||; pointer to 2| 4913
||ejc||||| 4914
;
;      special pattern nodes. the following pattern nodes
;      consist simply of a pcode pointer, see match routines
;      (p_xxx) for full details of their use and format).
;
|ndabb|dac|6,p_abb|||; arbno| 4920
|ndabd|dac|6,p_abd|||; arbno| 4921
|ndarc|dac|6,p_arc|||; arb| 4922
|ndexb|dac|6,p_exb|||; expression| 4923
|ndfnb|dac|6,p_fnb|||; fence()| 4924
|ndfnd|dac|6,p_fnd|||; fence()| 4925
|ndexc|dac|6,p_exc|||; expression| 4926
|ndimb|dac|6,p_imb|||; immediate assignment| 4927
|ndimd|dac|6,p_imd|||; immediate assignment| 4928
|ndnth|dac|6,p_nth|||; pattern end (null pattern)| 4929
|ndpab|dac|6,p_pab|||; pattern assignment| 4930
|ndpad|dac|6,p_pad|||; pattern assignment| 4931
|nduna|dac|6,p_una|||; anchor point movement| 4932
;
;      keyword constant pattern nodes. the following nodes are
;      used as the values of pattern keywords and the initial
;      values of the corresponding natural variables. all
;      nodes are in p0blk format and the order is tied to the
;      definitions of corresponding k_xxx symbols.
;
|ndabo|dac|6,p_abo|||; abort| 4940
||dac|4,ndnth|||;| 4941
|ndarb|dac|6,p_arb|||; arb| 4942
||dac|4,ndnth|||;| 4943
|ndbal|dac|6,p_bal|||; bal| 4944
||dac|4,ndnth|||;| 4945
|ndfal|dac|6,p_fal|||; fail| 4946
||dac|4,ndnth|||;| 4947
|ndfen|dac|6,p_fen|||; fence| 4948
||dac|4,ndnth|||;| 4949
|ndrem|dac|6,p_rem|||; rem| 4950
||dac|4,ndnth|||;| 4951
|ndsuc|dac|6,p_suc|||; succeed| 4952
||dac|4,ndnth|||;| 4953
;
;      null string. all null values point to this string. the
;      svchs field contains a blank to provide for easy default
;      processing in trace, stoptr, lpad and rpad.
;      nullw contains 10 blanks which ensures an all blank word
;      but for very exceptional machines.
;
|nulls|dac|6,b_scl|||; null string value| 4961
||dac|1,0|||; sclen = 0| 4962
|nullw|dtc|27,/          /|||| 4963
;
;
;      constant strings for lcase and ucase keywords
;
|lcase|dac|6,b_scl|||;| 4969
||dac|1,26|||;| 4970
||dtc|27,/abcdefghijklmnopqrstuvwxyz/|||| 4971
;
|ucase|dac|6,b_scl|||;| 4973
||dac|1,26|||;| 4974
||dtc|27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/|||| 4975
||ejc||||| 4977
;
;      operator dope vectors (see dvblk format)
;
|opdvc|dac|6,o_cnc|||; concatenation| 4981
||dac|2,c_cnc|||;| 4982
||dac|2,llcnc|||;| 4983
||dac|2,rrcnc|||;| 4984
;
;      opdvs is used when scanning below the top level to
;      insure that the concatenation will not be later
;      mistaken for pattern matching
;
|opdvp|dac|6,o_cnc|||; concatenation - not pattern match| 4990
||dac|2,c_cnp|||;| 4991
||dac|2,llcnc|||;| 4992
||dac|2,rrcnc|||;| 4993
;
;      note that the order of the remaining entries is tied to
;      the order of the coding in the scane procedure.
;
|opdvs|dac|6,o_ass|||; assignment| 4998
||dac|2,c_ass|||;| 4999
||dac|2,llass|||;| 5000
||dac|2,rrass|||;| 5001
;
||dac|1,6|||; unary equal| 5003
||dac|2,c_uuo|||;| 5004
||dac|2,lluno|||;| 5005
;
||dac|6,o_pmv|||; pattern match| 5007
||dac|2,c_pmt|||;| 5008
||dac|2,llpmt|||;| 5009
||dac|2,rrpmt|||;| 5010
;
||dac|6,o_int|||; interrogation| 5012
||dac|2,c_uvl|||;| 5013
||dac|2,lluno|||;| 5014
;
||dac|1,1|||; binary ampersand| 5016
||dac|2,c_ubo|||;| 5017
||dac|2,llamp|||;| 5018
||dac|2,rramp|||;| 5019
;
||dac|6,o_kwv|||; keyword reference| 5021
||dac|2,c_key|||;| 5022
||dac|2,lluno|||;| 5023
;
||dac|6,o_alt|||; alternation| 5025
||dac|2,c_alt|||;| 5026
||dac|2,llalt|||;| 5027
||dac|2,rralt|||;| 5028
||ejc||||| 5029
;
;      operator dope vectors (continued)
;
||dac|1,5|||; unary vertical bar| 5033
||dac|2,c_uuo|||;| 5034
||dac|2,lluno|||;| 5035
;
||dac|1,0|||; binary at| 5037
||dac|2,c_ubo|||;| 5038
||dac|2,llats|||;| 5039
||dac|2,rrats|||;| 5040
;
||dac|6,o_cas|||; cursor assignment| 5042
||dac|2,c_unm|||;| 5043
||dac|2,lluno|||;| 5044
;
||dac|1,2|||; binary number sign| 5046
||dac|2,c_ubo|||;| 5047
||dac|2,llnum|||;| 5048
||dac|2,rrnum|||;| 5049
;
||dac|1,7|||; unary number sign| 5051
||dac|2,c_uuo|||;| 5052
||dac|2,lluno|||;| 5053
;
||dac|6,o_dvd|||; division| 5055
||dac|2,c_bvl|||;| 5056
||dac|2,lldvd|||;| 5057
||dac|2,rrdvd|||;| 5058
;
||dac|1,9|||; unary slash| 5060
||dac|2,c_uuo|||;| 5061
||dac|2,lluno|||;| 5062
;
||dac|6,o_mlt|||; multiplication| 5064
||dac|2,c_bvl|||;| 5065
||dac|2,llmlt|||;| 5066
||dac|2,rrmlt|||;| 5067
||ejc||||| 5068
;
;      operator dope vectors (continued)
;
||dac|1,0|||; deferred expression| 5072
||dac|2,c_def|||;| 5073
||dac|2,lluno|||;| 5074
;
||dac|1,3|||; binary percent| 5076
||dac|2,c_ubo|||;| 5077
||dac|2,llpct|||;| 5078
||dac|2,rrpct|||;| 5079
;
||dac|1,8|||; unary percent| 5081
||dac|2,c_uuo|||;| 5082
||dac|2,lluno|||;| 5083
;
||dac|6,o_exp|||; exponentiation| 5085
||dac|2,c_bvl|||;| 5086
||dac|2,llexp|||;| 5087
||dac|2,rrexp|||;| 5088
;
||dac|1,10|||; unary exclamation| 5090
||dac|2,c_uuo|||;| 5091
||dac|2,lluno|||;| 5092
;
||dac|6,o_ima|||; immediate assignment| 5094
||dac|2,c_bvn|||;| 5095
||dac|2,lldld|||;| 5096
||dac|2,rrdld|||;| 5097
;
||dac|6,o_inv|||; indirection| 5099
||dac|2,c_ind|||;| 5100
||dac|2,lluno|||;| 5101
;
||dac|1,4|||; binary not| 5103
||dac|2,c_ubo|||;| 5104
||dac|2,llnot|||;| 5105
||dac|2,rrnot|||;| 5106
;
||dac|1,0|||; negation| 5108
||dac|2,c_neg|||;| 5109
||dac|2,lluno|||;| 5110
||ejc||||| 5111
;
;      operator dope vectors (continued)
;
||dac|6,o_sub|||; subtraction| 5115
||dac|2,c_bvl|||;| 5116
||dac|2,llplm|||;| 5117
||dac|2,rrplm|||;| 5118
;
||dac|6,o_com|||; complementation| 5120
||dac|2,c_uvl|||;| 5121
||dac|2,lluno|||;| 5122
;
||dac|6,o_add|||; addition| 5124
||dac|2,c_bvl|||;| 5125
||dac|2,llplm|||;| 5126
||dac|2,rrplm|||;| 5127
;
||dac|6,o_aff|||; affirmation| 5129
||dac|2,c_uvl|||;| 5130
||dac|2,lluno|||;| 5131
;
||dac|6,o_pas|||; pattern assignment| 5133
||dac|2,c_bvn|||;| 5134
||dac|2,lldld|||;| 5135
||dac|2,rrdld|||;| 5136
;
||dac|6,o_nam|||; name reference| 5138
||dac|2,c_unm|||;| 5139
||dac|2,lluno|||;| 5140
;
;      special dvs for goto operators (see procedure scngf)
;
|opdvd|dac|6,o_god|||; direct goto| 5144
||dac|2,c_uvl|||;| 5145
||dac|2,lluno|||;| 5146
;
|opdvn|dac|6,o_goc|||; complex normal goto| 5148
||dac|2,c_unm|||;| 5149
||dac|2,lluno|||;| 5150
||ejc||||| 5151
;
;      operator entry address pointers, used in code
;
|oamn_|dac|6,o_amn|||; array ref (multi-subs by value)| 5155
|oamv_|dac|6,o_amv|||; array ref (multi-subs by value)| 5156
|oaon_|dac|6,o_aon|||; array ref (one sub by name)| 5157
|oaov_|dac|6,o_aov|||; array ref (one sub by value)| 5158
|ocer_|dac|6,o_cer|||; compilation error| 5159
|ofex_|dac|6,o_fex|||; failure in expression evaluation| 5160
|ofif_|dac|6,o_fif|||; failure during goto evaluation| 5161
|ofnc_|dac|6,o_fnc|||; function call (more than one arg)| 5162
|ofne_|dac|6,o_fne|||; function name error| 5163
|ofns_|dac|6,o_fns|||; function call (single argument)| 5164
|ogof_|dac|6,o_gof|||; set goto failure trap| 5165
|oinn_|dac|6,o_inn|||; indirection by name| 5166
|okwn_|dac|6,o_kwn|||; keyword reference by name| 5167
|olex_|dac|6,o_lex|||; load expression by name| 5168
|olpt_|dac|6,o_lpt|||; load pattern| 5169
|olvn_|dac|6,o_lvn|||; load variable name| 5170
|onta_|dac|6,o_nta|||; negation, first entry| 5171
|ontb_|dac|6,o_ntb|||; negation, second entry| 5172
|ontc_|dac|6,o_ntc|||; negation, third entry| 5173
|opmn_|dac|6,o_pmn|||; pattern match by name| 5174
|opms_|dac|6,o_pms|||; pattern match (statement)| 5175
|opop_|dac|6,o_pop|||; pop top stack item| 5176
|ornm_|dac|6,o_rnm|||; return name from expression| 5177
|orpl_|dac|6,o_rpl|||; pattern replacement| 5178
|orvl_|dac|6,o_rvl|||; return value from expression| 5179
|osla_|dac|6,o_sla|||; selection, first entry| 5180
|oslb_|dac|6,o_slb|||; selection, second entry| 5181
|oslc_|dac|6,o_slc|||; selection, third entry| 5182
|osld_|dac|6,o_sld|||; selection, fourth entry| 5183
|ostp_|dac|6,o_stp|||; stop execution| 5184
|ounf_|dac|6,o_unf|||; unexpected failure| 5185
||ejc||||| 5186
;
;      table of names of undefined binary operators for opsyn
;
|opsnb|dac|2,ch_at|||; at| 5190
||dac|2,ch_am|||; ampersand| 5191
||dac|2,ch_nm|||; number| 5192
||dac|2,ch_pc|||; percent| 5193
||dac|2,ch_nt|||; not| 5194
;
;      table of names of undefined unary operators for opsyn
;
|opnsu|dac|2,ch_br|||; vertical bar| 5198
||dac|2,ch_eq|||; equal| 5199
||dac|2,ch_nm|||; number| 5200
||dac|2,ch_pc|||; percent| 5201
||dac|2,ch_sl|||; slash| 5202
||dac|2,ch_ex|||; exclamation| 5203
;
;      address const containing profile table entry size
;
|pfi2a|dac|2,pf_i2|||;| 5209
;
;      profiler message strings
;
|pfms1|dac|6,b_scl|||| 5213
||dac|1,15|||| 5214
||dtc|27,/program profile/|||| 5215
|pfms2|dac|6,b_scl|||| 5216
||dac|1,42|||| 5217
||dtc|27,/stmt    number of     -- execution time --/|||| 5218
|pfms3|dac|6,b_scl|||| 5219
||dac|1,47|||| 5220
||dtc|27,/number  executions  total(msec) per excn(mcsec)/|||| 5221
;
;
;      real constants for general use. note that the constants
;      starting at reav1 form a powers of ten table (used in
;      gtnum and gtstg)
;
|reav0|drc|17,+0.0|||; 0.0| 5231
|reap1|drc|17,+0.1|||; 0.1| 5234
|reap5|drc|17,+0.5|||; 0.5| 5235
|reav1|drc|17,+1.0|||; 10**0| 5237
|reavt|drc|17,+1.0e+1|||; 10**1| 5238
||drc|17,+1.0e+2|||; 10**2| 5239
||drc|17,+1.0e+3|||; 10**3| 5240
||drc|17,+1.0e+4|||; 10**4| 5241
||drc|17,+1.0e+5|||; 10**5| 5242
||drc|17,+1.0e+6|||; 10**6| 5243
||drc|17,+1.0e+7|||; 10**7| 5244
||drc|17,+1.0e+8|||; 10**8| 5245
||drc|17,+1.0e+9|||; 10**9| 5246
|reatt|drc|17,+1.0e+10|||; 10**10| 5247
||ejc||||| 5249
;
;      string constants (scblk format) for dtype procedure
;
|scarr|dac|6,b_scl|||; array| 5253
||dac|1,5|||;| 5254
||dtc|27,/array/|||| 5255
;
|sccod|dac|6,b_scl|||; code| 5264
||dac|1,4|||;| 5265
||dtc|27,/code/|||| 5266
;
|scexp|dac|6,b_scl|||; expression| 5268
||dac|1,10|||;| 5269
||dtc|27,/expression/|||| 5270
;
|scext|dac|6,b_scl|||; external| 5272
||dac|1,8|||;| 5273
||dtc|27,/external/|||| 5274
;
|scint|dac|6,b_scl|||; integer| 5276
||dac|1,7|||;| 5277
||dtc|27,/integer/|||| 5278
;
|scnam|dac|6,b_scl|||; name| 5280
||dac|1,4|||;| 5281
||dtc|27,/name/|||| 5282
;
|scnum|dac|6,b_scl|||; numeric| 5284
||dac|1,7|||;| 5285
||dtc|27,/numeric/|||| 5286
;
|scpat|dac|6,b_scl|||; pattern| 5288
||dac|1,7|||;| 5289
||dtc|27,/pattern/|||| 5290
;
|screa|dac|6,b_scl|||; real| 5294
||dac|1,4|||;| 5295
||dtc|27,/real/|||| 5296
;
|scstr|dac|6,b_scl|||; string| 5299
||dac|1,6|||;| 5300
||dtc|27,/string/|||| 5301
;
|sctab|dac|6,b_scl|||; table| 5303
||dac|1,5|||;| 5304
||dtc|27,/table/|||| 5305
|scfil|dac|6,b_scl|||; file (for extended load arguments)| 5307
||dac|1,4|||;| 5308
||dtc|27,/file/|||| 5309
||ejc||||| 5311
;
;      string constants (scblk format) for kvrtn (see retrn)
;
|scfrt|dac|6,b_scl|||; freturn| 5315
||dac|1,7|||;| 5316
||dtc|27,/freturn/|||| 5317
;
|scnrt|dac|6,b_scl|||; nreturn| 5319
||dac|1,7|||;| 5320
||dtc|27,/nreturn/|||| 5321
;
|scrtn|dac|6,b_scl|||; return| 5323
||dac|1,6|||;| 5324
||dtc|27,/return/|||| 5325
;
;      datatype name table for dtype procedure. the order of
;      these entries is tied to the b_xxx definitions for blocks
;
;      note that slots for buffer and real data types are filled
;      even if these data types are conditionalized out of the
;      implementation.	this is done so that the block numbering
;      at bl_ar etc. remains constant in all versions.
;
|scnmt|dac|4,scarr|||; arblk	    array| 5335
||dac|4,sccod|||; cdblk	    code| 5336
||dac|4,scexp|||; exblk	    expression| 5337
||dac|4,scint|||; icblk	    integer| 5338
||dac|4,scnam|||; nmblk	    name| 5339
||dac|4,scpat|||; p0blk	    pattern| 5340
||dac|4,scpat|||; p1blk	    pattern| 5341
||dac|4,scpat|||; p2blk	    pattern| 5342
||dac|4,screa|||; rcblk	    real| 5347
||dac|4,scstr|||; scblk	    string| 5349
||dac|4,scexp|||; seblk	    expression| 5350
||dac|4,sctab|||; tbblk	    table| 5351
||dac|4,scarr|||; vcblk	    array| 5352
||dac|4,scext|||; xnblk	    external| 5353
||dac|4,scext|||; xrblk	    external| 5354
||dac|4,nulls|||; bfblk	    no buffer in this version| 5356
;
;      string constant for real zero
;
|scre0|dac|6,b_scl|||;| 5365
||dac|1,2|||;| 5366
||dtc|27,/0./|||| 5367
||ejc||||| 5369
;
;      used to re-initialise kvstl
;
|stlim|dic|16,+2147483647|||; default statement limit| 5377
;
;      dummy function block used for undefined functions
;
|stndf|dac|6,o_fun|||; ptr to undefined function err call| 5385
||dac|1,0|||; dummy fargs count for call circuit| 5386
;
;      dummy code block used for undefined labels
;
|stndl|dac|6,l_und|||; code ptr points to undefined lbl| 5390
;
;      dummy operator block used for undefined operators
;
|stndo|dac|6,o_oun|||; ptr to undefined operator err call| 5394
||dac|1,0|||; dummy fargs count for call circuit| 5395
;
;      standard variable block. this block is used to initialize
;      the first seven fields of a newly constructed vrblk.
;      its format is tied to the vrblk definitions (see gtnvr).
;
|stnvr|dac|6,b_vrl|||; vrget| 5401
||dac|6,b_vrs|||; vrsto| 5402
||dac|4,nulls|||; vrval| 5403
||dac|6,b_vrg|||; vrtra| 5404
||dac|4,stndl|||; vrlbl| 5405
||dac|4,stndf|||; vrfnc| 5406
||dac|1,0|||; vrnxt| 5407
||ejc||||| 5408
;
;      messages used in end of run processing (stopr)
;
|stpm1|dac|6,b_scl|||; in statement| 5412
||dac|1,12|||;| 5413
||dtc|27,/in statement/|||| 5414
;
|stpm2|dac|6,b_scl|||;| 5416
||dac|1,14|||;| 5417
||dtc|27,/stmts executed/|||| 5418
;
|stpm3|dac|6,b_scl|||;| 5420
||dac|1,19|||;| 5425
||dtc|27,/run time (millisec)/|||| 5426
;
|stpm4|dac|6,b_scl|||;| 5429
||dac|1,12|||;| 5430
||dtc|27,_mcsec / stmt_|||| 5431
;
|stpm5|dac|6,b_scl|||;| 5433
||dac|1,13|||;| 5434
||dtc|27,/regenerations/|||| 5435
;
|stpm6|dac|6,b_scl|||; in line| 5438
||dac|1,7|||;| 5439
||dtc|27,/in line/|||| 5440
;
|stpm7|dac|6,b_scl|||; in file| 5444
||dac|1,7|||;| 5445
||dtc|27,/in file/|||| 5446
;
;      chars for /tu/ ending code
;
|strtu|dtc|27,/tu/|||| 5451
;
;      table used by convert function to check datatype name
;      the entries are ordered to correspond to branch table
;      in s_cnv
;
|svctb|dac|4,scstr|||; string| 5457
||dac|4,scint|||; integer| 5458
||dac|4,scnam|||; name| 5459
||dac|4,scpat|||; pattern| 5460
||dac|4,scarr|||; array| 5461
||dac|4,sctab|||; table| 5462
||dac|4,scexp|||; expression| 5463
||dac|4,sccod|||; code| 5464
||dac|4,scnum|||; numeric| 5465
||dac|4,screa|||; real| 5468
||dac|1,0|||; zero marks end of list| 5474
||ejc||||| 5475
;
;      messages (scblk format) used by trace procedures
;
;
|tmasb|dac|6,b_scl|||; asterisks for trace statement no| 5480
||dac|1,13|||;| 5481
||dtc|27,/************ /|||| 5482
;
|tmbeb|dac|6,b_scl|||; blank-equal-blank| 5485
||dac|1,3|||;| 5486
||dtc|27,/ = /|||| 5487
;
;      dummy trblk for expression variable
;
|trbev|dac|6,b_trt|||; dummy trblk| 5491
;
;      dummy trblk for keyword variable
;
|trbkv|dac|6,b_trt|||; dummy trblk| 5495
;
;      dummy code block to return control to trxeq procedure
;
|trxdr|dac|6,o_txr|||; block points to return routine| 5499
|trxdc|dac|4,trxdr|||; pointer to block| 5500
||ejc||||| 5501
;
;      standard variable blocks
;
;      see svblk format for full details of the format. the
;      vrblks are ordered by length and within each length the
;      order is alphabetical by name of the variable.
;
|v_eqf|dbc|2,svfpr|||; eq| 5509
||dac|1,2|||;| 5510
||dtc|27,/eq/|||| 5511
||dac|6,s_eqf|||;| 5512
||dac|1,2|||;| 5513
;
|v_gef|dbc|2,svfpr|||; ge| 5515
||dac|1,2|||;| 5516
||dtc|27,/ge/|||| 5517
||dac|6,s_gef|||;| 5518
||dac|1,2|||;| 5519
;
|v_gtf|dbc|2,svfpr|||; gt| 5521
||dac|1,2|||;| 5522
||dtc|27,/gt/|||| 5523
||dac|6,s_gtf|||;| 5524
||dac|1,2|||;| 5525
;
|v_lef|dbc|2,svfpr|||; le| 5527
||dac|1,2|||;| 5528
||dtc|27,/le/|||| 5529
||dac|6,s_lef|||;| 5530
||dac|1,2|||;| 5531
;
|v_lnf|dbc|2,svfnp|||; ln| 5534
||dac|1,2|||;| 5535
||dtc|27,/ln/|||| 5536
||dac|6,s_lnf|||;| 5537
||dac|1,1|||;| 5538
;
|v_ltf|dbc|2,svfpr|||; lt| 5541
||dac|1,2|||;| 5542
||dtc|27,/lt/|||| 5543
||dac|6,s_ltf|||;| 5544
||dac|1,2|||;| 5545
;
|v_nef|dbc|2,svfpr|||; ne| 5547
||dac|1,2|||;| 5548
||dtc|27,/ne/|||| 5549
||dac|6,s_nef|||;| 5550
||dac|1,2|||;| 5551
;
|v_any|dbc|2,svfnp|||; any| 5577
||dac|1,3|||;| 5578
||dtc|27,/any/|||| 5579
||dac|6,s_any|||;| 5580
||dac|1,1|||;| 5581
;
|v_arb|dbc|2,svkvc|||; arb| 5583
||dac|1,3|||;| 5584
||dtc|27,/arb/|||| 5585
||dac|2,k_arb|||;| 5586
||dac|4,ndarb|||;| 5587
||ejc||||| 5588
;
;      standard variable blocks (continued)
;
|v_arg|dbc|2,svfnn|||; arg| 5592
||dac|1,3|||;| 5593
||dtc|27,/arg/|||| 5594
||dac|6,s_arg|||;| 5595
||dac|1,2|||;| 5596
;
|v_bal|dbc|2,svkvc|||; bal| 5598
||dac|1,3|||;| 5599
||dtc|27,/bal/|||| 5600
||dac|2,k_bal|||;| 5601
||dac|4,ndbal|||;| 5602
;
|v_cos|dbc|2,svfnp|||; cos| 5605
||dac|1,3|||;| 5606
||dtc|27,/cos/|||| 5607
||dac|6,s_cos|||;| 5608
||dac|1,1|||;| 5609
;
|v_end|dbc|2,svlbl|||; end| 5612
||dac|1,3|||;| 5613
||dtc|27,/end/|||| 5614
||dac|6,l_end|||;| 5615
;
|v_exp|dbc|2,svfnp|||; exp| 5618
||dac|1,3|||;| 5619
||dtc|27,/exp/|||| 5620
||dac|6,s_exp|||;| 5621
||dac|1,1|||;| 5622
;
|v_len|dbc|2,svfnp|||; len| 5625
||dac|1,3|||;| 5626
||dtc|27,/len/|||| 5627
||dac|6,s_len|||;| 5628
||dac|1,1|||;| 5629
;
|v_leq|dbc|2,svfpr|||; leq| 5631
||dac|1,3|||;| 5632
||dtc|27,/leq/|||| 5633
||dac|6,s_leq|||;| 5634
||dac|1,2|||;| 5635
;
|v_lge|dbc|2,svfpr|||; lge| 5637
||dac|1,3|||;| 5638
||dtc|27,/lge/|||| 5639
||dac|6,s_lge|||;| 5640
||dac|1,2|||;| 5641
;
|v_lgt|dbc|2,svfpr|||; lgt| 5643
||dac|1,3|||;| 5644
||dtc|27,/lgt/|||| 5645
||dac|6,s_lgt|||;| 5646
||dac|1,2|||;| 5647
;
|v_lle|dbc|2,svfpr|||; lle| 5649
||dac|1,3|||;| 5650
||dtc|27,/lle/|||| 5651
||dac|6,s_lle|||;| 5652
||dac|1,2|||;| 5653
||ejc||||| 5654
;
;      standard variable blocks (continued)
;
|v_llt|dbc|2,svfpr|||; llt| 5658
||dac|1,3|||;| 5659
||dtc|27,/llt/|||| 5660
||dac|6,s_llt|||;| 5661
||dac|1,2|||;| 5662
;
|v_lne|dbc|2,svfpr|||; lne| 5664
||dac|1,3|||;| 5665
||dtc|27,/lne/|||| 5666
||dac|6,s_lne|||;| 5667
||dac|1,2|||;| 5668
;
|v_pos|dbc|2,svfnp|||; pos| 5670
||dac|1,3|||;| 5671
||dtc|27,/pos/|||| 5672
||dac|6,s_pos|||;| 5673
||dac|1,1|||;| 5674
;
|v_rem|dbc|2,svkvc|||; rem| 5676
||dac|1,3|||;| 5677
||dtc|27,/rem/|||| 5678
||dac|2,k_rem|||;| 5679
||dac|4,ndrem|||;| 5680
;
|v_set|dbc|2,svfnn|||; set| 5683
||dac|1,3|||;| 5684
||dtc|27,/set/|||| 5685
||dac|6,s_set|||;| 5686
||dac|1,3|||;| 5687
;
|v_sin|dbc|2,svfnp|||; sin| 5691
||dac|1,3|||;| 5692
||dtc|27,/sin/|||| 5693
||dac|6,s_sin|||;| 5694
||dac|1,1|||;| 5695
;
|v_tab|dbc|2,svfnp|||; tab| 5698
||dac|1,3|||;| 5699
||dtc|27,/tab/|||| 5700
||dac|6,s_tab|||;| 5701
||dac|1,1|||;| 5702
;
|v_tan|dbc|2,svfnp|||; tan| 5705
||dac|1,3|||;| 5706
||dtc|27,/tan/|||| 5707
||dac|6,s_tan|||;| 5708
||dac|1,1|||;| 5709
;
|v_atn|dbc|2,svfnp|||; atan| 5721
||dac|1,4|||;| 5722
||dtc|27,/atan/|||| 5723
||dac|6,s_atn|||;| 5724
||dac|1,1|||;| 5725
;
|v_cas|dbc|2,svknm|||; case| 5729
||dac|1,4|||;| 5730
||dtc|27,/case/|||| 5731
||dac|2,k_cas|||;| 5732
;
|v_chr|dbc|2,svfnp|||; char| 5735
||dac|1,4|||;| 5736
||dtc|27,/char/|||| 5737
||dac|6,s_chr|||;| 5738
||dac|1,1|||;| 5739
;
;
|v_chp|dbc|2,svfnp|||; chop| 5743
||dac|1,4|||;| 5744
||dtc|27,/chop/|||| 5745
||dac|6,s_chp|||;| 5746
||dac|1,1|||;| 5747
|v_cod|dbc|2,svfnk|||; code| 5749
||dac|1,4|||;| 5750
||dtc|27,/code/|||| 5751
||dac|2,k_cod|||;| 5752
||dac|6,s_cod|||;| 5753
||dac|1,1|||;| 5754
;
|v_cop|dbc|2,svfnn|||; copy| 5756
||dac|1,4|||;| 5757
||dtc|27,/copy/|||| 5758
||dac|6,s_cop|||;| 5759
||dac|1,1|||;| 5760
||ejc||||| 5761
;
;      standard variable blocks (continued)
;
|v_dat|dbc|2,svfnn|||; data| 5765
||dac|1,4|||;| 5766
||dtc|27,/data/|||| 5767
||dac|6,s_dat|||;| 5768
||dac|1,1|||;| 5769
;
|v_dte|dbc|2,svfnn|||; date| 5771
||dac|1,4|||;| 5772
||dtc|27,/date/|||| 5773
||dac|6,s_dte|||;| 5774
||dac|1,1|||;| 5775
;
|v_dmp|dbc|2,svfnk|||; dump| 5777
||dac|1,4|||;| 5778
||dtc|27,/dump/|||| 5779
||dac|2,k_dmp|||;| 5780
||dac|6,s_dmp|||;| 5781
||dac|1,1|||;| 5782
;
|v_dup|dbc|2,svfnn|||; dupl| 5784
||dac|1,4|||;| 5785
||dtc|27,/dupl/|||| 5786
||dac|6,s_dup|||;| 5787
||dac|1,2|||;| 5788
;
|v_evl|dbc|2,svfnn|||; eval| 5790
||dac|1,4|||;| 5791
||dtc|27,/eval/|||| 5792
||dac|6,s_evl|||;| 5793
||dac|1,1|||;| 5794
;
|v_ext|dbc|2,svfnn|||; exit| 5798
||dac|1,4|||;| 5799
||dtc|27,/exit/|||| 5800
||dac|6,s_ext|||;| 5801
||dac|1,2|||;| 5802
;
|v_fal|dbc|2,svkvc|||; fail| 5805
||dac|1,4|||;| 5806
||dtc|27,/fail/|||| 5807
||dac|2,k_fal|||;| 5808
||dac|4,ndfal|||;| 5809
;
|v_fil|dbc|2,svknm|||; file| 5812
||dac|1,4|||;| 5813
||dtc|27,/file/|||| 5814
||dac|2,k_fil|||;| 5815
;
|v_hst|dbc|2,svfnn|||; host| 5818
||dac|1,4|||;| 5819
||dtc|27,/host/|||| 5820
||dac|6,s_hst|||;| 5821
||dac|1,5|||;| 5822
||ejc||||| 5823
;
;      standard variable blocks (continued)
;
|v_itm|dbc|2,svfnf|||; item| 5827
||dac|1,4|||;| 5828
||dtc|27,/item/|||| 5829
||dac|6,s_itm|||;| 5830
||dac|1,999|||;| 5831
;
|v_lin|dbc|2,svknm|||; line| 5834
||dac|1,4|||;| 5835
||dtc|27,/line/|||| 5836
||dac|2,k_lin|||;| 5837
;
|v_lod|dbc|2,svfnn|||; load| 5842
||dac|1,4|||;| 5843
||dtc|27,/load/|||| 5844
||dac|6,s_lod|||;| 5845
||dac|1,2|||;| 5846
;
|v_lpd|dbc|2,svfnp|||; lpad| 5849
||dac|1,4|||;| 5850
||dtc|27,/lpad/|||| 5851
||dac|6,s_lpd|||;| 5852
||dac|1,3|||;| 5853
;
|v_rpd|dbc|2,svfnp|||; rpad| 5855
||dac|1,4|||;| 5856
||dtc|27,/rpad/|||| 5857
||dac|6,s_rpd|||;| 5858
||dac|1,3|||;| 5859
;
|v_rps|dbc|2,svfnp|||; rpos| 5861
||dac|1,4|||;| 5862
||dtc|27,/rpos/|||| 5863
||dac|6,s_rps|||;| 5864
||dac|1,1|||;| 5865
;
|v_rtb|dbc|2,svfnp|||; rtab| 5867
||dac|1,4|||;| 5868
||dtc|27,/rtab/|||| 5869
||dac|6,s_rtb|||;| 5870
||dac|1,1|||;| 5871
;
|v_si_|dbc|2,svfnp|||; size| 5873
||dac|1,4|||;| 5874
||dtc|27,/size/|||| 5875
||dac|6,s_si_|||;| 5876
||dac|1,1|||;| 5877
;
;
|v_srt|dbc|2,svfnn|||; sort| 5882
||dac|1,4|||;| 5883
||dtc|27,/sort/|||| 5884
||dac|6,s_srt|||;| 5885
||dac|1,2|||;| 5886
|v_spn|dbc|2,svfnp|||; span| 5888
||dac|1,4|||;| 5889
||dtc|27,/span/|||| 5890
||dac|6,s_spn|||;| 5891
||dac|1,1|||;| 5892
||ejc||||| 5893
;
;      standard variable blocks (continued)
;
;
|v_sqr|dbc|2,svfnp|||; sqrt| 5899
||dac|1,4|||;| 5900
||dtc|27,/sqrt/|||| 5901
||dac|6,s_sqr|||;| 5902
||dac|1,1|||;| 5903
|v_stn|dbc|2,svknm|||; stno| 5905
||dac|1,4|||;| 5906
||dtc|27,/stno/|||| 5907
||dac|2,k_stn|||;| 5908
;
|v_tim|dbc|2,svfnn|||; time| 5910
||dac|1,4|||;| 5911
||dtc|27,/time/|||| 5912
||dac|6,s_tim|||;| 5913
||dac|1,0|||;| 5914
;
|v_trm|dbc|2,svfnk|||; trim| 5916
||dac|1,4|||;| 5917
||dtc|27,/trim/|||| 5918
||dac|2,k_trm|||;| 5919
||dac|6,s_trm|||;| 5920
||dac|1,1|||;| 5921
;
|v_abe|dbc|2,svknm|||; abend| 5923
||dac|1,5|||;| 5924
||dtc|27,/abend/|||| 5925
||dac|2,k_abe|||;| 5926
;
|v_abo|dbc|2,svkvl|||; abort| 5928
||dac|1,5|||;| 5929
||dtc|27,/abort/|||| 5930
||dac|2,k_abo|||;| 5931
||dac|6,l_abo|||;| 5932
||dac|4,ndabo|||;| 5933
;
|v_app|dbc|2,svfnf|||; apply| 5935
||dac|1,5|||;| 5936
||dtc|27,/apply/|||| 5937
||dac|6,s_app|||;| 5938
||dac|1,999|||;| 5939
;
|v_abn|dbc|2,svfnp|||; arbno| 5941
||dac|1,5|||;| 5942
||dtc|27,/arbno/|||| 5943
||dac|6,s_abn|||;| 5944
||dac|1,1|||;| 5945
;
|v_arr|dbc|2,svfnn|||; array| 5947
||dac|1,5|||;| 5948
||dtc|27,/array/|||| 5949
||dac|6,s_arr|||;| 5950
||dac|1,2|||;| 5951
||ejc||||| 5952
;
;      standard variable blocks (continued)
;
|v_brk|dbc|2,svfnp|||; break| 5956
||dac|1,5|||;| 5957
||dtc|27,/break/|||| 5958
||dac|6,s_brk|||;| 5959
||dac|1,1|||;| 5960
;
|v_clr|dbc|2,svfnn|||; clear| 5962
||dac|1,5|||;| 5963
||dtc|27,/clear/|||| 5964
||dac|6,s_clr|||;| 5965
||dac|1,1|||;| 5966
;
|v_ejc|dbc|2,svfnn|||; eject| 5976
||dac|1,5|||;| 5977
||dtc|27,/eject/|||| 5978
||dac|6,s_ejc|||;| 5979
||dac|1,1|||;| 5980
;
|v_fen|dbc|2,svfpk|||; fence| 5982
||dac|1,5|||;| 5983
||dtc|27,/fence/|||| 5984
||dac|2,k_fen|||;| 5985
||dac|6,s_fnc|||;| 5986
||dac|1,1|||;| 5987
||dac|4,ndfen|||;| 5988
;
|v_fld|dbc|2,svfnn|||; field| 5990
||dac|1,5|||;| 5991
||dtc|27,/field/|||| 5992
||dac|6,s_fld|||;| 5993
||dac|1,2|||;| 5994
;
|v_idn|dbc|2,svfpr|||; ident| 5996
||dac|1,5|||;| 5997
||dtc|27,/ident/|||| 5998
||dac|6,s_idn|||;| 5999
||dac|1,2|||;| 6000
;
|v_inp|dbc|2,svfnk|||; input| 6002
||dac|1,5|||;| 6003
||dtc|27,/input/|||| 6004
||dac|2,k_inp|||;| 6005
||dac|6,s_inp|||;| 6006
||dac|1,3|||;| 6007
;
|v_lcs|dbc|2,svkwc|||; lcase| 6010
||dac|1,5|||;| 6011
||dtc|27,/lcase/|||| 6012
||dac|2,k_lcs|||;| 6013
;
|v_loc|dbc|2,svfnn|||; local| 6016
||dac|1,5|||;| 6017
||dtc|27,/local/|||| 6018
||dac|6,s_loc|||;| 6019
||dac|1,2|||;| 6020
||ejc||||| 6021
;
;      standard variable blocks (continued)
;
|v_ops|dbc|2,svfnn|||; opsyn| 6025
||dac|1,5|||;| 6026
||dtc|27,/opsyn/|||| 6027
||dac|6,s_ops|||;| 6028
||dac|1,3|||;| 6029
;
|v_rmd|dbc|2,svfnp|||; remdr| 6031
||dac|1,5|||;| 6032
||dtc|27,/remdr/|||| 6033
||dac|6,s_rmd|||;| 6034
||dac|1,2|||;| 6035
;
|v_rsr|dbc|2,svfnn|||; rsort| 6039
||dac|1,5|||;| 6040
||dtc|27,/rsort/|||| 6041
||dac|6,s_rsr|||;| 6042
||dac|1,2|||;| 6043
;
|v_tbl|dbc|2,svfnn|||; table| 6046
||dac|1,5|||;| 6047
||dtc|27,/table/|||| 6048
||dac|6,s_tbl|||;| 6049
||dac|1,3|||;| 6050
;
|v_tra|dbc|2,svfnk|||; trace| 6052
||dac|1,5|||;| 6053
||dtc|27,/trace/|||| 6054
||dac|2,k_tra|||;| 6055
||dac|6,s_tra|||;| 6056
||dac|1,4|||;| 6057
;
|v_ucs|dbc|2,svkwc|||; ucase| 6060
||dac|1,5|||;| 6061
||dtc|27,/ucase/|||| 6062
||dac|2,k_ucs|||;| 6063
;
|v_anc|dbc|2,svknm|||; anchor| 6066
||dac|1,6|||;| 6067
||dtc|27,/anchor/|||| 6068
||dac|2,k_anc|||;| 6069
;
|v_bkx|dbc|2,svfnp|||; breakx| 6080
||dac|1,6|||;| 6081
||dtc|27,/breakx/|||| 6082
||dac|6,s_bkx|||;| 6083
||dac|1,1|||;| 6084
;
;
|v_def|dbc|2,svfnn|||; define| 6095
||dac|1,6|||;| 6096
||dtc|27,/define/|||| 6097
||dac|6,s_def|||;| 6098
||dac|1,2|||;| 6099
;
|v_det|dbc|2,svfnn|||; detach| 6101
||dac|1,6|||;| 6102
||dtc|27,/detach/|||| 6103
||dac|6,s_det|||;| 6104
||dac|1,1|||;| 6105
||ejc||||| 6106
;
;      standard variable blocks (continued)
;
|v_dif|dbc|2,svfpr|||; differ| 6110
||dac|1,6|||;| 6111
||dtc|27,/differ/|||| 6112
||dac|6,s_dif|||;| 6113
||dac|1,2|||;| 6114
;
|v_ftr|dbc|2,svknm|||; ftrace| 6116
||dac|1,6|||;| 6117
||dtc|27,/ftrace/|||| 6118
||dac|2,k_ftr|||;| 6119
;
|v_lst|dbc|2,svknm|||; lastno| 6130
||dac|1,6|||;| 6131
||dtc|27,/lastno/|||| 6132
||dac|2,k_lst|||;| 6133
;
|v_nay|dbc|2,svfnp|||; notany| 6135
||dac|1,6|||;| 6136
||dtc|27,/notany/|||| 6137
||dac|6,s_nay|||;| 6138
||dac|1,1|||;| 6139
;
|v_oup|dbc|2,svfnk|||; output| 6141
||dac|1,6|||;| 6142
||dtc|27,/output/|||| 6143
||dac|2,k_oup|||;| 6144
||dac|6,s_oup|||;| 6145
||dac|1,3|||;| 6146
;
|v_ret|dbc|2,svlbl|||; return| 6148
||dac|1,6|||;| 6149
||dtc|27,/return/|||| 6150
||dac|6,l_rtn|||;| 6151
;
|v_rew|dbc|2,svfnn|||; rewind| 6153
||dac|1,6|||;| 6154
||dtc|27,/rewind/|||| 6155
||dac|6,s_rew|||;| 6156
||dac|1,1|||;| 6157
;
|v_stt|dbc|2,svfnn|||; stoptr| 6159
||dac|1,6|||;| 6160
||dtc|27,/stoptr/|||| 6161
||dac|6,s_stt|||;| 6162
||dac|1,2|||;| 6163
||ejc||||| 6164
;
;      standard variable blocks (continued)
;
|v_sub|dbc|2,svfnn|||; substr| 6168
||dac|1,6|||;| 6169
||dtc|27,/substr/|||| 6170
||dac|6,s_sub|||;| 6171
||dac|1,3|||;| 6172
;
|v_unl|dbc|2,svfnn|||; unload| 6174
||dac|1,6|||;| 6175
||dtc|27,/unload/|||| 6176
||dac|6,s_unl|||;| 6177
||dac|1,1|||;| 6178
;
|v_col|dbc|2,svfnn|||; collect| 6180
||dac|1,7|||;| 6181
||dtc|27,/collect/|||| 6182
||dac|6,s_col|||;| 6183
||dac|1,1|||;| 6184
;
|v_com|dbc|2,svknm|||; compare| 6187
||dac|1,7|||;| 6188
||dtc|27,/compare/|||| 6189
||dac|2,k_com|||;| 6190
;
|v_cnv|dbc|2,svfnn|||; convert| 6193
||dac|1,7|||;| 6194
||dtc|27,/convert/|||| 6195
||dac|6,s_cnv|||;| 6196
||dac|1,2|||;| 6197
;
|v_enf|dbc|2,svfnn|||; endfile| 6199
||dac|1,7|||;| 6200
||dtc|27,/endfile/|||| 6201
||dac|6,s_enf|||;| 6202
||dac|1,1|||;| 6203
;
|v_etx|dbc|2,svknm|||; errtext| 6205
||dac|1,7|||;| 6206
||dtc|27,/errtext/|||| 6207
||dac|2,k_etx|||;| 6208
;
|v_ert|dbc|2,svknm|||; errtype| 6210
||dac|1,7|||;| 6211
||dtc|27,/errtype/|||| 6212
||dac|2,k_ert|||;| 6213
;
|v_frt|dbc|2,svlbl|||; freturn| 6215
||dac|1,7|||;| 6216
||dtc|27,/freturn/|||| 6217
||dac|6,l_frt|||;| 6218
;
|v_int|dbc|2,svfpr|||; integer| 6220
||dac|1,7|||;| 6221
||dtc|27,/integer/|||| 6222
||dac|6,s_int|||;| 6223
||dac|1,1|||;| 6224
;
|v_nrt|dbc|2,svlbl|||; nreturn| 6226
||dac|1,7|||;| 6227
||dtc|27,/nreturn/|||| 6228
||dac|6,l_nrt|||;| 6229
||ejc||||| 6230
;
;      standard variable blocks (continued)
;
;
|v_pfl|dbc|2,svknm|||; profile| 6237
||dac|1,7|||;| 6238
||dtc|27,/profile/|||| 6239
||dac|2,k_pfl|||;| 6240
;
|v_rpl|dbc|2,svfnp|||; replace| 6243
||dac|1,7|||;| 6244
||dtc|27,/replace/|||| 6245
||dac|6,s_rpl|||;| 6246
||dac|1,3|||;| 6247
;
|v_rvs|dbc|2,svfnp|||; reverse| 6249
||dac|1,7|||;| 6250
||dtc|27,/reverse/|||| 6251
||dac|6,s_rvs|||;| 6252
||dac|1,1|||;| 6253
;
|v_rtn|dbc|2,svknm|||; rtntype| 6255
||dac|1,7|||;| 6256
||dtc|27,/rtntype/|||| 6257
||dac|2,k_rtn|||;| 6258
;
|v_stx|dbc|2,svfnn|||; setexit| 6260
||dac|1,7|||;| 6261
||dtc|27,/setexit/|||| 6262
||dac|6,s_stx|||;| 6263
||dac|1,1|||;| 6264
;
|v_stc|dbc|2,svknm|||; stcount| 6266
||dac|1,7|||;| 6267
||dtc|27,/stcount/|||| 6268
||dac|2,k_stc|||;| 6269
;
|v_stl|dbc|2,svknm|||; stlimit| 6271
||dac|1,7|||;| 6272
||dtc|27,/stlimit/|||| 6273
||dac|2,k_stl|||;| 6274
;
|v_suc|dbc|2,svkvc|||; succeed| 6276
||dac|1,7|||;| 6277
||dtc|27,/succeed/|||| 6278
||dac|2,k_suc|||;| 6279
||dac|4,ndsuc|||;| 6280
;
|v_alp|dbc|2,svkwc|||; alphabet| 6282
||dac|1,8|||;| 6283
||dtc|27,/alphabet/|||| 6284
||dac|2,k_alp|||;| 6285
;
|v_cnt|dbc|2,svlbl|||; continue| 6287
||dac|1,8|||;| 6288
||dtc|27,/continue/|||| 6289
||dac|6,l_cnt|||;| 6290
||ejc||||| 6291
;
;      standard variable blocks (continued)
;
|v_dtp|dbc|2,svfnp|||; datatype| 6295
||dac|1,8|||;| 6296
||dtc|27,/datatype/|||| 6297
||dac|6,s_dtp|||;| 6298
||dac|1,1|||;| 6299
;
|v_erl|dbc|2,svknm|||; errlimit| 6301
||dac|1,8|||;| 6302
||dtc|27,/errlimit/|||| 6303
||dac|2,k_erl|||;| 6304
;
|v_fnc|dbc|2,svknm|||; fnclevel| 6306
||dac|1,8|||;| 6307
||dtc|27,/fnclevel/|||| 6308
||dac|2,k_fnc|||;| 6309
;
|v_fls|dbc|2,svknm|||; fullscan| 6311
||dac|1,8|||;| 6312
||dtc|27,/fullscan/|||| 6313
||dac|2,k_fls|||;| 6314
;
|v_lfl|dbc|2,svknm|||; lastfile| 6317
||dac|1,8|||;| 6318
||dtc|27,/lastfile/|||| 6319
||dac|2,k_lfl|||;| 6320
;
|v_lln|dbc|2,svknm|||; lastline| 6324
||dac|1,8|||;| 6325
||dtc|27,/lastline/|||| 6326
||dac|2,k_lln|||;| 6327
;
|v_mxl|dbc|2,svknm|||; maxlngth| 6330
||dac|1,8|||;| 6331
||dtc|27,/maxlngth/|||| 6332
||dac|2,k_mxl|||;| 6333
;
|v_ter|dbc|1,0|||; terminal| 6335
||dac|1,8|||;| 6336
||dtc|27,/terminal/|||| 6337
||dac|1,0|||;| 6338
;
|v_bsp|dbc|2,svfnn|||; backspace| 6341
||dac|1,9|||;| 6342
||dtc|27,/backspace/|||| 6343
||dac|6,s_bsp|||;| 6344
||dac|1,1|||;| 6345
;
|v_pro|dbc|2,svfnn|||; prototype| 6348
||dac|1,9|||;| 6349
||dtc|27,/prototype/|||| 6350
||dac|6,s_pro|||;| 6351
||dac|1,1|||;| 6352
;
|v_scn|dbc|2,svlbl|||; scontinue| 6354
||dac|1,9|||;| 6355
||dtc|27,/scontinue/|||| 6356
||dac|6,l_scn|||;| 6357
;
||dbc|1,0|||; dummy entry to end list| 6359
||dac|1,10|||; length gt 9 (scontinue)| 6360
||ejc||||| 6361
;
;      list of svblk pointers for keywords to be dumped. the
;      list is in the order which appears on the dump output.
;
|vdmkw|dac|4,v_anc|||; anchor| 6366
||dac|4,v_cas|||; ccase| 6368
||dac|4,v_cod|||; code| 6370
||dac|1,1|||; compare not printed| 6375
||dac|4,v_dmp|||; dump| 6378
||dac|4,v_erl|||; errlimit| 6379
||dac|4,v_etx|||; errtext| 6380
||dac|4,v_ert|||; errtype| 6381
||dac|4,v_fil|||; file| 6383
||dac|4,v_fnc|||; fnclevel| 6385
||dac|4,v_ftr|||; ftrace| 6386
||dac|4,v_fls|||; fullscan| 6387
||dac|4,v_inp|||; input| 6388
||dac|4,v_lfl|||; lastfile| 6390
||dac|4,v_lln|||; lastline| 6393
||dac|4,v_lst|||; lastno| 6395
||dac|4,v_lin|||; line| 6397
||dac|4,v_mxl|||; maxlength| 6399
||dac|4,v_oup|||; output| 6400
||dac|4,v_pfl|||; profile| 6403
||dac|4,v_rtn|||; rtntype| 6405
||dac|4,v_stc|||; stcount| 6406
||dac|4,v_stl|||; stlimit| 6407
||dac|4,v_stn|||; stno| 6408
||dac|4,v_tra|||; trace| 6409
||dac|4,v_trm|||; trim| 6410
||dac|1,0|||; end of list| 6411
;
;      table used by gtnvr to search svblk lists
;
|vsrch|dac|1,0|||; dummy entry to get proper indexing| 6415
||dac|4,v_eqf|||; start of 1 char variables (none)| 6416
||dac|4,v_eqf|||; start of 2 char variables| 6417
||dac|4,v_any|||; start of 3 char variables| 6418
||dac|4,v_atn|||; start of 4 char variables| 6420
||dac|4,v_abe|||; start of 5 char variables| 6428
||dac|4,v_anc|||; start of 6 char variables| 6429
||dac|4,v_col|||; start of 7 char variables| 6430
||dac|4,v_alp|||; start of 8 char variables| 6431
||dac|4,v_bsp|||; start of 9 char variables| 6433
;
;      last location in constant section
;
|c_yyy|dac|1,0|||; last location in constant section| 6440
||ttl|27,s p i t b o l -- working storage section|||| 6441
;
;      the working storage section contains areas which are
;      changed during execution of the program. the value
;      assembled is the initial value before execution starts.
;
;      all these areas are fixed length areas. variable length
;      data is stored in the static or dynamic regions of the
;      allocated data areas.
;
;      the values in this area are described either as work
;      areas or as global values. a work area is used in an
;      ephemeral manner and the value is not saved from one
;      entry into a routine to another. a global value is a
;      less temporary location whose value is saved from one
;      call to another.
;
;      w_aaa marks the start of the working section whilst
;      w_yyy marks its end.  g_aaa marks the division between
;      temporary and global values.
;
;      global values are further subdivided to facilitate
;      processing by the garbage collector. r_aaa through
;      r_yyy are global values that may point into dynamic
;      storage and hence must be relocated after each garbage
;      collection.  they also serve as root pointers to all
;      allocated data that must be preserved.  pointers between
;      a_aaa and r_aaa may point into code, static storage,
;      or mark the limits of dynamic memory.  these pointers
;      must be adjusted when the working section is saved to a
;      file and subsequently reloaded at a different address.
;
;      a general part of the approach in this program is not
;      to overlap work areas between procedures even though a
;      small amount of space could be saved. such overlap is
;      considered a source of program errors and decreases the
;      information left behind after a system crash of any kind.
;
;      the names of these locations are labels with five letter
;      (a-y,_) names. as far as possible the order is kept
;      alphabetical by these names but in some cases there
;      are slight departures caused by other order requirements.
;
;      unless otherwise documented, the order of work areas
;      does not affect the execution of the spitbol program.
;
||sec||||; start of working storage section| 6487
||ejc||||| 6488
;
;      this area is not cleared by initial code
;
|cmlab|dac|6,b_scl|||; string used to check label legality| 6492
||dac|1,2|||;| 6493
||dtc|27,/  /|||| 6494
;
;      label to mark start of work area
;
|w_aaa|dac|1,0|||;| 6498
;
;      work areas for acess procedure
;
|actrm|dac|1,0|||; trim indicator| 6502
;
;      work areas for alloc procedure
;
|aldyn|dac|1,0|||; amount of dynamic store| 6506
|allia|dic|16,+0|||; dump ia| 6507
|allsv|dac|1,0|||; save wb in alloc| 6508
;
;      work areas for alost procedure
;
|alsta|dac|1,0|||; save wa in alost| 6512
;
;      work areas for array function (s_arr)
;
|arcdm|dac|1,0|||; count dimensions| 6516
|arnel|dic|16,+0|||; count elements| 6517
|arptr|dac|1,0|||; offset ptr into arblk| 6518
|arsvl|dic|16,+0|||; save integer low bound| 6519
||ejc||||| 6520
;
;      work areas for arref routine
;
|arfsi|dic|16,+0|||; save current evolving subscript| 6524
|arfxs|dac|1,0|||; save base stack pointer| 6525
;
;      work areas for b_efc block routine
;
|befof|dac|1,0|||; save offset ptr into efblk| 6529
;
;      work areas for b_pfc block routine
;
|bpfpf|dac|1,0|||; save pfblk pointer| 6533
|bpfsv|dac|1,0|||; save old function value| 6534
|bpfxt|dac|1,0|||; pointer to stacked arguments| 6535
;
;      work area for collect function (s_col)
;
|clsvi|dic|16,+0|||; save integer argument| 6539
;
;      work areas value for cncrd
;
|cnscc|dac|1,0|||; pointer to control card string| 6543
|cnswc|dac|1,0|||; word count| 6544
|cnr_t|dac|1,0|||; pointer to r_ttl or r_stl| 6545
;
;      work areas for convert function (s_cnv)
;
|cnvtp|dac|1,0|||; save ptr into scvtb| 6549
;
;      work areas for data function (s_dat)
;
|datdv|dac|1,0|||; save vrblk ptr for datatype name| 6553
|datxs|dac|1,0|||; save initial stack pointer| 6554
;
;      work areas for define function (s_def)
;
|deflb|dac|1,0|||; save vrblk ptr for label| 6558
|defna|dac|1,0|||; count function arguments| 6559
|defvr|dac|1,0|||; save vrblk ptr for function name| 6560
|defxs|dac|1,0|||; save initial stack pointer| 6561
;
;      work areas for dumpr procedure
;
|dmarg|dac|1,0|||; dump argument| 6565
|dmpsa|dac|1,0|||; preserve wa over prtvl call| 6566
|dmpsb|dac|1,0|||; preserve wb over syscm call| 6568
|dmpsv|dac|1,0|||; general scratch save| 6570
|dmvch|dac|1,0|||; chain pointer for variable blocks| 6571
|dmpch|dac|1,0|||; save sorted vrblk chain pointer| 6572
|dmpkb|dac|1,0|||; dummy kvblk for use in dumpr| 6573
|dmpkt|dac|1,0|||; kvvar trblk ptr (must follow dmpkb)| 6574
|dmpkn|dac|1,0|||; keyword number (must follow dmpkt)| 6575
;
;      work area for dtach
;
|dtcnb|dac|1,0|||; name base| 6579
|dtcnm|dac|1,0|||; name ptr| 6580
;
;      work areas for dupl function (s_dup)
;
|dupsi|dic|16,+0|||; store integer string length| 6584
;
;      work area for endfile (s_enf)
;
|enfch|dac|1,0|||; for iochn chain head| 6588
||ejc||||| 6589
;
;      work areas for ertex
;
|ertwa|dac|1,0|||; save wa| 6593
|ertwb|dac|1,0|||; save wb| 6594
;
;      work areas for evali
;
|evlin|dac|1,0|||; dummy pattern block pcode| 6598
|evlis|dac|1,0|||; then node (must follow evlin)| 6599
|evliv|dac|1,0|||; value of parm1 (must follow evlis)| 6600
|evlio|dac|1,0|||; ptr to original node| 6601
|evlif|dac|1,0|||; flag for simple/complex argument| 6602
;
;      work area for expan
;
|expsv|dac|1,0|||; save op dope vector pointer| 6606
;
;      work areas for gbcol procedure
;
|gbcfl|dac|1,0|||; garbage collector active flag| 6610
|gbclm|dac|1,0|||; pointer to last move block (pass 3)| 6611
|gbcnm|dac|1,0|||; dummy first move block| 6612
|gbcns|dac|1,0|||; rest of dummy block (follows gbcnm)| 6613
|gbcia|dic|16,+0|||; dump ia| 6619
|gbcsd|dac|1,0|||; first address beyond sediment| 6620
|gbcsf|dac|1,0|||; free space within sediment| 6621
|gbsva|dac|1,0|||; save wa| 6623
|gbsvb|dac|1,0|||; save wb| 6624
|gbsvc|dac|1,0|||; save wc| 6625
;
;      work areas for gtnvr procedure
;
|gnvhe|dac|1,0|||; ptr to end of hash chain| 6629
|gnvnw|dac|1,0|||; number of words in string name| 6630
|gnvsa|dac|1,0|||; save wa| 6631
|gnvsb|dac|1,0|||; save wb| 6632
|gnvsp|dac|1,0|||; pointer into vsrch table| 6633
|gnvst|dac|1,0|||; pointer to chars of string| 6634
;
;      work areas for gtarr
;
|gtawa|dac|1,0|||; save wa| 6638
;
;      work areas for gtint
;
|gtina|dac|1,0|||; save wa| 6642
|gtinb|dac|1,0|||; save wb| 6643
||ejc||||| 6644
;
;      work areas for gtnum procedure
;
|gtnnf|dac|1,0|||; zero/nonzero for result +/-| 6648
|gtnsi|dic|16,+0|||; general integer save| 6649
|gtndf|dac|1,0|||; 0/1 for dec point so far no/yes| 6652
|gtnes|dac|1,0|||; zero/nonzero exponent +/-| 6653
|gtnex|dic|16,+0|||; real exponent| 6654
|gtnsc|dac|1,0|||; scale (places after point)| 6655
|gtnsr|drc|17,+0.0|||; general real save| 6656
|gtnrd|dac|1,0|||; flag for ok real number| 6657
;
;      work areas for gtpat procedure
;
|gtpsb|dac|1,0|||; save wb| 6662
;
;      work areas for gtstg procedure
;
|gtssf|dac|1,0|||; 0/1 for result +/-| 6666
|gtsvc|dac|1,0|||; save wc| 6667
|gtsvb|dac|1,0|||; save wb| 6668
|gtses|dac|1,0|||; char + or - for exponent +/-| 6673
|gtsrs|drc|17,+0.0|||; general real save| 6674
;
;      work areas for gtvar procedure
;
|gtvrc|dac|1,0|||; save wc| 6680
;
;      work areas for ioput
;
|ioptt|dac|1,0|||; type of association| 6695
;
;      work areas for load function
;
|lodfn|dac|1,0|||; pointer to vrblk for func name| 6701
|lodna|dac|1,0|||; count number of arguments| 6702
;
;      mxint is value of maximum positive integer. it is computed at runtime to allow
;      the compilation of spitbol on a machine with smaller word size the the target.
;
|mxint|dac|1,0|||;| 6708
;
;      work area for profiler
;
|pfsvw|dac|1,0|||; to save a w-reg| 6714
;
;      work areas for prtnm procedure
;
|prnsi|dic|16,+0|||; scratch integer loc| 6719
;
;      work areas for prtsn procedure
;
|prsna|dac|1,0|||; save wa| 6723
;
;      work areas for prtst procedure
;
|prsva|dac|1,0|||; save wa| 6727
|prsvb|dac|1,0|||; save wb| 6728
|prsvc|dac|1,0|||; save char counter| 6729
;
;      work area for prtnl
;
|prtsa|dac|1,0|||; save wa| 6733
|prtsb|dac|1,0|||; save wb| 6734
;
;      work area for prtvl
;
|prvsi|dac|1,0|||; save idval| 6738
;
;      work areas for pattern match routines
;
|psave|dac|1,0|||; temporary save for current node ptr| 6742
|psavc|dac|1,0|||; save cursor in p_spn, p_str| 6743
;
;      work area for relaj routine
;
|rlals|dac|1,0|||; ptr to list of bounds and adjusts| 6748
;
;      work area for reldn routine
;
|rldcd|dac|1,0|||; save code adjustment| 6752
|rldst|dac|1,0|||; save static adjustment| 6753
|rldls|dac|1,0|||; save list pointer| 6754
;
;      work areas for retrn routine
;
|rtnbp|dac|1,0|||; to save a block pointer| 6759
|rtnfv|dac|1,0|||; new function value (result)| 6760
|rtnsv|dac|1,0|||; old function value (saved value)| 6761
;
;      work areas for substr function (s_sub)
;
|sbssv|dac|1,0|||; save third argument| 6765
;
;      work areas for scan procedure
;
|scnsa|dac|1,0|||; save wa| 6769
|scnsb|dac|1,0|||; save wb| 6770
|scnsc|dac|1,0|||; save wc| 6771
|scnof|dac|1,0|||; save offset| 6772
||ejc||||| 6775
;
;      work area used by sorta, sortc, sortf, sorth
;
|srtdf|dac|1,0|||; datatype field name| 6779
|srtfd|dac|1,0|||; found dfblk address| 6780
|srtff|dac|1,0|||; found field name| 6781
|srtfo|dac|1,0|||; offset to field name| 6782
|srtnr|dac|1,0|||; number of rows| 6783
|srtof|dac|1,0|||; offset within row to sort key| 6784
|srtrt|dac|1,0|||; root offset| 6785
|srts1|dac|1,0|||; save offset 1| 6786
|srts2|dac|1,0|||; save offset 2| 6787
|srtsc|dac|1,0|||; save wc| 6788
|srtsf|dac|1,0|||; sort array first row offset| 6789
|srtsn|dac|1,0|||; save n| 6790
|srtso|dac|1,0|||; offset to a(0)| 6791
|srtsr|dac|1,0|||; 0, non-zero for sort, rsort| 6792
|srtst|dac|1,0|||; stride from one row to next| 6793
|srtwc|dac|1,0|||; dump wc| 6794
;
;      work areas for stopr routine
;
|stpsi|dic|16,+0|||; save value of stcount| 6799
|stpti|dic|16,+0|||; save time elapsed| 6800
;
;      work areas for tfind procedure
;
|tfnsi|dic|16,+0|||; number of headers| 6804
;
;      work areas for xscan procedure
;
|xscrt|dac|1,0|||; save return code| 6808
|xscwb|dac|1,0|||; save register wb| 6809
;
;      start of global values in working section
;
|g_aaa|dac|1,0|||;| 6813
;
;      global value for alloc procedure
;
|alfsf|dic|16,+0|||; factor in free store pcntage check| 6817
;
;      global values for cmpil procedure
;
|cmerc|dac|1,0|||; count of initial compile errors| 6821
|cmpln|dac|1,0|||; line number of first line of stmt| 6822
|cmpxs|dac|1,0|||; save stack ptr in case of errors| 6823
|cmpsn|dac|1,1|||; number of next statement to compile| 6824
;
;      global values for cncrd
;
|cnsil|dac|1,0|||; save scnil during include process.| 6829
|cnind|dac|1,0|||; current include file nest level| 6830
|cnspt|dac|1,0|||; save scnpt during include process.| 6831
|cnttl|dac|1,0|||; flag for -title, -stitl| 6833
;
;      global flag for suppression of compilation statistics.
;
|cpsts|dac|1,0|||; suppress comp. stats if non zero| 6837
;
;      global values for control card switches
;
|cswdb|dac|1,0|||; 0/1 for -single/-double| 6841
|cswer|dac|1,0|||; 0/1 for -errors/-noerrors| 6842
|cswex|dac|1,0|||; 0/1 for -execute/-noexecute| 6843
|cswfl|dac|1,1|||; 0/1 for -nofail/-fail| 6844
|cswin|dac|2,iniln|||; xxx for -inxxx| 6845
|cswls|dac|1,1|||; 0/1 for -nolist/-list| 6846
|cswno|dac|1,0|||; 0/1 for -optimise/-noopt| 6847
|cswpr|dac|1,0|||; 0/1 for -noprint/-print| 6848
;
;      global location used by patst procedure
;
|ctmsk|dbc|1,0|||; last bit position used in r_ctp| 6852
|curid|dac|1,0|||; current id value| 6853
||ejc||||| 6854
;
;      global value for cdwrd procedure
;
|cwcof|dac|1,0|||; next word offset in current ccblk| 6858
;
;      global locations for dynamic storage pointers
;
|dnams|dac|1,0|||; size of sediment in baus| 6863
;
;      global area for error processing.
;
|erich|dac|1,0|||; copy error reports to int.chan if 1| 6868
|erlst|dac|1,0|||; for listr when errors go to int.ch.| 6869
|errft|dac|1,0|||; fatal error flag| 6870
|errsp|dac|1,0|||; error suppression flag| 6871
;
;      global flag for suppression of execution stats
;
|exsts|dac|1,0|||; suppress exec stats if set| 6875
;
;      global values for exfal and return
;
|flprt|dac|1,0|||; location of fail offset for return| 6879
|flptr|dac|1,0|||; location of failure offset on stack| 6880
;
;      global location to count garbage collections (gbcol)
;
|gbsed|dic|16,+0|||; factor in sediment pcntage check| 6885
|gbcnt|dac|1,0|||; count of garbage collections| 6887
;
;      global value for gtcod and gtexp
;
|gtcef|dac|1,0|||; save fail ptr in case of error| 6891
;
;      global locations for gtstg procedure
;
|gtsrn|drc|17,+0.0|||; rounding factor 0.5*10**-cfp_s| 6899
|gtssc|drc|17,+0.0|||; scaling value 10**cfp_s| 6900
|gtswk|dac|1,0|||; ptr to work area for gtstg| 6903
;
;      global flag for header printing
;
|headp|dac|1,0|||; header printed flag| 6907
;
;      global values for variable hash table
;
|hshnb|dic|16,+0|||; number of hash buckets| 6911
;
;      global areas for init
;
|initr|dac|1,0|||; save terminal flag| 6915
||ejc||||| 6916
;
;      global values for keyword values which are stored as one
;      word integers. these values must be assembled in the
;      following order (as dictated by k_xxx definition values).
;
|kvabe|dac|1,0|||; abend| 6922
|kvanc|dac|1,0|||; anchor| 6923
|kvcas|dac|1,0|||; case| 6925
|kvcod|dac|1,0|||; code| 6927
|kvcom|dac|1,0|||; compare| 6929
|kvdmp|dac|1,0|||; dump| 6931
|kverl|dac|1,0|||; errlimit| 6932
|kvert|dac|1,0|||; errtype| 6933
|kvftr|dac|1,0|||; ftrace| 6934
|kvfls|dac|1,1|||; fullscan| 6935
|kvinp|dac|1,1|||; input| 6936
|kvmxl|dac|1,5000|||; maxlength| 6937
|kvoup|dac|1,1|||; output| 6938
|kvpfl|dac|1,0|||; profile| 6941
|kvtra|dac|1,0|||; trace| 6943
|kvtrm|dac|1,0|||; trim| 6944
|kvfnc|dac|1,0|||; fnclevel| 6945
|kvlst|dac|1,0|||; lastno| 6946
|kvlln|dac|1,0|||; lastline| 6948
|kvlin|dac|1,0|||; line| 6949
|kvstn|dac|1,0|||; stno| 6951
;
;      global values for other keywords
;
|kvalp|dac|1,0|||; alphabet| 6955
|kvrtn|dac|4,nulls|||; rtntype (scblk pointer)| 6956
|kvstl|dic|16,+2147483647|||; stlimit| 6962
|kvstc|dic|16,+2147483647|||; stcount (counts down from stlimit)| 6963
;
;      global values for listr procedure
;
|lstid|dac|1,0|||; include depth of current image| 6973
|lstlc|dac|1,0|||; count lines on source list page| 6975
|lstnp|dac|1,0|||; max number of lines on page| 6976
|lstpf|dac|1,1|||; set nonzero if current image listed| 6977
|lstpg|dac|1,0|||; current source list page number| 6978
|lstpo|dac|1,0|||; offset to   page nnn	 message| 6979
|lstsn|dac|1,0|||; remember last stmnum listed| 6980
;
;      global maximum size of spitbol objects
;
|mxlen|dac|1,0|||; initialised by sysmx call| 6984
;
;      global execution control variable
;
|noxeq|dac|1,0|||; set non-zero to inhibit execution| 6988
;
;      global profiler values locations
;
|pfdmp|dac|1,0|||; set non-0 if &profile set non-0| 6994
|pffnc|dac|1,0|||; set non-0 if funct just entered| 6995
|pfstm|dic|16,+0|||; to store starting time of stmt| 6996
|pfetm|dic|16,+0|||; to store ending time of stmt| 6997
|pfnte|dac|1,0|||; nr of table entries| 6998
|pfste|dic|16,+0|||; gets int rep of table entry size| 6999
;
||ejc||||| 7002
;
;      global values used in pattern match routines
;
|pmdfl|dac|1,0|||; pattern assignment flag| 7006
|pmhbs|dac|1,0|||; history stack base pointer| 7007
|pmssl|dac|1,0|||; length of subject string in chars| 7008
;
;      global values for interface polling (syspl)
;
|polcs|dac|1,1|||; poll interval start value| 7013
|polct|dac|1,1|||; poll interval counter| 7014
;
;      global flags used for standard file listing options
;
|prich|dac|1,0|||; printer on interactive channel| 7019
|prstd|dac|1,0|||; tested by prtpg| 7020
|prsto|dac|1,0|||; standard listing option flag| 7021
;
;      global values for print procedures
;
|prbuf|dac|1,0|||; ptr to print bfr in static| 7025
|precl|dac|1,0|||; extended/compact listing flag| 7026
|prlen|dac|1,0|||; length of print buffer in chars| 7027
|prlnw|dac|1,0|||; length of print buffer in words| 7028
|profs|dac|1,0|||; offset to next location in prbuf| 7029
|prtef|dac|1,0|||; endfile flag| 7030
||ejc||||| 7031
;
;      global area for readr
;
|rdcln|dac|1,0|||; current statement line number| 7035
|rdnln|dac|1,0|||; next statement line number| 7036
;
;      global amount of memory reserved for end of execution
;
|rsmem|dac|1,0|||; reserve memory| 7040
;
;      global area for stmgo counters
;
|stmcs|dac|1,1|||; counter startup value| 7044
|stmct|dac|1,1|||; counter active value| 7045
;
;      adjustable global values
;
;      all the pointers in this section can point to the
;      dynamic or the static region.
;      when a save file is reloaded, these pointers must
;      be adjusted if static or dynamic memory is now
;      at a different address.	see routine reloc for
;      additional information.
;
;      some values cannot be move here because of adjacency
;      constraints.  they are handled specially by reloc et al.
;      these values are kvrtn,
;
;      values gtswk, kvalp, and prbuf are reinitialized by
;      procedure insta, and do not need to appear here.
;
;      values flprt, flptr, gtcef, and stbas point into the
;      stack and are explicitly adjusted by osint's restart
;      procedure.
;
|a_aaa|dac|1,0|||; start of adjustable values| 7067
|cmpss|dac|1,0|||; save subroutine stack ptr| 7068
|dnamb|dac|1,0|||; start of dynamic area| 7069
|dnamp|dac|1,0|||; next available loc in dynamic area| 7070
|dname|dac|1,0|||; end of available dynamic area| 7071
|hshtb|dac|1,0|||; pointer to start of vrblk hash tabl| 7072
|hshte|dac|1,0|||; pointer past end of vrblk hash tabl| 7073
|iniss|dac|1,0|||; save subroutine stack ptr| 7074
|pftbl|dac|1,0|||; gets adrs of (imag) table base| 7075
|prnmv|dac|1,0|||; vrblk ptr from last name search| 7076
|statb|dac|1,0|||; start of static area| 7077
|state|dac|1,0|||; end of static area| 7078
|stxvr|dac|4,nulls|||; vrblk pointer or null| 7079
;
;      relocatable global values
;
;      all the pointers in this section can point to blocks in
;      the dynamic storage area and must be relocated by the
;      garbage collector. they are identified by r_xxx names.
;
|r_aaa|dac|1,0|||; start of relocatable values| 7088
|r_arf|dac|1,0|||; array block pointer for arref| 7089
|r_ccb|dac|1,0|||; ptr to ccblk being built (cdwrd)| 7090
|r_cim|dac|1,0|||; ptr to current compiler input str| 7091
|r_cmp|dac|1,0|||; copy of r_cim used in cmpil| 7092
|r_cni|dac|1,0|||; ptr to next compiler input string| 7093
|r_cnt|dac|1,0|||; cdblk pointer for setexit continue| 7094
|r_cod|dac|1,0|||; pointer to current cdblk or exblk| 7095
|r_ctp|dac|1,0|||; ptr to current ctblk for patst| 7096
|r_cts|dac|1,0|||; ptr to last string scanned by patst| 7097
|r_ert|dac|1,0|||; trblk pointer for errtype trace| 7098
|r_etx|dac|4,nulls|||; pointer to errtext string| 7099
|r_exs|dac|1,0|||; = save xl in expdm| 7100
|r_fcb|dac|1,0|||; fcblk chain head| 7101
|r_fnc|dac|1,0|||; trblk pointer for fnclevel trace| 7102
|r_gtc|dac|1,0|||; keep code ptr for gtcod,gtexp| 7103
|r_ici|dac|1,0|||; saved r_cim during include process.| 7105
|r_ifa|dac|1,0|||; array of file names by incl. depth| 7107
|r_ifl|dac|1,0|||; array of line nums by include depth| 7108
|r_ifn|dac|1,0|||; last include file name| 7110
|r_inc|dac|1,0|||; table of include file names seen| 7111
|r_io1|dac|1,0|||; file arg1 for ioput| 7113
|r_io2|dac|1,0|||; file arg2 for ioput| 7114
|r_iof|dac|1,0|||; fcblk ptr or 0| 7115
|r_ion|dac|1,0|||; name base ptr| 7116
|r_iop|dac|1,0|||; predecessor block ptr for ioput| 7117
|r_iot|dac|1,0|||; trblk ptr for ioput| 7118
|r_pms|dac|1,0|||; subject string ptr in pattern match| 7123
|r_ra2|dac|1,0|||; replace second argument last time| 7124
|r_ra3|dac|1,0|||; replace third argument last time| 7125
|r_rpt|dac|1,0|||; ptr to ctblk replace table last usd| 7126
|r_scp|dac|1,0|||; save pointer from last scane call| 7127
|r_sfc|dac|4,nulls|||; current source file name| 7129
|r_sfn|dac|1,0|||; ptr to source file name table| 7130
|r_sxl|dac|1,0|||; preserve xl in sortc| 7132
|r_sxr|dac|1,0|||; preserve xr in sorta/sortc| 7133
|r_stc|dac|1,0|||; trblk pointer for stcount trace| 7134
|r_stl|dac|1,0|||; source listing sub-title| 7135
|r_sxc|dac|1,0|||; code (cdblk) ptr for setexit trap| 7136
|r_ttl|dac|4,nulls|||; source listing title| 7137
|r_xsc|dac|1,0|||; string pointer for xscan| 7138
||ejc||||| 7139
;
;      the remaining pointers in this list are used to point
;      to function blocks for normally undefined operators.
;
|r_uba|dac|4,stndo|||; binary at| 7144
|r_ubm|dac|4,stndo|||; binary ampersand| 7145
|r_ubn|dac|4,stndo|||; binary number sign| 7146
|r_ubp|dac|4,stndo|||; binary percent| 7147
|r_ubt|dac|4,stndo|||; binary not| 7148
|r_uub|dac|4,stndo|||; unary vertical bar| 7149
|r_uue|dac|4,stndo|||; unary equal| 7150
|r_uun|dac|4,stndo|||; unary number sign| 7151
|r_uup|dac|4,stndo|||; unary percent| 7152
|r_uus|dac|4,stndo|||; unary slash| 7153
|r_uux|dac|4,stndo|||; unary exclamation| 7154
|r_yyy|dac|1,0|||; last relocatable location| 7155
;
;      global locations used in scan procedure
;
|scnbl|dac|1,0|||; set non-zero if scanned past blanks| 7159
|scncc|dac|1,0|||; non-zero to scan control card name| 7160
|scngo|dac|1,0|||; set non-zero to scan goto field| 7161
|scnil|dac|1,0|||; length of current input image| 7162
|scnpt|dac|1,0|||; pointer to next location in r_cim| 7163
|scnrs|dac|1,0|||; set non-zero to signal rescan| 7164
|scnse|dac|1,0|||; start of current element| 7165
|scntp|dac|1,0|||; save syntax type from last call| 7166
;
;      global value for indicating stage (see error section)
;
|stage|dac|1,0|||; initial value = initial compile| 7170
||ejc||||| 7171
;
;      global stack pointer
;
|stbas|dac|1,0|||; pointer past stack base| 7175
;
;      global values for setexit function (s_stx)
;
|stxoc|dac|1,0|||; code pointer offset| 7179
|stxof|dac|1,0|||; failure offset| 7180
;
;      global value for time keeping
;
|timsx|dic|16,+0|||; time at start of execution| 7184
|timup|dac|1,0|||; set when time up occurs| 7185
;
;      global values for xscan and xscni procedures
;
|xsofs|dac|1,0|||; offset to current location in r_xsc| 7189
;
;      label to mark end of working section
;
|w_yyy|dac|1,0|||;| 7193
||ttl|27,s p i t b o l -- minimal code|||| 7194
||sec||||; start of program section| 7195
|s_aaa|ent|2,bl__i|||; mark start of code| 7196
||ttl|27,s p i t b o l -- relocation|||| 7198
;
;      relocation
;      the following section provides services to osint to
;      relocate portions of the workspace.  it is used when
;      a saved memory image must be restarted at a different
;      location.
;
;      relaj -- relocate a list of pointers
;
;      (wa)		     ptr past last pointer of list
;      (wb)		     ptr to first pointer of list
;      (xl)		     list of boundaries and adjustments
;      jsr  relaj	     call to process list of pointers
;      (wb)		     destroyed
;
|relaj|prc|25,e|1,0||; entry point| 7214
||mov|11,-(xs)|7,xr||; save xr| 7215
||mov|11,-(xs)|8,wa||; save wa| 7216
||mov|3,rlals|7,xl||; save ptr to list of bounds| 7217
||mov|7,xr|8,wb||; ptr to first pointer to process| 7218
;
;      merge here to check if done
;
|rlaj0|mov|7,xl|3,rlals||; restore xl| 7222
||bne|7,xr|9,(xs)|6,rlaj1|; proceed if more to do| 7223
||mov|8,wa|10,(xs)+||; restore wa| 7224
||mov|7,xr|10,(xs)+||; restore xr| 7225
||exi||||; return to caller| 7226
;
;      merge here to process next pointer on list
;
|rlaj1|mov|8,wa|9,(xr)||; load next pointer on list| 7230
||lct|8,wb|18,=rnsi_||; number of sections of adjusters| 7231
;
;      merge here to process next section of stack list
;
|rlaj2|bgt|8,wa|13,rlend(xl)|6,rlaj3|; ok if past end of section| 7235
||blt|8,wa|13,rlstr(xl)|6,rlaj3|; or if before start of section| 7236
||add|8,wa|13,rladj(xl)||; within section, add adjustment| 7237
||mov|9,(xr)|8,wa||; return updated ptr to memory| 7238
||brn|6,rlaj4|||; done with this pointer| 7239
;
;      here if not within section
;
|rlaj3|add|7,xl|19,*rssi_||; advance to next section| 7243
||bct|8,wb|6,rlaj2||; jump if more to go| 7244
;
;      here when finished processing one pointer
;
|rlaj4|ica|7,xr|||; increment to next ptr on list| 7248
||brn|6,rlaj0|||; jump to check	 for completion| 7249
||enp||||; end procedure relaj| 7250
||ejc||||| 7251
;
;      relcr -- create relocation info after save file reload
;
;      (wa)		     original s_aaa code section adr
;      (wb)		     original c_aaa constant section adr
;      (wc)		     original g_aaa working section adr
;      (xr)		     ptr to start of static region
;      (cp)		     ptr to start of dynamic region
;      (xl)		     ptr to area to receive information
;      jsr  relcr	     create relocation information
;      (wa,wb,wc,xr)	     destroyed
;
;      a block of information is built at (xl) that is used
;      in relocating pointers.	there are rnsi_ instances
;      of a rssi_ word structure.  each instance corresponds
;      to one of the regions that a pointer might point into.
;      the layout of this structure is shown in the definitions
;      section, together with symbolic definitions of the
;      entries as offsets from xl.
;
|relcr|prc|25,e|1,0||; entry point| 7272
||add|7,xl|19,*rlsi_||; point past build area| 7273
||mov|11,-(xl)|8,wa||; save original code address| 7274
||mov|8,wa|22,=s_aaa||; compute adjustment| 7275
||sub|8,wa|9,(xl)||; as new s_aaa minus original s_aaa| 7276
||mov|11,-(xl)|8,wa||; save code adjustment| 7277
||mov|8,wa|22,=s_yyy||; end of target code section| 7278
||sub|8,wa|22,=s_aaa||; length of code section| 7279
||add|8,wa|13,num01(xl)||; plus original start address| 7280
||mov|11,-(xl)|8,wa||; end of original code section| 7281
||mov|11,-(xl)|8,wb||; save constant section address| 7282
||mov|8,wb|21,=c_aaa||; start of constants section| 7283
||mov|8,wa|21,=c_yyy||; end of constants section| 7284
||sub|8,wa|8,wb||; length of constants section| 7285
||sub|8,wb|9,(xl)||; new c_aaa minus original c_aaa| 7286
||mov|11,-(xl)|8,wb||; save constant adjustment| 7287
||add|8,wa|13,num01(xl)||; length plus original start adr| 7288
||mov|11,-(xl)|8,wa||; save as end of original constants| 7289
||mov|11,-(xl)|8,wc||; save working globals address| 7290
||mov|8,wc|20,=g_aaa||; start of working globals section| 7291
||mov|8,wa|20,=w_yyy||; end of working section| 7292
||sub|8,wa|8,wc||; length of working globals| 7293
||sub|8,wc|9,(xl)||; new g_aaa minus original g_aaa| 7294
||mov|11,-(xl)|8,wc||; save working globals adjustment| 7295
||add|8,wa|13,num01(xl)||; length plus original start adr| 7296
||mov|11,-(xl)|8,wa||; save as end of working globals| 7297
||mov|8,wb|3,statb||; old start of static region| 7298
||mov|11,-(xl)|8,wb||; save| 7299
||sub|7,xr|8,wb||; compute adjustment| 7300
||mov|11,-(xl)|7,xr||; save new statb minus old statb| 7301
||mov|11,-(xl)|3,state||; old end of static region| 7302
||mov|8,wb|3,dnamb||; old start of dynamic region| 7303
||mov|11,-(xl)|8,wb||; save| 7304
||scp|8,wa|||; new start of dynamic| 7305
||sub|8,wa|8,wb||; compute adjustment| 7306
||mov|11,-(xl)|8,wa||; save new dnamb minus old dnamb| 7307
||mov|8,wc|3,dnamp||; old end of dynamic region in use| 7308
||mov|11,-(xl)|8,wc||; save as end of old dynamic region| 7309
||exi||||| 7310
||enp||||| 7311
||ejc||||| 7312
;
;      reldn -- relocate pointers in the dynamic region
;
;      (xl)		     list of boundaries and adjustments
;      (xr)		     ptr to first location to process
;      (wc)		     ptr past last location to process
;      jsr  reldn	     call to process blocks in dynamic
;      (wa,wb,wc,xr)	     destroyed
;
;      processes all blocks in the dynamic region.  within a
;      block, pointers to the code section, constant section,
;      working globals section, static region, and dynamic
;      region are relocated as needed.
;
|reldn|prc|25,e|1,0||; entry point| 7327
||mov|3,rldcd|13,rlcda(xl)||; save code adjustment| 7328
||mov|3,rldst|13,rlsta(xl)||; save static adjustment| 7329
||mov|3,rldls|7,xl||; save list pointer| 7330
;
;      merge here to process the next block in dynamic
;
|rld01|add|9,(xr)|3,rldcd||; adjust block type word| 7334
||mov|7,xl|9,(xr)||; load block type word| 7335
||lei|7,xl|||; load entry point id (bl_xx)| 7336
;
;      block type switch. note that blocks with no relocatable
;      fields just return to rld05 to continue to next block.
;
;      note that dfblks do not appear in dynamic, only in static.
;      ccblks and cmblks are not live when a save file is
;      created, and can be skipped.
;
;      further note:  static blocks other than vrblks discovered
;      while scanning dynamic must be adjusted at this time.
;      see processing of ffblk for example.
;
||ejc||||| 7349
;
;      reldn (continued)
;
||bsw|7,xl|2,bl___||; switch on block type| 7353
||iff|2,bl_ar|6,rld03||; arblk| 7390
||iff|2,bl_cd|6,rld07||; cdblk| 7390
||iff|2,bl_ex|6,rld10||; exblk| 7390
||iff|2,bl_ic|6,rld05||; icblk| 7390
||iff|2,bl_nm|6,rld13||; nmblk| 7390
||iff|2,bl_p0|6,rld13||; p0blk| 7390
||iff|2,bl_p1|6,rld14||; p1blk| 7390
||iff|2,bl_p2|6,rld14||; p2blk| 7390
||iff|2,bl_rc|6,rld05||; rcblk| 7390
||iff|2,bl_sc|6,rld05||; scblk| 7390
||iff|2,bl_se|6,rld13||; seblk| 7390
||iff|2,bl_tb|6,rld17||; tbblk| 7390
||iff|2,bl_vc|6,rld17||; vcblk| 7390
||iff|2,bl_xn|6,rld05||; xnblk| 7390
||iff|2,bl_xr|6,rld20||; xrblk| 7390
||iff|2,bl_bc|6,rld05||; bcblk - dummy to fill out iffs| 7390
||iff|2,bl_pd|6,rld15||; pdblk| 7390
||iff|2,bl_tr|6,rld19||; trblk| 7390
||iff|2,bl_bf|6,rld05||; bfblk| 7390
||iff|2,bl_cc|6,rld05||; ccblk| 7390
||iff|2,bl_cm|6,rld05||; cmblk| 7390
||iff|2,bl_ct|6,rld05||; ctblk| 7390
||iff|2,bl_df|6,rld05||; dfblk| 7390
||iff|2,bl_ef|6,rld08||; efblk| 7390
||iff|2,bl_ev|6,rld09||; evblk| 7390
||iff|2,bl_ff|6,rld11||; ffblk| 7390
||iff|2,bl_kv|6,rld13||; kvblk| 7390
||iff|2,bl_pf|6,rld16||; pfblk| 7390
||iff|2,bl_te|6,rld18||; teblk| 7390
||esw||||; end of jump table| 7390
;
;      arblk
;
|rld03|mov|8,wa|13,arlen(xr)||; load length| 7394
||mov|8,wb|13,arofs(xr)||; set offset to 1st reloc fld (arpro)| 7395
;
;      merge here to process pointers in a block
;
;      (xr)		     ptr to current block
;      (wc)		     ptr past last location to process
;      (wa)		     length (reloc flds + flds at start)
;      (wb)		     offset to first reloc field
;
|rld04|add|8,wa|7,xr||; point past last reloc field| 7404
||add|8,wb|7,xr||; point to first reloc field| 7405
||mov|7,xl|3,rldls||; point to list of bounds| 7406
||jsr|6,relaj|||; adjust pointers| 7407
||ejc||||| 7408
;
;      reldn (continued)
;
;
;      merge here to advance to next block
;
;      (xr)		     ptr to current block
;      (wc)		     ptr past last location to process
;
|rld05|mov|8,wa|9,(xr)||; block type word| 7418
||jsr|6,blkln|||; get length of block| 7419
||add|7,xr|8,wa||; point to next block| 7420
||blt|7,xr|8,wc|6,rld01|; continue if more to process| 7421
||mov|7,xl|3,rldls||; restore xl| 7422
||exi||||; return to caller if done| 7423
;
;      cdblk
;
|rld07|mov|8,wa|13,cdlen(xr)||; load length| 7436
||mov|8,wb|19,*cdfal||; set offset| 7437
||bne|9,(xr)|22,=b_cdc|6,rld04|; jump back if not complex goto| 7438
||mov|8,wb|19,*cdcod||; do not process cdfal word| 7439
||brn|6,rld04|||; jump back| 7440
;
;      efblk
;
;      if the efcod word points to an xnblk, the xnblk type
;      word will not be adjusted.  since this is implementation
;      dependent, we will not worry about it.
;
|rld08|mov|8,wa|19,*efrsl||; set length| 7448
||mov|8,wb|19,*efcod||; and offset| 7449
||brn|6,rld04|||; all set| 7450
;
;      evblk
;
|rld09|mov|8,wa|19,*offs3||; point past third field| 7454
||mov|8,wb|19,*evexp||; set offset| 7455
||brn|6,rld04|||; all set| 7456
;
;      exblk
;
|rld10|mov|8,wa|13,exlen(xr)||; load length| 7460
||mov|8,wb|19,*exflc||; set offset| 7461
||brn|6,rld04|||; jump back| 7462
||ejc||||| 7463
;
;      reldn (continued)
;
;
;      ffblk
;
;      this block contains a ptr to a dfblk in the static rgn.
;      because there are multiple ffblks pointing to the same
;      dfblk (one for each field name), we only process the
;      dfblk when we encounter the ffblk for the first field.
;      the dfblk in turn contains a pointer to an scblk within
;      static.
;
|rld11|bne|13,ffofs(xr)|19,*pdfld|6,rld12|; skip dfblk if not first field| 7477
||mov|11,-(xs)|7,xr||; save xr| 7478
||mov|7,xr|13,ffdfp(xr)||; load old ptr to dfblk| 7479
||add|7,xr|3,rldst||; current location of dfblk| 7480
||add|9,(xr)|3,rldcd||; adjust dfblk type word| 7481
||mov|8,wa|13,dflen(xr)||; length of dfblk| 7482
||mov|8,wb|19,*dfnam||; offset to dfnam field| 7483
||add|8,wa|7,xr||; point past last reloc field| 7484
||add|8,wb|7,xr||; point to first reloc field| 7485
||mov|7,xl|3,rldls||; point to list of bounds| 7486
||jsr|6,relaj|||; adjust pointers| 7487
||mov|7,xr|13,dfnam(xr)||; pointer to static scblk| 7488
||add|9,(xr)|3,rldcd||; adjust scblk type word| 7489
||mov|7,xr|10,(xs)+||; restore ffblk pointer| 7490
;
;      ffblk (continued)
;
;      merge here to set up for adjustment of ptrs in ffblk
;
|rld12|mov|8,wa|19,*ffofs||; set length| 7496
||mov|8,wb|19,*ffdfp||; set offset| 7497
||brn|6,rld04|||; all set| 7498
;
;      kvblk, nmblk, p0blk, seblk
;
|rld13|mov|8,wa|19,*offs2||; point past second field| 7502
||mov|8,wb|19,*offs1||; offset is one (only reloc fld is 2)| 7503
||brn|6,rld04|||; all set| 7504
;
;      p1blk, p2blk
;
;      in p2blks, parm2 contains either a bit mask or the
;      name offset of a variable.  it never requires relocation.
;
|rld14|mov|8,wa|19,*parm2||; length (parm2 is non-relocatable)| 7511
||mov|8,wb|19,*pthen||; set offset| 7512
||brn|6,rld04|||; all set| 7513
;
;      pdblk
;
;      note that the dfblk pointed to by this pdblk was
;      processed when the ffblk was encountered.  because
;      the data function will be called before any records are
;      defined, the ffblk is encountered before any
;      corresponding pdblk.
;
|rld15|mov|7,xl|13,pddfp(xr)||; load ptr to dfblk| 7523
||add|7,xl|3,rldst||; adjust for static relocation| 7524
||mov|8,wa|13,dfpdl(xl)||; get pdblk length| 7525
||mov|8,wb|19,*pddfp||; set offset| 7526
||brn|6,rld04|||; all set| 7527
||ejc||||| 7528
;
;      reldn (continued)
;
;
;      pfblk
;
|rld16|add|13,pfvbl(xr)|3,rldst||; adjust non-contiguous field| 7535
||mov|8,wa|13,pflen(xr)||; get pfblk length| 7536
||mov|8,wb|19,*pfcod||; offset to first reloc| 7537
||brn|6,rld04|||; all set| 7538
;
;      tbblk, vcblk
;
|rld17|mov|8,wa|13,offs2(xr)||; load length| 7542
||mov|8,wb|19,*offs3||; set offset| 7543
||brn|6,rld04|||; jump back| 7544
;
;      teblk
;
|rld18|mov|8,wa|19,*tesi_||; set length| 7548
||mov|8,wb|19,*tesub||; and offset| 7549
||brn|6,rld04|||; all set| 7550
;
;      trblk
;
|rld19|mov|8,wa|19,*trsi_||; set length| 7554
||mov|8,wb|19,*trval||; and offset| 7555
||brn|6,rld04|||; all set| 7556
;
;      xrblk
;
|rld20|mov|8,wa|13,xrlen(xr)||; load length| 7560
||mov|8,wb|19,*xrptr||; set offset| 7561
||brn|6,rld04|||; jump back| 7562
||enp||||; end procedure reldn| 7563
||ejc||||| 7564
;
;      reloc -- relocate storage after save file reload
;
;      (xl)		     list of boundaries and adjustments
;      jsr  reloc	     relocate all pointers
;      (wa,wb,wc,xr)	     destroyed
;
;      the list of boundaries and adjustments pointed to by
;      register xl is created by a call to relcr, which should
;      be consulted for information on its structure.
;
|reloc|prc|25,e|1,0||; entry point| 7576
||mov|7,xr|13,rldys(xl)||; old start of dynamic| 7577
||mov|8,wc|13,rldye(xl)||; old end of dynamic| 7578
||add|7,xr|13,rldya(xl)||; create new start of dynamic| 7579
||add|8,wc|13,rldya(xl)||; create new end of dynamic| 7580
||jsr|6,reldn|||; relocate pointers in dynamic| 7581
||jsr|6,relws|||; relocate pointers in working sect| 7582
||jsr|6,relst|||; relocate pointers in static| 7583
||exi||||; return to caller| 7584
||enp||||; end procedure reloc| 7585
||ejc||||| 7586
;
;      relst -- relocate pointers in the static region
;
;      (xl)		     list of boundaries and adjustments
;      jsr  relst	     call to process blocks in static
;      (wa,wb,wc,xr)	     destroyed
;
;      only vrblks on the hash chain and any profile block are
;      processed.  other static blocks (dfblks) are processed
;      during processing of dynamic blocks.
;
;      global work locations will be processed at this point,
;      so pointers there can be relied upon.
;
|relst|prc|25,e|1,0||; entry point| 7601
||mov|7,xr|3,pftbl||; profile table| 7602
||bze|7,xr|6,rls01||; branch if no table allocated| 7603
||add|9,(xr)|13,rlcda(xl)||; adjust block type word| 7604
;
;      here after dealing with profiler
;
|rls01|mov|8,wc|3,hshtb||; point to start of hash table| 7608
||mov|8,wb|8,wc||; point to first hash bucket| 7609
||mov|8,wa|3,hshte||; point beyond hash table| 7610
||jsr|6,relaj|||; adjust bucket pointers| 7611
;
;      loop through slots in hash table
;
|rls02|beq|8,wc|3,hshte|6,rls05|; done if none left| 7615
||mov|7,xr|8,wc||; else copy slot pointer| 7616
||ica|8,wc|||; bump slot pointer| 7617
||sub|7,xr|19,*vrnxt||; set offset to merge into loop| 7618
;
;      loop through vrblks on one hash chain
;
|rls03|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain| 7622
||bze|7,xr|6,rls02||; jump for next bucket if chain end| 7623
||mov|8,wa|19,*vrlen||; offset of first loc past ptr fields| 7624
||mov|8,wb|19,*vrget||; offset of first location in vrblk| 7625
||bnz|13,vrlen(xr)|6,rls04||; jump if not system variable| 7626
||mov|8,wa|19,*vrsi_||; offset to include vrsvp field| 7627
;
;      merge here to process fields of vrblk
;
|rls04|add|8,wa|7,xr||; create end ptr| 7631
||add|8,wb|7,xr||; create start ptr| 7632
||jsr|6,relaj|||; adjust pointers in vrblk| 7633
||brn|6,rls03|||; check for another vrblk on chain| 7634
;
;      here when all vrblks processed
;
|rls05|exi||||; return to caller| 7638
||enp||||; end procedure relst| 7639
||ejc||||| 7640
;
;      relws -- relocate pointers in the working section
;
;      (xl)		     list of boundaries and adjustments
;      jsr  relws	     call to process working section
;      (wa,wb,wc,xr)	     destroyed
;
;      pointers between a_aaa and r_yyy are examined and
;      adjusted if necessary.  the pointer kvrtn is also
;      adjusted although it lies outside this range.
;      dname is explicitly adjusted because the limits
;      on dynamic region in stack are to the area actively
;      in use (between dnamb and dnamp), and dname is outside
;      this range.
;
|relws|prc|25,e|1,0||; entry point| 7656
||mov|8,wb|20,=a_aaa||; point to start of adjustables| 7657
||mov|8,wa|20,=r_yyy||; point to end of adjustables| 7658
||jsr|6,relaj|||; relocate adjustable pointers| 7659
||add|3,dname|13,rldya(xl)||; adjust ptr missed by relaj| 7660
||mov|8,wb|20,=kvrtn||; case of kvrtn| 7661
||mov|8,wa|8,wb||; handled specially| 7662
||ica|8,wa|||; one value to adjust| 7663
||jsr|6,relaj|||; adjust kvrtn| 7664
||exi||||; return to caller| 7665
||enp||||; end procedure relws| 7666
||ttl|27,s p i t b o l -- initialization|||| 7668
;
;      initialisation
;      the following section receives control from the system
;      at the start of a run with the registers set as follows.
;
;      (wa)		     initial stack pointer
;      (xr)		     points to first word of data area
;      (xl)		     points to last word of data area
;
|start|prc|25,e|1,0||; entry point| 7678
;z-
||mov|3,mxint|8,wb||;| 7680
||mov|4,bitsm|8,wb||;| 7681
||zer|8,wb|||;| 7682
||mov|7,xs|8,wa||; discard return| 7683
;z+
||jsr|6,systm|||; initialise timer| 7685
||sti|3,timsx|||; store time| 7687
||mov|3,statb|7,xr||; start address of static| 7688
||mov|3,rsmem|19,*e_srs||; reserve memory| 7740
||mov|3,stbas|7,xs||; store stack base| 7741
||sss|3,iniss|||; save s-r stack ptr| 7742
;
;      now convert free store percentage to a suitable factor
;      for easy testing in alloc routine.
;
||ldi|4,intvh|||; get 100| 7747
||dvi|4,alfsp|||; form 100 / alfsp| 7748
||sti|3,alfsf|||; store the factor| 7749
;
;      now convert free sediment percentage to a suitable factor
;      for easy testing in gbcol routine.
;
||ldi|4,intvh|||; get 100| 7755
||dvi|4,gbsdp|||; form 100 / gbsdp| 7756
||sti|3,gbsed|||; store the factor| 7757
;
;      initialize values for real conversion routine
;
||lct|8,wb|18,=cfp_s||; load counter for significant digits| 7766
||ldr|4,reav1|||; load 1.0| 7767
;
;      loop to compute 10**(max number significant digits)
;
|ini03|mlr|4,reavt|||; * 10.0| 7771
||bct|8,wb|6,ini03||; loop till done| 7772
||str|3,gtssc|||; store 10**(max sig digits)| 7773
||ldr|4,reap5|||; load 0.5| 7774
||dvr|3,gtssc|||; compute 0.5*10**(max sig digits)| 7775
||str|3,gtsrn|||; store as rounding bias| 7776
||zer|8,wc|||; set to read parameters| 7779
||jsr|6,prpar|||; read them| 7780
||ejc||||| 7781
;
;      now compute starting address for dynamic store and if
;      necessary request more memory.
;
||sub|7,xl|19,*e_srs||; allow for reserve memory| 7786
||mov|8,wa|3,prlen||; get print buffer length| 7787
||add|8,wa|18,=cfp_a||; add no. of chars in alphabet| 7788
||add|8,wa|18,=nstmx||; add chars for gtstg bfr| 7789
||ctb|8,wa|1,8||; convert to bytes, allowing a margin| 7790
||mov|7,xr|3,statb||; point to static base| 7791
||add|7,xr|8,wa||; increment for above buffers| 7792
||add|7,xr|19,*e_hnb||; increment for hash table| 7793
||add|7,xr|19,*e_sts||; bump for initial static block| 7794
||jsr|6,sysmx|||; get mxlen| 7795
||mov|3,kvmxl|8,wa||; provisionally store as maxlngth| 7796
||mov|3,mxlen|8,wa||; and as mxlen| 7797
||bgt|7,xr|8,wa|6,ini06|; skip if static hi exceeds mxlen| 7798
||ctb|8,wa|1,1||; round up and make bigger than mxlen| 7799
||mov|7,xr|8,wa||; use it instead| 7800
;
;      here to store values which mark initial division
;      of data area into static and dynamic
;
|ini06|mov|3,dnamb|7,xr||; dynamic base adrs| 7805
||mov|3,dnamp|7,xr||; dynamic ptr| 7806
||bnz|8,wa|6,ini07||; skip if non-zero mxlen| 7807
||dca|7,xr|||; point a word in front| 7808
||mov|3,kvmxl|7,xr||; use as maxlngth| 7809
||mov|3,mxlen|7,xr||; and as mxlen| 7810
||ejc||||| 7811
;
;      loop here if necessary till enough memory obtained
;      so that dname is above dnamb
;
|ini07|mov|3,dname|7,xl||; store dynamic end address| 7816
||blt|3,dnamb|7,xl|6,ini09|; skip if high enough| 7817
||jsr|6,sysmm|||; request more memory| 7818
||wtb|7,xr|||; get as baus (sgd05)| 7819
||add|7,xl|7,xr||; bump by amount obtained| 7820
||bnz|7,xr|6,ini07||; try again| 7821
||mov|8,wa|18,=mxern||; insufficient memory for maxlength| 7823
||zer|8,wb|||; no column number info| 7824
||zer|8,wc|||; no line number info| 7825
||mov|7,xr|18,=stgic||; initial compile stage| 7826
||mov|7,xl|21,=nulls||; no file name| 7828
||jsr|6,sysea|||; advise of error| 7830
||ppm|6,ini08|||; cant use error logic yet| 7831
||brn|6,ini08|||; force termination| 7832
;
;      insert text for error 329 in error message table
;
||erb|1,329|26,requested maxlngth too large||| 7836
|ini08|mov|7,xr|21,=endmo||; point to failure message| 7838
||mov|8,wa|4,endml||; message length| 7839
||jsr|6,syspr|||; print it (prtst not yet usable)| 7840
||ppm||||; should not fail| 7841
||zer|7,xl|||; no fcb chain yet| 7842
||mov|8,wb|18,=num10||; set special code value| 7843
||jsr|6,sysej|||; pack up (stopr not yet usable)| 7844
;
;      initialise structures at start of static region
;
|ini09|mov|7,xr|3,statb||; point to static again| 7848
||jsr|6,insta|||; initialize static| 7849
;
;      initialize number of hash headers
;
||mov|8,wa|18,=e_hnb||; get number of hash headers| 7853
||mti|8,wa|||; convert to integer| 7854
||sti|3,hshnb|||; store for use by gtnvr procedure| 7855
||lct|8,wa|8,wa||; counter for clearing hash table| 7856
||mov|3,hshtb|7,xr||; pointer to hash table| 7857
;
;      loop to clear hash table
;
|ini11|zer|10,(xr)+|||; blank a word| 7861
||bct|8,wa|6,ini11||; loop| 7862
||mov|3,hshte|7,xr||; end of hash table adrs is kept| 7863
||mov|3,state|7,xr||; store static end address| 7864
;
;      init table to map statement numbers to source file names
;
||mov|8,wc|18,=num01||; table will have only one bucket| 7869
||mov|7,xl|21,=nulls||; default table value| 7870
||mov|3,r_sfc|7,xl||; current source file name| 7871
||jsr|6,tmake|||; create table| 7872
||mov|3,r_sfn|7,xr||; save ptr to table| 7873
;
;      initialize table to detect duplicate include file names
;
||mov|8,wc|18,=num01||; table will have only one bucket| 7879
||mov|7,xl|21,=nulls||; default table value| 7880
||jsr|6,tmake|||; create table| 7881
||mov|3,r_inc|7,xr||; save ptr to table| 7882
;
;      initialize array to hold names of nested include files
;
||mov|8,wa|18,=ccinm||; maximum nesting level| 7887
||mov|7,xl|21,=nulls||; null string default value| 7888
||jsr|6,vmake|||; create array| 7889
||ppm||||| 7890
||mov|3,r_ifa|7,xr||; save ptr to array| 7891
;
;      init array to hold line numbers of nested include files
;
||mov|8,wa|18,=ccinm||; maximum nesting level| 7895
||mov|7,xl|21,=inton||; integer one default value| 7896
||jsr|6,vmake|||; create array| 7897
||ppm||||| 7898
||mov|3,r_ifl|7,xr||; save ptr to array| 7899
;z+
;
;      initialize variable blocks for input and output
;
||mov|7,xl|21,=v_inp||; point to string /input/| 7906
||mov|8,wb|18,=trtin||; trblk type for input| 7907
||jsr|6,inout|||; perform input association| 7908
||mov|7,xl|21,=v_oup||; point to string /output/| 7909
||mov|8,wb|18,=trtou||; trblk type for output| 7910
||jsr|6,inout|||; perform output association| 7911
||mov|8,wc|3,initr||; terminal flag| 7912
||bze|8,wc|6,ini13||; skip if no terminal| 7913
||jsr|6,prpar|||; associate terminal| 7914
||ejc||||| 7915
;
;      check for expiry date
;
|ini13|jsr|6,sysdc|||; call date check| 7919
||mov|3,flptr|7,xs||; in case stack overflows in compiler| 7920
;
;      now compile source input code
;
||jsr|6,cmpil|||; call compiler| 7924
||mov|3,r_cod|7,xr||; set ptr to first code block| 7925
||mov|3,r_ttl|21,=nulls||; forget title| 7926
||mov|3,r_stl|21,=nulls||; forget sub-title| 7927
||zer|3,r_cim|||; forget compiler input image| 7928
||zer|3,r_ccb|||; forget interim code block| 7929
||zer|3,cnind|||; in case end occurred with include| 7931
||zer|3,lstid|||; listing include depth| 7932
||zer|7,xl|||; clear dud value| 7934
||zer|8,wb|||; dont shift dynamic store up| 7935
||zer|3,dnams|||; collect sediment too| 7937
||jsr|6,gbcol|||; clear garbage left from compile| 7938
||mov|3,dnams|7,xr||; record new sediment size| 7939
||bnz|3,cpsts|6,inix0||; skip if no listing of comp stats| 7943
||jsr|6,prtpg|||; eject page| 7944
;
;      print compile statistics
;
||jsr|6,prtmm|||; print memory usage| 7948
||mti|3,cmerc|||; get count of errors as integer| 7949
||mov|7,xr|21,=encm3||; point to /compile errors/| 7950
||jsr|6,prtmi|||; print it| 7951
||mti|3,gbcnt|||; garbage collection count| 7952
||sbi|4,intv1|||; adjust for unavoidable collect| 7953
||mov|7,xr|21,=stpm5||; point to /storage regenerations/| 7954
||jsr|6,prtmi|||; print gbcol count| 7955
||jsr|6,systm|||; get time| 7956
||sbi|3,timsx|||; get compilation time| 7957
||mov|7,xr|21,=encm4||; point to compilation time (msec)/| 7958
||jsr|6,prtmi|||; print message| 7959
||add|3,lstlc|18,=num05||; bump line count| 7960
||bze|3,headp|6,inix0||; no eject if nothing printed| 7962
||jsr|6,prtpg|||; eject printer| 7963
||ejc||||| 7965
;
;      prepare now to start execution
;
;      set default input record length
;
|inix0|bgt|3,cswin|18,=iniln|6,inix1|; skip if not default -in72 used| 7971
||mov|3,cswin|18,=inils||; else use default record length| 7972
;
;      reset timer
;
|inix1|jsr|6,systm|||; get time again| 7976
||sti|3,timsx|||; store for end run processing| 7977
||zer|3,gbcnt|||; initialise collect count| 7978
||jsr|6,sysbx|||; call before starting execution| 7979
||add|3,noxeq|3,cswex||; add -noexecute flag| 7980
||bnz|3,noxeq|6,inix2||; jump if execution suppressed| 7981
;
;      merge when listing file set for execution.  also
;      merge here when restarting a save file or load module.
;
|iniy0|mnz|3,headp|||; mark headers out regardless| 7991
||zer|11,-(xs)|||; set failure location on stack| 7992
||mov|3,flptr|7,xs||; save ptr to failure offset word| 7993
||mov|7,xr|3,r_cod||; load ptr to entry code block| 7994
||mov|3,stage|18,=stgxt||; set stage for execute time| 7995
||mov|3,polcs|18,=num01||; reset interface polling interval| 7997
||mov|3,polct|18,=num01||; reset interface polling interval| 7998
||mov|3,pfnte|3,cmpsn||; copy stmts compiled count in case| 8002
||mov|3,pfdmp|3,kvpfl||; start profiling if &profile set| 8003
||jsr|6,systm|||; time yet again| 8004
||sti|3,pfstm|||;| 8005
||jsr|6,stgcc|||; compute stmgo countdown counters| 8007
||bri|9,(xr)|||; start xeq with first statement| 8008
;
;      here if execution is suppressed
;
|inix2|zer|8,wa|||; set abend value to zero| 8013
||mov|8,wb|18,=nini9||; set special code value| 8021
||zer|7,xl|||; no fcb chain| 8022
||jsr|6,sysej|||; end of job, exit to system| 8023
||enp||||; end procedure start| 8024
;
;      here from osint to restart a save file or load module.
;
|rstrt|prc|25,e|1,0||; entry point| 8028
||mov|7,xs|3,stbas||; discard return| 8029
||zer|7,xl|||; clear xl| 8030
||brn|6,iniy0|||; resume execution| 8031
||enp||||; end procedure rstrt| 8032
||ttl|27,s p i t b o l -- snobol4 operator routines|||| 8034
;
;      this section includes all routines which can be accessed
;      directly from the generated code except system functions.
;
;      all routines in this section start with a label of the
;      form o_xxx where xxx is three letters. the generated code
;      contains a pointer to the appropriate entry label.
;
;      since the general form of the generated code consists of
;      pointers to blocks whose first word is the address of the
;      actual entry point label (o_xxx).
;
;      these routines are in alphabetical order by their
;      entry label names (i.e. by the xxx of the o_xxx name)
;
;      these routines receive control as follows
;
;      (cp)		     pointer to next code word
;      (xs)		     current stack pointer
||ejc||||| 8054
;
;      binary plus (addition)
;
|o_add|ent||||; entry point| 8058
;z+
||jsr|6,arith|||; fetch arithmetic operands| 8060
||err|1,001|26,addition left operand is not numeric||| 8061
||err|1,002|26,addition right operand is not numeric||| 8062
||ppm|6,oadd1|||; jump if real operands| 8065
;
;      here to add two integers
;
||adi|13,icval(xl)|||; add right operand to left| 8070
||ino|6,exint|||; return integer if no overflow| 8071
||erb|1,003|26,addition caused integer overflow||| 8072
;
;      here to add two reals
;
|oadd1|adr|13,rcval(xl)|||; add right operand to left| 8078
||rno|6,exrea|||; return real if no overflow| 8079
||erb|1,261|26,addition caused real overflow||| 8080
||ejc||||| 8082
;
;      unary plus (affirmation)
;
|o_aff|ent||||; entry point| 8086
||mov|7,xr|10,(xs)+||; load operand| 8087
||jsr|6,gtnum|||; convert to numeric| 8088
||err|1,004|26,affirmation operand is not numeric||| 8089
||mov|11,-(xs)|7,xr||; result if converted to numeric| 8090
||lcw|7,xr|||; get next code word| 8091
||bri|9,(xr)|||; execute it| 8092
||ejc||||| 8093
;
;      binary bar (alternation)
;
|o_alt|ent||||; entry point| 8097
||mov|7,xr|10,(xs)+||; load right operand| 8098
||jsr|6,gtpat|||; convert to pattern| 8099
||err|1,005|26,alternation right operand is not pattern||| 8100
;
;      merge here from special (left alternation) case
;
|oalt1|mov|8,wb|22,=p_alt||; set pcode for alternative node| 8104
||jsr|6,pbild|||; build alternative node| 8105
||mov|7,xl|7,xr||; save address of alternative node| 8106
||mov|7,xr|10,(xs)+||; load left operand| 8107
||jsr|6,gtpat|||; convert to pattern| 8108
||err|1,006|26,alternation left operand is not pattern||| 8109
||beq|7,xr|22,=p_alt|6,oalt2|; jump if left arg is alternation| 8110
||mov|13,pthen(xl)|7,xr||; set left operand as successor| 8111
||mov|11,-(xs)|7,xl||; stack result| 8112
||lcw|7,xr|||; get next code word| 8113
||bri|9,(xr)|||; execute it| 8114
;
;      come here if left argument is itself an alternation
;
;      the result is more efficient if we make the replacement
;
;      (a / b) / c = a / (b / c)
;
|oalt2|mov|13,pthen(xl)|13,parm1(xr)||; build the (b / c) node| 8122
||mov|11,-(xs)|13,pthen(xr)||; set a as new left arg| 8123
||mov|7,xr|7,xl||; set (b / c) as new right arg| 8124
||brn|6,oalt1|||; merge back to build a / (b / c)| 8125
||ejc||||| 8126
;
;      array reference (multiple subscripts, by name)
;
|o_amn|ent||||; entry point| 8130
||lcw|7,xr|||; load number of subscripts| 8131
||mov|8,wb|7,xr||; set flag for by name| 8132
||brn|6,arref|||; jump to array reference routine| 8133
||ejc||||| 8134
;
;      array reference (multiple subscripts, by value)
;
|o_amv|ent||||; entry point| 8138
||lcw|7,xr|||; load number of subscripts| 8139
||zer|8,wb|||; set flag for by value| 8140
||brn|6,arref|||; jump to array reference routine| 8141
||ejc||||| 8142
;
;      array reference (one subscript, by name)
;
|o_aon|ent||||; entry point| 8146
||mov|7,xr|9,(xs)||; load subscript value| 8147
||mov|7,xl|13,num01(xs)||; load array value| 8148
||mov|8,wa|9,(xl)||; load first word of array operand| 8149
||beq|8,wa|22,=b_vct|6,oaon2|; jump if vector reference| 8150
||beq|8,wa|22,=b_tbt|6,oaon3|; jump if table reference| 8151
;
;      here to use central array reference routine
;
|oaon1|mov|7,xr|18,=num01||; set number of subscripts to one| 8155
||mov|8,wb|7,xr||; set flag for by name| 8156
||brn|6,arref|||; jump to array reference routine| 8157
;
;      here if we have a vector reference
;
|oaon2|bne|9,(xr)|22,=b_icl|6,oaon1|; use long routine if not integer| 8161
||ldi|13,icval(xr)|||; load integer subscript value| 8162
||mfi|8,wa|6,exfal||; copy as address int, fail if ovflo| 8163
||bze|8,wa|6,exfal||; fail if zero| 8164
||add|8,wa|18,=vcvlb||; compute offset in words| 8165
||wtb|8,wa|||; convert to bytes| 8166
||mov|9,(xs)|8,wa||; complete name on stack| 8167
||blt|8,wa|13,vclen(xl)|6,oaon4|; exit if subscript not too large| 8168
||brn|6,exfal|||; else fail| 8169
;
;      here for table reference
;
|oaon3|mnz|8,wb|||; set flag for name reference| 8173
||jsr|6,tfind|||; locate/create table element| 8174
||ppm|6,exfal|||; fail if access fails| 8175
||mov|13,num01(xs)|7,xl||; store name base on stack| 8176
||mov|9,(xs)|8,wa||; store name offset on stack| 8177
;
;      here to exit with result on stack
;
|oaon4|lcw|7,xr|||; result on stack, get code word| 8181
||bri|9,(xr)|||; execute next code word| 8182
||ejc||||| 8183
;
;      array reference (one subscript, by value)
;
|o_aov|ent||||; entry point| 8187
||mov|7,xr|10,(xs)+||; load subscript value| 8188
||mov|7,xl|10,(xs)+||; load array value| 8189
||mov|8,wa|9,(xl)||; load first word of array operand| 8190
||beq|8,wa|22,=b_vct|6,oaov2|; jump if vector reference| 8191
||beq|8,wa|22,=b_tbt|6,oaov3|; jump if table reference| 8192
;
;      here to use central array reference routine
;
|oaov1|mov|11,-(xs)|7,xl||; restack array value| 8196
||mov|11,-(xs)|7,xr||; restack subscript| 8197
||mov|7,xr|18,=num01||; set number of subscripts to one| 8198
||zer|8,wb|||; set flag for value call| 8199
||brn|6,arref|||; jump to array reference routine| 8200
;
;      here if we have a vector reference
;
|oaov2|bne|9,(xr)|22,=b_icl|6,oaov1|; use long routine if not integer| 8204
||ldi|13,icval(xr)|||; load integer subscript value| 8205
||mfi|8,wa|6,exfal||; move as one word int, fail if ovflo| 8206
||bze|8,wa|6,exfal||; fail if zero| 8207
||add|8,wa|18,=vcvlb||; compute offset in words| 8208
||wtb|8,wa|||; convert to bytes| 8209
||bge|8,wa|13,vclen(xl)|6,exfal|; fail if subscript too large| 8210
||jsr|6,acess|||; access value| 8211
||ppm|6,exfal|||; fail if access fails| 8212
||mov|11,-(xs)|7,xr||; stack result| 8213
||lcw|7,xr|||; get next code word| 8214
||bri|9,(xr)|||; execute it| 8215
;
;      here for table reference by value
;
|oaov3|zer|8,wb|||; set flag for value reference| 8219
||jsr|6,tfind|||; call table search routine| 8220
||ppm|6,exfal|||; fail if access fails| 8221
||mov|11,-(xs)|7,xr||; stack result| 8222
||lcw|7,xr|||; get next code word| 8223
||bri|9,(xr)|||; execute it| 8224
||ejc||||| 8225
;
;      assignment
;
|o_ass|ent||||; entry point| 8229
;
;      o_rpl (pattern replacement) merges here
;
|oass0|mov|8,wb|10,(xs)+||; load value to be assigned| 8233
||mov|8,wa|10,(xs)+||; load name offset| 8234
||mov|7,xl|9,(xs)||; load name base| 8235
||mov|9,(xs)|8,wb||; store assigned value as result| 8236
||jsr|6,asign|||; perform assignment| 8237
||ppm|6,exfal|||; fail if assignment fails| 8238
||lcw|7,xr|||; result on stack, get code word| 8239
||bri|9,(xr)|||; execute next code word| 8240
||ejc||||| 8241
;
;      compilation error
;
|o_cer|ent||||; entry point| 8245
||erb|1,007|26,compilation error encountered during execution||| 8246
||ejc||||| 8247
;
;      unary at (cursor assignment)
;
|o_cas|ent||||; entry point| 8251
||mov|8,wc|10,(xs)+||; load name offset (parm2)| 8252
||mov|7,xr|10,(xs)+||; load name base (parm1)| 8253
||mov|8,wb|22,=p_cas||; set pcode for cursor assignment| 8254
||jsr|6,pbild|||; build node| 8255
||mov|11,-(xs)|7,xr||; stack result| 8256
||lcw|7,xr|||; get next code word| 8257
||bri|9,(xr)|||; execute it| 8258
||ejc||||| 8259
;
;      concatenation
;
|o_cnc|ent||||; entry point| 8263
||mov|7,xr|9,(xs)||; load right argument| 8264
||beq|7,xr|21,=nulls|6,ocnc3|; jump if right arg is null| 8265
||mov|7,xl|12,1(xs)||; load left argument| 8266
||beq|7,xl|21,=nulls|6,ocnc4|; jump if left argument is null| 8267
||mov|8,wa|22,=b_scl||; get constant to test for string| 8268
||bne|8,wa|9,(xl)|6,ocnc2|; jump if left arg not a string| 8269
||bne|8,wa|9,(xr)|6,ocnc2|; jump if right arg not a string| 8270
;
;      merge here to concatenate two strings
;
|ocnc1|mov|8,wa|13,sclen(xl)||; load left argument length| 8274
||add|8,wa|13,sclen(xr)||; compute result length| 8275
||jsr|6,alocs|||; allocate scblk for result| 8276
||mov|12,1(xs)|7,xr||; store result ptr over left argument| 8277
||psc|7,xr|||; prepare to store chars of result| 8278
||mov|8,wa|13,sclen(xl)||; get number of chars in left arg| 8279
||plc|7,xl|||; prepare to load left arg chars| 8280
||mvc||||; move characters of left argument| 8281
||mov|7,xl|10,(xs)+||; load right arg pointer, pop stack| 8282
||mov|8,wa|13,sclen(xl)||; load number of chars in right arg| 8283
||plc|7,xl|||; prepare to load right arg chars| 8284
||mvc||||; move characters of right argument| 8285
||zer|7,xl|||; clear garbage value in xl| 8286
||lcw|7,xr|||; result on stack, get code word| 8287
||bri|9,(xr)|||; execute next code word| 8288
;
;      come here if arguments are not both strings
;
|ocnc2|jsr|6,gtstg|||; convert right arg to string| 8292
||ppm|6,ocnc5|||; jump if right arg is not string| 8293
||mov|7,xl|7,xr||; save right arg ptr| 8294
||jsr|6,gtstg|||; convert left arg to string| 8295
||ppm|6,ocnc6|||; jump if left arg is not a string| 8296
||mov|11,-(xs)|7,xr||; stack left argument| 8297
||mov|11,-(xs)|7,xl||; stack right argument| 8298
||mov|7,xl|7,xr||; move left arg to proper reg| 8299
||mov|7,xr|9,(xs)||; move right arg to proper reg| 8300
||brn|6,ocnc1|||; merge back to concatenate strings| 8301
||ejc||||| 8302
;
;      concatenation (continued)
;
;      come here for null right argument
;
|ocnc3|ica|7,xs|||; remove right arg from stack| 8308
||lcw|7,xr|||; left argument on stack| 8309
||bri|9,(xr)|||; execute next code word| 8310
;
;      here for null left argument
;
|ocnc4|ica|7,xs|||; unstack one argument| 8314
||mov|9,(xs)|7,xr||; store right argument| 8315
||lcw|7,xr|||; result on stack, get code word| 8316
||bri|9,(xr)|||; execute next code word| 8317
;
;      here if right argument is not a string
;
|ocnc5|mov|7,xl|7,xr||; move right argument ptr| 8321
||mov|7,xr|10,(xs)+||; load left arg pointer| 8322
;
;      merge here when left argument is not a string
;
|ocnc6|jsr|6,gtpat|||; convert left arg to pattern| 8326
||err|1,008|26,concatenation left operand is not a string or pattern||| 8327
||mov|11,-(xs)|7,xr||; save result on stack| 8328
||mov|7,xr|7,xl||; point to right operand| 8329
||jsr|6,gtpat|||; convert to pattern| 8330
||err|1,009|26,concatenation right operand is not a string or pattern||| 8331
||mov|7,xl|7,xr||; move for pconc| 8332
||mov|7,xr|10,(xs)+||; reload left operand ptr| 8333
||jsr|6,pconc|||; concatenate patterns| 8334
||mov|11,-(xs)|7,xr||; stack result| 8335
||lcw|7,xr|||; get next code word| 8336
||bri|9,(xr)|||; execute it| 8337
||ejc||||| 8338
;
;      complementation
;
|o_com|ent||||; entry point| 8342
||mov|7,xr|10,(xs)+||; load operand| 8343
||mov|8,wa|9,(xr)||; load type word| 8344
;
;      merge back here after conversion
;
|ocom1|beq|8,wa|22,=b_icl|6,ocom2|; jump if integer| 8348
||beq|8,wa|22,=b_rcl|6,ocom3|; jump if real| 8351
||jsr|6,gtnum|||; else convert to numeric| 8353
||err|1,010|26,negation operand is not numeric||| 8354
||brn|6,ocom1|||; back to check cases| 8355
;
;      here to complement integer
;
|ocom2|ldi|13,icval(xr)|||; load integer value| 8359
||ngi||||; negate| 8360
||ino|6,exint|||; return integer if no overflow| 8361
||erb|1,011|26,negation caused integer overflow||| 8362
;
;      here to complement real
;
|ocom3|ldr|13,rcval(xr)|||; load real value| 8368
||ngr||||; negate| 8369
||brn|6,exrea|||; return real result| 8370
||ejc||||| 8372
;
;      binary slash (division)
;
|o_dvd|ent||||; entry point| 8376
||jsr|6,arith|||; fetch arithmetic operands| 8377
||err|1,012|26,division left operand is not numeric||| 8378
||err|1,013|26,division right operand is not numeric||| 8379
||ppm|6,odvd2|||; jump if real operands| 8382
;
;      here to divide two integers
;
||dvi|13,icval(xl)|||; divide left operand by right| 8387
||ino|6,exint|||; result ok if no overflow| 8388
||erb|1,014|26,division caused integer overflow||| 8389
;
;      here to divide two reals
;
|odvd2|dvr|13,rcval(xl)|||; divide left operand by right| 8395
||rno|6,exrea|||; return real if no overflow| 8396
||erb|1,262|26,division caused real overflow||| 8397
||ejc||||| 8399
;
;      exponentiation
;
|o_exp|ent||||; entry point| 8403
||mov|7,xr|10,(xs)+||; load exponent| 8404
||jsr|6,gtnum|||; convert to number| 8405
||err|1,015|26,exponentiation right operand is not numeric||| 8406
||mov|7,xl|7,xr||; move exponent to xl| 8407
||mov|7,xr|10,(xs)+||; load base| 8408
||jsr|6,gtnum|||; convert to numeric| 8409
||err|1,016|26,exponentiation left operand is not numeric||| 8410
||beq|9,(xl)|22,=b_rcl|6,oexp7|; jump if real exponent| 8413
||ldi|13,icval(xl)|||; load exponent| 8415
||ilt|6,oex12|||; jump if negative exponent| 8416
||beq|8,wa|22,=b_rcl|6,oexp3|; jump if base is real| 8419
;
;      here to exponentiate an integer base and integer exponent
;
||mfi|8,wa|6,oexp2||; convert exponent to 1 word integer| 8424
||lct|8,wa|8,wa||; set loop counter| 8425
||ldi|13,icval(xr)|||; load base as initial value| 8426
||bnz|8,wa|6,oexp1||; jump into loop if non-zero exponent| 8427
||ieq|6,oexp4|||; error if 0**0| 8428
||ldi|4,intv1|||; nonzero**0| 8429
||brn|6,exint|||; give one as result for nonzero**0| 8430
;
;      loop to perform exponentiation
;
|oex13|mli|13,icval(xr)|||; multiply by base| 8434
||iov|6,oexp2|||; jump if overflow| 8435
|oexp1|bct|8,wa|6,oex13||; loop if more to go| 8436
||brn|6,exint|||; else return integer result| 8437
;
;      here if integer overflow
;
|oexp2|erb|1,017|26,exponentiation caused integer overflow||| 8441
||ejc||||| 8442
;
;      exponentiation (continued)
;
;      here to exponentiate a real to an integer power
;
|oexp3|mfi|8,wa|6,oexp6||; convert exponent to one word| 8450
||lct|8,wa|8,wa||; set loop counter| 8451
||ldr|13,rcval(xr)|||; load base as initial value| 8452
||bnz|8,wa|6,oexp5||; jump into loop if non-zero exponent| 8453
||req|6,oexp4|||; error if 0.0**0| 8454
||ldr|4,reav1|||; nonzero**0| 8455
||brn|6,exrea|||; return 1.0 if nonzero**zero| 8456
;
;      here for error of 0**0 or 0.0**0
;
|oexp4|erb|1,018|26,exponentiation result is undefined||| 8461
;
;      loop to perform exponentiation
;
|oex14|mlr|13,rcval(xr)|||; multiply by base| 8467
||rov|6,oexp6|||; jump if overflow| 8468
|oexp5|bct|8,wa|6,oex14||; loop till computation complete| 8469
||brn|6,exrea|||; then return real result| 8470
;
;      here if real overflow
;
|oexp6|erb|1,266|26,exponentiation caused real overflow||| 8474
;
;      here with real exponent in (xl), numeric base in (xr)
;
|oexp7|beq|9,(xr)|22,=b_rcl|6,oexp8|; jump if base real| 8479
||ldi|13,icval(xr)|||; load integer base| 8480
||itr||||; convert to real| 8481
||jsr|6,rcbld|||; create real in (xr)| 8482
;
;      here with real exponent in (xl)
;      numeric base in (xr) and ra
;
|oexp8|zer|8,wb|||; set positive result flag| 8487
||ldr|13,rcval(xr)|||; load base to ra| 8488
||rne|6,oexp9|||; jump if base non-zero| 8489
||ldr|13,rcval(xl)|||; base is zero.	 check exponent| 8490
||req|6,oexp4|||; jump if 0.0 ** 0.0| 8491
||ldr|4,reav0|||; 0.0 to non-zero exponent yields 0.0| 8492
||brn|6,exrea|||; return zero result| 8493
;
;      here with non-zero base in (xr) and ra, exponent in (xl)
;
;      a negative base is allowed if the exponent is integral.
;
|oexp9|rgt|6,oex10|||; jump if base gt 0.0| 8499
||ngr||||; make base positive| 8500
||jsr|6,rcbld|||; create positive base in (xr)| 8501
||ldr|13,rcval(xl)|||; examine exponent| 8502
||chp||||; chop to integral value| 8503
||rti|6,oexp6|||; convert to integer, br if too large| 8504
||sbr|13,rcval(xl)|||; chop(exponent) - exponent| 8505
||rne|6,oex11|||; non-integral power with neg base| 8506
||mfi|8,wb|||; record even/odd exponent| 8507
||anb|8,wb|4,bits1||; odd exponent yields negative result| 8508
||ldr|13,rcval(xr)|||; restore base to ra| 8509
;
;      here with positive base in ra and (xr), exponent in (xl)
;
|oex10|lnf||||; log of base| 8513
||rov|6,oexp6|||; too large| 8514
||mlr|13,rcval(xl)|||; times exponent| 8515
||rov|6,oexp6|||; too large| 8516
||etx||||; e ** (exponent * ln(base))| 8517
||rov|6,oexp6|||; too large| 8518
||bze|8,wb|6,exrea||; if no sign fixup required| 8519
||ngr||||; negative result needed| 8520
||brn|6,exrea|||;| 8521
;
;      here for non-integral exponent with negative base
;
|oex11|erb|1,311|26,exponentiation of negative base to non-integral power||| 8525
;
;      here with negative integer exponent in ia
;
|oex12|mov|11,-(xs)|7,xr||; stack base| 8534
||itr||||; convert to real exponent| 8535
||jsr|6,rcbld|||; real negative exponent in (xr)| 8536
||mov|7,xl|7,xr||; put exponent in xl| 8537
||mov|7,xr|10,(xs)+||; restore base value| 8538
||brn|6,oexp7|||; process real exponent| 8539
||ejc||||| 8543
;
;      failure in expression evaluation
;
;      this entry point is used if the evaluation of an
;      expression, initiated by the evalx procedure, fails.
;      control is returned to an appropriate point in evalx.
;
|o_fex|ent||||; entry point| 8551
||brn|6,evlx6|||; jump to failure loc in evalx| 8552
||ejc||||| 8553
;
;      failure during evaluation of a complex or direct goto
;
|o_fif|ent||||; entry point| 8557
||erb|1,020|26,goto evaluation failure||| 8558
||ejc||||| 8559
;
;      function call (more than one argument)
;
|o_fnc|ent||||; entry point| 8563
||lcw|8,wa|||; load number of arguments| 8564
||lcw|7,xr|||; load function vrblk pointer| 8565
||mov|7,xl|13,vrfnc(xr)||; load function pointer| 8566
||bne|8,wa|13,fargs(xl)|6,cfunc|; use central routine if wrong num| 8567
||bri|9,(xl)|||; jump to function if arg count ok| 8568
||ejc||||| 8569
;
;      function name error
;
|o_fne|ent||||; entry point| 8573
||lcw|8,wa|||; get next code word| 8574
||bne|8,wa|21,=ornm_|6,ofne1|; fail if not evaluating expression| 8575
||bze|13,num02(xs)|6,evlx3||; ok if expr. was wanted by value| 8576
;
;      here for error
;
|ofne1|erb|1,021|26,function called by name returned a value||| 8580
||ejc||||| 8581
;
;      function call (single argument)
;
|o_fns|ent||||; entry point| 8585
||lcw|7,xr|||; load function vrblk pointer| 8586
||mov|8,wa|18,=num01||; set number of arguments to one| 8587
||mov|7,xl|13,vrfnc(xr)||; load function pointer| 8588
||bne|8,wa|13,fargs(xl)|6,cfunc|; use central routine if wrong num| 8589
||bri|9,(xl)|||; jump to function if arg count ok| 8590
||ejc||||| 8591
;      call to undefined function
;
|o_fun|ent||||; entry point| 8594
||erb|1,022|26,undefined function called||| 8595
||ejc||||| 8596
;
;      execute complex goto
;
|o_goc|ent||||; entry point| 8600
||mov|7,xr|13,num01(xs)||; load name base pointer| 8601
||bhi|7,xr|3,state|6,ogoc1|; jump if not natural variable| 8602
||add|7,xr|19,*vrtra||; else point to vrtra field| 8603
||bri|9,(xr)|||; and jump through it| 8604
;
;      here if goto operand is not natural variable
;
|ogoc1|erb|1,023|26,goto operand is not a natural variable||| 8608
||ejc||||| 8609
;
;      execute direct goto
;
|o_god|ent||||; entry point| 8613
||mov|7,xr|9,(xs)||; load operand| 8614
||mov|8,wa|9,(xr)||; load first word| 8615
||beq|8,wa|22,=b_cds|6,bcds0|; jump if code block to code routine| 8616
||beq|8,wa|22,=b_cdc|6,bcdc0|; jump if code block to code routine| 8617
||erb|1,024|26,goto operand in direct goto is not code||| 8618
||ejc||||| 8619
;
;      set goto failure trap
;
;      this routine is executed at the start of a complex or
;      direct failure goto to trap a subsequent fail (see exfal)
;
|o_gof|ent||||; entry point| 8626
||mov|7,xr|3,flptr||; point to fail offset on stack| 8627
||ica|9,(xr)|||; point failure to o_fif word| 8628
||icp||||; point to next code word| 8629
||lcw|7,xr|||; fetch next code word| 8630
||bri|9,(xr)|||; execute it| 8631
||ejc||||| 8632
;
;      binary dollar (immediate assignment)
;
;      the pattern built by binary dollar is a compound pattern.
;      see description at start of pattern match section for
;      details of the structure which is constructed.
;
|o_ima|ent||||; entry point| 8640
||mov|8,wb|22,=p_imc||; set pcode for last node| 8641
||mov|8,wc|10,(xs)+||; pop name offset (parm2)| 8642
||mov|7,xr|10,(xs)+||; pop name base (parm1)| 8643
||jsr|6,pbild|||; build p_imc node| 8644
||mov|7,xl|7,xr||; save ptr to node| 8645
||mov|7,xr|9,(xs)||; load left argument| 8646
||jsr|6,gtpat|||; convert to pattern| 8647
||err|1,025|26,immediate assignment left operand is not pattern||| 8648
||mov|9,(xs)|7,xr||; save ptr to left operand pattern| 8649
||mov|8,wb|22,=p_ima||; set pcode for first node| 8650
||jsr|6,pbild|||; build p_ima node| 8651
||mov|13,pthen(xr)|10,(xs)+||; set left operand as p_ima successor| 8652
||jsr|6,pconc|||; concatenate to form final pattern| 8653
||mov|11,-(xs)|7,xr||; stack result| 8654
||lcw|7,xr|||; get next code word| 8655
||bri|9,(xr)|||; execute it| 8656
||ejc||||| 8657
;
;      indirection (by name)
;
|o_inn|ent||||; entry point| 8661
||mnz|8,wb|||; set flag for result by name| 8662
||brn|6,indir|||; jump to common routine| 8663
||ejc||||| 8664
;
;      interrogation
;
|o_int|ent||||; entry point| 8668
||mov|9,(xs)|21,=nulls||; replace operand with null| 8669
||lcw|7,xr|||; get next code word| 8670
||bri|9,(xr)|||; execute next code word| 8671
||ejc||||| 8672
;
;      indirection (by value)
;
|o_inv|ent||||; entry point| 8676
||zer|8,wb|||; set flag for by value| 8677
||brn|6,indir|||; jump to common routine| 8678
||ejc||||| 8679
;
;      keyword reference (by name)
;
|o_kwn|ent||||; entry point| 8683
||jsr|6,kwnam|||; get keyword name| 8684
||brn|6,exnam|||; exit with result name| 8685
||ejc||||| 8686
;
;      keyword reference (by value)
;
|o_kwv|ent||||; entry point| 8690
||jsr|6,kwnam|||; get keyword name| 8691
||mov|3,dnamp|7,xr||; delete kvblk| 8692
||jsr|6,acess|||; access value| 8693
||ppm|6,exnul|||; dummy (unused) failure return| 8694
||mov|11,-(xs)|7,xr||; stack result| 8695
||lcw|7,xr|||; get next code word| 8696
||bri|9,(xr)|||; execute it| 8697
||ejc||||| 8698
;
;      load expression by name
;
|o_lex|ent||||; entry point| 8702
||mov|8,wa|19,*evsi_||; set size of evblk| 8703
||jsr|6,alloc|||; allocate space for evblk| 8704
||mov|9,(xr)|22,=b_evt||; set type word| 8705
||mov|13,evvar(xr)|21,=trbev||; set dummy trblk pointer| 8706
||lcw|8,wa|||; load exblk pointer| 8707
||mov|13,evexp(xr)|8,wa||; set exblk pointer| 8708
||mov|7,xl|7,xr||; move name base to proper reg| 8709
||mov|8,wa|19,*evvar||; set name offset = zero| 8710
||brn|6,exnam|||; exit with name in (xl,wa)| 8711
||ejc||||| 8712
;
;      load pattern value
;
|o_lpt|ent||||; entry point| 8716
||lcw|7,xr|||; load pattern pointer| 8717
||mov|11,-(xs)|7,xr||; stack result| 8718
||lcw|7,xr|||; get next code word| 8719
||bri|9,(xr)|||; execute it| 8720
||ejc||||| 8721
;
;      load variable name
;
|o_lvn|ent||||; entry point| 8725
||lcw|8,wa|||; load vrblk pointer| 8726
||mov|11,-(xs)|8,wa||; stack vrblk ptr (name base)| 8727
||mov|11,-(xs)|19,*vrval||; stack name offset| 8728
||lcw|7,xr|||; get next code word| 8729
||bri|9,(xr)|||; execute next code word| 8730
||ejc||||| 8731
;
;      binary asterisk (multiplication)
;
|o_mlt|ent||||; entry point| 8735
||jsr|6,arith|||; fetch arithmetic operands| 8736
||err|1,026|26,multiplication left operand is not numeric||| 8737
||err|1,027|26,multiplication right operand is not numeric||| 8738
||ppm|6,omlt1|||; jump if real operands| 8741
;
;      here to multiply two integers
;
||mli|13,icval(xl)|||; multiply left operand by right| 8746
||ino|6,exint|||; return integer if no overflow| 8747
||erb|1,028|26,multiplication caused integer overflow||| 8748
;
;      here to multiply two reals
;
|omlt1|mlr|13,rcval(xl)|||; multiply left operand by right| 8754
||rno|6,exrea|||; return real if no overflow| 8755
||erb|1,263|26,multiplication caused real overflow||| 8756
||ejc||||| 8758
;
;      name reference
;
|o_nam|ent||||; entry point| 8762
||mov|8,wa|19,*nmsi_||; set length of nmblk| 8763
||jsr|6,alloc|||; allocate nmblk| 8764
||mov|9,(xr)|22,=b_nml||; set name block code| 8765
||mov|13,nmofs(xr)|10,(xs)+||; set name offset from operand| 8766
||mov|13,nmbas(xr)|10,(xs)+||; set name base from operand| 8767
||mov|11,-(xs)|7,xr||; stack result| 8768
||lcw|7,xr|||; get next code word| 8769
||bri|9,(xr)|||; execute it| 8770
||ejc||||| 8771
;
;      negation
;
;      initial entry
;
|o_nta|ent||||; entry point| 8777
||lcw|8,wa|||; load new failure offset| 8778
||mov|11,-(xs)|3,flptr||; stack old failure pointer| 8779
||mov|11,-(xs)|8,wa||; stack new failure offset| 8780
||mov|3,flptr|7,xs||; set new failure pointer| 8781
||lcw|7,xr|||; get next code word| 8782
||bri|9,(xr)|||; execute next code word| 8783
;
;      entry after successful evaluation of operand
;
|o_ntb|ent||||; entry point| 8787
||mov|3,flptr|13,num02(xs)||; restore old failure pointer| 8788
||brn|6,exfal|||; and fail| 8789
;
;      entry for failure during operand evaluation
;
|o_ntc|ent||||; entry point| 8793
||ica|7,xs|||; pop failure offset| 8794
||mov|3,flptr|10,(xs)+||; restore old failure pointer| 8795
||brn|6,exnul|||; exit giving null result| 8796
||ejc||||| 8797
;
;      use of undefined operator
;
|o_oun|ent||||; entry point| 8801
||erb|1,029|26,undefined operator referenced||| 8802
||ejc||||| 8803
;
;      binary dot (pattern assignment)
;
;      the pattern built by binary dot is a compound pattern.
;      see description at start of pattern match section for
;      details of the structure which is constructed.
;
|o_pas|ent||||; entry point| 8811
||mov|8,wb|22,=p_pac||; load pcode for p_pac node| 8812
||mov|8,wc|10,(xs)+||; load name offset (parm2)| 8813
||mov|7,xr|10,(xs)+||; load name base (parm1)| 8814
||jsr|6,pbild|||; build p_pac node| 8815
||mov|7,xl|7,xr||; save ptr to node| 8816
||mov|7,xr|9,(xs)||; load left operand| 8817
||jsr|6,gtpat|||; convert to pattern| 8818
||err|1,030|26,pattern assignment left operand is not pattern||| 8819
||mov|9,(xs)|7,xr||; save ptr to left operand pattern| 8820
||mov|8,wb|22,=p_paa||; set pcode for p_paa node| 8821
||jsr|6,pbild|||; build p_paa node| 8822
||mov|13,pthen(xr)|10,(xs)+||; set left operand as p_paa successor| 8823
||jsr|6,pconc|||; concatenate to form final pattern| 8824
||mov|11,-(xs)|7,xr||; stack result| 8825
||lcw|7,xr|||; get next code word| 8826
||bri|9,(xr)|||; execute it| 8827
||ejc||||| 8828
;
;      pattern match (by name, for replacement)
;
|o_pmn|ent||||; entry point| 8832
||zer|8,wb|||; set type code for match by name| 8833
||brn|6,match|||; jump to routine to start match| 8834
||ejc||||| 8835
;
;      pattern match (statement)
;
;      o_pms is used in place of o_pmv when the pattern match
;      occurs at the outer (statement) level since in this
;      case the substring value need not be constructed.
;
|o_pms|ent||||; entry point| 8843
||mov|8,wb|18,=num02||; set flag for statement to match| 8844
||brn|6,match|||; jump to routine to start match| 8845
||ejc||||| 8846
;
;      pattern match (by value)
;
|o_pmv|ent||||; entry point| 8850
||mov|8,wb|18,=num01||; set type code for value match| 8851
||brn|6,match|||; jump to routine to start match| 8852
||ejc||||| 8853
;
;      pop top item on stack
;
|o_pop|ent||||; entry point| 8857
||ica|7,xs|||; pop top stack entry| 8858
||lcw|7,xr|||; get next code word| 8859
||bri|9,(xr)|||; execute next code word| 8860
||ejc||||| 8861
;
;      terminate execution (code compiled for end statement)
;
|o_stp|ent||||; entry point| 8865
||brn|6,lend0|||; jump to end circuit| 8866
||ejc||||| 8867
;
;      return name from expression
;      this entry points is used if the evaluation of an
;      expression, initiated by the evalx procedure, returns
;      a name. control is returned to the proper point in evalx.
;
|o_rnm|ent||||; entry point| 8874
||brn|6,evlx4|||; return to evalx procedure| 8875
||ejc||||| 8876
;
;      pattern replacement
;
;      when this routine gets control, the following stack
;      entries have been made (see end of match routine p_nth)
;
;			     subject name base
;			     subject name offset
;			     initial cursor value
;			     final cursor value
;			     subject string pointer
;      (xs) ---------------- replacement value
;
|o_rpl|ent||||; entry point| 8890
||jsr|6,gtstg|||; convert replacement val to string| 8891
||err|1,031|26,pattern replacement right operand is not a string||| 8892
;
;      get result length and allocate result scblk
;
||mov|7,xl|9,(xs)||; load subject string pointer| 8896
||add|8,wa|13,sclen(xl)||; add subject string length| 8901
||add|8,wa|13,num02(xs)||; add starting cursor| 8902
||sub|8,wa|13,num01(xs)||; minus final cursor = total length| 8903
||bze|8,wa|6,orpl3||; jump if result is null| 8904
||mov|11,-(xs)|7,xr||; restack replacement string| 8905
||jsr|6,alocs|||; allocate scblk for result| 8906
||mov|8,wa|13,num03(xs)||; get initial cursor (part 1 len)| 8907
||mov|13,num03(xs)|7,xr||; stack result pointer| 8908
||psc|7,xr|||; point to characters of result| 8909
;
;      move part 1 (start of subject) to result
;
||bze|8,wa|6,orpl1||; jump if first part is null| 8913
||mov|7,xl|13,num01(xs)||; else point to subject string| 8914
||plc|7,xl|||; point to subject string chars| 8915
||mvc||||; move first part to result| 8916
||ejc||||| 8917
;      pattern replacement (continued)
;
;      now move in replacement value
;
|orpl1|mov|7,xl|10,(xs)+||; load replacement string, pop| 8922
||mov|8,wa|13,sclen(xl)||; load length| 8923
||bze|8,wa|6,orpl2||; jump if null replacement| 8924
||plc|7,xl|||; else point to chars of replacement| 8925
||mvc||||; move in chars (part 2)| 8926
;
;      now move in remainder of string (part 3)
;
|orpl2|mov|7,xl|10,(xs)+||; load subject string pointer, pop| 8930
||mov|8,wc|10,(xs)+||; load final cursor, pop| 8931
||mov|8,wa|13,sclen(xl)||; load subject string length| 8932
||sub|8,wa|8,wc||; minus final cursor = part 3 length| 8933
||bze|8,wa|6,oass0||; jump to assign if part 3 is null| 8934
||plc|7,xl|8,wc||; else point to last part of string| 8935
||mvc||||; move part 3 to result| 8936
||brn|6,oass0|||; jump to perform assignment| 8937
;
;      here if result is null
;
|orpl3|add|7,xs|19,*num02||; pop subject str ptr, final cursor| 8941
||mov|9,(xs)|21,=nulls||; set null result| 8942
||brn|6,oass0|||; jump to assign null value| 8943
||ejc||||| 8962
;
;      return value from expression
;
;      this entry points is used if the evaluation of an
;      expression, initiated by the evalx procedure, returns
;      a value. control is returned to the proper point in evalx
;
|o_rvl|ent||||; entry point| 8970
||brn|6,evlx3|||; return to evalx procedure| 8971
||ejc||||| 8972
;
;      selection
;
;      initial entry
;
|o_sla|ent||||; entry point| 8978
||lcw|8,wa|||; load new failure offset| 8979
||mov|11,-(xs)|3,flptr||; stack old failure pointer| 8980
||mov|11,-(xs)|8,wa||; stack new failure offset| 8981
||mov|3,flptr|7,xs||; set new failure pointer| 8982
||lcw|7,xr|||; get next code word| 8983
||bri|9,(xr)|||; execute next code word| 8984
;
;      entry after successful evaluation of alternative
;
|o_slb|ent||||; entry point| 8988
||mov|7,xr|10,(xs)+||; load result| 8989
||ica|7,xs|||; pop fail offset| 8990
||mov|3,flptr|9,(xs)||; restore old failure pointer| 8991
||mov|9,(xs)|7,xr||; restack result| 8992
||lcw|8,wa|||; load new code offset| 8993
||add|8,wa|3,r_cod||; point to absolute code location| 8994
||lcp|8,wa|||; set new code pointer| 8995
||lcw|7,xr|||; get next code word| 8996
||bri|9,(xr)|||; execute next code word| 8997
;
;      entry at start of subsequent alternatives
;
|o_slc|ent||||; entry point| 9001
||lcw|8,wa|||; load new fail offset| 9002
||mov|9,(xs)|8,wa||; store new fail offset| 9003
||lcw|7,xr|||; get next code word| 9004
||bri|9,(xr)|||; execute next code word| 9005
;
;      entry at start of last alternative
;
|o_sld|ent||||; entry point| 9009
||ica|7,xs|||; pop failure offset| 9010
||mov|3,flptr|10,(xs)+||; restore old failure pointer| 9011
||lcw|7,xr|||; get next code word| 9012
||bri|9,(xr)|||; execute next code word| 9013
||ejc||||| 9014
;
;      binary minus (subtraction)
;
|o_sub|ent||||; entry point| 9018
||jsr|6,arith|||; fetch arithmetic operands| 9019
||err|1,032|26,subtraction left operand is not numeric||| 9020
||err|1,033|26,subtraction right operand is not numeric||| 9021
||ppm|6,osub1|||; jump if real operands| 9024
;
;      here to subtract two integers
;
||sbi|13,icval(xl)|||; subtract right operand from left| 9029
||ino|6,exint|||; return integer if no overflow| 9030
||erb|1,034|26,subtraction caused integer overflow||| 9031
;
;      here to subtract two reals
;
|osub1|sbr|13,rcval(xl)|||; subtract right operand from left| 9037
||rno|6,exrea|||; return real if no overflow| 9038
||erb|1,264|26,subtraction caused real overflow||| 9039
||ejc||||| 9041
;
;      dummy operator to return control to trxeq procedure
;
|o_txr|ent||||; entry point| 9045
||brn|6,trxq1|||; jump into trxeq procedure| 9046
||ejc||||| 9047
;
;      unexpected failure
;
;      note that if a setexit trap is operating then
;      transfer to system label continue
;      will result in looping here.  difficult to avoid except
;      with a considerable overhead which is not worthwhile or
;      else by a technique such as setting kverl to zero.
;
|o_unf|ent||||; entry point| 9057
||erb|1,035|26,unexpected failure in -nofail mode||| 9058
||ttl|27,s p i t b o l -- block action routines|||| 9059
;
;      the first word of every block in dynamic storage and the
;      vrget, vrsto and vrtra fields of a vrblk contain a
;      pointer to an entry point in the program. all such entry
;      points are in the following section except those for
;      pattern blocks which are in the pattern matching segment
;      later on (labels of the form p_xxx), and dope vectors
;      (d_xxx) which are in the dope vector section following
;      the pattern routines (dope vectors are used for cmblks).
;
;      the entry points in this section have labels of the
;      form b_xxy where xx is the two character block type for
;      the corresponding block and y is any letter.
;
;      in some cases, the pointers serve no other purpose than
;      to identify the block type. in this case the routine
;      is never executed and thus no code is assembled.
;
;      for each of these entry points corresponding to a block
;      an entry point identification is assembled (bl_xx).
;
;      the exact entry conditions depend on the manner in
;      which the routine is accessed and are documented with
;      the individual routines as required.
;
;      the order of these routines is alphabetical with the
;      following exceptions.
;
;      the routines for seblk and exblk entries occur first so
;      that expressions can be quickly identified from the fact
;      that their routines lie before the symbol b_e__.
;
;      these are immediately followed by the routine for a trblk
;      so that the test against the symbol b_t__ checks for
;      trapped values or expression values (see procedure evalp)
;
;      the pattern routines lie after this section so that
;      patterns are identified with routines starting at or
;      after the initial instruction in these routines (p_aaa).
;
;      the symbol b_aaa defines the first location for block
;      routines and the symbol p_yyy (at the end of the pattern
;      match routines section) defines the last such entry point
;
|b_aaa|ent|2,bl__i|||; entry point of first block routine| 9104
||ejc||||| 9105
;
;      exblk
;
;      the routine for an exblk loads the expression onto
;      the stack as a value.
;
;      (xr)		     pointer to exblk
;
|b_exl|ent|2,bl_ex|||; entry point (exblk)| 9114
||mov|11,-(xs)|7,xr||; stack result| 9115
||lcw|7,xr|||; get next code word| 9116
||bri|9,(xr)|||; execute it| 9117
||ejc||||| 9118
;
;      seblk
;
;      the routine for seblk is accessed from the generated
;      code to load the expression value onto the stack.
;
|b_sel|ent|2,bl_se|||; entry point (seblk)| 9125
||mov|11,-(xs)|7,xr||; stack result| 9126
||lcw|7,xr|||; get next code word| 9127
||bri|9,(xr)|||; execute it| 9128
;
;      define symbol which marks end of entries for expressions
;
|b_e__|ent|2,bl__i|||; entry point| 9132
||ejc||||| 9133
;
;      trblk
;
;      the routine for a trblk is never executed
;
|b_trt|ent|2,bl_tr|||; entry point (trblk)| 9139
;
;      define symbol marking end of trap and expression blocks
;
|b_t__|ent|2,bl__i|||; end of trblk,seblk,exblk entries| 9143
||ejc||||| 9144
;
;      arblk
;
;      the routine for arblk is never executed
;
|b_art|ent|2,bl_ar|||; entry point (arblk)| 9150
||ejc||||| 9151
;
;      bcblk
;
;      the routine for a bcblk is never executed
;
;      (xr)		     pointer to bcblk
;
|b_bct|ent|2,bl_bc|||; entry point (bcblk)| 9159
||ejc||||| 9160
;
;      bfblk
;
;      the routine for a bfblk is never executed
;
;      (xr)		     pointer to bfblk
;
|b_bft|ent|2,bl_bf|||; entry point (bfblk)| 9168
||ejc||||| 9169
;
;      ccblk
;
;      the routine for ccblk is never entered
;
|b_cct|ent|2,bl_cc|||; entry point (ccblk)| 9175
||ejc||||| 9176
;
;      cdblk
;
;      the cdblk routines are executed from the generated code.
;      there are two cases depending on the form of cdfal.
;
;      entry for complex failure code at cdfal
;
;      (xr)		     pointer to cdblk
;
|b_cdc|ent|2,bl_cd|||; entry point (cdblk)| 9187
|bcdc0|mov|7,xs|3,flptr||; pop garbage off stack| 9188
||mov|9,(xs)|13,cdfal(xr)||; set failure offset| 9189
||brn|6,stmgo|||; enter stmt| 9190
||ejc||||| 9191
;
;      cdblk (continued)
;
;      entry for simple failure code at cdfal
;
;      (xr)		     pointer to cdblk
;
|b_cds|ent|2,bl_cd|||; entry point (cdblk)| 9199
|bcds0|mov|7,xs|3,flptr||; pop garbage off stack| 9200
||mov|9,(xs)|19,*cdfal||; set failure offset| 9201
||brn|6,stmgo|||; enter stmt| 9202
||ejc||||| 9203
;
;      cmblk
;
;      the routine for a cmblk is never executed
;
|b_cmt|ent|2,bl_cm|||; entry point (cmblk)| 9209
||ejc||||| 9210
;
;      ctblk
;
;      the routine for a ctblk is never executed
;
|b_ctt|ent|2,bl_ct|||; entry point (ctblk)| 9216
||ejc||||| 9217
;
;      dfblk
;
;      the routine for a dfblk is accessed from the o_fnc entry
;      to call a datatype function and build a pdblk.
;
;      (xl)		     pointer to dfblk
;
|b_dfc|ent|2,bl_df|||; entry point| 9226
||mov|8,wa|13,dfpdl(xl)||; load length of pdblk| 9227
||jsr|6,alloc|||; allocate pdblk| 9228
||mov|9,(xr)|22,=b_pdt||; store type word| 9229
||mov|13,pddfp(xr)|7,xl||; store dfblk pointer| 9230
||mov|8,wc|7,xr||; save pointer to pdblk| 9231
||add|7,xr|8,wa||; point past pdblk| 9232
||lct|8,wa|13,fargs(xl)||; set to count fields| 9233
;
;      loop to acquire field values from stack
;
|bdfc1|mov|11,-(xr)|10,(xs)+||; move a field value| 9237
||bct|8,wa|6,bdfc1||; loop till all moved| 9238
||mov|7,xr|8,wc||; recall pointer to pdblk| 9239
||brn|6,exsid|||; exit setting id field| 9240
||ejc||||| 9241
;
;      efblk
;
;      the routine for an efblk is passed control form the o_fnc
;      entry to call an external function.
;
;      (xl)		     pointer to efblk
;
|b_efc|ent|2,bl_ef|||; entry point (efblk)| 9250
||mov|8,wc|13,fargs(xl)||; load number of arguments| 9253
||wtb|8,wc|||; convert to offset| 9254
||mov|11,-(xs)|7,xl||; save pointer to efblk| 9255
||mov|7,xt|7,xs||; copy pointer to arguments| 9256
;
;      loop to convert arguments
;
|befc1|ica|7,xt|||; point to next entry| 9260
||mov|7,xr|9,(xs)||; load pointer to efblk| 9261
||dca|8,wc|||; decrement eftar offset| 9262
||add|7,xr|8,wc||; point to next eftar entry| 9263
||mov|7,xr|13,eftar(xr)||; load eftar entry| 9264
||bsw|7,xr|1,5||; switch on type| 9273
||iff|1,0|6,befc7||; no conversion needed| 9291
||iff|1,1|6,befc2||; string| 9291
||iff|1,2|6,befc3||; integer| 9291
||iff|1,3|6,befc4||; real| 9291
||iff|1,4|6,beff1||; file| 9291
||esw||||; end of switch on type| 9291
;
;      here to convert to file
;
|beff1|mov|11,-(xs)|7,xt||; save entry pointer| 9296
||mov|3,befof|8,wc||; save offset| 9297
||mov|11,-(xs)|9,(xt)||; stack arg pointer| 9298
||jsr|6,iofcb|||; convert to fcb| 9299
||err|1,298|26,external function argument is not file||| 9300
||err|1,298|26,external function argument is not file||| 9301
||err|1,298|26,external function argument is not file||| 9302
||mov|7,xr|8,wa||; point to fcb| 9303
||mov|7,xt|10,(xs)+||; reload entry pointer| 9304
||brn|6,befc5|||; jump to merge| 9305
;
;      here to convert to string
;
|befc2|mov|11,-(xs)|9,(xt)||; stack arg ptr| 9310
||jsr|6,gtstg|||; convert argument to string| 9311
||err|1,039|26,external function argument is not a string||| 9312
||brn|6,befc6|||; jump to merge| 9313
||ejc||||| 9314
;
;      efblk (continued)
;
;      here to convert an integer
;
|befc3|mov|7,xr|9,(xt)||; load next argument| 9320
||mov|3,befof|8,wc||; save offset| 9321
||jsr|6,gtint|||; convert to integer| 9322
||err|1,040|26,external function argument is not integer||| 9323
||brn|6,befc5|||; merge with real case| 9326
;
;      here to convert a real
;
|befc4|mov|7,xr|9,(xt)||; load next argument| 9330
||mov|3,befof|8,wc||; save offset| 9331
||jsr|6,gtrea|||; convert to real| 9332
||err|1,265|26,external function argument is not real||| 9333
;
;      integer case merges here
;
|befc5|mov|8,wc|3,befof||; restore offset| 9338
;
;      string merges here
;
|befc6|mov|9,(xt)|7,xr||; store converted result| 9342
;
;      no conversion merges here
;
|befc7|bnz|8,wc|6,befc1||; loop back if more to go| 9346
;
;      here after converting all the arguments
;
||mov|7,xl|10,(xs)+||; restore efblk pointer| 9350
||mov|8,wa|13,fargs(xl)||; get number of args| 9351
||jsr|6,sysex|||; call routine to call external fnc| 9352
||ppm|6,exfal|||; fail if failure| 9353
||err|1,327|26,calling external function - not found||| 9354
||err|1,326|26,calling external function - bad argument type||| 9355
||wtb|8,wa|||; convert number of args to bytes| 9357
||add|7,xs|8,wa||; remove arguments from stack| 9358
||ejc||||| 9360
;
;      efblk (continued)
;
;      return here with result in xr
;
;      first defend against non-standard null string returned
;
||mov|8,wb|13,efrsl(xl)||; get result type id| 9368
||bnz|8,wb|6,befa8||; branch if not unconverted| 9369
||bne|9,(xr)|22,=b_scl|6,befc8|; jump if not a string| 9370
||bze|13,sclen(xr)|6,exnul||; return null if null| 9371
;
;      here if converted result to check for null string
;
|befa8|bne|8,wb|18,=num01|6,befc8|; jump if not a string| 9375
||bze|13,sclen(xr)|6,exnul||; return null if null| 9376
;
;      return if result is in dynamic storage
;
|befc8|blt|7,xr|3,dnamb|6,befc9|; jump if not in dynamic storage| 9380
||ble|7,xr|3,dnamp|6,exixr|; return result if already dynamic| 9381
;
;      here we copy a result into the dynamic region
;
|befc9|mov|8,wa|9,(xr)||; get possible type word| 9385
||bze|8,wb|6,bef11||; jump if unconverted result| 9386
||mov|8,wa|22,=b_scl||; string| 9387
||beq|8,wb|18,=num01|6,bef10|; yes jump| 9388
||mov|8,wa|22,=b_icl||; integer| 9389
||beq|8,wb|18,=num02|6,bef10|; yes jump| 9390
||mov|8,wa|22,=b_rcl||; real| 9393
;
;      store type word in result
;
|bef10|mov|9,(xr)|8,wa||; stored before copying to dynamic| 9398
;
;      merge for unconverted result
;
|bef11|beq|9,(xr)|22,=b_scl|6,bef12|; branch if string result| 9402
||jsr|6,blkln|||; get length of block| 9403
||mov|7,xl|7,xr||; copy address of old block| 9404
||jsr|6,alloc|||; allocate dynamic block same size| 9405
||mov|11,-(xs)|7,xr||; set pointer to new block as result| 9406
||mvw||||; copy old block to dynamic block| 9407
||zer|7,xl|||; clear garbage value| 9408
||lcw|7,xr|||; get next code word| 9409
||bri|9,(xr)|||; execute next code word| 9410
;
;      here to return a string result that was not in dynamic.
;      cannot use the simple word copy above because it will not
;      guarantee zero padding in the last word.
;
|bef12|mov|7,xl|7,xr||; save source string pointer| 9416
||mov|8,wa|13,sclen(xr)||; fetch string length| 9417
||bze|8,wa|6,exnul||; return null string if length zero| 9418
||jsr|6,alocs|||; allocate space for string| 9419
||mov|11,-(xs)|7,xr||; save as result pointer| 9420
||psc|7,xr|||; prepare to store chars of result| 9421
||plc|7,xl|||; point to chars in source string| 9422
||mov|8,wa|8,wc||; number of characters to copy| 9423
||mvc||||; move characters to result string| 9424
||zer|7,xl|||; clear garbage value| 9425
||lcw|7,xr|||; get next code word| 9426
||bri|9,(xr)|||; execute next code word| 9427
||ejc||||| 9429
;
;      evblk
;
;      the routine for an evblk is never executed
;
|b_evt|ent|2,bl_ev|||; entry point (evblk)| 9435
||ejc||||| 9436
;
;      ffblk
;
;      the routine for an ffblk is executed from the o_fnc entry
;      to call a field function and extract a field value/name.
;
;      (xl)		     pointer to ffblk
;
|b_ffc|ent|2,bl_ff|||; entry point (ffblk)| 9445
||mov|7,xr|7,xl||; copy ffblk pointer| 9446
||lcw|8,wc|||; load next code word| 9447
||mov|7,xl|9,(xs)||; load pdblk pointer| 9448
||bne|9,(xl)|22,=b_pdt|6,bffc2|; jump if not pdblk at all| 9449
||mov|8,wa|13,pddfp(xl)||; load dfblk pointer from pdblk| 9450
;
;      loop to find correct ffblk for this pdblk
;
|bffc1|beq|8,wa|13,ffdfp(xr)|6,bffc3|; jump if this is the correct ffblk| 9454
||mov|7,xr|13,ffnxt(xr)||; else link to next ffblk on chain| 9455
||bnz|7,xr|6,bffc1||; loop back if another entry to check| 9456
;
;      here for bad argument
;
|bffc2|erb|1,041|26,field function argument is wrong datatype||| 9460
||ejc||||| 9461
;
;      ffblk (continued)
;
;      here after locating correct ffblk
;
|bffc3|mov|8,wa|13,ffofs(xr)||; load field offset| 9467
||beq|8,wc|21,=ofne_|6,bffc5|; jump if called by name| 9468
||add|7,xl|8,wa||; else point to value field| 9469
||mov|7,xr|9,(xl)||; load value| 9470
||bne|9,(xr)|22,=b_trt|6,bffc4|; jump if not trapped| 9471
||sub|7,xl|8,wa||; else restore name base,offset| 9472
||mov|9,(xs)|8,wc||; save next code word over pdblk ptr| 9473
||jsr|6,acess|||; access value| 9474
||ppm|6,exfal|||; fail if access fails| 9475
||mov|8,wc|9,(xs)||; restore next code word| 9476
;
;      here after getting value in (xr), xl is garbage
;
|bffc4|mov|9,(xs)|7,xr||; store value on stack (over pdblk)| 9480
||mov|7,xr|8,wc||; copy next code word| 9481
||mov|7,xl|9,(xr)||; load entry address| 9482
||bri|7,xl|||; jump to routine for next code word| 9483
;
;      here if called by name
;
|bffc5|mov|11,-(xs)|8,wa||; store name offset (base is set)| 9487
||lcw|7,xr|||; get next code word| 9488
||bri|9,(xr)|||; execute next code word| 9489
||ejc||||| 9490
;
;      icblk
;
;      the routine for icblk is executed from the generated
;      code to load an integer value onto the stack.
;
;      (xr)		     pointer to icblk
;
|b_icl|ent|2,bl_ic|||; entry point (icblk)| 9499
||mov|11,-(xs)|7,xr||; stack result| 9500
||lcw|7,xr|||; get next code word| 9501
||bri|9,(xr)|||; execute it| 9502
||ejc||||| 9503
;
;      kvblk
;
;      the routine for a kvblk is never executed.
;
|b_kvt|ent|2,bl_kv|||; entry point (kvblk)| 9509
||ejc||||| 9510
;
;      nmblk
;
;      the routine for a nmblk is executed from the generated
;      code for the case of loading a name onto the stack
;      where the name is that of a natural variable which can
;      be preevaluated at compile time.
;
;      (xr)		     pointer to nmblk
;
|b_nml|ent|2,bl_nm|||; entry point (nmblk)| 9521
||mov|11,-(xs)|7,xr||; stack result| 9522
||lcw|7,xr|||; get next code word| 9523
||bri|9,(xr)|||; execute it| 9524
||ejc||||| 9525
;
;      pdblk
;
;      the routine for a pdblk is never executed
;
|b_pdt|ent|2,bl_pd|||; entry point (pdblk)| 9531
||ejc||||| 9532
;
;      pfblk
;
;      the routine for a pfblk is executed from the entry o_fnc
;      to call a program defined function.
;
;      (xl)		     pointer to pfblk
;
;      the following stack entries are made before passing
;      control to the program defined function.
;
;			     saved value of first argument
;			     .
;			     saved value of last argument
;			     saved value of first local
;			     .
;			     saved value of last local
;			     saved value of function name
;			     saved code block ptr (r_cod)
;			     saved code pointer (-r_cod)
;			     saved value of flprt
;			     saved value of flptr
;			     pointer to pfblk
;      flptr --------------- zero (to be overwritten with offs)
;
|b_pfc|ent|2,bl_pf|||; entry point (pfblk)| 9558
||mov|3,bpfpf|7,xl||; save pfblk ptr (need not be reloc)| 9559
||mov|7,xr|7,xl||; copy for the moment| 9560
||mov|7,xl|13,pfvbl(xr)||; point to vrblk for function| 9561
;
;      loop to find old value of function
;
|bpf01|mov|8,wb|7,xl||; save pointer| 9565
||mov|7,xl|13,vrval(xl)||; load value| 9566
||beq|9,(xl)|22,=b_trt|6,bpf01|; loop if trblk| 9567
;
;      set value to null and save old function value
;
||mov|3,bpfsv|7,xl||; save old value| 9571
||mov|7,xl|8,wb||; point back to block with value| 9572
||mov|13,vrval(xl)|21,=nulls||; set value to null| 9573
||mov|8,wa|13,fargs(xr)||; load number of arguments| 9574
||add|7,xr|19,*pfarg||; point to pfarg entries| 9575
||bze|8,wa|6,bpf04||; jump if no arguments| 9576
||mov|7,xt|7,xs||; ptr to last arg| 9577
||wtb|8,wa|||; convert no. of args to bytes offset| 9578
||add|7,xt|8,wa||; point before first arg| 9579
||mov|3,bpfxt|7,xt||; remember arg pointer| 9580
||ejc||||| 9581
;
;      pfblk (continued)
;
;      loop to save old argument values and set new ones
;
|bpf02|mov|7,xl|10,(xr)+||; load vrblk ptr for next argument| 9587
;
;      loop through possible trblk chain to find value
;
|bpf03|mov|8,wc|7,xl||; save pointer| 9591
||mov|7,xl|13,vrval(xl)||; load next value| 9592
||beq|9,(xl)|22,=b_trt|6,bpf03|; loop back if trblk| 9593
;
;      save old value and get new value
;
||mov|8,wa|7,xl||; keep old value| 9597
||mov|7,xt|3,bpfxt||; point before next stacked arg| 9598
||mov|8,wb|11,-(xt)||; load argument (new value)| 9599
||mov|9,(xt)|8,wa||; save old value| 9600
||mov|3,bpfxt|7,xt||; keep arg ptr for next time| 9601
||mov|7,xl|8,wc||; point back to block with value| 9602
||mov|13,vrval(xl)|8,wb||; set new value| 9603
||bne|7,xs|3,bpfxt|6,bpf02|; loop if not all done| 9604
;
;      now process locals
;
|bpf04|mov|7,xl|3,bpfpf||; restore pfblk pointer| 9608
||mov|8,wa|13,pfnlo(xl)||; load number of locals| 9609
||bze|8,wa|6,bpf07||; jump if no locals| 9610
||mov|8,wb|21,=nulls||; get null constant| 9611
||lct|8,wa|8,wa||; set local counter| 9612
;
;      loop to process locals
;
|bpf05|mov|7,xl|10,(xr)+||; load vrblk ptr for next local| 9616
;
;      loop through possible trblk chain to find value
;
|bpf06|mov|8,wc|7,xl||; save pointer| 9620
||mov|7,xl|13,vrval(xl)||; load next value| 9621
||beq|9,(xl)|22,=b_trt|6,bpf06|; loop back if trblk| 9622
;
;      save old value and set null as new value
;
||mov|11,-(xs)|7,xl||; stack old value| 9626
||mov|7,xl|8,wc||; point back to block with value| 9627
||mov|13,vrval(xl)|8,wb||; set null as new value| 9628
||bct|8,wa|6,bpf05||; loop till all locals processed| 9629
||ejc||||| 9630
;
;      pfblk (continued)
;
;      here after processing arguments and locals
;
|bpf07|zer|7,xr|||; zero reg xr in case| 9639
||bze|3,kvpfl|6,bpf7c||; skip if profiling is off| 9640
||beq|3,kvpfl|18,=num02|6,bpf7a|; branch on type of profile| 9641
;
;      here if &profile = 1
;
||jsr|6,systm|||; get current time| 9645
||sti|3,pfetm|||; save for a sec| 9646
||sbi|3,pfstm|||; find time used by caller| 9647
||jsr|6,icbld|||; build into an icblk| 9648
||ldi|3,pfetm|||; reload current time| 9649
||brn|6,bpf7b|||; merge| 9650
;
;	here if &profile = 2
;
|bpf7a|ldi|3,pfstm|||; get start time of calling stmt| 9654
||jsr|6,icbld|||; assemble an icblk round it| 9655
||jsr|6,systm|||; get now time| 9656
;
;      both types of profile merge here
;
|bpf7b|sti|3,pfstm|||; set start time of 1st func stmt| 9660
||mnz|3,pffnc|||; flag function entry| 9661
;
;      no profiling merges here
;
|bpf7c|mov|11,-(xs)|7,xr||; stack icblk ptr (or zero)| 9665
||mov|8,wa|3,r_cod||; load old code block pointer| 9666
||scp|8,wb|||; get code pointer| 9668
||sub|8,wb|8,wa||; make code pointer into offset| 9669
||mov|7,xl|3,bpfpf||; recall pfblk pointer| 9670
||mov|11,-(xs)|3,bpfsv||; stack old value of function name| 9671
||mov|11,-(xs)|8,wa||; stack code block pointer| 9672
||mov|11,-(xs)|8,wb||; stack code offset| 9673
||mov|11,-(xs)|3,flprt||; stack old flprt| 9674
||mov|11,-(xs)|3,flptr||; stack old failure pointer| 9675
||mov|11,-(xs)|7,xl||; stack pointer to pfblk| 9676
||zer|11,-(xs)|||; dummy zero entry for fail return| 9677
||chk||||; check for stack overflow| 9678
||mov|3,flptr|7,xs||; set new fail return value| 9679
||mov|3,flprt|7,xs||; set new flprt| 9680
||mov|8,wa|3,kvtra||; load trace value| 9681
||add|8,wa|3,kvftr||; add ftrace value| 9682
||bnz|8,wa|6,bpf09||; jump if tracing possible| 9683
||icv|3,kvfnc|||; else bump fnclevel| 9684
;
;      here to actually jump to function
;
|bpf08|mov|7,xr|13,pfcod(xl)||; point to vrblk of entry label| 9688
||mov|7,xr|13,vrlbl(xr)||; point to target code| 9689
||beq|7,xr|21,=stndl|6,bpf17|; test for undefined label| 9690
||bne|9,(xr)|22,=b_trt|6,bpf8a|; jump if not trapped| 9691
||mov|7,xr|13,trlbl(xr)||; else load ptr to real label code| 9692
|bpf8a|bri|9,(xr)|||; off to execute function| 9693
;
;      here if tracing is possible
;
|bpf09|mov|7,xr|13,pfctr(xl)||; load possible call trace trblk| 9697
||mov|7,xl|13,pfvbl(xl)||; load vrblk pointer for function| 9698
||mov|8,wa|19,*vrval||; set name offset for variable| 9699
||bze|3,kvtra|6,bpf10||; jump if trace mode is off| 9700
||bze|7,xr|6,bpf10||; or if there is no call trace| 9701
;
;      here if call traced
;
||dcv|3,kvtra|||; decrement trace count| 9705
||bze|13,trfnc(xr)|6,bpf11||; jump if print trace| 9706
||jsr|6,trxeq|||; execute function type trace| 9707
||ejc||||| 9708
;
;      pfblk (continued)
;
;      here to test for ftrace trace
;
|bpf10|bze|3,kvftr|6,bpf16||; jump if ftrace is off| 9714
||dcv|3,kvftr|||; else decrement ftrace| 9715
;
;      here for print trace
;
|bpf11|jsr|6,prtsn|||; print statement number| 9719
||jsr|6,prtnm|||; print function name| 9720
||mov|8,wa|18,=ch_pp||; load left paren| 9721
||jsr|6,prtch|||; print left paren| 9722
||mov|7,xl|13,num01(xs)||; recover pfblk pointer| 9723
||bze|13,fargs(xl)|6,bpf15||; skip if no arguments| 9724
||zer|8,wb|||; else set argument counter| 9725
||brn|6,bpf13|||; jump into loop| 9726
;
;      loop to print argument values
;
|bpf12|mov|8,wa|18,=ch_cm||; load comma| 9730
||jsr|6,prtch|||; print to separate from last arg| 9731
;
;      merge here first time (no comma required)
;
|bpf13|mov|9,(xs)|8,wb||; save arg ctr (over failoffs is ok)| 9735
||wtb|8,wb|||; convert to byte offset| 9736
||add|7,xl|8,wb||; point to next argument pointer| 9737
||mov|7,xr|13,pfarg(xl)||; load next argument vrblk ptr| 9738
||sub|7,xl|8,wb||; restore pfblk pointer| 9739
||mov|7,xr|13,vrval(xr)||; load next value| 9740
||jsr|6,prtvl|||; print argument value| 9741
||ejc||||| 9742
;
;      here after dealing with one argument
;
||mov|8,wb|9,(xs)||; restore argument counter| 9746
||icv|8,wb|||; increment argument counter| 9747
||blt|8,wb|13,fargs(xl)|6,bpf12|; loop if more to print| 9748
;
;      merge here in no args case to print paren
;
|bpf15|mov|8,wa|18,=ch_rp||; load right paren| 9752
||jsr|6,prtch|||; print to terminate output| 9753
||jsr|6,prtnl|||; terminate print line| 9754
;
;      merge here to exit with test for fnclevel trace
;
|bpf16|icv|3,kvfnc|||; increment fnclevel| 9758
||mov|7,xl|3,r_fnc||; load ptr to possible trblk| 9759
||jsr|6,ktrex|||; call keyword trace routine| 9760
;
;      call function after trace tests complete
;
||mov|7,xl|13,num01(xs)||; restore pfblk pointer| 9764
||brn|6,bpf08|||; jump back to execute function| 9765
;
;      here if calling a function whose entry label is undefined
;
|bpf17|mov|3,flptr|13,num02(xs)||; reset so exfal can return to evalx| 9769
||erb|1,286|26,function call to undefined entry label||| 9770
||ejc||||| 9773
;
;      rcblk
;
;      the routine for an rcblk is executed from the generated
;      code to load a real value onto the stack.
;
;      (xr)		     pointer to rcblk
;
|b_rcl|ent|2,bl_rc|||; entry point (rcblk)| 9782
||mov|11,-(xs)|7,xr||; stack result| 9783
||lcw|7,xr|||; get next code word| 9784
||bri|9,(xr)|||; execute it| 9785
||ejc||||| 9787
;
;      scblk
;
;      the routine for an scblk is executed from the generated
;      code to load a string value onto the stack.
;
;      (xr)		     pointer to scblk
;
|b_scl|ent|2,bl_sc|||; entry point (scblk)| 9796
||mov|11,-(xs)|7,xr||; stack result| 9797
||lcw|7,xr|||; get next code word| 9798
||bri|9,(xr)|||; execute it| 9799
||ejc||||| 9800
;
;      tbblk
;
;      the routine for a tbblk is never executed
;
|b_tbt|ent|2,bl_tb|||; entry point (tbblk)| 9806
||ejc||||| 9807
;
;      teblk
;
;      the routine for a teblk is never executed
;
|b_tet|ent|2,bl_te|||; entry point (teblk)| 9813
||ejc||||| 9814
;
;      vcblk
;
;      the routine for a vcblk is never executed
;
|b_vct|ent|2,bl_vc|||; entry point (vcblk)| 9820
||ejc||||| 9821
;
;      vrblk
;
;      the vrblk routines are executed from the generated code.
;      there are six entries for vrblk covering various cases
;
|b_vr_|ent|2,bl__i|||; mark start of vrblk entry points| 9828
;
;      entry for vrget (trapped case). this routine is called
;      from the generated code to load the value of a variable.
;      this entry point is used if an access trace or input
;      association is currently active.
;
;      (xr)		     pointer to vrget field of vrblk
;
|b_vra|ent|2,bl__i|||; entry point| 9837
||mov|7,xl|7,xr||; copy name base (vrget = 0)| 9838
||mov|8,wa|19,*vrval||; set name offset| 9839
||jsr|6,acess|||; access value| 9840
||ppm|6,exfal|||; fail if access fails| 9841
||mov|11,-(xs)|7,xr||; stack result| 9842
||lcw|7,xr|||; get next code word| 9843
||bri|9,(xr)|||; execute it| 9844
||ejc||||| 9845
;
;      vrblk (continued)
;
;      entry for vrsto (error case. this routine is called from
;      the executed code for an attempt to modify the value
;      of a protected (pattern valued) natural variable.
;
|b_vre|ent||||; entry point| 9853
||erb|1,042|26,attempt to change value of protected variable||| 9854
||ejc||||| 9855
;
;      vrblk (continued)
;
;      entry for vrtra (untrapped case). this routine is called
;      from the executed code to transfer to a label.
;
;      (xr)		     pointer to vrtra field of vrblk
;
|b_vrg|ent||||; entry point| 9864
||mov|7,xr|13,vrlbo(xr)||; load code pointer| 9865
||mov|7,xl|9,(xr)||; load entry address| 9866
||bri|7,xl|||; jump to routine for next code word| 9867
||ejc||||| 9868
;
;      vrblk (continued)
;
;      entry for vrget (untrapped case). this routine is called
;      from the generated code to load the value of a variable.
;
;      (xr)		     points to vrget field of vrblk
;
|b_vrl|ent||||; entry point| 9877
||mov|11,-(xs)|13,vrval(xr)||; load value onto stack (vrget = 0)| 9878
||lcw|7,xr|||; get next code word| 9879
||bri|9,(xr)|||; execute next code word| 9880
||ejc||||| 9881
;
;      vrblk (continued)
;
;      entry for vrsto (untrapped case). this routine is called
;      from the generated code to store the value of a variable.
;
;      (xr)		     pointer to vrsto field of vrblk
;
|b_vrs|ent||||; entry point| 9890
||mov|13,vrvlo(xr)|9,(xs)||; store value, leave on stack| 9891
||lcw|7,xr|||; get next code word| 9892
||bri|9,(xr)|||; execute next code word| 9893
||ejc||||| 9894
;
;      vrblk (continued)
;
;      vrtra (trapped case). this routine is called from the
;      generated code to transfer to a label when a label
;      trace is currently active.
;
|b_vrt|ent||||; entry point| 9902
||sub|7,xr|19,*vrtra||; point back to start of vrblk| 9903
||mov|7,xl|7,xr||; copy vrblk pointer| 9904
||mov|8,wa|19,*vrval||; set name offset| 9905
||mov|7,xr|13,vrlbl(xl)||; load pointer to trblk| 9906
||bze|3,kvtra|6,bvrt2||; jump if trace is off| 9907
||dcv|3,kvtra|||; else decrement trace count| 9908
||bze|13,trfnc(xr)|6,bvrt1||; jump if print trace case| 9909
||jsr|6,trxeq|||; else execute full trace| 9910
||brn|6,bvrt2|||; merge to jump to label| 9911
;
;      here for print trace -- print colon ( label name )
;
|bvrt1|jsr|6,prtsn|||; print statement number| 9915
||mov|7,xr|7,xl||; copy vrblk pointer| 9916
||mov|8,wa|18,=ch_cl||; colon| 9917
||jsr|6,prtch|||; print it| 9918
||mov|8,wa|18,=ch_pp||; left paren| 9919
||jsr|6,prtch|||; print it| 9920
||jsr|6,prtvn|||; print label name| 9921
||mov|8,wa|18,=ch_rp||; right paren| 9922
||jsr|6,prtch|||; print it| 9923
||jsr|6,prtnl|||; terminate line| 9924
||mov|7,xr|13,vrlbl(xl)||; point back to trblk| 9925
;
;      merge here to jump to label
;
|bvrt2|mov|7,xr|13,trlbl(xr)||; load pointer to actual code| 9929
||bri|9,(xr)|||; execute statement at label| 9930
||ejc||||| 9931
;
;      vrblk (continued)
;
;      entry for vrsto (trapped case). this routine is called
;      from the generated code to store the value of a variable.
;      this entry is used when a value trace or output
;      association is currently active.
;
;      (xr)		     pointer to vrsto field of vrblk
;
|b_vrv|ent||||; entry point| 9942
||mov|8,wb|9,(xs)||; load value (leave copy on stack)| 9943
||sub|7,xr|19,*vrsto||; point to vrblk| 9944
||mov|7,xl|7,xr||; copy vrblk pointer| 9945
||mov|8,wa|19,*vrval||; set offset| 9946
||jsr|6,asign|||; call assignment routine| 9947
||ppm|6,exfal|||; fail if assignment fails| 9948
||lcw|7,xr|||; else get next code word| 9949
||bri|9,(xr)|||; execute next code word| 9950
||ejc||||| 9951
;
;      xnblk
;
;      the routine for an xnblk is never executed
;
|b_xnt|ent|2,bl_xn|||; entry point (xnblk)| 9957
||ejc||||| 9958
;
;      xrblk
;
;      the routine for an xrblk is never executed
;
|b_xrt|ent|2,bl_xr|||; entry point (xrblk)| 9964
;
;      mark entry address past last block action routine
;
|b_yyy|ent|2,bl__i|||; last block routine entry point| 9968
||ttl|27,s p i t b o l -- pattern matching routines|||| 9969
;
;      the following section consists of the pattern matching
;      routines. all pattern nodes contain a pointer (pcode)
;      to one of the routines in this section (p_xxx).
;
;      note that this section follows the b_xxx routines to
;      enable a fast test for the pattern datatype.
;
|p_aaa|ent|2,bl__i|||; entry to mark first pattern| 9978
;
;
;      the entry conditions to the match routine are as follows
;      (see o_pmn, o_pmv, o_pms and procedure match).
;
;      stack contents.
;
;			     name base (o_pmn only)
;			     name offset (o_pmn only)
;			     type (0-o_pmn, 1-o_pmv, 2-o_pms)
;      pmhbs --------------- initial cursor (zero)
;			     initial node pointer
;      xs ------------------ =ndabo (anchored), =nduna (unanch)
;
;      register values.
;
;	    (xs)	     set as shown in stack diagram
;	    (xr)	     pointer to initial pattern node
;	    (wb)	     initial cursor (zero)
;
;      global pattern values
;
;	    r_pms	     pointer to subject string scblk
;	    pmssl	     length of subject string in chars
;	    pmdfl	     dot flag, initially zero
;	    pmhbs	     set as shown in stack diagram
;
;      control is passed by branching through the pcode
;      field of the initial pattern node (bri (xr)).
||ejc|||||10008
;
;      description of algorithm
;
;      a pattern structure is represented as a linked graph
;      of nodes with the following structure.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;	    i		     parm2		 i
;	    +------------------------------------+
;
;      pcode is a pointer to the routine which will perform
;      the match of this particular node type.
;
;      pthen is a pointer to the successor node. i.e. the node
;      to be matched if the attempt to match this node succeeds.
;      if this is the last node of the pattern pthen points
;      to the dummy node ndnth which initiates pattern exit.
;
;      parm1, parm2 are parameters whose use varies with the
;      particular node. they are only present if required.
;
;      alternatives are handled with the special alternative
;      node whose parameter points to the node to be matched
;      if there is a failure on the successor path.
;
;      the following example illustrates the manner in which
;      the structure is built up. the pattern is
;
;      (a / b / c) (d / e)   where / is alternation
;
;      in the diagram, the node marked + represents an
;      alternative node and the dotted line from a + node
;      represents the parameter pointer to the alternative.
;
;      +---+	 +---+	   +---+     +---+
;      i + i-----i a i-----i + i-----i d i-----
;      +---+	 +---+	i  +---+     +---+
;	 .		i    .
;	 .		i    .
;      +---+	 +---+	i  +---+
;      i + i-----i b i--i  i e i-----
;      +---+	 +---+	i  +---+
;	 .		i
;	 .		i
;      +---+		i
;      i c i------------i
;      +---+
||ejc|||||10062
;
;      during the match, the registers are used as follows.
;
;      (xr)		     points to the current node
;      (xl)		     scratch
;      (xs)		     main stack pointer
;      (wb)		     cursor (number of chars matched)
;      (wa,wc)		     scratch
;
;      to keep track of alternatives, the main stack is used as
;      a history stack and contains two word entries.
;
;      word 1		     saved cursor value
;      word 2		     node to match on failure
;
;      when a failure occurs, the most recent entry on this
;      stack is popped off to restore the cursor and point
;      to the node to be matched as an alternative. the entry
;      at the bottom of the stack points to the following
;      special nodes depending on the scan mode.
;
;      anchored mode	     the bottom entry points to the
;			     special node ndabo which causes an
;			     abort. the cursor value stored
;			     with this entry is always zero.
;
;      unanchored mode	     the bottom entry points to the
;			     special node nduna which moves the
;			     anchor point and restarts the match
;			     the cursor saved with this entry
;			     is the number of characters which
;			     lie before the initial anchor point
;			     (i.e. the number of anchor moves).
;			     this entry is three words long and
;			     also contains the initial pattern.
;
;      entries are made on this history stack by alternative
;      nodes and by some special compound patterns as described
;      later on. the following global locations are used during
;      pattern matching.
;
;      r_pms		     pointer to subject string
;      pmssl		     length of subject string
;      pmdfl		     flag set non-zero for dot patterns
;      pmhbs		     base ptr for current history stack
;
;      the following exit points are available to match routines
;
;      succp		     success in matching current node
;      failp		     failure in matching current node
||ejc|||||10113
;
;      compound patterns
;
;      some patterns have implicit alternatives and their
;      representation in the pattern structure consists of a
;      linked set of nodes as indicated by these diagrams.
;
;      as before, the + represents an alternative node and
;      the dotted line from a + node is the parameter pointer
;      to the alternative pattern.
;
;      arb
;      ---
;
;	    +---+	     this node (p_arb) matches null
;	    i b i-----	     and stacks cursor, successor ptr,
;	    +---+	     cursor (copy) and a ptr to ndarc.
;
;
;
;
;      bal
;      ---
;
;	    +---+	     the p_bal node scans a balanced
;	    i b i-----	     string and then stacks a pointer
;	    +---+	     to itself on the history stack.
||ejc|||||10141
;
;      compound pattern structures (continued)
;
;
;      arbno
;      -----
;
;	    +---+	     this alternative node matches null
;      +----i + i-----	     the first time and stacks a pointer
;      i    +---+	     to the argument pattern x.
;      i      .
;      i      .
;      i    +---+	     node (p_aba) to stack cursor
;      i    i a i	     and history stack base ptr.
;      i    +---+
;      i      i
;      i      i
;      i    +---+	     this is the argument pattern. as
;      i    i x i	     indicated, the successor of the
;      i    +---+	     pattern is the p_abc node
;      i      i
;      i      i
;      i    +---+	     this node (p_abc) pops pmhbs,
;      +----i c i	     stacks old pmhbs and ptr to ndabd
;	    +---+	     (unless optimization has occurred)
;
;      structure and execution of this pattern resemble those of
;      recursive pattern matching and immediate assignment.
;      the alternative node at the head of the structure matches
;      null initially but on subsequent failure ensures attempt
;      to match the argument.  before the argument is matched
;      p_aba stacks the cursor, pmhbs and a ptr to p_abb.  if
;      the argument cant be matched , p_abb removes this special
;      stack entry and fails.
;      if argument is matched , p_abc restores the outer pmhbs
;      value (saved by p_aba) .	 then if the argument has left
;      alternatives on stack it stacks the inner value of pmhbs
;      and a ptr to ndabd. if argument left nothing on the stack
;      it optimises by removing items stacked by p_aba.	 finally
;      a check is made that argument matched more than the null
;      string (check is intended to prevent useless looping).
;      if so the successor is again the alternative node at the
;      head of the structure , ensuring a possible extra attempt
;      to match the arg if necessary.  if not , the successor to
;      alternative is taken so as to terminate the loop.  p_abd
;      restores inner pmhbs ptr and fails , thus trying to match
;      alternatives left by the arbno argument.
||ejc|||||10189
;
;      compound pattern structures (continued)
;
;      breakx
;      ------
;
;	    +---+	     this node is a break node for
;      +----i b i	     the argument to breakx, identical
;      i    +---+	     to an ordinary break node.
;      i      i
;      i      i
;      i    +---+	     this alternative node stacks a
;      i    i + i-----	     pointer to the breakx node to
;      i    +---+	     allow for subsequent failure
;      i      .
;      i      .
;      i    +---+	     this is the breakx node itself. it
;      +----i x i	     matches one character and then
;	    +---+	     proceeds back to the break node.
;
;
;
;
;      fence
;      -----
;
;	    +---+	     the fence node matches null and
;	    i f i-----	     stacks a pointer to node ndabo to
;	    +---+	     abort on a subsequent rematch
;
;
;
;
;      succeed
;      -------
;
;	    +---+	     the node for succeed matches null
;	    i s i-----	     and stacks a pointer to itself
;	    +---+	     to repeat the match on a failure.
||ejc|||||10229
;
;      compound patterns (continued)
;
;      binary dot (pattern assignment)
;      -------------------------------
;
;	    +---+	     this node (p_paa) saves the current
;	    i a i	     cursor and a pointer to the
;	    +---+	     special node ndpab on the stack.
;	      i
;	      i
;	    +---+	     this is the structure for the
;	    i x i	     pattern left argument of the
;	    +---+	     pattern assignment call.
;	      i
;	      i
;	    +---+	     this node (p_pac) saves the cursor,
;	    i c i-----	     a ptr to itself, the cursor (copy)
;	    +---+	     and a ptr to ndpad on the stack.
;
;
;      the function of the match routine for ndpab (p_pab)
;      is simply to unstack itself and fail back onto the stack.
;
;      the match routine for p_pac also sets the global pattern
;      flag pmdfl non-zero to indicate that pattern assignments
;      may have occured in the pattern match
;
;      if pmdfl is set at the end of the match (see p_nth), the
;      history stack is scanned for matching ndpab-ndpad pairs
;      and the corresponding pattern assignments are executed.
;
;      the function of the match routine for ndpad (p_pad)
;      is simply to remove its entry from the stack and fail.
;      this includes removing the special node pointer stored
;      in addition to the standard two entries on the stack.
||ejc|||||10266
;
;      compount pattern structures (continued)
;
;      fence (function)
;      ----------------
;
;	    +---+	     this node (p_fna) saves the
;	    i a i	     current history stack and a
;	    +---+	     pointer to ndfnb on the stack.
;	      i
;	      i
;	    +---+	     this is the pattern structure
;	    i x i	     given as the argument to the
;	    +---+	     fence function.
;	      i
;	      i
;	    +---+	     this node p_fnc restores the outer
;	    i c i	     history stack ptr saved in p_fna,
;	    +---+	     and stacks the inner stack base
;			     ptr and a pointer to ndfnd on the
;			     stack.
;
;      ndfnb (f_fnb) simply is the failure exit for pattern
;      argument failure, and it pops itself and fails onto the
;      stack.
;
;      the match routine p_fnc allows for an optimization when
;      the fence pattern leaves no alternatives.  in this case,
;      the ndfnb entry is popped, and the match continues.
;
;      ndfnd (p_fnd) is entered when the pattern fails after
;      going through a non-optimized p_fnc, and it pops the
;      stack back past the innter stack base created by p_fna
||ejc|||||10300
;
;      compound patterns (continued)
;
;      expression patterns (recursive pattern matches)
;      -----------------------------------------------
;
;      initial entry for a pattern node is to the routine p_exa.
;      if the evaluated result of the expression is itself a
;      pattern, then the following steps are taken to arrange
;      for proper recursive processing.
;
;      1)   a pointer to the current node (the p_exa node) is
;	    stored on the history stack with a dummy cursor.
;
;      2)   a special history stack entry is made in which the
;	    node pointer points to ndexb, and the cursor value
;	    is the saved value of pmhbs on entry to this node.
;	    the match routine for ndexb (p_exb) restores pmhbs
;	    from this cursor entry, pops off the p_exa node
;	    pointer and fails.
;
;      3)   the resulting history stack pointer is saved in
;	    pmhbs to establish a new level of history stack.
;
;      after matching a pattern, the end of match routine gets
;      control (p_nth). this routine proceeds as follows.
;
;      1)   load the current value of pmhbs and recognize the
;	    outer level case by the fact that the associated
;	    cursor in this case is the pattern match type code
;	    which is less than 3. terminate the match in this
;	    case and continue execution of the program.
;
;      2)   otherwise make a special history stack entry in
;	    which the node pointer points to the special node
;	    ndexc and the cursor is the current value of pmhbs.
;	    the match routine for ndexc (p_exc) resets pmhbs to
;	    this (inner) value and and then fails.
;
;      3)   using the history stack entry made on starting the
;	    expression (accessible with the current value of
;	    pmhbs), restore the p_exa node pointer and the old
;	    pmhbs setting. take the successor and continue.
;
;      an optimization is possible if the expression pattern
;      makes no entries on the history stack. in this case,
;      instead of building the p_exc node in step 2, it is more
;      efficient to simply pop off the p_exb entry and its
;      associated node pointer. the effect is the same.
||ejc|||||10350
;
;      compound patterns (continued)
;
;      binary dollar (immediate assignment)
;      ------------------------------------
;
;	    +---+	     this node (p_ima) stacks the cursor
;	    i a i	     pmhbs and a ptr to ndimb and resets
;	    +---+	     the stack ptr pmhbs.
;	      i
;	      i
;	    +---+	     this is the left structure for the
;	    i x i	     pattern left argument of the
;	    +---+	     immediate assignment call.
;	      i
;	      i
;	    +---+	     this node (p_imc) performs the
;	    i c i-----	     assignment, pops pmhbs and stacks
;	    +---+	     the old pmhbs and a ptr to ndimd.
;
;
;      the structure and execution of this pattern are similar
;      to those of the recursive expression pattern matching.
;
;      the match routine for ndimb (p_imb) restores the outer
;      level value of pmhbs, unstacks the saved cursor and fails
;
;      the match routine p_imc uses the current value of pmhbs
;      to locate the p_imb entry. this entry is used to make
;      the assignment and restore the outer level value of
;      pmhbs. finally, the inner level value of pmhbs and a
;      pointer to the special node ndimd are stacked.
;
;      the match routine for ndimd (p_imd) restores the inner
;      level value of pmhbs and fails back into the stack.
;
;      an optimization occurs if the inner pattern makes no
;      entries on the history stack. in this case, p_imc pops
;      the p_imb entry instead of making a p_imd entry.
||ejc|||||10390
;
;      arbno
;
;      see compound patterns section for stucture and
;      algorithm for matching this node type.
;
;      no parameters
;
|p_aba|ent|2,bl_p0|||; p0blk|10399
||mov|11,-(xs)|8,wb||; stack cursor|10400
||mov|11,-(xs)|7,xr||; stack dummy node ptr|10401
||mov|11,-(xs)|3,pmhbs||; stack old stack base ptr|10402
||mov|11,-(xs)|21,=ndabb||; stack ptr to node ndabb|10403
||mov|3,pmhbs|7,xs||; store new stack base ptr|10404
||brn|6,succp|||; succeed|10405
||ejc|||||10406
;
;      arbno (remove p_aba special stack entry)
;
;      no parameters (dummy pattern)
;
|p_abb|ent||||; entry point|10412
||mov|3,pmhbs|8,wb||; restore history stack base ptr|10413
||brn|6,flpop|||; fail and pop dummy node ptr|10414
||ejc|||||10415
;
;      arbno (check if arg matched null string)
;
;      no parameters (dummy pattern)
;
|p_abc|ent|2,bl_p0|||; p0blk|10421
||mov|7,xt|3,pmhbs||; keep p_abb stack base|10422
||mov|8,wa|13,num03(xt)||; load initial cursor|10423
||mov|3,pmhbs|13,num01(xt)||; restore outer stack base ptr|10424
||beq|7,xt|7,xs|6,pabc1|; jump if no history stack entries|10425
||mov|11,-(xs)|7,xt||; else save inner pmhbs entry|10426
||mov|11,-(xs)|21,=ndabd||; stack ptr to special node ndabd|10427
||brn|6,pabc2|||; merge|10428
;
;      optimise case of no extra entries on stack from arbno arg
;
|pabc1|add|7,xs|19,*num04||; remove ndabb entry and cursor|10432
;
;      merge to check for matching of null string
;
|pabc2|bne|8,wa|8,wb|6,succp|; allow further attempt if non-null|10436
||mov|7,xr|13,pthen(xr)||; bypass alternative node so as to ...|10437
||brn|6,succp|||; ... refuse further match attempts|10438
||ejc|||||10439
;
;      arbno (try for alternatives in arbno argument)
;
;      no parameters (dummy pattern)
;
|p_abd|ent||||; entry point|10445
||mov|3,pmhbs|8,wb||; restore inner stack base ptr|10446
||brn|6,failp|||; and fail|10447
||ejc|||||10448
;
;      abort
;
;      no parameters
;
|p_abo|ent|2,bl_p0|||; p0blk|10454
||brn|6,exfal|||; signal statement failure|10455
||ejc|||||10456
;
;      alternation
;
;      parm1		     alternative node
;
|p_alt|ent|2,bl_p1|||; p1blk|10462
||mov|11,-(xs)|8,wb||; stack cursor|10463
||mov|11,-(xs)|13,parm1(xr)||; stack pointer to alternative|10464
||chk||||; check for stack overflow|10465
||brn|6,succp|||; if all ok, then succeed|10466
||ejc|||||10467
;
;      any (one character argument) (1-char string also)
;
;      parm1		     character argument
;
|p_ans|ent|2,bl_p1|||; p1blk|10473
||beq|8,wb|3,pmssl|6,failp|; fail if no chars left|10474
||mov|7,xl|3,r_pms||; else point to subject string|10475
||plc|7,xl|8,wb||; point to current character|10476
||lch|8,wa|9,(xl)||; load current character|10477
||bne|8,wa|13,parm1(xr)|6,failp|; fail if no match|10478
||icv|8,wb|||; else bump cursor|10479
||brn|6,succp|||; and succeed|10480
||ejc|||||10481
;
;      any (multi-character argument case)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit in ctblk
;
|p_any|ent|2,bl_p2|||; p2blk|10488
;
;      expression argument case merges here
;
|pany1|beq|8,wb|3,pmssl|6,failp|; fail if no characters left|10492
||mov|7,xl|3,r_pms||; else point to subject string|10493
||plc|7,xl|8,wb||; get char ptr to current character|10494
||lch|8,wa|9,(xl)||; load current character|10495
||mov|7,xl|13,parm1(xr)||; point to ctblk|10496
||wtb|8,wa|||; change to byte offset|10497
||add|7,xl|8,wa||; point to entry in ctblk|10498
||mov|8,wa|13,ctchs(xl)||; load word from ctblk|10499
||anb|8,wa|13,parm2(xr)||; and with selected bit|10500
||zrb|8,wa|6,failp||; fail if no match|10501
||icv|8,wb|||; else bump cursor|10502
||brn|6,succp|||; and succeed|10503
||ejc|||||10504
;
;      any (expression argument)
;
;      parm1		     expression pointer
;
|p_ayd|ent|2,bl_p1|||; p1blk|10510
||jsr|6,evals|||; evaluate string argument|10511
||err|1,043|26,any evaluated argument is not a string|||10512
||ppm|6,failp|||; fail if evaluation failure|10513
||ppm|6,pany1|||; merge multi-char case if ok|10514
||ejc|||||10515
;
;      p_arb		     initial arb match
;
;      no parameters
;
;      the p_arb node is part of a compound pattern structure
;      for an arb pattern (see description of compound patterns)
;
|p_arb|ent|2,bl_p0|||; p0blk|10524
||mov|7,xr|13,pthen(xr)||; load successor pointer|10525
||mov|11,-(xs)|8,wb||; stack dummy cursor|10526
||mov|11,-(xs)|7,xr||; stack successor pointer|10527
||mov|11,-(xs)|8,wb||; stack cursor|10528
||mov|11,-(xs)|21,=ndarc||; stack ptr to special node ndarc|10529
||bri|9,(xr)|||; execute next node matching null|10530
||ejc|||||10531
;
;      p_arc		     extend arb match
;
;      no parameters (dummy pattern)
;
|p_arc|ent||||; entry point|10537
||beq|8,wb|3,pmssl|6,flpop|; fail and pop stack to successor|10538
||icv|8,wb|||; else bump cursor|10539
||mov|11,-(xs)|8,wb||; stack updated cursor|10540
||mov|11,-(xs)|7,xr||; restack pointer to ndarc node|10541
||mov|7,xr|13,num02(xs)||; load successor pointer|10542
||bri|9,(xr)|||; off to reexecute successor node|10543
||ejc|||||10544
;
;      bal
;
;      no parameters
;
;      the p_bal node is part of the compound structure built
;      for bal (see section on compound patterns).
;
|p_bal|ent|2,bl_p0|||; p0blk|10553
||zer|8,wc|||; zero parentheses level counter|10554
||mov|7,xl|3,r_pms||; point to subject string|10555
||plc|7,xl|8,wb||; point to current character|10556
||brn|6,pbal2|||; jump into scan loop|10557
;
;      loop to scan out characters
;
|pbal1|lch|8,wa|10,(xl)+||; load next character, bump pointer|10561
||icv|8,wb|||; push cursor for character|10562
||beq|8,wa|18,=ch_pp|6,pbal3|; jump if left paren|10563
||beq|8,wa|18,=ch_rp|6,pbal4|; jump if right paren|10564
||bze|8,wc|6,pbal5||; else succeed if at outer level|10565
;
;      here after processing one character
;
|pbal2|bne|8,wb|3,pmssl|6,pbal1|; loop back unless end of string|10569
||brn|6,failp|||; in which case, fail|10570
;
;      here on left paren
;
|pbal3|icv|8,wc|||; bump paren level|10574
||brn|6,pbal2|||; loop back to check end of string|10575
;
;      here for right paren
;
|pbal4|bze|8,wc|6,failp||; fail if no matching left paren|10579
||dcv|8,wc|||; else decrement level counter|10580
||bnz|8,wc|6,pbal2||; loop back if not at outer level|10581
;
;      here after successfully scanning a balanced string
;
|pbal5|mov|11,-(xs)|8,wb||; stack cursor|10585
||mov|11,-(xs)|7,xr||; stack ptr to bal node for extend|10586
||brn|6,succp|||; and succeed|10587
||ejc|||||10588
;
;      break (expression argument)
;
;      parm1		     expression pointer
;
|p_bkd|ent|2,bl_p1|||; p1blk|10594
||jsr|6,evals|||; evaluate string expression|10595
||err|1,044|26,break evaluated argument is not a string|||10596
||ppm|6,failp|||; fail if evaluation fails|10597
||ppm|6,pbrk1|||; merge with multi-char case if ok|10598
||ejc|||||10599
;
;      break (one character argument)
;
;      parm1		     character argument
;
|p_bks|ent|2,bl_p1|||; p1blk|10605
||mov|8,wc|3,pmssl||; get subject string length|10606
||sub|8,wc|8,wb||; get number of characters left|10607
||bze|8,wc|6,failp||; fail if no characters left|10608
||lct|8,wc|8,wc||; set counter for chars left|10609
||mov|7,xl|3,r_pms||; point to subject string|10610
||plc|7,xl|8,wb||; point to current character|10611
;
;      loop to scan till break character found
;
|pbks1|lch|8,wa|10,(xl)+||; load next char, bump pointer|10615
||beq|8,wa|13,parm1(xr)|6,succp|; succeed if break character found|10616
||icv|8,wb|||; else push cursor|10617
||bct|8,wc|6,pbks1||; loop back if more to go|10618
||brn|6,failp|||; fail if end of string, no break chr|10619
||ejc|||||10620
;
;      break (multi-character argument)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
|p_brk|ent|2,bl_p2|||; p2blk|10627
;
;      expression argument merges here
;
|pbrk1|mov|8,wc|3,pmssl||; load subject string length|10631
||sub|8,wc|8,wb||; get number of characters left|10632
||bze|8,wc|6,failp||; fail if no characters left|10633
||lct|8,wc|8,wc||; set counter for characters left|10634
||mov|7,xl|3,r_pms||; else point to subject string|10635
||plc|7,xl|8,wb||; point to current character|10636
||mov|3,psave|7,xr||; save node pointer|10637
;
;      loop to search for break character
;
|pbrk2|lch|8,wa|10,(xl)+||; load next char, bump pointer|10641
||mov|7,xr|13,parm1(xr)||; load pointer to ctblk|10642
||wtb|8,wa|||; convert to byte offset|10643
||add|7,xr|8,wa||; point to ctblk entry|10644
||mov|8,wa|13,ctchs(xr)||; load ctblk word|10645
||mov|7,xr|3,psave||; restore node pointer|10646
||anb|8,wa|13,parm2(xr)||; and with selected bit|10647
||nzb|8,wa|6,succp||; succeed if break character found|10648
||icv|8,wb|||; else push cursor|10649
||bct|8,wc|6,pbrk2||; loop back unless end of string|10650
||brn|6,failp|||; fail if end of string, no break chr|10651
||ejc|||||10652
;
;      breakx (extension)
;
;      this is the entry which causes an extension of a breakx
;      match when failure occurs. see section on compound
;      patterns for full details of breakx matching.
;
;      no parameters
;
|p_bkx|ent|2,bl_p0|||; p0blk|10662
||icv|8,wb|||; step cursor past previous break chr|10663
||brn|6,succp|||; succeed to rematch break|10664
||ejc|||||10665
;
;      breakx (expression argument)
;
;      see section on compound patterns for full structure of
;      breakx pattern. the actual character matching uses a
;      break node. however, the entry for the expression
;      argument case is separated to get proper error messages.
;
;      parm1		     expression pointer
;
|p_bxd|ent|2,bl_p1|||; p1blk|10676
||jsr|6,evals|||; evaluate string argument|10677
||err|1,045|26,breakx evaluated argument is not a string|||10678
||ppm|6,failp|||; fail if evaluation fails|10679
||ppm|6,pbrk1|||; merge with break if all ok|10680
||ejc|||||10681
;
;      cursor assignment
;
;      parm1		     name base
;      parm2		     name offset
;
|p_cas|ent|2,bl_p2|||; p2blk|10688
||mov|11,-(xs)|7,xr||; save node pointer|10689
||mov|11,-(xs)|8,wb||; save cursor|10690
||mov|7,xl|13,parm1(xr)||; load name base|10691
||mti|8,wb|||; load cursor as integer|10692
||mov|8,wb|13,parm2(xr)||; load name offset|10693
||jsr|6,icbld|||; get icblk for cursor value|10694
||mov|8,wa|8,wb||; move name offset|10695
||mov|8,wb|7,xr||; move value to assign|10696
||jsr|6,asinp|||; perform assignment|10697
||ppm|6,flpop|||; fail on assignment failure|10698
||mov|8,wb|10,(xs)+||; else restore cursor|10699
||mov|7,xr|10,(xs)+||; restore node pointer|10700
||brn|6,succp|||; and succeed matching null|10701
||ejc|||||10702
;
;      expression node (p_exa, initial entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      parm1		     expression pointer
;
|p_exa|ent|2,bl_p1|||; p1blk|10711
||jsr|6,evalp|||; evaluate expression|10712
||ppm|6,failp|||; fail if evaluation fails|10713
||blo|8,wa|22,=p_aaa|6,pexa1|; jump if result is not a pattern|10714
;
;      here if result of expression is a pattern
;
||mov|11,-(xs)|8,wb||; stack dummy cursor|10718
||mov|11,-(xs)|7,xr||; stack ptr to p_exa node|10719
||mov|11,-(xs)|3,pmhbs||; stack history stack base ptr|10720
||mov|11,-(xs)|21,=ndexb||; stack ptr to special node ndexb|10721
||mov|3,pmhbs|7,xs||; store new stack base pointer|10722
||mov|7,xr|7,xl||; copy node pointer|10723
||bri|9,(xr)|||; match first node in expression pat|10724
;
;      here if result of expression is not a pattern
;
|pexa1|beq|8,wa|22,=b_scl|6,pexa2|; jump if it is already a string|10728
||mov|11,-(xs)|7,xl||; else stack result|10729
||mov|7,xl|7,xr||; save node pointer|10730
||jsr|6,gtstg|||; convert result to string|10731
||err|1,046|26,expression does not evaluate to pattern|||10732
||mov|8,wc|7,xr||; copy string pointer|10733
||mov|7,xr|7,xl||; restore node pointer|10734
||mov|7,xl|8,wc||; copy string pointer again|10735
;
;      merge here with string pointer in xl
;
|pexa2|bze|13,sclen(xl)|6,succp||; just succeed if null string|10739
||brn|6,pstr1|||; else merge with string circuit|10740
||ejc|||||10741
;
;      expression node (p_exb, remove ndexb entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      no parameters (dummy pattern)
;
|p_exb|ent||||; entry point|10750
||mov|3,pmhbs|8,wb||; restore outer level stack pointer|10751
||brn|6,flpop|||; fail and pop p_exa node ptr|10752
||ejc|||||10753
;
;      expression node (p_exc, remove ndexc entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      no parameters (dummy pattern)
;
|p_exc|ent||||; entry point|10762
||mov|3,pmhbs|8,wb||; restore inner stack base pointer|10763
||brn|6,failp|||; and fail into expr pattern alternvs|10764
||ejc|||||10765
;
;      fail
;
;      no parameters
;
|p_fal|ent|2,bl_p0|||; p0blk|10771
||brn|6,failp|||; just signal failure|10772
||ejc|||||10773
;
;      fence
;
;      see compound patterns section for the structure and
;      algorithm for matching this node type.
;
;      no parameters
;
|p_fen|ent|2,bl_p0|||; p0blk|10782
||mov|11,-(xs)|8,wb||; stack dummy cursor|10783
||mov|11,-(xs)|21,=ndabo||; stack ptr to abort node|10784
||brn|6,succp|||; and succeed matching null|10785
||ejc|||||10786
;
;      fence (function)
;
;      see compound patterns comments at start of this section
;      for details of scheme
;
;      no parameters
;
|p_fna|ent|2,bl_p0|||; p0blk|10795
||mov|11,-(xs)|3,pmhbs||; stack current history stack base|10796
||mov|11,-(xs)|21,=ndfnb||; stack indir ptr to p_fnb (failure)|10797
||mov|3,pmhbs|7,xs||; begin new history stack|10798
||brn|6,succp|||; succeed|10799
||ejc|||||10800
;
;      fence (function) (reset history stack and fail)
;
;      no parameters (dummy pattern)
;
|p_fnb|ent|2,bl_p0|||; p0blk|10806
||mov|3,pmhbs|8,wb||; restore outer pmhbs stack base|10807
||brn|6,failp|||; ...and fail|10808
||ejc|||||10809
;
;      fence (function) (make fence trap entry on stack)
;
;      no parameters (dummy pattern)
;
|p_fnc|ent|2,bl_p0|||; p0blk|10815
||mov|7,xt|3,pmhbs||; get inner stack base ptr|10816
||mov|3,pmhbs|13,num01(xt)||; restore outer stack base|10817
||beq|7,xt|7,xs|6,pfnc1|; optimize if no alternatives|10818
||mov|11,-(xs)|7,xt||; else stack inner stack base|10819
||mov|11,-(xs)|21,=ndfnd||; stack ptr to ndfnd|10820
||brn|6,succp|||; succeed|10821
;
;      here when fence function left nothing on the stack
;
|pfnc1|add|7,xs|19,*num02||; pop off p_fnb entry|10825
||brn|6,succp|||; succeed|10826
||ejc|||||10827
;
;      fence (function) (skip past alternatives on failure)
;
;      no parameters (dummy pattern)
;
|p_fnd|ent|2,bl_p0|||; p0blk|10833
||mov|7,xs|8,wb||; pop stack to fence() history base|10834
||brn|6,flpop|||; pop base entry and fail|10835
||ejc|||||10836
;
;      immediate assignment (initial entry, save current cursor)
;
;      see compound patterns description for details of the
;      structure and algorithm for matching this node type.
;
;      no parameters
;
|p_ima|ent|2,bl_p0|||; p0blk|10845
||mov|11,-(xs)|8,wb||; stack cursor|10846
||mov|11,-(xs)|7,xr||; stack dummy node pointer|10847
||mov|11,-(xs)|3,pmhbs||; stack old stack base pointer|10848
||mov|11,-(xs)|21,=ndimb||; stack ptr to special node ndimb|10849
||mov|3,pmhbs|7,xs||; store new stack base pointer|10850
||brn|6,succp|||; and succeed|10851
||ejc|||||10852
;
;      immediate assignment (remove cursor mark entry)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
|p_imb|ent||||; entry point|10861
||mov|3,pmhbs|8,wb||; restore history stack base ptr|10862
||brn|6,flpop|||; fail and pop dummy node ptr|10863
||ejc|||||10864
;
;      immediate assignment (perform actual assignment)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      parm1		     name base of variable
;      parm2		     name offset of variable
;
|p_imc|ent|2,bl_p2|||; p2blk|10874
||mov|7,xt|3,pmhbs||; load pointer to p_imb entry|10875
||mov|8,wa|8,wb||; copy final cursor|10876
||mov|8,wb|13,num03(xt)||; load initial cursor|10877
||mov|3,pmhbs|13,num01(xt)||; restore outer stack base pointer|10878
||beq|7,xt|7,xs|6,pimc1|; jump if no history stack entries|10879
||mov|11,-(xs)|7,xt||; else save inner pmhbs pointer|10880
||mov|11,-(xs)|21,=ndimd||; and a ptr to special node ndimd|10881
||brn|6,pimc2|||; merge|10882
;
;      here if no entries made on history stack
;
|pimc1|add|7,xs|19,*num04||; remove ndimb entry and cursor|10886
;
;      merge here to perform assignment
;
|pimc2|mov|11,-(xs)|8,wa||; save current (final) cursor|10890
||mov|11,-(xs)|7,xr||; save current node pointer|10891
||mov|7,xl|3,r_pms||; point to subject string|10892
||sub|8,wa|8,wb||; compute substring length|10893
||jsr|6,sbstr|||; build substring|10894
||mov|8,wb|7,xr||; move result|10895
||mov|7,xr|9,(xs)||; reload node pointer|10896
||mov|7,xl|13,parm1(xr)||; load name base|10897
||mov|8,wa|13,parm2(xr)||; load name offset|10898
||jsr|6,asinp|||; perform assignment|10899
||ppm|6,flpop|||; fail if assignment fails|10900
||mov|7,xr|10,(xs)+||; else restore node pointer|10901
||mov|8,wb|10,(xs)+||; restore cursor|10902
||brn|6,succp|||; and succeed|10903
||ejc|||||10904
;
;      immediate assignment (remove ndimd entry on failure)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
|p_imd|ent||||; entry point|10913
||mov|3,pmhbs|8,wb||; restore inner stack base pointer|10914
||brn|6,failp|||; and fail|10915
||ejc|||||10916
;
;      len (integer argument)
;
;      parm1		     integer argument
;
|p_len|ent|2,bl_p1|||; p1blk|10922
;
;      expression argument case merges here
;
|plen1|add|8,wb|13,parm1(xr)||; push cursor indicated amount|10926
||ble|8,wb|3,pmssl|6,succp|; succeed if not off end|10927
||brn|6,failp|||; else fail|10928
||ejc|||||10929
;
;      len (expression argument)
;
;      parm1		     expression pointer
;
|p_lnd|ent|2,bl_p1|||; p1blk|10935
||jsr|6,evali|||; evaluate integer argument|10936
||err|1,047|26,len evaluated argument is not integer|||10937
||err|1,048|26,len evaluated argument is negative or too large|||10938
||ppm|6,failp|||; fail if evaluation fails|10939
||ppm|6,plen1|||; merge with normal circuit if ok|10940
||ejc|||||10941
;
;      notany (expression argument)
;
;      parm1		     expression pointer
;
|p_nad|ent|2,bl_p1|||; p1blk|10947
||jsr|6,evals|||; evaluate string argument|10948
||err|1,049|26,notany evaluated argument is not a string|||10949
||ppm|6,failp|||; fail if evaluation fails|10950
||ppm|6,pnay1|||; merge with multi-char case if ok|10951
||ejc|||||10952
;
;      notany (one character argument)
;
;      parm1		     character argument
;
|p_nas|ent|2,bl_p1|||; entry point|10958
||beq|8,wb|3,pmssl|6,failp|; fail if no chars left|10959
||mov|7,xl|3,r_pms||; else point to subject string|10960
||plc|7,xl|8,wb||; point to current character in strin|10961
||lch|8,wa|9,(xl)||; load current character|10962
||beq|8,wa|13,parm1(xr)|6,failp|; fail if match|10963
||icv|8,wb|||; else bump cursor|10964
||brn|6,succp|||; and succeed|10965
||ejc|||||10966
;
;      notany (multi-character string argument)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
|p_nay|ent|2,bl_p2|||; p2blk|10973
;
;      expression argument case merges here
;
|pnay1|beq|8,wb|3,pmssl|6,failp|; fail if no characters left|10977
||mov|7,xl|3,r_pms||; else point to subject string|10978
||plc|7,xl|8,wb||; point to current character|10979
||lch|8,wa|9,(xl)||; load current character|10980
||wtb|8,wa|||; convert to byte offset|10981
||mov|7,xl|13,parm1(xr)||; load pointer to ctblk|10982
||add|7,xl|8,wa||; point to entry in ctblk|10983
||mov|8,wa|13,ctchs(xl)||; load entry from ctblk|10984
||anb|8,wa|13,parm2(xr)||; and with selected bit|10985
||nzb|8,wa|6,failp||; fail if character is matched|10986
||icv|8,wb|||; else bump cursor|10987
||brn|6,succp|||; and succeed|10988
||ejc|||||10989
;
;      end of pattern match
;
;      this routine is entered on successful completion.
;      see description of expression patterns in compound
;      pattern section for handling of recursion in matching.
;
;      this pattern also results from an attempt to convert the
;      null string to a pattern via convert()
;
;      no parameters (dummy pattern)
;
|p_nth|ent|2,bl_p0|||; p0blk (dummy)|11002
||mov|7,xt|3,pmhbs||; load pointer to base of stack|11003
||mov|8,wa|13,num01(xt)||; load saved pmhbs (or pattern type)|11004
||ble|8,wa|18,=num02|6,pnth2|; jump if outer level (pattern type)|11005
;
;      here we are at the end of matching an expression pattern
;
||mov|3,pmhbs|8,wa||; restore outer stack base pointer|11009
||mov|7,xr|13,num02(xt)||; restore pointer to p_exa node|11010
||beq|7,xt|7,xs|6,pnth1|; jump if no history stack entries|11011
||mov|11,-(xs)|7,xt||; else stack inner stack base ptr|11012
||mov|11,-(xs)|21,=ndexc||; stack ptr to special node ndexc|11013
||brn|6,succp|||; and succeed|11014
;
;      here if no history stack entries during pattern
;
|pnth1|add|7,xs|19,*num04||; remove p_exb entry and node ptr|11018
||brn|6,succp|||; and succeed|11019
;
;      here if end of match at outer level
;
|pnth2|mov|3,pmssl|8,wb||; save final cursor in safe place|11023
||bze|3,pmdfl|6,pnth6||; jump if no pattern assignments|11024
||ejc|||||11025
;
;      end of pattern match (continued)
;
;      now we must perform pattern assignments. this is done by
;      scanning the history stack for matching ndpab-ndpad pairs
;
|pnth3|dca|7,xt|||; point past cursor entry|11032
||mov|8,wa|11,-(xt)||; load node pointer|11033
||beq|8,wa|21,=ndpad|6,pnth4|; jump if ndpad entry|11034
||bne|8,wa|21,=ndpab|6,pnth5|; jump if not ndpab entry|11035
;
;      here for ndpab entry, stack initial cursor
;      note that there must be more entries on the stack.
;
||mov|11,-(xs)|13,num01(xt)||; stack initial cursor|11040
||chk||||; check for stack overflow|11041
||brn|6,pnth3|||; loop back if ok|11042
;
;      here for ndpad entry. the starting cursor from the
;      matching ndpad entry is now the top stack entry.
;
|pnth4|mov|8,wa|13,num01(xt)||; load final cursor|11047
||mov|8,wb|9,(xs)||; load initial cursor from stack|11048
||mov|9,(xs)|7,xt||; save history stack scan ptr|11049
||sub|8,wa|8,wb||; compute length of string|11050
;
;      build substring and perform assignment
;
||mov|7,xl|3,r_pms||; point to subject string|11054
||jsr|6,sbstr|||; construct substring|11055
||mov|8,wb|7,xr||; copy substring pointer|11056
||mov|7,xt|9,(xs)||; reload history stack scan ptr|11057
||mov|7,xl|13,num02(xt)||; load pointer to p_pac node with nam|11058
||mov|8,wa|13,parm2(xl)||; load name offset|11059
||mov|7,xl|13,parm1(xl)||; load name base|11060
||jsr|6,asinp|||; perform assignment|11061
||ppm|6,exfal|||; match fails if name eval fails|11062
||mov|7,xt|10,(xs)+||; else restore history stack ptr|11063
||ejc|||||11064
;
;      end of pattern match (continued)
;
;      here check for end of entries
;
|pnth5|bne|7,xt|7,xs|6,pnth3|; loop if more entries to scan|11070
;
;      here after dealing with pattern assignments
;
|pnth6|mov|7,xs|3,pmhbs||; wipe out history stack|11074
||mov|8,wb|10,(xs)+||; load initial cursor|11075
||mov|8,wc|10,(xs)+||; load match type code|11076
||mov|8,wa|3,pmssl||; load final cursor value|11077
||mov|7,xl|3,r_pms||; point to subject string|11078
||zer|3,r_pms|||; clear subject string ptr for gbcol|11079
||bze|8,wc|6,pnth7||; jump if call by name|11080
||beq|8,wc|18,=num02|6,pnth9|; exit if statement level call|11081
;
;      here we have a call by value, build substring
;
||sub|8,wa|8,wb||; compute length of string|11085
||jsr|6,sbstr|||; build substring|11086
||mov|11,-(xs)|7,xr||; stack result|11087
||lcw|7,xr|||; get next code word|11088
||bri|9,(xr)|||; execute it|11089
;
;      here for call by name, make stack entries for o_rpl
;
|pnth7|mov|11,-(xs)|8,wb||; stack initial cursor|11093
||mov|11,-(xs)|8,wa||; stack final cursor|11094
;
;      here with xl pointing to scblk or bcblk
;
|pnth8|mov|11,-(xs)|7,xl||; stack subject pointer|11103
;
;      here to obey next code word
;
|pnth9|lcw|7,xr|||; get next code word|11107
||bri|9,(xr)|||; execute next code word|11108
||ejc|||||11109
;
;      pos (integer argument)
;
;      parm1		     integer argument
;
|p_pos|ent|2,bl_p1|||; p1blk|11115
;
;      optimize pos if it is the first pattern element,
;      unanchored mode, cursor is zero and pos argument
;      is not beyond end of string.  force cursor position
;      and number of unanchored moves.
;
;      this optimization is performed invisible provided
;      the argument is either a simple integer or an
;      expression that is an untraced variable (that is,
;      it has no side effects that would be lost by short-
;      circuiting the normal logic of failing and moving the
;      unanchored starting point.)
;
;      pos (integer argument)
;
;      parm1		     integer argument
;
||beq|8,wb|13,parm1(xr)|6,succp|; succeed if at right location|11133
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11134
||mov|7,xt|3,pmhbs||; get history stack base ptr|11135
||bne|7,xr|11,-(xt)|6,failp|; fail if pos is not first node|11136
;
;      expression argument circuit merges here
;
|ppos2|bne|11,-(xt)|21,=nduna|6,failp|; fail if not unanchored mode|11140
||mov|8,wb|13,parm1(xr)||; get desired cursor position|11141
||bgt|8,wb|3,pmssl|6,exfal|; abort if off end|11142
||mov|13,num02(xt)|8,wb||; fake number of unanchored moves|11143
||brn|6,succp|||; continue match with adjusted cursor|11144
||ejc|||||11145
;
;      pos (expression argument)
;
;      parm1		     expression pointer
;
|p_psd|ent|2,bl_p1|||; p1blk|11151
||jsr|6,evali|||; evaluate integer argument|11152
||err|1,050|26,pos evaluated argument is not integer|||11153
||err|1,051|26,pos evaluated argument is negative or too large|||11154
||ppm|6,failp|||; fail if evaluation fails|11155
||ppm|6,ppos1|||; process expression case|11156
;
|ppos1|beq|8,wb|13,parm1(xr)|6,succp|; succeed if at right location|11158
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11159
||bnz|3,evlif|6,failp||; fail if complex argument|11160
||mov|7,xt|3,pmhbs||; get history stack base ptr|11161
||mov|8,wa|3,evlio||; get original node ptr|11162
||bne|8,wa|11,-(xt)|6,failp|; fail if pos is not first node|11163
||brn|6,ppos2|||; merge with integer argument code|11164
||ejc|||||11165
;
;      pattern assignment (initial entry, save cursor)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters
;
|p_paa|ent|2,bl_p0|||; p0blk|11174
||mov|11,-(xs)|8,wb||; stack initial cursor|11175
||mov|11,-(xs)|21,=ndpab||; stack ptr to ndpab special node|11176
||brn|6,succp|||; and succeed matching null|11177
||ejc|||||11178
;
;      pattern assignment (remove saved cursor)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
|p_pab|ent||||; entry point|11187
||brn|6,failp|||; just fail (entry is already popped)|11188
||ejc|||||11189
;
;      pattern assignment (end of match, make assign entry)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      parm1		     name base of variable
;      parm2		     name offset of variable
;
|p_pac|ent|2,bl_p2|||; p2blk|11199
||mov|11,-(xs)|8,wb||; stack dummy cursor value|11200
||mov|11,-(xs)|7,xr||; stack pointer to p_pac node|11201
||mov|11,-(xs)|8,wb||; stack final cursor|11202
||mov|11,-(xs)|21,=ndpad||; stack ptr to special ndpad node|11203
||mnz|3,pmdfl|||; set dot flag non-zero|11204
||brn|6,succp|||; and succeed|11205
||ejc|||||11206
;
;      pattern assignment (remove assign entry)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters (dummy node)
;
|p_pad|ent||||; entry point|11215
||brn|6,flpop|||; fail and remove p_pac node|11216
||ejc|||||11217
;
;      rem
;
;      no parameters
;
|p_rem|ent|2,bl_p0|||; p0blk|11223
||mov|8,wb|3,pmssl||; point cursor to end of string|11224
||brn|6,succp|||; and succeed|11225
||ejc|||||11226
;
;      rpos (expression argument)
;
;      optimize rpos if it is the first pattern element,
;      unanchored mode, cursor is zero and rpos argument
;      is not beyond end of string.  force cursor position
;      and number of unanchored moves.
;
;      this optimization is performed invisibly provided
;      the argument is either a simple integer or an
;      expression that is an untraced variable (that is,
;      it has no side effects that would be lost by short-
;      circuiting the normal logic of failing and moving the
;      unanchored starting point).
;
;      parm1		     expression pointer
;
|p_rpd|ent|2,bl_p1|||; p1blk|11244
||jsr|6,evali|||; evaluate integer argument|11245
||err|1,052|26,rpos evaluated argument is not integer|||11246
||err|1,053|26,rpos evaluated argument is negative or too large|||11247
||ppm|6,failp|||; fail if evaluation fails|11248
||ppm|6,prps1|||; merge with normal case if ok|11249
;
|prps1|mov|8,wc|3,pmssl||; get length of string|11251
||sub|8,wc|8,wb||; get number of characters remaining|11252
||beq|8,wc|13,parm1(xr)|6,succp|; succeed if at right location|11253
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11254
||bnz|3,evlif|6,failp||; fail if complex argument|11255
||mov|7,xt|3,pmhbs||; get history stack base ptr|11256
||mov|8,wa|3,evlio||; get original node ptr|11257
||bne|8,wa|11,-(xt)|6,failp|; fail if pos is not first node|11258
||brn|6,prps2|||; merge with integer arg code|11259
||ejc|||||11260
;
;      rpos (integer argument)
;
;      parm1		     integer argument
;
|p_rps|ent|2,bl_p1|||; p1blk|11266
;
;      rpos (integer argument)
;
;      parm1		     integer argument
;
||mov|8,wc|3,pmssl||; get length of string|11272
||sub|8,wc|8,wb||; get number of characters remaining|11273
||beq|8,wc|13,parm1(xr)|6,succp|; succeed if at right location|11274
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11275
||mov|7,xt|3,pmhbs||; get history stack base ptr|11276
||bne|7,xr|11,-(xt)|6,failp|; fail if rpos is not first node|11277
;
;      expression argument merges here
;
|prps2|bne|11,-(xt)|21,=nduna|6,failp|; fail if not unanchored mode|11281
||mov|8,wb|3,pmssl||; point to end of string|11282
||blt|8,wb|13,parm1(xr)|6,failp|; fail if string not long enough|11283
||sub|8,wb|13,parm1(xr)||; else set new cursor|11284
||mov|13,num02(xt)|8,wb||; fake number of unanchored moves|11285
||brn|6,succp|||; continue match with adjusted cursor|11286
||ejc|||||11287
;
;      rtab (integer argument)
;
;      parm1		     integer argument
;
|p_rtb|ent|2,bl_p1|||; p1blk|11293
;
;      expression argument case merges here
;
|prtb1|mov|8,wc|8,wb||; save initial cursor|11297
||mov|8,wb|3,pmssl||; point to end of string|11298
||blt|8,wb|13,parm1(xr)|6,failp|; fail if string not long enough|11299
||sub|8,wb|13,parm1(xr)||; else set new cursor|11300
||bge|8,wb|8,wc|6,succp|; and succeed if not too far already|11301
||brn|6,failp|||; in which case, fail|11302
||ejc|||||11303
;
;      rtab (expression argument)
;
;      parm1		     expression pointer
;
|p_rtd|ent|2,bl_p1|||; p1blk|11309
||jsr|6,evali|||; evaluate integer argument|11310
||err|1,054|26,rtab evaluated argument is not integer|||11311
||err|1,055|26,rtab evaluated argument is negative or too large|||11312
||ppm|6,failp|||; fail if evaluation fails|11313
||ppm|6,prtb1|||; merge with normal case if success|11314
||ejc|||||11315
;
;      span (expression argument)
;
;      parm1		     expression pointer
;
|p_spd|ent|2,bl_p1|||; p1blk|11321
||jsr|6,evals|||; evaluate string argument|11322
||err|1,056|26,span evaluated argument is not a string|||11323
||ppm|6,failp|||; fail if evaluation fails|11324
||ppm|6,pspn1|||; merge with multi-char case if ok|11325
||ejc|||||11326
;
;      span (multi-character argument case)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
|p_spn|ent|2,bl_p2|||; p2blk|11333
;
;      expression argument case merges here
;
|pspn1|mov|8,wc|3,pmssl||; copy subject string length|11337
||sub|8,wc|8,wb||; calculate number of characters left|11338
||bze|8,wc|6,failp||; fail if no characters left|11339
||mov|7,xl|3,r_pms||; point to subject string|11340
||plc|7,xl|8,wb||; point to current character|11341
||mov|3,psavc|8,wb||; save initial cursor|11342
||mov|3,psave|7,xr||; save node pointer|11343
||lct|8,wc|8,wc||; set counter for chars left|11344
;
;      loop to scan matching characters
;
|pspn2|lch|8,wa|10,(xl)+||; load next character, bump pointer|11348
||wtb|8,wa|||; convert to byte offset|11349
||mov|7,xr|13,parm1(xr)||; point to ctblk|11350
||add|7,xr|8,wa||; point to ctblk entry|11351
||mov|8,wa|13,ctchs(xr)||; load ctblk entry|11352
||mov|7,xr|3,psave||; restore node pointer|11353
||anb|8,wa|13,parm2(xr)||; and with selected bit|11354
||zrb|8,wa|6,pspn3||; jump if no match|11355
||icv|8,wb|||; else push cursor|11356
||bct|8,wc|6,pspn2||; loop back unless end of string|11357
;
;      here after scanning matching characters
;
|pspn3|bne|8,wb|3,psavc|6,succp|; succeed if chars matched|11361
||brn|6,failp|||; else fail if null string matched|11362
||ejc|||||11363
;
;      span (one character argument)
;
;      parm1		     character argument
;
|p_sps|ent|2,bl_p1|||; p1blk|11369
||mov|8,wc|3,pmssl||; get subject string length|11370
||sub|8,wc|8,wb||; calculate number of characters left|11371
||bze|8,wc|6,failp||; fail if no characters left|11372
||mov|7,xl|3,r_pms||; else point to subject string|11373
||plc|7,xl|8,wb||; point to current character|11374
||mov|3,psavc|8,wb||; save initial cursor|11375
||lct|8,wc|8,wc||; set counter for characters left|11376
;
;      loop to scan matching characters
;
|psps1|lch|8,wa|10,(xl)+||; load next character, bump pointer|11380
||bne|8,wa|13,parm1(xr)|6,psps2|; jump if no match|11381
||icv|8,wb|||; else push cursor|11382
||bct|8,wc|6,psps1||; and loop unless end of string|11383
;
;      here after scanning matching characters
;
|psps2|bne|8,wb|3,psavc|6,succp|; succeed if chars matched|11387
||brn|6,failp|||; fail if null string matched|11388
||ejc|||||11389
;
;      multi-character string
;
;      note that one character strings use the circuit for
;      one character any arguments (p_an1).
;
;      parm1		     pointer to scblk for string arg
;
|p_str|ent|2,bl_p1|||; p1blk|11398
||mov|7,xl|13,parm1(xr)||; get pointer to string|11399
;
;      merge here after evaluating expression with string value
;
|pstr1|mov|3,psave|7,xr||; save node pointer|11403
||mov|7,xr|3,r_pms||; load subject string pointer|11404
||plc|7,xr|8,wb||; point to current character|11405
||add|8,wb|13,sclen(xl)||; compute new cursor position|11406
||bgt|8,wb|3,pmssl|6,failp|; fail if past end of string|11407
||mov|3,psavc|8,wb||; save updated cursor|11408
||mov|8,wa|13,sclen(xl)||; get number of chars to compare|11409
||plc|7,xl|||; point to chars of test string|11410
||cmc|6,failp|6,failp||; compare, fail if not equal|11411
||mov|7,xr|3,psave||; if all matched, restore node ptr|11412
||mov|8,wb|3,psavc||; restore updated cursor|11413
||brn|6,succp|||; and succeed|11414
||ejc|||||11415
;
;      succeed
;
;      see section on compound patterns for details of the
;      structure and algorithms for matching this node type
;
;      no parameters
;
|p_suc|ent|2,bl_p0|||; p0blk|11424
||mov|11,-(xs)|8,wb||; stack cursor|11425
||mov|11,-(xs)|7,xr||; stack pointer to this node|11426
||brn|6,succp|||; succeed matching null|11427
||ejc|||||11428
;
;      tab (integer argument)
;
;      parm1		     integer argument
;
|p_tab|ent|2,bl_p1|||; p1blk|11434
;
;      expression argument case merges here
;
|ptab1|bgt|8,wb|13,parm1(xr)|6,failp|; fail if too far already|11438
||mov|8,wb|13,parm1(xr)||; else set new cursor position|11439
||ble|8,wb|3,pmssl|6,succp|; succeed if not off end|11440
||brn|6,failp|||; else fail|11441
||ejc|||||11442
;
;      tab (expression argument)
;
;      parm1		     expression pointer
;
|p_tbd|ent|2,bl_p1|||; p1blk|11448
||jsr|6,evali|||; evaluate integer argument|11449
||err|1,057|26,tab evaluated argument is not integer|||11450
||err|1,058|26,tab evaluated argument is negative or too large|||11451
||ppm|6,failp|||; fail if evaluation fails|11452
||ppm|6,ptab1|||; merge with normal case if ok|11453
||ejc|||||11454
;
;      anchor movement
;
;      no parameters (dummy node)
;
|p_una|ent||||; entry point|11460
||mov|7,xr|8,wb||; copy initial pattern node pointer|11461
||mov|8,wb|9,(xs)||; get initial cursor|11462
||beq|8,wb|3,pmssl|6,exfal|; match fails if at end of string|11463
||icv|8,wb|||; else increment cursor|11464
||mov|9,(xs)|8,wb||; store incremented cursor|11465
||mov|11,-(xs)|7,xr||; restack initial node ptr|11466
||mov|11,-(xs)|21,=nduna||; restack unanchored node|11467
||bri|9,(xr)|||; rematch first node|11468
||ejc|||||11469
;
;      end of pattern match routines
;
;      the following entry point marks the end of the pattern
;      matching routines and also the end of the entry points
;      referenced from the first word of blocks in dynamic store
;
|p_yyy|ent|2,bl__i|||; mark last entry in pattern section|11477
||ttl|27,s p i t b o l -- snobol4 built-in label routines||||11478
;
;      the following section contains the routines for labels
;      which have a predefined meaning in snobol4.
;
;      control is passed directly to the label name entry point.
;
;      entry names are of the form l_xxx where xxx is the three
;      letter variable name identifier.
;
;      entries are in alphabetical order
||ejc|||||11489
;
;      abort
;
|l_abo|ent||||; entry point|11493
;
;      merge here if execution terminates in error
;
|labo1|mov|8,wa|3,kvert||; load error code|11497
||bze|8,wa|6,labo3||; jump if no error has occured|11498
||jsr|6,sysax|||; call after execution proc|11500
||mov|8,wc|3,kvstn||; current statement|11504
||jsr|6,filnm|||; obtain file name for this statement|11505
||mov|7,xr|3,r_cod||; current code block|11508
||mov|8,wc|13,cdsln(xr)||; line number|11509
||zer|8,wb|||; column number|11513
||mov|7,xr|3,stage||;|11514
||jsr|6,sysea|||; advise system of error|11515
||ppm|6,stpr4|||; if system does not want print|11516
||jsr|6,prtpg|||; else eject printer|11518
||bze|7,xr|6,labo2||; did sysea request print|11520
||jsr|6,prtst|||; print text from sysea|11521
|labo2|jsr|6,ermsg|||; print error message|11523
||zer|7,xr|||; indicate no message to print|11524
||brn|6,stopr|||; jump to routine to stop run|11525
;
;      here if no error had occured
;
|labo3|erb|1,036|26,goto abort with no preceding error|||11529
||ejc|||||11530
;
;      continue
;
|l_cnt|ent||||; entry point|11534
;
;      merge here after execution error
;
|lcnt1|mov|7,xr|3,r_cnt||; load continuation code block ptr|11538
||bze|7,xr|6,lcnt3||; jump if no previous error|11539
||zer|3,r_cnt|||; clear flag|11540
||mov|3,r_cod|7,xr||; else store as new code block ptr|11541
||bne|9,(xr)|22,=b_cdc|6,lcnt2|; jump if not complex go|11542
||mov|8,wa|3,stxoc||; get offset of error|11543
||bge|8,wa|3,stxof|6,lcnt4|; jump if error in goto evaluation|11544
;
;      here if error did not occur in complex failure goto
;
|lcnt2|add|7,xr|3,stxof||; add failure offset|11548
||lcp|7,xr|||; load code pointer|11549
||mov|7,xs|3,flptr||; reset stack pointer|11550
||lcw|7,xr|||; get next code word|11551
||bri|9,(xr)|||; execute next code word|11552
;
;      here if no previous error
;
|lcnt3|icv|3,errft|||; fatal error|11556
||erb|1,037|26,goto continue with no preceding error|||11557
;
;      here if error in evaluation of failure goto.
;      cannot continue back to failure goto!
;
|lcnt4|icv|3,errft|||; fatal error|11562
||erb|1,332|26,goto continue with error in failure goto|||11563
||ejc|||||11564
;
;      end
;
|l_end|ent||||; entry point|11568
;
;      merge here from end code circuit
;
|lend0|mov|7,xr|21,=endms||; point to message /normal term.../|11572
||brn|6,stopr|||; jump to routine to stop run|11573
||ejc|||||11574
;
;      freturn
;
|l_frt|ent||||; entry point|11578
||mov|8,wa|21,=scfrt||; point to string /freturn/|11579
||brn|6,retrn|||; jump to common return routine|11580
||ejc|||||11581
;
;      nreturn
;
|l_nrt|ent||||; entry point|11585
||mov|8,wa|21,=scnrt||; point to string /nreturn/|11586
||brn|6,retrn|||; jump to common return routine|11587
||ejc|||||11588
;
;      return
;
|l_rtn|ent||||; entry point|11592
||mov|8,wa|21,=scrtn||; point to string /return/|11593
||brn|6,retrn|||; jump to common return routine|11594
||ejc|||||11595
;
;      scontinue
;
|l_scn|ent||||; entry point|11599
||mov|7,xr|3,r_cnt||; load continuation code block ptr|11600
||bze|7,xr|6,lscn2||; jump if no previous error|11601
||zer|3,r_cnt|||; clear flag|11602
||bne|3,kvert|18,=nm320|6,lscn1|; error must be user interrupt|11603
||beq|3,kvert|18,=nm321|6,lscn2|; detect scontinue loop|11604
||mov|3,r_cod|7,xr||; else store as new code block ptr|11605
||add|7,xr|3,stxoc||; add resume offset|11606
||lcp|7,xr|||; load code pointer|11607
||lcw|7,xr|||; get next code word|11608
||bri|9,(xr)|||; execute next code word|11609
;
;      here if no user interrupt
;
|lscn1|icv|3,errft|||; fatal error|11613
||erb|1,331|26,goto scontinue with no user interrupt|||11614
;
;      here if in scontinue loop or if no previous error
;
|lscn2|icv|3,errft|||; fatal error|11618
||erb|1,321|26,goto scontinue with no preceding error|||11619
||ejc|||||11620
;
;      undefined label
;
|l_und|ent||||; entry point|11624
||erb|1,038|26,goto undefined label|||11625
||ttl|27,s p i t b o l -- predefined snobol4 functions||||11626
;
;      the following section contains coding for functions
;      which are predefined and available at the snobol level.
;
;      these routines receive control directly from the code or
;      indirectly through the o_fnc, o_fns or cfunc routines.
;      in both cases the conditions on entry are as follows
;
;      the arguments are on the stack. the number of arguments
;      has been adjusted to correspond to the svblk svnar field.
;
;      in certain functions the direct call is not permitted
;      and in these instances we also have.
;
;      (wa)		     actual number of arguments in call
;
;      control returns by placing the function result value on
;      on the stack and continuing execution with the next
;      word from the generated code.
;
;      the names of the entry points of these functions are of
;      the form s_xxx where xxx is the three letter code for
;      the system variable name. the functions are in order
;      alphabetically by their entry names.
||ejc|||||11651
;
;      any
;
|s_any|ent||||; entry point|11705
||mov|8,wb|22,=p_ans||; set pcode for single char case|11706
||mov|7,xl|22,=p_any||; pcode for multi-char case|11707
||mov|8,wc|22,=p_ayd||; pcode for expression case|11708
||jsr|6,patst|||; call common routine to build node|11709
||err|1,059|26,any argument is not a string or expression|||11710
||mov|11,-(xs)|7,xr||; stack result|11711
||lcw|7,xr|||; get next code word|11712
||bri|9,(xr)|||; execute it|11713
||ejc|||||11714
;
;      apply
;
;      apply does not permit the direct (fast) call so that
;      wa contains the actual number of arguments passed.
;
|s_app|ent||||; entry point|11740
||bze|8,wa|6,sapp3||; jump if no arguments|11741
||dcv|8,wa|||; else get applied func arg count|11742
||mov|8,wb|8,wa||; copy|11743
||wtb|8,wb|||; convert to bytes|11744
||mov|7,xt|7,xs||; copy stack pointer|11745
||add|7,xt|8,wb||; point to function argument on stack|11746
||mov|7,xr|9,(xt)||; load function ptr (apply 1st arg)|11747
||bze|8,wa|6,sapp2||; jump if no args for applied func|11748
||lct|8,wb|8,wa||; else set counter for loop|11749
;
;      loop to move arguments up on stack
;
|sapp1|dca|7,xt|||; point to next argument|11753
||mov|13,num01(xt)|9,(xt)||; move argument up|11754
||bct|8,wb|6,sapp1||; loop till all moved|11755
;
;      merge here to call function (wa = number of arguments)
;
|sapp2|ica|7,xs|||; adjust stack ptr for apply 1st arg|11759
||jsr|6,gtnvr|||; get variable block addr for func|11760
||ppm|6,sapp3|||; jump if not natural variable|11761
||mov|7,xl|13,vrfnc(xr)||; else point to function block|11762
||brn|6,cfunc|||; go call applied function|11763
;
;      here for invalid first argument
;
|sapp3|erb|1,060|26,apply first arg is not natural variable name|||11767
||ejc|||||11768
;
;      arbno
;
;      arbno builds a compound pattern. see description at
;      start of pattern matching section for structure formed.
;
|s_abn|ent||||; entry point|11775
||zer|7,xr|||; set parm1 = 0 for the moment|11776
||mov|8,wb|22,=p_alt||; set pcode for alternative node|11777
||jsr|6,pbild|||; build alternative node|11778
||mov|7,xl|7,xr||; save ptr to alternative pattern|11779
||mov|8,wb|22,=p_abc||; pcode for p_abc|11780
||zer|7,xr|||; p0blk|11781
||jsr|6,pbild|||; build p_abc node|11782
||mov|13,pthen(xr)|7,xl||; put alternative node as successor|11783
||mov|8,wa|7,xl||; remember alternative node pointer|11784
||mov|7,xl|7,xr||; copy p_abc node ptr|11785
||mov|7,xr|9,(xs)||; load arbno argument|11786
||mov|9,(xs)|8,wa||; stack alternative node pointer|11787
||jsr|6,gtpat|||; get arbno argument as pattern|11788
||err|1,061|26,arbno argument is not pattern|||11789
||jsr|6,pconc|||; concat arg with p_abc node|11790
||mov|7,xl|7,xr||; remember ptr to concd patterns|11791
||mov|8,wb|22,=p_aba||; pcode for p_aba|11792
||zer|7,xr|||; p0blk|11793
||jsr|6,pbild|||; build p_aba node|11794
||mov|13,pthen(xr)|7,xl||; concatenate nodes|11795
||mov|7,xl|9,(xs)||; recall ptr to alternative node|11796
||mov|13,parm1(xl)|7,xr||; point alternative back to argument|11797
||lcw|7,xr|||; get next code word|11798
||bri|9,(xr)|||; execute next code word|11799
||ejc|||||11800
;
;      arg
;
|s_arg|ent||||; entry point|11804
||jsr|6,gtsmi|||; get second arg as small integer|11805
||err|1,062|26,arg second argument is not integer|||11806
||ppm|6,exfal|||; fail if out of range or negative|11807
||mov|8,wa|7,xr||; save argument number|11808
||mov|7,xr|10,(xs)+||; load first argument|11809
||jsr|6,gtnvr|||; locate vrblk|11810
||ppm|6,sarg1|||; jump if not natural variable|11811
||mov|7,xr|13,vrfnc(xr)||; else load function block pointer|11812
||bne|9,(xr)|22,=b_pfc|6,sarg1|; jump if not program defined|11813
||bze|8,wa|6,exfal||; fail if arg number is zero|11814
||bgt|8,wa|13,fargs(xr)|6,exfal|; fail if arg number is too large|11815
||wtb|8,wa|||; else convert to byte offset|11816
||add|7,xr|8,wa||; point to argument selected|11817
||mov|7,xr|13,pfagb(xr)||; load argument vrblk pointer|11818
||brn|6,exvnm|||; exit to build nmblk|11819
;
;      here if 1st argument is bad
;
|sarg1|erb|1,063|26,arg first argument is not program function name|||11823
||ejc|||||11824
;
;      array
;
|s_arr|ent||||; entry point|11828
||mov|7,xl|10,(xs)+||; load initial element value|11829
||mov|7,xr|10,(xs)+||; load first argument|11830
||jsr|6,gtint|||; convert first arg to integer|11831
||ppm|6,sar02|||; jump if not integer|11832
;
;      here for integer first argument, build vcblk
;
||ldi|13,icval(xr)|||; load integer value|11836
||ile|6,sar10|||; jump if zero or neg (bad dimension)|11837
||mfi|8,wa|6,sar11||; else convert to one word, test ovfl|11838
||jsr|6,vmake|||; create vector|11839
||ppm|6,sar11|||; fail if too large|11840
||brn|6,exsid|||; exit setting idval|11841
||ejc|||||11842
;
;      array (continued)
;
;      here if first argument is not an integer
;
|sar02|mov|11,-(xs)|7,xr||; replace argument on stack|11848
||jsr|6,xscni|||; initialize scan of first argument|11849
||err|1,064|26,array first argument is not integer or string|||11850
||ppm|6,exnul|||; dummy (unused) null string exit|11851
||mov|11,-(xs)|3,r_xsc||; save prototype pointer|11852
||mov|11,-(xs)|7,xl||; save default value|11853
||zer|3,arcdm|||; zero count of dimensions|11854
||zer|3,arptr|||; zero offset to indicate pass one|11855
||ldi|4,intv1|||; load integer one|11856
||sti|3,arnel|||; initialize element count|11857
;
;      the following code is executed twice. the first time
;      (arptr eq 0), it is used to count the number of elements
;      and number of dimensions. the second time (arptr gt 0) is
;      used to actually fill in the dim,lbd fields of the arblk.
;
|sar03|ldi|4,intv1|||; load one as default low bound|11864
||sti|3,arsvl|||; save as low bound|11865
||mov|8,wc|18,=ch_cl||; set delimiter one = colon|11866
||mov|7,xl|18,=ch_cm||; set delimiter two = comma|11867
||zer|8,wa|||; retain blanks in prototype|11868
||jsr|6,xscan|||; scan next bound|11869
||bne|8,wa|18,=num01|6,sar04|; jump if not colon|11870
;
;      here we have a colon ending a low bound
;
||jsr|6,gtint|||; convert low bound|11874
||err|1,065|26,array first argument lower bound is not integer|||11875
||ldi|13,icval(xr)|||; load value of low bound|11876
||sti|3,arsvl|||; store low bound value|11877
||mov|8,wc|18,=ch_cm||; set delimiter one = comma|11878
||mov|7,xl|8,wc||; and delimiter two = comma|11879
||zer|8,wa|||; retain blanks in prototype|11880
||jsr|6,xscan|||; scan high bound|11881
||ejc|||||11882
;
;      array (continued)
;
;      merge here to process upper bound
;
|sar04|jsr|6,gtint|||; convert high bound to integer|11888
||err|1,066|26,array first argument upper bound is not integer|||11889
||ldi|13,icval(xr)|||; get high bound|11890
||sbi|3,arsvl|||; subtract lower bound|11891
||iov|6,sar10|||; bad dimension if overflow|11892
||ilt|6,sar10|||; bad dimension if negative|11893
||adi|4,intv1|||; add 1 to get dimension|11894
||iov|6,sar10|||; bad dimension if overflow|11895
||mov|7,xl|3,arptr||; load offset (also pass indicator)|11896
||bze|7,xl|6,sar05||; jump if first pass|11897
;
;      here in second pass to store lbd and dim in arblk
;
||add|7,xl|9,(xs)||; point to current location in arblk|11901
||sti|13,cfp_i(xl)|||; store dimension|11902
||ldi|3,arsvl|||; load low bound|11903
||sti|9,(xl)|||; store low bound|11904
||add|3,arptr|19,*ardms||; bump offset to next bounds|11905
||brn|6,sar06|||; jump to check for end of bounds|11906
;
;      here in pass 1
;
|sar05|icv|3,arcdm|||; bump dimension count|11910
||mli|3,arnel|||; multiply dimension by count so far|11911
||iov|6,sar11|||; too large if overflow|11912
||sti|3,arnel|||; else store updated element count|11913
;
;      merge here after processing one set of bounds
;
|sar06|bnz|8,wa|6,sar03||; loop back unless end of bounds|11917
||bnz|3,arptr|6,sar09||; jump if end of pass 2|11918
||ejc|||||11919
;
;      array (continued)
;
;      here at end of pass one, build arblk
;
||ldi|3,arnel|||; get number of elements|11925
||mfi|8,wb|6,sar11||; get as addr integer, test ovflo|11926
||wtb|8,wb|||; else convert to length in bytes|11927
||mov|8,wa|19,*arsi_||; set size of standard fields|11928
||lct|8,wc|3,arcdm||; set dimension count to control loop|11929
;
;      loop to allow space for dimensions
;
|sar07|add|8,wa|19,*ardms||; allow space for one set of bounds|11933
||bct|8,wc|6,sar07||; loop back till all accounted for|11934
||mov|7,xl|8,wa||; save size (=arofs)|11935
;
;      now allocate space for arblk
;
||add|8,wa|8,wb||; add space for elements|11939
||ica|8,wa|||; allow for arpro prototype field|11940
||bgt|8,wa|3,mxlen|6,sar11|; fail if too large|11941
||jsr|6,alloc|||; else allocate arblk|11942
||mov|8,wb|9,(xs)||; load default value|11943
||mov|9,(xs)|7,xr||; save arblk pointer|11944
||mov|8,wc|8,wa||; save length in bytes|11945
||btw|8,wa|||; convert length back to words|11946
||lct|8,wa|8,wa||; set counter to control loop|11947
;
;      loop to clear entire arblk to default value
;
|sar08|mov|10,(xr)+|8,wb||; set one word|11951
||bct|8,wa|6,sar08||; loop till all set|11952
||ejc|||||11953
;
;      array (continued)
;
;      now set initial fields of arblk
;
||mov|7,xr|10,(xs)+||; reload arblk pointer|11959
||mov|8,wb|9,(xs)||; load prototype|11960
||mov|9,(xr)|22,=b_art||; set type word|11961
||mov|13,arlen(xr)|8,wc||; store length in bytes|11962
||zer|13,idval(xr)|||; zero id till we get it built|11963
||mov|13,arofs(xr)|7,xl||; set prototype field ptr|11964
||mov|13,arndm(xr)|3,arcdm||; set number of dimensions|11965
||mov|8,wc|7,xr||; save arblk pointer|11966
||add|7,xr|7,xl||; point to prototype field|11967
||mov|9,(xr)|8,wb||; store prototype ptr in arblk|11968
||mov|3,arptr|19,*arlbd||; set offset for pass 2 bounds scan|11969
||mov|3,r_xsc|8,wb||; reset string pointer for xscan|11970
||mov|9,(xs)|8,wc||; store arblk pointer on stack|11971
||zer|3,xsofs|||; reset offset ptr to start of string|11972
||brn|6,sar03|||; jump back to rescan bounds|11973
;
;      here after filling in bounds information (end pass two)
;
|sar09|mov|7,xr|10,(xs)+||; reload pointer to arblk|11977
||brn|6,exsid|||; exit setting idval|11978
;
;      here for bad dimension
;
|sar10|erb|1,067|26,array dimension is zero, negative or out of range|||11982
;
;      here if array is too large
;
|sar11|erb|1,068|26,array size exceeds maximum permitted|||11986
||ejc|||||11987
;
;      atan
;
|s_atn|ent||||; entry point|11992
||mov|7,xr|10,(xs)+||; get argument|11993
||jsr|6,gtrea|||; convert to real|11994
||err|1,301|26,atan argument not numeric|||11995
||ldr|13,rcval(xr)|||; load accumulator with argument|11996
||atn||||; take arctangent|11997
||brn|6,exrea|||; overflow, out of range not possible|11998
||ejc|||||11999
||ejc|||||12002
;
;      backspace
;
|s_bsp|ent||||; entry point|12006
||jsr|6,iofcb|||; call fcblk routine|12007
||err|1,316|26,backspace argument is not a suitable name|||12008
||err|1,316|26,backspace argument is not a suitable name|||12009
||err|1,317|26,backspace file does not exist|||12010
||jsr|6,sysbs|||; call backspace file function|12011
||err|1,317|26,backspace file does not exist|||12012
||err|1,318|26,backspace file does not permit backspace|||12013
||err|1,319|26,backspace caused non-recoverable error|||12014
||brn|6,exnul|||; return null as result|12015
||ejc|||||12016
;
;      break
;
|s_brk|ent||||; entry point|12049
||mov|8,wb|22,=p_bks||; set pcode for single char case|12050
||mov|7,xl|22,=p_brk||; pcode for multi-char case|12051
||mov|8,wc|22,=p_bkd||; pcode for expression case|12052
||jsr|6,patst|||; call common routine to build node|12053
||err|1,069|26,break argument is not a string or expression|||12054
||mov|11,-(xs)|7,xr||; stack result|12055
||lcw|7,xr|||; get next code word|12056
||bri|9,(xr)|||; execute it|12057
||ejc|||||12058
;
;      breakx
;
;      breakx is a compound pattern. see description at start
;      of pattern matching section for structure formed.
;
|s_bkx|ent||||; entry point|12065
||mov|8,wb|22,=p_bks||; pcode for single char argument|12066
||mov|7,xl|22,=p_brk||; pcode for multi-char argument|12067
||mov|8,wc|22,=p_bxd||; pcode for expression case|12068
||jsr|6,patst|||; call common routine to build node|12069
||err|1,070|26,breakx argument is not a string or expression|||12070
;
;      now hook breakx node on at front end
;
||mov|11,-(xs)|7,xr||; save ptr to break node|12074
||mov|8,wb|22,=p_bkx||; set pcode for breakx node|12075
||jsr|6,pbild|||; build it|12076
||mov|13,pthen(xr)|9,(xs)||; set break node as successor|12077
||mov|8,wb|22,=p_alt||; set pcode for alternation node|12078
||jsr|6,pbild|||; build (parm1=alt=breakx node)|12079
||mov|8,wa|7,xr||; save ptr to alternation node|12080
||mov|7,xr|9,(xs)||; point to break node|12081
||mov|13,pthen(xr)|8,wa||; set alternate node as successor|12082
||lcw|7,xr|||; result on stack|12083
||bri|9,(xr)|||; execute next code word|12084
||ejc|||||12085
;
;      char
;
|s_chr|ent||||; entry point|12089
||jsr|6,gtsmi|||; convert arg to integer|12090
||err|1,281|26,char argument not integer|||12091
||ppm|6,schr1|||; too big error exit|12092
||bge|8,wc|18,=cfp_a|6,schr1|; see if out of range of host set|12093
||mov|8,wa|18,=num01||; if not set scblk allocation|12094
||mov|8,wb|8,wc||; save char code|12095
||jsr|6,alocs|||; allocate 1 bau scblk|12096
||mov|7,xl|7,xr||; copy scblk pointer|12097
||psc|7,xl|||; get set to stuff char|12098
||sch|8,wb|9,(xl)||; stuff it|12099
||csc|7,xl|||; complete store character|12100
||zer|7,xl|||; clear slop in xl|12101
||mov|11,-(xs)|7,xr||; stack result|12102
||lcw|7,xr|||; get next code word|12103
||bri|9,(xr)|||; execute it|12104
;
;      here if char argument is out of range
;
|schr1|erb|1,282|26,char argument not in range|||12108
||ejc|||||12109
;
;      chop
;
|s_chp|ent||||; entry point|12114
||mov|7,xr|10,(xs)+||; get argument|12115
||jsr|6,gtrea|||; convert to real|12116
||err|1,302|26,chop argument not numeric|||12117
||ldr|13,rcval(xr)|||; load accumulator with argument|12118
||chp||||; truncate to integer valued real|12119
||brn|6,exrea|||; no overflow possible|12120
||ejc|||||12121
;
;      clear
;
|s_clr|ent||||; entry point|12126
||jsr|6,xscni|||; initialize to scan argument|12127
||err|1,071|26,clear argument is not a string|||12128
||ppm|6,sclr2|||; jump if null|12129
;
;      loop to scan out names in first argument. variables in
;      the list are flagged by setting vrget of vrblk to zero.
;
|sclr1|mov|8,wc|18,=ch_cm||; set delimiter one = comma|12134
||mov|7,xl|8,wc||; delimiter two = comma|12135
||mnz|8,wa|||; skip/trim blanks in prototype|12136
||jsr|6,xscan|||; scan next variable name|12137
||jsr|6,gtnvr|||; locate vrblk|12138
||err|1,072|26,clear argument has null variable name|||12139
||zer|13,vrget(xr)|||; else flag by zeroing vrget field|12140
||bnz|8,wa|6,sclr1||; loop back if stopped by comma|12141
;
;      here after flagging variables in argument list
;
|sclr2|mov|8,wb|3,hshtb||; point to start of hash table|12145
;
;      loop through slots in hash table
;
|sclr3|beq|8,wb|3,hshte|6,exnul|; exit returning null if none left|12149
||mov|7,xr|8,wb||; else copy slot pointer|12150
||ica|8,wb|||; bump slot pointer|12151
||sub|7,xr|19,*vrnxt||; set offset to merge into loop|12152
;
;      loop through vrblks on one hash chain
;
|sclr4|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain|12156
||bze|7,xr|6,sclr3||; jump for next bucket if chain end|12157
||bnz|13,vrget(xr)|6,sclr5||; jump if not flagged|12158
||ejc|||||12159
;
;      clear (continued)
;
;      here for flagged variable, do not set value to null
;
||jsr|6,setvr|||; for flagged var, restore vrget|12165
||brn|6,sclr4|||; and loop back for next vrblk|12166
;
;      here to set value of a variable to null
;      protected variables (arb, etc) are exempt
;
|sclr5|beq|13,vrsto(xr)|22,=b_vre|6,sclr4|; check for protected variable|12171
||mov|7,xl|7,xr||; copy vrblk pointer|12172
;
;      loop to locate value at end of possible trblk chain
;
|sclr6|mov|8,wa|7,xl||; save block pointer|12176
||mov|7,xl|13,vrval(xl)||; load next value field|12177
||beq|9,(xl)|22,=b_trt|6,sclr6|; loop back if trapped|12178
;
;      now store the null value
;
||mov|7,xl|8,wa||; restore block pointer|12182
||mov|13,vrval(xl)|21,=nulls||; store null constant value|12183
||brn|6,sclr4|||; loop back for next vrblk|12184
||ejc|||||12185
;
;      code
;
|s_cod|ent||||; entry point|12189
||mov|7,xr|10,(xs)+||; load argument|12190
||jsr|6,gtcod|||; convert to code|12191
||ppm|6,exfal|||; fail if conversion is impossible|12192
||mov|11,-(xs)|7,xr||; stack result|12193
||zer|3,r_ccb|||; forget interim code block|12194
||lcw|7,xr|||; get next code word|12195
||bri|9,(xr)|||; execute it|12196
||ejc|||||12197
;
;      collect
;
|s_col|ent||||; entry point|12201
||mov|7,xr|10,(xs)+||; load argument|12202
||jsr|6,gtint|||; convert to integer|12203
||err|1,073|26,collect argument is not integer|||12204
||ldi|13,icval(xr)|||; load collect argument|12205
||sti|3,clsvi|||; save collect argument|12206
||zer|8,wb|||; set no move up|12207
||zer|3,r_ccb|||; forget interim code block|12208
||zer|3,dnams|||; collect sediment too|12210
||jsr|6,gbcol|||; perform garbage collection|12211
||mov|3,dnams|7,xr||; record new sediment size|12212
||mov|8,wa|3,dname||; point to end of memory|12216
||sub|8,wa|3,dnamp||; subtract next location|12217
||btw|8,wa|||; convert bytes to words|12218
||mti|8,wa|||; convert words available as integer|12219
||sbi|3,clsvi|||; subtract argument|12220
||iov|6,exfal|||; fail if overflow|12221
||ilt|6,exfal|||; fail if not enough|12222
||adi|3,clsvi|||; else recompute available|12223
||brn|6,exint|||; and exit with integer result|12224
||ejc|||||12225
;
;      convert
;
|s_cnv|ent||||; entry point|12254
||jsr|6,gtstg|||; convert second argument to string|12255
||ppm|6,scv29|||; error if second argument not string|12256
||bze|8,wa|6,scv29||; or if null string|12257
||jsr|6,flstg|||; fold lower case to upper case|12259
||mov|7,xl|9,(xs)||; load first argument|12261
||bne|9,(xl)|22,=b_pdt|6,scv01|; jump if not program defined|12262
;
;      here for program defined datatype
;
||mov|7,xl|13,pddfp(xl)||; point to dfblk|12266
||mov|7,xl|13,dfnam(xl)||; load datatype name|12267
||jsr|6,ident|||; compare with second arg|12268
||ppm|6,exits|||; exit if ident with arg as result|12269
||brn|6,exfal|||; else fail|12270
;
;      here if not program defined datatype
;
|scv01|mov|11,-(xs)|7,xr||; save string argument|12274
||mov|7,xl|21,=svctb||; point to table of names to compare|12275
||zer|8,wb|||; initialize counter|12276
||mov|8,wc|8,wa||; save length of argument string|12277
;
;      loop through table entries
;
|scv02|mov|7,xr|10,(xl)+||; load next table entry, bump pointer|12281
||bze|7,xr|6,exfal||; fail if zero marking end of list|12282
||bne|8,wc|13,sclen(xr)|6,scv05|; jump if wrong length|12283
||mov|3,cnvtp|7,xl||; else store table pointer|12284
||plc|7,xr|||; point to chars of table entry|12285
||mov|7,xl|9,(xs)||; load pointer to string argument|12286
||plc|7,xl|||; point to chars of string arg|12287
||mov|8,wa|8,wc||; set number of chars to compare|12288
||cmc|6,scv04|6,scv04||; compare, jump if no match|12289
||ejc|||||12290
;
;      convert (continued)
;
;      here we have a match
;
|scv03|mov|7,xl|8,wb||; copy entry number|12296
||ica|7,xs|||; pop string arg off stack|12297
||mov|7,xr|10,(xs)+||; load first argument|12298
||bsw|7,xl|2,cnvtt||; jump to appropriate routine|12299
||iff|1,0|6,scv06||; string|12317
||iff|1,1|6,scv07||; integer|12317
||iff|1,2|6,scv09||; name|12317
||iff|1,3|6,scv10||; pattern|12317
||iff|1,4|6,scv11||; array|12317
||iff|1,5|6,scv19||; table|12317
||iff|1,6|6,scv25||; expression|12317
||iff|1,7|6,scv26||; code|12317
||iff|1,8|6,scv27||; numeric|12317
||iff|2,cnvrt|6,scv08||; real|12317
||esw||||; end of switch table|12317
;
;      here if no match with table entry
;
|scv04|mov|7,xl|3,cnvtp||; restore table pointer, merge|12321
;
;      merge here if lengths did not match
;
|scv05|icv|8,wb|||; bump entry number|12325
||brn|6,scv02|||; loop back to check next entry|12326
;
;      here to convert to string
;
|scv06|mov|11,-(xs)|7,xr||; replace string argument on stack|12330
||jsr|6,gtstg|||; convert to string|12331
||ppm|6,exfal|||; fail if conversion not possible|12332
||mov|11,-(xs)|7,xr||; stack result|12333
||lcw|7,xr|||; get next code word|12334
||bri|9,(xr)|||; execute it|12335
||ejc|||||12336
;
;      convert (continued)
;
;      here to convert to integer
;
|scv07|jsr|6,gtint|||; convert to integer|12342
||ppm|6,exfal|||; fail if conversion not possible|12343
||mov|11,-(xs)|7,xr||; stack result|12344
||lcw|7,xr|||; get next code word|12345
||bri|9,(xr)|||; execute it|12346
;
;      here to convert to real
;
|scv08|jsr|6,gtrea|||; convert to real|12352
||ppm|6,exfal|||; fail if conversion not possible|12353
||mov|11,-(xs)|7,xr||; stack result|12354
||lcw|7,xr|||; get next code word|12355
||bri|9,(xr)|||; execute it|12356
;
;      here to convert to name
;
|scv09|beq|9,(xr)|22,=b_nml|6,exixr|; return if already a name|12361
||jsr|6,gtnvr|||; else try string to name convert|12362
||ppm|6,exfal|||; fail if conversion not possible|12363
||brn|6,exvnm|||; else exit building nmblk for vrblk|12364
;
;      here to convert to pattern
;
|scv10|jsr|6,gtpat|||; convert to pattern|12368
||ppm|6,exfal|||; fail if conversion not possible|12369
||mov|11,-(xs)|7,xr||; stack result|12370
||lcw|7,xr|||; get next code word|12371
||bri|9,(xr)|||; execute it|12372
;
;      convert to array
;
;      if the first argument is a table, then we go through
;      an intermediate array of addresses that is sorted to
;      provide a result ordered by time of entry in the
;      original table.	see c3.762.
;
|scv11|mov|11,-(xs)|7,xr||; save argument on stack|12381
||zer|8,wa|||; use table chain block addresses|12382
||jsr|6,gtarr|||; get an array|12383
||ppm|6,exfal|||; fail if empty table|12384
||ppm|6,exfal|||; fail if not convertible|12385
||mov|7,xl|10,(xs)+||; reload original arg|12386
||bne|9,(xl)|22,=b_tbt|6,exsid|; exit if original not a table|12387
||mov|11,-(xs)|7,xr||; sort the intermediate array|12388
||mov|11,-(xs)|21,=nulls||; on first column|12389
||zer|8,wa|||; sort ascending|12390
||jsr|6,sorta|||; do sort|12391
||ppm|6,exfal|||; if sort fails, so shall we|12392
||mov|8,wb|7,xr||; save array result|12393
||ldi|13,ardim(xr)|||; load dim 1 (number of elements)|12394
||mfi|8,wa|||; get as one word integer|12395
||lct|8,wa|8,wa||; copy to control loop|12396
||add|7,xr|19,*arvl2||; point to first element in array|12397
;
;      here for each row of this 2-column array
;
|scv12|mov|7,xl|9,(xr)||; get teblk address|12401
||mov|10,(xr)+|13,tesub(xl)||; replace with subscript|12402
||mov|10,(xr)+|13,teval(xl)||; replace with value|12403
||bct|8,wa|6,scv12||; loop till all copied over|12404
||mov|7,xr|8,wb||; retrieve array address|12405
||brn|6,exsid|||; exit setting id field|12406
;
;      convert to table
;
|scv19|mov|8,wa|9,(xr)||; load first word of block|12410
||mov|11,-(xs)|7,xr||; replace arblk pointer on stack|12411
||beq|8,wa|22,=b_tbt|6,exits|; return arg if already a table|12412
||bne|8,wa|22,=b_art|6,exfal|; else fail if not an array|12413
||ejc|||||12414
;
;      convert (continued)
;
;      here to convert an array to table
;
||bne|13,arndm(xr)|18,=num02|6,exfal|; fail if not 2-dim array|12420
||ldi|13,ardm2(xr)|||; load dim 2|12421
||sbi|4,intv2|||; subtract 2 to compare|12422
||ine|6,exfal|||; fail if dim2 not 2|12423
;
;      here we have an arblk of the right shape
;
||ldi|13,ardim(xr)|||; load dim 1 (number of elements)|12427
||mfi|8,wa|||; get as one word integer|12428
||lct|8,wb|8,wa||; copy to control loop|12429
||add|8,wa|18,=tbsi_||; add space for standard fields|12430
||wtb|8,wa|||; convert length to bytes|12431
||jsr|6,alloc|||; allocate space for tbblk|12432
||mov|8,wc|7,xr||; copy tbblk pointer|12433
||mov|11,-(xs)|7,xr||; save tbblk pointer|12434
||mov|10,(xr)+|22,=b_tbt||; store type word|12435
||zer|10,(xr)+|||; store zero for idval for now|12436
||mov|10,(xr)+|8,wa||; store length|12437
||mov|10,(xr)+|21,=nulls||; null initial lookup value|12438
;
;      loop to initialize bucket ptrs to point to table
;
|scv20|mov|10,(xr)+|8,wc||; set bucket ptr to point to tbblk|12442
||bct|8,wb|6,scv20||; loop till all initialized|12443
||mov|8,wb|19,*arvl2||; set offset to first arblk element|12444
;
;      loop to copy elements from array to table
;
|scv21|mov|7,xl|13,num01(xs)||; point to arblk|12448
||beq|8,wb|13,arlen(xl)|6,scv24|; jump if all moved|12449
||add|7,xl|8,wb||; else point to current location|12450
||add|8,wb|19,*num02||; bump offset|12451
||mov|7,xr|9,(xl)||; load subscript name|12452
||dca|7,xl|||; adjust ptr to merge (trval=1+1)|12453
||ejc|||||12454
;
;      convert (continued)
;
;      loop to chase down trblk chain for value
;
|scv22|mov|7,xl|13,trval(xl)||; point to next value|12460
||beq|9,(xl)|22,=b_trt|6,scv22|; loop back if trapped|12461
;
;      here with name in xr, value in xl
;
|scv23|mov|11,-(xs)|7,xl||; stack value|12465
||mov|7,xl|13,num01(xs)||; load tbblk pointer|12466
||jsr|6,tfind|||; build teblk (note wb gt 0 by name)|12467
||ppm|6,exfal|||; fail if acess fails|12468
||mov|13,teval(xl)|10,(xs)+||; store value in teblk|12469
||brn|6,scv21|||; loop back for next element|12470
;
;      here after moving all elements to tbblk
;
|scv24|mov|7,xr|10,(xs)+||; load tbblk pointer|12474
||ica|7,xs|||; pop arblk pointer|12475
||brn|6,exsid|||; exit setting idval|12476
;
;      convert to expression
;
|scv25|zer|8,wb|||; by value|12481
||jsr|6,gtexp|||; convert to expression|12482
||ppm|6,exfal|||; fail if conversion not possible|12486
||zer|3,r_ccb|||; forget interim code block|12487
||mov|11,-(xs)|7,xr||; stack result|12488
||lcw|7,xr|||; get next code word|12489
||bri|9,(xr)|||; execute it|12490
;
;      convert to code
;
|scv26|jsr|6,gtcod|||; convert to code|12494
||ppm|6,exfal|||; fail if conversion is not possible|12495
||zer|3,r_ccb|||; forget interim code block|12496
||mov|11,-(xs)|7,xr||; stack result|12497
||lcw|7,xr|||; get next code word|12498
||bri|9,(xr)|||; execute it|12499
;
;      convert to numeric
;
|scv27|jsr|6,gtnum|||; convert to numeric|12503
||ppm|6,exfal|||; fail if unconvertible|12504
|scv31|mov|11,-(xs)|7,xr||; stack result|12505
||lcw|7,xr|||; get next code word|12506
||bri|9,(xr)|||; execute it|12507
||ejc|||||12508
;
;      second argument not string or null
;
|scv29|erb|1,074|26,convert second argument is not a string|||12534
;
;      copy
;
|s_cop|ent||||; entry point|12538
||jsr|6,copyb|||; copy the block|12539
||ppm|6,exits|||; return if no idval field|12540
||brn|6,exsid|||; exit setting id value|12541
||ejc|||||12542
;
;      cos
;
|s_cos|ent||||; entry point|12547
||mov|7,xr|10,(xs)+||; get argument|12548
||jsr|6,gtrea|||; convert to real|12549
||err|1,303|26,cos argument not numeric|||12550
||ldr|13,rcval(xr)|||; load accumulator with argument|12551
||cos||||; take cosine|12552
||rno|6,exrea|||; if no overflow, return result in ra|12553
||erb|1,322|26,cos argument is out of range|||12554
||ejc|||||12555
;
;      data
;
|s_dat|ent||||; entry point|12560
||jsr|6,xscni|||; prepare to scan argument|12561
||err|1,075|26,data argument is not a string|||12562
||err|1,076|26,data argument is null|||12563
;
;      scan out datatype name
;
||mov|8,wc|18,=ch_pp||; delimiter one = left paren|12567
||mov|7,xl|8,wc||; delimiter two = left paren|12568
||mnz|8,wa|||; skip/trim blanks in prototype|12569
||jsr|6,xscan|||; scan datatype name|12570
||bnz|8,wa|6,sdat1||; skip if left paren found|12571
||erb|1,077|26,data argument is missing a left paren|||12572
;
;      here after scanning datatype name
;
|sdat1|mov|8,wa|13,sclen(xr)||; get length|12577
||bze|8,wa|6,sdt1a||; avoid folding if null string|12578
||jsr|6,flstg|||; fold lower case to upper case|12579
|sdt1a|mov|7,xl|7,xr||; save name ptr|12580
||mov|8,wa|13,sclen(xr)||; get length|12584
||ctb|8,wa|2,scsi_||; compute space needed|12585
||jsr|6,alost|||; request static store for name|12586
||mov|11,-(xs)|7,xr||; save datatype name|12587
||mvw||||; copy name to static|12588
||mov|7,xr|9,(xs)||; get name ptr|12589
||zer|7,xl|||; scrub dud register|12590
||jsr|6,gtnvr|||; locate vrblk for datatype name|12591
||err|1,078|26,data argument has null datatype name|||12592
||mov|3,datdv|7,xr||; save vrblk pointer for datatype|12593
||mov|3,datxs|7,xs||; store starting stack value|12594
||zer|8,wb|||; zero count of field names|12595
;
;      loop to scan field names and stack vrblk pointers
;
|sdat2|mov|8,wc|18,=ch_rp||; delimiter one = right paren|12599
||mov|7,xl|18,=ch_cm||; delimiter two = comma|12600
||mnz|8,wa|||; skip/trim blanks in prototype|12601
||jsr|6,xscan|||; scan next field name|12602
||bnz|8,wa|6,sdat3||; jump if delimiter found|12603
||erb|1,079|26,data argument is missing a right paren|||12604
;
;      here after scanning out one field name
;
|sdat3|jsr|6,gtnvr|||; locate vrblk for field name|12608
||err|1,080|26,data argument has null field name|||12609
||mov|11,-(xs)|7,xr||; stack vrblk pointer|12610
||icv|8,wb|||; increment counter|12611
||beq|8,wa|18,=num02|6,sdat2|; loop back if stopped by comma|12612
||ejc|||||12613
;
;      data (continued)
;
;      now build the dfblk
;
||mov|8,wa|18,=dfsi_||; set size of dfblk standard fields|12619
||add|8,wa|8,wb||; add number of fields|12620
||wtb|8,wa|||; convert length to bytes|12621
||mov|8,wc|8,wb||; preserve no. of fields|12622
||jsr|6,alost|||; allocate space for dfblk|12623
||mov|8,wb|8,wc||; get no of fields|12624
||mov|7,xt|3,datxs||; point to start of stack|12625
||mov|8,wc|9,(xt)||; load datatype name|12626
||mov|9,(xt)|7,xr||; save dfblk pointer on stack|12627
||mov|10,(xr)+|22,=b_dfc||; store type word|12628
||mov|10,(xr)+|8,wb||; store number of fields (fargs)|12629
||mov|10,(xr)+|8,wa||; store length (dflen)|12630
||sub|8,wa|19,*pddfs||; compute pdblk length (for dfpdl)|12631
||mov|10,(xr)+|8,wa||; store pdblk length (dfpdl)|12632
||mov|10,(xr)+|8,wc||; store datatype name (dfnam)|12633
||lct|8,wc|8,wb||; copy number of fields|12634
;
;      loop to move field name vrblk pointers to dfblk
;
|sdat4|mov|10,(xr)+|11,-(xt)||; move one field name vrblk pointer|12638
||bct|8,wc|6,sdat4||; loop till all moved|12639
;
;      now define the datatype function
;
||mov|8,wc|8,wa||; copy length of pdblk for later loop|12643
||mov|7,xr|3,datdv||; point to vrblk|12644
||mov|7,xt|3,datxs||; point back on stack|12645
||mov|7,xl|9,(xt)||; load dfblk pointer|12646
||jsr|6,dffnc|||; define function|12647
||ejc|||||12648
;
;      data (continued)
;
;      loop to build ffblks
;
;
;      notice that the ffblks are constructed in reverse order
;      so that the required offsets can be obtained from
;      successive decrementation of the pdblk length (in wc).
;
|sdat5|mov|8,wa|19,*ffsi_||; set length of ffblk|12659
||jsr|6,alloc|||; allocate space for ffblk|12660
||mov|9,(xr)|22,=b_ffc||; set type word|12661
||mov|13,fargs(xr)|18,=num01||; store fargs (always one)|12662
||mov|7,xt|3,datxs||; point back on stack|12663
||mov|13,ffdfp(xr)|9,(xt)||; copy dfblk ptr to ffblk|12664
||dca|8,wc|||; decrement old dfpdl to get next ofs|12665
||mov|13,ffofs(xr)|8,wc||; set offset to this field|12666
||zer|13,ffnxt(xr)|||; tentatively set zero forward ptr|12667
||mov|7,xl|7,xr||; copy ffblk pointer for dffnc|12668
||mov|7,xr|9,(xs)||; load vrblk pointer for field|12669
||mov|7,xr|13,vrfnc(xr)||; load current function pointer|12670
||bne|9,(xr)|22,=b_ffc|6,sdat6|; skip if not currently a field func|12671
;
;      here we must chain an old ffblk ptr to preserve it in the
;      case of multiple field functions with the same name
;
||mov|13,ffnxt(xl)|7,xr||; link new ffblk to previous chain|12676
;
;      merge here to define field function
;
|sdat6|mov|7,xr|10,(xs)+||; load vrblk pointer|12680
||jsr|6,dffnc|||; define field function|12681
||bne|7,xs|3,datxs|6,sdat5|; loop back till all done|12682
||ica|7,xs|||; pop dfblk pointer|12683
||brn|6,exnul|||; return with null result|12684
||ejc|||||12685
;
;      datatype
;
|s_dtp|ent||||; entry point|12689
||mov|7,xr|10,(xs)+||; load argument|12690
||jsr|6,dtype|||; get datatype|12691
||mov|11,-(xs)|7,xr||; stack result|12692
||lcw|7,xr|||; get next code word|12693
||bri|9,(xr)|||; execute it|12694
||ejc|||||12695
;
;      date
;
|s_dte|ent||||; entry point|12699
||mov|7,xr|10,(xs)+||; load argument|12700
||jsr|6,gtint|||; convert to an integer|12701
||err|1,330|26,date argument is not integer|||12702
||jsr|6,sysdt|||; call system date routine|12703
||mov|8,wa|13,num01(xl)||; load length for sbstr|12704
||bze|8,wa|6,exnul||; return null if length is zero|12705
||zer|8,wb|||; set zero offset|12706
||jsr|6,sbstr|||; use sbstr to build scblk|12707
||mov|11,-(xs)|7,xr||; stack result|12708
||lcw|7,xr|||; get next code word|12709
||bri|9,(xr)|||; execute it|12710
||ejc|||||12711
;
;      define
;
|s_def|ent||||; entry point|12715
||mov|7,xr|10,(xs)+||; load second argument|12716
||zer|3,deflb|||; zero label pointer in case null|12717
||beq|7,xr|21,=nulls|6,sdf01|; jump if null second argument|12718
||jsr|6,gtnvr|||; else find vrblk for label|12719
||ppm|6,sdf12|||; jump if not a variable name|12720
||mov|3,deflb|7,xr||; else set specified entry|12721
;
;      scan function name
;
|sdf01|jsr|6,xscni|||; prepare to scan first argument|12725
||err|1,081|26,define first argument is not a string|||12726
||err|1,082|26,define first argument is null|||12727
||mov|8,wc|18,=ch_pp||; delimiter one = left paren|12728
||mov|7,xl|8,wc||; delimiter two = left paren|12729
||mnz|8,wa|||; skip/trim blanks in prototype|12730
||jsr|6,xscan|||; scan out function name|12731
||bnz|8,wa|6,sdf02||; jump if left paren found|12732
||erb|1,083|26,define first argument is missing a left paren|||12733
;
;      here after scanning out function name
;
|sdf02|jsr|6,gtnvr|||; get variable name|12737
||err|1,084|26,define first argument has null function name|||12738
||mov|3,defvr|7,xr||; save vrblk pointer for function nam|12739
||zer|8,wb|||; zero count of arguments|12740
||mov|3,defxs|7,xs||; save initial stack pointer|12741
||bnz|3,deflb|6,sdf03||; jump if second argument given|12742
||mov|3,deflb|7,xr||; else default is function name|12743
;
;      loop to scan argument names and stack vrblk pointers
;
|sdf03|mov|8,wc|18,=ch_rp||; delimiter one = right paren|12747
||mov|7,xl|18,=ch_cm||; delimiter two = comma|12748
||mnz|8,wa|||; skip/trim blanks in prototype|12749
||jsr|6,xscan|||; scan out next argument name|12750
||bnz|8,wa|6,sdf04||; skip if delimiter found|12751
||erb|1,085|26,null arg name or missing ) in define first arg.|||12752
||ejc|||||12753
;
;      define (continued)
;
;      here after scanning an argument name
;
|sdf04|bne|7,xr|21,=nulls|6,sdf05|; skip if non-null|12759
||bze|8,wb|6,sdf06||; ignore null if case of no arguments|12760
;
;      here after dealing with the case of no arguments
;
|sdf05|jsr|6,gtnvr|||; get vrblk pointer|12764
||ppm|6,sdf03|||; loop back to ignore null name|12765
||mov|11,-(xs)|7,xr||; stack argument vrblk pointer|12766
||icv|8,wb|||; increment counter|12767
||beq|8,wa|18,=num02|6,sdf03|; loop back if stopped by a comma|12768
;
;      here after scanning out function argument names
;
|sdf06|mov|3,defna|8,wb||; save number of arguments|12772
||zer|8,wb|||; zero count of locals|12773
;
;      loop to scan local names and stack vrblk pointers
;
|sdf07|mov|8,wc|18,=ch_cm||; set delimiter one = comma|12777
||mov|7,xl|8,wc||; set delimiter two = comma|12778
||mnz|8,wa|||; skip/trim blanks in prototype|12779
||jsr|6,xscan|||; scan out next local name|12780
||bne|7,xr|21,=nulls|6,sdf08|; skip if non-null|12781
||bze|8,wa|6,sdf09||; exit scan if end of string|12782
;
;      here after scanning out a local name
;
|sdf08|jsr|6,gtnvr|||; get vrblk pointer|12786
||ppm|6,sdf07|||; loop back to ignore null name|12787
||icv|8,wb|||; if ok, increment count|12788
||mov|11,-(xs)|7,xr||; stack vrblk pointer|12789
||bnz|8,wa|6,sdf07||; loop back if stopped by a comma|12790
||ejc|||||12791
;
;      define (continued)
;
;      here after scanning locals, build pfblk
;
|sdf09|mov|8,wa|8,wb||; copy count of locals|12797
||add|8,wa|3,defna||; add number of arguments|12798
||mov|8,wc|8,wa||; set sum args+locals as loop count|12799
||add|8,wa|18,=pfsi_||; add space for standard fields|12800
||wtb|8,wa|||; convert length to bytes|12801
||jsr|6,alloc|||; allocate space for pfblk|12802
||mov|7,xl|7,xr||; save pointer to pfblk|12803
||mov|10,(xr)+|22,=b_pfc||; store first word|12804
||mov|10,(xr)+|3,defna||; store number of arguments|12805
||mov|10,(xr)+|8,wa||; store length (pflen)|12806
||mov|10,(xr)+|3,defvr||; store vrblk ptr for function name|12807
||mov|10,(xr)+|8,wb||; store number of locals|12808
||zer|10,(xr)+|||; deal with label later|12809
||zer|10,(xr)+|||; zero pfctr|12810
||zer|10,(xr)+|||; zero pfrtr|12811
||bze|8,wc|6,sdf11||; skip if no args or locals|12812
||mov|8,wa|7,xl||; keep pfblk pointer|12813
||mov|7,xt|3,defxs||; point before arguments|12814
||lct|8,wc|8,wc||; get count of args+locals for loop|12815
;
;      loop to move locals and args to pfblk
;
|sdf10|mov|10,(xr)+|11,-(xt)||; store one entry and bump pointers|12819
||bct|8,wc|6,sdf10||; loop till all stored|12820
||mov|7,xl|8,wa||; recover pfblk pointer|12821
||ejc|||||12822
;
;      define (continued)
;
;      now deal with label
;
|sdf11|mov|7,xs|3,defxs||; pop stack|12828
||mov|13,pfcod(xl)|3,deflb||; store label vrblk in pfblk|12829
||mov|7,xr|3,defvr||; point back to vrblk for function|12830
||jsr|6,dffnc|||; define function|12831
||brn|6,exnul|||; and exit returning null|12832
;
;      here for erroneous label
;
|sdf12|erb|1,086|26,define function entry point is not defined label|||12836
||ejc|||||12837
;
;      detach
;
|s_det|ent||||; entry point|12841
||mov|7,xr|10,(xs)+||; load argument|12842
||jsr|6,gtvar|||; locate variable|12843
||err|1,087|26,detach argument is not appropriate name|||12844
||jsr|6,dtach|||; detach i/o association from name|12845
||brn|6,exnul|||; return null result|12846
||ejc|||||12847
;
;      differ
;
|s_dif|ent||||; entry point|12851
||mov|7,xr|10,(xs)+||; load second argument|12852
||mov|7,xl|10,(xs)+||; load first argument|12853
||jsr|6,ident|||; call ident comparison routine|12854
||ppm|6,exfal|||; fail if ident|12855
||brn|6,exnul|||; return null if differ|12856
||ejc|||||12857
;
;      dump
;
|s_dmp|ent||||; entry point|12861
||jsr|6,gtsmi|||; load dump arg as small integer|12862
||err|1,088|26,dump argument is not integer|||12863
||err|1,089|26,dump argument is negative or too large|||12864
||jsr|6,dumpr|||; else call dump routine|12865
||brn|6,exnul|||; and return null as result|12866
||ejc|||||12867
;
;      dupl
;
|s_dup|ent||||; entry point|12871
||jsr|6,gtsmi|||; get second argument as small integr|12872
||err|1,090|26,dupl second argument is not integer|||12873
||ppm|6,sdup7|||; jump if negative or too big|12874
||mov|8,wb|7,xr||; save duplication factor|12875
||jsr|6,gtstg|||; get first arg as string|12876
||ppm|6,sdup4|||; jump if not a string|12877
;
;      here for case of duplication of a string
;
||mti|8,wa|||; acquire length as integer|12881
||sti|3,dupsi|||; save for the moment|12882
||mti|8,wb|||; get duplication factor as integer|12883
||mli|3,dupsi|||; form product|12884
||iov|6,sdup3|||; jump if overflow|12885
||ieq|6,exnul|||; return null if result length = 0|12886
||mfi|8,wa|6,sdup3||; get as addr integer, check ovflo|12887
;
;      merge here with result length in wa
;
|sdup1|mov|7,xl|7,xr||; save string pointer|12891
||jsr|6,alocs|||; allocate space for string|12892
||mov|11,-(xs)|7,xr||; save as result pointer|12893
||mov|8,wc|7,xl||; save pointer to argument string|12894
||psc|7,xr|||; prepare to store chars of result|12895
||lct|8,wb|8,wb||; set counter to control loop|12896
;
;      loop through duplications
;
|sdup2|mov|7,xl|8,wc||; point back to argument string|12900
||mov|8,wa|13,sclen(xl)||; get number of characters|12901
||plc|7,xl|||; point to chars in argument string|12902
||mvc||||; move characters to result string|12903
||bct|8,wb|6,sdup2||; loop till all duplications done|12904
||zer|7,xl|||; clear garbage value|12905
||lcw|7,xr|||; get next code word|12906
||bri|9,(xr)|||; execute next code word|12907
||ejc|||||12908
;
;      dupl (continued)
;
;      here if too large, set max length and let alocs catch it
;
|sdup3|mov|8,wa|3,dname||; set impossible length for alocs|12914
||brn|6,sdup1|||; merge back|12915
;
;      here if not a string
;
|sdup4|jsr|6,gtpat|||; convert argument to pattern|12919
||err|1,091|26,dupl first argument is not a string or pattern|||12920
;
;      here to duplicate a pattern argument
;
||mov|11,-(xs)|7,xr||; store pattern on stack|12924
||mov|7,xr|21,=ndnth||; start off with null pattern|12925
||bze|8,wb|6,sdup6||; null pattern is result if dupfac=0|12926
||mov|11,-(xs)|8,wb||; preserve loop count|12927
;
;      loop to duplicate by successive concatenation
;
|sdup5|mov|7,xl|7,xr||; copy current value as right argumnt|12931
||mov|7,xr|13,num01(xs)||; get a new copy of left|12932
||jsr|6,pconc|||; concatenate|12933
||dcv|9,(xs)|||; count down|12934
||bnz|9,(xs)|6,sdup5||; loop|12935
||ica|7,xs|||; pop loop count|12936
;
;      here to exit after constructing pattern
;
|sdup6|mov|9,(xs)|7,xr||; store result on stack|12940
||lcw|7,xr|||; get next code word|12941
||bri|9,(xr)|||; execute next code word|12942
;
;      fail if second arg is out of range
;
|sdup7|ica|7,xs|||; pop first argument|12946
||brn|6,exfal|||; fail|12947
||ejc|||||12948
;
;      eject
;
|s_ejc|ent||||; entry point|12952
||jsr|6,iofcb|||; call fcblk routine|12953
||err|1,092|26,eject argument is not a suitable name|||12954
||ppm|6,sejc1|||; null argument|12955
||err|1,093|26,eject file does not exist|||12956
||jsr|6,sysef|||; call eject file function|12957
||err|1,093|26,eject file does not exist|||12958
||err|1,094|26,eject file does not permit page eject|||12959
||err|1,095|26,eject caused non-recoverable output error|||12960
||brn|6,exnul|||; return null as result|12961
;
;      here to eject standard output file
;
|sejc1|jsr|6,sysep|||; call routine to eject printer|12965
||brn|6,exnul|||; exit with null result|12966
||ejc|||||12967
;
;      endfile
;
|s_enf|ent||||; entry point|12971
||jsr|6,iofcb|||; call fcblk routine|12972
||err|1,096|26,endfile argument is not a suitable name|||12973
||err|1,097|26,endfile argument is null|||12974
||err|1,098|26,endfile file does not exist|||12975
||jsr|6,sysen|||; call endfile routine|12976
||err|1,098|26,endfile file does not exist|||12977
||err|1,099|26,endfile file does not permit endfile|||12978
||err|1,100|26,endfile caused non-recoverable output error|||12979
||mov|8,wb|7,xl||; remember vrblk ptr from iofcb call|12980
||mov|7,xr|7,xl||; copy pointer|12981
;
;      loop to find trtrf block
;
|senf1|mov|7,xl|7,xr||; remember previous entry|12985
||mov|7,xr|13,trval(xr)||; chain along|12986
||bne|9,(xr)|22,=b_trt|6,exnul|; skip out if chain end|12987
||bne|13,trtyp(xr)|18,=trtfc|6,senf1|; loop if not found|12988
||mov|13,trval(xl)|13,trval(xr)||; remove trtrf|12989
||mov|3,enfch|13,trtrf(xr)||; point to head of iochn|12990
||mov|8,wc|13,trfpt(xr)||; point to fcblk|12991
||mov|7,xr|8,wb||; filearg1 vrblk from iofcb|12992
||jsr|6,setvr|||; reset it|12993
||mov|7,xl|20,=r_fcb||; ptr to head of fcblk chain|12994
||sub|7,xl|19,*num02||; adjust ready to enter loop|12995
;
;      find fcblk
;
|senf2|mov|7,xr|7,xl||; copy ptr|12999
||mov|7,xl|13,num02(xl)||; get next link|13000
||bze|7,xl|6,senf4||; stop if chain end|13001
||beq|13,num03(xl)|8,wc|6,senf3|; jump if fcblk found|13002
||brn|6,senf2|||; loop|13003
;
;      remove fcblk
;
|senf3|mov|13,num02(xr)|13,num02(xl)||; delete fcblk from chain|13007
;
;      loop which detaches all vbls on iochn chain
;
|senf4|mov|7,xl|3,enfch||; get chain head|13011
||bze|7,xl|6,exnul||; finished if chain end|13012
||mov|3,enfch|13,trtrf(xl)||; chain along|13013
||mov|8,wa|13,ionmo(xl)||; name offset|13014
||mov|7,xl|13,ionmb(xl)||; name base|13015
||jsr|6,dtach|||; detach name|13016
||brn|6,senf4|||; loop till done|13017
||ejc|||||13018
;
;      eq
;
|s_eqf|ent||||; entry point|13022
||jsr|6,acomp|||; call arithmetic comparison routine|13023
||err|1,101|26,eq first argument is not numeric|||13024
||err|1,102|26,eq second argument is not numeric|||13025
||ppm|6,exfal|||; fail if lt|13026
||ppm|6,exnul|||; return null if eq|13027
||ppm|6,exfal|||; fail if gt|13028
||ejc|||||13029
;
;      eval
;
|s_evl|ent||||; entry point|13033
||mov|7,xr|10,(xs)+||; load argument|13034
||lcw|8,wc|||; load next code word|13040
||bne|8,wc|21,=ofne_|6,sevl1|; jump if called by value|13041
||scp|7,xl|||; copy code pointer|13042
||mov|8,wa|9,(xl)||; get next code word|13043
||bne|8,wa|21,=ornm_|6,sevl2|; by name unless expression|13044
||bnz|13,num01(xs)|6,sevl2||; jump if by name|13045
;
;      here if called by value
;
|sevl1|zer|8,wb|||; set flag for by value|13049
||mov|11,-(xs)|8,wc||; save code word|13051
||jsr|6,gtexp|||; convert to expression|13052
||err|1,103|26,eval argument is not expression|||13053
||zer|3,r_ccb|||; forget interim code block|13054
||zer|8,wb|||; set flag for by value|13055
||jsr|6,evalx|||; evaluate expression by value|13059
||ppm|6,exfal|||; fail if evaluation fails|13060
||mov|7,xl|7,xr||; copy result|13061
||mov|7,xr|9,(xs)||; reload next code word|13062
||mov|9,(xs)|7,xl||; stack result|13063
||bri|9,(xr)|||; jump to execute next code word|13064
;
;      here if called by name
;
|sevl2|mov|8,wb|18,=num01||; set flag for by name|13068
||jsr|6,gtexp|||; convert to expression|13070
||err|1,103|26,eval argument is not expression|||13071
||zer|3,r_ccb|||; forget interim code block|13072
||mov|8,wb|18,=num01||; set flag for by name|13073
||jsr|6,evalx|||; evaluate expression by name|13075
||ppm|6,exfal|||; fail if evaluation fails|13076
||brn|6,exnam|||; exit with name|13077
||ejc|||||13080
;
;      exit
;
|s_ext|ent||||; entry point|13084
||zer|8,wb|||; clear amount of static shift|13085
||zer|3,r_ccb|||; forget interim code block|13086
||zer|3,dnams|||; collect sediment too|13088
||jsr|6,gbcol|||; compact memory by collecting|13089
||mov|3,dnams|7,xr||; record new sediment size|13090
||jsr|6,gtstg|||;|13094
||err|1,288|26,exit second argument is not a string|||13095
||mov|7,xl|7,xr||; copy second arg string pointer|13096
||jsr|6,gtstg|||; convert arg to string|13097
||err|1,104|26,exit first argument is not suitable integer or string|||13098
||mov|11,-(xs)|7,xl||; save second argument|13099
||mov|7,xl|7,xr||; copy first arg string ptr|13100
||jsr|6,gtint|||; check it is integer|13101
||ppm|6,sext1|||; skip if unconvertible|13102
||zer|7,xl|||; note it is integer|13103
||ldi|13,icval(xr)|||; get integer arg|13104
;
;      merge to call osint exit routine
;
|sext1|mov|8,wb|3,r_fcb||; get fcblk chain header|13108
||mov|7,xr|21,=headv||; point to v.v string|13109
||mov|8,wa|10,(xs)+||; provide second argument scblk|13110
||jsr|6,sysxi|||; call external routine|13111
||err|1,105|26,exit action not available in this implementation|||13112
||err|1,106|26,exit action caused irrecoverable error|||13113
||ieq|6,exnul|||; return if argument 0|13114
||igt|6,sext2|||; skip if positive|13115
||ngi||||; make positive|13116
;
;      check for option respecification
;
;      sysxi returns 0 in wa when a file has been resumed,
;      1 when this is a continuation of an exit(4) or exit(-4)
;      action.
;
|sext2|mfi|8,wc|||; get value in work reg|13124
||add|8,wa|8,wc||; prepare to test for continue|13125
||beq|8,wa|18,=num05|6,sext5|; continued execution if 4 plus 1|13126
||zer|3,gbcnt|||; resuming execution so reset|13127
||bge|8,wc|18,=num03|6,sext3|; skip if was 3 or 4|13128
||mov|11,-(xs)|8,wc||; save value|13129
||zer|8,wc|||; set to read options|13130
||jsr|6,prpar|||; read syspp options|13131
||mov|8,wc|10,(xs)+||; restore value|13132
;
;      deal with header option (fiddled by prpar)
;
|sext3|mnz|3,headp|||; assume no headers|13136
||bne|8,wc|18,=num01|6,sext4|; skip if not 1|13137
||zer|3,headp|||; request header printing|13138
;
;      almost ready to resume running
;
|sext4|jsr|6,systm|||; get execution time start (sgd11)|13142
||sti|3,timsx|||; save as initial time|13143
||ldi|3,kvstc|||; reset to ensure ...|13144
||sti|3,kvstl|||; ... correct execution stats|13145
||jsr|6,stgcc|||; recompute countdown counters|13146
||brn|6,exnul|||; resume execution|13147
;
;      here after exit(4) or exit(-4) -- create save file
;      or load module and continue execution.
;
;      return integer 1 to signal the continuation of the
;      original execution.
;
|sext5|mov|7,xr|21,=inton||; integer one|13155
||brn|6,exixr|||; return as result|13156
||ejc|||||13158
;
;      exp
;
|s_exp|ent||||; entry point|13163
||mov|7,xr|10,(xs)+||; get argument|13164
||jsr|6,gtrea|||; convert to real|13165
||err|1,304|26,exp argument not numeric|||13166
||ldr|13,rcval(xr)|||; load accumulator with argument|13167
||etx||||; take exponential|13168
||rno|6,exrea|||; if no overflow, return result in ra|13169
||erb|1,305|26,exp produced real overflow|||13170
||ejc|||||13171
;
;      field
;
|s_fld|ent||||; entry point|13176
||jsr|6,gtsmi|||; get second argument (field number)|13177
||err|1,107|26,field second argument is not integer|||13178
||ppm|6,exfal|||; fail if out of range|13179
||mov|8,wb|7,xr||; else save integer value|13180
||mov|7,xr|10,(xs)+||; load first argument|13181
||jsr|6,gtnvr|||; point to vrblk|13182
||ppm|6,sfld1|||; jump (error) if not variable name|13183
||mov|7,xr|13,vrfnc(xr)||; else point to function block|13184
||bne|9,(xr)|22,=b_dfc|6,sfld1|; error if not datatype function|13185
;
;      here if first argument is a datatype function name
;
||bze|8,wb|6,exfal||; fail if argument number is zero|13189
||bgt|8,wb|13,fargs(xr)|6,exfal|; fail if too large|13190
||wtb|8,wb|||; else convert to byte offset|13191
||add|7,xr|8,wb||; point to field name|13192
||mov|7,xr|13,dfflb(xr)||; load vrblk pointer|13193
||brn|6,exvnm|||; exit to build nmblk|13194
;
;      here for bad first argument
;
|sfld1|erb|1,108|26,field first argument is not datatype name|||13198
||ejc|||||13199
;
;      fence
;
|s_fnc|ent||||; entry point|13203
||mov|8,wb|22,=p_fnc||; set pcode for p_fnc|13204
||zer|7,xr|||; p0blk|13205
||jsr|6,pbild|||; build p_fnc node|13206
||mov|7,xl|7,xr||; save pointer to it|13207
||mov|7,xr|10,(xs)+||; get argument|13208
||jsr|6,gtpat|||; convert to pattern|13209
||err|1,259|26,fence argument is not pattern|||13210
||jsr|6,pconc|||; concatenate to p_fnc node|13211
||mov|7,xl|7,xr||; save ptr to concatenated pattern|13212
||mov|8,wb|22,=p_fna||; set for p_fna pcode|13213
||zer|7,xr|||; p0blk|13214
||jsr|6,pbild|||; construct p_fna node|13215
||mov|13,pthen(xr)|7,xl||; set pattern as pthen|13216
||mov|11,-(xs)|7,xr||; set as result|13217
||lcw|7,xr|||; get next code word|13218
||bri|9,(xr)|||; execute next code word|13219
||ejc|||||13220
;
;      ge
;
|s_gef|ent||||; entry point|13224
||jsr|6,acomp|||; call arithmetic comparison routine|13225
||err|1,109|26,ge first argument is not numeric|||13226
||err|1,110|26,ge second argument is not numeric|||13227
||ppm|6,exfal|||; fail if lt|13228
||ppm|6,exnul|||; return null if eq|13229
||ppm|6,exnul|||; return null if gt|13230
||ejc|||||13231
;
;      gt
;
|s_gtf|ent||||; entry point|13235
||jsr|6,acomp|||; call arithmetic comparison routine|13236
||err|1,111|26,gt first argument is not numeric|||13237
||err|1,112|26,gt second argument is not numeric|||13238
||ppm|6,exfal|||; fail if lt|13239
||ppm|6,exfal|||; fail if eq|13240
||ppm|6,exnul|||; return null if gt|13241
||ejc|||||13242
;
;      host
;
|s_hst|ent||||; entry point|13246
||mov|8,wc|10,(xs)+||; get fifth arg|13247
||mov|8,wb|10,(xs)+||; get fourth arg|13248
||mov|7,xr|10,(xs)+||; get third arg|13249
||mov|7,xl|10,(xs)+||; get second arg|13250
||mov|8,wa|10,(xs)+||; get first arg|13251
||jsr|6,syshs|||; enter syshs routine|13252
||err|1,254|26,erroneous argument for host|||13253
||err|1,255|26,error during execution of host|||13254
||ppm|6,shst1|||; store host string|13255
||ppm|6,exnul|||; return null result|13256
||ppm|6,exixr|||; return xr|13257
||ppm|6,exfal|||; fail return|13258
||ppm|6,shst3|||; store actual string|13259
||ppm|6,shst4|||; return copy of xr|13260
;
;      return host string
;
|shst1|bze|7,xl|6,exnul||; null string if syshs uncooperative|13264
||mov|8,wa|13,sclen(xl)||; length|13265
||zer|8,wb|||; zero offset|13266
;
;      copy string and return
;
|shst2|jsr|6,sbstr|||; build copy of string|13270
||mov|11,-(xs)|7,xr||; stack the result|13271
||lcw|7,xr|||; load next code word|13272
||bri|9,(xr)|||; execute it|13273
;
;      return actual string pointed to by xl
;
|shst3|zer|8,wb|||; treat xl like an scblk ptr|13277
||sub|8,wb|18,=cfp_f||; by creating a negative offset|13278
||brn|6,shst2|||; join to copy string|13279
;
;      return copy of block pointed to by xr
;
|shst4|mov|11,-(xs)|7,xr||; stack results|13283
||jsr|6,copyb|||; make copy of block|13284
||ppm|6,exits|||; if not an aggregate structure|13285
||brn|6,exsid|||; set current id value otherwise|13286
||ejc|||||13287
;
;      ident
;
|s_idn|ent||||; entry point|13291
||mov|7,xr|10,(xs)+||; load second argument|13292
||mov|7,xl|10,(xs)+||; load first argument|13293
||jsr|6,ident|||; call ident comparison routine|13294
||ppm|6,exnul|||; return null if ident|13295
||brn|6,exfal|||; fail if differ|13296
||ejc|||||13297
;
;      input
;
|s_inp|ent||||; entry point|13301
||zer|8,wb|||; input flag|13302
||jsr|6,ioput|||; call input/output assoc. routine|13303
||err|1,113|26,input third argument is not a string|||13304
||err|1,114|26,inappropriate second argument for input|||13305
||err|1,115|26,inappropriate first argument for input|||13306
||err|1,116|26,inappropriate file specification for input|||13307
||ppm|6,exfal|||; fail if file does not exist|13308
||err|1,117|26,input file cannot be read|||13309
||err|1,289|26,input channel currently in use|||13310
||brn|6,exnul|||; return null string|13311
||ejc|||||13312
;
;      integer
;
|s_int|ent||||; entry point|13345
||mov|7,xr|10,(xs)+||; load argument|13346
||jsr|6,gtnum|||; convert to numeric|13347
||ppm|6,exfal|||; fail if non-numeric|13348
||beq|8,wa|22,=b_icl|6,exnul|; return null if integer|13349
||brn|6,exfal|||; fail if real|13350
||ejc|||||13351
;
;      item
;
;      item does not permit the direct (fast) call so that
;      wa contains the actual number of arguments passed.
;
|s_itm|ent||||; entry point|13358
;
;      deal with case of no args
;
||bnz|8,wa|6,sitm1||; jump if at least one arg|13362
||mov|11,-(xs)|21,=nulls||; else supply garbage null arg|13363
||mov|8,wa|18,=num01||; and fix argument count|13364
;
;      check for name/value cases
;
|sitm1|scp|7,xr|||; get current code pointer|13368
||mov|7,xl|9,(xr)||; load next code word|13369
||dcv|8,wa|||; get number of subscripts|13370
||mov|7,xr|8,wa||; copy for arref|13371
||beq|7,xl|21,=ofne_|6,sitm2|; jump if called by name|13372
;
;      here if called by value
;
||zer|8,wb|||; set code for call by value|13376
||brn|6,arref|||; off to array reference routine|13377
;
;      here for call by name
;
|sitm2|mnz|8,wb|||; set code for call by name|13381
||lcw|8,wa|||; load and ignore ofne_ call|13382
||brn|6,arref|||; off to array reference routine|13383
||ejc|||||13384
;
;      le
;
|s_lef|ent||||; entry point|13388
||jsr|6,acomp|||; call arithmetic comparison routine|13389
||err|1,118|26,le first argument is not numeric|||13390
||err|1,119|26,le second argument is not numeric|||13391
||ppm|6,exnul|||; return null if lt|13392
||ppm|6,exnul|||; return null if eq|13393
||ppm|6,exfal|||; fail if gt|13394
||ejc|||||13395
;
;      len
;
|s_len|ent||||; entry point|13399
||mov|8,wb|22,=p_len||; set pcode for integer arg case|13400
||mov|8,wa|22,=p_lnd||; set pcode for expr arg case|13401
||jsr|6,patin|||; call common routine to build node|13402
||err|1,120|26,len argument is not integer or expression|||13403
||err|1,121|26,len argument is negative or too large|||13404
||mov|11,-(xs)|7,xr||; stack result|13405
||lcw|7,xr|||; get next code word|13406
||bri|9,(xr)|||; execute it|13407
||ejc|||||13408
;
;      leq
;
|s_leq|ent||||; entry point|13412
||jsr|6,lcomp|||; call string comparison routine|13413
||err|1,122|26,leq first argument is not a string|||13414
||err|1,123|26,leq second argument is not a string|||13415
||ppm|6,exfal|||; fail if llt|13416
||ppm|6,exnul|||; return null if leq|13417
||ppm|6,exfal|||; fail if lgt|13418
||ejc|||||13419
;
;      lge
;
|s_lge|ent||||; entry point|13423
||jsr|6,lcomp|||; call string comparison routine|13424
||err|1,124|26,lge first argument is not a string|||13425
||err|1,125|26,lge second argument is not a string|||13426
||ppm|6,exfal|||; fail if llt|13427
||ppm|6,exnul|||; return null if leq|13428
||ppm|6,exnul|||; return null if lgt|13429
||ejc|||||13430
;
;      lgt
;
|s_lgt|ent||||; entry point|13434
||jsr|6,lcomp|||; call string comparison routine|13435
||err|1,126|26,lgt first argument is not a string|||13436
||err|1,127|26,lgt second argument is not a string|||13437
||ppm|6,exfal|||; fail if llt|13438
||ppm|6,exfal|||; fail if leq|13439
||ppm|6,exnul|||; return null if lgt|13440
||ejc|||||13441
;
;      lle
;
|s_lle|ent||||; entry point|13445
||jsr|6,lcomp|||; call string comparison routine|13446
||err|1,128|26,lle first argument is not a string|||13447
||err|1,129|26,lle second argument is not a string|||13448
||ppm|6,exnul|||; return null if llt|13449
||ppm|6,exnul|||; return null if leq|13450
||ppm|6,exfal|||; fail if lgt|13451
||ejc|||||13452
;
;      llt
;
|s_llt|ent||||; entry point|13456
||jsr|6,lcomp|||; call string comparison routine|13457
||err|1,130|26,llt first argument is not a string|||13458
||err|1,131|26,llt second argument is not a string|||13459
||ppm|6,exnul|||; return null if llt|13460
||ppm|6,exfal|||; fail if leq|13461
||ppm|6,exfal|||; fail if lgt|13462
||ejc|||||13463
;
;      lne
;
|s_lne|ent||||; entry point|13467
||jsr|6,lcomp|||; call string comparison routine|13468
||err|1,132|26,lne first argument is not a string|||13469
||err|1,133|26,lne second argument is not a string|||13470
||ppm|6,exnul|||; return null if llt|13471
||ppm|6,exfal|||; fail if leq|13472
||ppm|6,exnul|||; return null if lgt|13473
||ejc|||||13474
;
;      ln
;
|s_lnf|ent||||; entry point|13479
||mov|7,xr|10,(xs)+||; get argument|13480
||jsr|6,gtrea|||; convert to real|13481
||err|1,306|26,ln argument not numeric|||13482
||ldr|13,rcval(xr)|||; load accumulator with argument|13483
||req|6,slnf1|||; overflow if argument is 0|13484
||rlt|6,slnf2|||; error if argument less than 0|13485
||lnf||||; take natural logarithm|13486
||rno|6,exrea|||; if no overflow, return result in ra|13487
|slnf1|erb|1,307|26,ln produced real overflow|||13488
;
;      here for bad argument
;
|slnf2|erb|1,315|26,ln argument negative|||13492
||ejc|||||13493
;
;      local
;
|s_loc|ent||||; entry point|13498
||jsr|6,gtsmi|||; get second argument (local number)|13499
||err|1,134|26,local second argument is not integer|||13500
||ppm|6,exfal|||; fail if out of range|13501
||mov|8,wb|7,xr||; save local number|13502
||mov|7,xr|10,(xs)+||; load first argument|13503
||jsr|6,gtnvr|||; point to vrblk|13504
||ppm|6,sloc1|||; jump if not variable name|13505
||mov|7,xr|13,vrfnc(xr)||; else load function pointer|13506
||bne|9,(xr)|22,=b_pfc|6,sloc1|; jump if not program defined|13507
;
;      here if we have a program defined function name
;
||bze|8,wb|6,exfal||; fail if second arg is zero|13511
||bgt|8,wb|13,pfnlo(xr)|6,exfal|; or too large|13512
||add|8,wb|13,fargs(xr)||; else adjust offset to include args|13513
||wtb|8,wb|||; convert to bytes|13514
||add|7,xr|8,wb||; point to local pointer|13515
||mov|7,xr|13,pfagb(xr)||; load vrblk pointer|13516
||brn|6,exvnm|||; exit building nmblk|13517
;
;      here if first argument is no good
;
|sloc1|erb|1,135|26,local first arg is not a program function name|||13521
||ejc|||||13524
;
;      load
;
|s_lod|ent||||; entry point|13528
||jsr|6,gtstg|||; load library name|13529
||err|1,136|26,load second argument is not a string|||13530
||mov|7,xl|7,xr||; save library name|13531
||jsr|6,xscni|||; prepare to scan first argument|13532
||err|1,137|26,load first argument is not a string|||13533
||err|1,138|26,load first argument is null|||13534
||mov|11,-(xs)|7,xl||; stack library name|13535
||mov|8,wc|18,=ch_pp||; set delimiter one = left paren|13536
||mov|7,xl|8,wc||; set delimiter two = left paren|13537
||mnz|8,wa|||; skip/trim blanks in prototype|13538
||jsr|6,xscan|||; scan function name|13539
||mov|11,-(xs)|7,xr||; save ptr to function name|13540
||bnz|8,wa|6,slod1||; jump if left paren found|13541
||erb|1,139|26,load first argument is missing a left paren|||13542
;
;      here after successfully scanning function name
;
|slod1|jsr|6,gtnvr|||; locate vrblk|13546
||err|1,140|26,load first argument has null function name|||13547
||mov|3,lodfn|7,xr||; save vrblk pointer|13548
||zer|3,lodna|||; zero count of arguments|13549
;
;      loop to scan argument datatype names
;
|slod2|mov|8,wc|18,=ch_rp||; delimiter one is right paren|13553
||mov|7,xl|18,=ch_cm||; delimiter two is comma|13554
||mnz|8,wa|||; skip/trim blanks in prototype|13555
||jsr|6,xscan|||; scan next argument name|13556
||icv|3,lodna|||; bump argument count|13557
||bnz|8,wa|6,slod3||; jump if ok delimiter was found|13558
||erb|1,141|26,load first argument is missing a right paren|||13559
||ejc|||||13560
;
;      load (continued)
;
;      come here to analyze the datatype pointer in (xr). this
;      code is used both for arguments (wa=1,2) and for the
;      result datatype (with wa set to zero).
;
|slod3|mov|8,wb|8,wa||; save scan mode|13569
||mov|8,wa|13,sclen(xr)||; datatype length|13570
||bze|8,wa|6,sld3a||; bypass if null string|13571
||jsr|6,flstg|||; fold to upper case|13572
|sld3a|mov|8,wa|8,wb||; restore scan mode|13573
||mov|11,-(xs)|7,xr||; stack datatype name pointer|13574
||mov|8,wb|18,=num01||; set string code in case|13578
||mov|7,xl|21,=scstr||; point to /string/|13579
||jsr|6,ident|||; check for match|13580
||ppm|6,slod4|||; jump if match|13581
||mov|7,xr|9,(xs)||; else reload name|13582
||add|8,wb|8,wb||; set code for integer (2)|13583
||mov|7,xl|21,=scint||; point to /integer/|13584
||jsr|6,ident|||; check for match|13585
||ppm|6,slod4|||; jump if match|13586
||mov|7,xr|9,(xs)||; else reload string pointer|13589
||icv|8,wb|||; set code for real (3)|13590
||mov|7,xl|21,=screa||; point to /real/|13591
||jsr|6,ident|||; check for match|13592
||ppm|6,slod4|||; jump if match|13593
||mov|7,xr|9,(xs)||; reload string pointer|13596
||icv|8,wb|||; code for file (4, or 3 if no reals)|13597
||mov|7,xl|21,=scfil||; point to /file/|13598
||jsr|6,ident|||; check for match|13599
||ppm|6,slod4|||; jump if match|13600
||zer|8,wb|||; else get code for no convert|13602
;
;      merge here with proper datatype code in wb
;
|slod4|mov|9,(xs)|8,wb||; store code on stack|13606
||beq|8,wa|18,=num02|6,slod2|; loop back if arg stopped by comma|13607
||bze|8,wa|6,slod5||; jump if that was the result type|13608
;
;      here we scan out the result type (arg stopped by ) )
;
||mov|8,wc|3,mxlen||; set dummy (impossible) delimiter 1|13612
||mov|7,xl|8,wc||; and delimiter two|13613
||mnz|8,wa|||; skip/trim blanks in prototype|13614
||jsr|6,xscan|||; scan result name|13615
||zer|8,wa|||; set code for processing result|13616
||brn|6,slod3|||; jump back to process result name|13617
||ejc|||||13618
;
;      load (continued)
;
;      here after processing all args and result
;
|slod5|mov|8,wa|3,lodna||; get number of arguments|13624
||mov|8,wc|8,wa||; copy for later|13625
||wtb|8,wa|||; convert length to bytes|13626
||add|8,wa|19,*efsi_||; add space for standard fields|13627
||jsr|6,alloc|||; allocate efblk|13628
||mov|9,(xr)|22,=b_efc||; set type word|13629
||mov|13,fargs(xr)|8,wc||; set number of arguments|13630
||zer|13,efuse(xr)|||; set use count (dffnc will set to 1)|13631
||zer|13,efcod(xr)|||; zero code pointer for now|13632
||mov|13,efrsl(xr)|10,(xs)+||; store result type code|13633
||mov|13,efvar(xr)|3,lodfn||; store function vrblk pointer|13634
||mov|13,eflen(xr)|8,wa||; store efblk length|13635
||mov|8,wb|7,xr||; save efblk pointer|13636
||add|7,xr|8,wa||; point past end of efblk|13637
||lct|8,wc|8,wc||; set number of arguments for loop|13638
;
;      loop to set argument type codes from stack
;
|slod6|mov|11,-(xr)|10,(xs)+||; store one type code from stack|13642
||bct|8,wc|6,slod6||; loop till all stored|13643
;
;      now load the external function and perform definition
;
||mov|7,xr|10,(xs)+||; load function string name|13647
||mov|8,wa|13,sclen(xr)||; function name length|13649
||jsr|6,flstg|||; fold to upper case|13650
||mov|7,xl|9,(xs)||; load library name|13652
||mov|9,(xs)|8,wb||; store efblk pointer|13653
||jsr|6,sysld|||; call function to load external func|13654
||err|1,142|26,load function does not exist|||13655
||err|1,143|26,load function caused input error during load|||13656
||err|1,328|26,load function - insufficient memory|||13657
||mov|7,xl|10,(xs)+||; recall efblk pointer|13658
||mov|13,efcod(xl)|7,xr||; store code pointer|13659
||mov|7,xr|3,lodfn||; point to vrblk for function|13660
||jsr|6,dffnc|||; perform function definition|13661
||brn|6,exnul|||; return null result|13662
||ejc|||||13664
;
;      lpad
;
|s_lpd|ent||||; entry point|13668
||jsr|6,gtstg|||; get pad character|13669
||err|1,144|26,lpad third argument is not a string|||13670
||plc|7,xr|||; point to character (null is blank)|13671
||lch|8,wb|9,(xr)||; load pad character|13672
||jsr|6,gtsmi|||; get pad length|13673
||err|1,145|26,lpad second argument is not integer|||13674
||ppm|6,slpd4|||; skip if negative or large|13675
;
;      merge to check first arg
;
|slpd1|jsr|6,gtstg|||; get first argument (string to pad)|13679
||err|1,146|26,lpad first argument is not a string|||13680
||bge|8,wa|8,wc|6,exixr|; return 1st arg if too long to pad|13681
||mov|7,xl|7,xr||; else move ptr to string to pad|13682
;
;      now we are ready for the pad
;
;      (xl)		     pointer to string to pad
;      (wb)		     pad character
;      (wc)		     length to pad string to
;
||mov|8,wa|8,wc||; copy length|13690
||jsr|6,alocs|||; allocate scblk for new string|13691
||mov|11,-(xs)|7,xr||; save as result|13692
||mov|8,wa|13,sclen(xl)||; load length of argument|13693
||sub|8,wc|8,wa||; calculate number of pad characters|13694
||psc|7,xr|||; point to chars in result string|13695
||lct|8,wc|8,wc||; set counter for pad loop|13696
;
;      loop to perform pad
;
|slpd2|sch|8,wb|10,(xr)+||; store pad character, bump ptr|13700
||bct|8,wc|6,slpd2||; loop till all pad chars stored|13701
||csc|7,xr|||; complete store characters|13702
;
;      now copy string
;
||bze|8,wa|6,slpd3||; exit if null string|13706
||plc|7,xl|||; else point to chars in argument|13707
||mvc||||; move characters to result string|13708
||zer|7,xl|||; clear garbage xl|13709
;
;      here to exit with result on stack
;
|slpd3|lcw|7,xr|||; load next code word|13713
||bri|9,(xr)|||; execute it|13714
;
;      here if 2nd arg is negative or large
;
|slpd4|zer|8,wc|||; zero pad count|13718
||brn|6,slpd1|||; merge|13719
||ejc|||||13720
;
;      lt
;
|s_ltf|ent||||; entry point|13724
||jsr|6,acomp|||; call arithmetic comparison routine|13725
||err|1,147|26,lt first argument is not numeric|||13726
||err|1,148|26,lt second argument is not numeric|||13727
||ppm|6,exnul|||; return null if lt|13728
||ppm|6,exfal|||; fail if eq|13729
||ppm|6,exfal|||; fail if gt|13730
||ejc|||||13731
;
;      ne
;
|s_nef|ent||||; entry point|13735
||jsr|6,acomp|||; call arithmetic comparison routine|13736
||err|1,149|26,ne first argument is not numeric|||13737
||err|1,150|26,ne second argument is not numeric|||13738
||ppm|6,exnul|||; return null if lt|13739
||ppm|6,exfal|||; fail if eq|13740
||ppm|6,exnul|||; return null if gt|13741
||ejc|||||13742
;
;      notany
;
|s_nay|ent||||; entry point|13746
||mov|8,wb|22,=p_nas||; set pcode for single char arg|13747
||mov|7,xl|22,=p_nay||; pcode for multi-char arg|13748
||mov|8,wc|22,=p_nad||; set pcode for expr arg|13749
||jsr|6,patst|||; call common routine to build node|13750
||err|1,151|26,notany argument is not a string or expression|||13751
||mov|11,-(xs)|7,xr||; stack result|13752
||lcw|7,xr|||; get next code word|13753
||bri|9,(xr)|||; execute it|13754
||ejc|||||13755
;
;      opsyn
;
|s_ops|ent||||; entry point|13759
||jsr|6,gtsmi|||; load third argument|13760
||err|1,152|26,opsyn third argument is not integer|||13761
||err|1,153|26,opsyn third argument is negative or too large|||13762
||mov|8,wb|8,wc||; if ok, save third argumnet|13763
||mov|7,xr|10,(xs)+||; load second argument|13764
||jsr|6,gtnvr|||; locate variable block|13765
||err|1,154|26,opsyn second arg is not natural variable name|||13766
||mov|7,xl|13,vrfnc(xr)||; if ok, load function block pointer|13767
||bnz|8,wb|6,sops2||; jump if operator opsyn case|13768
;
;      here for function opsyn (third arg zero)
;
||mov|7,xr|10,(xs)+||; load first argument|13772
||jsr|6,gtnvr|||; get vrblk pointer|13773
||err|1,155|26,opsyn first arg is not natural variable name|||13774
;
;      merge here to perform function definition
;
|sops1|jsr|6,dffnc|||; call function definer|13778
||brn|6,exnul|||; exit with null result|13779
;
;      here for operator opsyn (third arg non-zero)
;
|sops2|jsr|6,gtstg|||; get operator name|13783
||ppm|6,sops5|||; jump if not string|13784
||bne|8,wa|18,=num01|6,sops5|; error if not one char long|13785
||plc|7,xr|||; else point to character|13786
||lch|8,wc|9,(xr)||; load character name|13787
||ejc|||||13788
;
;      opsyn (continued)
;
;      now set to search for matching unary or binary operator
;      name as appropriate. note that there are =opbun undefined
;      binary operators and =opuun undefined unary operators.
;
||mov|8,wa|20,=r_uub||; point to unop pointers in case|13796
||mov|7,xr|21,=opnsu||; point to names of unary operators|13797
||add|8,wb|18,=opbun||; add no. of undefined binary ops|13798
||beq|8,wb|18,=opuun|6,sops3|; jump if unop (third arg was 1)|13799
||mov|8,wa|20,=r_uba||; else point to binary operator ptrs|13800
||mov|7,xr|21,=opsnb||; point to names of binary operators|13801
||mov|8,wb|18,=opbun||; set number of undefined binops|13802
;
;      merge here to check list (wb = number to check)
;
|sops3|lct|8,wb|8,wb||; set counter to control loop|13806
;
;      loop to search for name match
;
|sops4|beq|8,wc|9,(xr)|6,sops6|; jump if names match|13810
||ica|8,wa|||; else push pointer to function ptr|13811
||ica|7,xr|||; bump pointer|13812
||bct|8,wb|6,sops4||; loop back till all checked|13813
;
;      here if bad operator name
;
|sops5|erb|1,156|26,opsyn first arg is not correct operator name|||13817
;
;      come here on finding a match in the operator name table
;
|sops6|mov|7,xr|8,wa||; copy pointer to function block ptr|13821
||sub|7,xr|19,*vrfnc||; make it look like dummy vrblk|13822
||brn|6,sops1|||; merge back to define operator|13823
||ejc|||||13824
;
;      output
;
|s_oup|ent||||; entry point|13849
||mov|8,wb|18,=num03||; output flag|13850
||jsr|6,ioput|||; call input/output assoc. routine|13851
||err|1,157|26,output third argument is not a string|||13852
||err|1,158|26,inappropriate second argument for output|||13853
||err|1,159|26,inappropriate first argument for output|||13854
||err|1,160|26,inappropriate file specification for output|||13855
||ppm|6,exfal|||; fail if file does not exist|13856
||err|1,161|26,output file cannot be written to|||13857
||err|1,290|26,output channel currently in use|||13858
||brn|6,exnul|||; return null string|13859
||ejc|||||13860
;
;      pos
;
|s_pos|ent||||; entry point|13864
||mov|8,wb|22,=p_pos||; set pcode for integer arg case|13865
||mov|8,wa|22,=p_psd||; set pcode for expression arg case|13866
||jsr|6,patin|||; call common routine to build node|13867
||err|1,162|26,pos argument is not integer or expression|||13868
||err|1,163|26,pos argument is negative or too large|||13869
||mov|11,-(xs)|7,xr||; stack result|13870
||lcw|7,xr|||; get next code word|13871
||bri|9,(xr)|||; execute it|13872
||ejc|||||13873
;
;      prototype
;
|s_pro|ent||||; entry point|13877
||mov|7,xr|10,(xs)+||; load argument|13878
||mov|8,wb|13,tblen(xr)||; length if table, vector (=vclen)|13879
||btw|8,wb|||; convert to words|13880
||mov|8,wa|9,(xr)||; load type word of argument block|13881
||beq|8,wa|22,=b_art|6,spro4|; jump if array|13882
||beq|8,wa|22,=b_tbt|6,spro1|; jump if table|13883
||beq|8,wa|22,=b_vct|6,spro3|; jump if vector|13884
||erb|1,164|26,prototype argument is not valid object|||13889
;
;      here for table
;
|spro1|sub|8,wb|18,=tbsi_||; subtract standard fields|13893
;
;      merge for vector
;
|spro2|mti|8,wb|||; convert to integer|13897
||brn|6,exint|||; exit with integer result|13898
;
;      here for vector
;
|spro3|sub|8,wb|18,=vcsi_||; subtract standard fields|13902
||brn|6,spro2|||; merge|13903
;
;      here for array
;
|spro4|add|7,xr|13,arofs(xr)||; point to prototype field|13907
||mov|7,xr|9,(xr)||; load prototype|13908
||mov|11,-(xs)|7,xr||; stack result|13909
||lcw|7,xr|||; get next code word|13910
||bri|9,(xr)|||; execute it|13911
||ejc|||||13921
;
;      remdr
;
|s_rmd|ent||||; entry point|13925
||jsr|6,arith|||; get two integers or two reals|13927
||err|1,166|26,remdr first argument is not numeric|||13928
||err|1,165|26,remdr second argument is not numeric|||13929
||ppm|6,srm06|||; if real|13930
;
;      both arguments integer
;
||zer|8,wb|||; set positive flag|13947
||ldi|13,icval(xr)|||; load left argument value|13948
||ige|6,srm01|||; jump if positive|13949
||mnz|8,wb|||; set negative flag|13950
|srm01|rmi|13,icval(xl)|||; get remainder|13951
||iov|6,srm05|||; error if overflow|13952
;
;      make sign of result match sign of first argument
;
||bze|8,wb|6,srm03||; if result should be positive|13956
||ile|6,exint|||; if should be negative, and is|13957
|srm02|ngi||||; adjust sign of result|13958
||brn|6,exint|||; return result|13959
|srm03|ilt|6,srm02|||; should be pos, and result negative|13960
||brn|6,exint|||; should be positive, and is|13961
;
;      fail first argument
;
|srm04|erb|1,166|26,remdr first argument is not numeric|||13965
;
;      fail if overflow
;
|srm05|erb|1,167|26,remdr caused integer overflow|||13969
;
;      here with 1st argument in (xr), 2nd in (xl), both real
;
;      result = n1 - chop(n1/n2)*n2
;
|srm06|zer|8,wb|||; set positive flag|13976
||ldr|13,rcval(xr)|||; load left argument value|13977
||rge|6,srm07|||; jump if positive|13978
||mnz|8,wb|||; set negative flag|13979
|srm07|dvr|13,rcval(xl)|||; compute n1/n2|13980
||rov|6,srm10|||; jump if overflow|13981
||chp||||; chop result|13982
||mlr|13,rcval(xl)|||; times n2|13983
||sbr|13,rcval(xr)|||; compute difference|13984
;
;      make sign of result match sign of first argument
;      -result is in ra at this point
;
||bze|8,wb|6,srm09||; if result should be positive|13989
||rle|6,exrea|||; if should be negative, and is|13990
|srm08|ngr||||; adjust sign of result|13991
||brn|6,exrea|||; return result|13992
|srm09|rlt|6,srm08|||; should be pos, and result negative|13993
||brn|6,exrea|||; should be positive, and is|13994
;
;      fail if overflow
;
|srm10|erb|1,312|26,remdr caused real overflow|||13998
||ejc|||||14000
;
;      replace
;
;      the actual replace operation uses an scblk whose cfp_a
;      chars contain the translated versions of all the chars.
;      the table pointer is remembered from call to call and
;      the table is only built when the arguments change.
;
;      we also perform an optimization gleaned from spitbol 370.
;      if the second argument is &alphabet, there is no need to
;      to build a replace table.  the third argument can be
;      used directly as the replace table.
;
|s_rpl|ent||||; entry point|14014
||jsr|6,gtstg|||; load third argument as string|14015
||err|1,168|26,replace third argument is not a string|||14016
||mov|7,xl|7,xr||; save third arg ptr|14017
||jsr|6,gtstg|||; get second argument|14018
||err|1,169|26,replace second argument is not a string|||14019
;
;      check to see if this is the same table as last time
;
||bne|7,xr|3,r_ra2|6,srpl1|; jump if 2nd argument different|14023
||beq|7,xl|3,r_ra3|6,srpl4|; jump if args same as last time|14024
;
;      here we build a new replace table (note wa = 2nd arg len)
;
|srpl1|mov|8,wb|13,sclen(xl)||; load 3rd argument length|14028
||bne|8,wa|8,wb|6,srpl6|; jump if arguments not same length|14029
||beq|7,xr|3,kvalp|6,srpl5|; jump if 2nd arg is alphabet string|14030
||bze|8,wb|6,srpl6||; jump if null 2nd argument|14031
||mov|3,r_ra3|7,xl||; save third arg for next time in|14032
||mov|3,r_ra2|7,xr||; save second arg for next time in|14033
||mov|7,xl|3,kvalp||; point to alphabet string|14034
||mov|8,wa|13,sclen(xl)||; load alphabet scblk length|14035
||mov|7,xr|3,r_rpt||; point to current table (if any)|14036
||bnz|7,xr|6,srpl2||; jump if we already have a table|14037
;
;      here we allocate a new table
;
||jsr|6,alocs|||; allocate new table|14041
||mov|8,wa|8,wc||; keep scblk length|14042
||mov|3,r_rpt|7,xr||; save table pointer for next time|14043
;
;      merge here with pointer to new table block in (xr)
;
|srpl2|ctb|8,wa|2,scsi_||; compute length of scblk|14047
||mvw||||; copy to get initial table values|14048
||ejc|||||14049
;
;      replace (continued)
;
;      now we must plug selected entries as required. note that
;      we are short of index registers for the following loop.
;      hence the need to repeatedly re-initialise char ptr xl
;
||mov|7,xl|3,r_ra2||; point to second argument|14057
||lct|8,wb|8,wb||; number of chars to plug|14058
||zer|8,wc|||; zero char offset|14059
||mov|7,xr|3,r_ra3||; point to 3rd arg|14060
||plc|7,xr|||; get char ptr for 3rd arg|14061
;
;      loop to plug chars
;
|srpl3|mov|7,xl|3,r_ra2||; point to 2nd arg|14065
||plc|7,xl|8,wc||; point to next char|14066
||icv|8,wc|||; increment offset|14067
||lch|8,wa|9,(xl)||; get next char|14068
||mov|7,xl|3,r_rpt||; point to translate table|14069
||psc|7,xl|8,wa||; convert char to offset into table|14070
||lch|8,wa|10,(xr)+||; get translated char|14071
||sch|8,wa|9,(xl)||; store in table|14072
||csc|7,xl|||; complete store characters|14073
||bct|8,wb|6,srpl3||; loop till done|14074
||ejc|||||14075
;
;      replace (continued)
;
;      here to use r_rpt as replace table.
;
|srpl4|mov|7,xl|3,r_rpt||; replace table to use|14081
;
;      here to perform translate using table in xl.
;
|srpl5|jsr|6,gtstg|||; get first argument|14086
||err|1,170|26,replace first argument is not a string|||14087
||bze|8,wa|6,exnul||; return null if null argument|14096
||mov|11,-(xs)|7,xl||; stack replace table to use|14097
||mov|7,xl|7,xr||; copy pointer|14098
||mov|8,wc|8,wa||; save length|14099
||ctb|8,wa|2,schar||; get scblk length|14100
||jsr|6,alloc|||; allocate space for copy|14101
||mov|8,wb|7,xr||; save address of copy|14102
||mvw||||; move scblk contents to copy|14103
||mov|7,xr|10,(xs)+||; unstack replace table|14104
||plc|7,xr|||; point to chars of table|14105
||mov|7,xl|8,wb||; point to string to translate|14106
||plc|7,xl|||; point to chars of string|14107
||mov|8,wa|8,wc||; set number of chars to translate|14108
||trc||||; perform translation|14109
|srpl8|mov|11,-(xs)|8,wb||; stack result|14110
||lcw|7,xr|||; load next code word|14111
||bri|9,(xr)|||; execute it|14112
;
;      error point
;
|srpl6|erb|1,171|26,null or unequally long 2nd, 3rd args to replace|||14116
||ejc|||||14131
;
;      rewind
;
|s_rew|ent||||; entry point|14135
||jsr|6,iofcb|||; call fcblk routine|14136
||err|1,172|26,rewind argument is not a suitable name|||14137
||err|1,173|26,rewind argument is null|||14138
||err|1,174|26,rewind file does not exist|||14139
||jsr|6,sysrw|||; call system rewind function|14140
||err|1,174|26,rewind file does not exist|||14141
||err|1,175|26,rewind file does not permit rewind|||14142
||err|1,176|26,rewind caused non-recoverable error|||14143
||brn|6,exnul|||; exit with null result if no error|14144
||ejc|||||14145
;
;      reverse
;
|s_rvs|ent||||; entry point|14149
||jsr|6,gtstg|||; load string argument|14151
||err|1,177|26,reverse argument is not a string|||14152
||bze|8,wa|6,exixr||; return argument if null|14158
||mov|7,xl|7,xr||; else save pointer to string arg|14159
||jsr|6,alocs|||; allocate space for new scblk|14160
||mov|11,-(xs)|7,xr||; store scblk ptr on stack as result|14161
||psc|7,xr|||; prepare to store in new scblk|14162
||plc|7,xl|8,wc||; point past last char in argument|14163
||lct|8,wc|8,wc||; set loop counter|14164
;
;      loop to move chars in reverse order
;
|srvs1|lch|8,wb|11,-(xl)||; load next char from argument|14168
||sch|8,wb|10,(xr)+||; store in result|14169
||bct|8,wc|6,srvs1||; loop till all moved|14170
;
;      here when complete to execute next code word
;
|srvs4|csc|7,xr|||; complete store characters|14174
||zer|7,xl|||; clear garbage xl|14175
|srvs2|lcw|7,xr|||; load next code word|14176
||bri|9,(xr)|||; execute it|14177
||ejc|||||14201
;
;      rpad
;
|s_rpd|ent||||; entry point|14205
||jsr|6,gtstg|||; get pad character|14206
||err|1,178|26,rpad third argument is not a string|||14207
||plc|7,xr|||; point to character (null is blank)|14208
||lch|8,wb|9,(xr)||; load pad character|14209
||jsr|6,gtsmi|||; get pad length|14210
||err|1,179|26,rpad second argument is not integer|||14211
||ppm|6,srpd3|||; skip if negative or large|14212
;
;      merge to check first arg.
;
|srpd1|jsr|6,gtstg|||; get first argument (string to pad)|14216
||err|1,180|26,rpad first argument is not a string|||14217
||bge|8,wa|8,wc|6,exixr|; return 1st arg if too long to pad|14218
||mov|7,xl|7,xr||; else move ptr to string to pad|14219
;
;      now we are ready for the pad
;
;      (xl)		     pointer to string to pad
;      (wb)		     pad character
;      (wc)		     length to pad string to
;
||mov|8,wa|8,wc||; copy length|14227
||jsr|6,alocs|||; allocate scblk for new string|14228
||mov|11,-(xs)|7,xr||; save as result|14229
||mov|8,wa|13,sclen(xl)||; load length of argument|14230
||sub|8,wc|8,wa||; calculate number of pad characters|14231
||psc|7,xr|||; point to chars in result string|14232
||lct|8,wc|8,wc||; set counter for pad loop|14233
;
;      copy argument string
;
||bze|8,wa|6,srpd2||; jump if argument is null|14237
||plc|7,xl|||; else point to argument chars|14238
||mvc||||; move characters to result string|14239
||zer|7,xl|||; clear garbage xl|14240
;
;      loop to supply pad characters
;
|srpd2|sch|8,wb|10,(xr)+||; store pad character, bump ptr|14244
||bct|8,wc|6,srpd2||; loop till all pad chars stored|14245
||csc|7,xr|||; complete character storing|14246
||lcw|7,xr|||; load next code word|14247
||bri|9,(xr)|||; execute it|14248
;
;      here if 2nd arg is negative or large
;
|srpd3|zer|8,wc|||; zero pad count|14252
||brn|6,srpd1|||; merge|14253
||ejc|||||14254
;
;      rtab
;
|s_rtb|ent||||; entry point|14258
||mov|8,wb|22,=p_rtb||; set pcode for integer arg case|14259
||mov|8,wa|22,=p_rtd||; set pcode for expression arg case|14260
||jsr|6,patin|||; call common routine to build node|14261
||err|1,181|26,rtab argument is not integer or expression|||14262
||err|1,182|26,rtab argument is negative or too large|||14263
||mov|11,-(xs)|7,xr||; stack result|14264
||lcw|7,xr|||; get next code word|14265
||bri|9,(xr)|||; execute it|14266
||ejc|||||14267
;
;      set
;
|s_set|ent||||; entry point|14272
||mov|3,r_io2|10,(xs)+||; save third arg (whence)|14273
||mov|3,r_io1|10,(xs)+||; save second arg (offset)|14280
||jsr|6,iofcb|||; call fcblk routine|14282
||err|1,291|26,set first argument is not a suitable name|||14283
||err|1,292|26,set first argument is null|||14284
||err|1,295|26,set file does not exist|||14285
||mov|8,wb|3,r_io1||; load second arg|14288
||mov|8,wc|3,r_io2||; load third arg|14290
||jsr|6,sysst|||; call system set routine|14291
||err|1,293|26,inappropriate second argument to set|||14292
||err|1,294|26,inappropriate third argument to set|||14293
||err|1,295|26,set file does not exist|||14294
||err|1,296|26,set file does not permit setting file pointer|||14295
||err|1,297|26,set caused non-recoverable i/o error|||14296
||brn|6,exint|||; otherwise return position|14301
||ejc|||||14303
;
;      tab
;
|s_tab|ent||||; entry point|14308
||mov|8,wb|22,=p_tab||; set pcode for integer arg case|14309
||mov|8,wa|22,=p_tbd||; set pcode for expression arg case|14310
||jsr|6,patin|||; call common routine to build node|14311
||err|1,183|26,tab argument is not integer or expression|||14312
||err|1,184|26,tab argument is negative or too large|||14313
||mov|11,-(xs)|7,xr||; stack result|14314
||lcw|7,xr|||; get next code word|14315
||bri|9,(xr)|||; execute it|14316
||ejc|||||14317
;
;      rpos
;
|s_rps|ent||||; entry point|14321
||mov|8,wb|22,=p_rps||; set pcode for integer arg case|14322
||mov|8,wa|22,=p_rpd||; set pcode for expression arg case|14323
||jsr|6,patin|||; call common routine to build node|14324
||err|1,185|26,rpos argument is not integer or expression|||14325
||err|1,186|26,rpos argument is negative or too large|||14326
||mov|11,-(xs)|7,xr||; stack result|14327
||lcw|7,xr|||; get next code word|14328
||bri|9,(xr)|||; execute it|14329
||ejc|||||14332
;
;      rsort
;
|s_rsr|ent||||; entry point|14336
||mnz|8,wa|||; mark as rsort|14337
||jsr|6,sorta|||; call sort routine|14338
||ppm|6,exfal|||; if conversion fails, so shall we|14339
||brn|6,exsid|||; return, setting idval|14340
||ejc|||||14342
;
;      setexit
;
|s_stx|ent||||; entry point|14346
||mov|7,xr|10,(xs)+||; load argument|14347
||mov|8,wa|3,stxvr||; load old vrblk pointer|14348
||zer|7,xl|||; load zero in case null arg|14349
||beq|7,xr|21,=nulls|6,sstx1|; jump if null argument (reset call)|14350
||jsr|6,gtnvr|||; else get specified vrblk|14351
||ppm|6,sstx2|||; jump if not natural variable|14352
||mov|7,xl|13,vrlbl(xr)||; else load label|14353
||beq|7,xl|21,=stndl|6,sstx2|; jump if label is not defined|14354
||bne|9,(xl)|22,=b_trt|6,sstx1|; jump if not trapped|14355
||mov|7,xl|13,trlbl(xl)||; else load ptr to real label code|14356
;
;      here to set/reset setexit trap
;
|sstx1|mov|3,stxvr|7,xr||; store new vrblk pointer (or null)|14360
||mov|3,r_sxc|7,xl||; store new code ptr (or zero)|14361
||beq|8,wa|21,=nulls|6,exnul|; return null if null result|14362
||mov|7,xr|8,wa||; else copy vrblk pointer|14363
||brn|6,exvnm|||; and return building nmblk|14364
;
;      here if bad argument
;
|sstx2|erb|1,187|26,setexit argument is not label name or null|||14368
;
;      sin
;
|s_sin|ent||||; entry point|14373
||mov|7,xr|10,(xs)+||; get argument|14374
||jsr|6,gtrea|||; convert to real|14375
||err|1,308|26,sin argument not numeric|||14376
||ldr|13,rcval(xr)|||; load accumulator with argument|14377
||sin||||; take sine|14378
||rno|6,exrea|||; if no overflow, return result in ra|14379
||erb|1,323|26,sin argument is out of range|||14380
||ejc|||||14381
;
;      sqrt
;
|s_sqr|ent||||; entry point|14387
||mov|7,xr|10,(xs)+||; get argument|14388
||jsr|6,gtrea|||; convert to real|14389
||err|1,313|26,sqrt argument not numeric|||14390
||ldr|13,rcval(xr)|||; load accumulator with argument|14391
||rlt|6,ssqr1|||; negative number|14392
||sqr||||; take square root|14393
||brn|6,exrea|||; no overflow possible, result in ra|14394
;
;      here if bad argument
;
|ssqr1|erb|1,314|26,sqrt argument negative|||14398
||ejc|||||14399
||ejc|||||14403
;
;      sort
;
|s_srt|ent||||; entry point|14407
||zer|8,wa|||; mark as sort|14408
||jsr|6,sorta|||; call sort routine|14409
||ppm|6,exfal|||; if conversion fails, so shall we|14410
||brn|6,exsid|||; return, setting idval|14411
||ejc|||||14413
;
;      span
;
|s_spn|ent||||; entry point|14417
||mov|8,wb|22,=p_sps||; set pcode for single char arg|14418
||mov|7,xl|22,=p_spn||; set pcode for multi-char arg|14419
||mov|8,wc|22,=p_spd||; set pcode for expression arg|14420
||jsr|6,patst|||; call common routine to build node|14421
||err|1,188|26,span argument is not a string or expression|||14422
||mov|11,-(xs)|7,xr||; stack result|14423
||lcw|7,xr|||; get next code word|14424
||bri|9,(xr)|||; execute it|14425
||ejc|||||14426
;
;      size
;
|s_si_|ent||||; entry point|14430
||jsr|6,gtstg|||; load string argument|14432
||err|1,189|26,size argument is not a string|||14433
;
;      merge with bfblk or scblk ptr in xr.  wa has length.
;
||mti|8,wa|||; load length as integer|14441
||brn|6,exint|||; exit with integer result|14442
||ejc|||||14443
;
;      stoptr
;
|s_stt|ent||||; entry point|14447
||zer|7,xl|||; indicate stoptr case|14448
||jsr|6,trace|||; call trace procedure|14449
||err|1,190|26,stoptr first argument is not appropriate name|||14450
||err|1,191|26,stoptr second argument is not trace type|||14451
||brn|6,exnul|||; return null|14452
||ejc|||||14453
;
;      substr
;
|s_sub|ent||||; entry point|14457
||jsr|6,gtsmi|||; load third argument|14458
||err|1,192|26,substr third argument is not integer|||14459
||ppm|6,exfal|||; jump if negative or too large|14460
||mov|3,sbssv|7,xr||; save third argument|14461
||jsr|6,gtsmi|||; load second argument|14462
||err|1,193|26,substr second argument is not integer|||14463
||ppm|6,exfal|||; jump if out of range|14464
||mov|8,wc|7,xr||; save second argument|14465
||bze|8,wc|6,exfal||; jump if second argument zero|14466
||dcv|8,wc|||; else decrement for ones origin|14467
||jsr|6,gtstg|||; load first argument|14469
||err|1,194|26,substr first argument is not a string|||14470
;
;      merge with bfblk or scblk ptr in xr.  wa has length
;
||mov|8,wb|8,wc||; copy second arg to wb|14478
||mov|8,wc|3,sbssv||; reload third argument|14479
||bnz|8,wc|6,ssub2||; skip if third arg given|14480
||mov|8,wc|8,wa||; else get string length|14481
||bgt|8,wb|8,wc|6,exfal|; fail if improper|14482
||sub|8,wc|8,wb||; reduce by offset to start|14483
;
;      merge
;
|ssub2|mov|7,xl|8,wa||; save string length|14487
||mov|8,wa|8,wc||; set length of substring|14488
||add|8,wc|8,wb||; add 2nd arg to 3rd arg|14489
||bgt|8,wc|7,xl|6,exfal|; jump if improper substring|14490
||mov|7,xl|7,xr||; copy pointer to first arg|14491
||jsr|6,sbstr|||; build substring|14492
||mov|11,-(xs)|7,xr||; stack result|14493
||lcw|7,xr|||; get next code word|14494
||bri|9,(xr)|||; execute it|14495
||ejc|||||14496
;
;      table
;
|s_tbl|ent||||; entry point|14500
||mov|7,xl|10,(xs)+||; get initial lookup value|14501
||ica|7,xs|||; pop second argument|14502
||jsr|6,gtsmi|||; load argument|14503
||err|1,195|26,table argument is not integer|||14504
||err|1,196|26,table argument is out of range|||14505
||bnz|8,wc|6,stbl1||; jump if non-zero|14506
||mov|8,wc|18,=tbnbk||; else supply default value|14507
;
;      merge here with number of headers in wc
;
|stbl1|jsr|6,tmake|||; make table|14511
||brn|6,exsid|||; exit setting idval|14512
||ejc|||||14513
;
;      tan
;
|s_tan|ent||||; entry point|14518
||mov|7,xr|10,(xs)+||; get argument|14519
||jsr|6,gtrea|||; convert to real|14520
||err|1,309|26,tan argument not numeric|||14521
||ldr|13,rcval(xr)|||; load accumulator with argument|14522
||tan||||; take tangent|14523
||rno|6,exrea|||; if no overflow, return result in ra|14524
||erb|1,310|26,tan produced real overflow or argument is out of range|||14525
||ejc|||||14526
;
;      time
;
|s_tim|ent||||; entry point|14531
||jsr|6,systm|||; get timer value|14532
||sbi|3,timsx|||; subtract starting time|14533
||brn|6,exint|||; exit with integer value|14534
||ejc|||||14535
;
;      trace
;
|s_tra|ent||||; entry point|14539
||beq|13,num03(xs)|21,=nulls|6,str02|; jump if first argument is null|14540
||mov|7,xr|10,(xs)+||; load fourth argument|14541
||zer|7,xl|||; tentatively set zero pointer|14542
||beq|7,xr|21,=nulls|6,str01|; jump if 4th argument is null|14543
||jsr|6,gtnvr|||; else point to vrblk|14544
||ppm|6,str03|||; jump if not variable name|14545
||mov|7,xl|7,xr||; else save vrblk in trfnc|14546
;
;      here with vrblk or zero in xl
;
|str01|mov|7,xr|10,(xs)+||; load third argument (tag)|14550
||zer|8,wb|||; set zero as trtyp value for now|14551
||jsr|6,trbld|||; build trblk for trace call|14552
||mov|7,xl|7,xr||; move trblk pointer for trace|14553
||jsr|6,trace|||; call trace procedure|14554
||err|1,198|26,trace first argument is not appropriate name|||14555
||err|1,199|26,trace second argument is not trace type|||14556
||brn|6,exnul|||; return null|14557
;
;      here to call system trace toggle routine
;
|str02|jsr|6,systt|||; call it|14561
||add|7,xs|19,*num04||; pop trace arguments|14562
||brn|6,exnul|||; return|14563
;
;      here for bad fourth argument
;
|str03|erb|1,197|26,trace fourth arg is not function name or null|||14567
||ejc|||||14568
;
;      trim
;
|s_trm|ent||||; entry point|14572
||jsr|6,gtstg|||; load argument as string|14574
||err|1,200|26,trim argument is not a string|||14575
||bze|8,wa|6,exnul||; return null if argument is null|14581
||mov|7,xl|7,xr||; copy string pointer|14582
||ctb|8,wa|2,schar||; get block length|14583
||jsr|6,alloc|||; allocate copy same size|14584
||mov|8,wb|7,xr||; save pointer to copy|14585
||mvw||||; copy old string block to new|14586
||mov|7,xr|8,wb||; restore ptr to new block|14587
||jsr|6,trimr|||; trim blanks (wb is non-zero)|14588
||mov|11,-(xs)|7,xr||; stack result|14589
||lcw|7,xr|||; get next code word|14590
||bri|9,(xr)|||; execute it|14591
||ejc|||||14634
;
;      unload
;
|s_unl|ent||||; entry point|14638
||mov|7,xr|10,(xs)+||; load argument|14639
||jsr|6,gtnvr|||; point to vrblk|14640
||err|1,201|26,unload argument is not natural variable name|||14641
||mov|7,xl|21,=stndf||; get ptr to undefined function|14642
||jsr|6,dffnc|||; undefine named function|14643
||brn|6,exnul|||; return null as result|14644
||ttl|27,s p i t b o l -- utility routines||||14666
;
;      the following section contains utility routines used for
;      various purposes throughout the system. these differ
;      from the procedures in the utility procedures section in
;      they are not in procedure form and they do not return
;      to their callers. they are accessed with a branch type
;      instruction after setting the registers to appropriate
;      parameter values.
;
;      the register values required for each routine are
;      documented at the start of each routine. registers not
;      mentioned may contain any values except that xr,xl
;      can only contain proper collectable pointers.
;
;      some of these routines will tolerate garbage pointers
;      in xl,xr on entry. this is always documented and in
;      each case, the routine clears these garbage values before
;      exiting after completing its task.
;
;      the routines have names consisting of five letters
;      and are assembled in alphabetical order.
||ejc|||||14688
;      arref -- array reference
;
;      (xl)		     may be non-collectable
;      (xr)		     number of subscripts
;      (wb)		     set zero/nonzero for value/name
;			     the value in wb must be collectable
;      stack		     subscripts and array operand
;      brn  arref	     jump to call function
;
;      arref continues by executing the next code word with
;      the result name or value placed on top of the stack.
;      to deal with the problem of accessing subscripts in the
;      order of stacking, xl is used as a subscript pointer
;      working below the stack pointer.
;
|arref|rtn|||||14704
||mov|8,wa|7,xr||; copy number of subscripts|14705
||mov|7,xt|7,xs||; point to stack front|14706
||wtb|7,xr|||; convert to byte offset|14707
||add|7,xt|7,xr||; point to array operand on stack|14708
||ica|7,xt|||; final value for stack popping|14709
||mov|3,arfxs|7,xt||; keep for later|14710
||mov|7,xr|11,-(xt)||; load array operand pointer|14711
||mov|3,r_arf|7,xr||; keep array pointer|14712
||mov|7,xr|7,xt||; save pointer to subscripts|14713
||mov|7,xl|3,r_arf||; point xl to possible vcblk or tbblk|14714
||mov|8,wc|9,(xl)||; load first word|14715
||beq|8,wc|22,=b_art|6,arf01|; jump if arblk|14716
||beq|8,wc|22,=b_vct|6,arf07|; jump if vcblk|14717
||beq|8,wc|22,=b_tbt|6,arf10|; jump if tbblk|14718
||erb|1,235|26,subscripted operand is not table or array|||14719
;
;      here for array (arblk)
;
|arf01|bne|8,wa|13,arndm(xl)|6,arf09|; jump if wrong number of dims|14723
||ldi|4,intv0|||; get initial subscript of zero|14724
||mov|7,xt|7,xr||; point before subscripts|14725
||zer|8,wa|||; initial offset to bounds|14726
||brn|6,arf03|||; jump into loop|14727
;
;      loop to compute subscripts by multiplications
;
|arf02|mli|13,ardm2(xr)|||; multiply total by next dimension|14731
;
;      merge here first time
;
|arf03|mov|7,xr|11,-(xt)||; load next subscript|14735
||sti|3,arfsi|||; save current subscript|14736
||ldi|13,icval(xr)|||; load integer value in case|14737
||beq|9,(xr)|22,=b_icl|6,arf04|; jump if it was an integer|14738
||ejc|||||14739
;
;      arref (continued)
;
;
||jsr|6,gtint|||; convert to integer|14744
||ppm|6,arf12|||; jump if not integer|14745
||ldi|13,icval(xr)|||; if ok, load integer value|14746
;
;      here with integer subscript in (ia)
;
|arf04|mov|7,xr|3,r_arf||; point to array|14750
||add|7,xr|8,wa||; offset to next bounds|14751
||sbi|13,arlbd(xr)|||; subtract low bound to compare|14752
||iov|6,arf13|||; out of range fail if overflow|14753
||ilt|6,arf13|||; out of range fail if too small|14754
||sbi|13,ardim(xr)|||; subtract dimension|14755
||ige|6,arf13|||; out of range fail if too large|14756
||adi|13,ardim(xr)|||; else restore subscript offset|14757
||adi|3,arfsi|||; add to current total|14758
||add|8,wa|19,*ardms||; point to next bounds|14759
||bne|7,xt|7,xs|6,arf02|; loop back if more to go|14760
;
;      here with integer subscript computed
;
||mfi|8,wa|||; get as one word integer|14764
||wtb|8,wa|||; convert to offset|14765
||mov|7,xl|3,r_arf||; point to arblk|14766
||add|8,wa|13,arofs(xl)||; add offset past bounds|14767
||ica|8,wa|||; adjust for arpro field|14768
||bnz|8,wb|6,arf08||; exit with name if name call|14769
;
;      merge here to get value for value call
;
|arf05|jsr|6,acess|||; get value|14773
||ppm|6,arf13|||; fail if acess fails|14774
;
;      return value
;
|arf06|mov|7,xs|3,arfxs||; pop stack entries|14778
||zer|3,r_arf|||; finished with array pointer|14779
||mov|11,-(xs)|7,xr||; stack result|14780
||lcw|7,xr|||; get next code word|14781
||bri|9,(xr)|||; execute it|14782
||ejc|||||14783
;
;      arref (continued)
;
;      here for vector
;
|arf07|bne|8,wa|18,=num01|6,arf09|; error if more than 1 subscript|14789
||mov|7,xr|9,(xs)||; else load subscript|14790
||jsr|6,gtint|||; convert to integer|14791
||ppm|6,arf12|||; error if not integer|14792
||ldi|13,icval(xr)|||; else load integer value|14793
||sbi|4,intv1|||; subtract for ones offset|14794
||mfi|8,wa|6,arf13||; get subscript as one word|14795
||add|8,wa|18,=vcvls||; add offset for standard fields|14796
||wtb|8,wa|||; convert offset to bytes|14797
||bge|8,wa|13,vclen(xl)|6,arf13|; fail if out of range subscript|14798
||bze|8,wb|6,arf05||; back to get value if value call|14799
;
;      return name
;
|arf08|mov|7,xs|3,arfxs||; pop stack entries|14803
||zer|3,r_arf|||; finished with array pointer|14804
||brn|6,exnam|||; else exit with name|14805
;
;      here if subscript count is wrong
;
|arf09|erb|1,236|26,array referenced with wrong number of subscripts|||14809
;
;      table
;
|arf10|bne|8,wa|18,=num01|6,arf11|; error if more than 1 subscript|14813
||mov|7,xr|9,(xs)||; else load subscript|14814
||jsr|6,tfind|||; call table search routine|14815
||ppm|6,arf13|||; fail if failed|14816
||bnz|8,wb|6,arf08||; exit with name if name call|14817
||brn|6,arf06|||; else exit with value|14818
;
;      here for bad table reference
;
|arf11|erb|1,237|26,table referenced with more than one subscript|||14822
;
;      here for bad subscript
;
|arf12|erb|1,238|26,array subscript is not integer|||14826
;
;      here to signal failure
;
|arf13|zer|3,r_arf|||; finished with array pointer|14830
||brn|6,exfal|||; fail|14831
||ejc|||||14832
;
;      cfunc -- call a function
;
;      cfunc is used to call a snobol level function. it is
;      used by the apply function (s_app), the function
;      trace routine (trxeq) and the main function call entry
;      (o_fnc, o_fns). in the latter cases, cfunc is used only
;      if the number of arguments is incorrect.
;
;      (xl)		     pointer to function block
;      (wa)		     actual number of arguments
;      (xs)		     points to stacked arguments
;      brn  cfunc	     jump to call function
;
;      cfunc continues by executing the function
;
|cfunc|rtn|||||14849
||blt|8,wa|13,fargs(xl)|6,cfnc1|; jump if too few arguments|14850
||beq|8,wa|13,fargs(xl)|6,cfnc3|; jump if correct number of args|14851
;
;      here if too many arguments supplied, pop them off
;
||mov|8,wb|8,wa||; copy actual number|14855
||sub|8,wb|13,fargs(xl)||; get number of extra args|14856
||wtb|8,wb|||; convert to bytes|14857
||add|7,xs|8,wb||; pop off unwanted arguments|14858
||brn|6,cfnc3|||; jump to go off to function|14859
;
;      here if too few arguments
;
|cfnc1|mov|8,wb|13,fargs(xl)||; load required number of arguments|14863
||beq|8,wb|18,=nini9|6,cfnc3|; jump if case of var num of args|14864
||sub|8,wb|8,wa||; calculate number missing|14865
||lct|8,wb|8,wb||; set counter to control loop|14866
;
;      loop to supply extra null arguments
;
|cfnc2|mov|11,-(xs)|21,=nulls||; stack a null argument|14870
||bct|8,wb|6,cfnc2||; loop till proper number stacked|14871
;
;      merge here to jump to function
;
|cfnc3|bri|9,(xl)|||; jump through fcode field|14875
||ejc|||||14876
;
;      exfal -- exit signalling snobol failure
;
;      (xl,xr)		     may be non-collectable
;      brn  exfal	     jump to fail
;
;      exfal continues by executing the appropriate fail goto
;
|exfal|rtn|||||14885
||mov|7,xs|3,flptr||; pop stack|14886
||mov|7,xr|9,(xs)||; load failure offset|14887
||add|7,xr|3,r_cod||; point to failure code location|14888
||lcp|7,xr|||; set code pointer|14889
||lcw|7,xr|||; load next code word|14890
||mov|7,xl|9,(xr)||; load entry address|14891
||bri|7,xl|||; jump to execute next code word|14892
||ejc|||||14893
;
;      exint -- exit with integer result
;
;      (xl,xr)		     may be non-collectable
;      (ia)		     integer value
;      brn  exint	     jump to exit with integer
;
;      exint continues by executing the next code word
;      which it does by falling through to exixr
;
|exint|rtn|||||14904
||zer|7,xl|||; clear dud value|14905
||jsr|6,icbld|||; build icblk|14906
||ejc|||||14907
;      exixr -- exit with result in (xr)
;
;      (xr)		     result
;      (xl)		     may be non-collectable
;      brn  exixr	     jump to exit with result in (xr)
;
;      exixr continues by executing the next code word
;      which it does by falling through to exits.
|exixr|rtn|||||14916
;
||mov|11,-(xs)|7,xr||; stack result|14918
;
;
;      exits -- exit with result if any stacked
;
;      (xr,xl)		     may be non-collectable
;
;      brn  exits	     enter exits routine
;
|exits|rtn|||||14927
||lcw|7,xr|||; load next code word|14928
||mov|7,xl|9,(xr)||; load entry address|14929
||bri|7,xl|||; jump to execute next code word|14930
||ejc|||||14931
;
;      exnam -- exit with name in (xl,wa)
;
;      (xl)		     name base
;      (wa)		     name offset
;      (xr)		     may be non-collectable
;      brn  exnam	     jump to exit with name in (xl,wa)
;
;      exnam continues by executing the next code word
;
|exnam|rtn|||||14942
||mov|11,-(xs)|7,xl||; stack name base|14943
||mov|11,-(xs)|8,wa||; stack name offset|14944
||lcw|7,xr|||; load next code word|14945
||bri|9,(xr)|||; execute it|14946
||ejc|||||14947
;
;      exnul -- exit with null result
;
;      (xl,xr)		     may be non-collectable
;      brn  exnul	     jump to exit with null value
;
;      exnul continues by executing the next code word
;
|exnul|rtn|||||14956
||mov|11,-(xs)|21,=nulls||; stack null value|14957
||lcw|7,xr|||; load next code word|14958
||mov|7,xl|9,(xr)||; load entry address|14959
||bri|7,xl|||; jump to execute next code word|14960
||ejc|||||14961
;
;      exrea -- exit with real result
;
;      (xl,xr)		     may be non-collectable
;      (ra)		     real value
;      brn  exrea	     jump to exit with real value
;
;      exrea continues by executing the next code word
;
|exrea|rtn|||||14973
||zer|7,xl|||; clear dud value|14974
||jsr|6,rcbld|||; build rcblk|14975
||brn|6,exixr|||; jump to exit with result in xr|14976
||ejc|||||14978
;
;      exsid -- exit setting id field
;
;      exsid is used to exit after building any of the following
;      blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.
;
;      (xr)		     ptr to block with idval field
;      (xl)		     may be non-collectable
;      brn  exsid	     jump to exit after setting id field
;
;      exsid continues by executing the next code word
;
|exsid|rtn|||||14991
||mov|8,wa|3,curid||; load current id value|14992
||bne|8,wa|3,mxint|6,exsi1|; jump if no overflow|14993
||zer|8,wa|||; else reset for wraparound|14994
;
;      here with old idval in wa
;
|exsi1|icv|8,wa|||; bump id value|14998
||mov|3,curid|8,wa||; store for next time|14999
||mov|13,idval(xr)|8,wa||; store id value|15000
||brn|6,exixr|||; exit with result in (xr)|15001
||ejc|||||15002
;
;      exvnm -- exit with name of variable
;
;      exvnm exits after stacking a value which is a nmblk
;      referencing the name of a given natural variable.
;
;      (xr)		     vrblk pointer
;      (xl)		     may be non-collectable
;      brn  exvnm	     exit with vrblk pointer in xr
;
|exvnm|rtn|||||15013
||mov|7,xl|7,xr||; copy name base pointer|15014
||mov|8,wa|19,*nmsi_||; set size of nmblk|15015
||jsr|6,alloc|||; allocate nmblk|15016
||mov|9,(xr)|22,=b_nml||; store type word|15017
||mov|13,nmbas(xr)|7,xl||; store name base|15018
||mov|13,nmofs(xr)|19,*vrval||; store name offset|15019
||brn|6,exixr|||; exit with result in xr|15020
||ejc|||||15021
;
;      flpop -- fail and pop in pattern matching
;
;      flpop pops the node and cursor on the stack and then
;      drops through into failp to cause pattern failure
;
;      (xl,xr)		     may be non-collectable
;      brn  flpop	     jump to fail and pop stack
;
|flpop|rtn|||||15031
||add|7,xs|19,*num02||; pop two entries off stack|15032
||ejc|||||15033
;
;      failp -- failure in matching pattern node
;
;      failp is used after failing to match a pattern node.
;      see pattern match routines for details of use.
;
;      (xl,xr)		     may be non-collectable
;      brn  failp	     signal failure to match
;
;      failp continues by matching an alternative from the stack
;
|failp|rtn|||||15045
||mov|7,xr|10,(xs)+||; load alternative node pointer|15046
||mov|8,wb|10,(xs)+||; restore old cursor|15047
||mov|7,xl|9,(xr)||; load pcode entry pointer|15048
||bri|7,xl|||; jump to execute code for node|15049
||ejc|||||15050
;
;      indir -- compute indirect reference
;
;      (wb)		     nonzero/zero for by name/value
;      brn  indir	     jump to get indirect ref on stack
;
;      indir continues by executing the next code word
;
|indir|rtn|||||15059
||mov|7,xr|10,(xs)+||; load argument|15060
||beq|9,(xr)|22,=b_nml|6,indr2|; jump if a name|15061
||jsr|6,gtnvr|||; else convert to variable|15062
||err|1,239|26,indirection operand is not name|||15063
||bze|8,wb|6,indr1||; skip if by value|15064
||mov|11,-(xs)|7,xr||; else stack vrblk ptr|15065
||mov|11,-(xs)|19,*vrval||; stack name offset|15066
||lcw|7,xr|||; load next code word|15067
||mov|7,xl|9,(xr)||; load entry address|15068
||bri|7,xl|||; jump to execute next code word|15069
;
;      here to get value of natural variable
;
|indr1|bri|9,(xr)|||; jump through vrget field of vrblk|15073
;
;      here if operand is a name
;
|indr2|mov|7,xl|13,nmbas(xr)||; load name base|15077
||mov|8,wa|13,nmofs(xr)||; load name offset|15078
||bnz|8,wb|6,exnam||; exit if called by name|15079
||jsr|6,acess|||; else get value first|15080
||ppm|6,exfal|||; fail if access fails|15081
||brn|6,exixr|||; else return with value in xr|15082
||ejc|||||15083
;
;      match -- initiate pattern match
;
;      (wb)		     match type code
;      brn  match	     jump to initiate pattern match
;
;      match continues by executing the pattern match. see
;      pattern match routines (p_xxx) for full details.
;
|match|rtn|||||15093
||mov|7,xr|10,(xs)+||; load pattern operand|15094
||jsr|6,gtpat|||; convert to pattern|15095
||err|1,240|26,pattern match right operand is not pattern|||15096
||mov|7,xl|7,xr||; if ok, save pattern pointer|15097
||bnz|8,wb|6,mtch1||; jump if not match by name|15098
||mov|8,wa|9,(xs)||; else load name offset|15099
||mov|11,-(xs)|7,xl||; save pattern pointer|15100
||mov|7,xl|13,num02(xs)||; load name base|15101
||jsr|6,acess|||; access subject value|15102
||ppm|6,exfal|||; fail if access fails|15103
||mov|7,xl|9,(xs)||; restore pattern pointer|15104
||mov|9,(xs)|7,xr||; stack subject string val for merge|15105
||zer|8,wb|||; restore type code|15106
;
;      merge here with subject value on stack
;
|mtch1|jsr|6,gtstg|||; convert subject to string|15111
||err|1,241|26,pattern match left operand is not a string|||15112
||mov|11,-(xs)|8,wb||; stack match type code|15113
||mov|3,r_pms|7,xr||; if ok, store subject string pointer|15121
||mov|3,pmssl|8,wa||; and length|15122
||zer|11,-(xs)|||; stack initial cursor (zero)|15123
||zer|8,wb|||; set initial cursor|15124
||mov|3,pmhbs|7,xs||; set history stack base ptr|15125
||zer|3,pmdfl|||; reset pattern assignment flag|15126
||mov|7,xr|7,xl||; set initial node pointer|15127
||bnz|3,kvanc|6,mtch2||; jump if anchored|15128
;
;      here for unanchored
;
||mov|11,-(xs)|7,xr||; stack initial node pointer|15132
||mov|11,-(xs)|21,=nduna||; stack pointer to anchor move node|15133
||bri|9,(xr)|||; start match of first node|15134
;
;      here in anchored mode
;
|mtch2|zer|11,-(xs)|||; dummy cursor value|15138
||mov|11,-(xs)|21,=ndabo||; stack pointer to abort node|15139
||bri|9,(xr)|||; start match of first node|15140
||ejc|||||15141
;
;      retrn -- return from function
;
;      (wa)		     string pointer for return type
;      brn  retrn	     jump to return from (snobol) func
;
;      retrn continues by executing the code at the return point
;      the stack is cleaned of any garbage left by other
;      routines which may have altered flptr since function
;      entry by using flprt, reserved for use only by
;      function call and return.
;
|retrn|rtn|||||15154
||bnz|3,kvfnc|6,rtn01||; jump if not level zero|15155
||erb|1,242|26,function return from level zero|||15156
;
;      here if not level zero return
;
|rtn01|mov|7,xs|3,flprt||; pop stack|15160
||ica|7,xs|||; remove failure offset|15161
||mov|7,xr|10,(xs)+||; pop pfblk pointer|15162
||mov|3,flptr|10,(xs)+||; pop failure pointer|15163
||mov|3,flprt|10,(xs)+||; pop old flprt|15164
||mov|8,wb|10,(xs)+||; pop code pointer offset|15165
||mov|8,wc|10,(xs)+||; pop old code block pointer|15166
||add|8,wb|8,wc||; make old code pointer absolute|15167
||lcp|8,wb|||; restore old code pointer|15168
||mov|3,r_cod|8,wc||; restore old code block pointer|15169
||dcv|3,kvfnc|||; decrement function level|15170
||mov|8,wb|3,kvtra||; load trace|15171
||add|8,wb|3,kvftr||; add ftrace|15172
||bze|8,wb|6,rtn06||; jump if no tracing possible|15173
;
;      here if there may be a trace
;
||mov|11,-(xs)|8,wa||; save function return type|15177
||mov|11,-(xs)|7,xr||; save pfblk pointer|15178
||mov|3,kvrtn|8,wa||; set rtntype for trace function|15179
||mov|7,xl|3,r_fnc||; load fnclevel trblk ptr (if any)|15180
||jsr|6,ktrex|||; execute possible fnclevel trace|15181
||mov|7,xl|13,pfvbl(xr)||; load vrblk ptr (sgd13)|15182
||bze|3,kvtra|6,rtn02||; jump if trace is off|15183
||mov|7,xr|13,pfrtr(xr)||; else load return trace trblk ptr|15184
||bze|7,xr|6,rtn02||; jump if not return traced|15185
||dcv|3,kvtra|||; else decrement trace count|15186
||bze|13,trfnc(xr)|6,rtn03||; jump if print trace|15187
||mov|8,wa|19,*vrval||; else set name offset|15188
||mov|3,kvrtn|13,num01(xs)||; make sure rtntype is set right|15189
||jsr|6,trxeq|||; execute full trace|15190
||ejc|||||15191
;
;      retrn (continued)
;
;      here to test for ftrace
;
|rtn02|bze|3,kvftr|6,rtn05||; jump if ftrace is off|15197
||dcv|3,kvftr|||; else decrement ftrace|15198
;
;      here for print trace of function return
;
|rtn03|jsr|6,prtsn|||; print statement number|15202
||mov|7,xr|13,num01(xs)||; load return type|15203
||jsr|6,prtst|||; print it|15204
||mov|8,wa|18,=ch_bl||; load blank|15205
||jsr|6,prtch|||; print it|15206
||mov|7,xl|12,0(xs)||; load pfblk ptr|15207
||mov|7,xl|13,pfvbl(xl)||; load function vrblk ptr|15208
||mov|8,wa|19,*vrval||; set vrblk name offset|15209
||bne|7,xr|21,=scfrt|6,rtn04|; jump if not freturn case|15210
;
;      for freturn, just print function name
;
||jsr|6,prtnm|||; print name|15214
||jsr|6,prtnl|||; terminate print line|15215
||brn|6,rtn05|||; merge|15216
;
;      here for return or nreturn, print function name = value
;
|rtn04|jsr|6,prtnv|||; print name = value|15220
;
;      here after completing trace
;
|rtn05|mov|7,xr|10,(xs)+||; pop pfblk pointer|15224
||mov|8,wa|10,(xs)+||; pop return type string|15225
;
;      merge here if no trace required
;
|rtn06|mov|3,kvrtn|8,wa||; set rtntype keyword|15229
||mov|7,xl|13,pfvbl(xr)||; load pointer to fn vrblk|15230
||ejc|||||15231
;      retrn (continued)
;
;      get value of function
;
|rtn07|mov|3,rtnbp|7,xl||; save block pointer|15236
||mov|7,xl|13,vrval(xl)||; load value|15237
||beq|9,(xl)|22,=b_trt|6,rtn07|; loop back if trapped|15238
||mov|3,rtnfv|7,xl||; else save function result value|15239
||mov|3,rtnsv|10,(xs)+||; save original function value|15240
||mov|7,xl|10,(xs)+||; pop saved pointer|15244
||bze|7,xl|6,rtn7c||; no action if none|15245
||bze|3,kvpfl|6,rtn7c||; jump if no profiling|15246
||jsr|6,prflu|||; else profile last func stmt|15247
||beq|3,kvpfl|18,=num02|6,rtn7a|; branch on value of profile keywd|15248
;
;      here if &profile = 1. start time must be frigged to
;      appear earlier than it actually is, by amount used before
;      the call.
;
||ldi|3,pfstm|||; load current time|15254
||sbi|13,icval(xl)|||; frig by subtracting saved amount|15255
||brn|6,rtn7b|||; and merge|15256
;
;      here if &profile = 2
;
|rtn7a|ldi|13,icval(xl)|||; load saved time|15260
;
;      both profile types merge here
;
|rtn7b|sti|3,pfstm|||; store back correct start time|15264
;
;      merge here if no profiling
;
|rtn7c|mov|8,wb|13,fargs(xr)||; get number of args|15268
||add|8,wb|13,pfnlo(xr)||; add number of locals|15270
||bze|8,wb|6,rtn10||; jump if no args/locals|15271
||lct|8,wb|8,wb||; else set loop counter|15272
||add|7,xr|13,pflen(xr)||; and point to end of pfblk|15273
;
;      loop to restore functions and locals
;
|rtn08|mov|7,xl|11,-(xr)||; load next vrblk pointer|15277
;
;      loop to find value block
;
|rtn09|mov|8,wa|7,xl||; save block pointer|15281
||mov|7,xl|13,vrval(xl)||; load pointer to next value|15282
||beq|9,(xl)|22,=b_trt|6,rtn09|; loop back if trapped|15283
||mov|7,xl|8,wa||; else restore last block pointer|15284
||mov|13,vrval(xl)|10,(xs)+||; restore old variable value|15285
||bct|8,wb|6,rtn08||; loop till all processed|15286
;
;      now restore function value and exit
;
|rtn10|mov|7,xl|3,rtnbp||; restore ptr to last function block|15290
||mov|13,vrval(xl)|3,rtnsv||; restore old function value|15291
||mov|7,xr|3,rtnfv||; reload function result|15292
||mov|7,xl|3,r_cod||; point to new code block|15293
||mov|3,kvlst|3,kvstn||; set lastno from stno|15294
||mov|3,kvstn|13,cdstm(xl)||; reset proper stno value|15295
||mov|3,kvlln|3,kvlin||; set lastline from line|15297
||mov|3,kvlin|13,cdsln(xl)||; reset proper line value|15298
||mov|8,wa|3,kvrtn||; load return type|15300
||beq|8,wa|21,=scrtn|6,exixr|; exit with result in xr if return|15301
||beq|8,wa|21,=scfrt|6,exfal|; fail if freturn|15302
||ejc|||||15303
;
;      retrn (continued)
;
;      here for nreturn
;
||beq|9,(xr)|22,=b_nml|6,rtn11|; jump if is a name|15309
||jsr|6,gtnvr|||; else try convert to variable name|15310
||err|1,243|26,function result in nreturn is not name|||15311
||mov|7,xl|7,xr||; if ok, copy vrblk (name base) ptr|15312
||mov|8,wa|19,*vrval||; set name offset|15313
||brn|6,rtn12|||; and merge|15314
;
;      here if returned result is a name
;
|rtn11|mov|7,xl|13,nmbas(xr)||; load name base|15318
||mov|8,wa|13,nmofs(xr)||; load name offset|15319
;
;      merge here with returned name in (xl,wa)
;
|rtn12|mov|7,xr|7,xl||; preserve xl|15323
||lcw|8,wb|||; load next word|15324
||mov|7,xl|7,xr||; restore xl|15325
||beq|8,wb|21,=ofne_|6,exnam|; exit if called by name|15326
||mov|11,-(xs)|8,wb||; else save code word|15327
||jsr|6,acess|||; get value|15328
||ppm|6,exfal|||; fail if access fails|15329
||mov|7,xl|7,xr||; if ok, copy result|15330
||mov|7,xr|9,(xs)||; reload next code word|15331
||mov|9,(xs)|7,xl||; store result on stack|15332
||mov|7,xl|9,(xr)||; load routine address|15333
||bri|7,xl|||; jump to execute next code word|15334
||ejc|||||15335
;
;      stcov -- signal statement counter overflow
;
;      brn  stcov	     jump to signal statement count oflo
;
;      permit up to 10 more statements to be obeyed so that
;      setexit trap can regain control.
;      stcov continues by issuing the error message
;
|stcov|rtn|||||15345
||icv|3,errft|||; fatal error|15346
||ldi|4,intvt|||; get 10|15347
||adi|3,kvstl|||; add to former limit|15348
||sti|3,kvstl|||; store as new stlimit|15349
||ldi|4,intvt|||; get 10|15350
||sti|3,kvstc|||; set as new count|15351
||jsr|6,stgcc|||; recompute countdown counters|15352
||erb|1,244|26,statement count exceeds value of stlimit keyword|||15353
||ejc|||||15354
;
;      stmgo -- start execution of new statement
;
;      (xr)		     pointer to cdblk for new statement
;      brn  stmgo	     jump to execute new statement
;
;      stmgo continues by executing the next statement
;
|stmgo|rtn|||||15363
||mov|3,r_cod|7,xr||; set new code block pointer|15364
||dcv|3,stmct|||; see if time to check something|15365
||bze|3,stmct|6,stgo2||; jump if so|15366
||mov|3,kvlst|3,kvstn||; set lastno|15367
||mov|3,kvstn|13,cdstm(xr)||; set stno|15368
||mov|3,kvlln|3,kvlin||; set lastline|15370
||mov|3,kvlin|13,cdsln(xr)||; set line|15371
||add|7,xr|19,*cdcod||; point to first code word|15373
||lcp|7,xr|||; set code pointer|15374
;
;      here to execute first code word of statement
;
|stgo1|lcw|7,xr|||; load next code word|15378
||zer|7,xl|||; clear garbage xl|15379
||bri|9,(xr)|||; execute it|15380
;
;      check profiling, polling, stlimit, statement tracing
;
|stgo2|bze|3,kvpfl|6,stgo3||; skip if no profiling|15384
||jsr|6,prflu|||; else profile the statement in kvstn|15385
;
;      here when finished with profiling
;
|stgo3|mov|3,kvlst|3,kvstn||; set lastno|15389
||mov|3,kvstn|13,cdstm(xr)||; set stno|15390
||mov|3,kvlln|3,kvlin||; set lastline|15392
||mov|3,kvlin|13,cdsln(xr)||; set line|15393
||add|7,xr|19,*cdcod||; point to first code word|15395
||lcp|7,xr|||; set code pointer|15396
;
;      here to check for polling
;
||mov|11,-(xs)|3,stmcs||; save present count start on stack|15401
||dcv|3,polct|||; poll interval within stmct|15402
||bnz|3,polct|6,stgo4||; jump if not poll time yet|15403
||zer|8,wa|||; =0 for poll|15404
||mov|8,wb|3,kvstn||; statement number|15405
||mov|7,xl|7,xr||; make collectable|15406
||jsr|6,syspl|||; allow interactive access|15407
||err|1,320|26,user interrupt|||15408
||ppm||||; single step|15409
||ppm||||; expression evaluation|15410
||mov|7,xr|7,xl||; restore code block pointer|15411
||mov|3,polcs|8,wa||; poll interval start value|15412
||jsr|6,stgcc|||; recompute counter values|15413
;
;      check statement limit
;
|stgo4|ldi|3,kvstc|||; get stmt count|15418
||ilt|6,stgo5|||; omit counting if negative|15419
||mti|10,(xs)+|||; reload start value of counter|15420
||ngi||||; negate|15421
||adi|3,kvstc|||; stmt count minus counter|15422
||sti|3,kvstc|||; replace it|15423
||ile|6,stcov|||; fail if stlimit reached|15424
||bze|3,r_stc|6,stgo5||; jump if no statement trace|15425
||zer|7,xr|||; clear garbage value in xr|15426
||mov|7,xl|3,r_stc||; load pointer to stcount trblk|15427
||jsr|6,ktrex|||; execute keyword trace|15428
;
;      reset stmgo counter
;
|stgo5|mov|3,stmct|3,stmcs||; reset counter|15432
||brn|6,stgo1|||; fetch next code word|15433
||ejc|||||15434
;
;      stopr -- terminate run
;
;      (xr)		     points to ending message
;      brn stopr	     jump to terminate run
;
;      terminate run and print statistics.  on entry xr points
;      to ending message or is zero if message	printed already.
;
|stopr|rtn|||||15444
||bze|7,xr|6,stpra||; skip if sysax already called|15446
||jsr|6,sysax|||; call after execution proc|15447
|stpra|add|3,dname|3,rsmem||; use the reserve memory|15448
||bne|7,xr|21,=endms|6,stpr0|; skip if not normal end message|15452
||bnz|3,exsts|6,stpr3||; skip if exec stats suppressed|15453
||zer|3,erich|||; clear errors to int.ch. flag|15454
;
;      look to see if an ending message is supplied
;
|stpr0|jsr|6,prtpg|||; eject printer|15458
||bze|7,xr|6,stpr1||; skip if no message|15459
||jsr|6,prtst|||; print message|15460
;
;      merge here if no message to print
;
|stpr1|jsr|6,prtis|||; print blank line|15464
||bnz|3,gbcfl|6,stpr5||; if in garbage collection, skip|15466
||mov|7,xr|21,=stpm7||; point to message /in file xxx/|15467
||jsr|6,prtst|||; print it|15468
||mov|3,profs|18,=prtmf||; set column offset|15469
||mov|8,wc|3,kvstn||; get statement number|15470
||jsr|6,filnm|||; get file name|15471
||mov|7,xr|7,xl||; prepare to print|15472
||jsr|6,prtst|||; print file name|15473
||jsr|6,prtis|||; print to interactive channel|15474
||mov|7,xr|3,r_cod||; get code pointer|15481
||mti|13,cdsln(xr)|||; get source line number|15482
||mov|7,xr|21,=stpm6||; point to message /in line xxx/|15483
||jsr|6,prtmx|||; print it|15484
|stpr5|mti|3,kvstn|||; get statement number|15486
||mov|7,xr|21,=stpm1||; point to message /in statement xxx/|15487
||jsr|6,prtmx|||; print it|15488
||jsr|6,systm|||; get current time|15489
||sbi|3,timsx|||; minus start time = elapsed exec tim|15490
||sti|3,stpti|||; save for later|15491
||mov|7,xr|21,=stpm3||; point to msg /execution time msec /|15492
||jsr|6,prtmx|||; print it|15493
||ldi|3,kvstl|||; get statement limit|15494
||ilt|6,stpr2|||; skip if negative|15495
||sbi|3,kvstc|||; minus counter = course count|15496
||sti|3,stpsi|||; save|15497
||mov|8,wa|3,stmcs||; refine with counter start value|15498
||sub|8,wa|3,stmct||; minus current counter|15499
||mti|8,wa|||; convert to integer|15500
||adi|3,stpsi|||; add in course count|15501
||sti|3,stpsi|||; save|15502
||mov|7,xr|21,=stpm2||; point to message /stmts executed/|15503
||jsr|6,prtmx|||; print it|15504
||ldi|3,stpti|||; reload elapsed time|15507
||mli|4,intth|||; *1000 (microsecs)|15508
||iov|6,stpr2|||; jump if we cannot compute|15509
||dvi|3,stpsi|||; divide by statement count|15510
||iov|6,stpr2|||; jump if overflow|15511
||mov|7,xr|21,=stpm4||; point to msg (mcsec per statement /|15512
||jsr|6,prtmx|||; print it|15513
||ejc|||||15515
;
;      stopr (continued)
;
;      merge to skip message (overflow or negative stlimit)
;
|stpr2|mti|3,gbcnt|||; load count of collections|15521
||mov|7,xr|21,=stpm5||; point to message /regenerations /|15522
||jsr|6,prtmx|||; print it|15523
||jsr|6,prtmm|||; print memory usage|15524
||jsr|6,prtis|||; one more blank for luck|15525
;
;      check if dump requested
;
|stpr3|jsr|6,prflr|||; print profile if wanted|15532
;
||mov|7,xr|3,kvdmp||; load dump keyword|15534
||jsr|6,dumpr|||; execute dump if requested|15536
||mov|7,xl|3,r_fcb||; get fcblk chain head|15537
||mov|8,wa|3,kvabe||; load abend value|15538
||mov|8,wb|3,kvcod||; load code value|15539
||jsr|6,sysej|||; exit to system|15540
;
;      here after sysea call and suppressing error msg print
;
|stpr4|rtn|||||15545
||add|3,dname|3,rsmem||; use the reserve memory|15546
||bze|3,exsts|6,stpr1||; if execution stats requested|15547
||brn|6,stpr3|||; check if dump or profile needed|15548
||ejc|||||15551
;
;      succp -- signal successful match of a pattern node
;
;      see pattern match routines for details
;
;      (xr)		     current node
;      (wb)		     current cursor
;      (xl)		     may be non-collectable
;      brn  succp	     signal successful pattern match
;
;      succp continues by matching the successor node
;
|succp|rtn|||||15564
||mov|7,xr|13,pthen(xr)||; load successor node|15565
||mov|7,xl|9,(xr)||; load node code entry address|15566
||bri|7,xl|||; jump to match successor node|15567
||ejc|||||15568
;
;      sysab -- print /abnormal end/ and terminate
;
|sysab|rtn|||||15572
||mov|7,xr|21,=endab||; point to message|15573
||mov|3,kvabe|18,=num01||; set abend flag|15574
||jsr|6,prtnl|||; skip to new line|15575
||brn|6,stopr|||; jump to pack up|15576
||ejc|||||15577
;
;      systu -- print /time up/ and terminate
;
|systu|rtn|||||15581
||mov|7,xr|21,=endtu||; point to message|15582
||mov|8,wa|4,strtu||; get chars /tu/|15583
||mov|3,kvcod|8,wa||; put in kvcod|15584
||mov|8,wa|3,timup||; check state of timeup switch|15585
||mnz|3,timup|||; set switch|15586
||bnz|8,wa|6,stopr||; stop run if already set|15587
||erb|1,245|26,translation/execution time expired|||15588
||ttl|27,s p i t b o l -- utility procedures||||15589
;
;      the following section contains procedures which are
;      used for various purposes throughout the system.
;
;      each procedure is preceded by a description of the
;      calling sequence. usually the arguments are in registers
;      but arguments can also occur on the stack and as
;      parameters assembled after the jsr instruction.
;
;      the following considerations apply to these descriptions.
;
;      1)   the stack pointer (xs) is not changed unless the
;	    change is explicitly documented in the call.
;
;      2)   registers whose entry values are not mentioned
;	    may contain any value except that xl,xr may only
;	    contain proper (collectable) pointer values.
;	    this condition on means that the called routine
;	    may if it chooses preserve xl,xr by stacking.
;
;      3)   registers not mentioned on exit contain the same
;	    values as they did on entry except that values in
;	    xr,xl may have been relocated by the collector.
;
;      4)   registers which are destroyed on exit may contain
;	    any value except that values in xl,xr are proper
;	    (collectable) pointers.
;
;      5)   the code pointer register points to the current
;	    code location on entry and is unchanged on exit.
;
;      in the above description, a collectable pointer is one
;      which either points outside the dynamic region or
;      points to the start of a block in the dynamic region.
;
;      in those cases where the calling sequence contains
;      parameters which are used as alternate return points,
;      these parameters may be replaced by error codes
;      assembled with the err instruction. this will result
;      in the posting of the error if the return is taken.
;
;      the procedures all have names consisting of five letters
;      and are in alphabetical order by their names.
||ejc|||||15633
;
;      acess - access variable value with trace/input checks
;
;      acess loads the value of a variable. trace and input
;      associations are tested for and executed as required.
;      acess also handles the special cases of pseudo-variables.
;
;      (xl)		     variable name base
;      (wa)		     variable name offset
;      jsr  acess	     call to access value
;      ppm  loc		     transfer loc if access failure
;      (xr)		     variable value
;      (wa,wb,wc)	     destroyed
;      (xl,ra)		     destroyed
;
;      failure can occur if an input association causes an end
;      of file condition or if the evaluation of an expression
;      associated with an expression variable fails.
;
|acess|prc|25,r|1,1||; entry point (recursive)|15653
||mov|7,xr|7,xl||; copy name base|15654
||add|7,xr|8,wa||; point to variable location|15655
||mov|7,xr|9,(xr)||; load variable value|15656
;
;      loop here to check for successive trblks
;
|acs02|bne|9,(xr)|22,=b_trt|6,acs18|; jump if not trapped|15660
;
;      here if trapped
;
||beq|7,xr|21,=trbkv|6,acs12|; jump if keyword variable|15664
||bne|7,xr|21,=trbev|6,acs05|; jump if not expression variable|15665
;
;      here for expression variable, evaluate variable
;
||mov|7,xr|13,evexp(xl)||; load expression pointer|15669
||zer|8,wb|||; evaluate by value|15670
||jsr|6,evalx|||; evaluate expression|15671
||ppm|6,acs04|||; jump if evaluation failure|15672
||brn|6,acs02|||; check value for more trblks|15673
||ejc|||||15674
;
;      acess (continued)
;
;      here on reading end of file
;
|acs03|add|7,xs|19,*num03||; pop trblk ptr, name base and offset|15680
||mov|3,dnamp|7,xr||; pop unused scblk|15681
;
;      merge here when evaluation of expression fails
;
|acs04|exi|1,1|||; take alternate (failure) return|15685
;
;      here if not keyword or expression variable
;
|acs05|mov|8,wb|13,trtyp(xr)||; load trap type code|15689
||bnz|8,wb|6,acs10||; jump if not input association|15690
||bze|3,kvinp|6,acs09||; ignore input assoc if input is off|15691
;
;      here for input association
;
||mov|11,-(xs)|7,xl||; stack name base|15695
||mov|11,-(xs)|8,wa||; stack name offset|15696
||mov|11,-(xs)|7,xr||; stack trblk pointer|15697
||mov|3,actrm|3,kvtrm||; temp to hold trim keyword|15698
||mov|7,xl|13,trfpt(xr)||; get file ctrl blk ptr or zero|15699
||bnz|7,xl|6,acs06||; jump if not standard input file|15700
||beq|13,trter(xr)|21,=v_ter|6,acs21|; jump if terminal|15701
;
;      here to read from standard input file
;
||mov|8,wa|3,cswin||; length for read buffer|15705
||jsr|6,alocs|||; build string of appropriate length|15706
||jsr|6,sysrd|||; read next standard input image|15707
||ppm|6,acs03|||; jump to fail exit if end of file|15708
||brn|6,acs07|||; else merge with other file case|15709
;
;      here for input from other than standard input file
;
|acs06|mov|8,wa|7,xl||; fcblk ptr|15713
||jsr|6,sysil|||; get input record max length (to wa)|15714
||bnz|8,wc|6,acs6a||; jump if not binary file|15715
||mov|3,actrm|8,wc||; disable trim for binary file|15716
|acs6a|jsr|6,alocs|||; allocate string of correct size|15717
||mov|8,wa|7,xl||; fcblk ptr|15718
||jsr|6,sysin|||; call system input routine|15719
||ppm|6,acs03|||; jump to fail exit if end of file|15720
||ppm|6,acs22|||; error|15721
||ppm|6,acs23|||; error|15722
||ejc|||||15723
;
;      acess (continued)
;
;      merge here after obtaining input record
;
|acs07|mov|8,wb|3,actrm||; load trim indicator|15729
||jsr|6,trimr|||; trim record as required|15730
||mov|8,wb|7,xr||; copy result pointer|15731
||mov|7,xr|9,(xs)||; reload pointer to trblk|15732
;
;      loop to chase to end of trblk chain and store value
;
|acs08|mov|7,xl|7,xr||; save pointer to this trblk|15736
||mov|7,xr|13,trnxt(xr)||; load forward pointer|15737
||beq|9,(xr)|22,=b_trt|6,acs08|; loop if this is another trblk|15738
||mov|13,trnxt(xl)|8,wb||; else store result at end of chain|15739
||mov|7,xr|10,(xs)+||; restore initial trblk pointer|15740
||mov|8,wa|10,(xs)+||; restore name offset|15741
||mov|7,xl|10,(xs)+||; restore name base pointer|15742
;
;      come here to move to next trblk
;
|acs09|mov|7,xr|13,trnxt(xr)||; load forward ptr to next value|15746
||brn|6,acs02|||; back to check if trapped|15747
;
;      here to check for access trace trblk
;
|acs10|bne|8,wb|18,=trtac|6,acs09|; loop back if not access trace|15751
||bze|3,kvtra|6,acs09||; ignore access trace if trace off|15752
||dcv|3,kvtra|||; else decrement trace count|15753
||bze|13,trfnc(xr)|6,acs11||; jump if print trace|15754
||ejc|||||15755
;
;      acess (continued)
;
;      here for full function trace
;
||jsr|6,trxeq|||; call routine to execute trace|15761
||brn|6,acs09|||; jump for next trblk|15762
;
;      here for case of print trace
;
|acs11|jsr|6,prtsn|||; print statement number|15766
||jsr|6,prtnv|||; print name = value|15767
||brn|6,acs09|||; jump back for next trblk|15768
;
;      here for keyword variable
;
|acs12|mov|7,xr|13,kvnum(xl)||; load keyword number|15772
||bge|7,xr|18,=k_v__|6,acs14|; jump if not one word value|15773
||mti|15,kvabe(xr)|||; else load value as integer|15774
;
;      common exit with keyword value as integer in (ia)
;
|acs13|jsr|6,icbld|||; build icblk|15778
||brn|6,acs18|||; jump to exit|15779
;
;      here if not one word keyword value
;
|acs14|bge|7,xr|18,=k_s__|6,acs15|; jump if special case|15783
||sub|7,xr|18,=k_v__||; else get offset|15784
||wtb|7,xr|||; convert to byte offset|15785
||add|7,xr|21,=ndabo||; point to pattern value|15786
||brn|6,acs18|||; jump to exit|15787
;
;      here if special keyword case
;
|acs15|mov|7,xl|3,kvrtn||; load rtntype in case|15791
||ldi|3,kvstl|||; load stlimit in case|15792
||sub|7,xr|18,=k_s__||; get case number|15793
||bsw|7,xr|2,k__n_||; switch on keyword number|15794
||iff|2,k__al|6,acs16||; jump if alphabet|15808
||iff|2,k__rt|6,acs17||; rtntype|15808
||iff|2,k__sc|6,acs19||; stcount|15808
||iff|2,k__et|6,acs20||; errtext|15808
||iff|2,k__fl|6,acs26||; file|15808
||iff|2,k__lf|6,acs27||; lastfile|15808
||iff|2,k__sl|6,acs13||; stlimit|15808
||iff|2,k__lc|6,acs24||; lcase|15808
||iff|2,k__uc|6,acs25||; ucase|15808
||esw||||; end switch on keyword number|15808
||ejc|||||15809
;
;      acess (continued)
;
;      lcase
;
|acs24|mov|7,xr|21,=lcase||; load pointer to lcase string|15816
||brn|6,acs18|||; common return|15817
;
;      ucase
;
|acs25|mov|7,xr|21,=ucase||; load pointer to ucase string|15821
||brn|6,acs18|||; common return|15822
;
;      file
;
|acs26|mov|8,wc|3,kvstn||; load current stmt number|15828
||brn|6,acs28|||; merge to obtain file name|15829
;
;      lastfile
;
|acs27|mov|8,wc|3,kvlst||; load last stmt number|15833
;
;      merge here to map statement number in wc to file name
;
|acs28|jsr|6,filnm|||; obtain file name for this stmt|15837
||brn|6,acs17|||; merge to return string in xl|15838
;      alphabet
;
|acs16|mov|7,xl|3,kvalp||; load pointer to alphabet string|15842
;
;      rtntype merges here
;
|acs17|mov|7,xr|7,xl||; copy string ptr to proper reg|15846
;
;      common return point
;
|acs18|exi||||; return to acess caller|15850
;
;      here for stcount (ia has stlimit)
;
|acs19|ilt|6,acs29|||; if counting suppressed|15854
||mov|8,wa|3,stmcs||; refine with counter start value|15855
||sub|8,wa|3,stmct||; minus current counter|15856
||mti|8,wa|||; convert to integer|15857
||adi|3,kvstl|||; add stlimit|15858
|acs29|sbi|3,kvstc|||; stcount = limit - left|15859
||brn|6,acs13|||; merge back with integer result|15860
;
;      errtext
;
|acs20|mov|7,xr|3,r_etx||; get errtext string|15864
||brn|6,acs18|||; merge with result|15865
;
;      here to read a record from terminal
;
|acs21|mov|8,wa|18,=rilen||; buffer length|15869
||jsr|6,alocs|||; allocate buffer|15870
||jsr|6,sysri|||; read record|15871
||ppm|6,acs03|||; endfile|15872
||brn|6,acs07|||; merge with record read|15873
;
;      error returns
;
|acs22|mov|3,dnamp|7,xr||; pop unused scblk|15877
||erb|1,202|26,input from file caused non-recoverable error|||15878
;
|acs23|mov|3,dnamp|7,xr||; pop unused scblk|15880
||erb|1,203|26,input file record has incorrect format|||15881
||enp||||; end procedure acess|15882
||ejc|||||15883
;
;      acomp -- compare two arithmetic values
;
;      1(xs)		     first argument
;      0(xs)		     second argument
;      jsr  acomp	     call to compare values
;      ppm  loc		     transfer loc if arg1 is non-numeric
;      ppm  loc		     transfer loc if arg2 is non-numeric
;      ppm  loc		     transfer loc for arg1 lt arg2
;      ppm  loc		     transfer loc for arg1 eq arg2
;      ppm  loc		     transfer loc for arg1 gt arg2
;      (normal return is never given)
;      (wa,wb,wc,ia,ra)	     destroyed
;      (xl,xr)		     destroyed
;
|acomp|prc|25,n|1,5||; entry point|15899
||jsr|6,arith|||; load arithmetic operands|15900
||ppm|6,acmp7|||; jump if first arg non-numeric|15901
||ppm|6,acmp8|||; jump if second arg non-numeric|15902
||ppm|6,acmp4|||; jump if real arguments|15905
;
;      here for integer arguments
;
||sbi|13,icval(xl)|||; subtract to compare|15910
||iov|6,acmp3|||; jump if overflow|15911
||ilt|6,acmp5|||; else jump if arg1 lt arg2|15912
||ieq|6,acmp2|||; jump if arg1 eq arg2|15913
;
;      here if arg1 gt arg2
;
|acmp1|exi|1,5|||; take gt exit|15917
;
;      here if arg1 eq arg2
;
|acmp2|exi|1,4|||; take eq exit|15921
||ejc|||||15922
;
;      acomp (continued)
;
;      here for integer overflow on subtract
;
|acmp3|ldi|13,icval(xl)|||; load second argument|15928
||ilt|6,acmp1|||; gt if negative|15929
||brn|6,acmp5|||; else lt|15930
;
;      here for real operands
;
|acmp4|sbr|13,rcval(xl)|||; subtract to compare|15936
||rov|6,acmp6|||; jump if overflow|15937
||rgt|6,acmp1|||; else jump if arg1 gt|15938
||req|6,acmp2|||; jump if arg1 eq arg2|15939
;
;      here if arg1 lt arg2
;
|acmp5|exi|1,3|||; take lt exit|15944
;
;      here if overflow on real subtraction
;
|acmp6|ldr|13,rcval(xl)|||; reload arg2|15950
||rlt|6,acmp1|||; gt if negative|15951
||brn|6,acmp5|||; else lt|15952
;
;      here if arg1 non-numeric
;
|acmp7|exi|1,1|||; take error exit|15957
;
;      here if arg2 non-numeric
;
|acmp8|exi|1,2|||; take error exit|15961
||enp||||; end procedure acomp|15962
||ejc|||||15963
;
;      alloc		     allocate block of dynamic storage
;
;      (wa)		     length required in bytes
;      jsr  alloc	     call to allocate block
;      (xr)		     pointer to allocated block
;
;      a possible alternative to aov ... and following stmt is -
;      mov  dname,xr .	sub  wa,xr .  blo xr,dnamp,aloc2 .
;      mov  dnamp,xr .	add  wa,xr
;
|alloc|prc|25,e|1,0||; entry point|15975
;
;      common exit point
;
|aloc1|mov|7,xr|3,dnamp||; point to next available loc|15979
||aov|8,wa|7,xr|6,aloc2|; point past allocated block|15980
||bgt|7,xr|3,dname|6,aloc2|; jump if not enough room|15981
||mov|3,dnamp|7,xr||; store new pointer|15982
||sub|7,xr|8,wa||; point back to start of allocated bk|15983
||exi||||; return to caller|15984
;
;      here if insufficient room, try a garbage collection
;
|aloc2|mov|3,allsv|8,wb||; save wb|15988
|alc2a|zer|8,wb|||; set no upward move for gbcol|15989
||jsr|6,gbcol|||; garbage collect|15990
||mov|8,wb|7,xr||; remember new sediment size|15992
;
;      see if room after gbcol or sysmm call
;
|aloc3|mov|7,xr|3,dnamp||; point to first available loc|15997
||aov|8,wa|7,xr|6,alc3a|; point past new block|15998
||blo|7,xr|3,dname|6,aloc4|; jump if there is room now|15999
;
;      failed again, see if we can get more core
;
|alc3a|jsr|6,sysmm|||; try to get more memory|16003
||wtb|7,xr|||; convert to baus (sgd05)|16004
||add|3,dname|7,xr||; bump ptr by amount obtained|16005
||bnz|7,xr|6,aloc3||; jump if got more core|16006
||bze|3,dnams|6,alc3b||; jump if there was no sediment|16008
||zer|3,dnams|||; try collecting the sediment|16009
||brn|6,alc2a|||;|16010
;
;      sysmm failed and there was no sediment to collect
;
|alc3b|add|3,dname|3,rsmem||; get the reserve memory|16014
||zer|3,rsmem|||; only permissible once|16018
||icv|3,errft|||; fatal error|16019
||erb|1,204|26,memory overflow|||16020
||ejc|||||16021
;
;      here after successful garbage collection
;
|aloc4|sti|3,allia|||; save ia|16025
||mov|3,dnams|8,wb||; record new sediment size|16027
||mov|8,wb|3,dname||; get dynamic end adrs|16029
||sub|8,wb|3,dnamp||; compute free store|16030
||btw|8,wb|||; convert bytes to words|16031
||mti|8,wb|||; put free store in ia|16032
||mli|3,alfsf|||; multiply by free store factor|16033
||iov|6,aloc5|||; jump if overflowed|16034
||mov|8,wb|3,dname||; dynamic end adrs|16035
||sub|8,wb|3,dnamb||; compute total amount of dynamic|16036
||btw|8,wb|||; convert to words|16037
||mov|3,aldyn|8,wb||; store it|16038
||sbi|3,aldyn|||; subtract from scaled up free store|16039
||igt|6,aloc5|||; jump if sufficient free store|16040
||jsr|6,sysmm|||; try to get more store|16041
||wtb|7,xr|||; convert to baus (sgd05)|16042
||add|3,dname|7,xr||; adjust dynamic end adrs|16043
;
;      merge to restore ia and wb
;
|aloc5|ldi|3,allia|||; recover ia|16047
||mov|8,wb|3,allsv||; restore wb|16048
||brn|6,aloc1|||; jump back to exit|16049
||enp||||; end procedure alloc|16050
||ejc|||||16051
;
;      alocs -- allocate string block
;
;      alocs is used to build a frame for a string block into
;      which the actual characters are placed by the caller.
;      all strings are created with a call to alocs (the
;      exceptions occur in trimr and s_rpl procedures).
;
;      (wa)		     length of string to be allocated
;      jsr  alocs	     call to allocate scblk
;      (xr)		     pointer to resulting scblk
;      (wa)		     destroyed
;      (wc)		     character count (entry value of wa)
;
;      the resulting scblk has the type word and the length
;      filled in and the last word is cleared to zero characters
;      to ensure correct right padding of the final word.
;
|alocs|prc|25,e|1,0||; entry point|16111
||bgt|8,wa|3,kvmxl|6,alcs2|; jump if length exceeds maxlength|16112
||mov|8,wc|8,wa||; else copy length|16113
||ctb|8,wa|2,scsi_||; compute length of scblk in bytes|16114
||mov|7,xr|3,dnamp||; point to next available location|16115
||aov|8,wa|7,xr|6,alcs0|; point past block|16116
||blo|7,xr|3,dname|6,alcs1|; jump if there is room|16117
;
;      insufficient memory
;
|alcs0|zer|7,xr|||; else clear garbage xr value|16121
||jsr|6,alloc|||; and use standard allocator|16122
||add|7,xr|8,wa||; point past end of block to merge|16123
;
;      merge here with xr pointing beyond new block
;
|alcs1|mov|3,dnamp|7,xr||; set updated storage pointer|16127
||zer|11,-(xr)|||; store zero chars in last word|16128
||dca|8,wa|||; decrement length|16129
||sub|7,xr|8,wa||; point back to start of block|16130
||mov|9,(xr)|22,=b_scl||; set type word|16131
||mov|13,sclen(xr)|8,wc||; store length in chars|16132
||exi||||; return to alocs caller|16133
;
;      come here if string is too long
;
|alcs2|erb|1,205|26,string length exceeds value of maxlngth keyword|||16137
||enp||||; end procedure alocs|16138
||ejc|||||16139
;
;      alost -- allocate space in static region
;
;      (wa)		     length required in bytes
;      jsr  alost	     call to allocate space
;      (xr)		     pointer to allocated block
;      (wb)		     destroyed
;
;      note that the coding ensures that the resulting value
;      of state is always less than dnamb. this fact is used
;      in testing a variable name for being in the static region
;
|alost|prc|25,e|1,0||; entry point|16152
;
;      merge back here after allocating new chunk
;
|alst1|mov|7,xr|3,state||; point to current end of area|16156
||aov|8,wa|7,xr|6,alst2|; point beyond proposed block|16157
||bge|7,xr|3,dnamb|6,alst2|; jump if overlap with dynamic area|16158
||mov|3,state|7,xr||; else store new pointer|16159
||sub|7,xr|8,wa||; point back to start of block|16160
||exi||||; return to alost caller|16161
;
;      here if no room, prepare to move dynamic storage up
;
|alst2|mov|3,alsta|8,wa||; save wa|16165
||bge|8,wa|19,*e_sts|6,alst3|; skip if requested chunk is large|16166
||mov|8,wa|19,*e_sts||; else set to get large enough chunk|16167
;
;      here with amount to move up in wa
;
|alst3|jsr|6,alloc|||; allocate block to ensure room|16171
||mov|3,dnamp|7,xr||; and delete it|16172
||mov|8,wb|8,wa||; copy move up amount|16173
||jsr|6,gbcol|||; call gbcol to move dynamic area up|16174
||mov|3,dnams|7,xr||; remember new sediment size|16176
||mov|8,wa|3,alsta||; restore wa|16178
||brn|6,alst1|||; loop back to try again|16179
||enp||||; end procedure alost|16180
||ejc|||||16181
;
;      arith -- fetch arithmetic operands
;
;      arith is used by functions and operators which expect
;      two numeric arguments (operands) which must both be
;      integer or both be real. arith fetches two arguments from
;      the stack and performs any necessary conversions.
;
;      1(xs)		     first argument (left operand)
;      0(xs)		     second argument (right operand)
;      jsr  arith	     call to fetch numeric arguments
;      ppm  loc		     transfer loc for opnd 1 non-numeric
;      ppm  loc		     transfer loc for opnd 2 non-numeric
;      ppm  loc		     transfer loc for real operands
;
;      for integer args, control returns past the parameters
;
;      (ia)		     left operand value
;      (xr)		     ptr to icblk for left operand
;      (xl)		     ptr to icblk for right operand
;      (xs)		     popped twice
;      (wa,wb,ra)	     destroyed
;
;      for real arguments, control returns to the location
;      specified by the third parameter.
;
;      (ra)		     left operand value
;      (xr)		     ptr to rcblk for left operand
;      (xl)		     ptr to rcblk for right operand
;      (wa,wb,wc)	     destroyed
;      (xs)		     popped twice
||ejc|||||16255
;
;      arith (continued)
;
;      entry point
;
|arith|prc|25,n|1,3||; entry point|16264
||mov|7,xl|10,(xs)+||; load right operand|16266
||mov|7,xr|10,(xs)+||; load left operand|16267
||mov|8,wa|9,(xl)||; get right operand type word|16268
||beq|8,wa|22,=b_icl|6,arth1|; jump if integer|16269
||beq|8,wa|22,=b_rcl|6,arth4|; jump if real|16272
||mov|11,-(xs)|7,xr||; else replace left arg on stack|16274
||mov|7,xr|7,xl||; copy left arg pointer|16275
||jsr|6,gtnum|||; convert to numeric|16276
||ppm|6,arth6|||; jump if unconvertible|16277
||mov|7,xl|7,xr||; else copy converted result|16278
||mov|8,wa|9,(xl)||; get right operand type word|16279
||mov|7,xr|10,(xs)+||; reload left argument|16280
||beq|8,wa|22,=b_rcl|6,arth4|; jump if right arg is real|16283
;
;      here if right arg is an integer
;
|arth1|bne|9,(xr)|22,=b_icl|6,arth3|; jump if left arg not integer|16288
;
;      exit for integer case
;
|arth2|ldi|13,icval(xr)|||; load left operand value|16292
||exi||||; return to arith caller|16293
;
;      here for right operand integer, left operand not
;
|arth3|jsr|6,gtnum|||; convert left arg to numeric|16297
||ppm|6,arth7|||; jump if not convertible|16298
||beq|8,wa|22,=b_icl|6,arth2|; jump back if integer-integer|16299
;
;      here we must convert real-integer to real-real
;
||mov|11,-(xs)|7,xr||; put left arg back on stack|16305
||ldi|13,icval(xl)|||; load right argument value|16306
||itr||||; convert to real|16307
||jsr|6,rcbld|||; get real block for right arg, merge|16308
||mov|7,xl|7,xr||; copy right arg ptr|16309
||mov|7,xr|10,(xs)+||; load left argument|16310
||brn|6,arth5|||; merge for real-real case|16311
||ejc|||||16312
;
;      arith (continued)
;
;      here if right argument is real
;
|arth4|beq|9,(xr)|22,=b_rcl|6,arth5|; jump if left arg real|16318
||jsr|6,gtrea|||; else convert to real|16319
||ppm|6,arth7|||; error if unconvertible|16320
;
;      here for real-real
;
|arth5|ldr|13,rcval(xr)|||; load left operand value|16324
||exi|1,3|||; take real-real exit|16325
;
;      here for error converting right argument
;
|arth6|ica|7,xs|||; pop unwanted left arg|16330
||exi|1,2|||; take appropriate error exit|16331
;
;      here for error converting left operand
;
|arth7|exi|1,1|||; take appropriate error return|16335
||enp||||; end procedure arith|16336
||ejc|||||16337
;
;      asign -- perform assignment
;
;      asign performs the assignment of a value to a variable
;      with appropriate checks for output associations and
;      value trace associations which are executed as required.
;      asign also handles the special cases of assignment to
;      pattern and expression variables.
;
;      (wb)		     value to be assigned
;      (xl)		     base pointer for variable
;      (wa)		     offset for variable
;      jsr  asign	     call to assign value to variable
;      ppm  loc		     transfer loc for failure
;      (xr,xl,wa,wb,wc)	     destroyed
;      (ra)		     destroyed
;
;      failure occurs if the evaluation of an expression
;      associated with an expression variable fails.
;
|asign|prc|25,r|1,1||; entry point (recursive)|16358
;
;      merge back here to assign result to expression variable.
;
|asg01|add|7,xl|8,wa||; point to variable value|16362
||mov|7,xr|9,(xl)||; load variable value|16363
||beq|9,(xr)|22,=b_trt|6,asg02|; jump if trapped|16364
||mov|9,(xl)|8,wb||; else perform assignment|16365
||zer|7,xl|||; clear garbage value in xl|16366
||exi||||; and return to asign caller|16367
;
;      here if value is trapped
;
|asg02|sub|7,xl|8,wa||; restore name base|16371
||beq|7,xr|21,=trbkv|6,asg14|; jump if keyword variable|16372
||bne|7,xr|21,=trbev|6,asg04|; jump if not expression variable|16373
;
;      here for assignment to expression variable
;
||mov|7,xr|13,evexp(xl)||; point to expression|16377
||mov|11,-(xs)|8,wb||; store value to assign on stack|16378
||mov|8,wb|18,=num01||; set for evaluation by name|16379
||jsr|6,evalx|||; evaluate expression by name|16380
||ppm|6,asg03|||; jump if evaluation fails|16381
||mov|8,wb|10,(xs)+||; else reload value to assign|16382
||brn|6,asg01|||; loop back to perform assignment|16383
||ejc|||||16384
;
;      asign (continued)
;
;      here for failure during expression evaluation
;
|asg03|ica|7,xs|||; remove stacked value entry|16390
||exi|1,1|||; take failure exit|16391
;
;      here if not keyword or expression variable
;
|asg04|mov|11,-(xs)|7,xr||; save ptr to first trblk|16395
;
;      loop to chase down trblk chain and assign value at end
;
|asg05|mov|8,wc|7,xr||; save ptr to this trblk|16399
||mov|7,xr|13,trnxt(xr)||; point to next trblk|16400
||beq|9,(xr)|22,=b_trt|6,asg05|; loop back if another trblk|16401
||mov|7,xr|8,wc||; else point back to last trblk|16402
||mov|13,trval(xr)|8,wb||; store value at end of chain|16403
||mov|7,xr|10,(xs)+||; restore ptr to first trblk|16404
;
;      loop to process trblk entries on chain
;
|asg06|mov|8,wb|13,trtyp(xr)||; load type code of trblk|16408
||beq|8,wb|18,=trtvl|6,asg08|; jump if value trace|16409
||beq|8,wb|18,=trtou|6,asg10|; jump if output association|16410
;
;      here to move to next trblk on chain
;
|asg07|mov|7,xr|13,trnxt(xr)||; point to next trblk on chain|16414
||beq|9,(xr)|22,=b_trt|6,asg06|; loop back if another trblk|16415
||exi||||; else end of chain, return to caller|16416
;
;      here to process value trace
;
|asg08|bze|3,kvtra|6,asg07||; ignore value trace if trace off|16420
||dcv|3,kvtra|||; else decrement trace count|16421
||bze|13,trfnc(xr)|6,asg09||; jump if print trace|16422
||jsr|6,trxeq|||; else execute function trace|16423
||brn|6,asg07|||; and loop back|16424
||ejc|||||16425
;
;      asign (continued)
;
;      here for print trace
;
|asg09|jsr|6,prtsn|||; print statement number|16431
||jsr|6,prtnv|||; print name = value|16432
||brn|6,asg07|||; loop back for next trblk|16433
;
;      here for output association
;
|asg10|bze|3,kvoup|6,asg07||; ignore output assoc if output off|16437
|asg1b|mov|7,xl|7,xr||; copy trblk pointer|16438
||mov|7,xr|13,trnxt(xr)||; point to next trblk|16439
||beq|9,(xr)|22,=b_trt|6,asg1b|; loop back if another trblk|16440
||mov|7,xr|7,xl||; else point back to last trblk|16441
||mov|11,-(xs)|13,trval(xr)||; stack value to output|16443
||jsr|6,gtstg|||; convert to string|16449
||ppm|6,asg12|||; get datatype name if unconvertible|16450
;
;      merge with string or buffer to output in xr
;
|asg11|mov|8,wa|13,trfpt(xl)||; fcblk ptr|16454
||bze|8,wa|6,asg13||; jump if standard output file|16455
;
;      here for output to file
;
|asg1a|jsr|6,sysou|||; call system output routine|16459
||err|1,206|26,output caused file overflow|||16460
||err|1,207|26,output caused non-recoverable error|||16461
||exi||||; else all done, return to caller|16462
;
;      if not printable, get datatype name instead
;
|asg12|jsr|6,dtype|||; call datatype routine|16466
||brn|6,asg11|||; merge|16467
;
;      here to print a string to standard output or terminal
;
|asg13|beq|13,trter(xl)|21,=v_ter|6,asg1a|; jump if terminal output|16472
||icv|8,wa|||; signal standard output|16473
||brn|6,asg1a|||; use sysou to perform output|16474
||ejc|||||16489
;
;      asign (continued)
;
;      here for keyword assignment
;
|asg14|mov|7,xl|13,kvnum(xl)||; load keyword number|16495
||beq|7,xl|18,=k_etx|6,asg19|; jump if errtext|16496
||mov|7,xr|8,wb||; copy value to be assigned|16497
||jsr|6,gtint|||; convert to integer|16498
||err|1,208|26,keyword value assigned is not integer|||16499
||ldi|13,icval(xr)|||; else load value|16500
||beq|7,xl|18,=k_stl|6,asg16|; jump if special case of stlimit|16501
||mfi|8,wa|6,asg18||; else get addr integer, test ovflow|16502
||bgt|8,wa|3,mxlen|6,asg18|; fail if too large|16503
||beq|7,xl|18,=k_ert|6,asg17|; jump if special case of errtype|16504
||beq|7,xl|18,=k_pfl|6,asg21|; jump if special case of profile|16507
||beq|7,xl|18,=k_mxl|6,asg24|; jump if special case of maxlngth|16509
||beq|7,xl|18,=k_fls|6,asg26|; jump if special case of fullscan|16510
||blt|7,xl|18,=k_p__|6,asg15|; jump unless protected|16511
||erb|1,209|26,keyword in assignment is protected|||16512
;
;      here to do assignment if not protected
;
|asg15|mov|15,kvabe(xl)|8,wa||; store new value|16516
||exi||||; return to asign caller|16517
;
;      here for special case of stlimit
;
;      since stcount is maintained as (stlimit-stcount)
;      it is also necessary to modify stcount appropriately.
;
|asg16|sbi|3,kvstl|||; subtract old limit|16524
||adi|3,kvstc|||; add old counter|16525
||sti|3,kvstc|||; store course counter value|16526
||ldi|3,kvstl|||; check if counting suppressed|16527
||ilt|6,asg25|||; do not refine if so|16528
||mov|8,wa|3,stmcs||; refine with counter breakout|16529
||sub|8,wa|3,stmct||; values|16530
||mti|8,wa|||; convert to integer|16531
||ngi||||; current-start value|16532
||adi|3,kvstc|||; add in course counter value|16533
||sti|3,kvstc|||; save refined value|16534
|asg25|ldi|13,icval(xr)|||; reload new limit value|16535
||sti|3,kvstl|||; store new limit value|16536
||jsr|6,stgcc|||; recompute countdown counters|16537
||exi||||; return to asign caller|16538
;
;      here for special case of errtype
;
|asg17|ble|8,wa|18,=nini9|6,error|; ok to signal if in range|16542
;
;      here if value assigned is out of range
;
|asg18|erb|1,210|26,keyword value assigned is negative or too large|||16546
;
;      here for special case of errtext
;
|asg19|mov|11,-(xs)|8,wb||; stack value|16550
||jsr|6,gtstg|||; convert to string|16551
||err|1,211|26,value assigned to keyword errtext not a string|||16552
||mov|3,r_etx|7,xr||; make assignment|16553
||exi||||; return to caller|16554
;
;      here for keyword profile
;
|asg21|bgt|8,wa|18,=num02|6,asg18|; moan if not 0,1, or 2|16568
||bze|8,wa|6,asg15||; just assign if zero|16569
||bze|3,pfdmp|6,asg22||; branch if first assignment|16570
||beq|8,wa|3,pfdmp|6,asg23|; also if same value as before|16571
||erb|1,268|26,inconsistent value assigned to keyword profile|||16572
;
|asg22|mov|3,pfdmp|8,wa||; note value on first assignment|16574
|asg23|mov|3,kvpfl|8,wa||; store new value|16575
||jsr|6,stgcc|||; recompute countdown counts|16576
||jsr|6,systm|||; get the time|16577
||sti|3,pfstm|||; fudge some kind of start time|16578
||exi||||; return to asign caller|16579
;
;      here for keyword maxlngth
;
|asg24|bge|8,wa|18,=mnlen|6,asg15|; if acceptable value|16584
||erb|1,287|26,value assigned to keyword maxlngth is too small|||16585
;
;      here for keyword fullscan
;
|asg26|bnz|8,wa|6,asg15||; if acceptable value|16589
||erb|1,274|26,value assigned to keyword fullscan is zero|||16590
;
||enp||||; end procedure asign|16592
||ejc|||||16593
;
;      asinp -- assign during pattern match
;
;      asinp is like asign and has a similar calling sequence
;      and effect. the difference is that the global pattern
;      variables are saved and restored if required.
;
;      (xl)		     base pointer for variable
;      (wa)		     offset for variable
;      (wb)		     value to be assigned
;      jsr  asinp	     call to assign value to variable
;      ppm  loc		     transfer loc if failure
;      (xr,xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
|asinp|prc|25,r|1,1||; entry point, recursive|16609
||add|7,xl|8,wa||; point to variable|16610
||mov|7,xr|9,(xl)||; load current contents|16611
||beq|9,(xr)|22,=b_trt|6,asnp1|; jump if trapped|16612
||mov|9,(xl)|8,wb||; else perform assignment|16613
||zer|7,xl|||; clear garbage value in xl|16614
||exi||||; return to asinp caller|16615
;
;      here if variable is trapped
;
|asnp1|sub|7,xl|8,wa||; restore base pointer|16619
||mov|11,-(xs)|3,pmssl||; stack subject string length|16620
||mov|11,-(xs)|3,pmhbs||; stack history stack base ptr|16621
||mov|11,-(xs)|3,r_pms||; stack subject string pointer|16622
||mov|11,-(xs)|3,pmdfl||; stack dot flag|16623
||jsr|6,asign|||; call full-blown assignment routine|16624
||ppm|6,asnp2|||; jump if failure|16625
||mov|3,pmdfl|10,(xs)+||; restore dot flag|16626
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|16627
||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|16628
||mov|3,pmssl|10,(xs)+||; restore subject string length|16629
||exi||||; return to asinp caller|16630
;
;      here if failure in asign call
;
|asnp2|mov|3,pmdfl|10,(xs)+||; restore dot flag|16634
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|16635
||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|16636
||mov|3,pmssl|10,(xs)+||; restore subject string length|16637
||exi|1,1|||; take failure exit|16638
||enp||||; end procedure asinp|16639
||ejc|||||16640
;
;      blkln -- determine length of block
;
;      blkln determines the length of a block in dynamic store.
;
;      (wa)		     first word of block
;      (xr)		     pointer to block
;      jsr  blkln	     call to get block length
;      (wa)		     length of block in bytes
;      (xl)		     destroyed
;
;      blkln is used by the garbage collector and is not
;      permitted to call gbcol directly or indirectly.
;
;      the first word stored in the block (i.e. at xr) may
;      be anything, but the contents of wa must be correct.
;
|blkln|prc|25,e|1,0||; entry point|16658
||mov|7,xl|8,wa||; copy first word|16659
||lei|7,xl|||; get entry id (bl_xx)|16660
||bsw|7,xl|2,bl___|6,bln00|; switch on block type|16661
||iff|2,bl_ar|6,bln01||; arblk|16701
||iff|2,bl_cd|6,bln12||; cdblk|16701
||iff|2,bl_ex|6,bln12||; exblk|16701
||iff|2,bl_ic|6,bln07||; icblk|16701
||iff|2,bl_nm|6,bln03||; nmblk|16701
||iff|2,bl_p0|6,bln02||; p0blk|16701
||iff|2,bl_p1|6,bln03||; p1blk|16701
||iff|2,bl_p2|6,bln04||; p2blk|16701
||iff|2,bl_rc|6,bln09||; rcblk|16701
||iff|2,bl_sc|6,bln10||; scblk|16701
||iff|2,bl_se|6,bln02||; seblk|16701
||iff|2,bl_tb|6,bln01||; tbblk|16701
||iff|2,bl_vc|6,bln01||; vcblk|16701
||iff|1,13|6,bln00|||16701
||iff|1,14|6,bln00|||16701
||iff|1,15|6,bln00|||16701
||iff|2,bl_pd|6,bln08||; pdblk|16701
||iff|2,bl_tr|6,bln05||; trblk|16701
||iff|1,18|6,bln00|||16701
||iff|1,19|6,bln00|||16701
||iff|1,20|6,bln00|||16701
||iff|2,bl_ct|6,bln06||; ctblk|16701
||iff|2,bl_df|6,bln01||; dfblk|16701
||iff|2,bl_ef|6,bln01||; efblk|16701
||iff|2,bl_ev|6,bln03||; evblk|16701
||iff|2,bl_ff|6,bln05||; ffblk|16701
||iff|2,bl_kv|6,bln03||; kvblk|16701
||iff|2,bl_pf|6,bln01||; pfblk|16701
||iff|2,bl_te|6,bln04||; teblk|16701
||esw||||; end of jump table on block type|16701
||ejc|||||16702
;
;      blkln (continued)
;
;      here for blocks with length in second word
;
|bln00|mov|8,wa|13,num01(xr)||; load length|16708
||exi||||; return to blkln caller|16709
;
;      here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)
;
|bln01|mov|8,wa|13,num02(xr)||; load length from third word|16713
||exi||||; return to blkln caller|16714
;
;      here for two word blocks (p0,se)
;
|bln02|mov|8,wa|19,*num02||; load length (two words)|16718
||exi||||; return to blkln caller|16719
;
;      here for three word blocks (nm,p1,ev,kv)
;
|bln03|mov|8,wa|19,*num03||; load length (three words)|16723
||exi||||; return to blkln caller|16724
;
;      here for four word blocks (p2,te,bc)
;
|bln04|mov|8,wa|19,*num04||; load length (four words)|16728
||exi||||; return to blkln caller|16729
;
;      here for five word blocks (ff,tr)
;
|bln05|mov|8,wa|19,*num05||; load length|16733
||exi||||; return to blkln caller|16734
||ejc|||||16735
;
;      blkln (continued)
;
;      here for ctblk
;
|bln06|mov|8,wa|19,*ctsi_||; set size of ctblk|16741
||exi||||; return to blkln caller|16742
;
;      here for icblk
;
|bln07|mov|8,wa|19,*icsi_||; set size of icblk|16746
||exi||||; return to blkln caller|16747
;
;      here for pdblk
;
|bln08|mov|7,xl|13,pddfp(xr)||; point to dfblk|16751
||mov|8,wa|13,dfpdl(xl)||; load pdblk length from dfblk|16752
||exi||||; return to blkln caller|16753
;
;      here for rcblk
;
|bln09|mov|8,wa|19,*rcsi_||; set size of rcblk|16759
||exi||||; return to blkln caller|16760
;
;      here for scblk
;
|bln10|mov|8,wa|13,sclen(xr)||; load length in characters|16765
||ctb|8,wa|2,scsi_||; calculate length in bytes|16766
||exi||||; return to blkln caller|16767
;
;      here for length in fourth word (cd,ex)
;
|bln12|mov|8,wa|13,num03(xr)||; load length from cdlen/exlen|16781
||exi||||; return to blkln caller|16782
||enp||||; end procedure blkln|16784
||ejc|||||16785
;
;      copyb -- copy a block
;
;      (xs)		     block to be copied
;      jsr  copyb	     call to copy block
;      ppm  loc		     return if block has no idval field
;			     normal return if idval field
;      (xr)		     copy of block
;      (xs)		     popped
;      (xl,wa,wb,wc)	     destroyed
;
|copyb|prc|25,n|1,1||; entry point|16797
||mov|7,xr|9,(xs)||; load argument|16798
||beq|7,xr|21,=nulls|6,cop10|; return argument if it is null|16799
||mov|8,wa|9,(xr)||; else load type word|16800
||mov|8,wb|8,wa||; copy type word|16801
||jsr|6,blkln|||; get length of argument block|16802
||mov|7,xl|7,xr||; copy pointer|16803
||jsr|6,alloc|||; allocate block of same size|16804
||mov|9,(xs)|7,xr||; store pointer to copy|16805
||mvw||||; copy contents of old block to new|16806
||zer|7,xl|||; clear garbage xl|16807
||mov|7,xr|9,(xs)||; reload pointer to start of copy|16808
||beq|8,wb|22,=b_tbt|6,cop05|; jump if table|16809
||beq|8,wb|22,=b_vct|6,cop01|; jump if vector|16810
||beq|8,wb|22,=b_pdt|6,cop01|; jump if program defined|16811
||bne|8,wb|22,=b_art|6,cop10|; return copy if not array|16816
;
;      here for array (arblk)
;
||add|7,xr|13,arofs(xr)||; point to prototype field|16820
||brn|6,cop02|||; jump to merge|16821
;
;      here for vector, program defined
;
|cop01|add|7,xr|19,*pdfld||; point to pdfld = vcvls|16825
;
;      merge here for arblk, vcblk, pdblk to delete trap
;      blocks from all value fields (the copy is untrapped)
;
|cop02|mov|7,xl|9,(xr)||; load next pointer|16830
;
;      loop to get value at end of trblk chain
;
|cop03|bne|9,(xl)|22,=b_trt|6,cop04|; jump if not trapped|16834
||mov|7,xl|13,trval(xl)||; else point to next value|16835
||brn|6,cop03|||; and loop back|16836
||ejc|||||16837
;
;      copyb (continued)
;
;      here with untrapped value in xl
;
|cop04|mov|10,(xr)+|7,xl||; store real value, bump pointer|16843
||bne|7,xr|3,dnamp|6,cop02|; loop back if more to go|16844
||brn|6,cop09|||; else jump to exit|16845
;
;      here to copy a table
;
|cop05|zer|13,idval(xr)|||; zero id to stop dump blowing up|16849
||mov|8,wa|19,*tesi_||; set size of teblk|16850
||mov|8,wc|19,*tbbuk||; set initial offset|16851
;
;      loop through buckets in table
;
|cop06|mov|7,xr|9,(xs)||; load table pointer|16855
||beq|8,wc|13,tblen(xr)|6,cop09|; jump to exit if all done|16856
||mov|8,wb|8,wc||; else copy offset|16857
||sub|8,wb|19,*tenxt||; subtract link offset to merge|16858
||add|7,xr|8,wb||; next bucket header less link offset|16859
||ica|8,wc|||; bump offset|16860
;
;      loop through teblks on one chain
;
|cop07|mov|7,xl|13,tenxt(xr)||; load pointer to next teblk|16864
||mov|13,tenxt(xr)|9,(xs)||; set end of chain pointer in case|16865
||beq|9,(xl)|22,=b_tbt|6,cop06|; back for next bucket if chain end|16866
||sub|7,xr|8,wb||; point to head of previous block|16867
||mov|11,-(xs)|7,xr||; stack ptr to previous block|16868
||mov|8,wa|19,*tesi_||; set size of teblk|16869
||jsr|6,alloc|||; allocate new teblk|16870
||mov|11,-(xs)|7,xr||; stack ptr to new teblk|16871
||mvw||||; copy old teblk to new teblk|16872
||mov|7,xr|10,(xs)+||; restore pointer to new teblk|16873
||mov|7,xl|10,(xs)+||; restore pointer to previous block|16874
||add|7,xl|8,wb||; add offset back in|16875
||mov|13,tenxt(xl)|7,xr||; link new block to previous|16876
||mov|7,xl|7,xr||; copy pointer to new block|16877
;
;      loop to set real value after removing trap chain
;
|cop08|mov|7,xl|13,teval(xl)||; load value|16881
||beq|9,(xl)|22,=b_trt|6,cop08|; loop back if trapped|16882
||mov|13,teval(xr)|7,xl||; store untrapped value in teblk|16883
||zer|8,wb|||; zero offset within teblk|16884
||brn|6,cop07|||; back for next teblk|16885
;
;      common exit point
;
|cop09|mov|7,xr|10,(xs)+||; load pointer to block|16889
||exi||||; return|16890
;
;      alternative return
;
|cop10|exi|1,1|||; return|16894
||ejc|||||16895
||enp||||; end procedure copyb|16913
;
;      cdgcg -- generate code for complex goto
;
;      used by cmpil to process complex goto tree
;
;      (wb)		     must be collectable
;      (xr)		     expression pointer
;      jsr  cdgcg	     call to generate complex goto
;      (xl,xr,wa)	     destroyed
;
|cdgcg|prc|25,e|1,0||; entry point|16924
||mov|7,xl|13,cmopn(xr)||; get unary goto operator|16925
||mov|7,xr|13,cmrop(xr)||; point to goto operand|16926
||beq|7,xl|21,=opdvd|6,cdgc2|; jump if direct goto|16927
||jsr|6,cdgnm|||; generate opnd by name if not direct|16928
;
;      return point
;
|cdgc1|mov|8,wa|7,xl||; goto operator|16932
||jsr|6,cdwrd|||; generate it|16933
||exi||||; return to caller|16934
;
;      direct goto
;
|cdgc2|jsr|6,cdgvl|||; generate operand by value|16938
||brn|6,cdgc1|||; merge to return|16939
||enp||||; end procedure cdgcg|16940
||ejc|||||16941
;
;      cdgex -- build expression block
;
;      cdgex is passed a pointer to an expression tree (see
;      expan) and returns an expression (seblk or exblk).
;
;      (wa)		     0 if by value, 1 if by name
;      (wc)		     some collectable value
;      (wb)		     integer in range 0 le x le mxlen
;      (xl)		     ptr to expression tree
;      jsr  cdgex	     call to build expression
;      (xr)		     ptr to seblk or exblk
;      (xl,wa,wb)	     destroyed
;
|cdgex|prc|25,r|1,0||; entry point, recursive|16958
||blo|9,(xl)|22,=b_vr_|6,cdgx1|; jump if not variable|16959
;
;      here for natural variable, build seblk
;
||mov|8,wa|19,*sesi_||; set size of seblk|16963
||jsr|6,alloc|||; allocate space for seblk|16964
||mov|9,(xr)|22,=b_sel||; set type word|16965
||mov|13,sevar(xr)|7,xl||; store vrblk pointer|16966
||exi||||; return to cdgex caller|16967
;
;      here if not variable, build exblk
;
|cdgx1|mov|7,xr|7,xl||; copy tree pointer|16971
||mov|11,-(xs)|8,wc||; save wc|16972
||mov|7,xl|3,cwcof||; save current offset|16973
||bze|8,wa|6,cdgx2||; jump if by value|16975
||mov|8,wa|9,(xr)||; get type word|16977
||bne|8,wa|22,=b_cmt|6,cdgx2|; call by value if not cmblk|16978
||bge|13,cmtyp(xr)|18,=c__nm|6,cdgx2|; jump if cmblk only by value|16979
||ejc|||||16980
;
;      cdgex (continued)
;
;      here if expression can be evaluated by name
;
||jsr|6,cdgnm|||; generate code by name|16986
||mov|8,wa|21,=ornm_||; load return by name word|16987
||brn|6,cdgx3|||; merge with value case|16988
;
;      here if expression can only be evaluated by value
;
|cdgx2|jsr|6,cdgvl|||; generate code by value|16992
||mov|8,wa|21,=orvl_||; load return by value word|16993
;
;      merge here to construct exblk
;
|cdgx3|jsr|6,cdwrd|||; generate return word|16997
||jsr|6,exbld|||; build exblk|16998
||mov|8,wc|10,(xs)+||; restore wc|16999
||exi||||; return to cdgex caller|17000
||enp||||; end procedure cdgex|17001
||ejc|||||17002
;
;      cdgnm -- generate code by name
;
;      cdgnm is called during the compilation process to
;      generate code by name for an expression. see cdblk
;      description for details of code generated. the input
;      to cdgnm is an expression tree as generated by expan.
;
;      cdgnm is a recursive procedure which proceeds by making
;      recursive calls to generate code for operands.
;
;      (wb)		     integer in range 0 le n le dnamb
;      (xr)		     ptr to tree generated by expan
;      (wc)		     constant flag (see below)
;      jsr  cdgnm	     call to generate code by name
;      (xr,wa)		     destroyed
;      (wc)		     set non-zero if non-constant
;
;      wc is set to a non-zero (collectable) value if the
;      expression for which code is generated cannot be
;      evaluated at compile time, otherwise wc is unchanged.
;
;      the code is generated in the current ccblk (see cdwrd).
;
|cdgnm|prc|25,r|1,0||; entry point, recursive|17027
||mov|11,-(xs)|7,xl||; save entry xl|17028
||mov|11,-(xs)|8,wb||; save entry wb|17029
||chk||||; check for stack overflow|17030
||mov|8,wa|9,(xr)||; load type word|17031
||beq|8,wa|22,=b_cmt|6,cgn04|; jump if cmblk|17032
||bhi|8,wa|22,=b_vr_|6,cgn02|; jump if simple variable|17033
;
;      merge here for operand yielding value (e.g. constant)
;
|cgn01|erb|1,212|26,syntax error: value used where name is required|||17037
;
;      here for natural variable reference
;
|cgn02|mov|8,wa|21,=olvn_||; load variable load call|17041
||jsr|6,cdwrd|||; generate it|17042
||mov|8,wa|7,xr||; copy vrblk pointer|17043
||jsr|6,cdwrd|||; generate vrblk pointer|17044
||ejc|||||17045
;
;      cdgnm (continued)
;
;      here to exit with wc set correctly
;
|cgn03|mov|8,wb|10,(xs)+||; restore entry wb|17051
||mov|7,xl|10,(xs)+||; restore entry xl|17052
||exi||||; return to cdgnm caller|17053
;
;      here for cmblk
;
|cgn04|mov|7,xl|7,xr||; copy cmblk pointer|17057
||mov|7,xr|13,cmtyp(xr)||; load cmblk type|17058
||bge|7,xr|18,=c__nm|6,cgn01|; error if not name operand|17059
||bsw|7,xr|2,c__nm||; else switch on type|17060
||iff|2,c_arr|6,cgn05||; array reference|17068
||iff|2,c_fnc|6,cgn08||; function call|17068
||iff|2,c_def|6,cgn09||; deferred expression|17068
||iff|2,c_ind|6,cgn10||; indirect reference|17068
||iff|2,c_key|6,cgn11||; keyword reference|17068
||iff|2,c_ubo|6,cgn08||; undefined binary op|17068
||iff|2,c_uuo|6,cgn08||; undefined unary op|17068
||esw||||; end switch on cmblk type|17068
;
;      here to generate code for array reference
;
|cgn05|mov|8,wb|19,*cmopn||; point to array operand|17072
;
;      loop to generate code for array operand and subscripts
;
|cgn06|jsr|6,cmgen|||; generate code for next operand|17076
||mov|8,wc|13,cmlen(xl)||; load length of cmblk|17077
||blt|8,wb|8,wc|6,cgn06|; loop till all generated|17078
;
;      generate appropriate array call
;
||mov|8,wa|21,=oaon_||; load one-subscript case call|17082
||beq|8,wc|19,*cmar1|6,cgn07|; jump to exit if one subscript case|17083
||mov|8,wa|21,=oamn_||; else load multi-subscript case call|17084
||jsr|6,cdwrd|||; generate call|17085
||mov|8,wa|8,wc||; copy cmblk length|17086
||btw|8,wa|||; convert to words|17087
||sub|8,wa|18,=cmvls||; calculate number of subscripts|17088
||ejc|||||17089
;
;      cdgnm (continued)
;
;      here to exit generating word (non-constant)
;
|cgn07|mnz|8,wc|||; set result non-constant|17095
||jsr|6,cdwrd|||; generate word|17096
||brn|6,cgn03|||; back to exit|17097
;
;      here to generate code for functions and undefined oprs
;
|cgn08|mov|7,xr|7,xl||; copy cmblk pointer|17101
||jsr|6,cdgvl|||; gen code by value for call|17102
||mov|8,wa|21,=ofne_||; get extra call for by name|17103
||brn|6,cgn07|||; back to generate and exit|17104
;
;      here to generate code for defered expression
;
|cgn09|mov|7,xr|13,cmrop(xl)||; check if variable|17108
||bhi|9,(xr)|22,=b_vr_|6,cgn02|; treat *variable as simple var|17109
||mov|7,xl|7,xr||; copy ptr to expression tree|17110
||mov|8,wa|18,=num01||; return name|17112
||jsr|6,cdgex|||; else build exblk|17114
||mov|8,wa|21,=olex_||; set call to load expr by name|17115
||jsr|6,cdwrd|||; generate it|17116
||mov|8,wa|7,xr||; copy exblk pointer|17117
||jsr|6,cdwrd|||; generate exblk pointer|17118
||brn|6,cgn03|||; back to exit|17119
;
;      here to generate code for indirect reference
;
|cgn10|mov|7,xr|13,cmrop(xl)||; get operand|17123
||jsr|6,cdgvl|||; generate code by value for it|17124
||mov|8,wa|21,=oinn_||; load call for indirect by name|17125
||brn|6,cgn12|||; merge|17126
;
;      here to generate code for keyword reference
;
|cgn11|mov|7,xr|13,cmrop(xl)||; get operand|17130
||jsr|6,cdgnm|||; generate code by name for it|17131
||mov|8,wa|21,=okwn_||; load call for keyword by name|17132
;
;      keyword, indirect merge here
;
|cgn12|jsr|6,cdwrd|||; generate code for operator|17136
||brn|6,cgn03|||; exit|17137
||enp||||; end procedure cdgnm|17138
||ejc|||||17139
;
;      cdgvl -- generate code by value
;
;      cdgvl is called during the compilation process to
;      generate code by value for an expression. see cdblk
;      description for details of the code generated. the input
;      to cdgvl is an expression tree as generated by expan.
;
;      cdgvl is a recursive procedure which proceeds by making
;      recursive calls to generate code for operands.
;
;      (wb)		     integer in range 0 le n le dnamb
;      (xr)		     ptr to tree generated by expan
;      (wc)		     constant flag (see below)
;      jsr  cdgvl	     call to generate code by value
;      (xr,wa)		     destroyed
;      (wc)		     set non-zero if non-constant
;
;      wc is set to a non-zero (collectable) value if the
;      expression for which code is generated cannot be
;      evaluated at compile time, otherwise wc is unchanged.
;
;      if wc is non-zero on entry, then preevaluation is not
;      allowed regardless of the nature of the operand.
;
;      the code is generated in the current ccblk (see cdwrd).
;
|cdgvl|prc|25,r|1,0||; entry point, recursive|17167
||mov|8,wa|9,(xr)||; load type word|17168
||beq|8,wa|22,=b_cmt|6,cgv01|; jump if cmblk|17169
||blt|8,wa|22,=b_vra|6,cgv00|; jump if icblk, rcblk, scblk|17170
||bnz|13,vrlen(xr)|6,cgvl0||; jump if not system variable|17171
||mov|11,-(xs)|7,xr||; stack xr|17172
||mov|7,xr|13,vrsvp(xr)||; point to svblk|17173
||mov|8,wa|13,svbit(xr)||; get svblk property bits|17174
||mov|7,xr|10,(xs)+||; recover xr|17175
||anb|8,wa|4,btkwv||; check if constant keyword value|17176
||beq|8,wa|4,btkwv|6,cgv00|; jump if constant keyword value|17177
;
;      here for variable value reference
;
|cgvl0|mnz|8,wc|||; indicate non-constant value|17181
;
;      merge here for simple constant (icblk,rcblk,scblk)
;      and for variables corresponding to constant keywords.
;
|cgv00|mov|8,wa|7,xr||; copy ptr to var or constant|17186
||jsr|6,cdwrd|||; generate as code word|17187
||exi||||; return to caller|17188
||ejc|||||17189
;
;      cdgvl (continued)
;
;      here for tree node (cmblk)
;
|cgv01|mov|11,-(xs)|8,wb||; save entry wb|17195
||mov|11,-(xs)|7,xl||; save entry xl|17196
||mov|11,-(xs)|8,wc||; save entry constant flag|17197
||mov|11,-(xs)|3,cwcof||; save initial code offset|17198
||chk||||; check for stack overflow|17199
;
;      prepare to generate code for cmblk. wc is set to the
;      value of cswno (zero if -optimise, 1 if -noopt) to
;      start with and is reset non-zero for any non-constant
;      code generated. if it is still zero after generating all
;      the cmblk code, then its value is computed as the result.
;
||mov|7,xl|7,xr||; copy cmblk pointer|17207
||mov|7,xr|13,cmtyp(xr)||; load cmblk type|17208
||mov|8,wc|3,cswno||; reset constant flag|17209
||ble|7,xr|18,=c_pr_|6,cgv02|; jump if not predicate value|17210
||mnz|8,wc|||; else force non-constant case|17211
;
;      here with wc set appropriately
;
|cgv02|bsw|7,xr|2,c__nv||; switch to appropriate generator|17215
||iff|2,c_arr|6,cgv03||; array reference|17235
||iff|2,c_fnc|6,cgv05||; function call|17235
||iff|2,c_def|6,cgv14||; deferred expression|17235
||iff|2,c_ind|6,cgv31||; indirect reference|17235
||iff|2,c_key|6,cgv27||; keyword reference|17235
||iff|2,c_ubo|6,cgv29||; undefined binop|17235
||iff|2,c_uuo|6,cgv30||; undefined unop|17235
||iff|2,c_bvl|6,cgv18||; binops with val opds|17235
||iff|2,c_uvl|6,cgv19||; unops with valu opnd|17235
||iff|2,c_alt|6,cgv18||; alternation|17235
||iff|2,c_cnc|6,cgv24||; concatenation|17235
||iff|2,c_cnp|6,cgv24||; concatenation (not pattern match)|17235
||iff|2,c_unm|6,cgv27||; unops with name opnd|17235
||iff|2,c_bvn|6,cgv26||; binary _ and .|17235
||iff|2,c_ass|6,cgv21||; assignment|17235
||iff|2,c_int|6,cgv31||; interrogation|17235
||iff|2,c_neg|6,cgv28||; negation|17235
||iff|2,c_sel|6,cgv15||; selection|17235
||iff|2,c_pmt|6,cgv18||; pattern match|17235
||esw||||; end switch on cmblk type|17235
||ejc|||||17236
;
;      cdgvl (continued)
;
;      here to generate code for array reference
;
|cgv03|mov|8,wb|19,*cmopn||; set offset to array operand|17242
;
;      loop to generate code for array operand and subscripts
;
|cgv04|jsr|6,cmgen|||; gen value code for next operand|17246
||mov|8,wc|13,cmlen(xl)||; load cmblk length|17247
||blt|8,wb|8,wc|6,cgv04|; loop back if more to go|17248
;
;      generate call to appropriate array reference routine
;
||mov|8,wa|21,=oaov_||; set one subscript call in case|17252
||beq|8,wc|19,*cmar1|6,cgv32|; jump to exit if 1-sub case|17253
||mov|8,wa|21,=oamv_||; else set call for multi-subscripts|17254
||jsr|6,cdwrd|||; generate call|17255
||mov|8,wa|8,wc||; copy length of cmblk|17256
||sub|8,wa|19,*cmvls||; subtract standard length|17257
||btw|8,wa|||; get number of words|17258
||brn|6,cgv32|||; jump to generate subscript count|17259
;
;      here to generate code for function call
;
|cgv05|mov|8,wb|19,*cmvls||; set offset to first argument|17263
;
;      loop to generate code for arguments
;
|cgv06|beq|8,wb|13,cmlen(xl)|6,cgv07|; jump if all generated|17267
||jsr|6,cmgen|||; else gen value code for next arg|17268
||brn|6,cgv06|||; back to generate next argument|17269
;
;      here to generate actual function call
;
|cgv07|sub|8,wb|19,*cmvls||; get number of arg ptrs (bytes)|17273
||btw|8,wb|||; convert bytes to words|17274
||mov|7,xr|13,cmopn(xl)||; load function vrblk pointer|17275
||bnz|13,vrlen(xr)|6,cgv12||; jump if not system function|17276
||mov|7,xl|13,vrsvp(xr)||; load svblk ptr if system var|17277
||mov|8,wa|13,svbit(xl)||; load bit mask|17278
||anb|8,wa|4,btffc||; test for fast function call allowed|17279
||zrb|8,wa|6,cgv12||; jump if not|17280
||ejc|||||17281
;
;      cdgvl (continued)
;
;      here if fast function call is allowed
;
||mov|8,wa|13,svbit(xl)||; reload bit indicators|17287
||anb|8,wa|4,btpre||; test for preevaluation ok|17288
||nzb|8,wa|6,cgv08||; jump if preevaluation permitted|17289
||mnz|8,wc|||; else set result non-constant|17290
;
;      test for correct number of args for fast call
;
|cgv08|mov|7,xl|13,vrfnc(xr)||; load ptr to svfnc field|17294
||mov|8,wa|13,fargs(xl)||; load svnar field value|17295
||beq|8,wa|8,wb|6,cgv11|; jump if argument count is correct|17296
||bhi|8,wa|8,wb|6,cgv09|; jump if too few arguments given|17297
;
;      here if too many arguments, prepare to generate o_pops
;
||sub|8,wb|8,wa||; get number of extra args|17301
||lct|8,wb|8,wb||; set as count to control loop|17302
||mov|8,wa|21,=opop_||; set pop call|17303
||brn|6,cgv10|||; jump to common loop|17304
;
;      here if too few arguments, prepare to generate nulls
;
|cgv09|sub|8,wa|8,wb||; get number of missing arguments|17308
||lct|8,wb|8,wa||; load as count to control loop|17309
||mov|8,wa|21,=nulls||; load ptr to null constant|17310
;
;      loop to generate calls to fix argument count
;
|cgv10|jsr|6,cdwrd|||; generate one call|17314
||bct|8,wb|6,cgv10||; loop till all generated|17315
;
;      here after adjusting arg count as required
;
|cgv11|mov|8,wa|7,xl||; copy pointer to svfnc field|17319
||brn|6,cgv36|||; jump to generate call|17320
||ejc|||||17321
;
;      cdgvl (continued)
;
;      come here if fast call is not permitted
;
|cgv12|mov|8,wa|21,=ofns_||; set one arg call in case|17327
||beq|8,wb|18,=num01|6,cgv13|; jump if one arg case|17328
||mov|8,wa|21,=ofnc_||; else load call for more than 1 arg|17329
||jsr|6,cdwrd|||; generate it|17330
||mov|8,wa|8,wb||; copy argument count|17331
;
;      one arg case merges here
;
|cgv13|jsr|6,cdwrd|||; generate =o_fns or arg count|17335
||mov|8,wa|7,xr||; copy vrblk pointer|17336
||brn|6,cgv32|||; jump to generate vrblk ptr|17337
;
;      here for deferred expression
;
|cgv14|mov|7,xl|13,cmrop(xl)||; point to expression tree|17341
||zer|8,wa|||; return value|17343
||jsr|6,cdgex|||; build exblk or seblk|17345
||mov|8,wa|7,xr||; copy block ptr|17346
||jsr|6,cdwrd|||; generate ptr to exblk or seblk|17347
||brn|6,cgv34|||; jump to exit, constant test|17348
;
;      here to generate code for selection
;
|cgv15|zer|11,-(xs)|||; zero ptr to chain of forward jumps|17352
||zer|11,-(xs)|||; zero ptr to prev o_slc forward ptr|17353
||mov|8,wb|19,*cmvls||; point to first alternative|17354
||mov|8,wa|21,=osla_||; set initial code word|17355
;
;      0(xs)		     is the offset to the previous word
;			     which requires filling in with an
;			     offset to the following o_slc,o_sld
;
;      1(xs)		     is the head of a chain of offset
;			     pointers indicating those locations
;			     to be filled with offsets past
;			     the end of all the alternatives
;
|cgv16|jsr|6,cdwrd|||; generate o_slc (o_sla first time)|17366
||mov|9,(xs)|3,cwcof||; set current loc as ptr to fill in|17367
||jsr|6,cdwrd|||; generate garbage word there for now|17368
||jsr|6,cmgen|||; gen value code for alternative|17369
||mov|8,wa|21,=oslb_||; load o_slb pointer|17370
||jsr|6,cdwrd|||; generate o_slb call|17371
||mov|8,wa|13,num01(xs)||; load old chain ptr|17372
||mov|13,num01(xs)|3,cwcof||; set current loc as new chain head|17373
||jsr|6,cdwrd|||; generate forward chain link|17374
||ejc|||||17375
;
;      cdgvl (continued)
;
;      now to fill in the skip offset to o_slc,o_sld
;
||mov|7,xr|9,(xs)||; load offset to word to plug|17381
||add|7,xr|3,r_ccb||; point to actual location to plug|17382
||mov|9,(xr)|3,cwcof||; plug proper offset in|17383
||mov|8,wa|21,=oslc_||; load o_slc ptr for next alternative|17384
||mov|7,xr|8,wb||; copy offset (destroy garbage xr)|17385
||ica|7,xr|||; bump extra time for test|17386
||blt|7,xr|13,cmlen(xl)|6,cgv16|; loop back if not last alternative|17387
;
;      here to generate code for last alternative
;
||mov|8,wa|21,=osld_||; get header call|17391
||jsr|6,cdwrd|||; generate o_sld call|17392
||jsr|6,cmgen|||; generate code for last alternative|17393
||ica|7,xs|||; pop offset ptr|17394
||mov|7,xr|10,(xs)+||; load chain ptr|17395
;
;      loop to plug offsets past structure
;
|cgv17|add|7,xr|3,r_ccb||; make next ptr absolute|17399
||mov|8,wa|9,(xr)||; load forward ptr|17400
||mov|9,(xr)|3,cwcof||; plug required offset|17401
||mov|7,xr|8,wa||; copy forward ptr|17402
||bnz|8,wa|6,cgv17||; loop back if more to go|17403
||brn|6,cgv33|||; else jump to exit (not constant)|17404
;
;      here for binary ops with value operands
;
|cgv18|mov|7,xr|13,cmlop(xl)||; load left operand pointer|17408
||jsr|6,cdgvl|||; gen value code for left operand|17409
;
;      here for unary ops with value operand (binops merge)
;
|cgv19|mov|7,xr|13,cmrop(xl)||; load right (only) operand ptr|17413
||jsr|6,cdgvl|||; gen code by value|17414
||ejc|||||17415
;
;      cdgvl (continued)
;
;      merge here to generate operator call from cmopn field
;
|cgv20|mov|8,wa|13,cmopn(xl)||; load operator call pointer|17421
||brn|6,cgv36|||; jump to generate it with cons test|17422
;
;      here for assignment
;
|cgv21|mov|7,xr|13,cmlop(xl)||; load left operand pointer|17426
||blo|9,(xr)|22,=b_vr_|6,cgv22|; jump if not variable|17427
;
;      here for assignment to simple variable
;
||mov|7,xr|13,cmrop(xl)||; load right operand ptr|17431
||jsr|6,cdgvl|||; generate code by value|17432
||mov|8,wa|13,cmlop(xl)||; reload left operand vrblk ptr|17433
||add|8,wa|19,*vrsto||; point to vrsto field|17434
||brn|6,cgv32|||; jump to generate store ptr|17435
;
;      here if not simple variable assignment
;
|cgv22|jsr|6,expap|||; test for pattern match on left side|17439
||ppm|6,cgv23|||; jump if not pattern match|17440
;
;      here for pattern replacement
;
||mov|13,cmlop(xl)|13,cmrop(xr)||; save pattern ptr in safe place|17444
||mov|7,xr|13,cmlop(xr)||; load subject ptr|17445
||jsr|6,cdgnm|||; gen code by name for subject|17446
||mov|7,xr|13,cmlop(xl)||; load pattern ptr|17447
||jsr|6,cdgvl|||; gen code by value for pattern|17448
||mov|8,wa|21,=opmn_||; load match by name call|17449
||jsr|6,cdwrd|||; generate it|17450
||mov|7,xr|13,cmrop(xl)||; load replacement value ptr|17451
||jsr|6,cdgvl|||; gen code by value|17452
||mov|8,wa|21,=orpl_||; load replace call|17453
||brn|6,cgv32|||; jump to gen and exit (not constant)|17454
;
;      here for assignment to complex variable
;
|cgv23|mnz|8,wc|||; inhibit pre-evaluation|17458
||jsr|6,cdgnm|||; gen code by name for left side|17459
||brn|6,cgv31|||; merge with unop circuit|17460
||ejc|||||17461
;
;      cdgvl (continued)
;
;      here for concatenation
;
|cgv24|mov|7,xr|13,cmlop(xl)||; load left operand ptr|17467
||bne|9,(xr)|22,=b_cmt|6,cgv18|; ordinary binop if not cmblk|17468
||mov|8,wb|13,cmtyp(xr)||; load cmblk type code|17469
||beq|8,wb|18,=c_int|6,cgv25|; special case if interrogation|17470
||beq|8,wb|18,=c_neg|6,cgv25|; or negation|17471
||bne|8,wb|18,=c_fnc|6,cgv18|; else ordinary binop if not function|17472
||mov|7,xr|13,cmopn(xr)||; else load function vrblk ptr|17473
||bnz|13,vrlen(xr)|6,cgv18||; ordinary binop if not system var|17474
||mov|7,xr|13,vrsvp(xr)||; else point to svblk|17475
||mov|8,wa|13,svbit(xr)||; load bit indicators|17476
||anb|8,wa|4,btprd||; test for predicate function|17477
||zrb|8,wa|6,cgv18||; ordinary binop if not|17478
;
;      here if left arg of concatenation is predicate function
;
|cgv25|mov|7,xr|13,cmlop(xl)||; reload left arg|17482
||jsr|6,cdgvl|||; gen code by value|17483
||mov|8,wa|21,=opop_||; load pop call|17484
||jsr|6,cdwrd|||; generate it|17485
||mov|7,xr|13,cmrop(xl)||; load right operand|17486
||jsr|6,cdgvl|||; gen code by value as result code|17487
||brn|6,cgv33|||; exit (not constant)|17488
;
;      here to generate code for pattern, immediate assignment
;
|cgv26|mov|7,xr|13,cmlop(xl)||; load left operand|17492
||jsr|6,cdgvl|||; gen code by value, merge|17493
;
;      here for unops with arg by name (binary _ . merge)
;
|cgv27|mov|7,xr|13,cmrop(xl)||; load right operand ptr|17497
||jsr|6,cdgnm|||; gen code by name for right arg|17498
||mov|7,xr|13,cmopn(xl)||; get operator code word|17499
||bne|9,(xr)|22,=o_kwv|6,cgv20|; gen call unless keyword value|17500
||ejc|||||17501
;
;      cdgvl (continued)
;
;      here for keyword by value. this is constant only if
;      the operand is one of the special system variables with
;      the svckw bit set to indicate a constant keyword value.
;      note that the only constant operand by name is a variable
;
||bnz|8,wc|6,cgv20||; gen call if non-constant (not var)|17510
||mnz|8,wc|||; else set non-constant in case|17511
||mov|7,xr|13,cmrop(xl)||; load ptr to operand vrblk|17512
||bnz|13,vrlen(xr)|6,cgv20||; gen (non-constant) if not sys var|17513
||mov|7,xr|13,vrsvp(xr)||; else load ptr to svblk|17514
||mov|8,wa|13,svbit(xr)||; load bit mask|17515
||anb|8,wa|4,btckw||; test for constant keyword|17516
||zrb|8,wa|6,cgv20||; go gen if not constant|17517
||zer|8,wc|||; else set result constant|17518
||brn|6,cgv20|||; and jump back to generate call|17519
;
;      here to generate code for negation
;
|cgv28|mov|8,wa|21,=onta_||; get initial word|17523
||jsr|6,cdwrd|||; generate it|17524
||mov|8,wb|3,cwcof||; save next offset|17525
||jsr|6,cdwrd|||; generate gunk word for now|17526
||mov|7,xr|13,cmrop(xl)||; load right operand ptr|17527
||jsr|6,cdgvl|||; gen code by value|17528
||mov|8,wa|21,=ontb_||; load end of evaluation call|17529
||jsr|6,cdwrd|||; generate it|17530
||mov|7,xr|8,wb||; copy offset to word to plug|17531
||add|7,xr|3,r_ccb||; point to actual word to plug|17532
||mov|9,(xr)|3,cwcof||; plug word with current offset|17533
||mov|8,wa|21,=ontc_||; load final call|17534
||brn|6,cgv32|||; jump to generate it (not constant)|17535
;
;      here to generate code for undefined binary operator
;
|cgv29|mov|7,xr|13,cmlop(xl)||; load left operand ptr|17539
||jsr|6,cdgvl|||; generate code by value|17540
||ejc|||||17541
;
;      cdgvl (continued)
;
;      here to generate code for undefined unary operator
;
|cgv30|mov|8,wb|18,=c_uo_||; set unop code + 1|17547
||sub|8,wb|13,cmtyp(xl)||; set number of args (1 or 2)|17548
;
;      merge here for undefined operators
;
||mov|7,xr|13,cmrop(xl)||; load right (only) operand pointer|17552
||jsr|6,cdgvl|||; gen value code for right operand|17553
||mov|7,xr|13,cmopn(xl)||; load pointer to operator dv|17554
||mov|7,xr|13,dvopn(xr)||; load pointer offset|17555
||wtb|7,xr|||; convert word offset to bytes|17556
||add|7,xr|20,=r_uba||; point to proper function ptr|17557
||sub|7,xr|19,*vrfnc||; set standard function offset|17558
||brn|6,cgv12|||; merge with function call circuit|17559
;
;      here to generate code for interrogation, indirection
;
|cgv31|mnz|8,wc|||; set non constant|17563
||brn|6,cgv19|||; merge|17564
;
;      here to exit generating a word, result not constant
;
|cgv32|jsr|6,cdwrd|||; generate word, merge|17568
;
;      here to exit with no word generated, not constant
;
|cgv33|mnz|8,wc|||; indicate result is not constant|17572
;
;      common exit point
;
|cgv34|ica|7,xs|||; pop initial code offset|17576
||mov|8,wa|10,(xs)+||; restore old constant flag|17577
||mov|7,xl|10,(xs)+||; restore entry xl|17578
||mov|8,wb|10,(xs)+||; restore entry wb|17579
||bnz|8,wc|6,cgv35||; jump if not constant|17580
||mov|8,wc|8,wa||; else restore entry constant flag|17581
;
;      here to return after dealing with wc setting
;
|cgv35|exi||||; return to cdgvl caller|17585
;
;      exit here to generate word and test for constant
;
|cgv36|jsr|6,cdwrd|||; generate word|17589
||bnz|8,wc|6,cgv34||; jump to exit if not constant|17590
||ejc|||||17591
;
;      cdgvl (continued)
;
;      here to preevaluate constant sub-expression
;
||mov|8,wa|21,=orvl_||; load call to return value|17597
||jsr|6,cdwrd|||; generate it|17598
||mov|7,xl|9,(xs)||; load initial code offset|17599
||jsr|6,exbld|||; build exblk for expression|17600
||zer|8,wb|||; set to evaluate by value|17601
||jsr|6,evalx|||; evaluate expression|17602
||ppm||||; should not fail|17603
||mov|8,wa|9,(xr)||; load type word of result|17604
||blo|8,wa|22,=p_aaa|6,cgv37|; jump if not pattern|17605
||mov|8,wa|21,=olpt_||; else load special pattern load call|17606
||jsr|6,cdwrd|||; generate it|17607
;
;      merge here to generate pointer to resulting constant
;
|cgv37|mov|8,wa|7,xr||; copy constant pointer|17611
||jsr|6,cdwrd|||; generate ptr|17612
||zer|8,wc|||; set result constant|17613
||brn|6,cgv34|||; jump back to exit|17614
||enp||||; end procedure cdgvl|17615
||ejc|||||17616
;
;      cdwrd -- generate one word of code
;
;      cdwrd writes one word into the current code block under
;      construction. a new, larger, block is allocated if there
;      is insufficient room in the current block. cdwrd ensures
;      that there are at least four words left in the block
;      after entering the new word. this guarantees that any
;      extra space at the end can be split off as a ccblk.
;
;      (wa)		     word to be generated
;      jsr  cdwrd	     call to generate word
;
|cdwrd|prc|25,e|1,0||; entry point|17634
||mov|11,-(xs)|7,xr||; save entry xr|17635
||mov|11,-(xs)|8,wa||; save code word to be generated|17636
;
;      merge back here after allocating larger block
;
|cdwd1|mov|7,xr|3,r_ccb||; load ptr to ccblk being built|17640
||bnz|7,xr|6,cdwd2||; jump if block allocated|17641
;
;      here we allocate an entirely fresh block
;
||mov|8,wa|19,*e_cbs||; load initial length|17645
||jsr|6,alloc|||; allocate ccblk|17646
||mov|9,(xr)|22,=b_cct||; store type word|17647
||mov|3,cwcof|19,*cccod||; set initial offset|17648
||mov|13,cclen(xr)|8,wa||; store block length|17649
||zer|13,ccsln(xr)|||; zero line number|17651
||mov|3,r_ccb|7,xr||; store ptr to new block|17653
;
;      here we have a block we can use
;
|cdwd2|mov|8,wa|3,cwcof||; load current offset|17657
||add|8,wa|19,*num05||; adjust for test (five words)|17659
||blo|8,wa|13,cclen(xr)|6,cdwd4|; jump if room in this block|17663
;
;      here if no room in current block
;
||bge|8,wa|3,mxlen|6,cdwd5|; jump if already at max size|17667
||add|8,wa|19,*e_cbs||; else get new size|17668
||mov|11,-(xs)|7,xl||; save entry xl|17669
||mov|7,xl|7,xr||; copy pointer|17670
||blt|8,wa|3,mxlen|6,cdwd3|; jump if not too large|17671
||mov|8,wa|3,mxlen||; else reset to max allowed size|17672
||ejc|||||17673
;
;      cdwrd (continued)
;
;      here with new block size in wa
;
|cdwd3|jsr|6,alloc|||; allocate new block|17679
||mov|3,r_ccb|7,xr||; store pointer to new block|17680
||mov|10,(xr)+|22,=b_cct||; store type word in new block|17681
||mov|10,(xr)+|8,wa||; store block length|17682
||mov|10,(xr)+|13,ccsln(xl)||; copy source line number word|17684
||add|7,xl|19,*ccuse||; point to ccuse,cccod fields in old|17686
||mov|8,wa|9,(xl)||; load ccuse value|17687
||mvw||||; copy useful words from old block|17688
||mov|7,xl|10,(xs)+||; restore xl|17689
||brn|6,cdwd1|||; merge back to try again|17690
;
;      here with room in current block
;
|cdwd4|mov|8,wa|3,cwcof||; load current offset|17694
||ica|8,wa|||; get new offset|17695
||mov|3,cwcof|8,wa||; store new offset|17696
||mov|13,ccuse(xr)|8,wa||; store in ccblk for gbcol|17697
||dca|8,wa|||; restore ptr to this word|17698
||add|7,xr|8,wa||; point to current entry|17699
||mov|8,wa|10,(xs)+||; reload word to generate|17700
||mov|9,(xr)|8,wa||; store word in block|17701
||mov|7,xr|10,(xs)+||; restore entry xr|17702
||exi||||; return to caller|17703
;
;      here if compiled code is too long for cdblk
;
|cdwd5|erb|1,213|26,syntax error: statement is too complicated.|||17707
||enp||||; end procedure cdwrd|17708
||ejc|||||17709
;
;      cmgen -- generate code for cmblk ptr
;
;      cmgen is a subsidiary procedure used to generate value
;      code for a cmblk ptr from the main code generators.
;
;      (xl)		     cmblk pointer
;      (wb)		     offset to pointer in cmblk
;      jsr  cmgen	     call to generate code
;      (xr,wa)		     destroyed
;      (wb)		     bumped by one word
;
|cmgen|prc|25,r|1,0||; entry point, recursive|17722
||mov|7,xr|7,xl||; copy cmblk pointer|17723
||add|7,xr|8,wb||; point to cmblk pointer|17724
||mov|7,xr|9,(xr)||; load cmblk pointer|17725
||jsr|6,cdgvl|||; generate code by value|17726
||ica|8,wb|||; bump offset|17727
||exi||||; return to caller|17728
||enp||||; end procedure cmgen|17729
||ejc|||||17730
;
;      cmpil (compile source code)
;
;      cmpil is used to convert snobol4 source code to internal
;      form (see cdblk format). it is used both for the initial
;      compile and at run time by the code and convert functions
;      this procedure has control for the entire duration of
;      initial compilation. an error in any procedure called
;      during compilation will lead first to the error section
;      and ultimately back here for resumed compilation. the
;      re-entry points after an error are specially labelled -
;
;      cmpce		     resume after control card error
;      cmple		     resume after label error
;      cmpse		     resume after statement error
;
;      jsr  cmpil	     call to compile code
;      (xr)		     ptr to cdblk for entry statement
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      the following global variables are referenced
;
;      cmpln		     line number of first line of
;			     statement to be compiled
;
;      cmpsn		     number of next statement
;			     to be compiled.
;
;      cswxx		     control card switch values are
;			     changed when relevant control
;			     cards are met.
;
;      cwcof		     offset to next word in code block
;			     being built (see cdwrd).
;
;      lstsn		     number of statement most recently
;			     compiled (initially set to zero).
;
;      r_cim		     current (initial) compiler image
;			     (zero for initial compile call)
;
;      r_cni		     used to point to following image.
;			     (see readr procedure).
;
;      scngo		     goto switch for scane procedure
;
;      scnil		     length of current image excluding
;			     characters removed by -input.
;
;      scnpt		     current scan offset, see scane.
;
;      scnrs		     rescan switch for scane procedure.
;
;      scnse		     offset (in r_cim) of most recently
;			     scanned element. set zero if not
;			     currently scanning items
||ejc|||||17787
;
;      cmpil (continued)
;
;      stage		   stgic  initial compile in progress
;			   stgxc  code/convert compile
;			   stgev  building exblk for eval
;			   stgxt  execute time (outside compile)
;			   stgce  initial compile after end line
;			   stgxe  execute compile after end line
;
;      cmpil also uses a fixed number of locations on the
;      main stack as follows. (the definitions of the actual
;      offsets are in the definitions section).
;
;      cmstm(xs)	     pointer to expan tree for body of
;			     statement (see expan procedure).
;
;      cmsgo(xs)	     pointer to tree representation of
;			     success goto (see procedure scngo)
;			     zero if no success goto is given
;
;      cmfgo(xs)	     like cmsgo for failure goto.
;
;      cmcgo(xs)	     set non-zero only if there is a
;			     conditional goto. used for -fail,
;			     -nofail code generation.
;
;      cmpcd(xs)	     pointer to cdblk for previous
;			     statement. zero for 1st statement.
;
;      cmffp(xs)	     set non-zero if cdfal in previous
;			     cdblk needs filling with forward
;			     pointer, else set to zero.
;
;      cmffc(xs)	     same as cmffp for current cdblk
;
;      cmsop(xs)	     offset to word in previous cdblk
;			     to be filled in with forward ptr
;			     to next cdblk for success goto.
;			     zero if no fill in is required.
;
;      cmsoc(xs)	     same as cmsop for current cdblk.
;
;      cmlbl(xs)	     pointer to vrblk for label of
;			     current statement. zero if no label
;
;      cmtra(xs)	     pointer to cdblk for entry stmnt.
||ejc|||||17835
;
;      cmpil (continued)
;
;      entry point
;
|cmpil|prc|25,e|1,0||; entry point|17841
||lct|8,wb|18,=cmnen||; set number of stack work locations|17842
;
;      loop to initialize stack working locations
;
|cmp00|zer|11,-(xs)|||; store a zero, make one entry|17846
||bct|8,wb|6,cmp00||; loop back until all set|17847
||mov|3,cmpxs|7,xs||; save stack pointer for error sec|17848
||sss|3,cmpss|||; save s-r stack pointer if any|17849
;
;      loop through statements
;
|cmp01|mov|8,wb|3,scnpt||; set scan pointer offset|17853
||mov|3,scnse|8,wb||; set start of element location|17854
||mov|8,wa|21,=ocer_||; point to compile error call|17855
||jsr|6,cdwrd|||; generate as temporary cdfal|17856
||blt|8,wb|3,scnil|6,cmp04|; jump if chars left on this image|17857
;
;      loop here after comment or control card
;      also special entry after control card error
;
|cmpce|zer|7,xr|||; clear possible garbage xr value|17862
||bnz|3,cnind|6,cmpc2||; if within include file|17864
||bne|3,stage|18,=stgic|6,cmp02|; skip unless initial compile|17866
|cmpc2|jsr|6,readr|||; read next input image|17867
||bze|7,xr|6,cmp09||; jump if no input available|17868
||jsr|6,nexts|||; acquire next source image|17869
||mov|3,lstsn|3,cmpsn||; store stmt no for use by listr|17870
||mov|3,cmpln|3,rdcln||; store line number at start of stmt|17871
||zer|3,scnpt|||; reset scan pointer|17872
||brn|6,cmp04|||; go process image|17873
;
;      for execute time compile, permit embedded control cards
;      and comments (by skipping to next semi-colon)
;
|cmp02|mov|7,xr|3,r_cim||; get current image|17878
||mov|8,wb|3,scnpt||; get current offset|17879
||plc|7,xr|8,wb||; prepare to get chars|17880
;
;      skip to semi-colon
;
|cmp03|bge|3,scnpt|3,scnil|6,cmp09|; end loop if end of image|17884
||lch|8,wc|10,(xr)+||; get char|17885
||icv|3,scnpt|||; advance offset|17886
||bne|8,wc|18,=ch_sm|6,cmp03|; loop if not semi-colon|17887
||ejc|||||17888
;
;      cmpil (continued)
;
;      here with image available to scan. note that if the input
;      string is null, then everything is ok since null is
;      actually assembled as a word of blanks.
;
|cmp04|mov|7,xr|3,r_cim||; point to current image|17896
||mov|8,wb|3,scnpt||; load current offset|17897
||mov|8,wa|8,wb||; copy for label scan|17898
||plc|7,xr|8,wb||; point to first character|17899
||lch|8,wc|10,(xr)+||; load first character|17900
||beq|8,wc|18,=ch_sm|6,cmp12|; no label if semicolon|17901
||beq|8,wc|18,=ch_as|6,cmpce|; loop back if comment card|17902
||beq|8,wc|18,=ch_mn|6,cmp32|; jump if control card|17903
||mov|3,r_cmp|3,r_cim||; about to destroy r_cim|17904
||mov|7,xl|20,=cmlab||; point to label work string|17905
||mov|3,r_cim|7,xl||; scane is to scan work string|17906
||psc|7,xl|||; point to first character position|17907
||sch|8,wc|10,(xl)+||; store char just loaded|17908
||mov|8,wc|18,=ch_sm||; get a semicolon|17909
||sch|8,wc|9,(xl)||; store after first char|17910
||csc|7,xl|||; finished character storing|17911
||zer|7,xl|||; clear pointer|17912
||zer|3,scnpt|||; start at first character|17913
||mov|11,-(xs)|3,scnil||; preserve image length|17914
||mov|3,scnil|18,=num02||; read 2 chars at most|17915
||jsr|6,scane|||; scan first char for type|17916
||mov|3,scnil|10,(xs)+||; restore image length|17917
||mov|8,wc|7,xl||; note return code|17918
||mov|7,xl|3,r_cmp||; get old r_cim|17919
||mov|3,r_cim|7,xl||; put it back|17920
||mov|3,scnpt|8,wb||; reinstate offset|17921
||bnz|3,scnbl|6,cmp12||; blank seen - cant be label|17922
||mov|7,xr|7,xl||; point to current image|17923
||plc|7,xr|8,wb||; point to first char again|17924
||beq|8,wc|18,=t_var|6,cmp06|; ok if letter|17925
||beq|8,wc|18,=t_con|6,cmp06|; ok if digit|17926
;
;      drop in or jump from error section if scane failed
;
|cmple|mov|3,r_cim|3,r_cmp||; point to bad line|17930
||erb|1,214|26,bad label or misplaced continuation line|||17931
;
;      loop to scan label
;
|cmp05|beq|8,wc|18,=ch_sm|6,cmp07|; skip if semicolon|17935
||icv|8,wa|||; bump offset|17936
||beq|8,wa|3,scnil|6,cmp07|; jump if end of image (label end)|17937
||ejc|||||17938
;
;      cmpil (continued)
;
;      enter loop at this point
;
|cmp06|lch|8,wc|10,(xr)+||; else load next character|17944
||beq|8,wc|18,=ch_ht|6,cmp07|; jump if horizontal tab|17946
||bne|8,wc|18,=ch_bl|6,cmp05|; loop back if non-blank|17951
;
;      here after scanning out label
;
|cmp07|mov|3,scnpt|8,wa||; save updated scan offset|17955
||sub|8,wa|8,wb||; get length of label|17956
||bze|8,wa|6,cmp12||; skip if label length zero|17957
||zer|7,xr|||; clear garbage xr value|17958
||jsr|6,sbstr|||; build scblk for label name|17959
||jsr|6,gtnvr|||; locate/contruct vrblk|17960
||ppm||||; dummy (impossible) error return|17961
||mov|13,cmlbl(xs)|7,xr||; store label pointer|17962
||bnz|13,vrlen(xr)|6,cmp11||; jump if not system label|17963
||bne|13,vrsvp(xr)|21,=v_end|6,cmp11|; jump if not end label|17964
;
;      here for end label scanned out
;
||add|3,stage|18,=stgnd||; adjust stage appropriately|17968
||jsr|6,scane|||; scan out next element|17969
||beq|7,xl|18,=t_smc|6,cmp10|; jump if end of image|17970
||bne|7,xl|18,=t_var|6,cmp08|; else error if not variable|17971
;
;      here check for valid initial transfer
;
||beq|13,vrlbl(xr)|21,=stndl|6,cmp08|; jump if not defined (error)|17975
||mov|13,cmtra(xs)|13,vrlbl(xr)||; else set initial entry pointer|17976
||jsr|6,scane|||; scan next element|17977
||beq|7,xl|18,=t_smc|6,cmp10|; jump if ok (end of image)|17978
;
;      here for bad transfer label
;
|cmp08|erb|1,215|26,syntax error: undefined or erroneous entry label|||17982
;
;      here for end of input (no end label detected)
;
|cmp09|zer|7,xr|||; clear garbage xr value|17986
||add|3,stage|18,=stgnd||; adjust stage appropriately|17987
||beq|3,stage|18,=stgxe|6,cmp10|; jump if code call (ok)|17988
||erb|1,216|26,syntax error: missing end line|||17989
;
;      here after processing end line (merge here on end error)
;
|cmp10|mov|8,wa|21,=ostp_||; set stop call pointer|17993
||jsr|6,cdwrd|||; generate as statement call|17994
||brn|6,cmpse|||; jump to generate as failure|17995
||ejc|||||17996
;
;      cmpil (continued)
;
;      here after processing label other than end
;
|cmp11|bne|3,stage|18,=stgic|6,cmp12|; jump if code call - redef. ok|18002
||beq|13,vrlbl(xr)|21,=stndl|6,cmp12|; else check for redefinition|18003
||zer|13,cmlbl(xs)|||; leave first label decln undisturbed|18004
||erb|1,217|26,syntax error: duplicate label|||18005
;
;      here after dealing with label
;      null statements and statements just containing a
;      constant subject are optimized out by resetting the
;      current ccblk to empty.
;
|cmp12|zer|8,wb|||; set flag for statement body|18012
||jsr|6,expan|||; get tree for statement body|18013
||mov|13,cmstm(xs)|7,xr||; store for later use|18014
||zer|13,cmsgo(xs)|||; clear success goto pointer|18015
||zer|13,cmfgo(xs)|||; clear failure goto pointer|18016
||zer|13,cmcgo(xs)|||; clear conditional goto flag|18017
||jsr|6,scane|||; scan next element|18018
||beq|7,xl|18,=t_col|6,cmp13|; jump if colon (goto)|18019
||bnz|3,cswno|6,cmp18||; jump if not optimizing|18020
||bnz|13,cmlbl(xs)|6,cmp18||; jump if label present|18021
||mov|7,xr|13,cmstm(xs)||; load tree ptr for statement body|18022
||mov|8,wa|9,(xr)||; load type word|18023
||beq|8,wa|22,=b_cmt|6,cmp18|; jump if cmblk|18024
||bge|8,wa|22,=b_vra|6,cmp18|; jump if not icblk, scblk, or rcblk|18025
||mov|7,xl|3,r_ccb||; load ptr to ccblk|18026
||mov|13,ccuse(xl)|19,*cccod||; reset use offset in ccblk|18027
||mov|3,cwcof|19,*cccod||; and in global|18028
||icv|3,cmpsn|||; bump statement number|18029
||brn|6,cmp01|||; generate no code for statement|18030
;
;      loop to process goto fields
;
|cmp13|mnz|3,scngo|||; set goto flag|18034
||jsr|6,scane|||; scan next element|18035
||beq|7,xl|18,=t_smc|6,cmp31|; jump if no fields left|18036
||beq|7,xl|18,=t_sgo|6,cmp14|; jump if s for success goto|18037
||beq|7,xl|18,=t_fgo|6,cmp16|; jump if f for failure goto|18038
;
;      here for unconditional goto (i.e. not f or s)
;
||mnz|3,scnrs|||; set to rescan element not f,s|18042
||jsr|6,scngf|||; scan out goto field|18043
||bnz|13,cmfgo(xs)|6,cmp17||; error if fgoto already|18044
||mov|13,cmfgo(xs)|7,xr||; else set as fgoto|18045
||brn|6,cmp15|||; merge with sgoto circuit|18046
;
;      here for success goto
;
|cmp14|jsr|6,scngf|||; scan success goto field|18050
||mov|13,cmcgo(xs)|18,=num01||; set conditional goto flag|18051
;
;      uncontional goto merges here
;
|cmp15|bnz|13,cmsgo(xs)|6,cmp17||; error if sgoto already given|18055
||mov|13,cmsgo(xs)|7,xr||; else set sgoto|18056
||brn|6,cmp13|||; loop back for next goto field|18057
;
;      here for failure goto
;
|cmp16|jsr|6,scngf|||; scan goto field|18061
||mov|13,cmcgo(xs)|18,=num01||; set conditonal goto flag|18062
||bnz|13,cmfgo(xs)|6,cmp17||; error if fgoto already given|18063
||mov|13,cmfgo(xs)|7,xr||; else store fgoto pointer|18064
||brn|6,cmp13|||; loop back for next field|18065
||ejc|||||18066
;
;      cmpil (continued)
;
;      here for duplicated goto field
;
|cmp17|erb|1,218|26,syntax error: duplicated goto field|||18072
;
;      here to generate code
;
|cmp18|zer|3,scnse|||; stop positional error flags|18076
||mov|7,xr|13,cmstm(xs)||; load tree ptr for statement body|18077
||zer|8,wb|||; collectable value for wb for cdgvl|18078
||zer|8,wc|||; reset constant flag for cdgvl|18079
||jsr|6,expap|||; test for pattern match|18080
||ppm|6,cmp19|||; jump if not pattern match|18081
||mov|13,cmopn(xr)|21,=opms_||; else set pattern match pointer|18082
||mov|13,cmtyp(xr)|18,=c_pmt||;|18083
;
;      here after dealing with special pattern match case
;
|cmp19|jsr|6,cdgvl|||; generate code for body of statement|18087
||mov|7,xr|13,cmsgo(xs)||; load sgoto pointer|18088
||mov|8,wa|7,xr||; copy it|18089
||bze|7,xr|6,cmp21||; jump if no success goto|18090
||zer|13,cmsoc(xs)|||; clear success offset fillin ptr|18091
||bhi|7,xr|3,state|6,cmp20|; jump if complex goto|18092
;
;      here for simple success goto (label)
;
||add|8,wa|19,*vrtra||; point to vrtra field as required|18096
||jsr|6,cdwrd|||; generate success goto|18097
||brn|6,cmp22|||; jump to deal with fgoto|18098
;
;      here for complex success goto
;
|cmp20|beq|7,xr|13,cmfgo(xs)|6,cmp22|; no code if same as fgoto|18102
||zer|8,wb|||; else set ok value for cdgvl in wb|18103
||jsr|6,cdgcg|||; generate code for success goto|18104
||brn|6,cmp22|||; jump to deal with fgoto|18105
;
;      here for no success goto
;
|cmp21|mov|13,cmsoc(xs)|3,cwcof||; set success fill in offset|18109
||mov|8,wa|21,=ocer_||; point to compile error call|18110
||jsr|6,cdwrd|||; generate as temporary value|18111
||ejc|||||18112
;
;      cmpil (continued)
;
;      here to deal with failure goto
;
|cmp22|mov|7,xr|13,cmfgo(xs)||; load failure goto pointer|18118
||mov|8,wa|7,xr||; copy it|18119
||zer|13,cmffc(xs)|||; set no fill in required yet|18120
||bze|7,xr|6,cmp23||; jump if no failure goto given|18121
||add|8,wa|19,*vrtra||; point to vrtra field in case|18122
||blo|7,xr|3,state|6,cmpse|; jump to gen if simple fgoto|18123
;
;      here for complex failure goto
;
||mov|8,wb|3,cwcof||; save offset to o_gof call|18127
||mov|8,wa|21,=ogof_||; point to failure goto call|18128
||jsr|6,cdwrd|||; generate|18129
||mov|8,wa|21,=ofif_||; point to fail in fail word|18130
||jsr|6,cdwrd|||; generate|18131
||jsr|6,cdgcg|||; generate code for failure goto|18132
||mov|8,wa|8,wb||; copy offset to o_gof for cdfal|18133
||mov|8,wb|22,=b_cdc||; set complex case cdtyp|18134
||brn|6,cmp25|||; jump to build cdblk|18135
;
;      here if no failure goto given
;
|cmp23|mov|8,wa|21,=ounf_||; load unexpected failure call in cas|18139
||mov|8,wc|3,cswfl||; get -nofail flag|18140
||orb|8,wc|13,cmcgo(xs)||; check if conditional goto|18141
||zrb|8,wc|6,cmpse||; jump if -nofail and no cond. goto|18142
||mnz|13,cmffc(xs)|||; else set fill in flag|18143
||mov|8,wa|21,=ocer_||; and set compile error for temporary|18144
;
;      merge here with cdfal value in wa, simple cdblk
;      also special entry after statement error
;
|cmpse|mov|8,wb|22,=b_cds||; set cdtyp for simple case|18149
||ejc|||||18150
;
;      cmpil (continued)
;
;      merge here to build cdblk
;
;      (wa)		     cdfal value to be generated
;      (wb)		     cdtyp value to be generated
;
;      at this stage, we chop off an appropriate chunk of the
;      current ccblk and convert it into a cdblk. the remainder
;      of the ccblk is reformatted to be the new ccblk.
;
|cmp25|mov|7,xr|3,r_ccb||; point to ccblk|18163
||mov|7,xl|13,cmlbl(xs)||; get possible label pointer|18164
||bze|7,xl|6,cmp26||; skip if no label|18165
||zer|13,cmlbl(xs)|||; clear flag for next statement|18166
||mov|13,vrlbl(xl)|7,xr||; put cdblk ptr in vrblk label field|18167
;
;      merge after doing label
;
|cmp26|mov|9,(xr)|8,wb||; set type word for new cdblk|18171
||mov|13,cdfal(xr)|8,wa||; set failure word|18172
||mov|7,xl|7,xr||; copy pointer to ccblk|18173
||mov|8,wb|13,ccuse(xr)||; load length gen (= new cdlen)|18174
||mov|8,wc|13,cclen(xr)||; load total ccblk length|18175
||add|7,xl|8,wb||; point past cdblk|18176
||sub|8,wc|8,wb||; get length left for chop off|18177
||mov|9,(xl)|22,=b_cct||; set type code for new ccblk at end|18178
||mov|13,ccuse(xl)|19,*cccod||; set initial code offset|18179
||mov|3,cwcof|19,*cccod||; reinitialise cwcof|18180
||mov|13,cclen(xl)|8,wc||; set new length|18181
||mov|3,r_ccb|7,xl||; set new ccblk pointer|18182
||zer|13,ccsln(xl)|||; initialize new line number|18184
||mov|13,cdsln(xr)|3,cmpln||; set line number in old block|18185
||mov|13,cdstm(xr)|3,cmpsn||; set statement number|18187
||icv|3,cmpsn|||; bump statement number|18188
;
;      set pointers in previous code block as required
;
||mov|7,xl|13,cmpcd(xs)||; load ptr to previous cdblk|18192
||bze|13,cmffp(xs)|6,cmp27||; jump if no failure fill in required|18193
||mov|13,cdfal(xl)|7,xr||; else set failure ptr in previous|18194
;
;      here to deal with success forward pointer
;
|cmp27|mov|8,wa|13,cmsop(xs)||; load success offset|18198
||bze|8,wa|6,cmp28||; jump if no fill in required|18199
||add|7,xl|8,wa||; else point to fill in location|18200
||mov|9,(xl)|7,xr||; store forward pointer|18201
||zer|7,xl|||; clear garbage xl value|18202
||ejc|||||18203
;
;      cmpil (continued)
;
;      now set fill in pointers for this statement
;
|cmp28|mov|13,cmffp(xs)|13,cmffc(xs)||; copy failure fill in flag|18209
||mov|13,cmsop(xs)|13,cmsoc(xs)||; copy success fill in offset|18210
||mov|13,cmpcd(xs)|7,xr||; save ptr to this cdblk|18211
||bnz|13,cmtra(xs)|6,cmp29||; jump if initial entry already set|18212
||mov|13,cmtra(xs)|7,xr||; else set ptr here as default|18213
;
;      here after compiling one statement
;
|cmp29|blt|3,stage|18,=stgce|6,cmp01|; jump if not end line just done|18217
||bze|3,cswls|6,cmp30||; skip if -nolist|18218
||jsr|6,listr|||; list last line|18219
;
;      return
;
|cmp30|mov|7,xr|13,cmtra(xs)||; load initial entry cdblk pointer|18223
||add|7,xs|19,*cmnen||; pop work locations off stack|18224
||exi||||; and return to cmpil caller|18225
;
;      here at end of goto field
;
|cmp31|mov|8,wb|13,cmfgo(xs)||; get fail goto|18229
||orb|8,wb|13,cmsgo(xs)||; or in success goto|18230
||bnz|8,wb|6,cmp18||; ok if non-null field|18231
||erb|1,219|26,syntax error: empty goto field|||18232
;
;      control card found
;
|cmp32|icv|8,wb|||; point past ch_mn|18236
||jsr|6,cncrd|||; process control card|18237
||zer|3,scnse|||; clear start of element loc.|18238
||brn|6,cmpce|||; loop for next statement|18239
||enp||||; end procedure cmpil|18240
||ejc|||||18241
;
;      cncrd -- control card processor
;
;      called to deal with control cards
;
;      r_cim		     points to current image
;      (wb)		     offset to 1st char of control card
;      jsr  cncrd	     call to process control cards
;      (xl,xr,wa,wb,wc,ia)   destroyed
;
|cncrd|prc|25,e|1,0||; entry point|18252
||mov|3,scnpt|8,wb||; offset for control card scan|18253
||mov|8,wa|18,=ccnoc||; number of chars for comparison|18254
||ctw|8,wa|1,0||; convert to word count|18255
||mov|3,cnswc|8,wa||; save word count|18256
;
;      loop here if more than one control card
;
|cnc01|bge|3,scnpt|3,scnil|6,cnc09|; return if end of image|18260
||mov|7,xr|3,r_cim||; point to image|18261
||plc|7,xr|3,scnpt||; char ptr for first char|18262
||lch|8,wa|10,(xr)+||; get first char|18263
||flc|8,wa|||; fold to lower case|18265
||beq|8,wa|18,=ch_li|6,cnc07|; special case of -inxxx|18267
|cnc0a|mnz|3,scncc|||; set flag for scane|18268
||jsr|6,scane|||; scan card name|18269
||zer|3,scncc|||; clear scane flag|18270
||bnz|7,xl|6,cnc06||; fail unless control card name|18271
||mov|8,wa|18,=ccnoc||; no. of chars to be compared|18272
||blt|13,sclen(xr)|8,wa|6,cnc08|; fail if too few chars|18274
||mov|7,xl|7,xr||; point to control card name|18278
||zer|8,wb|||; zero offset for substring|18279
||jsr|6,sbstr|||; extract substring for comparison|18280
||mov|8,wa|13,sclen(xr)||; reload length|18282
||jsr|6,flstg|||; fold to upper case|18283
||mov|3,cnscc|7,xr||; keep control card substring ptr|18285
||mov|7,xr|21,=ccnms||; point to list of standard names|18286
||zer|8,wb|||; initialise name offset|18287
||lct|8,wc|18,=cc_nc||; number of standard names|18288
;
;      try to match name
;
|cnc02|mov|7,xl|3,cnscc||; point to name|18292
||lct|8,wa|3,cnswc||; counter for inner loop|18293
||brn|6,cnc04|||; jump into loop|18294
;
;      inner loop to match card name chars
;
|cnc03|ica|7,xr|||; bump standard names ptr|18298
||ica|7,xl|||; bump name pointer|18299
;
;      here to initiate the loop
;
|cnc04|cne|13,schar(xl)|9,(xr)|6,cnc05|; comp. up to cfp_c chars at once|18303
||bct|8,wa|6,cnc03||; loop if more words to compare|18304
||ejc|||||18305
;
;      cncrd (continued)
;
;      matched - branch on card offset
;
||mov|7,xl|8,wb||; get name offset|18311
||bsw|7,xl|2,cc_nc|6,cnc08|; switch|18313
||iff|2,cc_ca|6,cnc37||; -case|18352
||iff|2,cc_do|6,cnc10||; -double|18352
||iff|1,2|6,cnc08|||18352
||iff|2,cc_du|6,cnc11||; -dump|18352
||iff|2,cc_cp|6,cnc41||; -copy|18352
||iff|2,cc_ej|6,cnc12||; -eject|18352
||iff|2,cc_er|6,cnc13||; -errors|18352
||iff|2,cc_ex|6,cnc14||; -execute|18352
||iff|2,cc_fa|6,cnc15||; -fail|18352
||iff|2,cc_in|6,cnc41||; -include|18352
||iff|2,cc_ln|6,cnc44||; -line|18352
||iff|2,cc_li|6,cnc16||; -list|18352
||iff|2,cc_nr|6,cnc17||; -noerrors|18352
||iff|2,cc_nx|6,cnc18||; -noexecute|18352
||iff|2,cc_nf|6,cnc19||; -nofail|18352
||iff|2,cc_nl|6,cnc20||; -nolist|18352
||iff|2,cc_no|6,cnc21||; -noopt|18352
||iff|2,cc_np|6,cnc22||; -noprint|18352
||iff|2,cc_op|6,cnc24||; -optimise|18352
||iff|2,cc_pr|6,cnc25||; -print|18352
||iff|2,cc_si|6,cnc27||; -single|18352
||iff|2,cc_sp|6,cnc28||; -space|18352
||iff|2,cc_st|6,cnc31||; -stitle|18352
||iff|2,cc_ti|6,cnc32||; -title|18352
||iff|2,cc_tr|6,cnc36||; -trace|18352
||esw||||; end switch|18352
;
;      not matched yet. align std names ptr and try again
;
|cnc05|ica|7,xr|||; bump standard names ptr|18356
||bct|8,wa|6,cnc05||; loop|18357
||icv|8,wb|||; bump names offset|18358
||bct|8,wc|6,cnc02||; continue if more names|18359
||brn|6,cnc08|||; ignore unrecognized control card|18361
;
;      invalid control card name
;
|cnc06|erb|1,247|26,invalid control statement|||18366
;
;      special processing for -inxxx
;
|cnc07|lch|8,wa|10,(xr)+||; get next char|18370
||flc|8,wa|||; fold to lower case|18372
||bne|8,wa|18,=ch_ln|6,cnc0a|; if not letter n|18374
||lch|8,wa|9,(xr)||; get third char|18375
||blt|8,wa|18,=ch_d0|6,cnc0a|; if not digit|18376
||bgt|8,wa|18,=ch_d9|6,cnc0a|; if not digit|18377
||add|3,scnpt|18,=num02||; bump offset past -in|18378
||jsr|6,scane|||; scan integer after -in|18379
||mov|11,-(xs)|7,xr||; stack scanned item|18380
||jsr|6,gtsmi|||; check if integer|18381
||ppm|6,cnc06|||; fail if not integer|18382
||ppm|6,cnc06|||; fail if negative or large|18383
||mov|3,cswin|7,xr||; keep integer|18384
||ejc|||||18385
;
;      cncrd (continued)
;
;      check for more control cards before returning
;
|cnc08|mov|8,wa|3,scnpt||; preserve in case xeq time compile|18391
||jsr|6,scane|||; look for comma|18392
||beq|7,xl|18,=t_cma|6,cnc01|; loop if comma found|18393
||mov|3,scnpt|8,wa||; restore scnpt in case xeq time|18394
;
;      return point
;
|cnc09|exi||||; return|18398
;
;      -double
;
|cnc10|mnz|3,cswdb|||; set switch|18402
||brn|6,cnc08|||; merge|18403
;
;      -dump
;      this is used for system debugging . it has the effect of
;      producing a core dump at compilation time
;
|cnc11|jsr|6,sysdm|||; call dumper|18409
||brn|6,cnc09|||; finished|18410
;
;      -eject
;
|cnc12|bze|3,cswls|6,cnc09||; return if -nolist|18414
||jsr|6,prtps|||; eject|18415
||jsr|6,listt|||; list title|18416
||brn|6,cnc09|||; finished|18417
;
;      -errors
;
|cnc13|zer|3,cswer|||; clear switch|18421
||brn|6,cnc08|||; merge|18422
;
;      -execute
;
|cnc14|zer|3,cswex|||; clear switch|18426
||brn|6,cnc08|||; merge|18427
;
;      -fail
;
|cnc15|mnz|3,cswfl|||; set switch|18431
||brn|6,cnc08|||; merge|18432
;
;      -list
;
|cnc16|mnz|3,cswls|||; set switch|18436
||beq|3,stage|18,=stgic|6,cnc08|; done if compile time|18437
;
;      list code line if execute time compile
;
||zer|3,lstpf|||; permit listing|18441
||jsr|6,listr|||; list line|18442
||brn|6,cnc08|||; merge|18443
||ejc|||||18444
;
;      cncrd (continued)
;
;      -noerrors
;
|cnc17|mnz|3,cswer|||; set switch|18450
||brn|6,cnc08|||; merge|18451
;
;      -noexecute
;
|cnc18|mnz|3,cswex|||; set switch|18455
||brn|6,cnc08|||; merge|18456
;
;      -nofail
;
|cnc19|zer|3,cswfl|||; clear switch|18460
||brn|6,cnc08|||; merge|18461
;
;      -nolist
;
|cnc20|zer|3,cswls|||; clear switch|18465
||brn|6,cnc08|||; merge|18466
;
;      -nooptimise
;
|cnc21|mnz|3,cswno|||; set switch|18470
||brn|6,cnc08|||; merge|18471
;
;      -noprint
;
|cnc22|zer|3,cswpr|||; clear switch|18475
||brn|6,cnc08|||; merge|18476
;
;      -optimise
;
|cnc24|zer|3,cswno|||; clear switch|18480
||brn|6,cnc08|||; merge|18481
;
;      -print
;
|cnc25|mnz|3,cswpr|||; set switch|18485
||brn|6,cnc08|||; merge|18486
||ejc|||||18487
;
;      cncrd (continued)
;
;      -single
;
|cnc27|zer|3,cswdb|||; clear switch|18493
||brn|6,cnc08|||; merge|18494
;
;      -space
;
|cnc28|bze|3,cswls|6,cnc09||; return if -nolist|18498
||jsr|6,scane|||; scan integer after -space|18499
||mov|8,wc|18,=num01||; 1 space in case|18500
||beq|7,xr|18,=t_smc|6,cnc29|; jump if no integer|18501
||mov|11,-(xs)|7,xr||; stack it|18502
||jsr|6,gtsmi|||; check integer|18503
||ppm|6,cnc06|||; fail if not integer|18504
||ppm|6,cnc06|||; fail if negative or large|18505
||bnz|8,wc|6,cnc29||; jump if non zero|18506
||mov|8,wc|18,=num01||; else 1 space|18507
;
;      merge with count of lines to skip
;
|cnc29|add|3,lstlc|8,wc||; bump line count|18511
||lct|8,wc|8,wc||; convert to loop counter|18512
||blt|3,lstlc|3,lstnp|6,cnc30|; jump if fits on page|18513
||jsr|6,prtps|||; eject|18514
||jsr|6,listt|||; list title|18515
||brn|6,cnc09|||; merge|18516
;
;      skip lines
;
|cnc30|jsr|6,prtnl|||; print a blank|18520
||bct|8,wc|6,cnc30||; loop|18521
||brn|6,cnc09|||; merge|18522
||ejc|||||18523
;
;      cncrd (continued)
;
;      -stitl
;
|cnc31|mov|3,cnr_t|20,=r_stl||; ptr to r_stl|18529
||brn|6,cnc33|||; merge|18530
;
;      -title
;
|cnc32|mov|3,r_stl|21,=nulls||; clear subtitle|18534
||mov|3,cnr_t|20,=r_ttl||; ptr to r_ttl|18535
;
;      common processing for -title, -stitl
;
|cnc33|mov|7,xr|21,=nulls||; null in case needed|18539
||mnz|3,cnttl|||; set flag for next listr call|18540
||mov|8,wb|18,=ccofs||; offset to title/subtitle|18541
||mov|8,wa|3,scnil||; input image length|18542
||blo|8,wa|8,wb|6,cnc34|; jump if no chars left|18543
||sub|8,wa|8,wb||; no of chars to extract|18544
||mov|7,xl|3,r_cim||; point to image|18545
||jsr|6,sbstr|||; get title/subtitle|18546
;
;      store title/subtitle
;
|cnc34|mov|7,xl|3,cnr_t||; point to storage location|18550
||mov|9,(xl)|7,xr||; store title/subtitle|18551
||beq|7,xl|20,=r_stl|6,cnc09|; return if stitl|18552
||bnz|3,precl|6,cnc09||; return if extended listing|18553
||bze|3,prich|6,cnc09||; return if regular printer|18554
||mov|7,xl|13,sclen(xr)||; get length of title|18555
||mov|8,wa|7,xl||; copy it|18556
||bze|7,xl|6,cnc35||; jump if null|18557
||add|7,xl|18,=num10||; increment|18558
||bhi|7,xl|3,prlen|6,cnc09|; use default lstp0 val if too long|18559
||add|8,wa|18,=num04||; point just past title|18560
;
;      store offset to page nn message for short title
;
|cnc35|mov|3,lstpo|8,wa||; store offset|18564
||brn|6,cnc09|||; return|18565
;
;      -trace
;      provided for system debugging.  toggles the system label
;      trace switch at compile time
;
|cnc36|jsr|6,systt|||; toggle switch|18571
||brn|6,cnc08|||; merge|18572
;
;      -case
;      sets value of kvcas so that names are folded or not
;      during compilation.
;
|cnc37|jsr|6,scane|||; scan integer after -case|18579
||zer|8,wc|||; get 0 in case none there|18580
||beq|7,xl|18,=t_smc|6,cnc38|; skip if no integer|18581
||mov|11,-(xs)|7,xr||; stack it|18582
||jsr|6,gtsmi|||; check integer|18583
||ppm|6,cnc06|||; fail if not integer|18584
||ppm|6,cnc06|||; fail if negative or too large|18585
|cnc38|mov|3,kvcas|8,wc||; store new case value|18586
||brn|6,cnc09|||; merge|18587
;
;      -include
;
|cnc41|mnz|3,scncc|||; set flag for scane|18610
||jsr|6,scane|||; scan quoted file name|18611
||zer|3,scncc|||; clear scane flag|18612
||bne|7,xl|18,=t_con|6,cnc06|; if not constant|18613
||bne|9,(xr)|22,=b_scl|6,cnc06|; if not string constant|18614
||mov|3,r_ifn|7,xr||; save file name|18615
||mov|7,xl|3,r_inc||; examine include file name table|18616
||zer|8,wb|||; lookup by value|18617
||jsr|6,tfind|||; do lookup|18618
||ppm||||; never fails|18619
||beq|7,xr|21,=inton|6,cnc09|; ignore if already in table|18620
||mnz|8,wb|||; set for trim|18621
||mov|7,xr|3,r_ifn||; file name|18622
||jsr|6,trimr|||; remove trailing blanks|18623
||mov|7,xl|3,r_inc||; include file name table|18624
||mnz|8,wb|||; lookup by name this time|18625
||jsr|6,tfind|||; do lookup|18626
||ppm||||; never fails|18627
||mov|13,teval(xl)|21,=inton||; make table value integer 1|18628
||icv|3,cnind|||; increase nesting level|18629
||mov|8,wa|3,cnind||; load new nest level|18630
||bgt|8,wa|18,=ccinm|6,cnc42|; fail if excessive nesting|18631
;
;      record the name and line number of the current input file
;
||mov|7,xl|3,r_ifa||; array of nested file names|18636
||add|8,wa|18,=vcvlb||; compute offset in words|18637
||wtb|8,wa|||; convert to bytes|18638
||add|7,xl|8,wa||; point to element|18639
||mov|9,(xl)|3,r_sfc||; record current file name|18640
||mov|7,xl|8,wa||; preserve nesting byte offset|18641
||mti|3,rdnln|||; fetch source line number as integer|18642
||jsr|6,icbld|||; convert to icblk|18643
||add|7,xl|3,r_ifl||; entry in nested line number array|18644
||mov|9,(xl)|7,xr||; record in array|18645
;
;      here to switch to include file named in r_ifn
;
||mov|8,wa|3,cswin||; max read length|18650
||mov|7,xl|3,r_ifn||; include file name|18651
||jsr|6,alocs|||; get buffer for complete file name|18652
||jsr|6,sysif|||; open include file|18653
||ppm|6,cnc43|||; could not open|18654
;
;      make note of the complete file name for error messages
;
||zer|8,wb|||; do not trim trailing blanks|18659
||jsr|6,trimr|||; adjust scblk for actual length|18660
||mov|3,r_sfc|7,xr||; save ptr to file name|18661
||mti|3,cmpsn|||; current statement as integer|18662
||jsr|6,icbld|||; build icblk for stmt number|18663
||mov|7,xl|3,r_sfn||; file name table|18664
||mnz|8,wb|||; lookup statement number by name|18665
||jsr|6,tfind|||; allocate new teblk|18666
||ppm||||; always possible to allocate block|18667
||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|18668
||zer|3,rdnln|||; restart line counter for new file|18672
||beq|3,stage|18,=stgic|6,cnc09|; if initial compile|18673
||bne|3,cnind|18,=num01|6,cnc09|; if not first execute-time nesting|18674
;
;      here for -include during execute-time compile
;
||mov|3,r_ici|3,r_cim||; remember code argument string|18678
||mov|3,cnspt|3,scnpt||; save position in string|18679
||mov|3,cnsil|3,scnil||; and length of string|18680
||brn|6,cnc09|||; all done, merge|18681
;
;      here for excessive include file nesting
;
|cnc42|erb|1,284|26,excessively nested include files|||18685
;
;      here if include file could not be opened
;
|cnc43|mov|3,dnamp|7,xr||; release allocated scblk|18689
||erb|1,285|26,include file cannot be opened|||18690
;
;
;      -line n filename
;
|cnc44|jsr|6,scane|||; scan integer after -line|18697
||bne|7,xl|18,=t_con|6,cnc06|; jump if no line number|18698
||bne|9,(xr)|22,=b_icl|6,cnc06|; jump if not integer|18699
||ldi|13,icval(xr)|||; fetch integer line number|18700
||ile|6,cnc06|||; error if negative or zero|18701
||beq|3,stage|18,=stgic|6,cnc45|; skip if initial compile|18702
||mfi|3,cmpln|||; set directly for other compiles|18703
||brn|6,cnc46|||; no need to set rdnln|18704
|cnc45|sbi|4,intv1|||; adjust number by one|18705
||mfi|3,rdnln|||; save line number|18706
|cnc46|mnz|3,scncc|||; set flag for scane|18708
||jsr|6,scane|||; scan quoted file name|18709
||zer|3,scncc|||; clear scane flag|18710
||beq|7,xl|18,=t_smc|6,cnc47|; done if no file name|18711
||bne|7,xl|18,=t_con|6,cnc06|; error if not constant|18712
||bne|9,(xr)|22,=b_scl|6,cnc06|; if not string constant|18713
||jsr|6,newfn|||; record new file name|18714
||brn|6,cnc09|||; merge|18715
;
;      here if file name not present
;
|cnc47|dcv|3,scnpt|||; set to rescan the terminator|18719
||brn|6,cnc09|||; merge|18720
||enp||||; end procedure cncrd|18725
||ejc|||||18726
;
;      dffnc -- define function
;
;      dffnc is called whenever a new function is assigned to
;      a variable. it deals with external function use counts.
;
;      (xr)		     pointer to vrblk
;      (xl)		     pointer to new function block
;      jsr  dffnc	     call to define function
;      (wa,wb)		     destroyed
;
|dffnc|prc|25,e|1,0||; entry point|18808
||bne|9,(xl)|22,=b_efc|6,dffn1|; skip if new function not external|18811
||icv|13,efuse(xl)|||; else increment its use count|18812
;
;      here after dealing with new function use count
;
|dffn1|mov|8,wa|7,xr||; save vrblk pointer|18816
||mov|7,xr|13,vrfnc(xr)||; load old function pointer|18817
||bne|9,(xr)|22,=b_efc|6,dffn2|; jump if old function not external|18818
||mov|8,wb|13,efuse(xr)||; else get use count|18819
||dcv|8,wb|||; decrement|18820
||mov|13,efuse(xr)|8,wb||; store decremented value|18821
||bnz|8,wb|6,dffn2||; jump if use count still non-zero|18822
||jsr|6,sysul|||; else call system unload function|18823
;
;      here after dealing with old function use count
;
|dffn2|mov|7,xr|8,wa||; restore vrblk pointer|18827
||mov|8,wa|7,xl||; copy function block ptr|18829
||blt|7,xr|20,=r_yyy|6,dffn3|; skip checks if opsyn op definition|18830
||bnz|13,vrlen(xr)|6,dffn3||; jump if not system variable|18831
;
;      for system variable, check for illegal redefinition
;
||mov|7,xl|13,vrsvp(xr)||; point to svblk|18835
||mov|8,wb|13,svbit(xl)||; load bit indicators|18836
||anb|8,wb|4,btfnc||; is it a system function|18837
||zrb|8,wb|6,dffn3||; redef ok if not|18838
||erb|1,248|26,attempted redefinition of system function|||18839
;
;      here if redefinition is permitted
;
|dffn3|mov|13,vrfnc(xr)|8,wa||; store new function pointer|18843
||mov|7,xl|8,wa||; restore function block pointer|18844
||exi||||; return to dffnc caller|18845
||enp||||; end procedure dffnc|18846
||ejc|||||18847
;
;      dtach -- detach i/o associated names
;
;      detaches trblks from i/o associated variables, removes
;      entry from iochn chain attached to filearg1 vrblk and may
;      remove vrblk access and store traps.
;      input, output, terminal are handled specially.
;
;      (xl)		     i/o assoc. vbl name base ptr
;      (wa)		     offset to name
;      jsr  dtach	     call for detach operation
;      (xl,xr,wa,wb,wc)	     destroyed
;
|dtach|prc|25,e|1,0||; entry point|18861
||mov|3,dtcnb|7,xl||; store name base (gbcol not called)|18862
||add|7,xl|8,wa||; point to name location|18863
||mov|3,dtcnm|7,xl||; store it|18864
;
;      loop to search for i/o trblk
;
|dtch1|mov|7,xr|7,xl||; copy name pointer|18868
;
;      continue after block deletion
;
|dtch2|mov|7,xl|9,(xl)||; point to next value|18872
||bne|9,(xl)|22,=b_trt|6,dtch6|; jump at chain end|18873
||mov|8,wa|13,trtyp(xl)||; get trap block type|18874
||beq|8,wa|18,=trtin|6,dtch3|; jump if input|18875
||beq|8,wa|18,=trtou|6,dtch3|; jump if output|18876
||add|7,xl|19,*trnxt||; point to next link|18877
||brn|6,dtch1|||; loop|18878
;
;      delete an old association
;
|dtch3|mov|9,(xr)|13,trval(xl)||; delete trblk|18882
||mov|8,wa|7,xl||; dump xl ...|18883
||mov|8,wb|7,xr||; ... and xr|18884
||mov|7,xl|13,trtrf(xl)||; point to trtrf trap block|18885
||bze|7,xl|6,dtch5||; jump if no iochn|18886
||bne|9,(xl)|22,=b_trt|6,dtch5|; jump if input, output, terminal|18887
;
;      loop to search iochn chain for name ptr
;
|dtch4|mov|7,xr|7,xl||; remember link ptr|18891
||mov|7,xl|13,trtrf(xl)||; point to next link|18892
||bze|7,xl|6,dtch5||; jump if end of chain|18893
||mov|8,wc|13,ionmb(xl)||; get name base|18894
||add|8,wc|13,ionmo(xl)||; add offset|18895
||bne|8,wc|3,dtcnm|6,dtch4|; loop if no match|18896
||mov|13,trtrf(xr)|13,trtrf(xl)||; remove name from chain|18897
||ejc|||||18898
;
;      dtach (continued)
;
;      prepare to resume i/o trblk scan
;
|dtch5|mov|7,xl|8,wa||; recover xl ...|18904
||mov|7,xr|8,wb||; ... and xr|18905
||add|7,xl|19,*trval||; point to value field|18906
||brn|6,dtch2|||; continue|18907
;
;      exit point
;
|dtch6|mov|7,xr|3,dtcnb||; possible vrblk ptr|18911
||jsr|6,setvr|||; reset vrblk if necessary|18912
||exi||||; return|18913
||enp||||; end procedure dtach|18914
||ejc|||||18915
;
;      dtype -- get datatype name
;
;      (xr)		     object whose datatype is required
;      jsr  dtype	     call to get datatype
;      (xr)		     result datatype
;
|dtype|prc|25,e|1,0||; entry point|18923
||beq|9,(xr)|22,=b_pdt|6,dtyp1|; jump if prog.defined|18924
||mov|7,xr|9,(xr)||; load type word|18925
||lei|7,xr|||; get entry point id (block code)|18926
||wtb|7,xr|||; convert to byte offset|18927
||mov|7,xr|14,scnmt(xr)||; load table entry|18928
||exi||||; exit to dtype caller|18929
;
;      here if program defined
;
|dtyp1|mov|7,xr|13,pddfp(xr)||; point to dfblk|18933
||mov|7,xr|13,dfnam(xr)||; get datatype name from dfblk|18934
||exi||||; return to dtype caller|18935
||enp||||; end procedure dtype|18936
||ejc|||||18937
;
;      dumpr -- print dump of storage
;
;      (xr)		     dump argument (see below)
;      jsr  dumpr	     call to print dump
;      (xr,xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
;      the dump argument has the following significance
;
;      dmarg = 0	     no dump printed
;      dmarg = 1	     partial dump (nat vars, keywords)
;      dmarg = 2	     full dump (arrays, tables, etc.)
;      dmarg = 3	     full dump + null variables
;      dmarg ge 4	     core dump
;
;      since dumpr scrambles store, it is not permissible to
;      collect in mid-dump. hence a collect is done initially
;      and then if store runs out an error message is produced.
;
|dumpr|prc|25,e|1,0||; entry point|18958
||bze|7,xr|6,dmp28||; skip dump if argument is zero|18959
||bgt|7,xr|18,=num03|6,dmp29|; jump if core dump required|18960
||zer|7,xl|||; clear xl|18961
||zer|8,wb|||; zero move offset|18962
||mov|3,dmarg|7,xr||; save dump argument|18963
||zer|3,dnams|||; collect sediment too|18965
||jsr|6,gbcol|||; collect garbage|18967
||jsr|6,prtpg|||; eject printer|18968
||mov|7,xr|21,=dmhdv||; point to heading for variables|18969
||jsr|6,prtst|||; print it|18970
||jsr|6,prtnl|||; terminate print line|18971
||jsr|6,prtnl|||; and print a blank line|18972
;
;      first all natural variable blocks (vrblk) whose values
;      are non-null are linked in lexical order using dmvch as
;      the chain head and chaining through the vrget fields.
;      note that this scrambles store if the process is
;      interrupted before completion e.g. by exceeding time  or
;      print limits. since the subsequent core dumps and
;      failures if execution is resumed are very confusing, the
;      execution time error routine checks for this event and
;      attempts an unscramble. similar precautions should be
;      observed if translate time dumping is implemented.
;
||zer|3,dmvch|||; set null chain to start|18985
||mov|8,wa|3,hshtb||; point to hash table|18986
;
;      loop through headers in hash table
;
|dmp00|mov|7,xr|8,wa||; copy hash bucket pointer|18990
||ica|8,wa|||; bump pointer|18991
||sub|7,xr|19,*vrnxt||; set offset to merge|18992
;
;      loop through vrblks on one chain
;
|dmp01|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain|18996
||bze|7,xr|6,dmp09||; jump if end of this hash chain|18997
||mov|7,xl|7,xr||; else copy vrblk pointer|18998
||ejc|||||18999
;
;      dumpr (continued)
;
;      loop to find value and skip if null
;
|dmp02|mov|7,xl|13,vrval(xl)||; load value|19005
||beq|3,dmarg|18,=num03|6,dmp2a|; skip null value check if dump(3)|19006
||beq|7,xl|21,=nulls|6,dmp01|; loop for next vrblk if null value|19007
|dmp2a|beq|9,(xl)|22,=b_trt|6,dmp02|; loop back if value is trapped|19008
;
;      non-null value, prepare to search chain
;
||mov|8,wc|7,xr||; save vrblk pointer|19012
||add|7,xr|19,*vrsof||; adjust ptr to be like scblk ptr|19013
||bnz|13,sclen(xr)|6,dmp03||; jump if non-system variable|19014
||mov|7,xr|13,vrsvo(xr)||; else load ptr to name in svblk|19015
;
;      here with name pointer for new block in xr
;
|dmp03|mov|8,wb|7,xr||; save pointer to chars|19019
||mov|3,dmpsv|8,wa||; save hash bucket pointer|19020
||mov|8,wa|20,=dmvch||; point to chain head|19021
;
;      loop to search chain for correct insertion point
;
|dmp04|mov|3,dmpch|8,wa||; save chain pointer|19025
||mov|7,xl|8,wa||; copy it|19026
||mov|7,xr|9,(xl)||; load pointer to next entry|19027
||bze|7,xr|6,dmp08||; jump if end of chain to insert|19028
||add|7,xr|19,*vrsof||; else get name ptr for chained vrblk|19029
||bnz|13,sclen(xr)|6,dmp05||; jump if not system variable|19030
||mov|7,xr|13,vrsvo(xr)||; else point to name in svblk|19031
;
;      here prepare to compare the names
;
;      (wa)		     scratch
;      (wb)		     pointer to string of entering vrblk
;      (wc)		     pointer to entering vrblk
;      (xr)		     pointer to string of current block
;      (xl)		     scratch
;
|dmp05|mov|7,xl|8,wb||; point to entering vrblk string|19041
||mov|8,wa|13,sclen(xl)||; load its length|19042
||plc|7,xl|||; point to chars of entering string|19043
||bhi|8,wa|13,sclen(xr)|6,dmp06|; jump if entering length high|19066
||plc|7,xr|||; else point to chars of old string|19067
||cmc|6,dmp08|6,dmp07||; compare, insert if new is llt old|19068
||brn|6,dmp08|||; or if leq (we had shorter length)|19069
;
;      here when new length is longer than old length
;
|dmp06|mov|8,wa|13,sclen(xr)||; load shorter length|19073
||plc|7,xr|||; point to chars of old string|19074
||cmc|6,dmp08|6,dmp07||; compare, insert if new one low|19075
||ejc|||||19076
;
;      dumpr (continued)
;
;      here we move out on the chain
;
|dmp07|mov|7,xl|3,dmpch||; copy chain pointer|19082
||mov|8,wa|9,(xl)||; move to next entry on chain|19084
||brn|6,dmp04|||; loop back|19085
;
;      here after locating the proper insertion point
;
|dmp08|mov|7,xl|3,dmpch||; copy chain pointer|19089
||mov|8,wa|3,dmpsv||; restore hash bucket pointer|19090
||mov|7,xr|8,wc||; restore vrblk pointer|19091
||mov|13,vrget(xr)|9,(xl)||; link vrblk to rest of chain|19092
||mov|9,(xl)|7,xr||; link vrblk into current chain loc|19093
||brn|6,dmp01|||; loop back for next vrblk|19094
;
;      here after processing all vrblks on one chain
;
|dmp09|bne|8,wa|3,hshte|6,dmp00|; loop back if more buckets to go|19098
;
;      loop to generate dump of natural variable values
;
|dmp10|mov|7,xr|3,dmvch||; load pointer to next entry on chain|19102
||bze|7,xr|6,dmp11||; jump if end of chain|19103
||mov|3,dmvch|9,(xr)||; else update chain ptr to next entry|19104
||jsr|6,setvr|||; restore vrget field|19105
||mov|7,xl|7,xr||; copy vrblk pointer (name base)|19106
||mov|8,wa|19,*vrval||; set offset for vrblk name|19107
||jsr|6,prtnv|||; print name = value|19108
||brn|6,dmp10|||; loop back till all printed|19109
;
;      prepare to print keywords
;
|dmp11|jsr|6,prtnl|||; print blank line|19113
||jsr|6,prtnl|||; and another|19114
||mov|7,xr|21,=dmhdk||; point to keyword heading|19115
||jsr|6,prtst|||; print heading|19116
||jsr|6,prtnl|||; end line|19117
||jsr|6,prtnl|||; print one blank line|19118
||mov|7,xl|21,=vdmkw||; point to list of keyword svblk ptrs|19119
||ejc|||||19120
;
;      dumpr (continued)
;
;      loop to dump keyword values
;
|dmp12|mov|7,xr|10,(xl)+||; load next svblk ptr from table|19126
||bze|7,xr|6,dmp13||; jump if end of list|19127
||beq|7,xr|18,=num01|6,dmp12|; &compare ignored if not implemented|19129
||mov|8,wa|18,=ch_am||; load ampersand|19131
||jsr|6,prtch|||; print ampersand|19132
||jsr|6,prtst|||; print keyword name|19133
||mov|8,wa|13,svlen(xr)||; load name length from svblk|19134
||ctb|8,wa|2,svchs||; get length of name|19135
||add|7,xr|8,wa||; point to svknm field|19136
||mov|3,dmpkn|9,(xr)||; store in dummy kvblk|19137
||mov|7,xr|21,=tmbeb||; point to blank-equal-blank|19138
||jsr|6,prtst|||; print it|19139
||mov|3,dmpsv|7,xl||; save table pointer|19140
||mov|7,xl|20,=dmpkb||; point to dummy kvblk|19141
||mov|9,(xl)|22,=b_kvt||; build type word|19142
||mov|13,kvvar(xl)|21,=trbkv||; build ptr to dummy trace block|19143
||mov|8,wa|19,*kvvar||; set zero offset|19144
||jsr|6,acess|||; get keyword value|19145
||ppm||||; failure is impossible|19146
||jsr|6,prtvl|||; print keyword value|19147
||jsr|6,prtnl|||; terminate print line|19148
||mov|7,xl|3,dmpsv||; restore table pointer|19149
||brn|6,dmp12|||; loop back till all printed|19150
;
;      here after completing partial dump
;
|dmp13|beq|3,dmarg|18,=num01|6,dmp27|; exit if partial dump complete|19154
||mov|7,xr|3,dnamb||; else point to first dynamic block|19155
;
;      loop through blocks in dynamic storage
;
|dmp14|beq|7,xr|3,dnamp|6,dmp27|; jump if end of used region|19159
||mov|8,wa|9,(xr)||; else load first word of block|19160
||beq|8,wa|22,=b_vct|6,dmp16|; jump if vector|19161
||beq|8,wa|22,=b_art|6,dmp17|; jump if array|19162
||beq|8,wa|22,=b_pdt|6,dmp18|; jump if program defined|19163
||beq|8,wa|22,=b_tbt|6,dmp19|; jump if table|19164
;
;      merge here to move to next block
;
|dmp15|jsr|6,blkln|||; get length of block|19172
||add|7,xr|8,wa||; point past this block|19173
||brn|6,dmp14|||; loop back for next block|19174
||ejc|||||19175
;
;      dumpr (continued)
;
;      here for vector
;
|dmp16|mov|8,wb|19,*vcvls||; set offset to first value|19181
||brn|6,dmp19|||; jump to merge|19182
;
;      here for array
;
|dmp17|mov|8,wb|13,arofs(xr)||; set offset to arpro field|19186
||ica|8,wb|||; bump to get offset to values|19187
||brn|6,dmp19|||; jump to merge|19188
;
;      here for program defined
;
|dmp18|mov|8,wb|19,*pdfld||; point to values, merge|19192
;
;      here for table (others merge)
;
|dmp19|bze|13,idval(xr)|6,dmp15||; ignore block if zero id value|19196
||jsr|6,blkln|||; else get block length|19197
||mov|7,xl|7,xr||; copy block pointer|19198
||mov|3,dmpsv|8,wa||; save length|19199
||mov|8,wa|8,wb||; copy offset to first value|19200
||jsr|6,prtnl|||; print blank line|19201
||mov|3,dmpsa|8,wa||; preserve offset|19202
||jsr|6,prtvl|||; print block value (for title)|19203
||mov|8,wa|3,dmpsa||; recover offset|19204
||jsr|6,prtnl|||; end print line|19205
||beq|9,(xr)|22,=b_tbt|6,dmp22|; jump if table|19206
||dca|8,wa|||; point before first word|19207
;
;      loop to print contents of array, vector, or program def
;
|dmp20|mov|7,xr|7,xl||; copy block pointer|19211
||ica|8,wa|||; bump offset|19212
||add|7,xr|8,wa||; point to next value|19213
||beq|8,wa|3,dmpsv|6,dmp14|; exit if end (xr past block)|19214
||sub|7,xr|19,*vrval||; subtract offset to merge into loop|19215
;
;      loop to find value and ignore nulls
;
|dmp21|mov|7,xr|13,vrval(xr)||; load next value|19219
||beq|3,dmarg|18,=num03|6,dmp2b|; skip null value check if dump(3)|19220
||beq|7,xr|21,=nulls|6,dmp20|; loop back if null value|19221
|dmp2b|beq|9,(xr)|22,=b_trt|6,dmp21|; loop back if trapped|19222
||jsr|6,prtnv|||; else print name = value|19223
||brn|6,dmp20|||; loop back for next field|19224
||ejc|||||19225
;
;      dumpr (continued)
;
;      here to dump a table
;
|dmp22|mov|8,wc|19,*tbbuk||; set offset to first bucket|19231
||mov|8,wa|19,*teval||; set name offset for all teblks|19232
;
;      loop through table buckets
;
|dmp23|mov|11,-(xs)|7,xl||; save tbblk pointer|19236
||add|7,xl|8,wc||; point to next bucket header|19237
||ica|8,wc|||; bump bucket offset|19238
||sub|7,xl|19,*tenxt||; subtract offset to merge into loop|19239
;
;      loop to process teblks on one chain
;
|dmp24|mov|7,xl|13,tenxt(xl)||; point to next teblk|19243
||beq|7,xl|9,(xs)|6,dmp26|; jump if end of chain|19244
||mov|7,xr|7,xl||; else copy teblk pointer|19245
;
;      loop to find value and ignore if null
;
|dmp25|mov|7,xr|13,teval(xr)||; load next value|19249
||beq|7,xr|21,=nulls|6,dmp24|; ignore if null value|19250
||beq|9,(xr)|22,=b_trt|6,dmp25|; loop back if trapped|19251
||mov|3,dmpsv|8,wc||; else save offset pointer|19252
||jsr|6,prtnv|||; print name = value|19253
||mov|8,wc|3,dmpsv||; reload offset|19254
||brn|6,dmp24|||; loop back for next teblk|19255
;
;      here to move to next hash chain
;
|dmp26|mov|7,xl|10,(xs)+||; restore tbblk pointer|19259
||bne|8,wc|13,tblen(xl)|6,dmp23|; loop back if more buckets to go|19260
||mov|7,xr|7,xl||; else copy table pointer|19261
||add|7,xr|8,wc||; point to following block|19262
||brn|6,dmp14|||; loop back to process next block|19263
;
;      here after completing dump
;
|dmp27|jsr|6,prtpg|||; eject printer|19267
;
;      merge here if no dump given (dmarg=0)
;
|dmp28|exi||||; return to dump caller|19271
;
;      call system core dump routine
;
|dmp29|jsr|6,sysdm|||; call it|19275
||brn|6,dmp28|||; return|19276
||enp||||; end procedure dumpr|19312
||ejc|||||19313
;
;      ermsg -- print error code and error message
;
;      kvert		     error code
;      jsr  ermsg	     call to print message
;      (xr,xl,wa,wb,wc,ia)   destroyed
;
|ermsg|prc|25,e|1,0||; entry point|19321
||mov|8,wa|3,kvert||; load error code|19322
||mov|7,xr|21,=ermms||; point to error message /error/|19323
||jsr|6,prtst|||; print it|19324
||jsr|6,ertex|||; get error message text|19325
||add|8,wa|18,=thsnd||; bump error code for print|19326
||mti|8,wa|||; fail code in int acc|19327
||mov|8,wb|3,profs||; save current buffer position|19328
||jsr|6,prtin|||; print code (now have error1xxx)|19329
||mov|7,xl|3,prbuf||; point to print buffer|19330
||psc|7,xl|8,wb||; point to the 1|19331
||mov|8,wa|18,=ch_bl||; load a blank|19332
||sch|8,wa|9,(xl)||; store blank over 1 (error xxx)|19333
||csc|7,xl|||; complete store characters|19334
||zer|7,xl|||; clear garbage pointer in xl|19335
||mov|8,wa|7,xr||; keep error text|19336
||mov|7,xr|21,=ermns||; point to / -- /|19337
||jsr|6,prtst|||; print it|19338
||mov|7,xr|8,wa||; get error text again|19339
||jsr|6,prtst|||; print error message text|19340
||jsr|6,prtis|||; print line|19341
||jsr|6,prtis|||; print blank line|19342
||exi||||; return to ermsg caller|19343
||enp||||; end procedure ermsg|19344
||ejc|||||19345
;
;      ertex -- get error message text
;
;      (wa)		     error code
;      jsr  ertex	     call to get error text
;      (xr)		     ptr to error text in dynamic
;      (r_etx)		     copy of ptr to error text
;      (xl,wc,ia)	     destroyed
;
|ertex|prc|25,e|1,0||; entry point|19355
||mov|3,ertwa|8,wa||; save wa|19356
||mov|3,ertwb|8,wb||; save wb|19357
||jsr|6,sysem|||; get failure message text|19358
||mov|7,xl|7,xr||; copy pointer to it|19359
||mov|8,wa|13,sclen(xr)||; get length of string|19360
||bze|8,wa|6,ert02||; jump if null|19361
||zer|8,wb|||; offset of zero|19362
||jsr|6,sbstr|||; copy into dynamic store|19363
||mov|3,r_etx|7,xr||; store for relocation|19364
;
;      return
;
|ert01|mov|8,wb|3,ertwb||; restore wb|19368
||mov|8,wa|3,ertwa||; restore wa|19369
||exi||||; return to caller|19370
;
;      return errtext contents instead of null
;
|ert02|mov|7,xr|3,r_etx||; get errtext|19374
||brn|6,ert01|||; return|19375
||enp|||||19376
||ejc|||||19377
;
;      evali -- evaluate integer argument
;
;      evali is used by pattern primitives len,tab,rtab,pos,rpos
;      when their argument is an expression value.
;
;      (xr)		     node pointer
;      (wb)		     cursor
;      jsr  evali	     call to evaluate integer
;      ppm  loc		     transfer loc for non-integer arg
;      ppm  loc		     transfer loc for out of range arg
;      ppm  loc		     transfer loc for evaluation failure
;      ppm  loc		     transfer loc for successful eval
;      (the normal return is never taken)
;      (xr)		     ptr to node with integer argument
;      (wc,xl,ra)	     destroyed
;
;      on return, the node pointed to has the integer argument
;      in parm1 and the proper successor pointer in pthen.
;      this allows merging with the normal (integer arg) case.
;
|evali|prc|25,r|1,4||; entry point (recursive)|19399
||jsr|6,evalp|||; evaluate expression|19400
||ppm|6,evli1|||; jump on failure|19401
||mov|11,-(xs)|7,xl||; stack result for gtsmi|19402
||mov|7,xl|13,pthen(xr)||; load successor pointer|19403
||mov|3,evlio|7,xr||; save original node pointer|19404
||mov|3,evlif|8,wc||; zero if simple argument|19405
||jsr|6,gtsmi|||; convert arg to small integer|19406
||ppm|6,evli2|||; jump if not integer|19407
||ppm|6,evli3|||; jump if out of range|19408
||mov|3,evliv|7,xr||; store result in special dummy node|19409
||mov|7,xr|20,=evlin||; point to dummy node with result|19410
||mov|9,(xr)|22,=p_len||; dummy pattern block pcode|19411
||mov|13,pthen(xr)|7,xl||; store successor pointer|19412
||exi|1,4|||; take successful exit|19413
;
;      here if evaluation fails
;
|evli1|exi|1,3|||; take failure return|19417
;
;      here if argument is not integer
;
|evli2|exi|1,1|||; take non-integer error exit|19421
;
;      here if argument is out of range
;
|evli3|exi|1,2|||; take out-of-range error exit|19425
||enp||||; end procedure evali|19426
||ejc|||||19427
;
;      evalp -- evaluate expression during pattern match
;
;      evalp is used to evaluate an expression (by value) during
;      a pattern match. the effect is like evalx, but pattern
;      variables are stacked and restored if necessary.
;
;      evalp also differs from evalx in that if the result is
;      an expression it is reevaluated. this occurs repeatedly.
;
;      to support optimization of pos and rpos, evalp uses wc
;      to signal the caller for the case of a simple vrblk
;      that is not an expression and is not trapped.  because
;      this case cannot have any side effects, optimization is
;      possible.
;
;      (xr)		     node pointer
;      (wb)		     pattern match cursor
;      jsr  evalp	     call to evaluate expression
;      ppm  loc		     transfer loc if evaluation fails
;      (xl)		     result
;      (wa)		     first word of result block
;      (wc)		     zero if simple vrblk, else non-zero
;      (xr,wb)		     destroyed (failure case only)
;      (ra)		     destroyed
;
;      the expression pointer is stored in parm1 of the node
;
;      control returns to failp on failure of evaluation
;
|evalp|prc|25,r|1,1||; entry point (recursive)|19458
||mov|7,xl|13,parm1(xr)||; load expression pointer|19459
||beq|9,(xl)|22,=b_exl|6,evlp1|; jump if exblk case|19460
;
;      here for case of seblk
;
;      we can give a fast return if the value of the vrblk is
;      not an expression and is not trapped.
;
||mov|7,xl|13,sevar(xl)||; load vrblk pointer|19467
||mov|7,xl|13,vrval(xl)||; load value of vrblk|19468
||mov|8,wa|9,(xl)||; load first word of value|19469
||bhi|8,wa|22,=b_t__|6,evlp3|; jump if not seblk, trblk or exblk|19470
;
;      here for exblk or seblk with expr value or trapped value
;
|evlp1|chk||||; check for stack space|19474
||mov|11,-(xs)|7,xr||; stack node pointer|19475
||mov|11,-(xs)|8,wb||; stack cursor|19476
||mov|11,-(xs)|3,r_pms||; stack subject string pointer|19477
||mov|11,-(xs)|3,pmssl||; stack subject string length|19478
||mov|11,-(xs)|3,pmdfl||; stack dot flag|19479
||mov|11,-(xs)|3,pmhbs||; stack history stack base pointer|19480
||mov|7,xr|13,parm1(xr)||; load expression pointer|19481
||ejc|||||19482
;
;      evalp (continued)
;
;      loop back here to reevaluate expression result
;
|evlp2|zer|8,wb|||; set flag for by value|19488
||jsr|6,evalx|||; evaluate expression|19489
||ppm|6,evlp4|||; jump on failure|19490
||mov|8,wa|9,(xr)||; else load first word of value|19491
||blo|8,wa|22,=b_e__|6,evlp2|; loop back to reevaluate expression|19492
;
;      here to restore pattern values after successful eval
;
||mov|7,xl|7,xr||; copy result pointer|19496
||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|19497
||mov|3,pmdfl|10,(xs)+||; restore dot flag|19498
||mov|3,pmssl|10,(xs)+||; restore subject string length|19499
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|19500
||mov|8,wb|10,(xs)+||; restore cursor|19501
||mov|7,xr|10,(xs)+||; restore node pointer|19502
||mov|8,wc|7,xr||; non-zero for simple vrblk|19503
||exi||||; return to evalp caller|19504
;
;      here to return after simple vrblk case
;
|evlp3|zer|8,wc|||; simple vrblk, no side effects|19508
||exi||||; return to evalp caller|19509
;
;      here for failure during evaluation
;
|evlp4|mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|19513
||mov|3,pmdfl|10,(xs)+||; restore dot flag|19514
||mov|3,pmssl|10,(xs)+||; restore subject string length|19515
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|19516
||add|7,xs|19,*num02||; remove node ptr, cursor|19517
||exi|1,1|||; take failure exit|19518
||enp||||; end procedure evalp|19519
||ejc|||||19520
;
;      evals -- evaluate string argument
;
;      evals is used by span, any, notany, break, breakx when
;      they are passed an expression argument.
;
;      (xr)		     node pointer
;      (wb)		     cursor
;      jsr  evals	     call to evaluate string
;      ppm  loc		     transfer loc for non-string arg
;      ppm  loc		     transfer loc for evaluation failure
;      ppm  loc		     transfer loc for successful eval
;      (the normal return is never taken)
;      (xr)		     ptr to node with parms set
;      (xl,wc,ra)	     destroyed
;
;      on return, the node pointed to has a character table
;      pointer in parm1 and a bit mask in parm2. the proper
;      successor is stored in pthen of this node. thus it is
;      ok for merging with the normal (multi-char string) case.
;
|evals|prc|25,r|1,3||; entry point (recursive)|19542
||jsr|6,evalp|||; evaluate expression|19543
||ppm|6,evls1|||; jump if evaluation fails|19544
||mov|11,-(xs)|13,pthen(xr)||; save successor pointer|19545
||mov|11,-(xs)|8,wb||; save cursor|19546
||mov|11,-(xs)|7,xl||; stack result ptr for patst|19547
||zer|8,wb|||; dummy pcode for one char string|19548
||zer|8,wc|||; dummy pcode for expression arg|19549
||mov|7,xl|22,=p_brk||; appropriate pcode for our use|19550
||jsr|6,patst|||; call routine to build node|19551
||ppm|6,evls2|||; jump if not string|19552
||mov|8,wb|10,(xs)+||; restore cursor|19553
||mov|13,pthen(xr)|10,(xs)+||; store successor pointer|19554
||exi|1,3|||; take success return|19555
;
;      here if evaluation fails
;
|evls1|exi|1,2|||; take failure return|19559
;
;      here if argument is not string
;
|evls2|add|7,xs|19,*num02||; pop successor and cursor|19563
||exi|1,1|||; take non-string error exit|19564
||enp||||; end procedure evals|19565
||ejc|||||19566
;
;      evalx -- evaluate expression
;
;      evalx is called to evaluate an expression
;
;      (xr)		     pointer to exblk or seblk
;      (wb)		     0 if by value, 1 if by name
;      jsr  evalx	     call to evaluate expression
;      ppm  loc		     transfer loc if evaluation fails
;      (xr)		     result if called by value
;      (xl,wa)		     result name base,offset if by name
;      (xr)		     destroyed (name case only)
;      (xl,wa)		     destroyed (value case only)
;      (wb,wc,ra)	     destroyed
;
|evalx|prc|25,r|1,1||; entry point, recursive|19582
||beq|9,(xr)|22,=b_exl|6,evlx2|; jump if exblk case|19583
;
;      here for seblk
;
||mov|7,xl|13,sevar(xr)||; load vrblk pointer (name base)|19587
||mov|8,wa|19,*vrval||; set name offset|19588
||bnz|8,wb|6,evlx1||; jump if called by name|19589
||jsr|6,acess|||; call routine to access value|19590
||ppm|6,evlx9|||; jump if failure on access|19591
;
;      merge here to exit for seblk case
;
|evlx1|exi||||; return to evalx caller|19595
||ejc|||||19596
;
;      evalx (continued)
;
;      here for full expression (exblk) case
;
;      if an error occurs in the expression code at execution
;      time, control is passed via error section to exfal
;      without returning to this routine.
;      the following entries are made on the stack before
;      giving control to the expression code
;
;			     evalx return point
;			     saved value of r_cod
;			     code pointer (-r_cod)
;			     saved value of flptr
;			     0 if by value, 1 if by name
;      flptr --------------- *exflc, fail offset in exblk
;
|evlx2|scp|8,wc|||; get code pointer|19615
||mov|8,wa|3,r_cod||; load code block pointer|19616
||sub|8,wc|8,wa||; get code pointer as offset|19617
||mov|11,-(xs)|8,wa||; stack old code block pointer|19618
||mov|11,-(xs)|8,wc||; stack relative code offset|19619
||mov|11,-(xs)|3,flptr||; stack old failure pointer|19620
||mov|11,-(xs)|8,wb||; stack name/value indicator|19621
||mov|11,-(xs)|19,*exflc||; stack new fail offset|19622
||mov|3,gtcef|3,flptr||; keep in case of error|19623
||mov|3,r_gtc|3,r_cod||; keep code block pointer similarly|19624
||mov|3,flptr|7,xs||; set new failure pointer|19625
||mov|3,r_cod|7,xr||; set new code block pointer|19626
||mov|13,exstm(xr)|3,kvstn||; remember stmnt number|19627
||add|7,xr|19,*excod||; point to first code word|19628
||lcp|7,xr|||; set code pointer|19629
||bne|3,stage|18,=stgxt|6,evlx0|; jump if not execution time|19630
||mov|3,stage|18,=stgee||; evaluating expression|19631
;
;      here to execute first code word of expression
;
|evlx0|zer|7,xl|||; clear garbage xl|19635
||lcw|7,xr|||; load first code word|19636
||bri|9,(xr)|||; execute it|19637
||ejc|||||19638
;
;      evalx (continued)
;
;      come here if successful return by value (see o_rvl)
;
|evlx3|mov|7,xr|10,(xs)+||; load value|19644
||bze|13,num01(xs)|6,evlx5||; jump if called by value|19645
||erb|1,249|26,expression evaluated by name returned value|||19646
;
;      here for expression returning by name (see o_rnm)
;
|evlx4|mov|8,wa|10,(xs)+||; load name offset|19650
||mov|7,xl|10,(xs)+||; load name base|19651
||bnz|13,num01(xs)|6,evlx5||; jump if called by name|19652
||jsr|6,acess|||; else access value first|19653
||ppm|6,evlx6|||; jump if failure during access|19654
;
;      here after loading correct result into xr or xl,wa
;
|evlx5|zer|8,wb|||; note successful|19658
||brn|6,evlx7|||; merge|19659
;
;      here for failure in expression evaluation (see o_fex)
;
|evlx6|mnz|8,wb|||; note unsuccessful|19663
;
;      restore environment
;
|evlx7|bne|3,stage|18,=stgee|6,evlx8|; skip if was not previously xt|19667
||mov|3,stage|18,=stgxt||; execute time|19668
;
;      merge with stage set up
;
|evlx8|add|7,xs|19,*num02||; pop name/value indicator, *exfal|19672
||mov|3,flptr|10,(xs)+||; restore old failure pointer|19673
||mov|8,wc|10,(xs)+||; load code offset|19674
||add|8,wc|9,(xs)||; make code pointer absolute|19675
||mov|3,r_cod|10,(xs)+||; restore old code block pointer|19676
||lcp|8,wc|||; restore old code pointer|19677
||bze|8,wb|6,evlx1||; jump for successful return|19678
;
;      merge here for failure in seblk case
;
|evlx9|exi|1,1|||; take failure exit|19682
||enp||||; end of procedure evalx|19683
||ejc|||||19684
;
;      exbld -- build exblk
;
;      exbld is used to build an expression block from the
;      code compiled most recently in the current ccblk.
;
;      (xl)		     offset in ccblk to start of code
;      (wb)		     integer in range 0 le n le mxlen
;      jsr  exbld	     call to build exblk
;      (xr)		     ptr to constructed exblk
;      (wa,wb,xl)	     destroyed
;
|exbld|prc|25,e|1,0||; entry point|19697
||mov|8,wa|7,xl||; copy offset to start of code|19698
||sub|8,wa|19,*excod||; calc reduction in offset in exblk|19699
||mov|11,-(xs)|8,wa||; stack for later|19700
||mov|8,wa|3,cwcof||; load final offset|19701
||sub|8,wa|7,xl||; compute length of code|19702
||add|8,wa|19,*exsi_||; add space for standard fields|19703
||jsr|6,alloc|||; allocate space for exblk|19704
||mov|11,-(xs)|7,xr||; save pointer to exblk|19705
||mov|13,extyp(xr)|22,=b_exl||; store type word|19706
||zer|13,exstm(xr)|||; zeroise stmnt number field|19707
||mov|13,exsln(xr)|3,cmpln||; set line number field|19709
||mov|13,exlen(xr)|8,wa||; store length|19711
||mov|13,exflc(xr)|21,=ofex_||; store failure word|19712
||add|7,xr|19,*exsi_||; set xr for mvw|19713
||mov|3,cwcof|7,xl||; reset offset to start of code|19714
||add|7,xl|3,r_ccb||; point to start of code|19715
||sub|8,wa|19,*exsi_||; length of code to move|19716
||mov|11,-(xs)|8,wa||; stack length of code|19717
||mvw||||; move code to exblk|19718
||mov|8,wa|10,(xs)+||; get length of code|19719
||btw|8,wa|||; convert byte count to word count|19720
||lct|8,wa|8,wa||; prepare counter for loop|19721
||mov|7,xl|9,(xs)||; copy exblk ptr, dont unstack|19722
||add|7,xl|19,*excod||; point to code itself|19723
||mov|8,wb|13,num01(xs)||; get reduction in offset|19724
;
;      this loop searches for negation and selection code so
;      that the offsets computed whilst code was in code block
;      can be transformed to reduced values applicable in an
;      exblk.
;
|exbl1|mov|7,xr|10,(xl)+||; get next code word|19731
||beq|7,xr|21,=osla_|6,exbl3|; jump if selection found|19732
||beq|7,xr|21,=onta_|6,exbl3|; jump if negation found|19733
||bct|8,wa|6,exbl1||; loop to end of code|19734
;
;      no selection found or merge to exit on termination
;
|exbl2|mov|7,xr|10,(xs)+||; pop exblk ptr into xr|19738
||mov|7,xl|10,(xs)+||; pop reduction constant|19739
||exi||||; return to caller|19740
||ejc|||||19741
;
;      exbld (continued)
;
;      selection or negation found
;      reduce the offsets as needed. offsets occur in words
;      following code words -
;	    =onta_, =osla_, =oslb_, =oslc_
;
|exbl3|sub|10,(xl)+|8,wb||; adjust offset|19750
||bct|8,wa|6,exbl4||; decrement count|19751
;
|exbl4|bct|8,wa|6,exbl5||; decrement count|19753
;
;      continue search for more offsets
;
|exbl5|mov|7,xr|10,(xl)+||; get next code word|19757
||beq|7,xr|21,=osla_|6,exbl3|; jump if offset found|19758
||beq|7,xr|21,=oslb_|6,exbl3|; jump if offset found|19759
||beq|7,xr|21,=oslc_|6,exbl3|; jump if offset found|19760
||beq|7,xr|21,=onta_|6,exbl3|; jump if offset found|19761
||bct|8,wa|6,exbl5||; loop|19762
||brn|6,exbl2|||; merge to return|19763
||enp||||; end procedure exbld|19764
||ejc|||||19765
;
;      expan -- analyze expression
;
;      the expression analyzer (expan) procedure is used to scan
;      an expression and convert it into a tree representation.
;      see the description of cmblk in the structures section
;      for detailed format of tree blocks.
;
;      the analyzer uses a simple precedence scheme in which
;      operands and operators are placed on a single stack
;      and condensations are made when low precedence operators
;      are stacked after a higher precedence operator. a global
;      variable (in wb) keeps track of the level as follows.
;
;      0    scanning outer level of statement or expression
;      1    scanning outer level of normal goto
;      2    scanning outer level of direct goto
;      3    scanning inside array brackets
;      4    scanning inside grouping parentheses
;      5    scanning inside function parentheses
;
;      this variable is saved on the stack on encountering a
;      grouping and restored at the end of the grouping.
;
;      another global variable (in wc) counts the number of
;      items at one grouping level and is incremented for each
;      comma encountered. it is stacked with the level indicator
;
;      the scan is controlled by a three state finite machine.
;      a global variable stored in wa is the current state.
;
;      wa=0		     nothing scanned at this level
;      wa=1		     operand expected
;      wa=2		     operator expected
;
;      (wb)		     call type (see below)
;      jsr  expan	     call to analyze expression
;      (xr)		     pointer to resulting tree
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      the entry value of wb indicates the call type as follows.
;
;      0    scanning either the main body of a statement or the
;	    text of an expression (from eval call). valid
;	    terminators are colon, semicolon. the rescan flag is
;	    set to return the terminator on the next scane call.
;
;      1    scanning a normal goto. the only valid
;	    terminator is a right paren.
;
;      2    scanning a direct goto. the only valid
;	    terminator is a right bracket.
||ejc|||||19818
;
;      expan (continued)
;
;      entry point
;
|expan|prc|25,e|1,0||; entry point|19824
||zer|11,-(xs)|||; set top of stack indicator|19825
||zer|8,wa|||; set initial state to zero|19826
||zer|8,wc|||; zero counter value|19827
;
;      loop here for successive entries
;
|exp01|jsr|6,scane|||; scan next element|19831
||add|7,xl|8,wa||; add state to syntax code|19832
||bsw|7,xl|2,t_nes||; switch on element type/state|19833
||iff|2,t_uo0|6,exp27||; unop, s=0|19870
||iff|2,t_uo1|6,exp27||; unop, s=1|19870
||iff|2,t_uo2|6,exp04||; unop, s=2|19870
||iff|2,t_lp0|6,exp06||; left paren, s=0|19870
||iff|2,t_lp1|6,exp06||; left paren, s=1|19870
||iff|2,t_lp2|6,exp04||; left paren, s=2|19870
||iff|2,t_lb0|6,exp08||; left brkt, s=0|19870
||iff|2,t_lb1|6,exp08||; left brkt, s=1|19870
||iff|2,t_lb2|6,exp09||; left brkt, s=2|19870
||iff|2,t_cm0|6,exp02||; comma, s=0|19870
||iff|2,t_cm1|6,exp05||; comma, s=1|19870
||iff|2,t_cm2|6,exp11||; comma, s=2|19870
||iff|2,t_fn0|6,exp10||; function, s=0|19870
||iff|2,t_fn1|6,exp10||; function, s=1|19870
||iff|2,t_fn2|6,exp04||; function, s=2|19870
||iff|2,t_va0|6,exp03||; variable, s=0|19870
||iff|2,t_va1|6,exp03||; variable, state one|19870
||iff|2,t_va2|6,exp04||; variable, s=2|19870
||iff|2,t_co0|6,exp03||; constant, s=0|19870
||iff|2,t_co1|6,exp03||; constant, s=1|19870
||iff|2,t_co2|6,exp04||; constant, s=2|19870
||iff|2,t_bo0|6,exp05||; binop, s=0|19870
||iff|2,t_bo1|6,exp05||; binop, s=1|19870
||iff|2,t_bo2|6,exp26||; binop, s=2|19870
||iff|2,t_rp0|6,exp02||; right paren, s=0|19870
||iff|2,t_rp1|6,exp05||; right paren, s=1|19870
||iff|2,t_rp2|6,exp12||; right paren, s=2|19870
||iff|2,t_rb0|6,exp02||; right brkt, s=0|19870
||iff|2,t_rb1|6,exp05||; right brkt, s=1|19870
||iff|2,t_rb2|6,exp18||; right brkt, s=2|19870
||iff|2,t_cl0|6,exp02||; colon, s=0|19870
||iff|2,t_cl1|6,exp05||; colon, s=1|19870
||iff|2,t_cl2|6,exp19||; colon, s=2|19870
||iff|2,t_sm0|6,exp02||; semicolon, s=0|19870
||iff|2,t_sm1|6,exp05||; semicolon, s=1|19870
||iff|2,t_sm2|6,exp19||; semicolon, s=2|19870
||esw||||; end switch on element type/state|19870
||ejc|||||19871
;
;      expan (continued)
;
;      here for rbr,rpr,col,smc,cma in state 0
;
;      set to rescan the terminator encountered and create
;      a null constant (case of omitted null)
;
|exp02|mnz|3,scnrs|||; set to rescan element|19880
||mov|7,xr|21,=nulls||; point to null, merge|19881
;
;      here for var or con in states 0,1
;
;      stack the variable/constant and set state=2
;
|exp03|mov|11,-(xs)|7,xr||; stack pointer to operand|19887
||mov|8,wa|18,=num02||; set state 2|19888
||brn|6,exp01|||; jump for next element|19889
;
;      here for var,con,lpr,fnc,uop in state 2
;
;      we rescan the element and create a concatenation operator
;      this is the case of the blank concatenation operator.
;
|exp04|mnz|3,scnrs|||; set to rescan element|19896
||mov|7,xr|21,=opdvc||; point to concat operator dv|19897
||bze|8,wb|6,exp4a||; ok if at top level|19898
||mov|7,xr|21,=opdvp||; else point to unmistakable concat.|19899
;
;      merge here when xr set up with proper concatenation dvblk
;
|exp4a|bnz|3,scnbl|6,exp26||; merge bop if blanks, else error|19903
;      dcv  scnse	     adjust start of element location
||erb|1,220|26,syntax error: missing operator|||19905
;
;      here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)
;
;      this is an erronous contruction
;
;exp05 dcv  scnse	     adjust start of element location
|exp05|erb|1,221|26,syntax error: missing operand|||19913
;
;      here for lpr (s=0,1)
;
|exp06|mov|7,xl|18,=num04||; set new level indicator|19917
||zer|7,xr|||; set zero value for cmopn|19918
||ejc|||||19919
;
;      expan (continued)
;
;      merge here to store old level on stack and start new one
;
|exp07|mov|11,-(xs)|7,xr||; stack cmopn value|19925
||mov|11,-(xs)|8,wc||; stack old counter|19926
||mov|11,-(xs)|8,wb||; stack old level indicator|19927
||chk||||; check for stack overflow|19928
||zer|8,wa|||; set new state to zero|19929
||mov|8,wb|7,xl||; set new level indicator|19930
||mov|8,wc|18,=num01||; initialize new counter|19931
||brn|6,exp01|||; jump to scan next element|19932
;
;      here for lbr (s=0,1)
;
;      this is an illegal use of left bracket
;
|exp08|erb|1,222|26,syntax error: invalid use of left bracket|||19938
;
;      here for lbr (s=2)
;
;      set new level and start to scan subscripts
;
|exp09|mov|7,xr|10,(xs)+||; load array ptr for cmopn|19944
||mov|7,xl|18,=num03||; set new level indicator|19945
||brn|6,exp07|||; jump to stack old and start new|19946
;
;      here for fnc (s=0,1)
;
;      stack old level and start to scan arguments
;
|exp10|mov|7,xl|18,=num05||; set new lev indic (xr=vrblk=cmopn)|19952
||brn|6,exp07|||; jump to stack old and start new|19953
;
;      here for cma (s=2)
;
;      increment argument count and continue
;
|exp11|icv|8,wc|||; increment counter|19959
||jsr|6,expdm|||; dump operators at this level|19960
||zer|11,-(xs)|||; set new level for parameter|19961
||zer|8,wa|||; set new state|19962
||bgt|8,wb|18,=num02|6,exp01|; loop back unless outer level|19963
||erb|1,223|26,syntax error: invalid use of comma|||19964
||ejc|||||19965
;
;      expan (continued)
;
;      here for rpr (s=2)
;
;      at outer level in a normal goto this is a terminator
;      otherwise it must terminate a function or grouping
;
|exp12|beq|8,wb|18,=num01|6,exp20|; end of normal goto|19974
||beq|8,wb|18,=num05|6,exp13|; end of function arguments|19975
||beq|8,wb|18,=num04|6,exp14|; end of grouping / selection|19976
||erb|1,224|26,syntax error: unbalanced right parenthesis|||19977
;
;      here at end of function arguments
;
|exp13|mov|7,xl|18,=c_fnc||; set cmtyp value for function|19981
||brn|6,exp15|||; jump to build cmblk|19982
;
;      here for end of grouping
;
|exp14|beq|8,wc|18,=num01|6,exp17|; jump if end of grouping|19986
||mov|7,xl|18,=c_sel||; else set cmtyp for selection|19987
;
;      merge here to build cmblk for level just scanned and
;      to pop up to the previous scan level before continuing.
;
|exp15|jsr|6,expdm|||; dump operators at this level|19992
||mov|8,wa|8,wc||; copy count|19993
||add|8,wa|18,=cmvls||; add for standard fields at start|19994
||wtb|8,wa|||; convert length to bytes|19995
||jsr|6,alloc|||; allocate space for cmblk|19996
||mov|9,(xr)|22,=b_cmt||; store type code for cmblk|19997
||mov|13,cmtyp(xr)|7,xl||; store cmblk node type indicator|19998
||mov|13,cmlen(xr)|8,wa||; store length|19999
||add|7,xr|8,wa||; point past end of block|20000
||lct|8,wc|8,wc||; set loop counter|20001
;
;      loop to move remaining words to cmblk
;
|exp16|mov|11,-(xr)|10,(xs)+||; move one operand ptr from stack|20005
||mov|8,wb|10,(xs)+||; pop to old level indicator|20006
||bct|8,wc|6,exp16||; loop till all moved|20007
||ejc|||||20008
;
;      expan (continued)
;
;      complete cmblk and stack pointer to it on stack
;
||sub|7,xr|19,*cmvls||; point back to start of block|20014
||mov|8,wc|10,(xs)+||; restore old counter|20015
||mov|13,cmopn(xr)|9,(xs)||; store operand ptr in cmblk|20016
||mov|9,(xs)|7,xr||; stack cmblk pointer|20017
||mov|8,wa|18,=num02||; set new state|20018
||brn|6,exp01|||; back for next element|20019
;
;      here at end of a parenthesized expression
;
|exp17|jsr|6,expdm|||; dump operators at this level|20023
||mov|7,xr|10,(xs)+||; restore xr|20024
||mov|8,wb|10,(xs)+||; restore outer level|20025
||mov|8,wc|10,(xs)+||; restore outer count|20026
||mov|9,(xs)|7,xr||; store opnd over unused cmopn val|20027
||mov|8,wa|18,=num02||; set new state|20028
||brn|6,exp01|||; back for next ele8ent|20029
;
;      here for rbr (s=2)
;
;      at outer level in a direct goto, this is a terminator.
;      otherwise it must terminate a subscript list.
;
|exp18|mov|7,xl|18,=c_arr||; set cmtyp for array reference|20036
||beq|8,wb|18,=num03|6,exp15|; jump to build cmblk if end arrayref|20037
||beq|8,wb|18,=num02|6,exp20|; jump if end of direct goto|20038
||erb|1,225|26,syntax error: unbalanced right bracket|||20039
||ejc|||||20040
;
;      expan (continued)
;
;      here for col,smc (s=2)
;
;      error unless terminating statement body at outer level
;
|exp19|mnz|3,scnrs|||; rescan terminator|20048
||mov|7,xl|8,wb||; copy level indicator|20049
||bsw|7,xl|1,6||; switch on level indicator|20050
||iff|1,0|6,exp20||; normal outer level|20057
||iff|1,1|6,exp22||; fail if normal goto|20057
||iff|1,2|6,exp23||; fail if direct goto|20057
||iff|1,3|6,exp24||; fail array brackets|20057
||iff|1,4|6,exp21||; fail if in grouping|20057
||iff|1,5|6,exp21||; fail function args|20057
||esw||||; end switch on level|20057
;
;      here at normal end of expression
;
|exp20|jsr|6,expdm|||; dump remaining operators|20061
||mov|7,xr|10,(xs)+||; load tree pointer|20062
||ica|7,xs|||; pop off bottom of stack marker|20063
||exi||||; return to expan caller|20064
;
;      missing right paren
;
|exp21|erb|1,226|26,syntax error: missing right paren|||20068
;
;      missing right paren in goto field
;
|exp22|erb|1,227|26,syntax error: right paren missing from goto|||20072
;
;      missing bracket in goto
;
|exp23|erb|1,228|26,syntax error: right bracket missing from goto|||20076
;
;      missing array bracket
;
|exp24|erb|1,229|26,syntax error: missing right array bracket|||20080
||ejc|||||20081
;
;      expan (continued)
;
;      loop here when an operator causes an operator dump
;
|exp25|mov|3,expsv|7,xr||;|20087
||jsr|6,expop|||; pop one operator|20088
||mov|7,xr|3,expsv||; restore op dv pointer and merge|20089
;
;      here for bop (s=2)
;
;      remove operators (condense) from stack until no more
;      left at this level or top one has lower precedence.
;      loop here till this condition is met.
;
|exp26|mov|7,xl|13,num01(xs)||; load operator dvptr from stack|20097
||ble|7,xl|18,=num05|6,exp27|; jump if bottom of stack level|20098
||blt|13,dvrpr(xr)|13,dvlpr(xl)|6,exp25|; else pop if new prec is lo|20099
;
;      here for uop (s=0,1)
;
;      binary operator merges after precedence check
;
;      the operator dv is stored on the stack and the scan
;      continues after setting the scan state to one.
;
|exp27|mov|11,-(xs)|7,xr||; stack operator dvptr on stack|20108
||chk||||; check for stack overflow|20109
||mov|8,wa|18,=num01||; set new state|20110
||bne|7,xr|21,=opdvs|6,exp01|; back for next element unless =|20111
;
;      here for special case of binary =. the syntax allows a
;      null right argument for this operator to be left
;      out. accordingly we reset to state zero to get proper
;      action on a terminator (supply a null constant).
;
||zer|8,wa|||; set state zero|20118
||brn|6,exp01|||; jump for next element|20119
||enp||||; end procedure expan|20120
||ejc|||||20121
;
;      expap -- test for pattern match tree
;
;      expap is passed an expression tree to determine if it
;      is a pattern match. the following are recogized as
;      matches in the context of this call.
;
;      1)   an explicit use of binary question mark
;      2)   a concatenation
;      3)   an alternation whose left operand is a concatenation
;
;      (xr)		     ptr to expan tree
;      jsr  expap	     call to test for pattern match
;      ppm  loc		     transfer loc if not a pattern match
;      (wa)		     destroyed
;      (xr)		     unchanged (if not match)
;      (xr)		     ptr to binary operator blk if match
;
|expap|prc|25,e|1,1||; entry point|20140
||mov|11,-(xs)|7,xl||; save xl|20141
||bne|9,(xr)|22,=b_cmt|6,expp2|; no match if not complex|20142
||mov|8,wa|13,cmtyp(xr)||; else load type code|20143
||beq|8,wa|18,=c_cnc|6,expp1|; concatenation is a match|20144
||beq|8,wa|18,=c_pmt|6,expp1|; binary question mark is a match|20145
||bne|8,wa|18,=c_alt|6,expp2|; else not match unless alternation|20146
;
;      here for alternation. change (a b) / c to a qm (b / c)
;
||mov|7,xl|13,cmlop(xr)||; load left operand pointer|20150
||bne|9,(xl)|22,=b_cmt|6,expp2|; not match if left opnd not complex|20151
||bne|13,cmtyp(xl)|18,=c_cnc|6,expp2|; not match if left op not conc|20152
||mov|13,cmlop(xr)|13,cmrop(xl)||; xr points to (b / c)|20153
||mov|13,cmrop(xl)|7,xr||; set xl opnds to a, (b / c)|20154
||mov|7,xr|7,xl||; point to this altered node|20155
;
;      exit here for pattern match
;
|expp1|mov|7,xl|10,(xs)+||; restore entry xl|20159
||exi||||; give pattern match return|20160
;
;      exit here if not pattern match
;
|expp2|mov|7,xl|10,(xs)+||; restore entry xl|20164
||exi|1,1|||; give non-match return|20165
||enp||||; end procedure expap|20166
||ejc|||||20167
;
;      expdm -- dump operators at current level (for expan)
;
;      expdm uses expop to condense all operators at this syntax
;      level. the stack bottom is recognized from the level
;      value which is saved on the top of the stack.
;
;      jsr  expdm	     call to dump operators
;      (xs)		     popped as required
;      (xr,wa)		     destroyed
;
|expdm|prc|25,n|1,0||; entry point|20179
||mov|3,r_exs|7,xl||; save xl value|20180
;
;      loop to dump operators
;
|exdm1|ble|13,num01(xs)|18,=num05|6,exdm2|; jump if stack bottom (saved level|20184
||jsr|6,expop|||; else pop one operator|20185
||brn|6,exdm1|||; and loop back|20186
;
;      here after popping all operators
;
|exdm2|mov|7,xl|3,r_exs||; restore xl|20190
||zer|3,r_exs|||; release save location|20191
||exi||||; return to expdm caller|20192
||enp||||; end procedure expdm|20193
||ejc|||||20194
;
;      expop-- pop operator (for expan)
;
;      expop is used by the expan routine to condense one
;      operator from the top of the syntax stack. an appropriate
;      cmblk is built for the operator (unary or binary) and a
;      pointer to this cmblk is stacked.
;
;      expop is also used by scngf (goto field scan) procedure
;
;      jsr  expop	     call to pop operator
;      (xs)		     popped appropriately
;      (xr,xl,wa)	     destroyed
;
|expop|prc|25,n|1,0||; entry point|20209
||mov|7,xr|13,num01(xs)||; load operator dv pointer|20210
||beq|13,dvlpr(xr)|18,=lluno|6,expo2|; jump if unary|20211
;
;      here for binary operator
;
||mov|8,wa|19,*cmbs_||; set size of binary operator cmblk|20215
||jsr|6,alloc|||; allocate space for cmblk|20216
||mov|13,cmrop(xr)|10,(xs)+||; pop and store right operand ptr|20217
||mov|7,xl|10,(xs)+||; pop and load operator dv ptr|20218
||mov|13,cmlop(xr)|9,(xs)||; store left operand pointer|20219
;
;      common exit point
;
|expo1|mov|9,(xr)|22,=b_cmt||; store type code for cmblk|20223
||mov|13,cmtyp(xr)|13,dvtyp(xl)||; store cmblk node type code|20224
||mov|13,cmopn(xr)|7,xl||; store dvptr (=ptr to dac o_xxx)|20225
||mov|13,cmlen(xr)|8,wa||; store cmblk length|20226
||mov|9,(xs)|7,xr||; store resulting node ptr on stack|20227
||exi||||; return to expop caller|20228
;
;      here for unary operator
;
|expo2|mov|8,wa|19,*cmus_||; set size of unary operator cmblk|20232
||jsr|6,alloc|||; allocate space for cmblk|20233
||mov|13,cmrop(xr)|10,(xs)+||; pop and store operand pointer|20234
||mov|7,xl|9,(xs)||; load operator dv pointer|20235
||brn|6,expo1|||; merge back to exit|20236
||enp||||; end procedure expop|20237
||ejc|||||20238
;
;      filnm -- obtain file name from statement number
;
;      filnm takes a statement number and examines the file name
;      table pointed to by r_sfn to find the name of the file
;      containing the given statement.	table entries are
;      arranged in order of ascending statement number (there
;      is only one hash bucket in this table).	elements are
;      added to the table each time there is a change in
;      file name, recording the then current statement number.
;
;      to find the file name, the linked list of teblks is
;      scanned for an element containing a subscript (statement
;      number) greater than the argument statement number, or
;      the end of chain.  when this condition is met, the
;      previous teblk contains the desired file name as its
;      value entry.
;
;      (wc)		     statement number
;      jsr  filnm	     call to obtain file name
;      (xl)		     file name (scblk)
;      (ia)		     destroyed
;
|filnm|prc|25,e|1,0||; entry point|20263
||mov|11,-(xs)|8,wb||; preserve wb|20264
||bze|8,wc|6,filn3||; return nulls if stno is zero|20265
||mov|7,xl|3,r_sfn||; file name table|20266
||bze|7,xl|6,filn3||; if no table|20267
||mov|8,wb|13,tbbuk(xl)||; get bucket entry|20268
||beq|8,wb|3,r_sfn|6,filn3|; jump if no teblks on chain|20269
||mov|11,-(xs)|7,xr||; preserve xr|20270
||mov|7,xr|8,wb||; previous block pointer|20271
||mov|11,-(xs)|8,wc||; preserve stmt number|20272
;
;      loop through teblks on hash chain
;
|filn1|mov|7,xl|7,xr||; next element to examine|20276
||mov|7,xr|13,tesub(xl)||; load subscript value (an icblk)|20277
||ldi|13,icval(xr)|||; load the statement number|20278
||mfi|8,wc|||; convert to address constant|20279
||blt|9,(xs)|8,wc|6,filn2|; compare arg with teblk stmt number|20280
;
;      here if desired stmt number is ge teblk stmt number
;
||mov|8,wb|7,xl||; save previous entry pointer|20284
||mov|7,xr|13,tenxt(xl)||; point to next teblk on chain|20285
||bne|7,xr|3,r_sfn|6,filn1|; jump if there is one|20286
;
;      here if chain exhausted or desired block found.
;
|filn2|mov|7,xl|8,wb||; previous teblk|20290
||mov|7,xl|13,teval(xl)||; get ptr to file name scblk|20291
||mov|8,wc|10,(xs)+||; restore stmt number|20292
||mov|7,xr|10,(xs)+||; restore xr|20293
||mov|8,wb|10,(xs)+||; restore wb|20294
||exi|||||20295
;
;      no table or no table entries
;
|filn3|mov|8,wb|10,(xs)+||; restore wb|20299
||mov|7,xl|21,=nulls||; return null string|20300
||exi|||||20301
||enp|||||20302
||ejc|||||20303
;
;
;      flstg -- fold string to lower case
;
;      flstg folds a character string containing upper case
;      characcters to one containing lower case characters.
;      folding is only done if &case (kvcas) is not zero.
;
;      (xr)		     string argument
;      (wa)		     length of string
;      jsr  flstg	     call to fold string
;      (xr)		     result string (possibly original)
;      (wc)		     destroyed
;
|flstg|prc|25,e|1,0||; entry point|20320
||bze|3,kvcas|6,fst99||; skip if &case is 0|20321
||mov|11,-(xs)|7,xl||; save xl across call|20322
||mov|11,-(xs)|7,xr||; save original scblk ptr|20323
||jsr|6,alocs|||; allocate new string block|20324
||mov|7,xl|9,(xs)||; point to original scblk|20325
||mov|11,-(xs)|7,xr||; save pointer to new scblk|20326
||plc|7,xl|||; point to original chars|20327
||psc|7,xr|||; point to new chars|20328
||zer|11,-(xs)|||; init did fold flag|20329
||lct|8,wc|8,wc||; load loop counter|20330
|fst01|lch|8,wa|10,(xl)+||; load character|20331
||blt|8,wa|18,=ch_ua|6,fst02|; skip if less than uc a|20332
||bgt|8,wa|18,=ch_uz|6,fst02|; skip if greater than uc z|20333
||flc|8,wa|||; fold character to lower case|20334
||mnz|9,(xs)|||; set did fold character flag|20335
|fst02|sch|8,wa|10,(xr)+||; store (possibly folded) character|20336
||bct|8,wc|6,fst01||; loop thru entire string|20337
||csc|7,xr|||; complete store characters|20338
||mov|7,xr|10,(xs)+||; see if any change|20339
||bnz|7,xr|6,fst10||; skip if folding done (no change)|20340
||mov|3,dnamp|10,(xs)+||; do not need new scblk|20341
||mov|7,xr|10,(xs)+||; return original scblk|20342
||brn|6,fst20|||; merge below|20343
|fst10|mov|7,xr|10,(xs)+||; return new scblk|20344
||ica|7,xs|||; throw away original scblk pointer|20345
|fst20|mov|8,wa|13,sclen(xr)||; reload string length|20346
||mov|7,xl|10,(xs)+||; restore xl|20347
|fst99|exi||||; return|20348
||enp|||||20349
||ejc|||||20350
;
;      gbcol -- perform garbage collection
;
;      gbcol performs a garbage collection on the dynamic region
;      all blocks which are no longer in use are eliminated
;      by moving blocks which are in use down and resetting
;      dnamp, the pointer to the next available location.
;
;      (wb)		     move offset (see below)
;      jsr  gbcol	     call to collect garbage
;      (xr)		     sediment size after collection
;
;      the following conditions must be met at the time when
;      gbcol is called.
;
;      1)   all pointers to blocks in the dynamic area must be
;	    accessible to the garbage collector. this means
;	    that they must occur in one of the following.
;
;	    a)		     main stack, with current top
;			     element being indicated by xs
;
;	    b)		     in relocatable fields of vrblks.
;
;	    c)		     in register xl at the time of call
;
;	    e)		     in the special region of working
;			     storage where names begin with r_.
;
;      2)   all pointers must point to the start of blocks with
;	    the sole exception of the contents of the code
;	    pointer register which points into the r_cod block.
;
;      3)   no location which appears to contain a pointer
;	    into the dynamic region may occur unless it is in
;	    fact a pointer to the start of the block. however
;	    pointers outside this area may occur and will
;	    not be changed by the garbage collector.
;	    it is especially important to make sure that xl
;	    does not contain a garbage value from some process
;	    carried out before the call to the collector.
;
;      gbcol has the capability of moving the final compacted
;      result up in memory (with addresses adjusted accordingly)
;      this is used to add space to the static region. the
;      entry value of wb is the number of bytes to move up.
;      the caller must guarantee that there is enough room.
;      furthermore the value in wb if it is non-zero, must be at
;      least 256 so that the mwb instruction conditions are met.
||ejc|||||20405
;
;      gbcol (continued)
;
;      the algorithm, which is a modification of the lisp-2
;      garbage collector devised by r.dewar and k.belcher
;      takes three passes as follows.
;
;      1)   all pointers in memory are scanned and blocks in use
;	    determined from this scan. note that this procedure
;	    is recursive and uses the main stack for linkage.
;	    the marking process is thus similar to that used in
;	    a standard lisp collector. however the method of
;	    actually marking the blocks is different.
;
;	    the first field of a block normally contains a
;	    code entry point pointer. such an entry pointer
;	    can be distinguished from the address of any pointer
;	    to be processed by the collector. during garbage
;	    collection, this word is used to build a back chain
;	    of pointers through fields which point to the block.
;	    the end of the chain is marked by the occurence
;	    of the word which used to be in the first word of
;	    the block. this backchain serves both as a mark
;	    indicating that the block is in use and as a list of
;	    references for the relocation phase.
;
;      2)   storage is scanned sequentially to discover which
;	    blocks are currently in use as indicated by the
;	    presence of a backchain. two pointers are maintained
;	    one scans through looking at each block. the other
;	    is incremented only for blocks found to be in use.
;	    in this way, the eventual location of each block can
;	    be determined without actually moving any blocks.
;	    as each block which is in use is processed, the back
;	    chain is used to reset all pointers which point to
;	    this block to contain its new address, i.e. the
;	    address it will occupy after the blocks are moved.
;	    the first word of the block, taken from the end of
;	    the chain is restored at this point.
;
;	    during pass 2, the collector builds blocks which
;	    describe the regions of storage which are to be
;	    moved in the third pass. there is one descriptor for
;	    each contiguous set of good blocks. the descriptor
;	    is built just behind the block to be moved and
;	    contains a pointer to the next block and the number
;	    of words to be moved.
;
;      3)   in the third and final pass, the move descriptor
;	    blocks built in pass two are used to actually move
;	    the blocks down to the bottom of the dynamic region.
;	    the collection is then complete and the next
;	    available location pointer is reset.
||ejc|||||20459
;
;      gbcol (continued)
;
;      the garbage collector also recognizes the concept of
;      sediment.  sediment is defined as long-lived objects
;      which percipitate to the bottom of dynamic storage.
;      moving these objects during repeated collections is
;      inefficient.  it also contributes to thrashing on
;      systems with virtual memory.  in a typical worst-case
;      situation, there may be several megabytes of live objects
;      in the sediment, and only a few dead objects in need of
;      collection.  without recognising sediment, the standard
;      collector would move those megabytes of objects downward
;      to squeeze out the dead objects.	 this type of move
;      would result in excessive thrasing for very little memory
;      gain.
;
;      scanning of blocks in the sediment cannot be avoided
;      entirely, because these blocks may contain pointers to
;      live objects above the sediment.	 however, sediment
;      blocks need not be linked to a back chain as described
;      in pass one above.  since these blocks will not be moved,
;      pointers to them do not need to be adjusted.  eliminating
;      unnecessary back chain links increases locality of
;      reference, improving virtual memory performance.
;
;      because back chains are used to mark blocks whose con-
;      tents have been processed, a different marking system
;      is needed for blocks in the sediment.  since block type
;      words point to odd-parity entry addresses, merely incre-
;      menting the type word serves to mark the block as pro-
;      cessed.	during pass three, the type words are decre-
;      mented to restore them to their original value.
||ejc|||||20503
;
;      gbcol (continued)
;
;
;      the variable dnams contains the number of bytes of memory
;      currently in the sediment.  setting dnams to zero will
;      eliminate the sediment and force it to be included in a
;      full garbage collection.	 gbcol returns a suggested new
;      value for dnams (usually dnamp-dnamb) in xr which the
;      caller can store in dnams if it wishes to maintain the
;      sediment.  that is, data remaining after a garbage
;      collection is considered to be sediment.	 if one accepts
;      the common lore that most objects are either very short-
;      or very long-lived, then this naive setting of dnams
;      probably includes some short-lived objects toward the end
;      of the sediment.
;
;      knowing when to reset dnams to zero to collect the sedi-
;      ment is not precisely known.  we force it to zero prior
;      to producing a dump, when gbcol is invoked by collect()
;      (so that the sediment is invisible to the user), when
;      sysmm is unable to obtain additional memory, and when
;      gbcol is called to relocate the dynamic area up in memory
;      (to make room for enlarging the static area).  if there
;      are no other reset situations, this leads to the inexo-
;      rable growth of the sediment, possible forcing a modest
;      program to begin to use virtual memory that it otherwise
;      would not.
;
;      as we scan sediment blocks in pass three, we maintain
;      aggregate counts of the amount of dead and live storage,
;      which is used to decide when to reset dnams.  when the
;      ratio of free storage found in the sediment to total
;      sediment size exceeds a threshold, the sediment is marked
;      for collection on the next gbcol call.
;
||ejc|||||20541
;
;      gbcol (continued)
;
|gbcol|prc|25,e|1,0||; entry point|20545
;z-
||bnz|3,dmvch|6,gbc14||; fail if in mid-dump|20547
||mnz|3,gbcfl|||; note gbcol entered|20548
||mov|3,gbsva|8,wa||; save entry wa|20549
||mov|3,gbsvb|8,wb||; save entry wb|20550
||mov|3,gbsvc|8,wc||; save entry wc|20551
||mov|11,-(xs)|7,xl||; save entry xl|20552
||scp|8,wa|||; get code pointer value|20553
||sub|8,wa|3,r_cod||; make relative|20554
||lcp|8,wa|||; and restore|20555
||bze|8,wb|6,gbc0a||; check there is no move offset|20557
||zer|3,dnams|||; collect sediment if must move it|20558
|gbc0a|mov|8,wa|3,dnamb||; start of dynamic area|20559
||add|8,wa|3,dnams||; size of sediment|20560
||mov|3,gbcsd|8,wa||; first location past sediment|20561
;
;      inform sysgc that collection to commence
;
||mnz|7,xr|||; non-zero flags start of collection|20574
||mov|8,wa|3,dnamb||; start of dynamic area|20575
||mov|8,wb|3,dnamp||; next available location|20576
||mov|8,wc|3,dname||; last available location + 1|20577
||jsr|6,sysgc|||; inform of collection|20578
;
;      process stack entries
;
||mov|7,xr|7,xs||; point to stack front|20583
||mov|7,xl|3,stbas||; point past end of stack|20584
||bge|7,xl|7,xr|6,gbc00|; ok if d-stack|20585
||mov|7,xr|7,xl||; reverse if ...|20586
||mov|7,xl|7,xs||; ... u-stack|20587
;
;      process the stack
;
|gbc00|jsr|6,gbcpf|||; process pointers on stack|20591
;
;      process special work locations
;
||mov|7,xr|20,=r_aaa||; point to start of relocatable locs|20595
||mov|7,xl|20,=r_yyy||; point past end of relocatable locs|20596
||jsr|6,gbcpf|||; process work fields|20597
;
;      prepare to process variable blocks
;
||mov|8,wa|3,hshtb||; point to first hash slot pointer|20601
;
;      loop through hash slots
;
|gbc01|mov|7,xl|8,wa||; point to next slot|20605
||ica|8,wa|||; bump bucket pointer|20606
||mov|3,gbcnm|8,wa||; save bucket pointer|20607
||ejc|||||20608
;
;      gbcol (continued)
;
;      loop through variables on one hash chain
;
|gbc02|mov|7,xr|9,(xl)||; load ptr to next vrblk|20614
||bze|7,xr|6,gbc03||; jump if end of chain|20615
||mov|7,xl|7,xr||; else copy vrblk pointer|20616
||add|7,xr|19,*vrval||; point to first reloc fld|20617
||add|7,xl|19,*vrnxt||; point past last (and to link ptr)|20618
||jsr|6,gbcpf|||; process reloc fields in vrblk|20619
||brn|6,gbc02|||; loop back for next block|20620
;
;      here at end of one hash chain
;
|gbc03|mov|8,wa|3,gbcnm||; restore bucket pointer|20624
||bne|8,wa|3,hshte|6,gbc01|; loop back if more buckets to go|20625
||ejc|||||20626
;
;      gbcol (continued)
;
;      now we are ready to start pass two. registers are used
;      as follows in pass two.
;
;      (xr)		     scans through all blocks
;      (wc)		     pointer to eventual location
;
;      the move description blocks built in this pass have
;      the following format.
;
;      word 1		     pointer to next move block,
;			     zero if end of chain of blocks
;
;      word 2		     length of blocks to be moved in
;			     bytes. set to the address of the
;			     first byte while actually scanning
;			     the blocks.
;
;      the first entry on this chain is a special entry
;      consisting of the two words gbcnm and gbcns. after
;      building the chain of move descriptors, gbcnm points to
;      the first real move block, and gbcns is the length of
;      blocks in use at the start of storage which need not
;      be moved since they are in the correct position.
;
||mov|7,xr|3,dnamb||; point to first block|20655
||zer|8,wb|||; accumulate size of dead blocks|20656
|gbc04|beq|7,xr|3,gbcsd|6,gbc4c|; jump if end of sediment|20657
||mov|8,wa|9,(xr)||; else get first word|20658
||bod|8,wa|6,gbc4b||; jump if entry pointer (unused)|20660
||dcv|8,wa|||; restore entry pointer|20661
||mov|9,(xr)|8,wa||; restore first word|20667
||jsr|6,blkln|||; get length of this block|20668
||add|7,xr|8,wa||; bump actual pointer|20669
||brn|6,gbc04|||; continue scan through sediment|20670
;
;      here for unused sediment block
;
|gbc4b|jsr|6,blkln|||; get length of this block|20674
||add|7,xr|8,wa||; bump actual pointer|20675
||add|8,wb|8,wa||; count size of unused blocks|20676
||brn|6,gbc04|||; continue scan through sediment|20677
;
;      here at end of sediment.	 remember size of free blocks
;      within the sediment.  this will be used later to decide
;      how to set the sediment size returned to caller.
;
;      then scan rest of dynamic area above sediment.
;
;      (wb) = aggregate size of free blocks in sediment
;      (xr) = first location past sediment
;
|gbc4c|mov|3,gbcsf|8,wb||; size of sediment free space|20688
||mov|8,wc|7,xr||; set as first eventual location|20692
||add|8,wc|3,gbsvb||; add offset for eventual move up|20693
||zer|3,gbcnm|||; clear initial forward pointer|20694
||mov|3,gbclm|20,=gbcnm||; initialize ptr to last move block|20695
||mov|3,gbcns|7,xr||; initialize first address|20696
;
;      loop through a series of blocks in use
;
|gbc05|beq|7,xr|3,dnamp|6,gbc07|; jump if end of used region|20700
||mov|8,wa|9,(xr)||; else get first word|20701
||bod|8,wa|6,gbc07||; jump if entry pointer (unused)|20703
;
;      here for block in use, loop to relocate references
;
|gbc06|mov|7,xl|8,wa||; copy pointer|20711
||mov|8,wa|9,(xl)||; load forward pointer|20712
||mov|9,(xl)|8,wc||; relocate reference|20713
||bev|8,wa|6,gbc06||; loop back if not end of chain|20715
||ejc|||||20720
;
;      gbcol (continued)
;
;      at end of chain, restore first word and bump past
;
||mov|9,(xr)|8,wa||; restore first word|20726
||jsr|6,blkln|||; get length of this block|20727
||add|7,xr|8,wa||; bump actual pointer|20728
||add|8,wc|8,wa||; bump eventual pointer|20729
||brn|6,gbc05|||; loop back for next block|20730
;
;      here at end of a series of blocks in use
;
|gbc07|mov|8,wa|7,xr||; copy pointer past last block|20734
||mov|7,xl|3,gbclm||; point to previous move block|20735
||sub|8,wa|13,num01(xl)||; subtract starting address|20736
||mov|13,num01(xl)|8,wa||; store length of block to be moved|20737
;
;      loop through a series of blocks not in use
;
|gbc08|beq|7,xr|3,dnamp|6,gbc10|; jump if end of used region|20741
||mov|8,wa|9,(xr)||; else load first word of next block|20742
||bev|8,wa|6,gbc09||; jump if in use|20744
||jsr|6,blkln|||; else get length of next block|20749
||add|7,xr|8,wa||; push pointer|20750
||brn|6,gbc08|||; and loop back|20751
;
;      here for a block in use after processing a series of
;      blocks which were not in use, build new move block.
;
|gbc09|sub|7,xr|19,*num02||; point 2 words behind for move block|20756
||mov|7,xl|3,gbclm||; point to previous move block|20757
||mov|9,(xl)|7,xr||; set forward ptr in previous block|20758
||zer|9,(xr)|||; zero forward ptr of new block|20759
||mov|3,gbclm|7,xr||; remember address of this block|20760
||mov|7,xl|7,xr||; copy ptr to move block|20761
||add|7,xr|19,*num02||; point back to block in use|20762
||mov|13,num01(xl)|7,xr||; store starting address|20763
||brn|6,gbc06|||; jump to process block in use|20764
||ejc|||||20765
;
;      gbcol (continued)
;
;      here for pass three -- actually move the blocks down
;
;      (xl)		     pointer to old location
;      (xr)		     pointer to new location
;
|gbc10|mov|7,xr|3,gbcsd||; point to storage above sediment|20775
||add|7,xr|3,gbcns||; bump past unmoved blocks at start|20779
;
;      loop through move descriptors
;
|gbc11|mov|7,xl|3,gbcnm||; point to next move block|20783
||bze|7,xl|6,gbc12||; jump if end of chain|20784
||mov|3,gbcnm|10,(xl)+||; move pointer down chain|20785
||mov|8,wa|10,(xl)+||; get length to move|20786
||mvw||||; perform move|20787
||brn|6,gbc11|||; loop back|20788
;
;      now test for move up
;
|gbc12|mov|3,dnamp|7,xr||; set next available loc ptr|20792
||mov|8,wb|3,gbsvb||; reload move offset|20793
||bze|8,wb|6,gbc13||; jump if no move required|20794
||mov|7,xl|7,xr||; else copy old top of core|20795
||add|7,xr|8,wb||; point to new top of core|20796
||mov|3,dnamp|7,xr||; save new top of core pointer|20797
||mov|8,wa|7,xl||; copy old top|20798
||sub|8,wa|3,dnamb||; minus old bottom = length|20799
||add|3,dnamb|8,wb||; bump bottom to get new value|20800
||mwb||||; perform move (backwards)|20801
;
;      merge here to exit
;
|gbc13|zer|7,xr|||; clear garbage value in xr|20805
||mov|3,gbcfl|7,xr||; note exit from gbcol|20806
||mov|8,wa|3,dnamb||; start of dynamic area|20808
||mov|8,wb|3,dnamp||; next available location|20809
||mov|8,wc|3,dname||; last available location + 1|20810
||jsr|6,sysgc|||; inform sysgc of completion|20811
;
;      decide whether to mark sediment for collection next time.
;      this is done by examining the ratio of previous sediment
;      free space to the new sediment size.
;
||sti|3,gbcia|||; save ia|20819
||zer|7,xr|||; presume no sediment will remain|20820
||mov|8,wb|3,gbcsf||; free space in sediment|20821
||btw|8,wb|||; convert bytes to words|20822
||mti|8,wb|||; put sediment free store in ia|20823
||mli|3,gbsed|||; multiply by sediment factor|20824
||iov|6,gb13a|||; jump if overflowed|20825
||mov|8,wb|3,dnamp||; end of dynamic area in use|20826
||sub|8,wb|3,dnamb||; minus start is sediment remaining|20827
||btw|8,wb|||; convert to words|20828
||mov|3,gbcsf|8,wb||; store it|20829
||sbi|3,gbcsf|||; subtract from scaled up free store|20830
||igt|6,gb13a|||; jump if large free store in sedimnt|20831
||mov|7,xr|3,dnamp||; below threshold, return sediment|20832
||sub|7,xr|3,dnamb||; for use by caller|20833
|gb13a|ldi|3,gbcia|||; restore ia|20834
||mov|8,wa|3,gbsva||; restore wa|20836
||mov|8,wb|3,gbsvb||; restore wb|20837
||scp|8,wc|||; get code pointer|20838
||add|8,wc|3,r_cod||; make absolute again|20839
||lcp|8,wc|||; and replace absolute value|20840
||mov|8,wc|3,gbsvc||; restore wc|20841
||mov|7,xl|10,(xs)+||; restore entry xl|20842
||icv|3,gbcnt|||; increment count of collections|20843
||exi||||; exit to gbcol caller|20844
;
;      garbage collection not allowed whilst dumping
;
|gbc14|icv|3,errft|||; fatal error|20848
||erb|1,250|26,insufficient memory to complete dump|||20849
||enp||||; end procedure gbcol|20850
||ejc|||||20851
;
;      gbcpf -- process fields for garbage collector
;
;      this procedure is used by the garbage collector to
;      process fields in pass one. see gbcol for full details.
;
;      (xr)		     ptr to first location to process
;      (xl)		     ptr past last location to process
;      jsr  gbcpf	     call to process fields
;      (xr,wa,wb,wc,ia)	     destroyed
;
;      note that although this procedure uses a recursive
;      approach, it controls its own stack and is not recursive.
;
|gbcpf|prc|25,e|1,0||; entry point|20866
||zer|11,-(xs)|||; set zero to mark bottom of stack|20867
||mov|11,-(xs)|7,xl||; save end pointer|20868
;
;      merge here to go down a level and start a new loop
;
;      1(xs)		     next lvl field ptr (0 at outer lvl)
;      0(xs)		     ptr past last field to process
;      (xr)		     ptr to first field to process
;
;      loop to process successive fields
;
|gpf01|mov|7,xl|9,(xr)||; load field contents|20878
||mov|8,wc|7,xr||; save field pointer|20879
||blt|7,xl|3,dnamb|6,gpf2a|; jump if not ptr into dynamic area|20883
||bge|7,xl|3,dnamp|6,gpf2a|; jump if not ptr into dynamic area|20884
;
;      here we have a ptr to a block in the dynamic area.
;      link this field onto the reference backchain.
;
||mov|8,wa|9,(xl)||; load ptr to chain (or entry ptr)|20889
||blt|7,xl|3,gbcsd|6,gpf1a|; do not chain if within sediment|20891
||mov|9,(xl)|7,xr||; set this field as new head of chain|20893
||mov|9,(xr)|8,wa||; set forward pointer|20894
;
;      now see if this block has been processed before
;
|gpf1a|bod|8,wa|6,gpf03||; jump if not already processed|20899
;
;      here to restore pointer in xr to field just processed
;
|gpf02|mov|7,xr|8,wc||; restore field pointer|20907
;
;      here to move to next field
;
|gpf2a|ica|7,xr|||; bump to next field|20911
||bne|7,xr|9,(xs)|6,gpf01|; loop back if more to go|20912
||ejc|||||20913
;
;      gbcpf (continued)
;
;      here we pop up a level after finishing a block
;
||mov|7,xl|10,(xs)+||; restore pointer past end|20919
||mov|7,xr|10,(xs)+||; restore block pointer|20920
||bnz|7,xr|6,gpf2a||; continue loop unless outer levl|20921
||exi||||; return to caller if outer level|20922
;
;      here to process an active block which has not been done
;
;
;      since sediment blocks are not marked by putting them on
;      the back chain, they must be explicitly marked in another
;      manner.	if odd parity entry points are present, mark by
;      temporarily converting to even parity.  if odd parity not
;      available, the entry point is adjusted by the value in
;      gbcmk.
;
|gpf03|bge|7,xl|3,gbcsd|6,gpf3a|; if not within sediment|20935
||icv|9,(xl)|||; mark by making entry point even|20937
|gpf3a|mov|7,xr|7,xl||; copy block pointer|20941
||mov|7,xl|8,wa||; copy first word of block|20945
||lei|7,xl|||; load entry point id (bl_xx)|20946
;
;      block type switch. note that blocks with no relocatable
;      fields just return to gpf02 here to continue to next fld.
;
||bsw|7,xl|2,bl___||; switch on block type|20951
||iff|2,bl_ar|6,gpf06||; arblk|20989
||iff|2,bl_cd|6,gpf19||; cdblk|20989
||iff|2,bl_ex|6,gpf17||; exblk|20989
||iff|2,bl_ic|6,gpf02||; icblk|20989
||iff|2,bl_nm|6,gpf10||; nmblk|20989
||iff|2,bl_p0|6,gpf10||; p0blk|20989
||iff|2,bl_p1|6,gpf12||; p1blk|20989
||iff|2,bl_p2|6,gpf12||; p2blk|20989
||iff|2,bl_rc|6,gpf02||; rcblk|20989
||iff|2,bl_sc|6,gpf02||; scblk|20989
||iff|2,bl_se|6,gpf02||; seblk|20989
||iff|2,bl_tb|6,gpf08||; tbblk|20989
||iff|2,bl_vc|6,gpf08||; vcblk|20989
||iff|2,bl_xn|6,gpf02||; xnblk|20989
||iff|2,bl_xr|6,gpf09||; xrblk|20989
||iff|2,bl_bc|6,gpf02||; bcblk - dummy to fill out iffs|20989
||iff|2,bl_pd|6,gpf13||; pdblk|20989
||iff|2,bl_tr|6,gpf16||; trblk|20989
||iff|2,bl_bf|6,gpf02||; bfblk|20989
||iff|2,bl_cc|6,gpf07||; ccblk|20989
||iff|2,bl_cm|6,gpf04||; cmblk|20989
||iff|2,bl_ct|6,gpf02||; ctblk|20989
||iff|2,bl_df|6,gpf02||; dfblk|20989
||iff|2,bl_ef|6,gpf02||; efblk|20989
||iff|2,bl_ev|6,gpf10||; evblk|20989
||iff|2,bl_ff|6,gpf11||; ffblk|20989
||iff|2,bl_kv|6,gpf02||; kvblk|20989
||iff|2,bl_pf|6,gpf14||; pfblk|20989
||iff|2,bl_te|6,gpf15||; teblk|20989
||esw||||; end of jump table|20989
||ejc|||||20990
;
;      gbcpf (continued)
;
;      cmblk
;
|gpf04|mov|8,wa|13,cmlen(xr)||; load length|20996
||mov|8,wb|19,*cmtyp||; set offset|20997
;
;      here to push down to new level
;
;      (wc)		     field ptr at previous level
;      (xr)		     ptr to new block
;      (wa)		     length (reloc flds + flds at start)
;      (wb)		     offset to first reloc field
;
|gpf05|add|8,wa|7,xr||; point past last reloc field|21006
||add|7,xr|8,wb||; point to first reloc field|21007
||mov|11,-(xs)|8,wc||; stack old field pointer|21008
||mov|11,-(xs)|8,wa||; stack new limit pointer|21009
||chk||||; check for stack overflow|21010
||brn|6,gpf01|||; if ok, back to process|21011
;
;      arblk
;
|gpf06|mov|8,wa|13,arlen(xr)||; load length|21015
||mov|8,wb|13,arofs(xr)||; set offset to 1st reloc fld (arpro)|21016
||brn|6,gpf05|||; all set|21017
;
;      ccblk
;
|gpf07|mov|8,wa|13,ccuse(xr)||; set length in use|21021
||mov|8,wb|19,*ccuse||; 1st word (make sure at least one)|21022
||brn|6,gpf05|||; all set|21023
||ejc|||||21024
;
;      gbcpf (continued)
;
;      cdblk
;
|gpf19|mov|8,wa|13,cdlen(xr)||; load length|21031
||mov|8,wb|19,*cdfal||; set offset|21032
||brn|6,gpf05|||; jump back|21033
;
;      tbblk, vcblk
;
|gpf08|mov|8,wa|13,offs2(xr)||; load length|21040
||mov|8,wb|19,*offs3||; set offset|21041
||brn|6,gpf05|||; jump back|21042
;
;      xrblk
;
|gpf09|mov|8,wa|13,xrlen(xr)||; load length|21046
||mov|8,wb|19,*xrptr||; set offset|21047
||brn|6,gpf05|||; jump back|21048
;
;      evblk, nmblk, p0blk
;
|gpf10|mov|8,wa|19,*offs2||; point past second field|21052
||mov|8,wb|19,*offs1||; offset is one (only reloc fld is 2)|21053
||brn|6,gpf05|||; all set|21054
;
;      ffblk
;
|gpf11|mov|8,wa|19,*ffofs||; set length|21058
||mov|8,wb|19,*ffnxt||; set offset|21059
||brn|6,gpf05|||; all set|21060
;
;      p1blk, p2blk
;
|gpf12|mov|8,wa|19,*parm2||; length (parm2 is non-relocatable)|21064
||mov|8,wb|19,*pthen||; set offset|21065
||brn|6,gpf05|||; all set|21066
||ejc|||||21067
;
;      gbcpf (continued)
;
;      pdblk
;
|gpf13|mov|7,xl|13,pddfp(xr)||; load ptr to dfblk|21073
||mov|8,wa|13,dfpdl(xl)||; get pdblk length|21074
||mov|8,wb|19,*pdfld||; set offset|21075
||brn|6,gpf05|||; all set|21076
;
;      pfblk
;
|gpf14|mov|8,wa|19,*pfarg||; length past last reloc|21080
||mov|8,wb|19,*pfcod||; offset to first reloc|21081
||brn|6,gpf05|||; all set|21082
;
;      teblk
;
|gpf15|mov|8,wa|19,*tesi_||; set length|21086
||mov|8,wb|19,*tesub||; and offset|21087
||brn|6,gpf05|||; all set|21088
;
;      trblk
;
|gpf16|mov|8,wa|19,*trsi_||; set length|21092
||mov|8,wb|19,*trval||; and offset|21093
||brn|6,gpf05|||; all set|21094
;
;      exblk
;
|gpf17|mov|8,wa|13,exlen(xr)||; load length|21098
||mov|8,wb|19,*exflc||; set offset|21099
||brn|6,gpf05|||; jump back|21100
||enp||||; end procedure gbcpf|21110
||ejc|||||21111
;z+
;
;      gtarr -- get array
;
;      gtarr is passed an object and returns an array if possibl
;
;      (xr)		     value to be converted
;      (wa)		     0 to place table addresses in array
;			     non-zero for keys/values in array
;      jsr  gtarr	     call to get array
;      ppm  loc		     transfer loc for all null table
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     resulting array
;      (xl,wa,wb,wc)	     destroyed
;
|gtarr|prc|25,e|1,2||; entry point|21127
||mov|3,gtawa|8,wa||; save wa indicator|21128
||mov|8,wa|9,(xr)||; load type word|21129
||beq|8,wa|22,=b_art|6,gtar8|; exit if already an array|21130
||beq|8,wa|22,=b_vct|6,gtar8|; exit if already an array|21131
||bne|8,wa|22,=b_tbt|6,gta9a|; else fail if not a table (sgd02)|21132
;
;      here we convert a table to an array
;
||mov|11,-(xs)|7,xr||; replace tbblk pointer on stack|21136
||zer|7,xr|||; signal first pass|21137
||zer|8,wb|||; zero non-null element count|21138
;
;      the following code is executed twice. on the first pass,
;      signalled by xr=0, the number of non-null elements in
;      the table is counted in wb. in the second pass, where
;      xr is a pointer into the arblk, the name and value are
;      entered into the current arblk location provided gtawa
;      is non-zero.  if gtawa is zero, the address of the teblk
;      is entered into the arblk twice (c3.762).
;
|gtar1|mov|7,xl|9,(xs)||; point to table|21148
||add|7,xl|13,tblen(xl)||; point past last bucket|21149
||sub|7,xl|19,*tbbuk||; set first bucket offset|21150
||mov|8,wa|7,xl||; copy adjusted pointer|21151
;
;      loop through buckets in table block
;      next three lines of code rely on tenxt having a value
;      1 less than tbbuk.
;
|gtar2|mov|7,xl|8,wa||; copy bucket pointer|21157
||dca|8,wa|||; decrement bucket pointer|21158
;
;      loop through teblks on one bucket chain
;
|gtar3|mov|7,xl|13,tenxt(xl)||; point to next teblk|21162
||beq|7,xl|9,(xs)|6,gtar6|; jump if chain end (tbblk ptr)|21163
||mov|3,cnvtp|7,xl||; else save teblk pointer|21164
;
;      loop to find value down trblk chain
;
|gtar4|mov|7,xl|13,teval(xl)||; load value|21168
||beq|9,(xl)|22,=b_trt|6,gtar4|; loop till value found|21169
||mov|8,wc|7,xl||; copy value|21170
||mov|7,xl|3,cnvtp||; restore teblk pointer|21171
||ejc|||||21172
;
;      gtarr (continued)
;
;      now check for null and test cases
;
||beq|8,wc|21,=nulls|6,gtar3|; loop back to ignore null value|21178
||bnz|7,xr|6,gtar5||; jump if second pass|21179
||icv|8,wb|||; for the first pass, bump count|21180
||brn|6,gtar3|||; and loop back for next teblk|21181
;
;      here in second pass
;
|gtar5|bze|3,gtawa|6,gta5a||; jump if address wanted|21185
||mov|10,(xr)+|13,tesub(xl)||; store subscript name|21186
||mov|10,(xr)+|8,wc||; store value in arblk|21187
||brn|6,gtar3|||; loop back for next teblk|21188
;
;      here to record teblk address in arblk.  this allows
;      a sort routine to sort by ascending address.
;
|gta5a|mov|10,(xr)+|7,xl||; store teblk address in name|21193
||mov|10,(xr)+|7,xl||; and value slots|21194
||brn|6,gtar3|||; loop back for next teblk|21195
;
;      here after scanning teblks on one chain
;
|gtar6|bne|8,wa|9,(xs)|6,gtar2|; loop back if more buckets to go|21199
||bnz|7,xr|6,gtar7||; else jump if second pass|21200
;
;      here after counting non-null elements
;
||bze|8,wb|6,gtar9||; fail if no non-null elements|21204
||mov|8,wa|8,wb||; else copy count|21205
||add|8,wa|8,wb||; double (two words/element)|21206
||add|8,wa|18,=arvl2||; add space for standard fields|21207
||wtb|8,wa|||; convert length to bytes|21208
||bgt|8,wa|3,mxlen|6,gta9b|; error if too long for array|21209
||jsr|6,alloc|||; else allocate space for arblk|21210
||mov|9,(xr)|22,=b_art||; store type word|21211
||zer|13,idval(xr)|||; zero id for the moment|21212
||mov|13,arlen(xr)|8,wa||; store length|21213
||mov|13,arndm(xr)|18,=num02||; set dimensions = 2|21214
||ldi|4,intv1|||; get integer one|21215
||sti|13,arlbd(xr)|||; store as lbd 1|21216
||sti|13,arlb2(xr)|||; store as lbd 2|21217
||ldi|4,intv2|||; load integer two|21218
||sti|13,ardm2(xr)|||; store as dim 2|21219
||mti|8,wb|||; get element count as integer|21220
||sti|13,ardim(xr)|||; store as dim 1|21221
||zer|13,arpr2(xr)|||; zero prototype field for now|21222
||mov|13,arofs(xr)|19,*arpr2||; set offset field (signal pass 2)|21223
||mov|8,wb|7,xr||; save arblk pointer|21224
||add|7,xr|19,*arvl2||; point to first element location|21225
||brn|6,gtar1|||; jump back to fill in elements|21226
||ejc|||||21227
;
;      gtarr (continued)
;
;      here after filling in element values
;
|gtar7|mov|7,xr|8,wb||; restore arblk pointer|21233
||mov|9,(xs)|8,wb||; store as result|21234
;
;      now we need the array prototype which is of the form nn,2
;      this is obtained by building the string for nn02 and
;      changing the zero to a comma before storing it.
;
||ldi|13,ardim(xr)|||; get number of elements (nn)|21240
||mli|4,intvh|||; multiply by 100|21241
||adi|4,intv2|||; add 2 (nn02)|21242
||jsr|6,icbld|||; build integer|21243
||mov|11,-(xs)|7,xr||; store ptr for gtstg|21244
||jsr|6,gtstg|||; convert to string|21245
||ppm||||; convert fail is impossible|21246
||mov|7,xl|7,xr||; copy string pointer|21247
||mov|7,xr|10,(xs)+||; reload arblk pointer|21248
||mov|13,arpr2(xr)|7,xl||; store prototype ptr (nn02)|21249
||sub|8,wa|18,=num02||; adjust length to point to zero|21250
||psc|7,xl|8,wa||; point to zero|21251
||mov|8,wb|18,=ch_cm||; load a comma|21252
||sch|8,wb|9,(xl)||; store a comma over the zero|21253
||csc|7,xl|||; complete store characters|21254
;
;      normal return
;
|gtar8|exi||||; return to caller|21258
;
;      null table non-conversion return
;
|gtar9|mov|7,xr|10,(xs)+||; restore stack for conv err (sgd02)|21262
||exi|1,1|||; return|21263
;
;      impossible conversion return
;
|gta9a|exi|1,2|||; return|21267
;
;      array size too large
;
|gta9b|erb|1,260|26,conversion array size exceeds maximum permitted|||21271
||enp||||; procedure gtarr|21272
||ejc|||||21273
;
;      gtcod -- convert to code
;
;      (xr)		     object to be converted
;      jsr  gtcod	     call to convert to code
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to resulting cdblk
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      if a spitbol error occurs during compilation or pre-
;      evaluation, control is passed via error section to exfal
;      without returning to this routine.
;
|gtcod|prc|25,e|1,1||; entry point|21287
||beq|9,(xr)|22,=b_cds|6,gtcd1|; jump if already code|21288
||beq|9,(xr)|22,=b_cdc|6,gtcd1|; jump if already code|21289
;
;      here we must generate a cdblk by compilation
;
||mov|11,-(xs)|7,xr||; stack argument for gtstg|21293
||jsr|6,gtstg|||; convert argument to string|21294
||ppm|6,gtcd2|||; jump if non-convertible|21295
||mov|3,gtcef|3,flptr||; save fail ptr in case of error|21296
||mov|3,r_gtc|3,r_cod||; also save code ptr|21297
||mov|3,r_cim|7,xr||; else set image pointer|21298
||mov|3,scnil|8,wa||; set image length|21299
||zer|3,scnpt|||; set scan pointer|21300
||mov|3,stage|18,=stgxc||; set stage for execute compile|21301
||mov|3,lstsn|3,cmpsn||; in case listr called|21302
||icv|3,cmpln|||; bump line number|21304
||jsr|6,cmpil|||; compile string|21306
||mov|3,stage|18,=stgxt||; reset stage for execute time|21307
||zer|3,r_cim|||; clear image|21308
;
;      merge here if no convert required
;
|gtcd1|exi||||; give normal gtcod return|21312
;
;      here if unconvertible
;
|gtcd2|exi|1,1|||; give error return|21316
||enp||||; end procedure gtcod|21317
||ejc|||||21318
;
;      gtexp -- convert to expression
;
;      (wb)		     0 if by value, 1 if by name
;      (xr)		     input value to be converted
;      jsr  gtexp	     call to convert to expression
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to result exblk or seblk
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      if a spitbol error occurs during compilation or pre-
;      evaluation, control is passed via error section to exfal
;      without returning to this routine.
;
|gtexp|prc|25,e|1,1||; entry point|21335
||blo|9,(xr)|22,=b_e__|6,gtex1|; jump if already an expression|21336
||mov|11,-(xs)|7,xr||; store argument for gtstg|21337
||jsr|6,gtstg|||; convert argument to string|21338
||ppm|6,gtex2|||; jump if unconvertible|21339
;
;      check the last character of the string for colon or
;      semicolon.  these characters can legitimately end an
;      expression in open code, so expan will not detect them
;      as errors, but they are invalid as terminators for a
;      string that is being converted to expression form.
;
||mov|7,xl|7,xr||; copy input string pointer|21347
||plc|7,xl|8,wa||; point one past the string end|21348
||lch|7,xl|11,-(xl)||; fetch the last character|21349
||beq|7,xl|18,=ch_cl|6,gtex2|; error if it is a semicolon|21350
||beq|7,xl|18,=ch_sm|6,gtex2|; or if it is a colon|21351
;
;      here we convert a string by compilation
;
||mov|3,r_cim|7,xr||; set input image pointer|21355
||zer|3,scnpt|||; set scan pointer|21356
||mov|3,scnil|8,wa||; set input image length|21357
||mov|11,-(xs)|8,wb||; save value/name flag|21359
||zer|8,wb|||; set code for normal scan|21361
||mov|3,gtcef|3,flptr||; save fail ptr in case of error|21362
||mov|3,r_gtc|3,r_cod||; also save code ptr|21363
||mov|3,stage|18,=stgev||; adjust stage for compile|21364
||mov|3,scntp|18,=t_uok||; indicate unary operator acceptable|21365
||jsr|6,expan|||; build tree for expression|21366
||zer|3,scnrs|||; reset rescan flag|21367
||mov|8,wa|10,(xs)+||; restore value/name flag|21369
||bne|3,scnpt|3,scnil|6,gtex2|; error if not end of image|21371
||zer|8,wb|||; set ok value for cdgex call|21372
||mov|7,xl|7,xr||; copy tree pointer|21373
||jsr|6,cdgex|||; build expression block|21374
||zer|3,r_cim|||; clear pointer|21375
||mov|3,stage|18,=stgxt||; restore stage for execute time|21376
;
;      merge here if no conversion required
;
|gtex1|exi||||; return to gtexp caller|21380
;
;      here if unconvertible
;
|gtex2|exi|1,1|||; take error exit|21384
||enp||||; end procedure gtexp|21385
||ejc|||||21386
;
;      gtint -- get integer value
;
;      gtint is passed an object and returns an integer after
;      performing any necessary conversions.
;
;      (xr)		     value to be converted
;      jsr  gtint	     call to convert to integer
;      ppm  loc		     transfer loc for convert impossible
;      (xr)		     resulting integer
;      (wc,ra)		     destroyed
;      (wa,wb)		     destroyed (only on conversion err)
;      (xr)		     unchanged (on convert error)
;
|gtint|prc|25,e|1,1||; entry point|21401
||beq|9,(xr)|22,=b_icl|6,gtin2|; jump if already an integer|21402
||mov|3,gtina|8,wa||; else save wa|21403
||mov|3,gtinb|8,wb||; save wb|21404
||jsr|6,gtnum|||; convert to numeric|21405
||ppm|6,gtin3|||; jump if unconvertible|21406
||beq|8,wa|22,=b_icl|6,gtin1|; jump if integer|21409
;
;      here we convert a real to integer
;
||ldr|13,rcval(xr)|||; load real value|21413
||rti|6,gtin3|||; convert to integer (err if ovflow)|21414
||jsr|6,icbld|||; if ok build icblk|21415
;
;      here after successful conversion to integer
;
|gtin1|mov|8,wa|3,gtina||; restore wa|21420
||mov|8,wb|3,gtinb||; restore wb|21421
;
;      common exit point
;
|gtin2|exi||||; return to gtint caller|21425
;
;      here on conversion error
;
|gtin3|exi|1,1|||; take convert error exit|21429
||enp||||; end procedure gtint|21430
||ejc|||||21431
;
;      gtnum -- get numeric value
;
;      gtnum is given an object and returns either an integer
;      or a real, performing any necessary conversions.
;
;      (xr)		     object to be converted
;      jsr  gtnum	     call to convert to numeric
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to result (int or real)
;      (wa)		     first word of result block
;      (wb,wc,ra)	     destroyed
;      (xr)		     unchanged (on convert error)
;
|gtnum|prc|25,e|1,1||; entry point|21446
||mov|8,wa|9,(xr)||; load first word of block|21447
||beq|8,wa|22,=b_icl|6,gtn34|; jump if integer (no conversion)|21448
||beq|8,wa|22,=b_rcl|6,gtn34|; jump if real (no conversion)|21451
;
;      at this point the only possibility is to convert a string
;      to an integer or real as appropriate.
;
||mov|11,-(xs)|7,xr||; stack argument in case convert err|21457
||mov|11,-(xs)|7,xr||; stack argument for gtstg|21458
||jsr|6,gtstg|||; convert argument to string|21460
||ppm|6,gtn36|||; jump if unconvertible|21464
;
;      initialize numeric conversion
;
||ldi|4,intv0|||; initialize integer result to zero|21468
||bze|8,wa|6,gtn32||; jump to exit with zero if null|21469
||lct|8,wa|8,wa||; set bct counter for following loops|21470
||zer|3,gtnnf|||; tentatively indicate result +|21471
||sti|3,gtnex|||; initialise exponent to zero|21474
||zer|3,gtnsc|||; zero scale in case real|21475
||zer|3,gtndf|||; reset flag for dec point found|21476
||zer|3,gtnrd|||; reset flag for digits found|21477
||ldr|4,reav0|||; zero real accum in case real|21478
||plc|7,xr|||; point to argument characters|21480
;
;      merge back here after ignoring leading blank
;
|gtn01|lch|8,wb|10,(xr)+||; load first character|21484
||blt|8,wb|18,=ch_d0|6,gtn02|; jump if not digit|21485
||ble|8,wb|18,=ch_d9|6,gtn06|; jump if first char is a digit|21486
||ejc|||||21487
;
;      gtnum (continued)
;
;      here if first digit is non-digit
;
|gtn02|bne|8,wb|18,=ch_bl|6,gtn03|; jump if non-blank|21493
|gtna2|bct|8,wa|6,gtn01||; else decr count and loop back|21494
||brn|6,gtn07|||; jump to return zero if all blanks|21495
;
;      here for first character non-blank, non-digit
;
|gtn03|beq|8,wb|18,=ch_pl|6,gtn04|; jump if plus sign|21499
||beq|8,wb|18,=ch_ht|6,gtna2|; horizontal tab equiv to blank|21501
||bne|8,wb|18,=ch_mn|6,gtn12|; jump if not minus (may be real)|21509
||mnz|3,gtnnf|||; if minus sign, set negative flag|21511
;
;      merge here after processing sign
;
|gtn04|bct|8,wa|6,gtn05||; jump if chars left|21515
||brn|6,gtn36|||; else error|21516
;
;      loop to fetch characters of an integer
;
|gtn05|lch|8,wb|10,(xr)+||; load next character|21520
||blt|8,wb|18,=ch_d0|6,gtn08|; jump if not a digit|21521
||bgt|8,wb|18,=ch_d9|6,gtn08|; jump if not a digit|21522
;
;      merge here for first digit
;
|gtn06|sti|3,gtnsi|||; save current value|21526
||cvm|6,gtn35|||; current*10-(new dig) jump if ovflow|21530
||mnz|3,gtnrd|||; set digit read flag|21531
||bct|8,wa|6,gtn05||; else loop back if more chars|21533
;
;      here to exit with converted integer value
;
|gtn07|bnz|3,gtnnf|6,gtn32||; jump if negative (all set)|21537
||ngi||||; else negate|21538
||ino|6,gtn32|||; jump if no overflow|21539
||brn|6,gtn36|||; else signal error|21540
||ejc|||||21541
;
;      gtnum (continued)
;
;      here for a non-digit character while attempting to
;      convert an integer, check for trailing blanks or real.
;
|gtn08|beq|8,wb|18,=ch_bl|6,gtna9|; jump if a blank|21548
||beq|8,wb|18,=ch_ht|6,gtna9|; jump if horizontal tab|21550
||itr||||; else convert integer to real|21558
||ngr||||; negate to get positive value|21559
||brn|6,gtn12|||; jump to try for real|21560
;
;      here we scan out blanks to end of string
;
|gtn09|lch|8,wb|10,(xr)+||; get next char|21565
||beq|8,wb|18,=ch_ht|6,gtna9|; jump if horizontal tab|21567
||bne|8,wb|18,=ch_bl|6,gtn36|; error if non-blank|21572
|gtna9|bct|8,wa|6,gtn09||; loop back if more chars to check|21573
||brn|6,gtn07|||; return integer if all blanks|21574
;
;      loop to collect mantissa of real
;
|gtn10|lch|8,wb|10,(xr)+||; load next character|21580
||blt|8,wb|18,=ch_d0|6,gtn12|; jump if non-numeric|21581
||bgt|8,wb|18,=ch_d9|6,gtn12|; jump if non-numeric|21582
;
;      merge here to collect first real digit
;
|gtn11|sub|8,wb|18,=ch_d0||; convert digit to number|21586
||mlr|4,reavt|||; multiply real by 10.0|21587
||rov|6,gtn36|||; convert error if overflow|21588
||str|3,gtnsr|||; save result|21589
||mti|8,wb|||; get new digit as integer|21590
||itr||||; convert new digit to real|21591
||adr|3,gtnsr|||; add to get new total|21592
||add|3,gtnsc|3,gtndf||; increment scale if after dec point|21593
||mnz|3,gtnrd|||; set digit found flag|21594
||bct|8,wa|6,gtn10||; loop back if more chars|21595
||brn|6,gtn22|||; else jump to scale|21596
||ejc|||||21597
;
;      gtnum (continued)
;
;      here if non-digit found while collecting a real
;
|gtn12|bne|8,wb|18,=ch_dt|6,gtn13|; jump if not dec point|21603
||bnz|3,gtndf|6,gtn36||; if dec point, error if one already|21604
||mov|3,gtndf|18,=num01||; else set flag for dec point|21605
||bct|8,wa|6,gtn10||; loop back if more chars|21606
||brn|6,gtn22|||; else jump to scale|21607
;
;      here if not decimal point
;
|gtn13|beq|8,wb|18,=ch_le|6,gtn15|; jump if e for exponent|21611
||beq|8,wb|18,=ch_ld|6,gtn15|; jump if d for exponent|21612
||beq|8,wb|18,=ch_ue|6,gtn15|; jump if e for exponent|21614
||beq|8,wb|18,=ch_ud|6,gtn15|; jump if d for exponent|21615
;
;      here check for trailing blanks
;
|gtn14|beq|8,wb|18,=ch_bl|6,gtnb4|; jump if blank|21620
||beq|8,wb|18,=ch_ht|6,gtnb4|; jump if horizontal tab|21622
||brn|6,gtn36|||; error if non-blank|21627
;
|gtnb4|lch|8,wb|10,(xr)+||; get next character|21629
||bct|8,wa|6,gtn14||; loop back to check if more|21630
||brn|6,gtn22|||; else jump to scale|21631
;
;      here to read and process an exponent
;
|gtn15|zer|3,gtnes|||; set exponent sign positive|21635
||ldi|4,intv0|||; initialize exponent to zero|21636
||mnz|3,gtndf|||; reset no dec point indication|21637
||bct|8,wa|6,gtn16||; jump skipping past e or d|21638
||brn|6,gtn36|||; error if null exponent|21639
;
;      check for exponent sign
;
|gtn16|lch|8,wb|10,(xr)+||; load first exponent character|21643
||beq|8,wb|18,=ch_pl|6,gtn17|; jump if plus sign|21644
||bne|8,wb|18,=ch_mn|6,gtn19|; else jump if not minus sign|21645
||mnz|3,gtnes|||; set sign negative if minus sign|21646
;
;      merge here after processing exponent sign
;
|gtn17|bct|8,wa|6,gtn18||; jump if chars left|21650
||brn|6,gtn36|||; else error|21651
;
;      loop to convert exponent digits
;
|gtn18|lch|8,wb|10,(xr)+||; load next character|21655
||ejc|||||21656
;
;      gtnum (continued)
;
;      merge here for first exponent digit
;
|gtn19|blt|8,wb|18,=ch_d0|6,gtn20|; jump if not digit|21662
||bgt|8,wb|18,=ch_d9|6,gtn20|; jump if not digit|21663
||cvm|6,gtn36|||; else current*10, subtract new digit|21664
||bct|8,wa|6,gtn18||; loop back if more chars|21665
||brn|6,gtn21|||; jump if exponent field is exhausted|21666
;
;      here to check for trailing blanks after exponent
;
|gtn20|beq|8,wb|18,=ch_bl|6,gtnc0|; jump if blank|21670
||beq|8,wb|18,=ch_ht|6,gtnc0|; jump if horizontal tab|21672
||brn|6,gtn36|||; error if non-blank|21677
;
|gtnc0|lch|8,wb|10,(xr)+||; get next character|21679
||bct|8,wa|6,gtn20||; loop back till all blanks scanned|21680
;
;      merge here after collecting exponent
;
|gtn21|sti|3,gtnex|||; save collected exponent|21684
||bnz|3,gtnes|6,gtn22||; jump if it was negative|21685
||ngi||||; else complement|21686
||iov|6,gtn36|||; error if overflow|21687
||sti|3,gtnex|||; and store positive exponent|21688
;
;      merge here with exponent (0 if none given)
;
|gtn22|bze|3,gtnrd|6,gtn36||; error if not digits collected|21692
||bze|3,gtndf|6,gtn36||; error if no exponent or dec point|21693
||mti|3,gtnsc|||; else load scale as integer|21694
||sbi|3,gtnex|||; subtract exponent|21695
||iov|6,gtn36|||; error if overflow|21696
||ilt|6,gtn26|||; jump if we must scale up|21697
;
;      here we have a negative exponent, so scale down
;
||mfi|8,wa|6,gtn36||; load scale factor, err if ovflow|21701
;
;      loop to scale down in steps of 10**10
;
|gtn23|ble|8,wa|18,=num10|6,gtn24|; jump if 10 or less to go|21705
||dvr|4,reatt|||; else divide by 10**10|21706
||sub|8,wa|18,=num10||; decrement scale|21707
||brn|6,gtn23|||; and loop back|21708
||ejc|||||21709
;
;      gtnum (continued)
;
;      here scale rest of way from powers of ten table
;
|gtn24|bze|8,wa|6,gtn30||; jump if scaled|21715
||lct|8,wb|18,=cfp_r||; else get indexing factor|21716
||mov|7,xr|21,=reav1||; point to powers of ten table|21717
||wtb|8,wa|||; convert remaining scale to byte ofs|21718
;
;      loop to point to powers of ten table entry
;
|gtn25|add|7,xr|8,wa||; bump pointer|21722
||bct|8,wb|6,gtn25||; once for each value word|21723
||dvr|9,(xr)|||; scale down as required|21724
||brn|6,gtn30|||; and jump|21725
;
;      come here to scale result up (positive exponent)
;
|gtn26|ngi||||; get absolute value of exponent|21729
||iov|6,gtn36|||; error if overflow|21730
||mfi|8,wa|6,gtn36||; acquire scale, error if ovflow|21731
;
;      loop to scale up in steps of 10**10
;
|gtn27|ble|8,wa|18,=num10|6,gtn28|; jump if 10 or less to go|21735
||mlr|4,reatt|||; else multiply by 10**10|21736
||rov|6,gtn36|||; error if overflow|21737
||sub|8,wa|18,=num10||; else decrement scale|21738
||brn|6,gtn27|||; and loop back|21739
;
;      here to scale up rest of way with table
;
|gtn28|bze|8,wa|6,gtn30||; jump if scaled|21743
||lct|8,wb|18,=cfp_r||; else get indexing factor|21744
||mov|7,xr|21,=reav1||; point to powers of ten table|21745
||wtb|8,wa|||; convert remaining scale to byte ofs|21746
;
;      loop to point to proper entry in powers of ten table
;
|gtn29|add|7,xr|8,wa||; bump pointer|21750
||bct|8,wb|6,gtn29||; once for each word in value|21751
||mlr|9,(xr)|||; scale up|21752
||rov|6,gtn36|||; error if overflow|21753
||ejc|||||21754
;
;      gtnum (continued)
;
;      here with real value scaled and ready except for sign
;
|gtn30|bze|3,gtnnf|6,gtn31||; jump if positive|21760
||ngr||||; else negate|21761
;
;      here with properly signed real value in (ra)
;
|gtn31|jsr|6,rcbld|||; build real block|21765
||brn|6,gtn33|||; merge to exit|21766
;
;      here with properly signed integer value in (ia)
;
|gtn32|jsr|6,icbld|||; build icblk|21771
;
;      real merges here
;
|gtn33|mov|8,wa|9,(xr)||; load first word of result block|21775
||ica|7,xs|||; pop argument off stack|21776
;
;      common exit point
;
|gtn34|exi||||; return to gtnum caller|21780
;
;      come here if overflow occurs during collection of integer
;      have to restore wb which cvm may have destroyed.
;
|gtn35|lch|8,wb|11,-(xr)||; reload current character|21787
||lch|8,wb|10,(xr)+||; bump character pointer|21788
||ldi|3,gtnsi|||; reload integer so far|21789
||itr||||; convert to real|21790
||ngr||||; make value positive|21791
||brn|6,gtn11|||; merge with real circuit|21792
;
;      here for unconvertible to string or conversion error
;
|gtn36|mov|7,xr|10,(xs)+||; reload original argument|21797
||exi|1,1|||; take convert-error exit|21798
||enp||||; end procedure gtnum|21799
||ejc|||||21800
;
;      gtnvr -- convert to natural variable
;
;      gtnvr locates a variable block (vrblk) given either an
;      appropriate name (nmblk) or a non-null string (scblk).
;
;      (xr)		     argument
;      jsr  gtnvr	     call to convert to natural variable
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to vrblk
;      (wa,wb)		     destroyed (conversion error only)
;      (wc)		     destroyed
;
|gtnvr|prc|25,e|1,1||; entry point|21814
;z-
||bne|9,(xr)|22,=b_nml|6,gnv02|; jump if not name|21816
||mov|7,xr|13,nmbas(xr)||; else load name base if name|21817
||blo|7,xr|3,state|6,gnv07|; skip if vrblk (in static region)|21818
;
;      common error exit
;
|gnv01|exi|1,1|||; take convert-error exit|21822
;
;      here if not name
;
|gnv02|mov|3,gnvsa|8,wa||; save wa|21826
||mov|3,gnvsb|8,wb||; save wb|21827
||mov|11,-(xs)|7,xr||; stack argument for gtstg|21828
||jsr|6,gtstg|||; convert argument to string|21829
||ppm|6,gnv01|||; jump if conversion error|21830
||bze|8,wa|6,gnv01||; null string is an error|21831
||jsr|6,flstg|||; fold upper case to lower case|21833
||mov|11,-(xs)|7,xl||; save xl|21835
||mov|11,-(xs)|7,xr||; stack string ptr for later|21836
||mov|8,wb|7,xr||; copy string pointer|21837
||add|8,wb|19,*schar||; point to characters of string|21838
||mov|3,gnvst|8,wb||; save pointer to characters|21839
||mov|8,wb|8,wa||; copy length|21840
||ctw|8,wb|1,0||; get number of words in name|21841
||mov|3,gnvnw|8,wb||; save for later|21842
||jsr|6,hashs|||; compute hash index for string|21843
||rmi|3,hshnb|||; compute hash offset by taking mod|21844
||mfi|8,wc|||; get as offset|21845
||wtb|8,wc|||; convert offset to bytes|21846
||add|8,wc|3,hshtb||; point to proper hash chain|21847
||sub|8,wc|19,*vrnxt||; subtract offset to merge into loop|21848
||ejc|||||21849
;
;      gtnvr (continued)
;
;      loop to search hash chain
;
|gnv03|mov|7,xl|8,wc||; copy hash chain pointer|21855
||mov|7,xl|13,vrnxt(xl)||; point to next vrblk on chain|21856
||bze|7,xl|6,gnv08||; jump if end of chain|21857
||mov|8,wc|7,xl||; save pointer to this vrblk|21858
||bnz|13,vrlen(xl)|6,gnv04||; jump if not system variable|21859
||mov|7,xl|13,vrsvp(xl)||; else point to svblk|21860
||sub|7,xl|19,*vrsof||; adjust offset for merge|21861
;
;      merge here with string ptr (like vrblk) in xl
;
|gnv04|bne|8,wa|13,vrlen(xl)|6,gnv03|; back for next vrblk if lengths ne|21865
||add|7,xl|19,*vrchs||; else point to chars of chain entry|21866
||lct|8,wb|3,gnvnw||; get word counter to control loop|21867
||mov|7,xr|3,gnvst||; point to chars of new name|21868
;
;      loop to compare characters of the two names
;
|gnv05|cne|9,(xr)|9,(xl)|6,gnv03|; jump if no match for next vrblk|21872
||ica|7,xr|||; bump new name pointer|21873
||ica|7,xl|||; bump vrblk in chain name pointer|21874
||bct|8,wb|6,gnv05||; else loop till all compared|21875
||mov|7,xr|8,wc||; we have found a match, get vrblk|21876
;
;      exit point after finding vrblk or building new one
;
|gnv06|mov|8,wa|3,gnvsa||; restore wa|21880
||mov|8,wb|3,gnvsb||; restore wb|21881
||ica|7,xs|||; pop string pointer|21882
||mov|7,xl|10,(xs)+||; restore xl|21883
;
;      common exit point
;
|gnv07|exi||||; return to gtnvr caller|21887
;
;      not found, prepare to search system variable table
;
|gnv08|zer|7,xr|||; clear garbage xr pointer|21891
||mov|3,gnvhe|8,wc||; save ptr to end of hash chain|21892
||bgt|8,wa|18,=num09|6,gnv14|; cannot be system var if length gt 9|21893
||mov|7,xl|8,wa||; else copy length|21894
||wtb|7,xl|||; convert to byte offset|21895
||mov|7,xl|14,vsrch(xl)||; point to first svblk of this length|21896
||ejc|||||21897
;
;      gtnvr (continued)
;
;      loop to search entries in standard variable table
;
|gnv09|mov|3,gnvsp|7,xl||; save table pointer|21903
||mov|8,wc|10,(xl)+||; load svbit bit string|21904
||mov|8,wb|10,(xl)+||; load length from table entry|21905
||bne|8,wa|8,wb|6,gnv14|; jump if end of right length entries|21906
||lct|8,wb|3,gnvnw||; get word counter to control loop|21907
||mov|7,xr|3,gnvst||; point to chars of new name|21908
;
;      loop to check for matching names
;
|gnv10|cne|9,(xr)|9,(xl)|6,gnv11|; jump if name mismatch|21912
||ica|7,xr|||; else bump new name pointer|21913
||ica|7,xl|||; bump svblk pointer|21914
||bct|8,wb|6,gnv10||; else loop until all checked|21915
;
;      here we have a match in the standard variable table
;
||zer|8,wc|||; set vrlen value zero|21919
||mov|8,wa|19,*vrsi_||; set standard size|21920
||brn|6,gnv15|||; jump to build vrblk|21921
;
;      here if no match with table entry in svblks table
;
|gnv11|ica|7,xl|||; bump past word of chars|21925
||bct|8,wb|6,gnv11||; loop back if more to go|21926
||rsh|8,wc|2,svnbt||; remove uninteresting bits|21927
;
;      loop to bump table ptr for each flagged word
;
|gnv12|mov|8,wb|4,bits1||; load bit to test|21931
||anb|8,wb|8,wc||; test for word present|21932
||zrb|8,wb|6,gnv13||; jump if not present|21933
||ica|7,xl|||; else bump table pointer|21934
;
;      here after dealing with one word (one bit)
;
|gnv13|rsh|8,wc|1,1||; remove bit already processed|21938
||nzb|8,wc|6,gnv12||; loop back if more bits to test|21939
||brn|6,gnv09|||; else loop back for next svblk|21940
;
;      here if not system variable
;
|gnv14|mov|8,wc|8,wa||; copy vrlen value|21944
||mov|8,wa|18,=vrchs||; load standard size -chars|21945
||add|8,wa|3,gnvnw||; adjust for chars of name|21946
||wtb|8,wa|||; convert length to bytes|21947
||ejc|||||21948
;
;      gtnvr (continued)
;
;      merge here to build vrblk
;
|gnv15|jsr|6,alost|||; allocate space for vrblk (static)|21954
||mov|8,wb|7,xr||; save vrblk pointer|21955
||mov|7,xl|21,=stnvr||; point to model variable block|21956
||mov|8,wa|19,*vrlen||; set length of standard fields|21957
||mvw||||; set initial fields of new block|21958
||mov|7,xl|3,gnvhe||; load pointer to end of hash chain|21959
||mov|13,vrnxt(xl)|8,wb||; add new block to end of chain|21960
||mov|10,(xr)+|8,wc||; set vrlen field, bump ptr|21961
||mov|8,wa|3,gnvnw||; get length in words|21962
||wtb|8,wa|||; convert to length in bytes|21963
||bze|8,wc|6,gnv16||; jump if system variable|21964
;
;      here for non-system variable -- set chars of name
;
||mov|7,xl|9,(xs)||; point back to string name|21968
||add|7,xl|19,*schar||; point to chars of name|21969
||mvw||||; move characters into place|21970
||mov|7,xr|8,wb||; restore vrblk pointer|21971
||brn|6,gnv06|||; jump back to exit|21972
;
;      here for system variable case to fill in fields where
;      necessary from the fields present in the svblk.
;
|gnv16|mov|7,xl|3,gnvsp||; load pointer to svblk|21977
||mov|9,(xr)|7,xl||; set svblk ptr in vrblk|21978
||mov|7,xr|8,wb||; restore vrblk pointer|21979
||mov|8,wb|13,svbit(xl)||; load bit indicators|21980
||add|7,xl|19,*svchs||; point to characters of name|21981
||add|7,xl|8,wa||; point past characters|21982
;
;      skip past keyword number (svknm) if present
;
||mov|8,wc|4,btknm||; load test bit|21986
||anb|8,wc|8,wb||; and to test|21987
||zrb|8,wc|6,gnv17||; jump if no keyword number|21988
||ica|7,xl|||; else bump pointer|21989
||ejc|||||21990
;
;      gtnvr (continued)
;
;      here test for function (svfnc and svnar)
;
|gnv17|mov|8,wc|4,btfnc||; get test bit|21996
||anb|8,wc|8,wb||; and to test|21997
||zrb|8,wc|6,gnv18||; skip if no system function|21998
||mov|13,vrfnc(xr)|7,xl||; else point vrfnc to svfnc field|21999
||add|7,xl|19,*num02||; and bump past svfnc, svnar fields|22000
;
;      now test for label (svlbl)
;
|gnv18|mov|8,wc|4,btlbl||; get test bit|22004
||anb|8,wc|8,wb||; and to test|22005
||zrb|8,wc|6,gnv19||; jump if bit is off (no system labl)|22006
||mov|13,vrlbl(xr)|7,xl||; else point vrlbl to svlbl field|22007
||ica|7,xl|||; bump past svlbl field|22008
;
;      now test for value (svval)
;
|gnv19|mov|8,wc|4,btval||; load test bit|22012
||anb|8,wc|8,wb||; and to test|22013
||zrb|8,wc|6,gnv06||; all done if no value|22014
||mov|13,vrval(xr)|9,(xl)||; else set initial value|22015
||mov|13,vrsto(xr)|22,=b_vre||; set error store access|22016
||brn|6,gnv06|||; merge back to exit to caller|22017
||enp||||; end procedure gtnvr|22018
||ejc|||||22019
;
;      gtpat -- get pattern
;
;      gtpat is passed an object in (xr) and returns a
;      pattern after performing any necessary conversions
;
;      (xr)		     input argument
;      jsr  gtpat	     call to convert to pattern
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     resulting pattern
;      (wa)		     destroyed
;      (wb)		     destroyed (only on convert error)
;      (xr)		     unchanged (only on convert error)
;
|gtpat|prc|25,e|1,1||; entry point|22034
;z+
||bhi|9,(xr)|22,=p_aaa|6,gtpt5|; jump if pattern already|22036
;
;      here if not pattern, try for string
;
||mov|3,gtpsb|8,wb||; save wb|22040
||mov|11,-(xs)|7,xr||; stack argument for gtstg|22041
||jsr|6,gtstg|||; convert argument to string|22042
||ppm|6,gtpt2|||; jump if impossible|22043
;
;      here we have a string
;
||bnz|8,wa|6,gtpt1||; jump if non-null|22047
;
;      here for null string. generate pointer to null pattern.
;
||mov|7,xr|21,=ndnth||; point to nothen node|22051
||brn|6,gtpt4|||; jump to exit|22052
||ejc|||||22053
;
;      gtpat (continued)
;
;      here for non-null string
;
|gtpt1|mov|8,wb|22,=p_str||; load pcode for multi-char string|22059
||bne|8,wa|18,=num01|6,gtpt3|; jump if multi-char string|22060
;
;      here for one character string, share one character any
;
||plc|7,xr|||; point to character|22064
||lch|8,wa|9,(xr)||; load character|22065
||mov|7,xr|8,wa||; set as parm1|22066
||mov|8,wb|22,=p_ans||; point to pcode for 1-char any|22067
||brn|6,gtpt3|||; jump to build node|22068
;
;      here if argument is not convertible to string
;
|gtpt2|mov|8,wb|22,=p_exa||; set pcode for expression in case|22072
||blo|9,(xr)|22,=b_e__|6,gtpt3|; jump to build node if expression|22073
;
;      here we have an error (conversion impossible)
;
||exi|1,1|||; take convert error exit|22077
;
;      merge here to build node for string or expression
;
|gtpt3|jsr|6,pbild|||; call routine to build pattern node|22081
;
;      common exit after successful conversion
;
|gtpt4|mov|8,wb|3,gtpsb||; restore wb|22085
;
;      merge here to exit if no conversion required
;
|gtpt5|exi||||; return to gtpat caller|22089
||enp||||; end procedure gtpat|22090
||ejc|||||22093
;
;      gtrea -- get real value
;
;      gtrea is passed an object and returns a real value
;      performing any necessary conversions.
;
;      (xr)		     object to be converted
;      jsr  gtrea	     call to convert object to real
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to resulting real
;      (wa,wb,wc,ra)	     destroyed
;      (xr)		     unchanged (convert error only)
;
|gtrea|prc|25,e|1,1||; entry point|22107
||mov|8,wa|9,(xr)||; get first word of block|22108
||beq|8,wa|22,=b_rcl|6,gtre2|; jump if real|22109
||jsr|6,gtnum|||; else convert argument to numeric|22110
||ppm|6,gtre3|||; jump if unconvertible|22111
||beq|8,wa|22,=b_rcl|6,gtre2|; jump if real was returned|22112
;
;      here for case of an integer to convert to real
;
|gtre1|ldi|13,icval(xr)|||; load integer|22116
||itr||||; convert to real|22117
||jsr|6,rcbld|||; build rcblk|22118
;
;      exit with real
;
|gtre2|exi||||; return to gtrea caller|22122
;
;      here on conversion error
;
|gtre3|exi|1,1|||; take convert error exit|22126
||enp||||; end procedure gtrea|22127
||ejc|||||22129
;
;      gtsmi -- get small integer
;
;      gtsmi is passed a snobol object and returns an address
;      integer in the range (0 le n le dnamb). such a value can
;      only be derived from an integer in the appropriate range.
;      small integers never appear as snobol values. however,
;      they are used internally for a variety of purposes.
;
;      -(xs)		     argument to convert (on stack)
;      jsr  gtsmi	     call to convert to small integer
;      ppm  loc		     transfer loc for not integer
;      ppm  loc		     transfer loc for lt 0, gt dnamb
;      (xr,wc)		     resulting small int (two copies)
;      (xs)		     popped
;      (ra)		     destroyed
;      (wa,wb)		     destroyed (on convert error only)
;      (xr)		     input arg (convert error only)
;
|gtsmi|prc|25,n|1,2||; entry point|22149
||mov|7,xr|10,(xs)+||; load argument|22150
||beq|9,(xr)|22,=b_icl|6,gtsm1|; skip if already an integer|22151
;
;      here if not an integer
;
||jsr|6,gtint|||; convert argument to integer|22155
||ppm|6,gtsm2|||; jump if convert is impossible|22156
;
;      merge here with integer
;
|gtsm1|ldi|13,icval(xr)|||; load integer value|22160
||mfi|8,wc|6,gtsm3||; move as one word, jump if ovflow|22161
||bgt|8,wc|3,mxlen|6,gtsm3|; or if too large|22162
||mov|7,xr|8,wc||; copy result to xr|22163
||exi||||; return to gtsmi caller|22164
;
;      here if unconvertible to integer
;
|gtsm2|exi|1,1|||; take non-integer error exit|22168
;
;      here if out of range
;
|gtsm3|exi|1,2|||; take out-of-range error exit|22172
||enp||||; end procedure gtsmi|22173
||ejc|||||22174
;
;      gtstg -- get string
;
;      gtstg is passed an object and returns a string with
;      any necessary conversions performed.
;
;      -(xs)		     input argument (on stack)
;      jsr  gtstg	     call to convert to string
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to resulting string
;      (wa)		     length of string in characters
;      (xs)		     popped
;      (ra)		     destroyed
;      (xr)		     input arg (convert error only)
;
|gtstg|prc|25,n|1,1||; entry point|22240
||mov|7,xr|10,(xs)+||; load argument, pop stack|22241
||beq|9,(xr)|22,=b_scl|6,gts30|; jump if already a string|22242
;
;      here if not a string already
;
|gts01|mov|11,-(xs)|7,xr||; restack argument in case error|22246
||mov|11,-(xs)|7,xl||; save xl|22247
||mov|3,gtsvb|8,wb||; save wb|22248
||mov|3,gtsvc|8,wc||; save wc|22249
||mov|8,wa|9,(xr)||; load first word of block|22250
||beq|8,wa|22,=b_icl|6,gts05|; jump to convert integer|22251
||beq|8,wa|22,=b_rcl|6,gts10|; jump to convert real|22254
||beq|8,wa|22,=b_nml|6,gts03|; jump to convert name|22256
;
;      here on conversion error
;
|gts02|mov|7,xl|10,(xs)+||; restore xl|22264
||mov|7,xr|10,(xs)+||; reload input argument|22265
||exi|1,1|||; take convert error exit|22266
||ejc|||||22267
;
;      gtstg (continued)
;
;      here to convert a name (only possible if natural var)
;
|gts03|mov|7,xl|13,nmbas(xr)||; load name base|22273
||bhi|7,xl|3,state|6,gts02|; error if not natural var (static)|22274
||add|7,xl|19,*vrsof||; else point to possible string name|22275
||mov|8,wa|13,sclen(xl)||; load length|22276
||bnz|8,wa|6,gts04||; jump if not system variable|22277
||mov|7,xl|13,vrsvo(xl)||; else point to svblk|22278
||mov|8,wa|13,svlen(xl)||; and load name length|22279
;
;      merge here with string in xr, length in wa
;
|gts04|zer|8,wb|||; set offset to zero|22283
||jsr|6,sbstr|||; use sbstr to copy string|22284
||brn|6,gts29|||; jump to exit|22285
;
;      come here to convert an integer
;
|gts05|ldi|13,icval(xr)|||; load integer value|22289
||mov|3,gtssf|18,=num01||; set sign flag negative|22297
||ilt|6,gts06|||; skip if integer is negative|22298
||ngi||||; else negate integer|22299
||zer|3,gtssf|||; and reset negative flag|22300
||ejc|||||22301
;
;      gtstg (continued)
;
;      here with sign flag set and sign forced negative as
;      required by the cvd instruction.
;
|gts06|mov|7,xr|3,gtswk||; point to result work area|22308
||mov|8,wb|18,=nstmx||; initialize counter to max length|22309
||psc|7,xr|8,wb||; prepare to store (right-left)|22310
;
;      loop to convert digits into work area
;
|gts07|cvd||||; convert one digit into wa|22314
||sch|8,wa|11,-(xr)||; store in work area|22315
||dcv|8,wb|||; decrement counter|22316
||ine|6,gts07|||; loop if more digits to go|22317
||csc|7,xr|||; complete store characters|22318
;
;      merge here after converting integer or real into work
;      area. wb is set to nstmx - (number of chars in result).
;
|gts08|mov|8,wa|18,=nstmx||; get max number of characters|22324
||sub|8,wa|8,wb||; compute length of result|22325
||mov|7,xl|8,wa||; remember length for move later on|22326
||add|8,wa|3,gtssf||; add one for negative sign if needed|22327
||jsr|6,alocs|||; allocate string for result|22328
||mov|8,wc|7,xr||; save result pointer for the moment|22329
||psc|7,xr|||; point to chars of result block|22330
||bze|3,gtssf|6,gts09||; skip if positive|22331
||mov|8,wa|18,=ch_mn||; else load negative sign|22332
||sch|8,wa|10,(xr)+||; and store it|22333
||csc|7,xr|||; complete store characters|22334
;
;      here after dealing with sign
;
|gts09|mov|8,wa|7,xl||; recall length to move|22338
||mov|7,xl|3,gtswk||; point to result work area|22339
||plc|7,xl|8,wb||; point to first result character|22340
||mvc||||; move chars to result string|22341
||mov|7,xr|8,wc||; restore result pointer|22342
||brn|6,gts29|||; jump to exit|22345
||ejc|||||22346
;
;      gtstg (continued)
;
;      here to convert a real
;
|gts10|ldr|13,rcval(xr)|||; load real|22352
||zer|3,gtssf|||; reset negative flag|22364
||req|6,gts31|||; skip if zero|22365
||rge|6,gts11|||; jump if real is positive|22366
||mov|3,gtssf|18,=num01||; else set negative flag|22367
||ngr||||; and get absolute value of real|22368
;
;      now scale the real to the range (0.1 le x lt 1.0)
;
|gts11|ldi|4,intv0|||; initialize exponent to zero|22372
;
;      loop to scale up in steps of 10**10
;
|gts12|str|3,gtsrs|||; save real value|22376
||sbr|4,reap1|||; subtract 0.1 to compare|22377
||rge|6,gts13|||; jump if scale up not required|22378
||ldr|3,gtsrs|||; else reload value|22379
||mlr|4,reatt|||; multiply by 10**10|22380
||sbi|4,intvt|||; decrement exponent by 10|22381
||brn|6,gts12|||; loop back to test again|22382
;
;      test for scale down required
;
|gts13|ldr|3,gtsrs|||; reload value|22386
||sbr|4,reav1|||; subtract 1.0|22387
||rlt|6,gts17|||; jump if no scale down required|22388
||ldr|3,gtsrs|||; else reload value|22389
;
;      loop to scale down in steps of 10**10
;
|gts14|sbr|4,reatt|||; subtract 10**10 to compare|22393
||rlt|6,gts15|||; jump if large step not required|22394
||ldr|3,gtsrs|||; else restore value|22395
||dvr|4,reatt|||; divide by 10**10|22396
||str|3,gtsrs|||; store new value|22397
||adi|4,intvt|||; increment exponent by 10|22398
||brn|6,gts14|||; loop back|22399
||ejc|||||22400
;
;      gtstg (continued)
;
;      at this point we have (1.0 le x lt 10**10)
;      complete scaling with powers of ten table
;
|gts15|mov|7,xr|21,=reav1||; point to powers of ten table|22407
;
;      loop to locate correct entry in table
;
|gts16|ldr|3,gtsrs|||; reload value|22411
||adi|4,intv1|||; increment exponent|22412
||add|7,xr|19,*cfp_r||; point to next entry in table|22413
||sbr|9,(xr)|||; subtract it to compare|22414
||rge|6,gts16|||; loop till we find a larger entry|22415
||ldr|3,gtsrs|||; then reload the value|22416
||dvr|9,(xr)|||; and complete scaling|22417
||str|3,gtsrs|||; store value|22418
;
;      we are now scaled, so round by adding 0.5 * 10**(-cfp_s)
;
|gts17|ldr|3,gtsrs|||; get value again|22422
||adr|3,gtsrn|||; add rounding factor|22423
||str|3,gtsrs|||; store result|22424
;
;      the rounding operation may have pushed us up past
;      1.0 again, so check one more time.
;
||sbr|4,reav1|||; subtract 1.0 to compare|22429
||rlt|6,gts18|||; skip if ok|22430
||adi|4,intv1|||; else increment exponent|22431
||ldr|3,gtsrs|||; reload value|22432
||dvr|4,reavt|||; divide by 10.0 to rescale|22433
||brn|6,gts19|||; jump to merge|22434
;
;      here if rounding did not muck up scaling
;
|gts18|ldr|3,gtsrs|||; reload rounded value|22438
||ejc|||||22439
;
;      gtstg (continued)
;
;      now we have completed the scaling as follows
;
;      (ia)		     signed exponent
;      (ra)		     scaled real (absolute value)
;
;      if the exponent is negative or greater than cfp_s, then
;      we convert the number in the form.
;
;      (neg sign) 0 . (cpf_s digits) e (exp sign) (exp digits)
;
;      if the exponent is positive and less than or equal to
;      cfp_s, the number is converted in the form.
;
;      (neg sign) (exponent digits) . (cfp_s-exponent digits)
;
;      in both cases, the formats obtained from the above
;      rules are modified by deleting trailing zeros after the
;      decimal point. there are no leading zeros in the exponent
;      and the exponent sign is always present.
;
|gts19|mov|7,xl|18,=cfp_s||; set num dec digits = cfp_s|22463
||mov|3,gtses|18,=ch_mn||; set exponent sign negative|22464
||ilt|6,gts21|||; all set if exponent is negative|22465
||mfi|8,wa|||; else fetch exponent|22466
||ble|8,wa|18,=cfp_s|6,gts20|; skip if we can use special format|22467
||mti|8,wa|||; else restore exponent|22468
||ngi||||; set negative for cvd|22469
||mov|3,gtses|18,=ch_pl||; set plus sign for exponent sign|22470
||brn|6,gts21|||; jump to generate exponent|22471
;
;      here if we can use the format without an exponent
;
|gts20|sub|7,xl|8,wa||; compute digits after decimal point|22475
||ldi|4,intv0|||; reset exponent to zero|22476
||ejc|||||22477
;
;      gtstg (continued)
;
;      merge here as follows
;
;      (ia)		     exponent absolute value
;      gtses		     character for exponent sign
;      (ra)		     positive fraction
;      (xl)		     number of digits after dec point
;
|gts21|mov|7,xr|3,gtswk||; point to work area|22488
||mov|8,wb|18,=nstmx||; set character ctr to max length|22489
||psc|7,xr|8,wb||; prepare to store (right to left)|22490
||ieq|6,gts23|||; skip exponent if it is zero|22491
;
;      loop to generate digits of exponent
;
|gts22|cvd||||; convert a digit into wa|22495
||sch|8,wa|11,-(xr)||; store in work area|22496
||dcv|8,wb|||; decrement counter|22497
||ine|6,gts22|||; loop back if more digits to go|22498
;
;      here generate exponent sign and e
;
||mov|8,wa|3,gtses||; load exponent sign|22502
||sch|8,wa|11,-(xr)||; store in work area|22503
||mov|8,wa|18,=ch_le||; get character letter e|22504
||sch|8,wa|11,-(xr)||; store in work area|22505
||sub|8,wb|18,=num02||; decrement counter for sign and e|22506
;
;      here to generate the fraction
;
|gts23|mlr|3,gtssc|||; convert real to integer (10**cfp_s)|22510
||rti||||; get integer (overflow impossible)|22511
||ngi||||; negate as required by cvd|22512
;
;      loop to suppress trailing zeros
;
|gts24|bze|7,xl|6,gts27||; jump if no digits left to do|22516
||cvd||||; else convert one digit|22517
||bne|8,wa|18,=ch_d0|6,gts26|; jump if not a zero|22518
||dcv|7,xl|||; decrement counter|22519
||brn|6,gts24|||; loop back for next digit|22520
||ejc|||||22521
;
;      gtstg (continued)
;
;      loop to generate digits after decimal point
;
|gts25|cvd||||; convert a digit into wa|22527
;
;      merge here first time
;
|gts26|sch|8,wa|11,-(xr)||; store digit|22531
||dcv|8,wb|||; decrement counter|22532
||dcv|7,xl|||; decrement counter|22533
||bnz|7,xl|6,gts25||; loop back if more to go|22534
;
;      here generate the decimal point
;
|gts27|mov|8,wa|18,=ch_dt||; load decimal point|22538
||sch|8,wa|11,-(xr)||; store in work area|22539
||dcv|8,wb|||; decrement counter|22540
;
;      here generate the digits before the decimal point
;
|gts28|cvd||||; convert a digit into wa|22544
||sch|8,wa|11,-(xr)||; store in work area|22545
||dcv|8,wb|||; decrement counter|22546
||ine|6,gts28|||; loop back if more to go|22547
||csc|7,xr|||; complete store characters|22548
||brn|6,gts08|||; else jump back to exit|22549
;
;      exit point after successful conversion
;
|gts29|mov|7,xl|10,(xs)+||; restore xl|22555
||ica|7,xs|||; pop argument|22556
||mov|8,wb|3,gtsvb||; restore wb|22557
||mov|8,wc|3,gtsvc||; restore wc|22558
;
;      merge here if no conversion required
;
|gts30|mov|8,wa|13,sclen(xr)||; load string length|22562
||exi||||; return to caller|22563
;
;      here to return string for real zero
;
|gts31|mov|7,xl|21,=scre0||; point to string|22569
||mov|8,wa|18,=num02||; 2 chars|22570
||zer|8,wb|||; zero offset|22571
||jsr|6,sbstr|||; copy string|22572
||brn|6,gts29|||; return|22573
||enp||||; end procedure gtstg|22600
||ejc|||||22601
;
;      gtvar -- get variable for i/o/trace association
;
;      gtvar is used to point to an actual variable location
;      for the detach,input,output,trace,stoptr system functions
;
;      (xr)		     argument to function
;      jsr  gtvar	     call to locate variable pointer
;      ppm  loc		     transfer loc if not ok variable
;      (xl,wa)		     name base,offset of variable
;      (xr,ra)		     destroyed
;      (wb,wc)		     destroyed (convert error only)
;      (xr)		     input arg (convert error only)
;
|gtvar|prc|25,e|1,1||; entry point|22616
||bne|9,(xr)|22,=b_nml|6,gtvr2|; jump if not a name|22617
||mov|8,wa|13,nmofs(xr)||; else load name offset|22618
||mov|7,xl|13,nmbas(xr)||; load name base|22619
||beq|9,(xl)|22,=b_evt|6,gtvr1|; error if expression variable|22620
||bne|9,(xl)|22,=b_kvt|6,gtvr3|; all ok if not keyword variable|22621
;
;      here on conversion error
;
|gtvr1|exi|1,1|||; take convert error exit|22625
;
;      here if not a name, try convert to natural variable
;
|gtvr2|mov|3,gtvrc|8,wc||; save wc|22629
||jsr|6,gtnvr|||; locate vrblk if possible|22630
||ppm|6,gtvr1|||; jump if convert error|22631
||mov|7,xl|7,xr||; else copy vrblk name base|22632
||mov|8,wa|19,*vrval||; and set offset|22633
||mov|8,wc|3,gtvrc||; restore wc|22634
;
;      here for name obtained
;
|gtvr3|bhi|7,xl|3,state|6,gtvr4|; all ok if not natural variable|22638
||beq|13,vrsto(xl)|22,=b_vre|6,gtvr1|; error if protected variable|22639
;
;      common exit point
;
|gtvr4|exi||||; return to caller|22643
||enp||||; end procedure gtvar|22644
||ejc|||||22645
||ejc|||||22646
;
;      hashs -- compute hash index for string
;
;      hashs is used to convert a string to a unique integer
;      value. the resulting hash value is a positive integer
;      in the range 0 to cfp_m
;
;      (xr)		     string to be hashed
;      jsr  hashs	     call to hash string
;      (ia)		     hash value
;      (xr,wb,wc)	     destroyed
;
;      the hash function used is as follows.
;
;      start with the length of the string.
;
;      if there is more than one character in a word,
;      take the first e_hnw words of the characters from
;      the string or all the words if fewer than e_hnw.
;
;      compute the exclusive or of all these words treating
;      them as one word bit string values.
;
;      if there is just one character in a word,
;      then mimic the word by word hash by shifting
;      successive characters to get a similar effect.
;
;      e_hnw is set to zero in case only one character per word.
;
;      move the result as an integer with the mti instruction.
;
;      the test on e_hnw is done dynamically. this should be done
;      eventually using conditional assembly, but that would require
;      changes to the build process (ds 8 may 2013).
;
|hashs|prc|25,e|1,0||; entry point|22682
;z-
||mov|8,wc|18,=e_hnw||; get number of words to use|22684
||bze|8,wc|6,hshsa||; branch if one character per word|22685
||mov|8,wc|13,sclen(xr)||; load string length in characters|22686
||mov|8,wb|8,wc||; initialize with length|22687
||bze|8,wc|6,hshs3||; jump if null string|22688
||zgb|8,wb|||; correct byte ordering if necessary|22689
||ctw|8,wc|1,0||; get number of words of chars|22690
||add|7,xr|19,*schar||; point to characters of string|22691
||blo|8,wc|18,=e_hnw|6,hshs1|; use whole string if short|22692
||mov|8,wc|18,=e_hnw||; else set to involve first e_hnw wds|22693
;
;      here with count of words to check in wc
;
|hshs1|lct|8,wc|8,wc||; set counter to control loop|22697
;
;      loop to compute exclusive or
;
|hshs2|xob|8,wb|10,(xr)+||; exclusive or next word of chars|22701
||bct|8,wc|6,hshs2||; loop till all processed|22702
;
;      merge here with exclusive or in wb
;
|hshs3|zgb|8,wb|||; zeroise undefined bits|22706
||anb|8,wb|4,bitsm||; ensure in range 0 to cfp_m|22707
||mti|8,wb|||; move result as integer|22708
||zer|7,xr|||; clear garbage value in xr|22709
||exi||||; return to hashs caller|22710
;
;      here if just one character per word
;
|hshsa|mov|8,wc|13,sclen(xr)||; load string length in characters|22714
||mov|8,wb|8,wc||; initialize with length|22715
||bze|8,wc|6,hshs3||; jump if null string|22716
||zgb|8,wb|||; correct byte ordering if necessary|22717
||ctw|8,wc|1,0||; get number of words of chars|22718
||plc|7,xr|||;|22719
||mov|11,-(xs)|7,xl||; save xl|22720
||mov|7,xl|8,wc||; load length for branch|22721
||bge|7,xl|18,=num25|6,hsh24|; use first characters if longer|22722
||bsw|7,xl|1,25||; merge to compute hash|22723
||iff|1,0|6,hsh00||;|22749
||iff|1,1|6,hsh01||;|22749
||iff|1,2|6,hsh02||;|22749
||iff|1,3|6,hsh03||;|22749
||iff|1,4|6,hsh04||;|22749
||iff|1,5|6,hsh05||;|22749
||iff|1,6|6,hsh06||;|22749
||iff|1,7|6,hsh07||;|22749
||iff|1,8|6,hsh08||;|22749
||iff|1,9|6,hsh09||;|22749
||iff|1,10|6,hsh10||;|22749
||iff|1,11|6,hsh11||;|22749
||iff|1,12|6,hsh12||;|22749
||iff|1,13|6,hsh13||;|22749
||iff|1,14|6,hsh14||;|22749
||iff|1,15|6,hsh15||;|22749
||iff|1,16|6,hsh16||;|22749
||iff|1,17|6,hsh17||;|22749
||iff|1,18|6,hsh18||;|22749
||iff|1,19|6,hsh19||;|22749
||iff|1,20|6,hsh20||;|22749
||iff|1,21|6,hsh21||;|22749
||iff|1,22|6,hsh22||;|22749
||iff|1,23|6,hsh23||;|22749
||iff|1,24|6,hsh24||;|22749
||esw|||||22749
|hsh24|lch|8,wc|10,(xr)+||; load next character|22750
||lsh|8,wc|1,24||; shift for hash|22751
||xob|8,wb|8,wc||; hash character|22752
|hsh23|lch|8,wc|10,(xr)+||; load next character|22753
||lsh|8,wc|1,16||; shift for hash|22754
||xob|8,wb|8,wc||; hash character|22755
|hsh22|lch|8,wc|10,(xr)+||; load next character|22756
||lsh|8,wc|1,8||; shift for hash|22757
||xob|8,wb|8,wc||; hash character|22758
|hsh21|lch|8,wc|10,(xr)+||; load next character|22759
||xob|8,wb|8,wc||; hash character|22760
|hsh20|lch|8,wc|10,(xr)+||; load next character|22761
||lsh|8,wc|1,24||; shift for hash|22762
||xob|8,wb|8,wc||; hash character|22763
|hsh19|lch|8,wc|10,(xr)+||; load next character|22764
||lsh|8,wc|1,16||; shift for hash|22765
||xob|8,wb|8,wc||; hash character|22766
|hsh18|lch|8,wc|10,(xr)+||; load next character|22767
||lsh|8,wc|1,8||; shift for hash|22768
||xob|8,wb|8,wc||; hash character|22769
|hsh17|lch|8,wc|10,(xr)+||; load next character|22770
||xob|8,wb|8,wc||; hash character|22771
|hsh16|lch|8,wc|10,(xr)+||; load next character|22772
||lsh|8,wc|1,24||; shift for hash|22773
||xob|8,wb|8,wc||; hash character|22774
|hsh15|lch|8,wc|10,(xr)+||; load next character|22775
||lsh|8,wc|1,16||; shift for hash|22776
||xob|8,wb|8,wc||; hash character|22777
|hsh14|lch|8,wc|10,(xr)+||; load next character|22778
||lsh|8,wc|1,8||; shift for hash|22779
||xob|8,wb|8,wc||; hash character|22780
|hsh13|lch|8,wc|10,(xr)+||; load next character|22781
||xob|8,wb|8,wc||; hash character|22782
|hsh12|lch|8,wc|10,(xr)+||; load next character|22783
||lsh|8,wc|1,24||; shift for hash|22784
||xob|8,wb|8,wc||; hash character|22785
|hsh11|lch|8,wc|10,(xr)+||; load next character|22786
||lsh|8,wc|1,16||; shift for hash|22787
||xob|8,wb|8,wc||; hash character|22788
|hsh10|lch|8,wc|10,(xr)+||; load next character|22789
||lsh|8,wc|1,8||; shift for hash|22790
||xob|8,wb|8,wc||; hash character|22791
|hsh09|lch|8,wc|10,(xr)+||; load next character|22792
||xob|8,wb|8,wc||; hash character|22793
|hsh08|lch|8,wc|10,(xr)+||; load next character|22794
||lsh|8,wc|1,24||; shift for hash|22795
||xob|8,wb|8,wc||; hash character|22796
|hsh07|lch|8,wc|10,(xr)+||; load next character|22797
||lsh|8,wc|1,16||; shift for hash|22798
||xob|8,wb|8,wc||; hash character|22799
|hsh06|lch|8,wc|10,(xr)+||; load next character|22800
||lsh|8,wc|1,8||; shift for hash|22801
||xob|8,wb|8,wc||; hash character|22802
|hsh05|lch|8,wc|10,(xr)+||; load next character|22803
||xob|8,wb|8,wc||; hash character|22804
|hsh04|lch|8,wc|10,(xr)+||; load next character|22805
||lsh|8,wc|1,24||; shift for hash|22806
||xob|8,wb|8,wc||; hash character|22807
|hsh03|lch|8,wc|10,(xr)+||; load next character|22808
||lsh|8,wc|1,16||; shift for hash|22809
||xob|8,wb|8,wc||; hash character|22810
|hsh02|lch|8,wc|10,(xr)+||; load next character|22811
||lsh|8,wc|1,8||; shift for hash|22812
||xob|8,wb|8,wc||; hash character|22813
|hsh01|lch|8,wc|10,(xr)+||; load next character|22814
||xob|8,wb|8,wc||; hash character|22815
|hsh00|mov|7,xl|10,(xs)+||; restore xl|22816
||brn|6,hshs3|||; merge to complete hash|22817
||enp||||; end procedure hashs|22818
;
;      icbld -- build integer block
;
;      (ia)		     integer value for icblk
;      jsr  icbld	     call to build integer block
;      (xr)		     pointer to result icblk
;      (wa)		     destroyed
;
|icbld|prc|25,e|1,0||; entry point|22827
;z+
||mfi|7,xr|6,icbl1||; copy small integers|22829
||ble|7,xr|18,=num02|6,icbl3|; jump if 0,1 or 2|22830
;
;      construct icblk
;
|icbl1|mov|7,xr|3,dnamp||; load pointer to next available loc|22834
||add|7,xr|19,*icsi_||; point past new icblk|22835
||blo|7,xr|3,dname|6,icbl2|; jump if there is room|22836
||mov|8,wa|19,*icsi_||; else load length of icblk|22837
||jsr|6,alloc|||; use standard allocator to get block|22838
||add|7,xr|8,wa||; point past block to merge|22839
;
;      merge here with xr pointing past the block obtained
;
|icbl2|mov|3,dnamp|7,xr||; set new pointer|22843
||sub|7,xr|19,*icsi_||; point back to start of block|22844
||mov|9,(xr)|22,=b_icl||; store type word|22845
||sti|13,icval(xr)|||; store integer value in icblk|22846
||exi||||; return to icbld caller|22847
;
;      optimise by not building icblks for small integers
;
|icbl3|wtb|7,xr|||; convert integer to offset|22851
||mov|7,xr|14,intab(xr)||; point to pre-built icblk|22852
||exi||||; return|22853
||enp||||; end procedure icbld|22854
||ejc|||||22855
;
;      ident -- compare two values
;
;      ident compares two values in the sense of the ident
;      differ functions available at the snobol level.
;
;      (xr)		     first argument
;      (xl)		     second argument
;      jsr  ident	     call to compare arguments
;      ppm  loc		     transfer loc if ident
;      (normal return if differ)
;      (xr,xl,wc,ra)	     destroyed
;
|ident|prc|25,e|1,1||; entry point|22869
||beq|7,xr|7,xl|6,iden7|; jump if same pointer (ident)|22870
||mov|8,wc|9,(xr)||; else load arg 1 type word|22871
||bne|8,wc|9,(xl)|6,iden1|; differ if arg 2 type word differ|22873
||beq|8,wc|22,=b_scl|6,iden2|; jump if strings|22877
||beq|8,wc|22,=b_icl|6,iden4|; jump if integers|22878
||beq|8,wc|22,=b_rcl|6,iden5|; jump if reals|22881
||beq|8,wc|22,=b_nml|6,iden6|; jump if names|22883
;
;      for all other datatypes, must be differ if xr ne xl
;
;      merge here for differ
;
|iden1|exi||||; take differ exit|22926
;
;      here for strings, ident only if lengths and chars same
;
|iden2|mov|8,wc|13,sclen(xr)||; load arg 1 length|22930
||bne|8,wc|13,sclen(xl)|6,iden1|; differ if lengths differ|22931
;
;      buffer and string comparisons merge here
;
|idn2a|add|7,xr|19,*schar||; point to chars of arg 1|22935
||add|7,xl|19,*schar||; point to chars of arg 2|22936
||ctw|8,wc|1,0||; get number of words in strings|22937
||lct|8,wc|8,wc||; set loop counter|22938
;
;      loop to compare characters. note that wc cannot be zero
;      since all null strings point to nulls and give xl=xr.
;
|iden3|cne|9,(xr)|9,(xl)|6,iden8|; differ if chars do not match|22943
||ica|7,xr|||; else bump arg one pointer|22944
||ica|7,xl|||; bump arg two pointer|22945
||bct|8,wc|6,iden3||; loop back till all checked|22946
||ejc|||||22947
;
;      ident (continued)
;
;      here to exit for case of two ident strings
;
||zer|7,xl|||; clear garbage value in xl|22953
||zer|7,xr|||; clear garbage value in xr|22954
||exi|1,1|||; take ident exit|22955
;
;      here for integers, ident if same values
;
|iden4|ldi|13,icval(xr)|||; load arg 1|22959
||sbi|13,icval(xl)|||; subtract arg 2 to compare|22960
||iov|6,iden1|||; differ if overflow|22961
||ine|6,iden1|||; differ if result is not zero|22962
||exi|1,1|||; take ident exit|22963
;
;      here for reals, ident if same values
;
|iden5|ldr|13,rcval(xr)|||; load arg 1|22969
||sbr|13,rcval(xl)|||; subtract arg 2 to compare|22970
||rov|6,iden1|||; differ if overflow|22971
||rne|6,iden1|||; differ if result is not zero|22972
||exi|1,1|||; take ident exit|22973
;
;      here for names, ident if bases and offsets same
;
|iden6|bne|13,nmofs(xr)|13,nmofs(xl)|6,iden1|; differ if different offset|22978
||bne|13,nmbas(xr)|13,nmbas(xl)|6,iden1|; differ if different base|22979
;
;      merge here to signal ident for identical pointers
;
|iden7|exi|1,1|||; take ident exit|22983
;
;      here for differ strings
;
|iden8|zer|7,xr|||; clear garbage ptr in xr|22987
||zer|7,xl|||; clear garbage ptr in xl|22988
||exi||||; return to caller (differ)|22989
||enp||||; end procedure ident|22990
||ejc|||||22991
;
;      inout - used to initialise input and output variables
;
;      (xl)		     pointer to vbl name string
;      (wb)		     trblk type
;      jsr  inout	     call to perform initialisation
;      (xl)		     vrblk ptr
;      (xr)		     trblk ptr
;      (wa,wc)		     destroyed
;
;      note that trter (= trtrf) field of standard i/o variables
;      points to corresponding svblk not to a trblk as is the
;      case for ordinary variables.
;
|inout|prc|25,e|1,0||; entry point|23006
||mov|11,-(xs)|8,wb||; stack trblk type|23007
||mov|8,wa|13,sclen(xl)||; get name length|23008
||zer|8,wb|||; point to start of name|23009
||jsr|6,sbstr|||; build a proper scblk|23010
||jsr|6,gtnvr|||; build vrblk|23011
||ppm||||; no error return|23012
||mov|8,wc|7,xr||; save vrblk pointer|23013
||mov|8,wb|10,(xs)+||; get trter field|23014
||zer|7,xl|||; zero trfpt|23015
||jsr|6,trbld|||; build trblk|23016
||mov|7,xl|8,wc||; recall vrblk pointer|23017
||mov|13,trter(xr)|13,vrsvp(xl)||; store svblk pointer|23018
||mov|13,vrval(xl)|7,xr||; store trblk ptr in vrblk|23019
||mov|13,vrget(xl)|22,=b_vra||; set trapped access|23020
||mov|13,vrsto(xl)|22,=b_vrv||; set trapped store|23021
||exi||||; return to caller|23022
||enp||||; end procedure inout|23023
||ejc|||||23024
;
;      insta - used to initialize structures in static region
;
;      (xr)		     pointer to starting static location
;      jsr  insta	     call to initialize static structure
;      (xr)		     ptr to next free static location
;      (wa,wb,wc)	     destroyed
;
;      note that this procedure establishes the pointers
;      prbuf, gtswk, and kvalp.
;
|insta|prc|25,e|1,0||; entry point|23203
;
;      initialize print buffer with blank words
;
;z-
||mov|8,wc|3,prlen||; no. of chars in print bfr|23208
||mov|3,prbuf|7,xr||; print bfr is put at static start|23209
||mov|10,(xr)+|22,=b_scl||; store string type code|23210
||mov|10,(xr)+|8,wc||; and string length|23211
||ctw|8,wc|1,0||; get number of words in buffer|23212
||mov|3,prlnw|8,wc||; store for buffer clear|23213
||lct|8,wc|8,wc||; words to clear|23214
;
;      loop to clear buffer
;
|inst1|mov|10,(xr)+|4,nullw||; store blank|23218
||bct|8,wc|6,inst1||; loop|23219
;
;      allocate work area for gtstg conversion procedure
;
||mov|8,wa|18,=nstmx||; get max num chars in output number|23223
||ctb|8,wa|2,scsi_||; no of bytes needed|23224
||mov|3,gtswk|7,xr||; store bfr adrs|23225
||add|7,xr|8,wa||; bump for work bfr|23226
;
;      build alphabet string for alphabet keyword and replace
;
||mov|3,kvalp|7,xr||; save alphabet pointer|23230
||mov|9,(xr)|22,=b_scl||; string blk type|23231
||mov|8,wc|18,=cfp_a||; no of chars in alphabet|23232
||mov|13,sclen(xr)|8,wc||; store as string length|23233
||mov|8,wb|8,wc||; copy char count|23234
||ctb|8,wb|2,scsi_||; no. of bytes needed|23235
||add|8,wb|7,xr||; current end address for static|23236
||mov|8,wa|8,wb||; save adrs past alphabet string|23237
||lct|8,wc|8,wc||; loop counter|23238
||psc|7,xr|||; point to chars of string|23239
||zer|8,wb|||; set initial character value|23240
;
;      loop to enter character codes in order
;
|inst2|sch|8,wb|10,(xr)+||; store next code|23244
||icv|8,wb|||; bump code value|23245
||bct|8,wc|6,inst2||; loop till all stored|23246
||csc|7,xr|||; complete store characters|23247
||mov|7,xr|8,wa||; return current static ptr|23248
||exi||||; return to caller|23249
||enp||||; end procedure insta|23250
||ejc|||||23251
;
;      iofcb -- get input/output fcblk pointer
;
;      used by endfile, eject and rewind to find the fcblk
;      (if any) corresponding to their argument.
;
;      -(xs)		     argument
;      jsr  iofcb	     call to find fcblk
;      ppm  loc		     arg is an unsuitable name
;      ppm  loc		     arg is null string
;      ppm  loc		     arg file not found
;      (xs)		     popped
;      (xl)		     ptr to filearg1 vrblk
;      (xr)		     argument
;      (wa)		     fcblk ptr or 0
;      (wb,wc)		     destroyed
;
|iofcb|prc|25,n|1,3||; entry point|23269
;z+
||jsr|6,gtstg|||; get arg as string|23271
||ppm|6,iofc2|||; fail|23272
||mov|7,xl|7,xr||; copy string ptr|23273
||jsr|6,gtnvr|||; get as natural variable|23274
||ppm|6,iofc3|||; fail if null|23275
||mov|8,wb|7,xl||; copy string pointer again|23276
||mov|7,xl|7,xr||; copy vrblk ptr for return|23277
||zer|8,wa|||; in case no trblk found|23278
;
;      loop to find file arg1 trblk
;
|iofc1|mov|7,xr|13,vrval(xr)||; get possible trblk ptr|23282
||bne|9,(xr)|22,=b_trt|6,iofc4|; fail if end of chain|23283
||bne|13,trtyp(xr)|18,=trtfc|6,iofc1|; loop if not file arg trblk|23284
||mov|8,wa|13,trfpt(xr)||; get fcblk ptr|23285
||mov|7,xr|8,wb||; copy arg|23286
||exi||||; return|23287
;
;      fail return
;
|iofc2|exi|1,1|||; fail|23291
;
;      null arg
;
|iofc3|exi|1,2|||; null arg return|23295
;
;      file not found
;
|iofc4|exi|1,3|||; file not found return|23299
||enp||||; end procedure iofcb|23300
||ejc|||||23301
;
;      ioppf -- process filearg2 for ioput
;
;      (r_xsc)		     filearg2 ptr
;      jsr  ioppf	     call to process filearg2
;      (xl)		     filearg1 ptr
;      (xr)		     file arg2 ptr
;      -(xs)...-(xs)	     fields extracted from filearg2
;      (wc)		     no. of fields extracted
;      (wb)		     input/output flag
;      (wa)		     fcblk ptr or 0
;
|ioppf|prc|25,n|1,0||; entry point|23314
||zer|8,wb|||; to count fields extracted|23315
;
;      loop to extract fields
;
|iopp1|mov|7,xl|18,=iodel||; get delimiter|23319
||mov|8,wc|7,xl||; copy it|23320
||zer|8,wa|||; retain leading blanks in filearg2|23321
||jsr|6,xscan|||; get next field|23322
||mov|11,-(xs)|7,xr||; stack it|23323
||icv|8,wb|||; increment count|23324
||bnz|8,wa|6,iopp1||; loop|23325
||mov|8,wc|8,wb||; count of fields|23326
||mov|8,wb|3,ioptt||; i/o marker|23327
||mov|8,wa|3,r_iof||; fcblk ptr or 0|23328
||mov|7,xr|3,r_io2||; file arg2 ptr|23329
||mov|7,xl|3,r_io1||; filearg1|23330
||exi||||; return|23331
||enp||||; end procedure ioppf|23332
||ejc|||||23333
;
;      ioput -- routine used by input and output
;
;      ioput sets up input/output  associations. it builds
;      such trace and file control blocks as are necessary and
;      calls sysfc,sysio to perform checks on the
;      arguments and to open the files.
;
;	  +-----------+	  +---------------+	  +-----------+
;      +-.i	      i	  i		  i------.i   =b_xrt  i
;      i  +-----------+	  +---------------+	  +-----------+
;      i  /	      /	       (r_fcb)		  i    *4     i
;      i  /	      /				  +-----------+
;      i  +-----------+	  +---------------+	  i	      i-
;      i  i   name    +--.i    =b_trt	  i	  +-----------+
;      i  /	      /	  +---------------+	  i	      i
;      i   (first arg)	  i =trtin/=trtou i	  +-----------+
;      i		  +---------------+		i
;      i		  i	value	  i		i
;      i		  +---------------+		i
;      i		  i(trtrf) 0   or i--+		i
;      i		  +---------------+  i		i
;      i		  i(trfpt) 0   or i----+	i
;      i		  +---------------+  i i	i
;      i		     (i/o trblk)     i i	i
;      i  +-----------+			     i i	i
;      i  i	      i			     i i	i
;      i  +-----------+			     i i	i
;      i  i	      i			     i i	i
;      i  +-----------+	  +---------------+  i i	i
;      i  i	      +--.i    =b_trt	  i.-+ i	i
;      i  +-----------+	  +---------------+    i	i
;      i  /	      /	  i    =trtfc	  i    i	i
;      i  /	      /	  +---------------+    i	i
;      i    (filearg1	  i	value	  i    i	i
;      i	 vrblk)	  +---------------+    i	i
;      i		  i(trtrf) 0   or i--+ i	.
;      i		  +---------------+  i .  +-----------+
;      i		  i(trfpt) 0   or i------./   fcblk   /
;      i		  +---------------+  i	  +-----------+
;      i		       (trtrf)	     i
;      i				     i
;      i				     i
;      i		  +---------------+  i
;      i		  i    =b_xrt	  i.-+
;      i		  +---------------+
;      i		  i	 *5	  i
;      i		  +---------------+
;      +------------------i		  i
;			  +---------------+	  +-----------+
;			  i(trtrf) o   or i------.i  =b_xrt   i
;			  +---------------+	  +-----------+
;			  i  name offset  i	  i    etc    i
;			  +---------------+
;			    (iochn - chain of name pointers)
||ejc|||||23389
;
;      ioput (continued)
;
;      no additional trap blocks are used for standard input/out
;      files. otherwise an i/o trap block is attached to second
;      arg (filearg1) vrblk. see diagram above for details of
;      the structure built.
;
;      -(xs)		     1st arg (vbl to be associated)
;      -(xs)		     2nd arg (file arg1)
;      -(xs)		     3rd arg (file arg2)
;      (wb)		     0 for input, 3 for output assoc.
;      jsr  ioput	     call for input/output association
;      ppm  loc		     3rd arg not a string
;      ppm  loc		     2nd arg not a suitable name
;      ppm  loc		     1st arg not a suitable name
;      ppm  loc		     inappropriate file spec for i/o
;      ppm  loc		     i/o file does not exist
;      ppm  loc		     i/o file cannot be read/written
;      ppm  loc		     i/o fcblk currently in use
;      (xs)		     popped
;      (xl,xr,wa,wb,wc)	     destroyed
;
|ioput|prc|25,n|1,7||; entry point|23413
||zer|3,r_iot|||; in case no trtrf block used|23414
||zer|3,r_iof|||; in case no fcblk alocated|23415
||zer|3,r_iop|||; in case sysio fails|23416
||mov|3,ioptt|8,wb||; store i/o trace type|23417
||jsr|6,xscni|||; prepare to scan filearg2|23418
||ppm|6,iop13|||; fail|23419
||ppm|6,iopa0|||; null file arg2|23420
;
|iopa0|mov|3,r_io2|7,xr||; keep file arg2|23422
||mov|7,xl|8,wa||; copy length|23423
||jsr|6,gtstg|||; convert filearg1 to string|23424
||ppm|6,iop14|||; fail|23425
||mov|3,r_io1|7,xr||; keep filearg1 ptr|23426
||jsr|6,gtnvr|||; convert to natural variable|23427
||ppm|6,iop00|||; jump if null|23428
||brn|6,iop04|||; jump to process non-null args|23429
;
;      null filearg1
;
|iop00|bze|7,xl|6,iop01||; skip if both args null|23433
||jsr|6,ioppf|||; process filearg2|23434
||jsr|6,sysfc|||; call for filearg2 check|23435
||ppm|6,iop16|||; fail|23436
||ppm|6,iop26|||; fail|23437
||brn|6,iop11|||; complete file association|23438
||ejc|||||23439
;
;      ioput (continued)
;
;      here with 0 or fcblk ptr in (xl)
;
|iop01|mov|8,wb|3,ioptt||; get trace type|23445
||mov|7,xr|3,r_iot||; get 0 or trtrf ptr|23446
||jsr|6,trbld|||; build trblk|23447
||mov|8,wc|7,xr||; copy trblk pointer|23448
||mov|7,xr|10,(xs)+||; get variable from stack|23449
||mov|11,-(xs)|8,wc||; make trblk collectable|23450
||jsr|6,gtvar|||; point to variable|23451
||ppm|6,iop15|||; fail|23452
||mov|8,wc|10,(xs)+||; recover trblk pointer|23453
||mov|3,r_ion|7,xl||; save name pointer|23454
||mov|7,xr|7,xl||; copy name pointer|23455
||add|7,xr|8,wa||; point to variable|23456
||sub|7,xr|19,*vrval||; subtract offset,merge into loop|23457
;
;      loop to end of trblk chain if any
;
|iop02|mov|7,xl|7,xr||; copy blk ptr|23461
||mov|7,xr|13,vrval(xr)||; load ptr to next trblk|23462
||bne|9,(xr)|22,=b_trt|6,iop03|; jump if not trapped|23463
||bne|13,trtyp(xr)|3,ioptt|6,iop02|; loop if not same assocn|23464
||mov|7,xr|13,trnxt(xr)||; get value and delete old trblk|23465
;
;      ioput (continued)
;
;      store new association
;
|iop03|mov|13,vrval(xl)|8,wc||; link to this trblk|23471
||mov|7,xl|8,wc||; copy pointer|23472
||mov|13,trnxt(xl)|7,xr||; store value in trblk|23473
||mov|7,xr|3,r_ion||; restore possible vrblk pointer|23474
||mov|8,wb|8,wa||; keep offset to name|23475
||jsr|6,setvr|||; if vrblk, set vrget,vrsto|23476
||mov|7,xr|3,r_iot||; get 0 or trtrf ptr|23477
||bnz|7,xr|6,iop19||; jump if trtrf block exists|23478
||exi||||; return to caller|23479
;
;      non standard file
;      see if an fcblk has already been allocated.
;
|iop04|zer|8,wa|||; in case no fcblk found|23484
||ejc|||||23485
;
;      ioput (continued)
;
;      search possible trblk chain to pick up the fcblk
;
|iop05|mov|8,wb|7,xr||; remember blk ptr|23491
||mov|7,xr|13,vrval(xr)||; chain along|23492
||bne|9,(xr)|22,=b_trt|6,iop06|; jump if end of trblk chain|23493
||bne|13,trtyp(xr)|18,=trtfc|6,iop05|; loop if more to go|23494
||mov|3,r_iot|7,xr||; point to file arg1 trblk|23495
||mov|8,wa|13,trfpt(xr)||; get fcblk ptr from trblk|23496
;
;      wa = 0 or fcblk ptr
;      wb = ptr to preceding blk to which any trtrf block
;	    for file arg1 must be chained.
;
|iop06|mov|3,r_iof|8,wa||; keep possible fcblk ptr|23502
||mov|3,r_iop|8,wb||; keep preceding blk ptr|23503
||jsr|6,ioppf|||; process filearg2|23504
||jsr|6,sysfc|||; see if fcblk required|23505
||ppm|6,iop16|||; fail|23506
||ppm|6,iop26|||; fail|23507
||bze|8,wa|6,iop12||; skip if no new fcblk wanted|23508
||blt|8,wc|18,=num02|6,iop6a|; jump if fcblk in dynamic|23509
||jsr|6,alost|||; get it in static|23510
||brn|6,iop6b|||; skip|23511
;
;      obtain fcblk in dynamic
;
|iop6a|jsr|6,alloc|||; get space for fcblk|23515
;
;      merge
;
|iop6b|mov|7,xl|7,xr||; point to fcblk|23519
||mov|8,wb|8,wa||; copy its length|23520
||btw|8,wb|||; get count as words (sgd apr80)|23521
||lct|8,wb|8,wb||; loop counter|23522
;
;      clear fcblk
;
|iop07|zer|10,(xr)+|||; clear a word|23526
||bct|8,wb|6,iop07||; loop|23527
||beq|8,wc|18,=num02|6,iop09|; skip if in static - dont set fields|23528
||mov|9,(xl)|22,=b_xnt||; store xnblk code in case|23529
||mov|13,num01(xl)|8,wa||; store length|23530
||bnz|8,wc|6,iop09||; jump if xnblk wanted|23531
||mov|9,(xl)|22,=b_xrt||; xrblk code requested|23532
;
||ejc|||||23534
;      ioput (continued)
;
;      complete fcblk initialisation
;
|iop09|mov|7,xr|3,r_iot||; get possible trblk ptr|23539
||mov|3,r_iof|7,xl||; store fcblk ptr|23540
||bnz|7,xr|6,iop10||; jump if trblk already found|23541
;
;      a new trblk is needed
;
||mov|8,wb|18,=trtfc||; trtyp for fcblk trap blk|23545
||jsr|6,trbld|||; make the block|23546
||mov|3,r_iot|7,xr||; copy trtrf ptr|23547
||mov|7,xl|3,r_iop||; point to preceding blk|23548
||mov|13,vrval(xr)|13,vrval(xl)||; copy value field to trblk|23549
||mov|13,vrval(xl)|7,xr||; link new trblk into chain|23550
||mov|7,xr|7,xl||; point to predecessor blk|23551
||jsr|6,setvr|||; set trace intercepts|23552
||mov|7,xr|13,vrval(xr)||; recover trblk ptr|23553
||brn|6,iop1a|||; store fcblk ptr|23554
;
;      here if existing trblk
;
|iop10|zer|3,r_iop|||; do not release if sysio fails|23558
;
;      xr is ptr to trblk, xl is fcblk ptr or 0
;
|iop1a|mov|13,trfpt(xr)|3,r_iof||; store fcblk ptr|23562
;
;      call sysio to complete file accessing
;
|iop11|mov|8,wa|3,r_iof||; copy fcblk ptr or 0|23566
||mov|8,wb|3,ioptt||; get input/output flag|23567
||mov|7,xr|3,r_io2||; get file arg2|23568
||mov|7,xl|3,r_io1||; get file arg1|23569
||jsr|6,sysio|||; associate to the file|23570
||ppm|6,iop17|||; fail|23571
||ppm|6,iop18|||; fail|23572
||bnz|3,r_iot|6,iop01||; not std input if non-null trtrf blk|23573
||bnz|3,ioptt|6,iop01||; jump if output|23574
||bze|8,wc|6,iop01||; no change to standard read length|23575
||mov|3,cswin|8,wc||; store new read length for std file|23576
||brn|6,iop01|||; merge to finish the task|23577
;
;      sysfc may have returned a pointer to a private fcblk
;
|iop12|bnz|7,xl|6,iop09||; jump if private fcblk|23581
||brn|6,iop11|||; finish the association|23582
;
;      failure returns
;
|iop13|exi|1,1|||; 3rd arg not a string|23586
|iop14|exi|1,2|||; 2nd arg unsuitable|23587
|iop15|ica|7,xs|||; discard trblk pointer|23588
||exi|1,3|||; 1st arg unsuitable|23589
|iop16|exi|1,4|||; file spec wrong|23590
|iop26|exi|1,7|||; fcblk in use|23591
;
;      i/o file does not exist
;
|iop17|mov|7,xr|3,r_iop||; is there a trblk to release|23595
||bze|7,xr|6,iopa7||; if not|23596
||mov|7,xl|13,vrval(xr)||; point to trblk|23597
||mov|13,vrval(xr)|13,vrval(xl)||; unsplice it|23598
||jsr|6,setvr|||; adjust trace intercepts|23599
|iopa7|exi|1,5|||; i/o file does not exist|23600
;
;      i/o file cannot be read/written
;
|iop18|mov|7,xr|3,r_iop||; is there a trblk to release|23604
||bze|7,xr|6,iopa7||; if not|23605
||mov|7,xl|13,vrval(xr)||; point to trblk|23606
||mov|13,vrval(xr)|13,vrval(xl)||; unsplice it|23607
||jsr|6,setvr|||; adjust trace intercepts|23608
|iopa8|exi|1,6|||; i/o file cannot be read/written|23609
||ejc|||||23610
;
;      ioput (continued)
;
;      add to iochn chain of associated variables unless
;      already present.
;
|iop19|mov|8,wc|3,r_ion||; wc = name base, wb = name offset|23617
;
;      search loop
;
|iop20|mov|7,xr|13,trtrf(xr)||; next link of chain|23621
||bze|7,xr|6,iop21||; not found|23622
||bne|8,wc|13,ionmb(xr)|6,iop20|; no match|23623
||beq|8,wb|13,ionmo(xr)|6,iop22|; exit if matched|23624
||brn|6,iop20|||; loop|23625
;
;      not found
;
|iop21|mov|8,wa|19,*num05||; space needed|23629
||jsr|6,alloc|||; get it|23630
||mov|9,(xr)|22,=b_xrt||; store xrblk code|23631
||mov|13,num01(xr)|8,wa||; store length|23632
||mov|13,ionmb(xr)|8,wc||; store name base|23633
||mov|13,ionmo(xr)|8,wb||; store name offset|23634
||mov|7,xl|3,r_iot||; point to trtrf blk|23635
||mov|8,wa|13,trtrf(xl)||; get ptr field contents|23636
||mov|13,trtrf(xl)|7,xr||; store ptr to new block|23637
||mov|13,trtrf(xr)|8,wa||; complete the linking|23638
;
;      insert fcblk on fcblk chain for sysej, sysxi
;
|iop22|bze|3,r_iof|6,iop25||; skip if no fcblk|23642
||mov|7,xl|3,r_fcb||; ptr to head of existing chain|23643
;
;      see if fcblk already on chain
;
|iop23|bze|7,xl|6,iop24||; not on if end of chain|23647
||beq|13,num03(xl)|3,r_iof|6,iop25|; dont duplicate if find it|23648
||mov|7,xl|13,num02(xl)||; get next link|23649
||brn|6,iop23|||; loop|23650
;
;      not found so add an entry for this fcblk
;
|iop24|mov|8,wa|19,*num04||; space needed|23654
||jsr|6,alloc|||; get it|23655
||mov|9,(xr)|22,=b_xrt||; store block code|23656
||mov|13,num01(xr)|8,wa||; store length|23657
||mov|13,num02(xr)|3,r_fcb||; store previous link in this node|23658
||mov|13,num03(xr)|3,r_iof||; store fcblk ptr|23659
||mov|3,r_fcb|7,xr||; insert node into fcblk chain|23660
;
;      return
;
|iop25|exi||||; return to caller|23664
||enp||||; end procedure ioput|23665
||ejc|||||23666
;
;      ktrex -- execute keyword trace
;
;      ktrex is used to execute a possible keyword trace. it
;      includes the test on trace and tests for trace active.
;
;      (xl)		     ptr to trblk (or 0 if untraced)
;      jsr  ktrex	     call to execute keyword trace
;      (xl,wa,wb,wc)	     destroyed
;      (ra)		     destroyed
;
|ktrex|prc|25,r|1,0||; entry point (recursive)|23678
||bze|7,xl|6,ktrx3||; immediate exit if keyword untraced|23679
||bze|3,kvtra|6,ktrx3||; immediate exit if trace = 0|23680
||dcv|3,kvtra|||; else decrement trace|23681
||mov|11,-(xs)|7,xr||; save xr|23682
||mov|7,xr|7,xl||; copy trblk pointer|23683
||mov|7,xl|13,trkvr(xr)||; load vrblk pointer (nmbas)|23684
||mov|8,wa|19,*vrval||; set name offset|23685
||bze|13,trfnc(xr)|6,ktrx1||; jump if print trace|23686
||jsr|6,trxeq|||; else execute full trace|23687
||brn|6,ktrx2|||; and jump to exit|23688
;
;      here for print trace
;
|ktrx1|mov|11,-(xs)|7,xl||; stack vrblk ptr for kwnam|23692
||mov|11,-(xs)|8,wa||; stack offset for kwnam|23693
||jsr|6,prtsn|||; print statement number|23694
||mov|8,wa|18,=ch_am||; load ampersand|23695
||jsr|6,prtch|||; print ampersand|23696
||jsr|6,prtnm|||; print keyword name|23697
||mov|7,xr|21,=tmbeb||; point to blank-equal-blank|23698
||jsr|6,prtst|||; print blank-equal-blank|23699
||jsr|6,kwnam|||; get keyword pseudo-variable name|23700
||mov|3,dnamp|7,xr||; reset ptr to delete kvblk|23701
||jsr|6,acess|||; get keyword value|23702
||ppm||||; failure is impossible|23703
||jsr|6,prtvl|||; print keyword value|23704
||jsr|6,prtnl|||; terminate print line|23705
;
;      here to exit after completing trace
;
|ktrx2|mov|7,xr|10,(xs)+||; restore entry xr|23709
;
;      merge here to exit if no trace required
;
|ktrx3|exi||||; return to ktrex caller|23713
||enp||||; end procedure ktrex|23714
||ejc|||||23715
;
;      kwnam -- get pseudo-variable name for keyword
;
;      1(xs)		     name base for vrblk
;      0(xs)		     offset (should be *vrval)
;      jsr  kwnam	     call to get pseudo-variable name
;      (xs)		     popped twice
;      (xl,wa)		     resulting pseudo-variable name
;      (xr,wa,wb)	     destroyed
;
|kwnam|prc|25,n|1,0||; entry point|23726
||ica|7,xs|||; ignore name offset|23727
||mov|7,xr|10,(xs)+||; load name base|23728
||bge|7,xr|3,state|6,kwnm1|; jump if not natural variable name|23729
||bnz|13,vrlen(xr)|6,kwnm1||; error if not system variable|23730
||mov|7,xr|13,vrsvp(xr)||; else point to svblk|23731
||mov|8,wa|13,svbit(xr)||; load bit mask|23732
||anb|8,wa|4,btknm||; and with keyword bit|23733
||zrb|8,wa|6,kwnm1||; error if no keyword association|23734
||mov|8,wa|13,svlen(xr)||; else load name length in characters|23735
||ctb|8,wa|2,svchs||; compute offset to field we want|23736
||add|7,xr|8,wa||; point to svknm field|23737
||mov|8,wb|9,(xr)||; load svknm value|23738
||mov|8,wa|19,*kvsi_||; set size of kvblk|23739
||jsr|6,alloc|||; allocate kvblk|23740
||mov|9,(xr)|22,=b_kvt||; store type word|23741
||mov|13,kvnum(xr)|8,wb||; store keyword number|23742
||mov|13,kvvar(xr)|21,=trbkv||; set dummy trblk pointer|23743
||mov|7,xl|7,xr||; copy kvblk pointer|23744
||mov|8,wa|19,*kvvar||; set proper offset|23745
||exi||||; return to kvnam caller|23746
;
;      here if not keyword name
;
|kwnm1|erb|1,251|26,keyword operand is not name of defined keyword|||23750
||enp||||; end procedure kwnam|23751
||ejc|||||23752
;
;      lcomp-- compare two strings lexically
;
;      1(xs)		     first argument
;      0(xs)		     second argument
;      jsr  lcomp	     call to compare aruments
;      ppm  loc		     transfer loc for arg1 not string
;      ppm  loc		     transfer loc for arg2 not string
;      ppm  loc		     transfer loc if arg1 llt arg2
;      ppm  loc		     transfer loc if arg1 leq arg2
;      ppm  loc		     transfer loc if arg1 lgt arg2
;      (the normal return is never taken)
;      (xs)		     popped twice
;      (xr,xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
|lcomp|prc|25,n|1,5||; entry point|23769
||jsr|6,gtstg|||; convert second arg to string|23771
||ppm|6,lcmp6|||; jump if second arg not string|23775
||mov|7,xl|7,xr||; else save pointer|23776
||mov|8,wc|8,wa||; and length|23777
||jsr|6,gtstg|||; convert first argument to string|23779
||ppm|6,lcmp5|||; jump if not string|23783
||mov|8,wb|8,wa||; save arg 1 length|23784
||plc|7,xr|||; point to chars of arg 1|23785
||plc|7,xl|||; point to chars of arg 2|23786
||blo|8,wa|8,wc|6,lcmp1|; jump if arg 1 length is smaller|23798
||mov|8,wa|8,wc||; else set arg 2 length as smaller|23799
;
;      here with smaller length in (wa)
;
|lcmp1|bze|8,wa|6,lcmp7||; if null string, compare lengths|23803
||cmc|6,lcmp4|6,lcmp3||; compare strings, jump if unequal|23804
|lcmp7|bne|8,wb|8,wc|6,lcmp2|; if equal, jump if lengths unequal|23805
||exi|1,4|||; else identical strings, leq exit|23806
||ejc|||||23807
;
;      lcomp (continued)
;
;      here if initial strings identical, but lengths unequal
;
|lcmp2|bhi|8,wb|8,wc|6,lcmp4|; jump if arg 1 length gt arg 2 leng|23813
;
;      here if first arg llt second arg
;
|lcmp3|exi|1,3|||; take llt exit|23818
;
;      here if first arg lgt second arg
;
|lcmp4|exi|1,5|||; take lgt exit|23822
;
;      here if first arg is not a string
;
|lcmp5|exi|1,1|||; take bad first arg exit|23826
;
;      here for second arg not a string
;
|lcmp6|exi|1,2|||; take bad second arg error exit|23830
||enp||||; end procedure lcomp|23831
||ejc|||||23832
;
;      listr -- list source line
;
;      listr is used to list a source line during the initial
;      compilation. it is called from scane and scanl.
;
;      jsr  listr	     call to list line
;      (xr,xl,wa,wb,wc)	     destroyed
;
;      global locations used by listr
;
;      cnttl		     flag for -title, -stitl
;
;      erlst		     if listing on account of an error
;
;      lstid		     include depth of current image
;
;      lstlc		     count lines on current page
;
;      lstnp		     max number of lines/page
;
;      lstpf		     set non-zero if the current source
;			     line has been listed, else zero.
;
;      lstpg		     compiler listing page number
;
;      lstsn		     set if stmnt num to be listed
;
;      r_cim		     pointer to current input line.
;
;      r_ttl		     title for source listing
;
;      r_stl		     ptr to sub-title string
;
;      entry point
;
|listr|prc|25,e|1,0||; entry point|23871
||bnz|3,cnttl|6,list5||; jump if -title or -stitl|23872
||bnz|3,lstpf|6,list4||; immediate exit if already listed|23873
||bge|3,lstlc|3,lstnp|6,list6|; jump if no room|23874
;
;      here after printing title (if needed)
;
|list0|mov|7,xr|3,r_cim||; load pointer to current image|23878
||bze|7,xr|6,list4||; jump if no image to print|23879
||plc|7,xr|||; point to characters|23880
||lch|8,wa|9,(xr)||; load first character|23881
||mov|7,xr|3,lstsn||; load statement number|23882
||bze|7,xr|6,list2||; jump if no statement number|23883
||mti|7,xr|||; else get stmnt number as integer|23884
||bne|3,stage|18,=stgic|6,list1|; skip if execute time|23885
||beq|8,wa|18,=ch_as|6,list2|; no stmnt number list if comment|23886
||beq|8,wa|18,=ch_mn|6,list2|; no stmnt no. if control card|23887
;
;      print statement number
;
|list1|jsr|6,prtin|||; else print statement number|23891
||zer|3,lstsn|||; and clear for next time in|23892
;
;      here to test for printing include depth
;
|list2|mov|7,xr|3,lstid||; include depth of image|23897
||bze|7,xr|6,list8||; if not from an include file|23898
||mov|8,wa|18,=stnpd||; position for start of statement|23899
||sub|8,wa|18,=num03||; position to place include depth|23900
||mov|3,profs|8,wa||; set as starting position|23901
||mti|7,xr|||; include depth as integer|23902
||jsr|6,prtin|||; print include depth|23903
||ejc|||||23904
;
;      listr (continued)
;
;      here after printing statement number and include depth
;
|list8|mov|3,profs|18,=stnpd||; point past statement number|23910
||mov|7,xr|3,r_cim||; load pointer to current image|23920
||jsr|6,prtst|||; print it|23921
||icv|3,lstlc|||; bump line counter|23922
||bnz|3,erlst|6,list3||; jump if error copy to int.ch.|23923
||jsr|6,prtnl|||; terminate line|23924
||bze|3,cswdb|6,list3||; jump if -single mode|23925
||jsr|6,prtnl|||; else add a blank line|23926
||icv|3,lstlc|||; and bump line counter|23927
;
;      here after printing source image
;
|list3|mnz|3,lstpf|||; set flag for line printed|23931
;
;      merge here to exit
;
|list4|exi||||; return to listr caller|23935
;
;      print title after -title or -stitl card
;
|list5|zer|3,cnttl|||; clear flag|23939
;
;      eject to new page and list title
;
|list6|jsr|6,prtps|||; eject|23943
||bze|3,prich|6,list7||; skip if listing to regular printer|23944
||beq|3,r_ttl|21,=nulls|6,list0|; terminal listing omits null title|23945
;
;      list title
;
|list7|jsr|6,listt|||; list title|23949
||brn|6,list0|||; merge|23950
||enp||||; end procedure listr|23951
||ejc|||||23952
;
;      listt -- list title and subtitle
;
;      used during compilation to print page heading
;
;      jsr  listt	     call to list title
;      (xr,wa)		     destroyed
;
|listt|prc|25,e|1,0||; entry point|23961
||mov|7,xr|3,r_ttl||; point to source listing title|23962
||jsr|6,prtst|||; print title|23963
||mov|3,profs|3,lstpo||; set offset|23964
||mov|7,xr|21,=lstms||; set page message|23965
||jsr|6,prtst|||; print page message|23966
||icv|3,lstpg|||; bump page number|23967
||mti|3,lstpg|||; load page number as integer|23968
||jsr|6,prtin|||; print page number|23969
||jsr|6,prtnl|||; terminate title line|23970
||add|3,lstlc|18,=num02||; count title line and blank line|23971
;
;      print sub-title (if any)
;
||mov|7,xr|3,r_stl||; load pointer to sub-title|23975
||bze|7,xr|6,lstt1||; jump if no sub-title|23976
||jsr|6,prtst|||; else print sub-title|23977
||jsr|6,prtnl|||; terminate line|23978
||icv|3,lstlc|||; bump line count|23979
;
;      return point
;
|lstt1|jsr|6,prtnl|||; print a blank line|23983
||exi||||; return to caller|23984
||enp||||; end procedure listt|23985
||ejc|||||23986
;
;      newfn -- record new source file name
;
;      newfn is used after switching to a new include file, or
;      after a -line statement which contains a file name.
;
;      (xr)		     file name scblk
;      jsr  newfn
;      (wa,wb,wc,xl,xr,ra)   destroyed
;
;      on return, the table that maps statement numbers to file
;      names has been updated to include this new file name and
;      the current statement number.  the entry is made only if
;      the file name had changed from its previous value.
;
|newfn|prc|25,e|1,0||; entry point|24003
||mov|11,-(xs)|7,xr||; save new name|24004
||mov|7,xl|3,r_sfc||; load previous name|24005
||jsr|6,ident|||; check for equality|24006
||ppm|6,nwfn1|||; jump if identical|24007
||mov|7,xr|10,(xs)+||; different, restore name|24008
||mov|3,r_sfc|7,xr||; record current file name|24009
||mov|8,wb|3,cmpsn||; get current statement|24010
||mti|8,wb|||; convert to integer|24011
||jsr|6,icbld|||; build icblk for stmt number|24012
||mov|7,xl|3,r_sfn||; file name table|24013
||mnz|8,wb|||; lookup statement number by name|24014
||jsr|6,tfind|||; allocate new teblk|24015
||ppm||||; always possible to allocate block|24016
||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|24017
||exi|||||24018
;
;     here if new name and old name identical
;
|nwfn1|ica|7,xs|||; pop stack|24022
||exi|||||24023
||ejc|||||24024
;
;      nexts -- acquire next source image
;
;      nexts is used to acquire the next source image at compile
;      time. it assumes that a prior call to readr has input
;      a line image (see procedure readr). before the current
;      image is finally lost it may be listed here.
;
;      jsr  nexts	     call to acquire next input line
;      (xr,xl,wa,wb,wc)	     destroyed
;
;      global values affected
;
;      lstid		     include depth of next image
;
;      r_cni		     on input, next image. on
;			     exit reset to zero
;
;      r_cim		     on exit, set to point to image
;
;      rdcln		     current ln set from next line num
;
;      scnil		     input image length on exit
;
;      scnse		     reset to zero on exit
;
;      lstpf		     set on exit if line is listed
;
|nexts|prc|25,e|1,0||; entry point|24056
||bze|3,cswls|6,nxts2||; jump if -nolist|24057
||mov|7,xr|3,r_cim||; point to image|24058
||bze|7,xr|6,nxts2||; jump if no image|24059
||plc|7,xr|||; get char ptr|24060
||lch|8,wa|9,(xr)||; get first char|24061
||bne|8,wa|18,=ch_mn|6,nxts1|; jump if not ctrl card|24062
||bze|3,cswpr|6,nxts2||; jump if -noprint|24063
;
;      here to call lister
;
|nxts1|jsr|6,listr|||; list line|24067
;
;      here after possible listing
;
|nxts2|mov|7,xr|3,r_cni||; point to next image|24071
||mov|3,r_cim|7,xr||; set as next image|24072
||mov|3,rdcln|3,rdnln||; set as current line number|24073
||mov|3,lstid|3,cnind||; set as current include depth|24075
||zer|3,r_cni|||; clear next image pointer|24077
||mov|8,wa|13,sclen(xr)||; get input image length|24078
||mov|8,wb|3,cswin||; get max allowable length|24079
||blo|8,wa|8,wb|6,nxts3|; skip if not too long|24080
||mov|8,wa|8,wb||; else truncate|24081
;
;      here with length in (wa)
;
|nxts3|mov|3,scnil|8,wa||; use as record length|24085
||zer|3,scnse|||; reset scnse|24086
||zer|3,lstpf|||; set line not listed yet|24087
||exi||||; return to nexts caller|24088
||enp||||; end procedure nexts|24089
||ejc|||||24090
;
;      patin -- pattern construction for len,pos,rpos,tab,rtab
;
;      these pattern types all generate a similar node type. so
;      the construction code is shared. see functions section
;      for actual entry points for these five functions.
;
;      (wa)		     pcode for expression arg case
;      (wb)		     pcode for integer arg case
;      jsr  patin	     call to build pattern node
;      ppm  loc		     transfer loc for not integer or exp
;      ppm  loc		     transfer loc for int out of range
;      (xr)		     pointer to constructed node
;      (xl,wa,wb,wc,ia)	     destroyed
;
|patin|prc|25,n|1,2||; entry point|24106
||mov|7,xl|8,wa||; preserve expression arg pcode|24107
||jsr|6,gtsmi|||; try to convert arg as small integer|24108
||ppm|6,ptin2|||; jump if not integer|24109
||ppm|6,ptin3|||; jump if out of range|24110
;
;      common successful exit point
;
|ptin1|jsr|6,pbild|||; build pattern node|24114
||exi||||; return to caller|24115
;
;      here if argument is not an integer
;
|ptin2|mov|8,wb|7,xl||; copy expr arg case pcode|24119
||blo|9,(xr)|22,=b_e__|6,ptin1|; all ok if expression arg|24120
||exi|1,1|||; else take error exit for wrong type|24121
;
;      here for error of out of range integer argument
;
|ptin3|exi|1,2|||; take out-of-range error exit|24125
||enp||||; end procedure patin|24126
||ejc|||||24127
;
;      patst -- pattern construction for any,notany,
;		break,span and breakx pattern functions.
;
;      these pattern functions build similar types of nodes and
;      the construction code is shared. see functions section
;      for actual entry points for these five pattern functions.
;
;      0(xs)		     string argument
;      (wb)		     pcode for one char argument
;      (xl)		     pcode for multi-char argument
;      (wc)		     pcode for expression argument
;      jsr  patst	     call to build node
;      ppm  loc		     if not string or expr (or null)
;      (xs)		     popped past string argument
;      (xr)		     pointer to constructed node
;      (xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
;      note that there is a special call to patst in the evals
;      procedure with a slightly different form. see evals
;      for details of the form of this call.
;
|patst|prc|25,n|1,1||; entry point|24151
||jsr|6,gtstg|||; convert argument as string|24152
||ppm|6,pats7|||; jump if not string|24153
||bze|8,wa|6,pats7||; jump if null string (catspaw)|24154
||bne|8,wa|18,=num01|6,pats2|; jump if not one char string|24155
;
;      here for one char string case
;
||bze|8,wb|6,pats2||; treat as multi-char if evals call|24159
||plc|7,xr|||; point to character|24160
||lch|7,xr|9,(xr)||; load character|24161
;
;      common exit point after successful construction
;
|pats1|jsr|6,pbild|||; call routine to build node|24165
||exi||||; return to patst caller|24166
||ejc|||||24167
;
;      patst (continued)
;
;      here for multi-character string case
;
|pats2|mov|11,-(xs)|7,xl||; save multi-char pcode|24173
||mov|8,wc|3,ctmsk||; load current mask bit|24174
||beq|7,xr|3,r_cts|6,pats6|; jump if same as last string c3.738|24175
||mov|11,-(xs)|7,xr||; save string pointer|24176
||lsh|8,wc|1,1||; shift to next position|24177
||nzb|8,wc|6,pats4||; skip if position left in this tbl|24178
;
;      here we must allocate a new character table
;
||mov|8,wa|19,*ctsi_||; set size of ctblk|24182
||jsr|6,alloc|||; allocate ctblk|24183
||mov|3,r_ctp|7,xr||; store ptr to new ctblk|24184
||mov|10,(xr)+|22,=b_ctt||; store type code, bump ptr|24185
||lct|8,wb|18,=cfp_a||; set number of words to clear|24186
||mov|8,wc|4,bits0||; load all zero bits|24187
;
;      loop to clear all bits in table to zeros
;
|pats3|mov|10,(xr)+|8,wc||; move word of zero bits|24191
||bct|8,wb|6,pats3||; loop till all cleared|24192
||mov|8,wc|4,bits1||; set initial bit position|24193
;
;      merge here with bit position available
;
|pats4|mov|3,ctmsk|8,wc||; save parm2 (new bit position)|24197
||mov|7,xl|10,(xs)+||; restore pointer to argument string|24198
||mov|3,r_cts|7,xl||; save for next time   c3.738|24199
||mov|8,wb|13,sclen(xl)||; load string length|24200
||bze|8,wb|6,pats6||; jump if null string case|24201
||lct|8,wb|8,wb||; else set loop counter|24202
||plc|7,xl|||; point to characters in argument|24203
||ejc|||||24204
;
;      patst (continued)
;
;      loop to set bits in column of table
;
|pats5|lch|8,wa|10,(xl)+||; load next character|24210
||wtb|8,wa|||; convert to byte offset|24211
||mov|7,xr|3,r_ctp||; point to ctblk|24212
||add|7,xr|8,wa||; point to ctblk entry|24213
||mov|8,wa|8,wc||; copy bit mask|24214
||orb|8,wa|13,ctchs(xr)||; or in bits already set|24215
||mov|13,ctchs(xr)|8,wa||; store resulting bit string|24216
||bct|8,wb|6,pats5||; loop till all bits set|24217
;
;      complete processing for multi-char string case
;
|pats6|mov|7,xr|3,r_ctp||; load ctblk ptr as parm1 for pbild|24221
||zer|7,xl|||; clear garbage ptr in xl|24222
||mov|8,wb|10,(xs)+||; load pcode for multi-char str case|24223
||brn|6,pats1|||; back to exit (wc=bitstring=parm2)|24224
;
;      here if argument is not a string
;
;      note that the call from evals cannot pass an expression
;      since evalp always reevaluates expressions.
;
|pats7|mov|8,wb|8,wc||; set pcode for expression argument|24231
||blo|9,(xr)|22,=b_e__|6,pats1|; jump to exit if expression arg|24232
||exi|1,1|||; else take wrong type error exit|24233
||enp||||; end procedure patst|24234
||ejc|||||24235
;
;      pbild -- build pattern node
;
;      (xr)		     parm1 (only if required)
;      (wb)		     pcode for node
;      (wc)		     parm2 (only if required)
;      jsr  pbild	     call to build node
;      (xr)		     pointer to constructed node
;      (wa)		     destroyed
;
|pbild|prc|25,e|1,0||; entry point|24246
||mov|11,-(xs)|7,xr||; stack possible parm1|24247
||mov|7,xr|8,wb||; copy pcode|24248
||lei|7,xr|||; load entry point id (bl_px)|24249
||beq|7,xr|18,=bl_p1|6,pbld1|; jump if one parameter|24250
||beq|7,xr|18,=bl_p0|6,pbld3|; jump if no parameters|24251
;
;      here for two parameter case
;
||mov|8,wa|19,*pcsi_||; set size of p2blk|24255
||jsr|6,alloc|||; allocate block|24256
||mov|13,parm2(xr)|8,wc||; store second parameter|24257
||brn|6,pbld2|||; merge with one parm case|24258
;
;      here for one parameter case
;
|pbld1|mov|8,wa|19,*pbsi_||; set size of p1blk|24262
||jsr|6,alloc|||; allocate node|24263
;
;      merge here from two parm case
;
|pbld2|mov|13,parm1(xr)|9,(xs)||; store first parameter|24267
||brn|6,pbld4|||; merge with no parameter case|24268
;
;      here for case of no parameters
;
|pbld3|mov|8,wa|19,*pasi_||; set size of p0blk|24272
||jsr|6,alloc|||; allocate node|24273
;
;      merge here from other cases
;
|pbld4|mov|9,(xr)|8,wb||; store pcode|24277
||ica|7,xs|||; pop first parameter|24278
||mov|13,pthen(xr)|21,=ndnth||; set nothen successor pointer|24279
||exi||||; return to pbild caller|24280
||enp||||; end procedure pbild|24281
||ejc|||||24282
;
;      pconc -- concatenate two patterns
;
;      (xl)		     ptr to right pattern
;      (xr)		     ptr to left pattern
;      jsr  pconc	     call to concatenate patterns
;      (xr)		     ptr to concatenated pattern
;      (xl,wa,wb,wc)	     destroyed
;
;
;      to concatenate two patterns, all successors in the left
;      pattern which point to the nothen node must be changed to
;      point to the right pattern. however, this modification
;      must be performed on a copy of the left argument rather
;      than the left argument itself, since the left argument
;      may be pointed to by some other variable value.
;
;      accordingly, it is necessary to copy the left argument.
;      this is not a trivial process since we must avoid copying
;      nodes more than once and the pattern is a graph structure
;      the following algorithm is employed.
;
;      the stack is used to store a list of nodes which
;      have already been copied. the format of the entries on
;      this list consists of a two word block. the first word
;      is the old address and the second word is the address
;      of the copy. this list is searched by the pcopy
;      routine to avoid making duplicate copies. a trick is
;      used to accomplish the concatenation at the same time.
;      a special entry is made to start with on the stack. this
;      entry records that the nothen node has been copied
;      already and the address of its copy is the right pattern.
;      this automatically performs the correct replacements.
;
|pconc|prc|25,e|1,0||; entry point|24317
||zer|11,-(xs)|||; make room for one entry at bottom|24318
||mov|8,wc|7,xs||; store pointer to start of list|24319
||mov|11,-(xs)|21,=ndnth||; stack nothen node as old node|24320
||mov|11,-(xs)|7,xl||; store right arg as copy of nothen|24321
||mov|7,xt|7,xs||; initialize pointer to stack entries|24322
||jsr|6,pcopy|||; copy first node of left arg|24323
||mov|13,num02(xt)|8,wa||; store as result under list|24324
||ejc|||||24325
;
;      pconc (continued)
;
;      the following loop scans entries in the list and makes
;      sure that their successors have been copied.
;
|pcnc1|beq|7,xt|7,xs|6,pcnc2|; jump if all entries processed|24332
||mov|7,xr|11,-(xt)||; else load next old address|24333
||mov|7,xr|13,pthen(xr)||; load pointer to successor|24334
||jsr|6,pcopy|||; copy successor node|24335
||mov|7,xr|11,-(xt)||; load pointer to new node (copy)|24336
||mov|13,pthen(xr)|8,wa||; store ptr to new successor|24337
;
;      now check for special case of alternation node where
;      parm1 points to a node and must be copied like pthen.
;
||bne|9,(xr)|22,=p_alt|6,pcnc1|; loop back if not|24342
||mov|7,xr|13,parm1(xr)||; else load pointer to alternative|24343
||jsr|6,pcopy|||; copy it|24344
||mov|7,xr|9,(xt)||; restore ptr to new node|24345
||mov|13,parm1(xr)|8,wa||; store ptr to copied alternative|24346
||brn|6,pcnc1|||; loop back for next entry|24347
;
;      here at end of copy process
;
|pcnc2|mov|7,xs|8,wc||; restore stack pointer|24351
||mov|7,xr|10,(xs)+||; load pointer to copy|24352
||exi||||; return to pconc caller|24353
||enp||||; end procedure pconc|24354
||ejc|||||24355
;
;      pcopy -- copy a pattern node
;
;      pcopy is called from the pconc procedure to copy a single
;      pattern node. the copy is only carried out if the node
;      has not been copied already.
;
;      (xr)		     pointer to node to be copied
;      (xt)		     ptr to current loc in copy list
;      (wc)		     pointer to list of copied nodes
;      jsr  pcopy	     call to copy a node
;      (wa)		     pointer to copy
;      (wb,xr)		     destroyed
;
|pcopy|prc|25,n|1,0||; entry point|24370
||mov|8,wb|7,xt||; save xt|24371
||mov|7,xt|8,wc||; point to start of list|24372
;
;      loop to search list of nodes copied already
;
|pcop1|dca|7,xt|||; point to next entry on list|24376
||beq|7,xr|9,(xt)|6,pcop2|; jump if match|24377
||dca|7,xt|||; else skip over copied address|24378
||bne|7,xt|7,xs|6,pcop1|; loop back if more to test|24379
;
;      here if not in list, perform copy
;
||mov|8,wa|9,(xr)||; load first word of block|24383
||jsr|6,blkln|||; get length of block|24384
||mov|7,xl|7,xr||; save pointer to old node|24385
||jsr|6,alloc|||; allocate space for copy|24386
||mov|11,-(xs)|7,xl||; store old address on list|24387
||mov|11,-(xs)|7,xr||; store new address on list|24388
||chk||||; check for stack overflow|24389
||mvw||||; move words from old block to copy|24390
||mov|8,wa|9,(xs)||; load pointer to copy|24391
||brn|6,pcop3|||; jump to exit|24392
;
;      here if we find entry in list
;
|pcop2|mov|8,wa|11,-(xt)||; load address of copy from list|24396
;
;      common exit point
;
|pcop3|mov|7,xt|8,wb||; restore xt|24400
||exi||||; return to pcopy caller|24401
||enp||||; end procedure pcopy|24402
||ejc|||||24403
;
;      prflr -- print profile
;      prflr is called to print the contents of the profile
;      table in a fairly readable tabular format.
;
;      jsr  prflr	     call to print profile
;      (wa,ia)		     destroyed
;
|prflr|prc|25,e|1,0||;|24414
||bze|3,pfdmp|6,prfl4||; no printing if no profiling done|24415
||mov|11,-(xs)|7,xr||; preserve entry xr|24416
||mov|3,pfsvw|8,wb||; and also wb|24417
||jsr|6,prtpg|||; eject|24418
||mov|7,xr|21,=pfms1||; load msg /program profile/|24419
||jsr|6,prtst|||; and print it|24420
||jsr|6,prtnl|||; followed by newline|24421
||jsr|6,prtnl|||; and another|24422
||mov|7,xr|21,=pfms2||; point to first hdr|24423
||jsr|6,prtst|||; print it|24424
||jsr|6,prtnl|||; new line|24425
||mov|7,xr|21,=pfms3||; second hdr|24426
||jsr|6,prtst|||; print it|24427
||jsr|6,prtnl|||; new line|24428
||jsr|6,prtnl|||; and another blank line|24429
||zer|8,wb|||; initial stmt count|24430
||mov|7,xr|3,pftbl||; point to table origin|24431
||add|7,xr|19,*xndta||; bias past xnblk header (sgd07)|24432
;
;      loop here to print successive entries
;
|prfl1|icv|8,wb|||; bump stmt nr|24436
||ldi|9,(xr)|||; load nr of executions|24437
||ieq|6,prfl3|||; no printing if zero|24438
||mov|3,profs|18,=pfpd1||; point where to print|24439
||jsr|6,prtin|||; and print it|24440
||zer|3,profs|||; back to start of line|24441
||mti|8,wb|||; load stmt nr|24442
||jsr|6,prtin|||; print it there|24443
||mov|3,profs|18,=pfpd2||; and pad past count|24444
||ldi|13,cfp_i(xr)|||; load total exec time|24445
||jsr|6,prtin|||; print that too|24446
||ldi|13,cfp_i(xr)|||; reload time|24447
||mli|4,intth|||; convert to microsec|24448
||iov|6,prfl2|||; omit next bit if overflow|24449
||dvi|9,(xr)|||; divide by executions|24450
||mov|3,profs|18,=pfpd3||; pad last print|24451
||jsr|6,prtin|||; and print mcsec/execn|24452
;
;      merge after printing time
;
|prfl2|jsr|6,prtnl|||; thats another line|24456
;
;      here to go to next entry
;
|prfl3|add|7,xr|19,*pf_i2||; bump index ptr (sgd07)|24460
||blt|8,wb|3,pfnte|6,prfl1|; loop if more stmts|24461
||mov|7,xr|10,(xs)+||; restore callers xr|24462
||mov|8,wb|3,pfsvw||; and wb too|24463
;
;      here to exit
;
|prfl4|exi||||; return|24467
||enp||||; end of prflr|24468
||ejc|||||24469
;
;      prflu -- update an entry in the profile table
;
;      on entry, kvstn contains nr of stmt to profile
;
;      jsr  prflu	     call to update entry
;      (ia)		     destroyed
;
|prflu|prc|25,e|1,0||;|24478
||bnz|3,pffnc|6,pflu4||; skip if just entered function|24479
||mov|11,-(xs)|7,xr||; preserve entry xr|24480
||mov|3,pfsvw|8,wa||; save wa (sgd07)|24481
||bnz|3,pftbl|6,pflu2||; branch if table allocated|24482
;
;      here if space for profile table not yet allocated.
;      calculate size needed, allocate a static xnblk, and
;      initialize it all to zero.
;      the time taken for this will be attributed to the current
;      statement (assignment to keywd profile), but since the
;      timing for this statement is up the pole anyway, this
;      doesnt really matter...
;
||sub|3,pfnte|18,=num01||; adjust for extra count (sgd07)|24492
||mti|4,pfi2a|||; convrt entry size to int|24493
||sti|3,pfste|||; and store safely for later|24494
||mti|3,pfnte|||; load table length as integer|24495
||mli|3,pfste|||; multiply by entry size|24496
||mfi|8,wa|||; get back address-style|24497
||add|8,wa|18,=num02||; add on 2 word overhead|24498
||wtb|8,wa|||; convert the whole lot to bytes|24499
||jsr|6,alost|||; gimme the space|24500
||mov|3,pftbl|7,xr||; save block pointer|24501
||mov|10,(xr)+|22,=b_xnt||; put block type and ...|24502
||mov|10,(xr)+|8,wa||; ... length into header|24503
||mfi|8,wa|||; get back nr of wds in data area|24504
||lct|8,wa|8,wa||; load the counter|24505
;
;      loop here to zero the block data
;
|pflu1|zer|10,(xr)+|||; blank a word|24509
||bct|8,wa|6,pflu1||; and alllllll the rest|24510
;
;      end of allocation. merge back into routine
;
|pflu2|mti|3,kvstn|||; load nr of stmt just ended|24514
||sbi|4,intv1|||; make into index offset|24515
||mli|3,pfste|||; make offset of table entry|24516
||mfi|8,wa|||; convert to address|24517
||wtb|8,wa|||; get as baus|24518
||add|8,wa|19,*num02||; offset includes table header|24519
||mov|7,xr|3,pftbl||; get table start|24520
||bge|8,wa|13,num01(xr)|6,pflu3|; if out of table, skip it|24521
||add|7,xr|8,wa||; else point to entry|24522
||ldi|9,(xr)|||; get nr of executions so far|24523
||adi|4,intv1|||; nudge up one|24524
||sti|9,(xr)|||; and put back|24525
||jsr|6,systm|||; get time now|24526
||sti|3,pfetm|||; stash ending time|24527
||sbi|3,pfstm|||; subtract start time|24528
||adi|13,cfp_i(xr)|||; add cumulative time so far|24529
||sti|13,cfp_i(xr)|||; and put back new total|24530
||ldi|3,pfetm|||; load end time of this stmt ...|24531
||sti|3,pfstm|||; ... which is start time of next|24532
;
;      merge here to exit
;
|pflu3|mov|7,xr|10,(xs)+||; restore callers xr|24536
||mov|8,wa|3,pfsvw||; restore saved reg|24537
||exi||||; and return|24538
;
;      here if profile is suppressed because a program defined
;      function is about to be entered, and so the current stmt
;      has not yet finished
;
|pflu4|zer|3,pffnc|||; reset the condition flag|24544
||exi||||; and immediate return|24545
||enp||||; end of procedure prflu|24546
||ejc|||||24547
;
;      prpar - process print parameters
;
;      (wc)		     if nonzero associate terminal only
;      jsr  prpar	     call to process print parameters
;      (xl,xr,wa,wb,wc)	     destroyed
;
;      since memory allocation is undecided on initial call,
;      terminal cannot be associated. the entry with wc non-zero
;      is provided so a later call can be made to complete this.
;
|prpar|prc|25,e|1,0||; entry point|24560
||bnz|8,wc|6,prpa8||; jump to associate terminal|24561
||jsr|6,syspp|||; get print parameters|24562
||bnz|8,wb|6,prpa1||; jump if lines/page specified|24563
||mov|8,wb|3,mxint||; else use a large value|24564
||rsh|8,wb|1,1||; but not too large|24565
;
;      store line count/page
;
|prpa1|mov|3,lstnp|8,wb||; store number of lines/page|24569
||mov|3,lstlc|8,wb||; pretend page is full initially|24570
||zer|3,lstpg|||; clear page number|24571
||mov|8,wb|3,prlen||; get prior length if any|24572
||bze|8,wb|6,prpa2||; skip if no length|24573
||bgt|8,wa|8,wb|6,prpa3|; skip storing if too big|24574
;
;      store print buffer length
;
|prpa2|mov|3,prlen|8,wa||; store value|24578
;
;      process bits options
;
|prpa3|mov|8,wb|4,bits3||; bit 3 mask|24582
||anb|8,wb|8,wc||; get -nolist bit|24583
||zrb|8,wb|6,prpa4||; skip if clear|24584
||zer|3,cswls|||; set -nolist|24585
;
;      check if fail reports goto interactive channel
;
|prpa4|mov|8,wb|4,bits1||; bit 1 mask|24589
||anb|8,wb|8,wc||; get bit|24590
||mov|3,erich|8,wb||; store int. chan. error flag|24591
||mov|8,wb|4,bits2||; bit 2 mask|24592
||anb|8,wb|8,wc||; get bit|24593
||mov|3,prich|8,wb||; flag for std printer on int. chan.|24594
||mov|8,wb|4,bits4||; bit 4 mask|24595
||anb|8,wb|8,wc||; get bit|24596
||mov|3,cpsts|8,wb||; flag for compile stats suppressn.|24597
||mov|8,wb|4,bits5||; bit 5 mask|24598
||anb|8,wb|8,wc||; get bit|24599
||mov|3,exsts|8,wb||; flag for exec stats suppression|24600
||ejc|||||24601
;
;      prpar (continued)
;
||mov|8,wb|4,bits6||; bit 6 mask|24605
||anb|8,wb|8,wc||; get bit|24606
||mov|3,precl|8,wb||; extended/compact listing flag|24607
||sub|8,wa|18,=num08||; point 8 chars from line end|24608
||zrb|8,wb|6,prpa5||; jump if not extended|24609
||mov|3,lstpo|8,wa||; store for listing page headings|24610
;
;	continue option processing
;
|prpa5|mov|8,wb|4,bits7||; bit 7 mask|24614
||anb|8,wb|8,wc||; get bit 7|24615
||mov|3,cswex|8,wb||; set -noexecute if non-zero|24616
||mov|8,wb|4,bit10||; bit 10 mask|24617
||anb|8,wb|8,wc||; get bit 10|24618
||mov|3,headp|8,wb||; pretend printed to omit headers|24619
||mov|8,wb|4,bits9||; bit 9 mask|24620
||anb|8,wb|8,wc||; get bit 9|24621
||mov|3,prsto|8,wb||; keep it as std listing option|24622
||mov|8,wb|8,wc||; copy flags|24624
||rsh|8,wb|1,12||; right justify bit 13|24625
||anb|8,wb|4,bits1||; get bit|24626
||mov|3,kvcas|8,wb||; set -case|24627
||mov|8,wb|4,bit12||; bit 12 mask|24629
||anb|8,wb|8,wc||; get bit 12|24630
||mov|3,cswer|8,wb||; keep it as errors/noerrors option|24631
||zrb|8,wb|6,prpa6||; skip if clear|24632
||mov|8,wa|3,prlen||; get print buffer length|24633
||sub|8,wa|18,=num08||; point 8 chars from line end|24634
||mov|3,lstpo|8,wa||; store page offset|24635
;
;      check for -print/-noprint
;
|prpa6|mov|8,wb|4,bit11||; bit 11 mask|24639
||anb|8,wb|8,wc||; get bit 11|24640
||mov|3,cswpr|8,wb||; set -print if non-zero|24641
;
;      check for terminal
;
||anb|8,wc|4,bits8||; see if terminal to be activated|24645
||bnz|8,wc|6,prpa8||; jump if terminal required|24646
||bze|3,initr|6,prpa9||; jump if no terminal to detach|24647
||mov|7,xl|21,=v_ter||; ptr to /terminal/|24648
||jsr|6,gtnvr|||; get vrblk pointer|24649
||ppm||||; cant fail|24650
||mov|13,vrval(xr)|21,=nulls||; clear value of terminal|24651
||jsr|6,setvr|||; remove association|24652
||brn|6,prpa9|||; return|24653
;
;      associate terminal
;
|prpa8|mnz|3,initr|||; note terminal associated|24657
||bze|3,dnamb|6,prpa9||; cant if memory not organised|24658
||mov|7,xl|21,=v_ter||; point to terminal string|24659
||mov|8,wb|18,=trtou||; output trace type|24660
||jsr|6,inout|||; attach output trblk to vrblk|24661
||mov|11,-(xs)|7,xr||; stack trblk ptr|24662
||mov|7,xl|21,=v_ter||; point to terminal string|24663
||mov|8,wb|18,=trtin||; input trace type|24664
||jsr|6,inout|||; attach input trace blk|24665
||mov|13,vrval(xr)|10,(xs)+||; add output trblk to chain|24666
;
;      return point
;
|prpa9|exi||||; return|24670
||enp||||; end procedure prpar|24671
||ejc|||||24672
;
;      prtch -- print a character
;
;      prtch is used to print a single character
;
;      (wa)		     character to be printed
;      jsr  prtch	     call to print character
;
|prtch|prc|25,e|1,0||; entry point|24681
||mov|11,-(xs)|7,xr||; save xr|24682
||bne|3,profs|3,prlen|6,prch1|; jump if room in buffer|24683
||jsr|6,prtnl|||; else print this line|24684
;
;      here after making sure we have room
;
|prch1|mov|7,xr|3,prbuf||; point to print buffer|24688
||psc|7,xr|3,profs||; point to next character location|24689
||sch|8,wa|9,(xr)||; store new character|24690
||csc|7,xr|||; complete store characters|24691
||icv|3,profs|||; bump pointer|24692
||mov|7,xr|10,(xs)+||; restore entry xr|24693
||exi||||; return to prtch caller|24694
||enp||||; end procedure prtch|24695
||ejc|||||24696
;
;      prtic -- print to interactive channel
;
;      prtic is called to print the contents of the standard
;      print buffer to the interactive channel. it is only
;      called after prtst has set up the string for printing.
;      it does not clear the buffer.
;
;      jsr  prtic	     call for print
;      (wa,wb)		     destroyed
;
|prtic|prc|25,e|1,0||; entry point|24708
||mov|11,-(xs)|7,xr||; save xr|24709
||mov|7,xr|3,prbuf||; point to buffer|24710
||mov|8,wa|3,profs||; no of chars|24711
||jsr|6,syspi|||; print|24712
||ppm|6,prtc2|||; fail return|24713
;
;      return
;
|prtc1|mov|7,xr|10,(xs)+||; restore xr|24717
||exi||||; return|24718
;
;      error occured
;
|prtc2|zer|3,erich|||; prevent looping|24722
||erb|1,252|26,error on printing to interactive channel|||24723
||brn|6,prtc1|||; return|24724
||enp||||; procedure prtic|24725
||ejc|||||24726
;
;      prtis -- print to interactive and standard printer
;
;      prtis puts a line from the print buffer onto the
;      interactive channel (if any) and the standard printer.
;      it always prints to the standard printer but does
;      not duplicate lines if the standard printer is
;      interactive.  it clears down the print buffer.
;
;      jsr  prtis	     call for printing
;      (wa,wb)		     destroyed
;
|prtis|prc|25,e|1,0||; entry point|24739
||bnz|3,prich|6,prts1||; jump if standard printer is int.ch.|24740
||bze|3,erich|6,prts1||; skip if not doing int. error reps.|24741
||jsr|6,prtic|||; print to interactive channel|24742
;
;      merge and exit
;
|prts1|jsr|6,prtnl|||; print to standard printer|24746
||exi||||; return|24747
||enp||||; end procedure prtis|24748
||ejc|||||24749
;
;      prtin -- print an integer
;
;      prtin prints the integer value which is in the integer
;      accumulator. blocks built in dynamic storage
;      during this process are immediately deleted.
;
;      (ia)		     integer value to be printed
;      jsr  prtin	     call to print integer
;      (ia,ra)		     destroyed
;
|prtin|prc|25,e|1,0||; entry point|24761
||mov|11,-(xs)|7,xr||; save xr|24762
||jsr|6,icbld|||; build integer block|24763
||blo|7,xr|3,dnamb|6,prti1|; jump if icblk below dynamic|24764
||bhi|7,xr|3,dnamp|6,prti1|; jump if above dynamic|24765
||mov|3,dnamp|7,xr||; immediately delete it|24766
;
;      delete icblk from dynamic store
;
|prti1|mov|11,-(xs)|7,xr||; stack ptr for gtstg|24770
||jsr|6,gtstg|||; convert to string|24771
||ppm||||; convert error is impossible|24772
||mov|3,dnamp|7,xr||; reset pointer to delete scblk|24773
||jsr|6,prtst|||; print integer string|24774
||mov|7,xr|10,(xs)+||; restore entry xr|24775
||exi||||; return to prtin caller|24776
||enp||||; end procedure prtin|24777
||ejc|||||24778
;
;      prtmi -- print message and integer
;
;      prtmi is used to print messages together with an integer
;      value starting in column 15 (used by the routines at
;      the end of compilation).
;
;      jsr  prtmi	     call to print message and integer
;
|prtmi|prc|25,e|1,0||; entry point|24788
||jsr|6,prtst|||; print string message|24789
||mov|3,profs|18,=prtmf||; set column offset|24790
||jsr|6,prtin|||; print integer|24791
||jsr|6,prtnl|||; print line|24792
||exi||||; return to prtmi caller|24793
||enp||||; end procedure prtmi|24794
||ejc|||||24795
;
;      prtmm -- print memory used and available
;
;      prtmm is used to provide memory usage information in
;      both the end-of-compile and end-of-run statistics.
;
;      jsr  prtmm	     call to print memory stats
;
|prtmm|prc|25,e|1,0||;|24804
||mov|8,wa|3,dnamp||; next available loc|24805
||sub|8,wa|3,statb||; minus start|24806
||mti|8,wa|||; convert to integer|24811
||mov|7,xr|21,=encm1||; point to /memory used (words)/|24812
||jsr|6,prtmi|||; print message|24813
||mov|8,wa|3,dname||; end of memory|24814
||sub|8,wa|3,dnamp||; minus next available loc|24815
||mti|8,wa|||; convert to integer|24820
||mov|7,xr|21,=encm2||; point to /memory available (words)/|24821
||jsr|6,prtmi|||; print line|24822
||exi||||; return to prtmm caller|24823
||enp||||; end of procedure prtmm|24824
||ejc|||||24825
;
;      prtmx  -- as prtmi with extra copy to interactive chan.
;
;      jsr  prtmx	     call for printing
;      (wa,wb)		     destroyed
;
|prtmx|prc|25,e|1,0||; entry point|24832
||jsr|6,prtst|||; print string message|24833
||mov|3,profs|18,=prtmf||; set column offset|24834
||jsr|6,prtin|||; print integer|24835
||jsr|6,prtis|||; print line|24836
||exi||||; return|24837
||enp||||; end procedure prtmx|24838
||ejc|||||24839
;
;      prtnl -- print new line (end print line)
;
;      prtnl prints the contents of the print buffer, resets
;      the buffer to all blanks and resets the print pointer.
;
;      jsr  prtnl	     call to print line
;
|prtnl|prc|25,r|1,0||; entry point|24848
||bnz|3,headp|6,prnl0||; were headers printed|24849
||jsr|6,prtps|||; no - print them|24850
;
;      call syspr
;
|prnl0|mov|11,-(xs)|7,xr||; save entry xr|24854
||mov|3,prtsa|8,wa||; save wa|24855
||mov|3,prtsb|8,wb||; save wb|24856
||mov|7,xr|3,prbuf||; load pointer to buffer|24857
||mov|8,wa|3,profs||; load number of chars in buffer|24858
||jsr|6,syspr|||; call system print routine|24859
||ppm|6,prnl2|||; jump if failed|24860
||lct|8,wa|3,prlnw||; load length of buffer in words|24861
||add|7,xr|19,*schar||; point to chars of buffer|24862
||mov|8,wb|4,nullw||; get word of blanks|24863
;
;      loop to blank buffer
;
|prnl1|mov|10,(xr)+|8,wb||; store word of blanks, bump ptr|24867
||bct|8,wa|6,prnl1||; loop till all blanked|24868
;
;      exit point
;
||mov|8,wb|3,prtsb||; restore wb|24872
||mov|8,wa|3,prtsa||; restore wa|24873
||mov|7,xr|10,(xs)+||; restore entry xr|24874
||zer|3,profs|||; reset print buffer pointer|24875
||exi||||; return to prtnl caller|24876
;
;      file full or no output file for load module
;
|prnl2|bnz|3,prtef|6,prnl3||; jump if not first time|24880
||mnz|3,prtef|||; mark first occurrence|24881
||erb|1,253|26,print limit exceeded on standard output channel|||24882
;
;      stop at once
;
|prnl3|mov|8,wb|18,=nini8||; ending code|24886
||mov|8,wa|3,kvstn||; statement number|24887
||mov|7,xl|3,r_fcb||; get fcblk chain head|24888
||jsr|6,sysej|||; stop|24889
||enp||||; end procedure prtnl|24890
||ejc|||||24891
;
;      prtnm -- print variable name
;
;      prtnm is used to print a character representation of the
;      name of a variable (not a value of datatype name)
;      names of pseudo-variables may not be passed to prtnm.
;
;      (xl)		     name base
;      (wa)		     name offset
;      jsr  prtnm	     call to print name
;      (wb,wc,ra)	     destroyed
;
|prtnm|prc|25,r|1,0||; entry point (recursive, see prtvl)|24904
||mov|11,-(xs)|8,wa||; save wa (offset is collectable)|24905
||mov|11,-(xs)|7,xr||; save entry xr|24906
||mov|11,-(xs)|7,xl||; save name base|24907
||bhi|7,xl|3,state|6,prn02|; jump if not natural variable|24908
;
;      here for natural variable name, recognized by the fact
;      that the name base points into the static area.
;
||mov|7,xr|7,xl||; point to vrblk|24913
||jsr|6,prtvn|||; print name of variable|24914
;
;      common exit point
;
|prn01|mov|7,xl|10,(xs)+||; restore name base|24918
||mov|7,xr|10,(xs)+||; restore entry value of xr|24919
||mov|8,wa|10,(xs)+||; restore wa|24920
||exi||||; return to prtnm caller|24921
;
;      here for case of non-natural variable
;
|prn02|mov|8,wb|8,wa||; copy name offset|24925
||bne|9,(xl)|22,=b_pdt|6,prn03|; jump if array or table|24926
;
;      for program defined datatype, prt fld name, left paren
;
||mov|7,xr|13,pddfp(xl)||; load pointer to dfblk|24930
||add|7,xr|8,wa||; add name offset|24931
||mov|7,xr|13,pdfof(xr)||; load vrblk pointer for field|24932
||jsr|6,prtvn|||; print field name|24933
||mov|8,wa|18,=ch_pp||; load left paren|24934
||jsr|6,prtch|||; print character|24935
||ejc|||||24936
;
;      prtnm (continued)
;
;      now we print an identifying name for the object if one
;      can be found. the following code searches for a natural
;      variable which contains this object as value. if such a
;      variable is found, its name is printed, else the value
;      of the object (as printed by prtvl) is used instead.
;
;      first we point to the parent tbblk if this is the case of
;      a table element. to do this, chase down the trnxt chain.
;
|prn03|bne|9,(xl)|22,=b_tet|6,prn04|; jump if we got there (or not te)|24949
||mov|7,xl|13,tenxt(xl)||; else move out on chain|24950
||brn|6,prn03|||; and loop back|24951
;
;      now we are ready for the search. to speed things up in
;      the case of calls from dump where the same name base
;      will occur repeatedly while dumping an array or table,
;      we remember the last vrblk pointer found in prnmv. so
;      first check to see if we have this one again.
;
|prn04|mov|7,xr|3,prnmv||; point to vrblk we found last time|24959
||mov|8,wa|3,hshtb||; point to hash table in case not|24960
||brn|6,prn07|||; jump into search for special check|24961
;
;      loop through hash slots
;
|prn05|mov|7,xr|8,wa||; copy slot pointer|24965
||ica|8,wa|||; bump slot pointer|24966
||sub|7,xr|19,*vrnxt||; introduce standard vrblk offset|24967
;
;      loop through vrblks on one hash chain
;
|prn06|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on hash chain|24971
;
;      merge here first time to check block we found last time
;
|prn07|mov|8,wc|7,xr||; copy vrblk pointer|24975
||bze|8,wc|6,prn09||; jump if chain end (or prnmv zero)|24976
||ejc|||||24977
;
;      prtnm (continued)
;
;      loop to find value (chase down possible trblk chain)
;
|prn08|mov|7,xr|13,vrval(xr)||; load value|24983
||beq|9,(xr)|22,=b_trt|6,prn08|; loop if that was a trblk|24984
;
;      now we have the value, is this the block we want
;
||beq|7,xr|7,xl|6,prn10|; jump if this matches the name base|24988
||mov|7,xr|8,wc||; else point back to that vrblk|24989
||brn|6,prn06|||; and loop back|24990
;
;      here to move to next hash slot
;
|prn09|blt|8,wa|3,hshte|6,prn05|; loop back if more to go|24994
||mov|7,xr|7,xl||; else not found, copy value pointer|24995
||jsr|6,prtvl|||; print value|24996
||brn|6,prn11|||; and merge ahead|24997
;
;      here when we find a matching entry
;
|prn10|mov|7,xr|8,wc||; copy vrblk pointer|25001
||mov|3,prnmv|7,xr||; save for next time in|25002
||jsr|6,prtvn|||; print variable name|25003
;
;      merge here if no entry found
;
|prn11|mov|8,wc|9,(xl)||; load first word of name base|25007
||bne|8,wc|22,=b_pdt|6,prn13|; jump if not program defined|25008
;
;      for program defined datatype, add right paren and exit
;
||mov|8,wa|18,=ch_rp||; load right paren, merge|25012
;
;      merge here to print final right paren or bracket
;
|prn12|jsr|6,prtch|||; print final character|25016
||mov|8,wa|8,wb||; restore name offset|25017
||brn|6,prn01|||; merge back to exit|25018
||ejc|||||25019
;
;      prtnm (continued)
;
;      here for array or table
;
|prn13|mov|8,wa|18,=ch_bb||; load left bracket|25025
||jsr|6,prtch|||; and print it|25026
||mov|7,xl|9,(xs)||; restore block pointer|25027
||mov|8,wc|9,(xl)||; load type word again|25028
||bne|8,wc|22,=b_tet|6,prn15|; jump if not table|25029
;
;      here for table, print subscript value
;
||mov|7,xr|13,tesub(xl)||; load subscript value|25033
||mov|7,xl|8,wb||; save name offset|25034
||jsr|6,prtvl|||; print subscript value|25035
||mov|8,wb|7,xl||; restore name offset|25036
;
;      merge here from array case to print right bracket
;
|prn14|mov|8,wa|18,=ch_rb||; load right bracket|25040
||brn|6,prn12|||; merge back to print it|25041
;
;      here for array or vector, to print subscript(s)
;
|prn15|mov|8,wa|8,wb||; copy name offset|25045
||btw|8,wa|||; convert to words|25046
||beq|8,wc|22,=b_art|6,prn16|; jump if arblk|25047
;
;      here for vector
;
||sub|8,wa|18,=vcvlb||; adjust for standard fields|25051
||mti|8,wa|||; move to integer accum|25052
||jsr|6,prtin|||; print linear subscript|25053
||brn|6,prn14|||; merge back for right bracket|25054
||ejc|||||25055
;
;      prtnm (continued)
;
;      here for array. first calculate absolute subscript
;      offsets by successive divisions by the dimension values.
;      this must be done right to left since the elements are
;      stored row-wise. the subscripts are stacked as integers.
;
|prn16|mov|8,wc|13,arofs(xl)||; load length of bounds info|25064
||ica|8,wc|||; adjust for arpro field|25065
||btw|8,wc|||; convert to words|25066
||sub|8,wa|8,wc||; get linear zero-origin subscript|25067
||mti|8,wa|||; get integer value|25068
||lct|8,wa|13,arndm(xl)||; set num of dimensions as loop count|25069
||add|7,xl|13,arofs(xl)||; point past bounds information|25070
||sub|7,xl|19,*arlbd||; set ok offset for proper ptr later|25071
;
;      loop to stack subscript offsets
;
|prn17|sub|7,xl|19,*ardms||; point to next set of bounds|25075
||sti|3,prnsi|||; save current offset|25076
||rmi|13,ardim(xl)|||; get remainder on dividing by dimens|25077
||mfi|11,-(xs)|||; store on stack (one word)|25078
||ldi|3,prnsi|||; reload argument|25079
||dvi|13,ardim(xl)|||; divide to get quotient|25080
||bct|8,wa|6,prn17||; loop till all stacked|25081
||zer|7,xr|||; set offset to first set of bounds|25082
||lct|8,wb|13,arndm(xl)||; load count of dims to control loop|25083
||brn|6,prn19|||; jump into print loop|25084
;
;      loop to print subscripts from stack adjusting by adding
;      the appropriate low bound value from the arblk
;
|prn18|mov|8,wa|18,=ch_cm||; load a comma|25089
||jsr|6,prtch|||; print it|25090
;
;      merge here first time in (no comma required)
;
|prn19|mti|10,(xs)+|||; load subscript offset as integer|25094
||add|7,xl|7,xr||; point to current lbd|25095
||adi|13,arlbd(xl)|||; add lbd to get signed subscript|25096
||sub|7,xl|7,xr||; point back to start of arblk|25097
||jsr|6,prtin|||; print subscript|25098
||add|7,xr|19,*ardms||; bump offset to next bounds|25099
||bct|8,wb|6,prn18||; loop back till all printed|25100
||brn|6,prn14|||; merge back to print right bracket|25101
||enp||||; end procedure prtnm|25102
||ejc|||||25103
;
;      prtnv -- print name value
;
;      prtnv is used by the trace and dump routines to print
;      a line of the form
;
;      name = value
;
;      note that the name involved can never be a pseudo-var
;
;      (xl)		     name base
;      (wa)		     name offset
;      jsr  prtnv	     call to print name = value
;      (wb,wc,ra)	     destroyed
;
|prtnv|prc|25,e|1,0||; entry point|25119
||jsr|6,prtnm|||; print argument name|25120
||mov|11,-(xs)|7,xr||; save entry xr|25121
||mov|11,-(xs)|8,wa||; save name offset (collectable)|25122
||mov|7,xr|21,=tmbeb||; point to blank equal blank|25123
||jsr|6,prtst|||; print it|25124
||mov|7,xr|7,xl||; copy name base|25125
||add|7,xr|8,wa||; point to value|25126
||mov|7,xr|9,(xr)||; load value pointer|25127
||jsr|6,prtvl|||; print value|25128
||jsr|6,prtnl|||; terminate line|25129
||mov|8,wa|10,(xs)+||; restore name offset|25130
||mov|7,xr|10,(xs)+||; restore entry xr|25131
||exi||||; return to caller|25132
||enp||||; end procedure prtnv|25133
||ejc|||||25134
;
;      prtpg  -- print a page throw
;
;      prints a page throw or a few blank lines on the standard
;      listing channel depending on the listing options chosen.
;
;      jsr  prtpg	     call for page eject
;
|prtpg|prc|25,e|1,0||; entry point|25143
||beq|3,stage|18,=stgxt|6,prp01|; jump if execution time|25144
||bze|3,lstlc|6,prp06||; return if top of page already|25145
||zer|3,lstlc|||; clear line count|25146
;
;      check type of listing
;
|prp01|mov|11,-(xs)|7,xr||; preserve xr|25150
||bnz|3,prstd|6,prp02||; eject if flag set|25151
||bnz|3,prich|6,prp03||; jump if interactive listing channel|25152
||bze|3,precl|6,prp03||; jump if compact listing|25153
;
;      perform an eject
;
|prp02|jsr|6,sysep|||; eject|25157
||brn|6,prp04|||; merge|25158
;
;      compact or interactive channel listing. cant print
;      blanks until check made for headers printed and flag set.
;
;
|prp03|mov|7,xr|3,headp||; remember headp|25164
||mnz|3,headp|||; set to avoid repeated prtpg calls|25165
||jsr|6,prtnl|||; print blank line|25166
||jsr|6,prtnl|||; print blank line|25167
||jsr|6,prtnl|||; print blank line|25168
||mov|3,lstlc|18,=num03||; count blank lines|25169
||mov|3,headp|7,xr||; restore header flag|25170
||ejc|||||25171
;
;      prptg (continued)
;
;      print the heading
;
|prp04|bnz|3,headp|6,prp05||; jump if header listed|25177
||mnz|3,headp|||; mark headers printed|25178
||mov|11,-(xs)|7,xl||; keep xl|25179
||mov|7,xr|21,=headr||; point to listing header|25180
||jsr|6,prtst|||; place it|25181
||jsr|6,sysid|||; get system identification|25182
||jsr|6,prtst|||; append extra chars|25183
||jsr|6,prtnl|||; print it|25184
||mov|7,xr|7,xl||; extra header line|25185
||jsr|6,prtst|||; place it|25186
||jsr|6,prtnl|||; print it|25187
||jsr|6,prtnl|||; print a blank|25188
||jsr|6,prtnl|||; and another|25189
||add|3,lstlc|18,=num04||; four header lines printed|25190
||mov|7,xl|10,(xs)+||; restore xl|25191
;
;      merge if header not printed
;
|prp05|mov|7,xr|10,(xs)+||; restore xr|25195
;
;      return
;
|prp06|exi||||; return|25199
||enp||||; end procedure prtpg|25200
||ejc|||||25201
;
;      prtps - print page with test for standard listing option
;
;      if the standard listing option is selected, insist that
;      an eject be done
;
;      jsr  prtps	     call for eject
;
|prtps|prc|25,e|1,0||; entry point|25210
||mov|3,prstd|3,prsto||; copy option flag|25211
||jsr|6,prtpg|||; print page|25212
||zer|3,prstd|||; clear flag|25213
||exi||||; return|25214
||enp||||; end procedure prtps|25215
||ejc|||||25216
;
;      prtsn -- print statement number
;
;      prtsn is used to initiate a print trace line by printing
;      asterisks and the current statement number. the actual
;      format of the output generated is.
;
;      ***nnnnn**** iii.....iiii
;
;      nnnnn is the statement number with leading zeros replaced
;      by asterisks (e.g. *******9****)
;
;      iii...iii represents a variable length output consisting
;      of a number of letter i characters equal to fnclevel.
;
;      jsr  prtsn	     call to print statement number
;      (wc)		     destroyed
;
|prtsn|prc|25,e|1,0||; entry point|25235
||mov|11,-(xs)|7,xr||; save entry xr|25236
||mov|3,prsna|8,wa||; save entry wa|25237
||mov|7,xr|21,=tmasb||; point to asterisks|25238
||jsr|6,prtst|||; print asterisks|25239
||mov|3,profs|18,=num04||; point into middle of asterisks|25240
||mti|3,kvstn|||; load statement number as integer|25241
||jsr|6,prtin|||; print integer statement number|25242
||mov|3,profs|18,=prsnf||; point past asterisks plus blank|25243
||mov|7,xr|3,kvfnc||; get fnclevel|25244
||mov|8,wa|18,=ch_li||; set letter i|25245
;
;      loop to generate letter i fnclevel times
;
|prsn1|bze|7,xr|6,prsn2||; jump if all set|25249
||jsr|6,prtch|||; else print an i|25250
||dcv|7,xr|||; decrement counter|25251
||brn|6,prsn1|||; loop back|25252
;
;      merge with all letter i characters generated
;
|prsn2|mov|8,wa|18,=ch_bl||; get blank|25256
||jsr|6,prtch|||; print blank|25257
||mov|8,wa|3,prsna||; restore entry wa|25258
||mov|7,xr|10,(xs)+||; restore entry xr|25259
||exi||||; return to prtsn caller|25260
||enp||||; end procedure prtsn|25261
||ejc|||||25262
;
;      prtst -- print string
;
;      prtst places a string of characters in the print buffer
;
;      see prtnl for global locations used
;
;      note that the first word of the block (normally b_scl)
;      is not used and need not be set correctly (see prtvn)
;
;      (xr)		     string to be printed
;      jsr  prtst	     call to print string
;      (profs)		     updated past chars placed
;
|prtst|prc|25,r|1,0||; entry point|25277
||bnz|3,headp|6,prst0||; were headers printed|25278
||jsr|6,prtps|||; no - print them|25279
;
;      call syspr
;
|prst0|mov|3,prsva|8,wa||; save wa|25283
||mov|3,prsvb|8,wb||; save wb|25284
||zer|8,wb|||; set chars printed count to zero|25285
;
;      loop to print successive lines for long string
;
|prst1|mov|8,wa|13,sclen(xr)||; load string length|25289
||sub|8,wa|8,wb||; subtract count of chars already out|25290
||bze|8,wa|6,prst4||; jump to exit if none left|25291
||mov|11,-(xs)|7,xl||; else stack entry xl|25292
||mov|11,-(xs)|7,xr||; save argument|25293
||mov|7,xl|7,xr||; copy for eventual move|25294
||mov|7,xr|3,prlen||; load print buffer length|25295
||sub|7,xr|3,profs||; get chars left in print buffer|25296
||bnz|7,xr|6,prst2||; skip if room left on this line|25297
||jsr|6,prtnl|||; else print this line|25298
||mov|7,xr|3,prlen||; and set full width available|25299
||ejc|||||25300
;
;      prtst (continued)
;
;      here with chars to print and some room in buffer
;
|prst2|blo|8,wa|7,xr|6,prst3|; jump if room for rest of string|25306
||mov|8,wa|7,xr||; else set to fill line|25307
;
;      merge here with character count in wa
;
|prst3|mov|7,xr|3,prbuf||; point to print buffer|25311
||plc|7,xl|8,wb||; point to location in string|25312
||psc|7,xr|3,profs||; point to location in buffer|25313
||add|8,wb|8,wa||; bump string chars count|25314
||add|3,profs|8,wa||; bump buffer pointer|25315
||mov|3,prsvc|8,wb||; preserve char counter|25316
||mvc||||; move characters to buffer|25317
||mov|8,wb|3,prsvc||; recover char counter|25318
||mov|7,xr|10,(xs)+||; restore argument pointer|25319
||mov|7,xl|10,(xs)+||; restore entry xl|25320
||brn|6,prst1|||; loop back to test for more|25321
;
;      here to exit after printing string
;
|prst4|mov|8,wb|3,prsvb||; restore entry wb|25325
||mov|8,wa|3,prsva||; restore entry wa|25326
||exi||||; return to prtst caller|25327
||enp||||; end procedure prtst|25328
||ejc|||||25329
;
;      prttr -- print to terminal
;
;      called to print contents of standard print buffer to
;      online terminal. clears buffer down and resets profs.
;
;      jsr  prttr	     call for print
;      (wa,wb)		     destroyed
;
|prttr|prc|25,e|1,0||; entry point|25339
||mov|11,-(xs)|7,xr||; save xr|25340
||jsr|6,prtic|||; print buffer contents|25341
||mov|7,xr|3,prbuf||; point to print bfr to clear it|25342
||lct|8,wa|3,prlnw||; get buffer length|25343
||add|7,xr|19,*schar||; point past scblk header|25344
||mov|8,wb|4,nullw||; get blanks|25345
;
;      loop to clear buffer
;
|prtt1|mov|10,(xr)+|8,wb||; clear a word|25349
||bct|8,wa|6,prtt1||; loop|25350
||zer|3,profs|||; reset profs|25351
||mov|7,xr|10,(xs)+||; restore xr|25352
||exi||||; return|25353
||enp||||; end procedure prttr|25354
||ejc|||||25355
;
;      prtvl -- print a value
;
;      prtvl places an appropriate character representation of
;      a data value in the print buffer for dump/trace use.
;
;      (xr)		     value to be printed
;      jsr  prtvl	     call to print value
;      (wa,wb,wc,ra)	     destroyed
;
|prtvl|prc|25,r|1,0||; entry point, recursive|25366
||mov|11,-(xs)|7,xl||; save entry xl|25367
||mov|11,-(xs)|7,xr||; save argument|25368
||chk||||; check for stack overflow|25369
;
;      loop back here after finding a trap block (trblk)
;
|prv01|mov|3,prvsi|13,idval(xr)||; copy idval (if any)|25373
||mov|7,xl|9,(xr)||; load first word of block|25374
||lei|7,xl|||; load entry point id|25375
||bsw|7,xl|2,bl__t|6,prv02|; switch on block type|25376
||iff|2,bl_ar|6,prv05||; arblk|25394
||iff|1,1|6,prv02|||25394
||iff|1,2|6,prv02|||25394
||iff|2,bl_ic|6,prv08||; icblk|25394
||iff|2,bl_nm|6,prv09||; nmblk|25394
||iff|1,5|6,prv02|||25394
||iff|1,6|6,prv02|||25394
||iff|1,7|6,prv02|||25394
||iff|2,bl_rc|6,prv08||; rcblk|25394
||iff|2,bl_sc|6,prv11||; scblk|25394
||iff|2,bl_se|6,prv12||; seblk|25394
||iff|2,bl_tb|6,prv13||; tbblk|25394
||iff|2,bl_vc|6,prv13||; vcblk|25394
||iff|1,13|6,prv02|||25394
||iff|1,14|6,prv02|||25394
||iff|1,15|6,prv02|||25394
||iff|2,bl_pd|6,prv10||; pdblk|25394
||iff|2,bl_tr|6,prv04||; trblk|25394
||esw||||; end of switch on block type|25394
;
;      here for blocks for which we just print datatype name
;
|prv02|jsr|6,dtype|||; get datatype name|25398
||jsr|6,prtst|||; print datatype name|25399
;
;      common exit point
;
|prv03|mov|7,xr|10,(xs)+||; reload argument|25403
||mov|7,xl|10,(xs)+||; restore xl|25404
||exi||||; return to prtvl caller|25405
;
;      here for trblk
;
|prv04|mov|7,xr|13,trval(xr)||; load real value|25409
||brn|6,prv01|||; and loop back|25410
||ejc|||||25411
;
;      prtvl (continued)
;
;      here for array (arblk)
;
;      print array ( prototype ) blank number idval
;
|prv05|mov|7,xl|7,xr||; preserve argument|25419
||mov|7,xr|21,=scarr||; point to datatype name (array)|25420
||jsr|6,prtst|||; print it|25421
||mov|8,wa|18,=ch_pp||; load left paren|25422
||jsr|6,prtch|||; print left paren|25423
||add|7,xl|13,arofs(xl)||; point to prototype|25424
||mov|7,xr|9,(xl)||; load prototype|25425
||jsr|6,prtst|||; print prototype|25426
;
;      vcblk, tbblk, bcblk merge here for ) blank number idval
;
|prv06|mov|8,wa|18,=ch_rp||; load right paren|25430
||jsr|6,prtch|||; print right paren|25431
;
;      pdblk merges here to print blank number idval
;
|prv07|mov|8,wa|18,=ch_bl||; load blank|25435
||jsr|6,prtch|||; print it|25436
||mov|8,wa|18,=ch_nm||; load number sign|25437
||jsr|6,prtch|||; print it|25438
||mti|3,prvsi|||; get idval|25439
||jsr|6,prtin|||; print id number|25440
||brn|6,prv03|||; back to exit|25441
;
;      here for integer (icblk), real (rcblk)
;
;      print character representation of value
;
|prv08|mov|11,-(xs)|7,xr||; stack argument for gtstg|25447
||jsr|6,gtstg|||; convert to string|25448
||ppm||||; error return is impossible|25449
||jsr|6,prtst|||; print the string|25450
||mov|3,dnamp|7,xr||; delete garbage string from storage|25451
||brn|6,prv03|||; back to exit|25452
||ejc|||||25453
;
;      prtvl (continued)
;
;      name (nmblk)
;
;      for pseudo-variable, just print datatype name (name)
;      for all other names, print dot followed by name rep
;
|prv09|mov|7,xl|13,nmbas(xr)||; load name base|25462
||mov|8,wa|9,(xl)||; load first word of block|25463
||beq|8,wa|22,=b_kvt|6,prv02|; just print name if keyword|25464
||beq|8,wa|22,=b_evt|6,prv02|; just print name if expression var|25465
||mov|8,wa|18,=ch_dt||; else get dot|25466
||jsr|6,prtch|||; and print it|25467
||mov|8,wa|13,nmofs(xr)||; load name offset|25468
||jsr|6,prtnm|||; print name|25469
||brn|6,prv03|||; back to exit|25470
;
;      program datatype (pdblk)
;
;      print datatype name ch_bl ch_nm idval
;
|prv10|jsr|6,dtype|||; get datatype name|25476
||jsr|6,prtst|||; print datatype name|25477
||brn|6,prv07|||; merge back to print id|25478
;
;      here for string (scblk)
;
;      print quote string-characters quote
;
|prv11|mov|8,wa|18,=ch_sq||; load single quote|25484
||jsr|6,prtch|||; print quote|25485
||jsr|6,prtst|||; print string value|25486
||jsr|6,prtch|||; print another quote|25487
||brn|6,prv03|||; back to exit|25488
||ejc|||||25489
;
;      prtvl (continued)
;
;      here for simple expression (seblk)
;
;      print asterisk variable-name
;
|prv12|mov|8,wa|18,=ch_as||; load asterisk|25497
||jsr|6,prtch|||; print asterisk|25498
||mov|7,xr|13,sevar(xr)||; load variable pointer|25499
||jsr|6,prtvn|||; print variable name|25500
||brn|6,prv03|||; jump back to exit|25501
;
;      here for table (tbblk) and array (vcblk)
;
;      print datatype ( prototype ) blank number idval
;
|prv13|mov|7,xl|7,xr||; preserve argument|25507
||jsr|6,dtype|||; get datatype name|25508
||jsr|6,prtst|||; print datatype name|25509
||mov|8,wa|18,=ch_pp||; load left paren|25510
||jsr|6,prtch|||; print left paren|25511
||mov|8,wa|13,tblen(xl)||; load length of block (=vclen)|25512
||btw|8,wa|||; convert to word count|25513
||sub|8,wa|18,=tbsi_||; allow for standard fields|25514
||beq|9,(xl)|22,=b_tbt|6,prv14|; jump if table|25515
||add|8,wa|18,=vctbd||; for vcblk, adjust size|25516
;
;      print prototype
;
|prv14|mti|8,wa|||; move as integer|25520
||jsr|6,prtin|||; print integer prototype|25521
||brn|6,prv06|||; merge back for rest|25522
||enp||||; end procedure prtvl|25545
||ejc|||||25546
;
;      prtvn -- print natural variable name
;
;      prtvn prints the name of a natural variable
;
;      (xr)		     pointer to vrblk
;      jsr  prtvn	     call to print variable name
;
|prtvn|prc|25,e|1,0||; entry point|25555
||mov|11,-(xs)|7,xr||; stack vrblk pointer|25556
||add|7,xr|19,*vrsof||; point to possible string name|25557
||bnz|13,sclen(xr)|6,prvn1||; jump if not system variable|25558
||mov|7,xr|13,vrsvo(xr)||; point to svblk with name|25559
;
;      merge here with dummy scblk pointer in xr
;
|prvn1|jsr|6,prtst|||; print string name of variable|25563
||mov|7,xr|10,(xs)+||; restore vrblk pointer|25564
||exi||||; return to prtvn caller|25565
||enp||||; end procedure prtvn|25566
||ejc|||||25569
;
;      rcbld -- build a real block
;
;      (ra)		     real value for rcblk
;      jsr  rcbld	     call to build real block
;      (xr)		     pointer to result rcblk
;      (wa)		     destroyed
;
|rcbld|prc|25,e|1,0||; entry point|25578
||mov|7,xr|3,dnamp||; load pointer to next available loc|25579
||add|7,xr|19,*rcsi_||; point past new rcblk|25580
||blo|7,xr|3,dname|6,rcbl1|; jump if there is room|25581
||mov|8,wa|19,*rcsi_||; else load rcblk length|25582
||jsr|6,alloc|||; use standard allocator to get block|25583
||add|7,xr|8,wa||; point past block to merge|25584
;
;      merge here with xr pointing past the block obtained
;
|rcbl1|mov|3,dnamp|7,xr||; set new pointer|25588
||sub|7,xr|19,*rcsi_||; point back to start of block|25589
||mov|9,(xr)|22,=b_rcl||; store type word|25590
||str|13,rcval(xr)|||; store real value in rcblk|25591
||exi||||; return to rcbld caller|25592
||enp||||; end procedure rcbld|25593
||ejc|||||25595
;
;      readr -- read next source image at compile time
;
;      readr is used to read the next source image. to process
;      continuation cards properly, the compiler must read one
;      line ahead. thus readr does not destroy the current image
;      see also the nexts routine which actually gets the image.
;
;      jsr  readr	     call to read next image
;      (xr)		     ptr to next image (0 if none)
;      (r_cni)		     copy of pointer
;      (wa,wb,wc,xl)	     destroyed
;
|readr|prc|25,e|1,0||; entry point|25609
||mov|7,xr|3,r_cni||; get ptr to next image|25610
||bnz|7,xr|6,read3||; exit if already read|25611
||bnz|3,cnind|6,reada||; if within include file|25613
||bne|3,stage|18,=stgic|6,read3|; exit if not initial compile|25615
|reada|mov|8,wa|3,cswin||; max read length|25616
||zer|7,xl|||; clear any dud value in xl|25617
||jsr|6,alocs|||; allocate buffer|25618
||jsr|6,sysrd|||; read input image|25619
||ppm|6,read4|||; jump if eof or new file name|25620
||icv|3,rdnln|||; increment next line number|25621
||dcv|3,polct|||; test if time to poll interface|25623
||bnz|3,polct|6,read0||; not yet|25624
||zer|8,wa|||; =0 for poll|25625
||mov|8,wb|3,rdnln||; line number|25626
||jsr|6,syspl|||; allow interactive access|25627
||err|1,320|26,user interrupt|||25628
||ppm||||; single step|25629
||ppm||||; expression evaluation|25630
||mov|3,polcs|8,wa||; new countdown start value|25631
||mov|3,polct|8,wa||; new counter value|25632
|read0|ble|13,sclen(xr)|3,cswin|6,read1|; use smaller of string lnth ...|25634
||mov|13,sclen(xr)|3,cswin||; ... and xxx of -inxxx|25635
;
;      perform the trim
;
|read1|mnz|8,wb|||; set trimr to perform trim|25639
||jsr|6,trimr|||; trim trailing blanks|25640
;
;      merge here after read
;
|read2|mov|3,r_cni|7,xr||; store copy of pointer|25644
;
;      merge here if no read attempted
;
|read3|exi||||; return to readr caller|25648
;
;      here on end of file or new source file name.
;      if this is a new source file name, the r_sfn table will
;      be augmented with a new table entry consisting of the
;      current compiler statement number as subscript, and the
;      file name as value.
;
|read4|bze|13,sclen(xr)|6,read5||; jump if true end of file|25657
||zer|8,wb|||; new source file name|25658
||mov|3,rdnln|8,wb||; restart line counter for new file|25659
||jsr|6,trimr|||; remove unused space in block|25660
||jsr|6,newfn|||; record new file name|25661
||brn|6,reada|||; now reissue read for record data|25662
;
;      here on end of file
;
|read5|mov|3,dnamp|7,xr||; pop unused scblk|25666
||bze|3,cnind|6,read6||; jump if not within an include file|25668
||zer|7,xl|||; eof within include file|25669
||jsr|6,sysif|||; switch stream back to previous file|25670
||ppm|||||25671
||mov|8,wa|3,cnind||; restore prev line number, file name|25672
||add|8,wa|18,=vcvlb||; vector offset in words|25673
||wtb|8,wa|||; convert to bytes|25674
||mov|7,xr|3,r_ifa||; file name array|25675
||add|7,xr|8,wa||; ptr to element|25676
||mov|3,r_sfc|9,(xr)||; change source file name|25677
||mov|9,(xr)|21,=nulls||; release scblk|25678
||mov|7,xr|3,r_ifl||; line number array|25679
||add|7,xr|8,wa||; ptr to element|25680
||mov|7,xl|9,(xr)||; icblk containing saved line number|25681
||ldi|13,icval(xl)|||; line number integer|25682
||mfi|3,rdnln|||; change source line number|25683
||mov|9,(xr)|21,=inton||; release icblk|25684
||dcv|3,cnind|||; decrement nesting level|25685
||mov|8,wb|3,cmpsn||; current statement number|25686
||icv|8,wb|||; anticipate end of previous stmt|25687
||mti|8,wb|||; convert to integer|25688
||jsr|6,icbld|||; build icblk for stmt number|25689
||mov|7,xl|3,r_sfn||; file name table|25690
||mnz|8,wb|||; lookup statement number by name|25691
||jsr|6,tfind|||; allocate new teblk|25692
||ppm||||; always possible to allocate block|25693
||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|25694
||beq|3,stage|18,=stgic|6,reada|; if initial compile, reissue read|25695
||bnz|3,cnind|6,reada||; still reading from include file|25696
;
;      outer nesting of execute-time compile of -include
;      resume with any string remaining prior to -include.
;
||mov|7,xl|3,r_ici||; restore code argument string|25701
||zer|3,r_ici|||; release original string|25702
||mov|8,wa|3,cnsil||; get length of string|25703
||mov|8,wb|3,cnspt||; offset of characters left|25704
||sub|8,wa|8,wb||; number of characters left|25705
||mov|3,scnil|8,wa||; set new scan length|25706
||zer|3,scnpt|||; scan from start of substring|25707
||jsr|6,sbstr|||; create substring of remainder|25708
||mov|3,r_cim|7,xr||; set scan image|25709
||brn|6,read2|||; return|25710
|read6|zer|7,xr|||; zero ptr as result|25726
||brn|6,read2|||; merge|25727
||enp||||; end procedure readr|25728
||ejc|||||25729
;
;      sbstr -- build a substring
;
;      (xl)		     ptr to scblk/bfblk with chars
;      (wa)		     number of chars in substring
;      (wb)		     offset to first char in scblk
;      jsr  sbstr	     call to build substring
;      (xr)		     ptr to new scblk with substring
;      (xl)		     zero
;      (wa,wb,wc,xl,ia)	     destroyed
;
;      note that sbstr is called with a dummy string pointer
;      (pointing into a vrblk or svblk) to copy the name of a
;      variable as a standard string value.
;
|sbstr|prc|25,e|1,0||; entry point|25824
||bze|8,wa|6,sbst2||; jump if null substring|25825
||jsr|6,alocs|||; else allocate scblk|25826
||mov|8,wa|8,wc||; move number of characters|25827
||mov|8,wc|7,xr||; save ptr to new scblk|25828
||plc|7,xl|8,wb||; prepare to load chars from old blk|25829
||psc|7,xr|||; prepare to store chars in new blk|25830
||mvc||||; move characters to new string|25831
||mov|7,xr|8,wc||; then restore scblk pointer|25832
;
;      return point
;
|sbst1|zer|7,xl|||; clear garbage pointer in xl|25836
||exi||||; return to sbstr caller|25837
;
;      here for null substring
;
|sbst2|mov|7,xr|21,=nulls||; set null string as result|25841
||brn|6,sbst1|||; return|25842
||enp||||; end procedure sbstr|25843
||ejc|||||25844
;
;      stgcc -- compute counters for stmt startup testing
;
;      jsr  stgcc	     call to recompute counters
;      (wa,wb)		     destroyed
;
;      on exit, stmcs and stmct contain the counter value to
;      tested in stmgo.
;
;
|stgcc|prc|25,e|1,0||;|25855
||mov|8,wa|3,polcs||; assume no profiling or stcount tracing|25857
||mov|8,wb|18,=num01||; poll each time polcs expires|25858
||ldi|3,kvstl|||; get stmt limit|25862
||bnz|3,kvpfl|6,stgc1||; jump if profiling enabled|25863
||ilt|6,stgc3|||; no stcount tracing if negative|25864
||bze|3,r_stc|6,stgc2||; jump if not stcount tracing|25865
;
;      here if profiling or if stcount tracing enabled
;
|stgc1|mov|8,wb|8,wa||; count polcs times within stmg|25870
||mov|8,wa|18,=num01||; break out of stmgo on each stmt|25871
||brn|6,stgc3|||;|25875
;
;      check that stmcs does not exceed kvstl
;
|stgc2|mti|8,wa|||; breakout count start value|25879
||sbi|3,kvstl|||; proposed stmcs minus stmt limit|25880
||ile|6,stgc3|||; jump if stmt count does not limit|25881
||ldi|3,kvstl|||; stlimit limits breakcount count|25882
||mfi|8,wa|||; use it instead|25883
;
;      re-initialize counter
;
|stgc3|mov|3,stmcs|8,wa||; update breakout count start value|25887
||mov|3,stmct|8,wa||; reset breakout counter|25888
||mov|3,polct|8,wb||;|25890
||exi|||||25892
||ejc|||||25893
;
;      tfind -- locate table element
;
;      (xr)		     subscript value for element
;      (xl)		     pointer to table
;      (wb)		     zero by value, non-zero by name
;      jsr  tfind	     call to locate element
;      ppm  loc		     transfer location if access fails
;      (xr)		     element value (if by value)
;      (xr)		     destroyed (if by name)
;      (xl,wa)		     teblk name (if by name)
;      (xl,wa)		     destroyed (if by value)
;      (wc,ra)		     destroyed
;
;      note that if a call by value specifies a non-existent
;      subscript, the default value is returned without building
;      a new teblk.
;
|tfind|prc|25,e|1,1||; entry point|25912
||mov|11,-(xs)|8,wb||; save name/value indicator|25913
||mov|11,-(xs)|7,xr||; save subscript value|25914
||mov|11,-(xs)|7,xl||; save table pointer|25915
||mov|8,wa|13,tblen(xl)||; load length of tbblk|25916
||btw|8,wa|||; convert to word count|25917
||sub|8,wa|18,=tbbuk||; get number of buckets|25918
||mti|8,wa|||; convert to integer value|25919
||sti|3,tfnsi|||; save for later|25920
||mov|7,xl|9,(xr)||; load first word of subscript|25921
||lei|7,xl|||; load block entry id (bl_xx)|25922
||bsw|7,xl|2,bl__d|6,tfn00|; switch on block type|25923
||iff|1,0|6,tfn00|||25934
||iff|1,1|6,tfn00|||25934
||iff|1,2|6,tfn00|||25934
||iff|2,bl_ic|6,tfn02||; jump if integer|25934
||iff|2,bl_nm|6,tfn04||; jump if name|25934
||iff|2,bl_p0|6,tfn03||; jump if pattern|25934
||iff|2,bl_p1|6,tfn03||; jump if pattern|25934
||iff|2,bl_p2|6,tfn03||; jump if pattern|25934
||iff|2,bl_rc|6,tfn02||; real|25934
||iff|2,bl_sc|6,tfn05||; jump if string|25934
||iff|1,10|6,tfn00|||25934
||iff|1,11|6,tfn00|||25934
||iff|1,12|6,tfn00|||25934
||iff|1,13|6,tfn00|||25934
||iff|1,14|6,tfn00|||25934
||iff|1,15|6,tfn00|||25934
||iff|1,16|6,tfn00|||25934
||esw||||; end switch on block type|25934
;
;      here for blocks for which we use the second word of the
;      block as the hash source (see block formats for details).
;
|tfn00|mov|8,wa|12,1(xr)||; load second word|25939
;
;      merge here with one word hash source in wa
;
|tfn01|mti|8,wa|||; convert to integer|25943
||brn|6,tfn06|||; jump to merge|25944
||ejc|||||25945
;
;      tfind (continued)
;
;      here for integer or real
;      possibility of overflow exist on twos complement
;      machine if hash source is most negative integer or is
;      a real having the same bit pattern.
;
;
|tfn02|ldi|12,1(xr)|||; load value as hash source|25955
||ige|6,tfn06|||; ok if positive or zero|25956
||ngi||||; make positive|25957
||iov|6,tfn06|||; clear possible overflow|25958
||brn|6,tfn06|||; merge|25959
;
;      for pattern, use first word (pcode) as source
;
|tfn03|mov|8,wa|9,(xr)||; load first word as hash source|25963
||brn|6,tfn01|||; merge back|25964
;
;      for name, use offset as hash source
;
|tfn04|mov|8,wa|13,nmofs(xr)||; load offset as hash source|25968
||brn|6,tfn01|||; merge back|25969
;
;      here for string
;
|tfn05|jsr|6,hashs|||; call routine to compute hash|25973
;
;      merge here with hash source in (ia)
;
|tfn06|rmi|3,tfnsi|||; compute hash index by remaindering|25977
||mfi|8,wc|||; get as one word integer|25978
||wtb|8,wc|||; convert to byte offset|25979
||mov|7,xl|9,(xs)||; get table ptr again|25980
||add|7,xl|8,wc||; point to proper bucket|25981
||mov|7,xr|13,tbbuk(xl)||; load first teblk pointer|25982
||beq|7,xr|9,(xs)|6,tfn10|; jump if no teblks on chain|25983
;
;      loop through teblks on hash chain
;
|tfn07|mov|8,wb|7,xr||; save teblk pointer|25987
||mov|7,xr|13,tesub(xr)||; load subscript value|25988
||mov|7,xl|12,1(xs)||; load input argument subscript val|25989
||jsr|6,ident|||; compare them|25990
||ppm|6,tfn08|||; jump if equal (ident)|25991
;
;      here if no match with that teblk
;
||mov|7,xl|8,wb||; restore teblk pointer|25995
||mov|7,xr|13,tenxt(xl)||; point to next teblk on chain|25996
||bne|7,xr|9,(xs)|6,tfn07|; jump if there is one|25997
;
;      here if no match with any teblk on chain
;
||mov|8,wc|19,*tenxt||; set offset to link field (xl base)|26001
||brn|6,tfn11|||; jump to merge|26002
||ejc|||||26003
;
;      tfind (continued)
;
;      here we have found a matching element
;
|tfn08|mov|7,xl|8,wb||; restore teblk pointer|26009
||mov|8,wa|19,*teval||; set teblk name offset|26010
||mov|8,wb|12,2(xs)||; restore name/value indicator|26011
||bnz|8,wb|6,tfn09||; jump if called by name|26012
||jsr|6,acess|||; else get value|26013
||ppm|6,tfn12|||; jump if reference fails|26014
||zer|8,wb|||; restore name/value indicator|26015
;
;      common exit for entry found
;
|tfn09|add|7,xs|19,*num03||; pop stack entries|26019
||exi||||; return to tfind caller|26020
;
;      here if no teblks on the hash chain
;
|tfn10|add|8,wc|19,*tbbuk||; get offset to bucket ptr|26024
||mov|7,xl|9,(xs)||; set tbblk ptr as base|26025
;
;      merge here with (xl,wc) base,offset of final link
;
|tfn11|mov|7,xr|9,(xs)||; tbblk pointer|26029
||mov|7,xr|13,tbinv(xr)||; load default value in case|26030
||mov|8,wb|12,2(xs)||; load name/value indicator|26031
||bze|8,wb|6,tfn09||; exit with default if value call|26032
||mov|8,wb|7,xr||; copy default value|26033
;
;      here we must build a new teblk
;
||mov|8,wa|19,*tesi_||; set size of teblk|26037
||jsr|6,alloc|||; allocate teblk|26038
||add|7,xl|8,wc||; point to hash link|26039
||mov|9,(xl)|7,xr||; link new teblk at end of chain|26040
||mov|9,(xr)|22,=b_tet||; store type word|26041
||mov|13,teval(xr)|8,wb||; set default as initial value|26042
||mov|13,tenxt(xr)|10,(xs)+||; set tbblk ptr to mark end of chain|26043
||mov|13,tesub(xr)|10,(xs)+||; store subscript value|26044
||mov|8,wb|10,(xs)+||; restore name/value indicator|26045
||mov|7,xl|7,xr||; copy teblk pointer (name base)|26046
||mov|8,wa|19,*teval||; set offset|26047
||exi||||; return to caller with new teblk|26048
;
;      acess fail return
;
|tfn12|exi|1,1|||; alternative return|26052
||enp||||; end procedure tfind|26053
||ejc|||||26054
;
;      tmake -- make new table
;
;      (xl)		     initial lookup value
;      (wc)		     number of buckets desired
;      jsr  tmake	     call to make new table
;      (xr)		     new table
;      (wa,wb)		     destroyed
;
|tmake|prc|25,e|1,0||;|26064
||mov|8,wa|8,wc||; copy number of headers|26065
||add|8,wa|18,=tbsi_||; adjust for standard fields|26066
||wtb|8,wa|||; convert length to bytes|26067
||jsr|6,alloc|||; allocate space for tbblk|26068
||mov|8,wb|7,xr||; copy pointer to tbblk|26069
||mov|10,(xr)+|22,=b_tbt||; store type word|26070
||zer|10,(xr)+|||; zero id for the moment|26071
||mov|10,(xr)+|8,wa||; store length (tblen)|26072
||mov|10,(xr)+|7,xl||; store initial lookup value|26073
||lct|8,wc|8,wc||; set loop counter (num headers)|26074
;
;      loop to initialize all bucket pointers
;
|tma01|mov|10,(xr)+|8,wb||; store tbblk ptr in bucket header|26078
||bct|8,wc|6,tma01||; loop till all stored|26079
||mov|7,xr|8,wb||; recall pointer to tbblk|26080
||exi|||||26081
||enp|||||26082
||ejc|||||26083
;
;      vmake -- create a vector
;
;      (wa)		     number of elements in vector
;      (xl)		     default value for vector elements
;      jsr  vmake	     call to create vector
;      ppm  loc		     if vector too large
;
;      (xr)		     pointer to vcblk
;      (wa,wb,wc,xl)	     destroyed
;
|vmake|prc|25,e|1,1||; entry point|26095
||lct|8,wb|8,wa||; copy elements for loop later on|26096
||add|8,wa|18,=vcsi_||; add space for standard fields|26097
||wtb|8,wa|||; convert length to bytes|26098
||bgt|8,wa|3,mxlen|6,vmak2|; fail if too large|26099
||jsr|6,alloc|||; allocate space for vcblk|26100
||mov|9,(xr)|22,=b_vct||; store type word|26101
||zer|13,idval(xr)|||; initialize idval|26102
||mov|13,vclen(xr)|8,wa||; set length|26103
||mov|8,wc|7,xl||; copy default value|26104
||mov|7,xl|7,xr||; copy vcblk pointer|26105
||add|7,xl|19,*vcvls||; point to first element value|26106
;
;      loop to set vector elements to default value
;
|vmak1|mov|10,(xl)+|8,wc||; store one value|26110
||bct|8,wb|6,vmak1||; loop till all stored|26111
||exi||||; success return|26112
;
;      here if desired vector size too large
;
|vmak2|exi|1,1|||; fail return|26116
||enp|||||26117
||ejc|||||26118
;
;      scane -- scan an element
;
;      scane is called at compile time (by expan ,cmpil,cncrd)
;      to scan one element from the input image.
;
;      (scncc)		     non-zero if called from cncrd
;      jsr  scane	     call to scan element
;      (xr)		     result pointer (see below)
;      (xl)		     syntax type code (t_xxx)
;
;      the following global locations are used.
;
;      r_cim		     pointer to string block (scblk)
;			     for current input image.
;
;      r_cni		     pointer to next input image string
;			     pointer (zero if none).
;
;      r_scp		     save pointer (exit xr) from last
;			     call in case rescan is set.
;
;      scnbl		     this location is set non-zero on
;			     exit if scane scanned past blanks
;			     before locating the current element
;			     the end of a line counts as blanks.
;
;      scncc		     cncrd sets this non-zero to scan
;			     control card names and clears it
;			     on return
;
;      scnil		     length of current input image
;
;      scngo		     if set non-zero on entry, f and s
;			     are returned as separate syntax
;			     types (not letters) (goto pro-
;			     cessing). scngo is reset on exit.
;
;      scnpt		     offset to current loc in r_cim
;
;      scnrs		     if set non-zero on entry, scane
;			     returns the same result as on the
;			     last call (rescan). scnrs is reset
;			     on exit from any call to scane.
;
;      scntp		     save syntax type from last
;			     call (in case rescan is set).
||ejc|||||26166
;
;      scane (continued)
;
;
;
;      element scanned	     xl	       xr
;      ---------------	     --	       --
;
;      control card name     0	       pointer to scblk for name
;
;      unary operator	     t_uop     ptr to operator dvblk
;
;      left paren	     t_lpr     t_lpr
;
;      left bracket	     t_lbr     t_lbr
;
;      comma		     t_cma     t_cma
;
;      function call	     t_fnc     ptr to function vrblk
;
;      variable		     t_var     ptr to vrblk
;
;      string constant	     t_con     ptr to scblk
;
;      integer constant	     t_con     ptr to icblk
;
;      real constant	     t_con     ptr to rcblk
;
;      binary operator	     t_bop     ptr to operator dvblk
;
;      right paren	     t_rpr     t_rpr
;
;      right bracket	     t_rbr     t_rbr
;
;      colon		     t_col     t_col
;
;      semi-colon	     t_smc     t_smc
;
;      f (scngo ne 0)	     t_fgo     t_fgo
;
;      s (scngo ne 0)	     t_sgo     t_sgo
||ejc|||||26211
;
;      scane (continued)
;
;      entry point
;
|scane|prc|25,e|1,0||; entry point|26217
||zer|3,scnbl|||; reset blanks flag|26218
||mov|3,scnsa|8,wa||; save wa|26219
||mov|3,scnsb|8,wb||; save wb|26220
||mov|3,scnsc|8,wc||; save wc|26221
||bze|3,scnrs|6,scn03||; jump if no rescan|26222
;
;      here for rescan request
;
||mov|7,xl|3,scntp||; set previous returned scan type|26226
||mov|7,xr|3,r_scp||; set previous returned pointer|26227
||zer|3,scnrs|||; reset rescan switch|26228
||brn|6,scn13|||; jump to exit|26229
;
;      come here to read new image to test for continuation
;
|scn01|jsr|6,readr|||; read next image|26233
||mov|8,wb|19,*dvubs||; set wb for not reading name|26234
||bze|7,xr|6,scn30||; treat as semi-colon if none|26235
||plc|7,xr|||; else point to first character|26236
||lch|8,wc|9,(xr)||; load first character|26237
||beq|8,wc|18,=ch_dt|6,scn02|; jump if dot for continuation|26238
||bne|8,wc|18,=ch_pl|6,scn30|; else treat as semicolon unless plus|26239
;
;      here for continuation line
;
|scn02|jsr|6,nexts|||; acquire next source image|26243
||mov|3,scnpt|18,=num01||; set scan pointer past continuation|26244
||mnz|3,scnbl|||; set blanks flag|26245
||ejc|||||26246
;
;      scane (continued)
;
;      merge here to scan next element on current line
;
|scn03|mov|8,wa|3,scnpt||; load current offset|26252
||beq|8,wa|3,scnil|6,scn01|; check continuation if end|26253
||mov|7,xl|3,r_cim||; point to current line|26254
||plc|7,xl|8,wa||; point to current character|26255
||mov|3,scnse|8,wa||; set start of element location|26256
||mov|8,wc|21,=opdvs||; point to operator dv list|26257
||mov|8,wb|19,*dvubs||; set constant for operator circuit|26258
||brn|6,scn06|||; start scanning|26259
;
;      loop here to ignore leading blanks and tabs
;
|scn05|bze|8,wb|6,scn10||; jump if trailing|26263
||icv|3,scnse|||; increment start of element|26264
||beq|8,wa|3,scnil|6,scn01|; jump if end of image|26265
||mnz|3,scnbl|||; note blanks seen|26266
;
;      the following jump is used repeatedly for scanning out
;      the characters of a numeric constant or variable name.
;      the registers are used as follows.
;
;      (xr)		     scratch
;      (xl)		     ptr to next character
;      (wa)		     current scan offset
;      (wb)		     *dvubs (0 if scanning name,const)
;      (wc)		     =opdvs (0 if scanning constant)
;
|scn06|lch|7,xr|10,(xl)+||; get next character|26278
||icv|8,wa|||; bump scan offset|26279
||mov|3,scnpt|8,wa||; store offset past char scanned|26280
||bsw|7,xr|2,cfp_u|6,scn07|; switch on scanned character|26282
;
;      switch table for switch on character
;
||ejc|||||26309
;
;      scane (continued)
;
||ejc|||||26365
;
;      scane (continued)
;
||iff|1,0|6,scn07|||26398
||iff|1,1|6,scn07|||26398
||iff|1,2|6,scn07|||26398
||iff|1,3|6,scn07|||26398
||iff|1,4|6,scn07|||26398
||iff|1,5|6,scn07|||26398
||iff|1,6|6,scn07|||26398
||iff|1,7|6,scn07|||26398
||iff|1,8|6,scn07|||26398
||iff|2,ch_ht|6,scn05||; horizontal tab|26398
||iff|1,10|6,scn07|||26398
||iff|1,11|6,scn07|||26398
||iff|1,12|6,scn07|||26398
||iff|1,13|6,scn07|||26398
||iff|1,14|6,scn07|||26398
||iff|1,15|6,scn07|||26398
||iff|1,16|6,scn07|||26398
||iff|1,17|6,scn07|||26398
||iff|1,18|6,scn07|||26398
||iff|1,19|6,scn07|||26398
||iff|1,20|6,scn07|||26398
||iff|1,21|6,scn07|||26398
||iff|1,22|6,scn07|||26398
||iff|1,23|6,scn07|||26398
||iff|1,24|6,scn07|||26398
||iff|1,25|6,scn07|||26398
||iff|1,26|6,scn07|||26398
||iff|1,27|6,scn07|||26398
||iff|1,28|6,scn07|||26398
||iff|1,29|6,scn07|||26398
||iff|1,30|6,scn07|||26398
||iff|1,31|6,scn07|||26398
||iff|2,ch_bl|6,scn05||; blank|26398
||iff|2,ch_ex|6,scn37||; exclamation mark|26398
||iff|2,ch_dq|6,scn17||; double quote|26398
||iff|2,ch_nm|6,scn41||; number sign|26398
||iff|2,ch_dl|6,scn36||; dollar|26398
||iff|2,ch_pc|6,scn38||; percent|26398
||iff|2,ch_am|6,scn44||; ampersand|26398
||iff|2,ch_sq|6,scn16||; single quote|26398
||iff|2,ch_pp|6,scn25||; left paren|26398
||iff|2,ch_rp|6,scn26||; right paren|26398
||iff|2,ch_as|6,scn49||; asterisk|26398
||iff|2,ch_pl|6,scn33||; plus|26398
||iff|2,ch_cm|6,scn31||; comma|26398
||iff|2,ch_mn|6,scn34||; minus|26398
||iff|2,ch_dt|6,scn32||; dot|26398
||iff|2,ch_sl|6,scn40||; slash|26398
||iff|2,ch_d0|6,scn08||; digit 0|26398
||iff|2,ch_d1|6,scn08||; digit 1|26398
||iff|2,ch_d2|6,scn08||; digit 2|26398
||iff|2,ch_d3|6,scn08||; digit 3|26398
||iff|2,ch_d4|6,scn08||; digit 4|26398
||iff|2,ch_d5|6,scn08||; digit 5|26398
||iff|2,ch_d6|6,scn08||; digit 6|26398
||iff|2,ch_d7|6,scn08||; digit 7|26398
||iff|2,ch_d8|6,scn08||; digit 8|26398
||iff|2,ch_d9|6,scn08||; digit 9|26398
||iff|2,ch_cl|6,scn29||; colon|26398
||iff|2,ch_sm|6,scn30||; semi-colon|26398
||iff|2,ch_bb|6,scn28||; left bracket|26398
||iff|2,ch_eq|6,scn46||; equal|26398
||iff|2,ch_rb|6,scn27||; right bracket|26398
||iff|2,ch_qu|6,scn45||; question mark|26398
||iff|2,ch_at|6,scn42||; at|26398
||iff|2,ch_ua|6,scn09||; shifted a|26398
||iff|2,ch_ub|6,scn09||; shifted b|26398
||iff|2,ch_uc|6,scn09||; shifted c|26398
||iff|2,ch_ud|6,scn09||; shifted d|26398
||iff|2,ch_ue|6,scn09||; shifted e|26398
||iff|2,ch_uf|6,scn20||; shifted f|26398
||iff|2,ch_ug|6,scn09||; shifted g|26398
||iff|2,ch_uh|6,scn09||; shifted h|26398
||iff|2,ch_ui|6,scn09||; shifted i|26398
||iff|2,ch_uj|6,scn09||; shifted j|26398
||iff|2,ch_uk|6,scn09||; shifted k|26398
||iff|2,ch_ul|6,scn09||; shifted l|26398
||iff|2,ch_um|6,scn09||; shifted m|26398
||iff|2,ch_un|6,scn09||; shifted n|26398
||iff|2,ch_uo|6,scn09||; shifted o|26398
||iff|2,ch_up|6,scn09||; shifted p|26398
||iff|2,ch_uq|6,scn09||; shifted q|26398
||iff|2,ch_ur|6,scn09||; shifted r|26398
||iff|2,ch_us|6,scn21||; shifted s|26398
||iff|2,ch_ut|6,scn09||; shifted t|26398
||iff|2,ch_uu|6,scn09||; shifted u|26398
||iff|2,ch_uv|6,scn09||; shifted v|26398
||iff|2,ch_uw|6,scn09||; shifted w|26398
||iff|2,ch_ux|6,scn09||; shifted x|26398
||iff|2,ch_uy|6,scn09||; shifted y|26398
||iff|2,ch_uz|6,scn09||; shifted z|26398
||iff|2,ch_ob|6,scn28||; left bracket|26398
||iff|1,92|6,scn07|||26398
||iff|2,ch_cb|6,scn27||; right bracket|26398
||iff|2,ch_ey|6,scn37||; up arrow|26398
||iff|2,ch_u_|6,scn24||; underline|26398
||iff|1,96|6,scn07|||26398
||iff|2,ch_la|6,scn09||; letter a|26398
||iff|2,ch_lb|6,scn09||; letter b|26398
||iff|2,ch_lc|6,scn09||; letter c|26398
||iff|2,ch_ld|6,scn09||; letter d|26398
||iff|2,ch_le|6,scn09||; letter e|26398
||iff|2,ch_lf|6,scn20||; letter f|26398
||iff|2,ch_lg|6,scn09||; letter g|26398
||iff|2,ch_lh|6,scn09||; letter h|26398
||iff|2,ch_li|6,scn09||; letter i|26398
||iff|2,ch_lj|6,scn09||; letter j|26398
||iff|2,ch_lk|6,scn09||; letter k|26398
||iff|2,ch_ll|6,scn09||; letter l|26398
||iff|2,ch_lm|6,scn09||; letter m|26398
||iff|2,ch_ln|6,scn09||; letter n|26398
||iff|2,ch_lo|6,scn09||; letter o|26398
||iff|2,ch_lp|6,scn09||; letter p|26398
||iff|2,ch_lq|6,scn09||; letter q|26398
||iff|2,ch_lr|6,scn09||; letter r|26398
||iff|2,ch_ls|6,scn21||; letter s|26398
||iff|2,ch_lt|6,scn09||; letter t|26398
||iff|2,ch_lu|6,scn09||; letter u|26398
||iff|2,ch_lv|6,scn09||; letter v|26398
||iff|2,ch_lw|6,scn09||; letter w|26398
||iff|2,ch_lx|6,scn09||; letter x|26398
||iff|2,ch_ly|6,scn09||; letter y|26398
||iff|2,ch_l_|6,scn09||; letter z|26398
||iff|1,123|6,scn07|||26398
||iff|2,ch_br|6,scn43||; vertical bar|26398
||iff|1,125|6,scn07|||26398
||iff|2,ch_nt|6,scn35||; not|26398
||iff|1,127|6,scn07|||26398
||esw||||; end switch on character|26398
;
;      here for illegal character (underline merges)
;
|scn07|bze|8,wb|6,scn10||; jump if scanning name or constant|26402
||erb|1,230|26,syntax error: illegal character|||26403
||ejc|||||26404
;
;      scane (continued)
;
;      here for digits 0-9
;
|scn08|bze|8,wb|6,scn09||; keep scanning if name/constant|26410
||zer|8,wc|||; else set flag for scanning constant|26411
;
;      here for letter. loop here when scanning name/constant
;
|scn09|beq|8,wa|3,scnil|6,scn11|; jump if end of image|26415
||zer|8,wb|||; set flag for scanning name/const|26416
||brn|6,scn06|||; merge back to continue scan|26417
;
;      come here for delimiter ending name or constant
;
|scn10|dcv|8,wa|||; reset offset to point to delimiter|26421
;
;      come here after finishing scan of name or constant
;
|scn11|mov|3,scnpt|8,wa||; store updated scan offset|26425
||mov|8,wb|3,scnse||; point to start of element|26426
||sub|8,wa|8,wb||; get number of characters|26427
||mov|7,xl|3,r_cim||; point to line image|26428
||bnz|8,wc|6,scn15||; jump if name|26429
;
;      here after scanning out numeric constant
;
||jsr|6,sbstr|||; get string for constant|26433
||mov|3,dnamp|7,xr||; delete from storage (not needed)|26434
||jsr|6,gtnum|||; convert to numeric|26435
||ppm|6,scn14|||; jump if conversion failure|26436
;
;      merge here to exit with constant
;
|scn12|mov|7,xl|18,=t_con||; set result type of constant|26440
||ejc|||||26441
;
;      scane (continued)
;
;      common exit point (xr,xl) set
;
|scn13|mov|8,wa|3,scnsa||; restore wa|26447
||mov|8,wb|3,scnsb||; restore wb|26448
||mov|8,wc|3,scnsc||; restore wc|26449
||mov|3,r_scp|7,xr||; save xr in case rescan|26450
||mov|3,scntp|7,xl||; save xl in case rescan|26451
||zer|3,scngo|||; reset possible goto flag|26452
||exi||||; return to scane caller|26453
;
;      here if conversion error on numeric item
;
|scn14|erb|1,231|26,syntax error: invalid numeric item|||26457
;
;      here after scanning out variable name
;
|scn15|jsr|6,sbstr|||; build string name of variable|26461
||bnz|3,scncc|6,scn13||; return if cncrd call|26462
||jsr|6,gtnvr|||; locate/build vrblk|26463
||ppm||||; dummy (unused) error return|26464
||mov|7,xl|18,=t_var||; set type as variable|26465
||brn|6,scn13|||; back to exit|26466
;
;      here for single quote (start of string constant)
;
|scn16|bze|8,wb|6,scn10||; terminator if scanning name or cnst|26470
||mov|8,wb|18,=ch_sq||; set terminator as single quote|26471
||brn|6,scn18|||; merge|26472
;
;      here for double quote (start of string constant)
;
|scn17|bze|8,wb|6,scn10||; terminator if scanning name or cnst|26476
||mov|8,wb|18,=ch_dq||; set double quote terminator, merge|26477
;
;      loop to scan out string constant
;
|scn18|beq|8,wa|3,scnil|6,scn19|; error if end of image|26481
||lch|8,wc|10,(xl)+||; else load next character|26482
||icv|8,wa|||; bump offset|26483
||bne|8,wc|8,wb|6,scn18|; loop back if not terminator|26484
||ejc|||||26485
;
;      scane (continued)
;
;      here after scanning out string constant
;
||mov|8,wb|3,scnpt||; point to first character|26491
||mov|3,scnpt|8,wa||; save offset past final quote|26492
||dcv|8,wa|||; point back past last character|26493
||sub|8,wa|8,wb||; get number of characters|26494
||mov|7,xl|3,r_cim||; point to input image|26495
||jsr|6,sbstr|||; build substring value|26496
||brn|6,scn12|||; back to exit with constant result|26497
;
;      here if no matching quote found
;
|scn19|mov|3,scnpt|8,wa||; set updated scan pointer|26501
||erb|1,232|26,syntax error: unmatched string quote|||26502
;
;      here for f (possible failure goto)
;
|scn20|mov|7,xr|18,=t_fgo||; set return code for fail goto|26506
||brn|6,scn22|||; jump to merge|26507
;
;      here for s (possible success goto)
;
|scn21|mov|7,xr|18,=t_sgo||; set success goto as return code|26511
;
;      special goto cases merge here
;
|scn22|bze|3,scngo|6,scn09||; treat as normal letter if not goto|26515
;
;      merge here for special character exit
;
|scn23|bze|8,wb|6,scn10||; jump if end of name/constant|26519
||mov|7,xl|7,xr||; else copy code|26520
||brn|6,scn13|||; and jump to exit|26521
;
;      here for underline
;
|scn24|bze|8,wb|6,scn09||; part of name if scanning name|26525
||brn|6,scn07|||; else illegal|26526
||ejc|||||26527
;
;      scane (continued)
;
;      here for left paren
;
|scn25|mov|7,xr|18,=t_lpr||; set left paren return code|26533
||bnz|8,wb|6,scn23||; return left paren unless name|26534
||bze|8,wc|6,scn10||; delimiter if scanning constant|26535
;
;      here for left paren after name (function call)
;
||mov|8,wb|3,scnse||; point to start of name|26539
||mov|3,scnpt|8,wa||; set pointer past left paren|26540
||dcv|8,wa|||; point back past last char of name|26541
||sub|8,wa|8,wb||; get name length|26542
||mov|7,xl|3,r_cim||; point to input image|26543
||jsr|6,sbstr|||; get string name for function|26544
||jsr|6,gtnvr|||; locate/build vrblk|26545
||ppm||||; dummy (unused) error return|26546
||mov|7,xl|18,=t_fnc||; set code for function call|26547
||brn|6,scn13|||; back to exit|26548
;
;      processing for special characters
;
|scn26|mov|7,xr|18,=t_rpr||; right paren, set code|26552
||brn|6,scn23|||; take special character exit|26553
;
|scn27|mov|7,xr|18,=t_rbr||; right bracket, set code|26555
||brn|6,scn23|||; take special character exit|26556
;
|scn28|mov|7,xr|18,=t_lbr||; left bracket, set code|26558
||brn|6,scn23|||; take special character exit|26559
;
|scn29|mov|7,xr|18,=t_col||; colon, set code|26561
||brn|6,scn23|||; take special character exit|26562
;
|scn30|mov|7,xr|18,=t_smc||; semi-colon, set code|26564
||brn|6,scn23|||; take special character exit|26565
;
|scn31|mov|7,xr|18,=t_cma||; comma, set code|26567
||brn|6,scn23|||; take special character exit|26568
||ejc|||||26569
;
;      scane (continued)
;
;      here for operators. on entry, wc points to the table of
;      operator dope vectors and wb is the increment to step
;      to the next pair (binary/unary) of dope vectors in the
;      list. on reaching scn46, the pointer has been adjusted to
;      point to the appropriate pair of dope vectors.
;      the first three entries are special since they can occur
;      as part of a variable name (.) or constant (.+-).
;
|scn32|bze|8,wb|6,scn09||; dot can be part of name or constant|26581
||add|8,wc|8,wb||; else bump pointer|26582
;
|scn33|bze|8,wc|6,scn09||; plus can be part of constant|26584
||bze|8,wb|6,scn48||; plus cannot be part of name|26585
||add|8,wc|8,wb||; else bump pointer|26586
;
|scn34|bze|8,wc|6,scn09||; minus can be part of constant|26588
||bze|8,wb|6,scn48||; minus cannot be part of name|26589
||add|8,wc|8,wb||; else bump pointer|26590
;
|scn35|add|8,wc|8,wb||; not|26592
|scn36|add|8,wc|8,wb||; dollar|26593
|scn37|add|8,wc|8,wb||; exclamation|26594
|scn38|add|8,wc|8,wb||; percent|26595
|scn39|add|8,wc|8,wb||; asterisk|26596
|scn40|add|8,wc|8,wb||; slash|26597
|scn41|add|8,wc|8,wb||; number sign|26598
|scn42|add|8,wc|8,wb||; at sign|26599
|scn43|add|8,wc|8,wb||; vertical bar|26600
|scn44|add|8,wc|8,wb||; ampersand|26601
|scn45|add|8,wc|8,wb||; question mark|26602
;
;      all operators come here (equal merges directly)
;      (wc) points to the binary/unary pair of operator dvblks.
;
|scn46|bze|8,wb|6,scn10||; operator terminates name/constant|26607
||mov|7,xr|8,wc||; else copy dv pointer|26608
||lch|8,wc|9,(xl)||; load next character|26609
||mov|7,xl|18,=t_bop||; set binary op in case|26610
||beq|8,wa|3,scnil|6,scn47|; should be binary if image end|26611
||beq|8,wc|18,=ch_bl|6,scn47|; should be binary if followed by blk|26612
||beq|8,wc|18,=ch_ht|6,scn47|; jump if horizontal tab|26614
||beq|8,wc|18,=ch_sm|6,scn47|; semicolon can immediately follow =|26619
||beq|8,wc|18,=ch_cl|6,scn47|; colon can immediately follow =|26620
||beq|8,wc|18,=ch_rp|6,scn47|; right paren can immediately follow =|26621
||beq|8,wc|18,=ch_rb|6,scn47|; right bracket can immediately follow =|26622
||beq|8,wc|18,=ch_cb|6,scn47|; right bracket can immediately follow =|26623
;
;      here for unary operator
;
||add|7,xr|19,*dvbs_||; point to dv for unary op|26627
||mov|7,xl|18,=t_uop||; set type for unary operator|26628
||ble|3,scntp|18,=t_uok|6,scn13|; ok unary if ok preceding element|26629
||ejc|||||26630
;
;      scane (continued)
;
;      merge here to require preceding blanks
;
|scn47|bnz|3,scnbl|6,scn13||; all ok if preceding blanks, exit|26636
;
;      fail operator in this position
;
|scn48|erb|1,233|26,syntax error: invalid use of operator|||26640
;
;      here for asterisk, could be ** substitute for exclamation
;
|scn49|bze|8,wb|6,scn10||; end of name if scanning name|26644
||beq|8,wa|3,scnil|6,scn39|; not ** if * at image end|26645
||mov|7,xr|8,wa||; else save offset past first *|26646
||mov|3,scnof|8,wa||; save another copy|26647
||lch|8,wa|10,(xl)+||; load next character|26648
||bne|8,wa|18,=ch_as|6,scn50|; not ** if next char not *|26649
||icv|7,xr|||; else step offset past second *|26650
||beq|7,xr|3,scnil|6,scn51|; ok exclam if end of image|26651
||lch|8,wa|9,(xl)||; else load next character|26652
||beq|8,wa|18,=ch_bl|6,scn51|; exclamation if blank|26653
||beq|8,wa|18,=ch_ht|6,scn51|; exclamation if horizontal tab|26655
;
;      unary *
;
|scn50|mov|8,wa|3,scnof||; recover stored offset|26663
||mov|7,xl|3,r_cim||; point to line again|26664
||plc|7,xl|8,wa||; point to current char|26665
||brn|6,scn39|||; merge with unary *|26666
;
;      here for ** as substitute for exclamation
;
|scn51|mov|3,scnpt|7,xr||; save scan pointer past 2nd *|26670
||mov|8,wa|7,xr||; copy scan pointer|26671
||brn|6,scn37|||; merge with exclamation|26672
||enp||||; end procedure scane|26673
||ejc|||||26674
;
;      scngf -- scan goto field
;
;      scngf is called from cmpil to scan and analyze a goto
;      field including the surrounding brackets or parentheses.
;      for a normal goto, the result returned is either a vrblk
;      pointer for a simple label operand, or a pointer to an
;      expression tree with a special outer unary operator
;      (o_goc). for a direct goto, the result returned is a
;      pointer to an expression tree with the special outer
;      unary operator o_god.
;
;      jsr  scngf	     call to scan goto field
;      (xr)		     result (see above)
;      (xl,wa,wb,wc)	     destroyed
;
|scngf|prc|25,e|1,0||; entry point|26691
||jsr|6,scane|||; scan initial element|26692
||beq|7,xl|18,=t_lpr|6,scng1|; skip if left paren (normal goto)|26693
||beq|7,xl|18,=t_lbr|6,scng2|; skip if left bracket (direct goto)|26694
||erb|1,234|26,syntax error: goto field incorrect|||26695
;
;      here for left paren (normal goto)
;
|scng1|mov|8,wb|18,=num01||; set expan flag for normal goto|26699
||jsr|6,expan|||; analyze goto field|26700
||mov|8,wa|21,=opdvn||; point to opdv for complex goto|26701
||ble|7,xr|3,statb|6,scng3|; jump if not in static (sgd15)|26702
||blo|7,xr|3,state|6,scng4|; jump to exit if simple label name|26703
||brn|6,scng3|||; complex goto - merge|26704
;
;      here for left bracket (direct goto)
;
|scng2|mov|8,wb|18,=num02||; set expan flag for direct goto|26708
||jsr|6,expan|||; scan goto field|26709
||mov|8,wa|21,=opdvd||; set opdv pointer for direct goto|26710
||ejc|||||26711
;
;      scngf (continued)
;
;      merge here to build outer unary operator block
;
|scng3|mov|11,-(xs)|8,wa||; stack operator dv pointer|26717
||mov|11,-(xs)|7,xr||; stack pointer to expression tree|26718
||jsr|6,expop|||; pop operator off|26719
||mov|7,xr|10,(xs)+||; reload new expression tree pointer|26720
;
;      common exit point
;
|scng4|exi||||; return to caller|26724
||enp||||; end procedure scngf|26725
||ejc|||||26726
;
;      setvr -- set vrget,vrsto fields of vrblk
;
;      setvr sets the proper values in the vrget and vrsto
;      fields of a vrblk. it is called whenever trblks are
;      added or subtracted (trace,stoptr,input,output,detach)
;
;      (xr)		     pointer to vrblk
;      jsr  setvr	     call to set fields
;      (xl,wa)		     destroyed
;
;      note that setvr ignores the call if xr does not point
;      into the static region (i.e. is some other name base)
;
|setvr|prc|25,e|1,0||; entry point|26741
||bhi|7,xr|3,state|6,setv1|; exit if not natural variable|26742
;
;      here if we have a vrblk
;
||mov|7,xl|7,xr||; copy vrblk pointer|26746
||mov|13,vrget(xr)|22,=b_vrl||; store normal get value|26747
||beq|13,vrsto(xr)|22,=b_vre|6,setv1|; skip if protected variable|26748
||mov|13,vrsto(xr)|22,=b_vrs||; store normal store value|26749
||mov|7,xl|13,vrval(xl)||; point to next entry on chain|26750
||bne|9,(xl)|22,=b_trt|6,setv1|; jump if end of trblk chain|26751
||mov|13,vrget(xr)|22,=b_vra||; store trapped routine address|26752
||mov|13,vrsto(xr)|22,=b_vrv||; set trapped routine address|26753
;
;      merge here to exit to caller
;
|setv1|exi||||; return to setvr caller|26757
||enp||||; end procedure setvr|26758
||ejc|||||26761
;
;      sorta -- sort array
;
;      routine to sort an array or table on same basis as in
;      sitbol. a table is converted to an array, leaving two
;      dimensional arrays and vectors as cases to be considered.
;      whole rows of arrays are permuted according to the
;      ordering of the keys they contain, and the stride
;      referred to, is the the length of a row. it is one
;      for a vector.
;      the sort used is heapsort, fundamentals of data structure
;      horowitz and sahni, pitman 1977, page 347.
;      it is an order n*log(n) algorithm. in order
;      to make it stable, comparands may not compare equal. this
;      is achieved by sorting a copy array (referred to as the
;      sort array) containing at its high address end, byte
;      offsets to the rows to be sorted held in the original
;      array (referred to as the key array). sortc, the
;      comparison routine, accesses the keys through these
;      offsets and in the case of equality, resolves it by
;      comparing the offsets themselves. the sort permutes the
;      offsets which are then used in a final operation to copy
;      the actual items into the new array in sorted order.
;      references to zeroth item are to notional item
;      preceding first actual item.
;      reverse sorting for rsort is done by having the less than
;      test for keys effectively be replaced by a
;      greater than test.
;
;      1(xs)		     first arg - array or table
;      0(xs)		     2nd arg - index or pdtype name
;      (wa)		     0 , non-zero for sort , rsort
;      jsr  sorta	     call to sort array
;      ppm  loc		     transfer loc if table is empty
;      (xr)		     sorted array
;      (xl,wa,wb,wc)	     destroyed
||ejc|||||26798
;
;      sorta (continued)
;
|sorta|prc|25,n|1,1||; entry point|26802
||mov|3,srtsr|8,wa||; sort/rsort indicator|26803
||mov|3,srtst|19,*num01||; default stride of 1|26804
||zer|3,srtof|||; default zero offset to sort key|26805
||mov|3,srtdf|21,=nulls||; clear datatype field name|26806
||mov|3,r_sxr|10,(xs)+||; unstack argument 2|26807
||mov|7,xr|10,(xs)+||; get first argument|26808
||mnz|8,wa|||; use key/values of table entries|26809
||jsr|6,gtarr|||; convert to array|26810
||ppm|6,srt18|||; signal that table is empty|26811
||ppm|6,srt16|||; error if non-convertable|26812
||mov|11,-(xs)|7,xr||; stack ptr to resulting key array|26813
||mov|11,-(xs)|7,xr||; another copy for copyb|26814
||jsr|6,copyb|||; get copy array for sorting into|26815
||ppm||||; cant fail|26816
||mov|11,-(xs)|7,xr||; stack pointer to sort array|26817
||mov|7,xr|3,r_sxr||; get second arg|26818
||mov|7,xl|13,num01(xs)||; get ptr to key array|26819
||bne|9,(xl)|22,=b_vct|6,srt02|; jump if arblk|26820
||beq|7,xr|21,=nulls|6,srt01|; jump if null second arg|26821
||jsr|6,gtnvr|||; get vrblk ptr for it|26822
||err|1,257|26,erroneous 2nd arg in sort/rsort of vector|||26823
||mov|3,srtdf|7,xr||; store datatype field name vrblk|26824
;
;      compute n and offset to item a(0) in vector case
;
|srt01|mov|8,wc|19,*vclen||; offset to a(0)|26828
||mov|8,wb|19,*vcvls||; offset to first item|26829
||mov|8,wa|13,vclen(xl)||; get block length|26830
||sub|8,wa|19,*vcsi_||; get no. of entries, n (in bytes)|26831
||brn|6,srt04|||; merge|26832
;
;      here for array
;
|srt02|ldi|13,ardim(xl)|||; get possible dimension|26836
||mfi|8,wa|||; convert to short integer|26837
||wtb|8,wa|||; further convert to baus|26838
||mov|8,wb|19,*arvls||; offset to first value if one|26839
||mov|8,wc|19,*arpro||; offset before values if one dim.|26840
||beq|13,arndm(xl)|18,=num01|6,srt04|; jump in fact if one dim.|26841
||bne|13,arndm(xl)|18,=num02|6,srt16|; fail unless two dimens|26842
||ldi|13,arlb2(xl)|||; get lower bound 2 as default|26843
||beq|7,xr|21,=nulls|6,srt03|; jump if default second arg|26844
||jsr|6,gtint|||; convert to integer|26845
||ppm|6,srt17|||; fail|26846
||ldi|13,icval(xr)|||; get actual integer value|26847
||ejc|||||26848
;
;      sorta (continued)
;
;      here with sort column index in ia in array case
;
|srt03|sbi|13,arlb2(xl)|||; subtract low bound|26854
||iov|6,srt17|||; fail if overflow|26855
||ilt|6,srt17|||; fail if below low bound|26856
||sbi|13,ardm2(xl)|||; check against dimension|26857
||ige|6,srt17|||; fail if too large|26858
||adi|13,ardm2(xl)|||; restore value|26859
||mfi|8,wa|||; get as small integer|26860
||wtb|8,wa|||; offset within row to key|26861
||mov|3,srtof|8,wa||; keep offset|26862
||ldi|13,ardm2(xl)|||; second dimension is row length|26863
||mfi|8,wa|||; convert to short integer|26864
||mov|7,xr|8,wa||; copy row length|26865
||wtb|8,wa|||; convert to bytes|26866
||mov|3,srtst|8,wa||; store as stride|26867
||ldi|13,ardim(xl)|||; get number of rows|26868
||mfi|8,wa|||; as a short integer|26869
||wtb|8,wa|||; convert n to baus|26870
||mov|8,wc|13,arlen(xl)||; offset past array end|26871
||sub|8,wc|8,wa||; adjust, giving space for n offsets|26872
||dca|8,wc|||; point to a(0)|26873
||mov|8,wb|13,arofs(xl)||; offset to word before first item|26874
||ica|8,wb|||; offset to first item|26875
;
;      separate pre-processing for arrays and vectors done.
;      to simplify later key comparisons, removal of any trblk
;      trap blocks from entries in key array is effected.
;
;      (xl) = 1(xs) = pointer to key array
;      (xs) = pointer to sort array
;      wa = number of items, n (converted to bytes).
;      wb = offset to first item of arrays.
;      wc = offset to a(0)
;
|srt04|ble|8,wa|19,*num01|6,srt15|; return if only a single item|26887
||mov|3,srtsn|8,wa||; store number of items (in baus)|26888
||mov|3,srtso|8,wc||; store offset to a(0)|26889
||mov|8,wc|13,arlen(xl)||; length of array or vec (=vclen)|26890
||add|8,wc|7,xl||; point past end of array or vector|26891
||mov|3,srtsf|8,wb||; store offset to first row|26892
||add|7,xl|8,wb||; point to first item in key array|26893
;
;      loop through array
;
|srt05|mov|7,xr|9,(xl)||; get an entry|26897
;
;      hunt along trblk chain
;
|srt06|bne|9,(xr)|22,=b_trt|6,srt07|; jump out if not trblk|26901
||mov|7,xr|13,trval(xr)||; get value field|26902
||brn|6,srt06|||; loop|26903
||ejc|||||26904
;
;      sorta (continued)
;
;      xr is value from end of chain
;
|srt07|mov|10,(xl)+|7,xr||; store as array entry|26910
||blt|7,xl|8,wc|6,srt05|; loop if not done|26911
||mov|7,xl|9,(xs)||; get adrs of sort array|26912
||mov|7,xr|3,srtsf||; initial offset to first key|26913
||mov|8,wb|3,srtst||; get stride|26914
||add|7,xl|3,srtso||; offset to a(0)|26915
||ica|7,xl|||; point to a(1)|26916
||mov|8,wc|3,srtsn||; get n|26917
||btw|8,wc|||; convert from bytes|26918
||mov|3,srtnr|8,wc||; store as row count|26919
||lct|8,wc|8,wc||; loop counter|26920
;
;      store key offsets at top of sort array
;
|srt08|mov|10,(xl)+|7,xr||; store an offset|26924
||add|7,xr|8,wb||; bump offset by stride|26925
||bct|8,wc|6,srt08||; loop through rows|26926
;
;      perform the sort on offsets in sort array.
;
;      (srtsn)		     number of items to sort, n (bytes)
;      (srtso)		     offset to a(0)
;
|srt09|mov|8,wa|3,srtsn||; get n|26933
||mov|8,wc|3,srtnr||; get number of rows|26934
||rsh|8,wc|1,1||; i = n / 2 (wc=i, index into array)|26935
||wtb|8,wc|||; convert back to bytes|26936
;
;      loop to form initial heap
;
|srt10|jsr|6,sorth|||; sorth(i,n)|26940
||dca|8,wc|||; i = i - 1|26941
||bnz|8,wc|6,srt10||; loop if i gt 0|26942
||mov|8,wc|8,wa||; i = n|26943
;
;      sorting loop. at this point, a(1) is the largest
;      item, since algorithm initialises it as, and then maintains
;      it as, root of tree.
;
|srt11|dca|8,wc|||; i = i - 1 (n - 1 initially)|26949
||bze|8,wc|6,srt12||; jump if done|26950
||mov|7,xr|9,(xs)||; get sort array address|26951
||add|7,xr|3,srtso||; point to a(0)|26952
||mov|7,xl|7,xr||; a(0) address|26953
||add|7,xl|8,wc||; a(i) address|26954
||mov|8,wb|13,num01(xl)||; copy a(i+1)|26955
||mov|13,num01(xl)|13,num01(xr)||; move a(1) to a(i+1)|26956
||mov|13,num01(xr)|8,wb||; complete exchange of a(1), a(i+1)|26957
||mov|8,wa|8,wc||; n = i for sorth|26958
||mov|8,wc|19,*num01||; i = 1 for sorth|26959
||jsr|6,sorth|||; sorth(1,n)|26960
||mov|8,wc|8,wa||; restore wc|26961
||brn|6,srt11|||; loop|26962
||ejc|||||26963
;
;      sorta (continued)
;
;      offsets have been permuted into required order by sort.
;      copy array elements over them.
;
|srt12|mov|7,xr|9,(xs)||; base adrs of key array|26970
||mov|8,wc|7,xr||; copy it|26971
||add|8,wc|3,srtso||; offset of a(0)|26972
||add|7,xr|3,srtsf||; adrs of first row of sort array|26973
||mov|8,wb|3,srtst||; get stride|26974
;
;      copying loop for successive items. sorted offsets are
;      held at end of sort array.
;
|srt13|ica|8,wc|||; adrs of next of sorted offsets|26979
||mov|7,xl|8,wc||; copy it for access|26980
||mov|7,xl|9,(xl)||; get offset|26981
||add|7,xl|13,num01(xs)||; add key array base adrs|26982
||mov|8,wa|8,wb||; get count of characters in row|26983
||mvw||||; copy a complete row|26984
||dcv|3,srtnr|||; decrement row count|26985
||bnz|3,srtnr|6,srt13||; repeat till all rows done|26986
;
;      return point
;
|srt15|mov|7,xr|10,(xs)+||; pop result array ptr|26990
||ica|7,xs|||; pop key array ptr|26991
||zer|3,r_sxl|||; clear junk|26992
||zer|3,r_sxr|||; clear junk|26993
||exi||||; return|26994
;
;      error point
;
|srt16|erb|1,256|26,sort/rsort 1st arg not suitable array or table|||26998
|srt17|erb|1,258|26,sort/rsort 2nd arg out of range or non-integer|||26999
;
;      return point if input table is empty
;
|srt18|exi|1,1|||; return indication of null table|27003
||enp||||; end procudure sorta|27004
||ejc|||||27005
;
;      sortc --	 compare sort keys
;
;      compare two sort keys given their offsets. if
;      equal, compare key offsets to give stable sort.
;      note that if srtsr is non-zero (request for reverse
;      sort), the quoted returns are inverted.
;      for objects of differing datatypes, the entry point
;      identifications are compared.
;
;      (xl)		     base adrs for keys
;      (wa)		     offset to key 1 item
;      (wb)		     offset to key 2 item
;      (srtsr)		     zero/non-zero for sort/rsort
;      (srtof)		     offset within row to comparands
;      jsr  sortc	     call to compare keys
;      ppm  loc		     key1 less than key2
;			     normal return, key1 gt than key2
;      (xl,xr,wa,wb)	     destroyed
;
|sortc|prc|25,e|1,1||; entry point|27026
||mov|3,srts1|8,wa||; save offset 1|27027
||mov|3,srts2|8,wb||; save offset 2|27028
||mov|3,srtsc|8,wc||; save wc|27029
||add|7,xl|3,srtof||; add offset to comparand field|27030
||mov|7,xr|7,xl||; copy base + offset|27031
||add|7,xl|8,wa||; add key1 offset|27032
||add|7,xr|8,wb||; add key2 offset|27033
||mov|7,xl|9,(xl)||; get key1|27034
||mov|7,xr|9,(xr)||; get key2|27035
||bne|3,srtdf|21,=nulls|6,src12|; jump if datatype field name used|27036
||ejc|||||27037
;
;      sortc (continued)
;
;      merge after dealing with field name. try for strings.
;
|src01|mov|8,wc|9,(xl)||; get type code|27043
||bne|8,wc|9,(xr)|6,src02|; skip if not same datatype|27044
||beq|8,wc|22,=b_scl|6,src09|; jump if both strings|27045
||beq|8,wc|22,=b_icl|6,src14|; jump if both integers|27046
;
;      datatypes different.  now try for numeric
;
|src02|mov|3,r_sxl|7,xl||; keep arg1|27054
||mov|3,r_sxr|7,xr||; keep arg2|27055
||beq|8,wc|22,=b_scl|6,src11|; do not allow conversion to number|27058
||beq|9,(xr)|22,=b_scl|6,src11|; if either arg is a string|27059
|src14|mov|11,-(xs)|7,xl||; stack|27102
||mov|11,-(xs)|7,xr||; args|27103
||jsr|6,acomp|||; compare objects|27104
||ppm|6,src10|||; not numeric|27105
||ppm|6,src10|||; not numeric|27106
||ppm|6,src03|||; key1 less|27107
||ppm|6,src08|||; keys equal|27108
||ppm|6,src05|||; key1 greater|27109
;
;      return if key1 smaller (sort), greater (rsort)
;
|src03|bnz|3,srtsr|6,src06||; jump if rsort|27113
;
|src04|mov|8,wc|3,srtsc||; restore wc|27115
||exi|1,1|||; return|27116
;
;      return if key1 greater (sort), smaller (rsort)
;
|src05|bnz|3,srtsr|6,src04||; jump if rsort|27120
;
|src06|mov|8,wc|3,srtsc||; restore wc|27122
||exi||||; return|27123
;
;      keys are of same datatype
;
|src07|blt|7,xl|7,xr|6,src03|; item first created is less|27127
||bgt|7,xl|7,xr|6,src05|; addresses rise in order of creation|27128
;
;      drop through or merge for identical or equal objects
;
|src08|blt|3,srts1|3,srts2|6,src04|; test offsets or key addrss instead|27132
||brn|6,src06|||; offset 1 greater|27133
||ejc|||||27134
;
;      sortc (continued)
;
;      strings
;
|src09|mov|11,-(xs)|7,xl||; stack|27144
||mov|11,-(xs)|7,xr||; args|27145
||jsr|6,lcomp|||; compare objects|27146
||ppm||||; cant|27147
||ppm||||; fail|27148
||ppm|6,src03|||; key1 less|27149
||ppm|6,src08|||; keys equal|27150
||ppm|6,src05|||; key1 greater|27151
;
;      arithmetic comparison failed - recover args
;
|src10|mov|7,xl|3,r_sxl||; get arg1|27155
||mov|7,xr|3,r_sxr||; get arg2|27156
||mov|8,wc|9,(xl)||; get type of key1|27157
||beq|8,wc|9,(xr)|6,src07|; jump if keys of same type|27158
;
;      here to compare datatype ids
;
|src11|mov|7,xl|8,wc||; get block type word|27162
||mov|7,xr|9,(xr)||; get block type word|27163
||lei|7,xl|||; entry point id for key1|27164
||lei|7,xr|||; entry point id for key2|27165
||bgt|7,xl|7,xr|6,src05|; jump if key1 gt key2|27166
||brn|6,src03|||; key1 lt key2|27167
;
;      datatype field name used
;
|src12|jsr|6,sortf|||; call routine to find field 1|27171
||mov|11,-(xs)|7,xl||; stack item pointer|27172
||mov|7,xl|7,xr||; get key2|27173
||jsr|6,sortf|||; find field 2|27174
||mov|7,xr|7,xl||; place as key2|27175
||mov|7,xl|10,(xs)+||; recover key1|27176
||brn|6,src01|||; merge|27177
||enp||||; procedure sortc|27178
||ejc|||||27179
;
;      sortf -- find field for sortc
;
;      routine used by sortc to obtain item corresponding
;      to a given field name, if this exists, in a programmer
;      defined object passed as argument.
;      if such a match occurs, record is kept of datatype
;      name, field name and offset to field in order to
;      short-circuit later searches on same type. note that
;      dfblks are stored in static and hence cannot be moved.
;
;      (srtdf)		     vrblk pointer of field name
;      (xl)		     possible pdblk pointer
;      jsr  sortf	     call to search for field name
;      (xl)		     item found or original pdblk ptr
;      (wc)		     destroyed
;
|sortf|prc|25,e|1,0||; entry point|27197
||bne|9,(xl)|22,=b_pdt|6,srtf3|; return if not pdblk|27198
||mov|11,-(xs)|7,xr||; keep xr|27199
||mov|7,xr|3,srtfd||; get possible former dfblk ptr|27200
||bze|7,xr|6,srtf4||; jump if not|27201
||bne|7,xr|13,pddfp(xl)|6,srtf4|; jump if not right datatype|27202
||bne|3,srtdf|3,srtff|6,srtf4|; jump if not right field name|27203
||add|7,xl|3,srtfo||; add offset to required field|27204
;
;      here with xl pointing to found field
;
|srtf1|mov|7,xl|9,(xl)||; get item from field|27208
;
;      return point
;
|srtf2|mov|7,xr|10,(xs)+||; restore xr|27212
;
|srtf3|exi||||; return|27214
||ejc|||||27215
;
;      sortf (continued)
;
;      conduct a search
;
|srtf4|mov|7,xr|7,xl||; copy original pointer|27221
||mov|7,xr|13,pddfp(xr)||; point to dfblk|27222
||mov|3,srtfd|7,xr||; keep a copy|27223
||mov|8,wc|13,fargs(xr)||; get number of fields|27224
||wtb|8,wc|||; convert to bytes|27225
||add|7,xr|13,dflen(xr)||; point past last field|27226
;
;      loop to find name in pdfblk
;
|srtf5|dca|8,wc|||; count down|27230
||dca|7,xr|||; point in front|27231
||beq|9,(xr)|3,srtdf|6,srtf6|; skip out if found|27232
||bnz|8,wc|6,srtf5||; loop|27233
||brn|6,srtf2|||; return - not found|27234
;
;      found
;
|srtf6|mov|3,srtff|9,(xr)||; keep field name ptr|27238
||add|8,wc|19,*pdfld||; add offset to first field|27239
||mov|3,srtfo|8,wc||; store as field offset|27240
||add|7,xl|8,wc||; point to field|27241
||brn|6,srtf1|||; return|27242
||enp||||; procedure sortf|27243
||ejc|||||27244
;
;      sorth -- heap routine for sorta
;
;      this routine constructs a heap from elements of array, a.
;      in this application, the elements are offsets to keys in
;      a key array.
;
;      (xs)		     pointer to sort array base
;      1(xs)		     pointer to key array base
;      (wa)		     max array index, n (in bytes)
;      (wc)		     offset j in a to root (in *1 to *n)
;      jsr  sorth	     call sorth(j,n) to make heap
;      (xl,xr,wb)	     destroyed
;
|sorth|prc|25,n|1,0||; entry point|27259
||mov|3,srtsn|8,wa||; save n|27260
||mov|3,srtwc|8,wc||; keep wc|27261
||mov|7,xl|9,(xs)||; sort array base adrs|27262
||add|7,xl|3,srtso||; add offset to a(0)|27263
||add|7,xl|8,wc||; point to a(j)|27264
||mov|3,srtrt|9,(xl)||; get offset to root|27265
||add|8,wc|8,wc||; double j - cant exceed n|27266
;
;      loop to move down tree using doubled index j
;
|srh01|bgt|8,wc|3,srtsn|6,srh03|; done if j gt n|27270
||beq|8,wc|3,srtsn|6,srh02|; skip if j equals n|27271
||mov|7,xr|9,(xs)||; sort array base adrs|27272
||mov|7,xl|13,num01(xs)||; key array base adrs|27273
||add|7,xr|3,srtso||; point to a(0)|27274
||add|7,xr|8,wc||; adrs of a(j)|27275
||mov|8,wa|13,num01(xr)||; get a(j+1)|27276
||mov|8,wb|9,(xr)||; get a(j)|27277
;
;      compare sons. (wa) right son, (wb) left son
;
||jsr|6,sortc|||; compare keys - lt(a(j+1),a(j))|27281
||ppm|6,srh02|||; a(j+1) lt a(j)|27282
||ica|8,wc|||; point to greater son, a(j+1)|27283
||ejc|||||27284
;
;      sorth (continued)
;
;      compare root with greater son
;
|srh02|mov|7,xl|13,num01(xs)||; key array base adrs|27290
||mov|7,xr|9,(xs)||; get sort array address|27291
||add|7,xr|3,srtso||; adrs of a(0)|27292
||mov|8,wb|7,xr||; copy this adrs|27293
||add|7,xr|8,wc||; adrs of greater son, a(j)|27294
||mov|8,wa|9,(xr)||; get a(j)|27295
||mov|7,xr|8,wb||; point back to a(0)|27296
||mov|8,wb|3,srtrt||; get root|27297
||jsr|6,sortc|||; compare them - lt(a(j),root)|27298
||ppm|6,srh03|||; father exceeds sons - done|27299
||mov|7,xr|9,(xs)||; get sort array adrs|27300
||add|7,xr|3,srtso||; point to a(0)|27301
||mov|7,xl|7,xr||; copy it|27302
||mov|8,wa|8,wc||; copy j|27303
||btw|8,wc|||; convert to words|27304
||rsh|8,wc|1,1||; get j/2|27305
||wtb|8,wc|||; convert back to bytes|27306
||add|7,xl|8,wa||; point to a(j)|27307
||add|7,xr|8,wc||; adrs of a(j/2)|27308
||mov|9,(xr)|9,(xl)||; a(j/2) = a(j)|27309
||mov|8,wc|8,wa||; recover j|27310
||aov|8,wc|8,wc|6,srh03|; j = j*2. done if too big|27311
||brn|6,srh01|||; loop|27312
;
;      finish by copying root offset back into array
;
|srh03|btw|8,wc|||; convert to words|27316
||rsh|8,wc|1,1||; j = j/2|27317
||wtb|8,wc|||; convert back to bytes|27318
||mov|7,xr|9,(xs)||; sort array adrs|27319
||add|7,xr|3,srtso||; adrs of a(0)|27320
||add|7,xr|8,wc||; adrs of a(j/2)|27321
||mov|9,(xr)|3,srtrt||; a(j/2) = root|27322
||mov|8,wa|3,srtsn||; restore wa|27323
||mov|8,wc|3,srtwc||; restore wc|27324
||exi||||; return|27325
||enp||||; end procedure sorth|27326
||ejc|||||27328
;
;      trace -- set/reset a trace association
;
;      this procedure is shared by trace and stoptr to
;      either initiate or stop a trace respectively.
;
;      (xl)		     trblk ptr (trace) or zero (stoptr)
;      1(xs)		     first argument (name)
;      0(xs)		     second argument (trace type)
;      jsr  trace	     call to set/reset trace
;      ppm  loc		     transfer loc if 1st arg is bad name
;      ppm  loc		     transfer loc if 2nd arg is bad type
;      (xs)		     popped
;      (xl,xr,wa,wb,wc,ia)   destroyed
;
|trace|prc|25,n|1,2||; entry point|27344
||jsr|6,gtstg|||; get trace type string|27345
||ppm|6,trc15|||; jump if not string|27346
||plc|7,xr|||; else point to string|27347
||lch|8,wa|9,(xr)||; load first character|27348
||flc|8,wa|||; fold to lower case|27350
||mov|7,xr|9,(xs)||; load name argument|27352
||mov|9,(xs)|7,xl||; stack trblk ptr or zero|27353
||mov|8,wc|18,=trtac||; set trtyp for access trace|27354
||beq|8,wa|18,=ch_la|6,trc10|; jump if a (access)|27355
||mov|8,wc|18,=trtvl||; set trtyp for value trace|27356
||beq|8,wa|18,=ch_lv|6,trc10|; jump if v (value)|27357
||beq|8,wa|18,=ch_bl|6,trc10|; jump if blank (value)|27358
;
;      here for l,k,f,c,r
;
||beq|8,wa|18,=ch_lf|6,trc01|; jump if f (function)|27362
||beq|8,wa|18,=ch_lr|6,trc01|; jump if r (return)|27363
||beq|8,wa|18,=ch_ll|6,trc03|; jump if l (label)|27364
||beq|8,wa|18,=ch_lk|6,trc06|; jump if k (keyword)|27365
||bne|8,wa|18,=ch_lc|6,trc15|; else error if not c (call)|27366
;
;      here for f,c,r
;
|trc01|jsr|6,gtnvr|||; point to vrblk for name|27370
||ppm|6,trc16|||; jump if bad name|27371
||ica|7,xs|||; pop stack|27372
||mov|7,xr|13,vrfnc(xr)||; point to function block|27373
||bne|9,(xr)|22,=b_pfc|6,trc17|; error if not program function|27374
||beq|8,wa|18,=ch_lr|6,trc02|; jump if r (return)|27375
||ejc|||||27376
;
;      trace (continued)
;
;      here for f,c to set/reset call trace
;
||mov|13,pfctr(xr)|7,xl||; set/reset call trace|27382
||beq|8,wa|18,=ch_lc|6,exnul|; exit with null if c (call)|27383
;
;      here for f,r to set/reset return trace
;
|trc02|mov|13,pfrtr(xr)|7,xl||; set/reset return trace|27387
||exi||||; return|27388
;
;      here for l to set/reset label trace
;
|trc03|jsr|6,gtnvr|||; point to vrblk|27392
||ppm|6,trc16|||; jump if bad name|27393
||mov|7,xl|13,vrlbl(xr)||; load label pointer|27394
||bne|9,(xl)|22,=b_trt|6,trc04|; jump if no old trace|27395
||mov|7,xl|13,trlbl(xl)||; else delete old trace association|27396
;
;      here with old label trace association deleted
;
|trc04|beq|7,xl|21,=stndl|6,trc16|; error if undefined label|27400
||mov|8,wb|10,(xs)+||; get trblk ptr again|27401
||bze|8,wb|6,trc05||; jump if stoptr case|27402
||mov|13,vrlbl(xr)|8,wb||; else set new trblk pointer|27403
||mov|13,vrtra(xr)|22,=b_vrt||; set label trace routine address|27404
||mov|7,xr|8,wb||; copy trblk pointer|27405
||mov|13,trlbl(xr)|7,xl||; store real label in trblk|27406
||exi||||; return|27407
;
;      here for stoptr case for label
;
|trc05|mov|13,vrlbl(xr)|7,xl||; store label ptr back in vrblk|27411
||mov|13,vrtra(xr)|22,=b_vrg||; store normal transfer address|27412
||exi||||; return|27413
||ejc|||||27414
;
;      trace (continued)
;
;      here for k (keyword)
;
|trc06|jsr|6,gtnvr|||; point to vrblk|27420
||ppm|6,trc16|||; error if not natural var|27421
||bnz|13,vrlen(xr)|6,trc16||; error if not system var|27422
||ica|7,xs|||; pop stack|27423
||bze|7,xl|6,trc07||; jump if stoptr case|27424
||mov|13,trkvr(xl)|7,xr||; store vrblk ptr in trblk for ktrex|27425
;
;      merge here with trblk set up in wb (or zero)
;
|trc07|mov|7,xr|13,vrsvp(xr)||; point to svblk|27429
||beq|7,xr|21,=v_ert|6,trc08|; jump if errtype|27430
||beq|7,xr|21,=v_stc|6,trc09|; jump if stcount|27431
||bne|7,xr|21,=v_fnc|6,trc17|; else error if not fnclevel|27432
;
;      fnclevel
;
||mov|3,r_fnc|7,xl||; set/reset fnclevel trace|27436
||exi||||; return|27437
;
;      errtype
;
|trc08|mov|3,r_ert|7,xl||; set/reset errtype trace|27441
||exi||||; return|27442
;
;      stcount
;
|trc09|mov|3,r_stc|7,xl||; set/reset stcount trace|27446
||jsr|6,stgcc|||; update countdown counters|27447
||exi||||; return|27448
||ejc|||||27449
;
;      trace (continued)
;
;      a,v merge here with trtyp value in wc
;
|trc10|jsr|6,gtvar|||; locate variable|27455
||ppm|6,trc16|||; error if not appropriate name|27456
||mov|8,wb|10,(xs)+||; get new trblk ptr again|27457
||add|8,wa|7,xl||; point to variable location|27458
||mov|7,xr|8,wa||; copy variable pointer|27459
;
;      loop to search trblk chain
;
|trc11|mov|7,xl|9,(xr)||; point to next entry|27463
||bne|9,(xl)|22,=b_trt|6,trc13|; jump if not trblk|27464
||blt|8,wc|13,trtyp(xl)|6,trc13|; jump if too far out on chain|27465
||beq|8,wc|13,trtyp(xl)|6,trc12|; jump if this matches our type|27466
||add|7,xl|19,*trnxt||; else point to link field|27467
||mov|7,xr|7,xl||; copy pointer|27468
||brn|6,trc11|||; and loop back|27469
;
;      here to delete an old trblk of the type we were given
;
|trc12|mov|7,xl|13,trnxt(xl)||; get ptr to next block or value|27473
||mov|9,(xr)|7,xl||; store to delete this trblk|27474
;
;      here after deleting any old association of this type
;
|trc13|bze|8,wb|6,trc14||; jump if stoptr case|27478
||mov|9,(xr)|8,wb||; else link new trblk in|27479
||mov|7,xr|8,wb||; copy trblk pointer|27480
||mov|13,trnxt(xr)|7,xl||; store forward pointer|27481
||mov|13,trtyp(xr)|8,wc||; store appropriate trap type code|27482
;
;      here to make sure vrget,vrsto are set properly
;
|trc14|mov|7,xr|8,wa||; recall possible vrblk pointer|27486
||sub|7,xr|19,*vrval||; point back to vrblk|27487
||jsr|6,setvr|||; set fields if vrblk|27488
||exi||||; return|27489
;
;      here for bad trace type
;
|trc15|exi|1,2|||; take bad trace type error exit|27493
;
;      pop stack before failing
;
|trc16|ica|7,xs|||; pop stack|27497
;
;      here for bad name argument
;
|trc17|exi|1,1|||; take bad name error exit|27501
||enp||||; end procedure trace|27502
||ejc|||||27503
;
;      trbld -- build trblk
;
;      trblk is used by the input, output and trace functions
;      to construct a trblk (trap block)
;
;      (xr)		     trtag or trter
;      (xl)		     trfnc or trfpt
;      (wb)		     trtyp
;      jsr  trbld	     call to build trblk
;      (xr)		     pointer to trblk
;      (wa)		     destroyed
;
|trbld|prc|25,e|1,0||; entry point|27517
||mov|11,-(xs)|7,xr||; stack trtag (or trfnm)|27518
||mov|8,wa|19,*trsi_||; set size of trblk|27519
||jsr|6,alloc|||; allocate trblk|27520
||mov|9,(xr)|22,=b_trt||; store first word|27521
||mov|13,trfnc(xr)|7,xl||; store trfnc (or trfpt)|27522
||mov|13,trtag(xr)|10,(xs)+||; store trtag (or trfnm)|27523
||mov|13,trtyp(xr)|8,wb||; store type|27524
||mov|13,trval(xr)|21,=nulls||; for now, a null value|27525
||exi||||; return to caller|27526
||enp||||; end procedure trbld|27527
||ejc|||||27528
;
;      trimr -- trim trailing blanks
;
;      trimr is passed a pointer to an scblk which must be the
;      last block in dynamic storage. trailing blanks are
;      trimmed off and the dynamic storage pointer reset to
;      the end of the (possibly) shortened block.
;
;      (wb)		     non-zero to trim trailing blanks
;      (xr)		     pointer to string to trim
;      jsr  trimr	     call to trim string
;      (xr)		     pointer to trimmed string
;      (xl,wa,wb,wc)	     destroyed
;
;      the call with wb zero still performs the end zero pad
;      and dnamp readjustment. it is used from acess if kvtrm=0.
;
|trimr|prc|25,e|1,0||; entry point|27546
||mov|7,xl|7,xr||; copy string pointer|27547
||mov|8,wa|13,sclen(xr)||; load string length|27548
||bze|8,wa|6,trim2||; jump if null input|27549
||plc|7,xl|8,wa||; else point past last character|27550
||bze|8,wb|6,trim3||; jump if no trim|27551
||mov|8,wc|18,=ch_bl||; load blank character|27552
;
;      loop through characters from right to left
;
|trim0|lch|8,wb|11,-(xl)||; load next character|27556
||beq|8,wb|18,=ch_ht|6,trim1|; jump if horizontal tab|27558
||bne|8,wb|8,wc|6,trim3|; jump if non-blank found|27560
|trim1|dcv|8,wa|||; else decrement character count|27561
||bnz|8,wa|6,trim0||; loop back if more to check|27562
;
;      here if result is null (null or all-blank input)
;
|trim2|mov|3,dnamp|7,xr||; wipe out input string block|27566
||mov|7,xr|21,=nulls||; load null result|27567
||brn|6,trim5|||; merge to exit|27568
||ejc|||||27569
;
;      trimr (continued)
;
;      here with non-blank found (merge for no trim)
;
|trim3|mov|13,sclen(xr)|8,wa||; set new length|27575
||mov|7,xl|7,xr||; copy string pointer|27576
||psc|7,xl|8,wa||; ready for storing blanks|27577
||ctb|8,wa|2,schar||; get length of block in bytes|27578
||add|8,wa|7,xr||; point past new block|27579
||mov|3,dnamp|8,wa||; set new top of storage pointer|27580
||lct|8,wa|18,=cfp_c||; get count of chars in word|27581
||zer|8,wc|||; set zero char|27582
;
;      loop to zero pad last word of characters
;
|trim4|sch|8,wc|10,(xl)+||; store zero character|27586
||bct|8,wa|6,trim4||; loop back till all stored|27587
||csc|7,xl|||; complete store characters|27588
;
;      common exit point
;
|trim5|zer|7,xl|||; clear garbage xl pointer|27592
||exi||||; return to caller|27593
||enp||||; end procedure trimr|27594
||ejc|||||27595
;
;      trxeq -- execute function type trace
;
;      trxeq is used to execute a trace when a fourth argument
;      has been supplied. trace has already been decremented.
;
;      (xr)		     pointer to trblk
;      (xl,wa)		     name base,offset for variable
;      jsr  trxeq	     call to execute trace
;      (wb,wc,ra)	     destroyed
;
;      the following stack entries are made before passing
;      control to the trace function using the cfunc routine.
;
;			     trxeq return point word(s)
;			     saved value of trace keyword
;			     trblk pointer
;			     name base
;			     name offset
;			     saved value of r_cod
;			     saved code ptr (-r_cod)
;			     saved value of flptr
;      flptr --------------- zero (dummy fail offset)
;			     nmblk for variable name
;      xs ------------------ trace tag
;
;      r_cod and the code ptr are set to dummy values which
;      cause control to return to the trxeq procedure on success
;      or failure (trxeq ignores a failure condition).
;
|trxeq|prc|25,r|1,0||; entry point (recursive)|27626
||mov|8,wc|3,r_cod||; load code block pointer|27627
||scp|8,wb|||; get current code pointer|27628
||sub|8,wb|8,wc||; make code pointer into offset|27629
||mov|11,-(xs)|3,kvtra||; stack trace keyword value|27630
||mov|11,-(xs)|7,xr||; stack trblk pointer|27631
||mov|11,-(xs)|7,xl||; stack name base|27632
||mov|11,-(xs)|8,wa||; stack name offset|27633
||mov|11,-(xs)|8,wc||; stack code block pointer|27634
||mov|11,-(xs)|8,wb||; stack code pointer offset|27635
||mov|11,-(xs)|3,flptr||; stack old failure pointer|27636
||zer|11,-(xs)|||; set dummy fail offset|27637
||mov|3,flptr|7,xs||; set new failure pointer|27638
||zer|3,kvtra|||; reset trace keyword to zero|27639
||mov|8,wc|21,=trxdc||; load new (dummy) code blk pointer|27640
||mov|3,r_cod|8,wc||; set as code block pointer|27641
||lcp|8,wc|||; and new code pointer|27642
||ejc|||||27643
;
;      trxeq (continued)
;
;      now prepare arguments for function
;
||mov|8,wb|8,wa||; save name offset|27649
||mov|8,wa|19,*nmsi_||; load nmblk size|27650
||jsr|6,alloc|||; allocate space for nmblk|27651
||mov|9,(xr)|22,=b_nml||; set type word|27652
||mov|13,nmbas(xr)|7,xl||; store name base|27653
||mov|13,nmofs(xr)|8,wb||; store name offset|27654
||mov|7,xl|12,6(xs)||; reload pointer to trblk|27655
||mov|11,-(xs)|7,xr||; stack nmblk pointer (1st argument)|27656
||mov|11,-(xs)|13,trtag(xl)||; stack trace tag (2nd argument)|27657
||mov|7,xl|13,trfnc(xl)||; load trace vrblk pointer|27658
||mov|7,xl|13,vrfnc(xl)||; load trace function pointer|27659
||beq|7,xl|21,=stndf|6,trxq2|; jump if not a defined function|27660
||mov|8,wa|18,=num02||; set number of arguments to two|27661
||brn|6,cfunc|||; jump to call function|27662
;
;      see o_txr for details of return to this point
;
|trxq1|mov|7,xs|3,flptr||; point back to our stack entries|27666
||ica|7,xs|||; pop off garbage fail offset|27667
||mov|3,flptr|10,(xs)+||; restore old failure pointer|27668
||mov|8,wb|10,(xs)+||; reload code offset|27669
||mov|8,wc|10,(xs)+||; load old code base pointer|27670
||mov|7,xr|8,wc||; copy cdblk pointer|27671
||mov|3,kvstn|13,cdstm(xr)||; restore stmnt no|27672
||mov|8,wa|10,(xs)+||; reload name offset|27673
||mov|7,xl|10,(xs)+||; reload name base|27674
||mov|7,xr|10,(xs)+||; reload trblk pointer|27675
||mov|3,kvtra|10,(xs)+||; restore trace keyword value|27676
||add|8,wb|8,wc||; recompute absolute code pointer|27677
||lcp|8,wb|||; restore code pointer|27678
||mov|3,r_cod|8,wc||; and code block pointer|27679
||exi||||; return to trxeq caller|27680
;
;      here if the target function is not defined
;
|trxq2|erb|1,197|26,trace fourth arg is not function name or null|||27684
;
||enp||||; end procedure trxeq|27686
||ejc|||||27687
;
;      xscan -- execution function argument scan
;
;      xscan scans out one token in a prototype argument in
;      array,clear,data,define,load function calls. xscan
;      calls must be preceded by a call to the initialization
;      procedure xscni. the following variables are used.
;
;      r_xsc		     pointer to scblk for function arg
;      xsofs		     offset (num chars scanned so far)
;
;      (wa)		     non-zero to skip and trim blanks
;      (wc)		     delimiter one (ch_xx)
;      (xl)		     delimiter two (ch_xx)
;      jsr  xscan	     call to scan next item
;      (xr)		     pointer to scblk for token scanned
;      (wa)		     completion code (see below)
;      (wc,xl)		     destroyed
;
;      the scan starts from the current position and continues
;      until one of the following three conditions occurs.
;
;      1)   delimiter one is encountered  (wa set to 1)
;
;      2)   delimiter two encountered  (wa set to 2)
;
;      3)   end of string encountered  (wa set to 0)
;
;      the result is a string containing all characters scanned
;      up to but not including any delimiter character.
;      the pointer is left pointing past the delimiter.
;
;      if only one delimiter is to be detected, delimiter one
;      and delimiter two should be set to the same value.
;
;      in the case where the end of string is encountered, the
;      string includes all the characters to the end of the
;      string. no further calls can be made to xscan until
;      xscni is called to initialize a new argument scan
||ejc|||||27727
;
;      xscan (continued)
;
|xscan|prc|25,e|1,0||; entry point|27731
||mov|3,xscwb|8,wb||; preserve wb|27732
||mov|11,-(xs)|8,wa||; record blank skip flag|27733
||mov|11,-(xs)|8,wa||; and second copy|27734
||mov|7,xr|3,r_xsc||; point to argument string|27735
||mov|8,wa|13,sclen(xr)||; load string length|27736
||mov|8,wb|3,xsofs||; load current offset|27737
||sub|8,wa|8,wb||; get number of remaining characters|27738
||bze|8,wa|6,xscn3||; jump if no characters left|27739
||plc|7,xr|8,wb||; point to current character|27740
;
;      loop to search for delimiter
;
|xscn1|lch|8,wb|10,(xr)+||; load next character|27744
||beq|8,wb|8,wc|6,xscn4|; jump if delimiter one found|27745
||beq|8,wb|7,xl|6,xscn5|; jump if delimiter two found|27746
||bze|9,(xs)|6,xscn2||; jump if not skipping blanks|27747
||icv|3,xsofs|||; assume blank and delete it|27748
||beq|8,wb|18,=ch_ht|6,xscn2|; jump if horizontal tab|27750
||beq|8,wb|18,=ch_bl|6,xscn2|; jump if blank|27755
||dcv|3,xsofs|||; undelete non-blank character|27756
||zer|9,(xs)|||; and discontinue blank checking|27757
;
;      here after performing any leading blank trimming.
;
|xscn2|dcv|8,wa|||; decrement count of chars left|27761
||bnz|8,wa|6,xscn1||; loop back if more chars to go|27762
;
;      here for runout
;
|xscn3|mov|7,xl|3,r_xsc||; point to string block|27766
||mov|8,wa|13,sclen(xl)||; get string length|27767
||mov|8,wb|3,xsofs||; load offset|27768
||sub|8,wa|8,wb||; get substring length|27769
||zer|3,r_xsc|||; clear string ptr for collector|27770
||zer|3,xscrt|||; set zero (runout) return code|27771
||brn|6,xscn7|||; jump to exit|27772
||ejc|||||27773
;
;      xscan (continued)
;
;      here if delimiter one found
;
|xscn4|mov|3,xscrt|18,=num01||; set return code|27779
||brn|6,xscn6|||; jump to merge|27780
;
;      here if delimiter two found
;
|xscn5|mov|3,xscrt|18,=num02||; set return code|27784
;
;      merge here after detecting a delimiter
;
|xscn6|mov|7,xl|3,r_xsc||; reload pointer to string|27788
||mov|8,wc|13,sclen(xl)||; get original length of string|27789
||sub|8,wc|8,wa||; minus chars left = chars scanned|27790
||mov|8,wa|8,wc||; move to reg for sbstr|27791
||mov|8,wb|3,xsofs||; set offset|27792
||sub|8,wa|8,wb||; compute length for sbstr|27793
||icv|8,wc|||; adjust new cursor past delimiter|27794
||mov|3,xsofs|8,wc||; store new offset|27795
;
;      common exit point
;
|xscn7|zer|7,xr|||; clear garbage character ptr in xr|27799
||jsr|6,sbstr|||; build sub-string|27800
||ica|7,xs|||; remove copy of blank flag|27801
||mov|8,wb|10,(xs)+||; original blank skip/trim flag|27802
||bze|13,sclen(xr)|6,xscn8||; cannot trim the null string|27803
||jsr|6,trimr|||; trim trailing blanks if requested|27804
;
;      final exit point
;
|xscn8|mov|8,wa|3,xscrt||; load return code|27808
||mov|8,wb|3,xscwb||; restore wb|27809
||exi||||; return to xscan caller|27810
||enp||||; end procedure xscan|27811
||ejc|||||27812
;
;      xscni -- execution function argument scan
;
;      xscni initializes the scan used for prototype arguments
;      in the clear, define, load, data, array functions. see
;      xscan for the procedure which is used after this call.
;
;      -(xs)		     argument to be scanned (on stack)
;      jsr  xscni	     call to scan argument
;      ppm  loc		     transfer loc if arg is not string
;      ppm  loc		     transfer loc if argument is null
;      (xs)		     popped
;      (xr,r_xsc)	     argument (scblk ptr)
;      (wa)		     argument length
;      (ia,ra)		     destroyed
;
|xscni|prc|25,n|1,2||; entry point|27829
||jsr|6,gtstg|||; fetch argument as string|27830
||ppm|6,xsci1|||; jump if not convertible|27831
||mov|3,r_xsc|7,xr||; else store scblk ptr for xscan|27832
||zer|3,xsofs|||; set offset to zero|27833
||bze|8,wa|6,xsci2||; jump if null string|27834
||exi||||; return to xscni caller|27835
;
;      here if argument is not a string
;
|xsci1|exi|1,1|||; take not-string error exit|27839
;
;      here for null string
;
|xsci2|exi|1,2|||; take null-string error exit|27843
||enp||||; end procedure xscni|27844
||ttl|27,s p i t b o l -- stack overflow section||||27845
;
;      control comes here if the main stack overflows
;
||sec||||; start of stack overflow section|27849
;
||add|3,errft|18,=num04||; force conclusive fatal error|27851
||mov|7,xs|3,flptr||; pop stack to avoid more fails|27852
||bnz|3,gbcfl|6,stak1||; jump if garbage collecting|27853
||erb|1,246|26,stack overflow|||27854
;
;      no chance of recovery in mid garbage collection
;
|stak1|mov|7,xr|21,=endso||; point to message|27858
||zer|3,kvdmp|||; memory is undumpable|27859
||brn|6,stopr|||; give up|27860
||ttl|27,s p i t b o l -- error section||||27861
;
;      this section of code is entered whenever a procedure
;      return via an err parameter or an erb opcode is obeyed.
;
;      (wa)		     is the error code
;
;      the global variable stage indicates the point at which
;      the error occured as follows.
;
;      stage=stgic	     error during initial compile
;
;      stage=stgxc	     error during compile at execute
;			     time (code, convert function calls)
;
;      stage=stgev	     error during compilation of
;			     expression at execution time
;			     (eval, convert function call).
;
;      stage=stgxt	     error at execute time. compiler
;			     not active.
;
;      stage=stgce	     error during initial compile after
;			     scanning out the end line.
;
;      stage=stgxe	     error during compile at execute
;			     time after scanning end line.
;
;      stage=stgee	     error during expression evaluation
;
||sec||||; start of error section|27891
;
|error|beq|3,r_cim|20,=cmlab|6,cmple|; jump if error in scanning label|27893
||mov|3,kvert|8,wa||; save error code|27894
||zer|3,scnrs|||; reset rescan switch for scane|27895
||zer|3,scngo|||; reset goto switch for scane|27896
||mov|3,polcs|18,=num01||; reset poll count|27898
||mov|3,polct|18,=num01||; reset poll count|27899
||mov|7,xr|3,stage||; load current stage|27901
||bsw|7,xr|2,stgno||; jump to appropriate error circuit|27902
||iff|2,stgic|6,err01||; initial compile|27910
||iff|2,stgxc|6,err04||; execute time compile|27910
||iff|2,stgev|6,err04||; eval compiling expr.|27910
||iff|2,stgxt|6,err05||; execute time|27910
||iff|2,stgce|6,err01||; compile - after end|27910
||iff|2,stgxe|6,err04||; xeq compile-past end|27910
||iff|2,stgee|6,err04||; eval evaluating expr|27910
||esw||||; end switch on error type|27910
||ejc|||||27911
;
;      error during initial compile
;
;      the error message is printed as part of the compiler
;      output. this printout includes the offending line (if not
;      printed already) and an error flag under the appropriate
;      column as indicated by scnse unless scnse is set to zero.
;
;      after printing the message, the generated code is
;      modified to an error call and control is returned to
;      the cmpil procedure after resetting the stack pointer.
;
;      if the error occurs after the end line, control returns
;      in a slightly different manner to ensure proper cleanup.
;
|err01|mov|7,xs|3,cmpxs||; reset stack pointer|27927
||ssl|3,cmpss|||; restore s-r stack ptr for cmpil|27928
||bnz|3,errsp|6,err03||; jump if error suppress flag set|27929
||mov|8,wc|3,cmpsn||; current statement|27932
||jsr|6,filnm|||; obtain file name for this statement|27933
||mov|8,wb|3,scnse||; column number|27935
||mov|8,wc|3,rdcln||; line number|27936
||mov|7,xr|3,stage||;|27937
||jsr|6,sysea|||; advise system of error|27938
||ppm|6,erra3|||; if system does not want print|27939
||mov|11,-(xs)|7,xr||; save any provided print message|27940
||mov|3,erlst|3,erich||; set flag for listr|27942
||jsr|6,listr|||; list line|27943
||jsr|6,prtis|||; terminate listing|27944
||zer|3,erlst|||; clear listr flag|27945
||mov|8,wa|3,scnse||; load scan element offset|27946
||bze|8,wa|6,err02||; skip if not set|27947
||lct|8,wb|8,wa||; loop counter|27949
||icv|8,wa|||; increase for ch_ex|27950
||mov|7,xl|3,r_cim||; point to bad statement|27951
||jsr|6,alocs|||; string block for error flag|27952
||mov|8,wa|7,xr||; remember string ptr|27953
||psc|7,xr|||; ready for character storing|27954
||plc|7,xl|||; ready to get chars|27955
;
;      loop to replace all chars but tabs by blanks
;
|erra1|lch|8,wc|10,(xl)+||; get next char|27959
||beq|8,wc|18,=ch_ht|6,erra2|; skip if tab|27960
||mov|8,wc|18,=ch_bl||; get a blank|27961
||ejc|||||27962
;
;      merge to store blank or tab in error line
;
|erra2|sch|8,wc|10,(xr)+||; store char|27966
||bct|8,wb|6,erra1||; loop|27967
||mov|7,xl|18,=ch_ex||; exclamation mark|27968
||sch|7,xl|9,(xr)||; store at end of error line|27969
||csc|7,xr|||; end of sch loop|27970
||mov|3,profs|18,=stnpd||; allow for statement number|27971
||mov|7,xr|8,wa||; point to error line|27972
||jsr|6,prtst|||; print error line|27973
;
;      here after placing error flag as required
;
|err02|jsr|6,prtis|||; print blank line|27987
||mov|7,xr|10,(xs)+||; restore any sysea message|27989
||bze|7,xr|6,erra0||; did sysea provide message to print|27990
||jsr|6,prtst|||; print sysea message|27991
|erra0|jsr|6,ermsg|||; generate flag and error message|27993
||add|3,lstlc|18,=num03||; bump page ctr for blank, error, blk|27994
|erra3|zer|7,xr|||; in case of fatal error|27995
||bhi|3,errft|18,=num03|6,stopr|; pack up if several fatals|27996
;
;      count error, inhibit execution if required
;
||icv|3,cmerc|||; bump error count|28000
||add|3,noxeq|3,cswer||; inhibit xeq if -noerrors|28001
||bne|3,stage|18,=stgic|6,cmp10|; special return if after end line|28002
||ejc|||||28003
;
;      loop to scan to end of statement
;
|err03|mov|7,xr|3,r_cim||; point to start of image|28007
||plc|7,xr|||; point to first char|28008
||lch|7,xr|9,(xr)||; get first char|28009
||beq|7,xr|18,=ch_mn|6,cmpce|; jump if error in control card|28010
||zer|3,scnrs|||; clear rescan flag|28011
||mnz|3,errsp|||; set error suppress flag|28012
||jsr|6,scane|||; scan next element|28013
||bne|7,xl|18,=t_smc|6,err03|; loop back if not statement end|28014
||zer|3,errsp|||; clear error suppress flag|28015
;
;      generate error call in code and return to cmpil
;
||mov|3,cwcof|19,*cdcod||; reset offset in ccblk|28019
||mov|8,wa|21,=ocer_||; load compile error call|28020
||jsr|6,cdwrd|||; generate it|28021
||mov|13,cmsoc(xs)|3,cwcof||; set success fill in offset|28022
||mnz|13,cmffc(xs)|||; set failure fill in flag|28023
||jsr|6,cdwrd|||; generate succ. fill in word|28024
||brn|6,cmpse|||; merge to generate error as cdfal|28025
;
;      error during execute time compile or expression evaluatio
;
;      execute time compilation is initiated through gtcod or
;      gtexp which are called by compile, code or eval.
;      before causing statement failure through exfal it is
;      helpful to set keyword errtext and for generality
;      these errors may be handled by the setexit mechanism.
;
|err04|bge|3,errft|18,=num03|6,labo1|; abort if too many fatal errors|28035
||beq|3,kvert|18,=nm320|6,err06|; treat user interrupt specially|28037
||zer|3,r_ccb|||; forget garbage code block|28039
||mov|3,cwcof|19,*cccod||; set initial offset (mbe catspaw)|28040
||ssl|3,iniss|||; restore main prog s-r stack ptr|28041
||jsr|6,ertex|||; get fail message text|28042
||dca|7,xs|||; ensure stack ok on loop start|28043
;
;      pop stack until find flptr for most deeply nested prog.
;      defined function call or call of eval / code.
;
|erra4|ica|7,xs|||; pop stack|28048
||beq|7,xs|3,flprt|6,errc4|; jump if prog defined fn call found|28049
||bne|7,xs|3,gtcef|6,erra4|; loop if not eval or code call yet|28050
||mov|3,stage|18,=stgxt||; re-set stage for execute|28051
||mov|3,r_cod|3,r_gtc||; recover code ptr|28052
||mov|3,flptr|7,xs||; restore fail pointer|28053
||zer|3,r_cim|||; forget possible image|28054
||zer|3,cnind|||; forget possible include|28056
;
;      test errlimit
;
|errb4|bnz|3,kverl|6,err07||; jump if errlimit non-zero|28061
||brn|6,exfal|||; fail|28062
;
;      return from prog. defined function is outstanding
;
|errc4|mov|7,xs|3,flptr||; restore stack from flptr|28066
||brn|6,errb4|||; merge|28067
||ejc|||||28068
;
;      error at execute time.
;
;      the action taken on an error is as follows.
;
;      if errlimit keyword is zero, an abort is signalled,
;      see coding for system label abort at l_abo.
;
;      otherwise, errlimit is decremented and an errtype trace
;      generated if required. control returns either via a jump
;      to continue (to take the failure exit) or a specified
;      setexit trap is executed and control passes to the trap.
;      if 3 or more fatal errors occur an abort is signalled
;      regardless of errlimit and setexit - looping is all too
;      probable otherwise. fatal errors include stack overflow
;      and exceeding stlimit.
;
|err05|ssl|3,iniss|||; restore main prog s-r stack ptr|28086
||bnz|3,dmvch|6,err08||; jump if in mid-dump|28087
;
;      merge here from err08 and err04 (error 320)
;
|err06|bze|3,kverl|6,labo1||; abort if errlimit is zero|28091
||jsr|6,ertex|||; get fail message text|28092
;
;      merge from err04
;
|err07|bge|3,errft|18,=num03|6,labo1|; abort if too many fatal errors|28096
||dcv|3,kverl|||; decrement errlimit|28097
||mov|7,xl|3,r_ert||; load errtype trace pointer|28098
||jsr|6,ktrex|||; generate errtype trace if required|28099
||mov|8,wa|3,r_cod||; get current code block|28100
||mov|3,r_cnt|8,wa||; set cdblk ptr for continuation|28101
||scp|8,wb|||; current code pointer|28102
||sub|8,wb|8,wa||; offset within code block|28103
||mov|3,stxoc|8,wb||; save code ptr offset for scontinue|28104
||mov|7,xr|3,flptr||; set ptr to failure offset|28105
||mov|3,stxof|9,(xr)||; save failure offset for continue|28106
||mov|7,xr|3,r_sxc||; load setexit cdblk pointer|28107
||bze|7,xr|6,lcnt1||; continue if no setexit trap|28108
||zer|3,r_sxc|||; else reset trap|28109
||mov|3,stxvr|21,=nulls||; reset setexit arg to null|28110
||mov|7,xl|9,(xr)||; load ptr to code block routine|28111
||bri|7,xl|||; execute first trap statement|28112
;
;      interrupted partly through a dump whilst store is in a
;      mess so do a tidy up operation. see dumpr for details.
;
|err08|mov|7,xr|3,dmvch||; chain head for affected vrblks|28117
||bze|7,xr|6,err06||; done if zero|28118
||mov|3,dmvch|9,(xr)||; set next link as chain head|28119
||jsr|6,setvr|||; restore vrget field|28120
;
;      label to mark end of code
;
|s_yyy|brn|6,err08|||; loop through chain|28124
||ttl|27,s p i t b o l -- here endeth the code||||28125
;
;      end of assembly
;
||end||||; end macro-spitbol assembly|28129
