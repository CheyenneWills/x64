*	expand symbolic definitions for target environment as input to assembler
*	
	tab = char(9)

	target = (differ(host(0)) host(0), "unix_64_asm")
	target break('_') . os len(1) break('_') . ws len(1) rem  . asm 
*	output = 'os ' os '  ws  '  ws '  asm  '  asm

.if G
*	&dump = 3
	target = host(0)
	target break('_') . os '_' break('_') . ws '_' rem . asm

*	create map from Minimal registers to gas register name

	rmap = table(20)

	s = 'XL si XR di XS sp XT si WA cx WB bx WC dx W0 ax IA bp '
rinit	s break(' ') . min ' ' break(' ') . reg ' '  = 		:f(rdone)
	rmap[min] =  (eq(ws,32) '%e', '%r') reg	:(rinit)
rdone

*	create map from 'low' register names to corresponding gas names
	lmap = table(4)
	s = 'W0_L %al WA_L %cl WB_L %bl WC_L %dl W0_L %al '
linit	s break(' ') . reg ' ' break(' ') . low ' '  = 		:f(ldone)
	lmap[reg] = low				:(linit)
ldone

	word = (eq(ws,32) 'dword','qword')
	defines = 'M_word ' word ' '
	defines = defines 'D_word' ' ' 	(eq(ws,32) '.long',	'.quad') ' '
	defines = defines 'CFP_B'  ' ' 	(eq(ws,32) '4',		'8') ' '

	define('a(ref)')			:(a.end)
						:(next)
a	ident(os,"osx")				:s(a.err)
	a = '[' ref ']' 			:(return)
a.end

	define('m(ref)')			:(m.end)
m
*	strip off enclosing parenthesis
	ref len(1) break(')') . m
	m = (eq(ws,32) 'd', 'q') 'word ptr ' m  :(return)
m.end



	rpat =  'IA' | ('X' any('LRST')) | ('W' any('ABC0')) 

	lpat = 'W' any('0ABC') '_L'

						:(next)
copy
	output = line
next
	line = input				:f(end)
*	copy out whole line comment
	line tab(0) ';' = '#' 			:s(copy)
*	change nasm-format comment to gas-format
	line ';' = '#'				
	

aloop	line breakx('A') . first 'A(' bal . ref ')' rem . last = first a(ref) last	:s(mloop)
	defs = defines

dloop
	defs break(' ') . key ' ' break(' ') . val ' ' =	:f(mloop)
dloop.1	line key = val				:s(dloop.1)f(dloop)

mloop	
*	line breakx('M') . first 'Mem' bal . ref  rem . last = first m(ref) last	:s(mloop)
	line breakx('M') . first 'Mem' bal . ref  rem . last = first m(ref) last	:f(mloop.1)
*	output = '#Mem line ' line
*	output = '# Mem first ' first '  ref ' ref '  last ' last	:(mloop)	
mloop.1

rloop 	line rpat . reg = prefix rmap[reg]	:s(rloop)

lloop 	line lpat . reg  = lmap[reg]		:s(lloop)

	output = line				:(next)
err	output = 'error '			:(end)

.fi

.if A
*	output standard definitions
	output = tab '%define'	tab	'cfp_b'	tab	(eq(ws,32) 4, 8)
	output = tab '%define'	tab 	'cfp_c'	tab	(eq(ws,32) 4, 8)
	output = tab '%define'	tab	'os '	tab	os
	output = tab '%define'	tab	'ws'	tab	ws

loop	line = input				:f(a.end)
	output = line				:(loop)
a.end
	output = tab '%undef'	tab	'cfp_b'
	output = tab '%undef'	tab	'cfp_c'
	output = tab '%undef'   tab	os
	output = tab '%undef'	tab	'ws'
.fi
end
