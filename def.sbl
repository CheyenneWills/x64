*	expand symbolic definitions for target environment as input to assembler
*	
	define('a(ref)')
	define('m(ref)')
*	define('macdef(name)')

	target = (differ(host(0)) host(0), "unix_64_asm")
	target break('_') . os len(1) break('_') . ws len(1) rem  . asm 
*	output = 'os ' os '  ws  '  ws '  asm  '  asm

	tab = char(9)
	span.space = span(' ' char(9))
	break.space = break(' ' char(9))

	&stlimit = 500000
*	&dump = 3
.if asm
*	output standard definitions
	output = tab	'%define'	tab	'cfp_b'	tab	(eq(ws,32) 4, 8)
	output = tab	'%define'	tab 	'cfp_c'	tab	(eq(ws,32) 4, 8)
	output = tab	'%define'	tab	'os '	tab	os
	output = tab	'%define'	tab	'ws'	tab	ws
	:(next)
copy	output = line
next	line = input					:f(a.end)

*	define 'Equ' definitions using %define statements

	line	break('E') 'Equ' span.space  break(',') . name ',' rem . value =
+		tab	'%define'	tab	name	tab	value			
							:(copy)

a.end
	output = tab '%undef'	tab	'cfp_b'
	output = tab '%undef'	tab	'cfp_c'
	output = tab '%undef'   tab	os
	output = tab '%undef'	tab	'ws'
.fi
.if gas
*	&dump = 3

	rpat =  ('IA' | ('X' any('LRST')) | ('W' any('ABC0')))

	lpat = 'W' any('0ABC') '_L'

	upper.pat = break(&ucase)

*	create map from Minimal registers to gas register names

	rmap = table(100)
	s = (eq(ws,32) 'XL %esi XR %edi XS %esp XT %esi WA %ecx WB %ebx WC %edx W0 %eax IA %ebp ',
+			   'XL %rsi XR %rdi XS %rsp XT %rsi WA %rcx WB %rbx WC %rdx W0 %rax IA %rbp')
rmap.ini
	s break(' ') . key ' ' break(' ') . val ' ' =		:f(rmap.done)
	rmap[key] = val						:(rmap.ini)
rmap.done

*	create map from 'low' register names to corresponding gas names
	lmap = table(10)
	s = 'W0_L %al WA_L %cl WB_L %bl WC_L %dl '
lmap.ini
	s break(' ') . key ' ' break(' ') . val ' ' =		:f(lmap.done)
	lmap[key] = val					:(lmap.ini)
lmap.done

	is_macro = table(100)
	s = 	'Add 1 Align 1 Add 1 And 1 Cmp 1 Data 1 Equ 1 Extern 1 '
+		'Fill 1 Global 1 Inc 1 Include 1 Jmp 1 Mov 1 Or 1 Sub 1 Text 1 Xor 1'
is_macro.ini
	s break(' ') . key ' ' break(' ') . val ' ' =		:f(is_macro.done)
	is_macro[key] = val					:(is_macro.ini)
is_macro.done

	macroname = any('ACDEFGIJMOSTX') span(&lcase '_')

						:(next)
a	ident(os,"osx")				:s(a.err)
	a = '[' ref ']' 			:(return)
a.end

m
*	strip off enclosing parenthesis
	ref len(1) break(')') . m		 :(return)
-stitl macdef(name)
*macdef
*	macdef = (differ[macros[name]) name '_', name)	:(return)
copy
	output = line
next
*	only need to change lines with upper case character
	line = input				:f(end)
*	copy out whole line comment
	line tab(0) ';' = '#' 			:s(copy)

*	change nasm-format comment to gas-format
	line ';' = '#'				

	line upper.pat				:f(copy)
	
*	resolve data declarators 

	line any('CDM')				:f(defs.end)
	line 'D_word' = (eq(ws,32) '.long', '.quad')
	line 'D_char' = '.ascii'
	line 'D_byte' = '.byte'
	line 'D_real' = '.double'
*	line 'CFP_B' =  (eq(ws,32) '4','8')
*	line 'CFP_C' =  (eq(ws,32) '4','8')
	line 'M_real' = 'qword'
	line 'M_word' = (eq(ws,32), 'dword', 'qword')
defs.end

aloop	line breakx('A') . first 'Adr' bal . ref  rem . last = first a(ref) last	:s(mloop)
	defs = defines

dloop
	defs break(' ') . key ' ' break(' ') . val ' ' =	:f(mloop)
dloop.1	line key = val				:s(dloop.1)f(dloop)

	line break('M')						:f(mloop.end)
* here to resolve Mem references
mloop	
*	line breakx('M') . first 'Mem' bal . ref  rem . last = first m(ref) last	:s(mloop)
	line breakx('M') . first 'Mem' bal . ref  rem . last = first m(ref) last	:f(mloop.end)
*	output = '#Mem line ' line
*	output = '# Mem first ' first '  ref ' ref '  last ' last	:(mloop)	
mloop.end

*	resolve register references

	line any('IXW')				:f(rloop.end)
rloop 	line rpat . reg = prefix (differ(rmap[reg]) rmap[reg], '??') 	:s(rloop)
rloop.end

*	here to find and resolve references to low part of W register

	line break('W')				:f(lloop.end)
lloop 	line lpat . reg  = lmap[reg]		:s(lloop)
lloop.end
regs.end

*	look for possible macro call. If found, append '_' to macro name, to avoid
*	error message that would result if macro invokes operator of same name, ignoring case.
 
macro
	line upper.pat					:f(macro.end)
*	output = '# looking for macro:' line ':'
	line	macroname . name			:f(macro.end)
*	output ' checking:' name ':'
	differ(is_macro[name])				:f(macro.end)
*	here if macro call, replace any commas by space
*	output = '# found macro ' name
*macro.comma line ',' =  ' '					:s(macro.comma)
	line  name = name '_'				:s(macro)
macro.end
	:(copy)
	
err	output = 'error '			:(end)

.fi

end
