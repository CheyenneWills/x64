; Copyright 1987-2012 Robert B. K. Dewar and Mark Emmer.
; Copyright 2012-2013 David Shields
; 
; This file is part of Macro SPITBOL.
; 
;     Macro SPITBOL is free software: you can redistribute it and/or modify
;     it under the terms of the GNU General Public License as published by
;     the Free Software Foundation, either version 2 of the License, or
;     (at your option) any later version.
; 
;     Macro SPITBOL is distributed in the hope that it will be useful,
;     but WITHOUT ANY WARRANTY; without even the implied warranty of
;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;     GNU General Public License for more details.
; 
;     You should have received a copy of the GNU General Public License
;     along with Macro SPITBOL.  If not, see <http://www.gnu.org/licenses/>.
;
        section	.text

	%include	"m.h"

	extern	osisp
	extern	compsp
	extern	save_regs
	extern	restore_regs
	extern	_rc_
	extern	reg_fl
	extern	reg_w0
	extern	f_dvi
	extern	f_rmi
	extern	OVR_
	
	global	MXINT

%define zz_trace
%ifdef zz_trace
	extern	zz
	extern	zzz
	extern	zz_cp
	extern	zz_xl
	extern	zz_xr
	extern	zz_xs
	extern	zz_wa
	extern	zz_wb
	extern	zz_wc
	extern	zz_w0
	extern	zz_zz
	extern	zz_id
	extern	zz_de
	extern	zz_0
	extern	zz_1
	extern	zz_2
	extern	zz_3
	extern	zz_4
	extern	zz_arg
	extern	zz_num
%endif
	global	START


;
;
;   Table to recover type word from type ordinal
;

	extern	_rc_
	global	TYPET
	section .data
	
        D_WORD	B_ART   ; ARBLK type word - 0
        D_WORD	B_CDC   ; CDBLK type word - 1
        D_WORD	B_EXL   ; EXBLK type word - 2
        D_WORD	B_ICL   ; ICBLK type word - 3
        D_WORD	B_NML   ; NMBLK type word - 4
        D_WORD	P_ABA   ; P0BLK type word - 5
        D_WORD	P_ALT   ; P1BLK type word - 6
        D_WORD	P_ANY   ; P2BLK type word - 7
; next needed only if support real arithmetic CNRA
;       D_WORD	B_RCL   ; RCBLK type word - 8
        D_WORD	B_SCL   ; SCBLK type word - 9
        D_WORD	B_SEL   ; SEBLK type word - 10
        D_WORD	B_TBT   ; TBBLK type word - 11
        D_WORD	B_VCT   ; VCBLK type word - 12
        D_WORD	B_XNT   ; XNBLK type word - 13
        D_WORD	B_XRT   ; XRBLK type word - 14
        D_WORD	B_BCT   ; BCBLK type word - 15
        D_WORD	B_PDT   ; PDBLK type word - 16
        D_WORD	B_TRT   ; TRBLK type word - 17
        D_WORD	B_BFT   ; BFBLK type word   18
        D_WORD	B_CCT   ; CCBLK type word - 19
        D_WORD	B_CMT   ; CMBLK type word - 20
        D_WORD	B_CTT   ; CTBLK type word - 21
        D_WORD	B_DFC   ; DFBLK type word - 22
        D_WORD	B_EFC   ; EFBLK type word - 23
        D_WORD	B_EVT   ; EVBLK type word - 24
        D_WORD	B_FFC   ; FFBLK type word - 25
        D_WORD	B_KVT   ; KVBLK type word - 26
        D_WORD	B_PFC   ; PFBLK type word - 27
        D_WORD	B_TET   ; TEBLK type word - 28
;
;   Table of MINIMAL entry points that can be dded from C
;   via the minimal function (see inter.asm).
;
;   Note that the order of entries in this table must correspond
;   to the order of entries in the CALL enumeration in osint.h
;   and osint.inc.
;
	global calltab
calltab:
        D_WORD	RELAJ
        D_WORD	RELCR
        D_WORD	RELOC
        D_WORD	ALLOC
        D_WORD	ALOCS
        D_WORD	ALOST
        D_WORD	BLKLN
        D_WORD	INSTA
        D_WORD	RSTRT
        D_WORD	START
        D_WORD	FILNM
        D_WORD	DTYPE
;       D_WORD	ENEVS ;  Engine words
;       D_WORD	ENGTS ;   not used

	global	GBCNT
	global	HEADV
	global	MXLEN
	global	STAGE
	global	TIMSX
	global	DNAMB
	global	DNAMP
	global	STATE
	global	B_EFC
	global	B_ICL
	global	B_SCL
	global	B_VCT
	global	B_XNT
	global	B_XRT
	global	STBAS
	global	STATB
	global	POLCT
	global  TYPET
	global	LOWSPMIN
	global	FLPRT
	global	FLPTR
	global	GTCEF
	global	HSHTB
	global	PMHBS
	global	R_FCB
	global	C_AAA
	global	C_YYY
	global	G_AAA
	global	W_YYY
	global	S_AAA
	global	S_YYY
	global	R_COD
	global	KVSTN
	global	KVDMP
	global	KVFTR
	global	KVCOM
	global	KVPFL
	global	CSWFL
        global  STMCS
        global  STMCT
	global	B_RCL
	global	END_MIN_DATA


        extern CVD_
        extern ATN_
        extern CHP_
        extern COS_
        extern ETX_
        extern LNF_
        extern SIN_
        extern SQR_
        extern TAN_

	%macro	ZZZ	3
	section	.data
%%desc:	db	%3,0
	section	.text
	mov	M_WORD [zz_id],%1
	mov	M_WORD [zz_zz],%2
	mov	M_WORD [zz_de],%%desc
	call	zzz
	%endmacro
	extern	reg_ia,reg_wa,reg_fl,reg_w0,reg_wc
;	Integer arithmetic instructions
	extern	CVD__
	%macro	CVD_	0
	call	CVD__
	%endmacro


	%macro	ADI_	1
	add	IA,%1
	seto	BYTE [reg_fl]
	%endmacro
	extern	DVI__
	%macro	DVI_	1
	call	DVI__
	%endmacro

	extern	RMI__
	%macro	RMI_	1
	mov	W0,%1
	call	RMI__
	%endmacro

	%macro	INO_	1
	mov	AL,BYTE [reg_fl]
	or	AL,AL
	jno	%1
	%endmacro
	
	%macro	IOV_	1
	mov	AL,BYTE [reg_fl]
	or	AL,AL
	jo	%1
	%endmacro
	
	%macro	LDI_	1
	mov	IA,%1
	%endmacro

	%macro	MLI_	1
	imul	IA,%1
	seto	BYTE [reg_fl]
	%endmacro
	
	%macro	NGI_	0
	neg	IA
	seto	BYTE [reg_fl]
	%endmacro

	extern	f_rti
	%macro	RTI_	0
	call	f_rti
	mov	IA,M_WORD [reg_ia]
	%endmacro

	%macro	SBI_	1
	sub	IA,%1
	mov	W0,0
	seto	BYTE [reg_fl]
	%endmacro
	
	%macro	STI_	1
	mov	%1,IA
	%endmacro

;	Code Pointer Instructions (CP maintained in location reg_cp)

	extern	reg_cp

	%macro	LCP_	1
	mov	W0,%1
	mov	M_WORD [reg_cp],W0
	%endmacro

	%macro	LCW_	1
	mov	W0,M_WORD [reg_cp]		; load address of code word
	mov	W0,M_WORD [W0]			; load code word
	mov	%1,W0
	mov	W0,M_WORD [reg_cp]		; load address of code word
	add	W0,CFP_B
	mov	M_WORD [reg_cp],W0
	%endmacro

	%macro	SCP_	1
	mov	W0,M_WORD [reg_cp]
	mov	%1,W0
	%endmacro
	
	%macro	ICP_	0
	mov	W0,M_WORD [reg_cp]
	add	W0,CFP_B
	mov	M_WORD [reg_cp],W0
	%endmacro

	extern	reg_ra

	extern	ldr_l,ldr_e
	extern	reg_rp
	%macro	LDR_	0
	mov	M_WORD [reg_rp],W0
	call	ldr_e
	fld	%1
	fstp	R_WORD [reg_ra]
	call	ldr_l
	%endmacro

	%macro	STR_	0
	fld	R_WORD [reg_ra]
	fstp	%1
	%endmacro

	%macro	RTI_	1
	fld	R_WORD [reg_ia]
	fistp	R_WORD [reg_ia]
	%endmacro


	%macro	ITR_	0
	mov	M_WORD [reg_ia],IA
	fild	M_WORD [reg_ia]
	fstp	R_WORD [reg_ra]
	%endmacro

	extern	adr_e,adr_l
	%macro	ADR_	0
	call	adr_e
	fld	R_WORD [reg_ra]
	fadd	R_WORD [W0]
	fstp	R_WORD [reg_ra]
	call	adr_l
	%endmacro

	extern	sbr_e,sbr_l
	%macro	SBR_	0
	call	sbr_e
	fld	R_WORD [reg_ra]
	fsub	R_WORD [W0]
	fstp	R_WORD [reg_ra]
	call	sbr_l
	%endmacro

	extern	mlr_e,mlr_l
	%macro	MLR_	0
	call	mlr_e
	fld	R_WORD [reg_ra]
	fmul	R_WORD [W0]
	fstp	R_WORD [reg_ra]
	call	mlr_l
	%endmacro

	extern	dvr_e,dvr_l
	%macro	DVR_	0
	call	dvr_e
	fld	R_WORD [reg_ra]
	fdiv	R_WORD [W0]
	fstp	R_WORD [reg_ra]
	call	dvr_l
	%endmacro
	
	extern	ngr_e,ngr_l
	%macro	NGR_	0
	call	ngr_e
	fld	R_WORD [reg_ra]
	fchs
	fstp	R_WORD [reg_ra]
	call	ngr_l
	%endmacro

	extern	zero
	extern	f_cpr
	%macro	CPR_	0
	call	f_cpr
; 	fld	R_WORD [reg_ra]
; ;	fcomip	M_WORD [zero]
; 	ftst
; 	fstsw
; 	test	AX,0x4500
; 	jz	%%1
; 	test	AX,0x0100
; 	jnz	%%2
; 	; here if equal to zero
; 	mov	BYTE [reg_fl],0
; 	jmp	%%3
; %%1:	; here if GT zero
; 	mov	BYTE [reg_fl],1
; 	jmp	%%3
; %%2:	; here if equal to zero
; 	mov	BYTE [reg_fl],0
; %%3:
	%endmacro

	extern	rno_e
	%macro	RNO_	1
	call	rno_e
	test	BYTE [reg_fl]
	jz		%1
	%endmacro

	extern	rov_e
	%macro	ROV_	1
	call	rov_e
	test	BYTE [reg_fl]
	jne		%1
	%endmacro

