-STITL Description
* Copyright 1987-2012 Robert B. K. Dewar and Mark Emmer.
* 
* This file is part of Macro SPITBOL.
* 
*     Macro SPITBOL is free software: you can redistribute it and/or modify
*     it under the terms of the GNU General Public License as published by
*     the Free Software Foundation, either version 3 of the License, or
*     (at your option) any later version.
* 
*     Macro SPITBOL is distributed in the hope that it will be useful,
*     but WITHOUT ANY WARRANTY; without even the implied warranty of
*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*     GNU General Public License for more details.
* 
*     You should have received a copy of the GNU General Public License
*     along with Macro SPITBOL.  If not, see <http://www.gnu.org/licenses/>.
*
*
*  This program takes input file in MINIMAL token form and
*  produces assembly code for INTEL 80386 processor.
*  The program obtains the name of the file to be translated from the
*  command line string in HOST(0).  Options relating to the processing
*  of comments can be changed by modifying the source.
*
*  In addition to the MINIMAL token file, the program requires the
*  name of a "machine definition file" that contains code specific
*  to a particular 80386 assembler.
*
*  You may also specify option flags on the command line to control the
*  code generation.  The following flags are processed:
*	COMPRESS	Generate tabs rather than spaces in output file
*       COMMENTS        Retain full-line and end-of-line comments
*
*  The variable MACHINE is set equal to the uppercase name of the machine
*  being processed.  Specific tests upon this variable are discouraged, as
*  all machine-dependent code should be placed in the machine-definition
*  file if possible.
*
*  In addition to the normal MINIMAL register complement, one scratch
*  work register, W0 is defined.
*  See the register map below for specific allocations.
*
*  This program is based in part on earlier translators for the
*  It is based in part on earlier translators for the DEC VAX
*  (VMS and UN*X) written by Steve Duff and Robert Goldberg, and the
*  PC-SPITBOL translator by David Shields.
*
*  To run under Spitbol:
*       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt
*
*	reads <file>.tok	containing tokenized source code
*       writes <file>.s         with 80386 assembly code
*	also writes <file>.err	with ERR and ERB error messages
*	using <machine>.def	to provide machine-specific information
*       parts of <machine>.hdr  are prepended and appended to <file>.s
*	also sets flags		to 1 after converting names to upper case
*	also reads <file>.pub	for debug symbols to be declared public
*
*  Example:
*       spitbol -u v37:dos:compress codlinux.spt
*
*
*  Revision History:
*
        VERSION = 'V1.12'
*
*  V1.00  20-Jul-89
*	Adopted from 68000 version cod368.spt (q.v.)
*
*  V1.01  30-Oct-89
*	Put everything into code segment so as to be at the beginning
*	of the load module, and hence immune from size changes due to changes
*	in C code.
*
*  V1.02  10-Sep-90
*       Clear XR as well as XL after completing CMC and TRC opcodes.
*
*  V1.03  21-Mar-91
*	Moved portions of jump short optimization kludge to <machine>.def
*	file.
*
*  V1.04  12-Jun-91
*	Allow COMMENTS as a command line flag to preserve comments.
*
*  V1.05  08-Aug-91
*	Use SEG1N-SEG9N and SEG1C-SEG9C variables defined in <machine>.DEF
*	to specify segment names and classes respectively.
*
*  V1.06  07-Nov-91
*	Add to C_LABELS.
*
*  V1.07  02-Aug-93
*	Add public label END_MIN_DATA after all the data.
*
*  V1.08  19-Mar-95
*       Use LABFIX on BORLANDC 32-bit version.
*
*  V1.09  12-Oct-95
*       Use LABFIX on BORLANDC 32-bit version for Win NT.
*
*  V1.10 25-Dec-95
*       Changed TERMINAL to OUTPUT for use in Microsoft build program.
*
*  V1.11 28-Mar-96
*       Changed RTI to use carry flag to signal real too large to convert
*       to integer (changed RTI in inter.s as well).
*  V1.12 13-Jun-09
*       Adopted for Linux "as" assembler from codlinux.spt.

*  Note: As an experiment, we tried aligning all ENT and PRC's on
*  a dword boundary, in an attempt to minimize instruction stall time
*  on the first opcode of a procedure.  The resultant EXE file was
*  larger by 592 bytes, and actually ran 0.1% slower.  We will continue
*  to use odd alignment of block entry routines so that the .CEPP
*  conditional may be used.
*
-EJECT
*
*  Keyword initialization
*
	&ANCHOR = 1;	&STLIMIT = 10000000;	&TRIM	= 1;  &DUMP = 1
*
*  Useful constants
*
	LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	UCASE   = LETTERS
	LCASE   = 'abcdefghijklmnopqrstuvwxyz'
	NOS     = '0123456789'
	TAB	= CHAR(9)
*
*  Data structures
*
	DATA('MINARG(I.TYPE,I.TEXT)')
	DATA('TSTMT(T.LABEL,T.OPC,T.OP1,T.OP2,T.OP3,T.COMMENT)')

	SECTNOW = 0
*
*  Function definitions
*
*  CRACK parses STMT into a STMT data plex and returns it.
*  It fails if there is a syntax error.
*
	DEFINE('CRACK(LINE)OPERANDS,OPERAND,CHAR')
*
*	COMREGS - map minimal register names to target register names
	DEFINE('COMREGS(LINE)T,PRE,WORD')
*
*  Error is used to report an error for current statement
*
	DEFINE('ERROR(TEXT)')
	DEFINE('FLUSH()')
	DEFINE('GENAOP(STMT)')
	DEFINE('GENBOP(STMT)')
        DEFINE('GENLAB()')
	DEFINE('GENOP(GOPC,GOP1,GOP2,GOP3)')
	DEFINE('GENOPL(GOPL,GOPC,GOP1,GOP2,GOP3)')
	DEFINE('GETARG(IARG,IACC)L1,L2,T1,T2')
	DEFINE('IFREG(IARG)')
	DEFINE('MEMMEM()T1')
	DEFINE('LABFIX(LABFIX)')
	DEFINE('PRCENT(N)')
	DEFINE('PRSARG(IARG)L1,L2')
	DEFINE('TBLINI(STR)POS,CNT,INDEX,VAL,LASTVAL')

*  OUTSTMT is used to send a target statement to the target code
*  output file OUTFILE
*
	DEFINE('OUTSTMT(OSTMT)LABEL,OPCODE,OP1,OP2,OP3,COMMENT,T,STMTOUT')

*  READLINE is called to return the next non-comment line from
*  the Minimal input file (INFILE <=> LU1).   Note that it will
*  not fail on EOF, but it will return a Minimal END statement
*
	DEFINE('READLINE()')
*
	 P.COMREGS = BREAK(LETTERS) . PRE SPAN(LETTERS) . WORD

*  EXTTAB has entry for external procedures
*
	EXTTAB = TABLE(50)

*  LABTAB records labels in the code section, and their line numbers
*
	LABTAB = TABLE(500)

*  For each statement, code in generated into three
*  arrays of statements:
*
*	ASTMTS:	STATEMENTS AFTER OPCODE (()+, ETC.)
*	BSTMTS: STATEMENTS BEFORE CODE (-(), ETC)
*	CSTMTS: GENERATED CODE PROPER
*
	ASTMTS = ARRAY(20,'')
	BSTMTS = ARRAY(10,'')
	CSTMTS = ARRAY(20,'')
*
*  GENLABELS is count of generated labels (cf. GENLAB)
*
	GENLABELS = 0

*
*  Initialize variables
*
	LABCNT = NOUTLINES = NLINES = NSTMTS = NTARGET = NERRORS = 0
	NOPTIM1 = NOPTIM2 = 0
	LASTOPC = LASTOP1 = LASTOP2 =
	DATA_LC = 0
	MAX_EXI = 0
	TAB = CHAR(9)
	SPAN_WS = SPAN(' ' TAB)
	BREAK_WS = BREAK(' ' TAB)
	ATLINES = 0
*
*  Initial patterns
*
*  P.CSPARSE Parses tokenized line
	P.CSPARSE = '{' BREAK('{') . INLABEL
.	'{' BREAK('{') . INCODE
.	'{' BREAK('{') . IARG1
.	'{' BREAK('{') . IARG2
.	'{' BREAK('{') . IARG3
.	'{' BREAK('{') . INCOMMENT
	'{' REM . SLINENO

*  Dispatch Table
*
	GETARGCASE = TABLE(27)
	GETARGCASE[1] = .GETARG.C.1;   GETARGCASE[2] = .GETARG.C.2
	GETARGCASE[3] = .GETARG.C.3;   GETARGCASE[4] = .GETARG.C.4
	GETARGCASE[5] = .GETARG.C.5;   GETARGCASE[6] = .GETARG.C.6
	GETARGCASE[7] = .GETARG.C.7;   GETARGCASE[8] = .GETARG.C.8
	GETARGCASE[9] = .GETARG.C.9;   GETARGCASE[10] = .GETARG.C.10
	GETARGCASE[11] = .GETARG.C.11; GETARGCASE[12] = .GETARG.C.12
	GETARGCASE[13] = .GETARG.C.13; GETARGCASE[14] = .GETARG.C.14
	GETARGCASE[15] = .GETARG.C.15; GETARGCASE[16] = .GETARG.C.16
	GETARGCASE[17] = .GETARG.C.17; GETARGCASE[18] = .GETARG.C.18
	GETARGCASE[19] = .GETARG.C.19; GETARGCASE[20] = .GETARG.C.20
	GETARGCASE[21] = .GETARG.C.21; GETARGCASE[22] = .GETARG.C.22
	GETARGCASE[23] = .GETARG.C.23; GETARGCASE[24] = .GETARG.C.24
	GETARGCASE[25] = .GETARG.C.25; GETARGCASE[26] = .GETARG.C.26
	GETARGCASE[27] = .GETARG.C.27

*
*  PIFATAL maps MINIMAL opcodes for which no A code allowed
*  to nonzero value. Such operations include conditional
*  branches with operand of form (X)+
*
	PIFATAL = TBLINI(
.	'AOV[1]BEQ[1]BNE[1]BGE[1]BGT[1]BHI[1]BLE[1]BLO[1]'
.	'BLT[1]BNE[1]BNZ[1]CEQ[1]CNE[1]MFI[1]NZB[1]ZRB[1]')
*
*


	IS_EXECUTABLE = TABLE(100)
	s = 
+       'ADD ADI ADR ANB AOV ATN '
+	'BCT BEQ BEV BGE BGT BHI BLE BLO BLT BNE BNZ BOD '
+       'BRN BRI BSW BTW BZE CEQ CHK CHP CMB CMC CMP CNE CSC '
+       'COS CTB CTW CVD CVM DCA DCV ETI DVI DVR ERB ESW ETX EXI FLC '
+       'ICA ICP ICV IEQ IGE IGT ILE ILT INE INO IOV ITR JMP '
+       'JSR LCH LCT LCP LCW LDI LDR LEI LNF LSH LSX MCB MFI MLI MLR '
+       'MNZ MOV MTI MVC MVW MWB NGI ETI NGR NZB ORB PLC PRC PSC '
+       'REQ RGE RGT RLE RLT RMI RNE RNO ROV RSH RSX RTI RTN SBI SBR '
+       'SCH SCP SIN SQR SSL SSS STI STR SUB TAN TRC WTB XOB ZER '
+       'ZGB ZRB'
IS_EXEC.1
	S LEN(3) . OPC ' ' =				:F(IS_EXEC.2)
	IS_EXECUTABLE[OPC] = 1				:(IS_EXEC.1)
IS_EXEC.2

-STITL MAIN PROGRAM
*  Here follows the driver code for the "main" program.

*
*  Loop until program exits via G.END
*
*  OPNEXT is invoked to initiate processing of the next line from
*  READLINE.
*  After doing this, OPNEXT branches to the generator routine indicated
*  for this opcode if there is one.
*  The generators all have entry points beginning
*  with "G.", and can be considered a logical extension of the
*  OPNEXT routine.  The generators have the choice of branching back
*  to DSGEN to cause the THISSTMT plex to be sent to OUTSTMT, or
*  or branching to DSOUT, in which case the generator must output
*  all needed code itself.
*
*  The generators are listed in a separate section below.
*
*
*  Get file name
*
	TRANSDATE = DATE()
        OUTPUT = 'MINIMAL to 80386 Translator'
*
*  Default the parameter string if none present
*
        PARMS = (DIFFER(HOST(0)) HOST(0), "v37:linux:compress")
        OUTPUT = IDENT(PARMS) "Filename (.tok) required" :S(END)

*
* Get machine definition file name following token file name, and flags.
*
	PARMS ? BREAK(';:') . PARMS LEN(1) (BREAK(';:') | REM) . MACHINE
+		((LEN(1) REM . FLAGS) | '')
        OUTPUT = IDENT(MACHINE)
+		"Machine type file (.def) required"	:S(END)
	$REPLACE(MACHINE,LCASE,UCASE) = 1
*
* Parse and display flags, setting each one's name to non-null value (1).
*
FLGS	FLAGS ? ((LEN(1) BREAK(';:')) . FLAG LEN(1)) |
+	 ((LEN(1) REM) . FLAG) =			:F(FLGS2)
	FLAG = REPLACE(FLAG,LCASE,UCASE)
        OUTPUT = "Flag: " FLAG
	$FLAG = 1					:(FLGS)
*
*  Open machine definition file
*
FLGS2	FILENAMD = MACHINE '.def'
	INPUT(.DEFFILE,1,FILENAMD)			:S(DEFOK)
        OUTPUT = "Cannot open machine definition file: " FILENAMD :(END)
*
*  Read in statements, discarding comments and building a long string.
*  Spitbol code in machine definition file may contain one-line
*  statements and comments only.  Continuation lines are not processed
*  by this code (but could be easily handled).
*
DEFOK   OUTPUT = "Machine definition file: " FILENAMD
	DEFS =
DEFLOOP	LINE = DEFFILE					:F(DEFCOMP)
	LINE '*'					:S(DEFLOOP)
	DEFS = DIFFER(LINE) DEFS ';' LINE		:(DEFLOOP)
*
*  Compile the code, and execute it to perform initializations.
*  Returns to label COMPDONE when complete.
*
DEFCOMP	DEFS = CODE(DEFS '; :(COMPDONE)')		:S(COMPOK)
        OUTPUT = "Error compiling definitions file"
        OUTPUT = &ERRTEXT                             :(END)
COMPOK	ENDFILE(1)					:<DEFS>
COMPDONE DEFS =

* Here define things that depend on the DEF file.
*
*
*  Table of labels that must be in a form that allows C functions
*  to access them.  Table is used by LABFIX().
*
*  C.OUT is provided by the MACHINE.DEF file.
*
	C_LABELS = TABLE(37)
          C_LABELS['GBCNT'] = C.OUT 'GBCNT'
          C_LABELS['HEADV'] = C.OUT 'HEADV'
          C_LABELS['MXLEN'] = C.OUT 'MXLEN'
          C_LABELS['STAGE'] = C.OUT 'STAGE'
          C_LABELS['TIMSX'] = C.OUT 'TIMSX'
          C_LABELS['DNAMB'] = C.OUT 'DNAMB'
          C_LABELS['DNAMP'] = C.OUT 'DNAMP'
          C_LABELS['STATE'] = C.OUT 'STATE'
          C_LABELS['B$EFC'] = C.OUT 'B_EFC'
          C_LABELS['B$ICL'] = C.OUT 'B_ICL'
          C_LABELS['B$RCL'] = C.OUT 'B_RCL'
          C_LABELS['B$SCL'] = C.OUT 'B_SCL'
          C_LABELS['B$VCT'] = C.OUT 'B_VCT'
          C_LABELS['B$XNT'] = C.OUT 'B_XNT'
          C_LABELS['B$XRT'] = C.OUT 'B_XRT'
          C_LABELS['STBAS'] = C.OUT 'STBAS'
          C_LABELS['STATB'] = C.OUT 'STATB'
          C_LABELS['POLCT'] = C.OUT 'POLCT'
          C_LABELS['STMCS'] = C.OUT 'STMCS'
          C_LABELS['STMCT'] = C.OUT 'STMCT'
          C_LABELS['TYPET'] = C.OUT 'TYPET'
          C_LABELS['DFFNC'] = C.OUT 'DFFNC'
          C_LABELS['LOWSPMIN'] = C.OUT 'LOWSPMIN'
          C_LABELS['FLPRT'] = C.OUT 'FLPRT'
          C_LABELS['FLPTR'] = C.OUT 'FLPTR'
          C_LABELS['GTCEF'] = C.OUT 'GTCEF'
          C_LABELS['HSHTB'] = C.OUT 'HSHTB'
          C_LABELS['PMHBS'] = C.OUT 'PMHBS'
          C_LABELS['R$FCB'] = C.OUT 'R_FCB'
          C_LABELS['C$AAA'] = C.OUT 'C_AAA'
          C_LABELS['C$YYY'] = C.OUT 'C_YYY'
          C_LABELS['G$AAA'] = C.OUT 'G_AAA'
          C_LABELS['W$YYY'] = C.OUT 'W_YYY'
          C_LABELS['S$AAA'] = C.OUT 'S_AAA'
          C_LABELS['S$YYY'] = C.OUT 'S_YYY'
          C_LABELS['R$COD'] = C.OUT 'R_COD'
          C_LABELS['KVSTN'] = C.OUT 'KVSTN'
          C_LABELS['KVCOM'] = C.OUT 'KVCOM'
          C_LABELS['KVDMP'] = C.OUT 'KVDMP'
          C_LABELS['KVFTR'] = C.OUT 'KVFTR'
          C_LABELS['KVPFL'] = C.OUT 'KVPFL'
          C_LABELS['CSWFL'] = C.OUT 'CSWFL'
          C_LABELS['END$MIN$DATA'] = C.OUT 'END_MIN_DATA'

* Various constants
*
        COMMENT.DELIM = '#'
	LABEL.DELIM   = ':'
*
*
*  BRANCHTAB maps MINIMAL opcodes 'BEQ', etc to desired
*  target instruction
*
	BRANCHTAB = TABLE(10)
	BRANCHTAB['BEQ'] = 'JE'
	BRANCHTAB['BNE'] = 'JNE'
	BRANCHTAB['BGT'] = 'JA'
	BRANCHTAB['BGE'] = 'JAE'
	BRANCHTAB['BLE'] = 'JBE'
	BRANCHTAB['BLT'] = 'JB'
	BRANCHTAB['BLO'] = 'JB'
	BRANCHTAB['BHI'] = 'JA'

*  OPTIM.TAB flags opcodes capable of participating in OR optimization
*		in OUTSTMT routine
*
	OPTIM.TAB = TABLE(10)
	OPTIM.TAB<"AND"> = 1
	OPTIM.TAB<"ADD"> = 1
	OPTIM.TAB<"SUB"> = 1
	OPTIM.TAB<"NEG"> = 1
	OPTIM.TAB<"OR"> = 1
	OPTIM.TAB<"XOR"> = 1
	OPTIM.TAB<"SHR"> = 1
	OPTIM.TAB<"SHL"> = 1
	OPTIM.TAB<"INC"> = 1
	OPTIM.TAB<"DEC"> = 1


*  ISMEM IS TABLE indexed by operand type which is nonzero if
*  operand type implies memory reference.

	ISMEM = ARRAY(30,0)
	ISMEM<3> = 1; ISMEM<4> = 1; ISMEM<5> = 1
	ISMEM<9> = 1; ISMEM<10> = 1; ISMEM<11> = 1
	ISMEM<12> = 1; ISMEM<13> = 1; ISMEM<14> = 1
	ISMEM<15> = 1
*
*  REGMAP maps MINIMAL register name to target machine
*  register/memory-location name.
*
	REGMAP = TABLE(30)
	REGMAP['XL'] = 'ESI';  REGMAP['XT'] = 'ESI'
	REGMAP['XR'] = 'EDI';  REGMAP['XS'] = 'ESP'
	REGMAP['WA'] = 'ECX';  REGMAP['WB'] = 'EBX'
	REGMAP['WC'] = 'EDX';  REGMAP['IA'] = 'EDX'
	REGMAP['CP'] = 'EBP'
*	W0 is temp register
	REGMAP['W0'] = 'EAX'

*  Quick reference:
	REG.IA = REGMAP['IA']
	REG.WA = REGMAP['WA']
	REG.CP = REGMAP['CP']
	W0 = REGMAP['W0']
*  Other definitions that are dependent upon things defined in the
*  machine definition file, and cannot be built until after the definition
*  file has been read in.
*
*  P.OUTSTMT examines output lines for certain types of comment contructions
	FILLC	  = (IDENT(COMPRESS) " ",TAB)
	P.OUTSTMT = (BREAK(FILLC) . LABEL SPAN(FILLC)) . LEADER
+			COMMENT.DELIM REM . COMMENT
	P.ALLTABS = SPAN(TAB) RPOS(0)

*  Strip end of comments if Y
*
	STRIP_COMMENT = (DIFFER(COMMENTS) 'N', 'Y')

	FILENAMI = PARMS '.tok'
        INPUT(.INFILE,1,FILENAMI)                     :S(INPUTOK)
        OUTPUT = 'Cannot open TOKEN file: ' FILENAMI  :(END)
INPUTOK OUTPUT = 'Input TOKEN file: ' FILENAMI
*
*
*
*  Associate output files.  Code is written to a temp file, which
*  will subsequently be rewound and reread for jump optimization.
*
	FILENAMO = PARMS '.tmp'
        OUTPUT(.OUTFILE,2,FILENAMO)                 :S(OUTPUTOK)
        OUTPUT = 'Cannot open TEMP file: ' FILENAMO :(END)
OUTPUTOK
        OUTPUT = 'Output TEMP file: ' FILENAMO

*
* Open file for compilation of Minimal ERR and ERB messages
*
        OUTPUT(.ERRFILE,3, PARMS ".err")             :S(ERR_OK)
        OUTPUT = "Cannot open error message file: " PARMS ".err" :(END)
ERR_OK

* Begin with standard preamble
        OUTSTMT(TSTMT(,'.title','"SPITBOL TRANSLATOR ' REPLACE(PARMS,LCASE,UCASE) '"'))
        OUTSTMT(TSTMT(,'.sbttl','"' REPLACE(PARMS,LCASE,UCASE) '"'))

*  Then copy contents of <machine>.HDR (if it exists) to OUTFILE
*  Stop at line with just 'END' or end of file
*
	OUTFILE = COMMENT.DELIM ' MINIMAL/80386 Translator ' VERSION
+		  ' ' TRANSDATE ' for ' MACHINE
	NOUTLINES = NOUTLINES + 1

	INPUT(.HDRFILE,4,MACHINE '.hdr')	:F(NOHDR)
	HAVEHDR = 1
        OUTPUT = 'Input HEADER file: ' MACHINE '.hdr'
HDRCOPY LINE = HDRFILE				:F(HDREND)
	IDENT(LINE,'END')			:S(NOHDR)
	OUTFILE = LINE
	NOUTLINES = NOUTLINES + 1		:(HDRCOPY)
HDREND	HAVEHDR =
NOHDR
*
*  Will have HAVEHDR non-null if more remains to copy out at end.
*
*  Read in PUB file if it exists.  This contains a list of symbols to
*  be declared public when encountered.
*
	PUBTAB = TABLE(2)
	INPUT(.PUBFILE,5, PARMS ".pub")		:F(NOPUB)
	PUBTAB = TABLE(101)
PUBCOPY	LINE = PUBFILE				:F(PUBEND)
	PUBTAB[LINE] = 1			:(PUBCOPY)
PUBEND	ENDFILE(5)
NOPUB

						:(DSOUT)
  &TRACE = 2000
  &FTRACE = 1000
*  &PROFILE = 1
DSOUT
OPNEXT	THISLINE = READLINE()
	CRACK(THISLINE)				:F(DSOUT)
*
* Append LABEL.DELIM after label if in code or data.
*
        TLABEL = LABFIX(INLABEL) (DIFFER(INLABEL) GE(SECTNOW,3) LABEL.DELIM, )
	I1 = PRSARG(IARG1)
	I2 = PRSARG(IARG2)
	I3 = PRSARG(IARG3)
	TCOMMENT = COMREGS(INCOMMENT) '} ' INCODE ' ' I.TEXT(I1) ' '
.		I.TEXT(I2) ' ' I.TEXT(I3)
	ARGERRS = 0
						:($('G.' INCODE))
*  Here if bad opcode
DS01	ERROR('BAD OP-CODE')			:(DSOUT)

*  GENERATE TOKENS.
*
DS.TYPERR
	ERROR('OPERAND TYPE ZERO')		:(DSOUT)
-STITL COMREGS(LINE)T,PRE,WORD
COMREGS
	LINE P.COMREGS =			:F(COMREGS1)
	WORD = EQ(SIZE(WORD),2) DIFFER(T = REGMAP[WORD]) T
	COMREGS = COMREGS PRE WORD		:(COMREGS)
COMREGS1 COMREGS = COMREGS LINE			:(RETURN)
-STITL CRACK(LINE)
*  CRACK is called to create a STMT plex containing the various
*  entrails of the Minimal Source statement in LINE.  For
*  conditional assembly ops, the opcode is the op, and OP1
*  is the symbol.  Note that DTC is handled as a special case to
*  assure that the decomposition is correct.
*
*  CRACK will print an error and fail if a syntax error occurs.
*
CRACK   NSTMTS  = NSTMTS + 1
	OP1 = OP2 = OP3 = TYP1 = TYP2 = TYP3 =
	LINE    P.CSPARSE			:S(RETURN)
*  Here on syntax error
*
	ERROR('SOURCE LINE SYNTAX ERROR')	:(FRETURN)
-STITL ERROR(TEXT)
*  This module handles reporting of errors with the offending
*  statement text in THISLINE.  Comments explaining
*  the error are written to the listing (including error chain), and
*  the appropriate counts are updated.
*
ERROR   OUTFILE = '* *???* ' THISLINE
	OUTFILE = '*       ' TEXT
.	          (IDENT(LASTERROR),'. LAST ERROR WAS LINE ' LASTERROR)
	LASTERROR = NOUTLINES
	NOUTLINES = NOUTLINES + 2
	LE(NERRORS = NERRORS + 1, 10)		:S(DSOUT)
        OUTPUT = 'Too many errors, quitting'  :(END)
-STITL GENAOP(STMT)
GENAOP
	ASTMTS[ASTMTS.N = ASTMTS.N + 1] = STMT	:(RETURN)
-STITL GENBOP(STMT)
GENBOP
	BSTMTS[BSTMTS.N = BSTMTS.N + 1] = STMT	:(RETURN)

-STITL GENLAB()
*  Generate unique labels for use in generated code
GENLAB	GENLAB = 'L' LPAD(GENLABELS = GENLABELS + 1,4,'0') :(RETURN)

-STITL GENOPL(GOPL,GOPC,GOP1,GOP2,GOP3)
*  Generate operation with label
GENOPL	CSTMTS[CSTMTS.N = CSTMTS.N + 1] =
.		TSTMT(GOPL,GOPC,GOP1,GOP2,GOP3)		:(RETURN)

-STITL GENOP(GOPC,GOP1,GOP2,GOP3)
*  Generate operation with no label
GENOP   GENOPL(,GOPC,GOP1,GOP2,GOP3)            :(RETURN)

-STITL LABFIX(LABFIX)
*  Perform substitution for a few labels that must be in a
*  form that allows C functions to access them.
*
*
LABFIX  LABFIX = DIFFER(C.OUT)
+	 DIFFER(C_LABELS[LABFIX]) C_LABELS[LABFIX] :(RETURN)


-STITL GETARG(IARG,IACC)
GETARG	L1 = I.TEXT(IARG)
	L2 = I.TYPE(IARG)
	EQ(L2)					:F($(GETARGCASE[L2]))
	GETARG = LABFIX(L1)			:(RETURN)

* INT
GETARG.C.1 GETARG = L1				:(RETURN)

* DLBL
GETARG.C.2 GETARG = LABFIX(L1)			:(RETURN)

* WLBL, CLBL
GETARG.C.3
GETARG.C.4 GETARG = 'DWORD PTR ' LABFIX(L1)     :(RETURN)

* ELBL, PLBL
GETARG.C.5
GETARG.C.6 GETARG = LABFIX(L1)			:(RETURN)

* W,X, Map register name
GETARG.C.7
GETARG.C.8
	GETARG = REGMAP[L1]			:(RETURN)

* (X), Register indirect
GETARG.C.9
	L1 LEN(1) LEN(2) . L2
	L2 = REGMAP[L2]
	GETARG = 'DWORD PTR [' L2 ']'		:(RETURN)

* (X)+, Register indirect, post increment
* Use lea reg,[reg+4] unless reg is esp, since it takes an extra byte.
* Actually, lea reg,[reg+4] and add reg,4 are both 2 cycles and 3 bytes
* for all the other regs, and either could be used.
GETARG.C.10
	L1 = SUBSTR(L1,2,2)
	T1 = REGMAP[L1]
	GETARG = 'DWORD PTR [' T1 ']'
	(IDENT(L1,'XS') GENAOP(TSTMT(,'ADD',T1,'4'))) :S(RETURN)
	GENAOP(TSTMT(,'LEA',T1,'[' T1 '+4]'))	:(RETURN)

*  -(X), Register indirect, pre decrement
GETARG.C.11
	T1 = REGMAP[SUBSTR(L1,3,2)]
	GETARG = 'DWORD PTR [' T1 ']'
	GENBOP(TSTMT(,'LEA',T1,'[' T1 '-4]'))	:(RETURN)

* INT(X)
* DLBL(X)
GETARG.C.12
GETARG.C.13
	L1 BREAK('(') . T1 '(' LEN(2) . T2
	GETARG = 'DWORD PTR (4*' LABFIX(T1) ')[' REGMAP[T2] ']'	:(RETURN)

*  NAME(X), WHERE NAME IS IN WORKING SECTION
GETARG.C.14
GETARG.C.15
	L1 BREAK('(') . T1 '(' LEN(2) . T2
	GETARG = LABFIX(T1) '[' REGMAP[T2] ']'	:(RETURN)

* Signed Integer
GETARG.C.16 GETARG = L1				:(RETURN)

* Signed Real
GETARG.C.17 GETARG = L1				:(RETURN)

*  =DLBL
GETARG.C.18
	GETARG = LABFIX(SUBSTR(L1,2))		:(RETURN)

*  *DLBL
GETARG.C.19
	GETARG = '4*' LABFIX(SUBSTR(L1,2))	:(RETURN)

*  =NAME (Data section)
GETARG.C.20
GETARG.C.21
        GETARG = 'offset ' LABFIX(SUBSTR(L1,2)) :(RETURN)

*  =NAME (Program section)
GETARG.C.22
        GETARG = 'offset ' LABFIX(SUBSTR(L1,2))  :(RETURN)

*  PNAM, EQOP
GETARG.C.23
GETARG.C.24 GETARG = LABFIX(L1)			:(RETURN)

* PTYP, TEXT, DTEXT
GETARG.C.25
GETARG.C.26
GETARG.C.27 GETARG = L1				:(RETURN)

-STITL MEMMEM()T1
MEMMEM
*  MEMMEM is called for those ops for which both operands may be
*  in memory, in which case, we generate code to load first operand
*  to pseudo-register 'W0', and then modify the first argument
*  to reference this register
*
  EQ(ISMEM[I.TYPE(I1)])				:S(RETURN)
  EQ(ISMEM[I.TYPE(I2)])				:S(RETURN)
*  here if memory-memory case, load first argument
  T1 = GETARG(I1)
  I1 = MINARG(8,'W0')
  GENOP('MOV','EAX',T1)				:(RETURN)

-STITL PRCENT(N)
PRCENT PRCENT = LABFIX('PRC$') '+'  (4 * ( N - 1)) :(RETURN)

-STITL OUTSTMT(OSTMT)LABEL,OPCODE,OP1,OP2,OP3,COMMENT)
*  This module writes the components of the statement
*  passed in the argument list to the formatted .s file
*
OUTSTMT	LABEL = T.LABEL(OSTMT)
*  attach source label to first generated instruction
	DIFFER(LABEL)				:S(OUTSTMT1)
	IDENT(TLABEL)				:S(OUTSTMT1)
	LABEL = TLABEL; TLABEL =

OUTSTMT1
	COMMENT = T.COMMENT(OSTMT)
*  attach source comment to first generated instruction
	DIFFER(COMMENT)				:S(OUTSTMT2)
	IDENT(TCOMMENT)				:S(OUTSTMT2)
	COMMENT = TCOMMENT; TCOMMENT =
OUTSTMT2
	OPCODE = T.OPC(OSTMT)
	OPCODE.SAVE = OPCODE
	OP1 = T.OP1(OSTMT)
	OP2 = T.OP2(OSTMT)
	OP3 = T.OP3(OSTMT)
	DIFFER(COMPRESS)			:S(OUTSTMT6)
	STMTOUT = RPAD( RPAD(LABEL,7) ' ' RPAD(OPCODE,4) ' '
.		  (IDENT(OP1), OP1
.			(IDENT(OP2), ',' OP2
.				(IDENT(OP3), ',' OP3))) ,27)
.       (IDENT(STRIP_COMMENT,'Y'), ' ' (IDENT(COMMENT), '#') COMMENT)
.						:(OUTSTMT7)
OUTSTMT6
	STMTOUT = LABEL TAB OPCODE TAB
.		  (IDENT(OP1), OP1
.		    (IDENT(OP2), ',' OP2
.		      (IDENT(OP3), ',' OP3)))
.       (IDENT(STRIP_COMMENT,'Y'), TAB (IDENT(COMMENT), '#') COMMENT)
*
**	Send text to OUTFILE
*
**
**  Here is the Peephole Optimizer
**
*   Optimization if:
*	1) This statement is not labeled
*   and	2) This opcode is OR OP1,OP1 or CMP OP1,0
*   and 3) Last opcode was AND, ADD, SUB, NEG, OR, XOR, SHR, SHL, INC or DEC.
*   and	4) Last OP1 = current OP1
*
* DS 9/9/12 Bypass this whilst tracint
	:(OUTSTMT4)
OUTSTMT7 (
.	IDENT(LABEL)
.	  (IDENT(OPCODE,"OR") IDENT(OP1,OP2),
.	   IDENT(OPCODE,"CMP") IDENT(OP2,"0"))
.	      DIFFER(OPTIM.TAB<LASTOPC>)
.	        IDENT(LASTOP1,OP1)
.		)				:F(OUTSTMT4)
*
*  Criteria satisfied.  Make current line into a comment.
*
	STMTOUT = COMMENT.DELIM STMTOUT FILLC "(Optimized)"
	NOPTIM1 = NOPTIM1 + 1
*
*  Record this statement's components for next time
*
OUTSTMT4
	LASTOPC = OPCODE
	LASTOP1 = OP1
	LASTOP2 = OP2
**
**	Send text to output file if not null.
*
	STMTOUT = REPLACE(TRIM(STMTOUT),'$','_')
	IDENT(STMTOUT)				:S(RETURN)

	IDENT(LABEL)				:S(OUTSTMT5)
*	OUTPUT = '*CHECK ' STMTOUT
*	OUTPUT = '*CHECK LABEL ' LABEL ' OPCODE ' OPCODE
	TRACING = IDENT(LABEL,'S$AAA:') 1      
*	Turn off tracing for GTNUM procedure due to embedded loop
	TRACING = IDENT(LABEL,'GTN01:') 
	TRACING = IDENT(LABEL,'GTN14:') 1

  :(OUTSTMT5)
	IDENT(IS_EXECUTABLE[OPCODE])				:S(OUTSTMT5)
	IDENT(TRACING)						:S(OUTSTMT5)
	NE(SECTNOW,5)						:S(OUTSTMT5)
*	OUTPUT = '*TRACE ' STMTOUT
*  Statement has label, so emit trace code.
	STMTOUT ? BREAK_WS  . LABEL SPANWS  REM . BODY	:F(OUTSTMT5)
	STMTOUT = TAB BODY
*	OUTPUT = '* AFTER ' STMTOUT
	OUTFILE = LABEL
	LABEL =
*	Emit trace code if desired
*	Emit extern declaration before firsr use of 'atlin'
	NE(ATLINES)				:S(OUTSTMT4A)
*	OUTFILE = '  .extern atlin'
OUTSTMT4A
	ATLINES = ATLINES + 1
	OUTFILE = '  MOV DWORD PTR  nlines,'   NLINES tab '# @: ' ATLINES
	OUTFILE = '  CALL  atlin'

OUTSTMT5
	OUTFILE = STMTOUT
	NTARGET	= NTARGET + 1
	NOUTLINES = NOUTLINES + 1

*
*  Record code labels in table with delimiter removed.
	(GE(SECTNOW,5) DIFFER(LABEL))		:F(RETURN)
	LABEL ? BREAK(LABEL.DELIM) . LABEL	:F(RETURN)
	LABTAB<LABEL> = NOUTLINES		:(RETURN)

-STITL PRSARG(IARG)
PRSARG	PRSARG = MINARG(0)
	IARG BREAK(',') . L1 ',' REM . L2	:F(RETURN)
	PRSARG = MINARG(CONVERT(L1,'INTEGER'),L2)	:(RETURN)
-STITL READLINE()
*  This routine returns the next statement line in the input file
*  to the caller.  It never fails.  If there is no more input,
*  then a Minimal END statement is returned.
*  Comments are passed through to the output file directly.
*
*
READLINE READLINE = INFILE                      :F(RL02)
	NLINES  = NLINES + 1
	IDENT( READLINE )			:S(READLINE)
	LEQ( SUBSTR( READLINE,1,1 ),'*' )       :F(RL01)
*
*  Only print comment if requested.
*
	IDENT(STRIP_COMMENT,'N')		:F(READLINE)
        READLINE LEN(1) = '#'
	OUTFILE = READLINE
	NOUTLINES = NOUTLINES + 1               :(READLINE)
*
*  Here if not a comment line
*
RL01						:(RETURN)
*
*  Here on EOF
*
RL02    READLINE = '       END'
						:(RL01)
-STITL TBLINI(STR)
*  This routine is called to initialize a table from a string of
*  index/value pairs.
*
TBLINI   POS     = 0
*
*  Count the number of "[" symbols to get an assessment of the table
*  size we need.
*
TIN01   STR     (TAB(*POS) '[' BREAK(']') *?(CNT = CNT + 1) @POS)
.						:S(TIN01)
*
*  Allocate the table, and then fill it. Note that a small memory
*  optimisation is attempted here by trying to re-use the previous
*  value string if it is the same as the present one.
*
	TBLINI   = TABLE(CNT)
TIN02   STR     (BREAK('[') $ INDEX LEN(1) BREAK(']') $ VAL LEN(1)) =
.						:F(RETURN)
	VAL     = CONVERT( VAL,'INTEGER' )
	VAL     = IDENT(VAL,LASTVAL) LASTVAL
	LASTVAL = VAL
	TBLINI[INDEX] = VAL			:(TIN02)
-STITL Generators

IFREG	GE(I.TYPE(IARG),7) LE(I.TYPE(IARG),8)
.						:F(FRETURN)S(RETURN)

G.FLC
	T1 = SUBSTR(GETARG(I1),2,1) 'L'
	T2 = GENLAB()
	GENOP('CMP',T1,"'a'")
	GENOP('JB','SHORT ' T2)
	GENOP('CMP',T1,"'z'")
	GENOP('JA','SHORT ' T2)
	GENOP('SUB',T1,'32')
        GENOPL(T2 LABEL.DELIM)                  :(OPDONE)

G.MOV
*  perhaps change MOV X,(XR)+ to
*	mov ax,X; STOWS
*
*  Perhaps do  MOV (XL)+,Wx as
*	lodsw
*	xchg ax,Tx
*  and also MOV (XL)+,NAME as
*	lodsw
*	mov NAME,EAX
*  NEED TO PROCESS MEMORY-MEMORY CASE
*  CHANGE 'MOV (XS)+,A' TO 'POP A'
*  CHANGE 'MOV A,-(XS)' TO 'PUSH A'
	T1 = I.TEXT(I1); T2 = I.TEXT(I2)
	IDENT(T1,'(XL)+')			:S(MOV.XLP)
	IDENT(T1,'(XT)+')			:S(MOV.XTP)
	IDENT(T1,'(XS)+')			:S(MOV.XSP)
	IDENT(T2,'(XR)+')			:S(MOV.XRP)
	IDENT(T2,'-(XS)')			:S(MOV.2)
	MEMMEM()
	GENOP('MOV',GETARG(I2),GETARG(I1))
						:(OPDONE)
MOV.XTP
MOV.XLP
	IDENT(T2,'(XR)+') GENOP('MOVSD')	:S(OPDONE)
	GENOP('LODSD')
	IDENT(T2,'-(XS)') GENOP('PUSH','EAX')	:S(OPDONE)
	GENOP('MOV',GETARG(I2),'EAX')		:(OPDONE)
MOV.XSP
	IDENT(I.TEXT(I2),'(XR)+')		:S(MOV.XSPRP)
	GENOP('POP',GETARG(I2))			:(OPDONE)
MOV.XSPRP GENOP('POP','EAX')
	GENOP('STOSD')				:(OPDONE)
MOV.XRP GENOP('MOV','EAX',GETARG(I1))
	GENOP('STOSD')				:(OPDONE)
MOV.2
	GENOP('PUSH',GETARG(I1))		:(OPDONE)

* Odd/Even tests.  If W reg, use low byte of register.
G.BOD	T1 = GETARG(I1)
	T1 = EQ(I.TYPE(I1),8) SUBSTR(T1,2,1) 'L'
	GENOP('TEST',T1,'1')
	GENOP('JNE',GETARG(I2))			:(OPDONE)

G.BEV	T1 = GETARG(I1)
	T1 = EQ(I.TYPE(I1),8) SUBSTR(T1,2,1) 'L'
	GENOP('TEST',T1,'1')
	GENOP('JE',GETARG(I2))			:(OPDONE)

G.BRN   GENOP('JMP',GETARG(I1))			:(OPDONE)

G.BSW	T1 = GETARG(I1)
	T2 = GENLAB()
	IDENT(I.TEXT(I3))			:S(G.BSW1)
	GENOP('CMP',T1,GETARG(I2))
	GENOP('JGE',GETARG(I3))
* Here after default case.
G.BSW1	GENOP('JMP', 'DWORD PTR ' T2 '[' T1 '*4]')
        GENOP('DSeg_')
        GENOPL(T2 LABEL.DELIM)                  :(OPDONE)

G.IFF   GENOP('.long',GETARG(I2))               :(OPDONE)

G.ESW   GENOP('DSegEnd_')
        GENOP('CSeg_')                          :(OPDONE)

G.ENT
*
*  Entry points are stored in byte before program entry label
*  last arg is optional, in which case no initial '.byte' need be
*  issued. We force odd alignment so can distinguish entry point
*  addresses from block addresses (which are always even).
*
*  Note that this address of odd/even is less restrictive than
*  the MINIMAL definition, which defines an even address as being
*  a multiple of CFP$B (4), and an odd address as one that is not
*  a multiple of CFP$B (ends in 1, 2, or 3).  The definition here
*  is a simple odd/even, least significant bit definition.
*  That is, for us, 1 and 3 are odd, 2 and 4 are even.
*
	T1 = I.TEXT(I1)
        GENOP('.balign',2)
        (DIFFER(T1) GENOP('.byte',T1), GENOP('NOP'))
	GENOP()
*  Note that want to attach label to last instruction
	T1 = CSTMTS[CSTMTS.N]
	T.LABEL(T1) = TLABEL
	CSTMTS[CSTMTS.N] = T1
*  Here to see if want label made public
	TLABEL ? RTAB(1) . TLABEL LABEL.DELIM
        (DIFFER(PUBTAB[TLABEL]), DIFFER(DEBUG)) GENOP('.global',TLABEL)
	TLABEL =				:(OPDONE)

G.BRI	GENOP('JMP',GETARG(I1))			:(OPDONE)

G.LEI	T1 = REGMAP[I.TEXT(I1)]
	GENOP('MOVZX',T1,'BYTE PTR [' T1 '-1]')	:(OPDONE)

G.JSR	GENOP('CALL',GETARG(I1))		:(OPDONE)

G.PPM
*  Last arg is optional. generate two bytes
	IDENT(I.TEXT(I1))			:S(G.PPM1)
        GENOP('.short',GETARG(I1) '-' LABFIX('DFFNC'))        :(OPDONE)
G.PPM1
*  A PPM with no arguments, which should never be executed, is
*  translated to ERR 299,Internal logic error: Unexpected PPM branch
	T1 = 299
	ERRFILE =  T1 ' Internal logic error: Unexpected PPM branch'
						:(G.ERR1)

G.PRC
*	Generate PUBLIC declaration and then generate label again
	T1 = TLABEL
	T1 ? RTAB(1) . T1 LABEL.DELIM
	GENOP()
        GENOP('.global',T1)
	PRC.ARGS = GETARG(I2)
	MAX_EXI = GT(PRC.ARGS,MAX_EXI) PRC.ARGS
	PRC.TYPE = I.TEXT(I1)		:($('G.PRC.' PRC.TYPE))
G.PRC.E
G.PRC.R						:(OPDONE)

G.PRC.N
*  Store return address in reserved location
	PRC.COUNT = PRC.COUNT + 1
	GENOP('POP',PRCENT(PRC.COUNT))		:(OPDONE)

G.EXI	T1 = GETARG(I1); T2 = PRC.TYPE; T3 = I.TEXT(I1)
	IDENT(T2,'N')				:S(G.EXIN)
*  Here if R OR E, with return address on stack.
	IDENT(T3) EQ(PRC.ARGS) GENOP('RET')	:S(OPDONE)
	DIFFER(T3)				:S(G.EXIRE)
*  Here if normal return.
	GENOP('POP','EAX')
G.EXIR0	GE(PRC.ARGS,1) GENOP('LEA','EAX','[EAX+' 2 * PRC.ARGS ']')
	GENOP('JMP','EAX')			:(OPDONE)
G.EXIRE;* HERE IF ERROR RETURN
	GENOP('POP','EAX')
G.EXIR1	GENOP('JMP','EXI__' T1)			:(OPDONE)
G.EXIN;* HERE IF N TYPE PROCEDURE
	DIFFER(T3)				:S(G.EXINE)
*  Here if normal N return.  If no args, we can jump
*  directly through the return link cell.
	(EQ(PRC.ARGS,0) GENOP('JMP', '[' PRCENT(PRC.COUNT) ']')) :S(OPDONE)
	GENOP('MOV','EAX', PRCENT(PRC.COUNT))	:(G.EXIR0)
G.EXINE;* HERE IF ERROR RETURN FROM N PROCEDURE
	GENOP('MOV','EAX',PRCENT(PRC.COUNT))	:(G.EXIR1)

G.ENP   GENOP()					:(OPDONE)

G.ERR
*  ASSUME AX IS ZERO, THEN ERR NNN,TEXT IS TRANSLATED TO
*       .long  ERR-NNN
*  and will be branched through indirectly
*  where the sequence of instructions
*	INC EAX
*	INC EAX
*  ERR	MOV	WA,EAX
*	JMP	SEC07
*  is defined elsewhere.
*  Remove '0' prefix from T1 so it's not perceived as an octal constant by assembler.
	ERRFILE =  I.TEXT(I1) ' ' I.TEXT(I2)
	T1 = GETARG(I1)
G.ERR1	MAX.ERR = GT(T1,MAX.ERR) T1
        GENOP('.short',LABFIX('ERR$') '-' +T1 '-' LABFIX('DFFNC')) :(OPDONE)

G.ERB	ERRFILE =  I.TEXT(I1) ' ' I.TEXT(I2)
	T1 = GETARG(I1)
	MAX.ERR = GT(T1,MAX.ERR) T1
	GENOP('CALL','ERR_' (LT(T1,256) '0','1'))
        GENOP('.byte',(LT(T1,256) +T1,T1 - 256)) :(OPDONE)


G.ICV   GENOP('INC',GETARG(I1))    :(OPDONE)
G.DCV   GENOP('DEC',GETARG(I1))    :(OPDONE)

G.ZER	IDENT(I.TEXT(I1),'(XR)+') GENOP('XOR','EAX','EAX')
+		GENOP('STOSD')			:S(OPDONE)
	IFREG(I1)				:S(G.ZER1)
	IDENT(I.TEXT(I1),'-(XS)')		:S(G.ZER.XS)
	GENOP('XOR','EAX','EAX')
	GENOP('MOV',GETARG(I1),'EAX')		:(OPDONE)
G.ZER1	T1 = GETARG(I1)
	GENOP('XOR',T1,T1)			:(OPDONE)
G.ZER.XS GENOP('PUSH','0')			:(OPDONE)

G.MNZ   GENOP('MOV',GETARG(I1),'ESP')		:(OPDONE)

G.SSL   GENOP()					:(OPDONE)
G.SSS   GENOP()					:(OPDONE)

G.RTN
*	Generate PUBLIC declaration and then regenerate label
	T1 = TLABEL
	T1 ? RTAB(1) . T1 LABEL.DELIM
	GENOP()
        GENOP('.global',T1)                     :(OPDONE)

G.ADD	MEMMEM()
	GENOP('ADD',GETARG(I2),GETARG(I1))	:(OPDONE)

G.SUB	MEMMEM()
	GENOP('SUB',GETARG(I2),GETARG(I1))	:(OPDONE)

G.ICA   GENOP('ADD',GETARG(I1),'4')		:(OPDONE)
G.DCA   GENOP('SUB',GETARG(I1),'4')		:(OPDONE)

G.BEQ
G.BNE
G.BGT
G.BGE
G.BLT
G.BLE
G.BLO
G.BHI
*
*  These operators all have two operands, MEMMEM may apply
*  Issue target opcode by table lookup.
*
	MEMMEM()
	T1 = BRANCHTAB[INCODE]
	GENOP('CMP',GETARG(I1),GETARG(I2))
	GENOP(BRANCHTAB[INCODE],GETARG(I3))
.						:(OPDONE)

G.BNZ
	IFREG(I1)				:S(G.BNZ1)
        GENOP('CMP','DWORD PTR ' GETARG(I1),'0')
	GENOP('JNZ',GETARG(I2))			:(OPDONE)
G.BNZ1	GENOP('OR',GETARG(I1),GETARG(I1))
	GENOP('JNZ',GETARG(I2))			:(OPDONE)

G.BZE   IFREG(I1)				:S(G.BZE1)
        GENOP('CMP','DWORD PTR ' GETARG(I1),'0')
	GENOP('JZ',GETARG(I2))			:(OPDONE)
G.BZE1
	T1 = GETARG(I1)
	GENOP('OR',T1,T1)
	GENOP('JZ',GETARG(I2))			:(OPDONE)

G.LCT
*
*  If operands differ must emit code
*
	DIFFER(I.TEXT(I1),I.TEXT(I2))		:S(G.LCT.1)
*  Here if operands same. Emit no code if no label, else emit null
	IDENT(TLABEL)				:S(OPNEXT)
	GENOP()					:(OPDONE)

G.LCT.1	GENOP('MOV',GETARG(I1),GETARG(I2))	:(OPDONE)

G.BCT
*  Can issue LOOP if target register is CX.
	T1 = GETARG(I1)
	T2 = GETARG(I2)
	IDENT(T1,'ECX')				:S(G.BCT1)
G.BCT2	GENOP('DEC',T1)
	GENOP('JNZ',T2)				:(OPDONE)
G.BCT1	GENOP('LOOP',T2)			:(OPDONE)

G.AOV   GENOP('ADD',GETARG(I2),GETARG(I1))
	GENOP('JC',GETARG(I3))			:(OPDONE)
G.LCP
*  Use CP for code pointer.
	GENOP('MOV',REG.CP,GETARG(I1))		:(OPDONE)
G.SCP   GENOP('MOV',GETARG(I1),REG.CP)		:(OPDONE)
G.LCW
*  Should be able to get LODSD; XCHG EAX,GETARG(I1)
	GENOP('MOV',GETARG(I1),'[' REG.CP ']')
	GENOP('ADD',REG.CP,'4')			:(OPDONE)


G.ICP   GENOP('ADD',REG.CP,'4')			:(OPDONE)

*  INTEGER ACCUMULATOR KEPT IN WDX (WC)
G.LDI	GENOP('MOV',REG.IA,GETARG(I1))		:(OPDONE)

G.ADI   GENOP('ADD',REG.IA,GETARG(I1))		:(OPDONE)

G.MLI	GENOP('IMUL',REG.IA,GETARG(I1))		:(OPDONE)

G.SBI   GENOP('SUB',REG.IA,GETARG(I1))		:(OPDONE)

G.DVI
G.RMI
*	Move argument to EAX, call procedure
	GENOP('MOV','EAX',GETARG(I1))
	GENOP('CALL', INCODE '_')	:(OPDONE)

G.STI   GENOP('MOV',GETARG(I1),REG.IA)		:(OPDONE)

G.NGI   GENOP('NEG',REG.IA)			:(OPDONE)

G.INO   GENOP('JNO',GETARG(I1))			:(OPDONE)
G.IOV   GENOP('JO',GETARG(I1))			:(OPDONE)

G.IEQ	GENOP('OR',REG.IA,REG.IA)
	GENOP('JE',GETARG(I1))			:(OPDONE)
G.IGE   GENOP('OR',REG.IA,REG.IA)
	GENOP('JGE',GETARG(I1))			:(OPDONE)
G.IGT   GENOP('OR',REG.IA,REG.IA)
	GENOP('JG',GETARG(I1))			:(OPDONE)
G.ILE   GENOP('OR',REG.IA,REG.IA)
	GENOP('JLE',GETARG(I1))			:(OPDONE)
G.ILT   GENOP('OR',REG.IA,REG.IA)
	GENOP('JL',GETARG(I1))			:(OPDONE)
G.INE   GENOP('OR',REG.IA,REG.IA)
	GENOP('JNE',GETARG(I1))			:(OPDONE)



*
*  Real operations
*
G.ITR	GENOP('CALL','ITR_')	:(OPDONE)

G.RTI	GENOP('CALL','RTI_')
	EQ(I.TYPE(I1))				:S(OPDONE)
*  HERE IF LABEL GIVEN, BRANCH IF REAL TOO LARGE
        GENOP('JC',GETARG(I1))                 :(OPDONE)

G.LDR
G.STR
G.ADR
G.SBR
G.MLR
G.DVR	T1 = I.TYPE(I1)
	(GE(T1,9) LE(T1,15) GENOP('LEA','EAX',GETARG(I1)),
+               GENOP('MOV','EAX','offset ' GETARG(I1)))
	GENOP('CALL',INCODE '_')		:(OPDONE)

G.NGR
G.ATN
G.CHP
G.COS
G.ETX
G.LNF
G.SIN
G.SQR
G.TAN	GENOP('CALL',INCODE '_')		:(OPDONE)


G.RNO	T1 = 'JNO'				:(G.ROV1)
G.ROV	T1 = 'JO'
G.ROV1  GENOP('CALL','OVR_')
	GENOP(T1,GETARG(I1))			:(OPDONE)

G.REQ	T1 = 'JE'				:(G.R1)
G.RNE	T1 = 'JNE'				:(G.R1)
G.RGE	T1 = 'JGE'				:(G.R1)
G.RGT	T1 = 'JG'				:(G.R1)
G.RLE	T1 = 'JLE'				:(G.R1)
G.RLT	T1 = 'JL'
G.R1	GENOP('CALL','CPR_')
	GENOP(T1,GETARG(I1))			:(OPDONE)

G.PLC
G.PSC
*  Last arg is optinal.  If present and a register or constant,
*  use lea instead.

	T1 = GETARG(I1)
	T2 = I.TYPE(I2)
	((IFREG(I2), GE(T2,1) LE(T2,2))
+	GENOP('LEA',T1,'[CFP$F+' T1 '+' GETARG(I2) ']')) :S(OPDONE)
	GENOP('ADD',T1,'CFP$F')
	EQ(I.TYPE(I2))				:S(OPDONE)
*
*  Here if offset given (in a variable), so add it in.
*
	GENOP('ADD',T1,GETARG(I2))		:(OPDONE)
*
*  LCH requires separate cases for each first operand possibility.
*
G.LCH
	T2 = I.TEXT(I2)
	T1 = GETARG(I1)

*  See if predecrement.
	LEQ('-',SUBSTR(T2,1,1))			:F(G.LCG.1)
	T2 BREAK('(') LEN(1) LEN(2) . T3
	GENOP('DEC',REGMAP[T3])
G.LCG.1
	T2 BREAK('(') LEN(1) LEN(2) . T3
	GENOP('MOVZX',T1,'BYTE PTR [' REGMAP[T3] ']')

*  SEE IF POSTINCREMENT NEEDED
	T2 RTAB(1) '+'				:F(G.LCG.2)
	GENOP('INC',REGMAP[T3])
G.LCG.2						:(OPDONE)

G.SCH
	T2 = I.TEXT(I2)
	EQ(I.TYPE(I1),8)			:S(G.SCG.W)
	T1 = GETARG(I1)
	IDENT(T2,'(XR)+')			:F(G.SCG.0)
*
*  Here if can use STOSB.
*
	GENOP('MOV','AL',GETARG(I1))
	GENOP('STOSB')				:(OPDONE)

G.SCG.0
	LEQ('-',SUBSTR(T2,1,1))			:F(G.SCG.1)
	T2 BREAK('(') LEN(1) LEN(2) . T3
	GENOP('DEC',REGMAP[T3])
G.SCG.1
	T2 BREAK('(') LEN(1) LEN(2) . T3
	GENOP('MOV','EAX',T1,)
	GENOP('MOV','[' REGMAP[T3] ']','AL')
*  See if postincrement needed.
	T2 RTAB(1) '+'				:F(G.SCG.2)
	GENOP('INC',REGMAP[T3])
G.SCG.2						:(OPDONE)
G.SCG.W
*
*  Here if moving character from work register, convert T1
*  to name of low part.
*
	T1 = SUBSTR(REGMAP[I.TEXT(I1)],2,1) 'L'
	IDENT(T2,'(XL)')			:S(G.SCG.W.XL)
	IDENT(T2,'-(XL)')			:S(G.SCG.W.PXL)
	IDENT(T2,'(XL)+')			:S(G.SCG.W.XLP)
	IDENT(T2,'(XR)')			:S(G.SCG.W.XR)
	IDENT(T2,'-(XR)')			:S(G.SCG.W.PXR)
	IDENT(T2,'(XR)+')			:S(G.SCG.W.XRP)
G.SCG.W.XL
	GENOP('MOV','[ESI]',T1)			:(OPDONE)
G.SCG.W.PXL
	GENOP('DEC','ESI')
	GENOP('MOV','[ESI]',T1)			:(OPDONE)
G.SCG.W.XLP
	GENOP('MOV','[ESI]',T1)
	GENOP('INC','ESI')			:(OPDONE)
G.SCG.W.XR
	OUTPUT = 'scg.w ' i.text(i1)
	GENOP('MOV','[EDI]',T1)			:(OPDONE)
G.SCG.W.PXR
	GENOP('DEC','EDI')
	GENOP('MOV','[EDI]',T1)			:(OPDONE)
G.SCG.W.XRP
	GENOP('MOV','AL',T1)
	GENOP('STOSB')				:(OPDONE)
G.CSC  	IDENT(TLABEL)				:S(OPNEXT)
	GENOP()					:(OPDONE)

G.CEQ
	MEMMEM()
	GENOP('CMP',GETARG(I1),GETARG(I2))
	GENOP('JE',GETARG(I3))			:(OPDONE)

G.CNE   MEMMEM()
	GENOP('CMP',GETARG(I1),GETARG(I2))
	GENOP('JNZ',GETARG(I3))			:(OPDONE)

G.CMC
*	repe	cmpsb		;compare strings
*	mov	esi,0		;clear XL (without changing flags)
*	mov	edi,esi		;v1.02  XR also
*
	GENOP('REPE','CMPSB')
	GENOP('MOV','ESI','0')
	GENOP('MOV','EDI','ESI')
	T1 = GETARG(I1)
	T2 = GETARG(I2)
	(IDENT(T1,T2) GENOP('JNZ',T1))		:S(OPDONE)
	GENOP('JA',T2)
	GENOP('JB',T1)				:(OPDONE)

G.TRC
*	xchg	esi,edi
*  tmp	movzx   eax,byte ptr [edi]	;get character
*	mov	al,[esi+eax]		;translate
*	stosd				;put back and increment ptr
*	loop	tmp
*	xor	esi,esi			;set XL to zero
*	xor	edi,edi			;v1.02  XR also
	GENOP('XCHG','ESI','EDI')
        GENOPL((T1 = GENLAB()) LABEL.DELIM,'MOVZX','EAX','BYTE PTR [EDI]')
	GENOP('MOV','AL','[ESI+EAX]')
	GENOP('STOSB')
	GENOP('LOOP',T1)
	GENOP('XOR','ESI','ESI')
	GENOP('XOR','EDI','EDI')		:(OPDONE)


G.ANB   GENOP('AND',GETARG(I2),GETARG(I1))	:(OPDONE)
G.ORB   GENOP('OR',GETARG(I2),GETARG(I1))	:(OPDONE)
G.XOB   GENOP('XOR',GETARG(I2),GETARG(I1))	:(OPDONE)
G.CMB   GENOP('NOT',GETARG(I1))			:(OPDONE)

G.RSH
	GENOP('SHR',GETARG(I1),GETARG(I2))		:(OPDONE)

G.LSH
	GENOP('SHL',GETARG(I1),GETARG(I2))		:(OPDONE)

G.RSX	T1 = REGMAP[SUBSTR(I.TEXT(I2),2,2)]
	IDENT(I.TEXT(I1),'WA')				:S(G.RSX.C)
	GENOP('XCHG',T1,'ECX')
	GENOP('SHR',GETARG(I1),'CL')
	GENOP('XCHG',T1,'ECX')				:(OPDONE)

G.RSX.C	GENOP('XCHG',T1,'ECX')
	GENOP('SHR',T1,'CL')
	GENOP('XCHG',T1,'ECX')				:(OPDONE)

G.LSX	T1 = REGMAP[SUBSTR(I.TEXT(I2),2,2)]
	IDENT(I.TEXT(I1),'WA')				:S(G.LSX.C)
	GENOP('XCHG',T1,'ECX')
	GENOP('SHL',GETARG(I1),'CL')
	GENOP('XCHG',T1,'ECX')				:(OPDONE)

G.LSX.C	GENOP('XCHG',T1,'ECX')
	GENOP('SHL',T1,'CL')
	GENOP('XCHG',T1,'ECX')				:(OPDONE)

G.NZB	IFREG(I1)				:S(G.NZB1)
	GENOP('CMP',GETARG(I1),'0')
	GENOP('JNZ',GETARG(I2))			:(OPDONE)
G.NZB1	GENOP('OR',GETARG(I1),GETARG(I1))
	GENOP('JNZ',GETARG(I2))			:(OPDONE)

G.ZRB	IFREG(I1)				:S(G.ZRB1)
	GENOP('CMP',GETARG(I1),'0')
	GENOP('JZ',GETARG(I2))			:(OPDONE)
G.ZRB1	GENOP('OR',GETARG(I1),GETARG(I1))
	GENOP('JZ',GETARG(I2))			:(OPDONE)

* 80386 is a Little-Endian machine, so ZGB must swap bytes.
*
* NOTE THAT ON A 486 AND LATER CPU, THIS CAN BE DONE WITH ONE INSTRUCTION, BSWAP.
* SHOULD CONSIDER ABANDONING THE 80386 SO CAN USE BSWAP.
*
G.ZGB	T1 = GETARG(I1)			;* 32-bit register name, e.g., EDX
        T2 = SUBSTR(T1,2,1) 'L'         ;* 8-bit low register name, e.g., DL
	T3 = SUBSTR(T1,2,1) 'H'		;* 8-bit high register name, e.g., DH
	GENOP('XCHG',T2,T3)		;* e.g., XCHG DL,DH
	GENOP('ROL',T1,16)		;* e.g., ROL EDX,16
	GENOP('XCHG',T2,T3)		;* e.g., XCHG DL,DH
						:(OPDONE)

G.WTB   GENOP('SAL',GETARG(I1),'2')		:(OPDONE)
G.BTW   GENOP('SHR',GETARG(I1),'2')		:(OPDONE)

G.MTI	(IDENT(I.TEXT(I1),'(XS)+') GENOP('POP',REG.IA)) :S(OPDONE)
	GENOP('MOV',REG.IA,GETARG(I1))		:(OPDONE)

G.MFI
*  LAST ARG IS OPTIONAL
*  COMPARE WITH CFP$M, BRANCHING IF RESULT NEGATIVE
	EQ(I.TYPE(I2))				:S(G.MFI1)
*  HERE IF LABEL GIVEN, BRANCH IF WC NOT IN RANGE (IE, NEGATIVE)
	GENOP('OR',REG.IA,REG.IA)
	GENOP('JS',GETARG(I2))
G.MFI1	IDENT(I.TEXT(I1),'WC') GENOP()		:S(OPDONE)
	IDENT(I.TEXT(I1),'-(XS)') GENOP('PUSH',REG.IA)	:S(OPDONE)
	GENOP('MOV',GETARG(I1),REG.IA)		:(OPDONE)

G.CTW
*  assume four chars per word
	T1 = GETARG(I1)
	GENOP('ADD',T1,'3+4*' I.TEXT(I2))
	GENOP('SHR',T1,'2')		:(OPDONE)

G.CTB
*  use add w,val*CFP.B+3; and w,-4
	T1 = GETARG(I1)
	GENOP('ADD',T1,'3+4*' I.TEXT(I2))
	GENOP('AND',T1,'-4')	:(OPDONE)

G.CVM	T1 = GETARG(I1)
	GENOP('IMUL',REG.IA,'10')
	GENOP('JO',T1)
	GENOP('SUB',REGMAP['WB'],'CH$D0')
	GENOP('SUB',REG.IA,REGMAP['WB'])
	GENOP('JO',T1)				:(OPDONE)

G.CVD	GENOP('CALL','CVD_')			:(OPDONE)

G.MVC
*	move chars from XL (ESI) to XR (EDI), count in WA (ECX)
*
*  The following sequence "Old Method" is shorter than the "New Method"
*  shown below, but is MUCH slower because of the conditional jumps that
*  cause the instruction cache to be flushed for 3 out of 4 count values.
*
*  OLD METHOD:
*	shr	ecx,1
*	jnc	tmp1
*	movsb		; move odd byte
*  tmp1	shr	ecx,1
*	jnc	tmp2
*	movsw		; move odd word
*  tmp2 rep	movsd	; move string as double words
*
*	GENOP('SHR','ECX','1')
*	GENOP('JNC','SHORT ' (T1 = GENLAB()))
*	GENOP('MOVSB')
*       GENOPL(T1 LABEL.DELIM,'SHR','ECX','1')
*	GENOP('JNC','SHORT ' (T1 = GENLAB()))
*	GENOP('MOVSW')
*       GENOPL(T1 LABEL.DELIM,'REP','MOVSD')        :(OPDONE)
*
*  NEW METHOD:
*	shrd	eax,ecx,1 ; preserve ecx[0] in eax[31]
*	shr	ecx,2	  ; preserve ecx[1] in CY, divide by 4
*	rep	movsd	  ; move dwords, leaves ECX=0
*	adc	ecx,ecx	  ; copy CY to ecx[0]
*	rep	movsw	  ; copy 1 or 0 words, leaves ECX=0
*	shld	ecx,eax,1 ; copy eax[31] to ecx[0]
*	rep	movsb	  ; copy 1 or 0 bytes
*
	GENOP('SHRD','EAX','ECX','1')
	GENOP('SHR','ECX','2')
	GENOP('REP','MOVSD')
	GENOP('ADC','ECX','ECX')
	GENOP('REP','MOVSW')
	GENOP('SHLD','ECX','EAX','1')
	GENOP('REP','MOVSB')			:(OPDONE)

G.MVW
	GENOP('SHR','ECX','2')
	GENOP('REP','MOVSD')			:(OPDONE)

G.MWB
*   move words backwards
	GENOP('SHR','ECX','2')
	GENOP('STD')
	GENOP('LEA','ESI','[ESI-4]')
	GENOP('LEA','EDI','[EDI-4]')
	GENOP('REP','MOVSD')
	GENOP('CLD')				:(OPDONE)

G.MCB
*   move characters backwards
	GENOP('STD')
	GENOP('DEC','ESI')
	GENOP('DEC','EDI')
	GENOP('REP','MOVSB')
	GENOP('CLD')				:(OPDONE)

G.CHK   GENOP('CMP','ESP',LABFIX('LOWSPMIN'))
	GENOP('JB','SEC06')			:(OPDONE)

DECEND
*  Here at end of DIC or DAC to see if want label made public
	TLABEL ? RTAB(1) . TLABEL LABEL.DELIM
        DIFFER(PUBTAB[TLABEL]) GENOP('.global',TLABEL)  :(OPDONE)

G.DAC	T1 = I.TYPE(I1)
        T2 = "" ;*(LE(T1,2) "", LE(T1,4) "offset ", LE(T1,6) "offset ", "")
        GENOPL(TLABEL,'.long',T2 LABFIX(I.TEXT(I1)))    :(DECEND)
G.DIC   GENOPL(TLABEL,'.long',I.TEXT(I1))               :(DECEND)

*
* Make sure don't attach label to the align.
*
* Note that we strip any leading plus sign from the constant.  With
* Microsoft MASM 6.0, it treats "+0.0" as an expression, and
* then says that real-valued expressions are illegal.
*
G.DRC   GENOP('.balign','4')
	T1 = I.TEXT(I1)
	T1 ? FENCE "+" = ""
        GENOP('.double','0e' T1)
*  Note that want to attach label to last instruction
	T.LABEL(CSTMTS[CSTMTS.N]) = TLABEL
	TLABEL =					:(OPDONE)

G.DTC
*  CHANGE FIRST AND LAST CHARS TO " (ASSUME / USED IN SOURCE)
	T1 = I.TEXT(I1)
	T1 TAB(1) RTAB(1) . T2
	T3 = REMDR(SIZE(T2),4)
        T2 = '"' T2
*  APPEND "\x00" IF STRING HAS ODD LENGTH TO COMPLETE LAST DWORD
        T2 = NE(T3) T2 DUPL('\x00',4 - T3)
        T2 = T2  '"'
        GENOPL(TLABEL,'.ascii',T2)              :(OPDONE)
G.DBC   GENOPL(TLABEL,'.long',GETARG(I1))       :(OPDONE)
G.EQU   GENOP('=',I.TEXT(I1))			:(OPDONE)
G.EXP   GENOP('.extern',TLABEL ':NEAR')
	TLABEL =				:(OPDONE)

G.INP	PRC.COUNT1 = IDENT(I.TEXT(I1),'N') PRC.COUNT1 + 1
+						:(OPNEXT)

G.INR						:(OPNEXT)

G.EJC	
						:(OPDONE)

G.TTL	GENOP('')
        GENOP('.sbttl','"' I.TEXT(I1) '"')      :(OPDONE)

G.SEC	GENOP('')
	SECTNOW = SECTNOW + 1			:($("G.SEC." SECTNOW))

* Procedure declaration section
G.SEC.1 GENOP('CSeg_')
        GENOP('.global','SEC01')
        GENOPL('SEC01' LABEL.DELIM)             :(OPDONE)

* Definitions section
G.SEC.2 GENOP('CSegEnd_')
        GENOP('DSeg_')
        GENOP('.global','SEC02')
        GENOPL('SEC02' LABEL.DELIM)             :(OPDONE)

* Constants section
G.SEC.3 GENOP('DSegEnd_')
        GENOP('DSeg_')
        GENOP('.global',LABFIX('SEC03'))
        GENOPL(LABFIX('SEC03') LABEL.DELIM)     :(OPDONE)

* Working variables section
G.SEC.4 GENOP('.global',LABFIX('ESEC03'))
        GENOPL(LABFIX('ESEC03') LABEL.DELIM)
        GENOP('DSegEnd_')
        GENOP('DSeg_')
        GENOP('.global',LABFIX('SEC04'))
        GENOPL(LABFIX('SEC04') LABEL.DELIM)     :(OPDONE)

*  Here at start of program section.  If any N type procedures,
*  put out entry-word block declaration at end of working storage
G.SEC.5
*  Emit code to indicate in code section
*  Get direction set to up.
        GENOP('.global',LABFIX('ESEC04'))
        GENOPL(LABFIX('ESEC04') LABEL.DELIM)
        (GT(PRC.COUNT1) GENOPL('PRC$' LABEL.DELIM,'.fill', PRC.COUNT1 ',4,0'))
        GENOP('.global',LABFIX('LOWSPMIN'))
        GENOPL(LABFIX('LOWSPMIN') LABEL.DELIM,'.long','0')
        GENOP('.global',LABFIX('END$MIN$DATA'))
        GENOPL(LABFIX('END$MIN$DATA') LABEL.DELIM)
        GENOP('DSegEnd_')
        GENOP('CSeg_')
        GENOP('.global',LABFIX('SEC05'))
        GENOPL(LABFIX('SEC05') LABEL.DELIM)     :(OPDONE)

*  Stack overflow section.  Output EXI__n tail code
G.SEC.6	I1 = 1
G.SEC.6.1
        (DIFFER(DEBUG) GENOPL(,'.global','EXI__' I1))
        GENOPL('EXI__' I1 LABEL.DELIM, 'MOVSX', 'EAX',
+		'WORD PTR [EAX+' (2 * (I1 - 1)) ']')
        GENOP('ADD','EAX','offset ' LABFIX('DFFNC'))
	GENOP('PUSH','EAX')
	GENOP('XOR','EAX','EAX')
	GENOP('RET')
	FLUSH()
	I1 = LT(I1,MAX_EXI) I1 + 1		:S(G.SEC.6.1)

* Now being the stack overflow section
        GENOP('.global','SEC06')
        GENOPL('SEC06' LABEL.DELIM)             :(OPDONE)

*  Error section.  Produce code to receive ERB's
G.SEC.7
        (DIFFER(DEBUG) GENOPL(,'.global','ERR_0'))
        GENOPL('ERR_0' LABEL.DELIM,'POP','EAX')
	GENOP('MOVZX','EAX','BYTE PTR [EAX]')
	GENOP('JMP','SHORT ERR_1A')
        (DIFFER(DEBUG) GENOPL(,'.global','ERR_1'))
        GENOPL('ERR_1' LABEL.DELIM,'POP','EAX')
	GENOP('MOVZX','EAX','BYTE PTR [EAX]')
	GENOP('ADD','EAX','256')
        GENOPL('ERR_1A' LABEL.DELIM,'JMP','ERR$')
	FLUSH()

*  Loop to emit INC EAX for each possible error code
	I1 = MAX.ERR
G.SEC.7.1
	GE(I1 = I1 - 1) OUTSTMT(TSTMT(,'INC','EAX'))	:S(G.SEC.7.1)
        GENOPL('ERR$' LABEL.DELIM,'XCHG',REG.WA,'EAX')
        GENOP('.global','SEC07')
        GENOPL('SEC07' LABEL.DELIM)             :(OPDONE)



OPDONE	FLUSH()					:(OPNEXT)
*
*  Here to emit BSTMTS, CSTMTS, ASTMTS. Attach input label and
*  comment to first instruction generated.
*
FLUSH	EQ(ASTMTS.N) EQ(BSTMTS.N) EQ(CSTMTS.N)	:F(OPDONE1)
*
*  Here if some instructions to emit, so output single 'null' 
*  statement to get label and comment field right.
*

	OUTSTMT(TSTMT())			
						:(OPDONE.6)
OPDONE1	
	EQ(BSTMTS.N)				:S(OPDONE.2)
	I = 1
OPDONE.1
	OUTSTMT(BSTMTS[I])
	LE(I = I + 1, BSTMTS.N)			:S(OPDONE.1)

OPDONE.2	EQ(CSTMTS.N)			:S(OPDONE.4)
	I = 1
OPDONE.3
	OUTSTMT(CSTMTS[I])
	LE(I = I + 1, CSTMTS.N)			:S(OPDONE.3)

OPDONE.4	EQ(ASTMTS.N)			:S(OPDONE.6)
	I = 1
	IDENT(PIFATAL[INCODE])			:S(OPDONE.5)
*  Here if post incrementing code not allowed
	ERROR('POST INCREMENT NOT ALLOWED FOR OP ' INCODE)
OPDONE.5	OUTSTMT(ASTMTS[I])
	LE(I = I + 1, ASTMTS.N)			:S(OPDONE.5)
OPDONE.6 ASTMTS.N = BSTMTS.N = CSTMTS.N =	:(RETURN)
FLUSH_END

G.END
	&DUMP = 0
	IDENT(HAVEHDR)				:S(G.END.2)
*  Here to copy remaining part from hdr file
G.END.1	LINE = HDRFILE				:F(G.END.2)
	NTARGET = NTARGET + 1
	NOUTLINES = NOUTLINES + 1
	OUTFILE = LINE				:(G.END.1)
G.END.2
        OUTSTMT(TSTMT(,'.end',,,,COMMENT))


* Here at end of code generation.  Close the temp file, and reread
* it to perform jump optimization.
	ENDFILE(1)
	ENDFILE(2)
        OUTPUT = "Code generation complete, begin jump optimization"

	INPUT(.INFILE,1,FILENAMO)			:S(G.END.3)
        OUTPUT = 'Cannot reopen TEMP file: ' FILENAMO :(END)

G.END.3 FILENAMO = PARMS ".s"
        OUTPUT(.OUTFILE,2,FILENAMO '[-m10 -n0]')            :S(G.END.4)
        OUTPUT = 'Cannot open ASSEMBLY file: ' FILENAMO :(END)
G.END.4 OUTPUT = 'Output ASSEMBLY file: ' FILENAMO

***************************************************************************
* Jump optimization
*
* Forward jumps to target labels within JUMP_N lines of the jump receive
* a SHORT.  Exception is made for those lines that match NS_PAT.
*
* JUMP_N and NS_PAT are defined in the <machine>.def file.
*
***************************************************************************
*
	N = JUMP_N			;* # lines allowed for shortening
	JUMP = "J" SPAN(&UCASE)
	WS = SPAN(" " CHAR(9))
	LETS = &UCASE "_0123456789"
	L_PAT = SPAN(LETS)
	L_PATC = L_PAT LABEL.DELIM
	L_PAT2 = L_PAT . LABEL LABEL.DELIM
	STMT = ((L_PATC | "") WS JUMP WS) . FIRST (L_PAT . LABEL REM) . REST

	LNO = 0
G.END.5	LINE = INFILE					:F(G.END.7)
	LNO = LNO + 1
	LINE ? STMT					:F(G.END.6)
	(IDENT(LABEL,"SHORT"), IDENT(LABTAB<LABEL>))	:S(G.END.6)
	DISTANCE = LABTAB<LABEL> - LNO
	(GT(DISTANCE,0) LE(DISTANCE,N))			:F(G.END.6)
	LINE ? NS_PAT					:S(G.END.6)
	NOPTIM2 = NOPTIM2 + 1
        LINE = FIRST "SHORT " REST FILLC "# (Jump shortened)"
G.END.6	OUTFILE = LINE					:(G.END.5)

G.END.7 ENDFILE(1)
	ENDFILE(2)
	ENDFILE(3)
	HOST(1,"touch " PARMS ".err")
	HOST(1,"del " PARMS ".tmp")
        OUTPUT = '*** TRANSLATION COMPLETE ***'
        OUTPUT = NLINES ' LINES READ.'
        OUTPUT = NSTMTS ' STATEMENTS PROCESSED.'
        OUTPUT = NTARGET ' TARGET CODE LINES PRODUCED.'
        OUTPUT = NOPTIM1 ' "OR" optimizations performed.'
        OUTPUT = NOPTIM2 ' jumps shortened.'
        OUTPUT = MAX.ERR ' MAXIMUM ERR/ERB NUMBER.'
        OUTPUT = PRC.COUNT1 ' PRC COUNT.'
        OUTPUT = GT(PRC.COUNT,PRC.COUNT1)
.	  'DIFFERING COUNTS FOR N-PROCEDURES:'
.	  ' INP ' PRC.COUNT1 ' PRC ' PRC.COUNT
        OUTPUT = NERRORS ' ERRORS OCCURRED.'
        OUTPUT =
	ERRFILE = '* ' MAX.ERR ' MAXIMUM ERR/ERB NUMBER'
	ERRFILE  = '* ' PRC.COUNT ' PRC COUNT'
.		DIFFER(LASTERROR) 'THE LAST ERROR WAS IN LINE ' LASTERROR
	&CODE   = NE(NERRORS) 2001
        OUTPUT = COLLECT() ' FREE WORDS'
	:(END)
END
