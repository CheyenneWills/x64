-title lex phase 1 translation from minimal to tokens
-stitl initialization
-eject

*	procedures

	define('init()')				:(init.end)

*	initialization

init
        &anchor = 1
        &trim   = 1
        minlets = 'abcdefghijklmnopqrstuvwxy_z' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        nos     = '0123456789'
        p.nos   = span(nos) rpos(0)
        p.exp   = 'e' any('+-') span(nos)
        p.real  = span(nos) '.' (span(nos) | null) (p.exp | null) rpos(0)
        tab = char(9)
           catab = table( 11,,.badop )
           catab['.def']   = .defop; catab['.undef'] = .undefop
           catab['.if']    = .ifop; catab['.then']  = .thenop
           catab['.else']  = .elseop; catab['.fi']    = .fiop
        symtbl      = table( 11 )
        statestk    = array( 30 )
        level       = 0
        top         =
        data( 'state(result,mode)' )
        false    = 0
        true     = 1
        bypass   = 2
        else     = 0
        then     = 1
        processrec    = array( false ':' bypass ',' else ':' then,0 )
        processrec[true,then]  = 1
        processrec[false,else] = 1
        sep      = ' '
        p.condasm      = ( break(sep) | rem ) . condcmd
.             ( span(sep) | '' )
.             ( break(sep) | rem ) . condvar
        p.argskel1 = fence(break(',') | rem) $ argthis *differ(argthis)
        p.argskel2 = len(1) fence(break(',') | rem) $ argthis *differ(argthis)
        ityptab = table(21)
        ityptab['0'] = 1; ityptab['1'] = 1; ityptab['wa'] = 8
        ityptab['wb'] = 8; ityptab['wc'] = 8; ityptab['xl'] = 7
        ityptab['xr'] = 7; ityptab['xs'] = 7; ityptab['xt'] = 7
        ityptab['(xl)'] = 9; ityptab['(xr)'] = 9; ityptab['(xs)'] = 9
        ityptab['(xt)'] = 9; ityptab['-(xl)'] = 11; ityptab['-(xr)'] = 11
        ityptab['-(xs)'] = 11; ityptab['-(xt)'] = 11;
        ityptab['(xl)+'] = 10;  ityptab['(xr)+'] = 10;
        ityptab['(xs)+'] = 10; ityptab['(xt)+'] = 10
        labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
        p.minlabel = any(minlets) any(minlets) any(minlets nos)
.              any(minlets nos) any(minlets nos)
        p.csparse = (((p.minlabel . label) | ('     '  '' . label)) '  '
.     len(3) . opcode
.     (('  ' (break(' ') | rtab(0)) . operands
.         (span(' ') | '') rtab(0) . comment)  |
.         (rpos(0) . operands . comment)))  |
.        ('.'  '' . label  mincond . opcode
.          ((tab(7)  '.'  len(4) . operands) | (rpos(0) . operands))
.              '' . comment)
        p.csoperand = (break(',') . operand  ',')  |
.           ((len(1) rtab(0)) . operand)
        p.csdtc   = ((p.minlabel . label)  |  ('     '  '' . label))
.             len(7) (len(1) $ char  break(*char)  len(1)) . operand
.             (span(' ') | '')  rtab(0) . comment
        p.equ.rip  = ( span(nos) . num1 | p.minlabel . sym1 )
.          ( any('+-') . oprtr | '' )
.          ( span(nos) . num2 | p.minlabel . sym2 | '' )
.          rpos(0)

*	optab is a table that maps opcodes into their argument
*	types and is used for argument checking and processing.
        optab = initmap(
. 'flc[w]'
. 'add[opn,opv]adi[ops]adr[ops]anb[w,opw]aov[opv,opn,plbl]atn[none]'
. 'bod[opn,plbl]bev[opn,plbl]'
. 'bct[w,plbl]beq[opn,opv,plbl]bge[opn,opv,plbl]bgt[opn,opv,plbl]'
. 'bhi[opn,opv,plbl]ble[opn,opv,plbl]blo[opn,opv,plbl]'
. 'blt[opn,opv,plbl]bne[opn,opv,plbl]bnz[opn,plbl]brn[plbl]'
. 'bri[opn]bsw[x,val,*plbl bsw]btw[reg]'
. 'bze[opn,plbl]ceq[ops,ops,plbl]'
. 'chk[none]chp[none]cmb[w]cmc[plbl,plbl]cne[ops,ops,plbl]cos[none]csc[x]ctb[w,val]'
. 'ctw[w,val]cvd[none]cvm[plbl]dac[addr]dbc[val]dca[opn]dcv[opn]'
. 'def[def]dic[integer]drc[real]dtc[dtext]dvi[ops]dvr[ops]ejc[none]'
. 'else[else]end[none end]enp[none]ent[*val ent]equ[eqop equ]'
. 'erb[int,text erb]err[int,text err]esw[none esw]etx[none]exi[*int]exp[int]fi[fi]'
. 'ica[opn]icp[none]icv[opn]ieq[plbl]if[if]iff[val,plbl iff]ige[plbl]'
. 'igt[plbl]ile[plbl]ilt[plbl]ine[plbl]ino[plbl]inp[ptyp,int inp]'
. 'inr[none]iov[plbl]itr[none]jsr[pnam]lch[reg,opc]lct[w,opv]lcp[reg]'
. 'lcw[reg]ldi[ops]ldr[ops]lei[x]lnf[none]lsh[w,val]lsx[w,(x)]mcb[none]'
. 'mfi[opn,*plbl]mli[ops]mlr[ops]mnz[opn]mov[opn,opv]mti[opn]'
. 'mvc[none]mvw[none]mwb[none]ngi[none]ngr[none]nzb[w,plbl]'
. 'orb[w,opw]plc[x,*opv]ppm[*plbl]prc[ptyp,val prc]psc[x,*opv]req[plbl]'
. 'rge[plbl]rgt[plbl]rle[plbl]rlt[plbl]rmi[ops]rne[plbl]rno[plbl]'
. 'rov[plbl]rsh[w,val]rsx[w,(x)]rti[*plbl]rtn[none]sbi[ops]'
. 'sbr[ops]sch[reg,opc]scp[reg]sec[none sec]sin[none]sqr[none]ssl[opw]sss[opw]'
. 'sti[ops]str[ops]sub[opn,opv]tan[none]then[then]trc[none]ttl[none ttl]'
. 'undef[undef]wtb[reg]xob[w,opw]zer[opn]zgb[opn]zrb[w,plbl]zzz[int]' )

	equ_defs = initmap(
.	'nstmx[10]cfp_s[9]cfp_x[3]e_srs[100]e_sts[1000]e_cbs[500]e_hnb[257]e_hnw[3]e_fsp[15]'
.	'e_sed[25]ch_ua[65]ch_ub[66]ch_uc[67]ch_ud[68]ch_ue[69]ch_uf[70]ch_ug[71]ch_uh[72]'
.	'ch_ui[73]ch_uj[74]ch_uk[75]ch_ul[76]ch_um[77]ch_un[78]ch_uo[79]ch_up[80]ch_uq[81]'
.	'ch_ur[82]ch_us[83]ch_ut[84]ch_uu[85]ch_uv[86]ch_uw[87]ch_ux[88]ch_uy[89]ch_uz[90]'
.	'ch_d0[48]ch_d1[49]ch_d2[50]ch_d3[51]ch_d4[52]ch_d5[53]ch_d6[54]ch_d7[55]ch_d8[56]'
.	'ch_d9[57]ch_la[97]ch_lb[98]ch_lc[99]ch_ld[100]ch_le[101]ch_lf[102]ch_lg[103]ch_lh[104]ch_li[105]'
.	'ch_lj[106]ch_lk[107]ch_ll[108]ch_lm[109]ch_ln[110]ch_lo[111]ch_lp[112]ch_lq[113]ch_lr[114]'
.	'ch_ls[115]ch_lt[116]ch_lu[117]ch_lv[118]ch_lw[119]ch_lx[120]ch_ly[121]ch_l_[122]ch_am[38]'
.	'ch_as[42]ch_at[64]ch_bb[60]ch_bl[32]ch_br[124]ch_cl[58]ch_cm[44]ch_dl[36]ch_dt[46]ch_dq[34]'
.	'ch_eq[61]ch_ex[33]ch_mn[45]ch_nm[35]ch_nt[126]ch_pc[94]ch_pl[43]ch_pp[40]ch_rb[62]'
.	'ch_rp[41]ch_qu[63]ch_sl[47]ch_sm[59]ch_sq[39]ch_u_[95]ch_ob[91]ch_cb[93]ch_ht[9]ch_vt[11]'
.	'ch_ey[94]iodel[32]cfp_a[256]cfp_b[8]cfp_c[8]cfp_f[16]cfp_i[1]cfp_l[18446744073709551616]'
.	'cfp_m[9223372036854775807]cfp_n[64]cfp_r[1]cfp_u[128]')

*	prctab is table of procedures declared in inp that is used to
*	check for consistency of inp/prc statements.

	prctab = table(60)

*	equates is used by g.equ and .  it contains a directory of
*	all labels that were defined by equ instructions.

	equates = table(257)

*	labtab is a table that maps each label to the section in which
*	it is defined, except labels defined in the definitions section
*	(section 2).

	labtab = table(150,150)

*	bsw is a flag that indicates whether or not a bsw...esw range
*	is being processed.

	bsw = 0


*	loop until program exits via g.end
*	start execution

*	 reads for xxx.min, writes to xxx.lex, where xxx is a command line parameter.
*	 the command line parameter may optionally be expressed as xxx;yyy, where
*	 yyy.cnd is the name of a file containing .defs to override those in
*	 file xxx.min.

*	get file name

-stitl main program
        trandate = date()
        parm = 'sbl'
        filenami = parm '.min'
        filenamo = parm '.lex'
        output = rpad('input file:',15) filenami
        output = rpad('output file:',15) filenamo
        flcflag = 'n'
        flcflag = 'y'
        ejcflag = 'n'
        ejcflag = 'y'
main1
        output(.outfile,2,filenamo)                     :s(main2)
        output = "cannot open output file: " filenamo   :(end)

main2
        input(.infile,1,filenami)                       :s(main3)
        error('cannot open input file ' filenami)
main3

        p.opsk1 = (break(' ') | rem) . argskel

	equ_defs = initmap(
.	'nstmx[10]cfp_s[9]cfp_x[3]e_srs[100]e_sts[1000]e_cbs[500]e_hnb[257]e_hnw[3]e_fsp[15]'
.	'e_sed[25]ch_ua[65]ch_ub[66]ch_uc[67]ch_ud[68]ch_ue[69]ch_uf[70]ch_ug[71]ch_uh[72]'
.	'ch_ui[73]ch_uj[74]ch_uk[75]ch_ul[76]ch_um[77]ch_un[78]ch_uo[79]ch_up[80]ch_uq[81]'
.	'ch_ur[82]ch_us[83]ch_ut[84]ch_uu[85]ch_uv[86]ch_uw[87]ch_ux[88]ch_uy[89]ch_uz[90]'
.	'ch_d0[48]ch_d1[49]ch_d2[50]ch_d3[51]ch_d4[52]ch_d5[53]ch_d6[54]ch_d7[55]ch_d8[56]'
.	'ch_d9[57]ch_la[97]ch_lb[98]ch_lc[99]ch_ld[100]ch_le[101]ch_lf[102]ch_lg[103]ch_lh[104]ch_li[105]'
.	'ch_lj[106]ch_lk[107]ch_ll[108]ch_lm[109]ch_ln[110]ch_lo[111]ch_lp[112]ch_lq[113]ch_lr[114]'
.	'ch_ls[115]ch_lt[116]ch_lu[117]ch_lv[118]ch_lw[119]ch_lx[120]ch_ly[121]ch_l_[122]ch_am[38]'
.	'ch_as[42]ch_at[64]ch_bb[60]ch_bl[32]ch_br[124]ch_cl[58]ch_cm[44]ch_dl[36]ch_dt[46]ch_dq[34]'
.	'ch_eq[61]ch_ex[33]ch_mn[45]ch_nm[35]ch_nt[126]ch_pc[94]ch_pl[43]ch_pp[40]ch_rb[62]'
.	'ch_rp[41]ch_qu[63]ch_sl[47]ch_sm[59]ch_sq[39]ch_u_[95]ch_ob[91]ch_cb[93]ch_ht[9]ch_vt[11]'
.	'ch_ey[94]iodel[32]cfp_a[256]cfp_b[8]cfp_c[8]cfp_f[16]cfp_i[1]cfp_l[18446744073709551616]'
.	'cfp_m[9223372036854775807]cfp_n[64]cfp_r[1]cfp_u[128]')

							:(return)
init.end
-stitl  initmap(str)pos,cnt,index,val,lastval
        define('initmap(str)pos,cnt,index,val,lastval')	:(initmap.end)
initmap  pos     = 0

        initmap   = table(cnt)
initmap.next
        str     (break('[') $ index len(1) break(']') $ val len(1)) = :f(return)
        val     = convert( val,'integer' )
        val     = ident(val,lastval) lastval
        lastval = val
        initmap[index] = val                             :(initmap.next)

initmap.end
-stitl argform(arg)
        define('argform(arg)')				:(argform.end)
argform
        argform = 0
        ident(t = ityptab[arg])                         :s(argform1)
        argform = t                                     :(return)
argform1
        arg p.nos                                       :s(argform.int)
        arg '='                                         :s(argform.eq)
        arg '*'                                         :s(argform.star)
        arg any('+-')                                   :s(argform.snum)
        arg break('(')                                  :s(argform.index)
        ident(t = labtab[arg])                          :s(argform.plbl)
        argform = t                                     :(return)
argform.plbl
        labtab[arg] = 6
        argform = 6                                     :(return)
argform.eq
        arg len(1) rem . itypa
        itypa = labtab[itypa]
        argform = (eq(itypa,2) 18, eq(itypa,6) 22,
.   gt(itypa,2) itypa + 17)                             :s(return)
        argform = 22
        labtab[itypa] = 5                               :(return)
argform.star
        arg len(1) rem . t                              :f(return)
        eq(labtab[t],2)                                 :f(return)
        argform = 19                                    :(return)
argform.int
        argform = 1                                     :(return)
argform.snum
        arg len(1) p.nos                                :f(argform.sreal)
        argform = 16                                    :(return)
argform.sreal
        arg len(1) p.real                               :f(return)
        argform = 17                                    :(return)
argform.index
        arg break('(') . t '(x' any('lrst') ')' rpos(0)
.                                                       :f(return)
        t p.nos                                         :f(argform.index1)
        argform = 12                                    :(return)
argform.index1
        ident(t = labtab[t])                            :s(return)
        argform = (eq(t,2) 13, eq(t,3) 15, eq(t,4) 14)  :(return)

argform.end
-stitl argtype(op,typ)
        define('argtype(op,typ)')			:(argtype.end)

argtype
        argtype = 0
        typ '*' =
        ident(typ,'text')                               :s(arg.text)
        ident(typ,'dtext')                              :s(arg.dtext)
        ident(typ,'ptyp')                               :s(arg.ptyp)
        ident(typ,'eqop')                               :s(arg.eqop)
        itype = argform(op)
        opform = opformtab<typ>
        argtype = ne(validform<+opform,itype>) itype    :(return)
arg.text
        argtype = 26                                    :(return)
arg.dtext
        argtype = 27                                    :(return)
arg.ptyp
        op any('rne')                                   :f(return)
        argtype = 25                                    :(return)
arg.eqop
        op1 = ident(op,'*') equ_defs[label]
        argtype = 24                                    :(return)

argtype.end
-stitl crack(line)operands,operand,char
        define('crack(line)operands,operand,char')	:(crack.end)
crack
        nstmts  = nstmts + 1
        line    p.csparse                               :f(cs03)
        op1 = op2 = op3 = typ1 = typ2 = typ3 =
        ident(opcode,'dtc')                             :s(cs02)
        operands  p.csoperand =                         :f(cs01)
        op1 = operand
        operands  p.csoperand =                         :f(cs01)
        op2 = operand
        operands  p.csoperand                           :f(cs01)
        op3 = operand
cs01                                                    :(return)
cs02    line    p.csdtc                                 :f(cs03)
        op1 = operand
                                                        :(cs01)
cs03
        error('source line syntax error')               :(freturn)

crack.end
        define('error(text)')				:(error.end)
-stitl error(text)
error
        outfile = '* *???* ' thisline
*        outfile = '*       ' text
*.             (ident(lasterror),'. last error was line ' lasterror)
        lasterror = noutlines
        noutlines = noutlines + 2
        nerrors = nerrors + 1				:(return)
error.end
-stitl labenter()tlab
        define('labenter()tlab')			:(labenter.end)
labenter
        ident(label)                                    :s(return)
        labtab[label] = (eq(sectnow,2) 2, eq(sectnow,3) 4,
.	eq(sectnow,4) 3 , gt(sectnow,4)  6)            	:(return)
							:(return)
labenter.end
-stitl outstmt(label,opcode,op1,op2,op3,comment)
        define('outstmt(label,opcode,op1,op2,op3,comment)t')	:(outstmt.end)

outstmt
        outline = '{' label '{' opcode '{'
.   (ident(typ1), typ1 ',') op1 '{'
.   (ident(typ2), typ2 ',') op2 '{'
.   (ident(typ3), typ3 ',') op3 '{' comment
.   '{' nlines

 output = ' outstmt <' outline '>'
 output = 'outstmt opcode <' opcode '> typ1 <' typ1 '> typ2 <' typ2 '< typ3 <' typ3 '>'
	outfile = outline
        ntarget = ntarget + 1
        noutlines = noutlines + 1
                                                       :(return)
outstmt.end
-stitl readline()
        define('readline()')				:(readline.end)
readline
        readline = infile                                 :f(g.end)
        nlines  = nlines + 1
 output = 'readline <' readline '>'
        differ( readline )                                :s(readline.1)
        outfile =
        noutlines = noutlines + 1                       :(readline)
readline.1
        leq( substr( readline,1,1 ),'.' )                 :f(other)
        readline ? p.condasm                              :s( $catab[condcmd] )
rl00
        leq( substr( readline,1,1 ),'*' )                 :f(rl01)
        outfile = ident(flcflag,'y') readline             :f(readline)
        noutlines = noutlines + 1                       :(readline)
rl01
        leq( substr( readline,1,1 ),'>' )                 :f(readline.done)
        c = code(substr( readline, 2 ) "; :(readline)")     :s<c>
        output = "error compiling snobol4 statement"
                                                        :(rl03)
rl03
        readline = '       end'                           :(freturn)
synerr output = incnt '(syntax error):' readline          :(readline)
defop
        ident( condvar )                                :s(synerr)
        differ( ignore_defs )                           :s(readline)
        eq( level )                                     :s(defok)
        eq( processrec[result(top),mode(top)] )         :s(readline)
defok
        symtbl[condvar] = 1                             :(readline)
undefop
           ident( condvar )                             :s(synerr)
           eq( level )                                  :s(undok)
           eq( processrec[result(top),mode(top)] )      :s(readline)
undok
        symtbl[condvar] =                               :(readline)
ifop
        ident( condvar )                                :s(synerr)
        eq( level )                                     :s(ifok)
        ne( processrec[result(top),mode(top)] )         :s(ifok)
        level    = level + 1
        top      = statestk[level] = state(bypass,then) :(readline)
ifok
        level    = level + 1
        top      = statestk[level] = state(
.                ( differ( symtbl[condvar] ) true,false ),
.                then )                                 :(readline)
thenop
        differ(condvar)                                 :s(synerr)
        eq(level)                                       :s(synerr)f(readline)
elseop
        differ(condvar)                                 :s(synerr)
        mode(top) = ne( level ) else                    :s(readline)f(synerr)
fiop
        differ(condvar)                                 :s(synerr)
        level = ne( level ) level - 1                   :f(synerr)
        top   = ( ne( level ) statestk[level],'' )      :(readline)
other
        eq( level )                                     :s(rl00)
        eq( processrec[result(top),mode(top)] )         :s(readline)f(rl00)

readline.done
	
							:(return)

readline.end
-stltl	report
        define('report(num,text)')			:(report.end)

report
        output = lpad(num,10) '  ' text                 :(return)

report.end

*	Main program.

	init()
	init = 					;* make init code collectible
*	&stlimit = &stcount + 15000
* output = 'after init stcount ' &stcount
* output = 'after init stlimit ' &stlimit
*	&trace = &ftrace = 1000
	&dump = 2

*	Loop through statements
	
nextstmt

	thisline = readline()				:f(g.end)

* output = 'thisline <' thisline '>'

        crack(thisline)                                 :f(nextstmt)
        differ(label) labenter()
        argerrs = 0
        opskel = optab[opcode]				:f(nextargs.1)
* output = 'opcode <' opcode '> opskel <' opskel '>'
        ident(opskel) error("opcode not known " opcode)	:s(nextstmt)
        opskel p.opsk1 =
* output = 'Argskel <' argskel '>'
       ident(argskel,'none')                           	:s(nextargs.done) 
nextargs.1

        ident(argskel)                              	:s(nextargs.done)

*	process arguments

* output = 'process arguments'

        argskel p.argskel1 =
 output = 'argthis <' argthis '>'

        argthis '*' ident(op1)                          :s(nextargs.done)
        typ1 = argtype(op1,argthis)

 output = 'typ1 <' typ1 '>'

        argerrs = eq(typ1) argerrs + 1
        ident(argskel)                              	:s(nextargs.done)
        argskel p.argskel2 =
        argthis '*' ident(op2)                          :s(nextargs.done)
        typ2 = argtype(op2,argthis)

 output = 'typ2 <' typ2 '>'

       argerrs = eq(typ2) argerrs + 1
	ident(arkskel)					:s(nextargs.done)
        argskel p.argskel2 =
        argthis '*' ident(op3)                          :s(nextargs.done)
        typ3 = argtype(op3,argthis)                     

 output = 'typ3 <' typ3 '>'
							:(nextargs.done)
       argerrs = eq(typ2) argerrs + 1


nextargs.done

 output = 'argerrs ' argerrs
        gt(argerrs) error('arg type not known')		:s(nextstmt)
* output = 'branching to generator <g.' opskel '>'
        opskel ' ' =                                    :f(stmtout)
 output = 'generate code for g.' opskel '>'
                                                        :($('g.' opskel))
                                                        :(g.h)
nextstmt.error

        error('bad op-code')                            :(nextstmt)

ds.typerr

        error('operand type zero')                      :(nextstmt)
stmtout
* output = 'reached stmtout ' opcode 

        outstmt(label,opcode,op1,op2,op3,comment)       :(nextstmt)

-stitl generators
g.bsw
        ub = ( integer( op2 ) op2, equates[op2] )
        iffar = integer( ub )
.       array( '0:' ub - 1,'{{' )                       :f(g.bsw1)
        dplbl = op3
        bsw   = 1                                       :(stmtout)
g.bsw1
        error("non-integer lower bound for bsw")	:(nextstmt)

g.iff
        (eq( bsw ) error("iff without bsw"))		:(nextstmt)
        ifftyp = ( integer(op1) '1', '2')
        iffval = ( integer( op1 ) op1, equates[op1] )
        iffar[iffval] = integer( iffval )
.       ifftyp ',' op1 '{' typ2 ',' op2 '{'  comment
.                                                       :s(nextstmt)
        error("non-integer iff value")			:(nextstmt)
g.equ
        equates[label] = ident(op1,'*')
.           equ_defs[label]                             :s(stmtout)
        num1 = num2 = sym1 = sym2 = oprtr =
        op1 p.equ.rip                                   :f(g.equ2)
        num1    = differ(sym1) equates[sym1]
        num2    = differ(sym2) equates[sym2]
        val     = (differ(oprtr) eval( num1 ' ' oprtr ' ' num2 ), num1):f(g.equ3)
g.equ1
        equates[label] = val                            :(stmtout)
g.equ2
        error("equ operand syntax error")
g.equ3
        error("equ evaluation failed                    : " num1 ' ' oprtr ' ' num2 ' "' op1 '"' )
g.esw
        eq(bsw) error("esw without bsw")		:s(nextstmt)
        iffindx = 0
g.esw1
        iffar[iffindx] break('{') $ val len(1)
.       break( '{' ) $ plbl len(1)
.       rem $ cmnt
.                                                       :f(g.esw2)
        val = ident( val ) '1,' iffindx
        plbl = ident( plbl ) '6,' dplbl
        ident(dplbl) ident(plbl) error("missing iff value: "
.        val " without plbl in preceding bsw")		:s(nextstmt)
        outstmt(,'iff',val,plbl,,cmnt)
        iffindx = iffindx + 1                           :(g.esw1)
g.esw2
        iffar =                                         :(stmtout)
g.end
        outstmt(,'end',,,,comment)
        (ne(level) error("  unclosed if conditional clause"))
            report(nlines,      'lines read')
            report(nstmts,      'statements processed')
            report(ntarget,     'target code lines produced')
        report(&stcount,    'spitbol statements executed')
            differ(nerrors) report(nerrors,'errors detected')
        report =
+     differ(lasterror) '  the last error was in line ' lasterror
        &code   = ne(nerrors) 2001
            report(collect() * 5,   'free bytes')
        t = convert(prctab,'array')                     :f(g.end.2)
            output = '  procedures with inp, no prc'
        i = 1
g.end.1
        output = t[i,1] ' ' t[i,2]                      :f(g.end.2)
        i = i + 1                                       :(g.end.1)
g.end.2
                                                        :(end)
g.ent
        labtab[label] = 5                               :(stmtout)
g.h                                                     :(stmtout)
	error('reached g.h')				:(nextstmt)
g.sec
        sectnow = sectnow + 1                           :(stmtout)
g.ttl
        thisline len(10) rem . t
        t span(' ') =
        outstmt(,'ttl','27,' t)                         :(nextstmt)
g.erb
g.err   thisline break(',') len(1) rem . t
        outstmt(label,opcode,op1, t)                    :(nextstmt)
g.inp
        ident(label) error('no label for inp')
        differ(t = prctab[label]) error('duplicate inp')
        prctab[label] = op1                             :(stmtout)
g.prc
        ident(label) error('no label for prc')
        ident(t = prctab[label]) error('missing inp')
        differ(t,op1) error('inconsistent inp/prc')
        prctab[label] =                                 :(stmtout)
end

*	dostmt is invoked to initiate processing of the next line from
*	rdline.
*	after doing this, dostmt branches to the generator routine indicated
*	for this opcode if there is one.
*	the generators all have entry points beginning
*	with "g.", and can be considered a logical extension of the
*	dostmt routine.  the generators have the choice of branching back
*	to dsgen to cause the thisstmt plex to be sent to outstmt, or
*	or branching to dsout, in which case the generator must output
*	all needed code itself.

*	the generators are listed in a separate section below.
	trandate = date()
*	 exit(-2)

