-title mincod: phase 2 translation from minimal tokens to 80386 code
-stitl description

* ops with result that may be a memory reference (always in first argument)
* add aov dca dcv ica icv mnz mov sti str sub zer zgb

* copyright 1987-2012 robert b. k. dewar and mark emmer.
* copyright 2012-2013 david shields
*
* this file is part of macro spitbol.
*
*     macro spitbol is free software: you can redistribute it and/or modify
*     it under the terms of the gnu general public license as published by
*     the free software foundation, either version 2 of the license, or
*     (at your option) any later version.
*
*     macro spitbol is distributed in the hope that it will be useful,
*     but without any warranty; without even the implied warranty of
*     merchantability or fitness for a particular purpose.  see the
*     gnu general public license for more details.
*
*     you should have received a copy of the gnu general public license
*     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
*
*
*  this program takes input file in minimal token form and
*  produces assembly code for intel 80386 processor.
*  the program obtains the name of the file to be translated from the
*  command line string in host(0).  options relating to the processing
*  of comments can be changed by modifying the source.
*
*  in addition to the minimal token file, the program requires the
*  name of a "machine definition file" that contains code specific
*  to a particular 80386 assembler.
*
*  you may also specify option flags on the command line to control the
*  code generation.  the following flags are processed:
*	compress	generate tabs rather than spaces in output file
*       comments        retain full-line and end-of-line comments
*
*  the variable arch is set equal to the uppercase name of the machine
*  being processed.  specific tests upon this variable are discouraged, as
*  all machine-dependent code should be placed in the machine-definition
*  file if possible.
*
*  in addition to the normal minimal register complement, one scratch
*  work register, wt is defined.
*  see the register map below for specific allocations.
*
*  this program is based in part on earlier translators for the
*  it is based in part on earlier translators for the dec vax
*  (vms and un*x) written by steve duff and robert goldberg, and the
*  pc-spitbol translator by david shields.
*
*  to run under spitbol:
*       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt
*
*	reads <file>.lex	containing tokenized source code
*       writes <file>.s         with 80386 assembly code
*	also writes <file>.err	with err and erb error messages
*       parts of <machine>.hdr  are prepended and appended to <file>.s
*	also sets flags		to 1 after converting names to upper case
*	also reads <file>.pub	for debug symbols to be declared public
*
*  example:
*       spitbol -u v37:dos:compress codlinux.spt
*
*
*  revision history:
*
        version = 'v1.12'
	rcode = '_rc_'
*
*
-eject
*
*  keyword initialization
*
	&anchor = 1;	&stlimit = 10000000;	&trim	= 1;  &dump = 1
*
*  useful constants
*
	letters = 'abcdefghijklmnopqrstuvwxyz'
	ucase  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	lcase   = letters
	nos     = '0123456789'
	tab	= char(9)

	define('lower(s)')
	define('upper(s)')

*  default the parameter string if none present
*
        arch = (differ(host(0)) host(0), "i32")
	arch = lower(arch)
	output = 'target architecture ' arch
*        output = ident(fileprefix) "filename (.lex) required" :s(end)
	fileprefix = "s"
	output = '  target architecture:' arch

*	1 is bytes per word, 1 is characters per word
*       these should agree with values used in translator
* set target-dependent configuration parameters
	:($('config.' lower(arch)))

config.i32
config.i32-8
	hdr = 'i32'
*	op_w is instruction suffix for word-size
	op_w = ''
*	op_c is instruction suffix for minimal character size
	op_c = ''

*	set z_trace to enable instruction by instruction trace
	z_trace = 0
*	z_limit is maximum number of calls to be generated if non-zero
	z_limit = 000
*	set z_first non-zero to skip first number of instructions that would generate trace
	z_first = 0
*	will set in_executable when in part of program where executable
*	instructions may occur
	z_exec = 0
*
*	z_suspend is set to temporarily disable the trace.
	z_suspend = 0
*	set in_skip when should not insert trace code, else assembly errors result.
*	start with skip on, turn off when see first start of code.
	z_skip = 1
*	skip_on and skip_off are labels indicating the start and end,
*	respectively, of sections of the code that should not be traced,
*	usually because they contain a loop instruction that won't
*	compile if too much trace code is inserted.
	skip_on = table(50)
	skip_off = table(50)

	define('skip_init(s)on,off')		:(skip_init.end)
skip_init	s break(':') . on ':' rem . off	:f(return)
	skip_on[on] = 1
	skip_off[off] = 1			:(return)
skip_init.end

*	skip_init('start:ini03')
   	skip_init('gbcol:gtarr')
*	skip_init('gtn01:gtnvr')
*	skip_init('bpf05:bpf07')
*	skip_init('scv12:scv19')
*	skip_init('exbl1:exbl2')
*	skip_init('exbl5:expan')
*	skip_init('prn17:prn18')
*	skip_init('ini11:ini13')
*	skip_init('oex13:oexp2')
*	skip_init('oex14:oexp6')
*	skip_init('bdfc1:b_efc')
*	skip_init('sar01:sar10')
*	skip_init('srpl5:srpl8')
*	skip_init('pflu1:pflu2')
*	skip_init('prpa4:prpa5')
*	skip_init('prn17:prn18')
*	skip_init('prtvl:prtt1')
*	skip_init('trim4:trim5')
*	skip_init('prnl1:prnl2')
*	skip_init('prti1:prtmi')
*	skip_init('srpl5:srpl8')


*
*  data structures
*
	data('minarg(i.type,i.text)')
	data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment)')

	sectnow = 0

*	ppm_cases gives count of ppm/err statments that must follow call to
*	a procedure

	ppm_cases = table(50,,0)

*
*  function definitions
*
*  crack parses stmt into a stmt data plex and returns it.
*  it fails if there is a syntax error.
*
	define('crack(line)operands,operand,char')
*
	define('chktrace()')
*	comregs - map minimal register names to target register names
	define('comregs(line)t,pre,word')
*
*  error is used to report an error for current statement
*
	define('error(text)')
	define('flush()')
	define('genz()')
	define('genaop(stmt)')
	define('genbop(stmt)')
        define('genlab()')
	define('genop(gopc,gop1,gop2,gop3)')
	define('genopl(gopl,gopc,gop1,gop2,gop3)')
	define('get1()')
	define('get2()')
	define('getarg(iarg,imem)l1,l2,t1,t2')
	define('getoff(iarg)atype')
	define('getreg(iarg)atype')
	define('iflit(iarg)')
	define('ifmem(iarg)')
	define('ifreg(iarg)')
	define('memmem()t')
	define('move(dst,src)dtype,stype,mop,stext,dtext')
	define('prcent(n)')
	define('prsarg(iarg)l1,l2')
	define('put1()')
	define('report(num,text)')
	define('tblini(str)pos,cnt,index,val,lastval')

*  outstmt is used to send a target statement to the target code
*  output file outfile
*
	define('outstmt(ostmt)label,opcode,op1,op2,op3,comment,t,stmtout')

*  readline is called to return the next non-comment line from
*  the minimal input file (infile <=> lu1).   note that it will
*  not fail on eof, but it will return a minimal end statement
*
	define('readline()')
*
	 p.comregs = break(letters) . pre span(letters) . word

*  exttab has entry for external procedures
*
	exttab = table(50)

*  labtab records labels in the code section, and their line numbers
*
	labtab = table(500)

*  for each statement, code in generated into three
*  arrays of statements:
*
*	astmts:	statements after opcode (()+, etc.)
*	bstmts: statements before code (-(), etc)
*	cstmts: generated code proper
*
	astmts = array(20,'')
	bstmts = array(10,'')
	cstmts = array(20,'')
*
*  genlabels is count of generated labels (cf. genlab)
*
	genlabels = 0

*
*  initialize variables
*
	labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
	lastopc = lastop1 = lastop2 =
	data_lc = 0
	max_exi = 0
*
*  initial patterns
*
*  p.csparse parses tokenized line
	p.csparse = '{' break('{') . inlabel
.	'{' break('{') . incode
.	'{' break('{') . iarg1
.	'{' break('{') . iarg2
.	'{' break('{') . iarg3
.	'{' break('{') . incomment
	'{' rem . slineno

*  dispatch table
*
	getargcase = table(27)
	getargcase[1] = .getarg.c.1;   getargcase[2] = .getarg.c.2
	getargcase[3] = .getarg.c.3;   getargcase[4] = .getarg.c.4
	getargcase[5] = .getarg.c.5;   getargcase[6] = .getarg.c.6
	getargcase[7] = .getarg.c.7;   getargcase[8] = .getarg.c.8
	getargcase[9] = .getarg.c.9;   getargcase[10] = .getarg.c.10
	getargcase[11] = .getarg.c.11; getargcase[12] = .getarg.c.12
	getargcase[13] = .getarg.c.13; getargcase[14] = .getarg.c.14
	getargcase[15] = .getarg.c.15; getargcase[16] = .getarg.c.16
	getargcase[17] = .getarg.c.17; getargcase[18] = .getarg.c.18
	getargcase[19] = .getarg.c.19; getargcase[20] = .getarg.c.20
	getargcase[21] = .getarg.c.21; getargcase[22] = .getarg.c.22
	getargcase[23] = .getarg.c.23; getargcase[24] = .getarg.c.24
	getargcase[25] = .getarg.c.25; getargcase[26] = .getarg.c.26
	getargcase[27] = .getarg.c.27

*
*  pifatal maps minimal opcodes for which no a code allowed
*  to nonzero value. such operations include conditional
*  branches with operand of form (x)+
*
	pifatal = tblini(
.	'aov[1]beq[1]bne[1]bge[1]bgt[1]bhi[1]ble[1]blo[1]'
.	'blt[1]bne[1]bnz[1]ceq[1]cne[1]mfi[1]nzb[1]zrb[1]')
*
*	trace not working for mvc (x32/x64)

	is_executable = table(100)
	s =
+       'add adi adr anb aov atn '
+	'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti dvi dvr erb esw etx flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp '
+       'jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvw mwb ngi eti ngr nzb orb plc prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer '
+       'zgb zrb'

*	don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)

is_exec.1
	s len(3) . opc ' ' =			:f(is_exec.2)
	is_executable[opc] = 1			:(is_exec.1)
is_exec.2

-stitl main program
*  here follows the driver code for the "main" program.

*
*  loop until program exits via g.end
*
*  opnext is invoked to initiate processing of the next line from
*  readline.
*  after doing this, opnext branches to the generator routine indicated
*  for this opcode if there is one.
*  the generators all have entry points beginning
*  with "g.", and can be considered a logical extension of the
*  opnext routine.  the generators have the choice of branching back
*  to dsgen to cause the thisstmt plex to be sent to outstmt, or
*  or branching to dsout, in which case the generator must output
*  all needed code itself.
*
*  the generators are listed in a separate section below.
*
*
*  get file name

*
* get definition file name following token file name, and flags.
*
*	fileprefix ? break(';:') . fileprefix len(1) (break(';:') | rem) . target
*+		((len(1) rem . flags) | '')
*	$replace(target,lcase,ucase) = 1
*
* parse and display flags, setting each one's name to non-null value (1).
*
 :(flgs.skip)
flgs	flags ? ((len(1) break(';:')) . flag len(1)) |
+	 ((len(1) rem) . flag) =			:f(flgs2)
	flag = replace(flag,lcase,ucase)
        output = "  flag: " flag
	$flag = 1					:(flgs)
*
flgs.skip
flgs2
*
* various constants
*
        comment.delim = ';'

	xl = 'xl'; xr = 'xr'; xs = 'xs'; xt = 'xl'
	wa = 'wa'; wb = 'wb'; wc = 'wc'
	w0 = 'w0'; w1 = 'w1'; w2 = 'w2'
	ia = 'ia'; cp = 'cp'

	w1.minarg = minarg(8, 'w1')
	w2.minarg = minarg(8, 'w2')

*  other definitions that are dependent upon things defined in the
*  machine definition file, and cannot be built until after the definition
*  file has been read in.
*
*  p.outstmt examines output lines for certain types of comment contructions
	fillc	  = (ident(compress) " ",tab)
	p.outstmt = (break(fillc) . label span(fillc)) . leader
+			comment.delim rem . comment
	p.alltabs = span(tab) rpos(0)

*  strip end of comments if y
*
	strip_comment = (differ(comments) 'n', 'y')

	filenami = fileprefix '.lex'
        input(.infile,1,filenami)                     :s(inputok)

inputok output = '  input lex file: ' filenami
*
*
*
*  associate output files.
*
	filenamo = fileprefix '.i'
        output(.outfile,2,filenamo)             :s(outputok)
        output = '  cannot open asm file: ' filenamo :(end)
outputok
        output = '  output asm file: ' filenamo

*
* open file for compilation of minimal err and erb messages
*
        output(.errfile,3, fileprefix ".err")	:s(err_ok)
        output = "  cannot open error message file: " fileprefix ".err" :(end)
err_ok


*  then copy contents of <machine>.hdr (if it exists) to outfile
*  stop at line with just 'end' or end of file
*
	noutlines = noutlines + 1

	input(.hdrfile,4,hdr '.hdr')	:f(nohdr)
	havehdr = 1
        output = '  input header file:  ' hdr  '.hdr'
hdrcopy line = hdrfile				:f(hdrend)
	ident(line,'end')			:s(nohdr)
	outfile = line
	noutlines = noutlines + 1		:(hdrcopy)
hdrend	havehdr =
nohdr
*
*  will have havehdr non-null if more remains to copy out at end.
*
*  read in pub file if it exists.  this contains a list of symbols to
*  be declared public when encountered.
*
	pubtab = table(2)
	input(.pubfile,5, fileprefix ".pub")		:f(nopub)
	pubtab = table(101)
pubcopy	line = pubfile				:f(pubend)
	pubtab[line] = 1			:(pubcopy)
pubend	endfile(5)
nopub

						:(dsout)
  &trace = 2000
  &ftrace = 1000
*  &profile = 1
dsout
opnext	thisline = readline()
	crack(thisline)				:f(dsout)
*	 output = thisline
*
* append ':' after label if in code or data.
*
* output label of executable instruction immediately if there is one,
* as it simplifies later processing, especially for tracing.
	ident(inlabel)				:s(opnext.1)
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
* keep the label as is is not in executable code
	lt(sectnow,5)				:s(opnext.1)
* here if in code, so output label now
* defer label processing for ent to allow emission of alignment ops for x86.
	ident(incode,'ent')			:s(opnext.1)
	outfile = thislabel
	outlines = outlines + 1
* set lastlabel so can check to avoid emitting duplicate label definitions
	lastlabel = thislabel
* clear out label info once generated
	label = thislabel =
opnext.1
	thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
	i1 = prsarg(iarg1)
	i2 = prsarg(iarg2)
	i3 = prsarg(iarg3)

	tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.		i.text(i2) ' ' i.text(i3)
	argerrs = 0
						:($('g.' incode))
*  here if bad opcode
ds01	error('bad op-code')			:(dsout)

*  generate tokens.
*
ds.typerr
	error('operand type zero')		:(dsout)
-stitl comregs(line)t,pre,word
comregs
	line p.comregs =			:f(comregs1)
	word = eq(size(word),2) differ(t = word) t
	comregs = comregs pre word		:(comregs)
comregs1 comregs = comregs line			:(return)
-stitl crack(line)
*  crack is called to create a stmt plex containing the various parts  of
* the minimal source statement in line.  for conditional assembly ops,
* the opcode is the op, and op1 is the symbol.  note that dtc is handled
*  as a special case to assure that the decomposition is correct.

*  crack prints an error and fails if a syntax error occurs.
*
crack   nstmts  = nstmts + 1
	op1 = op2 = op3 = typ1 = typ2 = typ3 =
	line    p.csparse			:s(return)
*  here on syntax error
*
	error('source line syntax error')	:(freturn)
-stitl error(text)
*  this module handles reporting of errors with the offending
*  statement text in thisline.  comments explaining
*  the error are written to the listing (including error chain), and
*  the appropriate counts are updated.
*
error   outfile = '* *???* ' thisline
	outfile = '*       ' text
.	          (ident(lasterror),'. last error was line ' lasterror)
	lasterror = noutlines
	noutlines = noutlines + 2
	le(nerrors = nerrors + 1, 10)		:s(dsout)
        output = 'too many errors, quitting'  :(end)
-stitl genaop(stmt)
genaop
	astmts[astmts.n = astmts.n + 1] = stmt	:(return)
-stitl genbop(stmt)
genbop
	bstmts[bstmts.n = bstmts.n + 1] = stmt	:(return)

-stitl genlab()
*  generate unique labels for use in generated code
genlab	genlab = '_l' lpad(genlabels = genlabels + 1,4,'0') :(return)

-stitl genopl(gopl,gopc,gop1,gop2,gop3)
*  generate operation with label
genopl	cstmts[cstmts.n = cstmts.n + 1] =
.		tstmt(gopl,lower(gopc),gop1,gop2,gop3)	:(return)

-stitl genop(gopc,gop1,gop2,gop3)
*  generate operation with no label
genop   genopl(,lower(gopc),gop1,gop2,(differ(gop3) gop3,0))            :(return)

-stitl get1()
* return register if i1 is register, else load i1 value to w1
get1
	ifreg(i1)				:f(get1.1)
        get1 = getreg(i1)                      :(return)
get1.1
        iflit(i1)                              :f(get1.2)
	genop('loadi',w1,w0,getoff(i1))		:(get1.3)
get1.2
* here if source in memory, so load to w1
        move(w1.minarg,i1)
get1.3
* merge to return with argument now in w1
        get1 = w1	                        :(return)

-stitl get2()
* return register if i2 is register, else load i2 value to w1
get2
	ifreg(i2)				:f(get2.1)
        get2 = getreg(i2)                      :(return)
get2.1
        iflit(i2)                              :f(get2.2)
	genop('loadi',w2,w0,getoff(i2))		:(get2.3)
get2.2
* here if source in memory, so load to w2
        move(w2.minarg,i2)
get2.3
* merge to return with argument now in w1
        get1 = w2	                        :(return)

-stitl getarg(iarg,imem)
getarg
	l1 = i.text(iarg)
	l2 = i.type(iarg)
	eq(l2)					:f($(getargcase[l2]))
	getarg = l1				:(return)

* int
getarg.c.1 getarg = l1				:(return)

* dlbl
getarg.c.2 getarg = l1				:(return)

* wlbl, clbl
getarg.c.3
getarg.c.4 getarg =  l1      	:(return)

* elbl, plbl
getarg.c.5
getarg.c.6 getarg = l1				:(return)

* w,x, map register name
getarg.c.7
getarg.c.8
	getarg = $l1			:(return)

* (x), register indirect
getarg.c.9
	l1 len(1) len(2) . l2
	l2 = $l2
	getarg =  l2 				:(return)

* (x)+, register indirect, post increment
getarg.c.10
	l1 = substr(l1,2,2)
	t1 = $l1
	getarg =  t1
 	(ident(l1,'xs') genaop(tstmt(,'inc',t1))) :s(return)
 	genaop(tstmt(,'lea',t1,'[' t1 '+1]'))	:(return)

*  -(x), register indirect, pre decrement
getarg.c.11
	t1 = $substr(l1,3,2)
	getarg =  t1
	genbop(tstmt(,'lea',t1,'[' t1 '-1]')) :(return)

* int(x)
* dlbl(x)
getarg.c.12
getarg.c.13
	l1 break('(') . t1 '(' len(2) . t2
	getarg =  $t2 '!' t1   	:(return)

*  name(x), where name is in working section
getarg.c.14
getarg.c.15
	l1 break('(') . t1 '(' len(2) . t2
	getarg = $t2 '!' t1 :(return)

* signed integer
getarg.c.16 getarg = l1				:(return)

* signed real
getarg.c.17 getarg = l1				:(return)

*  =dlbl
getarg.c.18
	getarg = substr(l1,2)			:(return)

*  *dlbl
getarg.c.19
	getarg = substr(l1,2)		:(return)

*  =name (data section)
getarg.c.20
getarg.c.21
        getarg =  substr(l1,2) 			:(return)

*  =name (program section)
getarg.c.22
        getarg =  substr(l1,2)   		:(return)

*  pnam, eqop
getarg.c.23
getarg.c.24 getarg = l1				:(return)

* ptyp, text, dtext
getarg.c.25
getarg.c.26
getarg.c.27 getarg = l1				:(return)

-stitl getoff(iarg)atype
- return offset of argument, or 0
getoff
	getoff = 0
	lt(atype,2)			:s(return)
	gt(atype,6)			:s(getoff.1)
* here if plain label, just return it
	getoff = i.text(iarg)		:(return)
getoff.1
	lt(atype,12)			:s(return)
	gt(atype,15)			:s(return)
	i.text(iarg) break('(') . getoff	:(return)

-stitl getreg(iarg)atype
* return register associated with argument, or null if no register
getreg
	atype = i.type(iarg)
	lt(atype,6)			:s(return)
	gt(atype,8)			:s(getreg.1)
* here if explicit x or w register
	getreg = i.text(iarg)		:(return)
getreg.1
	gt(atype,15)			:s(getreg.2)
* here if register enclosed in parentheses
	i.text(iarg) break('(') len(2) . getreg 	:(return)
getreg.2
* no type if numeric constant
	le(atype,17)			:s(return)
	gt(atype,22)			:s(return)
* here if literal, so return w0
	getreg = 'w0'			:(return)

						:(return)
-stitl memmem()t
memmem
*  memmem is called for those ops for which both operands may be
*  in memory, in which case, we generate code to load second operand
*  to pseudo-register 'w2', and then modify the second argument
*  to reference this register
*
  :(return)
  ifmem(i1) ifmem(i2    )			:f(return)
*  here if memory-memory case, load second argument
  t = get2()
  i2 = w2.minarg
  genop('mov','w2',t)				:(return)

-stltl move(dst,src)dtype,stype,stext,dtext
* generate code for move instruction
move
* output ops are
* move - from register to register
* load - load from memory
* loadi - load immediate (note this can be done as move with src=r0 and off=value)
* push - push value from memory
* pushi - push immdiate, that is, of the effective address
* pop	- pop stack value to memory
* popr  - pop stack value to registera
*
* result may need to be stored back to memory
* new special casing
	stype = i.type(src); stext = i.text(src)
	dtype = i.type(dst); dtext = i.text(dst)

* 	output = ' ' lpad(dtype,2,'0') lpad(stype,2,'0') ' ' dtext ',' stext

* look for register to register move
        ifreg(src) ifreg(dst) genop('mover',getreg(dst),getreg(src))  :s(return)

* look for pop to register
        ifreg(dst) eq(stype,10) genop('popr',getreg(dst),getreg(src)) :s(return)

* look for pop to memory
	ifmem(dst) eq(stype,10)  genop('pop',getreg(src),getreg(dst),getoff(dst))    :s(return)
* look for push of literal
 	eq(dtype,11) iflit(src)  genop('pushl',getarg(dst),w0,getoff(src))   :s(return)
* look for push of memory value
 	eq(dtype,11) ifmem(src)  genop('pushm',getarg(dst),getreg(src),getoff(src))   :s(return)
* look for push of register
 	eq(dtype,11) ifreg(src)  genop('pushr',getarg(dst),getreg(src),0)  :s(return)

* look for load of immediate value
	ifreg(dst) iflit(src) genop('loadi',getreg(dst),w0,getoff(src))  :s(return)

* look for load from memory
	ifreg(dst) ifmem(src) genop('load',getreg(dst),getreg(src),getoff(src))  :s(return)

* look for store
	ifmem(dst) ifreg(src) genop('store',getreg(src),getreg(dst),getoff(dst))  :s(return)

* here if have memory-to-memory case, so move src to w1 and then do store
*	memmem()
	move(w1.minarg,src)
	move(dst,w1.minarg)
						:(return)
move.1
        genop(mop,getarg(i1),getarg(i2))        :(return)


-stitl prcent(n)
prcent prcent = 'prc_' '+'  (1 * ( n - 1)) :(return)

-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment)
*  this module writes the components of the statement
*  passed in the argument list to the formatted .s file
*
outstmt	label = t.label(ostmt)
* clear label if definition already emitted
	label = ident(label, lastlabel)

outstmt1
	comment = t.comment(ostmt)
* ds suppress comments
 	comment = tcomment = comments =
 	:(outstmt2)
*  attach source comment to first generated instruction
	differ(comment)				:s(outstmt2)
	ident(tcomment)				:s(outstmt2)
	comment = tcomment; tcomment =
outstmt2
	opcode = t.opc(ostmt)
	op1 = t.op1(ostmt)
	op2 = t.op2(ostmt)
	op3 = t.op3(ostmt)
	differ(compress)			:s(outstmt3)
	stmtout = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.		  (ident(op1), op1
.			(ident(op2), ',' op2
.				(ident(op3), ',' op3))) ,27)
.       (ident(strip_comment,'y'), ' ' (ident(comment), ';') comment)
.						:(outstmt4)
outstmt3
	stmtout = label tab opcode tab
.		  (ident(op1), op1
.		    (ident(op2), ',' op2
.		      (ident(op3), ',' op3)))
.       (ident(strip_comment,'y'), tab (ident(comment), ';') comment)
*
**	send text to outfile
*
**
outstmt4
**
**	send text to output file if not null.
*
*	stmtout = replace(trim(stmtout),'$','_')
	stmtout = trim(stmtout)
	ident(stmtout)				:s(return)
	eq(z_trace)				:s(outstmt5)
*	here if trace code desired for executable instructions
	chktrace()
outstmt5
	ident(stmtout)				:s(return)
	outfile = stmtout
	ntarget	= ntarget + 1
	noutlines = noutlines + 1
*
*  record code labels in table with delimiter removed.
	(ge(sectnow,5) differ(thislabel))	:f(return)
	label ? break(':') . label		:f(return)
	labtab<label> = noutlines		:(return)

-stitl  chktrace()
chktrace
*						:(return)
*	output = 'chktrace:' inlines ':' label ':' stmtout
*	output = differ (label) 'chktrace label:' label ':'
*	turn off skip mode when begin executable code
	clabel = inlabel
 	old_z_skip = z_skip
 	old_z_exec = z_exec
 	old_is_exec = is_exec
	z_skip = ident(inlabel,'s_aaa') 0

*	incode ? any(lcase)			:s(return)
	uopcode  = replace(incode, lcase,ucase)
*  do not trace bsw (for now)
	ident(uopcode,'bsw')			:s(return)
	is_exec = is_executable[uopcode]
	z_exec = ne(z_trace)  ident(inlabel, 's_aaa') 1
	z_exec = gt(nlines,2186) 1
*	need to skip certain blocks since otherwise get branches that are too long
*	skip when in code that won't assemble if try to trace
*	this was discovered on a case-by-case basis.

 	z_skip  = differ(inlabel) differ(skip_on[inlabel]) 1
 	z_skip  = differ(inlabel) differ(skip_off[inlabel]) 0

	ne(z_skip)				:s(return)
	eq(z_exec)				:s(return)
	eq(is_exec)				:s(return)
*	here to emit trace. need to emit trace after label if there is label
* 	ident(inlabel)				:s(chktrace.1)
*	only trace at labels since get jumps that are too removed otherwise
*	ident(label)				:s(return)
*	here to emit trace code when there is label
*	first need to emit label, then fall through

*	stmtout ? break_ws  . label spanws  rem . body	:f(outstmt5)
* 	stmtout = tab body
*	outfile = label
*	label =
	ne(in_gcol)				:s(return)
chktrace.1
	genz()
						:(return)
genz
*	no trace if trace has been suspended
*	output = ne(z_suspend) 'z_suspend ' thisline
 	ne(z_suspend)			:s(return)
* only trace at label definition
*	ident(thislabel)			:s(return)
	z_count = z_count + 1
	gt(z_first) le(z_count,z_first)		:s(return)
	gt(z_limit)  gt(z_count, z_limit)	:s(return)
*	always generate trace if at label definition
	z_desc = '"' replace(thisline,'{',' ') '"'
	outfile = tab 'zzz' tab	z_count ',' nlines ',' z_desc
	outlines = outlines + 1
						:(return)

-stitl prsarg(iarg)
prsarg	prsarg = minarg(0)
	iarg break(',') . l1 ',' rem . l2	:f(return)
	prsarg = minarg(convert(l1,'integer'),l2)	:(return)

-stitl put1()
put1
* no need to issue store if argument is plain register
	ident(get1.mem)				:s(return)
* issue store in case first argument is memory location that must be updated
        genop('put',w1,get1.mem)
						:(return)

-stitl readline()
*  this routine returns the next statement line in the input file
*  to the caller.  it never fails.  if there is no more input,
*  then a minimal end statement is returned.
*  comments are passed through to the output file directly.
*
*
readline readline = lower(infile)                      :f(rl02)
	nlines  = nlines + 1
	ident( readline )			:s(readline)
readline.0
	leq( substr(readline,1,1 ),'*' )       	:f(rl01)
	z_skip = ident(readline,'*z+') 0	:s(readline)
	z_skip = ident(readline,'*z-') 1	:s(readline)
* force skip of full line comments
	:(readline)
*
*  only print comment if requested.
*
	ident(strip_comment,'n')		:f(readline)
        readline len(1) = ';'
	outfile = readline
	noutlines = noutlines + 1               :(readline)
*
*  here if not a comment line
*
rl01						:(return)
*
*  here on eof
*
rl02    readline = '       end'
						:(rl01)
-stitl tblini(str)
*  this routine is called to initialize a table from a string of
*  index/value pairs.
*
tblini   pos     = 0
*
*  count the number of "[" symbols to get an assessment of the table
*  size we need.
*
tin01   str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.						:s(tin01)
*
*  allocate the table, and then fill it. note that a small memory
*  optimisation is attempted here by trying to re-use the previous
*  value string if it is the same as the present one.
*
	tblini   = table(cnt)
tin02   str     (break('[') $ index len(1) break(']') $ val len(1)) =
.						:f(return)
	val     = convert( val,'integer' )
	val     = ident(val,lastval) lastval
	lastval = val
	tblini[index] = val			:(tin02)
-stitl generators

iflit	ge(i.type(iarg),18) le(i.type(iarg),22) :f(freturn)s(return)

ifmem
        ge(i.type(iarg),3) lt(i.type(iarg),6)    :s(return)
	ge(i.type(iarg),9) le(i.type(iarg),15)	:s(return)f(freturn)

ifreg	ge(i.type(iarg),7) le(i.type(iarg),8) 	:f(freturn)s(return)

g.mov
	move(i1,i2)				:(opdone)
g.none
* here for standard case with no arguments
        genop(incode)                           :(opdone)

g.one
* here for standard case with single value argument
        genop(incode,get1())
                                                :(opdone)
g.two
* here for standard case with two value arguments
        genop(incode,get1(),get2(),0)
                                                :(opdone)

g.oneput
* here for standard case with single argument which is computed
        genop(incode,get1())
        differ(get1.mem) put1('w1',get1.mem)
                                                :(opdone)
g.twoput
* here for standard case with two arguments
        genop(incode,get1(),get2())
        differ(get1.mem) put1('w1',get1.mem)
                                                :(opdone)


g.brn
        genop('brn',getarg(i1))                 :(opdone)
        

g.bsw	t1 = getarg(i1)
	t2 = genlab()
	z_suspend = 1
	ident(i.text(i3))			:s(g.bsw1)
	genop('cmp',t1,getarg(i2))
	genop('jge',getarg(i3))
* here after default case.
g.bsw1	genop('jmp', '[' t2 '+' t1 ']')
        genopl(t2 ':')
	z_suspend = 0
						:(opdone)

g.iff   genop('lbl',getarg(i2))              :(opdone)

g.esw
        					:(opdone)
g.ent
*
*  entry points are stored in byte before program entry label
*  last arg is optional, in which case no initial 'db' need be
*  issued. we force odd alignment so can distinguish entry point
*  addresses from block addresses (which are always even).
*
*  note that this address of odd/even is less restrictive than
*  the minimal definition, which defines an even address as being
*  a multiple of 1 (4), and an odd address as one that is not
*  a multiple of 1 (ends in 1, 2, or 3).  the definition here
*  is a simple odd/even, least significant bit definition.
*  that is, for us, 1 and 3 are odd, 2 and 4 are even.
*

	t1 = i.text(i1)
*        genop('align',2)
	outfile = tab 'align' tab '2'
	differ(t1)				:s(g.ent.1)
	outfile = tab 'nop'
						:(g.ent.2)
g.ent.1
	outfile = tab 'dw' tab	t1

g.ent.2
	outlines = outlines + 2
	genopl(thislabel)
*  note that want to attach label to last instruction
*	t1 = cstmts[cstmts.n]
*	t.label(t1) = tlabel
*	cstmts[cstmts.n] = t1
*  here to see if want label made public
	thislabel ? rtab(1) . thislabel ':'
*        (differ(pubtab[thislabel]), differ(debug)) genop('global',thislabel)
	thislabel =				:(opdone)

g.bri	genop('jmp',getarg(i1))			:(opdone)

g.lei	t1 = $i.text(i1)
	genop('lei',t1)	                        :(opdone)

g.jsr
	jsr_proc = getarg(i1)
	genop('call',jsr_proc)
*	get count of following ppm statements
	jsr_count = ppm_cases[jsr_proc]
	eq(jsr_count)				:s(opdone)
	z_suspend = 1
	jsr_calls = jsr_calls +  1
	jsr_label = 'call_' jsr_calls
	jsr_label_norm = jsr_label
	genop('dec','[' rcode ']')
	genop('js',jsr_label_norm)
	z_suspend = 0

*	generate branch around for ppms that will follow
*	take the branch if normal return (eax==0)
						:(opdone)

g.err
g.ppm

*  here with return code in rcode. it is zero for normal return
*  and positive for error return. decrement the value.
*  if it is negative then this is normal return. otherwise,
*  proceed decrementing rcode until it goes negative,and then
*  take the appropriate branch.

	t1 = getarg(i1)

*  branch to next case if rcode code still not negative.
	ident(incode,'ppm')			:s(g.ppm.loop)
	count.err =  count.err + 1
	errfile =   i.text(i1) ' ' i.text(i2)
	max.err = gt(t1,max.err) t1
						:(g.ppm.loop)

g.ppm.loop.next
	genopl(lab_next ':')
 	jsr_count = jsr_count - 1
 	z_suspend = eq(jsr_count) 0
	eq(jsr_count) genopl(jsr_label_norm ':') :(opdone)
g.ppm.loop
	lab_next = genlab()
	genop('dec','[' rcode ']')
	genop('jns',lab_next)
	ident(incode,'ppm')			:s(g.ppm.loop.ppm)
*  here if error exit via exi. set rcode to exit code and jump
*  to error handler with error code in rcode
g.ppm.loop.err
	genop('mov','[' rcode ']', +t1)
	genop('jmp','err_')
						:(g.ppm.loop.next)
g.ppm.loop.ppm
*	check each ppm case and take branch if appropriate
	ident(i.text(i1))			:s(g.ppm.2)
	count.ppm = count.ppm + 1
	genop('jmp',	getarg(i1))
						:(g.ppm.loop.next)

g.ppm.2
*  a ppm with no arguments, which should never be executed, is
*  translated to err 299,internal logic error: unexpected ppm branch
	t1 = 299
	errfile =  t1 ' internal logic error: unexpected ppm branch'
						:(g.ppm.loop.err)

g.prc

*  generate public declaration
*	t1 = thislabel
*	t1 ? rtab(1) . t1 ':'
*	genop()
*	genop('global',t1)
*  nop needed to get labels straight
	prc.args = getarg(i2)
	ppm_cases[thislabel] = i.text(i2)
	thislabel =
	max_exi = gt(prc.args,max_exi) prc.args
	prc.type = i.text(i1)			:($('g.prc.' prc.type))
g.prc.e
g.prc.r						:(opdone)

g.prc.n
*  store return address in reserved location
	prc.count = prc.count + 1
	genop('qop', '[' prcent(prc.count) ']')		:(opdone)

g.exi
 	t3 = i.text(i1)
        t1 = getarg(i1); t2 = prc.type
*  if type r or e, and no exit parameters, just return
 	differ(t2,'n') eq(prc.args)	genop('ret')	:s(opdone)
        t3 = ident(t3) '0'
    	genop('mov','[' rcode ']',+t3)
	ident(t2,'n')				:s(g.exi.1)
	genop('ret')				:(opdone)
g.exi.1

	genop('mov','wt', '['  prcent(prc.count) ']' )
	genop('jmp','wt')
						:(opdone)
g.enp   genop()					:(opdone)

g.erb
	errfile =  i.text(i1) ' ' i.text(i2)
*	set rcode to error code and branch to error handler
	genop('mov', '[' rcode ']',  +(i.text(i1)))
 	genop('jmp','err_')
						:(opdone)

g.start

g.icv
        genop('incv',get1())
        put1()
                                                :(opdone)
g.dcv
        genop('decv',get1())
        put1()
                                                :(opdone)

* for zer (mnz) move register w0 (xs) to target
g.zer
g.mnz
       zer.reg = (ident(incode, 'zer') 'w0', 'xs')
       ifreg(i1)                                :f(g.mnz.1)
       genop('mov', i.text(i1), zer.reg)        :(opdone)
g.mnz.1
* result may need to be stored back to memory
        genop('put',zer.reg,i.text(i1))
                                                :(opdone)

g.ssl   genop()					:(opdone)

g.sss   genop()					:(opdone)

g.rtn
	genop()
                                                :(opdone)

g.add
* may have result in memory
        memmem()
	genop('add',get1(),get2())
        put1()
                                                :(opdone)

g.sub
* result may need to be stored back to memory
        memmem()
	genop('sub',get1(),get2())
        put1()
                                                :(opdone)

g.ica
* result may need to be stored back to memory
        genop('incv',get1())
        put1()
                                                :(opdone)

g.dca
* result may need to be stored back to memory
        genop('decv',get1())
        put1()
                                                :(opdone)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi
*
*  these operators all have two operands, memmem may apply
*
	memmem()
	genop('cmp',get1(),get2())
	genop(incode,getarg(i3))
.						:(opdone)

g.bod
g.bev
g.bnz
g.bze
	genop(incode,get1(),getarg(i2))		:(opdone)


g.lct
*
*  if operands differ must emit code
*
	differ(i.text(i1),i.text(i2))		:s(g.lct.1)
*  here if operands same. emit no code if no label, else emit null
	ident(thislabel)			:s(opnext)
	genop()					:(opdone)

g.lct.1	genop('mov',get1(),get2())	:(opdone)

g.bct
        genop('bct',getarg(i1),getarg(i2),0)    :(opdone)

g.aov
* result may need to be stored back to memory
	genop('add',get2(),get1())
        put1()
	genop('jc',getarg(i3))
						:(opdone)
g.lcp
g.lcw
g.scp
                                                :(g.one)

g.icp
                                                :(g.none)

g.ldi
g.adi
g.mli
g.sbi
g.dvi
g.rmi

                                                :(g.one)
g.ngi
	genop(incode,w0,w0)			:(opdone)

g.sti
* result may need to be stored back to memory

        ifreg(i1)                               :s(opdone)
        genop('put',ia,getarg(i1))
                                                :(opdone)

g.ino
g.iov
        genop(incode,w0,w0,,getarg(i1))                :(opdone)

g.ieq
g.ige
g.igt
g.ile
g.ilt
g.ine
        genop(incode,w0,w0,getarg(i1))                :(opdone)


g.itr genop(incode,w0,w0)			:(opdone)

g.rti
*  here if label given, branch if real too large
        genop(incode,w0,w0,getoff(i1))                 :(opdone)

g.str
* result may need to be stored back to memory

        ifreg(i1)                               :f(g.str.1)
* here if result is register
        genop('mov',getarg(i1), ra)	:(opdone)
g.str.1
        genop('put',ra,getarg(i1))
                                                :(opdone)

g.ldr
g.adr
g.sbr
g.mlr
g.dvr
                                                :(g.one)
g.ngr
g.atn
g.chp
g.cos
g.etx
g.lnf
g.sin
g.sqr
g.tan
                                                :(g.none)

g.rno	t1 = 'jno'				:(g.rov1)
g.rov	t1 = 'jo'
g.rov1  genop('call','ovr_')
	genop(t1,getarg(i1))			:(opdone)

g.req
g.rne
g.rge
g.rgt
g.rle
g.rlt
	genop(incode,w0,w0,getoff(i1))
                                                :(opdone)

g.plc
g.psc
	ne(1,1)				:s(g.plc.1)
*  last arg is optional.  if present and a register or constant,
*  use lea instead.

	t1 = get1()
	t2 = i.type(i2)
	((ifreg(i2), ge(t2,1) le(t2,2))
+	genop('lea',t1,'[cfp_f+' t1 '+' get2() ']')) :s(opdone)
	genop('add',t1,'cfp_f')
	eq(i.type(i2))				:s(opdone)
*
*  here if d_offset_(given (in a variable), so add it in.
*
	genop('add',t1,get2())		:(opdone)

g.plc.1
*  here for case where character size if word size
*  last arg is optional.  if present and a register or constant,
*  use lea instead.

	t1 = get1()
	t2 = i.type(i2)
	((ifreg(i2), ge(t2,1) le(t2,2))
+	genop('lea',t1,'[cfp_f+' t1 '+' get2() ']')) :s(opdone)
	genop('add',t1,'cfp_f')
	eq(i.type(i2))				:s(opdone)
*
*  here if d_offset_(given (in a variable), so add it in, after converting to byte count
	genop('mov','wt', get2())
*
	genop('add',t1,'wt')		:(opdone)
*
*  lch requires separate cases for each first operand possibility.
*
g.lch
	t2 = i.text(i2)
	t1 = get1()

*  see if predecrement needed.
	leq('-',substr(t2,1,1))			:f(g.lcg.1)
	t2 break('(') len(1) len(2) . t3
	(eq(1,1) genop('dec',$t3), genop('dec',$t3))
g.lcg.1
	t2 break('(') len(1) len(2) . t3
	genop('mov','al','[' $t3 ']')
	genop('mov',t1,'w0')

*  see if postincrement needed.
	t2 rtab(1) '+'				:f(g.lcg.2)
	(eq(1,1) genop('inc',$t3), genop('inc',$t3))
g.lcg.2						:(opdone)

g.sch
	t2 = i.text(i2)
	eq(i.type(i1),8)			:s(g.scg.w)
	t1 = get1()
	eq(1,cfp_w)				:f(g.scg.0)
	ident(t2,'(xr)+')			:f(g.scg.0)
*
*  here if can use stos.
*
	eq(1,1) genop('mov','al',get1())
	ne(1,1) genop('mov','eax',get1())
	genop('stos' op_c)			:(opdone)

g.scg.0
	leq('-',substr(t2,1,1))			:f(g.scg.1)
	t2 break('(') len(1) len(2) . t3
	genop('dec',$t3)
	(eq(1,1) genop('dec',$t3), genop('dec',$t3))
g.scg.1
	t2 break('(') len(1) len(2) . t3
	eq(1,1) genop('mov','wt',t1,)
	eq(1,1) genop('mov','[' $t3 ']','al')
	ne(1,1) genop('mov','[' $t3 ']',t1)
*  see if postincrement needed.
	t2 rtab(1) '+'				:f(g.scg.2)
	(eq(1,1) genop('inc',$t3), genop('inc',$t3))
g.scg.2						:(opdone)
g.scg.w
*
*  here if moving character from work register, convert t1
*  to name of low part.
*

	ident(t2,'(xl)')			:s(g.scg.w.xl)
	ident(t2,'-(xl)')			:s(g.scg.w.pxl)
	ident(t2,'(xl)+')			:s(g.scg.w.xlp)
	ident(t2,'(xr)')			:s(g.scg.w.xr)
	ident(t2,'-(xr)')			:s(g.scg.w.pxr)
	ident(t2,'(xr)+')			:s(g.scg.w.xrp)
g.scg.w.xl
	genop('mov','[xl]',t1)		:(opdone)
g.scg.w.pxl
	genop('dec','xl')
	genop('mov','[xl]',t1)			:(opdone)

g.scg.w.xlp
	genop('mov','[xl]',t1)
	genop('inc', 'xl')
						:(opdone)
g.scg.w.xr
	genop('mov','[xr]',t1)			:(opdone)

g.scg.w.pxr
	genop('dec', 'xr')
	genop('mov','[xr]',t1)			:(opdone)
g.scg.w.xrp
	(eq(1,1) genop('mov','al',t1), genop('mov','eax',t1))
	genop('stos' op_c)				:(opdone)

g.csc  	ident(thislabel)			:s(opnext)
	genop()					:(opdone)

g.ceq
g.cne   memmem()
	genop(incode,get1(),get2(),getarg(i3))  :(opdone)

g.cmc
*  cmc has two label operands, so generate two instructions
	genop('cmc1',0,i.text(i1))
	genop('cmc2',0,i.text(i2))
						:(opdone)

g.trc
	genop(incode)				:(opdone)

g.flc
	genop(incode,get1())				:(opdone)

g.anb
g.orb
g.xob
g.rsh
g.lsh
	genop(incode,getarg(i1),getarg(i2))	:(opdone)

g.cmb   genop(incode,getarg(i1))		:(opdone)

g.rsx
	error('rsx not supported')
g.lsx
	error('lsx not supported')

g.nzb	ifreg(i1)				:s(g.nzb1)
	genop('cmp',getarg(i1),'0')
	genop('jnz',getarg(i2))
						:(opdone)
g.nzb1
	genop('or',getreg(i1),getreg(i1))
	genop('jnz',getarg(i2))
						:(opdone)

g.zrb	ifreg(i1)				:s(g.zrb1)
	genop('cmp',getarg(i1),'0')
	genop('jz',getarg(i2))
						:(opdone)
g.zrb1
	genop('or',getreg(i1),getreg(i1))
	genop('jz',getarg(i2))
						:(opdone)

g.zgb
	genop('nop')				:(opdone)

g.zzz
 	genop('zzz',getarg(i1))			:(opdone)

g.wtb   	:(opdone)

g.btw   	:(opdone)

g.mti	(ident(i.text(i1),'(xs)+') genop('qop',ia)) :s(opdone)
	genop('mov',ia,get1())		:(opdone)

g.mfi
*  last arg is optional
*  compare with cfp$m, branching if result negative
	eq(i.type(i2))				:s(g.mfi1)
*  here if label given, branch if wc not in range (ie, negative)
	genop('or',ia,ia)
	genop('js',getarg(i2))
g.mfi1	ident(i.text(i1),'wc') genop()		:s(opdone)
	ident(i.text(i1),'-(xs)') genop('qush',ia)	:s(opdone)
	genop('mov',getarg(i1),ia)		:(opdone)

g.ctw
g.ctb
	genop(incode,getarg(i1))			:(opdone)
g.cvm
	genop(incode,getarg(i1))		:(opdone)

g.cvd
	genop('call','cvd_')			:(opdone)
g.mvc
g.mcb
g.mvw
g.mwb
	genop(incode)				:(opdone)

g.chk
	genop('cmp','xs','lowspmin')
	genop('jb','sec06')
						:(opdone)

decend
*  here at end of dic or dac to see if want label made public
	thislabel ? rtab(1) . thislabel ':'
*        differ(pubtab[thislabel]) genop('global',thislabel)
						:(opdone)

g.dac	t1 = i.type(i1)
        t2 = "" ;*(le(t1,2) "", le(t1,4) "d_offset_(", le(t1,6) "d_offset_(", "")
        genopl(thislabel,'lbl',t2 i.text(i1))
						:(decend)
g.dic   genopl(thislabel,'lbl',i.text(i1))
						:(decend)

g.drc
*	genop('align','1')
	genop('align',8)
	t1 = i.text(i1)
	t1 ? fence "+" = ""
        genop('d_real',t1)
*  note that want to attach label to last instruction
	t.label(cstmts[cstmts.n]) = thislabel
	thislabel =				:(opdone)

g.dtc
        t1 = i.text(i1)
        dtc.count = dtc.count + size(t1)
	genop('dtc', t1)
						:(opdone)
g.dbc   genopl(thislabel,'lbl',getarg(i1))
						:(opdone)
g.equ   genopl(thislabel,'equ',i.text(i1))
						:(opdone)
g.exp
	ppm_cases[thislabel] = i.text(i1)
*	genop('extern',thislabel)
	thislabel =				:(opdone)

g.inp
	ppm_cases[thislabel] = i.text(i2)
	prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
+						:(opnext)

g.inr
        genop(incode, thislabel)                :(opdone)

g.ejc	genop('')				:(opdone)

g.ttl	genop('')
						:(opdone)

g.sec	genop('')
	sectnow = sectnow + 1			:($("g.sec." sectnow))

* procedure declaration section
g.sec.1
*	genop('segment .text')
*        genop('global','sec01')
        genopl('sec01' ':')             	:(opdone)

* definitions section
g.sec.2
*        genop('segment .data')
*        genop('global','sec02')
        genopl('sec02' ':')             	:(opdone)

* constants section
g.sec.3
*        genop('segment .data')
*        genop('global','sec03')
        genopl('sec03' ':')     		:(opdone)

* working variables section
g.sec.4
*	genop('global','esec03')
        genopl('esec03' ':')
*        genop('segment .data')
*        genop('global','sec04')
        genopl('sec04' ':')     :(opdone)

*  here at start of program section.  if any n type procedures,
*  put out entry-word block declaration at end of working storage
g.sec.5
*  emit code to indicate in code section
*  get direction set to up.
*        genop('global','esec04')
        genopl('esec04' ':')
*        (gt(prc.count1) genopl('prc$' ':','times', prc.count1 ' dd 0'))
	genop('prc_: times ' prc.count1 ' dd 0')
        genop('global','lowspmin')
        genopl('lowspmin' ':','lbl','0')
*        genop('global','end_min_data')
        genopl('end_min_data' ':')
*        genop('segment .text')
*        genop('global','sec05')
        genopl('sec05' ':')
						:(opdone)

*  stack overflow section.  output exi__n tail code
g.sec.6
*        genop('global','sec06')
        genopl('sec06'  ':', 'nop')
				             :(opdone)

*  error section.  produce code to receive erb's
g.sec.7
*        genop('global','sec07')
        genopl('sec07' ':')
	flush()
*  error section.  produce code to receive erb's

*	allow for some extra cases in case of max.err bad estimate
	n1 = max.err + 8
	output = '  max.err ' max.err
	genopl('err_:','xchg',wa,'[' rcode ']')
						:(opdone)


opdone	flush()					:(opnext)
*
*  here to emit bstmts, cstmts, astmts. attach input label and
*  comment to first instruction generated.
*
flush	eq(astmts.n) eq(bstmts.n) eq(cstmts.n)	:f(opdone1)
*
*  here if some statements to emit, so output single 'null' statement to get label
*  and comment field right.
*
	label = thislabel =
	outstmt(tstmt())			:(opdone.6)
opdone1	eq(bstmts.n)				:s(opdone.2)
	i = 1
opdone.1
	outstmt(bstmts[i])
	le(i = i + 1, bstmts.n)			:s(opdone.1)

opdone.2	eq(cstmts.n)			:s(opdone.4)
	i = 1
opdone.3
	outstmt(cstmts[i])
	le(i = i + 1, cstmts.n)			:s(opdone.3)

opdone.4	eq(astmts.n)			:s(opdone.6)
	i = 1
	ident(pifatal[incode])			:s(opdone.5)
*  here if post incrementing code not allowed
	error('post increment not allowed for op ' incode)
opdone.5	outstmt(astmts[i])
	le(i = i + 1, astmts.n)			:s(opdone.5)
opdone.6 astmts.n = bstmts.n = cstmts.n =	:(return)
flush_end

report
	output = lpad(num,10) '  ' text		:(return)


g.end
	&dump = 0
	ident(havehdr)				:s(g.end.2)
*  here to copy remaining part from hdr file
g.end.1	line = hdrfile				:f(g.end.2)
	ntarget = ntarget + 1
	noutlines = noutlines + 1
	outfile = line				:(g.end.1)
g.end.2

* here at end of code generation.

	endfile(1)
	endfile(2)
	endfile(3)
        report(nlines,		'lines read')
        report(nstmts,		'statements processed')
        report(ntarget,		'target code lines produced')
	report(&stcount,	'spitbol statements executed')
        report(max.err,		'maximum err/erb number')
        report(prc.count1, 	'prc count')
        report(dtc.count, 	'dtc count')
        output  = '  ' gt(prc.count,prc.count1)
.	  '  differing counts for n-procedures:'
.	  ' inp ' prc.count1 ' prc ' prc.count
        differ(nerrors) report(nerrors,'errors detected')

	errfile = '* ' max.err ' maximum err/erb number'
	errfile  = '* ' prc.count ' prc count'
.		differ(lasterror) '  the last error was in line ' lasterror

	&code   = ne(nerrors) 2001
        report(collect(), 'free words')
	:(end)
* convert argument to upper case
lower
	lower = replace(s,'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
.			  'abcdefghijklmnopqrstuvwxyz')	:(return)
* convert argument to upper case
upper
	upper = replace(s,'abcdefghijklmnopqrstuvwxyz',
.			  'ABCDEFGHIJKLMNOPQRSTUVWXYZ')	:(return)
end
