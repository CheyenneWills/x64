- title mincod: phase 2 translation from minimal tokens to 80386 code
-stitl description

* copyright 1987-2012 robert b. k. dewar and mark emmer.
* copyright 2012-2014 david shields
*
* this file is part of macro spitbol.
*
*     macro spitbol is free software: you can redistribute it and/or modify
*     it under the terms of the gnu general public license as published by
*     the free software foundation, either version 2 of the license, or
*     (at your option) any later version.
*
*     macro spitbol is distributed in the hope that it will be useful,
*     but without any warranty; without even the implied warranty of
*     merchantability or fitness for a particular purpose.  see the
*     gnu general public license for more details.
*
*     you should have received a copy of the gnu general public license
*     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
*
*
*  this program takes input file in minimal token form and
*  produces assembly code for intel 80386 processor.
*  the program obtains the name of the file to be translated from the
*  command line string in host(0).  options relating to the processing
*  of comments can be changed by modifying the source.
*
*  in addition to the minimal token file, the program requires the
*  name of a "machine definition file" that contains code specific
*  to a particular 80386 assembler.
*
*  you may also specify option flags on the command line to control the
*  code generation.  the following flags are processed:
*       comments        retain full-line and end-of-line comments
*
*  the variable arch is set equal to the uppercase name of the machine
*  being processed.  specific tests upon this variable are discouraged, as
*  all machine-dependent code should be placed in the machine-definition
*  file if possible.
*
*  in addition to the normal minimal register complement, one scratch
*  work register, wt is defined.
*  see the register map below for specific allocations.
*
*  this program is based in part on earlier translators for the dec vax
*  (vms and un*x) written by steve duff and robert goldberg, and the
*  pc-spitbol translator by david shields.
*
*  to run under spitbol:
*       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt
*
*	reads <file>.lex	containing tokenized source code
*       writes <file>.s         with 80386 assembly code
*	also writes <file>.err	with err and erb error messages
*       parts of <machine>.hdr  are prepended and appended to <file>.s
*	also sets flags		to 1 after converting names to upper case
*	also reads <file>.pub	for debug symbols to be declared public
*
*  example:
*       spitbol -u v37:dos codlinux.spt
*
*
*  revision history:
*
        version = 'v1.12'
*
*
-eject
*
*  keyword initialization
*
	&anchor = 1;	&stlimit = 10000000;	&trim	= 1;  &dump = 1
*
*  useful constants
*
	letters = 'abcdefghijklmnopqrstuvwxyz'
	ucase  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	lcase   = letters
	nos     = '0123456789'
	tab	= char(9)

	define('lower(s)')
	define('upper(s)')

*  default the parameter string if none present
*
        arch = (differ(host(0)) host(0), "i32")
	arch = lower(arch)
	output = 'target architecture ' arch
*        output = ident(fileprefix) "filename (.lex) required" :s(end)
	fileprefix = "s"
	output = '  target architecture:' arch

*	1 is bytes per word, 1 is characters per word
*       these should agree with values used in translator
* set target-dependent configuration parameters

	hdr = 'i32'
*	op_w is instruction suffix for word-size
	op_w = ''
*	op_c is instruction suffix for minimal character size
	op_c = ''


*
*  data structures
*
	data('minarg(i.type,i.text)')

	sectnow = 0

*	ppm_cases gives count of ppm/err statments that must follow call to
*	a procedure

	ppm_cases = table(50,,0)

	error_messages = table(200)
*
*  function definitions
*
*  crack parses stmt into a stmt data plex and returns it.
*  it fails if there is a syntax error.
*
	define('crack(line)operands,operand,char')
*
*	comregs - map minimal register names to target register names
	define('comregs(line)t,pre,word')
*
*  error is used to report an error for current statement
*
	define('error(text)')
	define('genz()')
	define('genaop(stmt)')
	define('genbop(stmt)')
	define('putconst(label,value)')
        define('genlab()')
	define('genop(gopc,gop1,gop2,gop3)')
	define('genopl(gopl,gopc,gop1,gop2,gop3)')
	define('get1()')
	define('get2()')
	define('getarg(iarg,imem)l1,l2,t1,t2')
	define('getoff(iarg)itext,itype')
	define('getreg(iarg)atype')
	define('iflit(iarg)')
	define('ifmem(iarg)')
	define('ifreg(iarg)')
	define('move(dst,src)dtype,stype,mop,stext,dtext')
	define('prcent(n)')
	define('prsarg(iarg)l1,l2')
	define('put1()')
	define('putlab(label)')
	define('putline(stmt)')
	define('report(num,text)')
	define('tblini(str)pos,cnt,index,val,lastval')

*  putstmt writes a target statement
*
	define('putstmt(label,opcode,op1,op2,op3,comment)')

*  readline is called to return the next non-comment line from
*  the minimal input file (infile <=> lu1).   note that it will
*  not fail on eof, but it will return a minimal end statement
*
	define('readline()')
*
	 p.comregs = break(letters) . pre span(letters) . word

*  exttab has entry for external procedures
*
	exttab = table(50)

*  labtab records labels and their offsets in the program section
*
	labtab = table(500)

*
*  genlabels is count of generated labels (cf. genlab)
*
	genlabels = 0

*
*  initialize variables
*
	labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
	lastopc = lastop1 = lastop2 =
	data_lc = 0
	max_exi = 0
*
*  initial patterns
*
*  p.csparse parses tokenized line
	p.csparse = '{' break('{') . inlabel
.	'{' break('{') . incode
.	'{' break('{') . iarg1
.	'{' break('{') . iarg2
.	'{' break('{') . iarg3
.	'{' break('{') . incomment
	'{' rem . slineno

*  dispatch table
*
	getargcase = table(27)
	getargcase[1] = .getarg.c.1;   getargcase[2] = .getarg.c.2
	getargcase[3] = .getarg.c.3;   getargcase[4] = .getarg.c.4
	getargcase[5] = .getarg.c.5;   getargcase[6] = .getarg.c.6
	getargcase[7] = .getarg.c.7;   getargcase[8] = .getarg.c.8
	getargcase[9] = .getarg.c.9;   getargcase[10] = .getarg.c.10
	getargcase[11] = .getarg.c.11; getargcase[12] = .getarg.c.12
	getargcase[13] = .getarg.c.13; getargcase[14] = .getarg.c.14
	getargcase[15] = .getarg.c.15; getargcase[16] = .getarg.c.16
	getargcase[17] = .getarg.c.17; getargcase[18] = .getarg.c.18
	getargcase[19] = .getarg.c.19; getargcase[20] = .getarg.c.20
	getargcase[21] = .getarg.c.21; getargcase[22] = .getarg.c.22
	getargcase[23] = .getarg.c.23; getargcase[24] = .getarg.c.24
	getargcase[25] = .getarg.c.25; getargcase[26] = .getarg.c.26
	getargcase[27] = .getarg.c.27

	opcodes = table(100)
	s =
+       'add adi adr anb aov atn '
+	'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze call callos ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti decv dvi dvr enp err erb esw etx exi flc '
+       'ica icp icv ieq ige igt ile ilt incv ine ino iov itr jmp '
+       'jsr jsrerr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvc mvw mwb ngi eti ngr nzb orb plc ppm prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer '
+	'decr ent inr lea move load loadi push pushi pushr pop popr realop store zrb '
* decr is used to decrement rc register (cf. rcode)

*	don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)
	opsused = table(100)

opcodes.1
	s break(' ') . opc ' ' =			:f(opcodes.2)
	opcodes[opc] = 1			:(opcodes.1)
opcodes.2

* since program is represented as an array of unsigned integers we cannot enter real constants, so we
* create a map that can be used to enter the values later.
	drctab = table(50)

* initialize osint procs
	osiprocs = 
.	'sysax sysbs sysbx syscm sysdc sysdm sysdt sysea sysef sysej sysem sysen sysep sysex '
.	'sysfc sysgc syshs sysid sysif sysil sysin sysio sysld sysmm sysmx sysou syspi syspl '
.	'syspp syspr sysrd sysri sysrw sysst systt systm sysul sysxi '
	is_osint = table(50)
	str = osiprocs
osiprocs.1
	str break(' ') . name ' ' =			:f(osiprocs.2)
	is_osint[name] = 1			:(osiprocs.1)
osiprocs.2

-stitl main program
*  here follows the driver code for the "main" program.

*
*  loop until program exits via g.end
*
*  opnext is invoked to initiate processing of the next line from
*  readline.
*  after doing this, opnext branches to the generator routine indicated
*  for this opcode if there is one.
*  the generators all have entry points beginning
*  with "g.", and can be considered a logical extension of the
*  opnext routine.  
*  the generators are listed in a separate section below.
*
*
*  get file name

*
* get definition file name following token file name, and flags.
*
*	fileprefix ? break(';:') . fileprefix len(1) (break(';:') | rem) . target
*+		((len(1) rem . flags) | '')
*	$replace(target,lcase,ucase) = 1
*
* parse and display flags, setting each one's name to non-null value (1).
*
 :(flgs.skip)
flgs	flags ? ((len(1) break(';:')) . flag len(1)) |
+	 ((len(1) rem) . flag) =			:f(flgs2)
	flag = replace(flag,lcase,ucase)
        output = "  flag: " flag
	$flag = 1					:(flgs)
*
flgs.skip
flgs2
*
* various constants
*
        comment.delim = ';'

	w0 = 'w0'; w1 = 'w1'; w2 = 'w2'
	xl = 'xl'; xr = 'xr'; xs = 'xs'; xt = 'xl'
	wa = 'wa'; wb = 'wb'; wc = 'wc'
	ia = 'ia'; cp = 'cp'; ra = 'ra'
* user rc for error handling (this is memory location in x32 version)
	rc = 'rc'

	w1.minarg = minarg(8, 'w1')
	w2.minarg = minarg(8, 'w2')
	ia.minarg = minarg(8, 'ia')
	ra.minarg = minarg(8, 'ra')
	rcode = minarg(8,'rc')

*  other definitions that are dependent upon things defined in the
*  machine definition file, and cannot be built until after the definition
*  file has been read in.
*
*  p.putstmt examines output lines for certain types of comment contructions
	fillc	  = tab
	p.putstmt = (break(fillc) . label span(fillc)) . leader
+			comment.delim rem . comment
	p.alltabs = span(tab) rpos(0)

*  strip end of comments if y
*
	strip_comment = (differ(comments) 'n', 'y')

	filenami = fileprefix '.lex'
        input(.infile,1,filenami)                     :s(inputok)

inputok output = '  input lex file: ' filenami
*
*
*
*  associate output files.
*
	filenamo = fileprefix '.int'
        output(.outfile,2,filenamo)             :s(outputok)
        output = '  cannot open asm file: ' filenamo :(end)
outputok
        output = '  output asm file: ' filenamo

*  then copy contents of <machine>.hdr (if it exists) to outfile
*  stop at line with just 'end' or end of file
*
	noutlines = noutlines + 1

	input(.hdrfile,4,hdr '.hdr')	:f(nohdr)
	havehdr = 1
        output = '  input header file:  ' hdr  '.hdr'
hdrcopy line = hdrfile				:f(hdrend)
	ident(line,'end')			:s(nohdr)
	outfile = line
	noutlines = noutlines + 1		:(hdrcopy)
hdrend	havehdr =
nohdr
*
*  will have havehdr non-null if more remains to copy out at end.
*
*  read in pub file if it exists.  this contains a list of symbols to
*  be declared public when encountered.
*
	pubtab = table(2)
	input(.pubfile,5, fileprefix ".pub")	:f(nopub)
	pubtab = table(101)
pubcopy	line = pubfile				:f(pubend)
	pubtab[line] = 1			:(pubcopy)
pubend	endfile(5)
nopub

						:(dsout)

  &trace = 2000
  &ftrace = 1000
*  &profile = 1
dsout
opnext	
	label = thislabel =
	thisline = readline()
	crack(thisline)				:f(dsout)
*	 output = thisline
*
* output label of executable instruction immediately if there is one,
* as it simplifies later processing, especially for tracing.
	ident(inlabel)				:s(opnext.1)
	thislabel = inlabel 
* keep the label as is not in executable code
*	lt(sectnow,5)				:s(opnext.1)
	lt(sectnow,3)				:s(opnext.1)
* here if in code, so output label now
* defer label processing for ent to allow emission of alignment ops for x86.
	ident(incode,'ent')			:s(opnext.1)
	putlab(thislabel)
* set lastlabel so can check to avoid emitting duplicate label definitions
	lastlabel = thislabel
* clear out label info once generated
	label = thislabel =
opnext.1
	thislabel = inlabel 
	i1 = prsarg(iarg1)
	i2 = prsarg(iarg2)
	i3 = prsarg(iarg3)

	tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.		i.text(i2) ' ' i.text(i3)
	argerrs = 0
						:($('g.' incode))
*  here if bad opcode
ds01	error('bad op-code')			:(dsout)

*  generate tokens.
*
ds.typerr
	error('operand type zero')		:(dsout)
-stitl comregs(line)t,pre,word
comregs
	line p.comregs =			:f(comregs1)
	word = eq(size(word),2) differ(t = word) t
	comregs = comregs pre word		:(comregs)
comregs1 comregs = comregs line			:(return)
-stitl crack(line)
*  crack is called to create a stmt plex containing the various parts  of
* the minimal source statement in line.  for conditional assembly ops,
* the opcode is the op, and op1 is the symbol.  note that dtc is handled
*  as a special case to assure that the decomposition is correct.

*  crack prints an error and fails if a syntax error occurs.
*
crack   nstmts  = nstmts + 1
	op1 = op2 = op3 = typ1 = typ2 = typ3 =
	line    p.csparse			:s(return)
*  here on syntax error
*
	error('source line syntax error')	:(freturn)
-stitl error(text)
*  this module handles reporting of errors with the offending
*  statement text in thisline.  comments explaining
*  the error are written to the listing (including error chain), and
*  the appropriate counts are updated.
*
error   outfile = '* *???* ' thisline
	outfile = '*       ' text
.	          (ident(lasterror),'. last error was line ' lasterror)
	lasterror = noutlines
	noutlines = noutlines + 2
	le(nerrors = nerrors + 1, 10)		:s(dsout)
        output = 'too many errors, quitting'  	:(end)
-stitl	putconst(label,value)
putconst
	differ(label) putlab(label)
	program_counter = program_counter + 1
	putline(tab  value ',') :(return)
	
-stitl genlab()
*  generate unique labels for use in generated code
genlab	genlab = 'labl' lpad(genlabels = genlabels + 1,3,'0') :(return)

-stitl genopl(gopl,gopc,gop1,gop2,gop3)
*  generate operation with label
genopl	
	gopc = lower(gopc)
*	output = ident(gopc,'sss') 'sss ' thisline
	opsused[gopc] = opsused[gopc] + 1
	putstmt(gopl,gopc,gop1,gop2,gop3)	:(return)

-stitl genop(gopc,gop1,gop2,gop3)
*  generate operation with no label
genop   genopl(,lower(gopc),gop1,gop2,gop3)            
* output = 'genop ' gopc ',' gop1 ',' gop2 ',' gop3
						:(return)

-stitl get1()
* return argument if it is a register, or else load the argument
* value into w1
get1
	ident(i.text(i1))			:s(return)
	ifreg(i1)				:f(get1.1)
        get1 = getreg(i1)			:(return)
get1.1
        iflit(i1)				:f(get1.2)
	genop('loadi',w1,,getoff(i1))		:(get1.3)
get1.2
* here if argument in memory, so load to w1
        move(w1.minarg,i1)
get1.3
* merge to return with argument now in w1
        get1 = w1	                        :(return)

-stitl get2()
* return register if i2 is register, else load i2 value to w1
get2
	ident(i.text(i2))			:s(return)
	ifreg(i2)				:f(get2.1)
        get2 = getreg(i2)			:(return)
get2.1
        iflit(i2)				:f(get2.2)
	genop('loadi',w2,,getoff(i2))		:(get2.3)
get2.2
* here if source in memory, so load to w2
        move(w2.minarg,i2)
get2.3
* merge to return with argument now in w1
        get2 = w2	                        :(return)

-stitl getarg(iarg,imem)
getarg
	l1 = i.text(iarg)
	l2 = i.type(iarg)
	eq(l2)					:f($(getargcase[l2]))
	getarg = l1				:(return)

* int
getarg.c.1 getarg = l1				:(return)

* dlbl
getarg.c.2 getarg = l1				:(return)

* wlbl, clbl
getarg.c.3
getarg.c.4 getarg =  l1      			:(return)

* elbl, plbl
getarg.c.5
getarg.c.6 getarg = l1				:(return)

* w,x, map register name
getarg.c.7
getarg.c.8
	getarg = $l1				:(return)

* (x), register indirect
getarg.c.9
	l1 len(1) len(2) . l2
	l2 = $l2
	getarg =  l2 				:(return)

* (x)+, register indirect, post increment
getarg.c.10
	l1 = substr(l1,2,2)
	t1 = $l1
	getarg =  t1
						:(return)

*  -(x), register indirect, pre decrement
getarg.c.11
	t1 = $substr(l1,3,2)
	getarg =  t1
						:(return)

* int(x)
* dlbl(x)
getarg.c.12
getarg.c.13
	l1 break('(') . t1 '(' len(2) . t2
	getarg =  $t2 '!' t1   			:(return)

*  name(x), where name is in working section
getarg.c.14
getarg.c.15
	l1 break('(') . t1 '(' len(2) . t2
	getarg = $t2 '!' t1			:(return)

* signed integer
getarg.c.16 getarg = l1				:(return)

* signed real
getarg.c.17 getarg = l1				:(return)

*  =dlbl
getarg.c.18
	getarg = substr(l1,2)			:(return)

*  *dlbl
getarg.c.19
	getarg = substr(l1,2)			:(return)

*  =name (data section)
getarg.c.20
getarg.c.21
        getarg =  substr(l1,2) 			:(return)

*  =name (program section)
getarg.c.22
        getarg =  substr(l1,2)   		:(return)

*  pnam, eqop
getarg.c.23
getarg.c.24 getarg = l1				:(return)

* ptyp, text, dtext
getarg.c.25
getarg.c.26
getarg.c.27 getarg = l1				:(return)

-stitl getoff(iarg)itext,itype
- return offset of argument, or 0
getoff
	itype = i.type(iarg)
	itext = i.text(iarg)
	lt(itype,2)				:s(return)
	gt(itype,6)				:s(getoff.1)
* here if plain label, just return it
	getoff = itext				:(return)
getoff.1
	lt(itype,12)				:s(return)
	gt(itype,15)				:s(getoff.2)
	i.text(iarg) break('(') . getoff	:(return)
getoff.2
	gt(itype,22)				:s(return)
	getoff = substr(itext,2)		:(return)

-stitl getreg(iarg)atype
* return register associated with argument, or w0 if no register
* since it is assumed a register is needed.
getreg
* assume result is w0
	getreg = w0
	atype = i.type(iarg)
	lt(atype,6)				:s(return)
	gt(atype,8)				:s(getreg.1)
* here if explicit x or w register
	getreg = i.text(iarg)			:(return)
getreg.1
	gt(atype,15)				:s(getreg.2)
* here if register enclosed in parentheses
	i.text(iarg) break('(') '('  len(2) . getreg 	:(return)
getreg.2
* no type if numeric constant
	le(atype,17)				:s(return)
	gt(atype,22)				:s(return)
* here if literal, so return w0
	getreg = 'w0'				:(return)

-stitl iflit(iarg) - test if argument is literal
iflit	ge(i.type(iarg),18) le(i.type(iarg),22) :f(freturn)s(return)

-stitl ifmem(iarg) - test if argument is in memory
ifmem
        ge(i.type(iarg),3) lt(i.type(iarg),6)  	:s(return)
	ge(i.type(iarg),9) le(i.type(iarg),15)	:s(return)f(freturn)

-stitl ifreg(iarg) - test if argument is register
ifreg	
*	ia is considered to be a register
	eq(i.type(iarg),8) ident(i.text(iarg),'ia')	:s(return)
	ge(i.type(iarg),7) le(i.type(iarg),8) 	:f(freturn)s(return)

-stitl lower(s) -  convert argument to upper case
lower
	lower = replace(s,'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
.			  'abcdefghijklmnopqrstuvwxyz')	:(return)

-stltl move(dst,src)dtype,stype,stext,dtext
* generate code for move instruction
move
* output ops are
* move - from register to register
* load - load from memory
* loadi - load immediate (note this can be done as move with src=r0 and off=value)
* push - push value from memory
* pushi - push immdiate, that is, of the effective address
* pop	- pop stack value to memory
* popr  - pop stack value to register
*
* result may need to be stored back to memory
* new special casing
	stype = i.type(src); stext = i.text(src)
	dtype = i.type(dst); dtext = i.text(dst)
* look for register to register move
*	putline(dtype ' ' dtext ' ' stype ' ' stext)
        ifreg(src) ifreg(dst) genop('move',getreg(dst),getreg(src))  :s(return)

* look for pop to register
        ifreg(dst) eq(stype,10) genop('popr',getreg(dst),getreg(src)) :s(return)

* look for pop to memory
	ifmem(dst) eq(stype,10)  genop('pop',getreg(src),getreg(dst),getoff(dst))    :s(return)
* look for push of literal
 	eq(dtype,11) iflit(src)  genop('pushi',getreg(dst),,getoff(src))   :s(return)
* look for push of memory value
 	eq(dtype,11) ifmem(src)  genop('push',getreg(dst),getreg(src),getoff(src))   :s(return)
* look for push of register
 	eq(dtype,11) ifreg(src)  genop('pushr',getreg(dst),getreg(src))  :s(return)

* look for load of immediate value
	ifreg(dst) iflit(src) genop('loadi',getreg(dst),,getoff(src))  :s(return)

* look for load from memory
	ifreg(dst) ifmem(src) genop('load',getreg(dst),getreg(src),getoff(src))  :s(return)

* look for store
	ifmem(dst) ifreg(src) genop('store',getreg(src),getreg(dst),getoff(dst))  :s(return)

* here if have memory-to-memory case, so move src to w1 and then do store
	move(w1.minarg,src)
	move(dst,w1.minarg)
						:(return)
move.1
        genop(mop,getarg(i1),getarg(i2))        :(return)


-stitl prcent(n)
prcent 
	prcent = 'prc_' '+'  (1 * ( n - 1)) 	:(return)

-stitl putlab(label)
putlab
	ident(label)				:s(return)
	labtab<label> = program_counter
	putline('/* ' label ' */')		:(return)

-stitl putstmt(label,opcode,op1,op2,op3,comment)
putstmt	
*	putline(thisline)
* clear label if definition already emitted
	label = ident(label, lastlabel)
	differ(label) putlab(label)

putstmt1
* ds suppress comments
 	comment = tcomment = comments =
 	:(putstmt2)
*  attach source comment to first generated instruction
	differ(comment)				:s(putstmt2)
	ident(tcomment)				:s(putstmt2)
	comment = tcomment; tcomment =
putstmt2
*	 putline('putstmt ' opcode ',' op1 ',' op2 ',' op3)

putstmt3
	stmtout = tab opcode 
.	(differ(op1) tab '| ' op1 tab ' << dst ','')
.	(ident(op2,'w0') '', differ(op2) tab '| ' op2 tab ' << src ','')
.	(differ(op3) tab '| ' op3 tab ' << off ',, ) ','
*.       (ident(strip_comment,'y'), tab (ident(comment), ';') comment)
*
**	send text to outfile
*
**
putstmt4
**
**	send text to output file if not null.
*
*	stmtout = replace(trim(stmtout),'$','_')
	stmtout = trim(stmtout)
	ident(stmtout)				:s(return)
	program_counter = program_counter + 1
	putline(stmtout)
*
*  record code labels in table with delimiter removed.
	ident(thislabel)			:s(return)
	
	labtab<label> = program_counter - 1	:(return)

-stitl prsarg(iarg)
prsarg	prsarg = minarg(0)
	iarg break(',') . l1 ',' rem . l2	:f(return)
	prsarg = minarg(convert(l1,'integer'),l2)	:(return)

-stitl put1()
put1
* no need to issue store if argument is plain register
	ident(get1.mem)				:s(return)
* issue store in case first argument is memory location that must be updated
        genop('store',w1,,get1.mem)
						:(return)

-stitl readline()
*  this routine returns the next statement line in the input file
*  to the caller.  it never fails.  if there is no more input,
*  then a minimal end statement is returned.
*  comments are passed through to the output file directly.
*
*
readline readline = lower(infile)              	:f(rl02)
	nlines  = nlines + 1
	ident( readline )			:s(readline)
readline.0
	leq( substr(readline,1,1 ),'*' )       	:f(rl01)
* force skip of full line comments
	:(readline)
*
*  only print comment if requested.
*
	ident(strip_comment,'n')		:f(readline)
        readline len(1) = ';'
	outfile = readline
	noutlines = noutlines + 1               :(readline)
*
*  here if not a comment line
*
rl01						:(return)
*
*  here on eof
*
rl02    readline = '       end'
						:(rl01)
-stitl putline(stmt)
putline
	outfile = stmt
	ntarget	= ntarget + 1
	noutlines = noutlines + 1		:(return)

-stitl tblini(str)
*  this routine is called to initialize a table from a string of
*  index/value pairs.
*
tblini   pos     = 0
*
*  count the number of "[" symbols to get an assessment of the table
*  size we need.
*
tin01   str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.						:s(tin01)
*
*  allocate the table, and then fill it. note that a small memory
*  optimisation is attempted here by trying to re-use the previous
*  value string if it is the same as the present one.
*
	tblini   = table(cnt)
tin02   str     (break('[') $ index len(1) break(']') $ val len(1)) =
.						:f(return)
	val     = convert( val,'integer' )
	val     = ident(val,lastval) lastval
	lastval = val
	tblini[index] = val			:(tin02)
-stitl generators

-stitl upper(s) - convert string to upper case
upper
	upper = replace(s,'abcdefghijklmnopqrstuvwxyz',
.			  'ABCDEFGHIJKLMNOPQRSTUVWXYZ')	:(return)

* 1 - Basic instruction set

g.mov
	move(i1,i2)				:(opnext)

g.brn
        genop('brn',,,getarg(i1))		:(opnext)
        

g.bsw	
	genop('loadi',w1,i.text(i2))
	genop(incode,get1(),w1,getarg(i3))	:(opnext)

g.iff   
	putconst(,i.text(i2))			:(opnext)

g.esw						:(opnext)

g.ent
*
*  entry points are stored in byte before program entry label
*  last arg is optional, in which case no initial 'db' need be
*  issued. we force odd alignment so can distinguish entry point
*  addresses from block addresses (which are always even).
*
*  note that this address of odd/even is less restrictive than
*  the minimal definition, which defines an even address as being
*  a multiple of 1 (4), and an odd address as one that is not
*  a multiple of 1 (ends in 1, 2, or 3).  the definition here
*  is a simple odd/even, least significant bit definition.
*  that is, for us, 1 and 3 are odd, 2 and 4 are even.
*
	differ(thislabel) putlab(thislabel)

	genop('ent',,,i.text(i1))		:(opnext)
* TODO: Review this later

	t1 = i.text(i1)
	differ(t1)				:s(g.ent.1)
	outfile = tab 'nop'
						:(g.ent.2)
g.ent.1
	outfile = tab 'dw' tab	t1

g.ent.2
	outlines = outlines + 2
	genopl(thislabel)
	thislabel ? rtab(1) . thislabel 
*        (differ(pubtab[thislabel]), differ(debug)) genop('global',thislabel)
	thislabel =				:(opnext)

g.bri	genop(incode,,,getarg(i1))		:(opnext)

g.lei	genop(incode,i.text(i1))		:(opnext)

g.jsr
	jsr_proc = getarg(i1)
	jsr_op = (differ(is_osint[jsr_proc]) 'callos', 'call')
	genop(jsr_op,,,jsr_proc)
*	get count of following ppm statements
	jsr_count = ppm_cases[jsr_proc]
	eq(jsr_count)				:s(opnext)
	genop('jsrerr',,,jsr_count)
						:s(opnext)

g.err
	genop(incode,,,+i.text(i1))		:(opnext)
g.ppm
	genop(incode,,,i.text(i1))		:(opnext)

g.prc
	prc.args = getarg(i2)
	ppm_cases[thislabel] = i.text(i2)
	thislabel =
	max_exi = gt(prc.args,max_exi) prc.args
	prc.type = i.text(i1)			:($('g.prc.' prc.type))

g.prc.e
g.prc.r						:(opnext)

g.prc.n
*  store return address in reserved location
	genop('prc',,,prc.count)
	prc.count = prc.count + 1
	:(opnext)

g.exi
	genop(incode,,,i.text(i1))		:(opnext)
 	t3 = i.text(i1)
        t1 = getarg(i1); t2 = prc.type
*  if type r or e, and no exit parameters, just return
 	differ(t2,'n') eq(prc.args)	genop('ret')	:s(opnext)
        t3 = ident(t3) '0'
	genop('loadi',rc,,t3)
	ident(t2,'n')				:s(g.exi.1)
	genop('ret')				:(opnext)
g.exi.1

	genop('move','wt', '['  prcent(prc.count) ']' )
	genop('jmp','wt')
						:(opnext)

g.enp   genop('enp')				:(opnext)

g.erb
	error_messages[+i.text(i1)] = i.text(i2)
*	genop('erb',,,'err_')
	genop('erb')
*	set rcode to error code and branch to error handler
*	genop('mov', rcode,  +(i.text(i1)))
* 	genop('jmp',,,'err_')
						:(opnext)

g.start

g.icv
        genop('icv',get1())
        put1()					:(opnext)

g.dcv
        genop('dcv',get1())
        put1() 					:(opnext) 

g.zer
g.mnz
	zer.reg = (ident(incode, 'zer') 'w0', 'xs')
	move(i1,minarg(8,zer.reg))
                                                :(opnext)

g.rtn
g.ssl
g.sss   					
						:(op.none)

* 2 - Operations on one word integer values (addresses)

g.add
	genop('add',get1(),get2())
        put1()
                                                :(opnext)

g.sub
	genop('sub',get1(),get2())
        put1()
                                                :(opnext)

g.ica
* result may need to be stored back to memory
        genop('incv',get1())
        put1()
                                                :(opnext)

g.dca
* result may need to be stored back to memory
        genop('decv',get1())
        put1()
                                                :(opnext)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi
	genop(incode,get1(),get2(),getarg(i3)) 	:(opnext)

g.bod
g.bev
g.bnz
g.bze
	genop(incode,get1(),getarg(i2))		:(opnext)

g.lct
*
*  if operands differ must emit code
*
	differ(i.text(i1),i.text(i2))		:s(g.lct.1)
*  here if operands same. emit no code if no label, else emit null
	ident(thislabel)			:s(opnext)
	genop('lct')				:(opnext)

	
g.lct.1	genop('mov',get1(),get2())		:(opnext)

g.bct
        genop('bct',getarg(i1),getarg(i2))    	:(opnext)

g.aov
* result may need to be stored back to memory
	genop(incode,get1(),get2(),getoff(i3))	:(opnext)
	genop('add',get2(),get1())
        put1()
	genop('jc',,,getarg(i3))
						:(opnext)

* 3 - Operations on the code pointer register (CP)

g.lcp
g.lcw
g.scp
                                                :(op.one)

g.icp
                                                :(op.none)

* 4 - Operatons on signed integer values

g.ldi
g.adi
g.mli
g.sbi
g.dvi
g.rmi
                                                :(op.one)
g.ngi
	genop(incode)				:(opnext)

g.sti
	move(i1,ia.minarg)			:(opnext)

g.ino
g.iov
        genop(incode,,,getarg(i1))             	:(opnext)

g.ieq
g.ige
g.igt
g.ile
g.ilt
g.ine
        genop(incode,,,getarg(i1))             	:(opnext)

* 5 - Operations on real values


g.ldr
g.adr
g.sbr
g.mlr
g.dvr
                                                :(op.one)

g.str move(i1,ra.minarg)			:(opnext)
 
g.ngr						:(op.none)
g.atn
g.chp
g.cos
g.etx
g.lnf
g.sin
g.sqr
g.tan
	genop('realop',,,incode)		
                                                :(opnext)

g.rno	
g.rov
g.req
g.rne
g.rge
g.rgt
g.rle
g.rlt
	genop(incode,,,getoff(i1))
                                                :(opnext)

* 6 - Operations on character values

g.plc
g.psc
	genop(incode,get1(),get2())		:(opnext)

g.lch
	move(i1,i2)				:(opnext)
g.sch
	move(i2,i1)				:(opnext)

g.csc  						:(opnext)

g.ceq
g.cne 
	genop(incode,get1(),get2(),getarg(i3))  :(opnext)

g.cmc
	genop('loadi',w1,getarg(i1))
	genop('loadi',w2,getarg(i2))
	genop('cmc')				:(opnext)

g.trc
	genop(incode)				:(opnext)

g.flc
	genop(incode,get1())			:(opnext)

* 7 - Operations on bit string values

g.anb
g.orb
g.xob
						:(op.two)

g.rsh
g.lsh
	genop(incode,getarg(i1),getarg(i2))	:(opnext)

g.cmb   genop(incode,getarg(i1))		:(opnext)

g.rsx
	error('rsx not supported')
g.lsx
	error('lsx not supported')

g.nzb	
g.zrb
	genop(incode,get1(),,getarg(i2))	:(opnext)
	
g.zgb						:(opnext)

* 8 - Conversion instructions

g.wtb   					:(opnext)

g.btw   					:(opnext)

g.mti	
	move(ia.minarg,i1)			:(opnext)

g.mfi
*  last arg is optional
	eq(i.type(i2))				:s(g.mfi.1)
*  compare with cfp$m, branching if result negative
*  here if label given, branch if ia not in range (ie, negative)
	genop(incode,,,getoff(i2))
g.mfi.1
	move(i1,ia.minarg)				
						:(opnext)

g.itr genop(incode)				:(opnext)

g.rti
*  here if label given, branch if real too large
        genop(incode,,,getarg(i1))             	:(opnext)

g.ctw
g.ctb
g.cvm
	genop(incode,getarg(i1))		:(opnext)

g.cvd						:(op.none)

* 9 - BLock move instructions

g.mvc
g.mcb
g.mvw
g.mwb
						:(op.none)

* 10 - Operations connected with the stack

g.chk						:(op.none)
	genop('cmp','xs',,'lowspmin')
	genop('jb',,,'sec06')
						:(opnext)

* 11 - Data generation instructions

g.dac
g.dbc
g.dic
	putconst(thislabel,i.text(i1))
						:(decend)
g.drc
	str = i.text(i1)
*	strip leading +
	str '+' =
	drctab<program_counter> = i.text(i1)
	putconst(thislabel,"0")
						:(decend)

g.dtc
* each character needs separate declaration, but do not include enclosing '/' characters

*	putline('dtc ' i.text(i1))
	differ(thislabel) putlab(thislabel)
	str = i.text(i1)
	str = substr(str,2,size(str) - 2)

g.dtc.1
	str len(1) . c =			:f(decend)
	putconst("","'" c "'") 			:(g.dtc.1)

						:(decend)

decend
*  here at end of dic or dac to see if want label made public
*	thislabel ? rtab(1) . thislabel 
						:(opnext)

* 12 - Symbol definition instructions

g.equ   
	putline(tab thislabel ' = ' i.text(i1))
						:(opnext)
g.exp
	ppm_cases[thislabel] = i.text(i1)
*	putline('//' tab 'extern' tab thislabel)
	thislabel =				:(opnext)

g.inp
	ppm_cases[thislabel] = i.text(i2)
	prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
+						:(opnext)

g.inr
	putline('//' tab incode tab thislabel) :(opnext) 

* 13 - Assembly listing layout instruction

g.ejc						:(opnext)

g.ttl	
* TODO: add line text later
*	putline('// ' thisline)

						:(opnext)

* 14 - Program form
g.sec	sectnow = sectnow + 1			:($("g.sec." sectnow))

* procedure declaration section
g.sec.1
* write out opcode definitions

	putline('const (')
	putline(tab	'nop = iota')
	opcodea = sort(opcodes,1)
	i = 0
* write out opcodes offsets sorted by offset value
	opcodea = sort(opcodes,1)	
	i = 0
g.sec.1.2
	i = i +  1
*	differ(opcodea<i,1>) putline(tab opcodea<i,1>  tab '=' tab  opcodea<i,2>)	:s(g.sec.1.2)
	putline(tab opcodea<i,1>)		:s(g.sec.1.2)
	putline(')')

g.sec.1.1
	putline('//sec01')
        			            	:(opnext)

* definitions section
g.sec.2
	putline('const (')
				             	:(opnext)

* constants section
g.sec.3
	putline(tab ')')
	putline('//sec03')
	putline('var program = []uint32 {')
				     		:(opnext)

* working variables section
g.sec.4
        putline('//sec04' )     
						:(opnext)

*  here at start of program section.  if any n type procedures,
*  put out entry-word block declaration at end of working storage
g.sec.5
*  emit code to indicate in code section
*  get direction set to up.
*        (gt(prc.count1) genopl('prc$' ':','times', prc.count1 ' dd 0'))
*TODO	genop('prc_: times ' prc.count1 ' dd 0')
*	putlab('lowspmin')
*	putconst('lowspmin','0')
        putline('// sec05' )
						:(opnext)

*  stack overflow section.  output exi__n tail code
g.sec.6
        genopl('sec06'  , 'nop')
						:(opnext)

*  error section.  produce code to receive erb's
g.sec.7
        putline('//sec07' )

*	allow for some extra cases in case of max.err bad estimate
	n1 = max.err + 8
	output = '  max.err ' max.err
*	genopl('err_','xchg',wa,rc)
						:(opnext)

g.end						:(program.end)

* These utility procedures are used to just map Minimal opcode and
* its arguments into the same target opcode.

op.none
        genop(incode)                           :(opnext)

op.one
        genop(incode,get1())
                                                :(opnext)
op.two
*	putline("// op.two " incode " " i.text(i1) "," i.text(i2))
        genop(incode,get1(),get2())
                                                :(opnext)

op.oneput
* here for standard case with single argument which is computed
* and so must be stored back if it came from memory
of 	ifreg(i1)				:f(op.oneput.1)
* here if argument is register, so just use it
	genop(incode,getreg(i1))		:(opnext)
op.oneput.1
* here if argument in memory. First bring it to w1
	oneput.arg = i1
* then do the operation
	oneput.res = get1()
	genop(incode,oneput.res)
* and now store it back
	genop('store',oneput.res,oneput.reop.oneput.off)	
						:(opnext)
op.twoput
* here for standard case with two arguments
        genop(incode,get1(),get2())
        differ(get1.mem) put1('w1',get1.mem)
                                                :(opnext)

report
	output = lpad(num,10) '  ' text		:(return)

* Complete compilation by writing out needed declarations

program.end
	&dump = 0
	ident(havehdr)				:s(g.end.2)
*  here to copy remaining part from hdr file
g.end.1	line = hdrfile				:f(g.end.2)
	ntarget = ntarget + 1
	noutlines = noutlines + 1
	outfile = line				:(g.end.1)
g.end.2

* here at end of code generation.
*	mark end of program
	putline('}')
	putline('const (')

* write out labels offsets sorted by offset value
	labels = sort(labtab,2)	
	i = 0
g.end.3
	i = i +  1
	differ(labels<i,1>) putline(tab labels<i,1>  tab '=' tab  labels<i,2>)	:s(g.end.3)
	putline(')')

* TODO - fix declaration below
	:(g.end.4a)
* write out any real constants that need to be patched into the program text
	putline('reals = map[int] float32 {')
	drcara = sort(drctab,1)
	i = 0
g.end.4
	i = i + 1
	putline(tab drcara<i,1> tab ':' tab  drcara<i,2> ",") :s(g.end.4)
	putline('}')

g.end.4a
* write out const definitions for osint procedures

	putline('const (')
	str = osiprocs
	str break(' ') . name ' ' =
	putline(tab name ' = iota + 1 ')
g.end.5
	str break(' ') . name ' ' =		:f(g.end.6)
	putline(tab name )			:(g.end.5)
g.end.6
	putline(')')

* list ops used
	usedara = sort(opsused,1)
	i = 0
g.end.7
	nused = nused + 1
	opnam = usedara<i = i + 1,1>		:f(g.end.8)
	opcnt = usedara<i,2>
	output = opnam tab opcnt			
						:(g.end.7)
g.end.8

*	output = 'ppm_cases'
*	putline(tab "var ppm_cases =  map[int]int {")
* list ppm_cases
	ppm_cases_ara = sort(ppm_cases,1)
	i = 0
	:(g.end.10)
* this may not be needed
g.end.9
	i = i + 1
	putline(tab  ppm_cases_ara[i,1]  tab ':' ppm_cases_ara[i,2] ',')	:s(g.end.9)
	putline('}')
g.end.10

*	emit error messages
	ara = sort(error_messages,1)
	i = 0
	putline('var error_messages = map[int]string {')
g.end.11
	i = i + 1
	putline(tab ara<i,1> tab ': "' ara<i,2> '",')	:s(g.end.11)
	putline("}")

* Close files and issue summary report

	endfile(1)
	endfile(2)

        report(nlines,		'lines read')
        report(nstmts,		'statements processed')
        report(ntarget,		'target code lines produced')
	report(nused,		'opcodes used')
	report(&stcount,	'spitbol statements executed')
        report(max.err,		'maximum err/erb number')
        report(prc.count1, 	'prc count')
        report(dtc.count, 	'dtc count')
        output  = '  ' gt(prc.count,prc.count1)
.	  '  differing counts for n-procedures:'
.	  ' inp ' prc.count1 ' prc ' prc.count
        differ(nerrors) report(nerrors,'errors detected')

*	errfile = '* ' max.err ' maximum err/erb number'
*	errfile  = '* ' prc.count ' prc count'
*.		differ(lasterror) '  the last error was in line ' lasterror

	&code   = ne(nerrors) 2001
        report(collect(), 'free words')
	:(end)
end
