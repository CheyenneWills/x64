*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS FOR USE BY TOKEN.SPT
*      ---------------------------------------------------------
*
*      THIS FILE OF CONDITIONAL SYMBOLS WILL OVERRIDE THE CONDITIONAL
*      DEFINITIONS CONTAINED IN THE SPITBOL MINIMAL FILE.   IN ADDITION,
*      LINES BEGINNING WITH ">" ARE TREATED AS SPITBOL STATEMENTS AND
*      IMMEDIATELY EXECUTED.
*
*      FOR Linux SPITBOL-x86
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL NOT
*                            DEFINED, A FULL COMMENT LINE INDICATES
*                            SYMBOL INITIALLY NOT DEFINED.
*
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CENG                 DEFINE TO INCLUDE ENGINE FEATURES
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CRPP                 DEFINE IF RETURN POINTS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*      .CUSR                 DEFINE TO HAVE SET() USE REAL VALUES
*                             (MUST ALSO #DEFINE SETREAL 1 IN SYSTYPE.H)
*
{{TTL{27,S P I T B O L -- COPYRIGHT NOTICE{{{{77
*
*      COPYRIGHT (C) BY ROBERT B. K. DEWAR, 1983, 2009
*
*      THIS SOFTWARE IS THE PROPERTY OF
*           PROFESSOR ROBERT B. K. DEWAR
*           COURANT INSTITUTE OF MATHEMATICAL SCIENCES
*           251 MERCER STREET
*           NEW YORK,  NY 10012
*           U.S.A.
*      TEL NO -  (212) 460 7497
*
{{EJC{{{{{89
{{TTL{27,L I C E N S E -- SOFTWARE LICENSE FOR THIS PROGRAM{{{{90
*      THIS PROGRAM IS FREE SOFTWARE: YOU CAN REDISTRIBUTE IT AND/OR MODIFY
*      IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
*      THE FREE SOFTWARE FOUNDATION, EITHER VERSION 3 OF THE LICENSE, OR
*      (AT YOUR OPTION) ANY LATER VERSION.
*
*      THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
*      but WITHOUT ANY WARRANTY; without even the implied warranty of
*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*      GNU General Public License for more details.
*
*      YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
*      ALONG WITH THIS PROGRAM.  IF NOT, SEE <HTTP://WWW.GNU.ORG/LICENSES/>.
{{TTL{27,S P I T B O L -- NOTES TO IMPLEMENTORS{{{{103
*
*      M A C R O   S P I T B O L     V E R S I O N   3 . 7
*      ---------------------------------------------------
*
*      DATE OF RELEASE  -  16 APRIL 2009
*
*      PERMISSION TO USE SPITBOL MAY BE NEGOTIATED WITH
*      PROFESSOR ROBERT B. K. DEWAR.
*      SITES WHICH HAVE OBTAINED SUCH PERMISSION MAY NOT PASS
*      ON COPIES OF THE SPITBOL SYSTEM OR PARTS OF IT EXCEPT
*      BY AGREEMENT WITH DEWAR.
*
*      VERSION 3.7 WAS MAINTAINED BY
*           MARK EMMER
*           CATSPAW, INC.
*           P.O. BOX 1123
*           SALIDA, COLORADO 81021
*           U.S.A
*      TEL NO -  (719) 539 3884
*      E-MAIL - MARKE AT SNOBOL4 DOT COM
*
*      VERSIONS 2.6 THROUGH 3.4 WERE MAINTAINED BY
*           DR. A. P. MCCANN
*           DEPARTMENT OF COMPUTER STUDIES
*           UNIVERSITY OF LEEDS
*           LEEDS LS2 9JT
*           ENGLAND.
*
*      FROM 1979 THROUGH EARLY 1983 A NUMBER OF FIXES AND
*      ENHANCEMENTS WERE MADE BY STEVE DUFF AND ROBERT GOLDBERG.
*
*      TO ASSIST IMPLEMENTORS A REVISION HISTORY BASED ON
*      VERSION 2.7 IS BEING MAINTAINED.
*
{{TTL{27,S P I T B O L - REVISION HISTORY{{{{138
{{EJC{{{{{139
*      R E V I S I O N   H I S T O R Y
*      -------------------------------
*
*
*      VERSION 3.6A TO 3.7 (NOVEMBER 1, 1991, MARK B. EMMER)
*      -----------------------------------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.701  ADD BTKWV AND REFINED TEST AT CDGVL+9 TO PREVENT
*              VARIABLE NAMES ALPHABET, LCASE, UCASE FROM BEING
*              PRE-EVALUATED BECAUSE OF THEIR ASSOCIATED
*              CONSTANT KEYWORDS.  THE CODE
*                 ALPHABET = "ABC"; OUTPUT = SIZE(ALPHABET)
*              RETURNED ZERO BECAUSE OF PRE-EVALUATION.
*      B3.702  DELAY BINDING TO FUNCTION BLOCK OF FOURTH
*              ARGUMENT TO TRACE FUNCTION.  THIS PERMITS THE
*              TRACE FUNCTION TO BE INVOKED BEFORE THE 4TH
*              ARGUMENT FUNCTION IS DEFINED.  ACCOMPLISHED BY
*              STORING A VRBLK POINTER IN TRFNC, AND FETCHING
*              ITS VRFNC ENTRY LATER, IN TRXEQ.
*      B3.703  REFERENCES TO KEYWORDS WITH CONSTANT PATTERN
*              VALUES (&ARB, &BAL, ETC.) DID NOT WORK.  A WTB
*              INSTRUCTION HAD BEEN OMITTED AT ACS14+2.
*      B3.704  IF A PROGRAM EMPLOYED THE CODE FUNCTION TO
*              REDEFINE A LABEL THAT WAS THE ENTRY LOCATION OF
*              A USER-DEFINED FUNCTION, THE FUNCTION WOULD
*              CONTINUE TO JUMP TO ITS OLD FUNCTION BODY.  PFCOD
*              IN PFBLK WAS POINTING DIRECTLY TO THE TARGET CODE
*              BLOCK, INSTEAD OF DOING SO INDIRECTLY THROUGH THE
*              VRBLK FOR THE ENTRY LABEL.
*      B3.705  THE TEST THAT REQUIRED A LABEL TO BE DEFINED
*              BEFORE IT COULD BE USED AS THE ENTRY OF A USER-
*              DEFINED FUNCTION HAS BEEN REMOVED.  FUNCTIONS
*              MAY BE DEFINED EVEN IF THE LABEL IS YET
*              UNDEFINED.
*      B3.706  AFTER A COMPILATION ERROR IN THE CODE FUNCTION,
*              THE EVAL FUNCTION PRODUCES SPURRIOUS ERRORS.  THE
*              CODE OFFSET CWCOF WAS NOT BEING RESET TO THE
*              BEGINNING OF CODE BLOCK.  ADD LINE AT ERR04+1 TO
*              ACCOMPLISH THIS RESET.
*      B3.707  INCONSISTANT TESTS WITH MXLEN CORRECTED.  SEVERAL
*              PLACES WERE TESTING WITH BGE INSTEAD OF BGT,
*              RESULTING IN SUCH ANOMALIES AS THE STATEMENT
*                 &MAXLNGTH = &MAXLNGTH
*              FAILING.  SINCE MXLEN IS GUARANTEED TO BE
*              STRICTLY LESS THAN DNAMB, IT IS PERMISSIBLE TO
*              CREATE OBJECTS OF SIZE MXLEN.  BGE CHANGED TO
*              BGT AT LOCATIONS
*                 S$ARR+14, SAR07+8, ALOBF+3, ASG14+8, GTAR6+10.
*      B3.708  EXIT(COMMAND STRING) WAS NOT LOADING PTR TO FCB
*              CHAIN INTO WB.  CORRECTED AT SEXT1.
*      B3.709  CHANGE PATST TO RETURN NON-STRING ERROR FOR NULL
*              ARGUMENT.  PREVIOUSLY, BREAK(), ANY(), ETC., WERE
*              SUCCEEDING, CONTRARY TO THE LANGUAGE DEFINITION.
*      B3.710  CONVERT FUNCTION WITH NULL SECOND ARGUMENT
*              CRASHED SYSTEM BY CALLING FLSTG WITH WA=0.  ADDED
*              TEST AT S$CNV, MOVED ERROR 74 TO SEPARATE ERB AT
*              SCV29.
*      B3.711  LEQ(,) CRASHED SYSTEM.  LCOMP DID NOT OBEY
*              MINIMAL ASSUMPTION THAT CMC OPCODE WILL ALWAYS
*              BE CALLED WITH WA .GT. 0.  ADDED TEST AT LCMP1.
*      B3.712  MODIFIED LINE AT SDF07+4 TO USE REGISTER WA
*              INSTEAD OF WB.  THIS CORRECTS PROBLEM OF DEFINE
*              FUNCTION WITH LOCAL VARIABLE LIST THAT BEGINS
*              WITH COMMA-  DEFINE("F(X),L1,L2")
*      B3.713  ERRONEOUS PLC ON UNINITIALISED R$CIM IN LISTR.
*      B3.714  ERRONEOUS CALL TO FLSTG POSSIBLE WITH NULL STRING
*              AT SDAT1.
*      B3.715  WHEN COPY FUNCTION USED WITH TABLE ARGUMENT, FIX
*              PROBLEM AT COP07.  WHEN COPYING FIRST TEBLK ON A
*              CHAIN, THE PSEUDO-PREVIOUS BLOCK POINTER IN XR
*              IS PUSHED ON THE STACK PRIOR TO CALLING ALLOC.
*              THIS IS NOT A VALID BLOCK POINTER, AS IT POINTS
*              WITHIN THE TBBLK.  IF THE SUBSEQUENT ALLOC
*              INVOKES GBCOL, THE HEAP BECOMES SCRAMBLED.
*              RECODED TO SAVE POINTER TO START OF BLOCK, PLUS
*              OFFSET IN WB.
*      B3.716  AT IOP01, IF GTVAR TRIGGERED GARBAGE COLLECTION
*              VIA ALOST, TRAP BLOCK IN WC WAS NOT COLLECTED.
*              SAVE WC ON STACK TO MAKE IT COLLECTABLE ACROSS
*              GTVAR CALL.
*      B3.717  AT ASG10, ALLOW CASE OF VARIABLE WITH MORE THAN
*              ONE TRBLK, AS HAPPENS WITH THE FOLLOWING STMT -
*              OUTPUT(.OUTPUT, .OUTPUT, FILENAME).
*      B3.718  AT SENF1, TRBLK CHAIN SEARCH WAS RELOADING CHAIN
*              HEAD, CAUSING INFINITE LOOP IF THE DESIRED TRBLK
*              WAS NOT THE FIRST ON CHAIN.  SYSTEM CRASHED WITH
*              TRACE(.V1) OUTPUT(.V2,.V1,FILE).
*      B3.719  PROTOTYPE STRINGS (DEFINE, LOAD, DATA, ETC.) WERE
*              ALLOWING BLANK CHARACTERS, PRODUCING BOGUS
*              VARIABLE NAMES.
*      B3.720  THE FACT THAT IOFCB DESTROYED REGISTER WC WAS NOT
*              DOCUMENTED.  B$EFC CONVERSION OF FILE ARGUMENT
*              NEVER WORKED BECAUSE WC AND XT WERE DESTROYED BY
*              CALL TO IOFCB.
*      B3.721  IOPUT LEFT A TRBLK ATTACHED TO FILEARG1 IF SYSIO
*              FAILED.  SUBSEQUENT USE OF THIS FILEARG1 VARIABLE
*              IN ANOTHER I/O CALL WOULD CRASH SYSTEM.
*      B3.722  ADD CHK AT EVLP1 TO CATCH RECURSIVE PATTERN ERROR.
*      B3.723  ALLOW -LINE TO WORK PROPERLY WITHIN CODE FUNCTION
*              BY SETTING CMPLN DIRECTLY IN CNC44.  IF FILE NAME
*              ABSENT, DECREMENT SCNPT TO RESCAN TERMINATOR.
*      B3.724  WHEN MXLEN EXCEEDS START OF DYNAMIC MEMORY, ROUND
*              IT UP TO MULTIPLE OF WORD SIZE PRIOR TO STORING
*              IN DNAMB AT INI06.
*      B3.725  PROVIDE RIGHT PADDING OF ZERO CHARACTERS TO ANY
*              STRING RETURNED BY AN EXTERNAL FUNCTION.
*      B3.726  RESET FLPTR AT BPF17 FOR UNDEFINED FUNCTION
*              WHEN EVALX IS EVALUATING AN EXPRESSION.
*      B3.727  MODIFY CODE AFTER READ5 FOR OUTER NESTING OF
*              AN EXECUTE-TIME COMPILE OF -INCLUDE STATEMENT.
*              CREATE A SUBSTRING OF REMAINDER OF ORIGINAL
*              CODE FUNCTION ARGUMENT STRING AND RETURN AS
*              RESULT OF READR FUNCTION
*      B3.728  THE DEFINITION OF THE AOV OPCODE IS CORRECTED.
*              FORMERLY THE DEFINITION SPECIFIED THAT THE BRANCH
*              WAS TO BE TAKEN IF THE RESULT OF THE ADDITION
*              EXCEEDED CFP$M, IMPLYING A TEST FOR OVERFLOW
*              FROM SIGNED ADDITION.
*              HOWEVER, ADDRESS ARITHMETIC MUST BE UNSIGNED TO
*              ALLOW FOR SYSTEMS WHERE THE HIGH ORDER ADDRESS
*              BIT IS SET.  THEREFORE, THE TEST MUST BE FOR
*              CARRY OUT OF THE HIGH ORDER BIT, IF THE RESULT
*              WOULD EXCEED CFP$L.
*      B3.729  A LABEL TRACE ON THE ENTRY LABEL FOR A FUNCTION
*              WAS UNDETECTED, RESULTING IN A TRANSFER TO
*              B$TRT AND SUBSEQUENT CRASH.  SEE BPF08 FOR FIX.
*      B3.730  POP FIRST ARGUMENT TO SUBSTR IF IT IS A BUFFER.
*      B3.731  PATTERN REPLACEMENT WITH BUFFER SUBJECT RETURNED
*              NULL STRING INSTEAD OF NEW SUBJECT VALUE.
*              CHANGED TO BEHAVE AS IF SUBJECT WAS A STRING.
*      B3.732  IF CONVERT FUNCTION WAS CALLED WITH A BUFFER
*              FIRST ARGUMENT AND "BUFFER" SECOND ARGUMENT,
*              IT WOULD CONVERT THE BUFFER TO A STRING, AND
*              THEN BACK TO A BUFFER.  THIS HAS BE CORRECTED
*              TO SIMPLY RETURN THE FIRST ARGUMENT AS THE
*              FUNCTION RESULT.
*      B3.733  DETECT EXTERNAL FUNCTION RETURNING A NULL STRING
*              UNCONVERTED RESULT AT BEF12, AND JUMP TO EXNUL.
*      B3.734  FIX PROBLEM AT INS04 WHEN INSERTING ZERO LENGTH
*              STRING INTO BUFFER.  DEFEND AGAINST INVOKING
*              MVC WITH A ZERO VALUE IN WA, WHICH WILL CAUSE
*              SOME IMPLEMENTATIONS TO WRAP THE COUNTER.
*      B3.735  ADD OVERFLOW TEST FOR COS AND SIN TO DETECT
*              OUT-OF-RANGE ARGUMENT.
*      B3.736  FIXED PROBLEM INTRODUCED WITH B3.727 NOT
*              RESTORING R$CIM, SCNPT AND SCNIL AFTER CREATING
*              SUBSTRING.
*      B3.737  FIXED TFIND TO PLACE DEFAULT VALUE IN NEWLY
*              ALLOCATED TEBLK.
*      B3.738  ADDED BL$P0 TO P$NTH ENTRY POINT.  THE EXPRESSION
*              DATATYPE(CONVERT("","PATTERN")) WOULD CRASH WHEN
*              THE DTYPE FUNCTION USES THE NON-EXISTANT TYPE
*              WORD PRECEDING P$NTH.
*      B3.739  BUG AT GTN35 IN THE CASE OF OVERFLOW DURING CVM.
*              WB CAN BE DESTROYED BY CVM ON SOME PLATFORMS.
*      B3.740  PROTECT SCONTINUE FROM USAGE IN OTHER THAN ERROR
*              320 CASE.
*      B3.741  PROTECT CONTINUE FROM USAGE FOLLOWING ERROR
*              EVALUATING COMPLEX FAILURE GOTO.
*
*
*      CHANGES
*      -------
*
*      C3.701  ADD .CULK CONDITIONAL TO INCLUDE &LCASE, &UCASE.
*      C3.702  ADD -LINE NN "FILENAME" CONTROL CARD.
*      C3.703  MOVE .CNLD CONDITIONAL UP IN ROUTINE DFFNC TO
*              OMIT ALL TESTS FOR B$EFC.
*      C3.704  ADD CONDITIONAL .CICC TO IGNORE UNRECOGNIZED
*              CONTROL CARDS.
*      C3.705  ADD CONDITIONAL .CNSC TO OMIT STRING TO NUMERIC
*              CONVERSION IN SORT.  THE PRESENCE OF THIS
*              CONVERSION MODE PRODUCES A SORT RESULT THAT IS
*              DEPENDENT UPON THE ORDER OF INPUT DATA.
*              FOR EXAMPLE, GIVEN INPUT DATA "2", 5, "10",
*              STRING COMPARISON YIELDS "10" LT "2", BUT STRING
*              TO INTEGER CONVERSION YIELDS "2" LT 5 LT "10".
*      C3.706  ADD SEVENTH RETURN FROM SYSHS THAT ALLOWS CALLEE
*              TO RETURN A STRING POINTER AND LENGTH.  THIS IS
*              DONE TO ELIMINATE THE NEED FOR THE CALLER TO HAVE
*              AN SCBLK BIG ENOUGH TO ACCOMMODATE LONG STRINGS.
*      C3.707  ADD EIGHTH RETURN FROM SYSHS TO FORCE COPY OF
*              BLOCK POINTED TO BY XR.
*      C3.708  MADE -COPY A SYNONYM FOR -INCLUDE.
*      C3.709  ADD CONDITIONAL .CBYT FOR STATISTICS DISPLAYED
*              IN BYTES RATHER THAN WORDS.
*      C3.710  DUMP NULL VALUED VARIABLES WHEN DUMP = 3.  CORE
*              DUMP PRODUCED FOR DUMP = 4.
*      C3.711  RESTRICT MINIMUM VALUE TO WHICH KEYWORD MAXLNGTH
*              CAN BE SET TO 1,024 VIA NEW VARIABLE MNLEN.
*      C3.712  ADD CONDITIONAL SYMBOL .CMTH FOR EXTENDED MATH
*              FUNCTIONS- ATAN, CHOP, COS, EXP, LN, SIN, SQRT,
*              TAN.  X**Y AND REMDR(X,Y) ARE EXTENDED TO INCLUDE
*              REALS.
*      C3.713  ADD BIT TO SYSPP TO SET -PRINT UPON ENTRY
*      C3.714  ADD CONDITIONAL .CSFN TO TRACK SOURCE FILE NAME
*              ASSOCIATED WITH EACH CODE BLOCK.
*      C3.715  ADD CONDITIONAL .CINC FOR -INCLUDE CONTROL CARD
*              FEATURE.  THE FORMAT OF THE CARD IS
*                 -INCLUDE "FILENAME"
*              INCLUDE CONTROL CARDS MAY BE USED DURING BOTH THE
*              INITIAL COMPILE AND EXECUTE-TIME COMPILE.  THE
*              FILENAME IS SAVED IN A TABLE, AND REDUNDANT
*              INCLUDES OF THAT FILE ARE IGNORED.
*      C3.716  ADD CONDITIONAL .CSLN TO INCLUDE SOURCE LINE
*              NUMBER IN CODE BLOCKS.  RELEASE CURRENT CCBLK
*              AFTER INITIAL COMPILE.
*      C3.717  CHANGED RILEN TO 258 (FROM 120) TO PROVIDE
*              UNIFORM INPUT LINE LENGTH WHEN READING FROM
*              TERMINAL OR INPUT.
*      C3.718  ADD ADDITIONAL EXIT TO IOFCB TO DISTINGUISH
*              ARGUMENT NOT CONVERTABLE TO STRING AND ARGUMENT
*              FILE NOT OPEN.
*      C3.719  ADD FOURTH AND FIFTH ARGUMENTS TO HOST FUNCTION.
*      C3.720  ADD &COMPARE KEYWORD TO CONTROL STRING
*              COMPARISONS.
*      C3.721  SETUP PFDMP AT INIY0 IN CASE OSINT FORCED
*              &PROFILE NON-ZERO.
*      C3.722  ADD CONDITIONAL SYMBOL .CAEX TO INCLUDE UP ARROW
*              AS SYNONYM FOR EXPONENTIATION.
*      C3.723  ADD CONDITIONAL .CCMC AND EXTERNAL FUNCTION SYSCM
*              TO PROVIDE STRING COMPARISON USING COLLATION
*              SEQUENCE OTHER THAN STRICT ORDERING OF CHARACTER
*              CODES (INTERNATIONAL COMPARES).
*      C3.724  ADD CONDITIONAL .CPOL AND EXTERNAL FUNCTION SYSPL
*              TO PROVIDE INTERACTIVE CONTROL OF SPITBOL
*              EXECUTION.
*      C3.725  ADD CONDITIONAL SYMBOL .CERA AND EXTERNAL
*              FUNCTION SYSEA TO PROVIDE ADVICE OF COMPILATION
*              AND RUNTIME ERRORS TO OSINT.
*      C3.726  ADD CMPLN, RDCLN, RDNLN TO TRACK SOURCE LINE
*              NUMBER.
*      C3.727  CONVERTED ERROR MESSAGES TO UPPER/LOWER CASE.
*      C3.728  ADD CONDITIONAL .CGBC TO EXTERNAL ROUTINE SYSGC.
*              CALLED AT THE START AND END OF GARBAGE COLLECTION
*              TO PERFORM ANY NEEDED NOTIFICATION TO OPERATING
*              SYSTEM OR USER.
*      C3.729  MODIFIED LAST LINE OF S$SET FROM EXNUL TO EXINT
*              SO SEEK CAN RETURN FINAL FILE POSITION AFTER
*              SEEK.
*      C3.730  PLACE MOV XR,(XS) AT S$RMD+4 TO ALLOW REAL SECOND
*              ARG TO REMDR.
*      C3.731  REMOVE REDUNDANT BGE XR,=CFP$U,SCN07 AT SCN06+4
*      C3.732  CHANGE DEFINITION OF CMC AND TRC SUCH THAT ONLY
*              XL MUST BE CLEARED AFTER OPERATION.  NOTE, THIS
*              CHANGE WAS SUBSEQUENTLY VOIDED.  CMC AND TRC MUST
*              CLEAR BOTH XL AND XR, BECAUSE UTILITY ROUTINES
*              MAY PRESERVE XL OR XR ON THE STACK, AND THE STACK
*              IS COLLECTABLE BY GBCOL.
*      C3.733  REMOVE MOST BRANCHES TO EXITS AND EXIXR.
*              INSTEAD, JUMP DIRECTLY TO NEXT CODE WORD.
*      C3.734  ADD ERROR 260 FOR ARRAY TOO LARGE IN GTARR.
*      C3.735  ADD CONDITIONAL .CS32 TO INITIALIZE STLIM TO
*              2147483647.
*      C3.736  ADD SECOND ARGUMENT TO EXIT FUNCTION, ALLOWING
*              USER TO SPECIFY FILE NAME OF LOAD MODULE BEING
*              WRITTEN.  IF OMITTED, OSINT WILL PROVIDE A
*              DEFAULT NAME.
*      C3.737  ADD CONDITIONAL .CSPR TO INCLUDE SPARE LOCATIONS
*              IN WORKING AREA.  THESE MAY BE USED IN LATER BUG
*              FIXES WITHOUT CHANGING THE SIZE OF THE WORKING
*              STORAGE AND OBSOLETING MODULES CREATED BY EXIT().
*              SUBSUENTLY REMOVED IN C3.767.
*      C3.738  ADD R$CTS TO REMEMBER LAST STRING USED TO BUILD
*              BIT COLUMN IN PATST.
*      C3.739  CHANGE FLSTG TO TYPE E PROCEDURE INSTEAD OF R.
*      C3.740  STANDARDIZE ON BIG-ENDIAN SYSTEMS.  AT THE
*              IMPLEMENTORS CHOICE, THE ZGB OPCODE CAN ALSO
*              PERFORM A BYTE SWAP IF NECESSARY TO ACHIEVE BIG-
*              ENDIAN BYTE ORDERING.  THIS IS DONE SO THAT
*              SYSTEMS WITH SIMILAR WORD LENGTHS WILL PRODUCE
*              THE SAME HASH CODE FOR STRINGS, AND HENCE THE
*              SAME ORDERING FOR TABLE ENTRIES.  THE HASHS
*              PROCEDURE HAS AN ADDITIONAL ZGB ADDED TO REORDER
*              THE LENGTH WORD.
*      C3.741  ADD CONDITIONAL .CSOU TO CAUSE ASSIGNMENTS TO
*              OUTPUT AND TERMINAL VARIABLES TO BE PROCESSED
*              THROUGH CALLS TO SYSOU RATHER THAN THROUGH
*              LISTING BUFFER.  DONE TO ELIMINATE SHORT RECORD
*              LENGTHS ENFORCED BY BUFFER SIZE.  A CODE OF 0 OR
*              1 IS PASSED TO SYSOU INSTEAD OF AN FCBLK.
*      C3.742  INCREASED INILN, INILS, RILEN TO 1024.
*      C3.743  ADD BIT TO SYSPP TO SET NOERRORS MODE.
*      C3.744  ADD .CCMK CONDITIONAL TO INCLUDE KEYWORD COMPARE
*              EVEN IF SYSCM IS NOT BEING INCLUDED.  DONE TO
*              PROVIDE IDENTICAL DATA REGIONS IN SYSTEMS THAT
*              IMPLEMENT SYSCM AND THOSE WHICH DO NOT, SO THAT
*              SAVE FILES CAN BE EXCHANGED IN THE NEXT RELEASE.
*      C3.745  ADD WC RETURN PARAMETER TO SYSIL TO ALLOW
*              INTERFACE TO INFORM SPITBOL IF FILE ABOUT TO BE
*              READ IS A BINARY FILE.  IF SO, NO BLANK TRIMMING
*              OCCURS.
*      C3.746  FOLD LOAD FUNCTION ARGUMENT TYPES TO UPPER CASE.
*      C3.747  ADD .CEXP CONDITIONAL TO HAVE SYSEX POP ITS
*              ARGUMENTS.
*      C3.748  IN STOPR, DO NOT ATTEMPT TO DISPLAY FILE NAME AND
*              LINE NUMBER IF STOPPING BECAUSE OF STACK OVERFLOW
*              DURING GARBAGE COLLECTION.  POINTERS TO FILE NAME
*              TABLE AND CODE BLOCK ARE WRONG.
*      C3.749  ADD BIT TO SYSPP TO SET CASE FOLDING MODE.
*      C3.750  ADD ADDITIONAL RETURN FROM SYSLD IF INSUFFICIENT
*              MEMORY TO LOAD/CALL EXTERNAL FUNCTION.
*      C3.751  ADD ADDITIONAL RETURNS FROM SYSEX IF INSUFFICIENT
*              MEMORY OR BAD ARGUMENT TYPE.
*      C3.752  IGNORE LEADING AND TRAILING BLANKS IN ARGUMENTS
*              WITHIN PROTOTYPE STRINGS TO CLEAR, DATA, DEFINE
*              AND LOAD.
*      C3.753  TEST FOR FATAL ERROR AT ERR04 AND ABORT IF SO.
*              FORCE TERMINATION ON STACK OVERFLOW BY SETTING
*              ERRFT TO 4 IN STACK OVERFLOW SECTION.
*      C3.754  RECODE COPY LOOP AT SRT14 TO EXCHANGE USAGE OF
*              REGISTERS XL AND XR.  THIS PERMITS USE OF THE
*              MVW ORDER INSTEAD OF THE EXPLICIT LOOP CODING
*              PREVIOUSLY EMPLOYED.
*      C3.755  ADD .CENG CONDITIONAL TO INCLUDE ROUTINES NEEDED
*              BY TEXT PROCESSING ENGINE. ADD ROUTINES ENEVS AND
*              ENGTS FOR USE BY ENGINE OR DEBUGGER.  COPY XR TO
*              XL AROUND CALL TO SYSPL TO ALLOW SYSPL TO
*              TRIGGER GARBAGE COLLECTION.
*      C3.756  ADD &FILE, &LASTFILE, &LINE, &LASTLINE KEYWORDS.
*              FOR NOW, LINE AND LASTLINE ARE MAINTAINED IN THE
*              SAME MANNER AS STNO AND LASTNO, WHICH ADDS OVER-
*              HEAD TO THE STATEMENT INITIALIZATION CODE.  A
*              POSSIBLE CHANGE IS TO CREATE A STMLN PROCEDURE
*              THAT MAPS STATEMENT NUMBERS TO LINE NUMBERS.
*              ONE SIMPLE STRATEGY WOULD BE TO SWEEP CODE BLOCKS
*              IN MEMORY LOOKING FOR THE STATEMENT NUMBER AND
*              EXTRACTING THE LINE NUMBER FROM THAT CODE BLOCK.
*              SUCH A PROCEDURE WOULD ALSO ALLOW LINE NUMBERS
*              (AND FILE NAMES) TO BE ADDED TO STATEMENT PROFILE
*              REPORTS.
*      C3.757  CHANGE SORT TO FAIL INSTEAD OF PRODUCING ERROR
*              MESSAGE IF ARGUMENT TABLE IS NULL.  CHANGE SORTA
*              TO RETURN FAILURE.  ADD ANOTHER RETURN TO GTARR
*              TO DISTINGUISH NULL TABLE FROM BAD ARGUMENT.
*      C3.758  CREATE PROCEDURE PRTMM TO DISPLAY MEMORY USAGE
*              STATISTICS, AND CALL IT WHEN PRODUCING END-OF-
*              RUN STATS.
*      C3.759  ADD LABEL SCONTINUE TO ALLOW SETEXIT TO RESUME
*              EXECUTION EXACTLY WHERE IT WAS INTERRUPTED.
*      C3.760  ADD SNOBOL4 BACKSPACE FUNCTION AND CONDITIONAL
*              .CBSP.
*      C3.761  ADD ADDITIONAL ARGUMENTS TO SYSGC TO ASSIST
*              VIRTUAL MEMORY MANAGERS.
*      C3.762  THE METHOD OF CONVERTING A TABLE TO AN ARRAY HAS
*              BEEN REVISED.  PREVIOUSLY, TABLE ELEMENTS WERE
*              COPIED TO THE RESULT ARRAY IN THE ORDER THEY WERE
*              ENCOUNTERED ALONG THE VARIOUS HASH CHAINS.  THIS
*              APPEARED TO THE USER AS A RANDOM ORDERING.  HOW-
*              EVER, SPITBOL/370 AS WELL AS SIL SNOBOL4 ORDERED
*              ARRAY ELEMENTS ACCORDING TO THEIR TIME OF ENTRY
*              INTO THE TABLE.  USER PROGRAMS THAT RELIED UPON
*              THIS BEHAVIOR MALFUNCTIONED WHEN PORTED TO MACRO
*              SPITBOL.
*              TO REMEDY THIS, THE CONVERSION IS PERFORMED IN
*              THREE STEPS:
*              1. CONVERT TABLE TO AN ARRAY PLACING THE ADDRESS
*                 OF EACH TEBLK IN THE ARRAY INSTEAD OF THE KEY
*                 AND VALUE.
*              2. SORT THE ARRAY OF ADDRESSES.  THIS ORDERS ELE-
*                 MENTS BY TIME OF CREATION (ASCENDING ADDRESS).
*              3. SCAN THE ARRAY, REPLACING ADDRESSES WITH THE
*                 KEY AND VALUE FROM THE REFERENCED TEBLK.
*              THE AFFECTED PORTIONS OF THE PROGRAM ARE AT S$CNV
*              AND IN GTARR, WHICH NOW ACCEPTS AN ADDITIONAL
*              ARGUMENT SPECIFYING WHETHER TO PLACE KEY/VALUES
*              IN THE ARRAY OR TEBLK ADDRESSES.
*      C3.763  IF CASE-FOLDING IS ACTIVE, FOLD THE FUNCTION NAME
*              PROVIDED TO THE LOAD() FUNCTION BEFORE PASSING IT
*              TO SYSLD.
*      C3.764  ADD SEDIMENT ALGORITHM TO GARBAGE COLLECTOR,
*              CONDITIONED ON .CSED.
*      C3.765  ADD OPTIMIZATION TO DISCARD NULL STATEMENTS AND
*              STATEMENTS WHICH JUST HAVE A CONSTANT SUBJECT
*              (SEE CODE AT CMP12).
*      C3.766  REARRANGED ORDER OF INITIAL OBJECTS IN STATIC
*              MEMORY SO THAT HASH TABLE IS THE LAST OF THE FOUR
*              OBJECT CREATED BY INITIALIZATION CODE.  THIS IS
*              DONE SO THAT THE PRINT BUFFER, GTS WORK AREA, AND
*              &ALPHABET KEYWORDS DO NOT NEED TO BE SAVED IN
*              ANY SAVE FILE CREATED BY OSINT.  ADDED ROUTINE TO
*              INITIALIZE THESE STRUCTURES.
*      C3.767  REMOVED .CSPR CONDITIONAL AND SPARE LOCATIONS.
*      C3.768  ADDED .CREL CONDITIONAL AND EXTENSIVE ROUTINES
*              (RELOC ET. AL.) TO PERFORM RELOCATION OF DATA
*              IN WORKING SECTION, STATIC REGION, AND DYNAMIC
*              REGION AFTER RELOAD OF A SAVED MEMORY IMAGE.
*              ROUTINES RELAJ, RELCR, AND RELOC ARE INVOKED
*              BY OSINT AFTER RELOADING A SAVE FILE.
*              IT IS NOW POSSIBLE TO RELOAD SUCH AN IMAGE EVEN
*              IF THE SPITBOL COMPILER AND ITS DATA STRUCTURES
*              ARE RELOADED TO OTHER ADDRESSES.  THE WORKING
*              SECTION HAS BEEN EXTENSIVELY REARRANGED TO
*              ACCOMMODATE THE RELOC PROCEDURE.
*      C3.769  ZERO R$CCB (INTERIM CCBLK PTR) IN COLLECT,
*              CONVERT, EVAL, AND EXIT FUNCTIONS TO RELEASE
*              UNNEEDED CCBLK MEMORY.
*      C3.770  ADD EXIT(4) AND EXIT(-4) TO ALLOW EXECUTION TO
*              CONTINUE AFTER WRITING SAVE FILE OR LOAD MODULE.
*              REVISED SYSXI INTERFACE TO DETECT CONTINUATION
*              AFTER PERFORMANCE OF EXIT(4) OR EXIT(-4) ACTION.
*      C3.771  CHANGE FILNM TO PRESERVE REGISTERS.
*      C3.772  ADDITION OF .CNCR AND SYSCR (REAL TO STRING
*              SYSTEM ROUTINE OPTION).
*      C3.773  MODIFIED REPLACE FUNCTION TO OPTIMIZE USAGE
*              WHEN SECOND ARGUMENT IS &ALPHABET.  IN THIS CASE,
*              THE THIRD ARGUMENT CAN BE USED AS THE TRANSLATE
*              TABLE DIRECTLY.
*      C3.774  MODIFIED CONDITIONALS FOR BUFFERS AND REALS SO
*              THAT THEIR RESPECTIVE BLOCK CODES ARE ALWAYS
*              PRESENT, EVEN IF THESE DATA TYPES ARE CONDITIONED
*              OUT.  THIS PROVIDES CONSISTENT BLOCK CODE
*              NUMBERING FOR EXTERNAL FUNCTIONS.
*      C3.775  MODIFIED ALOBF TO TEST STRING LENGTH AGAINST
*              KVMXL INSTEAD OF MXLEN.  ALSO, ALOBF WAS TESTING
*              TOTAL SIZE OF BFBLK, INSTEAD OF JUST STRING LEN.
*      C3.776  MOVE UTILITY ROUTINES SOURCE UP TO LIE BETWEEN
*              PREDEFINED SNOBOL FUNCTIONS (S$XXX) ROUTINES AND
*              UTILITY PROCEDURES.  THIS WAS DONE TO ASSIST
*              TRANSLATION ON PLATFORMS SUCH AS APPLE MACINTOSH
*              THAT USE 15-BIT OFFSETS TO STORE ERROR EXITS (PPM
*              BRANCHES).  OFFSETS TO LABELS LIKE EXFAL WERE
*              JUST TOO FAR AWAY.  SIMILARLY, FUNCTIONS TFIND,
*              TMAKE, AND VMAKE ARE LOCATED OUT OF ALPHABETIC
*              ORDER TO SATISFY THE MACINTOSH'S LIMITED RANGE
*              FOR SUBROUTINE CALLS.  MOVE BUILT-IN LABELS
*              BEYOND THE BLOCK AND PATTERN ROUTINES TO GET IT
*              WITHIN 32K OF THE ERROR ROUTINES.
*      C3.777  AT SCN46, ALLOW COLON, RIGHT PAREN AND RIGHT
*              BRACKET TO TERMINATE = OPERATOR WITH DEFAULT
*              NULL OPERAND.
*      C3.778  ADDED .CTET CONDITIONAL FOR TABLE ENTRY TRACE.
*      C3.779  INTRODUCE CFP$L, THE LARGEST UNSIGNED VALUE
*              THAT MAY BE STORED IN A ONE-WORD INTEGER.  THIS
*              IS DONE TO ACCOMMODATE MACHINES WHERE MEMORY
*              ADDRESSES HAVE THE HIGH-ORDER ADDRESS BIT SET.
*      C3.780  PERFORM REPLACE IN PLACE IF FIRST ARG IS BUFFER.
*      C3.781  PERFORM REVERSE IN PLACE IF FIRST ARG IS BUFFER.
*      C3.782  CHANGE SYSOU TO ACCEPT BUFFER AS WELL AS STRING
*              TO BE OUTPUT.  CHANGE CODE AT ASG11 TO PREVENT
*              CONVERSION OF BUFFER TO STRING.
*      C3.783  OPTIMIZE POS AND RPOS WHEN IT IS THE FIRST NODE
*              OF A PATTERN AND HAS EITHER AN INTEGER OR SIMPLE
*              EXPRESSION VARIABLE ARGUMENT.  IF UNANCHORED MODE
*              AND THE CURSOR IS ZERO, IT IS ADVANCED DIRECTLY
*              TO THE DESIRED CURSOR POSITION.
*      C3.784  PERFORM TRIM FUNCTION IN PLACE IF ARG IS BUFFER.
*      C3.785  ADD GTSTB PROCEDURE TO GET A STRING OR BUFFER
*              ARGUMENT FOR REPLACE, REVERSE, SIZE, TRIM, ETC.
*      C3.786  CHANGE LEQ, LGT, ETC. TO PERFORM COMPARISONS
*              WITHOUT CONVERTING BUFFER ARGUMENTS TO STRINGS.
*              THIS IS DONE BY CHANGING LCOMP TO ACCEPT BUFFER
*              ARGUMENT(S).  THIS ALSO AFFECTS SORT FUNCTION,
*              WHICH WILL COMPARE TWO BUFFERS AS STRINGS.
*      C3.787  CHANGE GTNUM TO USE CHARACTERS IN BUFFER WITHOUT
*              CONVERSION TO A STRING.  THIS IMPLIES THAT ACOMP
*              WILL PERFORM ARITHMETIC COMPARISONS OF BUFFERS
*              WITHOUT CONVERTING TO STRINGS FIRST.
*      C3.788  PERFORM COMPARISONS OF STRINGS AND BUFFERS IN
*              SORTC.
*      C3.789  CHANGE INSBF TO ALLOW INSERTION OF A BUFFER INTO
*              A BUFFER WITHOUT FIRST CONVERTING IT TO A STRING.
*              NOTE THAT THIS ONLY WORKS WHEN THE TWO BUFFERS
*              ARE NOT THE SAME.
*      C3.790  DOCUMENTATION CHANGE:  NOTE THAT ALL OF THE BLOCK
*              MOVE OPCODES SHOULD HAVE WA .GT. 0.  NOT ALL
*              IMPLEMENTATIONS AVOID MOVING OBJECTS WHEN WA IS
*              ZERO.
*      C3.791  CHANGE IDENT TO PROVIDE BUFFER/BUFFER AND
*              BUFFER/STRING COMPARISONS, TO ACCOMMODATE USERS
*              WHO PERFORM IDENT(BUF) TO CHECK FOR NULL STRING
*              IN BUFFER.
*      C3.792  ADDED FULLSCAN KEYWORD INITIALIZED TO ONE.  USER
*              MAY SET TO ANY NON-ZERO VALUE, WILL RECEIVE AN
*              ERROR MESSAGE IF ATTEMPTS TO SET TO ZERO, SINCE
*              QUICKSCAN MODE IS NOT SUPPORTED.
*      C3.793  REWROTE STATEMENT STARTUP CODE AT STMGO TO ONLY
*              PERFORM CHECKING OF PROFILING, STCOUNT TRACING,
*              AND STATEMENT COUNTING IF NECESSARY.
*      C3.794  ADD ADDITIONAL EXIT TO SYSFC AND IOPUT TO SIGNAL
*              THAT I/O CHANNEL (FCBLK) IS ALREADY IN USE.
*              ADDED ERROR MESSAGE NUMBERS 289 AND 290.
*      C3.795  ADDED OPTIONAL INTEGER ARGUMENT TO DATE FUNCTION
*              TO SPECIFY FORMAT OF DATE STRING RETURNED BY
*              SYSDT.
*
*
*      VERSION 3.6 TO 3.6A (OCT 83)
*      ---------------------------
*
*      CHANGES
*      -------
*
*      C3.617  ADD .CNLF. IF DEFINED, THEN ARGUMENTS TO EXTERNAL
*              FUNCTIONS MAY BE DECLARED TO HAVE TYPE FILE.
*              SUCH ARGUMENTS MUST HAVE BEEN USED AS SECOND
*              ARG TO INPUT() OR OUTPUT() AND A POINTER TO THE
*              FCB IS PASSED TO THE EXTERNAL FUNCTION.
*
*
*      VERSION 3.5 TO 3.6 (JUN 83)
*      ---------------------------
*
*      CODES USED TO IDENTIFY AUTHORS ARE (SGD) FOR DUFF,
*      (REG) FOR  GOLDBERG, AND (LDS) FOR SHIELDS.
*
*      BUGS FIXED
*      ----------
*      B3.601  (SGD) TO FIX MULTIPLE TRAP BLOCK PROBLEM IN ASIGN
*      B3.602  (SGD) PATCH IN GTARR TO FIX NULL CONVERT.
*      B3.603  (SGD) INSERTED MISSING WTB AFTER SYSMM CALLS.
*      B3.604  (SGD) USE STRING LENGTH IN HASHS.
*      B3.605  (SGD) FIXED SERIOUS PARSER PROBLEM
*              RELATING TO (X Y) ON LINE BEING VIEWED AS PATTERN
*              MATCH.  FIXED BY ADDITION OF NEW CMTYP VALUE
*              C$CNP (CONCATENATION - NOT PATTERN MATCH).
*      B3.606  (SGD) FIXED EXIT(N) RESPECIFICATION CODE
*              TO PROPERLY OBSERVE HEADER SEMANTICS ON RETURN.
*      B3.607  (SGD) BYPASS PRTPG CALL AT INITIALIZATION
*              FOLLOWING COMPILATION IF NO OUTPUT GENERATED.
*              THIS PREVENTS OUTPUT FILES CONSISTING OF THE
*              HEADERS AND A FEW BLANK LINES WHEN THERE IS NO
*              SOURCE LISTING AND NO COMPILATION STATS.
*              ALSO FIX TIMSX INITIALIZATION IN SAME CODE.
*      B3.608  (SGD) B$EFC CODE DID NOT CHECK FOR
*              UNCONVERTED RESULT RETURNING NULL STRING.
*      B3.609  (SGD) LOAD PFVBL FIELD IN RETRN FOR
*              RETURN TRACING. THIS WAS CAUSING BUG ON RETURN
*              TRACES THAT TRIED TO ACCESS THE VARIABLE NAME.
*      B3.610  (SGD) FIXED PROBLEM RELATING TO COMPILATION OF
*              GOTO FIELDS CONTAINING SMALL INTEGERS
*              (IN CONST SEC).
*      B3.611  (REG) PREVENT CLEAR() FROM CLOBBERING PROTECTED
*              VARIABLES AT LABEL SCLR5.
*      B3.612  (REG) FIXED GTEXP FROM ACCEPTING TRAILING
*              SEMICOLON OR COLON. THIS IS NOT A LEGAL WAY
*              TO END AN EXPRESSION.
*      B3.613  (REG) FIXED DIFFICULTIES WITH LISTINGS DURING
*              EXECUTION WHEN NO LISTING GENERATED DURING
*              COMPILATION. -LIST TO CODE() CAUSED BOMB.
*              FIX IS TO RESET R$TTL AND R$STL TO NULLS NOT 0
*              AFTER COMPILATION.
*              (LISTR AND LISTT EXPECT NULLS)
*              WHEN LISTING AND STATISTICS ROUTED TO DIFFERENT
*              FILE THAN EXECUTION OUTPUT, ERROR MESSAGE IS SENT
*              TO EXECUTION OUTPUT (AND GETS SEPARATED FROM
*              ... IN STATEMENT ... MSG). LABO1 CALLS SYSAX AND
*              STOPR DOES NOT CALL SYSAX IF ENTERED FROM LABO1.
*      B3.614  (LDS) FIX MISUSE OF WC JUST AFTER ASG10.
*      B3.615  (LDS) ADD COMMENT POINTING OUT SUSPICIOUS CODE
*              AFTER TFN02
*      B3.616  (LDS) FIX INCONSISTENT DECLARATION OF SORTH.
*      B3.617  (LDS) INSERT MISSING CONDITIONAL TESTS ON CNBF.
*      B3.618  (LDS) FIX SOME VIOLATIONS OF MINIMAL LANGUAGE
*              THAT HAD SLIPPED PAST SOME TRANSLATORS.
*      B3.619  (LDS) CORRECT ERROR INTRODUCED IN FIXING B3.614.
{{EJC{{{{{699
*      CHANGES
*      -------
*
*
*      C3.601  (SGD) ADDITION OF .CNCI AND SYSCI (INT TO STRING
*              SYSTEM ROUTINE OPTION)
*      C3.602  (REG) CHANGED INILN AND AND INILS TO 258
*      C3.603  (SGD) MERGED IN PROFILER PATCHES, REPAIRED CODE.
*      C3.604  (SGD) ADDED BUFFER TYPE AND SYMBOL CNBF
*      C3.605  (SGD) ADDED CHAR FUNCTION.  CHAR(N) RETURNS NTH
*              CHARACTER OF HOST MACHINE CHARACTER SET.
*      C3.606  (REG) ADDED CFP$U TO EASE TRANSLATION ON SMALLER
*              SYSTEMS - CONDITIONAL .CUCF
*      C3.607  (REG) ADDED LOWER CASE SUPPORT, CONDITIONAL .CULC
*      C3.608  (REG) ADDED SET I/O FUNCTION, CONDITIONAL .CUST
*      C3.609  (REG) CONDITIONALIZED PAGE EJECT AFTER CALL TO
*              SYSBX AND ADDED ANOTHER BEFORE CALL TO SYSBX,
*              SO THAT, IF DESIRED BY THE IMPLEMENTOR,
*              STANDARD OUTPUT WILL REFLECT ASSIGNMENTS MADE
*              BY EXECUTING PROGRAM ONLY.
*              CONDITIONAL .CUEJ CONTROLS - IF DEFINED THEN
*              EJECT IS BEFORE CALL TO SYSBX.
*      C3.610  (LDS) INTRODUCE .CTMD TO SUPPORT SYSTM THAT
*              REPORTS ELAPSED TIME IN DECISECONDS INSTEAD OF
*              MILLISECONDS.
*      C3.611  (LDS)  PROVIDE PLACE FOR .DEF OR .UND FOR EACH
*              CONDITIONAL  OPTION, SO THAT SETTINGS CAN BE
*              CHANGED WITHOUT CHANGING LINE NUMBERS.
*              CURRENT SETTINGS ARE FOR 808X TRANSLATION.
*      C3.612  (LDS) OBEY (NEW) RESTRICTION THAT OPERAND IN
*              CONDITIONAL BRANCH INSTRUCTION CANNOT HAVE FORM
*              (X)+ IN ORDER TO SIMPLIFY TRANSLATIONS FOR WHICH
*              POSTINCREMENT NOT READILY AVAILABLE.
*      C3.613  (REG,LDS) ADD OP
*                    FLC WREG
*              THAT FOLDS CHARACTER IN WREG TO UPPER CASE.
*              THIS OP IS USED ONLY IF .CULC IS DEFINED.
*              THIS CHANGE ALSO INVOLVES ADDITION OF KEYWORD
*              &CASE WHICH WHEN NONZERO (THE INITIAL SETTING)
*              CAUSES THE CASE FOLDING JUST DESCRIBED TO BE
*              DONE.
*      C3.614  (LDS) ADD OPTION .CS16 TO PERMIT INITIALIZATION
*              OF STATEMENT LIMIT VALUES TO 32767 FOR 16 BIT
*              MACHINES.
*      C3.615  (LDS) PERMIT RETURN POINT AND ENTRY POINT
*              ADDRESSES TO BE DISTINGUISHED BY THEIR PARITY
*              INSTEAD OF BY LYING WITHIN A CERTAIN RANGE
*              OF VALUES.  INTRODUCE CONDITIONAL SYMBOLS
*              .CRPP  RETURN POINTS HAVE ODD PARITY
*              .CEPP  ENTRY POINTS HAVE ODD PARITY
*      C3.616  (LDS) INTRODUCE NEW MINIMAL OPCODES TO BRANCH
*              ACCORDING TO PARITY,
*                BEV  OPN,PLBL  BRANCH IF ADDRESS EVEN
*                BOD  OPN,PLBL  BRANCH IF ADDRESS ODD
*              AN ADDRESS IS EVEN IF IT IS A MULTIPLE OF CFP$B.
{{EJC{{{{{755
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.601  (LDS) BRING MINIMAL MACHINE DESCRIPTION UP TO
*              DATE
*
{{EJC{{{{{762
*      VERSION 3.4 TO 3.5 (FEB 79)
*      ---------------------------
*
*
*      BUGS FIXED
*      ----------
*
*      B3.401  PRTST SHOULD BE DECLARED AS AN R TYPE PROCEDURE.
*      B3.402  TIMING ERROR IF SPITBOL FAILS IN DUMP.
*      B3.403  ERROR IN HANDLING OMITTED ARGS OF OPERATORS.
*      B3.404  TOO MANY LINES PUT ON FIRST PAGE OF LISTING.
*      B3.405  LEADING UNARY OPERATOR IN EVAL ERRONEOUSLY NEEDED
*              PRECEDING BLANK.
*      B3.406  IDENTIFYING NAME IN DUMP OF ARRAY OR TABLE VALUES
*              WAS OMITTED.
*      B3.407  EVAL UNABLE TO RETURN A DEFERRED EXPRESSION.
*      B3.408  ILLEGAL IF SETEXIT CODE BRANCHES TO RETURN.
*      B3.409  ILLEGAL ON DETACHING INPUT, OUTPUT, TERMINAL.
*
*      CHANGES
*      -------
*
*      C3.401  -SEQU AND -NOSE CONTROL CARDS REMOVED.
*      C3.402  OPTION PROVIDED TO SUPPRESS SYSTEM IDENTIFICATION
*              ON LISTING.
*      C3.403  DESCRIPTION OF SYSBX SLIGHTLY REVISED.
*      C3.404  PERMISSIBLE TO MODIFY SCBLK LENGTH BEFORE TAKING
*              ERROR RETURNS FROM SYSIN, SYSRD, SYSRI.
*      C3.405  CONDITIONAL .CNLD MAY BE DEFINED TO OMIT LOAD().
*      C3.406  CONDITIONAL .CNEX MAY BE DEFINED TO OMIT EXIT().
*      C3.407  TABLE NOW ACCEPTS A THIRD ARGUMENT SPECIFYING
*              DEFAULT INITIAL LOOKUP VALUE.
*      C3.408  ROUTINES SORT, RSORT FOR SORTING ARRAYS AND TABLE
*              INTRODUCED. SPECIFICATION IS AS IN SITBOL.
*              ROUTINES MAY BE OMITTED BY DEFINING .CNSR .
*      C3.409  ERROR IN CODE(), EVAL() CALL NOW CAUSES STATEMENT
*              FAILURE BUT ERRTEXT KEYWORD IS STILL SET.
*      C3.410  ARG TO CODE() MAY CONTAIN EMBEDDED CONTROL CARDS
*              AND COMMENT DELIMITED BY A SEMICOLON.
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.401  PURPOSE OF RESTRICTION 2 IN MINIMAL SECTION -6-
*              (OPERATIONS ON CHAR VALUES), ERRONEOUSLY STATED
*              TO BE FOR CMC, RATHER THAN FOR CEQ, CNE.
*              DESCRIPTIONS OF ABOVE OPCODES REVISED.
*      D3.402  DESCRIPTION OF ENT CLARIFIED.
*      D3.403  DESCRIPTIONS OF SEVERAL OPCODES REVISED TO REMOVE
*              TECHNICALLY INVALID LITERALS E.G. =0 , *1.
*      D3.405  RESTRICTED USE OF LETTER Z IN MINIMAL CLARIFIED.
*      D3.406  DIVIDE BY ZERO EXPLICITLY MENTIONED IN RELATION
*              TO OVERFLOW SETTING.
{{EJC{{{{{816
*      VERSION 3.3 TO 3.4 (OCT 78)
*      ---------------------------
*
*
*      BUGS FIXED
*      ----------
*
*      B3.301  ILLEGAL FOR ERRONEOUS EVAL() ARG.
*      B3.302  ADDRESS ARITHMETIC OVERFLOW IN ALLOC AND ALOCS.
*      B3.303  -EJECT AND -SPACE IGNORED -NOLIST OPTION.
*      B3.304  ERRONEOUS ARGUMENT SCAN IN LOAD().
*      B3.305  ERRONEOUS PLC ON UNINITIALISED R$CIM IN NEXTS.
*      B3.306  LDI USED INSTEAD OF MTI AFTER PRV07.
*      B3.307  MISUSE OF RMI AT ERRA2.
*      B3.308  MISUSE OF MTI IN HASHS.
*      B3.309  BUG IN -SEQU CARD SEQUENCE NUMBER CHECKING.
*      B3.310  STACK OVERFLOW ERROR MESSAGE NOT ALWAYS PRINTED.
*      B3.311  CORRUPT PROTOTYPE PRINT FOR TRACED ARRAYS.
*      B3.312  PATTERN FIRST ARG IN DUPL CAUSED ERROR.
*      B3.313  OMITTED CSC IN S$RPD, ERRONEOUS CSC IN CONVERT.
*      B3.314  MISPLACED BTW IN EXBLD.
*      B3.315  INCORRECT CODE IN HASHS.
*      B3.316  FAILURE OF LOAD TO SCAN INTEGER ARG.
*      B3.317  TABLE ACCESS WITH NEGATIVE INTEGER ARG. FAILED.
*      B3.318  ERROR IN RETURNING RESULT OF LOADED FUNCTION.
*      B3.319  =E$SRS USED AFTER INI01 INSTEAD OF *E$SRS.
*      B3.320  ERR USED INSTEAD OF ERB AFTER SYSTU
*      B3.321  LABEL COULD START WITH DISALLOWED CHARACTER.
*      B3.322  CONTINUE AFTER SETEXIT HAD BAD HEURISTIC.
{{EJC{{{{{846
*
*
*      CHANGES
*      -------
*
*      C3.301  SYSAX AND .CSAX INTRODUCED - SEE SYSAX
*              IN PROCEDURES SECTION.
*      C3.302  VARIABLE MXLEN INTRODUCED. CONTAINS THE MAXIMUM
*              SIZE OF A SPITBOL OBJECT AND IS NOT CHANGEABLE
*              AFTER INITIALISATION. MAY BE DEFAULTED OR SET
*              EXPLICITLY BY SYSMX.
*      C3.303  SYSHS RETURNS REVISED - SEE SYSHS.
*      C3.304  NEW MINIMAL OPCODE AOV TO FIX B3.302.
*      C3.305  INHIBIT STLIMIT CHECK IF STLIMIT MADE NEGATIVE.
*      C3.306  CFP$M IS REQUIRED TO BE OF FORM 2**N - 1.
*      C3.307  DUPL MADE TO CONFORM TO SIL SNOBOL4 STANDARD.
*      C3.308  LCH AND SCH ACTIONS MORE CLOSELY DEFINED.
*      C3.309  BATCH INITIALISATION CODE OMITTED IF CONDITIONAL
*              ASSEMBLY SYMBOL .CNBT (NO BATCH) DEFINED.
*      C3.310  (WA) CONTAINS ARGUMENT COUNT IN SYSEX CALL.
*      C3.311  SYSFC  MAY REQUEST ALLOCATION OF STATIC FCBLK.
*      C3.312  IF IA,WC OVERLAP, RESTRICTION PUT ON DUMPING/
*              RESTORING THESE REGISTERS.
*      C3.313  NEW LISTING OPTION INTERMEDIATE BETWEEN COMPACT
*              AND EXTENDED PROVIDED (SEE SYSPP).
*      C3.314  REVISION OF SYSXI INTERFACE TO PERMIT OPTIONS FOR
*              LOAD MODULE STANDARD O/P FILE (SEE SYSXI,SYSPP).
*      C3.315  LAST ARG OF SUBSTR MAY BE OMITTED - TREATED
*              AS REMAINDER OF STRING.
{{EJC{{{{{876
*      VERSION 3.2 TO 3.3 (JAN 78)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.201  ARRAY REFERENCE AND EXTERNAL FUNCTION LOAD
*              ROUTINES ILLEGALLY ACCESSED INFORMATION
*              BEYOND THE STACK FRONT.
*              SIMILAR FAULT IN UNANCHORED PATTERN MATCHING.
*      B3.202  DUMP(1) PRODUCED DUMP(2) TYPE OUTPUT.
*      B3.203  WTB CONVERSION OMITTED IN CODE FOLLOWING
*              INI01, INI02, EXBLD.
*      B3.204  INCORRECT FAIL RETURN FROM TFIND IN ARREF.
*      B3.205  ENDFILE DID NOT DETACH I/O ASSOCIATED VARIABLES.
*      B3.206  -SPACE WITH OMITTED ARG. FAILED
*      B3.207  LOOPED IF DUMP KEYWORD NON-ZERO AFTER STACK
*              OVERFLOW IN GARBAGE COLLECT FAILURE.
*      B3.208  FAILURE IN READING NUMBERS WITH TRAILING BLANKS.
*
*      CHANGES
*      -------
*
*      THE EXTENSIVE CHANGES MADE HERE MOSTLY RESULT FROM A
*      SNOBOL4 IMPLEMENTORS MEETING HELD AT NEW YORK UNIVERSITY
*      IN AUGUST 1977. THEY ARE AIMED AT
*           (1) HAVING SPITBOL CONFORM TO CERTAIN SNOBOL4
*           LANGUAGE STANDARDS  AND
*           (2) PRODUCING A STABLE DEFINITION OF MINIMAL BY
*           CARRYING OUT A FEW ESSENTIAL REVISIONS IN THE LIGHT
*           OF EXPERIENCE IN ITS USE.
*
*      CHANGES TO SPITBOL
*      ------------------
*
*      C3.201  DEFAULT VALUES FOR KEYWORDS TRIM AND ANCHOR ARE
*              ZERO. ON SYSTEMS WHERE RECORDS ARE CUSTOMARILY
*              HANDLED WITHOUT TRALING BLANKS, THERE IS NO
*              OBLIGATION TO SUPPLY SUCH BLANKS.
*      C3.202  DEFAULT VALUE OF -INXX CONTROL CARD IS -IN72.
{{EJC{{{{{917
*      C3.203  THE SECOND ARGUMENT OF INPUT AND OUTPUT IS
*              PERMITTED TO BE AN INTEGER AS IN SNOBOL4.
*              IN ADDITION INPUT(), OUTPUT() NOW GIVE A SNOBOL4
*              STATEMENT FAILURE IF SYSIO USES THE FILE NOT
*              FOUND RETURN.
*              THE THIRD ARGUMENT HAS A RECOMMENDED FORMAT AND
*              TO OVERRIDE ITS DEFAULT DELIMITER (,) A
*              CONDITIONAL ASSEMBLY SYMBOL, .CIOD, IS USED.
*              INTERFACES TO SYSEF,SYSEJ,SYFC,SYSIO,SYSRW
*              ARE REVISED.
*              WC MAY NOW BE USED TO RETURN FROM SYSIO, A MAX
*              RECORD LENGTH.
*      C3.204  A NEW CONFIGURATION PARAMETER CFP$F (SCBLK OFFSET
*              IS INTRODUCED. CFP$U IS REMOVED.
*      C3.205  IMPLEMENTATION AND VERSION IDENTIFICATION IS
*              REQUIRED - SEE SYSID.
*      C3.206  ROUTINE SYSMX RETURNS THE MAXIMUM LENGTH OF
*              SPITBOL OBJECTS (STRINGS ARRAYS ETC).  THIS
*              INFORMATION IS NOT NOW NEEDED AT TIME OF ENTRY TO
*              SPITBOL AND HENCE WC SHOULD BE ZERO ON ENTRY.
*      C3.207  A CONDITIONAL PARAMETER .CNRA PERMITS ASSEMBLY
*              OF A MORE COMPACT VERSION WITH NO REAL
*              ARITHMETIC CODE.
*      C3.208  TERMINAL IS A NEW PRE-ASSOCIATED VARIABLE
*              CAPABLE OF PERFORMING INPUT AND OUTPUT TO AN
*              ONLINE TERMINAL.
*              SYSRI IS A NEW ROUTINE USED IN THE IMPLEMENTATION
*              OF THIS. SEE ALSO SYSPP.
*      C3.209  THE ENVIRONMENT PARAMETERS E$--- ARE NOW
*              PROVIDED BY THE MINIMAL TRANSLATOR USING THE
*              REVISED   EQU  *   FORMAT (SEE C3.229 AND START
*              OF SPITBOL DEFINITIONS SECTION - SOME REORDERING
*              OF SYMBOLS HAS OCCURRED).
*      C3.210  THE INTERFACE OF SYSXI HAS BEEN SLIGHTLY REVISED.
*              UNAVAILABILITY OF I/O CHANNELS AFTER EXIT(1),
*              EXIT(-1) IS DOCUMENTED TOGETHER WITH ADDITIONAL
*              ERROR RETURN USAGE FOR SYSIN,SYSOU,SYSPR,SYSRD.
*      C3.211  SPITBOL ERROR CODES HAVE BEEN FROZEN - SEE C3.230
*      C3.212  THE UTILITY ROUTINES ARREF ETC. ARE NOW
*              INTRODUCED BY RTN STATEMENTS.
*      C3.213  SYSRL (RECORD LENGTH FOR STD INPUT FILE) IS
*              REMOVED. SINCE IMPLEMENTATION OF A GENERAL -INXXX
*              CONTROL CARD AND AN ABILITY TO SPECIFY MAX RECORD
*              LENGTH USING THE THIRD ARGUMENT OF INPUT, SYSRL
*              HAS BECOME REDUNDANT.
*      C3.214  SYSEJ AND SYSXI ARE NOW PASSED A CHAIN LINKING
*              ALL FCBLKS IN USE.
*      C3.215  A SPECIAL ENDING CODE IN SYSEJ IS USED WHEN
*              ATTEMPTS TO USE STANDARD OUTPUT CHANNEL FAIL.
*      C3.216  RESTRICTION C3.233 OBSERVED SO SIMPLIFYING
*              OPTIMISED TRANSLATION OF ENT WITH OMITTED VAL.
{{EJC{{{{{969
*
*      CHANGES TO MINIMAL
*      ------------------
*
*      C3.220  MINIMAL OPCODES DEC, DIM, INC, AND BMP
*              ARE WITHDRAWN AND REPLACED BY THE MORE CONSISTENT
*              SET DCA, DCV, ICA, ICV.
*      C3.221  CHS HAS BEEN REPLACED BY THE MORE GENERALLY
*              USEFUL ZGB (STILL LIKELY TO BE A NO-OP FOR MOST
*              IMPLEMENTATIONS HOWEVER).
*      C3.222  THE SET OF CHARACTER COMPARISONS HAS BEEN
*              REDUCED TO CEQ AND CNE TO EASE IMPLEMENTATION
*              PROBLEMS.
*      C3.223  OPCODE IRZ IS REMOVED AND DVI, RMI ORDERS ARE
*              REDEFINED TO CONFORM TO MORE COMMON USAGE.
*      C3.224  NEW OPCODES SSL AND SSS ARE DEFINED. THEIR USE
*              PERMITS RETURN LINKS FOR N TYPE PROCEDURES TO BE
*              PLACED ON A LOCAL STACK IF DESIRED.
*      C3.225  OPCODE MNZ COMPLEMENTS ZER. IT MOVES A NON-ZERO
*              FLAG TO ITS DESTINATION.
*      C3.226  FOR SOME MACHINES IT IS PREFERABLE FOR THE STACK
*              TO BUILD UP RATHER THAN DOWN. TO PERMIT THIS
*              WITHOUT NEED FOR MASSIVE CHANGES IN MINIMAL AND
*              RECODING OF EXISTING PROGRAMS, A SCHEME HAS BEEN
*              DEVISED IN WHICH AN ADDITIONAL REGISTER NAME, XT,
*              IS USED AS A SYNONYM FOR XL WHEN THIS REGISTER
*              IS INVOLVED IN STACK MANIPULATION- SEE SECTION 4.
*      C3.227  SECTION 0 OF A MINIMAL PROGRAM IS RENAMED THE
*              PROCEDURE SECTION. IT NOW CONTAINS, IN ADDITION
*              TO EXP, SPECIFICATIONS OF INTERNAL PROCEDURES
*              AND ROUTINES BY MEANS OF THE INP AND INR OPCODES.
*      C3.228  THE LITERAL OPERAND FORMATS =INT AND *INT HAVE
*              BEEN WITHDRAWN. =DLBL AND *DLBL MUST BE USED IN
*              THEIR STEAD.
*      C3.229  THE FORMAT
*              LABEL  EQU  *NN
*              USED TO SPECIFY VALUES SUPPLIED BY THE MINIMAL
*              TRANSLATOR FOR CHAR. CODES ETC. IS REPLACED BY
*              LABEL  EQU  *
*              WHERE THE ORDER IN WHICH THE DEFINITIONS ARE
*              SUPPLIED BY THE TRANSLATOR SHOULD MATCH THE
*              ORDER OF OCCURRENCE IN THE DEFINITIONS SECTION.
*      C3.230  THE FORMAT OF ERR,ERB OPCODES IS CHANGED TO
*              REQUIRE A NUMERIC OPERAND.
*      C3.231  THE RTN OPCODE IS USED TO INTRODUCE ROUTINES
*              (WHICH ARE QUITE DISTINCT FROM PROCEDURES).
*      C3.232  CONDITIONAL ASSEMBLY DIRECTIVES MAY BE NESTED.
*      C3.233  MINOR RESTRICTION PLACED ON THE OMISSION OF
*              VAL WITH THE ENT OPCODE.
{{EJC{{{{{1019
*      VERSION 3.1 TO 3.2 (AUG 77)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.101  ASTONISHING THIS WAS UNNOTICED FOR THREE YEARS.
*              BAD CODE FOR SNOBOL4 INTEGER DIVIDE, /, GAVE
*              WRONG RESULT FOR OPERANDS OF OPPOSITE SIGNS.
*              IMPLEMENTATIONS HAVE EITHER WRONGLY TRANSLATED
*              DVI AND GOT CORRECT RESULT OR CORRECTLY
*              TRANSLATED DVI AND GOT WRONG RESULT - LEEDS HAD
*              ONE OF EACH. SEE ALSO C3.106.
*              TEST PROGRAM NO. 1 NOW EXTENDED TO CHECK /
*              MORE THOROUGHLY.
*      B3.102  GARBAGE COLLECTION BUG IN SCANE
*
*      CHANGES
*      -------
*
*      C3.101  OPTION TO USE ADDITIONAL CHARACTERS CH$HT,CH$VT
*              (HORIZONTAL AND VERTICAL TAB) WITH SAME SYNTACTIC
*              SIGNIFICANCE AS CH$BL (BLANK).
*      C3.102  OPTION TO USE A SET OF SHIFTED CASE ALPHABETIC
*              CHARACTERS CH$$A ... CH$$$.
*      C3.103  CONDITIONAL ASSEMBLY FEATURES ARE INTRODUCED INTO
*              MINIMAL ON ACCOUNT OF THE ABOVE.
*              SEE MINIMAL DOCUMENTATION SECTION FOR DETAILS
*              OF ABOVE CHANGES.
*      C3.104  LCH AND SCH MAY USE AN X REGISTER FIRST
*              OPERAND AS ALTERNATIVE TO A W REGISTER.
*      C3.105  SPITBOL STATEMENT NUMBERS IN THE LISTING MAY
*              OPTIONALLY BE PADDED TO 6 OR 8 CHARS INSTEAD OF 5
*              BY DEFINING CONDITIONAL ASSEMBLY SYMBOLS
*              .CSN6 OR .CSN8 .
*      C3.106  TO FIX BUG 3.101. AT MODERATE COST,
*              OPCODE IRZ (BRANCH IF INTEGER DIVIDE REMAINDER
*              ZERO) INTRODUCED.
*      C3.107  TO HANDLE POSSIBLE MACHINE DEPENDENCY IN STRING
*              HASHING, CHS (COMPLETE HASHING OF STRING) OPCODE
*              IS INTRODUCED. PROBABLY A NO-OP ON MOST MACHINES
*              - NOT ON THE DEC10.
*      C3.108  PROCEDURES PATIN,TFIND,TRACE HAVE BEEN
*              MODIFIED TO CONFORM TO THE MINIMAL STANDARD
*              CALL AND RETURN REGIME.
*      C3.109  SYSFC INTERFACE REVISED SLIGHTLY TO PERMIT
*              OSINT TO RETURN A POINTER TO A PRIVATELY
*              ALLOCATED FCBLK WHICH SPITBOL WILL RETURN ON
*              SUBSEQUENT I/O - SEE SYSFC DOC.
*      C3.110  TO REMOVE INCONSISTENCIES IN CALLING SEQUENCES,
*              ALL SYS ROUTINES HAVING ACCESS TO A POSSIBLE
*              FCBLK HAVE FCBLK PTR OR ZERO IN REG. WA ON ENTRY.
*              CHANGE AFFECTS SYSEF, SYSEN, SYSIL, SYSIN,
*              SYSOU, SYSRW.
*      C3.111  SYSPP BIT ALLOCATED TO PROVIDE
*               -NOEXEC OPTION ON ENTRY TO SPITBOL.
{{EJC{{{{{1076
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.101  NEED TO PRESERVE REGISTERS IN SYSPI, SYSPR,
*              SYSRD CALLS WAS OVERSTATED.
{{EJC{{{{{1083
*      VERSION 3.0 TO 3.1 (MAR 77)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.001  REPLACE() COULD FAIL DURING PRE-EVALUATION.
*              SPITBOL NOW SIGNALS AN ERROR FOR NULL OR
*              UNEQUALLY LONG 2ND AND 3RD ARGUMENTS.
*      B3.002  NEGATIVE SECOND ARGUMENTS TO DUPL, LPAD, RPAD
*              CAUSED SPITBOL TO SIGNAL AN ERROR. NOW CAUSES
*              RETURN OF NULL STRING OR FIRST ARG RESPECTIVELY.
*      B3.003  BRN-S USED INSTEAD OF PPM-S IN S$SUB.
*      B3.004  ERR USED INSTEAD OF ERB AFTER CMP30.
*      B3.005  B$PFC, S$CNV, S$DEF, ARITH AND ARREF KEPT
*              INFORMATION ILLEGALLY ABOVE THE STACK TOP.
*      B3.006  PRE-EVALUATION OF CONSTANT PARTS OF
*              COMPLEX GOTOS WAS ERRONEOUS.
*      B3.007  INCORRECT HANDLING OF LABELS COMPILED BY CODE().
*      B3.008  THE SINGLE USE OF TRC (IN S$RPL) WAS NOT IN
*              ACCORD WITH ITS DEFINITION. SOME TRANSLATIONS OF
*              TRC MAY NEED REVISION NOW THAT THE USE
*              HAS BEEN BROUGHT INTO LINE WITH DEFINITION.
*
*      CHANGES
*      -------
*
*      A DEBATE ON A FEW WEAKNESSES IN MINIMAL DESIGN HAS
*      BEEN RESOLVED BY INTRODUCING 4 NEW OPCODES.
*
*      C3.001  NEW MINIMAL OPCODES BMP AND DIM INTRODUCED
*              TO AUGMENT INC AND DEC WHICH ARE APPLICABLE
*              ONLY TO ADDRESSES.
*      C3.002  THE OPCODE SZC (STORE ZERO CHARACTERS) HAD
*              A RESTRICTED APPLICABILITY. IT HAS BEEN
*              REPLACED BY THE MORE GENERAL ZER (ZEROISE).
*      C3.003  FCBLKS MAY BE OPTIONALLY ALLOCATED AS XRBLK-S OR
*              XNBLK-S  - SEE SYSFC FOR VITAL INFORMATION.
*      C3.004  CONTROL CARD PROCESSING HAS BEEN RECODED.
*              -INXXX ALLOWS SPECIFICATION OF STANDARD INPUT
*              FILE RECORD LENGTHS OTHER THAN 72 OR 80, SEE ALSO
*              SYSRL. -SEQU IS IGNORED UNLESS -IN80 IS IN EFFECT
*      C3.005  TO ENABLE EFFICIENT BUFFERING OF CHARS ON
*              MACHINES WITHOUT CHAR. HANDLING ORDERS, THE
*              CSC (COMPLETE STORE CHARACTERS) INSTRUCTION
*              IS INTRODUCED. CURRENT IMPLEMENTATIONS CAN
*              TRANSLATE IT AS A NO-OP IF IT IS OF NO BENEFIT.
*      C3.006  INTEGERS 0,1,2 ARE TREATED SPECIALLY.
*              ICBLKS IN STATIC ARE USED INSTEAD OF
*              ALLOCATING SPACE IN DYNAMIC.
{{EJC{{{{{1134
*
*      VERSION 2.7 (JUNE 76) TO 3.0 (JAN 77)
*      -------------------------------------
*
*      BUGS FIXED
*      ----------
*
*      B2.701  GOES ILLEGAL IF TIMED OUT DURING PROCESSING OF
*              DUMP() CALL.
*      B2.702  GOES ILLEGAL IF SPITBOL ERROR DETECTED IN ARGS OF
*              CODE() OR EVAL(). BUG FIXED SO THAT USER NOW GETS
*              A SPITBOL ERROR REPORT (TRAPPABLE BY SETEXIT)
*              BEFORE STATEMENT FAILURE.
*      B2.703  GOES ILLEGAL IN SOME CIRCUMSTANCES WHEN
*              MULTIPLE COMPILATION ERRORS OCCUR IN A STATEMENT
*      B2.704  GOES ILLEGAL IF GARBAGE COLLECTOR RUNS OUT OF
*              STACK SPACE.
*      B2.705  CONTROL CARD PROCESSING INCORRECT FOR CDC 6400.
*      B2.706  INCORRECT HANDLING OF MULTIPLE OCCURRENCES OF
*              CHARS IN REPLACE 2ND AND 3RD ARGS.
*      B2.707  STACK OVERFLOW IN PRE-EVALUATION OF REPLACE IN
*              CDC 6400 VERSION.
*      B2.708  AN EXPLICIT CALL OF SYSMW WAS CODED IN S$DAT
*              INSTEAD OF THE MVW OPCODE.
*      B2.709  CALL OF GARBAGE COLLECTOR WHILST DUMPING
*              CAUSED HAVOC.
*      B2.710  SIZE RESTRICTION ON SPITBOL OBJECTS (SIZE MUST BE
*              NUMERICALLY LESS THAN LOWEST DYNAMIC ADDRESS)
*              WAS NOT ENFORCED, WITH POTENTIAL FOR CATASTROPHE.
*      B2.711  DEFERRED EXPRESSIONS INVOLVING ALTERNATION OR
*              NEGATION WERE INCORRECTLY TRANSLATED.
*      B2.712  LISTING OF A COMPILATION ERROR AT THE END OF A
*              LONG LINE COULD CAUSE COMPILER TO GO ILLEGAL.
*      B2.713  INCORRECT -NOFAIL CODE WITH SUCCESS GOTO.
{{EJC{{{{{1169
*
*
*      CHANGES
*      -------
*
*      (IT IS NOT ANTICIPATED THAT MAJOR REVISIONS ON THIS
*      SCALE WILL BE FREQUENT).
*
*      C2.701  DEFAULT VALUE OF ANCHOR KEYWORD IS SET TO 1. THIS
*              CONFLICTS WITH SNOBOL4 PRACTICE BUT IS A
*              PREFERABLE DEFAULT FOR MOST APPLICATIONS.
*      C2.702  IF ERRTYPE IS OUT OF RANGE THE STRING IN KEYWORD
*              ERRTEXT IS PRINTED AS THE ERROR MESSAGE.
*      C2.703  IF STLIMIT IS EXCEEDED, UP TO 10 MORE STATEMENTS
*              MAY BE OBEYED TO PERMIT SETEXIT TRAP TO GAIN
*              CONTROL.
*      C2.704  THE CONCEPT OF AN INTERACTIVE CHANNEL IS
*              INTRODUCED FOR IMPLEMENTATIONS WHERE AN ONLINE
*              TERMINAL MAY BE USED FOR SPITBOL. THE STANDARD
*              PRINT FILE MAY BE SPECIFIED AS INTERACTIVE IN
*              WHICH CASE SHORTER TITLE LINES ARE OUTPUT.
*              ALTERNATIVELY COPIES OF COMPILATION AND
*              EXECUTION ERRORS ONLY MAY BE SENT TO THIS CHANNEL
*      C2.705  PRINTING OF COMPILATION STATISTICS MAY BE
*              SUPPRESSED.
*      C2.706  PRINTING OF EXECUTION STATISTICS MAY BE
*              SUPPRESSED.
*      C2.707  EXTENDED OR COMPACT LISTING FORMAT MAY BE
*              SELECTED.
*      C2.708  AN INITIAL -NOLIST OPTION MAY BE SPECIFIED
*              BEFORE COMPILATION STARTS.
*      C2.709  TO SPECIFY CHOICES IMPLIED BY C2.704 TO C2.708
*              SYSPP INTERFACE IS REVISED AND SYSPI IS DEFINED.
*      C2.710  COMPILATION AND EXECUTION TIME STATISTICS
*              MESSAGES HAVE BEEN SHORTENED.
*      C2.711  THE EXIT FUNCTION AS IN SITBOL IS INTRODUCED
*              TO PERMIT SAVING LOAD MODULES - SEE SYSXI, S$EXT.
*      C2.712  DIAGNOSTIC ROUTINES SYSGB AND SYSGD HAVE BEEN
*              REMOVED. THEY WERE USEFUL IN THE EARLY DEBUGGING
*              DAYS BUT HAVE FALLEN INTO DISUSE NOW.
*      C2.713  SZC MAY HAVE AN OPERAND OF TYPE OPN INSTEAD OF
*              TYPE OPW
*      C2.714  INPUT/OUTPUT ASSOCIATION INTERFACE HAS BEEN
*              REVISED. SYSIF,SYSOF HAVE BEEN CONSOLIDATED INTO
*              THE NEW SYSTEM ROUTINE, SYSIO, AND THE
*              SPECIFICATION OF SYSFC HAS BEEN SLIGHTLY CHANGED.
*      C2.715  CONFIGURATION PARAMETER MXLEN HAS BEEN WITHDRAWN
*              AND THE MAXIMUM SIZE OF A SPITBOL OBJECT WHICH
*              WAS FORMERLY FIXED AT SPITBOL COMPILE TIME BY
*              REFERENCE TO IT MAY NOW BE SPECIFIED AS A RUN
*              TIME OPTION BY PLACING A VALUE IN WC BEFORE ENTRY
*              TO SPITBOL. (SEE COMMENT ON DYNAMIC AREA IN
*              BASIC INFORMATION SECTION).
*      C2.716  A FUNCTION, HOST, IS INTRODUCED WHICH YIELDS
*              INFORMATION ABOUT THE HOST MACHINE - SEE SYSHS
*              AND S$HST.
{{EJC{{{{{1226
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D2.701  THE DESCRIPTION OF MVC HAS BEEN REVISED TO
*              REFLECT THE FACT THAT SOME SPITBOL CODE SEQUENCES
*              RELY ON MVC NOT DESTROYING WB. MINOR CHANGES
*              HAVE BEEN MADE TO MWB AND MVW DESCRIPTIONS TO
*              EMPHASISE SIMILARITIES IN THE IMPLICIT LOOPS OF
*              THESE ORDERS.
*      D2.702  DESCRIPTIONS OF DVI AND RMI HAVE BEEN CLARIFIED.
*      D2.703  IMPLEMENTATION OF RSX,LSX,CEQ,CGE,CGT,CHI,CLO,CLT
*              IS OPTIONAL AT PRESENT SINCE THEY ARE CURRENTLY
*              UNUSED. THEIR USE IN LATER VERSIONS IS NOT
*              EXCLUDED.
*      D2.704  IMPOSSIBILITY OF USING STACK FOR RETURN LINKS OF
*              N TYPE PROCEDURES IS EMPHASISED.
*      D2.705  NOTATION (XL),(WC) ETC IN LANGUAGE DESCRIPTION IS
*              CLARIFIED.
*      D2.706  DOCUMENTATION OF SYSFC, SYSIO HAS BEEN IMPROVED.
*      D2.707  OPCODE DESCRIPTIONS ARE CROSS REFERENCED FROM
*              THE ALPHABETICAL OPCODE LIST.
*      D2.708  GENERAL DESCRIPTION OF COMPILER HAS BEEN MOVED TO
*              THE START OF THE COMPILER PROPER.
*      D2.709  DEFINITIONS OF ENVIRONMENT PARAMETERS HAVE BEEN
*              PUT NEAR THE FRONT OF THE DEFINITIONS SECTION.
{{TTL{27,MINIMAL -- MACHINE INDEPENDENT MACRO ASSEMBLY LANG.{{{{1253
{{EJC{{{{{1254
*
*      THE FOLLOWING SECTIONS DESCRIBE THE IMPLEMENTATION
*      LANGUAGE ORIGINALLY DEVELOPED FOR SPITBOL BUT NOW MORE
*      WIDELY USED. MINIMAL IS AN ASSEMBLY LANGUAGE
*      FOR AN IDEALIZED MACHINE. THE FOLLOWING DESCRIBES THE
*      BASIC CHARACTERISTICS OF THIS MACHINE.
*
*      SECTION 1 - CONFIGURATION PARAMETERS
*
*      THERE ARE SEVERAL PARAMETERS WHICH MAY VARY WITH THE
*      TARGET MACHINE. THE MACRO-PROGRAM IS INDEPENDENT OF THE
*      ACTUAL DEFINITIONS OF THESE PARAMETERS.
*
*      THE DEFINITIONS OF THESE PARAMETERS ARE SUPPLIED BY
*      THE TRANSLATION PROGRAM TO MATCH THE TARGET MACHINE.
*
*      CFP$A                 NUMBER OF DISTINCT CHARACTERS IN
*                            INTERNAL ALPHABET IN THE RANGE
*                            64 LE CFP$A LE MXLEN.
*
*      CFP$B                 NUMBER OF BYTES IN A WORD WHERE A
*                            BYTE IS THE AMOUNT OF STORAGE
*                            ADDRESSED BY THE LEAST SIGNIFICANT
*                            ADDRESS BIT.
*
*      CFP$C                 NUMBER OF CHARACTERS WHICH CAN
*                            BE STORED IN A SINGLE WORD.
*
*      CFP$F                 BYTE OFFSET FROM START OF A STRING
*                            BLOCK TO THE FIRST CHARACTER.
*                            DEPENDS BOTH ON TARGET MACHINE AND
*                            STRING DATA STRUCTURE. SEE PLC, PSC
*
*      CFP$I                 NUMBER OF WORDS IN A SIGNED
*                            INTEGER CONSTANT
*
*      CFP$L                 THE LARGEST UNSIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N BUT NEED NOT BE.
*
*      CFP$M                 THE LARGEST POSITIVE SIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N-1 BUT NEED NOT BE.
*
*      CFP$N                 NUMBER OF BITS WHICH CAN BE STORED
*                            IN A ONE WORD BIT STRING.
*
*      CFP$R                 NUMBER OF WORDS IN A REAL CONSTANT
*
*      CFP$S                 NUMBER OF SIGNIFICANT DIGITS TO
*                            BE OUTPUT IN CONVERSION OF A REAL
*                            QUANTITY.
*                            THE INTEGER CONSISTING OF
*                            THIS NUMBER OF 9S MUST NOT BE TOO
*                            LARGE TO FIT IN THE INTEGER ACCUM.
*
*      CFP$U                 REALISTIC UPPER BOUND ON ALPHABET.
*
*
*      CFP$X                 NUMBER OF DIGITS IN REAL EXPONENT
{{EJC{{{{{1322
*
*      SECTION 2 - MEMORY
*
*      MEMORY IS ORGANIZED INTO WORDS WHICH EACH CONTAIN CFP$B
*      BYTES. FOR WORD MACHINES CFP$B, WHICH IS A CONFIGURATION
*      PARAMETER, MAY BE ONE IN WHICH CASE WORDS AND BYTES ARE
*      IDENTICAL. TO EACH WORD CORRESPONDS AN ADDRESS WHICH IS
*      A NON-NEGATIVE QUANTITY WHICH IS A MULTIPLE OF CFP$B.
*      DATA IS ORGANIZED INTO WORDS AS FOLLOWS.
*
*      1)   A SIGNED INTEGER VALUE OCCUPIES CFP$I CONSECUTIVE
*           WORDS (CFP$I IS A CONFIGURATION PARAMETER).
*           THE RANGE MAY INCLUDE MORE NEGATIVE NUMBERS THAN
*           POSITIVE (E.G. THE TWOS COMPLEMENT REPRESENTATION).
*
*      2)   A SIGNED REAL VALUE OCCUPIES CFP$R CONSECUTIVE
*           WORDS. (CFP$R IS A CONFIGURATION PARAMETER).
*
*      3)   CFP$C CHARACTERS MAY BE STORED IN A SINGLE WORD
*           (CFP$C IS A CONFIGURATION PARAMETER).
*
*      4)   A BIT STRING CONTAINING CFP$N BITS CAN BE STORED IN
*           A SINGLE WORD (CFP$N IS A CONFIGURATION PARAMETER).
*
*      5)   A WORD CAN CONTAIN A UNSIGNED INTEGER VALUE IN
*           THE RANGE (0 LE N LE CFP$L). THESE INTEGER VALUES
*           MAY REPRESENT ADDRESSES OF OTHER WORDS AND SOME OF
*           THE INSTRUCTIONS USE THIS FACT TO PROVIDE INDEXING
*           AND INDIRECTION FACILITIES.
*
*      6)   PROGRAM INSTRUCTIONS OCCUPY WORDS IN AN UNDEFINED
*           MANNER. DEPENDING ON THE ACTUAL IMPLEMENTATION,
*           INSTRUCTIONS MAY OCCUPY SEVERAL WORDS, OR PART OF
*           A WORD, OR EVEN BE SPLIT OVER WORD BOUNDARIES.
*
*      THE FOLLOWING REGIONS OF MEMORY ARE AVAILABLE TO THE
*      PROGRAM. EACH REGION CONSISTS OF A SERIES OF WORDS WITH
*      CONSECUTIVE ADDRESSES.
*
*      1)   CONSTANT SECTION           ASSEMBLED CONSTANTS
*      2)   WORKING STORAGE SECTION    ASSEMBLED WORK AREAS
*      3)   PROGRAM SECTION            ASSEMBLED INSTRUCTIONS
*      4)   STACK AREA                 ALLOCATED STACK AREA
*      5)   DATA AREA                  ALLOCATED DATA AREA
{{EJC{{{{{1367
*
*      SECTION 3 - REGISTERS
*
*      THERE ARE THREE INDEX REGISTERS CALLED XR,XL,XS. IN
*      ADDITION XL MAY SOMETIMES BE REFERRED TO BY THE ALIAS
*      OF XT - SEE SECTION 4. ANY OF THE ABOVE REGISTERS
*      MAY HOLD A POSITIVE UNSIGNED INTEGER IN THE RANGE
*      (0 LE N LE CFP$L). WHEN THE INDEX REGISTER IS USED FOR
*      INDEXING PURPOSES, THIS MUST BE AN APPROPRIATE ADDRESS.
*      XS IS SPECIAL IN THAT IT IS USED TO POINT TO THE TOP
*      ITEM OF A STACK IN MEMORY. THE STACK MAY BUILD UP OR
*      DOWN IN MEMORY.SINCE IT IS REQUIRED THAT XS POINTS TO THE
*      STACK TOP BUT ACCESS TO ITEMS BELOW THE TOP IS PERMITTED,
*      REGISTERS XS AND XT MAY BE USED WITH SUITABLE OFFSETS
*      TO INDEX STACKED ITEMS. ONLY XS AND XT MAY BE USED FOR
*      THIS PURPOSE SINCE THE DIRECTION OF THE OFFSET IS
*      TARGET MACHINE DEPENDENT. XT IS A SYNONYM FOR XL
*      WHICH THEREFORE CANNOT BE USED IN CODE SEQUENCES
*      REFERENCING XT.
*
*      THE STACK IS USED FOR S-R LINKAGE AND TEMPORARY
*      DATA STORAGE FOR WHICH THE STACK ARRANGEMENT IS SUITABLE.
*      XR,XL CAN ALSO CONTAIN A CHARACTER POINTER IN CONJUNCTION
*      WITH THE CHARACTER INSTRUCTIONS (SEE DESCRIPTION OF PLC).
{{EJC{{{{{1392
*
*      THERE ARE THREE WORK REGISTERS CALLED WA,WB,WC WHICH
*      CAN CONTAIN ANY DATA ITEM WHICH CAN BE STORED IN A
*      SINGLE MEMORY WORD. IN FACT, THE WORK REGISTERS ARE JUST
*      LIKE MEMORY LOCATIONS EXCEPT THAT THEY HAVE NO ADDRESSES
*      AND ARE REFERENCED IN A SPECIAL WAY BY THE INSTRUCTIONS.
*
*      NOTE THAT REGISTERS WA,WB HAVE SPECIAL USES IN CONNECTION
*      WITH THE CVD, CVM, MVC, MVW, MWB, CMC, TRC INSTRUCTIONS.
*
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE FOLLOWING RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*          RESTRICTION
*          -----------
*
*      IF IA AND WC OVERLAP THEN
*          STI  IASAV
*          LDI  IASAV
*      DOES NOT CHANGE WC, AND
*          MOV  WC,WCSAV
*          MOV  WCSAV,WC
*      DOES NOT CHANGE IA.
*
*
*
*      THERE IS AN INTEGER ACCUMULATOR (IA) WHICH IS CAPABLE OF
*      HOLDING A SIGNED INTEGER VALUE (CFP$I WORDS LONG).
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE ABOVE RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*
*
*      THERE IS A SINGLE REAL ACCUMULATOR (RA) WHICH CAN HOLD
*      ANY REAL VALUE AND IS COMPLETELY SEPARATE FROM ANY OF
*      THE OTHER REGISTERS OR PROGRAM ACCESSIBLE LOCATIONS.
*
*
*
*      THE CODE POINTER REGISTER (CP) IS A SPECIAL INDEX
*      REGISTER FOR USE IN IMPLEMENTATIONS OF INTERPRETORS.
*      IT IS USED TO CONTAIN A PSEUDO-CODE POINTER AND CAN
*      ONLY BE AFFECTED BY ICP, LCP, SCP AND LCW INSTRUCTIONS.
{{EJC{{{{{1442
*      SECTION 4 - THE STACK
*
*      THE FOLLOWING NOTES ARE TO GUIDE BOTH IMPLEMENTORS OF
*      SYSTEMS WRITTEN IN MINIMAL AND MINIMAL PROGRAMMERS IN
*      DEALING WITH STACK MANIPULATION. IMPLEMENTATION OF A
*      DOWNWARDS BUILDING STACK IS EASIEST AND IN GENERAL IS
*      TO BE PREFERRED, IN WHICH CASE IT IS MERELY NECESSARY TO
*      CONSIDER XT AS AN ALTERNATIVE NAME FOR XL.
*
*      THE MINIMAL VIRTUAL MACHINE INCLUDES A STACK AND HAS
*      OPERAND FORMATS -(XS) AND (XS)+ FOR PUSHING AND POPPING
*      ITEMS WITH AN IMPLICATION THAT THE STACK BUILDS DOWN IN
*      MEMORY (A D-STACK). HOWEVER ON SOME TARGET MACHINES IT IS
*      BETTER FOR THE STACK TO BUILD UP (A U-STACK).
*      A STACK ADDRESSED ONLY BY PUSH AND POP OPERATIONS CAN
*      BUILD IN EITHER DIRECTION WITH NO COMPLICATION BUT
*      SUCH A PURE SCHEME OF STACK ACCESS PROVES RESTRICTIVE.
*      HENCE IT IS PERMITTED TO ACCESS BURIED ITEMS USING AN
*      INTEGER OFFSET PAST THE INDEX REGISTER POINTING TO THE
*      STACK TOP. ON TARGET MACHINES THIS OFFSET WILL BE
*      POSITIVE/NEGATIVE FOR D-STACKS/U-STACKS AND THIS MUST
*      BE ALLOWED FOR IN THE TRANSLATION.
*      A FURTHER RESTRICTION IS THAT AT NO TIME MAY AN ITEM BE
*      PLACED ABOVE THE STACK TOP. FOR SOME OPERATIONS THIS
*      MAKES IT CONVENIENT TO ADVANCE THE STACK POINTER AND THEN
*      ADDRESS ITEMS BELOW IT USING A SECOND INDEX REGISTER.
*      THE PROBLEM OF SIGNED OFFSETS PAST SUCH A REGISTER THEN
*      ARISES. TO DISTINGUISH STACK OFFSETS, WHICH IN SOME
*      IMPLEMENTATIONS MAY BE NEGATIVE, FROM NON-STACK OFFSETS
*      WHICH ARE INVARIABLY POSITIVE, XT, AN ALIAS OR
*      SYNONYM FOR XL IS USED. FOR A U-STACK IMPLEMENTATION, THE
*      MINIMAL TRANSLATOR SHOULD NEGATE THE SIGN OF OFFSETS
*      APPLIED TO BOTH (XS) AND (XT).
*      PROGRAMMERS SHOULD NOTE THAT SINCE XT IS NOT A
*      SEPARATE REGISTER, XL SHOULD NOT BE USED IN CODE WHERE
*      XT IS REFERENCED. OTHER MODIFICATIONS NEEDED IN U-STACK
*      TRANSLATIONS ARE IN THE ADD, SUB, ICA, DCA OPCODES
*      APPLIED TO XS, XT. FOR EXAMPLE
*
*      MINIMAL           D-STACK TRANS.  U-STACK TRANS.
*
*      MOV  WA,-(XS)     SBI  XS,1       ADI  XS,1
*                        STO  WA,(XS)    STO  WA,(XS)
*      MOV  (XT)+,WC     LOD  WC,(XL)    LOD  WC,(XL)
*                        ADI  XL,1       SBI  XL,1
*      ADD  =SEVEN,XS    ADI  XS,7       SBI  XS,7
*      MOV  2(XT),WA     LOD  WA,2(XL)   LOD  WA,-2(XL)
*      ICA  XS           ADI  XS,1       SBI  XS,1
*
*      NOTE THAT FORMS SUCH AS
*      MOV  -(XS),WA
*      ADD  WA,(XS)+
*      ARE ILLEGAL, SINCE THEY ASSUME INFORMATION STORAGE
*      ABOVE THE STACK TOP.
{{EJC{{{{{1497
*      SECTION 5 - INTERNAL CHARACTER SET
*
*      THE INTERNAL CHARACTER SET IS REPRESENTED BY A SET OF
*      CONTIGUOUS CODES FROM 0 TO CFP$A-1. THE CODES FOR THE
*      DIGITS 0-9 MUST BE CONTIGUOUS AND IN SEQUENCE. OTHER
*      THAN THIS, THERE ARE NO RESTRAINTS.
*
*      THE FOLLOWING SYMBOLS ARE AUTOMATICALLY DEFINED TO HAVE
*      THE VALUE OF THE CORRESPONDING INTERNAL CHARACTER CODE.
*
*      CH$LA                 LETTER A
*      CH$LB                 LETTER B
*      .                     .
*      CH$L$                 LETTER Z
*
*      CH$D0                 DIGIT 0
*      .                     .
*      CH$D9                 DIGIT 9
*
*      CH$AM                 AMPERSAND
*      CH$AS                 ASTERISK
*      CH$AT                 AT
*      CH$BB                 LEFT BRACKET
*      CH$BL                 BLANK
*      CH$BR                 VERTICAL BAR
*      CH$CL                 COLON
*      CH$CM                 COMMA
*      CH$DL                 DOLLAR SIGN
*      CH$DT                 DOT (PERIOD)
*      CH$DQ                 DOUBLE QUOTE
*      CH$EQ                 EQUAL SIGN
*      CH$EX                 EXCLAMATION MARK
*      CH$MN                 MINUS
*      CH$NM                 NUMBER SIGN
*      CH$NT                 NOT
*      CH$PC                 PERCENT
*      CH$PL                 PLUS
*      CH$PP                 LEFT PAREN
*      CH$RB                 RIGHT BRACKET
*      CH$RP                 RIGHT PAREN
*      CH$QU                 QUESTION MARK
*      CH$SL                 SLASH
*      CH$SM                 SEMI-COLON
*      CH$SQ                 SINGLE QUOTE
*      CH$UN                 UNDERLINE
*
*      THE FOLLOWING OPTIONAL SYMBOLS ARE INCORPORATED
*      BY DEFINING THE CONDITIONAL ASSEMBLY SYMBOL NAMED.
*
*      26 SHIFTED LETTERS INCORPORATED BY DEFINING .CASL
*
*      CH$$A                 SHIFTED A
*      CH$$B                 SHIFTED B
*      .                     .
*      CH$$$                 SHIFTED Z
*
*      CH$HT                 HORIZONTAL TAB - DEFINE .CAHT
*      CH$VT                 VERTICAL TAB   - DEFINE .CAVT
*      CH$EY                 UP ARROW       - DEFINE .CAEX
{{EJC{{{{{1557
*
*      SECTION 6 - CONDITIONAL ASSEMBLY FEATURES
*
*      SOME FEATURES OF THE INTERPRETER ARE APPLICABLE TO ONLY
*      CERTAIN TARGET MACHINES. THEY MAY BE INCORPORATED OR
*      OMITTED BY USE OF CONDITIONAL ASSEMBLY. THE FULL
*      FORM OF A CONDITION IS -
*      .IF    CONDITIONAL ASSEMBLY SYMBOL    (CAS)
*      .THEN
*             MINIMAL STATEMENTS1   (MS1)
*      .ELSE
*             MINIMAL STATEMENTS2   (MS2)
*      .FI
*      THE FOLLOWING RULES APPLY
*      1.   THE DIRECTIVES .IF, .THEN, .ELSE, .FI MUST
*           START IN COLUMN 1.
*      2.   THE CONDITIONAL ASSEMBLY SYMBOL MUST START WITH A
*           DOT IN COLUMN 8 FOLLOWED BY 4 LETTERS OR DIGITS E.G.
*              .CA$1
*      3.   .THEN IS REDUNDANT AND MAY BE OMITTED IF WISHED.
*      4.   MS1, MS2 ARE ARBITRARY SEQUENCES OF MINIMAL
*           STATEMENTS EITHER OF WHICH MAY BE NULL OR MAY
*           CONTAIN FURTHER CONDITIONS.
*      5.   IF MS2 IS OMITTED, .ELSE MAY ALSO BE OMITTED.
*      6.   .FI IS REQUIRED.
*      7.   CONDITIONS MAY BE NESTED TO A DEPTH DETERMINED
*           BY THE TRANSLATOR (NOT LESS THAN 20, SAY).
*
*      SELECTION OF THE ALTERNATIVES MS1, MS2 IS BY MEANS OF THE
*      DEFINE AND UNDEFINE DIRECTIVES OF FORM -
*      .DEF   CAS
*      .UNDEF CAS
*      WHICH OBEY RULES 1. AND 2. ABOVE AND MAY OCCUR AT ANY
*      POINT IN A MINIMAL PROGRAM, INCLUDING WITHIN A CONDITION.
*      MULTIPLY DEFINING A SYMBOL IS AN ERROR.
*      UNDEFINING A SYMBOL WHICH IS NOT DEFINED IS NOT AN ERROR.
*
*      THE EFFECT IS THAT IF A SYMBOL IS CURRENTLY DEFINED,
*      THEN IN ANY CONDITION DEPENDING ON IT, MS1 WILL BE
*      PROCESSED AND MS2 OMITTED. CONVERSELY IF IT IS UNDEFINED,
*      MS1 WILL BE OMITTED AND MS2 PROCESSED.
*
*      NESTING OF CONDITIONS IS SUCH THAT CONDITIONS
*      IN A SECTION NOT SELECTED FOR PROCESSING MUST NOT BE
*      EVALUATED. NESTED CONDITIONS MUST REMEMBER THEIR
*      ENVIRONMENT WHILST BEING PROCESSED. EFFECTIVELY THIS
*      IMPLIES USE OF A SCHEME BASED ON A STACK WITH .IF, .FI
*      MATCHING BY THE CONDITION PROCESSOR OF THE TRANSLATOR.
{{EJC{{{{{1606
*
*      SECTION 7 - OPERAND FORMATS
*
*      THE FOLLOWING SECTION DESCRIBES THE VARIOUS POSSIBILITIES
*      FOR OPERANDS OF INSTRUCTIONS AND ASSEMBLY OPERATIONS.
*
*      01   INT              UNSIGNED INTEGER LE CFP$L
*      02   DLBL             SYMBOL DEFINED IN DEFINITIONS SEC
*      03   WLBL             LABEL IN WORKING STORAGE SECTION
*      04   CLBL             LABEL IN CONSTANT SECTION
*      05   ELBL             PROGRAM SECTION ENTRY LABEL
*      06   PLBL             PROGRAM SECTION LABEL (NON-ENTRY)
*      07   X                ONE OF THE THREE INDEX REGISTERS
*      08   W                ONE OF THE THREE WORK REGISTERS
*      09   (X)              LOCATION INDEXED BY X
*      10   (X)+             LIKE (X) BUT POST INCREMENT X
*      11   -(X)             LIKE (X) BUT PREDECREMENT X
*      12   INT(X)           LOCATION INT WORDS BEYOND ADDR IN X
*      13   DLBL(X)          LOCATION DLBL WORDS PAST ADDR IN X
*      14   CLBL(X)          LOCATION (X) BYTES BEYOND CLBL
*      15   WLBL(X)          LOCATION (X) BYTES BEYOND WLBL
*      16   INTEGER          SIGNED INTEGER (DIC)
*      17   REAL             SIGNED REAL (DRC)
*      18   =DLBL            LOCATION CONTAINING DAC DLBL
*      19   *DLBL            LOCATION CONTAINING DAC CFP$B*DLBL
*      20   =WLBL            LOCATION CONTAINING DAC WLBL
*      21   =CLBL            LOCATION CONTAINING DAC CLBL
*      22   =ELBL            LOCATION CONTAINING DAC ELBL
*      23   PNAM             PROCEDURE LABEL (ON PRC INSTRUC)
*      24   EQOP             OPERAND FOR EQU INSTRUCTION
*      25   PTYP             PROCEDURE TYPE (SEE PRC)
*      26   TEXT             ARBITRARY TEXT (ERB,ERR,TTL)
*      27   DTEXT            DELIMITED TEXT STRING (DTC)
*
*      THE NUMBERS IN THE ABOVE LIST ARE USED IN SUBSEQUENT
*      DESCRIPTION AND IN SOME OF THE MINIMAL TRANSLATORS.
{{EJC{{{{{1643
*
*      OPERAND FORMATS (CONTINUED)
*
*      THE FOLLOWING SPECIAL SYMBOLS REFER TO A COLLECTION OF
*      THE LISTED POSSIBILITIES
*
*      VAL  01,02                      PREDEFINED VALUE
*
*           VAL IS USED TO REFER TO A PREDEFINED ONE WORD
*           INTEGER VALUE IN THE RANGE 0 LE N LE CFP$L.
*
*      REG  07,08                      REGISTER
*
*           REG IS USED TO DESCRIBE AN OPERAND WHICH CAN BE
*           ANY OF THE REGISTERS (XL,XR,XS,XT,WA,WB,WC). SUCH
*           AN OPERAND CAN HOLD A ONE WORD INTEGER (ADDRESS).
*
*      OPC  09,10,11                   CHARACTER
*
*           OPC IS USED TO DESIGNATE A SPECIFIC CHARACTER
*           OPERAND FOR USE IN THE LCH AND SCH INSTRUCTIONS.
*           THE INDEX REGISTER REFERENCED MUST BE EITHER XR OR
*           XL (NOT XS,XT). SEE SECTION ON CHARACTER OPERATIONS.
*
*      OPS  03,04,09,12,13,14,15       MEMORY REFERENCE
*
*           OPS IS USED TO DESCRIBE AN OPERAND WHICH IS IN
*           MEMORY. THE OPERAND MAY BE ONE OR MORE WORDS LONG
*           DEPENDING ON THE DATA TYPE. IN THE CASE OF MULTIWORD
*           OPERANDS, THE ADDRESS GIVEN IS THE FIRST WORD.
*
*      OPW  AS FOR OPS + 08,10,11      FULL WORD
*
*           OPW IS USED TO REFER TO AN OPERAND WHOSE CAPACITY IS
*           THAT OF A FULL MEMORY WORD. OPW INCLUDES ALL THE
*           POSSIBILITIES FOR OPS (THE REFERENCED WORD IS USED)
*           PLUS THE USE OF ONE OF THE THREE WORK REGISTERS
*           (WA,WB,WC). IN ADDITION, THE FORMATS (X)+ AND -(X)
*           ALLOW INDEXED OPERATIONS IN WHICH THE INDEX REGISTER
*           IS POPPED BY ONE WORD AFTER THE REFERENCE (X)+,
*           OR PUSHED BY ONE WORD BEFORE THE REFERENCE -(X)
*           THESE LATTER TWO FORMATS PROVIDE A FACILITY FOR
*           MANIPULATION OF STACKS. THE FORMAT DOES NOT IMPLY
*           A PARTICULAR DIRECTION IN WHICH STACKS MUST BUILD -
*           IT IS USED FOR COMPACTNESS. NOTE THAT THERE IS A
*           RESTRICTION WHICH DISALLOWS AN INSTRUCTION TO USE
*           AN INDEX REGISTER IN ONE OF THESE FORMATS
*           IN SOME OTHER MANNER IN THE SAME INSTRUCTION.
*           E.G.   MOV  XL,(XL)+   IS ILLEGAL.
*           THE FORMATS -(X) AND (X)+ MAY ALSO BE USED IN
*           PRE-DECREMENTATION, POST-INCREMENTATION TO ACCESS
*           THE ADJACENT CHARACTER OF A STRING.
{{EJC{{{{{1696
*
*      OPERAND FORMATS (CONTINUED)
*
*      OPN  AS FOR OPW + 07            ONE WORD INTEGER
*
*           OPN IS USED TO REPRESENT AN OPERAND LOCATION WHICH
*           CAN CONTAIN A ONE WORD INTEGER (E.G. AN ADDRESS).
*           THIS INCLUDES ALL THE POSSIBILITIES FOR OPW PLUS
*           THE USE OF ONE OF THE INDEX REGISTERS (XL,XR,XT,
*           XS). THE RANGE OF INTEGER VALUES IS 0 LE N LE CFP$L.
*
*      OPV  AS FOR OPN + 18-22         ONE WORD INTEGER VALUE
*
*           OPV IS USED FOR AN OPERAND WHICH CAN YIELD A ONE
*           WORD INTEGER VALUE (E.G. AN ADDRESS). IT INCLUDES
*           ALL THE POSSIBILITIES FOR OPN (THE CURRENT VALUE OF
*           THE LOCATION IS USED) PLUS THE USE OF LITERALS. NOTE
*           THAT ALTHOUGH THE LITERAL FORMATS ARE DESCRIBED IN
*           TERMS OF A REFERENCE TO A LOCATION CONTAINING AN
*           ADDRESS CONSTANT, THIS LOCATION MAY NOT ACTUALLY
*           EXIST IN SOME IMPLEMENTATIONS SINCE ONLY THE VALUE
*           IS REQUIRED. A RESTRICTION IS PLACED ON LITERALS
*           WHICH MAY CONSIST ONLY OF DEFINED SYMBOLS AND
*           CERTAIN LABELS. CONSEQUENTLY SMALL INTEGERS TO BE
*           USED AS LITERALS MUST BE PRE-DEFINED, A DISCIPLINE
*           AIDING PROGRAM MAINTENANCE AND REVISION.
*
*      ADDR 01,02,03,04,05             ADDRESS
*
*           ADDR IS USED TO DESCRIBE AN EXPLICIT ADDRESS VALUE
*           (ONE WORD INTEGER VALUE) FOR USE WITH DAC.
*
*
*           ****************************************************
*           *   IN THE FOLLOWING DESCRIPTIONS THE USAGE --     *
*           *      (XL),(XR), ... ,(IA)                        *
*           *   IN THE DESCRIPTIVE TEXT SIGNIFIES THE          +
*           *   CONTENTS OF THE STATED REGISTER.               *
*           ****************************************************
{{EJC{{{{{1736
*
*      SECTION 8 - LIST OF INSTRUCTION MNEMONICS
*
*      THE FOLLOWING LIST INCLUDES ALL INSTRUCTION AND
*      ASSEMBLY OPERATION MNEMONICS IN ALPHABETICAL ORDER.
*      THE MNEMONICS ARE PRECEDED BY A NUMBER IDENTIFYING
*      THE FOLLOWING SECTION WHERE THE INSTRUCTION IS DESCRIBED.
*      A STAR (*) IS APPENDED TO THE MNEMONIC IF THE LAST
*      OPERAND MAY OPTIONALLY BE OMITTED.
*      SEE SECTION -15- FOR DETAILS OF STATEMENT FORMAT AND
*      COMMENT CONVENTIONS.
*
*       2.1  ADD  OPV,OPN      ADD ADDRESS
*       4.2  ADI  OPS          ADD INTEGER
*       5.3  ADR  OPS          ADD REAL
*       7.1  ANB  OPW,W        AND BIT STRING
*       2.17 AOV  OPV,OPN,PLBL ADD ADDRESS, FAIL IF OVERFLOW
*       5.16 ATN               ARCTANGENT OF REAL ACCUM
*       2.16 BCT  W,PLBL       BRANCH AND COUNT
*       2.5  BEQ  OPN,OPV,PLBL BRANCH IF ADDRESS EQUAL
*       2.18 BEV  OPN,PLBL     BRANCH IF ADDRESS EVEN
*       2.8  BGE  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER OR EQUL
*       2.7  BGT  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER
*       2.12 BHI  OPN,OPV,PLBL BRANCH IF ADDRESS HIGH
*       2.10 BLE  OPN,OPV,PLBL BRANCH IF ADDRESS LESS OR EQUAL
*       2.11 BLO  OPN,OPV,PLBL BRANCH IF ADDRESS LOW
*       2.9  BLT  OPN,OPV,PLBL BRANCH IF ADDRESS LESS THAN
*       2.6  BNE  OPN,OPV,PLBL BRANCH IF ADDRESS NOT EQUAL
*       2.13 BNZ  OPN,PLBL     BRANCH IF ADDRESS NON-ZERO
*       2.19 BOD  OPN,PLBL     BRANCH IF ADDRESS ODD
*       1.2  BRN  PLBL         BRANCH UNCONDITIONAL
*       1.7  BRI  OPN          BRANCH INDIRECT
*       1.3  BSW* X,VAL,PLBL   BRANCH ON SWITCH VALUE
*       8.2  BTW  REG          CONVERT BYTES TO WORDS
*       2.14 BZE  OPN,PLBL     BRANCH IF ADDRESS ZERO
*       6.6  CEQ  OPW,OPW,PLBL BRANCH IF CHARACTERS EQUAL
*      10.1  CHK               CHECK STACK OVERFLOW
*       5.17 CHP               INTEGER PORTION OF REAL ACCUM
*       7.4  CMB  W            COMPLEMENT BIT STRING
*       6.8  CMC  PLBL,PLBL    COMPARE CHARACTER STRINGS
*       6.7  CNE  OPW,OPW,PLBL BRANCH IF CHARACTERS NOT EQUAL
*       6.5  CSC  X            COMPLETE STORE CHARACTERS
*       5.18 COS               COSINE OF REAL ACCUM
*       8.8  CTB  W,VAL        CONVERT CHARACTER COUNT TO BYTES
*       8.7  CTW  W,VAL        CONVERT CHARACTER COUNT TO WORDS
*       8.10 CVD               CONVERT BY DIVISION
*       8.9  CVM  PLBL         CONVERT BY MULTIPLICATION
*      11.1  DAC  ADDR         DEFINE ADDRESS CONSTANT
*      11.5  DBC  VAL          DEFINE BIT STRING CONSTANT
*       2.4  DCA  OPN          DECREMENT ADDRESS BY ONE WORD
*       1.17 DCV  OPN          DECREMENT VALUE BY ONE
*      11.2  DIC  INTEGER      DEFINE INTEGER CONSTANT
{{EJC{{{{{1789
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*      11.3  DRC  REAL         DEFINE REAL CONSTANT
*      11.4  DTC  DTEXT        DEFINE TEXT (CHARACTER) CONSTANT
*       4.5  DVI  OPS          DIVIDE INTEGER
*       5.6  DVR  OPS          DIVIDE REAL
*      13.1  EJC               EJECT ASSEMBLY LISTING
*      14.2  END               END OF ASSEMBLY
*       1.13 ENP               DEFINE END OF PROCEDURE
*       1.6  ENT* VAL          DEFINE ENTRY POINT
*      12.1  EQU  EQOP         DEFINE SYMBOLIC VALUE
*       1.15 ERB  INT,TEXT     ASSEMBLE ERROR CODE AND BRANCH
*       1.14 ERR  INT,TEXT     ASSEMBLE ERROR CODE
*       1.5  ESW               END OF SWITCH LIST FOR BSW
*       5.19 ETX               E TO THE POWER IN THE REAL ACCUM
*       1.12 EXI* INT          EXIT FROM PROCEDURE
*      12.2  EXP               DEFINE EXTERNAL PROCEDURE
*       6.10 FLC  W            FOLD CHARACTER TO UPPER CASE
*       2.3  ICA  OPN          INCREMENT ADDRESS BY ONE WORD
*       3.4  ICP               INCREMENT CODE POINTER
*       1.16 ICV  OPN          INCREMENT VALUE BY ONE
*       4.11 IEQ  PLBL         JUMP IF INTEGER ZERO
*       1.4  IFF  VAL,PLBL     SPECIFY BRANCH FOR BSW
*       4.12 IGE  PLBL         JUMP IF INTEGER NON-NEGATIVE
*       4.13 IGT  PLBL         JUMP IF INTEGER POSITIVE
*       4.14 ILE  PLBL         JUMP IF INTEGER NEGATIVE OR ZERO
*       4.15 ILT  PLBL         JUMP IF INTEGER NEGATIVE
*       4.16 INE  PLBL         JUMP IF INTEGER NON-ZERO
*       4.9  INO  PLBL         JUMP IF NO INTEGER OVERFLOW
*      12.3  INP  PTYP,INT     INTERNAL PROCEDURE
*      12.4  INR               INTERNAL ROUTINE
*       4.10 IOV  PLBL         JUMP IF INTEGER OVERFLOW
*       8.5  ITR               CONVERT INTEGER TO REAL
*       1.9  JSR  PNAM         CALL PROCEDURE
*       6.3  LCH  REG,OPC      LOAD CHARACTER
*       2.15 LCT  W,OPV        LOAD COUNTER FOR LOOP
*       3.1  LCP  REG          LOAD CODE POINTER REGISTER
*       3.3  LCW  REG          LOAD NEXT CODE WORD
*       4.1  LDI  OPS          LOAD INTEGER
*       5.1  LDR  OPS          LOAD REAL
*       1.8  LEI  X            LOAD ENTRY POINT ID
*       5.20 LNF               NATURAL LOGORITHM OF REAL ACCUM
*       7.6  LSH  W,VAL        LEFT SHIFT BIT STRING
*       7.8  LSX  W,(X)        LEFT SHIFT INDEXED
*       9.4  MCB               MOVE CHARACTERSWORDS BACKWARDS
*       8.4  MFI* OPN,PLBL     CONVERT (IA) TO ADDRESS VALUE
*       4.3  MLI  OPS          MULTIPLY INTEGER
*       5.5  MLR  OPS          MULTIPLY REAL
*       1.19 MNZ  OPN          MOVE NON-ZERO
*       1.1  MOV  OPV,OPN      MOVE
*       8.3  MTI  OPN          MOVE ADDRESS VALUE TO (IA)
*       9.1  MVC               MOVE CHARACTERS
*       9.2  MVW               MOVE WORDS
*       9.3  MWB               MOVE WORDS BACKWARDS
*       4.8  NGI               NEGATE INTEGER
{{EJC{{{{{1846
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*       5.9  NGR               NEGATE REAL
*       7.9  NZB  W,PLBL       JUMP IF NOT ALL ZERO BITS
*       7.2  ORB  OPW,W        OR BIT STRINGS
*       6.1  PLC* X,OPV        PREPARE TO LOAD CHARACTERS
*       1.10 PPM* PLBL         PROVIDE PROCEDURE EXIT PARAMETER
*       1.11 PRC  PTYP,VAL     DEFINE START OF PROCEDURE
*       6.2  PSC* X,OPV        PREPARE TO STORE CHARACTERS
*       5.10 REQ  PLBL         JUMP IF REAL ZERO
*       5.11 RGE  PLBL         JUMP IF REAL POSITIVE OR ZERO
*       5.12 RGT  PLBL         JUMP IF REAL POSITIVE
*       5.13 RLE  PLBL         JUMP IF REAL NEGATIVE OR ZERO
*       5.14 RLT  PLBL         JUMP IF REAL NEGATIVE
*       4.6  RMI  OPS          REMAINDER INTEGER
*       5.15 RNE  PLBL         JUMP IF REAL NON-ZERO
*       5.8  RNO  PLBL         JUMP IF NO REAL OVERFLOW
*       5.7  ROV  PLBL         JUMP IF REAL OVERFLOW
*       7.5  RSH  W,VAL        RIGHT SHIFT BIT STRING
*       7.7  RSX  W,(X)        RIGHT SHIFT INDEXED
*       8.6  RTI* PLBL         CONVERT REAL TO INTEGER
*       1.22 RTN               DEFINE START OF ROUTINE
*       4.4  SBI  OPS          SUBTRACT INTEGER
*       5.4  SBR  OPS          SUBTRACT REALS
*       6.4  SCH  REG,OPC      STORE CHARACTER
*       3.2  SCP  REG          STORE CODE POINTER
*      14.1  SEC               DEFINE START OF ASSEMBLY SECTION
*       5.21 SIN               SINE OF REAL ACCUM
*       5.22 SQR               SQUARE ROOT OF REAL ACCUM
*       1.20 SSL  OPW          SUBROUTINE STACK LOAD
*       1.21 SSS  OPW          SUBROUTINE STACK STORE
*       4.7  STI  OPS          STORE INTEGER
*       5.2  STR  OPS          STORE REAL
*       2.2  SUB  OPV,OPN      SUBTRACT ADDRESS
*       5.23 TAN               TANGENT OF REAL ACCUM
*       6.9  TRC               TRANSLATE CHARACTER STRING
*      13.2  TTL  TEXT         SUPPLY ASSEMBLY TITLE
*       8.1  WTB  REG          CONVERT WORDS TO BYTES
*       7.3  XOB  OPW,W        EXCLUSIVE OR BIT STRINGS
*       1.18 ZER  OPN          ZEROISE INTEGER LOCATION
*       7.11 ZGB  OPN          ZEROISE GARBAGE BITS
*       7.10 ZRB  W,PLBL       JUMP IF ALL ZERO BITS
{{EJC{{{{{1890
*
*      SECTION 9 - MINIMAL INSTRUCTIONS
*
*      THE FOLLOWING DESCRIPTIONS ASSUME THE DEFINITIONS -
*
*      ZEROE  EQU  0
*      UNITY  EQU  1
*
*      -1-  BASIC INSTRUCTION SET
*
*      1.1  MOV  OPV,OPN     MOVE ONE WORD VALUE
*
*           MOV CAUSES THE VALUE OF OPERAND OPV TO BE SET AS
*           THE NEW CONTENTS OF OPERAND LOCATION OPN. IN THE
*           CASE WHERE OPN IS NOT AN INDEX REGISTER, ANY VALUE
*           WHICH CAN NORMALLY OCCUPY A MEMORY WORD (INCLUDING
*           A PART OF A MULTIWORD REAL OR INTEGER VALUE)
*           CAN BE TRANSFERRED USING MOV. IF THE TARGET LOCATION
*           OPN IS AN INDEX REGISTER, THEN OPV MUST SPECIFY AN
*           APPROPRIATE ONE WORD VALUE OR OPERAND CONTAINING
*           SUCH AN APPROPRIATE VALUE.
*
*      1.2  BRN  PLBL        UNCONDITIONAL BRANCH
*
*           BRN CAUSES CONTROL TO BE PASSED TO THE INDICATED
*           LABEL IN THE PROGRAM SECTION.
*
*      1.3  BSW  X,VAL,PLBL  BRANCH ON SWITCH VALUE
*      1.4  IFF  VAL,PLBL    PROVIDE BRANCH FOR SWITCH
*           IFF  VAL,PLBL     ...
*           ...
*           ...
*      1.5  ESW              END OF BRANCH SWITCH TABLE
*
*           BSW,IFF,ESW PROVIDE A CAPABILITY FOR A SWITCHED
*           BRANCH SIMILAR TO A FORTRAN COMPUTED GOTO. THE
*           VAL ON THE BSW INSTRUCTION IS THE MAXIMUM NUMBER
*           OF BRANCHES. THE VALUE IN X RANGES FROM ZERO UP TO
*           BUT NOT INCLUDING THIS MAXIMUM. EACH IFF PROVIDES A
*           BRANCH. VAL MUST BE LESS THAN THAT GIVEN ON THE BSW
*           AND CONTROL GOES TO PLBL IF THE VALUE IN X MATCHES.
*           IF THE VALUE IN X DOES NOT CORRESPOND TO ANY OF THE
*           IFF ENTRIES, THEN CONTROL PASSES TO THE PLBL ON THE
*           BSW. THIS PLBL OPERAND MAY BE OMITTED IF THERE ARE
*           NO VALUES MISSING FROM THE LIST.
*
*           IFF AND ESW MAY ONLY BE USED IN THIS CONTEXT.
*           EXECUTION OF BSW MAY DESTROY THE CONTENTS OF X.
*           THE IFF ENTRIES MAY BE IN ANY ORDER AND SINCE
*           A TRANSLATOR MAY THUS NEED TO STORE AND SORT THEM,
*           THE COMMENT FIELD IS RESTRICTED IN LENGTH (SEC 11).
{{EJC{{{{{1942
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.6  ENT  VAL         DEFINE PROGRAM ENTRY POINT
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE A PROGRAM ENTRY POINT WHICH CAN SUBSEQUENTLY
*           BE USED IN CONJUNCTION WITH THE BRI INSTRUCTION,
*           WHICH PROVIDES THE ONLY MEANS OF ENTERING THE
*           CODE. IT IS ILLEGAL TO FALL INTO CODE
*           IDENTIFIED BY AN ENTRY POINT. THE
*           ENTRY SYMBOL IS ASSIGNED AN ADDRESS WHICH NEED NOT
*           BE A MULTIPLE OF CFP$B BUT WHICH MUST BE IN THE
*           RANGE 0 LE CFP$L AND THE ADDRESS MUST NOT LIE WITHIN
*           THE ADDRESS RANGE OF THE ALLOCATED DATA AREA.
*           FURTHERMORE, ADDRESSES OF SUCCESSIVE ENTRY POINTS
*           MUST BE ASSIGNED IN SOME ASCENDING SEQUENCE SO
*           THAT THE ADDRESS COMPARISON INSTRUCTIONS CAN BE
*           USED TO TEST THE ORDER IN WHICH TWO ENTRY POINTS
*           OCCUR. THE SYMBOL VAL GIVES AN IDENTIFYING VALUE
*           TO THE ENTRY POINT WHICH CAN BE ACCESSED WITH THE
*           LEI INSTRUCTION.
*
*           NOTE - SUBJECT TO THE RESTRICTION BELOW, VAL MAY
*           BE OMITTED IF NO SUCH IDENTIFICATION IS NEEDED I.E.
*           IF NO LEI REFERENCES THE ENTRY POINT. FOR THIS
*           CASE, A TRANSLATION OPTIMISATION IS POSSIBLE IN
*           WHICH NO MEMORY NEED BE RESERVED FOR A NULL
*           IDENTIFICATION WHICH IS NEVER TO BE REFERENCED, BUT
*           ONLY PROVIDED THIS IS DONE SO AS NOT TO INTERFERE
*           WITH THE STRICTLY ASCENDING SEQUENCE OF ENTRY POINT
*           ADDRESSES. TO SIMPLIFY THIS OPTIMISATION FOR ALL
*           IMPLEMENTORS, THE FOLLOWING RESTRICTION IS OBSERVED
*                VAL MAY ONLY BE OMITTED IF THE ENTRY POINT IS
*                SEPARATED FROM A FOLLOWING ENTRY POINT BY A
*                NON-NULL MINIMAL CODE SEQUENCE.
*           ENTRY POINT ADDRESSES ARE ACCESSIBLE ONLY BY USE OF
*           LITERALS (=ELBL, SECTION 7) OR DAC CONSTANTS
*           (SECTION 8-11.1).
*
*      1.7  BRI  OPN         BRANCH INDIRECT
*
*           OPN CONTAINS THE ADDRESS OF A PROGRAM ENTRY POINT
*           (SEE ENT). CONTROL IS PASSED TO THE EXECUTABLE
*           CODE STARTING AT THE ENTRY POINT ADDRESS. OPN IS
*           LEFT UNCHANGED.
*
*      1.8  LEI  X           LOAD ENTRY POINT IDENTIFICATION
*
*           X CONTAINS THE ADDRESS OF AN ENTRY POINT FOR WHICH
*           AN IDENTIFYING VALUE WAS GIVEN ON THE THE ENT LINE.
*           LEI REPLACES THE CONTENTS OF X BY THIS VALUE.
{{EJC{{{{{1995
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.9  JSR  PNAM        CALL PROCEDURE PNAM
*      1.10 PPM  PLBL        PROVIDE EXIT PARAMETER
*           PPM  PLBL         ...
*           ...
*           PPM  PLBL         ...
*
*           JSR CAUSES CONTROL TO BE PASSED TO THE NAMED
*           PROCEDURE. PNAM IS THE LABEL ON A PRC STATEMENT
*           ELSEWHERE IN THE PROGRAM SECTION (SEE PRC)
*           OR HAS BEEN DEFINED USING AN EXP INSTRUCTION.
*           THE PPM EXIT PARAMETERS FOLLOWING THE CALL GIVE
*           NAMES OF PROGRAM LOCATIONS (PLBL-S) TO WHICH
*           ALTERNATIVE EXI RETURNS OF THE CALLED PROCEDURE MAY
*           PASS CONTROL. THEY MAY OPTIONALLY BE REPLACED BY
*           ERROR RETURNS (SEE ERR). THE NUMBER OF EXIT
*           PARAMETERS FOLLOWING A JSR MUST EQUAL THE INT IN THE
*           PROCEDURE DEFINITION. THE OPERAND OF PPM MAY BE
*           OMITTED IF THE CORRESPONDING EXI RETURN IS CERTAIN
*           NOT TO BE TAKEN.
*
*      1.11 PRC  PTYP,INT    DEFINE START OF PROCEDURE
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE THE NAME OF A PROCEDURE FOR USE WITH JSR.
*           A PROCEDURE IS A CONTIGUOUS SECTION OF INSTRUCTIONS
*           TO WHICH CONTROL MAY BE PASSED WITH A JSR
*           INSTRUCTION. THIS IS THE ONLY WAY IN WHICH THE
*           INSTRUCTIONS IN A PROCEDURE MAY BE EXECUTED. IT IS
*           NOT PERMITTED TO FALL INTO A PROCEDURE.
*           ALL PROCEDURES SHOULD BE NAMED IN SECTION 0
*           INP  STATEMENTS.
*
*           INT IS THE NUMBER OF EXIT PARAMETERS (PPM-S) TO
*           BE USED IN JSR CALLS.
*
*           THERE ARE THREE POSSIBILITIES FOR PTYP, EACH
*           CONSISTING OF A SINGLE LETTER AS FOLLOWS.
*
*           R                RECURSIVE
*
*           THE RETURN POINT (ONE OR MORE WORDS) IS STORED ON
*           THE STACK AS THOUGH ONE OR MORE MOV ...,-(XS)
*           INSTRUCTIONS WERE EXECUTED.
{{EJC{{{{{2042
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*           N                NON-RECURSIVE
*
*           THE RETURN POINT IS TO BE STORED EITHER
*           (1) IN A LOCAL STORAGE WORD ASSOCIATED
*           WITH THE PROCEDURE AND NOT DIRECTLY
*           AVAILABLE TO THE PROGRAM IN ANY OTHER MANNER OR
*           (2) ON A SUBROUTINE LINK STACK QUITE DISTINCT FROM
*           THE MINIMAL STACK ADDRESSED BY XS.
*           IT IS AN ERROR TO USE THE STACK FOR N-LINKS, SINCE
*           PROCEDURE PARAMETERS OR RESULTS MAY BE PASSED VIA
*           THE STACK.
*           IF METHOD (2) IS USED FOR LINKS, ERROR EXITS
*           (ERB,ERR) FROM A PROCEDURE WILL NECESSITATE LINK
*           STACK RESETTING. THE SSL AND SSS ORDERS PROVIDED
*           FOR THIS MAY BE REGARDED AS NO-OPS FOR
*           IMPLEMENTATIONS USING METHOD (1).
*
*           E                EITHER
*
*           THE RETURN POINT MAY BE STORED IN EITHER MANNER
*           ACCORDING TO EFFICIENCY REQUIREMENTS OF THE ACTUAL
*           PHYSICAL MACHINE USED FOR THE IMPLEMENTATION. NOTE
*           THAT PROGRAMMING OF E TYPE PROCEDURES MUST BE
*           INDEPENDENT OF THE ACTUAL IMPLEMENTATION.
*
*           THE ACTUAL FORM OF THE RETURN POINT IS UNDEFINED.
*           HOWEVER, EACH WORD STORED ON THE STACK FOR AN
*           R-TYPE CALL MUST MEET THE FOLLOWING REQUIREMENTS.
*
*           1)               IT CAN BE HANDLED AS AN ADDRESS
*                            AND PLACED IN AN INDEX REGISTER.
*
*           2)               WHEN USED AS AN OPERAND IN AN
*                            ADDRESS COMPARISON INSTRUCTION, IT
*                            MUST NOT APPEAR TO LIE WITHIN
*                            THE ALLOCATED DATA AREA.
*
*           3)               IT IS NOT REQUIRED TO APPEAR
*                            TO LIE WITHIN THE PROGRAM SECTION.
{{EJC{{{{{2085
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.12 EXI  INT         EXIT FROM PROCEDURE
*
*           THE PPM AND ERR PARAMETERS FOLLOWING A JSR ARE
*           NUMBERED STARTING FROM 1.  EXI  INT CAUSES CONTROL
*           TO BE RETURNED TO THE INT-TH SUCH PARAM. EXI 1 GIVES
*           CONTROL TO THE PLBL OF THE FIRST PPM AFTER THE JSR.
*           IF INT IS OMITTED, CONTROL IS PASSED BACK PAST THE
*           LAST EXIT PARAMETER (OR PAST THE JSR IF THERE ARE
*           NONE). FOR R AND E TYPE PROCEDURES, THE
*           STACK POINTER XS MUST BE SET TO ITS APPROPRIATE
*           ENTRY VALUE BEFORE EXECUTING AN EXI INSTRUCTION.
*           IN THIS CASE, EXI REMOVES RETURN POINTS FROM THE
*           STACK IF ANY ARE STORED THERE SO THAT THE STACK
*           POINTER IS RESTORED TO ITS CALLING VALUE.
*
*      1.13 ENP              DEFINE END OF PROCEDURE BODY
*
*           ENP DELIMITS A PROCEDURE BODY AND MAY NOT ACTUALLY
*           BE EXECUTED, HENCE IT MUST HAVE NO LABEL.
*
*      1.14 ERR  INT,TEXT    PROVIDE ERROR RETURN
*
*           ERR MAY REPLACE AN EXIT PARAMETER (PPM) IN
*           ANY PROCEDURE CALL. THE INT ARGUMENT IS A UNIQUE
*           ERROR CODE IN 0 TO 899.
*           THE TEXT SUPPLIED AS THE OTHER OPERAND IS
*           ARBITRARY TEXT IN THE FORTRAN CHARACTER SET AND
*           MAY BE USED IN CONSTRUCTING A FILE OF ERROR
*           MESSAGES FOR DOCUMENTING PURPOSES OR FOR BUILDING
*           A DIRECT ACCESS OR OTHER FILE OF MESSAGES TO BE
*           USED BY THE ERROR HANDLING CODE.
*           IN THE EVENT THAT AN EXI ATTEMPTS
*           TO RETURN CONTROL VIA AN EXIT PARAMETER TO
*           AN ERR, CONTROL IS INSTEAD PASSED TO THE FIRST
*           INSTRUCTION IN THE ERROR SECTION (WHICH FOLLOWS THE
*           PROGRAM SECTION) WITH THE ERROR CODE IN WA.
*
*      1.15 ERB  INT,TEXT    ERROR BRANCH
*
*           THIS INSTRUCTION RESEMBLES ERR EXCEPT THAT IT MAY
*           OCCUR AT ANY POINT WHERE A BRANCH IS PERMITTED.
*           IT EFFECTS A TRANSFER OF CONTROL TO THE ERROR
*           SECTION WITH THE ERROR CODE IN WA.
*
*      1.16 ICV  OPN         INCREMENT VALUE BY ONE
*
*           ICV INCREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   ADD  =UNITY,OPN
*
*      1.17 DCV  OPN         DECREMENT VALUE BY ONE
*
*           DCV DECREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   SUB  =UNITY,OPN
{{EJC{{{{{2142
*
*      BASIC INSTRUCTIONS (CONTINUED)
*
*      1.18 ZER  OPN         ZEROISE OPN
*
*           ZER IS EQUIVALENT TO  MOV  =ZEROE,OPN
*
*      1.19 MNZ  OPN         MOVE NON-ZERO TO OPN
*
*           ANY NON-ZERO COLLECTABLE VALUE MAY USED, FOR WHICH
*           THE OPCODES BNZ/BZE WILL BRANCH/FAIL TO BRANCH.
*
*      1.20 SSL  OPW         SUBROUTINE STACK LOAD
*
*      1.21 SSS  OPW         SUBROUTINE STACK STORE
*
*           THIS PAIR OF OPERATIONS IS PROVIDED TO MAKE POSSIBLE
*           THE USE OF A LOCAL STACK TO HOLD SUBROUTINE (S-R)
*           RETURN LINKS FOR N-TYPE PROCEDURES. SSS STORES THE
*           S-R STACK POINTER IN OPW AND SSL LOADS THE S-R
*           STACK POINTER FROM OPW. BY USING SSS IN THE MAIN
*           PROGRAM OR ON ENTRY TO A PROCEDURE WHICH SHOULD
*           REGAIN CONTROL ON OCCURRENCE OF AN ERR OR ERB AND BY
*           USE OF SSL IN THE ERROR PROCESSING SECTIONS THE
*           S-R STACK POINTER CAN BE RESTORED GIVING A LINK
*           STACK CLEANED UP READY FOR RESUMED EXECUTION.
*           THE FORM OF THE LINK STACK POINTER IS UNDEFINED IN
*           MINIMAL (IT IS LIKELY TO BE A PRIVATE REGISTER
*           KNOWN TO THE TRANSLATOR) AND THE ONLY REQUIREMENT
*           IS THAT IT SHOULD FIT INTO A SINGLE FULL WORD.
*           SSL AND SSS ARE NO-OPS IF A PRIVATE LINK STACK IS
*           NOT USED.
*
*      1.22 RTN              DEFINE START OF ROUTINE
*
*           A ROUTINE IS A CODE CHUNK USED FOR SIMILAR PURPOSES
*           TO A PROCEDURE. HOWEVER IT IS ENTERED BY ANY TYPE OF
*           CONDITIONAL OR UNCONDITIONAL BRANCH (NOT BY JSR). ON
*           TERMINATION IT PASSES CONTROL BY A BRANCH (OFTEN
*           BRI THROUGH A CODE WORD) OR EVEN PERMITS CONTROL
*           TO DROP THROUGH TO ANOTHER ROUTINE. NO RETURN LINK
*           EXISTS AND THE END OF A ROUTINE IS NOT MARKED BY
*           AN EXPLICIT OPCODE (COMPARE ENP).
*           ALL ROUTINES SHOULD BE NAMED IN SECTION 0
*           INR  STATEMENTS.
{{EJC{{{{{2188
*
*      -2-  OPERATIONS ON ONE WORD INTEGER VALUES (ADDRESSES)
*
*      2.1  ADD  OPV,OPN     ADDS OPV TO THE VALUE IN OPN AND
*                            STORES THE RESULT IN OPN. UNDEFINED
*                            IF THE RESULT EXCEEDS CFP$L.
*
*      2.2  SUB  OPV,OPN     SUBTRACTS OPV FROM OPN. STORES THE
*                            RESULT IN OPN. UNDEFINED IF THE
*                            RESULT IS NEGATIVE.
*
*      2.3  ICA  OPN         INCREMENT ADDRESS IN OPN
*                            EQUIVALENT TO ADD *UNITY,OPN
*
*      2.4  DCA  OPN         DECREMENT ADDRESS IN OPN
*                            EQUIVALENT TO SUB *UNITY,OPN
*
*      2.5  BEQ  OPN,OPV,PLBL BRANCH TO PLBL IF OPN EQ OPV
*      2.6  BNE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN NE OPV
*      2.7  BGT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GT OPV
*      2.8  BGE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GE OPV
*      2.9  BLT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LT OPV
*      2.10 BLE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LE OPV
*      2.11 BLO  OPN,OPV,PLBL EQUIVALENT TO BLT OR BLE
*      2.12 BHI  OPN,OPV,PLBL EQUIVALENT TO BGT OR BGE
*
*           THE ABOVE INSTRUCTIONS COMPARE TWO ADDRESS
*           VALUES AS UNSIGNED INTEGER VALUES.
*           THE BLO AND BHI INSTRUCTIONS ARE USED IN CASES WHERE
*           THE EQUAL CONDITION EITHER DOES NOT OCCUR OR CAN
*           RESULT EITHER IN A BRANCH OR NO BRANCH. THIS AVOIDS
*           INEFFICIENT TRANSLATIONS IN SOME IMPLEMENTATIONS.
*
*      2.13 BNZ  OPN,PLBL    EQUIVALENT TO BNE OPN,=ZEROE,PLBL
*
*      2.14 BZE  OPN,PLBL    EQUIVALENT TO BEQ OPN,=ZEROE,PLBL
*
*
*      2.15 LCT  W,OPV       LOAD COUNTER FOR BCT
*
*           LCT LOADS A COUNTER VALUE FOR USE WITH THE BCT
*           INSTRUCTION. THE VALUE IN OPV IS THE NUMBER OF LOOPS
*           TO BE EXECUTED. THE VALUE IN W AFTER THIS OPERATION
*           IS AN UNDEFINED ONE WORD INTEGER QUANTITY.
*
*      2.16 BCT  W,PLBL      BRANCH AND COUNT
*
*           BCT USES THE COUNTER VALUE IN W TO BRANCH THE
*           REQUIRED NUMBER OF TIMES AND THEN FINALLY TO FALL
*           THROUGH TO THE NEXT INSTRUCTION. BCT CAN ONLY BE
*           USED FOLLOWING AN APPROPRIATE LCT INSTRUCTION.
*           THE VALUE IN W AFTER EXECUTION OF BCT IS UNDEFINED.
*
*      2.17 AOV  OPV,OPN,PLBL ADD WITH CARRY TEST
*
*           ADDS OPV TO THE VALUE IN OPN AND STORES RESULT IN
*           OPN. BRANCHES TO PLBL IF RESULT EXCEEDS CFP$L
*           WITH RESULT IN OPN UNDEFINED. CF. ADD.
*
*      2.18 BEV  OPN,PLBL     BRANCH IF EVEN
*      2.19 BOD  OPN,PLBL     BRANCH IF ODD
*
*           THESE OPERATIONS ARE USED ONLY IF .CEPP OR .CRPP IS
*           DEFINED.  ON SOME IMPLEMENTATIONS, A MORE EFFICIENT
*           IMPLEMENTATION IS POSSIBLE BY NOTING THAT ADDRESS OF
*           BLOCKS MUST ALWAYS BE A MULTIPLE OF CFP$B. WE CALL
*           SUCH ADDRESSES EVEN.  THUS RETURN ADDRESS ON THE
*           STACK (.CRPP) AND ENTRY POINT ADDRESSES (.CEPP) CAN
*           BE DISTINGUISHED FROM BLOCK ADDRESSES IF THEY ARE
*           FORCED TO BE ODD (NOT A MULTIPLE OF CFP$B).
*           BEV AND BOD BRANCH ACCORDING AS OPERAND IS EVEN
*           OR ODD, RESPECTIVELY.
{{EJC{{{{{2261
*
*      -3-  OPERATIONS ON THE CODE POINTER REGISTER (CP)
*
*           THE CODE POINTER REGISTER PROVIDES A PSUEDO
*           INSTRUCTION COUNTER FOR USE IN AN INTERPRETOR. IT
*           MAY BE IMPLEMENTED AS A REAL REGISTER OR AS A
*           MEMORY LOCATION, BUT IN EITHER CASE IT IS SEPARATE
*           FROM ANY OTHER REGISTER. THE VALUE IN THE CODE
*           POINTER REGISTER IS ALWAYS A WORD ADDRESS (I.E.
*           A ONE WORD INTEGER WHICH IS A MULTIPLE OF CFP$B).
*
*      3.1  LCP  REG         LOAD CODE POINTER REGISTER
*                            THIS INSTRUCTION CAUSES THE CODE
*                            POINTER REGISTER TO BE SET FROM
*                            THE VALUE IN REG WHICH IS UNCHANGED
*
*      3.2  SCP  REG         STORE CODE POINTER REGISTER
*                            THIS INSTRUCTION LOADS THE CURRENT
*                            VALUE IN THE CODE POINTER REGISTER
*                            INTO REG. (CP) IS UNCHANGED.
*
*      3.3  LCW  REG         LOAD NEXT CODE WORD
*                            THIS INSTRUCTION CAUSES THE WORD
*                            POINTED TO BY CP TO BE LOADED INTO
*                            THE INDICATED REG. THE VALUE IN CP
*                            IS THEN INCREMENTED BY ONE WORD.
*                            EXECUTION OF LCW MAY DESTROY XL.
*
*      3.4  ICP              INCREMENT CP BY ONE WORD
*
*           ON MACHINES WITH MORE THAN THREE INDEX REGISTERS,
*           CP CAN BE TREATED SIMPLY AS AN INDEX REGISTER.
*           IN THIS CASE, THE FOLLOWING EQUIVALENCES APPLY.
*
*           LCP REG IS LIKE MOV REG,CP
*           SCP REG IS LIKE MOV CP,REG
*           LCW REG IS LIKE MOV (CP)+,REG
*           ICP     IS LIKE ICA CP
*
*           SINCE LCW IS ALLOWED TO DESTROY XL, THE FOLLOWING
*           IMPLEMENTATION USING A WORK LOCATION CP$$$ CAN
*           ALSO BE USED.
*
*           LCP  REG         MOV  REG,CP$$$
*
*           SCP  REG         MOV  CP$$$,REG
*
*           LCW  REG         MOV  CP$$$,XL
*                            MOV  (XL)+,REG
*                            MOV  XL,CP$$$
*
*           ICP              ICA  CP$$$
{{EJC{{{{{2314
*
*      -4-  OPERATIONS ON SIGNED INTEGER VALUES
*
*      4.1  LDI  OPS         LOAD INTEGER ACCUMULATOR FROM OPS
*      4.2  ADI  OPS         ADD OPS TO INTEGER ACCUMULATOR
*      4.3  MLI  OPS         MULTIPLY INTEGER ACCUMULATOR BY OPS
*      4.4  SBI  OPS         SUBTRACT OPS FROM INT ACCUMULATOR
*      4.5  DVI  OPS         DIVIDE INTEGER ACCUMULATOR BY OPS
*      4.6  RMI  OPS         SET INT ACCUM TO MOD(INTACC,OPS)
*      4.7  STI  OPS         STORE INTEGER ACCUMULATOR AT OPS
*      4.8  NGI              NEGATE THE VALUE IN THE INTEGER
*                            ACCUMULATOR (CHANGE ITS SIGN)
*
*           THE EQUATION SATISFIED BY OPERANDS AND RESULTS OF
*           DVI AND RMI IS
*                  DIV = QOT * OPS + REM          WHERE
*           DIV = DIVIDEND IN INTEGER ACCUMULATOR
*           QOT = QUOTIENT LEFT IN IA BY DIV
*           OPS = THE DIVISOR
*           REM = REMAINDER LEFT IN IA BY RMI
*           THE SIGN OF THE RESULT OF DVI IS + IF (IA) AND (OPS)
*           HAVE THE SAME SIGN AND IS - IF THEY HAVE OPPOSITE
*           SIGNS. THE SIGN OF (IA) IS ALWAYS USED AS THE SIGN
*           OF THE RESULT OF REM.
*           ASSUMING IN EACH CASE THAT IA CONTAINS THE NUMBER
*           SPECIFIED IN PARENTHESES AND THAT SEVEN AND MSEVN
*           HOLD +7 AND -7 RESP. THE ALGORITHM IS ILLUSTRATED
*           BELOW.
*           (IA = 13)
*           DVI  SEVEN       IA = 1
*           RMI  SEVEN       IA = 6
*           DVI  MSEVN       IA = -1
*           RMI  MSEVN       IA = 6
*           (IA = -13)
*           DVI  SEVEN       IA = -1
*           RMI  SEVEN       IA = -6
*           DVI  MSEVN       IA = 1
*           RMI  MSEVN       IA = -6
{{EJC{{{{{2353
*
*           THE ABOVE INSTRUCTIONS OPERATE ON A FULL RANGE OF
*           SIGNED INTEGER VALUES. WITH THE EXCEPTION OF LDI AND
*           STI, THESE INSTRUCTIONS MAY CAUSE INTEGER OVERFLOW
*           BY ATTEMPTING TO PRODUCE AN UNDEFINED OR OUT OF
*           RANGE RESULT IN WHICH CASE INTEGER OVERFLOW IS SET,
*           THE RESULT IN (IA) IS UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE IOV OR INO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      4.9  INO  PLBL        JUMP TO PLBL IF NO INTEGER OVERFLOW
*      4.10 IOV  PLBL        JUMP TO PLBL IF INTEGER OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE INTEGER
*           OVERFLOW (ADI, SBI, MLI, DVI, RMI, NGI) AND
*           TEST THE RESULT OF THE PRECEDING INSTRUCTION.
*           IOV AND INO MAY NOT HAVE LABELS.
*
*      4.11 IEQ  PLBL        JUMP TO PLBL IF (IA) EQ 0
*      4.12 IGE  PLBL        JUMP TO PLBL IF (IA) GE 0
*      4.13 IGT  PLBL        JUMP TO PLBL IF (IA) GT 0
*      4.14 ILE  PLBL        JUMP TO PLBL IF (IA) LE 0
*      4.15 ILT  PLBL        JUMP TO PLBL IF (IA) LT 0
*      4.16 INE  PLBL        JUMP TO PLBL IF (IA) NE 0
*
*           THE ABOVE CONDITIONAL JUMP INSTRUCTIONS DO
*           NOT CHANGE THE CONTENTS OF THE ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN IA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
{{EJC{{{{{2387
*
*      -5-  OPERATIONS ON REAL VALUES
*
*      5.1  LDR  OPS         LOAD REAL ACCUMULATOR FROM OPS
*      5.2  STR  OPS         STORE REAL ACCUMULATOR AT OPS
*      5.3  ADR  OPS         ADD OPS TO REAL ACCUMULATOR
*      5.4  SBR  OPS         SUBTRACT OPS FROM REAL ACCUMULATOR
*      5.5  MLR  OPS         MULTIPLY REAL ACCUMULATOR BY OPS
*      5.6  DVR  OPS         DIVIDE REAL ACCUMULATOR BY OPS
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS CAUSES
*           UNDERFLOW, THE RESULT YIELDED IS 0.0.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      5.7  ROV  PLBL        JUMP TO PLBL IF REAL OVERFLOW
*      5.8  RNO  PLBL        JUMP TO PLBL IF NO REAL OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE REAL
*           OVERFLOW (ADR,SBR,MLR,DVR).
*
*      5.9  NGR              NEGATE REAL ACCUM (CHANGE SIGN)
*
*      5.10 REQ  PLBL        JUMP TO PLBL IF (RA) EQ 0.0
*      5.11 RGE  PLBL        JUMP TO PLBL IF (RA) GE 0.0
*      5.12 RGT  PLBL        JUMP TO PLBL IF (RA) GT 0.0
*      5.13 RLE  PLBL        JUMP TO PLBL IF (RA) LE 0.0
*      5.14 RLT  PLBL        JUMP TO PLBL IF (RA) LT 0.0
*      5.15 RNE  PLBL        JUMP TO PLBL IF (RA) NE 0.0
*
*           THE ABOVE CONDITIONAL INSTRUCTIONS DO NOT AFFECT
*           THE VALUE STORED IN THE REAL ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN RA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
*
*      5.16 ATN              ARCTANGENT OF REAL ACCUM
*      5.17 CHP              INTEGER PORTION OF REAL ACCUM
*      5.18 COS              COSINE OF REAL ACCUM
*      5.19 ETX              E TO THE POWER IN THE REAL ACCUM
*      5.20 LNF              NATURAL LOGORITHM OF REAL ACCUM
*      5.21 SIN              SINE OF REAL ACCUM
*      5.22 SQR              SQUARE ROOT OF REAL ACCUM
*      5.23 TAN              TANGENT OF REAL ACCUM
*
*           THE ABOVE ORDERS OPERATE UPON THE REAL ACCUMULATOR,
*           AND REPLACE THE CONTENTS OF THE ACCUMULATOR WITH THE
*           RESULT.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
{{EJC{{{{{2450
*
*      -6-  OPERATIONS ON CHARACTER VALUES
*
*           CHARACTER OPERATIONS EMPLOY THE CONCEPT OF A
*           CHARACTER POINTER WHICH USES EITHER
*           INDEX REGISTER XR OR XL (NOT XS).
*
*           A CHARACTER POINTER POINTS TO A SPECIFIC CHARACTER
*           IN A STRING OF CHARACTERS STORED CFP$C CHARS TO A
*           WORD. THE ONLY OPERATIONS PERMITTED ON A CHARACTER
*           POINTER ARE LCH AND SCH. IN PARTICULAR, A CHARACTER
*           POINTER MAY NOT EVEN BE MOVED WITH MOV.
*
*              RESTRICTION 1.
*              --------------
*           IT IS IMPORTANT WHEN CODING IN MINIMAL TO ENSURE
*           THAT NO ACTION OCCURRING BETWEEN THE INITIAL USE OF
*           PLC OR PSC AND THE EVENTUAL CLEARING OF XL OR XR ON
*           COMPLETION OF CHARACTER OPERATIONS CAN INITIATE A
*           GARBAGE COLLECTION. THE LATTER OF COURSE COULD CAUSE
*           THE ADDRESSED CHARACTERS TO BE MOVED LEAVING THE
*           CHARACTER POINTERS POINTING TO RUBBISH.
*
*              RESTRICTION 2.
*              --------------
*           A FURTHER RESTRICTION TO BE OBSERVED IN CODE
*           HANDLING CHARACTER STRINGS, IS THAT STRINGS BUILT
*           DYNAMICALLY SHOULD BE RIGHT PADDED WITH ZERO
*           CHARACTERS TO A FULL WORD BOUNDARY TO PERMIT EASY
*           HASHING AND USE OF CEQ OR CNE IN TESTING STRINGS
*           FOR EQUALITY.
*
*      6.1  PLC  X,OPV       PREPARE CH PTR FOR LCH,CMC,MVC,TRC,
*                            MCB.
*
*      6.2  PSC  X,OPV       PREPARE CHAR. PTR FOR SCH,MVC,MCB.
*
*           OPV CAN BE OMITTED IF IT IS ZERO.
*           THE CHAR. INITIALLY ADDRESSED IS DETERMINED BY THE
*           WORD ADDRESS IN X AND THE INTEGER OFFSET OPV.
*           THERE IS AN AUTOMATIC IMPLIED OFFSET OF CFP$F BYTES.
*           CFP$F IS USED TO FORMALLY INTRODUCE INTO MINIMAL A
*           VALUE NEEDED IN TRANSLATING THESE OPCODES WHICH,
*           SINCE MINIMAL ITSELF DOES NOT PRESCRIBE A STRING
*           STRUCTURE IN DETAIL, DEPENDS ON THE CHOICE OF A DATA
*           STRUCTURE FOR STRINGS IN THE MINIMAL PROGRAM.
*           E.G. IF CFP$B = CFP$C = 3, CFP$F = 6, NUM01 = 1, XL
*           POINTS TO A SERIES OF 4 WORDS, ABC/DEF/GHI/JKL, THEN
*               PLC  XL,=NUM01
*           POINTS TO H.
{{EJC{{{{{2501
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.3  LCH  REG,OPC     LOAD CHARACTER INTO REG
*
*      6.4  SCH  REG,OPC     STORE CHARACTER FROM REG
*
*           THESE OPERATIONS ARE DEFINED SUCH THAT THE CHARACTER
*           IS RIGHT JUSTIFIED IN REGISTER REG WITH ZERO BITS TO
*           THE LEFT. AFTER LCH FOR EXAMPLE, IT IS LEGITIMATE
*           TO REGARD REG AS CONTAINING THE ORDINAL INTEGER
*           CORRESPONDING TO THE CHARACTER.
*
*           OPC IS ONE OF THE FOLLOWING THREE POSSIBILITIES.
*
*           (X)              THE CHARACTER POINTED TO BY THE
*                            CHARACTER POINTER IN X. THE
*                            CHARACTER POINTER IS NOT CHANGED.
*
*           (X)+             SAME CHARACTER AS (X) BUT THE
*                            CHARACTER POINTER IS INCREMENTED
*                            TO POINT TO THE NEXT CHARACTER
*                            FOLLOWING EXECUTION.
*
*           -(X)             THE CHARACTER POINTER IS DECRE-
*                            MENTED BEFORE ACCESSING THE
*                            CHARACTER SO THAT THE PREVIOUS
*                            CHARACTER IS REFERENCED.
*
*      6.5  CSC  X           COMPLETE STORE CHARACTERS
*
*           THIS INSTRUCTION MARKS COMPLETION OF A
*           PSC,SCH,SCH,...,SCH SEQUENCE INITIATED BY
*           A  PSC  X INSTRUCTION. NO MORE SCH INSTRUCTIONS
*           USING  X  SHOULD BE OBEYED UNTIL ANOTHER PSC IS
*           OBEYED. IT IS PROVIDED SOLELY AS AN EFFICIENCY AID
*           ON MACHINES WITHOUT CHARACTER ORDERS SINCE IT
*           PERMITS USE OF REGISTER BUFFERING OF CHARS IN SCH
*           SEQUENCES. WHERE CSC IS NOT A NO-OP, IT MUST OBSERVE
*           RESTRICTION 2. (E.G. IN SPITBOL, ALOCS ZEROISES THE
*           LAST WORD OF A STRING FRAME PRIOR TO SCH SEQUENCE
*           BEING STARTED SO CSC MUST NOT NULLIFY THIS ACTION.)
*
*           THE FOLLOWING INSTRUCTIONS ARE USED TO COMPARE
*           TWO WORDS CONTAINING CFP$C CHARACTERS.
*           COMPARISONS DISTINCT FROM BEQ,BNE ARE PROVIDED AS
*           ON SOME TARGET MACHINES, THE POSSIBILITY OF THE SIGN
*           BIT BEING SET MAY REQUIRE SPECIAL ACTION.
*           NOTE THAT RESTRICTION 2 ABOVE, EASES USE OF THESE
*           ORDERS IN TESTING COMPLETE STRINGS FOR EQUALITY,
*           SINCE WHOLE WORD TESTS ARE POSSIBLE.
*
*      6.6  CEQ  OPW,OPW,PLBL JUMP TO PLBL IF OPW EQ OPW
*      6.7  CNE  OPW,OPW,PLBL JUMP TO PLBL IF OPW NE OPW
{{EJC{{{{{2556
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.8  CMC  PLBL,PLBL   COMPARE CHARACTERS
*
*           CMC IS USED TO COMPARE TWO CHARACTER STRINGS. BEFORE
*           EXECUTING CMC, REGISTERS ARE SET UP AS FOLLOWS.
*           (XL)             CHARACTER PTR FOR FIRST STRING
*           (XR)             CHARACTER POINTER FOR SECOND STRING
*           (WA)             CHARACTER COUNT (MUST BE .GT. ZERO)
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           CONTROL PASSES TO FIRST PLBL IF THE FIRST STRING
*           IS LEXICALLY LESS THAN THE SECOND STRING, AND TO
*           THE SECOND PLBL IF THE FIRST STRING IS LEXICALLY
*           GREATER. CONTROL PASSES TO THE FOLLOWING INSTRUCTION
*           IF THE STRINGS ARE IDENTICAL. AFTER EXECUTING THIS
*           INSTRUCTION, THE VALUES OF XR AND XL ARE SET TO
*           ZERO AND THE VALUE IN (WA) IS UNDEFINED.
*           ARGUMENTS TO CMC MAY BE COMPLETE OR PARTIAL
*           STRINGS, SO MAKING OPTIMISATION TO USE WHOLE WORD
*           COMPARISONS DIFFICULT (DEPENDENT IN GENERAL ON
*           SHIFTS AND MASKING).
*
*      6.9  TRC              TRANSLATE CHARACTERS
*
*           TRC IS USED TO TRANSLATE A CHARACTER STRING USING A
*           SUPPLIED TRANSLATION TABLE. BEFORE EXECUTING TRC THE
*           REGISTERS ARE SET AS FOLLOWS.
*           (XL)             CHAR PTR TO STRING TO BE TRANSLATED
*           (XR)             CHAR PTR TO TRANSLATE TABLE
*           (WA)             LENGTH OF STRING TO BE TRANSLATED
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           THE TRANSLATE TABLE CONSISTS OF CFP$A CONTIGUOUS
*           CHARACTERS GIVING THE TRANSLATIONS OF THE CFP$A
*           CHARACTERS IN THE ALPHABET. ON COMPLETION, (XR) AND
*           (XL) ARE SET TO ZERO AND (WA) IS UNDEFINED.
*
*      6.10 FLC  W           FOLD CHARACTER TO UPPER CASE
*           FLC IS USED ONLY IF .CULC IS DEFINED. THE CHARACTER
*           CODE VALUE IN W IS TRANSLATED TO UPPER CASE IF IT
*           CORRESPONDS TO A LOWER CASE CHARACTER.
{{EJC{{{{{2598
*
*      -7-  OPERATIONS ON BIT STRING VALUES
*
*      7.1  ANB  OPW,W       AND BIT STRING VALUES
*      7.2  ORB  OPW,W       OR BIT STRING VALUES
*      7.3  XOB  OPW,W       EXCLUSIVE OR BIT STRING VALUES
*
*           IN THE ABOVE OPERATIONS, THE LOGICAL CONNECTIVE IS
*           APPLIED SEPARATELY TO EACH OF THE CFP$N BITS.
*           THE RESULT IS STORED IN THE SECOND OPERAND LOCATION.
*
*      7.4  CMB  W           COMPLEMENT ALL BITS IN OPW
*
*      7.5  RSH  W,VAL       RIGHT SHIFT BY VAL BITS
*      7.6  LSH  W,VAL       LEFT SHIFT BY VAL BITS
*      7.7  RSX  W,(X)       RIGHT SHIFT W NUMBER OF BITS IN X
*      7.8  LSX  W,(X)       LEFT SHIFT W NUMBER OF BITS IN X
*
*           THE ABOVE SHIFTS ARE LOGICAL SHIFTS IN WHICH BITS
*           SHIFTED OUT ARE LOST AND ZERO BITS SUPPLIED AS
*           REQUIRED. THE SHIFT COUNT IS IN THE RANGE 0-CFP$N.
*
*      7.9  NZB  W,PLBL      JUMP TO PLBL IF W IS NOT
*                            ALL ZERO BITS.
*
*      7.10 ZRB  W,PLBL      JUMP TO PLBL IF W IS ALL ZERO BITS
*
*      7.11 ZGB  OPN         ZEROISE GARBAGE BITS
*
*           OPN CONTAINS A BIT STRING REPRESENTING A WORD
*           OF CHARACTERS FROM A STRING OR SOME FUNCTION
*           FORMED FROM SUCH CHARACTERS (E.G. AS A RESULT OF
*           HASHING). ON A MACHINE WHERE THE WORD SIZE IS NOT A
*           MULTIPLE OF THE CHARACTER SIZE, SOME BITS IN REG MAY
*           BE UNDEFINED. THIS OPCODE REPLACES SUCH BITS BY THE
*           ZERO BIT. ZGB IS A NO-OP IF THE WORD SIZE IS A
*           MULTIPLE OF THE CHARACTER SIZE.
{{EJC{{{{{2636
*
*      -8-  CONVERSION INSTRUCTIONS
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN LENGTHS IN BYTES AND LENGTHS IN WORDS.
*
*      8.1  WTB  REG         CONVERT REG FROM WORDS TO BYTES.
*                            THAT IS, MULTIPLY BY CFP$B. THIS IS
*                            A NO-OP IF CFP$B IS ONE.
*
*      8.2  BTW  REG         CONVERT REG FROM BYTES TO WORDS
*                            BY DIVIDING REG BY CFP$B DISCARDING
*                            THE FRACTION. NO-OP IF CFP$B IS ONE
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           OF ONE WORD INTEGER VALUES (ADDRESSES) TO AND
*           FROM THE FULL SIGNED INTEGER FORMAT.
*
*      8.3  MTI  OPN         THE VALUE OF OPN (AN ADDRESS)
*                            IS MOVED AS A POSITIVE INTEGER
*                            TO THE INTEGER ACCUMULATOR.
*
*      8.4  MFI  OPN,PLBL    THE VALUE CURRENTLY STORED IN THE
*                            INTEGER ACCUMULATOR IS MOVED
*                            TO OPN AS AN ADDRESS IF IT IS IN
*                            THE RANGE 0 TO CFP$M INCLUSIVE.
*                            IF THE ACCUMULATOR VALUE IS
*                            OUTSIDE THIS RANGE, THEN THE RESULT
*                            IN OPN IS UNDEFINED AND CONTROL IS
*                            PASSED TO PLBL. MFI DESTROYS THE
*                            VALUE OF (IA) WHETHER OR NOT
*                            INTEGER OVERFLOW IS SIGNALLED.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN REAL VALUES AND INTEGER VALUES.
*
*      8.5  ITR              CONVERT INTEGER VALUE IN INTEGER
*                            ACCUMULATOR TO REAL AND STORE IN
*                            REAL ACCUMULATOR (MAY LOSE
*                            PRECISION IN SOME CASES)
*
*      8.6  RTI  PLBL        CONVERT THE REAL VALUE IN RA TO
*                            AN INTEGER AND PLACE RESULT IN IA.
*                            CONVERSION IS BY TRUNCATION OF THE
*                            FRACTION - NO ROUNDING OCCURS.
*                            JUMP TO PLBL IF OUT OF RANGE. (RA)
*                            IS NOT CHANGED IN EITHER CASE.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
{{EJC{{{{{2688
*
*      -8-  CONVERSION INSTRUCTIONS (CONTINUED)
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR COMPUTING
*           THE LENGTH OF STORAGE REQUIRED FOR A TEXT STRING.
*
*      8.7  CTW  W,VAL       THIS INSTRUCTION COMPUTES THE SUM
*                            (NUMBER OF WORDS REQUIRED TO STORE
*                            W CHARACTERS) + (VAL). THE SUM
*                            IS STORED IN W.
*                            FOR EXAMPLE, IF CFP$C IS 5, AND WA
*                            CONTAINS 32, THEN CTW WA,2
*                            GIVES A RESULT OF 9 IN WA.
*
*      8.8  CTB  W,VAL       CTB IS EXACTLY LIKE CTW EXCEPT THAT
*                            THE RESULT IS IN BYTES. IT HAS THE
*                            SAME EFFECT AS CTW W,VAL  WTB W
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           FROM INTEGERS TO AND FROM NUMERIC DIGIT CHARACTERS
*           FOR USE IN NUMERIC CONVERSION ROUTINES. THEY EMPLOY
*           NEGATIVE INTEGER VALUES TO ALLOW FOR PROPER
*           CONVERSION OF NUMBERS WHICH CANNOT BE COMPLEMENTED.
*
*      8.9  CVM  PLBL        CONVERT BY MULTIPLICATION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS MULTIPLIED BY 10. WB CONTAINS THE CHARACTER
*           CODE FOR A DIGIT. THE VALUE OF THIS DIGIT IS THEN
*           SUBTRACTED FROM THE RESULT. IF THE RESULT IS OUT OF
*           RANGE, THEN CONTROL IS PASSED TO PLBL WITH THE
*           RESULT IN (IA) UNDEFINED. EXECUTION OF CVM LEAVES
*           THE RESULT IN (WB) UNDEFINED.
*
*      8.10 CVD              CONVERT BY DIVISION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS DIVIDED BY 10. THE QUOTIENT (ZERO OR NEGATIVE)
*           IS REPLACED IN THE ACCUMULATOR. THE REMAINDER IS
*           CONVERTED TO THE CHARACTER CODE OF A DIGIT AND
*           PLACED IN WA. FOR EXAMPLE, AN OPERAND OF -523 GIVES
*           A QUOTIENT OF -52 AND A REMAINDER IN WA OF CH$D3.
{{EJC{{{{{2731
*
*      -9-  BLOCK MOVE INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED FOR TRANSFERRING
*      DATA FROM ONE AREA OF MEMORY TO ANOTHER IN BLOCKS.
*      THEY CAN BE IMPLEMENTED WITH THE INDICATED SERIES OF
*      OTHER MACRO-INSTRUCTIONS, BUT MORE EFFICIENT IMPLE-
*      MENTATIONS WILL BE POSSIBLE ON MOST MACHINES.
*
*      NOTE THAT IN THE EQUIVALENT CODE SEQUENCE SHOWN BELOW, A
*      ZERO VALUE IN WA WILL MOVE AT LEAST ONE ITEM, AND MAY
*      MAY WRAP THE COUNTER CAUSING A CORE DUMP IN SOME IMPLE-
*      MENTATIONS.  THUS WA SHOULD BE .GT. 0 PRIOR TO INVOKING
*      ANY OF THESE BLOCK MOVE INSTRUCTIONS.
*
*      9.1  MVC              MOVE CHARACTERS
*
*           BEFORE OBEYING THIS ORDER WA,XL,XR SHOULD HAVE BEEN
*           SET UP, THE LATTER TWO BY PLC, PSC RESP.
*           MVC IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,(XL)+
*                  SCH  WB,(XR)+
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THE CHARACTER POINTERS ARE BUMPED AS INDICATED
*           AND THE FINAL VALUE OF WA IS UNDEFINED.
*
*
*      9.2  MVW              MOVE WORDS
*
*           MVW IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPW  MOV  (XL)+,(XR)+
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPW
*
*           NOTE THAT THIS IMPLIES THAT THE VALUE IN WA IS THE
*           LENGTH IN BYTES WHICH IS A MULTIPLE OF CFP$B.
*           THE INITIAL ADDRESSES IN XR,XL ARE WORD ADDRESSES.
*           AS INDICATED, THE FINAL XR,XL VALUES POINT PAST THE
*           NEW AND OLD REGIONS OF MEMORY RESPECTIVELY.
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MVW.
*
*      9.3  MWB              MOVE WORDS BACKWARDS
*
*           MWB IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPB  MOV  -(XL),-(XR)
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MWB.
*
*      9.4  MCB              MOVE CHARACTERS BACKWARDS
*
*           MCB IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,-(XL)
*                  SCH  WB,-(XR)
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MCB.
{{EJC{{{{{2814
*
*      -10- OPERATIONS CONNECTED WITH THE STACK
*
*      THE STACK IS AN AREA IN MEMORY WHICH IS DEDICATED FOR USE
*      IN CONJUNCTION WITH THE STACK POINTER REGISTER (XS). AS
*      PREVIOUSLY DESCRIBED, IT IS USED BY THE JSR AND EXI
*      INSTRUCTIONS AND MAY BE USED FOR STORAGE OF ANY OTHER
*      DATA AS REQUIRED.
*
*      THE STACK BUILDS EITHER WAY IN MEMORY AND AN IMPORTANT
*      RESTRICTION IS THAT THE VALUE IN (XS) MUST BE THE ADDRESS
*      OF THE STACK FRONT AT ALL TIMES SINCE
*      SOME IMPLEMENTATIONS MAY RANDOMLY DESTROY STACK LOCATIONS
*      BEYOND (XS).
*
*      THE STARTING STACK BASE ADDRESS IS PASSED
*      IN (XS) AT THE START OF EXECUTION. DURING EXECUTION IT
*      IS NECESSARY TO MAKE SURE THAT THE STACK DOES NOT
*      OVERFLOW. THIS IS ACHIEVED BY EXECUTING THE FOLLOWING
*      INSTRUCTION PERIODICALLY.
*
*      10.1 CHK              CHECK STACK OVERFLOW
*
*      AFTER SUCCESSFULLY EXECUTING CHK, IT IS PERMISSIBLE TO
*      USE UP TO 100 ADDITIONAL WORDS BEFORE ISSUING ANOTHER CHK
*      THUS CHK NEED NOT BE ISSUED EVERY TIME THE STACK IS
*      EXPANDED. IN SOME IMPLEMENTATIONS, THE CHECKING MAY BE
*      AUTOMATIC AND CHK WILL HAVE NO EFFECT. FOLLOWING THE
*      ABOVE RULE MAKES SURE THAT THE PROGRAM WILL OPERATE
*      CORRECTLY IN IMPLEMENTATIONS WITH NO AUTOMATIC CHECK.
*
*      IF STACK OVERFLOW OCCURS (DETECTED EITHER AUTOMATICALLY
*      OR BY A CHK INSTRUCTION), THEN CONTROL IS PASSED TO THE
*      STACK OVERFLOW SECTION (SEE PROGRAM FORM). NOTE THAT THIS
*      TRANSFER MAY TAKE PLACE FOLLOWING ANY INSTRUCTION WHICH
*      STORES DATA AT A NEW LOCATION ON THE STACK.
*      AFTER STACK OVERFLOW, STACK IS ARBITRARILY POPPED
*      TO GIVE SOME SPACE IN WHICH THE ERROR PROCEDURE MAY
*      OPERATE. OTHERWISE A LOOP OF STACK OVERFLOWS MAY OCCUR.
{{EJC{{{{{2854
*
*      -11- DATA GENERATION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED TO GENERATE CONSTANT
*      VALUES IN THE CONSTANT SECTION AND ALSO TO ASSEMBLE
*      INITIAL VALUES IN THE WORKING STORAGE SECTION. THEY
*      MAY NOT APPEAR EXCEPT IN THESE TWO SECTIONS.
*
*      11.1 DAC  ADDR        ASSEMBLE ADDRESS CONSTANT.
*                            GENERATES ONE WORD CONTAINING THE
*                            SPECIFIED ONE WORD INTEGER
*                            VALUE (ADDRESS).
*
*      11.2 DIC  INTEGER     GENERATES AN INTEGER VALUE WHICH
*                            OCCUPIES CFP$I CONSECUTIVE WORDS.
*                            THE OPERAND IS A DIGIT STRING WITH
*                            A REQUIRED LEADING SIGN.
*
*      11.3 DRC  REAL        ASSEMBLES A REAL CONSTANT WHICH
*                            OCCUPIES CFP$R CONSECUTIVE WORDS.
*                            THE OPERAND FORM MUST OBEY THE
*                            RULES FOR A FORTRAN REAL CONSTANT
*                            WITH THE EXTRA REQUIREMENT THAT A
*                            LEADING SIGN BE PRESENT.
*
*      11.4 DTC  DTEXT       DEFINE TEXT CONSTANT. DTEXT
*                            IS STARTED AND ENDED WITH ANY
*                            CHARACTER NOT CONTAINED IN THE
*                            CHARACTERS TO BE ASSEMBLED. THE
*                            CONSTANT OCCUPIES CONSECUTIVE WORDS
*                            AS DICTATED BY THE CONFIGURATION
*                            PARAMETER CFP$C. ANY UNUSED CHARS
*                            IN THE LAST WORD ARE RIGHT FILLED
*                            WITH ZEROS (I.E. THE CHARACTER
*                            WHOSE INTERNAL CODE IS ZERO).
*                            THE STRING CONTAINS A SEQUENCE OF
*                            LETTERS, DIGITS, BLANKS AND ANY OF
*                            THE FOLLOWING SPECIAL CHARACTERS.
*                            =,$.(*)/+-
*                            NO OTHER CHARACTERS
*                            MAY BE USED IN A DTEXT OPERAND.
*
*      11.5 DBC  VAL         ASSEMBLE BIT STRING CONSTANT. THE
*                            OPERAND IS A POSITIVE INTEGER
*                            VALUE WHICH IS INTERPRETED IN
*                            BINARY, RIGHT JUSTIFIED AND LEFT
*                            FILLED WITH ZERO BITS. THUS 5 WOULD
*                            IMPLY THE BIT STRING VALUE 00...101.
{{EJC{{{{{2903
*
*      -12- SYMBOL DEFINITION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTION IS USED TO DEFINE SYMBOLS
*      IN THE DEFINITIONS SECTION. IT MAY NOT BE USED ELSEWHERE.
*
*      12.1 EQU  EQOP        DEFINE SYMBOL
*
*           THE SYMBOL WHICH APPEARS IN THE LABEL FIELD IS
*           DEFINED TO HAVE THE ABSOLUTE VALUE GIVEN
*           BY THE EQOP OPERAND. A GIVEN SYMBOL MAY BE DEFINED
*           ONLY ONCE IN THIS MANNER, AND ANY SYMBOLS OCCURING
*           IN EQOP MUST BE PREVIOUSLY DEFINED.
*
*           THE FOLLOWING ARE THE POSSIBILITIES FOR EQOP
*
*           VAL              THE INDICATED VALUE IS USED
*
*           VAL+VAL          THE SUM OF THE TWO VALUES IS USED.
*                            THIS SUM MUST NOT EXCEED CFP$M
*
*           VAL-VAL          THE DIFFERENCE BETWEEN THE TWO
*                            VALUES (MUST BE POSITIVE) IS USED.
*
*           *                THIS FORMAT DEFINES THE LABEL BY
*                            USING A VALUE SUPPLIED BY THE
*                            MINIMAL TRANSLATOR. VALUES ARE
*                            REQUIRED FOR THE
*           CFP$X            (CONFIGURATION PARAMETERS)
*           E$XXX            (ENVIRONMENT PARAMETERS)
*           CH$XX            (CHARACTER CODES).
*                            IN ORDER FOR A TRANSLATOR TO
*                            HANDLE THIS FORMAT CORRECTLY THE
*                            DEFINITIONS SECTION MUST BE
*                            CONSULTED FOR DETAILS OF REQUIRED
*                            SYMBOLS AS LISTED AT THE FRONT OF
*                            THE SECTION.
{{EJC{{{{{2941
*
*      SYMBOL DEFINITION INSTRUCTIONS (CONTINUED)
*
*      THE FOLLOWING INSTRUCTIONS MAY BE USED TO DEFINE SYMBOLS
*      IN THE PROCEDURE SECTION. THEY MAY NOT BE USED IN
*      ANY OTHER PART OF THE PROGRAM.
*
*      12.2 EXP              DEFINE EXTERNAL PROCEDURE
*
*           EXP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN EXTERNAL PROCEDURE WHICH CAN BE
*           REFERENCED IN A SUBSEQUENT JSR INSTRUCTION. THE
*           CODING FOR THE PROCEDURE IS EXTERNAL TO THE
*           CODING OF THE SOURCE PROGRAM IN THIS LANGUAGE.
*           THE CODE FOR EXTERNAL PROCEDURES MAY BE
*           REFERRED TO COLLECTIVELY AS THE OPERATING SYSTEM
*           INTERFACE, OR MORE BRIEFLY, OSINT, AND WILL
*           FREQUENTLY BE A SEPARATELY COMPILED SEGMENT OF CODE
*           LOADED WITH SPITBOL TO PRODUCE A COMPLETE SYSTEM.
*
*      12.3 INP  PTYP,INT    DEFINE INTERNAL PROCEDURE
*
*           INP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN INTERNAL PROCEDURE AND GIVES
*           ITS TYPE AND NUMBER OF EXIT PARAMETERS. THE LABEL
*           CAN BE REFERENCED IN JSR INSTRUCTIONS AND
*           IT MUST APPEAR LABELLING A PRC INSTRUCTION IN THE
*           PROGRAM SECTION.
*
*      12.4 INR              DEFINE INTERNAL ROUTINE
*
*           INR DEFINES THE SYMBOL APPEARING IN THE LABEL
*           FIELD TO BE THE NAME OF AN INTERNAL ROUTINE. THE
*           LABEL MAY BE REFERENCED IN ANY TYPE OF BRANCH ORDER
*           AND IT MUST APPEAR LABELLING A RTN INSTRUCTION IN
*           THE PROGRAM SECTION.
{{EJC{{{{{2978
*
*      -13- ASSEMBLY LISTING LAYOUT INSTRUCTIONS
*
*      13.1 EJC              EJECT TO NEXT PAGE
*
*      13.2 TTL  TEXT        SET NEW ASSEMBLY TITLE
*
*           TTL IMPLIES AN IMMEDIATE EJECT OF THE
*           ASSEMBLY LISTING TO PRINT THE NEW TITLE.
*
*           THE USE OF TTL AND EJC CARDS IS SUCH THAT THE
*           PROGRAM WILL LIST NEATLY IF THE PRINTER PRINTS
*           AS MANY AS 58 LINES PER PAGE. IN THE EVENT THAT
*           THE PRINTER DEPTH IS LESS THAN THIS, OR IF THE
*           LISTING CONTAINS INTERSPERSED LINES (SUCH AS ACTUAL
*           GENERATED CODE), THEN THE FORMAT MAY BE UPSET.
*
*           LINES STARTING WITH AN ASTERISK ARE COMMENT LINES
*           WHICH CAUSE NO CODE TO BE GENERATED AND MAY OCCUR
*           FREELY ANYWHERE IN THE PROGRAM. THE FORMAT FOR
*           COMMENT LINES IS GIVEN IN SECTION -15-.
{{EJC{{{{{3000
*
*      -14- PROGRAM FORM
*
*           THE PROGRAM CONSISTS OF SEPARATE SECTIONS SEPARATED
*           BY SEC OPERATIONS. THE SECTIONS MUST APPEAR IN THE
*           FOLLOWING SPECIFIED ORDER.
*
*      14.1 SEC              START OF PROCEDURE SECTION
*
*           (PROCEDURE SECTION)
*
*           SEC               START OF DEFINITIONS SECTION
*
*           (DEFINITIONS SECTION)
*
*           SEC               START OF CONSTANT STORAGE SECTION
*
*           (CONSTANT STORAGE SECTION)
*
*           SEC               START OF WORKING STORAGE SECTION
*
*           (WORKING STORAGE SECTION)
*
*           SEC               START OF PROGRAM SECTION
*
*           (PROGRAM SECTION)
*
*           SEC               START OF STACK OVERFLOW SECTION
*
*           (STACK OVERFLOW SECTION)
*
*           SEC               START OF ERROR SECTION
*
*           (ERROR SECTION)
*
*      14.2 END              END OF ASSEMBLY
{{EJC{{{{{3037
*
*      SECTION 10 - PROGRAM FORM
*
*      PROCEDURE SECTION
*
*           THE PROCEDURE SECTION CONTAINS ALL THE EXP
*           INSTRUCTIONS FOR EXTERNALLY AVAILABLE PROCEDURES
*           AND INP,INR OPCODES FOR INTERNAL PROCEDURES,ROUTINES
*           SO THAT A SINGLE PASS MINIMAL TRANSLATOR HAS ADVANCE
*           KNOWLEDGE OF PROCEDURE TYPES WHEN TRANSLATING CALLS.
*
*      DEFINITIONS SECTION
*
*           THE DEFINITIONS SECTION CONTAINS EQU INSTRUCTIONS
*           WHICH DEFINE SYMBOLS REFERENCED LATER ON IN THE
*           PROGRAM, CONSTANT AND WORK SECTIONS.
*
*      CONSTANT STORAGE SECTION
*
*           THE CONSTANT STORAGE SECTION CONSISTS ENTIRELY
*           OF CONSTANTS ASSEMBLED WITH THE DAC,DIC,DRC,DTC,DBC
*           ASSEMBLY OPERATIONS. THESE CONSTANTS CAN BE FREELY
*           REFERENCED BY THE PROGRAM INSTRUCTIONS.
*
*      WORKING STORAGE SECTION
*
*           THE WORKING STORAGE SECTION CONSISTS ENTIRELY OF
*           DAC,DIC,DRC,DBC,DTC INSTRUCTIONS TO DEFINE A FIXED
*           LENGTH WORK AREA. THE WORK LOCATIONS IN THIS AREA
*           CAN BE DIRECTLY REFERENCED IN PROGRAM INSTRUCTIONS.
*           THE AREA IS INITIALIZED IN ACCORDANCE WITH THE
*           VALUES ASSEMBLED IN THE INSTRUCTIONS.
*
*      PROGRAM SECTION
*
*           THE PROGRAM SECTION CONTAINS PROGRAM INSTRUCTIONS
*           AND ASSOCIATED OPERATIONS (SUCH AS PRC, ENP, ENT).
*           CONTROL IS PASSED TO THE FIRST INSTRUCTION IN THIS
*           SECTION WHEN EXECUTION IS INITIATED.
*
*      STACK OVERFLOW SECTION
*
*           THE STACK OVERFLOW SECTION CONTAINS INSTRUCTIONS
*           LIKE THE PROGRAM SECTION. CONTROL IS PASSED TO THE
*           FIRST INSTRUCTION IN THIS SECTION FOLLOWING THE
*           OCCURRENCE OF STACK OVERFLOW, SEE CHK INSTRUCTION.
*
*      ERROR SECTION
*
*           THE ERROR SECTION CONTAINS INSTRUCTIONS LIKE THE
*           PROGRAM SECTION. CONTROL IS PASSED TO THE FIRST
*           INSTRUCTION IN THIS SECTION WHEN A PROCEDURE EXIT
*           CORRESPONDS TO AN ERROR PARAMETER (SEE ERR)
*           OR WHEN AN ERB OPCODE IS OBEYED. THE ERROR CODE
*           MUST CLEAN UP THE MAIN STACK AND CATER FOR THE
*           POSSIBILITY THAT A SUBROUTINE STACK MAY NEED CLEAN
*           UP.
{{EJC{{{{{3095
*      OSINT
*
*           THOUGH NOT PART OF THE MINIMAL SOURCE, IT IS USEFUL
*           TO REFER TO THE COLLECTION OF INITIALISATION AND
*           EXP ROUTINES AS OSINT (OPERATING SYSTEM INTERFACE).
*           ERRORS OCCURRING WITHIN OSINT PROCEDURES ARE
*           USUALLY HANDLED BY MAKING AN ERROR RETURN. IF THIS
*           IS NOT FEASIBLE OR APPROPRIATE, OSINT MAY USE THE
*           MINIMAL ERROR SECTION TO REPORT ERRORS DIRECTLY BY
*           BRANCHING TO IT WITH A SUITABLE NUMERIC ERROR
*           CODE IN WA.
{{EJC{{{{{3107
*
*      SECTION 11 - STATEMENT FORMAT
*
*      ALL LABELS ARE EXACTLY FIVE CHARACTERS LONG AND START
*      WITH THREE LETTERS (ABCDEFGHIJKLMNOPQRSTUVWXY$) FOLLOWED
*      BY TWO LETTERS OR DIGITS.
*      THE LETTER Z MAY NOT BE USED IN MINIMAL SYMBOLS BUT $ IS
*      PERMITTED.
*      FOR IMPLEMENTATIONS WHERE $ MAY NOT APPEAR IN THE
*      TARGET CODE , A SIMPLE SUBSTITUTION OF Z FOR $
*      MAY THUS BE MADE WITHOUT RISK OF PRODUCING NON-UNIQUE
*      SYMBOLS.
*      THE LETTER Z IS HOWEVER PERMITTED IN OPCODE MNEMONICS AND
*      IN COMMENTS.
*
*      MINIMAL STATEMENTS ARE IN A FIXED FORMAT AS FOLLOWS.
*
*      COLS 1-5              LABEL IF ANY (ELSE BLANK)
*
*      COLS 6-7              ALWAYS BLANK
*
*      COLS 8-10             OPERATION MNEMONIC
*
*      COLS 11-12            BLANKS
*
*      COLS 13-28            OPERAND FIELD, TERMINATED BY A
*                            BLANK. MAY OCCASIONALLY
*                            EXTEND PAST COLUMN 28.
*
*      COLS 30-64            COMMENT. ALWAYS SEPARATED FROM THE
*                            OPERAND FIELD BY AT LEAST ONE BLANK
*                            MAY OCCASIONALLY START AFTER COLUMN
*                            30 IF THE OPERAND EXTENDS PAST 28.
*                            A SPECIAL EXCEPTION OCCURS FOR THE
*                            IFF INSTRUCTION, WHOSE COMMENT MAY
*                            BE ONLY 20 CHARACTERS LONG (30-49).
*
*      COLS 65 ON            UNUSED
*
*
*      COMMENT LINES HAVE THE FOLLOWING FORMAT
*
*      COL 1                 ASTERISK
*
*      COLS 2-7              BLANK
*
*      COLS 8-64             ARBITRARY TEXT, RESTRICTED TO THE
*                            FORTRAN CHARACTER SET.
*
*
*      THE FORTRAN CHARACTER SET IS A-Z 0-9 =,$.(*)-/+
{{EJC{{{{{3159
*
*      SECTION 12 - PROGRAM EXECUTION
*
*      EXECUTION OF THE PROGRAM BEGINS WITH THE FIRST
*      INSTRUCTION IN THE PROGRAM SECTION.
*
*      IN ADDITION TO THE FIXED LENGTH MEMORY REGIONS DEFINED
*      BY THE ASSEMBLY, THERE ARE TWO DYNAMICALLY ALLOCATED
*      MEMORY REGIONS AS FOLLOWS.
*
*      DATA AREA             THIS IS AN AREA AVAILABLE TO THE
*                            PROGRAM FOR GENERAL STORAGE OF DATA
*                            ANY DATA VALUE MAY BE STORED IN
*                            THIS AREA EXCEPT INSTRUCTIONS.
*                            IN SOME IMPLEMENTATIONS, IT MAY BE
*                            POSSIBLE TO INCREASE THE SIZE OF
*                            THIS AREA DYNAMICALLY BY ADDING
*                            WORDS AT THE TOP END WITH A CALL
*                            TO A SYSTEM PROCEDURE.
*
*      STACK AREA            THIS REGION OF MEMORY HOLDS
*                            THE STACK USED FOR SUBROUTINE CALLS
*                            AND OTHER STORAGE OF ONE WORD
*                            INTEGER VALUES (ADDRESSES). THIS
*                            IS THE STACK ASSOCIATED WITH
*                            INDEX REGISTER XS.
*
*      THE LOCATIONS AND SIZES OF THESE AREAS ARE SPECIFIED
*      BY THE VALUES IN THE REGISTERS AT THE START OF PROGRAM
*      EXECUTION AS FOLLOWS.
*
*      (XS)                  ADDRESS ONE PAST THE STACK BASE.
*                            E.G. IF XS IS 23456, A D-STACK WILL
*                            OCCUPY WORDS 23455,23454,...
*                            WHEREAS A U-STACK WILL OCCUPY
*                            23457,23458,...
*
*      (XR)                  ADDRESS OF THE FIRST WORD
*                            IN THE DATA AREA
*
*      (XL)                  ADDRESS OF THE LAST WORD IN THE
*                            DATA AREA.
*
*      (WA)                  INITIAL STACK POINTER
*
*      (WB,WC,IA,RA,CP)      ZERO
*
*      THERE IS NO EXPLICIT WAY TO TERMINATE THE EXECUTION OF A
*      PROGRAM. THIS FUNCTION IS PERFORMED BY AN APPROPRIATE
*      SYSTEM PROCEDURE REFERENCED WITH THE SYSEJ INSTRUCTION.
{{TTL{27,S P I T B O L  -- BASIC INFORMATION{{{{3210
{{EJC{{{{{3211
*
*      GENERAL STRUCTURE
*      -----------------
*
*      THIS PROGRAM IS A TRANSLATOR FOR A VERSION OF THE SNOBOL4
*      PROGRAMMING LANGUAGE. LANGUAGE DETAILS ARE CONTAINED IN
*      THE MANUAL MACRO SPITBOL BY DEWAR AND MCCANN, TECHNICAL
*      REPORT 90, UNIVERSITY OF LEEDS 1976.
*      THE IMPLEMENTATION IS DISCUSSED IN DEWAR AND MCCANN,
*      MACRO SPITBOL - A SNOBOL4 COMPILER, SOFTWARE PRACTICE AND
*      EXPERIENCE, 7, 95-113, 1977.
*      THE LANGUAGE IS AS IMPLEMENTED BY THE BTL TRANSLATOR
*      (GRISWOLD, POAGE AND POLONSKY, PRENTICE HALL, 1971)
*      WITH THE FOLLOWING PRINCIPAL EXCEPTIONS.
*
*      1)   REDEFINITION OF STANDARD SYSTEM FUNCTIONS AND
*           OPERATORS IS NOT PERMITTED.
*
*      2)   THE VALUE FUNCTION IS NOT PROVIDED.
*
*      3)   ACCESS TRACING IS PROVIDED IN ADDITION TO THE
*           OTHER STANDARD TRACE MODES.
*
*      4)   THE KEYWORD STFCOUNT IS NOT PROVIDED.
*
*      5)   THE KEYWORD FULLSCAN IS NOT PROVIDED AND ALL PATTERN
*           MATCHING TAKES PLACE IN FULLSCAN MODE (I.E. WITH NO
*           HEURISTICS APPLIED).
*
*      6)   A SERIES OF EXPRESSIONS SEPARATED BY COMMAS MAY
*           BE GROUPED WITHIN PARENTHESES TO PROVIDE A SELECTION
*           CAPABILITY. THE SEMANTICS ARE THAT THE SELECTION
*           ASSUMES THE VALUE OF THE FIRST EXPRESSION WITHIN IT
*           WHICH SUCCEEDS AS THEY ARE EVALUATED FROM THE LEFT.
*           IF NO EXPRESSION SUCCEEDS THE ENTIRE STATEMENT FAILS
*
*      7)   AN EXPLICIT PATTERN MATCHING OPERATOR IS PROVIDED.
*           THIS IS THE BINARY QUERY (SEE GIMPEL SIGPLAN OCT 74)
*
*      8)   THE ASSIGNMENT OPERATOR IS INTRODUCED AS IN THE
*           GIMPEL REFERENCE.
*
*      9)   THE EXIT FUNCTION IS PROVIDED FOR GENERATING LOAD
*           MODULES - CF. GIMPELS SITBOL.
*
*
*      THE METHOD USED IN THIS PROGRAM IS TO TRANSLATE THE
*      SOURCE CODE INTO AN INTERNAL PSEUDO-CODE (SEE FOLLOWING
*      SECTION). AN INTERPRETOR IS THEN USED TO EXECUTE THIS
*      GENERATED PSEUDO-CODE. THE NATURE OF THE SNOBOL4 LANGUAGE
*      IS SUCH THAT THE LATTER TASK IS MUCH MORE COMPLEX THAN
*      THE ACTUAL TRANSLATION PHASE. ACCORDINGLY, NEARLY ALL THE
*      CODE IN THE PROGRAM SECTION IS CONCERNED WITH THE ACTUAL
*      EXECUTION OF THE SNOBOL4 PROGRAM.
{{EJC{{{{{3266
*
*      INTERPRETIVE CODE FORMAT
*      ------------------------
*
*      THE INTERPRETIVE PSEUDO-CODE CONSISTS OF A SERIES OF
*      ADDRESS POINTERS. THE EXACT FORMAT OF THE CODE IS
*      DESCRIBED IN CONNECTION WITH THE CDBLK FORMAT. THE
*      PURPOSE OF THIS SECTION IS TO GIVE GENERAL INSIGHT INTO
*      THE INTERPRETIVE APPROACH INVOLVED.
*
*      THE BASIC FORM OF THE CODE IS RELATED TO REVERSE POLISH.
*      IN OTHER WORDS, THE OPERANDS PRECEDE THE OPERATORS WHICH
*      ARE ZERO ADDRESS OPERATORS. THERE ARE SOME EXCEPTIONS TO
*      THESE RULES, NOTABLY THE UNARY NOT OPERATOR AND THE
*      SELECTION CONSTRUCTION WHICH CLEARLY REQUIRE ADVANCE
*      KNOWLEDGE OF THE OPERATOR INVOLVED.
*
*      THE OPERANDS ARE MOVED TO THE TOP OF THE MAIN STACK AND
*      THE OPERATORS ARE APPLIED TO THE TOP STACK ENTRIES. LIKE
*      OTHER VERSIONS OF SPITBOL, THIS PROCESSOR DEPENDS ON
*      KNOWING WHETHER OPERANDS ARE REQUIRED BY NAME OR BY VALUE
*      AND MOVES THE APPROPRIATE OBJECT TO THE STACK. THUS NO
*      NAME/VALUE CHECKS ARE INCLUDED IN THE OPERATOR CIRCUITS.
*
*      THE ACTUAL POINTERS IN THE CODE POINT TO A BLOCK WHOSE
*      FIRST WORD IS THE ADDRESS OF THE INTERPRETOR ROUTINE
*      TO BE EXECUTED FOR THE CODE WORD.
*
*      IN THE CASE OF OPERATORS, THE POINTER IS TO A WORD WHICH
*      CONTAINS THE ADDRESS OF THE OPERATOR TO BE EXECUTED. IN
*      THE CASE OF OPERANDS SUCH AS CONSTANTS, THE POINTER IS TO
*      THE OPERAND ITSELF. ACCORDINGLY, ALL OPERANDS CONTAIN
*      A FIELD WHICH POINTS TO THE ROUTINE TO LOAD THE VALUE OF
*      THE OPERAND ONTO THE STACK. IN THE CASE OF A VARIABLE,
*      THERE ARE THREE SUCH POINTERS. ONE TO LOAD THE VALUE,
*      ONE TO STORE THE VALUE AND A THIRD TO JUMP TO THE LABEL.
*
*      THE HANDLING OF FAILURE RETURNS DESERVES SPECIAL COMMENT.
*      THE LOCATION FLPTR CONTAINS THE POINTER TO THE LOCATION
*      ON THE MAIN STACK WHICH CONTAINS THE FAILURE RETURN
*      WHICH IS IN THE FORM OF A BYTE OFFSET IN THE CURRENT
*      CODE BLOCK (CDBLK OR EXBLK). WHEN A FAILURE OCCURS, THE
*      STACK IS POPPED AS INDICATED BY THE SETTING OF FLPTR AND
*      CONTROL IS PASSED TO THE APPROPRIATE LOCATION IN THE
*      CURRENT CODE BLOCK WITH THE STACK POINTER POINTING TO THE
*      FAILURE OFFSET ON THE STACK AND FLPTR UNCHANGED.
{{EJC{{{{{3313
*
*      INTERNAL DATA REPRESENTATIONS
*      -----------------------------
*
*      REPRESENTATION OF VALUES
*
*      A VALUE IS REPRESENTED BY A POINTER TO A BLOCK WHICH
*      DESCRIBES THE TYPE AND PARTICULARS OF THE DATA VALUE.
*      IN GENERAL, A VARIABLE IS A LOCATION CONTAINING SUCH A
*      POINTER (ALTHOUGH IN THE CASE OF TRACE ASSOCIATIONS THIS
*      IS MODIFIED, SEE DESCRIPTION OF TRBLK).
*
*      THE FOLLOWING IS A LIST OF POSSIBLE DATATYPES SHOWING THE
*      TYPE OF BLOCK USED TO HOLD THE VALUE. THE DETAILS OF
*      EACH BLOCK FORMAT ARE GIVEN LATER.
*
*      DATATYPE              BLOCK TYPE
*      --------              ----------
*
*      ARRAY                 ARBLK OR VCBLK
*
*      CODE                  CDBLK
*
*      EXPRESSION            EXBLK OR SEBLK
*
*      INTEGER               ICBLK
*
*      NAME                  NMBLK
*
*      PATTERN               P0BLK OR P1BLK OR P2BLK
*
*      REAL                  RCBLK
*
*      STRING                SCBLK
*
*      TABLE                 TBBLK
*
*      PROGRAM DATATYPE      PDBLK
{{EJC{{{{{3352
*
*      REPRESENTATION OF VARIABLES
*      ---------------------------
*
*      DURING THE COURSE OF EVALUATING EXPRESSIONS, IT IS
*      NECESSARY TO GENERATE NAMES OF VARIABLES (FOR EXAMPLE
*      ON THE LEFT SIDE OF A BINARY EQUALS OPERATOR). THESE ARE
*      NOT TO BE CONFUSED WITH OBJECTS OF DATATYPE NAME WHICH
*      ARE IN FACT VALUES.
*
*      FROM A LOGICAL POINT OF VIEW, SUCH NAMES COULD BE SIMPLY
*      REPRESENTED BY A POINTER TO THE APPROPRIATE VALUE CELL.
*      HOWEVER IN THE CASE OF ARRAYS AND PROGRAM DEFINED
*      DATATYPES, THIS WOULD VIOLATE THE RULE THAT THERE MUST BE
*      NO POINTERS INTO THE MIDDLE OF A BLOCK IN DYNAMIC STORE.
*      ACCORDINGLY, A NAME IS ALWAYS REPRESENTED BY A BASE AND
*      OFFSET. THE BASE POINTS TO THE START OF THE BLOCK
*      CONTAINING THE VARIABLE VALUE AND THE OFFSET IS THE
*      OFFSET WITHIN THIS BLOCK IN BYTES. THUS THE ADDRESS
*      OF THE ACTUAL VARIABLE IS DETERMINED BY ADDING THE BASE
*      AND OFFSET VALUES.
*
*      THE FOLLOWING ARE THE INSTANCES OF VARIABLES REPRESENTED
*      IN THIS MANNER.
*
*      1)   NATURAL VARIABLE BASE IS PTR TO VRBLK
*                            OFFSET IS *VRVAL
*
*      2)   TABLE ELEMENT    BASE IS PTR TO TEBLK
*                            OFFSET IS *TEVAL
*
*      3)   ARRAY ELEMENT    BASE IS PTR TO ARBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      4)   VECTOR ELEMENT   BASE IS PTR TO VCBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      5)   PROG DEF DTP     BASE IS PTR TO PDBLK
*                            OFFSET IS OFFSET TO FIELD VALUE
*
*      IN ADDITION THERE ARE TWO CASES OF OBJECTS WHICH ARE
*      LIKE VARIABLES BUT CANNOT BE HANDLED IN THIS MANNER.
*      THESE ARE CALLED PSEUDO-VARIABLES AND ARE REPRESENTED
*      WITH A SPECIAL BASE POINTER AS FOLLOWS=
*
*      EXPRESSION VARIABLE   PTR TO EVBLK (SEE EVBLK)
*
*      KEYWORD VARIABLE      PTR TO KVBLK (SEE KVBLK)
*
*      PSEUDO-VARIABLES ARE HANDLED AS SPECIAL CASES BY THE
*      ACCESS PROCEDURE (ACESS) AND THE ASSIGNMENT PROCEDURE
*      (ASIGN). SEE THESE TWO PROCEDURES FOR DETAILS.
{{EJC{{{{{3405
*
*      ORGANIZATION OF DATA AREA
*      -------------------------
*
*      THE DATA AREA IS DIVIDED INTO TWO REGIONS.
*
*      STATIC AREA
*
*      THE STATIC AREA BUILDS UP FROM THE BOTTOM AND CONTAINS
*      DATA AREAS WHICH ARE ALLOCATED DYNAMICALLY BUT ARE NEVER
*      DELETED OR MOVED AROUND. THE MACRO-PROGRAM ITSELF
*      USES THE STATIC AREA FOR THE FOLLOWING.
*
*      1)   ALL VARIABLE BLOCKS (VRBLK).
*
*      2)   THE HASH TABLE FOR VARIABLE BLOCKS.
*
*      3)   MISCELLANEOUS BUFFERS AND WORK AREAS (SEE PROGRAM
*           INITIALIZATION SECTION).
*
*      IN ADDITION, THE SYSTEM PROCEDURES MAY USE THIS AREA FOR
*      INPUT/OUTPUT BUFFERS, EXTERNAL FUNCTIONS ETC. SPACE IN
*      THE STATIC REGION IS ALLOCATED BY CALLING PROCEDURE ALOST
*
*      THE FOLLOWING GLOBAL VARIABLES DEFINE THE CURRENT
*      LOCATION AND SIZE OF THE STATIC AREA.
*
*      STATB                 ADDRESS OF START OF STATIC AREA
*      STATE                 ADDRESS+1 OF LAST WORD IN AREA.
*
*      THE MINIMUM SIZE OF STATIC IS GIVEN APPROXIMATELY BY
*           12 + *E$HNB + *E$STS + SPACE FOR ALPHABET STRING
*           AND STANDARD PRINT BUFFER.
{{EJC{{{{{3439
*      DYNAMIC AREA
*
*      THE DYNAMIC AREA IS BUILT UPWARDS IN MEMORY AFTER THE
*      STATIC REGION. DATA IN THIS AREA MUST ALL BE IN STANDARD
*      BLOCK FORMATS SO THAT IT CAN BE PROCESSED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL). GBCOL COMPACTS BLOCKS DOWN
*      IN THIS REGION AS REQUIRED BY SPACE EXHAUSTION AND CAN
*      ALSO MOVE ALL BLOCKS UP TO ALLOW FOR EXPANSION OF THE
*      STATIC REGION.
*      WITH THE EXCEPTION OF TABLES AND ARRAYS, NO SPITBOL
*      OBJECT ONCE BUILT IN DYNAMIC MEMORY IS EVER SUBSEQUENTLY
*      MODIFIED. OBSERVING THIS RULE NECESSITATES A COPYING
*      ACTION DURING STRING AND PATTERN CONCATENATION.
*
*      GARBAGE COLLECTION IS FUNDAMENTAL TO THE ALLOCATION OF
*      SPACE FOR VALUES. SPITBOL USES A VERY EFFICIENT GARBAGE
*      COLLECTOR WHICH INSISTS THAT POINTERS INTO DYNAMIC STORE
*      SHOULD BE IDENTIFIABLE WITHOUT USE OF BIT TABLES,
*      MARKER BITS ETC. TO SATISFY THIS REQUIREMENT, DYNAMIC
*      MEMORY MUST NOT START AT TOO LOW AN ADDRESS AND LENGTHS
*      OF ARRAYS, TABLES, STRINGS, CODE AND EXPRESSION BLOCKS
*      MAY NOT EXCEED THE NUMERICAL VALUE OF THE LOWEST DYNAMIC
*      ADDRESS.
*
*      TO AVOID EITHER PENALIZING USERS WITH MODEST
*      REQUIREMENTS OR RESTRICTING THOSE WITH GREATER NEEDS ON
*      HOST SYSTEMS WHERE DYNAMIC MEMORY IS ALLOCATED IN LOW
*      ADDRESSES, THE MINIMUM DYNAMIC ADDRESS MAY BE SPECIFIED
*      SUFFICIENTLY HIGH TO PERMIT ARBITRARILY LARGE SPITBOL
*      OBJECTS TO BE CREATED (WITH THE POSSIBILITY IN EXTREME
*      CASES OF WASTING LARGE AMOUNTS OF MEMORY BELOW THE
*      START ADDRESS). THIS MINIMUM VALUE IS MADE AVAILABLE
*      IN VARIABLE MXLEN BY A SYSTEM ROUTINE, SYSMX.
*      ALTERNATIVELY SYSMX MAY INDICATE THAT A
*      DEFAULT MAY BE USED IN WHICH DYNAMIC IS PLACED
*      AT THE LOWEST POSSIBLE ADDRESS FOLLOWING STATIC.
*
*      THE FOLLOWING GLOBAL WORK CELLS DEFINE THE LOCATION AND
*      LENGTH OF THE DYNAMIC AREA.
*
*      DNAMB                 START OF DYNAMIC AREA
*      DNAMP                 NEXT AVAILABLE LOCATION
*      DNAME                 LAST AVAILABLE LOCATION + 1
*
*      DNAMB IS ALWAYS HIGHER THAN STATE SINCE THE ALOST
*      PROCEDURE MAINTAINS SOME EXPANSION SPACE ABOVE STATE.
*      *** DNAMB MUST NEVER BE PERMITTED TO HAVE A VALUE LESS
*      THAN THAT IN MXLEN ***
*
*      SPACE IN THE DYNAMIC REGION IS ALLOCATED BY THE ALLOC
*      PROCEDURE. THE DYNAMIC REGION MAY BE USED BY SYSTEM
*      PROCEDURES PROVIDED THAT ALL THE RULES ARE OBEYED.
*      SOME OF THE RULES ARE SUBTLE SO IT IS PREFERABLE FOR
*      OSINT TO MANAGE ITS OWN MEMORY NEEDS. SPITBOL PROCS
*      OBEY RULES TO ENSURE THAT NO ACTION CAN CAUSE A GARBAGE
*      COLLECTION EXCEPT AT SUCH TIMES AS CONTENTS OF XL, XR
*      AND THE STACK ARE +CLEAN+ (SEE COMMENT BEFORE UTILITY
*      PROCEDURES AND IN GBCOL FOR MORE DETAIL). NOTE
*      THAT CALLS OF ALOST MAY CAUSE GARBAGE COLLECTION (SHIFT
*      OF MEMORY TO FREE SPACE). SPITBOL PROCS WHICH CALL
*      SYSTEM ROUTINES ASSUME THAT THEY CANNOT PRECIPITATE
*      COLLECTION AND THIS MUST BE RESPECTED.
{{EJC{{{{{3502
*
*      REGISTER USAGE
*      --------------
*
*      (CP)                  CODE POINTER REGISTER. USED TO
*                            HOLD A POINTER TO THE CURRENT
*                            LOCATION IN THE INTERPRETIVE PSEUDO
*                            CODE (I.E. PTR INTO A CDBLK).
*
*      (XL,XR)               GENERAL INDEX REGISTERS. USUALLY
*                            USED TO HOLD POINTERS TO BLOCKS IN
*                            DYNAMIC STORAGE. AN IMPORTANT
*                            RESTRICTION IS THAT THE VALUE IN
*                            XL MUST BE COLLECTABLE FOR
*                            A GARBAGE COLLECT CALL. A VALUE
*                            IS COLLECTABLE IF IT EITHER POINTS
*                            OUTSIDE THE DYNAMIC AREA, OR IF IT
*                            POINTS TO THE START OF A BLOCK IN
*                            THE DYNAMIC AREA.
*
*      (XS)                  STACK POINTER. USED TO POINT TO
*                            THE STACK FRONT. THE STACK MAY
*                            BUILD UP OR DOWN AND IS USED
*                            TO STACK SUBROUTINE RETURN POINTS
*                            AND OTHER RECURSIVELY SAVED DATA.
*
*      (XT)                  AN ALTERNATIVE NAME FOR XL DURING
*                            ITS USE IN ACCESSING STACKED ITEMS.
*
*      (WA,WB,WC)            GENERAL WORK REGISTERS. CANNOT BE
*                            USED FOR INDEXING, BUT MAY HOLD
*                            VARIOUS TYPES OF DATA.
*
*      (IA)                  USED FOR ALL SIGNED INTEGER
*                            ARITHMETIC, BOTH THAT USED BY THE
*                            TRANSLATOR AND THAT ARISING FROM
*                            USE OF SNOBOL4 ARITHMETIC OPERATORS
*
*      (RA)                  REAL ACCUMULATOR. USED FOR ALL
*                            FLOATING POINT ARITHMETIC.
{{EJC{{{{{3543
*
*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS
*      ------------------------------------
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*      .CAEX                 DEFINE TO ALLOW UP ARROW FOR EXPON.
*      .CAHT                 DEFINE TO INCLUDE HORIZONTAL TAB
*      .CASL                 DEFINE TO INCLUDE 26 SHIFTED LETTRS
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CGBC                 DEFINE TO INCLUDE SYSGC FUNCTION
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*      .CIOD                 DEFINE TO NOT USE DEFAULT DELIMITER
*                              IN PROCESSING 3RD ARG OF INPUT()
*                              AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNBF                 DEFINE TO OMIT BUFFER EXTENSION
*      .CNBT                 DEFINE TO OMIT BATCH INITIALISATION
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE FOR LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE TO NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*                            OMIT TO TAKE DEFAULT OF 50000
*      .CSAX                 DEFINE IF SYSAX IS TO BE CALLED
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSN8                 DEFINE TO PAD STMT NOS TO 8 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTET                 DEFINE TO TABLE ENTRY TRACE WANTED
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*      .CUCF                 DEFINE TO INCLUDE CFP$U
*      .CUEJ                 DEFINE TO SUPPRESS NEEDLESS EJECTS
*      .CULK                 DEFINE TO INCLUDE &L/UCASE KEYWORDS
*      .CULC                 DEFINE TO INCLUDE &CASE (LC NAMES)
*                            IF CUCL DEFINED, MUST SUPPORT
*                            MINIMAL OP FLC WREG THAT FOLDS
*                            ARGUMENT TO UPPER CASE
*      .CUST                 DEFINE TO INCLUDE SET() CODE
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL
*                            NOT DEFINED, A FULL COMMENT LINE
*                            INDICATES SYMBOL INITIALLY NOT
*                            DEFINED.
*
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*                            IN PROCESSING 3RD ARG OF INPUT()
*                            AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE TO LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE IF NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*
*      FORCE DEFINITION OF .CCMK IF .CCMC IS DEFINED
*
{{TTL{27,S P I T B O L -- PROCEDURES SECTION{{{{3670
*
*      THIS SECTION STARTS WITH DESCRIPTIONS OF THE OPERATING
*      SYSTEM DEPENDENT PROCEDURES WHICH ARE USED BY THE SPITBOL
*      TRANSLATOR. ALL SUCH PROCEDURES HAVE FIVE LETTER NAMES
*      BEGINNING WITH SYS. THEY ARE LISTED IN ALPHABETICAL
*      ORDER.
*      ALL PROCEDURES HAVE A  SPECIFICATION CONSISTING OF A
*      MODEL CALL, PRECEDED BY A POSSIBLY EMPTY LIST OF REGISTER
*      CONTENTS GIVING PARAMETERS AVAILABLE TO THE PROCEDURE AND
*      FOLLOWED BY A POSSIBLY EMPTY LIST OF REGISTER CONTENTS
*      REQUIRED ON RETURN FROM THE CALL OR WHICH MAY HAVE HAD
*      THEIR CONTENTS DESTROYED. ONLY THOSE REGISTERS EXPLICITLY
*      MENTIONED IN THE LIST AFTER THE CALL MAY HAVE THEIR
*      VALUES CHANGED.
*      THE SEGMENT OF CODE PROVIDING THE EXTERNAL PROCEDURES IS
*      CONVENIENTLY REFERRED TO AS OSINT (OPERATING SYSTEM
*      INTERFACE). THE SYSXX PROCEDURES IT CONTAINS PROVIDE
*      FACILITIES NOT USUALLY AVAILABLE AS PRIMITIVES IN
*      ASSEMBLY LANGUAGES. FOR PARTICULAR TARGET MACHINES,
*      IMPLEMENTORS MAY CHOOSE FOR SOME MINIMAL OPCODES WHICH
*      DO NOT HAVE REASONABLY DIRECT TRANSLATIONS, TO USE CALLS
*      OF ADDITIONAL PROCEDURES WHICH THEY PROVIDE IN OSINT.
*      E.G. MWB OR TRC MIGHT BE TRANSLATED AS JSR SYSMB,
*      JSR SYSTC IN SOME IMPLEMENTATIONS.
*
*      IN THE DESCRIPTIONS, REFERENCE IS MADE TO --BLK
*      FORMATS (-- = A PAIR OF LETTERS). SEE THE SPITBOL
*      DEFINITIONS SECTION FOR DETAILED DESCRIPTIONS OF ALL
*      SUCH BLOCK FORMATS EXCEPT FCBLK FOR WHICH SYSFC SHOULD
*      BE CONSULTED.
*
*      SECTION 0 CONTAINS INP,INR SPECIFICATIONS OF INTERNAL
*      PROCEDURES,ROUTINES. THIS GIVES A SINGLE PASS TRANSLATOR
*      INFORMATION MAKING IT EASY TO GENERATE ALTERNATIVE CALLS
*      IN THE TRANSLATION OF JSR-S FOR PROCEDURES OF DIFFERENT
*      TYPES IF THIS PROVES NECESSARY.
*
{{SEC{{{{START OF PROCEDURES SECTION{3708
{{EJC{{{{{3710
*
*      SYSAX -- AFTER EXECUTION
*
{SYSAX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3714
*
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CSAX IS DEFINED,
*      THIS ROUTINE IS CALLED IMMEDIATELY AFTER EXECUTION AND
*      BEFORE PRINTING OF EXECUTION STATISTICS OR DUMP OUTPUT.
*      PURPOSE OF CALL IS FOR IMPLEMENTOR TO DETERMINE AND
*      IF THE CALL IS NOT REQUIRED IT WILL BE OMITTED IF .CSAX
*      IS UNDEFINED. IN THIS CASE SYSAX NEED NOT BE CODED.
*
*      JSR  SYSAX            CALL AFTER EXECUTION
{{EJC{{{{{3726
*
*      SYSBS -- BACKSPACE FILE
*
{SYSBS{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3731
*
*      SYSBS IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION BACKSPACE
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CBSP IS DEFINED.
*      THE MEANING IS SYSTEM DEPENDENT.  IN GENERAL, BACKSPACE
*      REPOSITIONS THE FILE ONE RECORD CLOSER TO THE BEGINNING
*      OF FILE, SUCH THAT A SUBSEQUENT READ OR WRITE WILL
*      OPERATE ON THE PREVIOUS RECORD.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  BACKSPACE ARGUMENT (SCBLK PTR)
*      JSR  SYSBS            CALL TO BACKSPACE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF BACKSPACE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      BACKSPACE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      FILES ON CHARACTER DEVICES ARE IN THIS CATEGORY.
{{EJC{{{{{3751
*
*      SYSBX -- BEFORE EXECUTION
*
{SYSBX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3756
*
*      CALLED AFTER INITIAL SPITBOL COMPILATION AND BEFORE
*      COMMENCING EXECUTION IN CASE OSINT NEEDS
*      TO ASSIGN FILES OR PERFORM OTHER NECESSARY SERVICES.
*      OSINT MAY ALSO CHOOSE TO SEND A MESSAGE TO ONLINE
*      TERMINAL (IF ANY) INDICATING THAT EXECUTION IS STARTING.
*
*      JSR  SYSBX            CALL BEFORE EXECUTION STARTS
{{EJC{{{{{3765
*
*      SYSDC -- DATE CHECK
*
{SYSDC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3859
*
*      SYSDC IS CALLED TO CHECK THAT THE EXPIRY DATE FOR A TRIAL
*      VERSION OF SPITBOL IS UNEXPIRED.
*
*      JSR  SYSDC            CALL TO CHECK DATE
*      RETURN ONLY IF DATE IS OK
{{EJC{{{{{3866
*
*      SYSDM  -- DUMP CORE
*
{SYSDM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3870
*
*      SYSDM IS CALLED BY A SPITBOL PROGRAM CALL OF DUMP(N) WITH
*      N GE 4.  ITS PURPOSE IS TO PROVIDE A CORE DUMP.
*      N COULD HOLD AN ENCODING OF THE START ADRS FOR DUMP AND
*      AMOUNT TO BE DUMPED E.G.  N = 256*A + S , S = START ADRS
*      IN KILOWORDS,  A = KILOWORDS TO DUMP
*
*      (XR)                  PARAMETER N OF CALL DUMP(N)
*      JSR  SYSDM            CALL TO ENTER ROUTINE
{{EJC{{{{{3880
*
*      SYSDT -- GET CURRENT DATE
*
{SYSDT{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3884
*
*      SYSDT IS USED TO OBTAIN THE CURRENT DATE. THE DATE IS
*      RETURNED AS A CHARACTER STRING IN ANY FORMAT APPROPRIATE
*      TO THE OPERATING SYSTEM IN USE. IT MAY ALSO CONTAIN THE
*      CURRENT TIME OF DAY. SYSDT IS USED TO IMPLEMENT THE
*      SNOBOL4 FUNCTION DATE().
*
*      (XR)                  PARAMETER N OF CALL DATE(N)
*      JSR  SYSDT            CALL TO GET DATE
*      (XL)                  POINTER TO BLOCK CONTAINING DATE
*
*      THE FORMAT OF THE BLOCK IS LIKE AN SCBLK EXCEPT THAT
*      THE FIRST WORD NEED NOT BE SET. THE RESULT IS COPIED
*      INTO SPITBOL DYNAMIC MEMORY ON RETURN.
{{EJC{{{{{3900
*
*      SYSEA -- INFORM OSINT OF COMPILATION AND RUNTIME ERRORS
*
{SYSEA{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3904
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS ON
*      ERRORS
*
*      (WA)                  ERROR CODE
*      (WB)                  LINE NUMBER
*      (WC)                  COLUMN NUMBER
*      (XR)                  SYSTEM STAGE
*      (XL)                  FILE NAME (SCBLK)
*      JSR  SYSEA            CALL TO SYSEA FUNCTION
*      PPM  LOC              SUPPRESS PRINTING OF ERROR MESSAGE
*      (XR)                  MESSAGE TO PRINT (SCBLK) OR 0
*
*      SYSEA MAY NOT RETURN IF INTERFACE CHOOSES TO RETAIN
*      CONTROL.  CLOSING FILES VIA THE FCB CHAIN WILL BE THE
*      RESPONSIBILITY OF THE INTERFACE.
*
*      ALL REGISTERS PRESERVED
{{EJC{{{{{3926
*
*      SYSEF -- EJECT FILE
*
{SYSEF{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3930
*
*      SYSEF IS USED TO WRITE A PAGE EJECT TO A NAMED FILE. IT
*      MAY ONLY BE USED FOR FILES WHERE THIS CONCEPT MAKES
*      SENSE. NOTE THAT SYSEF IS NOT NORMALLY USED FOR THE
*      STANDARD OUTPUT FILE (SEE SYSEP).
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  EJECT ARGUMENT (SCBLK PTR)
*      JSR  SYSEF            CALL TO EJECT FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF INAPPROPRIATE FILE
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{3943
*
*      SYSEJ -- END OF JOB
*
{SYSEJ{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3947
*
*      SYSEJ IS CALLED ONCE AT THE END OF EXECUTION TO
*      TERMINATE THE RUN. THE SIGNIFICANCE OF THE ABEND AND
*      CODE VALUES IS SYSTEM DEPENDENT. IN GENERAL, THE CODE
*      VALUE SHOULD BE MADE AVAILABLE FOR TESTING, AND THE
*      ABEND VALUE SHOULD CAUSE SOME POST-MORTEM ACTION SUCH AS
*      A DUMP. NOTE THAT SYSEJ DOES NOT RETURN TO ITS CALLER.
*      SEE SYSXI FOR DETAILS OF FCBLK CHAIN
*
*      (WA)                  VALUE OF ABEND KEYWORD
*      (WB)                  VALUE OF CODE KEYWORD
*      (XL)                  O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSEJ            CALL TO END JOB
*
*      THE FOLLOWING SPECIAL VALUES ARE USED AS CODES IN (WB)
*      999  EXECUTION SUPPRESSED
*      998  STANDARD OUTPUT FILE FULL OR UNAVAILABLE IN A SYSXI
*           LOAD MODULE. IN THESE CASES (WA) CONTAINS THE NUMBER
*           OF THE STATEMENT CAUSING PREMATURE TERMINATION.
{{EJC{{{{{3967
*
*      SYSEM -- GET ERROR MESSAGE TEXT
*
{SYSEM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3971
*
*      SYSEM IS USED TO OBTAIN THE TEXT OF ERR, ERB CALLS IN THE
*      SOURCE PROGRAM GIVEN THE ERROR CODE NUMBER. IT IS ALLOWED
*      TO RETURN A NULL STRING IF THIS FACILITY IS UNAVAILABLE.
*
*      (WA)                  ERROR CODE NUMBER
*      JSR  SYSEM            CALL TO GET TEXT
*      (XR)                  TEXT OF MESSAGE
*
*      THE RETURNED VALUE IS A POINTER TO A BLOCK IN SCBLK
*      FORMAT EXCEPT THAT THE FIRST WORD NEED NOT BE SET. THE
*      STRING IS COPIED INTO DYNAMIC MEMORY ON RETURN.
*      IF THE NULL STRING IS RETURNED EITHER BECAUSE SYSEM DOES
*      NOT PROVIDE ERROR MESSAGE TEXTS OR BECAUSE WA IS OUT OF
*      RANGE, SPITBOL WILL PRINT THE STRING STORED IN ERRTEXT
*      KEYWORD.
{{EJC{{{{{3988
*
*      SYSEN -- ENDFILE
*
{SYSEN{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3992
*
*      SYSEN IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION ENDFILE.
*      THE MEANING IS SYSTEM DEPENDENT. IN GENERAL, ENDFILE
*      IMPLIES THAT NO FURTHER I/O OPERATIONS WILL BE PERFORMED,
*      BUT DOES NOT GUARANTEE THIS TO BE THE CASE. THE FILE
*      SHOULD BE CLOSED AFTER THE CALL, A SUBSEQUENT READ
*      OR WRITE MAY REOPEN THE FILE AT THE START OR IT MAY BE
*      NECESSARY TO REOPEN THE FILE VIA SYSIO.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  ENDFILE ARGUMENT (SCBLK PTR)
*      JSR  SYSEN            CALL TO ENDFILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF ENDFILE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      ENDFILE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      THAT THE STANDARD INPUT AND OUTPUT FILES ARE IN THIS
*      CATEGORY.
{{EJC{{{{{4014
*
*      SYSEP -- EJECT PRINTER PAGE
*
{SYSEP{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4018
*
*      SYSEP IS CALLED TO PERFORM A PAGE EJECT ON THE STANDARD
*      PRINTER OUTPUT FILE (CORRESPONDING TO SYSPR OUTPUT).
*
*      JSR  SYSEP            CALL TO EJECT PRINTER OUTPUT
{{EJC{{{{{4024
*
*      SYSEX -- CALL EXTERNAL FUNCTION
*
{SYSEX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4028
*
*      SYSEX IS CALLED TO PASS CONTROL TO AN EXTERNAL FUNCTION
*      PREVIOUSLY LOADED WITH A CALL TO SYSLD.
*
*      (XS)                  POINTER TO ARGUMENTS ON STACK
*      (XL)                  POINTER TO CONTROL BLOCK (EFBLK)
*      (WA)                  NUMBER OF ARGUMENTS ON STACK
*      JSR  SYSEX            CALL TO PASS CONTROL TO FUNCTION
*      PPM  LOC              RETURN HERE IF FUNCTION CALL FAILS
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      PPM  LOC              RETURN HERE IF BAD ARGUMENT TYPE
*      (XR)                  RESULT RETURNED
*
*      THE ARGUMENTS ARE STORED ON THE STACK WITH
*      THE LAST ARGUMENT AT 0(XS). ON RETURN, XS
*      IS POPPED PAST THE ARGUMENTS.
*
*      THE FORM OF THE ARGUMENTS AS PASSED IS THAT USED IN THE
*      SPITBOL TRANSLATOR (SEE DEFINITIONS AND DATA STRUCTURES
*      SECTION). THE CONTROL BLOCK FORMAT IS ALSO DESCRIBED
*      (UNDER EFBLK) IN THIS SECTION.
*
*      THERE ARE TWO WAYS OF RETURNING A RESULT.
*
*      1)   RETURN A POINTER TO A BLOCK IN DYNAMIC STORAGE. THIS
*           BLOCK MUST BE IN EXACTLY CORRECT FORMAT, INCLUDING
*           THE FIRST WORD. ONLY FUNCTIONS WRITTEN WITH INTIMATE
*           KNOWLEDGE OF THE SYSTEM WILL RETURN IN THIS WAY.
*
*      2)   STRING, INTEGER AND REAL RESULTS MAY BE RETURNED BY
*           POINTING TO A PSEUDO-BLOCK OUTSIDE DYNAMIC MEMORY.
*           THIS BLOCK IS IN ICBLK, RCBLK OR SCBLK FORMAT EXCEPT
*           THAT THE FIRST WORD WILL BE OVERWRITTEN
*           BY A TYPE WORD ON RETURN AND SO NEED NOT
*           BE CORRECTLY SET. SUCH A RESULT IS
*           COPIED INTO MAIN STORAGE BEFORE PROCEEDING.
*           UNCONVERTED RESULTS MAY SIMILARLY BE RETURNED IN A
*           PSEUDO-BLOCK WHICH IS IN CORRECT FORMAT INCLUDING
*           TYPE WORD RECOGNISABLE BY GARBAGE COLLECTOR SINCE
*           BLOCK IS COPIED INTO DYNAMIC MEMORY.
{{EJC{{{{{4073
*
*      SYSFC -- FILE CONTROL BLOCK ROUTINE
*
{SYSFC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4077
*
*      SEE ALSO SYSIO
*      INPUT AND OUTPUT HAVE 3 ARGUMENTS REFERRED TO AS SHOWN
*           INPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*           OUTPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*      FILE ARG1 MAY BE AN INTEGER OR STRING USED TO IDENTIFY
*      AN I/O CHANNEL. IT IS CONVERTED TO A STRING FOR CHECKING.
*      THE EXACT SIGNIFICANCE OF FILE ARG2
*      IS NOT RIGOROUSLY PRESCRIBED BUT TO IMPROVE PORTABILITY,
*      THE SCHEME DESCRIBED IN THE SPITBOL USER MANUAL
*      SHOULD BE ADOPTED WHEN POSSIBLE. THE PREFERRED FORM IS
*      A STRING $F$,R$R$,C$C$,I$I$,...,Z$Z$  WHERE
*      $F$ IS AN OPTIONAL FILE NAME WHICH IS PLACED FIRST.
*       REMAINING ITEMS MAY BE OMITTED OR INCLUDED IN ANY ORDER.
*      $R$ IS MAXIMUM RECORD LENGTH
*      $C$ IS A CARRIAGE CONTROL CHARACTER OR CHARACTER STRING
*      $I$ IS SOME FORM OF CHANNEL IDENTIFICATION USED IN THE
*         ABSENCE OF $F$ TO ASSOCIATE THE VARIABLE
*         WITH A FILE ALLOCATED DYNAMICALLY BY JCL COMMANDS AT
*         SPITBOL LOAD TIME.
*      ,...,Z$Z$ ARE ADDITIONAL FIELDS.
*      IF , (COMMA) CANNOT BE USED AS A DELIMITER, .CIOD
*      SHOULD BE DEFINED TO INTRODUCE BY CONDITIONAL ASSEMBLY
*      ANOTHER DELIMITER (SEE
*        IODEL  EQU  *
*      EARLY IN DEFINITIONS SECTION).
*      SYSFC IS CALLED WHEN A VARIABLE IS INPUT OR OUTPUT
*      ASSOCIATED TO CHECK FILE ARG1 AND FILE ARG2 AND
*      TO  REPORT WHETHER AN FCBLK (FILE CONTROL
*      BLOCK) IS NECESSARY AND IF SO WHAT SIZE IT SHOULD BE.
*      THIS MAKES IT POSSIBLE FOR SPITBOL RATHER THAN OSINT TO
*      ALLOCATE SUCH A BLOCK IN DYNAMIC MEMORY IF REQUIRED
*      OR ALTERNATIVELY IN STATIC MEMORY.
*      THE SIGNIFICANCE OF AN FCBLK , IF ONE IS REQUESTED, IS
*      ENTIRELY UP TO THE SYSTEM INTERFACE. THE ONLY RESTRICTION
*      IS THAT IF THE FCBLK SHOULD APPEAR TO LIE IN DYNAMIC
*      MEMORY, POINTERS TO IT SHOULD BE PROPER POINTERS TO
*      THE START OF A RECOGNISABLE AND GARBAGE COLLECTABLE
*      BLOCK (THIS CONDITION WILL BE MET IF SYSFC REQUESTS
*      SPITBOL TO PROVIDE AN FCBLK).
*      AN OPTION IS PROVIDED FOR OSINT TO RETURN A POINTER IN
*      XL TO AN FCBLK WHICH IT PRIVATELY ALLOCATED. THIS PTR
*      WILL BE MADE AVAILABLE WHEN I/O OCCURS LATER.
*      PRIVATE FCBLKS MAY HAVE ARBITRARY CONTENTS AND SPITBOL
*      STORES NOTHING IN THEM.
{{EJC{{{{{4123
*      THE REQUESTED SIZE FOR AN FCBLK IN DYNAMIC MEMORY
*      SHOULD ALLOW A 2 WORD OVERHEAD FOR BLOCK TYPE AND
*      LENGTH FIELDS. INFORMATION SUBSEQUENTLY STORED IN THE
*      REMAINING WORDS MAY BE ARBITRARY IF AN XNBLK (EXTERNAL
*      NON-RELOCATABLE BLOCK) IS REQUESTED. IF THE REQUEST IS
*      FOR AN XRBLK (EXTERNAL RELOCATABLE BLOCK) THE
*      CONTENTS OF WORDS SHOULD BE COLLECTABLE (I.E. ANY
*      APPARENT POINTERS INTO DYNAMIC SHOULD BE GENUINE BLOCK
*      POINTERS). THESE RESTRICTIONS DO NOT APPLY IF AN FCBLK
*      IS ALLOCATED OUTSIDE DYNAMIC OR IS NOT ALLOCATED AT ALL.
*      IF AN FCBLK IS REQUESTED, ITS FIELDS WILL BE INITIALISED
*      TO ZERO BEFORE ENTRY TO SYSIO WITH THE EXCEPTION OF
*      WORDS 0 AND 1 IN WHICH THE BLOCK TYPE AND LENGTH
*      FIELDS ARE PLACED FOR FCBLKS IN DYNAMIC MEMORY ONLY.
*      FOR THE POSSIBLE USE OF SYSEJ AND SYSXI, IF FCBLKS
*      ARE USED, A CHAIN IS BUILT SO THAT THEY MAY ALL BE
*      FOUND - SEE SYSXI FOR DETAILS.
*      IF BOTH FILE ARG1 AND FILE ARG2 ARE NULL, CALLS OF SYSFC
*      AND SYSIO ARE OMITTED.
*      IF FILE ARG1 IS NULL (STANDARD INPUT/OUTPUT FILE), SYSFC
*      IS CALLED TO CHECK NON-NULL FILE ARG2 BUT ANY REQUEST
*      FOR AN FCBLK WILL BE IGNORED, SINCE SPITBOL HANDLES THE
*      STANDARD FILES SPECIALLY AND CANNOT READILY KEEP FCBLK
*      POINTERS FOR THEM.
*      FILEARG1 IS TYPE CHECKED BY SPITBOL SO FURTHER CHECKING
*      MAY BE UNNECCESSARY IN MANY IMPLEMENTATIONS.
*      FILE ARG2 IS PASSED SO THAT SYSFC MAY ANALYSE AND
*      CHECK IT. HOWEVER TO ASSIST IN THIS, SPITBOL ALSO PASSES
*      ON THE STACK THE COMPONENTS OF THIS ARGUMENT WITH
*      FILE NAME, $F$ (OTHERWISE NULL) EXTRACTED AND STACKED
*      FIRST.
*      THE OTHER FIELDS, IF ANY, ARE EXTRACTED AS SUBSTRINGS,
*      POINTERS TO THEM ARE STACKED AND A COUNT OF ALL ITEMS
*      STACKED IS PLACED IN WC. IF AN FCBLK WAS EARLIER
*      ALLOCATED AND POINTED TO VIA FILE ARG1, SYSFC IS ALSO
*      PASSED A POINTER TO THIS FCBLK.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILEARG2 (3RD ARG) OR NULL
*      -(XS)...-(XS)         SCBLKS FOR $F$,$R$,$C$,...
*      (WC)                  NO. OF STACKED SCBLKS ABOVE
*      (WA)                  EXISTING FILE ARG1 FCBLK PTR OR 0
*      (WB)                  0/3 FOR INPUT/OUTPUT ASSOCN
*      JSR  SYSFC            CALL TO CHECK NEED FOR FCBLK
*      PPM  LOC              INVALID FILE ARGUMENT
*      PPM  LOC              FCBLK ALREADY IN USE
*      (XS)                  POPPED (WC) TIMES
*      (WA NON ZERO)         BYTE SIZE OF REQUESTED FCBLK
*      (WA=0,XL NON ZERO)    PRIVATE FCBLK PTR IN XL
*      (WA=XL=0)             NO FCBLK WANTED, NO PRIVATE FCBLK
*      (WC)                  0/1/2 REQUEST ALLOC OF XRBLK/XNBLK
*                            /STATIC BLOCK FOR USE AS FCBLK
*      (WB)                  DESTROYED
{{EJC{{{{{4178
*
*      SYSGC -- INFORM INTERFACE OF GARBAGE COLLECTIONS
*
{SYSGC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4182
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS
*      PRIOR TO AND AFTER A GARBAGE COLLECTION.
*
*      POSSIBLE USAGES-
*      1. PROVIDE VISIBLE SCREEN ICON OF GARBAGE COLLECTION
*         IN PROGRESS
*      2. INFORM VIRTUAL MEMORY MANAGER TO IGNORE PAGE ACCESS
*         PATTERNS DURING GARBAGE COLLECTION.  SUCH ACCESSES
*         TYPICALLY DESTROY THE PAGE WORKING SET ACCUMULATED
*         BY THE PROGRAM.
*      3. INFORM VIRTUAL MEMORY MANAGER THAT CONTENTS OF MEMORY
*         FREED BY GARBAGE COLLECTION CAN BE DISCARDED.
*
*      (XR)                  NON-ZERO IF BEGINNING GC
*                            =0 IF COMPLETING GC
*      (WA)                  DNAMB=START OF DYNAMIC AREA
*      (WB)                  DNAMP=NEXT AVAILABLE LOCATION
*      (WC)                  DNAME=LAST AVAILABLE LOCATION + 1
*      JSR  SYSGC            CALL TO SYSGC FUNCTION
*      ALL REGISTERS PRESERVED
{{EJC{{{{{4206
*
*      SYSHS -- GIVE ACCESS TO HOST COMPUTER FEATURES
*
{SYSHS{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4210
*
*      PROVIDES MEANS FOR IMPLEMENTING SPECIAL FEATURES
*      ON DIFFERENT HOST COMPUTERS. THE ONLY DEFINED ENTRY IS
*      THAT WHERE ALL ARGUMENTS ARE NULL IN WHICH CASE SYSHS
*      RETURNS AN SCBLK CONTAINING NAME OF COMPUTER,
*      NAME OF OPERATING SYSTEM AND NAME OF SITE SEPARATED BY
*      COLONS. THE SCBLK NEED NOT HAVE A CORRECT FIRST FIELD
*      AS THIS IS SUPPLIED ON COPYING STRING TO DYNAMIC MEMORY.
*      SPITBOL DOES NO ARGUMENT CHECKING BUT DOES PROVIDE A
*      SINGLE ERROR RETURN FOR ARGUMENTS CHECKED AS ERRONEOUS
*      BY OSINT. IT ALSO PROVIDES A SINGLE EXECUTION ERROR
*      RETURN. IF THESE ARE INADEQUATE, USE MAY BE MADE OF THE
*      MINIMAL ERROR SECTION DIRECT AS DESCRIBED IN MINIMAL
*      DOCUMENTATION, SECTION 10.
*      SEVERAL NON-ERROR RETURNS ARE PROVIDED. THE FIRST
*      CORRESPONDS TO THE DEFINED ENTRY OR, FOR IMPLEMENTATION
*      DEFINED ENTRIES, ANY STRING MAY BE RETURNED. THE OTHERS
*      PERMIT RESPECTIVELY,  RETURN A NULL RESULT, RETURN WITH A
*      RESULT TO BE STACKED WHICH IS POINTED AT BY XR, AND A
*      RETURN CAUSING SPITBOL STATEMENT FAILURE. IF A RETURNED
*      RESULT IS IN DYNAMIC MEMORY IT MUST OBEY GARBAGE
*      COLLECTOR RULES. THE ONLY RESULTS COPIED ON RETURN
*      ARE STRINGS RETURNED VIA PPM LOC3 RETURN.
*
*      (WA)                  ARGUMENT 1
*      (XL)                  ARGUMENT 2
*      (XR)                  ARGUMENT 3
*      (WB)                  ARGUMENT 4
*      (WC)                  ARGUMENT 5
*      JSR  SYSHS            CALL TO GET HOST INFORMATION
*      PPM  LOC1             ERRONEOUS ARG
*      PPM  LOC2             EXECUTION ERROR
*      PPM  LOC3             SCBLK PTR IN XL OR 0 IF UNAVAILABLE
*      PPM  LOC4             RETURN A NULL RESULT
*      PPM  LOC5             RETURN RESULT IN XR
*      PPM  LOC6             CAUSE STATEMENT FAILURE
*      PPM  LOC7             RETURN STRING AT XL, LENGTH WA
*      PPM  LOC8             RETURN COPY OF RESULT IN XR
{{EJC{{{{{4249
*
*      SYSID -- RETURN SYSTEM IDENTIFICATION
*
{SYSID{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4253
*
*      THIS ROUTINE SHOULD RETURN STRINGS TO HEAD THE STANDARD
*      PRINTER OUTPUT. THE FIRST STRING WILL BE APPENDED TO
*      A HEADING LINE OF THE FORM
*           MACRO SPITBOL VERSION V.V
*      SUPPLIED BY SPITBOL ITSELF. V.V ARE DIGITS GIVING THE
*      MAJOR VERSION NUMBER AND GENERALLY AT LEAST A MINOR
*      VERSION NUMBER RELATING TO OSINT SHOULD BE SUPPLIED TO
*      GIVE SAY
*           MACRO SPITBOL VERSION V.V(M.M)
*      THE SECOND STRING SHOULD IDENTIFY AT LEAST THE MACHINE
*      AND OPERATING SYSTEM.  PREFERABLY IT SHOULD INCLUDE
*      THE DATE AND TIME OF THE RUN.
*      OPTIONALLY THE STRINGS MAY INCLUDE SITE NAME OF THE
*      THE IMPLEMENTOR AND/OR MACHINE ON WHICH RUN TAKES PLACE,
*      UNIQUE SITE OR COPY NUMBER AND OTHER INFORMATION AS
*      APPROPRIATE WITHOUT MAKING IT SO LONG AS TO BE A
*      NUISANCE TO USERS.
*      THE FIRST WORDS OF THE SCBLKS POINTED AT NEED NOT BE
*      CORRECTLY SET.
*
*      JSR  SYSID            CALL FOR SYSTEM IDENTIFICATION
*      (XR)                  SCBLK PTR FOR ADDITION TO HEADER
*      (XL)                  SCBLK PTR FOR SECOND HEADER
{{EJC{{{{{4278
*
*      SYSIF -- SWITCH TO NEW INCLUDE FILE
*
{SYSIF{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4283
*
*      SYSIF IS USED FOR INCLUDE FILE PROCESSING, BOTH TO INFORM
*      THE INTERFACE WHEN A NEW INCLUDE FILE IS DESIRED, AND
*      WHEN THE END OF FILE OF AN INCLUDE FILE HAS BEEN REACHED
*      AND IT IS DESIRED TO RETURN TO READING FROM THE PREVIOUS
*      NESTED FILE.
*
*      IT IS THE RESPONSIBILITY OF SYSIF TO REMEMBER THE FILE
*      ACCESS PATH TO THE PRESENT INPUT FILE BEFORE SWITCHING TO
*      THE NEW INCLUDE FILE.
*
*      (XL)                  PTR TO SCBLK OR ZERO
*      (XR)                  PTR TO VACANT SCBLK OF LENGTH CSWIN
*                            (XR NOT USED IF XL IS ZERO)
*      JSR  SYSIF            CALL TO CHANGE FILES
*      PPM  LOC              UNABLE TO OPEN FILE
*      (XR)                  SCBLK WITH FULL PATH NAME OF FILE
*                            (XR NOT USED IF INPUT XL IS ZERO)
*
*      REGISTER XL POINTS TO AN SCBLK CONTAINING THE NAME OF THE
*      INCLUDE FILE TO WHICH THE INTERFACE SHOULD SWITCH.  DATA
*      IS FETCHED FROM THE FILE UPON THE NEXT CALL TO SYSRD.
*
*      SYSIF MAY HAVE THE ABILITY TO SEARCH MULTIPLE LIBRARIES
*      FOR THE INCLUDE FILE NAMED IN (XL).  IT IS THEREFORE
*      REQUIRED THAT THE FULL PATH NAME OF THE FILE WHERE THE
*      FILE WAS FINALLY LOCATED BE RETURNED IN (XR).  IT IS THIS
*      NAME THAT IS RECORDED ALONG WITH THE SOURCE STATEMENTS,
*      AND WILL ACCOMPANY SUBSEQUENT ERROR MESSAGES.
*
*      REGISTER XL IS ZERO TO MARK CONCLUSION OF USE OF AN
*      INCLUDE FILE.
{{EJC{{{{{4316
*
*      SYSIL -- GET INPUT RECORD LENGTH
*
{SYSIL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4321
*
*      SYSIL IS USED TO GET THE LENGTH OF THE NEXT INPUT RECORD
*      FROM A FILE PREVIOUSLY INPUT ASSOCIATED WITH A SYSIO
*      CALL. THE LENGTH RETURNED IS USED TO ESTABLISH A BUFFER
*      FOR A SUBSEQUENT SYSIN CALL.  SYSIL ALSO INDICATES TO THE
*      CALLER IF THIS IS A BINARY OR TEXT FILE.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      JSR  SYSIL            CALL TO GET RECORD LENGTH
*      (WA)                  LENGTH OR ZERO IF FILE CLOSED
*      (WC)                  ZERO IF BINARY, NON-ZERO IF TEXT
*
*      NO HARM IS DONE IF THE VALUE RETURNED IS TOO LONG SINCE
*      UNUSED SPACE WILL BE RECLAIMED AFTER THE SYSIN CALL.
*
*      NOTE THAT IT IS THE SYSIL CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD INPUT FROM THE FILE.
{{EJC{{{{{4340
*
*      SYSIN -- READ INPUT RECORD
*
{SYSIN{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4344
*
*      SYSIN IS USED TO READ A RECORD FROM THE FILE WHICH WAS
*      REFERENCED IN A PRIOR CALL TO SYSIL (I.E. THESE CALLS
*      ALWAYS OCCUR IN PAIRS). THE BUFFER PROVIDED IS AN
*      SCBLK FOR A STRING OF LENGTH SET FROM THE SYSIL CALL.
*      IF THE ACTUAL LENGTH READ IS LESS THAN THIS, THE LENGTH
*      FIELD OF THE SCBLK MUST BE MODIFIED BEFORE RETURNING
*      UNLESS BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE ANY OF THE ALTERNATIVE
*      RETURNS AFTER SCBLK LENGTH HAS BEEN MODIFIED.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      JSR  SYSIN            CALL TO READ RECORD
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF RECORD FORMAT ERROR
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{4363
*
*      SYSIO -- INPUT/OUTPUT FILE ASSOCIATION
*
{SYSIO{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4367
*
*      SEE ALSO SYSFC.
*      SYSIO IS CALLED IN RESPONSE TO A SNOBOL4 INPUT OR OUTPUT
*      FUNCTION CALL EXCEPT WHEN FILE ARG1 AND FILE ARG2
*      ARE BOTH NULL.
*      ITS CALL ALWAYS FOLLOWS IMMEDIATELY AFTER A CALL
*      OF SYSFC. IF SYSFC REQUESTED ALLOCATION
*      OF AN FCBLK, ITS ADDRESS WILL BE IN WA.
*      FOR INPUT FILES, NON-ZERO VALUES OF $R$ SHOULD BE
*      COPIED TO WC FOR USE IN ALLOCATING INPUT BUFFERS. IF $R$
*      IS DEFAULTED OR NOT IMPLEMENTED, WC SHOULD BE ZEROISED.
*      ONCE A FILE HAS BEEN OPENED, SUBSEQUENT INPUT(),OUTPUT()
*      CALLS IN WHICH THE SECOND ARGUMENT IS IDENTICAL WITH THAT
*      IN A PREVIOUS CALL, MERELY ASSOCIATE THE ADDITIONAL
*      VARIABLE NAME (FIRST ARGUMENT) TO THE FILE AND DO NOT
*      RESULT IN RE-OPENING THE FILE.
*      IN SUBSEQUENT ASSOCIATED ACCESSES TO THE FILE A POINTER
*      TO ANY FCBLK ALLOCATED WILL BE MADE AVAILABLE.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILE ARG2 SCBLK PTR (3RD ARG)
*      (WA)                  FCBLK PTR (0 IF NONE)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT
*      JSR  SYSIO            CALL TO ASSOCIATE FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN IF INPUT/OUTPUT NOT ALLOWED
*      (XL)                  FCBLK POINTER (0 IF NONE)
*      (WC)                  0 (FOR DEFAULT) OR MAX RECORD LNGTH
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED IF THE FILE NAMED EXISTS
*      BUT INPUT/OUTPUT FROM THE FILE IS NOT ALLOWED. FOR
*      EXAMPLE, THE STANDARD OUTPUT FILE MAY BE IN THIS CATEGORY
*      AS REGARDS INPUT ASSOCIATION.
{{EJC{{{{{4402
*
*      SYSLD -- LOAD EXTERNAL FUNCTION
*
{SYSLD{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4406
*
*      SYSLD IS CALLED IN RESPONSE TO THE USE OF THE SNOBOL4
*      LOAD FUNCTION. THE NAMED FUNCTION IS LOADED (WHATEVER
*      THIS MEANS), AND A POINTER IS RETURNED. THE POINTER WILL
*      BE USED ON SUBSEQUENT CALLS TO THE FUNCTION (SEE SYSEX).
*
*      (XR)                  POINTER TO FUNCTION NAME (SCBLK)
*      (XL)                  POINTER TO LIBRARY NAME (SCBLK)
*      JSR  SYSLD            CALL TO LOAD FUNCTION
*      PPM  LOC              RETURN HERE IF FUNC DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      (XR)                  POINTER TO LOADED CODE
*
*      THE SIGNIFICANCE OF THE POINTER RETURNED IS UP TO THE
*      SYSTEM INTERFACE ROUTINE. THE ONLY RESTRICTION IS THAT
*      IF THE POINTER IS WITHIN DYNAMIC STORAGE, IT MUST BE
*      A PROPER BLOCK POINTER.
{{EJC{{{{{4425
*
*      SYSMM -- GET MORE MEMORY
*
{SYSMM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4429
*
*      SYSMM IS CALLED IN AN ATTEMPT TO ALLOCATE MORE DYNAMIC
*      MEMORY. THIS MEMORY MUST BE ALLOCATED CONTIGUOUSLY WITH
*      THE CURRENT DYNAMIC DATA AREA.
*
*      THE AMOUNT ALLOCATED IS UP TO THE SYSTEM TO DECIDE. ANY
*      VALUE IS ACCEPTABLE INCLUDING ZERO IF ALLOCATION IS
*      IMPOSSIBLE.
*
*      JSR  SYSMM            CALL TO GET MORE MEMORY
*      (XR)                  NUMBER OF ADDITIONAL WORDS OBTAINED
{{EJC{{{{{4441
*
*      SYSMX -- SUPPLY MXLEN
*
{SYSMX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4445
*
*      BECAUSE OF THE METHOD OF GARBAGE COLLECTION, NO SPITBOL
*      OBJECT IS ALLOWED TO OCCUPY MORE BYTES OF MEMORY THAN
*      THE INTEGER GIVING THE LOWEST ADDRESS OF DYNAMIC
*      (GARBAGE COLLECTABLE) MEMORY. MXLEN IS THE NAME USED TO
*      REFER TO THIS MAXIMUM LENGTH OF AN OBJECT AND FOR MOST
*      USERS OF MOST IMPLEMENTATIONS, PROVIDED DYNAMIC MEMORY
*      STARTS AT AN ADDRESS OF AT LEAST A FEW THOUSAND WORDS,
*      THERE IS NO PROBLEM.
*      IF THE DEFAULT STARTING ADDRESS IS LESS THAN SAY 10000 OR
*      20000, THEN A LOAD TIME OPTION SHOULD BE PROVIDED WHERE A
*      USER CAN REQUEST THAT HE BE ABLE TO CREATE LARGER
*      OBJECTS. THIS ROUTINE INFORMS SPITBOL OF THIS REQUEST IF
*      ANY. THE VALUE RETURNED IS EITHER AN INTEGER
*      REPRESENTING THE DESIRED VALUE OF MXLEN (AND HENCE THE
*      MINIMUM DYNAMIC STORE ADDRESS WHICH MAY RESULT IN
*      NON-USE OF SOME STORE) OR ZERO IF A DEFAULT IS ACCEPTABLE
*      IN WHICH MXLEN IS SET TO THE LOWEST ADDRESS ALLOCATED
*      TO DYNAMIC STORE BEFORE COMPILATION STARTS.
*      IF A NON-ZERO VALUE IS RETURNED, THIS IS USED FOR KEYWORD
*      MAXLNGTH. OTHERWISE THE INITIAL LOW ADDRESS OF DYNAMIC
*      MEMORY IS USED FOR THIS KEYWORD.
*
*      JSR  SYSMX            CALL TO GET MXLEN
*      (WA)                  EITHER MXLEN OR 0 FOR DEFAULT
{{EJC{{{{{4471
*
*      SYSOU -- OUTPUT RECORD
*
{SYSOU{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4475
*
*      SYSOU IS USED TO WRITE A RECORD TO A FILE PREVIOUSLY
*      ASSOCIATED WITH A SYSIO CALL.
*
*      (WA)                  PTR TO FCBLK
*                            OR 0 FOR TERMINAL OR 1 FOR OUTPUT
*      (XR)                  RECORD TO BE WRITTEN (SCBLK)
*      JSR  SYSOU            CALL TO OUTPUT RECORD
*      PPM  LOC              FILE FULL OR NO FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT IT IS THE SYSOU CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD OUTPUT TO THE FILE.
{{EJC{{{{{4497
*
*      SYSPI -- PRINT ON INTERACTIVE CHANNEL
*
{SYSPI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4501
*
*      IF SPITBOL IS RUN FROM AN ONLINE TERMINAL, OSINT CAN
*      REQUEST THAT MESSAGES SUCH AS COPIES OF COMPILATION
*      ERRORS BE SENT TO THE TERMINAL (SEE SYSPP). IF RELEVANT
*      REPLY WAS MADE BY SYSPP THEN SYSPI IS CALLED TO SEND SUCH
*      MESSAGES TO THE INTERACTIVE CHANNEL.
*      SYSPI IS ALSO USED FOR SENDING OUTPUT TO THE TERMINAL
*      THROUGH THE SPECIAL VARIABLE NAME, TERMINAL.
*
*      (XR)                  PTR TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPI            CALL TO PRINT LINE
*      PPM  LOC              FAILURE RETURN
*      (WA,WB)               DESTROYED
{{EJC{{{{{4517
*
*      SYSPL -- PROVIDE INTERACTIVE CONTROL OF SPITBOL
*
{SYSPL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4521
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS,
*      SUCH AS INTERRUPTING EXECUTION, BREAKPOINTING, STEPPING,
*      AND EXPRESSION EVALUATION.  THESE LAST THREE OPTIONS ARE
*      NOT PRESENTLY IMPLEMENTED BY THE CODE CALLING SYSPL.
*
*
*      (WA)                  OPCODE AS FOLLOWS-
*                            =0 POLL TO ALLOW OSINT TO INTERRUPT
*                            =1 BREAKPOINT HIT
*                            =2 COMPLETION OF STATEMENT STEPPING
*                            =3 EXPRESSION EVALUATION RESULT
*      (WB)                  STATEMENT NUMBER
*      R$FCB                 O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSPL            CALL TO SYSPL FUNCTION
*      PPM  LOC              USER INTERRUPTION
*      PPM  LOC              STEP ONE STATEMENT
*      PPM  LOC              EVALUATE EXPRESSION
*      ---                   RESUME EXECUTION
*                            (WA) = NEW POLLING INTERVAL
*
{{EJC{{{{{4544
*
*      SYSPP -- OBTAIN PRINT PARAMETERS
*
{SYSPP{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4548
*
*      SYSPP IS CALLED ONCE DURING COMPILATION TO OBTAIN
*      PARAMETERS REQUIRED FOR CORRECT PRINTED OUTPUT FORMAT
*      AND TO SELECT OTHER OPTIONS. IT MAY ALSO BE CALLED AGAIN
*      AFTER SYSXI WHEN A LOAD MODULE IS RESUMED. IN THIS
*      CASE THE VALUE RETURNED IN WA MAY BE LESS THAN OR EQUAL
*      TO THAT RETURNED IN INITIAL CALL BUT MAY NOT BE
*      GREATER.
*      THE INFORMATION RETURNED IS -
*      1.   LINE LENGTH IN CHARS FOR STANDARD PRINT FILE
*      2.   NO OF LINES/PAGE. 0 IS PREFERABLE FOR A NON-PAGED
*           DEVICE (E.G. ONLINE TERMINAL) IN WHICH CASE LISTING
*           PAGE THROWS ARE SUPPRESSED AND PAGE HEADERS
*           RESULTING FROM -TITLE,-STITL LINES ARE KEPT SHORT.
*      3.   AN INITIAL -NOLIST OPTION TO SUPPRESS LISTING UNLESS
*           THE PROGRAM CONTAINS AN EXPLICIT -LIST.
*      4.   OPTIONS TO SUPPRESS LISTING OF COMPILATION AND/OR
*           EXECUTION STATS (USEFUL FOR ESTABLISHED PROGRAMS) -
*           COMBINED WITH 3. GIVES POSSIBILITY OF LISTING
*           FILE NEVER BEING OPENED.
*      5.   OPTION TO HAVE COPIES OF ERRORS SENT TO AN
*           INTERACTIVE CHANNEL IN ADDITION TO STANDARD PRINTER.
*      6.   OPTION TO KEEP PAGE HEADERS SHORT (E.G. IF LISTING
*           TO AN ONLINE TERMINAL).
*      7.   AN OPTION TO CHOOSE EXTENDED OR COMPACT LISTING
*           FORMAT. IN THE FORMER A PAGE EJECT AND IN THE LATTER
*           A FEW LINE FEEDS PRECEDE THE PRINTING OF EACH
*           OF-- LISTING, COMPILATION STATISTICS, EXECUTION
*           OUTPUT AND EXECUTION STATISTICS.
*      8.   AN OPTION TO SUPPRESS EXECUTION AS THOUGH A
*           -NOEXECUTE CARD WERE SUPPLIED.
*      9.   AN OPTION TO REQUEST THAT NAME /TERMINAL/  BE PRE-
*           ASSOCIATED TO AN ONLINE TERMINAL VIA SYSPI AND SYSRI
*      10.  AN INTERMEDIATE (STANDARD) LISTING OPTION REQUIRING
*           THAT PAGE EJECTS OCCUR IN SOURCE LISTINGS. REDUNDANT
*           IF EXTENDED OPTION CHOSEN BUT PARTIALLY EXTENDS
*           COMPACT OPTION.
*      11.  OPTION TO SUPPRESS SYSID IDENTIFICATION.
*
*      JSR  SYSPP            CALL TO GET PRINT PARAMETERS
*      (WA)                  PRINT LINE LENGTH IN CHARS
*      (WB)                  NUMBER OF LINES/PAGE
*      (WC)                  BITS VALUE ...MLKJIHGFEDCBA WHERE
*                            A = 1 TO SEND ERROR COPY TO INT.CH.
*                            B = 1 MEANS STD PRINTER IS INT. CH.
*                            C = 1 FOR -NOLIST OPTION
*                            D = 1 TO SUPPRESS COMPILN. STATS
*
*                            E = 1 TO SUPPRESS EXECN. STATS
*                            F = 1/0 FOR EXTNDED/COMPACT LISTING
*                            G = 1 FOR -NOEXECUTE
*                            H = 1 PRE-ASSOCIATE /TERMINAL/
*
*                            I = 1 FOR STANDARD LISTING OPTION.
*                            J = 1 SUPPRESSES LISTING HEADER
*                            K = 1 FOR -PRINT
*                            L = 1 FOR -NOERRORS
*
*                            M = 1 FOR -CASE 1
{{EJC{{{{{4610
*
*      SYSPR -- PRINT LINE ON STANDARD OUTPUT FILE
*
{SYSPR{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4614
*
*      SYSPR IS USED TO PRINT A SINGLE LINE ON THE STANDARD
*      OUTPUT FILE.
*
*      (XR)                  POINTER TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPR            CALL TO PRINT LINE
*      PPM  LOC              TOO MUCH O/P OR NO FILE AFTER SYSXI
*      (WA,WB)               DESTROYED
*
*      THE BUFFER POINTED TO IS THE LENGTH OBTAINED FROM THE
*      SYSPP CALL AND IS FILLED OUT WITH TRAILING BLANKS. THE
*      VALUE IN WA IS THE ACTUAL LINE LENGTH WHICH MAY BE LESS
*      THAN THE MAXIMUM LINE LENGTH POSSIBLE. THERE IS NO SPACE
*      CONTROL ASSOCIATED WITH THE LINE, ALL LINES ARE PRINTED
*      SINGLE SPACED. NOTE THAT NULL LINES (WA=0) ARE POSSIBLE
*      IN WHICH CASE A BLANK LINE IS TO BE PRINTED.
*
*      THE ERROR EXIT IS USED FOR SYSTEMS WHICH LIMIT THE AMOUNT
*      OF PRINTED OUTPUT. IF POSSIBLE, PRINTING SHOULD BE
*      PERMITTED AFTER THIS CONDITION HAS BEEN SIGNALLED ONCE TO
*      ALLOW FOR DUMP AND OTHER DIAGNOSTIC INFORMATION.
*      ASSUMING THIS TO BE POSSIBLE, SPITBOL MAY MAKE MORE SYSPR
*      CALLS. IF THE ERROR RETURN OCCURS ANOTHER TIME, EXECUTION
*      IS TERMINATED BY A CALL OF SYSEJ WITH ENDING CODE 998.
{{EJC{{{{{4640
*
*      SYSRD -- READ RECORD FROM STANDARD INPUT FILE
*
{SYSRD{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4644
*
*      SYSRD IS USED TO READ A RECORD FROM THE STANDARD INPUT
*      FILE. THE BUFFER PROVIDED IS AN SCBLK FOR A STRING THE
*      LENGTH OF WHICH IN CHARACTERS IS GIVEN IN WC, THIS
*      CORRESPONDING TO THE MAXIMUM LENGTH OF STRING WHICH
*      SPITBOL IS PREPARED TO RECEIVE. AT COMPILE TIME IT
*      CORRESPONDS TO XXX IN THE MOST RECENT -INXXX CARD
*      (DEFAULT 72) AND AT EXECUTION TIME TO THE MOST RECENT
*      ,R$R$ (RECORD LENGTH) IN THE THIRD ARG OF AN INPUT()
*      STATEMENT FOR THE STANDARD INPUT FILE (DEFAULT 80).
*      IF FEWER THAN (WC) CHARACTERS ARE READ, THE LENGTH
*      FIELD OF THE SCBLK MUST BE ADJUSTED BEFORE RETURNING
*      UNLESS THE BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE RETURN
*      AFTER SUCH AN ADJUSTMENT HAS BEEN MADE.
*      SPITBOL MAY CONTINUE TO MAKE CALLS AFTER AN ENDFILE
*      RETURN SO THIS ROUTINE SHOULD BE PREPARED TO MAKE
*      REPEATED ENDFILE RETURNS.
*
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      (WC)                  LENGTH OF BUFFER IN CHARACTERS
*      JSR  SYSRD            CALL TO READ LINE
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*                            OR INPUT FILE NAME CHANGE.  IF
*                            THE FORMER, SCBLK LENGTH IS ZERO.
*                            IF INPUT FILE NAME CHANGE, LENGTH
*                            IS NON-ZERO. CALLER SHOULD RE-ISSUE
*                            SYSRD TO OBTAIN INPUT RECORD.
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{4676
*
*      SYSRI -- READ RECORD FROM INTERACTIVE CHANNEL
*
{SYSRI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4680
*
*      READS A RECORD FROM ONLINE TERMINAL FOR SPITBOL VARIABLE,
*      TERMINAL. IF ONLINE TERMINAL IS UNAVAILABLE THEN CODE THE
*      ENDFILE RETURN ONLY.
*      THE BUFFER PROVIDED IS OF LENGTH 258 CHARACTERS. SYSRI
*      SHOULD REPLACE THE COUNT IN THE SECOND WORD OF THE SCBLK
*      BY THE ACTUAL CHARACTER COUNT UNLESS BUFFER IS RIGHT
*      PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE
*      RETURN AFTER ADJUSTING THE COUNT.
*      THE END OF FILE RETURN MAY BE USED IF THIS MAKES
*      SENSE ON THE TARGET MACHINE (E.G. IF THERE IS AN
*      EOF CHARACTER.)
*
*      (XR)                  PTR TO 258 CHAR BUFFER (SCBLK PTR)
*      JSR  SYSRI            CALL TO READ LINE FROM TERMINAL
*      PPM  LOC              END OF FILE RETURN
*      (WA,WB,WC)            MAY BE DESTROYED
{{EJC{{{{{4699
*
*      SYSRW -- REWIND FILE
*
{SYSRW{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4703
*
*      SYSRW IS USED TO REWIND A FILE I.E. REPOSITION THE FILE
*      AT THE START BEFORE THE FIRST RECORD. THE FILE SHOULD BE
*      CLOSED AND THE NEXT READ OR WRITE CALL WILL OPEN THE
*      FILE AT THE START.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  REWIND ARG (SCBLK PTR)
*      JSR  SYSRW            CALL TO REWIND FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF REWIND NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{4716
*
*      SYSST -- SET FILE POINTER
*
{SYSST{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4721
*
*      SYSST IS CALLED TO CHANGE THE POSITION OF A FILE
*      POINTER. THIS IS ACCOMPLISHED IN A SYSTEM DEPENDENT
*      MANNER, AND THUS THE 2ND AND 3RD ARGUMENTS ARE PASSED
*      UNCONVERTED.
*
*      (WA)                  FCBLK POINTER
*      (WB)                  2ND ARGUMENT
*      (WC)                  3RD ARGUMENT
*      JSR  SYSST            CALL TO SET FILE POINTER
*      PPM  LOC              RETURN HERE IF INVALID 2ND ARG
*      PPM  LOC              RETURN HERE IF INVALID 3RD ARG
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF SET NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*
{{EJC{{{{{4738
*
*      SYSTM -- GET EXECUTION TIME SO FAR
*
{SYSTM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4743
*
*      SYSTM IS USED TO OBTAIN THE AMOUNT OF EXECUTION TIME
*      USED SO FAR SINCE SPITBOL WAS GIVEN CONTROL. THE UNITS
*      ARE DESCRIBED AS MILLISECONDS IN THE SPITBOL OUTPUT, BUT
*      THE EXACT MEANING IS SYSTEM DEPENDENT. WHERE APPROPRIATE,
*      THIS VALUE SHOULD RELATE TO PROCESSOR RATHER THAN CLOCK
*      TIMING VALUES.
*      IF THE SYMBOL .CTMD IS DEFINED, THE UNITS ARE DESCRIBED
*      AS DECISECONDS (0.1 SECOND).
*
*      JSR  SYSTM            CALL TO GET TIMER VALUE
*      (IA)                  TIME SO FAR IN MILLISECONDS
*                            (DECISECONDS IF .CTMD DEFINED)
{{EJC{{{{{4757
*
*      SYSTT -- TRACE TOGGLE
*
{SYSTT{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4761
*
*      CALLED BY SPITBOL FUNCTION TRACE() WITH NO ARGS TO
*      TOGGLE THE SYSTEM TRACE SWITCH.  THIS PERMITS TRACING OF
*      LABELS IN SPITBOL CODE TO BE TURNED ON OR OFF.
*
*      JSR  SYSTT            CALL TO TOGGLE TRACE SWITCH
{{EJC{{{{{4768
*
*      SYSUL -- UNLOAD EXTERNAL FUNCTION
*
{SYSUL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4772
*
*      SYSUL IS USED TO UNLOAD A FUNCTION PREVIOUSLY
*      LOADED WITH A CALL TO SYSLD.
*
*      (XR)                  PTR TO CONTROL BLOCK (EFBLK)
*      JSR  SYSUL            CALL TO UNLOAD FUNCTION
*
*      THE FUNCTION CANNOT BE CALLED FOLLOWING A SYSUL CALL
*      UNTIL ANOTHER SYSLD CALL IS MADE FOR THE SAME FUNCTION.
*
*      THE EFBLK CONTAINS THE FUNCTION CODE POINTER AND ALSO A
*      POINTER TO THE VRBLK CONTAINING THE FUNCTION NAME (SEE
*      DEFINITIONS AND DATA STRUCTURES SECTION).
{{EJC{{{{{4788
*
*      SYSXI -- EXIT TO PRODUCE LOAD MODULE
*
{SYSXI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4792
*
*      WHEN SYSXI IS CALLED, XL CONTAINS EITHER A STRING POINTER
*      OR ZERO. IN THE FORMER CASE, THE STRING GIVES THE
*      CHARACTER NAME OF A PROGRAM. THE INTENTION IS THAT
*      SPITBOL EXECUTION SHOULD BE TERMINATED FORTHWITH AND
*      THE NAMED PROGRAM LOADED AND EXECUTED. THIS TYPE OF CHAIN
*      EXECUTION IS VERY SYSTEM DEPENDENT AND IMPLEMENTORS MAY
*      CHOOSE TO OMIT IT OR FIND IT IMPOSSIBLE TO PROVIDE.
*      IF (XL) IS ZERO,IA CONTAINS ONE OF THE FOLLOWING INTEGERS
*
*      -1, -2, -3, -4
*           CREATE IF POSSIBLE A LOAD MODULE CONTAINING ONLY THE
*           IMPURE AREA OF MEMORY WHICH NEEDS TO BE LOADED WITH
*           A COMPATIBLE PURE SEGMENT FOR SUBSEQUENT EXECUTIONS.
*           VERSION NUMBERS TO CHECK COMPATIBILITY SHOULD BE
*           KEPT IN BOTH SEGMENTS AND CHECKED ON LOADING.
*           TO ASSIST WITH THIS CHECK, (XR) ON ENTRY IS A
*           POINTER TO AN SCBLK CONTAINING THE SPITBOL MAJOR
*           VERSION NUMBER V.V (SEE SYSID).  THE FILE THUS
*           CREATED IS CALLED A SAVE FILE.
*
*      0    IF POSSIBLE, RETURN CONTROL TO JOB CONTROL
*           COMMAND LEVEL. THE EFFECT IF AVAILABLE WILL BE
*           SYSTEM DEPENDENT.
*
*      +1, +2, +3, +4
*           CREATE IF POSSIBLE A LOAD MODULE FROM ALL OF
*           MEMORY. IT SHOULD BE POSSIBLE TO LOAD AND EXECUTE
*           THIS MODULE DIRECTLY.
*
*      IN THE CASE OF SAVED LOAD MODULES, THE STATUS OF OPEN
*      FILES IS NOT PRESERVED AND IMPLEMENTORS MAY CHOOSE TO
*      OFFER MEANS OF ATTACHING FILES BEFORE EXECUTION OF LOAD
*      MODULES STARTS OR LEAVE IT TO THE USER TO INCLUDE
*      SUITABLE INPUT(), OUTPUT() CALLS IN HIS PROGRAM.
*      SYSXI SHOULD MAKE A NOTE THAT NO I/O CHANNELS,
*      INCLUDING STANDARD FILES, HAVE FILES ATTACHED SO THAT
*      CALLS OF SYSIN, SYSOU, SYSPR, SYSRD SHOULD FAIL UNLESS
*      NEW ASSOCIATIONS ARE MADE FOR THE LOAD MODULE.
*      AT LEAST IN THE CASE OF THE STANDARD OUTPUT FILE, IT IS
*      RECOMMENDED THAT EITHER THE USER BE REQUIRED TO ATTACH
*      A FILE OR THAT A DEFAULT FILE IS ATTACHED, SINCE THE
*      PROBLEM OF ERROR MESSAGES GENERATED BY THE LOAD MODULE
*      IS OTHERWISE SEVERE. AS A LAST RESORT, IF SPITBOL
*      ATTEMPTS TO WRITE TO THE STANDARD OUTPUT FILE AND GETS A
*      REPLY INDICATING THAT SUCH OUPUT IS UNACCEPTABLE IT STOPS
*      BY USING AN ENTRY TO SYSEJ WITH ENDING CODE 998.
*      AS DESCRIBED BELOW, PASSING OF SOME ARGUMENTS MAKES IT
*      CLEAR THAT LOAD MODULE WILL USE A STANDARD OUTPUT FILE.
*
*      IF USE IS MADE OF FCBLKS FOR I/O ASSOCIATION, SPITBOL
*      BUILDS A CHAIN SO THAT THOSE IN USE MAY BE FOUND IN SYSXI
*      AND SYSEJ. THE NODES ARE 4 WORDS LONG. THIRD WORD
*      CONTAINS LINK TO NEXT NODE OR 0, FOURTH WORD CONTAINS
*      FCBLK POINTER.
{{EJC{{{{{4848
*
*      SYSXI (CONTINUED)
*
*      (XL)                  ZERO OR SCBLK PTR TO FIRST ARGUMENT
*      (XR)                  PTR TO V.V SCBLK
*      (IA)                  SIGNED INTEGER ARGUMENT
*      (WA)                  SCBLK PTR TO SECOND ARGUMENT
*      (WB)                  0 OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSXI            CALL TO EXIT
*      PPM  LOC              REQUESTED ACTION NOT POSSIBLE
*      PPM  LOC              ACTION CAUSED IRRECOVERABLE ERROR
*      (WB,WC,IA,XR,XL,CP)   SHOULD BE PRESERVED OVER CALL
*      (WA)                  0 IN ALL CASES EXCEPT SUCESSFUL
*                            PERFORMANCE OF EXIT(4) OR EXIT(-4),
*                            IN WHICH CASE 1 SHOULD BE RETURNED.
*
*      LOADING AND RUNNING THE LOAD MODULE OR RETURNING FROM
*      JCL COMMAND LEVEL CAUSES EXECUTION TO RESUME AT THE POINT
*      AFTER THE ERROR RETURNS WHICH FOLLOW THE CALL OF SYSXI.
*      THE VALUE PASSED AS EXIT ARGUMENT IS USED TO INDICATE
*      OPTIONS REQUIRED ON RESUMPTION OF LOAD MODULE.
*      +1 OR -1 REQUIRE THAT ON RESUMPTION, SYSID AND SYSPP BE
*      CALLED AND A HEADING PRINTED ON THE STANDARD OUTPUT FILE.
*      +2 OR -2 INDICATE THAT SYSPP WILL BE CALLED BUT NOT SYSID
*      AND NO HEADING WILL BE PUT ON STANDARD OUTPUT FILE.
*      ABOVE OPTIONS HAVE THE OBVIOUS IMPLICATION THAT A
*      STANDARD O/P FILE MUST BE PROVIDED FOR THE LOAD MODULE.
*      +3, +4, -3 OR -4 INDICATE CALLS OF NEITHER SYSID NOR
*      SYSPP AND NO HEADING WILL BE PLACED ON STANDARD OUTPUT
*      FILE.
*      +4 OR -4 INDICATE THAT EXECUTION IS TO CONTINUE AFTER
*      CREATION OF THE SAVE FILE OR LOAD MODULE, ALTHOUGH ALL
*      FILES WILL BE CLOSED BY THE SYSXI ACTION.  THIS PERMITS
*      THE USER TO CHECKPOINT LONG-RUNNING PROGRAMS WHILE
*      CONTINUING EXECUTION.
*
*      NO RETURN FROM SYSXI IS POSSIBLE IF ANOTHER PROGRAM
*      IS LOADED AND ENTERED.
{{EJC{{{{{4888
*
*      INTRODUCE THE INTERNAL PROCEDURES.
*
{ACESS{INP{25,R{1,1{{{4892
{ACOMP{INP{25,N{1,5{{{4893
{ALLOC{INP{25,E{1,0{{{4894
{ALOCS{INP{25,E{1,0{{{4899
{ALOST{INP{25,E{1,0{{{4900
{ARITH{INP{25,N{1,3{{{4908
{ASIGN{INP{25,R{1,1{{{4910
{ASINP{INP{25,R{1,1{{{4911
{BLKLN{INP{25,E{1,0{{{4912
{CDGCG{INP{25,E{1,0{{{4913
{CDGEX{INP{25,R{1,0{{{4914
{CDGNM{INP{25,R{1,0{{{4915
{CDGVL{INP{25,R{1,0{{{4916
{CDWRD{INP{25,E{1,0{{{4917
{CMGEN{INP{25,R{1,0{{{4918
{CMPIL{INP{25,E{1,0{{{4919
{CNCRD{INP{25,E{1,0{{{4920
{COPYB{INP{25,N{1,1{{{4921
{DFFNC{INP{25,E{1,0{{{4922
{DTACH{INP{25,E{1,0{{{4923
{DTYPE{INP{25,E{1,0{{{4924
{DUMPR{INP{25,E{1,0{{{4925
{ERMSG{INP{25,E{1,0{{{4930
{ERTEX{INP{25,E{1,0{{{4931
{EVALI{INP{25,R{1,4{{{4932
{EVALP{INP{25,R{1,1{{{4933
{EVALS{INP{25,R{1,3{{{4934
{EVALX{INP{25,R{1,1{{{4935
{EXBLD{INP{25,E{1,0{{{4936
{EXPAN{INP{25,E{1,0{{{4937
{EXPAP{INP{25,E{1,1{{{4938
{EXPDM{INP{25,N{1,0{{{4939
{EXPOP{INP{25,N{1,0{{{4940
{FILNM{INP{25,E{1,0{{{4942
{FLSTG{INP{25,E{1,0{{{4945
{GBCOL{INP{25,E{1,0{{{4947
{GBCPF{INP{25,E{1,0{{{4948
{GTARR{INP{25,E{1,2{{{4949
{{EJC{{{{{4950
{GTCOD{INP{25,E{1,1{{{4951
{GTEXP{INP{25,E{1,1{{{4952
{GTINT{INP{25,E{1,1{{{4953
{GTNUM{INP{25,E{1,1{{{4954
{GTNVR{INP{25,E{1,1{{{4955
{GTPAT{INP{25,E{1,1{{{4956
{GTREA{INP{25,E{1,1{{{4959
{GTSMI{INP{25,N{1,2{{{4961
{GTSTG{INP{25,N{1,1{{{4966
{GTVAR{INP{25,E{1,1{{{4967
{HASHS{INP{25,E{1,0{{{4968
{ICBLD{INP{25,E{1,0{{{4969
{IDENT{INP{25,E{1,1{{{4970
{INOUT{INP{25,E{1,0{{{4971
{INSTA{INP{25,E{1,0{{{4976
{IOFCB{INP{25,N{1,3{{{4977
{IOPPF{INP{25,N{1,0{{{4978
{IOPUT{INP{25,N{1,7{{{4979
{KTREX{INP{25,R{1,0{{{4980
{KWNAM{INP{25,N{1,0{{{4981
{LCOMP{INP{25,N{1,5{{{4982
{LISTR{INP{25,E{1,0{{{4983
{LISTT{INP{25,E{1,0{{{4984
{NEWFN{INP{25,E{1,0{{{4986
{NEXTS{INP{25,E{1,0{{{4988
{PATIN{INP{25,N{1,2{{{4989
{PATST{INP{25,N{1,1{{{4990
{PBILD{INP{25,E{1,0{{{4991
{PCONC{INP{25,E{1,0{{{4992
{PCOPY{INP{25,N{1,0{{{4993
{PRFLR{INP{25,E{1,0{{{4996
{PRFLU{INP{25,E{1,0{{{4997
{PRPAR{INP{25,E{1,0{{{4999
{PRTCH{INP{25,E{1,0{{{5000
{PRTIC{INP{25,E{1,0{{{5001
{PRTIS{INP{25,E{1,0{{{5002
{PRTIN{INP{25,E{1,0{{{5003
{PRTMI{INP{25,E{1,0{{{5004
{PRTMM{INP{25,E{1,0{{{5005
{PRTMX{INP{25,E{1,0{{{5006
{PRTNL{INP{25,R{1,0{{{5007
{PRTNM{INP{25,R{1,0{{{5008
{PRTNV{INP{25,E{1,0{{{5009
{PRTPG{INP{25,E{1,0{{{5010
{PRTPS{INP{25,E{1,0{{{5011
{PRTSN{INP{25,E{1,0{{{5012
{PRTST{INP{25,R{1,0{{{5013
{{EJC{{{{{5014
{PRTTR{INP{25,E{1,0{{{5015
{PRTVL{INP{25,R{1,0{{{5016
{PRTVN{INP{25,E{1,0{{{5017
{RCBLD{INP{25,E{1,0{{{5020
{READR{INP{25,E{1,0{{{5022
{RELAJ{INP{25,E{1,0{{{5024
{RELCR{INP{25,E{1,0{{{5025
{RELDN{INP{25,E{1,0{{{5026
{RELOC{INP{25,E{1,0{{{5027
{RELST{INP{25,E{1,0{{{5028
{RELWS{INP{25,E{1,0{{{5029
{RSTRT{INP{25,E{1,0{{{5031
{SBSTR{INP{25,E{1,0{{{5035
{SCANE{INP{25,E{1,0{{{5036
{SCNGF{INP{25,E{1,0{{{5037
{SETVR{INP{25,E{1,0{{{5038
{SORTA{INP{25,N{1,1{{{5041
{SORTC{INP{25,E{1,1{{{5042
{SORTF{INP{25,E{1,0{{{5043
{SORTH{INP{25,N{1,0{{{5044
{START{INP{25,E{1,0{{{5046
{STGCC{INP{25,E{1,0{{{5047
{TFIND{INP{25,E{1,1{{{5048
{TMAKE{INP{25,E{1,0{{{5049
{TRACE{INP{25,N{1,2{{{5050
{TRBLD{INP{25,E{1,0{{{5051
{TRIMR{INP{25,E{1,0{{{5052
{TRXEQ{INP{25,R{1,0{{{5053
{VMAKE{INP{25,E{1,1{{{5054
{XSCAN{INP{25,E{1,0{{{5055
{XSCNI{INP{25,N{1,2{{{5056
*
*      INTRODUCE THE INTERNAL ROUTINES
*
{ARREF{INR{{{{{5060
{CFUNC{INR{{{{{5061
{EXFAL{INR{{{{{5062
{EXINT{INR{{{{{5063
{EXITS{INR{{{{{5064
{EXIXR{INR{{{{{5065
{EXNAM{INR{{{{{5066
{EXNUL{INR{{{{{5067
{EXREA{INR{{{{{5070
{EXSID{INR{{{{{5072
{EXVNM{INR{{{{{5073
{FAILP{INR{{{{{5074
{FLPOP{INR{{{{{5075
{INDIR{INR{{{{{5076
{MATCH{INR{{{{{5077
{RETRN{INR{{{{{5078
{STCOV{INR{{{{{5079
{STMGO{INR{{{{{5080
{STOPR{INR{{{{{5081
{SUCCP{INR{{{{{5082
{SYSAB{INR{{{{{5083
{SYSTU{INR{{{{{5084
{{TTL{27,S P I T B O L -- DEFINITIONS AND DATA STRUCTURES{{{{5085
*      THIS SECTION CONTAINS ALL SYMBOL DEFINITIONS AND ALSO
*      PICTURES OF ALL DATA STRUCTURES USED IN THE SYSTEM.
*
{{SEC{{{{START OF DEFINITIONS SECTION{5089
*
*      DEFINITIONS OF MACHINE PARAMETERS
*
*      THE MINIMAL TRANSLATOR SHOULD SUPPLY APPROPRIATE VALUES
*      FOR THE PARTICULAR TARGET MACHINE FOR ALL THE
*      EQU  *
*      DEFINITIONS GIVEN AT THE START OF THIS SECTION.
*      NOTE THAT EVEN IF CONDITIONAL ASSEMBLY IS USED TO OMIT
*      SOME FEATURE (E.G. REAL ARITHMETIC) A FULL SET OF CFP$-
*      VALUES MUST BE SUPPLIED. USE DUMMY VALUES IF GENUINE
*      ONES ARE NOT NEEDED.
*
{CFP$A{EQU{24,256{{{NUMBER OF CHARACTERS IN ALPHABET{5102
*
{CFP$B{EQU{24,4{{{BYTES/WORD ADDRESSING FACTOR{5104
*
{CFP$C{EQU{24,4{{{NUMBER OF CHARACTERS PER WORD{5106
*
{CFP$F{EQU{24,8{{{OFFSET IN BYTES TO CHARS IN{5108
*                            SCBLK. SEE SCBLK FORMAT.
*
{CFP$I{EQU{24,1{{{NUMBER OF WORDS IN INTEGER CONSTANT{5111
*
{CFP$M{EQU{24,2147483647{{{MAX POSITIVE INTEGER IN ONE WORD{5113
*
{CFP$N{EQU{24,32{{{NUMBER OF BITS IN ONE WORD{5115
*
*      THE FOLLOWING DEFINITIONS REQUIRE THE SUPPLY OF EITHER
*      A SINGLE PARAMETER IF REAL ARITHMETIC IS OMITTED OR
*      THREE PARAMETERS IF REAL ARITHMETIC IS INCLUDED.
*
*
{CFP$R{EQU{24,2{{{NUMBER OF WORDS IN REAL CONSTANT{5125
*
{CFP$S{EQU{24,9{{{NUMBER OF SIG DIGS FOR REAL OUTPUT{5127
*
{CFP$X{EQU{24,3{{{MAX DIGITS IN REAL EXPONENT{5129
*
{MXDGS{EQU{24,CFP$S+CFP$X{{{MAX DIGITS IN REAL NUMBER{5140
*
*
*      MAX SPACE FOR REAL (FOR +0.E+) NEEDS FIVE MORE PLACES
*
{NSTMX{EQU{24,MXDGS+5{{{MAX SPACE FOR REAL{5145
*
*      THE FOLLOWING DEFINITION FOR CFP$U SUPPLIES A REALISTIC
*      UPPER BOUND ON THE SIZE OF THE ALPHABET.  CFP$U IS USED
*      TO SAVE SPACE IN THE SCANE BSW-IFF-ESW TABLE AND TO EASE
*      TRANSLATION STORAGE REQUIREMENTS.
*
{CFP$U{EQU{24,128{{{REALISTIC UPPER BOUND ON ALPHABET{5155
{{EJC{{{{{5157
*
*      ENVIRONMENT PARAMETERS
*
*      THE SPITBOL PROGRAM IS ESSENTIALLY INDEPENDENT OF
*      THE DEFINITIONS OF THESE PARAMETERS. HOWEVER, THE
*      EFFICIENCY OF THE SYSTEM MAY BE AFFECTED. CONSEQUENTLY,
*      THESE PARAMETERS MAY REQUIRE TUNING FOR A GIVEN VERSION
*      THE VALUES GIVEN IN COMMENTS HAVE BEEN SUCCESSFULLY USED.
*
*      E$SRS IS THE NUMBER OF WORDS TO RESERVE AT THE END OF
*      STORAGE FOR END OF RUN PROCESSING. IT SHOULD BE
*      SET AS SMALL AS POSSIBLE WITHOUT CAUSING MEMORY OVERFLOW
*      IN CRITICAL SITUATIONS (E.G. MEMORY OVERFLOW TERMINATION)
*      AND SHOULD THUS RESERVE SUFFICIENT SPACE AT LEAST FOR
*      AN SCBLK CONTAINING SAY 30 CHARACTERS.
*
{E$SRS{EQU{24,100{{{30 WORDS{5174
*
*      E$STS IS THE NUMBER OF WORDS GRABBED IN A CHUNK WHEN
*      STORAGE IS ALLOCATED IN THE STATIC REGION. THE MINIMUM
*      PERMITTED VALUE IS 256/CFP$B. LARGER VALUES WILL LEAD
*      TO INCREASED EFFICIENCY AT THE COST OF WASTING MEMORY.
*
{E$STS{EQU{24,1000{{{500 WORDS{5181
*
*      E$CBS IS THE SIZE OF CODE BLOCK ALLOCATED INITIALLY AND
*      THE EXPANSION INCREMENT IF OVERFLOW OCCURS. IF THIS VALUE
*      IS TOO SMALL OR TOO LARGE, EXCESSIVE GARBAGE COLLECTIONS
*      WILL OCCUR DURING COMPILATION AND MEMORY MAY BE LOST
*      IN THE CASE OF A TOO LARGE VALUE.
*
{E$CBS{EQU{24,500{{{500 WORDS{5189
*
*      E$HNB IS THE NUMBER OF BUCKET HEADERS IN THE VARIABLE
*      HASH TABLE. IT SHOULD ALWAYS BE ODD. LARGER VALUES WILL
*      SPEED UP COMPILATION AND INDIRECT REFERENCES AT THE
*      EXPENSE OF ADDITIONAL STORAGE FOR THE HASH TABLE ITSELF.
*
{E$HNB{EQU{24,257{{{127 BUCKET HEADERS{5196
*
*      E$HNW IS THE MAXIMUM NUMBER OF WORDS OF A STRING
*      NAME WHICH PARTICIPATE IN THE STRING HASH ALGORITHM.
*      LARGER VALUES GIVE A BETTER HASH AT THE EXPENSE OF TAKING
*      LONGER TO COMPUTE THE HASH. THERE IS SOME OPTIMAL VALUE.
*
{E$HNW{EQU{24,6{{{6 WORDS{5203
*
*      E$FSP.  IF THE AMOUNT OF FREE SPACE LEFT AFTER A GARBAGE
*      COLLECTION IS SMALL COMPARED TO THE TOTAL AMOUNT OF SPACE
*      IN USE GARBAGE COLLECTOR THRASHING IS LIKELY TO OCCUR AS
*      THIS SPACE IS USED UP.  E$FSP IS A MEASURE OF THE
*      MINIMUM PERCENTAGE OF DYNAMIC MEMORY LEFT AS FREE SPACE
*      BEFORE THE SYSTEM ROUTINE SYSMM IS CALLED TO TRY TO
*      OBTAIN MORE MEMORY.
*
{E$FSP{EQU{24,15{{{15 PERCENT{5213
*
*      E$SED.  IF THE AMOUNT OF FREE SPACE LEFT IN THE SEDIMENT
*      AFTER A GARBAGE COLLECTION IS A SIGNIFICANT FRACTION OF
*      THE NEW SEDIMENT SIZE, THE SEDIMENT IS MARKED FOR
*      COLLECTION ON THE NEXT CALL TO THE GARBAGE COLLECTOR.
*
{E$SED{EQU{24,25{{{25 PERCENT{5221
{{EJC{{{{{5223
*
*      DEFINITIONS OF CODES FOR LETTERS
*
{CH$LA{EQU{24,65{{{LETTER A{5227
{CH$LB{EQU{24,66{{{LETTER B{5228
{CH$LC{EQU{24,67{{{LETTER C{5229
{CH$LD{EQU{24,68{{{LETTER D{5230
{CH$LE{EQU{24,69{{{LETTER E{5231
{CH$LF{EQU{24,70{{{LETTER F{5232
{CH$LG{EQU{24,71{{{LETTER G{5233
{CH$LH{EQU{24,72{{{LETTER H{5234
{CH$LI{EQU{24,73{{{LETTER I{5235
{CH$LJ{EQU{24,74{{{LETTER J{5236
{CH$LK{EQU{24,75{{{LETTER K{5237
{CH$LL{EQU{24,76{{{LETTER L{5238
{CH$LM{EQU{24,77{{{LETTER M{5239
{CH$LN{EQU{24,78{{{LETTER N{5240
{CH$LO{EQU{24,79{{{LETTER O{5241
{CH$LP{EQU{24,80{{{LETTER P{5242
{CH$LQ{EQU{24,81{{{LETTER Q{5243
{CH$LR{EQU{24,82{{{LETTER R{5244
{CH$LS{EQU{24,83{{{LETTER S{5245
{CH$LT{EQU{24,84{{{LETTER T{5246
{CH$LU{EQU{24,85{{{LETTER U{5247
{CH$LV{EQU{24,86{{{LETTER V{5248
{CH$LW{EQU{24,87{{{LETTER W{5249
{CH$LX{EQU{24,88{{{LETTER X{5250
{CH$LY{EQU{24,89{{{LETTER Y{5251
{CH$L${EQU{24,90{{{LETTER Z{5252
*
*      DEFINITIONS OF CODES FOR DIGITS
*
{CH$D0{EQU{24,48{{{DIGIT 0{5256
{CH$D1{EQU{24,49{{{DIGIT 1{5257
{CH$D2{EQU{24,50{{{DIGIT 2{5258
{CH$D3{EQU{24,51{{{DIGIT 3{5259
{CH$D4{EQU{24,52{{{DIGIT 4{5260
{CH$D5{EQU{24,53{{{DIGIT 5{5261
{CH$D6{EQU{24,54{{{DIGIT 6{5262
{CH$D7{EQU{24,55{{{DIGIT 7{5263
{CH$D8{EQU{24,56{{{DIGIT 8{5264
{CH$D9{EQU{24,57{{{DIGIT 9{5265
{{EJC{{{{{5266
*
*      DEFINITIONS OF CODES FOR SPECIAL CHARACTERS
*
*      THE NAMES OF THESE CHARACTERS ARE RELATED TO THEIR
*      ORIGINAL REPRESENTATION IN THE EBCDIC SET CORRESPONDING
*      TO THE DESCRIPTION IN STANDARD SNOBOL4 MANUALS AND TEXTS.
*
{CH$AM{EQU{24,38{{{KEYWORD OPERATOR (AMPERSAND){5274
{CH$AS{EQU{24,42{{{MULTIPLICATION SYMBOL (ASTERISK){5275
{CH$AT{EQU{24,64{{{CURSOR POSITION OPERATOR (AT){5276
{CH$BB{EQU{24,60{{{LEFT ARRAY BRACKET (LESS THAN){5277
{CH$BL{EQU{24,32{{{BLANK{5278
{CH$BR{EQU{24,124{{{ALTERNATION OPERATOR (VERTICAL BAR){5279
{CH$CL{EQU{24,58{{{GOTO SYMBOL (COLON){5280
{CH$CM{EQU{24,44{{{COMMA{5281
{CH$DL{EQU{24,36{{{INDIRECTION OPERATOR (DOLLAR){5282
{CH$DT{EQU{24,46{{{NAME OPERATOR (DOT){5283
{CH$DQ{EQU{24,34{{{DOUBLE QUOTE{5284
{CH$EQ{EQU{24,61{{{EQUAL SIGN{5285
{CH$EX{EQU{24,33{{{EXPONENTIATION OPERATOR (EXCLM){5286
{CH$MN{EQU{24,45{{{MINUS SIGN / HYPHEN{5287
{CH$NM{EQU{24,35{{{NUMBER SIGN{5288
{CH$NT{EQU{24,126{{{NEGATION OPERATOR (NOT){5289
{CH$PC{EQU{24,37{{{PERCENT{5290
{CH$PL{EQU{24,43{{{PLUS SIGN{5291
{CH$PP{EQU{24,40{{{LEFT PARENTHESIS{5292
{CH$RB{EQU{24,62{{{RIGHT ARRAY BRACKET (GRTR THAN){5293
{CH$RP{EQU{24,41{{{RIGHT PARENTHESIS{5294
{CH$QU{EQU{24,63{{{INTERROGATION OPERATOR (QUESTION){5295
{CH$SL{EQU{24,47{{{SLASH{5296
{CH$SM{EQU{24,59{{{SEMICOLON{5297
{CH$SQ{EQU{24,39{{{SINGLE QUOTE{5298
{CH$UN{EQU{24,95{{{SPECIAL IDENTIFIER CHAR (UNDERLINE){5299
{CH$OB{EQU{24,91{{{OPENING BRACKET{5300
{CH$CB{EQU{24,93{{{CLOSING BRACKET{5301
{{EJC{{{{{5302
*
*      REMAINING CHARS ARE OPTIONAL ADDITIONS TO THE STANDARDS.
*
*      TAB CHARACTERS - SYNTACTICALLY EQUIVALENT TO BLANK
*
{CH$HT{EQU{24,9{{{HORIZONTAL TAB{5309
*
*      UP ARROW SAME AS EXCLAMATION MARK FOR EXPONENTIATION
*
{CH$EY{EQU{24,94{{{UP ARROW{5318
*
*      LOWER CASE OR SHIFTED CASE ALPHABETIC CHARS
*
{CH$$A{EQU{24,97{{{SHIFTED A{5324
{CH$$B{EQU{24,98{{{SHIFTED B{5325
{CH$$C{EQU{24,99{{{SHIFTED C{5326
{CH$$D{EQU{24,100{{{SHIFTED D{5327
{CH$$E{EQU{24,101{{{SHIFTED E{5328
{CH$$F{EQU{24,102{{{SHIFTED F{5329
{CH$$G{EQU{24,103{{{SHIFTED G{5330
{CH$$H{EQU{24,104{{{SHIFTED H{5331
{CH$$I{EQU{24,105{{{SHIFTED I{5332
{CH$$J{EQU{24,106{{{SHIFTED J{5333
{CH$$K{EQU{24,107{{{SHIFTED K{5334
{CH$$L{EQU{24,108{{{SHIFTED L{5335
{CH$$M{EQU{24,109{{{SHIFTED M{5336
{CH$$N{EQU{24,110{{{SHIFTED N{5337
{CH$$O{EQU{24,111{{{SHIFTED O{5338
{CH$$P{EQU{24,112{{{SHIFTED P{5339
{CH$$Q{EQU{24,113{{{SHIFTED Q{5340
{CH$$R{EQU{24,114{{{SHIFTED R{5341
{CH$$S{EQU{24,115{{{SHIFTED S{5342
{CH$$T{EQU{24,116{{{SHIFTED T{5343
{CH$$U{EQU{24,117{{{SHIFTED U{5344
{CH$$V{EQU{24,118{{{SHIFTED V{5345
{CH$$W{EQU{24,119{{{SHIFTED W{5346
{CH$$X{EQU{24,120{{{SHIFTED X{5347
{CH$$Y{EQU{24,121{{{SHIFTED Y{5348
{CH$$${EQU{24,122{{{SHIFTED Z{5349
*      IF A DELIMITER OTHER THAN CH$CM MUST BE USED IN
*      THE THIRD ARGUMENT OF INPUT(),OUTPUT() THEN .CIOD SHOULD
*      BE DEFINED AND A PARAMETER SUPPLIED FOR IODEL.
*
{IODEL{EQU{24,32{{{{5356
{{EJC{{{{{5360
*
*      DATA BLOCK FORMATS AND DEFINITIONS
*
*      THE FOLLOWING SECTIONS DESCRIBE THE DETAILED FORMAT OF
*      ALL POSSIBLE DATA BLOCKS IN STATIC AND DYNAMIC MEMORY.
*
*      EVERY BLOCK HAS A NAME OF THE FORM XXBLK WHERE XX IS A
*      UNIQUE TWO CHARACTER IDENTIFIER. THE FIRST WORD OF EVERY
*      BLOCK MUST CONTAIN A POINTER TO A PROGRAM LOCATION IN THE
*      INTERPRETOR WHICH IS IMMEDIATELY PRECEDED BY AN ADDRESS
*      CONSTANT CONTAINING THE VALUE BL$XX WHERE XX IS THE BLOCK
*      IDENTIFIER. THIS PROVIDES A UNIFORM MECHANISM FOR
*      DISTINGUISHING BETWEEN THE VARIOUS BLOCK TYPES.
*
*      IN SOME CASES, THE CONTENTS OF THE FIRST WORD IS CONSTANT
*      FOR A GIVEN BLOCK TYPE AND MERELY SERVES AS A POINTER
*      TO THE IDENTIFYING ADDRESS CONSTANT. HOWEVER, IN OTHER
*      CASES THERE ARE SEVERAL POSSIBILITIES FOR THE FIRST
*      WORD IN WHICH CASE EACH OF THE SEVERAL PROGRAM ENTRY
*      POINTS MUST BE PRECEDED BY THE APPROPRIATE CONSTANT.
*
*      IN EACH BLOCK, SOME OF THE FIELDS ARE RELOCATABLE. THIS
*      MEANS THAT THEY MAY CONTAIN A POINTER TO ANOTHER BLOCK
*      IN THE DYNAMIC AREA. (TO BE MORE PRECISE, IF THEY CONTAIN
*      A POINTER WITHIN THE DYNAMIC AREA, THEN IT IS A POINTER
*      TO A BLOCK). SUCH FIELDS MUST BE MODIFIED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL) WHENEVER BLOCKS ARE COMPACTED
*      IN THE DYNAMIC REGION. THE GARBAGE COLLECTOR (ACTUALLY
*      PROCEDURE GBCPF) REQUIRES THAT ALL SUCH RELOCATABLE
*      FIELDS IN A BLOCK MUST BE CONTIGUOUS.
{{EJC{{{{{5391
*
*      THE DESCRIPTION FORMAT USES THE FOLLOWING SCHEME.
*
*      1)   BLOCK TITLE AND TWO CHARACTER IDENTIFIER
*
*      2)   DESCRIPTION OF BASIC USE OF BLOCK AND INDICATION
*           OF CIRCUMSTANCES UNDER WHICH IT IS CONSTRUCTED.
*
*      3)   PICTURE OF THE BLOCK FORMAT. IN THESE PICTURES LOW
*           MEMORY ADDRESSES ARE AT THE TOP OF THE PAGE. FIXED
*           LENGTH FIELDS ARE SURROUNDED BY I (LETTER I). FIELDS
*           WHICH ARE FIXED LENGTH BUT WHOSE LENGTH IS DEPENDENT
*           ON A CONFIGURATION PARAMETER ARE SURROUNDED BY *
*           (ASTERISK). VARIABLE LENGTH FIELDS ARE SURROUNDED
*           BY / (SLASH).
*
*      4)   DEFINITION OF SYMBOLIC OFFSETS TO FIELDS IN
*           BLOCK AND OF THE SIZE OF THE BLOCK IF FIXED LENGTH
*           OR OF THE SIZE OF THE FIXED LENGTH FIELDS IF THE
*           BLOCK IS VARIABLE LENGTH.
*           NOTE THAT SOME ROUTINES SUCH AS GBCPF ASSUME
*           CERTAIN OFFSETS ARE EQUAL. THE DEFINITIONS
*           GIVEN HERE ENFORCE THIS.  MAKE CHANGES TO
*           THEM ONLY WITH DUE CARE.
*
*      DEFINITIONS OF COMMON OFFSETS
*
{OFFS1{EQU{24,1{{{{5419
{OFFS2{EQU{24,2{{{{5420
{OFFS3{EQU{24,3{{{{5421
*
*      5)   DETAILED COMMENTS ON THE SIGNIFICANCE AND FORMATS
*           OF THE VARIOUS FIELDS.
*
*      THE ORDER IS ALPHABETICAL BY IDENTIFICATION CODE.
{{EJC{{{{{5427
*
*      DEFINITIONS OF BLOCK CODES
*
*      THIS TABLE PROVIDES A UNIQUE IDENTIFICATION CODE FOR
*      EACH SEPARATE BLOCK TYPE. THE FIRST WORD OF A BLOCK IN
*      THE DYNAMIC AREA ALWAYS CONTAINS THE ADDRESS OF A PROGRAM
*      ENTRY POINT. THE BLOCK CODE IS USED AS THE ENTRY POINT ID
*      THE ORDER OF THESE CODES DICTATES THE ORDER OF THE TABLE
*      USED BY THE DATATYPE FUNCTION (SCNMT IN THE CONSTANT SEC)
*
*      BLOCK CODES FOR ACCESSIBLE DATATYPES
*
*      NOTE THAT REAL AND BUFFER TYPES ARE ALWAYS INCLUDED, EVEN
*      IF THEY ARE CONDITIONALLY EXCLUDED ELSEWHERE.  THIS MAIN-
*      TAINS BLOCK TYPE CODES ACROSS ALL VERSIONS OF SPITBOL,
*      PROVIDING CONSISTANCY FOR EXTERNAL FUNCTIONS.  BUT NOTE
*      THAT THE BCBLK IS OUT OF ALPHABETIC ORDER, PLACED AT THE
*      END OF THE LIST SO AS NOT TO CHANGE THE BLOCK TYPE
*      ORDERING IN USE IN EXISTING EXTERNAL FUNCTIONS.
*
{BL$AR{EQU{24,0{{{ARBLK     ARRAY{5448
{BL$CD{EQU{24,BL$AR+1{{{CDBLK     CODE{5449
{BL$EX{EQU{24,BL$CD+1{{{EXBLK     EXPRESSION{5450
{BL$IC{EQU{24,BL$EX+1{{{ICBLK     INTEGER{5451
{BL$NM{EQU{24,BL$IC+1{{{NMBLK     NAME{5452
{BL$P0{EQU{24,BL$NM+1{{{P0BLK     PATTERN{5453
{BL$P1{EQU{24,BL$P0+1{{{P1BLK     PATTERN{5454
{BL$P2{EQU{24,BL$P1+1{{{P2BLK     PATTERN{5455
{BL$RC{EQU{24,BL$P2+1{{{RCBLK     REAL{5456
{BL$SC{EQU{24,BL$RC+1{{{SCBLK     STRING{5457
{BL$SE{EQU{24,BL$SC+1{{{SEBLK     EXPRESSION{5458
{BL$TB{EQU{24,BL$SE+1{{{TBBLK     TABLE{5459
{BL$VC{EQU{24,BL$TB+1{{{VCBLK     ARRAY{5460
{BL$XN{EQU{24,BL$VC+1{{{XNBLK     EXTERNAL{5461
{BL$XR{EQU{24,BL$XN+1{{{XRBLK     EXTERNAL{5462
{BL$BC{EQU{24,BL$XR+1{{{BCBLK     BUFFER{5463
{BL$PD{EQU{24,BL$BC+1{{{PDBLK     PROGRAM DEFINED DATATYPE{5464
*
{BL$$D{EQU{24,BL$PD+1{{{NUMBER OF BLOCK CODES FOR DATA{5466
*
*      OTHER BLOCK CODES
*
{BL$TR{EQU{24,BL$PD+1{{{TRBLK{5470
{BL$BF{EQU{24,BL$TR+1{{{BFBLK{5471
{BL$CC{EQU{24,BL$BF+1{{{CCBLK{5472
{BL$CM{EQU{24,BL$CC+1{{{CMBLK{5473
{BL$CT{EQU{24,BL$CM+1{{{CTBLK{5474
{BL$DF{EQU{24,BL$CT+1{{{DFBLK{5475
{BL$EF{EQU{24,BL$DF+1{{{EFBLK{5476
{BL$EV{EQU{24,BL$EF+1{{{EVBLK{5477
{BL$FF{EQU{24,BL$EV+1{{{FFBLK{5478
{BL$KV{EQU{24,BL$FF+1{{{KVBLK{5479
{BL$PF{EQU{24,BL$KV+1{{{PFBLK{5480
{BL$TE{EQU{24,BL$PF+1{{{TEBLK{5481
*
{BL$$I{EQU{24,0{{{DEFAULT IDENTIFICATION CODE{5483
{BL$$T{EQU{24,BL$TR+1{{{CODE FOR DATA OR TRACE BLOCK{5484
{BL$$${EQU{24,BL$TE+1{{{NUMBER OF BLOCK CODES{5485
{{EJC{{{{{5486
*
*      FIELD REFERENCES
*
*      REFERENCES TO THE FIELDS OF DATA BLOCKS ARE SYMBOLIC
*      (I.E. USE THE SYMBOLIC OFFSETS) WITH THE FOLLOWING
*      EXCEPTIONS.
*
*      1)   REFERENCES TO THE FIRST WORD ARE USUALLY NOT
*           SYMBOLIC SINCE THEY USE THE (X) OPERAND FORMAT.
*
*      2)   THE CODE WHICH CONSTRUCTS A BLOCK IS OFTEN NOT
*           SYMBOLIC AND SHOULD BE CHANGED IF THE CORRESPONDING
*           BLOCK FORMAT IS MODIFIED.
*
*      3)   THE PLC AND PSC INSTRUCTIONS IMPLY AN OFFSET
*           CORRESPONDING TO THE DEFINITION OF CFP$F.
*
*      4)   THERE ARE NON-SYMBOLIC REFERENCES (EASILY CHANGED)
*           IN THE GARBAGE COLLECTOR (PROCEDURES GBCPF, BLKLN).
*
*      5)   THE FIELDS IDVAL, FARGS APPEAR IN SEVERAL BLOCKS
*           AND ANY CHANGES MUST BE MADE IN PARALLEL TO ALL
*           BLOCKS CONTAINING THE FIELDS. THE ACTUAL REFERENCES
*           TO THESE FIELDS ARE SYMBOLIC WITH THE ABOVE
*           LISTED EXCEPTIONS.
*
*      6)   SEVERAL SPOTS IN THE CODE ASSUME THAT THE
*           DEFINITIONS OF THE FIELDS VRVAL, TEVAL, TRNXT ARE
*           THE SAME (THESE ARE SECTIONS OF CODE WHICH SEARCH
*           OUT ALONG A TRBLK CHAIN FROM A VARIABLE).
*
*      7)   REFERENCES TO THE FIELDS OF AN ARRAY BLOCK IN THE
*           ARRAY REFERENCE ROUTINE ARREF ARE NON-SYMBOLIC.
*
*      APART FROM THE EXCEPTIONS LISTED, REFERENCES ARE SYMBOLIC
*      AS FAR AS POSSIBLE AND MODIFYING THE ORDER OR NUMBER
*      OF FIELDS WILL NOT REQUIRE CHANGES.
{{EJC{{{{{5524
*
*      COMMON FIELDS FOR FUNCTION BLOCKS
*
*      BLOCKS WHICH REPRESENT CALLABLE FUNCTIONS HAVE TWO
*      COMMON FIELDS AT THE START OF THE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           /                                    /
*           /       REST OF FUNCTION BLOCK       /
*           /                                    /
*           +------------------------------------+
*
{FCODE{EQU{24,0{{{POINTER TO CODE FOR FUNCTION{5541
{FARGS{EQU{24,1{{{NUMBER OF ARGUMENTS{5542
*
*      FCODE IS A POINTER TO THE LOCATION IN THE INTERPRETOR
*      PROGRAM WHICH PROCESSES THIS TYPE OF FUNCTION CALL.
*
*      FARGS IS THE EXPECTED NUMBER OF ARGUMENTS. THE ACTUAL
*      NUMBER OF ARGUMENTS IS ADJUSTED TO THIS AMOUNT BY
*      DELETING EXTRA ARGUMENTS OR SUPPLYING TRAILING NULLS
*      FOR MISSING ONES BEFORE TRANSFERRING THOUGH FCODE.
*      A VALUE OF 999 MAY BE USED IN THIS FIELD TO INDICATE A
*      VARIABLE NUMBER OF ARGUMENTS (SEE SVBLK FIELD SVNAR).
*
*      THE BLOCK TYPES WHICH FOLLOW THIS SCHEME ARE.
*
*      FFBLK                 FIELD FUNCTION
*      DFBLK                 DATATYPE FUNCTION
*      PFBLK                 PROGRAM DEFINED FUNCTION
*      EFBLK                 EXTERNAL LOADED FUNCTION
{{EJC{{{{{5560
*
*      IDENTIFICATION FIELD
*
*
*      ID   FIELD
*
*      CERTAIN PROGRAM ACCESSIBLE OBJECTS (THOSE WHICH CONTAIN
*      OTHER DATA VALUES AND CAN BE COPIED) ARE GIVEN A UNIQUE
*      IDENTIFICATION NUMBER (SEE EXSID). THIS ID VALUE IS AN
*      ADDRESS INTEGER VALUE WHICH IS ALWAYS STORED IN WORD TWO.
*
{IDVAL{EQU{24,1{{{ID VALUE FIELD{5572
*
*      THE BLOCKS CONTAINING AN IDVAL FIELD ARE.
*
*      ARBLK                 ARRAY
*      PDBLK                 PROGRAM DEFINED DATATYPE
*      TBBLK                 TABLE
*      VCBLK                 VECTOR BLOCK (ARRAY)
*
*      NOTE THAT A ZERO IDVAL MEANS THAT THE BLOCK IS ONLY
*      HALF BUILT AND SHOULD NOT BE DUMPED (SEE DUMPR).
{{EJC{{{{{5587
*
*      ARRAY BLOCK (ARBLK)
*
*      AN ARRAY BLOCK REPRESENTS AN ARRAY VALUE OTHER THAN ONE
*      WITH ONE DIMENSION WHOSE LOWER BOUND IS ONE (SEE VCBLK).
*      AN ARBLK IS BUILT WITH A CALL TO THE FUNCTIONS CONVERT
*      (S$CNV) OR ARRAY (S$ARR).
*
*           +------------------------------------+
*           I                ARTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                ARLEN               I
*           +------------------------------------+
*           I                AROFS               I
*           +------------------------------------+
*           I                ARNDM               I
*           +------------------------------------+
*           *                ARLBD               *
*           +------------------------------------+
*           *                ARDIM               *
*           +------------------------------------+
*           *                                    *
*           * ABOVE 2 FLDS REPEATED FOR EACH DIM *
*           *                                    *
*           +------------------------------------+
*           I                ARPRO               I
*           +------------------------------------+
*           /                                    /
*           /                ARVLS               /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{5621
*
*      ARRAY BLOCK (CONTINUED)
*
{ARTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$ART{5625
{ARLEN{EQU{24,IDVAL+1{{{LENGTH OF ARBLK IN BYTES{5626
{AROFS{EQU{24,ARLEN+1{{{OFFSET IN ARBLK TO ARPRO FIELD{5627
{ARNDM{EQU{24,AROFS+1{{{NUMBER OF DIMENSIONS{5628
{ARLBD{EQU{24,ARNDM+1{{{LOW BOUND (FIRST SUBSCRIPT){5629
{ARDIM{EQU{24,ARLBD+CFP$I{{{DIMENSION (FIRST SUBSCRIPT){5630
{ARLB2{EQU{24,ARDIM+CFP$I{{{LOW BOUND (SECOND SUBSCRIPT){5631
{ARDM2{EQU{24,ARLB2+CFP$I{{{DIMENSION (SECOND SUBSCRIPT){5632
{ARPRO{EQU{24,ARDIM+CFP$I{{{ARRAY PROTOTYPE (ONE DIMENSION){5633
{ARVLS{EQU{24,ARPRO+1{{{START OF VALUES (ONE DIMENSION){5634
{ARPR2{EQU{24,ARDM2+CFP$I{{{ARRAY PROTOTYPE (TWO DIMENSIONS){5635
{ARVL2{EQU{24,ARPR2+1{{{START OF VALUES (TWO DIMENSIONS){5636
{ARSI${EQU{24,ARLBD{{{NUMBER OF STANDARD FIELDS IN BLOCK{5637
{ARDMS{EQU{24,ARLB2-ARLBD{{{SIZE OF INFO FOR ONE SET OF BOUNDS{5638
*
*      THE BOUNDS AND DIMENSION FIELDS ARE SIGNED INTEGER
*      VALUES AND EACH OCCUPY CFP$I WORDS IN THE ARBLK.
*
*      THE LENGTH OF AN ARBLK IN BYTES MAY NOT EXCEED MXLEN.
*      THIS IS REQUIRED TO KEEP NAME OFFSETS GARBAGE COLLECTABLE
*
*      THE ACTUAL VALUES ARE ARRANGED IN ROW-WISE ORDER AND
*      CAN CONTAIN A DATA POINTER OR A POINTER TO A TRBLK.
{{EJC{{{{{5724
*
*      CODE CONSTRUCTION BLOCK (CCBLK)
*
*      AT ANY ONE MOMENT THERE IS AT MOST ONE CCBLK INTO
*      WHICH THE COMPILER IS CURRENTLY STORING CODE (CDWRD).
*
*           +------------------------------------+
*           I                CCTYP               I
*           +------------------------------------+
*           I                CCLEN               I
*           +------------------------------------+
*           I                CCSLN               I
*           +------------------------------------+
*           I                CCUSE               I
*           +------------------------------------+
*           /                                    /
*           /                CCCOD               /
*           /                                    /
*           +------------------------------------+
*
{CCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CCT{5747
{CCLEN{EQU{24,CCTYP+1{{{LENGTH OF CCBLK IN BYTES{5748
{CCSLN{EQU{24,CCLEN+1{{{SOURCE LINE NUMBER{5750
{CCUSE{EQU{24,CCSLN+1{{{OFFSET PAST LAST USED WORD (BYTES){5751
{CCCOD{EQU{24,CCUSE+1{{{START OF GENERATED CODE IN BLOCK{5755
*
*      THE REASON THAT THE CCBLK IS A SEPARATE BLOCK TYPE FROM
*      THE USUAL CDBLK IS THAT THE GARBAGE COLLECTOR MUST
*      ONLY PROCESS THOSE FIELDS WHICH HAVE BEEN SET (SEE GBCPF)
{{EJC{{{{{5760
*
*      CODE BLOCK (CDBLK)
*
*      A CODE BLOCK IS BUILT FOR EACH STATEMENT COMPILED DURING
*      THE INITIAL COMPILATION OR BY SUBSEQUENT CALLS TO CODE.
*
*           +------------------------------------+
*           I                CDJMP               I
*           +------------------------------------+
*           I                CDSTM               I
*           +------------------------------------+
*           I                CDSLN               I
*           +------------------------------------+
*           I                CDLEN               I
*           +------------------------------------+
*           I                CDFAL               I
*           +------------------------------------+
*           /                                    /
*           /                CDCOD               /
*           /                                    /
*           +------------------------------------+
*
{CDJMP{EQU{24,0{{{PTR TO ROUTINE TO EXECUTE STATEMENT{5785
{CDSTM{EQU{24,CDJMP+1{{{STATEMENT NUMBER{5786
{CDSLN{EQU{24,CDSTM+1{{{SOURCE LINE NUMBER{5788
{CDLEN{EQU{24,CDSLN+1{{{LENGTH OF CDBLK IN BYTES{5789
{CDFAL{EQU{24,CDLEN+1{{{FAILURE EXIT (SEE BELOW){5790
{CDCOD{EQU{24,CDFAL+1{{{EXECUTABLE PSEUDO-CODE{5795
{CDSI${EQU{24,CDCOD{{{NUMBER OF STANDARD FIELDS IN CDBLK{5796
*
*      CDSTM IS THE STATEMENT NUMBER OF THE CURRENT STATEMENT.
*
*      CDJMP, CDFAL ARE SET AS FOLLOWS.
*
*      1)   IF THE FAILURE EXIT IS THE NEXT STATEMENT
*
*           CDJMP = B$CDS
*           CDFAL = PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   IF THE FAILURE EXIT IS A SIMPLE LABEL NAME
*
*           CDJMP = B$CDS
*           CDFAL IS A PTR TO THE VRTRA FIELD OF THE VRBLK
*
*      3)   IF THERE IS NO FAILURE EXIT (-NOFAIL MODE)
*
*           CDJMP = B$CDS
*           CDFAL = O$UNF
*
*      4)   IF THE FAILURE EXIT IS COMPLEX OR DIRECT
*
*           CDJMP = B$CDC
*           CDFAL IS THE OFFSET TO THE O$GOF WORD
{{EJC{{{{{5821
*
*      CODE BLOCK (CONTINUED)
*
*      CDCOD IS THE START OF THE ACTUAL CODE. FIRST WE DESCRIBE
*      THE CODE GENERATED FOR AN EXPRESSION. IN AN EXPRESSION,
*      ELEMENTS ARE FETCHED BY NAME OR BY VALUE. FOR EXAMPLE,
*      THE BINARY EQUAL OPERATOR FETCHES ITS LEFT ARGUMENT
*      BY NAME AND ITS RIGHT ARGUMENT BY VALUE. THESE TWO
*      CASES GENERATE QUITE DIFFERENT CODE AND ARE DESCRIBED
*      SEPARATELY. FIRST WE CONSIDER THE CODE BY VALUE CASE.
*
*      GENERATION OF CODE BY VALUE FOR EXPRESSIONS ELEMENTS.
*
*      EXPRESSION            POINTER TO EXBLK OR SEBLK
*
*      INTEGER CONSTANT      POINTER TO ICBLK
*
*      NULL CONSTANT         POINTER TO NULLS
*
*      PATTERN               (RESULTING FROM PREEVALUATION)
*                            =O$LPT
*                            POINTER TO P0BLK,P1BLK OR P2BLK
*
*      REAL CONSTANT         POINTER TO RCBLK
*
*      STRING CONSTANT       POINTER TO SCBLK
*
*      VARIABLE              POINTER TO VRGET FIELD OF VRBLK
*
*      ADDITION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ADD
*
*      AFFIRMATION           VALUE CODE FOR OPERAND
*                            =O$AFF
*
*      ALTERNATION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ALT
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O$AOV
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O$AMV
*                            NUMBER OF SUBSCRIPTS
{{EJC{{{{{5875
*
*      CODE BLOCK (CONTINUED)
*
*      ASSIGNMENT            (TO NATURAL VARIABLE)
*                            VALUE CODE FOR RIGHT OPERAND
*                            POINTER TO VRSTO FIELD OF VRBLK
*
*                            (TO ANY OTHER VARIABLE)
*                            NAME CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ASS
*
*      COMPILE ERROR         =O$CER
*
*
*      COMPLEMENTATION       VALUE CODE FOR OPERAND
*                            =O$COM
*
*      CONCATENATION         (CASE OF PRED FUNC LEFT OPERAND)
*                            VALUE CODE FOR LEFT OPERAND
*                            =O$POP
*                            VALUE CODE FOR RIGHT OPERAND
*
*                            (ALL OTHER CASES)
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$CNC
*
*      CURSOR ASSIGNMENT     NAME CODE FOR OPERAND
*                            =O$CAS
*
*      DIVISION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$DVD
*
*      EXPONENTIATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$EXP
*
*      FUNCTION CALL         (CASE OF CALL TO SYSTEM FUNCTION)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            POINTER TO SVFNC FIELD OF SVBLK
*
{{EJC{{{{{5922
*
*      CODE BLOCK (CONTINUED)
*
*      FUNCTION CALL         (CASE OF NON-SYSTEM FUNCTION 1 ARG)
*                            VALUE CODE FOR ARGUMENT
*                            =O$FNS
*                            POINTER TO VRBLK FOR FUNCTION
*
*                            (NON-SYSTEM FUNCTION, GT 1 ARG)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            =O$FNC
*                            NUMBER OF ARGUMENTS
*                            POINTER TO VRBLK FOR FUNCTION
*
*      IMMEDIATE ASSIGNMENT  VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O$IMA
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O$INV
*
*      INTERROGATION         VALUE CODE FOR OPERAND
*                            =O$INT
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O$KWV
*
*      MULTIPLICATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$MLT
*
*      NAME REFERENCE        (NATURAL VARIABLE CASE)
*                            POINTER TO NMBLK FOR NAME
*
*                            (ALL OTHER CASES)
*                            NAME CODE FOR OPERAND
*                            =O$NAM
*
*      NEGATION              =O$NTA
*                            CDBLK OFFSET OF O$NTC WORD
*                            VALUE CODE FOR OPERAND
*                            =O$NTB
*                            =O$NTC
{{EJC{{{{{5969
*
*      CODE BLOCK (CONTINUED)
*
*      PATTERN ASSIGNMENT    VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O$PAS
*
*      PATTERN MATCH         VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$PMV
*
*      PATTERN REPLACEMENT   NAME CODE FOR SUBJECT
*                            VALUE CODE FOR PATTERN
*                            =O$PMN
*                            VALUE CODE FOR REPLACEMENT
*                            =O$RPL
*
*      SELECTION             (FOR FIRST ALTERNATIVE)
*                            =O$SLA
*                            CDBLK OFFSET TO NEXT O$SLC WORD
*                            VALUE CODE FOR FIRST ALTERNATIVE
*                            =O$SLB
*                            CDBLK OFFSET PAST ALTERNATIVES
*
*                            (FOR SUBSEQUENT ALTERNATIVES)
*                            =O$SLC
*                            CDBLK OFFSET TO NEXT O$SLC,O$SLD
*                            VALUE CODE FOR ALTERNATIVE
*                            =O$SLB
*                            OFFSET IN CDBLK PAST ALTERNATIVES
*
*                            (FOR LAST ALTERNATIVE)
*                            =O$SLD
*                            VALUE CODE FOR LAST ALTERNATIVE
*
*      SUBTRACTION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$SUB
{{EJC{{{{{6008
*
*      CODE BLOCK (CONTINUED)
*
*      GENERATION OF CODE BY NAME FOR EXPRESSION ELEMENTS.
*
*      VARIABLE              =O$LVN
*                            POINTER TO VRBLK
*
*      EXPRESSION            (CASE OF *NATURAL VARIABLE)
*                            =O$LVN
*                            POINTER TO VRBLK
*
*                            (ALL OTHER CASES)
*                            =O$LEX
*                            POINTER TO EXBLK
*
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O$AON
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O$AMN
*                            NUMBER OF SUBSCRIPTS
*
*      COMPILE ERROR         =O$CER
*
*      FUNCTION CALL         (SAME CODE AS FOR VALUE CALL)
*                            =O$FNE
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O$INN
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O$KWN
*
*      ANY OTHER OPERAND IS AN ERROR IN A NAME POSITION
*
*      NOTE THAT IN THIS DESCRIPTION, =O$XXX REFERS TO THE
*      GENERATION OF A WORD CONTAINING THE ADDRESS OF ANOTHER
*      WORD WHICH CONTAINS THE ENTRY POINT ADDRESS O$XXX.
{{EJC{{{{{6056
*
*      CODE BLOCK (CONTINUED)
*
*      NOW WE CONSIDER THE OVERALL STRUCTURE OF THE CODE BLOCK
*      FOR A STATEMENT WITH POSSIBLE GOTO FIELDS.
*
*      FIRST COMES THE CODE FOR THE STATEMENT BODY.
*      THE STATEMENT BODY IS AN EXPRESSION TO BE EVALUATED
*      BY VALUE ALTHOUGH THE VALUE IS NOT ACTUALLY REQUIRED.
*      NORMAL VALUE CODE IS GENERATED FOR THE BODY OF THE
*      STATEMENT EXCEPT IN THE CASE OF A PATTERN MATCH BY
*      VALUE, IN WHICH CASE THE FOLLOWING IS GENERATED.
*
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$PMS
*
*      NEXT WE HAVE THE CODE FOR THE SUCCESS GOTO. THERE ARE
*      SEVERAL CASES AS FOLLOWS.
*
*      1)   NO SUCCESS GOTO  PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   SIMPLE LABEL     PTR TO VRTRA FIELD OF VRBLK
*
*      3)   COMPLEX GOTO     (CODE BY NAME FOR GOTO OPERAND)
*                            =O$GOC
*
*      4)   DIRECT GOTO      (CODE BY VALUE FOR GOTO OPERAND)
*                            =O$GOD
*
*      FOLLOWING THIS WE GENERATE CODE FOR THE FAILURE GOTO IF
*      IT IS DIRECT OR IF IT IS COMPLEX, SIMPLE FAILURE GOTOS
*      HAVING BEEN HANDLED BY AN APPROPRIATE SETTING OF THE
*      CDFAL FIELD OF THE CDBLK. THE GENERATED CODE IS ONE
*      OF THE FOLLOWING.
*
*      1)   COMPLEX FGOTO    =O$FIF
*                            =O$GOF
*                            NAME CODE FOR GOTO OPERAND
*                            =O$GOC
*
*      2)   DIRECT FGOTO     =O$FIF
*                            =O$GOF
*                            VALUE CODE FOR GOTO OPERAND
*                            =O$GOD
*
*      AN OPTIMIZATION OCCURS IF THE SUCCESS AND FAILURE GOTOS
*      ARE IDENTICAL AND EITHER COMPLEX OR DIRECT. IN THIS CASE,
*      NO CODE IS GENERATED FOR THE SUCCESS GOTO AND CONTROL
*      IS ALLOWED TO FALL INTO THE FAILURE GOTO ON SUCCESS.
{{EJC{{{{{6107
*
*      COMPILER BLOCK (CMBLK)
*
*      A COMPILER BLOCK (CMBLK) IS BUILT BY EXPAN TO REPRESENT
*      ONE NODE OF A TREE STRUCTURED EXPRESSION REPRESENTATION.
*
*           +------------------------------------+
*           I                CMIDN               I
*           +------------------------------------+
*           I                CMLEN               I
*           +------------------------------------+
*           I                CMTYP               I
*           +------------------------------------+
*           I                CMOPN               I
*           +------------------------------------+
*           /           CMVLS OR CMROP           /
*           /                                    /
*           /                CMLOP               /
*           /                                    /
*           +------------------------------------+
*
{CMIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CMT{6129
{CMLEN{EQU{24,CMIDN+1{{{LENGTH OF CMBLK IN BYTES{6130
{CMTYP{EQU{24,CMLEN+1{{{TYPE (C$XXX, SEE LIST BELOW){6131
{CMOPN{EQU{24,CMTYP+1{{{OPERAND POINTER (SEE BELOW){6132
{CMVLS{EQU{24,CMOPN+1{{{OPERAND VALUE POINTERS (SEE BELOW){6133
{CMROP{EQU{24,CMVLS{{{RIGHT (ONLY) OPERATOR OPERAND{6134
{CMLOP{EQU{24,CMVLS+1{{{LEFT OPERATOR OPERAND{6135
{CMSI${EQU{24,CMVLS{{{NUMBER OF STANDARD FIELDS IN CMBLK{6136
{CMUS${EQU{24,CMSI$+1{{{SIZE OF UNARY OPERATOR CMBLK{6137
{CMBS${EQU{24,CMSI$+2{{{SIZE OF BINARY OPERATOR CMBLK{6138
{CMAR1{EQU{24,CMVLS+1{{{ARRAY SUBSCRIPT POINTERS{6139
*
*      THE CMOPN AND CMVLS FIELDS ARE SET AS FOLLOWS
*
*      ARRAY REFERENCE       CMOPN = PTR TO ARRAY OPERAND
*                            CMVLS = PTRS TO SUBSCRIPT OPERANDS
*
*      FUNCTION CALL         CMOPN = PTR TO VRBLK FOR FUNCTION
*                            CMVLS = PTRS TO ARGUMENT OPERANDS
*
*      SELECTION             CMOPN = ZERO
*                            CMVLS = PTRS TO ALTERNATE OPERANDS
*
*      UNARY OPERATOR        CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO OPERAND
*
*      BINARY OPERATOR       CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO RIGHT OPERAND
*                            CMLOP = PTR TO LEFT OPERAND
{{EJC{{{{{6158
*
*      CMTYP IS SET TO INDICATE THE TYPE OF EXPRESSION ELEMENT
*      AS SHOWN BY THE FOLLOWING TABLE OF DEFINITIONS.
*
{C$ARR{EQU{24,0{{{ARRAY REFERENCE{6163
{C$FNC{EQU{24,C$ARR+1{{{FUNCTION CALL{6164
{C$DEF{EQU{24,C$FNC+1{{{DEFERRED EXPRESSION (UNARY *){6165
{C$IND{EQU{24,C$DEF+1{{{INDIRECTION (UNARY $){6166
{C$KEY{EQU{24,C$IND+1{{{KEYWORD REFERENCE (UNARY AMPERSAND){6167
{C$UBO{EQU{24,C$KEY+1{{{UNDEFINED BINARY OPERATOR{6168
{C$UUO{EQU{24,C$UBO+1{{{UNDEFINED UNARY OPERATOR{6169
{C$UO${EQU{24,C$UUO+1{{{TEST VALUE (=C$UUO+1=C$UBO+2){6170
{C$$NM{EQU{24,C$UUO+1{{{NUMBER OF CODES FOR NAME OPERANDS{6171
*
*      THE REMAINING TYPES INDICATE EXPRESSION ELEMENTS WHICH
*      CAN ONLY BE EVALUATED BY VALUE (NOT BY NAME).
*
{C$BVL{EQU{24,C$UUO+1{{{BINARY OP WITH VALUE OPERANDS{6176
{C$UVL{EQU{24,C$BVL+1{{{UNARY OPERATOR WITH VALUE OPERAND{6177
{C$ALT{EQU{24,C$UVL+1{{{ALTERNATION (BINARY BAR){6178
{C$CNC{EQU{24,C$ALT+1{{{CONCATENATION{6179
{C$CNP{EQU{24,C$CNC+1{{{CONCATENATION, NOT PATTERN MATCH{6180
{C$UNM{EQU{24,C$CNP+1{{{UNARY OP WITH NAME OPERAND{6181
{C$BVN{EQU{24,C$UNM+1{{{BINARY OP (OPERANDS BY VALUE, NAME){6182
{C$ASS{EQU{24,C$BVN+1{{{ASSIGNMENT{6183
{C$INT{EQU{24,C$ASS+1{{{INTERROGATION{6184
{C$NEG{EQU{24,C$INT+1{{{NEGATION (UNARY NOT){6185
{C$SEL{EQU{24,C$NEG+1{{{SELECTION{6186
{C$PMT{EQU{24,C$SEL+1{{{PATTERN MATCH{6187
*
{C$PR${EQU{24,C$BVN{{{LAST PREEVALUABLE CODE{6189
{C$$NV{EQU{24,C$PMT+1{{{NUMBER OF DIFFERENT CMBLK TYPES{6190
{{EJC{{{{{6191
*
*      CHARACTER TABLE BLOCK (CTBLK)
*
*      A CHARACTER TABLE BLOCK IS USED TO HOLD LOGICAL CHARACTER
*      TABLES FOR USE WITH ANY,NOTANY,SPAN,BREAK,BREAKX
*      PATTERNS. EACH CHARACTER TABLE CAN BE USED TO STORE
*      CFP$N DISTINCT TABLES AS BIT COLUMNS. A BIT COLUMN
*      ALLOCATED FOR EACH ARGUMENT OF MORE THAN ONE CHARACTER
*      IN LENGTH TO ONE OF THE ABOVE LISTED PATTERN PRIMITIVES.
*
*           +------------------------------------+
*           I                CTTYP               I
*           +------------------------------------+
*           *                                    *
*           *                                    *
*           *                CTCHS               *
*           *                                    *
*           *                                    *
*           +------------------------------------+
*
{CTTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CTT{6212
{CTCHS{EQU{24,CTTYP+1{{{START OF CHARACTER TABLE WORDS{6213
{CTSI${EQU{24,CTCHS+CFP$A{{{NUMBER OF WORDS IN CTBLK{6214
*
*      CTCHS IS CFP$A WORDS LONG AND CONSISTS OF A ONE WORD
*      BIT STRING VALUE FOR EACH POSSIBLE CHARACTER IN THE
*      INTERNAL ALPHABET. EACH OF THE CFP$N POSSIBLE BITS IN
*      A BITSTRING IS USED TO FORM A COLUMN OF BIT INDICATORS.
*      A BIT IS SET ON IF THE CHARACTER IS IN THE TABLE AND OFF
*      IF THE CHARACTER IS NOT PRESENT.
{{EJC{{{{{6222
*
*      DATATYPE FUNCTION BLOCK (DFBLK)
*
*      A DATATYPE FUNCTION IS USED TO CONTROL THE CONSTRUCTION
*      OF A PROGRAM DEFINED DATATYPE OBJECT. A CALL TO THE
*      SYSTEM FUNCTION DATA BUILDS A DFBLK FOR THE DATATYPE NAME
*
*      NOTE THAT THESE BLOCKS ARE BUILT IN STATIC BECAUSE PDBLK
*      LENGTH IS GOT FROM DFLEN FIELD.  IF DFBLK WAS IN DYNAMIC
*      STORE THIS WOULD CAUSE TROUBLE DURING PASS TWO OF GARBAGE
*      COLLECTION.  SCBLK REFERRED TO BY DFNAM FIELD IS ALSO PUT
*      IN STATIC SO THAT THERE ARE NO RELOC. FIELDS. THIS CUTS
*      GARBAGE COLLECTION TASK APPRECIABLY FOR PDBLKS WHICH ARE
*      LIKELY TO BE PRESENT IN LARGE NUMBERS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                DFLEN               I
*           +------------------------------------+
*           I                DFPDL               I
*           +------------------------------------+
*           I                DFNAM               I
*           +------------------------------------+
*           /                                    /
*           /                DFFLD               /
*           /                                    /
*           +------------------------------------+
*
{DFLEN{EQU{24,FARGS+1{{{LENGTH OF DFBLK IN BYTES{6254
{DFPDL{EQU{24,DFLEN+1{{{LENGTH OF CORRESPONDING PDBLK{6255
{DFNAM{EQU{24,DFPDL+1{{{POINTER TO SCBLK FOR DATATYPE NAME{6256
{DFFLD{EQU{24,DFNAM+1{{{START OF VRBLK PTRS FOR FIELD NAMES{6257
{DFFLB{EQU{24,DFFLD-1{{{OFFSET BEHIND DFFLD FOR FIELD FUNC{6258
{DFSI${EQU{24,DFFLD{{{NUMBER OF STANDARD FIELDS IN DFBLK{6259
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$DFC
*
*      FARGS (THE NUMBER OF ARGUMENTS) IS THE NUMBER OF FIELDS.
{{EJC{{{{{6264
*
*      DOPE VECTOR BLOCK (DVBLK)
*
*      A DOPE VECTOR IS ASSEMBLED FOR EACH POSSIBLE OPERATOR IN
*      THE SNOBOL4 LANGUAGE AS PART OF THE CONSTANT SECTION.
*
*           +------------------------------------+
*           I                DVOPN               I
*           +------------------------------------+
*           I                DVTYP               I
*           +------------------------------------+
*           I                DVLPR               I
*           +------------------------------------+
*           I                DVRPR               I
*           +------------------------------------+
*
{DVOPN{EQU{24,0{{{ENTRY ADDRESS (PTR TO O$XXX){6281
{DVTYP{EQU{24,DVOPN+1{{{TYPE CODE (C$XXX, SEE CMBLK){6282
{DVLPR{EQU{24,DVTYP+1{{{LEFT PRECEDENCE (LLXXX, SEE BELOW){6283
{DVRPR{EQU{24,DVLPR+1{{{RIGHT PRECEDENCE (RRXXX, SEE BELOW){6284
{DVUS${EQU{24,DVLPR+1{{{SIZE OF UNARY OPERATOR DV{6285
{DVBS${EQU{24,DVRPR+1{{{SIZE OF BINARY OPERATOR DV{6286
{DVUBS{EQU{24,DVUS$+DVBS${{{SIZE OF UNOP + BINOP (SEE SCANE){6287
*
*      THE CONTENTS OF THE DVTYP FIELD IS COPIED INTO THE CMTYP
*      FIELD OF THE CMBLK FOR THE OPERATOR IF IT IS USED.
*
*      THE CMOPN FIELD OF AN OPERATOR CMBLK POINTS TO THE DVBLK
*      ITSELF, PROVIDING THE REQUIRED ENTRY ADDRESS POINTER PTR.
*
*      FOR NORMALLY UNDEFINED OPERATORS, THE DVOPN (AND CMOPN)
*      FIELDS CONTAIN A WORD OFFSET FROM R$UBA OF THE FUNCTION
*      BLOCK POINTER FOR THE OPERATOR (INSTEAD OF O$XXX PTR).
*      FOR CERTAIN SPECIAL OPERATORS, THE DVOPN FIELD IS NOT
*      REQUIRED AT ALL AND IS ASSEMBLED AS ZERO.
*
*      THE LEFT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE LEFT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS THE
*      PRECEDENCE OF THE OPERATOR TOWARDS ITS RIGHT OPERAND.
*
*      THE RIGHT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE RIGHT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS
*      THE PRECEDENCE OF THE OPERATOR TOWARDS ITS LEFT OPERAND.
*
*      HIGHER PRECEDENCE VALUES CORRESPOND TO A TIGHTER BINDING
*      CAPABILITY. THUS WE HAVE THE LEFT PRECEDENCE LOWER
*      (HIGHER) THAN THE RIGHT PRECEDENCE FOR RIGHT (LEFT)
*      ASSOCIATIVE BINARY OPERATORS.
*
*      THE LEFT PRECEDENCE OF UNARY OPERATORS IS SET TO AN
*      ARBITRARY HIGH VALUE. THE RIGHT VALUE IS NOT REQUIRED AND
*      CONSEQUENTLY THE DVRPR FIELD IS OMITTED FOR UNARY OPS.
{{EJC{{{{{6317
*
*      TABLE OF OPERATOR PRECEDENCE VALUES
*
{RRASS{EQU{24,10{{{RIGHT     EQUAL{6321
{LLASS{EQU{24,00{{{LEFT      EQUAL{6322
{RRPMT{EQU{24,20{{{RIGHT     QUESTION MARK{6323
{LLPMT{EQU{24,30{{{LEFT      QUESTION MARK{6324
{RRAMP{EQU{24,40{{{RIGHT     AMPERSAND{6325
{LLAMP{EQU{24,50{{{LEFT      AMPERSAND{6326
{RRALT{EQU{24,70{{{RIGHT     VERTICAL BAR{6327
{LLALT{EQU{24,60{{{LEFT      VERTICAL BAR{6328
{RRCNC{EQU{24,90{{{RIGHT     BLANK{6329
{LLCNC{EQU{24,80{{{LEFT      BLANK{6330
{RRATS{EQU{24,110{{{RIGHT     AT{6331
{LLATS{EQU{24,100{{{LEFT      AT{6332
{RRPLM{EQU{24,120{{{RIGHT     PLUS, MINUS{6333
{LLPLM{EQU{24,130{{{LEFT      PLUS, MINUS{6334
{RRNUM{EQU{24,140{{{RIGHT     NUMBER{6335
{LLNUM{EQU{24,150{{{LEFT      NUMBER{6336
{RRDVD{EQU{24,160{{{RIGHT     SLASH{6337
{LLDVD{EQU{24,170{{{LEFT      SLASH{6338
{RRMLT{EQU{24,180{{{RIGHT     ASTERISK{6339
{LLMLT{EQU{24,190{{{LEFT      ASTERISK{6340
{RRPCT{EQU{24,200{{{RIGHT     PERCENT{6341
{LLPCT{EQU{24,210{{{LEFT      PERCENT{6342
{RREXP{EQU{24,230{{{RIGHT     EXCLAMATION{6343
{LLEXP{EQU{24,220{{{LEFT      EXCLAMATION{6344
{RRDLD{EQU{24,240{{{RIGHT     DOLLAR, DOT{6345
{LLDLD{EQU{24,250{{{LEFT      DOLLAR, DOT{6346
{RRNOT{EQU{24,270{{{RIGHT     NOT{6347
{LLNOT{EQU{24,260{{{LEFT      NOT{6348
{LLUNO{EQU{24,999{{{LEFT      ALL UNARY OPERATORS{6349
*
*      PRECEDENCES ARE THE SAME AS IN BTL SNOBOL4 WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      1)   BINARY QUESTION MARK IS LOWERED AND MADE LEFT ASSOC-
*           IATIVE TO REFLECT ITS NEW USE FOR PATTERN MATCHING.
*
*      2)   ALTERNATION AND CONCATENATION ARE MADE RIGHT
*           ASSOCIATIVE FOR GREATER EFFICIENCY IN PATTERN
*           CONSTRUCTION AND MATCHING RESPECTIVELY. THIS CHANGE
*           IS TRANSPARENT TO THE SNOBOL4 PROGRAMMER.
*
*      3)   THE EQUAL SIGN HAS BEEN ADDED AS A LOW PRECEDENCE
*           OPERATOR WHICH IS RIGHT ASSOCIATIVE TO REFLECT ITS
*           MORE GENERAL USAGE IN THIS VERSION OF SNOBOL4.
{{EJC{{{{{6365
*
*      EXTERNAL FUNCTION BLOCK (EFBLK)
*
*      AN EXTERNAL FUNCTION BLOCK IS USED TO CONTROL THE CALLING
*      OF AN EXTERNAL FUNCTION. IT IS BUILT BY A CALL TO LOAD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                EFLEN               I
*           +------------------------------------+
*           I                EFUSE               I
*           +------------------------------------+
*           I                EFCOD               I
*           +------------------------------------+
*           I                EFVAR               I
*           +------------------------------------+
*           I                EFRSL               I
*           +------------------------------------+
*           /                                    /
*           /                EFTAR               /
*           /                                    /
*           +------------------------------------+
*
{EFLEN{EQU{24,FARGS+1{{{LENGTH OF EFBLK IN BYTES{6392
{EFUSE{EQU{24,EFLEN+1{{{USE COUNT (FOR OPSYN){6393
{EFCOD{EQU{24,EFUSE+1{{{PTR TO CODE (FROM SYSLD){6394
{EFVAR{EQU{24,EFCOD+1{{{PTR TO ASSOCIATED VRBLK{6395
{EFRSL{EQU{24,EFVAR+1{{{RESULT TYPE (SEE BELOW){6396
{EFTAR{EQU{24,EFRSL+1{{{ARGUMENT TYPES (SEE BELOW){6397
{EFSI${EQU{24,EFTAR{{{NUMBER OF STANDARD FIELDS IN EFBLK{6398
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$EFC.
*
*      EFUSE IS USED TO KEEP TRACK OF MULTIPLE USE WHEN OPSYN
*      IS EMPLOYED. THE FUNCTION IS AUTOMATICALLY UNLOADED
*      WHEN THERE ARE NO MORE REFERENCES TO THE FUNCTION.
*
*      EFRSL AND EFTAR ARE TYPE CODES AS FOLLOWS.
*
*           0                TYPE IS UNCONVERTED
*           1                TYPE IS STRING
*           2                TYPE IS INTEGER
*           3                TYPE IS REAL
*           4                TYPE IS FILE
{{EJC{{{{{6421
*
*      EXPRESSION VARIABLE BLOCK (EVBLK)
*
*      IN THIS VERSION OF SPITBOL, AN EXPRESSION CAN BE USED IN
*      ANY POSITION WHICH WOULD NORMALLY EXPECT A NAME (FOR
*      EXAMPLE ON THE LEFT SIDE OF EQUALS OR AS THE RIGHT
*      ARGUMENT OF BINARY DOT). THIS CORRESPONDS TO THE CREATION
*      OF A PSEUDO-VARIABLE WHICH IS REPRESENTED BY A POINTER TO
*      AN EXPRESSION VARIABLE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                EVTYP               I
*           +------------------------------------+
*           I                EVEXP               I
*           +------------------------------------+
*           I                EVVAR               I
*           +------------------------------------+
*
{EVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$EVT{6440
{EVEXP{EQU{24,EVTYP+1{{{POINTER TO EXBLK FOR EXPRESSION{6441
{EVVAR{EQU{24,EVEXP+1{{{POINTER TO TRBEV DUMMY TRBLK{6442
{EVSI${EQU{24,EVVAR+1{{{SIZE OF EVBLK{6443
*
*      THE NAME OF AN EXPRESSION VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE EVBLK AND AN OFFSET OF EVVAR. THIS
*      VALUE APPEARS TO BE TRAPPED BY THE DUMMY TRBEV BLOCK.
*
*      NOTE THAT THERE IS NO NEED TO ALLOW FOR THE CASE OF AN
*      EXPRESSION VARIABLE WHICH REFERENCES AN SEBLK SINCE A
*      VARIABLE WHICH IS OF THE FORM *VAR IS EQUIVALENT TO VAR.
{{EJC{{{{{6452
*
*      EXPRESSION BLOCK (EXBLK)
*
*      AN EXPRESSION BLOCK IS BUILT FOR EACH EXPRESSION
*      REFERENCED IN A PROGRAM OR CREATED BY EVAL OR CONVERT
*      DURING EXECUTION OF A PROGRAM.
*
*           +------------------------------------+
*           I                EXTYP               I
*           +------------------------------------+
*           I                EXSTM               I
*           +------------------------------------+
*           I                EXSLN               I
*           +------------------------------------+
*           I                EXLEN               I
*           +------------------------------------+
*           I                EXFLC               I
*           +------------------------------------+
*           /                                    /
*           /                EXCOD               /
*           /                                    /
*           +------------------------------------+
*
{EXTYP{EQU{24,0{{{PTR TO ROUTINE B$EXL TO LOAD EXPR{6478
{EXSTM{EQU{24,CDSTM{{{STORES STMNT NO. DURING EVALUATION{6479
{EXSLN{EQU{24,EXSTM+1{{{STORES LINE NO. DURING EVALUATION{6481
{EXLEN{EQU{24,EXSLN+1{{{LENGTH OF EXBLK IN BYTES{6482
{EXFLC{EQU{24,EXLEN+1{{{FAILURE CODE (=O$FEX){6486
{EXCOD{EQU{24,EXFLC+1{{{PSEUDO-CODE FOR EXPRESSION{6487
{EXSI${EQU{24,EXCOD{{{NUMBER OF STANDARD FIELDS IN EXBLK{6488
*
*      THERE ARE TWO CASES FOR EXCOD DEPENDING ON WHETHER THE
*      EXPRESSION CAN BE EVALUATED BY NAME (SEE DESCRIPTION
*      OF CDBLK FOR DETAILS OF CODE FOR EXPRESSIONS).
*
*      IF THE EXPRESSION CAN BE EVALUATED BY NAME WE HAVE.
*
*                            (CODE FOR EXPR BY NAME)
*                            =O$RNM
*
*      IF THE EXPRESSION CAN ONLY BE EVALUATED BY VALUE.
*
*                            (CODE FOR EXPR BY VALUE)
*                            =O$RVL
{{EJC{{{{{6503
*
*      FIELD FUNCTION BLOCK (FFBLK)
*
*      A FIELD FUNCTION BLOCK IS USED TO CONTROL THE SELECTION
*      OF A FIELD FROM A PROGRAM DEFINED DATATYPE BLOCK.
*      A CALL TO DATA CREATES AN FFBLK FOR EACH FIELD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                FFDFP               I
*           +------------------------------------+
*           I                FFNXT               I
*           +------------------------------------+
*           I                FFOFS               I
*           +------------------------------------+
*
{FFDFP{EQU{24,FARGS+1{{{POINTER TO ASSOCIATED DFBLK{6523
{FFNXT{EQU{24,FFDFP+1{{{PTR TO NEXT FFBLK ON CHAIN OR ZERO{6524
{FFOFS{EQU{24,FFNXT+1{{{OFFSET (BYTES) TO FIELD IN PDBLK{6525
{FFSI${EQU{24,FFOFS+1{{{SIZE OF FFBLK IN WORDS{6526
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$FFC.
*
*      FARGS ALWAYS CONTAINS ONE.
*
*      FFDFP IS USED TO VERIFY THAT THE CORRECT PROGRAM DEFINED
*      DATATYPE IS BEING ACCESSED BY THIS CALL.
*      FFDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      FFOFS IS USED TO SELECT THE APPROPRIATE FIELD. NOTE THAT
*      IT IS AN ACTUAL OFFSET (NOT A FIELD NUMBER)
*
*      FFNXT IS USED TO POINT TO THE NEXT FFBLK OF THE SAME NAME
*      IN THE CASE WHERE THERE ARE SEVERAL FIELDS OF THE SAME
*      NAME FOR DIFFERENT DATATYPES. ZERO MARKS THE END OF CHAIN
{{EJC{{{{{6542
*
*      INTEGER CONSTANT BLOCK (ICBLK)
*
*      AN ICBLK IS CREATED FOR EVERY INTEGER REFERENCED OR
*      CREATED BY A PROGRAM. NOTE HOWEVER THAT CERTAIN INTERNAL
*      INTEGER VALUES ARE STORED AS ADDRESSES (E.G. THE LENGTH
*      FIELD IN A STRING CONSTANT BLOCK)
*
*           +------------------------------------+
*           I                ICGET               I
*           +------------------------------------+
*           *                ICVAL               *
*           +------------------------------------+
*
{ICGET{EQU{24,0{{{PTR TO ROUTINE B$ICL TO LOAD INT{6557
{ICVAL{EQU{24,ICGET+1{{{INTEGER VALUE{6558
{ICSI${EQU{24,ICVAL+CFP$I{{{SIZE OF ICBLK{6559
*
*      THE LENGTH OF THE ICVAL FIELD IS CFP$I.
{{EJC{{{{{6562
*
*      KEYWORD VARIABLE BLOCK (KVBLK)
*
*      A KVBLK IS USED TO REPRESENT A KEYWORD PSEUDO-VARIABLE.
*      A KVBLK IS BUILT FOR EACH KEYWORD REFERENCE (KWNAM).
*
*           +------------------------------------+
*           I                KVTYP               I
*           +------------------------------------+
*           I                KVVAR               I
*           +------------------------------------+
*           I                KVNUM               I
*           +------------------------------------+
*
{KVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$KVT{6577
{KVVAR{EQU{24,KVTYP+1{{{POINTER TO DUMMY BLOCK TRBKV{6578
{KVNUM{EQU{24,KVVAR+1{{{KEYWORD NUMBER{6579
{KVSI${EQU{24,KVNUM+1{{{SIZE OF KVBLK{6580
*
*      THE NAME OF A KEYWORD VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE KVBLK AND AN OFFSET OF KVVAR. THE
*      VALUE APPEARS TO BE TRAPPED BY THE POINTER TO TRBKV.
{{EJC{{{{{6585
*
*      NAME BLOCK (NMBLK)
*
*      A NAME BLOCK IS USED WHEREVER A NAME MUST BE STORED AS
*      A VALUE FOLLOWING USE OF THE UNARY DOT OPERATOR.
*
*           +------------------------------------+
*           I                NMTYP               I
*           +------------------------------------+
*           I                NMBAS               I
*           +------------------------------------+
*           I                NMOFS               I
*           +------------------------------------+
*
{NMTYP{EQU{24,0{{{PTR TO ROUTINE B$NML TO LOAD NAME{6600
{NMBAS{EQU{24,NMTYP+1{{{BASE POINTER FOR VARIABLE{6601
{NMOFS{EQU{24,NMBAS+1{{{OFFSET FOR VARIABLE{6602
{NMSI${EQU{24,NMOFS+1{{{SIZE OF NMBLK{6603
*
*      THE ACTUAL FIELD REPRESENTING THE CONTENTS OF THE NAME
*      IS FOUND NMOFS BYTES PAST THE ADDRESS IN NMBAS.
*
*      THE NAME IS SPLIT INTO BASE AND OFFSET FORM TO AVOID
*      CREATION OF A POINTER INTO THE MIDDLE OF A BLOCK WHICH
*      COULD NOT BE HANDLED PROPERLY BY THE GARBAGE COLLECTOR.
*
*      A NAME MAY BE BUILT FOR ANY VARIABLE (SEE SECTION ON
*      REPRESENTATIONS OF VARIABLES) THIS INCLUDES THE
*      CASES OF PSEUDO-VARIABLES.
{{EJC{{{{{6615
*
*      PATTERN BLOCK, NO PARAMETERS (P0BLK)
*
*      A P0BLK IS USED TO REPRESENT PATTERN NODES WHICH DO
*      NOT REQUIRE THE USE OF ANY PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*
{PCODE{EQU{24,0{{{PTR TO MATCH ROUTINE (P$XXX){6628
{PTHEN{EQU{24,PCODE+1{{{POINTER TO SUBSEQUENT NODE{6629
{PASI${EQU{24,PTHEN+1{{{SIZE OF P0BLK{6630
*
*      PTHEN POINTS TO THE PATTERN BLOCK FOR THE SUBSEQUENT
*      NODE TO BE MATCHED. THIS IS A POINTER TO THE PATTERN
*      BLOCK NDNTH IF THERE IS NO SUBSEQUENT (END OF PATTERN)
*
*      PCODE IS A POINTER TO THE MATCH ROUTINE FOR THE NODE.
{{EJC{{{{{6637
*
*      PATTERN BLOCK (ONE PARAMETER)
*
*      A P1BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE ONE PARAMETER VALUE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*
{PARM1{EQU{24,PTHEN+1{{{FIRST PARAMETER VALUE{6652
{PBSI${EQU{24,PARM1+1{{{SIZE OF P1BLK IN WORDS{6653
*
*      SEE P0BLK FOR DEFINITIONS OF PCODE, PTHEN
*
*      PARM1 CONTAINS A PARAMETER VALUE USED IN MATCHING THE
*      NODE. FOR EXAMPLE, IN A LEN PATTERN, IT IS THE INTEGER
*      ARGUMENT TO LEN. THE DETAILS OF THE USE OF THE PARAMETER
*      FIELD ARE INCLUDED IN THE DESCRIPTION OF THE INDIVIDUAL
*      MATCH ROUTINES. PARM1 IS ALWAYS AN ADDRESS POINTER WHICH
*      IS PROCESSED BY THE GARBAGE COLLECTOR.
{{EJC{{{{{6663
*
*      PATTERN BLOCK (TWO PARAMETERS)
*
*      A P2BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE TWO PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
{PARM2{EQU{24,PARM1+1{{{SECOND PARAMETER VALUE{6680
{PCSI${EQU{24,PARM2+1{{{SIZE OF P2BLK IN WORDS{6681
*
*      SEE P1BLK FOR DEFINITIONS OF PCODE, PTHEN, PARM1
*
*      PARM2 IS A PARAMETER WHICH PERFORMS THE SAME SORT OF
*      FUNCTION AS PARM1 (SEE DESCRIPTION OF P1BLK).
*
*      PARM2 IS A NON-RELOCATABLE FIELD AND IS NOT
*      PROCESSED BY THE GARBAGE COLLECTOR. ACCORDINGLY, IT MAY
*      NOT CONTAIN A POINTER TO A BLOCK IN DYNAMIC MEMORY.
{{EJC{{{{{6691
*
*      PROGRAM-DEFINED DATATYPE BLOCK
*
*      A PDBLK REPRESENTS THE DATA ITEM FORMED BY A CALL TO A
*      DATATYPE FUNCTION AS DEFINED BY THE SYSTEM FUNCTION DATA.
*
*           +------------------------------------+
*           I                PDTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                PDDFP               I
*           +------------------------------------+
*           /                                    /
*           /                PDFLD               /
*           /                                    /
*           +------------------------------------+
*
{PDTYP{EQU{24,0{{{PTR TO DUMMY ROUTINE B$PDT{6710
{PDDFP{EQU{24,IDVAL+1{{{PTR TO ASSOCIATED DFBLK{6711
{PDFLD{EQU{24,PDDFP+1{{{START OF FIELD VALUE POINTERS{6712
{PDFOF{EQU{24,DFFLD-PDFLD{{{DIFFERENCE IN OFFSET TO FIELD PTRS{6713
{PDSI${EQU{24,PDFLD{{{SIZE OF STANDARD FIELDS IN PDBLK{6714
{PDDFS{EQU{24,DFSI$-PDSI${{{DIFFERENCE IN DFBLK, PDBLK SIZES{6715
*
*      THE PDDFP POINTER MAY BE USED TO DETERMINE THE DATATYPE
*      AND THE NAMES OF THE FIELDS IF REQUIRED. THE DFBLK ALSO
*      CONTAINS THE LENGTH OF THE PDBLK IN BYTES (FIELD DFPDL).
*      PDDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      PDFLD VALUES ARE STORED IN ORDER FROM LEFT TO RIGHT.
*      THEY CONTAIN VALUES OR POINTERS TO TRBLK CHAINS.
{{EJC{{{{{6724
*
*      PROGRAM DEFINED FUNCTION BLOCK (PFBLK)
*
*      A PFBLK IS CREATED FOR EACH CALL TO THE DEFINE FUNCTION
*      AND A POINTER TO THE PFBLK PLACED IN THE PROPER VRBLK.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                PFLEN               I
*           +------------------------------------+
*           I                PFVBL               I
*           +------------------------------------+
*           I                PFNLO               I
*           +------------------------------------+
*           I                PFCOD               I
*           +------------------------------------+
*           I                PFCTR               I
*           +------------------------------------+
*           I                PFRTR               I
*           +------------------------------------+
*           /                                    /
*           /                PFARG               /
*           /                                    /
*           +------------------------------------+
*
{PFLEN{EQU{24,FARGS+1{{{LENGTH OF PFBLK IN BYTES{6753
{PFVBL{EQU{24,PFLEN+1{{{POINTER TO VRBLK FOR FUNCTION NAME{6754
{PFNLO{EQU{24,PFVBL+1{{{NUMBER OF LOCALS{6755
{PFCOD{EQU{24,PFNLO+1{{{PTR TO VRBLK FOR ENTRY LABEL{6756
{PFCTR{EQU{24,PFCOD+1{{{TRBLK PTR IF CALL TRACED ELSE 0{6757
{PFRTR{EQU{24,PFCTR+1{{{TRBLK PTR IF RETURN TRACED ELSE 0{6758
{PFARG{EQU{24,PFRTR+1{{{VRBLK PTRS FOR ARGUMENTS AND LOCALS{6759
{PFAGB{EQU{24,PFARG-1{{{OFFSET BEHIND PFARG FOR ARG, LOCAL{6760
{PFSI${EQU{24,PFARG{{{NUMBER OF STANDARD FIELDS IN PFBLK{6761
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$PFC.
*
*      PFARG IS STORED IN THE FOLLOWING ORDER.
*
*           ARGUMENTS (LEFT TO RIGHT)
*           LOCALS (LEFT TO RIGHT)
{{EJC{{{{{6771
*
*      REAL CONSTANT BLOCK (RCBLK)
*
*      AN RCBLK IS CREATED FOR EVERY REAL REFERENCED OR
*      CREATED BY A PROGRAM.
*
*           +------------------------------------+
*           I                RCGET               I
*           +------------------------------------+
*           *                RCVAL               *
*           +------------------------------------+
*
{RCGET{EQU{24,0{{{PTR TO ROUTINE B$RCL TO LOAD REAL{6784
{RCVAL{EQU{24,RCGET+1{{{REAL VALUE{6785
{RCSI${EQU{24,RCVAL+CFP$R{{{SIZE OF RCBLK{6786
*
*      THE LENGTH OF THE RCVAL FIELD IS CFP$R.
{{EJC{{{{{6790
*
*      STRING CONSTANT BLOCK (SCBLK)
*
*      AN SCBLK IS BUILT FOR EVERY STRING REFERENCED OR CREATED
*      BY A PROGRAM.
*
*           +------------------------------------+
*           I                SCGET               I
*           +------------------------------------+
*           I                SCLEN               I
*           +------------------------------------+
*           /                                    /
*           /                SCHAR               /
*           /                                    /
*           +------------------------------------+
*
{SCGET{EQU{24,0{{{PTR TO ROUTINE B$SCL TO LOAD STRING{6807
{SCLEN{EQU{24,SCGET+1{{{LENGTH OF STRING IN CHARACTERS{6808
{SCHAR{EQU{24,SCLEN+1{{{CHARACTERS OF STRING{6809
{SCSI${EQU{24,SCHAR{{{SIZE OF STANDARD FIELDS IN SCBLK{6810
*
*      THE CHARACTERS OF THE STRING ARE STORED LEFT JUSTIFIED.
*      THE FINAL WORD IS PADDED ON THE RIGHT WITH ZEROS.
*      (I.E. THE CHARACTER WHOSE INTERNAL CODE IS ZERO).
*
*      THE VALUE OF SCLEN MAY NOT EXCEED MXLEN. THIS ENSURES
*      THAT CHARACTER OFFSETS (E.G. THE PATTERN MATCH CURSOR)
*      CAN BE CORRECTLY PROCESSED BY THE GARBAGE COLLECTOR.
*
*      NOTE THAT THE OFFSET TO THE CHARACTERS OF THE STRING
*      IS GIVEN IN BYTES BY CFP$F AND THAT THIS VALUE IS
*      AUTOMATICALLY ALLOWED FOR IN PLC, PSC.
*      NOTE THAT FOR A SPITBOL SCBLK, THE VALUE OF CFP$F
*      IS GIVEN BY CFP$B*SCHAR.
{{EJC{{{{{6825
*
*      SIMPLE EXPRESSION BLOCK (SEBLK)
*
*      AN SEBLK IS USED TO REPRESENT AN EXPRESSION OF THE FORM
*      *(NATURAL VARIABLE). ALL OTHER EXPRESSIONS ARE EXBLKS.
*
*           +------------------------------------+
*           I                SETYP               I
*           +------------------------------------+
*           I                SEVAR               I
*           +------------------------------------+
*
{SETYP{EQU{24,0{{{PTR TO ROUTINE B$SEL TO LOAD EXPR{6838
{SEVAR{EQU{24,SETYP+1{{{PTR TO VRBLK FOR VARIABLE{6839
{SESI${EQU{24,SEVAR+1{{{LENGTH OF SEBLK IN WORDS{6840
{{EJC{{{{{6841
*
*      STANDARD VARIABLE BLOCK (SVBLK)
*
*      AN SVBLK IS ASSEMBLED IN THE CONSTANT SECTION FOR EACH
*      VARIABLE WHICH SATISFIES ONE OF THE FOLLOWING CONDITIONS.
*
*      1)   IT IS THE NAME OF A SYSTEM FUNCTION
*      2)   IT HAS AN INITIAL VALUE
*      3)   IT HAS A KEYWORD ASSOCIATION
*      4)   IT HAS A STANDARD I/O ASSOCIATION
*      6)   IT HAS A STANDARD LABEL ASSOCIATION
*
*      IF VRBLKS ARE CONSTRUCTED FOR ANY OF THESE VARIABLES,
*      THEN THE VRSVP FIELD POINTS TO THE SVBLK (SEE VRBLK)
*
*           +------------------------------------+
*           I                SVBIT               I
*           +------------------------------------+
*           I                SVLEN               I
*           +------------------------------------+
*           /                SVCHS               /
*           +------------------------------------+
*           I                SVKNM               I
*           +------------------------------------+
*           I                SVFNC               I
*           +------------------------------------+
*           I                SVNAR               I
*           +------------------------------------+
*           I                SVLBL               I
*           +------------------------------------+
*           I                SVVAL               I
*           +------------------------------------+
{{EJC{{{{{6874
*
*      STANDARD VARIABLE BLOCK (CONTINUED)
*
{SVBIT{EQU{24,0{{{BIT STRING INDICATING ATTRIBUTES{6878
{SVLEN{EQU{24,1{{{(=SCLEN) LENGTH OF NAME IN CHARS{6879
{SVCHS{EQU{24,2{{{(=SCHAR) CHARACTERS OF NAME{6880
{SVSI${EQU{24,2{{{NUMBER OF STANDARD FIELDS IN SVBLK{6881
{SVPRE{EQU{24,1{{{SET IF PREEVALUATION PERMITTED{6882
{SVFFC{EQU{24,SVPRE+SVPRE{{{SET ON IF FAST CALL PERMITTED{6883
{SVCKW{EQU{24,SVFFC+SVFFC{{{SET ON IF KEYWORD VALUE CONSTANT{6884
{SVPRD{EQU{24,SVCKW+SVCKW{{{SET ON IF PREDICATE FUNCTION{6885
{SVNBT{EQU{24,4{{{NUMBER OF BITS TO RIGHT OF SVKNM{6886
{SVKNM{EQU{24,SVPRD+SVPRD{{{SET ON IF KEYWORD ASSOCIATION{6887
{SVFNC{EQU{24,SVKNM+SVKNM{{{SET ON IF SYSTEM FUNCTION{6888
{SVNAR{EQU{24,SVFNC+SVFNC{{{SET ON IF SYSTEM FUNCTION{6889
{SVLBL{EQU{24,SVNAR+SVNAR{{{SET ON IF SYSTEM LABEL{6890
{SVVAL{EQU{24,SVLBL+SVLBL{{{SET ON IF PREDEFINED VALUE{6891
*
*      NOTE THAT THE LAST FIVE BITS CORRESPOND IN ORDER
*      TO THE FIELDS WHICH ARE PRESENT (SEE PROCEDURE GTNVR).
*
*      THE FOLLOWING DEFINITIONS ARE USED IN THE SVBLK TABLE
*
{SVFNF{EQU{24,SVFNC+SVNAR{{{FUNCTION WITH NO FAST CALL{6898
{SVFNN{EQU{24,SVFNF+SVFFC{{{FUNCTION WITH FAST CALL, NO PREEVAL{6899
{SVFNP{EQU{24,SVFNN+SVPRE{{{FUNCTION ALLOWING PREEVALUATION{6900
{SVFPR{EQU{24,SVFNN+SVPRD{{{PREDICATE FUNCTION{6901
{SVFNK{EQU{24,SVFNN+SVKNM{{{NO PREEVAL FUNC + KEYWORD{6902
{SVKWV{EQU{24,SVKNM+SVVAL{{{KEYWORD + VALUE{6903
{SVKWC{EQU{24,SVCKW+SVKNM{{{KEYWORD WITH CONSTANT VALUE{6904
{SVKVC{EQU{24,SVKWV+SVCKW{{{CONSTANT KEYWORD + VALUE{6905
{SVKVL{EQU{24,SVKVC+SVLBL{{{CONSTANT KEYWORD + VALUE + LABEL{6906
{SVFPK{EQU{24,SVFNP+SVKVC{{{PREEVAL FCN + CONST KEYWD + VAL{6907
*
*      THE SVPRE BIT ALLOWS THE COMPILER TO PREEVALUATE A CALL
*      TO THE ASSOCIATED SYSTEM FUNCTION IF ALL THE ARGUMENTS
*      ARE THEMSELVES CONSTANTS. FUNCTIONS IN THIS CATEGORY
*      MUST HAVE NO SIDE EFFECTS AND MUST NEVER CAUSE FAILURE.
*      THE CALL MAY GENERATE AN ERROR CONDITION.
*
*      THE SVFFC BIT ALLOWS THE COMPILER TO GENERATE THE SPECIAL
*      FAST CALL AFTER ADJUSTING THE NUMBER OF ARGUMENTS. ONLY
*      THE ITEM AND APPLY FUNCTIONS FALL OUTSIDE THIS CATEGORY.
*
*      THE SVCKW BIT IS SET IF THE ASSOCIATED KEYWORD VALUE IS
*      A CONSTANT, THUS ALLOWING PREEVALUATION FOR A VALUE CALL.
*
*      THE SVPRD BIT IS SET ON FOR ALL PREDICATE FUNCTIONS TO
*      ENABLE THE SPECIAL CONCATENATION CODE OPTIMIZATION.
{{EJC{{{{{6924
*
*      SVBLK (CONTINUED)
*
*      SVKNM                 KEYWORD NUMBER
*
*           SVKNM IS PRESENT ONLY FOR A STANDARD KEYWORD ASSOC.
*           IT CONTAINS A KEYWORD NUMBER AS DEFINED BY THE
*           KEYWORD NUMBER TABLE GIVEN LATER ON.
*
*      SVFNC                 SYSTEM FUNCTION POINTER
*
*           SVFNC IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS A POINTER TO THE ACTUAL CODE FOR THE SYSTEM
*           FUNCTION. THE GENERATED CODE FOR A FAST CALL IS A
*           POINTER TO THE SVFNC FIELD OF THE SVBLK FOR THE
*           FUNCTION. THE VRFNC FIELD OF THE VRBLK POINTS TO
*           THIS SAME FIELD, IN WHICH CASE, IT SERVES AS THE
*           FCODE FIELD FOR THE FUNCTION CALL.
*
*      SVNAR                 NUMBER OF FUNCTION ARGUMENTS
*
*           SVNAR IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS THE NUMBER OF ARGUMENTS REQUIRED FOR A CALL
*           TO THE SYSTEM FUNCTION. THE COMPILER USES THIS
*           VALUE TO ADJUST THE NUMBER OF ARGUMENTS IN A FAST
*           CALL AND IN THE CASE OF A FUNCTION CALLED THROUGH
*           THE VRFNC FIELD OF THE VRBLK, THE SVNAR FIELD
*           SERVES AS THE FARGS FIELD FOR O$FNC. A SPECIAL
*           CASE OCCURS IF THIS VALUE IS SET TO 999. THIS IS
*           USED TO INDICATE THAT THE FUNCTION HAS A VARIABLE
*           NUMBER OF ARGUMENTS AND CAUSES O$FNC TO PASS CONTROL
*           WITHOUT ADJUSTING THE ARGUMENT COUNT. THE ONLY
*           PREDEFINED FUNCTIONS USING THIS ARE APPLY AND ITEM.
*
*      SVLBL                 SYSTEM LABEL POINTER
*
*           SVLBL IS PRESENT ONLY FOR A STANDARD LABEL ASSOC.
*           IT IS A POINTER TO A SYSTEM LABEL ROUTINE (L$XXX).
*           THE VRLBL FIELD OF THE CORRESPONDING VRBLK POINTS TO
*           THE SVLBL FIELD OF THE SVBLK.
*
*      SVVAL                 SYSTEM VALUE POINTER
*
*           SVVAL IS PRESENT ONLY FOR A STANDARD VALUE.
*           IT IS A POINTER TO THE PATTERN NODE (NDXXX) WHICH
*           IS THE STANDARD INITIAL VALUE OF THE VARIABLE.
*           THIS VALUE IS COPIED TO THE VRVAL FIELD OF THE VRBLK
{{EJC{{{{{6972
*
*      SVBLK (CONTINUED)
*
*      KEYWORD NUMBER TABLE
*
*      THE FOLLOWING TABLE GIVES SYMBOLIC NAMES FOR KEYWORD
*      NUMBERS. THESE VALUES ARE STORED IN THE SVKNM FIELD OF
*      SVBLKS AND IN THE KVNUM FIELD OF KVBLKS. SEE ALSO
*      PROCEDURES ASIGN, ACESS AND KWNAM.
*
*      UNPROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K$ABE{EQU{24,0{{{ABEND{6985
{K$ANC{EQU{24,K$ABE+CFP$B{{{ANCHOR{6986
{K$CAS{EQU{24,K$ANC+CFP$B{{{CASE{6988
{K$COD{EQU{24,K$CAS+CFP$B{{{CODE{6989
{K$COM{EQU{24,K$COD+CFP$B{{{COMPARE{6994
{K$DMP{EQU{24,K$COM+CFP$B{{{DUMP{6995
{K$ERL{EQU{24,K$DMP+CFP$B{{{ERRLIMIT{6999
{K$ERT{EQU{24,K$ERL+CFP$B{{{ERRTYPE{7000
{K$FTR{EQU{24,K$ERT+CFP$B{{{FTRACE{7001
{K$FLS{EQU{24,K$FTR+CFP$B{{{FULLSCAN{7002
{K$INP{EQU{24,K$FLS+CFP$B{{{INPUT{7003
{K$MXL{EQU{24,K$INP+CFP$B{{{MAXLENGTH{7004
{K$OUP{EQU{24,K$MXL+CFP$B{{{OUTPUT{7005
{K$PFL{EQU{24,K$OUP+CFP$B{{{PROFILE{7009
{K$TRA{EQU{24,K$PFL+CFP$B{{{TRACE{7010
{K$TRM{EQU{24,K$TRA+CFP$B{{{TRIM{7012
*
*      PROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K$FNC{EQU{24,K$TRM+CFP$B{{{FNCLEVEL{7016
{K$LST{EQU{24,K$FNC+CFP$B{{{LASTNO{7017
{K$LLN{EQU{24,K$LST+CFP$B{{{LASTLINE{7019
{K$LIN{EQU{24,K$LLN+CFP$B{{{LINE{7020
{K$STN{EQU{24,K$LIN+CFP$B{{{STNO{7021
*
*      KEYWORDS WITH CONSTANT PATTERN VALUES
*
{K$ABO{EQU{24,K$STN+CFP$B{{{ABORT{7028
{K$ARB{EQU{24,K$ABO+PASI${{{ARB{7029
{K$BAL{EQU{24,K$ARB+PASI${{{BAL{7030
{K$FAL{EQU{24,K$BAL+PASI${{{FAIL{7031
{K$FEN{EQU{24,K$FAL+PASI${{{FENCE{7032
{K$REM{EQU{24,K$FEN+PASI${{{REM{7033
{K$SUC{EQU{24,K$REM+PASI${{{SUCCEED{7034
{{EJC{{{{{7035
*
*      KEYWORD NUMBER TABLE (CONTINUED)
*
*      SPECIAL KEYWORDS
*
{K$ALP{EQU{24,K$SUC+1{{{ALPHABET{7041
{K$RTN{EQU{24,K$ALP+1{{{RTNTYPE{7042
{K$STC{EQU{24,K$RTN+1{{{STCOUNT{7043
{K$ETX{EQU{24,K$STC+1{{{ERRTEXT{7044
{K$FIL{EQU{24,K$ETX+1{{{FILE{7046
{K$LFL{EQU{24,K$FIL+1{{{LASTFILE{7047
{K$STL{EQU{24,K$LFL+1{{{STLIMIT{7048
{K$LCS{EQU{24,K$STL+1{{{LCASE{7053
{K$UCS{EQU{24,K$LCS+1{{{UCASE{7054
*
*      RELATIVE OFFSETS OF SPECIAL KEYWORDS
*
{K$$AL{EQU{24,K$ALP-K$ALP{{{ALPHABET{7059
{K$$RT{EQU{24,K$RTN-K$ALP{{{RTNTYPE{7060
{K$$SC{EQU{24,K$STC-K$ALP{{{STCOUNT{7061
{K$$ET{EQU{24,K$ETX-K$ALP{{{ERRTEXT{7062
{K$$FL{EQU{24,K$FIL-K$ALP{{{FILE{7064
{K$$LF{EQU{24,K$LFL-K$ALP{{{LASTFILE{7065
{K$$SL{EQU{24,K$STL-K$ALP{{{STLIMIT{7067
{K$$LC{EQU{24,K$LCS-K$ALP{{{LCASE{7069
{K$$UC{EQU{24,K$UCS-K$ALP{{{UCASE{7070
{K$$N${EQU{24,K$$UC+1{{{NUMBER OF SPECIAL CASES{7071
*
*      SYMBOLS USED IN ASIGN AND ACESS PROCEDURES
*
{K$P$${EQU{24,K$FNC{{{FIRST PROTECTED KEYWORD{7078
{K$V$${EQU{24,K$ABO{{{FIRST KEYWORD WITH CONSTANT VALUE{7079
{K$S$${EQU{24,K$ALP{{{FIRST KEYWORD WITH SPECIAL ACESS{7080
{{EJC{{{{{7081
*
*      FORMAT OF A TABLE BLOCK (TBBLK)
*
*      A TABLE BLOCK IS USED TO REPRESENT A TABLE VALUE.
*      IT IS BUILT BY A CALL TO THE TABLE OR CONVERT FUNCTIONS.
*
*           +------------------------------------+
*           I                TBTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                TBLEN               I
*           +------------------------------------+
*           I                TBINV               I
*           +------------------------------------+
*           /                                    /
*           /                TBBUK               /
*           /                                    /
*           +------------------------------------+
*
{TBTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TBT{7102
{TBLEN{EQU{24,OFFS2{{{LENGTH OF TBBLK IN BYTES{7103
{TBINV{EQU{24,OFFS3{{{DEFAULT INITIAL LOOKUP VALUE{7104
{TBBUK{EQU{24,TBINV+1{{{START OF HASH BUCKET POINTERS{7105
{TBSI${EQU{24,TBBUK{{{SIZE OF STANDARD FIELDS IN TBBLK{7106
{TBNBK{EQU{24,11{{{DEFAULT NO. OF BUCKETS{7107
*
*      THE TABLE BLOCK IS A HASH TABLE WHICH POINTS TO CHAINS
*      OF TABLE ELEMENT BLOCKS REPRESENTING THE ELEMENTS
*      IN THE TABLE WHICH HASH INTO THE SAME BUCKET.
*
*      TBBUK ENTRIES EITHER POINT TO THE FIRST TEBLK ON THE
*      CHAIN OR THEY POINT TO THE TBBLK ITSELF TO INDICATE THE
*      END OF THE CHAIN.
{{EJC{{{{{7116
*
*      TABLE ELEMENT BLOCK (TEBLK)
*
*      A TABLE ELEMENT IS USED TO REPRESENT A SINGLE ENTRY IN
*      A TABLE (SEE DESCRIPTION OF TBBLK FORMAT FOR HASH TABLE)
*
*           +------------------------------------+
*           I                TETYP               I
*           +------------------------------------+
*           I                TESUB               I
*           +------------------------------------+
*           I                TEVAL               I
*           +------------------------------------+
*           I                TENXT               I
*           +------------------------------------+
*
{TETYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TET{7133
{TESUB{EQU{24,TETYP+1{{{SUBSCRIPT VALUE{7134
{TEVAL{EQU{24,TESUB+1{{{(=VRVAL) TABLE ELEMENT VALUE{7135
{TENXT{EQU{24,TEVAL+1{{{LINK TO NEXT TEBLK{7136
*      SEE S$CNV WHERE RELATION IS ASSUMED WITH TENXT AND TBBUK
{TESI${EQU{24,TENXT+1{{{SIZE OF TEBLK IN WORDS{7138
*
*      TENXT POINTS TO THE NEXT TEBLK ON THE HASH CHAIN FROM THE
*      TBBUK CHAIN FOR THIS HASH INDEX. AT THE END OF THE CHAIN,
*      TENXT POINTS BACK TO THE START OF THE TBBLK.
*
*      TEVAL CONTAINS A DATA POINTER OR A TRBLK POINTER.
*
*      TESUB CONTAINS A DATA POINTER.
{{EJC{{{{{7147
*
*      TRAP BLOCK (TRBLK)
*
*      A TRAP BLOCK IS USED TO REPRESENT A TRACE OR INPUT OR
*      OUTPUT ASSOCIATION IN RESPONSE TO A CALL TO THE TRACE
*      INPUT OR OUTPUT SYSTEM FUNCTIONS. SEE BELOW FOR DETAILS
*
*           +------------------------------------+
*           I                TRIDN               I
*           +------------------------------------+
*           I                TRTYP               I
*           +------------------------------------+
*           I  TRVAL OR TRLBL OR TRNXT OR TRKVR  I
*           +------------------------------------+
*           I       TRTAG OR TRTER OR TRTRF      I
*           +------------------------------------+
*           I            TRFNC OR TRFPT          I
*           +------------------------------------+
*
{TRIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TRT{7167
{TRTYP{EQU{24,TRIDN+1{{{TRAP TYPE CODE{7168
{TRVAL{EQU{24,TRTYP+1{{{VALUE OF TRAPPED VARIABLE (=VRVAL){7169
{TRNXT{EQU{24,TRVAL{{{PTR TO NEXT TRBLK ON TRBLK CHAIN{7170
{TRLBL{EQU{24,TRVAL{{{PTR TO ACTUAL LABEL (TRACED LABEL){7171
{TRKVR{EQU{24,TRVAL{{{VRBLK POINTER FOR KEYWORD TRACE{7172
{TRTAG{EQU{24,TRVAL+1{{{TRACE TAG{7173
{TRTER{EQU{24,TRTAG{{{PTR TO TERMINAL VRBLK OR NULL{7174
{TRTRF{EQU{24,TRTAG{{{PTR TO TRBLK HOLDING FCBLK PTR{7175
{TRFNC{EQU{24,TRTAG+1{{{TRACE FUNCTION VRBLK (ZERO IF NONE){7176
{TRFPT{EQU{24,TRFNC{{{FCBLK PTR FOR SYSIO{7177
{TRSI${EQU{24,TRFNC+1{{{NUMBER OF WORDS IN TRBLK{7178
*
{TRTIN{EQU{24,0{{{TRACE TYPE FOR INPUT ASSOCIATION{7180
{TRTAC{EQU{24,TRTIN+1{{{TRACE TYPE FOR ACCESS TRACE{7181
{TRTVL{EQU{24,TRTAC+1{{{TRACE TYPE FOR VALUE TRACE{7182
{TRTOU{EQU{24,TRTVL+1{{{TRACE TYPE FOR OUTPUT ASSOCIATION{7183
{TRTFC{EQU{24,TRTOU+1{{{TRACE TYPE FOR FCBLK IDENTIFICATION{7184
{{EJC{{{{{7185
*
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE INPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR INPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      VARIABLE ACCESS TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTAC
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      VARIABLE VALUE TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTVL
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{7227
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE OUTPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTOU
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR OUTPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      FUNCTION CALL TRACE
*
*           THE PFCTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      FUNCTION RETURN TRACE
*
*           THE PFRTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      LABEL TRACE
*
*           THE VRLBL OF THE VRBLK FOR THE LABEL IS
*           CHANGED TO POINT TO A TRBLK AND THE VRTRA FIELD IS
*           SET TO B$VRT TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRLBL POINTS TO THE ACTUAL LABEL (CDBLK) VALUE
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{7275
*
*      TRAP BLOCK (CONTINUED)
*
*      KEYWORD TRACE
*
*           KEYWORDS WHICH CAN BE TRACED POSSESS A UNIQUE
*           LOCATION WHICH IS ZERO IF THERE IS NO TRACE AND
*           POINTS TO A TRBLK IF THERE IS A TRACE. THE LOCATIONS
*           ARE AS FOLLOWS.
*
*           R$ERT            ERRTYPE
*           R$FNC            FNCLEVEL
*           R$STC            STCOUNT
*
*           THE FORMAT OF THE TRBLK IS AS FOLLOWS.
*
*           TRTYP IS SET TO TRTIN
*           TRKVR IS A POINTER TO THE VRBLK FOR THE KEYWORD
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      INPUT/OUTPUT FILE ARG1 TRAP BLOCK
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE OF
*           A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV. THIS TRAP BLOCK IS USED
*           TO HOLD A POINTER TO THE FCBLK WHICH AN
*           IMPLEMENTATION MAY REQUEST TO HOLD INFORMATION
*           ABOUT A FILE.
*
*           TRTYP IS SET TO TRTFC
*           TRNEXT POINTS TO NEXT TRBLK OR TRVAL IS VARIABLE VAL
*           TRFNM IS 0
*           TRFPT IS THE FCBLK POINTER.
*
*      NOTE THAT WHEN MULTIPLE TRAPS ARE SET ON A VARIABLE
*      THE ORDER IS IN ASCENDING VALUE OF TRTYP FIELD.
*
*      INPUT ASSOCIATION (IF PRESENT)
*      ACCESS TRACE (IF PRESENT)
*      VALUE TRACE (IF PRESENT)
*      OUTPUT ASSOCIATION (IF PRESENT)
*
*      THE ACTUAL VALUE OF THE VARIABLE IS STORED IN THE TRVAL
*      FIELD OF THE LAST TRBLK ON THE CHAIN.
*
*      THIS IMPLEMENTATION DOES NOT PERMIT TRACE OR I/O
*      ASSOCIATIONS TO ANY OF THE PSEUDO-VARIABLES.
{{EJC{{{{{7325
*
*      VECTOR BLOCK (VCBLK)
*
*      A VCBLK IS USED TO REPRESENT AN ARRAY VALUE WHICH HAS
*      ONE DIMENSION WHOSE LOWER BOUND IS ONE. ALL OTHER ARRAYS
*      ARE REPRESENTED BY ARBLKS. A VCBLK IS CREATED BY THE
*      SYSTEM FUNCTION ARRAY (S$ARR) WHEN PASSED AN INTEGER ARG.
*
*           +------------------------------------+
*           I                VCTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                VCLEN               I
*           +------------------------------------+
*           I                VCVLS               I
*           +------------------------------------+
*
{VCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$VCT{7344
{VCLEN{EQU{24,OFFS2{{{LENGTH OF VCBLK IN BYTES{7345
{VCVLS{EQU{24,OFFS3{{{START OF VECTOR VALUES{7346
{VCSI${EQU{24,VCVLS{{{SIZE OF STANDARD FIELDS IN VCBLK{7347
{VCVLB{EQU{24,VCVLS-1{{{OFFSET ONE WORD BEHIND VCVLS{7348
{VCTBD{EQU{24,TBSI$-VCSI${{{DIFFERENCE IN SIZES - SEE PRTVL{7349
*
*      VCVLS ARE EITHER DATA POINTERS OR TRBLK POINTERS
*
*      THE DIMENSION CAN BE DEDUCED FROM VCLEN.
{{EJC{{{{{7354
*
*      VARIABLE BLOCK (VRBLK)
*
*      A VARIABLE BLOCK IS BUILT IN THE STATIC MEMORY AREA
*      FOR EVERY VARIABLE REFERENCED OR CREATED BY A PROGRAM.
*      THE ORDER OF FIELDS IS ASSUMED IN THE MODEL VRBLK STNVR.
*
*      NOTE THAT SINCE THESE BLOCKS ONLY OCCUR IN THE STATIC
*      REGION, IT IS PERMISSIBLE TO POINT TO ANY WORD IN
*      THE BLOCK AND THIS IS USED TO PROVIDE THREE DISTINCT
*      ACCESS POINTS FROM THE GENERATED CODE AS FOLLOWS.
*
*      1)   POINT TO VRGET (FIRST WORD OF VRBLK) TO LOAD THE
*           VALUE OF THE VARIABLE ONTO THE MAIN STACK.
*
*      2)   POINT TO VRSTO (SECOND WORD OF VRBLK) TO STORE THE
*           TOP STACK ELEMENT AS THE VALUE OF THE VARIABLE.
*
*      3)   POINT TO VRTRA (FOURTH WORD OF VRBLK) TO JUMP TO
*           THE LABEL ASSOCIATED WITH THE VARIABLE NAME.
*
*           +------------------------------------+
*           I                VRGET               I
*           +------------------------------------+
*           I                VRSTO               I
*           +------------------------------------+
*           I                VRVAL               I
*           +------------------------------------+
*           I                VRTRA               I
*           +------------------------------------+
*           I                VRLBL               I
*           +------------------------------------+
*           I                VRFNC               I
*           +------------------------------------+
*           I                VRNXT               I
*           +------------------------------------+
*           I                VRLEN               I
*           +------------------------------------+
*           /                                    /
*           /            VRCHS = VRSVP           /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{7397
*
*      VARIABLE BLOCK (CONTINUED)
*
{VRGET{EQU{24,0{{{POINTER TO ROUTINE TO LOAD VALUE{7401
{VRSTO{EQU{24,VRGET+1{{{POINTER TO ROUTINE TO STORE VALUE{7402
{VRVAL{EQU{24,VRSTO+1{{{VARIABLE VALUE{7403
{VRVLO{EQU{24,VRVAL-VRSTO{{{OFFSET TO VALUE FROM STORE FIELD{7404
{VRTRA{EQU{24,VRVAL+1{{{POINTER TO ROUTINE TO JUMP TO LABEL{7405
{VRLBL{EQU{24,VRTRA+1{{{POINTER TO CODE FOR LABEL{7406
{VRLBO{EQU{24,VRLBL-VRTRA{{{OFFSET TO LABEL FROM TRANSFER FIELD{7407
{VRFNC{EQU{24,VRLBL+1{{{POINTER TO FUNCTION BLOCK{7408
{VRNXT{EQU{24,VRFNC+1{{{POINTER TO NEXT VRBLK ON HASH CHAIN{7409
{VRLEN{EQU{24,VRNXT+1{{{LENGTH OF NAME (OR ZERO){7410
{VRCHS{EQU{24,VRLEN+1{{{CHARACTERS OF NAME (VRLEN GT 0){7411
{VRSVP{EQU{24,VRLEN+1{{{PTR TO SVBLK (VRLEN EQ 0){7412
{VRSI${EQU{24,VRCHS+1{{{NUMBER OF STANDARD FIELDS IN VRBLK{7413
{VRSOF{EQU{24,VRLEN-SCLEN{{{OFFSET TO DUMMY SCBLK FOR NAME{7414
{VRSVO{EQU{24,VRSVP-VRSOF{{{PSEUDO-OFFSET TO VRSVP FIELD{7415
*
*      VRGET = B$VRL IF NOT INPUT ASSOCIATED OR ACCESS TRACED
*      VRGET = B$VRA IF INPUT ASSOCIATED OR ACCESS TRACED
*
*      VRSTO = B$VRS IF NOT OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B$VRV IF OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B$VRE IF VALUE IS PROTECTED PATTERN VALUE
*
*      VRVAL POINTS TO THE APPROPRIATE VALUE UNLESS THE
*      VARIABLE IS I/O/TRACE ASSOCIATED IN WHICH CASE, VRVAL
*      POINTS TO AN APPROPRIATE TRBLK (TRAP BLOCK) CHAIN.
*
*      VRTRA = B$VRG IF THE LABEL IS NOT TRACED
*      VRTRA = B$VRT IF THE LABEL IS TRACED
*
*      VRLBL POINTS TO A CDBLK IF THERE IS A LABEL
*      VRLBL POINTS TO THE SVBLK SVLBL FIELD FOR A SYSTEM LABEL
*      VRLBL POINTS TO STNDL FOR AN UNDEFINED LABEL
*      VRLBL POINTS TO A TRBLK IF THE LABEL IS TRACED
*
*      VRFNC POINTS TO A FFBLK FOR A FIELD FUNCTION
*      VRFNC POINTS TO A DFBLK FOR A DATATYPE FUNCTION
*      VRFNC POINTS TO A PFBLK FOR A PROGRAM DEFINED FUNCTION
*      VRFNC POINTS TO A EFBLK FOR AN EXTERNAL LOADED FUNCTION
*      VRFNC POINTS TO SVFNC (SVBLK) FOR A SYSTEM FUNCTION
*      VRFNC POINTS TO STNDF IF THE FUNCTION IS UNDEFINED
*
*      VRNXT POINTS TO THE NEXT VRBLK ON THIS CHAIN UNLESS
*      THIS IS THE END OF THE CHAIN IN WHICH CASE IT IS ZERO.
*
*      VRLEN IS THE NAME LENGTH FOR A NON-SYSTEM VARIABLE.
*      VRLEN IS ZERO FOR A SYSTEM VARIABLE.
*
*      VRCHS IS THE NAME (LJRZ) IF VRLEN IS NON-ZERO.
*      VRSVP IS A PTR TO THE SVBLK IF VRLEN IS ZERO.
{{EJC{{{{{7451
*
*      FORMAT OF A NON-RELOCATABLE EXTERNAL BLOCK (XNBLK)
*
*      AN XNBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE BLOCK CONTAINS NO POINTERS TO OTHER
*      RELOCATABLE BLOCKS. AN XNBLK IS USED BY EXTERNAL FUNCTION
*      PROCESSING OR POSSIBLY FOR SYSTEM I/O ROUTINES ETC.
*      THE MACRO-SYSTEM ITSELF DOES NOT USE XNBLKS.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XNTYP               I
*           +------------------------------------+
*           I                XNLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XNDTA               /
*           /                                    /
*           +------------------------------------+
*
{XNTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$XNT{7473
{XNLEN{EQU{24,XNTYP+1{{{LENGTH OF XNBLK IN BYTES{7474
{XNDTA{EQU{24,XNLEN+1{{{DATA WORDS{7475
{XNSI${EQU{24,XNDTA{{{SIZE OF STANDARD FIELDS IN XNBLK{7476
*
*      NOTE THAT THE TERM NON-RELOCATABLE REFERS TO THE CONTENTS
*      AND NOT THE BLOCK ITSELF. AN XNBLK CAN BE MOVED AROUND IF
*      IT IS BUILT IN THE DYNAMIC MEMORY AREA.
{{EJC{{{{{7481
*
*      RELOCATABLE EXTERNAL BLOCK (XRBLK)
*
*      AN XRBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE DATA AREA IN THIS BLOCK CONSISTS ONLY
*      OF ADDRESS VALUES AND ANY ADDRESSES POINTING INTO THE
*      DYNAMIC MEMORY AREA MUST POINT TO THE START OF OTHER
*      DATA BLOCKS. SEE ALSO DESCRIPTION OF XNBLK.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XRTYP               I
*           +------------------------------------+
*           I                XRLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XRPTR               /
*           /                                    /
*           +------------------------------------+
*
{XRTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$XRT{7503
{XRLEN{EQU{24,XRTYP+1{{{LENGTH OF XRBLK IN BYTES{7504
{XRPTR{EQU{24,XRLEN+1{{{START OF ADDRESS POINTERS{7505
{XRSI${EQU{24,XRPTR{{{SIZE OF STANDARD FIELDS IN XRBLK{7506
{{EJC{{{{{7507
*
*      S$CNV (CONVERT) FUNCTION SWITCH CONSTANTS.  THE VALUES
*      ARE TIED TO THE ORDER OF THE ENTRIES IN THE SVCTB TABLE
*      AND HENCE TO THE BRANCH TABLE IN S$CNV.
*
{CNVST{EQU{24,8{{{MAX STANDARD TYPE CODE FOR CONVERT{7513
{CNVRT{EQU{24,CNVST+1{{{CONVERT CODE FOR REALS{7517
{CNVBT{EQU{24,CNVRT{{{NO BUFFERS - SAME AS REAL CODE{7520
{CNVTT{EQU{24,CNVBT+1{{{BSW CODE FOR CONVERT{7524
*
*      INPUT IMAGE LENGTH
*
{INILN{EQU{24,1024{{{DEFAULT IMAGE LENGTH FOR COMPILER{7528
{INILS{EQU{24,1024{{{IMAGE LENGTH IF -SEQU IN EFFECT{7529
*
{IONMB{EQU{24,2{{{NAME BASE USED FOR IOCHN IN SYSIO{7531
{IONMO{EQU{24,4{{{NAME OFFSET USED FOR IOCHN IN SYSIO{7532
*
*      MINIMUM VALUE FOR KEYWORD MAXLNGTH
*      SHOULD BE LARGER THAN INILN
*
{MNLEN{EQU{24,1024{{{MIN VALUE ALLOWED KEYWORD MAXLNGTH{7537
{MXERN{EQU{24,329{{{ERR NUM INADEQUATE STARTUP MEMORY{7538
*
*      IN GENERAL, MEANINGFUL MNEMONICS SHOULD BE USED FOR
*      OFFSETS. HOWEVER FOR SMALL INTEGERS USED OFTEN IN
*      LITERALS THE FOLLOWING GENERAL DEFINITIONS ARE PROVIDED.
*
{NUM01{EQU{24,1{{{{7544
{NUM02{EQU{24,2{{{{7545
{NUM03{EQU{24,3{{{{7546
{NUM04{EQU{24,4{{{{7547
{NUM05{EQU{24,5{{{{7548
{NUM06{EQU{24,6{{{{7549
{NUM07{EQU{24,7{{{{7550
{NUM08{EQU{24,8{{{{7551
{NUM09{EQU{24,9{{{{7552
{NUM10{EQU{24,10{{{{7553
{NM320{EQU{24,320{{{{7554
{NM321{EQU{24,321{{{{7555
{NINI8{EQU{24,998{{{{7556
{NINI9{EQU{24,999{{{{7557
{THSND{EQU{24,1000{{{{7558
{{EJC{{{{{7559
*
*      NUMBERS OF UNDEFINED SPITBOL OPERATORS
*
{OPBUN{EQU{24,5{{{NO. OF BINARY UNDEFINED OPS{7563
{OPUUN{EQU{24,6{{{NO OF UNARY UNDEFINED OPS{7564
*
*      OFFSETS USED IN PRTSN, PRTMI AND ACESS
*
{PRSNF{EQU{24,13{{{OFFSET USED IN PRTSN{7568
{PRTMF{EQU{24,21{{{OFFSET TO COL 21 (PRTMI){7569
{RILEN{EQU{24,1024{{{BUFFER LENGTH FOR SYSRI{7570
*
*      CODES FOR STAGES OF PROCESSING
*
{STGIC{EQU{24,0{{{INITIAL COMPILE{7574
{STGXC{EQU{24,STGIC+1{{{EXECUTION COMPILE (CODE){7575
{STGEV{EQU{24,STGXC+1{{{EXPRESSION EVAL DURING EXECUTION{7576
{STGXT{EQU{24,STGEV+1{{{EXECUTION TIME{7577
{STGCE{EQU{24,STGXT+1{{{INITIAL COMPILE AFTER END LINE{7578
{STGXE{EQU{24,STGCE+1{{{EXEC. COMPILE AFTER END LINE{7579
{STGND{EQU{24,STGCE-STGIC{{{DIFFERENCE IN STAGE AFTER END{7580
{STGEE{EQU{24,STGXE+1{{{EVAL EVALUATING EXPRESSION{7581
{STGNO{EQU{24,STGEE+1{{{NUMBER OF CODES{7582
{{EJC{{{{{7583
*
*
*      STATEMENT NUMBER PAD COUNT FOR LISTR
*
{STNPD{EQU{24,8{{{STATEMENT NO. PAD COUNT{7592
*
*      SYNTAX TYPE CODES
*
*      THESE CODES ARE RETURNED FROM THE SCANE PROCEDURE.
*
*      THEY ARE SPACED 3 APART FOR THE BENEFIT OF EXPAN.
*
{T$UOP{EQU{24,0{{{UNARY OPERATOR{7604
{T$LPR{EQU{24,T$UOP+3{{{LEFT PAREN{7605
{T$LBR{EQU{24,T$LPR+3{{{LEFT BRACKET{7606
{T$CMA{EQU{24,T$LBR+3{{{COMMA{7607
{T$FNC{EQU{24,T$CMA+3{{{FUNCTION CALL{7608
{T$VAR{EQU{24,T$FNC+3{{{VARIABLE{7609
{T$CON{EQU{24,T$VAR+3{{{CONSTANT{7610
{T$BOP{EQU{24,T$CON+3{{{BINARY OPERATOR{7611
{T$RPR{EQU{24,T$BOP+3{{{RIGHT PAREN{7612
{T$RBR{EQU{24,T$RPR+3{{{RIGHT BRACKET{7613
{T$COL{EQU{24,T$RBR+3{{{COLON{7614
{T$SMC{EQU{24,T$COL+3{{{SEMI-COLON{7615
*
*      THE FOLLOWING DEFINITIONS ARE USED ONLY IN THE GOTO FIELD
*
{T$FGO{EQU{24,T$SMC+1{{{FAILURE GOTO{7619
{T$SGO{EQU{24,T$FGO+1{{{SUCCESS GOTO{7620
*
*      THE ABOVE CODES ARE GROUPED SO THAT CODES FOR ELEMENTS
*      WHICH CAN LEGITIMATELY IMMEDIATELY PRECEDE A UNARY
*      OPERATOR COME FIRST TO FACILITATE OPERATOR SYNTAX CHECK.
*
{T$UOK{EQU{24,T$FNC{{{LAST CODE OK BEFORE UNARY OPERATOR{7626
{{EJC{{{{{7627
*
*      DEFINITIONS OF VALUES FOR EXPAN JUMP TABLE
*
{T$UO0{EQU{24,T$UOP+0{{{UNARY OPERATOR, STATE ZERO{7631
{T$UO1{EQU{24,T$UOP+1{{{UNARY OPERATOR, STATE ONE{7632
{T$UO2{EQU{24,T$UOP+2{{{UNARY OPERATOR, STATE TWO{7633
{T$LP0{EQU{24,T$LPR+0{{{LEFT PAREN, STATE ZERO{7634
{T$LP1{EQU{24,T$LPR+1{{{LEFT PAREN, STATE ONE{7635
{T$LP2{EQU{24,T$LPR+2{{{LEFT PAREN, STATE TWO{7636
{T$LB0{EQU{24,T$LBR+0{{{LEFT BRACKET, STATE ZERO{7637
{T$LB1{EQU{24,T$LBR+1{{{LEFT BRACKET, STATE ONE{7638
{T$LB2{EQU{24,T$LBR+2{{{LEFT BRACKET, STATE TWO{7639
{T$CM0{EQU{24,T$CMA+0{{{COMMA, STATE ZERO{7640
{T$CM1{EQU{24,T$CMA+1{{{COMMA, STATE ONE{7641
{T$CM2{EQU{24,T$CMA+2{{{COMMA, STATE TWO{7642
{T$FN0{EQU{24,T$FNC+0{{{FUNCTION CALL, STATE ZERO{7643
{T$FN1{EQU{24,T$FNC+1{{{FUNCTION CALL, STATE ONE{7644
{T$FN2{EQU{24,T$FNC+2{{{FUNCTION CALL, STATE TWO{7645
{T$VA0{EQU{24,T$VAR+0{{{VARIABLE, STATE ZERO{7646
{T$VA1{EQU{24,T$VAR+1{{{VARIABLE, STATE ONE{7647
{T$VA2{EQU{24,T$VAR+2{{{VARIABLE, STATE TWO{7648
{T$CO0{EQU{24,T$CON+0{{{CONSTANT, STATE ZERO{7649
{T$CO1{EQU{24,T$CON+1{{{CONSTANT, STATE ONE{7650
{T$CO2{EQU{24,T$CON+2{{{CONSTANT, STATE TWO{7651
{T$BO0{EQU{24,T$BOP+0{{{BINARY OPERATOR, STATE ZERO{7652
{T$BO1{EQU{24,T$BOP+1{{{BINARY OPERATOR, STATE ONE{7653
{T$BO2{EQU{24,T$BOP+2{{{BINARY OPERATOR, STATE TWO{7654
{T$RP0{EQU{24,T$RPR+0{{{RIGHT PAREN, STATE ZERO{7655
{T$RP1{EQU{24,T$RPR+1{{{RIGHT PAREN, STATE ONE{7656
{T$RP2{EQU{24,T$RPR+2{{{RIGHT PAREN, STATE TWO{7657
{T$RB0{EQU{24,T$RBR+0{{{RIGHT BRACKET, STATE ZERO{7658
{T$RB1{EQU{24,T$RBR+1{{{RIGHT BRACKET, STATE ONE{7659
{T$RB2{EQU{24,T$RBR+2{{{RIGHT BRACKET, STATE TWO{7660
{T$CL0{EQU{24,T$COL+0{{{COLON, STATE ZERO{7661
{T$CL1{EQU{24,T$COL+1{{{COLON, STATE ONE{7662
{T$CL2{EQU{24,T$COL+2{{{COLON, STATE TWO{7663
{T$SM0{EQU{24,T$SMC+0{{{SEMICOLON, STATE ZERO{7664
{T$SM1{EQU{24,T$SMC+1{{{SEMICOLON, STATE ONE{7665
{T$SM2{EQU{24,T$SMC+2{{{SEMICOLON, STATE TWO{7666
*
{T$NES{EQU{24,T$SM2+1{{{NUMBER OF ENTRIES IN BRANCH TABLE{7668
{{EJC{{{{{7669
*
*       DEFINITION OF OFFSETS USED IN CONTROL CARD PROCESSING
*
{CC$CA{EQU{24,0{{{-CASE{7674
{CC$DO{EQU{24,CC$CA+1{{{-DOUBLE{7675
{CC$CO{EQU{24,CC$DO+1{{{-COMPARE{7680
{CC$DU{EQU{24,CC$CO+1{{{-DUMP{7681
{CC$CP{EQU{24,CC$DU+1{{{-COPY{7686
{CC$EJ{EQU{24,CC$CP+1{{{-EJECT{7687
{CC$ER{EQU{24,CC$EJ+1{{{-ERRORS{7691
{CC$EX{EQU{24,CC$ER+1{{{-EXECUTE{7692
{CC$FA{EQU{24,CC$EX+1{{{-FAIL{7693
{CC$IN{EQU{24,CC$FA+1{{{-INCLUDE{7695
{CC$LN{EQU{24,CC$IN+1{{{-LINE{7697
{CC$LI{EQU{24,CC$LN+1{{{-LIST{7698
{CC$NR{EQU{24,CC$LI+1{{{-NOERRORS{7710
{CC$NX{EQU{24,CC$NR+1{{{-NOEXECUTE{7711
{CC$NF{EQU{24,CC$NX+1{{{-NOFAIL{7712
{CC$NL{EQU{24,CC$NF+1{{{-NOLIST{7713
{CC$NO{EQU{24,CC$NL+1{{{-NOOPT{7714
{CC$NP{EQU{24,CC$NO+1{{{-NOPRINT{7715
{CC$OP{EQU{24,CC$NP+1{{{-OPTIMISE{7716
{CC$PR{EQU{24,CC$OP+1{{{-PRINT{7717
{CC$SI{EQU{24,CC$PR+1{{{-SINGLE{7718
{CC$SP{EQU{24,CC$SI+1{{{-SPACE{7719
{CC$ST{EQU{24,CC$SP+1{{{-STITL{7720
{CC$TI{EQU{24,CC$ST+1{{{-TITLE{7721
{CC$TR{EQU{24,CC$TI+1{{{-TRACE{7722
{CC$NC{EQU{24,CC$TR+1{{{NUMBER OF CONTROL CARDS{7723
{CCNOC{EQU{24,4{{{NO. OF CHARS INCLUDED IN MATCH{7724
{CCOFS{EQU{24,7{{{OFFSET TO START OF TITLE/SUBTITLE{7725
{CCINM{EQU{24,9{{{MAX DEPTH OF INCLUDE FILE NESTING{7727
{{EJC{{{{{7729
*
*      DEFINITIONS OF STACK OFFSETS USED IN CMPIL PROCEDURE
*
*      SEE DESCRIPTION AT START OF CMPIL PROCEDURE FOR DETAILS
*      OF USE OF THESE LOCATIONS ON THE STACK.
*
{CMSTM{EQU{24,0{{{TREE FOR STATEMENT BODY{7736
{CMSGO{EQU{24,CMSTM+1{{{TREE FOR SUCCESS GOTO{7737
{CMFGO{EQU{24,CMSGO+1{{{TREE FOR FAIL GOTO{7738
{CMCGO{EQU{24,CMFGO+1{{{CONDITIONAL GOTO FLAG{7739
{CMPCD{EQU{24,CMCGO+1{{{PREVIOUS CDBLK POINTER{7740
{CMFFP{EQU{24,CMPCD+1{{{FAILURE FILL IN FLAG FOR PREVIOUS{7741
{CMFFC{EQU{24,CMFFP+1{{{FAILURE FILL IN FLAG FOR CURRENT{7742
{CMSOP{EQU{24,CMFFC+1{{{SUCCESS FILL IN OFFSET FOR PREVIOUS{7743
{CMSOC{EQU{24,CMSOP+1{{{SUCCESS FILL IN OFFSET FOR CURRENT{7744
{CMLBL{EQU{24,CMSOC+1{{{PTR TO VRBLK FOR CURRENT LABEL{7745
{CMTRA{EQU{24,CMLBL+1{{{PTR TO ENTRY CDBLK{7746
*
{CMNEN{EQU{24,CMTRA+1{{{COUNT OF STACK ENTRIES FOR CMPIL{7748
*
*      A FEW CONSTANTS USED BY THE PROFILER
{PFPD1{EQU{24,8{{{PAD POSITIONS ...{7753
{PFPD2{EQU{24,20{{{... FOR PROFILE ...{7754
{PFPD3{EQU{24,32{{{... PRINTOUT{7755
{PF$I2{EQU{24,CFP$I+CFP$I{{{SIZE OF TABLE ENTRY (2 INTS){7756
{{EJC{{{{{7759
*
*      DEFINITION OF LIMITS AND ADJUSTMENTS THAT ARE BUILT BY
*      RELCR FOR USE BY THE ROUTINES THAT RELOCATE POINTERS
*      AFTER A SAVE FILE IS RELOADED.  SEE RELOC ETC. FOR USAGE.
*
*      A BLOCK OF INFORMATION IS BUILT THAT IS USED IN
*      RELOCATING POINTERS.  THERE ARE RNSI$ INSTANCES
*      OF A RSSI$ WORD STRUCTURE.  EACH INSTANCE CORRESPONDS
*      TO ONE OF THE REGIONS THAT A POINTER MIGHT POINT INTO.
*
*      EACH STRUCTURE TAKES THE FORM:
*
*           +------------------------------------+
*           I    ADDRESS PAST END OF SECTION     I
*           +------------------------------------+
*           I  ADJUSTMENT FROM OLD TO NEW ADRS   I
*           +------------------------------------+
*           I    ADDRESS OF START OF SECTION     I
*           +------------------------------------+
*
*      THE INSTANCES ARE ORDERED THUSLY:
*
*           +------------------------------------+
*           I           DYNAMIC STORAGE          I
*           +------------------------------------+
*           I           STATIC STORAGE           I
*           +------------------------------------+
*           I       WORKING SECTION GLOBALS      I
*           +------------------------------------+
*           I          CONSTANT SECTION          I
*           +------------------------------------+
*           I            CODE SECTION            I
*           +------------------------------------+
*
*      SYMBOLIC NAMES FOR THESE LOCATIONS AS OFFSETS FROM
*      THE FIRST ENTRY ARE PROVIDED HERE.
*
*      DEFINITIONS WITHIN A SECTION
*
{RLEND{EQU{24,0{{{END{7799
{RLADJ{EQU{24,RLEND+1{{{ADJUSTMENT{7800
{RLSTR{EQU{24,RLADJ+1{{{START{7801
{RSSI${EQU{24,RLSTR+1{{{SIZE OF SECTION{7802
{RNSI${EQU{24,5{{{NUMBER OF STRUCTURES{7803
*
*      OVERALL DEFINITIONS OF ALL STRUCTURES
*
{RLDYE{EQU{24,0{{{DYNAMIC REGION END{7807
{RLDYA{EQU{24,RLDYE+1{{{DYNAMIC REGION ADJUSTMENT{7808
{RLDYS{EQU{24,RLDYA+1{{{DYNAMIC REGION START{7809
{RLSTE{EQU{24,RLDYS+1{{{STATIC REGION END{7810
{RLSTA{EQU{24,RLSTE+1{{{STATIC REGION ADJUSTMENT{7811
{RLSTS{EQU{24,RLSTA+1{{{STATIC REGION START{7812
{RLWKE{EQU{24,RLSTS+1{{{WORKING SECTION GLOBALS END{7813
{RLWKA{EQU{24,RLWKE+1{{{WORKING SECTION GLOBALS ADJUSTMENT{7814
{RLWKS{EQU{24,RLWKA+1{{{WORKING SECTION GLOBALS START{7815
{RLCNE{EQU{24,RLWKS+1{{{CONSTANTS SECTION END{7816
{RLCNA{EQU{24,RLCNE+1{{{CONSTANTS SECTION ADJUSTMENT{7817
{RLCNS{EQU{24,RLCNA+1{{{CONSTANTS SECTION START{7818
{RLCDE{EQU{24,RLCNS+1{{{CODE SECTION END{7819
{RLCDA{EQU{24,RLCDE+1{{{CODE SECTION ADJUSTMENT{7820
{RLCDS{EQU{24,RLCDA+1{{{CODE SECTION START{7821
{RLSI${EQU{24,RLCDS+1{{{NUMBER OF FIELDS IN STRUCTURE{7822
*
{{TTL{27,S P I T B O L -- CONSTANT SECTION{{{{7825
*
*      THIS SECTION CONSISTS ENTIRELY OF ASSEMBLED CONSTANTS.
*
*      ALL LABEL NAMES ARE FIVE LETTERS. THE ORDER IS
*      APPROXIMATELY ALPHABETICAL, BUT IN SOME CASES (ALWAYS
*      DOCUMENTED), CONSTANTS MUST BE PLACED IN SOME SPECIAL
*      ORDER WHICH MUST NOT BE DISTURBED.
*
*      IT MUST ALSO BE REMEMBERED THAT THERE IS A REQUIREMENT
*      FOR NO FORWARD REFERENCES WHICH ALSO DISTURBS THE
*      ALPHABETICAL ORDER IN SOME CASES.
*
{{SEC{{{{START OF CONSTANT SECTION{7838
*
*      START OF CONSTANT SECTION
*
{C$AAA{DAC{1,0{{{FIRST LOCATION OF CONSTANT SECTION{7842
*
*      FREE STORE PERCENTAGE (USED BY ALLOC)
*
{ALFSP{DAC{2,E$FSP{{{FREE STORE PERCENTAGE{7846
*
*      BIT CONSTANTS FOR GENERAL USE
*
{BITS0{DBC{1,0{{{ALL ZERO BITS{7850
{BITS1{DBC{1,1{{{ONE BIT IN LOW ORDER POSITION{7851
{BITS2{DBC{1,2{{{BIT IN POSITION 2{7852
{BITS3{DBC{1,4{{{BIT IN POSITION 3{7853
{BITS4{DBC{1,8{{{BIT IN POSITION 4{7854
{BITS5{DBC{1,16{{{BIT IN POSITION 5{7855
{BITS6{DBC{1,32{{{BIT IN POSITION 6{7856
{BITS7{DBC{1,64{{{BIT IN POSITION 7{7857
{BITS8{DBC{1,128{{{BIT IN POSITION 8{7858
{BITS9{DBC{1,256{{{BIT IN POSITION 9{7859
{BIT10{DBC{1,512{{{BIT IN POSITION 10{7860
{BIT11{DBC{1,1024{{{BIT IN POSITION 11{7861
{BIT12{DBC{1,2048{{{BIT IN POSITION 12{7862
{BITSM{DBC{2,CFP$M{{{MASK FOR MAX INTEGER{7863
*
*      BIT CONSTANTS FOR SVBLK (SVBIT FIELD) TESTS
*
{BTFNC{DBC{2,SVFNC{{{BIT TO TEST FOR FUNCTION{7867
{BTKNM{DBC{2,SVKNM{{{BIT TO TEST FOR KEYWORD NUMBER{7868
{BTLBL{DBC{2,SVLBL{{{BIT TO TEST FOR LABEL{7869
{BTFFC{DBC{2,SVFFC{{{BIT TO TEST FOR FAST CALL{7870
{BTCKW{DBC{2,SVCKW{{{BIT TO TEST FOR CONSTANT KEYWORD{7871
{BTKWV{DBC{2,SVKWV{{{BITS TO TEST FOR KEWORD WITH VALUE{7872
{BTPRD{DBC{2,SVPRD{{{BIT TO TEST FOR PREDICATE FUNCTION{7873
{BTPRE{DBC{2,SVPRE{{{BIT TO TEST FOR PREEVALUATION{7874
{BTVAL{DBC{2,SVVAL{{{BIT TO TEST FOR VALUE{7875
{{EJC{{{{{7876
*
*      LIST OF NAMES USED FOR CONTROL CARD PROCESSING
*
{CCNMS{DTC{27,/CASE/{{{{7881
{{DTC{27,/DOUB/{{{{7882
{{DTC{27,/COMP/{{{{7887
{{DTC{27,/DUMP/{{{{7889
{{DTC{27,/COPY/{{{{7891
{{DTC{27,/EJEC/{{{{7893
{{DTC{27,/ERRO/{{{{7894
{{DTC{27,/EXEC/{{{{7895
{{DTC{27,/FAIL/{{{{7896
{{DTC{27,/INCL/{{{{7898
{{DTC{27,/LINE/{{{{7901
{{DTC{27,/LIST/{{{{7903
{{DTC{27,/NOER/{{{{7904
{{DTC{27,/NOEX/{{{{7905
{{DTC{27,/NOFA/{{{{7906
{{DTC{27,/NOLI/{{{{7907
{{DTC{27,/NOOP/{{{{7908
{{DTC{27,/NOPR/{{{{7909
{{DTC{27,/OPTI/{{{{7910
{{DTC{27,/PRIN/{{{{7911
{{DTC{27,/SING/{{{{7912
{{DTC{27,/SPAC/{{{{7913
{{DTC{27,/STIT/{{{{7914
{{DTC{27,/TITL/{{{{7915
{{DTC{27,/TRAC/{{{{7916
*
*      HEADER MESSAGES FOR DUMPR PROCEDURE (SCBLK FORMAT)
*
{DMHDK{DAC{6,B$SCL{{{DUMP OF KEYWORD VALUES{7920
{{DAC{1,22{{{{7921
{{DTC{27,/Dump of Keyword Values/{{{{7922
*
{DMHDV{DAC{6,B$SCL{{{DUMP OF NATURAL VARIABLES{7924
{{DAC{1,25{{{{7925
{{DTC{27,/Dump of Natural Variables/{{{{7926
{{EJC{{{{{7927
*
*      MESSAGE TEXT FOR COMPILATION STATISTICS
*
{ENCM1{DAC{6,B$SCL{{{{7931
{{DAC{1,19{{{{7933
{{DTC{27,/Memory used (bytes)/{{{{7934
*
{ENCM2{DAC{6,B$SCL{{{{7936
{{DAC{1,19{{{{7937
{{DTC{27,/Memory left (bytes)/{{{{7938
*
{ENCM3{DAC{6,B$SCL{{{{7948
{{DAC{1,11{{{{7949
{{DTC{27,/Comp errors/{{{{7950
*
{ENCM4{DAC{6,B$SCL{{{{7952
{{DAC{1,20{{{{7957
{{DTC{27,/Comp time (millisec)/{{{{7958
*
{ENCM5{DAC{6,B$SCL{{{EXECUTION SUPPRESSED{7961
{{DAC{1,20{{{{7962
{{DTC{27,/Execution suppressed/{{{{7963
*
*      STRING CONSTANT FOR ABNORMAL END
*
{ENDAB{DAC{6,B$SCL{{{{7967
{{DAC{1,12{{{{7968
{{DTC{27,/Abnormal End/{{{{7969
{{EJC{{{{{7970
*
*      MEMORY OVERFLOW DURING INITIALISATION
*
{ENDMO{DAC{6,B$SCL{{{{7974
{ENDML{DAC{1,15{{{{7975
{{DTC{27,/Memory Overflow/{{{{7976
*
*      STRING CONSTANT FOR MESSAGE ISSUED BY L$END
*
{ENDMS{DAC{6,B$SCL{{{{7980
{{DAC{1,10{{{{7981
{{DTC{27,/Normal end/{{{{7982
*
*      FAIL MESSAGE FOR STACK FAIL SECTION
*
{ENDSO{DAC{6,B$SCL{{{STACK OVERFLOW IN GARBAGE COLLECTOR{7986
{{DAC{1,36{{{{7987
{{DTC{27,/Stack overflow in garbage collection/{{{{7988
*
*      STRING CONSTANT FOR TIME UP
*
{ENDTU{DAC{6,B$SCL{{{{7992
{{DAC{1,15{{{{7993
{{DTC{27,/Error - Time Up/{{{{7994
{{EJC{{{{{7995
*
*      STRING CONSTANT FOR ERROR MESSAGE (ERROR SECTION)
*
{ERMMS{DAC{6,B$SCL{{{ERROR{7999
{{DAC{1,5{{{{8000
{{DTC{27,/Error/{{{{8001
*
{ERMNS{DAC{6,B$SCL{{{STRING / -- /{8003
{{DAC{1,4{{{{8004
{{DTC{27,/ -- /{{{{8005
*
*      STRING CONSTANT FOR PAGE NUMBERING
*
{LSTMS{DAC{6,B$SCL{{{PAGE{8009
{{DAC{1,5{{{{8010
{{DTC{27,/Page /{{{{8011
*
*      LISTING HEADER MESSAGE
*
{HEADR{DAC{6,B$SCL{{{{8015
{{DAC{1,25{{{{8016
{{DTC{27,/Macro SPITBOL Version 3.7/{{{{8017
*
{HEADV{DAC{6,B$SCL{{{FOR EXIT() VERSION NO. CHECK{8019
{{DAC{1,3{{{{8020
{{DTC{27,/3.7/{{{{8021
*      FREE STORE PERCENTAGE (USED BY GBCOL)
*
{GBSDP{DAC{2,E$SED{{{SEDIMENT PERCENTAGE{8025
*
*      INTEGER CONSTANTS FOR GENERAL USE
*      ICBLD OPTIMISATION USES THE FIRST THREE.
*
{INT$R{DAC{6,B$ICL{{{{8031
{INTV0{DIC{16,+0{{{0{8032
{INTON{DAC{6,B$ICL{{{{8033
{INTV1{DIC{16,+1{{{1{8034
{INTTW{DAC{6,B$ICL{{{{8035
{INTV2{DIC{16,+2{{{2{8036
{INTVT{DIC{16,+10{{{10{8037
{INTVH{DIC{16,+100{{{100{8038
{INTTH{DIC{16,+1000{{{1000{8039
*
*      TABLE USED IN ICBLD OPTIMISATION
*
{INTAB{DAC{4,INT$R{{{POINTER TO 0{8043
{{DAC{4,INTON{{{POINTER TO 1{8044
{{DAC{4,INTTW{{{POINTER TO 2{8045
{{EJC{{{{{8046
*
*      SPECIAL PATTERN NODES. THE FOLLOWING PATTERN NODES
*      CONSIST SIMPLY OF A PCODE POINTER, SEE MATCH ROUTINES
*      (P$XXX) FOR FULL DETAILS OF THEIR USE AND FORMAT).
*
{NDABB{DAC{6,P$ABB{{{ARBNO{8052
{NDABD{DAC{6,P$ABD{{{ARBNO{8053
{NDARC{DAC{6,P$ARC{{{ARB{8054
{NDEXB{DAC{6,P$EXB{{{EXPRESSION{8055
{NDFNB{DAC{6,P$FNB{{{FENCE(){8056
{NDFND{DAC{6,P$FND{{{FENCE(){8057
{NDEXC{DAC{6,P$EXC{{{EXPRESSION{8058
{NDIMB{DAC{6,P$IMB{{{IMMEDIATE ASSIGNMENT{8059
{NDIMD{DAC{6,P$IMD{{{IMMEDIATE ASSIGNMENT{8060
{NDNTH{DAC{6,P$NTH{{{PATTERN END (NULL PATTERN){8061
{NDPAB{DAC{6,P$PAB{{{PATTERN ASSIGNMENT{8062
{NDPAD{DAC{6,P$PAD{{{PATTERN ASSIGNMENT{8063
{NDUNA{DAC{6,P$UNA{{{ANCHOR POINT MOVEMENT{8064
*
*      KEYWORD CONSTANT PATTERN NODES. THE FOLLOWING NODES ARE
*      USED AS THE VALUES OF PATTERN KEYWORDS AND THE INITIAL
*      VALUES OF THE CORRESPONDING NATURAL VARIABLES. ALL
*      NODES ARE IN P0BLK FORMAT AND THE ORDER IS TIED TO THE
*      DEFINITIONS OF CORRESPONDING K$XXX SYMBOLS.
*
{NDABO{DAC{6,P$ABO{{{ABORT{8072
{{DAC{4,NDNTH{{{{8073
{NDARB{DAC{6,P$ARB{{{ARB{8074
{{DAC{4,NDNTH{{{{8075
{NDBAL{DAC{6,P$BAL{{{BAL{8076
{{DAC{4,NDNTH{{{{8077
{NDFAL{DAC{6,P$FAL{{{FAIL{8078
{{DAC{4,NDNTH{{{{8079
{NDFEN{DAC{6,P$FEN{{{FENCE{8080
{{DAC{4,NDNTH{{{{8081
{NDREM{DAC{6,P$REM{{{REM{8082
{{DAC{4,NDNTH{{{{8083
{NDSUC{DAC{6,P$SUC{{{SUCCEED{8084
{{DAC{4,NDNTH{{{{8085
*
*      NULL STRING. ALL NULL VALUES POINT TO THIS STRING. THE
*      SVCHS FIELD CONTAINS A BLANK TO PROVIDE FOR EASY DEFAULT
*      PROCESSING IN TRACE, STOPTR, LPAD AND RPAD.
*      NULLW CONTAINS 10 BLANKS WHICH ENSURES AN ALL BLANK WORD
*      BUT FOR VERY EXCEPTIONAL MACHINES.
*
{NULLS{DAC{6,B$SCL{{{NULL STRING VALUE{8093
{{DAC{1,0{{{SCLEN = 0{8094
{NULLW{DTC{27,/          /{{{{8095
*
*
*      CONSTANT STRINGS FOR LCASE AND UCASE KEYWORDS
*
{LCASE{DAC{6,B$SCL{{{{8101
{{DAC{1,26{{{{8102
{{DTC{27,/abcdefghijklmnopqrstuvwxyz/{{{{8103
*
{UCASE{DAC{6,B$SCL{{{{8105
{{DAC{1,26{{{{8106
{{DTC{27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/{{{{8107
{{EJC{{{{{8109
*
*      OPERATOR DOPE VECTORS (SEE DVBLK FORMAT)
*
{OPDVC{DAC{6,O$CNC{{{CONCATENATION{8113
{{DAC{2,C$CNC{{{{8114
{{DAC{2,LLCNC{{{{8115
{{DAC{2,RRCNC{{{{8116
*
*      OPDVS IS USED WHEN SCANNING BELOW THE TOP LEVEL TO
*      INSURE THAT THE CONCATENATION WILL NOT BE LATER
*      MISTAKEN FOR PATTERN MATCHING
*
{OPDVP{DAC{6,O$CNC{{{CONCATENATION - NOT PATTERN MATCH{8122
{{DAC{2,C$CNP{{{{8123
{{DAC{2,LLCNC{{{{8124
{{DAC{2,RRCNC{{{{8125
*
*      NOTE THAT THE ORDER OF THE REMAINING ENTRIES IS TIED TO
*      THE ORDER OF THE CODING IN THE SCANE PROCEDURE.
*
{OPDVS{DAC{6,O$ASS{{{ASSIGNMENT{8130
{{DAC{2,C$ASS{{{{8131
{{DAC{2,LLASS{{{{8132
{{DAC{2,RRASS{{{{8133
*
{{DAC{1,6{{{UNARY EQUAL{8135
{{DAC{2,C$UUO{{{{8136
{{DAC{2,LLUNO{{{{8137
*
{{DAC{6,O$PMV{{{PATTERN MATCH{8139
{{DAC{2,C$PMT{{{{8140
{{DAC{2,LLPMT{{{{8141
{{DAC{2,RRPMT{{{{8142
*
{{DAC{6,O$INT{{{INTERROGATION{8144
{{DAC{2,C$UVL{{{{8145
{{DAC{2,LLUNO{{{{8146
*
{{DAC{1,1{{{BINARY AMPERSAND{8148
{{DAC{2,C$UBO{{{{8149
{{DAC{2,LLAMP{{{{8150
{{DAC{2,RRAMP{{{{8151
*
{{DAC{6,O$KWV{{{KEYWORD REFERENCE{8153
{{DAC{2,C$KEY{{{{8154
{{DAC{2,LLUNO{{{{8155
*
{{DAC{6,O$ALT{{{ALTERNATION{8157
{{DAC{2,C$ALT{{{{8158
{{DAC{2,LLALT{{{{8159
{{DAC{2,RRALT{{{{8160
{{EJC{{{{{8161
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,5{{{UNARY VERTICAL BAR{8165
{{DAC{2,C$UUO{{{{8166
{{DAC{2,LLUNO{{{{8167
*
{{DAC{1,0{{{BINARY AT{8169
{{DAC{2,C$UBO{{{{8170
{{DAC{2,LLATS{{{{8171
{{DAC{2,RRATS{{{{8172
*
{{DAC{6,O$CAS{{{CURSOR ASSIGNMENT{8174
{{DAC{2,C$UNM{{{{8175
{{DAC{2,LLUNO{{{{8176
*
{{DAC{1,2{{{BINARY NUMBER SIGN{8178
{{DAC{2,C$UBO{{{{8179
{{DAC{2,LLNUM{{{{8180
{{DAC{2,RRNUM{{{{8181
*
{{DAC{1,7{{{UNARY NUMBER SIGN{8183
{{DAC{2,C$UUO{{{{8184
{{DAC{2,LLUNO{{{{8185
*
{{DAC{6,O$DVD{{{DIVISION{8187
{{DAC{2,C$BVL{{{{8188
{{DAC{2,LLDVD{{{{8189
{{DAC{2,RRDVD{{{{8190
*
{{DAC{1,9{{{UNARY SLASH{8192
{{DAC{2,C$UUO{{{{8193
{{DAC{2,LLUNO{{{{8194
*
{{DAC{6,O$MLT{{{MULTIPLICATION{8196
{{DAC{2,C$BVL{{{{8197
{{DAC{2,LLMLT{{{{8198
{{DAC{2,RRMLT{{{{8199
{{EJC{{{{{8200
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,0{{{DEFERRED EXPRESSION{8204
{{DAC{2,C$DEF{{{{8205
{{DAC{2,LLUNO{{{{8206
*
{{DAC{1,3{{{BINARY PERCENT{8208
{{DAC{2,C$UBO{{{{8209
{{DAC{2,LLPCT{{{{8210
{{DAC{2,RRPCT{{{{8211
*
{{DAC{1,8{{{UNARY PERCENT{8213
{{DAC{2,C$UUO{{{{8214
{{DAC{2,LLUNO{{{{8215
*
{{DAC{6,O$EXP{{{EXPONENTIATION{8217
{{DAC{2,C$BVL{{{{8218
{{DAC{2,LLEXP{{{{8219
{{DAC{2,RREXP{{{{8220
*
{{DAC{1,10{{{UNARY EXCLAMATION{8222
{{DAC{2,C$UUO{{{{8223
{{DAC{2,LLUNO{{{{8224
*
{{DAC{6,O$IMA{{{IMMEDIATE ASSIGNMENT{8226
{{DAC{2,C$BVN{{{{8227
{{DAC{2,LLDLD{{{{8228
{{DAC{2,RRDLD{{{{8229
*
{{DAC{6,O$INV{{{INDIRECTION{8231
{{DAC{2,C$IND{{{{8232
{{DAC{2,LLUNO{{{{8233
*
{{DAC{1,4{{{BINARY NOT{8235
{{DAC{2,C$UBO{{{{8236
{{DAC{2,LLNOT{{{{8237
{{DAC{2,RRNOT{{{{8238
*
{{DAC{1,0{{{NEGATION{8240
{{DAC{2,C$NEG{{{{8241
{{DAC{2,LLUNO{{{{8242
{{EJC{{{{{8243
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{6,O$SUB{{{SUBTRACTION{8247
{{DAC{2,C$BVL{{{{8248
{{DAC{2,LLPLM{{{{8249
{{DAC{2,RRPLM{{{{8250
*
{{DAC{6,O$COM{{{COMPLEMENTATION{8252
{{DAC{2,C$UVL{{{{8253
{{DAC{2,LLUNO{{{{8254
*
{{DAC{6,O$ADD{{{ADDITION{8256
{{DAC{2,C$BVL{{{{8257
{{DAC{2,LLPLM{{{{8258
{{DAC{2,RRPLM{{{{8259
*
{{DAC{6,O$AFF{{{AFFIRMATION{8261
{{DAC{2,C$UVL{{{{8262
{{DAC{2,LLUNO{{{{8263
*
{{DAC{6,O$PAS{{{PATTERN ASSIGNMENT{8265
{{DAC{2,C$BVN{{{{8266
{{DAC{2,LLDLD{{{{8267
{{DAC{2,RRDLD{{{{8268
*
{{DAC{6,O$NAM{{{NAME REFERENCE{8270
{{DAC{2,C$UNM{{{{8271
{{DAC{2,LLUNO{{{{8272
*
*      SPECIAL DVS FOR GOTO OPERATORS (SEE PROCEDURE SCNGF)
*
{OPDVD{DAC{6,O$GOD{{{DIRECT GOTO{8276
{{DAC{2,C$UVL{{{{8277
{{DAC{2,LLUNO{{{{8278
*
{OPDVN{DAC{6,O$GOC{{{COMPLEX NORMAL GOTO{8280
{{DAC{2,C$UNM{{{{8281
{{DAC{2,LLUNO{{{{8282
{{EJC{{{{{8283
*
*      OPERATOR ENTRY ADDRESS POINTERS, USED IN CODE
*
{OAMN${DAC{6,O$AMN{{{ARRAY REF (MULTI-SUBS BY VALUE){8287
{OAMV${DAC{6,O$AMV{{{ARRAY REF (MULTI-SUBS BY VALUE){8288
{OAON${DAC{6,O$AON{{{ARRAY REF (ONE SUB BY NAME){8289
{OAOV${DAC{6,O$AOV{{{ARRAY REF (ONE SUB BY VALUE){8290
{OCER${DAC{6,O$CER{{{COMPILATION ERROR{8291
{OFEX${DAC{6,O$FEX{{{FAILURE IN EXPRESSION EVALUATION{8292
{OFIF${DAC{6,O$FIF{{{FAILURE DURING GOTO EVALUATION{8293
{OFNC${DAC{6,O$FNC{{{FUNCTION CALL (MORE THAN ONE ARG){8294
{OFNE${DAC{6,O$FNE{{{FUNCTION NAME ERROR{8295
{OFNS${DAC{6,O$FNS{{{FUNCTION CALL (SINGLE ARGUMENT){8296
{OGOF${DAC{6,O$GOF{{{SET GOTO FAILURE TRAP{8297
{OINN${DAC{6,O$INN{{{INDIRECTION BY NAME{8298
{OKWN${DAC{6,O$KWN{{{KEYWORD REFERENCE BY NAME{8299
{OLEX${DAC{6,O$LEX{{{LOAD EXPRESSION BY NAME{8300
{OLPT${DAC{6,O$LPT{{{LOAD PATTERN{8301
{OLVN${DAC{6,O$LVN{{{LOAD VARIABLE NAME{8302
{ONTA${DAC{6,O$NTA{{{NEGATION, FIRST ENTRY{8303
{ONTB${DAC{6,O$NTB{{{NEGATION, SECOND ENTRY{8304
{ONTC${DAC{6,O$NTC{{{NEGATION, THIRD ENTRY{8305
{OPMN${DAC{6,O$PMN{{{PATTERN MATCH BY NAME{8306
{OPMS${DAC{6,O$PMS{{{PATTERN MATCH (STATEMENT){8307
{OPOP${DAC{6,O$POP{{{POP TOP STACK ITEM{8308
{ORNM${DAC{6,O$RNM{{{RETURN NAME FROM EXPRESSION{8309
{ORPL${DAC{6,O$RPL{{{PATTERN REPLACEMENT{8310
{ORVL${DAC{6,O$RVL{{{RETURN VALUE FROM EXPRESSION{8311
{OSLA${DAC{6,O$SLA{{{SELECTION, FIRST ENTRY{8312
{OSLB${DAC{6,O$SLB{{{SELECTION, SECOND ENTRY{8313
{OSLC${DAC{6,O$SLC{{{SELECTION, THIRD ENTRY{8314
{OSLD${DAC{6,O$SLD{{{SELECTION, FOURTH ENTRY{8315
{OSTP${DAC{6,O$STP{{{STOP EXECUTION{8316
{OUNF${DAC{6,O$UNF{{{UNEXPECTED FAILURE{8317
{{EJC{{{{{8318
*
*      TABLE OF NAMES OF UNDEFINED BINARY OPERATORS FOR OPSYN
*
{OPSNB{DAC{2,CH$AT{{{AT{8322
{{DAC{2,CH$AM{{{AMPERSAND{8323
{{DAC{2,CH$NM{{{NUMBER{8324
{{DAC{2,CH$PC{{{PERCENT{8325
{{DAC{2,CH$NT{{{NOT{8326
*
*      TABLE OF NAMES OF UNDEFINED UNARY OPERATORS FOR OPSYN
*
{OPNSU{DAC{2,CH$BR{{{VERTICAL BAR{8330
{{DAC{2,CH$EQ{{{EQUAL{8331
{{DAC{2,CH$NM{{{NUMBER{8332
{{DAC{2,CH$PC{{{PERCENT{8333
{{DAC{2,CH$SL{{{SLASH{8334
{{DAC{2,CH$EX{{{EXCLAMATION{8335
*
*      ADDRESS CONST CONTAINING PROFILE TABLE ENTRY SIZE
*
{PFI2A{DAC{2,PF$I2{{{{8341
*
*      PROFILER MESSAGE STRINGS
*
{PFMS1{DAC{6,B$SCL{{{{8345
{{DAC{1,15{{{{8346
{{DTC{27,/Program Profile/{{{{8347
{PFMS2{DAC{6,B$SCL{{{{8348
{{DAC{1,42{{{{8349
{{DTC{27,/STMT    Number Of     -- Execution Time --/{{{{8350
{PFMS3{DAC{6,B$SCL{{{{8351
{{DAC{1,47{{{{8352
{{DTC{27,/Number  Executions  Total(MSec) per Excn(MCSec)/{{{{8353
*
*
*      REAL CONSTANTS FOR GENERAL USE. NOTE THAT THE CONSTANTS
*      STARTING AT REAV1 FORM A POWERS OF TEN TABLE (USED IN
*      GTNUM AND GTSTG)
*
{REAV0{DRC{17,+0.0{{{0.0{8363
{REAP1{DRC{17,+0.1{{{0.1{8366
{REAP5{DRC{17,+0.5{{{0.5{8367
{REAV1{DRC{17,+1.0{{{10**0{8369
{REAVT{DRC{17,+1.0E+1{{{10**1{8370
{{DRC{17,+1.0E+2{{{10**2{8371
{{DRC{17,+1.0E+3{{{10**3{8372
{{DRC{17,+1.0E+4{{{10**4{8373
{{DRC{17,+1.0E+5{{{10**5{8374
{{DRC{17,+1.0E+6{{{10**6{8375
{{DRC{17,+1.0E+7{{{10**7{8376
{{DRC{17,+1.0E+8{{{10**8{8377
{{DRC{17,+1.0E+9{{{10**9{8378
{REATT{DRC{17,+1.0E+10{{{10**10{8379
{{EJC{{{{{8381
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR DTYPE PROCEDURE
*
{SCARR{DAC{6,B$SCL{{{ARRAY{8385
{{DAC{1,5{{{{8386
{{DTC{27,/ARRAY/{{{{8387
*
{SCCOD{DAC{6,B$SCL{{{CODE{8396
{{DAC{1,4{{{{8397
{{DTC{27,/CODE/{{{{8398
*
{SCEXP{DAC{6,B$SCL{{{EXPRESSION{8400
{{DAC{1,10{{{{8401
{{DTC{27,/EXPRESSION/{{{{8402
*
{SCEXT{DAC{6,B$SCL{{{EXTERNAL{8404
{{DAC{1,8{{{{8405
{{DTC{27,/EXTERNAL/{{{{8406
*
{SCINT{DAC{6,B$SCL{{{INTEGER{8408
{{DAC{1,7{{{{8409
{{DTC{27,/INTEGER/{{{{8410
*
{SCNAM{DAC{6,B$SCL{{{NAME{8412
{{DAC{1,4{{{{8413
{{DTC{27,/NAME/{{{{8414
*
{SCNUM{DAC{6,B$SCL{{{NUMERIC{8416
{{DAC{1,7{{{{8417
{{DTC{27,/NUMERIC/{{{{8418
*
{SCPAT{DAC{6,B$SCL{{{PATTERN{8420
{{DAC{1,7{{{{8421
{{DTC{27,/PATTERN/{{{{8422
*
{SCREA{DAC{6,B$SCL{{{REAL{8426
{{DAC{1,4{{{{8427
{{DTC{27,/REAL/{{{{8428
*
{SCSTR{DAC{6,B$SCL{{{STRING{8431
{{DAC{1,6{{{{8432
{{DTC{27,/STRING/{{{{8433
*
{SCTAB{DAC{6,B$SCL{{{TABLE{8435
{{DAC{1,5{{{{8436
{{DTC{27,/TABLE/{{{{8437
{SCFIL{DAC{6,B$SCL{{{FILE (FOR EXTENDED LOAD ARGUMENTS){8439
{{DAC{1,4{{{{8440
{{DTC{27,/FILE/{{{{8441
{{EJC{{{{{8443
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR KVRTN (SEE RETRN)
*
{SCFRT{DAC{6,B$SCL{{{FRETURN{8447
{{DAC{1,7{{{{8448
{{DTC{27,/FRETURN/{{{{8449
*
{SCNRT{DAC{6,B$SCL{{{NRETURN{8451
{{DAC{1,7{{{{8452
{{DTC{27,/NRETURN/{{{{8453
*
{SCRTN{DAC{6,B$SCL{{{RETURN{8455
{{DAC{1,6{{{{8456
{{DTC{27,/RETURN/{{{{8457
*
*      DATATYPE NAME TABLE FOR DTYPE PROCEDURE. THE ORDER OF
*      THESE ENTRIES IS TIED TO THE B$XXX DEFINITIONS FOR BLOCKS
*
*      NOTE THAT SLOTS FOR BUFFER AND REAL DATA TYPES ARE FILLED
*      EVEN IF THESE DATA TYPES ARE CONDITIONALIZED OUT OF THE
*      IMPLEMENTATION.  THIS IS DONE SO THAT THE BLOCK NUMBERING
*      AT BL$AR ETC. REMAINS CONSTANT IN ALL VERSIONS.
*
{SCNMT{DAC{4,SCARR{{{ARBLK     ARRAY{8467
{{DAC{4,SCCOD{{{CDBLK     CODE{8468
{{DAC{4,SCEXP{{{EXBLK     EXPRESSION{8469
{{DAC{4,SCINT{{{ICBLK     INTEGER{8470
{{DAC{4,SCNAM{{{NMBLK     NAME{8471
{{DAC{4,SCPAT{{{P0BLK     PATTERN{8472
{{DAC{4,SCPAT{{{P1BLK     PATTERN{8473
{{DAC{4,SCPAT{{{P2BLK     PATTERN{8474
{{DAC{4,SCREA{{{RCBLK     REAL{8479
{{DAC{4,SCSTR{{{SCBLK     STRING{8481
{{DAC{4,SCEXP{{{SEBLK     EXPRESSION{8482
{{DAC{4,SCTAB{{{TBBLK     TABLE{8483
{{DAC{4,SCARR{{{VCBLK     ARRAY{8484
{{DAC{4,SCEXT{{{XNBLK     EXTERNAL{8485
{{DAC{4,SCEXT{{{XRBLK     EXTERNAL{8486
{{DAC{4,NULLS{{{BFBLK     NO BUFFER IN THIS VERSION{8488
*
*      STRING CONSTANT FOR REAL ZERO
*
{SCRE0{DAC{6,B$SCL{{{{8497
{{DAC{1,2{{{{8498
{{DTC{27,/0./{{{{8499
{{EJC{{{{{8501
*
*      USED TO RE-INITIALISE KVSTL
*
{STLIM{DIC{16,+2147483647{{{DEFAULT STATEMENT LIMIT{8509
*
*      DUMMY FUNCTION BLOCK USED FOR UNDEFINED FUNCTIONS
*
{STNDF{DAC{6,O$FUN{{{PTR TO UNDEFINED FUNCTION ERR CALL{8517
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{8518
*
*      DUMMY CODE BLOCK USED FOR UNDEFINED LABELS
*
{STNDL{DAC{6,L$UND{{{CODE PTR POINTS TO UNDEFINED LBL{8522
*
*      DUMMY OPERATOR BLOCK USED FOR UNDEFINED OPERATORS
*
{STNDO{DAC{6,O$OUN{{{PTR TO UNDEFINED OPERATOR ERR CALL{8526
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{8527
*
*      STANDARD VARIABLE BLOCK. THIS BLOCK IS USED TO INITIALIZE
*      THE FIRST SEVEN FIELDS OF A NEWLY CONSTRUCTED VRBLK.
*      ITS FORMAT IS TIED TO THE VRBLK DEFINITIONS (SEE GTNVR).
*
{STNVR{DAC{6,B$VRL{{{VRGET{8533
{{DAC{6,B$VRS{{{VRSTO{8534
{{DAC{4,NULLS{{{VRVAL{8535
{{DAC{6,B$VRG{{{VRTRA{8536
{{DAC{4,STNDL{{{VRLBL{8537
{{DAC{4,STNDF{{{VRFNC{8538
{{DAC{1,0{{{VRNXT{8539
{{EJC{{{{{8540
*
*      MESSAGES USED IN END OF RUN PROCESSING (STOPR)
*
{STPM1{DAC{6,B$SCL{{{IN STATEMENT{8544
{{DAC{1,12{{{{8545
{{DTC{27,/In statement/{{{{8546
*
{STPM2{DAC{6,B$SCL{{{{8548
{{DAC{1,14{{{{8549
{{DTC{27,/Stmts executed/{{{{8550
*
{STPM3{DAC{6,B$SCL{{{{8552
{{DAC{1,19{{{{8557
{{DTC{27,/Run time (millisec)/{{{{8558
*
{STPM4{DAC{6,B$SCL{{{{8561
{{DAC{1,12{{{{8562
{{DTC{27,$MCSec / Stmt${{{{8563
*
{STPM5{DAC{6,B$SCL{{{{8565
{{DAC{1,13{{{{8566
{{DTC{27,/Regenerations/{{{{8567
*
{STPM6{DAC{6,B$SCL{{{IN LINE{8570
{{DAC{1,7{{{{8571
{{DTC{27,/In line/{{{{8572
*
{STPM7{DAC{6,B$SCL{{{IN FILE{8576
{{DAC{1,7{{{{8577
{{DTC{27,/In file/{{{{8578
*
*      CHARS FOR /TU/ ENDING CODE
*
{STRTU{DTC{27,/TU/{{{{8583
*
*      TABLE USED BY CONVERT FUNCTION TO CHECK DATATYPE NAME
*      THE ENTRIES ARE ORDERED TO CORRESPOND TO BRANCH TABLE
*      IN S$CNV
*
{SVCTB{DAC{4,SCSTR{{{STRING{8589
{{DAC{4,SCINT{{{INTEGER{8590
{{DAC{4,SCNAM{{{NAME{8591
{{DAC{4,SCPAT{{{PATTERN{8592
{{DAC{4,SCARR{{{ARRAY{8593
{{DAC{4,SCTAB{{{TABLE{8594
{{DAC{4,SCEXP{{{EXPRESSION{8595
{{DAC{4,SCCOD{{{CODE{8596
{{DAC{4,SCNUM{{{NUMERIC{8597
{{DAC{4,SCREA{{{REAL{8600
{{DAC{1,0{{{ZERO MARKS END OF LIST{8606
{{EJC{{{{{8607
*
*      MESSAGES (SCBLK FORMAT) USED BY TRACE PROCEDURES
*
*
{TMASB{DAC{6,B$SCL{{{ASTERISKS FOR TRACE STATEMENT NO{8612
{{DAC{1,13{{{{8613
{{DTC{27,/************ /{{{{8614
*
{TMBEB{DAC{6,B$SCL{{{BLANK-EQUAL-BLANK{8617
{{DAC{1,3{{{{8618
{{DTC{27,/ = /{{{{8619
*
*      DUMMY TRBLK FOR EXPRESSION VARIABLE
*
{TRBEV{DAC{6,B$TRT{{{DUMMY TRBLK{8623
*
*      DUMMY TRBLK FOR KEYWORD VARIABLE
*
{TRBKV{DAC{6,B$TRT{{{DUMMY TRBLK{8627
*
*      DUMMY CODE BLOCK TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{TRXDR{DAC{6,O$TXR{{{BLOCK POINTS TO RETURN ROUTINE{8631
{TRXDC{DAC{4,TRXDR{{{POINTER TO BLOCK{8632
{{EJC{{{{{8633
*
*      STANDARD VARIABLE BLOCKS
*
*      SEE SVBLK FORMAT FOR FULL DETAILS OF THE FORMAT. THE
*      VRBLKS ARE ORDERED BY LENGTH AND WITHIN EACH LENGTH THE
*      ORDER IS ALPHABETICAL BY NAME OF THE VARIABLE.
*
{V$EQF{DBC{2,SVFPR{{{EQ{8641
{{DAC{1,2{{{{8642
{{DTC{27,/EQ/{{{{8643
{{DAC{6,S$EQF{{{{8644
{{DAC{1,2{{{{8645
*
{V$GEF{DBC{2,SVFPR{{{GE{8647
{{DAC{1,2{{{{8648
{{DTC{27,/GE/{{{{8649
{{DAC{6,S$GEF{{{{8650
{{DAC{1,2{{{{8651
*
{V$GTF{DBC{2,SVFPR{{{GT{8653
{{DAC{1,2{{{{8654
{{DTC{27,/GT/{{{{8655
{{DAC{6,S$GTF{{{{8656
{{DAC{1,2{{{{8657
*
{V$LEF{DBC{2,SVFPR{{{LE{8659
{{DAC{1,2{{{{8660
{{DTC{27,/LE/{{{{8661
{{DAC{6,S$LEF{{{{8662
{{DAC{1,2{{{{8663
*
{V$LNF{DBC{2,SVFNP{{{LN{8666
{{DAC{1,2{{{{8667
{{DTC{27,/LN/{{{{8668
{{DAC{6,S$LNF{{{{8669
{{DAC{1,1{{{{8670
*
{V$LTF{DBC{2,SVFPR{{{LT{8673
{{DAC{1,2{{{{8674
{{DTC{27,/LT/{{{{8675
{{DAC{6,S$LTF{{{{8676
{{DAC{1,2{{{{8677
*
{V$NEF{DBC{2,SVFPR{{{NE{8679
{{DAC{1,2{{{{8680
{{DTC{27,/NE/{{{{8681
{{DAC{6,S$NEF{{{{8682
{{DAC{1,2{{{{8683
*
{V$ANY{DBC{2,SVFNP{{{ANY{8709
{{DAC{1,3{{{{8710
{{DTC{27,/ANY/{{{{8711
{{DAC{6,S$ANY{{{{8712
{{DAC{1,1{{{{8713
*
{V$ARB{DBC{2,SVKVC{{{ARB{8715
{{DAC{1,3{{{{8716
{{DTC{27,/ARB/{{{{8717
{{DAC{2,K$ARB{{{{8718
{{DAC{4,NDARB{{{{8719
{{EJC{{{{{8720
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$ARG{DBC{2,SVFNN{{{ARG{8724
{{DAC{1,3{{{{8725
{{DTC{27,/ARG/{{{{8726
{{DAC{6,S$ARG{{{{8727
{{DAC{1,2{{{{8728
*
{V$BAL{DBC{2,SVKVC{{{BAL{8730
{{DAC{1,3{{{{8731
{{DTC{27,/BAL/{{{{8732
{{DAC{2,K$BAL{{{{8733
{{DAC{4,NDBAL{{{{8734
*
{V$COS{DBC{2,SVFNP{{{COS{8737
{{DAC{1,3{{{{8738
{{DTC{27,/COS/{{{{8739
{{DAC{6,S$COS{{{{8740
{{DAC{1,1{{{{8741
*
{V$END{DBC{2,SVLBL{{{END{8744
{{DAC{1,3{{{{8745
{{DTC{27,/END/{{{{8746
{{DAC{6,L$END{{{{8747
*
{V$EXP{DBC{2,SVFNP{{{EXP{8750
{{DAC{1,3{{{{8751
{{DTC{27,/EXP/{{{{8752
{{DAC{6,S$EXP{{{{8753
{{DAC{1,1{{{{8754
*
{V$LEN{DBC{2,SVFNP{{{LEN{8757
{{DAC{1,3{{{{8758
{{DTC{27,/LEN/{{{{8759
{{DAC{6,S$LEN{{{{8760
{{DAC{1,1{{{{8761
*
{V$LEQ{DBC{2,SVFPR{{{LEQ{8763
{{DAC{1,3{{{{8764
{{DTC{27,/LEQ/{{{{8765
{{DAC{6,S$LEQ{{{{8766
{{DAC{1,2{{{{8767
*
{V$LGE{DBC{2,SVFPR{{{LGE{8769
{{DAC{1,3{{{{8770
{{DTC{27,/LGE/{{{{8771
{{DAC{6,S$LGE{{{{8772
{{DAC{1,2{{{{8773
*
{V$LGT{DBC{2,SVFPR{{{LGT{8775
{{DAC{1,3{{{{8776
{{DTC{27,/LGT/{{{{8777
{{DAC{6,S$LGT{{{{8778
{{DAC{1,2{{{{8779
*
{V$LLE{DBC{2,SVFPR{{{LLE{8781
{{DAC{1,3{{{{8782
{{DTC{27,/LLE/{{{{8783
{{DAC{6,S$LLE{{{{8784
{{DAC{1,2{{{{8785
{{EJC{{{{{8786
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$LLT{DBC{2,SVFPR{{{LLT{8790
{{DAC{1,3{{{{8791
{{DTC{27,/LLT/{{{{8792
{{DAC{6,S$LLT{{{{8793
{{DAC{1,2{{{{8794
*
{V$LNE{DBC{2,SVFPR{{{LNE{8796
{{DAC{1,3{{{{8797
{{DTC{27,/LNE/{{{{8798
{{DAC{6,S$LNE{{{{8799
{{DAC{1,2{{{{8800
*
{V$POS{DBC{2,SVFNP{{{POS{8802
{{DAC{1,3{{{{8803
{{DTC{27,/POS/{{{{8804
{{DAC{6,S$POS{{{{8805
{{DAC{1,1{{{{8806
*
{V$REM{DBC{2,SVKVC{{{REM{8808
{{DAC{1,3{{{{8809
{{DTC{27,/REM/{{{{8810
{{DAC{2,K$REM{{{{8811
{{DAC{4,NDREM{{{{8812
*
{V$SET{DBC{2,SVFNN{{{SET{8815
{{DAC{1,3{{{{8816
{{DTC{27,/SET/{{{{8817
{{DAC{6,S$SET{{{{8818
{{DAC{1,3{{{{8819
*
{V$SIN{DBC{2,SVFNP{{{SIN{8823
{{DAC{1,3{{{{8824
{{DTC{27,/SIN/{{{{8825
{{DAC{6,S$SIN{{{{8826
{{DAC{1,1{{{{8827
*
{V$TAB{DBC{2,SVFNP{{{TAB{8830
{{DAC{1,3{{{{8831
{{DTC{27,/TAB/{{{{8832
{{DAC{6,S$TAB{{{{8833
{{DAC{1,1{{{{8834
*
{V$TAN{DBC{2,SVFNP{{{TAN{8837
{{DAC{1,3{{{{8838
{{DTC{27,/TAN/{{{{8839
{{DAC{6,S$TAN{{{{8840
{{DAC{1,1{{{{8841
*
{V$ATN{DBC{2,SVFNP{{{ATAN{8853
{{DAC{1,4{{{{8854
{{DTC{27,/ATAN/{{{{8855
{{DAC{6,S$ATN{{{{8856
{{DAC{1,1{{{{8857
*
{V$CAS{DBC{2,SVKNM{{{CASE{8861
{{DAC{1,4{{{{8862
{{DTC{27,/CASE/{{{{8863
{{DAC{2,K$CAS{{{{8864
*
{V$CHR{DBC{2,SVFNP{{{CHAR{8867
{{DAC{1,4{{{{8868
{{DTC{27,/CHAR/{{{{8869
{{DAC{6,S$CHR{{{{8870
{{DAC{1,1{{{{8871
*
*
{V$CHP{DBC{2,SVFNP{{{CHOP{8875
{{DAC{1,4{{{{8876
{{DTC{27,/CHOP/{{{{8877
{{DAC{6,S$CHP{{{{8878
{{DAC{1,1{{{{8879
{V$COD{DBC{2,SVFNK{{{CODE{8881
{{DAC{1,4{{{{8882
{{DTC{27,/CODE/{{{{8883
{{DAC{2,K$COD{{{{8884
{{DAC{6,S$COD{{{{8885
{{DAC{1,1{{{{8886
*
{V$COP{DBC{2,SVFNN{{{COPY{8888
{{DAC{1,4{{{{8889
{{DTC{27,/COPY/{{{{8890
{{DAC{6,S$COP{{{{8891
{{DAC{1,1{{{{8892
{{EJC{{{{{8893
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DAT{DBC{2,SVFNN{{{DATA{8897
{{DAC{1,4{{{{8898
{{DTC{27,/DATA/{{{{8899
{{DAC{6,S$DAT{{{{8900
{{DAC{1,1{{{{8901
*
{V$DTE{DBC{2,SVFNN{{{DATE{8903
{{DAC{1,4{{{{8904
{{DTC{27,/DATE/{{{{8905
{{DAC{6,S$DTE{{{{8906
{{DAC{1,1{{{{8907
*
{V$DMP{DBC{2,SVFNK{{{DUMP{8909
{{DAC{1,4{{{{8910
{{DTC{27,/DUMP/{{{{8911
{{DAC{2,K$DMP{{{{8912
{{DAC{6,S$DMP{{{{8913
{{DAC{1,1{{{{8914
*
{V$DUP{DBC{2,SVFNN{{{DUPL{8916
{{DAC{1,4{{{{8917
{{DTC{27,/DUPL/{{{{8918
{{DAC{6,S$DUP{{{{8919
{{DAC{1,2{{{{8920
*
{V$EVL{DBC{2,SVFNN{{{EVAL{8922
{{DAC{1,4{{{{8923
{{DTC{27,/EVAL/{{{{8924
{{DAC{6,S$EVL{{{{8925
{{DAC{1,1{{{{8926
*
{V$EXT{DBC{2,SVFNN{{{EXIT{8930
{{DAC{1,4{{{{8931
{{DTC{27,/EXIT/{{{{8932
{{DAC{6,S$EXT{{{{8933
{{DAC{1,2{{{{8934
*
{V$FAL{DBC{2,SVKVC{{{FAIL{8937
{{DAC{1,4{{{{8938
{{DTC{27,/FAIL/{{{{8939
{{DAC{2,K$FAL{{{{8940
{{DAC{4,NDFAL{{{{8941
*
{V$FIL{DBC{2,SVKNM{{{FILE{8944
{{DAC{1,4{{{{8945
{{DTC{27,/FILE/{{{{8946
{{DAC{2,K$FIL{{{{8947
*
{V$HST{DBC{2,SVFNN{{{HOST{8950
{{DAC{1,4{{{{8951
{{DTC{27,/HOST/{{{{8952
{{DAC{6,S$HST{{{{8953
{{DAC{1,5{{{{8954
{{EJC{{{{{8955
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$ITM{DBC{2,SVFNF{{{ITEM{8959
{{DAC{1,4{{{{8960
{{DTC{27,/ITEM/{{{{8961
{{DAC{6,S$ITM{{{{8962
{{DAC{1,999{{{{8963
*
{V$LIN{DBC{2,SVKNM{{{LINE{8966
{{DAC{1,4{{{{8967
{{DTC{27,/LINE/{{{{8968
{{DAC{2,K$LIN{{{{8969
*
{V$LOD{DBC{2,SVFNN{{{LOAD{8974
{{DAC{1,4{{{{8975
{{DTC{27,/LOAD/{{{{8976
{{DAC{6,S$LOD{{{{8977
{{DAC{1,2{{{{8978
*
{V$LPD{DBC{2,SVFNP{{{LPAD{8981
{{DAC{1,4{{{{8982
{{DTC{27,/LPAD/{{{{8983
{{DAC{6,S$LPD{{{{8984
{{DAC{1,3{{{{8985
*
{V$RPD{DBC{2,SVFNP{{{RPAD{8987
{{DAC{1,4{{{{8988
{{DTC{27,/RPAD/{{{{8989
{{DAC{6,S$RPD{{{{8990
{{DAC{1,3{{{{8991
*
{V$RPS{DBC{2,SVFNP{{{RPOS{8993
{{DAC{1,4{{{{8994
{{DTC{27,/RPOS/{{{{8995
{{DAC{6,S$RPS{{{{8996
{{DAC{1,1{{{{8997
*
{V$RTB{DBC{2,SVFNP{{{RTAB{8999
{{DAC{1,4{{{{9000
{{DTC{27,/RTAB/{{{{9001
{{DAC{6,S$RTB{{{{9002
{{DAC{1,1{{{{9003
*
{V$SI${DBC{2,SVFNP{{{SIZE{9005
{{DAC{1,4{{{{9006
{{DTC{27,/SIZE/{{{{9007
{{DAC{6,S$SI${{{{9008
{{DAC{1,1{{{{9009
*
*
{V$SRT{DBC{2,SVFNN{{{SORT{9014
{{DAC{1,4{{{{9015
{{DTC{27,/SORT/{{{{9016
{{DAC{6,S$SRT{{{{9017
{{DAC{1,2{{{{9018
{V$SPN{DBC{2,SVFNP{{{SPAN{9020
{{DAC{1,4{{{{9021
{{DTC{27,/SPAN/{{{{9022
{{DAC{6,S$SPN{{{{9023
{{DAC{1,1{{{{9024
{{EJC{{{{{9025
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V$SQR{DBC{2,SVFNP{{{SQRT{9031
{{DAC{1,4{{{{9032
{{DTC{27,/SQRT/{{{{9033
{{DAC{6,S$SQR{{{{9034
{{DAC{1,1{{{{9035
{V$STN{DBC{2,SVKNM{{{STNO{9037
{{DAC{1,4{{{{9038
{{DTC{27,/STNO/{{{{9039
{{DAC{2,K$STN{{{{9040
*
{V$TIM{DBC{2,SVFNN{{{TIME{9042
{{DAC{1,4{{{{9043
{{DTC{27,/TIME/{{{{9044
{{DAC{6,S$TIM{{{{9045
{{DAC{1,0{{{{9046
*
{V$TRM{DBC{2,SVFNK{{{TRIM{9048
{{DAC{1,4{{{{9049
{{DTC{27,/TRIM/{{{{9050
{{DAC{2,K$TRM{{{{9051
{{DAC{6,S$TRM{{{{9052
{{DAC{1,1{{{{9053
*
{V$ABE{DBC{2,SVKNM{{{ABEND{9055
{{DAC{1,5{{{{9056
{{DTC{27,/ABEND/{{{{9057
{{DAC{2,K$ABE{{{{9058
*
{V$ABO{DBC{2,SVKVL{{{ABORT{9060
{{DAC{1,5{{{{9061
{{DTC{27,/ABORT/{{{{9062
{{DAC{2,K$ABO{{{{9063
{{DAC{6,L$ABO{{{{9064
{{DAC{4,NDABO{{{{9065
*
{V$APP{DBC{2,SVFNF{{{APPLY{9067
{{DAC{1,5{{{{9068
{{DTC{27,/APPLY/{{{{9069
{{DAC{6,S$APP{{{{9070
{{DAC{1,999{{{{9071
*
{V$ABN{DBC{2,SVFNP{{{ARBNO{9073
{{DAC{1,5{{{{9074
{{DTC{27,/ARBNO/{{{{9075
{{DAC{6,S$ABN{{{{9076
{{DAC{1,1{{{{9077
*
{V$ARR{DBC{2,SVFNN{{{ARRAY{9079
{{DAC{1,5{{{{9080
{{DTC{27,/ARRAY/{{{{9081
{{DAC{6,S$ARR{{{{9082
{{DAC{1,2{{{{9083
{{EJC{{{{{9084
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$BRK{DBC{2,SVFNP{{{BREAK{9088
{{DAC{1,5{{{{9089
{{DTC{27,/BREAK/{{{{9090
{{DAC{6,S$BRK{{{{9091
{{DAC{1,1{{{{9092
*
{V$CLR{DBC{2,SVFNN{{{CLEAR{9094
{{DAC{1,5{{{{9095
{{DTC{27,/CLEAR/{{{{9096
{{DAC{6,S$CLR{{{{9097
{{DAC{1,1{{{{9098
*
{V$EJC{DBC{2,SVFNN{{{EJECT{9108
{{DAC{1,5{{{{9109
{{DTC{27,/EJECT/{{{{9110
{{DAC{6,S$EJC{{{{9111
{{DAC{1,1{{{{9112
*
{V$FEN{DBC{2,SVFPK{{{FENCE{9114
{{DAC{1,5{{{{9115
{{DTC{27,/FENCE/{{{{9116
{{DAC{2,K$FEN{{{{9117
{{DAC{6,S$FNC{{{{9118
{{DAC{1,1{{{{9119
{{DAC{4,NDFEN{{{{9120
*
{V$FLD{DBC{2,SVFNN{{{FIELD{9122
{{DAC{1,5{{{{9123
{{DTC{27,/FIELD/{{{{9124
{{DAC{6,S$FLD{{{{9125
{{DAC{1,2{{{{9126
*
{V$IDN{DBC{2,SVFPR{{{IDENT{9128
{{DAC{1,5{{{{9129
{{DTC{27,/IDENT/{{{{9130
{{DAC{6,S$IDN{{{{9131
{{DAC{1,2{{{{9132
*
{V$INP{DBC{2,SVFNK{{{INPUT{9134
{{DAC{1,5{{{{9135
{{DTC{27,/INPUT/{{{{9136
{{DAC{2,K$INP{{{{9137
{{DAC{6,S$INP{{{{9138
{{DAC{1,3{{{{9139
*
{V$LCS{DBC{2,SVKWC{{{LCASE{9142
{{DAC{1,5{{{{9143
{{DTC{27,/LCASE/{{{{9144
{{DAC{2,K$LCS{{{{9145
*
{V$LOC{DBC{2,SVFNN{{{LOCAL{9148
{{DAC{1,5{{{{9149
{{DTC{27,/LOCAL/{{{{9150
{{DAC{6,S$LOC{{{{9151
{{DAC{1,2{{{{9152
{{EJC{{{{{9153
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$OPS{DBC{2,SVFNN{{{OPSYN{9157
{{DAC{1,5{{{{9158
{{DTC{27,/OPSYN/{{{{9159
{{DAC{6,S$OPS{{{{9160
{{DAC{1,3{{{{9161
*
{V$RMD{DBC{2,SVFNP{{{REMDR{9163
{{DAC{1,5{{{{9164
{{DTC{27,/REMDR/{{{{9165
{{DAC{6,S$RMD{{{{9166
{{DAC{1,2{{{{9167
*
{V$RSR{DBC{2,SVFNN{{{RSORT{9171
{{DAC{1,5{{{{9172
{{DTC{27,/RSORT/{{{{9173
{{DAC{6,S$RSR{{{{9174
{{DAC{1,2{{{{9175
*
{V$TBL{DBC{2,SVFNN{{{TABLE{9178
{{DAC{1,5{{{{9179
{{DTC{27,/TABLE/{{{{9180
{{DAC{6,S$TBL{{{{9181
{{DAC{1,3{{{{9182
*
{V$TRA{DBC{2,SVFNK{{{TRACE{9184
{{DAC{1,5{{{{9185
{{DTC{27,/TRACE/{{{{9186
{{DAC{2,K$TRA{{{{9187
{{DAC{6,S$TRA{{{{9188
{{DAC{1,4{{{{9189
*
{V$UCS{DBC{2,SVKWC{{{UCASE{9192
{{DAC{1,5{{{{9193
{{DTC{27,/UCASE/{{{{9194
{{DAC{2,K$UCS{{{{9195
*
{V$ANC{DBC{2,SVKNM{{{ANCHOR{9198
{{DAC{1,6{{{{9199
{{DTC{27,/ANCHOR/{{{{9200
{{DAC{2,K$ANC{{{{9201
*
{V$BKX{DBC{2,SVFNP{{{BREAKX{9212
{{DAC{1,6{{{{9213
{{DTC{27,/BREAKX/{{{{9214
{{DAC{6,S$BKX{{{{9215
{{DAC{1,1{{{{9216
*
*
{V$DEF{DBC{2,SVFNN{{{DEFINE{9227
{{DAC{1,6{{{{9228
{{DTC{27,/DEFINE/{{{{9229
{{DAC{6,S$DEF{{{{9230
{{DAC{1,2{{{{9231
*
{V$DET{DBC{2,SVFNN{{{DETACH{9233
{{DAC{1,6{{{{9234
{{DTC{27,/DETACH/{{{{9235
{{DAC{6,S$DET{{{{9236
{{DAC{1,1{{{{9237
{{EJC{{{{{9238
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DIF{DBC{2,SVFPR{{{DIFFER{9242
{{DAC{1,6{{{{9243
{{DTC{27,/DIFFER/{{{{9244
{{DAC{6,S$DIF{{{{9245
{{DAC{1,2{{{{9246
*
{V$FTR{DBC{2,SVKNM{{{FTRACE{9248
{{DAC{1,6{{{{9249
{{DTC{27,/FTRACE/{{{{9250
{{DAC{2,K$FTR{{{{9251
*
{V$LST{DBC{2,SVKNM{{{LASTNO{9262
{{DAC{1,6{{{{9263
{{DTC{27,/LASTNO/{{{{9264
{{DAC{2,K$LST{{{{9265
*
{V$NAY{DBC{2,SVFNP{{{NOTANY{9267
{{DAC{1,6{{{{9268
{{DTC{27,/NOTANY/{{{{9269
{{DAC{6,S$NAY{{{{9270
{{DAC{1,1{{{{9271
*
{V$OUP{DBC{2,SVFNK{{{OUTPUT{9273
{{DAC{1,6{{{{9274
{{DTC{27,/OUTPUT/{{{{9275
{{DAC{2,K$OUP{{{{9276
{{DAC{6,S$OUP{{{{9277
{{DAC{1,3{{{{9278
*
{V$RET{DBC{2,SVLBL{{{RETURN{9280
{{DAC{1,6{{{{9281
{{DTC{27,/RETURN/{{{{9282
{{DAC{6,L$RTN{{{{9283
*
{V$REW{DBC{2,SVFNN{{{REWIND{9285
{{DAC{1,6{{{{9286
{{DTC{27,/REWIND/{{{{9287
{{DAC{6,S$REW{{{{9288
{{DAC{1,1{{{{9289
*
{V$STT{DBC{2,SVFNN{{{STOPTR{9291
{{DAC{1,6{{{{9292
{{DTC{27,/STOPTR/{{{{9293
{{DAC{6,S$STT{{{{9294
{{DAC{1,2{{{{9295
{{EJC{{{{{9296
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$SUB{DBC{2,SVFNN{{{SUBSTR{9300
{{DAC{1,6{{{{9301
{{DTC{27,/SUBSTR/{{{{9302
{{DAC{6,S$SUB{{{{9303
{{DAC{1,3{{{{9304
*
{V$UNL{DBC{2,SVFNN{{{UNLOAD{9306
{{DAC{1,6{{{{9307
{{DTC{27,/UNLOAD/{{{{9308
{{DAC{6,S$UNL{{{{9309
{{DAC{1,1{{{{9310
*
{V$COL{DBC{2,SVFNN{{{COLLECT{9312
{{DAC{1,7{{{{9313
{{DTC{27,/COLLECT/{{{{9314
{{DAC{6,S$COL{{{{9315
{{DAC{1,1{{{{9316
*
{V$COM{DBC{2,SVKNM{{{COMPARE{9319
{{DAC{1,7{{{{9320
{{DTC{27,/COMPARE/{{{{9321
{{DAC{2,K$COM{{{{9322
*
{V$CNV{DBC{2,SVFNN{{{CONVERT{9325
{{DAC{1,7{{{{9326
{{DTC{27,/CONVERT/{{{{9327
{{DAC{6,S$CNV{{{{9328
{{DAC{1,2{{{{9329
*
{V$ENF{DBC{2,SVFNN{{{ENDFILE{9331
{{DAC{1,7{{{{9332
{{DTC{27,/ENDFILE/{{{{9333
{{DAC{6,S$ENF{{{{9334
{{DAC{1,1{{{{9335
*
{V$ETX{DBC{2,SVKNM{{{ERRTEXT{9337
{{DAC{1,7{{{{9338
{{DTC{27,/ERRTEXT/{{{{9339
{{DAC{2,K$ETX{{{{9340
*
{V$ERT{DBC{2,SVKNM{{{ERRTYPE{9342
{{DAC{1,7{{{{9343
{{DTC{27,/ERRTYPE/{{{{9344
{{DAC{2,K$ERT{{{{9345
*
{V$FRT{DBC{2,SVLBL{{{FRETURN{9347
{{DAC{1,7{{{{9348
{{DTC{27,/FRETURN/{{{{9349
{{DAC{6,L$FRT{{{{9350
*
{V$INT{DBC{2,SVFPR{{{INTEGER{9352
{{DAC{1,7{{{{9353
{{DTC{27,/INTEGER/{{{{9354
{{DAC{6,S$INT{{{{9355
{{DAC{1,1{{{{9356
*
{V$NRT{DBC{2,SVLBL{{{NRETURN{9358
{{DAC{1,7{{{{9359
{{DTC{27,/NRETURN/{{{{9360
{{DAC{6,L$NRT{{{{9361
{{EJC{{{{{9362
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V$PFL{DBC{2,SVKNM{{{PROFILE{9369
{{DAC{1,7{{{{9370
{{DTC{27,/PROFILE/{{{{9371
{{DAC{2,K$PFL{{{{9372
*
{V$RPL{DBC{2,SVFNP{{{REPLACE{9375
{{DAC{1,7{{{{9376
{{DTC{27,/REPLACE/{{{{9377
{{DAC{6,S$RPL{{{{9378
{{DAC{1,3{{{{9379
*
{V$RVS{DBC{2,SVFNP{{{REVERSE{9381
{{DAC{1,7{{{{9382
{{DTC{27,/REVERSE/{{{{9383
{{DAC{6,S$RVS{{{{9384
{{DAC{1,1{{{{9385
*
{V$RTN{DBC{2,SVKNM{{{RTNTYPE{9387
{{DAC{1,7{{{{9388
{{DTC{27,/RTNTYPE/{{{{9389
{{DAC{2,K$RTN{{{{9390
*
{V$STX{DBC{2,SVFNN{{{SETEXIT{9392
{{DAC{1,7{{{{9393
{{DTC{27,/SETEXIT/{{{{9394
{{DAC{6,S$STX{{{{9395
{{DAC{1,1{{{{9396
*
{V$STC{DBC{2,SVKNM{{{STCOUNT{9398
{{DAC{1,7{{{{9399
{{DTC{27,/STCOUNT/{{{{9400
{{DAC{2,K$STC{{{{9401
*
{V$STL{DBC{2,SVKNM{{{STLIMIT{9403
{{DAC{1,7{{{{9404
{{DTC{27,/STLIMIT/{{{{9405
{{DAC{2,K$STL{{{{9406
*
{V$SUC{DBC{2,SVKVC{{{SUCCEED{9408
{{DAC{1,7{{{{9409
{{DTC{27,/SUCCEED/{{{{9410
{{DAC{2,K$SUC{{{{9411
{{DAC{4,NDSUC{{{{9412
*
{V$ALP{DBC{2,SVKWC{{{ALPHABET{9414
{{DAC{1,8{{{{9415
{{DTC{27,/ALPHABET/{{{{9416
{{DAC{2,K$ALP{{{{9417
*
{V$CNT{DBC{2,SVLBL{{{CONTINUE{9419
{{DAC{1,8{{{{9420
{{DTC{27,/CONTINUE/{{{{9421
{{DAC{6,L$CNT{{{{9422
{{EJC{{{{{9423
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DTP{DBC{2,SVFNP{{{DATATYPE{9427
{{DAC{1,8{{{{9428
{{DTC{27,/DATATYPE/{{{{9429
{{DAC{6,S$DTP{{{{9430
{{DAC{1,1{{{{9431
*
{V$ERL{DBC{2,SVKNM{{{ERRLIMIT{9433
{{DAC{1,8{{{{9434
{{DTC{27,/ERRLIMIT/{{{{9435
{{DAC{2,K$ERL{{{{9436
*
{V$FNC{DBC{2,SVKNM{{{FNCLEVEL{9438
{{DAC{1,8{{{{9439
{{DTC{27,/FNCLEVEL/{{{{9440
{{DAC{2,K$FNC{{{{9441
*
{V$FLS{DBC{2,SVKNM{{{FULLSCAN{9443
{{DAC{1,8{{{{9444
{{DTC{27,/FULLSCAN/{{{{9445
{{DAC{2,K$FLS{{{{9446
*
{V$LFL{DBC{2,SVKNM{{{LASTFILE{9449
{{DAC{1,8{{{{9450
{{DTC{27,/LASTFILE/{{{{9451
{{DAC{2,K$LFL{{{{9452
*
{V$LLN{DBC{2,SVKNM{{{LASTLINE{9456
{{DAC{1,8{{{{9457
{{DTC{27,/LASTLINE/{{{{9458
{{DAC{2,K$LLN{{{{9459
*
{V$MXL{DBC{2,SVKNM{{{MAXLNGTH{9462
{{DAC{1,8{{{{9463
{{DTC{27,/MAXLNGTH/{{{{9464
{{DAC{2,K$MXL{{{{9465
*
{V$TER{DBC{1,0{{{TERMINAL{9467
{{DAC{1,8{{{{9468
{{DTC{27,/TERMINAL/{{{{9469
{{DAC{1,0{{{{9470
*
{V$BSP{DBC{2,SVFNN{{{BACKSPACE{9473
{{DAC{1,9{{{{9474
{{DTC{27,/BACKSPACE/{{{{9475
{{DAC{6,S$BSP{{{{9476
{{DAC{1,1{{{{9477
*
{V$PRO{DBC{2,SVFNN{{{PROTOTYPE{9480
{{DAC{1,9{{{{9481
{{DTC{27,/PROTOTYPE/{{{{9482
{{DAC{6,S$PRO{{{{9483
{{DAC{1,1{{{{9484
*
{V$SCN{DBC{2,SVLBL{{{SCONTINUE{9486
{{DAC{1,9{{{{9487
{{DTC{27,/SCONTINUE/{{{{9488
{{DAC{6,L$SCN{{{{9489
*
{{DBC{1,0{{{DUMMY ENTRY TO END LIST{9491
{{DAC{1,10{{{LENGTH GT 9 (SCONTINUE){9492
{{EJC{{{{{9493
*
*      LIST OF SVBLK POINTERS FOR KEYWORDS TO BE DUMPED. THE
*      LIST IS IN THE ORDER WHICH APPEARS ON THE DUMP OUTPUT.
*
{VDMKW{DAC{4,V$ANC{{{ANCHOR{9498
{{DAC{4,V$CAS{{{CCASE{9500
{{DAC{4,V$COD{{{CODE{9502
{{DAC{1,1{{{COMPARE NOT PRINTED{9507
{{DAC{4,V$DMP{{{DUMP{9510
{{DAC{4,V$ERL{{{ERRLIMIT{9511
{{DAC{4,V$ETX{{{ERRTEXT{9512
{{DAC{4,V$ERT{{{ERRTYPE{9513
{{DAC{4,V$FIL{{{FILE{9515
{{DAC{4,V$FNC{{{FNCLEVEL{9517
{{DAC{4,V$FTR{{{FTRACE{9518
{{DAC{4,V$FLS{{{FULLSCAN{9519
{{DAC{4,V$INP{{{INPUT{9520
{{DAC{4,V$LFL{{{LASTFILE{9522
{{DAC{4,V$LLN{{{LASTLINE{9525
{{DAC{4,V$LST{{{LASTNO{9527
{{DAC{4,V$LIN{{{LINE{9529
{{DAC{4,V$MXL{{{MAXLENGTH{9531
{{DAC{4,V$OUP{{{OUTPUT{9532
{{DAC{4,V$PFL{{{PROFILE{9535
{{DAC{4,V$RTN{{{RTNTYPE{9537
{{DAC{4,V$STC{{{STCOUNT{9538
{{DAC{4,V$STL{{{STLIMIT{9539
{{DAC{4,V$STN{{{STNO{9540
{{DAC{4,V$TRA{{{TRACE{9541
{{DAC{4,V$TRM{{{TRIM{9542
{{DAC{1,0{{{END OF LIST{9543
*
*      TABLE USED BY GTNVR TO SEARCH SVBLK LISTS
*
{VSRCH{DAC{1,0{{{DUMMY ENTRY TO GET PROPER INDEXING{9547
{{DAC{4,V$EQF{{{START OF 1 CHAR VARIABLES (NONE){9548
{{DAC{4,V$EQF{{{START OF 2 CHAR VARIABLES{9549
{{DAC{4,V$ANY{{{START OF 3 CHAR VARIABLES{9550
{{DAC{4,V$ATN{{{START OF 4 CHAR VARIABLES{9552
{{DAC{4,V$ABE{{{START OF 5 CHAR VARIABLES{9560
{{DAC{4,V$ANC{{{START OF 6 CHAR VARIABLES{9561
{{DAC{4,V$COL{{{START OF 7 CHAR VARIABLES{9562
{{DAC{4,V$ALP{{{START OF 8 CHAR VARIABLES{9563
{{DAC{4,V$BSP{{{START OF 9 CHAR VARIABLES{9565
*
*      LAST LOCATION IN CONSTANT SECTION
*
{C$YYY{DAC{1,0{{{LAST LOCATION IN CONSTANT SECTION{9572
{{TTL{27,S P I T B O L -- WORKING STORAGE SECTION{{{{9573
*
*      THE WORKING STORAGE SECTION CONTAINS AREAS WHICH ARE
*      CHANGED DURING EXECUTION OF THE PROGRAM. THE VALUE
*      ASSEMBLED IS THE INITIAL VALUE BEFORE EXECUTION STARTS.
*
*      ALL THESE AREAS ARE FIXED LENGTH AREAS. VARIABLE LENGTH
*      DATA IS STORED IN THE STATIC OR DYNAMIC REGIONS OF THE
*      ALLOCATED DATA AREAS.
*
*      THE VALUES IN THIS AREA ARE DESCRIBED EITHER AS WORK
*      AREAS OR AS GLOBAL VALUES. A WORK AREA IS USED IN AN
*      EPHEMERAL MANNER AND THE VALUE IS NOT SAVED FROM ONE
*      ENTRY INTO A ROUTINE TO ANOTHER. A GLOBAL VALUE IS A
*      LESS TEMPORARY LOCATION WHOSE VALUE IS SAVED FROM ONE
*      CALL TO ANOTHER.
*
*      W$AAA MARKS THE START OF THE WORKING SECTION WHILST
*      W$YYY MARKS ITS END.  G$AAA MARKS THE DIVISION BETWEEN
*      TEMPORARY AND GLOBAL VALUES.
*
*      GLOBAL VALUES ARE FURTHER SUBDIVIDED TO FACILITATE
*      PROCESSING BY THE GARBAGE COLLECTOR. R$AAA THROUGH
*      R$YYY ARE GLOBAL VALUES THAT MAY POINT INTO DYNAMIC
*      STORAGE AND HENCE MUST BE RELOCATED AFTER EACH GARBAGE
*      COLLECTION.  THEY ALSO SERVE AS ROOT POINTERS TO ALL
*      ALLOCATED DATA THAT MUST BE PRESERVED.  POINTERS BETWEEN
*      A$AAA AND R$AAA MAY POINT INTO CODE, STATIC STORAGE,
*      OR MARK THE LIMITS OF DYNAMIC MEMORY.  THESE POINTERS
*      MUST BE ADJUSTED WHEN THE WORKING SECTION IS SAVED TO A
*      FILE AND SUBSEQUENTLY RELOADED AT A DIFFERENT ADDRESS.
*
*      A GENERAL PART OF THE APPROACH IN THIS PROGRAM IS NOT
*      TO OVERLAP WORK AREAS BETWEEN PROCEDURES EVEN THOUGH A
*      SMALL AMOUNT OF SPACE COULD BE SAVED. SUCH OVERLAP IS
*      CONSIDERED A SOURCE OF PROGRAM ERRORS AND DECREASES THE
*      INFORMATION LEFT BEHIND AFTER A SYSTEM CRASH OF ANY KIND.
*
*      THE NAMES OF THESE LOCATIONS ARE LABELS WITH FIVE LETTER
*      (A-Y,$) NAMES. AS FAR AS POSSIBLE THE ORDER IS KEPT
*      ALPHABETICAL BY THESE NAMES BUT IN SOME CASES THERE
*      ARE SLIGHT DEPARTURES CAUSED BY OTHER ORDER REQUIREMENTS.
*
*      UNLESS OTHERWISE DOCUMENTED, THE ORDER OF WORK AREAS
*      DOES NOT AFFECT THE EXECUTION OF THE SPITBOL PROGRAM.
*
{{SEC{{{{START OF WORKING STORAGE SECTION{9619
{{EJC{{{{{9620
*
*      THIS AREA IS NOT CLEARED BY INITIAL CODE
*
{CMLAB{DAC{6,B$SCL{{{STRING USED TO CHECK LABEL LEGALITY{9624
{{DAC{1,2{{{{9625
{{DTC{27,/  /{{{{9626
*
*      LABEL TO MARK START OF WORK AREA
*
{W$AAA{DAC{1,0{{{{9630
*
*      WORK AREAS FOR ACESS PROCEDURE
*
{ACTRM{DAC{1,0{{{TRIM INDICATOR{9634
*
*      WORK AREAS FOR ALLOC PROCEDURE
*
{ALDYN{DAC{1,0{{{AMOUNT OF DYNAMIC STORE{9638
{ALLIA{DIC{16,+0{{{DUMP IA{9639
{ALLSV{DAC{1,0{{{SAVE WB IN ALLOC{9640
*
*      WORK AREAS FOR ALOST PROCEDURE
*
{ALSTA{DAC{1,0{{{SAVE WA IN ALOST{9644
*
*      WORK AREAS FOR ARRAY FUNCTION (S$ARR)
*
{ARCDM{DAC{1,0{{{COUNT DIMENSIONS{9648
{ARNEL{DIC{16,+0{{{COUNT ELEMENTS{9649
{ARPTR{DAC{1,0{{{OFFSET PTR INTO ARBLK{9650
{ARSVL{DIC{16,+0{{{SAVE INTEGER LOW BOUND{9651
{{EJC{{{{{9652
*
*      WORK AREAS FOR ARREF ROUTINE
*
{ARFSI{DIC{16,+0{{{SAVE CURRENT EVOLVING SUBSCRIPT{9656
{ARFXS{DAC{1,0{{{SAVE BASE STACK POINTER{9657
*
*      WORK AREAS FOR B$EFC BLOCK ROUTINE
*
{BEFOF{DAC{1,0{{{SAVE OFFSET PTR INTO EFBLK{9661
*
*      WORK AREAS FOR B$PFC BLOCK ROUTINE
*
{BPFPF{DAC{1,0{{{SAVE PFBLK POINTER{9665
{BPFSV{DAC{1,0{{{SAVE OLD FUNCTION VALUE{9666
{BPFXT{DAC{1,0{{{POINTER TO STACKED ARGUMENTS{9667
*
*      WORK AREA FOR COLLECT FUNCTION (S$COL)
*
{CLSVI{DIC{16,+0{{{SAVE INTEGER ARGUMENT{9671
*
*      WORK AREAS VALUE FOR CNCRD
*
{CNSCC{DAC{1,0{{{POINTER TO CONTROL CARD STRING{9675
{CNSWC{DAC{1,0{{{WORD COUNT{9676
{CNR$T{DAC{1,0{{{POINTER TO R$TTL OR R$STL{9677
*
*      WORK AREAS FOR CONVERT FUNCTION (S$CNV)
*
{CNVTP{DAC{1,0{{{SAVE PTR INTO SCVTB{9681
*
*      WORK AREAS FOR DATA FUNCTION (S$DAT)
*
{DATDV{DAC{1,0{{{SAVE VRBLK PTR FOR DATATYPE NAME{9685
{DATXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{9686
*
*      WORK AREAS FOR DEFINE FUNCTION (S$DEF)
*
{DEFLB{DAC{1,0{{{SAVE VRBLK PTR FOR LABEL{9690
{DEFNA{DAC{1,0{{{COUNT FUNCTION ARGUMENTS{9691
{DEFVR{DAC{1,0{{{SAVE VRBLK PTR FOR FUNCTION NAME{9692
{DEFXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{9693
*
*      WORK AREAS FOR DUMPR PROCEDURE
*
{DMARG{DAC{1,0{{{DUMP ARGUMENT{9697
{DMPSA{DAC{1,0{{{PRESERVE WA OVER PRTVL CALL{9698
{DMPSB{DAC{1,0{{{PRESERVE WB OVER SYSCM CALL{9700
{DMPSV{DAC{1,0{{{GENERAL SCRATCH SAVE{9702
{DMVCH{DAC{1,0{{{CHAIN POINTER FOR VARIABLE BLOCKS{9703
{DMPCH{DAC{1,0{{{SAVE SORTED VRBLK CHAIN POINTER{9704
{DMPKB{DAC{1,0{{{DUMMY KVBLK FOR USE IN DUMPR{9705
{DMPKT{DAC{1,0{{{KVVAR TRBLK PTR (MUST FOLLOW DMPKB){9706
{DMPKN{DAC{1,0{{{KEYWORD NUMBER (MUST FOLLOW DMPKT){9707
*
*      WORK AREA FOR DTACH
*
{DTCNB{DAC{1,0{{{NAME BASE{9711
{DTCNM{DAC{1,0{{{NAME PTR{9712
*
*      WORK AREAS FOR DUPL FUNCTION (S$DUP)
*
{DUPSI{DIC{16,+0{{{STORE INTEGER STRING LENGTH{9716
*
*      WORK AREA FOR ENDFILE (S$ENF)
*
{ENFCH{DAC{1,0{{{FOR IOCHN CHAIN HEAD{9720
{{EJC{{{{{9721
*
*      WORK AREAS FOR ERTEX
*
{ERTWA{DAC{1,0{{{SAVE WA{9725
{ERTWB{DAC{1,0{{{SAVE WB{9726
*
*      WORK AREAS FOR EVALI
*
{EVLIN{DAC{1,0{{{DUMMY PATTERN BLOCK PCODE{9730
{EVLIS{DAC{1,0{{{THEN NODE (MUST FOLLOW EVLIN){9731
{EVLIV{DAC{1,0{{{VALUE OF PARM1 (MUST FOLLOW EVLIS){9732
{EVLIO{DAC{1,0{{{PTR TO ORIGINAL NODE{9733
{EVLIF{DAC{1,0{{{FLAG FOR SIMPLE/COMPLEX ARGUMENT{9734
*
*      WORK AREA FOR EXPAN
*
{EXPSV{DAC{1,0{{{SAVE OP DOPE VECTOR POINTER{9738
*
*      WORK AREAS FOR GBCOL PROCEDURE
*
{GBCFL{DAC{1,0{{{GARBAGE COLLECTOR ACTIVE FLAG{9742
{GBCLM{DAC{1,0{{{POINTER TO LAST MOVE BLOCK (PASS 3){9743
{GBCNM{DAC{1,0{{{DUMMY FIRST MOVE BLOCK{9744
{GBCNS{DAC{1,0{{{REST OF DUMMY BLOCK (FOLLOWS GBCNM){9745
{GBCIA{DIC{16,+0{{{DUMP IA{9751
{GBCSD{DAC{1,0{{{FIRST ADDRESS BEYOND SEDIMENT{9752
{GBCSF{DAC{1,0{{{FREE SPACE WITHIN SEDIMENT{9753
{GBSVA{DAC{1,0{{{SAVE WA{9755
{GBSVB{DAC{1,0{{{SAVE WB{9756
{GBSVC{DAC{1,0{{{SAVE WC{9757
*
*      WORK AREAS FOR GTNVR PROCEDURE
*
{GNVHE{DAC{1,0{{{PTR TO END OF HASH CHAIN{9761
{GNVNW{DAC{1,0{{{NUMBER OF WORDS IN STRING NAME{9762
{GNVSA{DAC{1,0{{{SAVE WA{9763
{GNVSB{DAC{1,0{{{SAVE WB{9764
{GNVSP{DAC{1,0{{{POINTER INTO VSRCH TABLE{9765
{GNVST{DAC{1,0{{{POINTER TO CHARS OF STRING{9766
*
*      WORK AREAS FOR GTARR
*
{GTAWA{DAC{1,0{{{SAVE WA{9770
*
*      WORK AREAS FOR GTINT
*
{GTINA{DAC{1,0{{{SAVE WA{9774
{GTINB{DAC{1,0{{{SAVE WB{9775
{{EJC{{{{{9776
*
*      WORK AREAS FOR GTNUM PROCEDURE
*
{GTNNF{DAC{1,0{{{ZERO/NONZERO FOR RESULT +/-{9780
{GTNSI{DIC{16,+0{{{GENERAL INTEGER SAVE{9781
{GTNDF{DAC{1,0{{{0/1 FOR DEC POINT SO FAR NO/YES{9784
{GTNES{DAC{1,0{{{ZERO/NONZERO EXPONENT +/-{9785
{GTNEX{DIC{16,+0{{{REAL EXPONENT{9786
{GTNSC{DAC{1,0{{{SCALE (PLACES AFTER POINT){9787
{GTNSR{DRC{17,+0.0{{{GENERAL REAL SAVE{9788
{GTNRD{DAC{1,0{{{FLAG FOR OK REAL NUMBER{9789
*
*      WORK AREAS FOR GTPAT PROCEDURE
*
{GTPSB{DAC{1,0{{{SAVE WB{9794
*
*      WORK AREAS FOR GTSTG PROCEDURE
*
{GTSSF{DAC{1,0{{{0/1 FOR RESULT +/-{9798
{GTSVC{DAC{1,0{{{SAVE WC{9799
{GTSVB{DAC{1,0{{{SAVE WB{9800
{GTSES{DAC{1,0{{{CHAR + OR - FOR EXPONENT +/-{9805
{GTSRS{DRC{17,+0.0{{{GENERAL REAL SAVE{9806
*
*      WORK AREAS FOR GTVAR PROCEDURE
*
{GTVRC{DAC{1,0{{{SAVE WC{9812
*
*      WORK AREAS FOR IOPUT
*
{IOPTT{DAC{1,0{{{TYPE OF ASSOCIATION{9827
*
*      WORK AREAS FOR LOAD FUNCTION
*
{LODFN{DAC{1,0{{{POINTER TO VRBLK FOR FUNC NAME{9833
{LODNA{DAC{1,0{{{COUNT NUMBER OF ARGUMENTS{9834
*
*      WORK AREA FOR PROFILER
*
{PFSVW{DAC{1,0{{{TO SAVE A W-REG{9841
*
*      WORK AREAS FOR PRTNM PROCEDURE
*
{PRNSI{DIC{16,+0{{{SCRATCH INTEGER LOC{9846
*
*      WORK AREAS FOR PRTSN PROCEDURE
*
{PRSNA{DAC{1,0{{{SAVE WA{9850
*
*      WORK AREAS FOR PRTST PROCEDURE
*
{PRSVA{DAC{1,0{{{SAVE WA{9854
{PRSVB{DAC{1,0{{{SAVE WB{9855
{PRSVC{DAC{1,0{{{SAVE CHAR COUNTER{9856
*
*      WORK AREA FOR PRTNL
*
{PRTSA{DAC{1,0{{{SAVE WA{9860
{PRTSB{DAC{1,0{{{SAVE WB{9861
*
*      WORK AREA FOR PRTVL
*
{PRVSI{DAC{1,0{{{SAVE IDVAL{9865
*
*      WORK AREAS FOR PATTERN MATCH ROUTINES
*
{PSAVE{DAC{1,0{{{TEMPORARY SAVE FOR CURRENT NODE PTR{9869
{PSAVC{DAC{1,0{{{SAVE CURSOR IN P$SPN, P$STR{9870
*
*      WORK AREA FOR RELAJ ROUTINE
*
{RLALS{DAC{1,0{{{PTR TO LIST OF BOUNDS AND ADJUSTS{9875
*
*      WORK AREA FOR RELDN ROUTINE
*
{RLDCD{DAC{1,0{{{SAVE CODE ADJUSTMENT{9879
{RLDST{DAC{1,0{{{SAVE STATIC ADJUSTMENT{9880
{RLDLS{DAC{1,0{{{SAVE LIST POINTER{9881
*
*      WORK AREAS FOR RETRN ROUTINE
*
{RTNBP{DAC{1,0{{{TO SAVE A BLOCK POINTER{9886
{RTNFV{DAC{1,0{{{NEW FUNCTION VALUE (RESULT){9887
{RTNSV{DAC{1,0{{{OLD FUNCTION VALUE (SAVED VALUE){9888
*
*      WORK AREAS FOR SUBSTR FUNCTION (S$SUB)
*
{SBSSV{DAC{1,0{{{SAVE THIRD ARGUMENT{9892
*
*      WORK AREAS FOR SCAN PROCEDURE
*
{SCNSA{DAC{1,0{{{SAVE WA{9896
{SCNSB{DAC{1,0{{{SAVE WB{9897
{SCNSC{DAC{1,0{{{SAVE WC{9898
{SCNOF{DAC{1,0{{{SAVE OFFSET{9899
{{EJC{{{{{9902
*
*      WORK AREA USED BY SORTA, SORTC, SORTF, SORTH
*
{SRTDF{DAC{1,0{{{DATATYPE FIELD NAME{9906
{SRTFD{DAC{1,0{{{FOUND DFBLK ADDRESS{9907
{SRTFF{DAC{1,0{{{FOUND FIELD NAME{9908
{SRTFO{DAC{1,0{{{OFFSET TO FIELD NAME{9909
{SRTNR{DAC{1,0{{{NUMBER OF ROWS{9910
{SRTOF{DAC{1,0{{{OFFSET WITHIN ROW TO SORT KEY{9911
{SRTRT{DAC{1,0{{{ROOT OFFSET{9912
{SRTS1{DAC{1,0{{{SAVE OFFSET 1{9913
{SRTS2{DAC{1,0{{{SAVE OFFSET 2{9914
{SRTSC{DAC{1,0{{{SAVE WC{9915
{SRTSF{DAC{1,0{{{SORT ARRAY FIRST ROW OFFSET{9916
{SRTSN{DAC{1,0{{{SAVE N{9917
{SRTSO{DAC{1,0{{{OFFSET TO A(0){9918
{SRTSR{DAC{1,0{{{0, NON-ZERO FOR SORT, RSORT{9919
{SRTST{DAC{1,0{{{STRIDE FROM ONE ROW TO NEXT{9920
{SRTWC{DAC{1,0{{{DUMP WC{9921
*
*      WORK AREAS FOR STOPR ROUTINE
*
{STPSI{DIC{16,+0{{{SAVE VALUE OF STCOUNT{9926
{STPTI{DIC{16,+0{{{SAVE TIME ELAPSED{9927
*
*      WORK AREAS FOR TFIND PROCEDURE
*
{TFNSI{DIC{16,+0{{{NUMBER OF HEADERS{9931
*
*      WORK AREAS FOR XSCAN PROCEDURE
*
{XSCRT{DAC{1,0{{{SAVE RETURN CODE{9935
{XSCWB{DAC{1,0{{{SAVE REGISTER WB{9936
*
*      START OF GLOBAL VALUES IN WORKING SECTION
*
{G$AAA{DAC{1,0{{{{9940
*
*      GLOBAL VALUE FOR ALLOC PROCEDURE
*
{ALFSF{DIC{16,+0{{{FACTOR IN FREE STORE PCNTAGE CHECK{9944
*
*      GLOBAL VALUES FOR CMPIL PROCEDURE
*
{CMERC{DAC{1,0{{{COUNT OF INITIAL COMPILE ERRORS{9948
{CMPLN{DAC{1,0{{{LINE NUMBER OF FIRST LINE OF STMT{9949
{CMPXS{DAC{1,0{{{SAVE STACK PTR IN CASE OF ERRORS{9950
{CMPSN{DAC{1,1{{{NUMBER OF NEXT STATEMENT TO COMPILE{9951
*
*      GLOBAL VALUES FOR CNCRD
*
{CNSIL{DAC{1,0{{{SAVE SCNIL DURING INCLUDE PROCESS.{9956
{CNIND{DAC{1,0{{{CURRENT INCLUDE FILE NEST LEVEL{9957
{CNSPT{DAC{1,0{{{SAVE SCNPT DURING INCLUDE PROCESS.{9958
{CNTTL{DAC{1,0{{{FLAG FOR -TITLE, -STITL{9960
*
*      GLOBAL FLAG FOR SUPPRESSION OF COMPILATION STATISTICS.
*
{CPSTS{DAC{1,0{{{SUPPRESS COMP. STATS IF NON ZERO{9964
*
*      GLOBAL VALUES FOR CONTROL CARD SWITCHES
*
{CSWDB{DAC{1,0{{{0/1 FOR -SINGLE/-DOUBLE{9968
{CSWER{DAC{1,0{{{0/1 FOR -ERRORS/-NOERRORS{9969
{CSWEX{DAC{1,0{{{0/1 FOR -EXECUTE/-NOEXECUTE{9970
{CSWFL{DAC{1,1{{{0/1 FOR -NOFAIL/-FAIL{9971
{CSWIN{DAC{2,INILN{{{XXX FOR -INXXX{9972
{CSWLS{DAC{1,1{{{0/1 FOR -NOLIST/-LIST{9973
{CSWNO{DAC{1,0{{{0/1 FOR -OPTIMISE/-NOOPT{9974
{CSWPR{DAC{1,0{{{0/1 FOR -NOPRINT/-PRINT{9975
*
*      GLOBAL LOCATION USED BY PATST PROCEDURE
*
{CTMSK{DBC{1,0{{{LAST BIT POSITION USED IN R$CTP{9979
{CURID{DAC{1,0{{{CURRENT ID VALUE{9980
{{EJC{{{{{9981
*
*      GLOBAL VALUE FOR CDWRD PROCEDURE
*
{CWCOF{DAC{1,0{{{NEXT WORD OFFSET IN CURRENT CCBLK{9985
*
*      GLOBAL LOCATIONS FOR DYNAMIC STORAGE POINTERS
*
{DNAMS{DAC{1,0{{{SIZE OF SEDIMENT IN BAUS{9990
*
*      GLOBAL AREA FOR ERROR PROCESSING.
*
{ERICH{DAC{1,0{{{COPY ERROR REPORTS TO INT.CHAN IF 1{9995
{ERLST{DAC{1,0{{{FOR LISTR WHEN ERRORS GO TO INT.CH.{9996
{ERRFT{DAC{1,0{{{FATAL ERROR FLAG{9997
{ERRSP{DAC{1,0{{{ERROR SUPPRESSION FLAG{9998
*
*      GLOBAL FLAG FOR SUPPRESSION OF EXECUTION STATS
*
{EXSTS{DAC{1,0{{{SUPPRESS EXEC STATS IF SET{10002
*
*      GLOBAL VALUES FOR EXFAL AND RETURN
*
{FLPRT{DAC{1,0{{{LOCATION OF FAIL OFFSET FOR RETURN{10006
{FLPTR{DAC{1,0{{{LOCATION OF FAILURE OFFSET ON STACK{10007
*
*      GLOBAL LOCATION TO COUNT GARBAGE COLLECTIONS (GBCOL)
*
{GBSED{DIC{16,+0{{{FACTOR IN SEDIMENT PCNTAGE CHECK{10012
{GBCNT{DAC{1,0{{{COUNT OF GARBAGE COLLECTIONS{10014
*
*      GLOBAL VALUE FOR GTCOD AND GTEXP
*
{GTCEF{DAC{1,0{{{SAVE FAIL PTR IN CASE OF ERROR{10018
*
*      GLOBAL LOCATIONS FOR GTSTG PROCEDURE
*
{GTSRN{DRC{17,+0.0{{{ROUNDING FACTOR 0.5*10**-CFP$S{10026
{GTSSC{DRC{17,+0.0{{{SCALING VALUE 10**CFP$S{10027
{GTSWK{DAC{1,0{{{PTR TO WORK AREA FOR GTSTG{10030
*
*      GLOBAL FLAG FOR HEADER PRINTING
*
{HEADP{DAC{1,0{{{HEADER PRINTED FLAG{10034
*
*      GLOBAL VALUES FOR VARIABLE HASH TABLE
*
{HSHNB{DIC{16,+0{{{NUMBER OF HASH BUCKETS{10038
*
*      GLOBAL AREAS FOR INIT
*
{INITR{DAC{1,0{{{SAVE TERMINAL FLAG{10042
{{EJC{{{{{10043
*
*      GLOBAL VALUES FOR KEYWORD VALUES WHICH ARE STORED AS ONE
*      WORD INTEGERS. THESE VALUES MUST BE ASSEMBLED IN THE
*      FOLLOWING ORDER (AS DICTATED BY K$XXX DEFINITION VALUES).
*
{KVABE{DAC{1,0{{{ABEND{10049
{KVANC{DAC{1,0{{{ANCHOR{10050
{KVCAS{DAC{1,0{{{CASE{10052
{KVCOD{DAC{1,0{{{CODE{10054
{KVCOM{DAC{1,0{{{COMPARE{10056
{KVDMP{DAC{1,0{{{DUMP{10058
{KVERL{DAC{1,0{{{ERRLIMIT{10059
{KVERT{DAC{1,0{{{ERRTYPE{10060
{KVFTR{DAC{1,0{{{FTRACE{10061
{KVFLS{DAC{1,1{{{FULLSCAN{10062
{KVINP{DAC{1,1{{{INPUT{10063
{KVMXL{DAC{1,5000{{{MAXLENGTH{10064
{KVOUP{DAC{1,1{{{OUTPUT{10065
{KVPFL{DAC{1,0{{{PROFILE{10068
{KVTRA{DAC{1,0{{{TRACE{10070
{KVTRM{DAC{1,0{{{TRIM{10071
{KVFNC{DAC{1,0{{{FNCLEVEL{10072
{KVLST{DAC{1,0{{{LASTNO{10073
{KVLLN{DAC{1,0{{{LASTLINE{10075
{KVLIN{DAC{1,0{{{LINE{10076
{KVSTN{DAC{1,0{{{STNO{10078
*
*      GLOBAL VALUES FOR OTHER KEYWORDS
*
{KVALP{DAC{1,0{{{ALPHABET{10082
{KVRTN{DAC{4,NULLS{{{RTNTYPE (SCBLK POINTER){10083
{KVSTL{DIC{16,+2147483647{{{STLIMIT{10089
{KVSTC{DIC{16,+2147483647{{{STCOUNT (COUNTS DOWN FROM STLIMIT){10090
*
*      GLOBAL VALUES FOR LISTR PROCEDURE
*
{LSTID{DAC{1,0{{{INCLUDE DEPTH OF CURRENT IMAGE{10100
{LSTLC{DAC{1,0{{{COUNT LINES ON SOURCE LIST PAGE{10102
{LSTNP{DAC{1,0{{{MAX NUMBER OF LINES ON PAGE{10103
{LSTPF{DAC{1,1{{{SET NONZERO IF CURRENT IMAGE LISTED{10104
{LSTPG{DAC{1,0{{{CURRENT SOURCE LIST PAGE NUMBER{10105
{LSTPO{DAC{1,0{{{OFFSET TO   PAGE NNN   MESSAGE{10106
{LSTSN{DAC{1,0{{{REMEMBER LAST STMNUM LISTED{10107
*
*      GLOBAL MAXIMUM SIZE OF SPITBOL OBJECTS
*
{MXLEN{DAC{1,0{{{INITIALISED BY SYSMX CALL{10111
*
*      GLOBAL EXECUTION CONTROL VARIABLE
*
{NOXEQ{DAC{1,0{{{SET NON-ZERO TO INHIBIT EXECUTION{10115
*
*      GLOBAL PROFILER VALUES LOCATIONS
*
{PFDMP{DAC{1,0{{{SET NON-0 IF &PROFILE SET NON-0{10121
{PFFNC{DAC{1,0{{{SET NON-0 IF FUNCT JUST ENTERED{10122
{PFSTM{DIC{16,+0{{{TO STORE STARTING TIME OF STMT{10123
{PFETM{DIC{16,+0{{{TO STORE ENDING TIME OF STMT{10124
{PFNTE{DAC{1,0{{{NR OF TABLE ENTRIES{10125
{PFSTE{DIC{16,+0{{{GETS INT REP OF TABLE ENTRY SIZE{10126
*
{{EJC{{{{{10129
*
*      GLOBAL VALUES USED IN PATTERN MATCH ROUTINES
*
{PMDFL{DAC{1,0{{{PATTERN ASSIGNMENT FLAG{10133
{PMHBS{DAC{1,0{{{HISTORY STACK BASE POINTER{10134
{PMSSL{DAC{1,0{{{LENGTH OF SUBJECT STRING IN CHARS{10135
*
*      GLOBAL VALUES FOR INTERFACE POLLING (SYSPL)
*
{POLCS{DAC{1,1{{{POLL INTERVAL START VALUE{10140
{POLCT{DAC{1,1{{{POLL INTERVAL COUNTER{10141
*
*      GLOBAL FLAGS USED FOR STANDARD FILE LISTING OPTIONS
*
{PRICH{DAC{1,0{{{PRINTER ON INTERACTIVE CHANNEL{10146
{PRSTD{DAC{1,0{{{TESTED BY PRTPG{10147
{PRSTO{DAC{1,0{{{STANDARD LISTING OPTION FLAG{10148
*
*      GLOBAL VALUES FOR PRINT PROCEDURES
*
{PRBUF{DAC{1,0{{{PTR TO PRINT BFR IN STATIC{10152
{PRECL{DAC{1,0{{{EXTENDED/COMPACT LISTING FLAG{10153
{PRLEN{DAC{1,0{{{LENGTH OF PRINT BUFFER IN CHARS{10154
{PRLNW{DAC{1,0{{{LENGTH OF PRINT BUFFER IN WORDS{10155
{PROFS{DAC{1,0{{{OFFSET TO NEXT LOCATION IN PRBUF{10156
{PRTEF{DAC{1,0{{{ENDFILE FLAG{10157
{{EJC{{{{{10158
*
*      GLOBAL AREA FOR READR
*
{RDCLN{DAC{1,0{{{CURRENT STATEMENT LINE NUMBER{10162
{RDNLN{DAC{1,0{{{NEXT STATEMENT LINE NUMBER{10163
*
*      GLOBAL AMOUNT OF MEMORY RESERVED FOR END OF EXECUTION
*
{RSMEM{DAC{1,0{{{RESERVE MEMORY{10167
*
*      GLOBAL AREA FOR STMGO COUNTERS
*
{STMCS{DAC{1,1{{{COUNTER STARTUP VALUE{10171
{STMCT{DAC{1,1{{{COUNTER ACTIVE VALUE{10172
*
*      ADJUSTABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO THE
*      DYNAMIC OR THE STATIC REGION.
*      WHEN A SAVE FILE IS RELOADED, THESE POINTERS MUST
*      BE ADJUSTED IF STATIC OR DYNAMIC MEMORY IS NOW
*      AT A DIFFERENT ADDRESS.  SEE ROUTINE RELOC FOR
*      ADDITIONAL INFORMATION.
*
*      SOME VALUES CANNOT BE MOVE HERE BECAUSE OF ADJACENCY
*      CONSTRAINTS.  THEY ARE HANDLED SPECIALLY BY RELOC ET AL.
*      THESE VALUES ARE KVRTN,
*
*      VALUES GTSWK, KVALP, AND PRBUF ARE REINITIALIZED BY
*      PROCEDURE INSTA, AND DO NOT NEED TO APPEAR HERE.
*
*      VALUES FLPRT, FLPTR, GTCEF, AND STBAS POINT INTO THE
*      STACK AND ARE EXPLICITLY ADJUSTED BY OSINT'S RESTART
*      PROCEDURE.
*
{A$AAA{DAC{1,0{{{START OF ADJUSTABLE VALUES{10194
{CMPSS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{10195
{DNAMB{DAC{1,0{{{START OF DYNAMIC AREA{10196
{DNAMP{DAC{1,0{{{NEXT AVAILABLE LOC IN DYNAMIC AREA{10197
{DNAME{DAC{1,0{{{END OF AVAILABLE DYNAMIC AREA{10198
{HSHTB{DAC{1,0{{{POINTER TO START OF VRBLK HASH TABL{10199
{HSHTE{DAC{1,0{{{POINTER PAST END OF VRBLK HASH TABL{10200
{INISS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{10201
{PFTBL{DAC{1,0{{{GETS ADRS OF (IMAG) TABLE BASE{10202
{PRNMV{DAC{1,0{{{VRBLK PTR FROM LAST NAME SEARCH{10203
{STATB{DAC{1,0{{{START OF STATIC AREA{10204
{STATE{DAC{1,0{{{END OF STATIC AREA{10205
{STXVR{DAC{4,NULLS{{{VRBLK POINTER OR NULL{10206
*
*      RELOCATABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO BLOCKS IN
*      THE DYNAMIC STORAGE AREA AND MUST BE RELOCATED BY THE
*      GARBAGE COLLECTOR. THEY ARE IDENTIFIED BY R$XXX NAMES.
*
{R$AAA{DAC{1,0{{{START OF RELOCATABLE VALUES{10215
{R$ARF{DAC{1,0{{{ARRAY BLOCK POINTER FOR ARREF{10216
{R$CCB{DAC{1,0{{{PTR TO CCBLK BEING BUILT (CDWRD){10217
{R$CIM{DAC{1,0{{{PTR TO CURRENT COMPILER INPUT STR{10218
{R$CMP{DAC{1,0{{{COPY OF R$CIM USED IN CMPIL{10219
{R$CNI{DAC{1,0{{{PTR TO NEXT COMPILER INPUT STRING{10220
{R$CNT{DAC{1,0{{{CDBLK POINTER FOR SETEXIT CONTINUE{10221
{R$COD{DAC{1,0{{{POINTER TO CURRENT CDBLK OR EXBLK{10222
{R$CTP{DAC{1,0{{{PTR TO CURRENT CTBLK FOR PATST{10223
{R$CTS{DAC{1,0{{{PTR TO LAST STRING SCANNED BY PATST{10224
{R$ERT{DAC{1,0{{{TRBLK POINTER FOR ERRTYPE TRACE{10225
{R$ETX{DAC{4,NULLS{{{POINTER TO ERRTEXT STRING{10226
{R$EXS{DAC{1,0{{{= SAVE XL IN EXPDM{10227
{R$FCB{DAC{1,0{{{FCBLK CHAIN HEAD{10228
{R$FNC{DAC{1,0{{{TRBLK POINTER FOR FNCLEVEL TRACE{10229
{R$GTC{DAC{1,0{{{KEEP CODE PTR FOR GTCOD,GTEXP{10230
{R$ICI{DAC{1,0{{{SAVED R$CIM DURING INCLUDE PROCESS.{10232
{R$IFA{DAC{1,0{{{ARRAY OF FILE NAMES BY INCL. DEPTH{10234
{R$IFL{DAC{1,0{{{ARRAY OF LINE NUMS BY INCLUDE DEPTH{10235
{R$IFN{DAC{1,0{{{LAST INCLUDE FILE NAME{10237
{R$INC{DAC{1,0{{{TABLE OF INCLUDE FILE NAMES SEEN{10238
{R$IO1{DAC{1,0{{{FILE ARG1 FOR IOPUT{10240
{R$IO2{DAC{1,0{{{FILE ARG2 FOR IOPUT{10241
{R$IOF{DAC{1,0{{{FCBLK PTR OR 0{10242
{R$ION{DAC{1,0{{{NAME BASE PTR{10243
{R$IOP{DAC{1,0{{{PREDECESSOR BLOCK PTR FOR IOPUT{10244
{R$IOT{DAC{1,0{{{TRBLK PTR FOR IOPUT{10245
{R$PMS{DAC{1,0{{{SUBJECT STRING PTR IN PATTERN MATCH{10250
{R$RA2{DAC{1,0{{{REPLACE SECOND ARGUMENT LAST TIME{10251
{R$RA3{DAC{1,0{{{REPLACE THIRD ARGUMENT LAST TIME{10252
{R$RPT{DAC{1,0{{{PTR TO CTBLK REPLACE TABLE LAST USD{10253
{R$SCP{DAC{1,0{{{SAVE POINTER FROM LAST SCANE CALL{10254
{R$SFC{DAC{4,NULLS{{{CURRENT SOURCE FILE NAME{10256
{R$SFN{DAC{1,0{{{PTR TO SOURCE FILE NAME TABLE{10257
{R$SXL{DAC{1,0{{{PRESERVE XL IN SORTC{10259
{R$SXR{DAC{1,0{{{PRESERVE XR IN SORTA/SORTC{10260
{R$STC{DAC{1,0{{{TRBLK POINTER FOR STCOUNT TRACE{10261
{R$STL{DAC{1,0{{{SOURCE LISTING SUB-TITLE{10262
{R$SXC{DAC{1,0{{{CODE (CDBLK) PTR FOR SETEXIT TRAP{10263
{R$TTL{DAC{4,NULLS{{{SOURCE LISTING TITLE{10264
{R$XSC{DAC{1,0{{{STRING POINTER FOR XSCAN{10265
{{EJC{{{{{10266
*
*      THE REMAINING POINTERS IN THIS LIST ARE USED TO POINT
*      TO FUNCTION BLOCKS FOR NORMALLY UNDEFINED OPERATORS.
*
{R$UBA{DAC{4,STNDO{{{BINARY AT{10271
{R$UBM{DAC{4,STNDO{{{BINARY AMPERSAND{10272
{R$UBN{DAC{4,STNDO{{{BINARY NUMBER SIGN{10273
{R$UBP{DAC{4,STNDO{{{BINARY PERCENT{10274
{R$UBT{DAC{4,STNDO{{{BINARY NOT{10275
{R$UUB{DAC{4,STNDO{{{UNARY VERTICAL BAR{10276
{R$UUE{DAC{4,STNDO{{{UNARY EQUAL{10277
{R$UUN{DAC{4,STNDO{{{UNARY NUMBER SIGN{10278
{R$UUP{DAC{4,STNDO{{{UNARY PERCENT{10279
{R$UUS{DAC{4,STNDO{{{UNARY SLASH{10280
{R$UUX{DAC{4,STNDO{{{UNARY EXCLAMATION{10281
{R$YYY{DAC{1,0{{{LAST RELOCATABLE LOCATION{10282
*
*      GLOBAL LOCATIONS USED IN SCAN PROCEDURE
*
{SCNBL{DAC{1,0{{{SET NON-ZERO IF SCANNED PAST BLANKS{10286
{SCNCC{DAC{1,0{{{NON-ZERO TO SCAN CONTROL CARD NAME{10287
{SCNGO{DAC{1,0{{{SET NON-ZERO TO SCAN GOTO FIELD{10288
{SCNIL{DAC{1,0{{{LENGTH OF CURRENT INPUT IMAGE{10289
{SCNPT{DAC{1,0{{{POINTER TO NEXT LOCATION IN R$CIM{10290
{SCNRS{DAC{1,0{{{SET NON-ZERO TO SIGNAL RESCAN{10291
{SCNSE{DAC{1,0{{{START OF CURRENT ELEMENT{10292
{SCNTP{DAC{1,0{{{SAVE SYNTAX TYPE FROM LAST CALL{10293
*
*      GLOBAL VALUE FOR INDICATING STAGE (SEE ERROR SECTION)
*
{STAGE{DAC{1,0{{{INITIAL VALUE = INITIAL COMPILE{10297
{{EJC{{{{{10298
*
*      GLOBAL STACK POINTER
*
{STBAS{DAC{1,0{{{POINTER PAST STACK BASE{10302
*
*      GLOBAL VALUES FOR SETEXIT FUNCTION (S$STX)
*
{STXOC{DAC{1,0{{{CODE POINTER OFFSET{10306
{STXOF{DAC{1,0{{{FAILURE OFFSET{10307
*
*      GLOBAL VALUE FOR TIME KEEPING
*
{TIMSX{DIC{16,+0{{{TIME AT START OF EXECUTION{10311
{TIMUP{DAC{1,0{{{SET WHEN TIME UP OCCURS{10312
*
*      GLOBAL VALUES FOR XSCAN AND XSCNI PROCEDURES
*
{XSOFS{DAC{1,0{{{OFFSET TO CURRENT LOCATION IN R$XSC{10316
*
*      LABEL TO MARK END OF WORKING SECTION
*
{W$YYY{DAC{1,0{{{{10320
{{TTL{27,S P I T B O L -- MINIMAL CODE{{{{10321
{{SEC{{{{START OF PROGRAM SECTION{10322
{S$AAA{ENT{2,BL$$I{{{MARK START OF CODE{10323
{{TTL{27,S P I T B O L -- RELOCATION{{{{10325
*
*      RELOCATION
*      THE FOLLOWING SECTION PROVIDES SERVICES TO OSINT TO
*      RELOCATE PORTIONS OF THE WORKSPACE.  IT IS USED WHEN
*      A SAVED MEMORY IMAGE MUST BE RESTARTED AT A DIFFERENT
*      LOCATION.
*
*      RELAJ -- RELOCATE A LIST OF POINTERS
*
*      (WA)                  PTR PAST LAST POINTER OF LIST
*      (WB)                  PTR TO FIRST POINTER OF LIST
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELAJ            CALL TO PROCESS LIST OF POINTERS
*      (WB)                  DESTROYED
*
{RELAJ{PRC{25,E{1,0{{ENTRY POINT{10341
{{MOV{7,XR{11,-(XS){{SAVE XR{10342
{{MOV{8,WA{11,-(XS){{SAVE WA{10343
{{MOV{7,XL{3,RLALS{{SAVE PTR TO LIST OF BOUNDS{10344
{{MOV{8,WB{7,XR{{PTR TO FIRST POINTER TO PROCESS{10345
*
*      MERGE HERE TO CHECK IF DONE
*
{RLAJ0{MOV{3,RLALS{7,XL{{RESTORE XL{10349
{{BNE{7,XR{9,(XS){6,RLAJ1{PROCEED IF MORE TO DO{10350
{{MOV{10,(XS)+{8,WA{{RESTORE WA{10351
{{MOV{10,(XS)+{7,XR{{RESTORE XR{10352
{{EXI{{{{RETURN TO CALLER{10353
*
*      MERGE HERE TO PROCESS NEXT POINTER ON LIST
*
{RLAJ1{MOV{9,(XR){8,WA{{LOAD NEXT POINTER ON LIST{10357
{{LCT{8,WB{18,=RNSI${{NUMBER OF SECTIONS OF ADJUSTERS{10358
*
*      MERGE HERE TO PROCESS NEXT SECTION OF STACK LIST
*
{RLAJ2{BGT{8,WA{13,RLEND(XL){6,RLAJ3{OK IF PAST END OF SECTION{10362
{{BLT{8,WA{13,RLSTR(XL){6,RLAJ3{OR IF BEFORE START OF SECTION{10363
{{ADD{13,RLADJ(XL){8,WA{{WITHIN SECTION, ADD ADJUSTMENT{10364
{{MOV{8,WA{9,(XR){{RETURN UPDATED PTR TO MEMORY{10365
{{BRN{6,RLAJ4{{{DONE WITH THIS POINTER{10366
*
*      HERE IF NOT WITHIN SECTION
*
{RLAJ3{ADD{19,*RSSI${7,XL{{ADVANCE TO NEXT SECTION{10370
{{BCT{8,WB{6,RLAJ2{{JUMP IF MORE TO GO{10371
*
*      HERE WHEN FINISHED PROCESSING ONE POINTER
*
{RLAJ4{ICA{7,XR{{{INCREMENT TO NEXT PTR ON LIST{10375
{{BRN{6,RLAJ0{{{JUMP TO CHECK  FOR COMPLETION{10376
{{ENP{{{{END PROCEDURE RELAJ{10377
{{EJC{{{{{10378
*
*      RELCR -- CREATE RELOCATION INFO AFTER SAVE FILE RELOAD
*
*      (WA)                  ORIGINAL S$AAA CODE SECTION ADR
*      (WB)                  ORIGINAL C$AAA CONSTANT SECTION ADR
*      (WC)                  ORIGINAL G$AAA WORKING SECTION ADR
*      (XR)                  PTR TO START OF STATIC REGION
*      (CP)                  PTR TO START OF DYNAMIC REGION
*      (XL)                  PTR TO AREA TO RECEIVE INFORMATION
*      JSR  RELCR            CREATE RELOCATION INFORMATION
*      (WA,WB,WC,XR)         DESTROYED
*
*      A BLOCK OF INFORMATION IS BUILT AT (XL) THAT IS USED
*      IN RELOCATING POINTERS.  THERE ARE RNSI$ INSTANCES
*      OF A RSSI$ WORD STRUCTURE.  EACH INSTANCE CORRESPONDS
*      TO ONE OF THE REGIONS THAT A POINTER MIGHT POINT INTO.
*      THE LAYOUT OF THIS STRUCTURE IS SHOWN IN THE DEFINITIONS
*      SECTION, TOGETHER WITH SYMBOLIC DEFINITIONS OF THE
*      ENTRIES AS OFFSETS FROM XL.
*
{RELCR{PRC{25,E{1,0{{ENTRY POINT{10399
{{ADD{19,*RLSI${7,XL{{POINT PAST BUILD AREA{10400
{{MOV{8,WA{11,-(XL){{SAVE ORIGINAL CODE ADDRESS{10401
{{MOV{22,=S$AAA{8,WA{{COMPUTE ADJUSTMENT{10402
{{SUB{9,(XL){8,WA{{AS NEW S$AAA MINUS ORIGINAL S$AAA{10403
{{MOV{8,WA{11,-(XL){{SAVE CODE ADJUSTMENT{10404
{{MOV{22,=S$YYY{8,WA{{END OF TARGET CODE SECTION{10405
{{SUB{22,=S$AAA{8,WA{{LENGTH OF CODE SECTION{10406
{{ADD{13,NUM01(XL){8,WA{{PLUS ORIGINAL START ADDRESS{10407
{{MOV{8,WA{11,-(XL){{END OF ORIGINAL CODE SECTION{10408
{{MOV{8,WB{11,-(XL){{SAVE CONSTANT SECTION ADDRESS{10409
{{MOV{21,=C$AAA{8,WB{{START OF CONSTANTS SECTION{10410
{{MOV{21,=C$YYY{8,WA{{END OF CONSTANTS SECTION{10411
{{SUB{8,WB{8,WA{{LENGTH OF CONSTANTS SECTION{10412
{{SUB{9,(XL){8,WB{{NEW C$AAA MINUS ORIGINAL C$AAA{10413
{{MOV{8,WB{11,-(XL){{SAVE CONSTANT ADJUSTMENT{10414
{{ADD{13,NUM01(XL){8,WA{{LENGTH PLUS ORIGINAL START ADR{10415
{{MOV{8,WA{11,-(XL){{SAVE AS END OF ORIGINAL CONSTANTS{10416
{{MOV{8,WC{11,-(XL){{SAVE WORKING GLOBALS ADDRESS{10417
{{MOV{20,=G$AAA{8,WC{{START OF WORKING GLOBALS SECTION{10418
{{MOV{20,=W$YYY{8,WA{{END OF WORKING SECTION{10419
{{SUB{8,WC{8,WA{{LENGTH OF WORKING GLOBALS{10420
{{SUB{9,(XL){8,WC{{NEW G$AAA MINUS ORIGINAL G$AAA{10421
{{MOV{8,WC{11,-(XL){{SAVE WORKING GLOBALS ADJUSTMENT{10422
{{ADD{13,NUM01(XL){8,WA{{LENGTH PLUS ORIGINAL START ADR{10423
{{MOV{8,WA{11,-(XL){{SAVE AS END OF WORKING GLOBALS{10424
{{MOV{3,STATB{8,WB{{OLD START OF STATIC REGION{10425
{{MOV{8,WB{11,-(XL){{SAVE{10426
{{SUB{8,WB{7,XR{{COMPUTE ADJUSTMENT{10427
{{MOV{7,XR{11,-(XL){{SAVE NEW STATB MINUS OLD STATB{10428
{{MOV{3,STATE{11,-(XL){{OLD END OF STATIC REGION{10429
{{MOV{3,DNAMB{8,WB{{OLD START OF DYNAMIC REGION{10430
{{MOV{8,WB{11,-(XL){{SAVE{10431
{{SCP{8,WA{{{NEW START OF DYNAMIC{10432
{{SUB{8,WB{8,WA{{COMPUTE ADJUSTMENT{10433
{{MOV{8,WA{11,-(XL){{SAVE NEW DNAMB MINUS OLD DNAMB{10434
{{MOV{3,DNAMP{8,WC{{OLD END OF DYNAMIC REGION IN USE{10435
{{MOV{8,WC{11,-(XL){{SAVE AS END OF OLD DYNAMIC REGION{10436
{{EXI{{{{{10437
{{ENP{{{{{10438
{{EJC{{{{{10439
*
*      RELDN -- RELOCATE POINTERS IN THE DYNAMIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  RELDN            CALL TO PROCESS BLOCKS IN DYNAMIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      PROCESSES ALL BLOCKS IN THE DYNAMIC REGION.  WITHIN A
*      BLOCK, POINTERS TO THE CODE SECTION, CONSTANT SECTION,
*      WORKING GLOBALS SECTION, STATIC REGION, AND DYNAMIC
*      REGION ARE RELOCATED AS NEEDED.
*
{RELDN{PRC{25,E{1,0{{ENTRY POINT{10454
{{MOV{13,RLCDA(XL){3,RLDCD{{SAVE CODE ADJUSTMENT{10455
{{MOV{13,RLSTA(XL){3,RLDST{{SAVE STATIC ADJUSTMENT{10456
{{MOV{7,XL{3,RLDLS{{SAVE LIST POINTER{10457
*
*      MERGE HERE TO PROCESS THE NEXT BLOCK IN DYNAMIC
*
{RLD01{ADD{3,RLDCD{9,(XR){{ADJUST BLOCK TYPE WORD{10461
{{MOV{9,(XR){7,XL{{LOAD BLOCK TYPE WORD{10462
{{LEI{7,XL{{{LOAD ENTRY POINT ID (BL$XX){10463
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO RLD05 TO CONTINUE TO NEXT BLOCK.
*
*      NOTE THAT DFBLKS DO NOT APPEAR IN DYNAMIC, ONLY IN STATIC.
*      CCBLKS AND CMBLKS ARE NOT LIVE WHEN A SAVE FILE IS
*      CREATED, AND CAN BE SKIPPED.
*
*      FURTHER NOTE:  STATIC BLOCKS OTHER THAN VRBLKS DISCOVERED
*      WHILE SCANNING DYNAMIC MUST BE ADJUSTED AT THIS TIME.
*      SEE PROCESSING OF FFBLK FOR EXAMPLE.
*
{{EJC{{{{{10476
*
*      RELDN (CONTINUED)
*
{{BSW{7,XL{2,BL$$${{SWITCH ON BLOCK TYPE{10480
{{IFF{2,BL$AR{6,RLD03{{ARBLK{10517
{{IFF{2,BL$CD{6,RLD07{{CDBLK{10517
{{IFF{2,BL$EX{6,RLD10{{EXBLK{10517
{{IFF{2,BL$IC{6,RLD05{{ICBLK{10517
{{IFF{2,BL$NM{6,RLD13{{NMBLK{10517
{{IFF{2,BL$P0{6,RLD13{{P0BLK{10517
{{IFF{2,BL$P1{6,RLD14{{P1BLK{10517
{{IFF{2,BL$P2{6,RLD14{{P2BLK{10517
{{IFF{2,BL$RC{6,RLD05{{RCBLK{10517
{{IFF{2,BL$SC{6,RLD05{{SCBLK{10517
{{IFF{2,BL$SE{6,RLD13{{SEBLK{10517
{{IFF{2,BL$TB{6,RLD17{{TBBLK{10517
{{IFF{2,BL$VC{6,RLD17{{VCBLK{10517
{{IFF{2,BL$XN{6,RLD05{{XNBLK{10517
{{IFF{2,BL$XR{6,RLD20{{XRBLK{10517
{{IFF{2,BL$BC{6,RLD05{{BCBLK - DUMMY TO FILL OUT IFFS{10517
{{IFF{2,BL$PD{6,RLD15{{PDBLK{10517
{{IFF{2,BL$TR{6,RLD19{{TRBLK{10517
{{IFF{2,BL$BF{6,RLD05{{BFBLK{10517
{{IFF{2,BL$CC{6,RLD05{{CCBLK{10517
{{IFF{2,BL$CM{6,RLD05{{CMBLK{10517
{{IFF{2,BL$CT{6,RLD05{{CTBLK{10517
{{IFF{2,BL$DF{6,RLD05{{DFBLK{10517
{{IFF{2,BL$EF{6,RLD08{{EFBLK{10517
{{IFF{2,BL$EV{6,RLD09{{EVBLK{10517
{{IFF{2,BL$FF{6,RLD11{{FFBLK{10517
{{IFF{2,BL$KV{6,RLD13{{KVBLK{10517
{{IFF{2,BL$PF{6,RLD16{{PFBLK{10517
{{IFF{2,BL$TE{6,RLD18{{TEBLK{10517
{{ESW{{{{END OF JUMP TABLE{10517
*
*      ARBLK
*
{RLD03{MOV{13,ARLEN(XR){8,WA{{LOAD LENGTH{10521
{{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO 1ST RELOC FLD (ARPRO){10522
*
*      MERGE HERE TO PROCESS POINTERS IN A BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
{RLD04{ADD{7,XR{8,WA{{POINT PAST LAST RELOC FIELD{10531
{{ADD{7,XR{8,WB{{POINT TO FIRST RELOC FIELD{10532
{{MOV{3,RLDLS{7,XL{{POINT TO LIST OF BOUNDS{10533
{{JSR{6,RELAJ{{{ADJUST POINTERS{10534
{{EJC{{{{{10535
*
*      RELDN (CONTINUED)
*
*
*      MERGE HERE TO ADVANCE TO NEXT BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*
{RLD05{MOV{9,(XR){8,WA{{BLOCK TYPE WORD{10545
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{10546
{{ADD{8,WA{7,XR{{POINT TO NEXT BLOCK{10547
{{BLT{7,XR{8,WC{6,RLD01{CONTINUE IF MORE TO PROCESS{10548
{{MOV{3,RLDLS{7,XL{{RESTORE XL{10549
{{EXI{{{{RETURN TO CALLER IF DONE{10550
*
*      CDBLK
*
{RLD07{MOV{13,CDLEN(XR){8,WA{{LOAD LENGTH{10563
{{MOV{19,*CDFAL{8,WB{{SET OFFSET{10564
{{BNE{9,(XR){22,=B$CDC{6,RLD04{JUMP BACK IF NOT COMPLEX GOTO{10565
{{MOV{19,*CDCOD{8,WB{{DO NOT PROCESS CDFAL WORD{10566
{{BRN{6,RLD04{{{JUMP BACK{10567
*
*      EFBLK
*
*      IF THE EFCOD WORD POINTS TO AN XNBLK, THE XNBLK TYPE
*      WORD WILL NOT BE ADJUSTED.  SINCE THIS IS IMPLEMENTATION
*      DEPENDENT, WE WILL NOT WORRY ABOUT IT.
*
{RLD08{MOV{19,*EFRSL{8,WA{{SET LENGTH{10575
{{MOV{19,*EFCOD{8,WB{{AND OFFSET{10576
{{BRN{6,RLD04{{{ALL SET{10577
*
*      EVBLK
*
{RLD09{MOV{19,*OFFS3{8,WA{{POINT PAST THIRD FIELD{10581
{{MOV{19,*EVEXP{8,WB{{SET OFFSET{10582
{{BRN{6,RLD04{{{ALL SET{10583
*
*      EXBLK
*
{RLD10{MOV{13,EXLEN(XR){8,WA{{LOAD LENGTH{10587
{{MOV{19,*EXFLC{8,WB{{SET OFFSET{10588
{{BRN{6,RLD04{{{JUMP BACK{10589
{{EJC{{{{{10590
*
*      RELDN (CONTINUED)
*
*
*      FFBLK
*
*      THIS BLOCK CONTAINS A PTR TO A DFBLK IN THE STATIC RGN.
*      BECAUSE THERE ARE MULTIPLE FFBLKS POINTING TO THE SAME
*      DFBLK (ONE FOR EACH FIELD NAME), WE ONLY PROCESS THE
*      DFBLK WHEN WE ENCOUNTER THE FFBLK FOR THE FIRST FIELD.
*      THE DFBLK IN TURN CONTAINS A POINTER TO AN SCBLK WITHIN
*      STATIC.
*
{RLD11{BNE{13,FFOFS(XR){19,*PDFLD{6,RLD12{SKIP DFBLK IF NOT FIRST FIELD{10604
{{MOV{7,XR{11,-(XS){{SAVE XR{10605
{{MOV{13,FFDFP(XR){7,XR{{LOAD OLD PTR TO DFBLK{10606
{{ADD{3,RLDST{7,XR{{CURRENT LOCATION OF DFBLK{10607
{{ADD{3,RLDCD{9,(XR){{ADJUST DFBLK TYPE WORD{10608
{{MOV{13,DFLEN(XR){8,WA{{LENGTH OF DFBLK{10609
{{MOV{19,*DFNAM{8,WB{{OFFSET TO DFNAM FIELD{10610
{{ADD{7,XR{8,WA{{POINT PAST LAST RELOC FIELD{10611
{{ADD{7,XR{8,WB{{POINT TO FIRST RELOC FIELD{10612
{{MOV{3,RLDLS{7,XL{{POINT TO LIST OF BOUNDS{10613
{{JSR{6,RELAJ{{{ADJUST POINTERS{10614
{{MOV{13,DFNAM(XR){7,XR{{POINTER TO STATIC SCBLK{10615
{{ADD{3,RLDCD{9,(XR){{ADJUST SCBLK TYPE WORD{10616
{{MOV{10,(XS)+{7,XR{{RESTORE FFBLK POINTER{10617
*
*      FFBLK (CONTINUED)
*
*      MERGE HERE TO SET UP FOR ADJUSTMENT OF PTRS IN FFBLK
*
{RLD12{MOV{19,*FFOFS{8,WA{{SET LENGTH{10623
{{MOV{19,*FFDFP{8,WB{{SET OFFSET{10624
{{BRN{6,RLD04{{{ALL SET{10625
*
*      KVBLK, NMBLK, P0BLK, SEBLK
*
{RLD13{MOV{19,*OFFS2{8,WA{{POINT PAST SECOND FIELD{10629
{{MOV{19,*OFFS1{8,WB{{OFFSET IS ONE (ONLY RELOC FLD IS 2){10630
{{BRN{6,RLD04{{{ALL SET{10631
*
*      P1BLK, P2BLK
*
*      IN P2BLKS, PARM2 CONTAINS EITHER A BIT MASK OR THE
*      NAME OFFSET OF A VARIABLE.  IT NEVER REQUIRES RELOCATION.
*
{RLD14{MOV{19,*PARM2{8,WA{{LENGTH (PARM2 IS NON-RELOCATABLE){10638
{{MOV{19,*PTHEN{8,WB{{SET OFFSET{10639
{{BRN{6,RLD04{{{ALL SET{10640
*
*      PDBLK
*
*      NOTE THAT THE DFBLK POINTED TO BY THIS PDBLK WAS
*      PROCESSED WHEN THE FFBLK WAS ENCOUNTERED.  BECAUSE
*      THE DATA FUNCTION WILL BE CALLED BEFORE ANY RECORDS ARE
*      DEFINED, THE FFBLK IS ENCOUNTERED BEFORE ANY
*      CORRESPONDING PDBLK.
*
{RLD15{MOV{13,PDDFP(XR){7,XL{{LOAD PTR TO DFBLK{10650
{{ADD{3,RLDST{7,XL{{ADJUST FOR STATIC RELOCATION{10651
{{MOV{13,DFPDL(XL){8,WA{{GET PDBLK LENGTH{10652
{{MOV{19,*PDDFP{8,WB{{SET OFFSET{10653
{{BRN{6,RLD04{{{ALL SET{10654
{{EJC{{{{{10655
*
*      RELDN (CONTINUED)
*
*
*      PFBLK
*
{RLD16{ADD{3,RLDST{13,PFVBL(XR){{ADJUST NON-CONTIGUOUS FIELD{10662
{{MOV{13,PFLEN(XR){8,WA{{GET PFBLK LENGTH{10663
{{MOV{19,*PFCOD{8,WB{{OFFSET TO FIRST RELOC{10664
{{BRN{6,RLD04{{{ALL SET{10665
*
*      TBBLK, VCBLK
*
{RLD17{MOV{13,OFFS2(XR){8,WA{{LOAD LENGTH{10669
{{MOV{19,*OFFS3{8,WB{{SET OFFSET{10670
{{BRN{6,RLD04{{{JUMP BACK{10671
*
*      TEBLK
*
{RLD18{MOV{19,*TESI${8,WA{{SET LENGTH{10675
{{MOV{19,*TESUB{8,WB{{AND OFFSET{10676
{{BRN{6,RLD04{{{ALL SET{10677
*
*      TRBLK
*
{RLD19{MOV{19,*TRSI${8,WA{{SET LENGTH{10681
{{MOV{19,*TRVAL{8,WB{{AND OFFSET{10682
{{BRN{6,RLD04{{{ALL SET{10683
*
*      XRBLK
*
{RLD20{MOV{13,XRLEN(XR){8,WA{{LOAD LENGTH{10687
{{MOV{19,*XRPTR{8,WB{{SET OFFSET{10688
{{BRN{6,RLD04{{{JUMP BACK{10689
{{ENP{{{{END PROCEDURE RELDN{10690
{{EJC{{{{{10691
*
*      RELOC -- RELOCATE STORAGE AFTER SAVE FILE RELOAD
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELOC            RELOCATE ALL POINTERS
*      (WA,WB,WC,XR)         DESTROYED
*
*      THE LIST OF BOUNDARIES AND ADJUSTMENTS POINTED TO BY
*      REGISTER XL IS CREATED BY A CALL TO RELCR, WHICH SHOULD
*      BE CONSULTED FOR INFORMATION ON ITS STRUCTURE.
*
{RELOC{PRC{25,E{1,0{{ENTRY POINT{10703
{{MOV{13,RLDYS(XL){7,XR{{OLD START OF DYNAMIC{10704
{{MOV{13,RLDYE(XL){8,WC{{OLD END OF DYNAMIC{10705
{{ADD{13,RLDYA(XL){7,XR{{CREATE NEW START OF DYNAMIC{10706
{{ADD{13,RLDYA(XL){8,WC{{CREATE NEW END OF DYNAMIC{10707
{{JSR{6,RELDN{{{RELOCATE POINTERS IN DYNAMIC{10708
{{JSR{6,RELWS{{{RELOCATE POINTERS IN WORKING SECT{10709
{{JSR{6,RELST{{{RELOCATE POINTERS IN STATIC{10710
{{EXI{{{{RETURN TO CALLER{10711
{{ENP{{{{END PROCEDURE RELOC{10712
{{EJC{{{{{10713
*
*      RELST -- RELOCATE POINTERS IN THE STATIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELST            CALL TO PROCESS BLOCKS IN STATIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      ONLY VRBLKS ON THE HASH CHAIN AND ANY PROFILE BLOCK ARE
*      PROCESSED.  OTHER STATIC BLOCKS (DFBLKS) ARE PROCESSED
*      DURING PROCESSING OF DYNAMIC BLOCKS.
*
*      GLOBAL WORK LOCATIONS WILL BE PROCESSED AT THIS POINT,
*      SO POINTERS THERE CAN BE RELIED UPON.
*
{RELST{PRC{25,E{1,0{{ENTRY POINT{10728
{{MOV{3,PFTBL{7,XR{{PROFILE TABLE{10729
{{BZE{7,XR{6,RLS01{{BRANCH IF NO TABLE ALLOCATED{10730
{{ADD{13,RLCDA(XL){9,(XR){{ADJUST BLOCK TYPE WORD{10731
*
*      HERE AFTER DEALING WITH PROFILER
*
{RLS01{MOV{3,HSHTB{8,WC{{POINT TO START OF HASH TABLE{10735
{{MOV{8,WC{8,WB{{POINT TO FIRST HASH BUCKET{10736
{{MOV{3,HSHTE{8,WA{{POINT BEYOND HASH TABLE{10737
{{JSR{6,RELAJ{{{ADJUST BUCKET POINTERS{10738
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
{RLS02{BEQ{8,WC{3,HSHTE{6,RLS05{DONE IF NONE LEFT{10742
{{MOV{8,WC{7,XR{{ELSE COPY SLOT POINTER{10743
{{ICA{8,WC{{{BUMP SLOT POINTER{10744
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE INTO LOOP{10745
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{RLS03{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{10749
{{BZE{7,XR{6,RLS02{{JUMP FOR NEXT BUCKET IF CHAIN END{10750
{{MOV{19,*VRLEN{8,WA{{OFFSET OF FIRST LOC PAST PTR FIELDS{10751
{{MOV{19,*VRGET{8,WB{{OFFSET OF FIRST LOCATION IN VRBLK{10752
{{BNZ{13,VRLEN(XR){6,RLS04{{JUMP IF NOT SYSTEM VARIABLE{10753
{{MOV{19,*VRSI${8,WA{{OFFSET TO INCLUDE VRSVP FIELD{10754
*
*      MERGE HERE TO PROCESS FIELDS OF VRBLK
*
{RLS04{ADD{7,XR{8,WA{{CREATE END PTR{10758
{{ADD{7,XR{8,WB{{CREATE START PTR{10759
{{JSR{6,RELAJ{{{ADJUST POINTERS IN VRBLK{10760
{{BRN{6,RLS03{{{CHECK FOR ANOTHER VRBLK ON CHAIN{10761
*
*      HERE WHEN ALL VRBLKS PROCESSED
*
{RLS05{EXI{{{{RETURN TO CALLER{10765
{{ENP{{{{END PROCEDURE RELST{10766
{{EJC{{{{{10767
*
*      RELWS -- RELOCATE POINTERS IN THE WORKING SECTION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELWS            CALL TO PROCESS WORKING SECTION
*      (WA,WB,WC,XR)         DESTROYED
*
*      POINTERS BETWEEN A$AAA AND R$YYY ARE EXAMINED AND
*      ADJUSTED IF NECESSARY.  THE POINTER KVRTN IS ALSO
*      ADJUSTED ALTHOUGH IT LIES OUTSIDE THIS RANGE.
*      DNAME IS EXPLICITLY ADJUSTED BECAUSE THE LIMITS
*      ON DYNAMIC REGION IN STACK ARE TO THE AREA ACTIVELY
*      IN USE (BETWEEN DNAMB AND DNAMP), AND DNAME IS OUTSIDE
*      THIS RANGE.
*
{RELWS{PRC{25,E{1,0{{ENTRY POINT{10783
{{MOV{20,=A$AAA{8,WB{{POINT TO START OF ADJUSTABLES{10784
{{MOV{20,=R$YYY{8,WA{{POINT TO END OF ADJUSTABLES{10785
{{JSR{6,RELAJ{{{RELOCATE ADJUSTABLE POINTERS{10786
{{ADD{13,RLDYA(XL){3,DNAME{{ADJUST PTR MISSED BY RELAJ{10787
{{MOV{20,=KVRTN{8,WB{{CASE OF KVRTN{10788
{{MOV{8,WB{8,WA{{HANDLED SPECIALLY{10789
{{ICA{8,WA{{{ONE VALUE TO ADJUST{10790
{{JSR{6,RELAJ{{{ADJUST KVRTN{10791
{{EXI{{{{RETURN TO CALLER{10792
{{ENP{{{{END PROCEDURE RELWS{10793
{{TTL{27,S P I T B O L -- INITIALIZATION{{{{10795
*
*      INITIALISATION
*      THE FOLLOWING SECTION RECEIVES CONTROL FROM THE SYSTEM
*      AT THE START OF A RUN WITH THE REGISTERS SET AS FOLLOWS.
*
*      (WA)                  INITIAL STACK POINTER
*      (XR)                  POINTS TO FIRST WORD OF DATA AREA
*      (XL)                  POINTS TO LAST WORD OF DATA AREA
*
{START{PRC{25,E{1,0{{ENTRY POINT{10805
{{MOV{8,WA{7,XS{{DISCARD RETURN{10806
{{JSR{6,SYSTM{{{INITIALISE TIMER{10807
{{STI{3,TIMSX{{{STORE TIME{10809
{{MOV{7,XR{3,STATB{{START ADDRESS OF STATIC{10810
{{MOV{19,*E$SRS{3,RSMEM{{RESERVE MEMORY{10862
{{MOV{7,XS{3,STBAS{{STORE STACK BASE{10863
{{SSS{3,INISS{{{SAVE S-R STACK PTR{10864
*
*      NOW CONVERT FREE STORE PERCENTAGE TO A SUITABLE FACTOR
*      FOR EASY TESTING IN ALLOC ROUTINE.
*
{{LDI{4,INTVH{{{GET 100{10869
{{DVI{4,ALFSP{{{FORM 100 / ALFSP{10870
{{STI{3,ALFSF{{{STORE THE FACTOR{10871
*
*      NOW CONVERT FREE SEDIMENT PERCENTAGE TO A SUITABLE FACTOR
*      FOR EASY TESTING IN GBCOL ROUTINE.
*
{{LDI{4,INTVH{{{GET 100{10877
{{DVI{4,GBSDP{{{FORM 100 / GBSDP{10878
{{STI{3,GBSED{{{STORE THE FACTOR{10879
*
*      INITIALIZE VALUES FOR REAL CONVERSION ROUTINE
*
{{LCT{8,WB{18,=CFP$S{{LOAD COUNTER FOR SIGNIFICANT DIGITS{10888
{{LDR{4,REAV1{{{LOAD 1.0{10889
*
*      LOOP TO COMPUTE 10**(MAX NUMBER SIGNIFICANT DIGITS)
*
{INI03{MLR{4,REAVT{{{* 10.0{10893
{{BCT{8,WB{6,INI03{{LOOP TILL DONE{10894
{{STR{3,GTSSC{{{STORE 10**(MAX SIG DIGITS){10895
{{LDR{4,REAP5{{{LOAD 0.5{10896
{{DVR{3,GTSSC{{{COMPUTE 0.5*10**(MAX SIG DIGITS){10897
{{STR{3,GTSRN{{{STORE AS ROUNDING BIAS{10898
{{ZER{8,WC{{{SET TO READ PARAMETERS{10901
{{JSR{6,PRPAR{{{READ THEM{10902
{{EJC{{{{{10903
*
*      NOW COMPUTE STARTING ADDRESS FOR DYNAMIC STORE AND IF
*      NECESSARY REQUEST MORE MEMORY.
*
{{SUB{19,*E$SRS{7,XL{{ALLOW FOR RESERVE MEMORY{10908
{{MOV{3,PRLEN{8,WA{{GET PRINT BUFFER LENGTH{10909
{{ADD{18,=CFP$A{8,WA{{ADD NO. OF CHARS IN ALPHABET{10910
{{ADD{18,=NSTMX{8,WA{{ADD CHARS FOR GTSTG BFR{10911
{{CTB{8,WA{1,8{{CONVERT TO BYTES, ALLOWING A MARGIN{10912
{{MOV{3,STATB{7,XR{{POINT TO STATIC BASE{10913
{{ADD{8,WA{7,XR{{INCREMENT FOR ABOVE BUFFERS{10914
{{ADD{19,*E$HNB{7,XR{{INCREMENT FOR HASH TABLE{10915
{{ADD{19,*E$STS{7,XR{{BUMP FOR INITIAL STATIC BLOCK{10916
{{JSR{6,SYSMX{{{GET MXLEN{10917
{{MOV{8,WA{3,KVMXL{{PROVISIONALLY STORE AS MAXLNGTH{10918
{{MOV{8,WA{3,MXLEN{{AND AS MXLEN{10919
{{BGT{7,XR{8,WA{6,INI06{SKIP IF STATIC HI EXCEEDS MXLEN{10920
{{CTB{8,WA{1,1{{ROUND UP AND MAKE BIGGER THAN MXLEN{10921
{{MOV{8,WA{7,XR{{USE IT INSTEAD{10922
*
*      HERE TO STORE VALUES WHICH MARK INITIAL DIVISION
*      OF DATA AREA INTO STATIC AND DYNAMIC
*
{INI06{MOV{7,XR{3,DNAMB{{DYNAMIC BASE ADRS{10927
{{MOV{7,XR{3,DNAMP{{DYNAMIC PTR{10928
{{BNZ{8,WA{6,INI07{{SKIP IF NON-ZERO MXLEN{10929
{{DCA{7,XR{{{POINT A WORD IN FRONT{10930
{{MOV{7,XR{3,KVMXL{{USE AS MAXLNGTH{10931
{{MOV{7,XR{3,MXLEN{{AND AS MXLEN{10932
{{EJC{{{{{10933
*
*      LOOP HERE IF NECESSARY TILL ENOUGH MEMORY OBTAINED
*      SO THAT DNAME IS ABOVE DNAMB
*
{INI07{MOV{7,XL{3,DNAME{{STORE DYNAMIC END ADDRESS{10938
{{BLT{3,DNAMB{7,XL{6,INI09{SKIP IF HIGH ENOUGH{10939
{{JSR{6,SYSMM{{{REQUEST MORE MEMORY{10940
{{WTB{7,XR{{{GET AS BAUS (SGD05){10941
{{ADD{7,XR{7,XL{{BUMP BY AMOUNT OBTAINED{10942
{{BNZ{7,XR{6,INI07{{TRY AGAIN{10943
{{MOV{18,=MXERN{8,WA{{INSUFFICIENT MEMORY FOR MAXLENGTH{10945
{{ZER{8,WB{{{NO COLUMN NUMBER INFO{10946
{{ZER{8,WC{{{NO LINE NUMBER INFO{10947
{{MOV{18,=STGIC{7,XR{{INITIAL COMPILE STAGE{10948
{{MOV{21,=NULLS{7,XL{{NO FILE NAME{10950
{{JSR{6,SYSEA{{{ADVISE OF ERROR{10952
{{PPM{6,INI08{{{CANT USE ERROR LOGIC YET{10953
{{BRN{6,INI08{{{FORCE TERMINATION{10954
*
*      INSERT TEXT FOR ERROR 329 IN ERROR MESSAGE TABLE
*
{{ERB{1,329{26,Requested MAXLNGTH too large{{{10958
{INI08{MOV{21,=ENDMO{7,XR{{POINT TO FAILURE MESSAGE{10960
{{MOV{4,ENDML{8,WA{{MESSAGE LENGTH{10961
{{JSR{6,SYSPR{{{PRINT IT (PRTST NOT YET USABLE){10962
{{PPM{{{{SHOULD NOT FAIL{10963
{{ZER{7,XL{{{NO FCB CHAIN YET{10964
{{MOV{18,=NUM10{8,WB{{SET SPECIAL CODE VALUE{10965
{{JSR{6,SYSEJ{{{PACK UP (STOPR NOT YET USABLE){10966
*
*      INITIALISE STRUCTURES AT START OF STATIC REGION
*
{INI09{MOV{3,STATB{7,XR{{POINT TO STATIC AGAIN{10970
{{JSR{6,INSTA{{{INITIALIZE STATIC{10971
*
*      INITIALIZE NUMBER OF HASH HEADERS
*
{{MOV{18,=E$HNB{8,WA{{GET NUMBER OF HASH HEADERS{10975
{{MTI{8,WA{{{CONVERT TO INTEGER{10976
{{STI{3,HSHNB{{{STORE FOR USE BY GTNVR PROCEDURE{10977
{{LCT{8,WA{8,WA{{COUNTER FOR CLEARING HASH TABLE{10978
{{MOV{7,XR{3,HSHTB{{POINTER TO HASH TABLE{10979
*
*      LOOP TO CLEAR HASH TABLE
*
{INI11{ZER{10,(XR)+{{{BLANK A WORD{10983
{{BCT{8,WA{6,INI11{{LOOP{10984
{{MOV{7,XR{3,HSHTE{{END OF HASH TABLE ADRS IS KEPT{10985
{{MOV{7,XR{3,STATE{{STORE STATIC END ADDRESS{10986
*
*      INIT TABLE TO MAP STATEMENT NUMBERS TO SOURCE FILE NAMES
*
{{MOV{18,=NUM01{8,WC{{TABLE WILL HAVE ONLY ONE BUCKET{10991
{{MOV{21,=NULLS{7,XL{{DEFAULT TABLE VALUE{10992
{{MOV{7,XL{3,R$SFC{{CURRENT SOURCE FILE NAME{10993
{{JSR{6,TMAKE{{{CREATE TABLE{10994
{{MOV{7,XR{3,R$SFN{{SAVE PTR TO TABLE{10995
*
*      INITIALIZE TABLE TO DETECT DUPLICATE INCLUDE FILE NAMES
*
{{MOV{18,=NUM01{8,WC{{TABLE WILL HAVE ONLY ONE BUCKET{11001
{{MOV{21,=NULLS{7,XL{{DEFAULT TABLE VALUE{11002
{{JSR{6,TMAKE{{{CREATE TABLE{11003
{{MOV{7,XR{3,R$INC{{SAVE PTR TO TABLE{11004
*
*      INITIALIZE ARRAY TO HOLD NAMES OF NESTED INCLUDE FILES
*
{{MOV{18,=CCINM{8,WA{{MAXIMUM NESTING LEVEL{11009
{{MOV{21,=NULLS{7,XL{{NULL STRING DEFAULT VALUE{11010
{{JSR{6,VMAKE{{{CREATE ARRAY{11011
{{PPM{{{{{11012
{{MOV{7,XR{3,R$IFA{{SAVE PTR TO ARRAY{11013
*
*      INIT ARRAY TO HOLD LINE NUMBERS OF NESTED INCLUDE FILES
*
{{MOV{18,=CCINM{8,WA{{MAXIMUM NESTING LEVEL{11017
{{MOV{21,=INTON{7,XL{{INTEGER ONE DEFAULT VALUE{11018
{{JSR{6,VMAKE{{{CREATE ARRAY{11019
{{PPM{{{{{11020
{{MOV{7,XR{3,R$IFL{{SAVE PTR TO ARRAY{11021
*
*      INITIALIZE VARIABLE BLOCKS FOR INPUT AND OUTPUT
*
{{MOV{21,=V$INP{7,XL{{POINT TO STRING /INPUT/{11027
{{MOV{18,=TRTIN{8,WB{{TRBLK TYPE FOR INPUT{11028
{{JSR{6,INOUT{{{PERFORM INPUT ASSOCIATION{11029
{{MOV{21,=V$OUP{7,XL{{POINT TO STRING /OUTPUT/{11030
{{MOV{18,=TRTOU{8,WB{{TRBLK TYPE FOR OUTPUT{11031
{{JSR{6,INOUT{{{PERFORM OUTPUT ASSOCIATION{11032
{{MOV{3,INITR{8,WC{{TERMINAL FLAG{11033
{{BZE{8,WC{6,INI13{{SKIP IF NO TERMINAL{11034
{{JSR{6,PRPAR{{{ASSOCIATE TERMINAL{11035
{{EJC{{{{{11036
*
*      CHECK FOR EXPIRY DATE
*
{INI13{JSR{6,SYSDC{{{CALL DATE CHECK{11040
{{MOV{7,XS{3,FLPTR{{IN CASE STACK OVERFLOWS IN COMPILER{11041
*
*      NOW COMPILE SOURCE INPUT CODE
*
{{JSR{6,CMPIL{{{CALL COMPILER{11045
{{MOV{7,XR{3,R$COD{{SET PTR TO FIRST CODE BLOCK{11046
{{MOV{21,=NULLS{3,R$TTL{{FORGET TITLE{11047
{{MOV{21,=NULLS{3,R$STL{{FORGET SUB-TITLE{11048
{{ZER{3,R$CIM{{{FORGET COMPILER INPUT IMAGE{11049
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{11050
{{ZER{3,CNIND{{{IN CASE END OCCURRED WITH INCLUDE{11052
{{ZER{3,LSTID{{{LISTING INCLUDE DEPTH{11053
{{ZER{7,XL{{{CLEAR DUD VALUE{11055
{{ZER{8,WB{{{DONT SHIFT DYNAMIC STORE UP{11056
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{11058
{{JSR{6,GBCOL{{{CLEAR GARBAGE LEFT FROM COMPILE{11059
{{MOV{7,XR{3,DNAMS{{RECORD NEW SEDIMENT SIZE{11060
{{BNZ{3,CPSTS{6,INIX0{{SKIP IF NO LISTING OF COMP STATS{11064
{{JSR{6,PRTPG{{{EJECT PAGE{11065
*
*      PRINT COMPILE STATISTICS
*
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{11069
{{MTI{3,CMERC{{{GET COUNT OF ERRORS AS INTEGER{11070
{{MOV{21,=ENCM3{7,XR{{POINT TO /COMPILE ERRORS/{11071
{{JSR{6,PRTMI{{{PRINT IT{11072
{{MTI{3,GBCNT{{{GARBAGE COLLECTION COUNT{11073
{{SBI{4,INTV1{{{ADJUST FOR UNAVOIDABLE COLLECT{11074
{{MOV{21,=STPM5{7,XR{{POINT TO /STORAGE REGENERATIONS/{11075
{{JSR{6,PRTMI{{{PRINT GBCOL COUNT{11076
{{JSR{6,SYSTM{{{GET TIME{11077
{{SBI{3,TIMSX{{{GET COMPILATION TIME{11078
{{MOV{21,=ENCM4{7,XR{{POINT TO COMPILATION TIME (MSEC)/{11079
{{JSR{6,PRTMI{{{PRINT MESSAGE{11080
{{ADD{18,=NUM05{3,LSTLC{{BUMP LINE COUNT{11081
{{BZE{3,HEADP{6,INIX0{{NO EJECT IF NOTHING PRINTED{11083
{{JSR{6,PRTPG{{{EJECT PRINTER{11084
{{EJC{{{{{11086
*
*      PREPARE NOW TO START EXECUTION
*
*      SET DEFAULT INPUT RECORD LENGTH
*
{INIX0{BGT{3,CSWIN{18,=INILN{6,INIX1{SKIP IF NOT DEFAULT -IN72 USED{11092
{{MOV{18,=INILS{3,CSWIN{{ELSE USE DEFAULT RECORD LENGTH{11093
*
*      RESET TIMER
*
{INIX1{JSR{6,SYSTM{{{GET TIME AGAIN{11097
{{STI{3,TIMSX{{{STORE FOR END RUN PROCESSING{11098
{{ZER{3,GBCNT{{{INITIALISE COLLECT COUNT{11099
{{JSR{6,SYSBX{{{CALL BEFORE STARTING EXECUTION{11100
{{ADD{3,CSWEX{3,NOXEQ{{ADD -NOEXECUTE FLAG{11101
{{BNZ{3,NOXEQ{6,INIX2{{JUMP IF EXECUTION SUPPRESSED{11102
*
*      MERGE WHEN LISTING FILE SET FOR EXECUTION.  ALSO
*      MERGE HERE WHEN RESTARTING A SAVE FILE OR LOAD MODULE.
*
{INIY0{MNZ{3,HEADP{{{MARK HEADERS OUT REGARDLESS{11112
{{ZER{11,-(XS){{{SET FAILURE LOCATION ON STACK{11113
{{MOV{7,XS{3,FLPTR{{SAVE PTR TO FAILURE OFFSET WORD{11114
{{MOV{3,R$COD{7,XR{{LOAD PTR TO ENTRY CODE BLOCK{11115
{{MOV{18,=STGXT{3,STAGE{{SET STAGE FOR EXECUTE TIME{11116
{{MOV{18,=NUM01{3,POLCS{{RESET INTERFACE POLLING INTERVAL{11118
{{MOV{18,=NUM01{3,POLCT{{RESET INTERFACE POLLING INTERVAL{11119
{{MOV{3,CMPSN{3,PFNTE{{COPY STMTS COMPILED COUNT IN CASE{11123
{{MOV{3,KVPFL{3,PFDMP{{START PROFILING IF &PROFILE SET{11124
{{JSR{6,SYSTM{{{TIME YET AGAIN{11125
{{STI{3,PFSTM{{{{11126
{{JSR{6,STGCC{{{COMPUTE STMGO COUNTDOWN COUNTERS{11128
{{BRI{9,(XR){{{START XEQ WITH FIRST STATEMENT{11129
*
*      HERE IF EXECUTION IS SUPPRESSED
*
{INIX2{ZER{8,WA{{{SET ABEND VALUE TO ZERO{11134
{{MOV{18,=NINI9{8,WB{{SET SPECIAL CODE VALUE{11142
{{ZER{7,XL{{{NO FCB CHAIN{11143
{{JSR{6,SYSEJ{{{END OF JOB, EXIT TO SYSTEM{11144
{{ENP{{{{END PROCEDURE START{11145
*
*      HERE FROM OSINT TO RESTART A SAVE FILE OR LOAD MODULE.
*
{RSTRT{PRC{25,E{1,0{{ENTRY POINT{11149
{{MOV{3,STBAS{7,XS{{DISCARD RETURN{11150
{{ZER{7,XL{{{CLEAR XL{11151
{{BRN{6,INIY0{{{RESUME EXECUTION{11152
{{ENP{{{{END PROCEDURE RSTRT{11153
{{TTL{27,S P I T B O L -- SNOBOL4 OPERATOR ROUTINES{{{{11155
*
*      THIS SECTION INCLUDES ALL ROUTINES WHICH CAN BE ACCESSED
*      DIRECTLY FROM THE GENERATED CODE EXCEPT SYSTEM FUNCTIONS.
*
*      ALL ROUTINES IN THIS SECTION START WITH A LABEL OF THE
*      FORM O$XXX WHERE XXX IS THREE LETTERS. THE GENERATED CODE
*      CONTAINS A POINTER TO THE APPROPRIATE ENTRY LABEL.
*
*      SINCE THE GENERAL FORM OF THE GENERATED CODE CONSISTS OF
*      POINTERS TO BLOCKS WHOSE FIRST WORD IS THE ADDRESS OF THE
*      ACTUAL ENTRY POINT LABEL (O$XXX).
*
*      THESE ROUTINES ARE IN ALPHABETICAL ORDER BY THEIR
*      ENTRY LABEL NAMES (I.E. BY THE XXX OF THE O$XXX NAME)
*
*      THESE ROUTINES RECEIVE CONTROL AS FOLLOWS
*
*      (CP)                  POINTER TO NEXT CODE WORD
*      (XS)                  CURRENT STACK POINTER
{{EJC{{{{{11175
*
*      BINARY PLUS (ADDITION)
*
{O$ADD{ENT{{{{ENTRY POINT{11179
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11180
{{ERR{1,001{26,Addition left operand is not numeric{{{11181
{{ERR{1,002{26,Addition right operand is not numeric{{{11182
{{PPM{6,OADD1{{{JUMP IF REAL OPERANDS{11185
*
*      HERE TO ADD TWO INTEGERS
*
{{ADI{13,ICVAL(XL){{{ADD RIGHT OPERAND TO LEFT{11190
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11191
{{ERB{1,003{26,Addition caused integer overflow{{{11192
*
*      HERE TO ADD TWO REALS
*
{OADD1{ADR{13,RCVAL(XL){{{ADD RIGHT OPERAND TO LEFT{11198
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11199
{{ERB{1,261{26,Addition caused real overflow{{{11200
{{EJC{{{{{11202
*
*      UNARY PLUS (AFFIRMATION)
*
{O$AFF{ENT{{{{ENTRY POINT{11206
{{MOV{10,(XS)+{7,XR{{LOAD OPERAND{11207
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{11208
{{ERR{1,004{26,Affirmation operand is not numeric{{{11209
{{MOV{7,XR{11,-(XS){{RESULT IF CONVERTED TO NUMERIC{11210
{{LCW{7,XR{{{GET NEXT CODE WORD{11211
{{BRI{9,(XR){{{EXECUTE IT{11212
{{EJC{{{{{11213
*
*      BINARY BAR (ALTERNATION)
*
{O$ALT{ENT{{{{ENTRY POINT{11217
{{MOV{10,(XS)+{7,XR{{LOAD RIGHT OPERAND{11218
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11219
{{ERR{1,005{26,Alternation right operand is not pattern{{{11220
*
*      MERGE HERE FROM SPECIAL (LEFT ALTERNATION) CASE
*
{OALT1{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATIVE NODE{11224
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{11225
{{MOV{7,XR{7,XL{{SAVE ADDRESS OF ALTERNATIVE NODE{11226
{{MOV{10,(XS)+{7,XR{{LOAD LEFT OPERAND{11227
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11228
{{ERR{1,006{26,Alternation left operand is not pattern{{{11229
{{BEQ{7,XR{22,=P$ALT{6,OALT2{JUMP IF LEFT ARG IS ALTERNATION{11230
{{MOV{7,XR{13,PTHEN(XL){{SET LEFT OPERAND AS SUCCESSOR{11231
{{MOV{7,XL{11,-(XS){{STACK RESULT{11232
{{LCW{7,XR{{{GET NEXT CODE WORD{11233
{{BRI{9,(XR){{{EXECUTE IT{11234
*
*      COME HERE IF LEFT ARGUMENT IS ITSELF AN ALTERNATION
*
*      THE RESULT IS MORE EFFICIENT IF WE MAKE THE REPLACEMENT
*
*      (A / B) / C = A / (B / C)
*
{OALT2{MOV{13,PARM1(XR){13,PTHEN(XL){{BUILD THE (B / C) NODE{11242
{{MOV{13,PTHEN(XR){11,-(XS){{SET A AS NEW LEFT ARG{11243
{{MOV{7,XL{7,XR{{SET (B / C) AS NEW RIGHT ARG{11244
{{BRN{6,OALT1{{{MERGE BACK TO BUILD A / (B / C){11245
{{EJC{{{{{11246
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY NAME)
*
{O$AMN{ENT{{{{ENTRY POINT{11250
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{11251
{{MOV{7,XR{8,WB{{SET FLAG FOR BY NAME{11252
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11253
{{EJC{{{{{11254
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY VALUE)
*
{O$AMV{ENT{{{{ENTRY POINT{11258
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{11259
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{11260
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11261
{{EJC{{{{{11262
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY NAME)
*
{O$AON{ENT{{{{ENTRY POINT{11266
{{MOV{9,(XS){7,XR{{LOAD SUBSCRIPT VALUE{11267
{{MOV{13,NUM01(XS){7,XL{{LOAD ARRAY VALUE{11268
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF ARRAY OPERAND{11269
{{BEQ{8,WA{22,=B$VCT{6,OAON2{JUMP IF VECTOR REFERENCE{11270
{{BEQ{8,WA{22,=B$TBT{6,OAON3{JUMP IF TABLE REFERENCE{11271
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAON1{MOV{18,=NUM01{7,XR{{SET NUMBER OF SUBSCRIPTS TO ONE{11275
{{MOV{7,XR{8,WB{{SET FLAG FOR BY NAME{11276
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11277
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAON2{BNE{9,(XR){22,=B$ICL{6,OAON1{USE LONG ROUTINE IF NOT INTEGER{11281
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{11282
{{MFI{8,WA{6,EXFAL{{COPY AS ADDRESS INT, FAIL IF OVFLO{11283
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{11284
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{11285
{{WTB{8,WA{{{CONVERT TO BYTES{11286
{{MOV{8,WA{9,(XS){{COMPLETE NAME ON STACK{11287
{{BLT{8,WA{13,VCLEN(XL){6,OAON4{EXIT IF SUBSCRIPT NOT TOO LARGE{11288
{{BRN{6,EXFAL{{{ELSE FAIL{11289
*
*      HERE FOR TABLE REFERENCE
*
{OAON3{MNZ{8,WB{{{SET FLAG FOR NAME REFERENCE{11293
{{JSR{6,TFIND{{{LOCATE/CREATE TABLE ELEMENT{11294
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11295
{{MOV{7,XL{13,NUM01(XS){{STORE NAME BASE ON STACK{11296
{{MOV{8,WA{9,(XS){{STORE NAME OFFSET ON STACK{11297
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{OAON4{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11301
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11302
{{EJC{{{{{11303
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY VALUE)
*
{O$AOV{ENT{{{{ENTRY POINT{11307
{{MOV{10,(XS)+{7,XR{{LOAD SUBSCRIPT VALUE{11308
{{MOV{10,(XS)+{7,XL{{LOAD ARRAY VALUE{11309
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF ARRAY OPERAND{11310
{{BEQ{8,WA{22,=B$VCT{6,OAOV2{JUMP IF VECTOR REFERENCE{11311
{{BEQ{8,WA{22,=B$TBT{6,OAOV3{JUMP IF TABLE REFERENCE{11312
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAOV1{MOV{7,XL{11,-(XS){{RESTACK ARRAY VALUE{11316
{{MOV{7,XR{11,-(XS){{RESTACK SUBSCRIPT{11317
{{MOV{18,=NUM01{7,XR{{SET NUMBER OF SUBSCRIPTS TO ONE{11318
{{ZER{8,WB{{{SET FLAG FOR VALUE CALL{11319
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11320
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAOV2{BNE{9,(XR){22,=B$ICL{6,OAOV1{USE LONG ROUTINE IF NOT INTEGER{11324
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{11325
{{MFI{8,WA{6,EXFAL{{MOVE AS ONE WORD INT, FAIL IF OVFLO{11326
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{11327
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{11328
{{WTB{8,WA{{{CONVERT TO BYTES{11329
{{BGE{8,WA{13,VCLEN(XL){6,EXFAL{FAIL IF SUBSCRIPT TOO LARGE{11330
{{JSR{6,ACESS{{{ACCESS VALUE{11331
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11332
{{MOV{7,XR{11,-(XS){{STACK RESULT{11333
{{LCW{7,XR{{{GET NEXT CODE WORD{11334
{{BRI{9,(XR){{{EXECUTE IT{11335
*
*      HERE FOR TABLE REFERENCE BY VALUE
*
{OAOV3{ZER{8,WB{{{SET FLAG FOR VALUE REFERENCE{11339
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{11340
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11341
{{MOV{7,XR{11,-(XS){{STACK RESULT{11342
{{LCW{7,XR{{{GET NEXT CODE WORD{11343
{{BRI{9,(XR){{{EXECUTE IT{11344
{{EJC{{{{{11345
*
*      ASSIGNMENT
*
{O$ASS{ENT{{{{ENTRY POINT{11349
*
*      O$RPL (PATTERN REPLACEMENT) MERGES HERE
*
{OASS0{MOV{10,(XS)+{8,WB{{LOAD VALUE TO BE ASSIGNED{11353
{{MOV{10,(XS)+{8,WA{{LOAD NAME OFFSET{11354
{{MOV{9,(XS){7,XL{{LOAD NAME BASE{11355
{{MOV{8,WB{9,(XS){{STORE ASSIGNED VALUE AS RESULT{11356
{{JSR{6,ASIGN{{{PERFORM ASSIGNMENT{11357
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{11358
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11359
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11360
{{EJC{{{{{11361
*
*      COMPILATION ERROR
*
{O$CER{ENT{{{{ENTRY POINT{11365
{{ERB{1,007{26,Compilation error encountered during execution{{{11366
{{EJC{{{{{11367
*
*      UNARY AT (CURSOR ASSIGNMENT)
*
{O$CAS{ENT{{{{ENTRY POINT{11371
{{MOV{10,(XS)+{8,WC{{LOAD NAME OFFSET (PARM2){11372
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE (PARM1){11373
{{MOV{22,=P$CAS{8,WB{{SET PCODE FOR CURSOR ASSIGNMENT{11374
{{JSR{6,PBILD{{{BUILD NODE{11375
{{MOV{7,XR{11,-(XS){{STACK RESULT{11376
{{LCW{7,XR{{{GET NEXT CODE WORD{11377
{{BRI{9,(XR){{{EXECUTE IT{11378
{{EJC{{{{{11379
*
*      CONCATENATION
*
{O$CNC{ENT{{{{ENTRY POINT{11383
{{MOV{9,(XS){7,XR{{LOAD RIGHT ARGUMENT{11384
{{BEQ{7,XR{21,=NULLS{6,OCNC3{JUMP IF RIGHT ARG IS NULL{11385
{{MOV{12,1(XS){7,XL{{LOAD LEFT ARGUMENT{11386
{{BEQ{7,XL{21,=NULLS{6,OCNC4{JUMP IF LEFT ARGUMENT IS NULL{11387
{{MOV{22,=B$SCL{8,WA{{GET CONSTANT TO TEST FOR STRING{11388
{{BNE{8,WA{9,(XL){6,OCNC2{JUMP IF LEFT ARG NOT A STRING{11389
{{BNE{8,WA{9,(XR){6,OCNC2{JUMP IF RIGHT ARG NOT A STRING{11390
*
*      MERGE HERE TO CONCATENATE TWO STRINGS
*
{OCNC1{MOV{13,SCLEN(XL){8,WA{{LOAD LEFT ARGUMENT LENGTH{11394
{{ADD{13,SCLEN(XR){8,WA{{COMPUTE RESULT LENGTH{11395
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{11396
{{MOV{7,XR{12,1(XS){{STORE RESULT PTR OVER LEFT ARGUMENT{11397
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{11398
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARS IN LEFT ARG{11399
{{PLC{7,XL{{{PREPARE TO LOAD LEFT ARG CHARS{11400
{{MVC{{{{MOVE CHARACTERS OF LEFT ARGUMENT{11401
{{MOV{10,(XS)+{7,XL{{LOAD RIGHT ARG POINTER, POP STACK{11402
{{MOV{13,SCLEN(XL){8,WA{{LOAD NUMBER OF CHARS IN RIGHT ARG{11403
{{PLC{7,XL{{{PREPARE TO LOAD RIGHT ARG CHARS{11404
{{MVC{{{{MOVE CHARACTERS OF RIGHT ARGUMENT{11405
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{11406
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11407
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11408
*
*      COME HERE IF ARGUMENTS ARE NOT BOTH STRINGS
*
{OCNC2{JSR{6,GTSTG{{{CONVERT RIGHT ARG TO STRING{11412
{{PPM{6,OCNC5{{{JUMP IF RIGHT ARG IS NOT STRING{11413
{{MOV{7,XR{7,XL{{SAVE RIGHT ARG PTR{11414
{{JSR{6,GTSTG{{{CONVERT LEFT ARG TO STRING{11415
{{PPM{6,OCNC6{{{JUMP IF LEFT ARG IS NOT A STRING{11416
{{MOV{7,XR{11,-(XS){{STACK LEFT ARGUMENT{11417
{{MOV{7,XL{11,-(XS){{STACK RIGHT ARGUMENT{11418
{{MOV{7,XR{7,XL{{MOVE LEFT ARG TO PROPER REG{11419
{{MOV{9,(XS){7,XR{{MOVE RIGHT ARG TO PROPER REG{11420
{{BRN{6,OCNC1{{{MERGE BACK TO CONCATENATE STRINGS{11421
{{EJC{{{{{11422
*
*      CONCATENATION (CONTINUED)
*
*      COME HERE FOR NULL RIGHT ARGUMENT
*
{OCNC3{ICA{7,XS{{{REMOVE RIGHT ARG FROM STACK{11428
{{LCW{7,XR{{{LEFT ARGUMENT ON STACK{11429
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11430
*
*      HERE FOR NULL LEFT ARGUMENT
*
{OCNC4{ICA{7,XS{{{UNSTACK ONE ARGUMENT{11434
{{MOV{7,XR{9,(XS){{STORE RIGHT ARGUMENT{11435
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11436
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11437
*
*      HERE IF RIGHT ARGUMENT IS NOT A STRING
*
{OCNC5{MOV{7,XR{7,XL{{MOVE RIGHT ARGUMENT PTR{11441
{{MOV{10,(XS)+{7,XR{{LOAD LEFT ARG POINTER{11442
*
*      MERGE HERE WHEN LEFT ARGUMENT IS NOT A STRING
*
{OCNC6{JSR{6,GTPAT{{{CONVERT LEFT ARG TO PATTERN{11446
{{ERR{1,008{26,Concatenation left operand is not a string or pattern{{{11447
{{MOV{7,XR{11,-(XS){{SAVE RESULT ON STACK{11448
{{MOV{7,XL{7,XR{{POINT TO RIGHT OPERAND{11449
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11450
{{ERR{1,009{26,Concatenation right operand is not a string or pattern{{{11451
{{MOV{7,XR{7,XL{{MOVE FOR PCONC{11452
{{MOV{10,(XS)+{7,XR{{RELOAD LEFT OPERAND PTR{11453
{{JSR{6,PCONC{{{CONCATENATE PATTERNS{11454
{{MOV{7,XR{11,-(XS){{STACK RESULT{11455
{{LCW{7,XR{{{GET NEXT CODE WORD{11456
{{BRI{9,(XR){{{EXECUTE IT{11457
{{EJC{{{{{11458
*
*      COMPLEMENTATION
*
{O$COM{ENT{{{{ENTRY POINT{11462
{{MOV{10,(XS)+{7,XR{{LOAD OPERAND{11463
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{11464
*
*      MERGE BACK HERE AFTER CONVERSION
*
{OCOM1{BEQ{8,WA{22,=B$ICL{6,OCOM2{JUMP IF INTEGER{11468
{{BEQ{8,WA{22,=B$RCL{6,OCOM3{JUMP IF REAL{11471
{{JSR{6,GTNUM{{{ELSE CONVERT TO NUMERIC{11473
{{ERR{1,010{26,Negation operand is not numeric{{{11474
{{BRN{6,OCOM1{{{BACK TO CHECK CASES{11475
*
*      HERE TO COMPLEMENT INTEGER
*
{OCOM2{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{11479
{{NGI{{{{NEGATE{11480
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11481
{{ERB{1,011{26,Negation caused integer overflow{{{11482
*
*      HERE TO COMPLEMENT REAL
*
{OCOM3{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{11488
{{NGR{{{{NEGATE{11489
{{BRN{6,EXREA{{{RETURN REAL RESULT{11490
{{EJC{{{{{11492
*
*      BINARY SLASH (DIVISION)
*
{O$DVD{ENT{{{{ENTRY POINT{11496
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11497
{{ERR{1,012{26,Division left operand is not numeric{{{11498
{{ERR{1,013{26,Division right operand is not numeric{{{11499
{{PPM{6,ODVD2{{{JUMP IF REAL OPERANDS{11502
*
*      HERE TO DIVIDE TWO INTEGERS
*
{{DVI{13,ICVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{11507
{{INO{6,EXINT{{{RESULT OK IF NO OVERFLOW{11508
{{ERB{1,014{26,Division caused integer overflow{{{11509
*
*      HERE TO DIVIDE TWO REALS
*
{ODVD2{DVR{13,RCVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{11515
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11516
{{ERB{1,262{26,Division caused real overflow{{{11517
{{EJC{{{{{11519
*
*      EXPONENTIATION
*
{O$EXP{ENT{{{{ENTRY POINT{11523
{{MOV{10,(XS)+{7,XR{{LOAD EXPONENT{11524
{{JSR{6,GTNUM{{{CONVERT TO NUMBER{11525
{{ERR{1,015{26,Exponentiation right operand is not numeric{{{11526
{{MOV{7,XR{7,XL{{MOVE EXPONENT TO XL{11527
{{MOV{10,(XS)+{7,XR{{LOAD BASE{11528
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{11529
{{ERR{1,016{26,Exponentiation left operand is not numeric{{{11530
{{BEQ{9,(XL){22,=B$RCL{6,OEXP7{JUMP IF REAL EXPONENT{11533
{{LDI{13,ICVAL(XL){{{LOAD EXPONENT{11535
{{ILT{6,OEX12{{{JUMP IF NEGATIVE EXPONENT{11536
{{BEQ{8,WA{22,=B$RCL{6,OEXP3{JUMP IF BASE IS REAL{11539
*
*      HERE TO EXPONENTIATE AN INTEGER BASE AND INTEGER EXPONENT
*
{{MFI{8,WA{6,OEXP2{{CONVERT EXPONENT TO 1 WORD INTEGER{11544
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{11545
{{LDI{13,ICVAL(XR){{{LOAD BASE AS INITIAL VALUE{11546
{{BNZ{8,WA{6,OEXP1{{JUMP INTO LOOP IF NON-ZERO EXPONENT{11547
{{IEQ{6,OEXP4{{{ERROR IF 0**0{11548
{{LDI{4,INTV1{{{NONZERO**0{11549
{{BRN{6,EXINT{{{GIVE ONE AS RESULT FOR NONZERO**0{11550
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX13{MLI{13,ICVAL(XR){{{MULTIPLY BY BASE{11554
{{IOV{6,OEXP2{{{JUMP IF OVERFLOW{11555
{OEXP1{BCT{8,WA{6,OEX13{{LOOP IF MORE TO GO{11556
{{BRN{6,EXINT{{{ELSE RETURN INTEGER RESULT{11557
*
*      HERE IF INTEGER OVERFLOW
*
{OEXP2{ERB{1,017{26,Exponentiation caused integer overflow{{{11561
{{EJC{{{{{11562
*
*      EXPONENTIATION (CONTINUED)
*
*      HERE TO EXPONENTIATE A REAL TO AN INTEGER POWER
*
{OEXP3{MFI{8,WA{6,OEXP6{{CONVERT EXPONENT TO ONE WORD{11570
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{11571
{{LDR{13,RCVAL(XR){{{LOAD BASE AS INITIAL VALUE{11572
{{BNZ{8,WA{6,OEXP5{{JUMP INTO LOOP IF NON-ZERO EXPONENT{11573
{{REQ{6,OEXP4{{{ERROR IF 0.0**0{11574
{{LDR{4,REAV1{{{NONZERO**0{11575
{{BRN{6,EXREA{{{RETURN 1.0 IF NONZERO**ZERO{11576
*
*      HERE FOR ERROR OF 0**0 OR 0.0**0
*
{OEXP4{ERB{1,018{26,Exponentiation result is undefined{{{11581
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX14{MLR{13,RCVAL(XR){{{MULTIPLY BY BASE{11587
{{ROV{6,OEXP6{{{JUMP IF OVERFLOW{11588
{OEXP5{BCT{8,WA{6,OEX14{{LOOP TILL COMPUTATION COMPLETE{11589
{{BRN{6,EXREA{{{THEN RETURN REAL RESULT{11590
*
*      HERE IF REAL OVERFLOW
*
{OEXP6{ERB{1,266{26,Exponentiation caused real overflow{{{11594
*
*      HERE WITH REAL EXPONENT IN (XL), NUMERIC BASE IN (XR)
*
{OEXP7{BEQ{9,(XR){22,=B$RCL{6,OEXP8{JUMP IF BASE REAL{11599
{{LDI{13,ICVAL(XR){{{LOAD INTEGER BASE{11600
{{ITR{{{{CONVERT TO REAL{11601
{{JSR{6,RCBLD{{{CREATE REAL IN (XR){11602
*
*      HERE WITH REAL EXPONENT IN (XL)
*      NUMERIC BASE IN (XR) AND RA
*
{OEXP8{ZER{8,WB{{{SET POSITIVE RESULT FLAG{11607
{{LDR{13,RCVAL(XR){{{LOAD BASE TO RA{11608
{{RNE{6,OEXP9{{{JUMP IF BASE NON-ZERO{11609
{{LDR{13,RCVAL(XL){{{BASE IS ZERO.  CHECK EXPONENT{11610
{{REQ{6,OEXP4{{{JUMP IF 0.0 ** 0.0{11611
{{LDR{4,REAV0{{{0.0 TO NON-ZERO EXPONENT YIELDS 0.0{11612
{{BRN{6,EXREA{{{RETURN ZERO RESULT{11613
*
*      HERE WITH NON-ZERO BASE IN (XR) AND RA, EXPONENT IN (XL)
*
*      A NEGATIVE BASE IS ALLOWED IF THE EXPONENT IS INTEGRAL.
*
{OEXP9{RGT{6,OEX10{{{JUMP IF BASE GT 0.0{11619
{{NGR{{{{MAKE BASE POSITIVE{11620
{{JSR{6,RCBLD{{{CREATE POSITIVE BASE IN (XR){11621
{{LDR{13,RCVAL(XL){{{EXAMINE EXPONENT{11622
{{CHP{{{{CHOP TO INTEGRAL VALUE{11623
{{RTI{6,OEXP6{{{CONVERT TO INTEGER, BR IF TOO LARGE{11624
{{SBR{13,RCVAL(XL){{{CHOP(EXPONENT) - EXPONENT{11625
{{RNE{6,OEX11{{{NON-INTEGRAL POWER WITH NEG BASE{11626
{{MFI{8,WB{{{RECORD EVEN/ODD EXPONENT{11627
{{ANB{4,BITS1{8,WB{{ODD EXPONENT YIELDS NEGATIVE RESULT{11628
{{LDR{13,RCVAL(XR){{{RESTORE BASE TO RA{11629
*
*      HERE WITH POSITIVE BASE IN RA AND (XR), EXPONENT IN (XL)
*
{OEX10{LNF{{{{LOG OF BASE{11633
{{ROV{6,OEXP6{{{TOO LARGE{11634
{{MLR{13,RCVAL(XL){{{TIMES EXPONENT{11635
{{ROV{6,OEXP6{{{TOO LARGE{11636
{{ETX{{{{E ** (EXPONENT * LN(BASE)){11637
{{ROV{6,OEXP6{{{TOO LARGE{11638
{{BZE{8,WB{6,EXREA{{IF NO SIGN FIXUP REQUIRED{11639
{{NGR{{{{NEGATIVE RESULT NEEDED{11640
{{BRN{6,EXREA{{{{11641
*
*      HERE FOR NON-INTEGRAL EXPONENT WITH NEGATIVE BASE
*
{OEX11{ERB{1,311{26,Exponentiation of negative base to non-integral power{{{11645
*
*      HERE WITH NEGATIVE INTEGER EXPONENT IN IA
*
{OEX12{MOV{7,XR{11,-(XS){{STACK BASE{11654
{{ITR{{{{CONVERT TO REAL EXPONENT{11655
{{JSR{6,RCBLD{{{REAL NEGATIVE EXPONENT IN (XR){11656
{{MOV{7,XR{7,XL{{PUT EXPONENT IN XL{11657
{{MOV{10,(XS)+{7,XR{{RESTORE BASE VALUE{11658
{{BRN{6,OEXP7{{{PROCESS REAL EXPONENT{11659
{{EJC{{{{{11663
*
*      FAILURE IN EXPRESSION EVALUATION
*
*      THIS ENTRY POINT IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, FAILS.
*      CONTROL IS RETURNED TO AN APPROPRIATE POINT IN EVALX.
*
{O$FEX{ENT{{{{ENTRY POINT{11671
{{BRN{6,EVLX6{{{JUMP TO FAILURE LOC IN EVALX{11672
{{EJC{{{{{11673
*
*      FAILURE DURING EVALUATION OF A COMPLEX OR DIRECT GOTO
*
{O$FIF{ENT{{{{ENTRY POINT{11677
{{ERB{1,020{26,Goto evaluation failure{{{11678
{{EJC{{{{{11679
*
*      FUNCTION CALL (MORE THAN ONE ARGUMENT)
*
{O$FNC{ENT{{{{ENTRY POINT{11683
{{LCW{8,WA{{{LOAD NUMBER OF ARGUMENTS{11684
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{11685
{{MOV{13,VRFNC(XR){7,XL{{LOAD FUNCTION POINTER{11686
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{11687
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{11688
{{EJC{{{{{11689
*
*      FUNCTION NAME ERROR
*
{O$FNE{ENT{{{{ENTRY POINT{11693
{{LCW{8,WA{{{GET NEXT CODE WORD{11694
{{BNE{8,WA{21,=ORNM${6,OFNE1{FAIL IF NOT EVALUATING EXPRESSION{11695
{{BZE{13,NUM02(XS){6,EVLX3{{OK IF EXPR. WAS WANTED BY VALUE{11696
*
*      HERE FOR ERROR
*
{OFNE1{ERB{1,021{26,Function called by name returned a value{{{11700
{{EJC{{{{{11701
*
*      FUNCTION CALL (SINGLE ARGUMENT)
*
{O$FNS{ENT{{{{ENTRY POINT{11705
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{11706
{{MOV{18,=NUM01{8,WA{{SET NUMBER OF ARGUMENTS TO ONE{11707
{{MOV{13,VRFNC(XR){7,XL{{LOAD FUNCTION POINTER{11708
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{11709
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{11710
{{EJC{{{{{11711
*      CALL TO UNDEFINED FUNCTION
*
{O$FUN{ENT{{{{ENTRY POINT{11714
{{ERB{1,022{26,Undefined function called{{{11715
{{EJC{{{{{11716
*
*      EXECUTE COMPLEX GOTO
*
{O$GOC{ENT{{{{ENTRY POINT{11720
{{MOV{13,NUM01(XS){7,XR{{LOAD NAME BASE POINTER{11721
{{BHI{7,XR{3,STATE{6,OGOC1{JUMP IF NOT NATURAL VARIABLE{11722
{{ADD{19,*VRTRA{7,XR{{ELSE POINT TO VRTRA FIELD{11723
{{BRI{9,(XR){{{AND JUMP THROUGH IT{11724
*
*      HERE IF GOTO OPERAND IS NOT NATURAL VARIABLE
*
{OGOC1{ERB{1,023{26,Goto operand is not a natural variable{{{11728
{{EJC{{{{{11729
*
*      EXECUTE DIRECT GOTO
*
{O$GOD{ENT{{{{ENTRY POINT{11733
{{MOV{9,(XS){7,XR{{LOAD OPERAND{11734
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD{11735
{{BEQ{8,WA{22,=B$CDS{6,BCDS0{JUMP IF CODE BLOCK TO CODE ROUTINE{11736
{{BEQ{8,WA{22,=B$CDC{6,BCDC0{JUMP IF CODE BLOCK TO CODE ROUTINE{11737
{{ERB{1,024{26,Goto operand in direct goto is not code{{{11738
{{EJC{{{{{11739
*
*      SET GOTO FAILURE TRAP
*
*      THIS ROUTINE IS EXECUTED AT THE START OF A COMPLEX OR
*      DIRECT FAILURE GOTO TO TRAP A SUBSEQUENT FAIL (SEE EXFAL)
*
{O$GOF{ENT{{{{ENTRY POINT{11746
{{MOV{3,FLPTR{7,XR{{POINT TO FAIL OFFSET ON STACK{11747
{{ICA{9,(XR){{{POINT FAILURE TO O$FIF WORD{11748
{{ICP{{{{POINT TO NEXT CODE WORD{11749
{{LCW{7,XR{{{FETCH NEXT CODE WORD{11750
{{BRI{9,(XR){{{EXECUTE IT{11751
{{EJC{{{{{11752
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOLLAR IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O$IMA{ENT{{{{ENTRY POINT{11760
{{MOV{22,=P$IMC{8,WB{{SET PCODE FOR LAST NODE{11761
{{MOV{10,(XS)+{8,WC{{POP NAME OFFSET (PARM2){11762
{{MOV{10,(XS)+{7,XR{{POP NAME BASE (PARM1){11763
{{JSR{6,PBILD{{{BUILD P$IMC NODE{11764
{{MOV{7,XR{7,XL{{SAVE PTR TO NODE{11765
{{MOV{9,(XS){7,XR{{LOAD LEFT ARGUMENT{11766
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11767
{{ERR{1,025{26,Immediate assignment left operand is not pattern{{{11768
{{MOV{7,XR{9,(XS){{SAVE PTR TO LEFT OPERAND PATTERN{11769
{{MOV{22,=P$IMA{8,WB{{SET PCODE FOR FIRST NODE{11770
{{JSR{6,PBILD{{{BUILD P$IMA NODE{11771
{{MOV{10,(XS)+{13,PTHEN(XR){{SET LEFT OPERAND AS P$IMA SUCCESSOR{11772
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{11773
{{MOV{7,XR{11,-(XS){{STACK RESULT{11774
{{LCW{7,XR{{{GET NEXT CODE WORD{11775
{{BRI{9,(XR){{{EXECUTE IT{11776
{{EJC{{{{{11777
*
*      INDIRECTION (BY NAME)
*
{O$INN{ENT{{{{ENTRY POINT{11781
{{MNZ{8,WB{{{SET FLAG FOR RESULT BY NAME{11782
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{11783
{{EJC{{{{{11784
*
*      INTERROGATION
*
{O$INT{ENT{{{{ENTRY POINT{11788
{{MOV{21,=NULLS{9,(XS){{REPLACE OPERAND WITH NULL{11789
{{LCW{7,XR{{{GET NEXT CODE WORD{11790
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11791
{{EJC{{{{{11792
*
*      INDIRECTION (BY VALUE)
*
{O$INV{ENT{{{{ENTRY POINT{11796
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{11797
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{11798
{{EJC{{{{{11799
*
*      KEYWORD REFERENCE (BY NAME)
*
{O$KWN{ENT{{{{ENTRY POINT{11803
{{JSR{6,KWNAM{{{GET KEYWORD NAME{11804
{{BRN{6,EXNAM{{{EXIT WITH RESULT NAME{11805
{{EJC{{{{{11806
*
*      KEYWORD REFERENCE (BY VALUE)
*
{O$KWV{ENT{{{{ENTRY POINT{11810
{{JSR{6,KWNAM{{{GET KEYWORD NAME{11811
{{MOV{7,XR{3,DNAMP{{DELETE KVBLK{11812
{{JSR{6,ACESS{{{ACCESS VALUE{11813
{{PPM{6,EXNUL{{{DUMMY (UNUSED) FAILURE RETURN{11814
{{MOV{7,XR{11,-(XS){{STACK RESULT{11815
{{LCW{7,XR{{{GET NEXT CODE WORD{11816
{{BRI{9,(XR){{{EXECUTE IT{11817
{{EJC{{{{{11818
*
*      LOAD EXPRESSION BY NAME
*
{O$LEX{ENT{{{{ENTRY POINT{11822
{{MOV{19,*EVSI${8,WA{{SET SIZE OF EVBLK{11823
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EVBLK{11824
{{MOV{22,=B$EVT{9,(XR){{SET TYPE WORD{11825
{{MOV{21,=TRBEV{13,EVVAR(XR){{SET DUMMY TRBLK POINTER{11826
{{LCW{8,WA{{{LOAD EXBLK POINTER{11827
{{MOV{8,WA{13,EVEXP(XR){{SET EXBLK POINTER{11828
{{MOV{7,XR{7,XL{{MOVE NAME BASE TO PROPER REG{11829
{{MOV{19,*EVVAR{8,WA{{SET NAME OFFSET = ZERO{11830
{{BRN{6,EXNAM{{{EXIT WITH NAME IN (XL,WA){11831
{{EJC{{{{{11832
*
*      LOAD PATTERN VALUE
*
{O$LPT{ENT{{{{ENTRY POINT{11836
{{LCW{7,XR{{{LOAD PATTERN POINTER{11837
{{MOV{7,XR{11,-(XS){{STACK RESULT{11838
{{LCW{7,XR{{{GET NEXT CODE WORD{11839
{{BRI{9,(XR){{{EXECUTE IT{11840
{{EJC{{{{{11841
*
*      LOAD VARIABLE NAME
*
{O$LVN{ENT{{{{ENTRY POINT{11845
{{LCW{8,WA{{{LOAD VRBLK POINTER{11846
{{MOV{8,WA{11,-(XS){{STACK VRBLK PTR (NAME BASE){11847
{{MOV{19,*VRVAL{11,-(XS){{STACK NAME OFFSET{11848
{{LCW{7,XR{{{GET NEXT CODE WORD{11849
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11850
{{EJC{{{{{11851
*
*      BINARY ASTERISK (MULTIPLICATION)
*
{O$MLT{ENT{{{{ENTRY POINT{11855
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11856
{{ERR{1,026{26,Multiplication left operand is not numeric{{{11857
{{ERR{1,027{26,Multiplication right operand is not numeric{{{11858
{{PPM{6,OMLT1{{{JUMP IF REAL OPERANDS{11861
*
*      HERE TO MULTIPLY TWO INTEGERS
*
{{MLI{13,ICVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{11866
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11867
{{ERB{1,028{26,Multiplication caused integer overflow{{{11868
*
*      HERE TO MULTIPLY TWO REALS
*
{OMLT1{MLR{13,RCVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{11874
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11875
{{ERB{1,263{26,Multiplication caused real overflow{{{11876
{{EJC{{{{{11878
*
*      NAME REFERENCE
*
{O$NAM{ENT{{{{ENTRY POINT{11882
{{MOV{19,*NMSI${8,WA{{SET LENGTH OF NMBLK{11883
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{11884
{{MOV{22,=B$NML{9,(XR){{SET NAME BLOCK CODE{11885
{{MOV{10,(XS)+{13,NMOFS(XR){{SET NAME OFFSET FROM OPERAND{11886
{{MOV{10,(XS)+{13,NMBAS(XR){{SET NAME BASE FROM OPERAND{11887
{{MOV{7,XR{11,-(XS){{STACK RESULT{11888
{{LCW{7,XR{{{GET NEXT CODE WORD{11889
{{BRI{9,(XR){{{EXECUTE IT{11890
{{EJC{{{{{11891
*
*      NEGATION
*
*      INITIAL ENTRY
*
{O$NTA{ENT{{{{ENTRY POINT{11897
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{11898
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{11899
{{MOV{8,WA{11,-(XS){{STACK NEW FAILURE OFFSET{11900
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{11901
{{LCW{7,XR{{{GET NEXT CODE WORD{11902
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11903
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF OPERAND
*
{O$NTB{ENT{{{{ENTRY POINT{11907
{{MOV{13,NUM02(XS){3,FLPTR{{RESTORE OLD FAILURE POINTER{11908
{{BRN{6,EXFAL{{{AND FAIL{11909
*
*      ENTRY FOR FAILURE DURING OPERAND EVALUATION
*
{O$NTC{ENT{{{{ENTRY POINT{11913
{{ICA{7,XS{{{POP FAILURE OFFSET{11914
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{11915
{{BRN{6,EXNUL{{{EXIT GIVING NULL RESULT{11916
{{EJC{{{{{11917
*
*      USE OF UNDEFINED OPERATOR
*
{O$OUN{ENT{{{{ENTRY POINT{11921
{{ERB{1,029{26,Undefined operator referenced{{{11922
{{EJC{{{{{11923
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOT IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O$PAS{ENT{{{{ENTRY POINT{11931
{{MOV{22,=P$PAC{8,WB{{LOAD PCODE FOR P$PAC NODE{11932
{{MOV{10,(XS)+{8,WC{{LOAD NAME OFFSET (PARM2){11933
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE (PARM1){11934
{{JSR{6,PBILD{{{BUILD P$PAC NODE{11935
{{MOV{7,XR{7,XL{{SAVE PTR TO NODE{11936
{{MOV{9,(XS){7,XR{{LOAD LEFT OPERAND{11937
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11938
{{ERR{1,030{26,Pattern assignment left operand is not pattern{{{11939
{{MOV{7,XR{9,(XS){{SAVE PTR TO LEFT OPERAND PATTERN{11940
{{MOV{22,=P$PAA{8,WB{{SET PCODE FOR P$PAA NODE{11941
{{JSR{6,PBILD{{{BUILD P$PAA NODE{11942
{{MOV{10,(XS)+{13,PTHEN(XR){{SET LEFT OPERAND AS P$PAA SUCCESSOR{11943
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{11944
{{MOV{7,XR{11,-(XS){{STACK RESULT{11945
{{LCW{7,XR{{{GET NEXT CODE WORD{11946
{{BRI{9,(XR){{{EXECUTE IT{11947
{{EJC{{{{{11948
*
*      PATTERN MATCH (BY NAME, FOR REPLACEMENT)
*
{O$PMN{ENT{{{{ENTRY POINT{11952
{{ZER{8,WB{{{SET TYPE CODE FOR MATCH BY NAME{11953
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11954
{{EJC{{{{{11955
*
*      PATTERN MATCH (STATEMENT)
*
*      O$PMS IS USED IN PLACE OF O$PMV WHEN THE PATTERN MATCH
*      OCCURS AT THE OUTER (STATEMENT) LEVEL SINCE IN THIS
*      CASE THE SUBSTRING VALUE NEED NOT BE CONSTRUCTED.
*
{O$PMS{ENT{{{{ENTRY POINT{11963
{{MOV{18,=NUM02{8,WB{{SET FLAG FOR STATEMENT TO MATCH{11964
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11965
{{EJC{{{{{11966
*
*      PATTERN MATCH (BY VALUE)
*
{O$PMV{ENT{{{{ENTRY POINT{11970
{{MOV{18,=NUM01{8,WB{{SET TYPE CODE FOR VALUE MATCH{11971
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11972
{{EJC{{{{{11973
*
*      POP TOP ITEM ON STACK
*
{O$POP{ENT{{{{ENTRY POINT{11977
{{ICA{7,XS{{{POP TOP STACK ENTRY{11978
{{LCW{7,XR{{{GET NEXT CODE WORD{11979
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11980
{{EJC{{{{{11981
*
*      TERMINATE EXECUTION (CODE COMPILED FOR END STATEMENT)
*
{O$STP{ENT{{{{ENTRY POINT{11985
{{BRN{6,LEND0{{{JUMP TO END CIRCUIT{11986
{{EJC{{{{{11987
*
*      RETURN NAME FROM EXPRESSION
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A NAME. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX.
*
{O$RNM{ENT{{{{ENTRY POINT{11994
{{BRN{6,EVLX4{{{RETURN TO EVALX PROCEDURE{11995
{{EJC{{{{{11996
*
*      PATTERN REPLACEMENT
*
*      WHEN THIS ROUTINE GETS CONTROL, THE FOLLOWING STACK
*      ENTRIES HAVE BEEN MADE (SEE END OF MATCH ROUTINE P$NTH)
*
*                            SUBJECT NAME BASE
*                            SUBJECT NAME OFFSET
*                            INITIAL CURSOR VALUE
*                            FINAL CURSOR VALUE
*                            SUBJECT STRING POINTER
*      (XS) ---------------- REPLACEMENT VALUE
*
{O$RPL{ENT{{{{ENTRY POINT{12010
{{JSR{6,GTSTG{{{CONVERT REPLACEMENT VAL TO STRING{12011
{{ERR{1,031{26,Pattern replacement right operand is not a string{{{12012
*
*      GET RESULT LENGTH AND ALLOCATE RESULT SCBLK
*
{{MOV{9,(XS){7,XL{{LOAD SUBJECT STRING POINTER{12016
{{ADD{13,SCLEN(XL){8,WA{{ADD SUBJECT STRING LENGTH{12021
{{ADD{13,NUM02(XS){8,WA{{ADD STARTING CURSOR{12022
{{SUB{13,NUM01(XS){8,WA{{MINUS FINAL CURSOR = TOTAL LENGTH{12023
{{BZE{8,WA{6,ORPL3{{JUMP IF RESULT IS NULL{12024
{{MOV{7,XR{11,-(XS){{RESTACK REPLACEMENT STRING{12025
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{12026
{{MOV{13,NUM03(XS){8,WA{{GET INITIAL CURSOR (PART 1 LEN){12027
{{MOV{7,XR{13,NUM03(XS){{STACK RESULT POINTER{12028
{{PSC{7,XR{{{POINT TO CHARACTERS OF RESULT{12029
*
*      MOVE PART 1 (START OF SUBJECT) TO RESULT
*
{{BZE{8,WA{6,ORPL1{{JUMP IF FIRST PART IS NULL{12033
{{MOV{13,NUM01(XS){7,XL{{ELSE POINT TO SUBJECT STRING{12034
{{PLC{7,XL{{{POINT TO SUBJECT STRING CHARS{12035
{{MVC{{{{MOVE FIRST PART TO RESULT{12036
{{EJC{{{{{12037
*      PATTERN REPLACEMENT (CONTINUED)
*
*      NOW MOVE IN REPLACEMENT VALUE
*
{ORPL1{MOV{10,(XS)+{7,XL{{LOAD REPLACEMENT STRING, POP{12042
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH{12043
{{BZE{8,WA{6,ORPL2{{JUMP IF NULL REPLACEMENT{12044
{{PLC{7,XL{{{ELSE POINT TO CHARS OF REPLACEMENT{12045
{{MVC{{{{MOVE IN CHARS (PART 2){12046
*
*      NOW MOVE IN REMAINDER OF STRING (PART 3)
*
{ORPL2{MOV{10,(XS)+{7,XL{{LOAD SUBJECT STRING POINTER, POP{12050
{{MOV{10,(XS)+{8,WC{{LOAD FINAL CURSOR, POP{12051
{{MOV{13,SCLEN(XL){8,WA{{LOAD SUBJECT STRING LENGTH{12052
{{SUB{8,WC{8,WA{{MINUS FINAL CURSOR = PART 3 LENGTH{12053
{{BZE{8,WA{6,OASS0{{JUMP TO ASSIGN IF PART 3 IS NULL{12054
{{PLC{7,XL{8,WC{{ELSE POINT TO LAST PART OF STRING{12055
{{MVC{{{{MOVE PART 3 TO RESULT{12056
{{BRN{6,OASS0{{{JUMP TO PERFORM ASSIGNMENT{12057
*
*      HERE IF RESULT IS NULL
*
{ORPL3{ADD{19,*NUM02{7,XS{{POP SUBJECT STR PTR, FINAL CURSOR{12061
{{MOV{21,=NULLS{9,(XS){{SET NULL RESULT{12062
{{BRN{6,OASS0{{{JUMP TO ASSIGN NULL VALUE{12063
{{EJC{{{{{12082
*
*      RETURN VALUE FROM EXPRESSION
*
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A VALUE. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX
*
{O$RVL{ENT{{{{ENTRY POINT{12090
{{BRN{6,EVLX3{{{RETURN TO EVALX PROCEDURE{12091
{{EJC{{{{{12092
*
*      SELECTION
*
*      INITIAL ENTRY
*
{O$SLA{ENT{{{{ENTRY POINT{12098
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{12099
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{12100
{{MOV{8,WA{11,-(XS){{STACK NEW FAILURE OFFSET{12101
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{12102
{{LCW{7,XR{{{GET NEXT CODE WORD{12103
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12104
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF ALTERNATIVE
*
{O$SLB{ENT{{{{ENTRY POINT{12108
{{MOV{10,(XS)+{7,XR{{LOAD RESULT{12109
{{ICA{7,XS{{{POP FAIL OFFSET{12110
{{MOV{9,(XS){3,FLPTR{{RESTORE OLD FAILURE POINTER{12111
{{MOV{7,XR{9,(XS){{RESTACK RESULT{12112
{{LCW{8,WA{{{LOAD NEW CODE OFFSET{12113
{{ADD{3,R$COD{8,WA{{POINT TO ABSOLUTE CODE LOCATION{12114
{{LCP{8,WA{{{SET NEW CODE POINTER{12115
{{LCW{7,XR{{{GET NEXT CODE WORD{12116
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12117
*
*      ENTRY AT START OF SUBSEQUENT ALTERNATIVES
*
{O$SLC{ENT{{{{ENTRY POINT{12121
{{LCW{8,WA{{{LOAD NEW FAIL OFFSET{12122
{{MOV{8,WA{9,(XS){{STORE NEW FAIL OFFSET{12123
{{LCW{7,XR{{{GET NEXT CODE WORD{12124
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12125
*
*      ENTRY AT START OF LAST ALTERNATIVE
*
{O$SLD{ENT{{{{ENTRY POINT{12129
{{ICA{7,XS{{{POP FAILURE OFFSET{12130
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{12131
{{LCW{7,XR{{{GET NEXT CODE WORD{12132
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12133
{{EJC{{{{{12134
*
*      BINARY MINUS (SUBTRACTION)
*
{O$SUB{ENT{{{{ENTRY POINT{12138
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{12139
{{ERR{1,032{26,Subtraction left operand is not numeric{{{12140
{{ERR{1,033{26,Subtraction right operand is not numeric{{{12141
{{PPM{6,OSUB1{{{JUMP IF REAL OPERANDS{12144
*
*      HERE TO SUBTRACT TWO INTEGERS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{12149
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{12150
{{ERB{1,034{26,Subtraction caused integer overflow{{{12151
*
*      HERE TO SUBTRACT TWO REALS
*
{OSUB1{SBR{13,RCVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{12157
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{12158
{{ERB{1,264{26,Subtraction caused real overflow{{{12159
{{EJC{{{{{12161
*
*      DUMMY OPERATOR TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{O$TXR{ENT{{{{ENTRY POINT{12165
{{BRN{6,TRXQ1{{{JUMP INTO TRXEQ PROCEDURE{12166
{{EJC{{{{{12167
*
*      UNEXPECTED FAILURE
*
*      NOTE THAT IF A SETEXIT TRAP IS OPERATING THEN
*      TRANSFER TO SYSTEM LABEL CONTINUE
*      WILL RESULT IN LOOPING HERE.  DIFFICULT TO AVOID EXCEPT
*      WITH A CONSIDERABLE OVERHEAD WHICH IS NOT WORTHWHILE OR
*      ELSE BY A TECHNIQUE SUCH AS SETTING KVERL TO ZERO.
*
{O$UNF{ENT{{{{ENTRY POINT{12177
{{ERB{1,035{26,Unexpected failure in -NOFAIL mode{{{12178
{{TTL{27,S P I T B O L -- BLOCK ACTION ROUTINES{{{{12179
*
*      THE FIRST WORD OF EVERY BLOCK IN DYNAMIC STORAGE AND THE
*      VRGET, VRSTO AND VRTRA FIELDS OF A VRBLK CONTAIN A
*      POINTER TO AN ENTRY POINT IN THE PROGRAM. ALL SUCH ENTRY
*      POINTS ARE IN THE FOLLOWING SECTION EXCEPT THOSE FOR
*      PATTERN BLOCKS WHICH ARE IN THE PATTERN MATCHING SEGMENT
*      LATER ON (LABELS OF THE FORM P$XXX), AND DOPE VECTORS
*      (D$XXX) WHICH ARE IN THE DOPE VECTOR SECTION FOLLOWING
*      THE PATTERN ROUTINES (DOPE VECTORS ARE USED FOR CMBLKS).
*
*      THE ENTRY POINTS IN THIS SECTION HAVE LABELS OF THE
*      FORM B$XXY WHERE XX IS THE TWO CHARACTER BLOCK TYPE FOR
*      THE CORRESPONDING BLOCK AND Y IS ANY LETTER.
*
*      IN SOME CASES, THE POINTERS SERVE NO OTHER PURPOSE THAN
*      TO IDENTIFY THE BLOCK TYPE. IN THIS CASE THE ROUTINE
*      IS NEVER EXECUTED AND THUS NO CODE IS ASSEMBLED.
*
*      FOR EACH OF THESE ENTRY POINTS CORRESPONDING TO A BLOCK
*      AN ENTRY POINT IDENTIFICATION IS ASSEMBLED (BL$XX).
*
*      THE EXACT ENTRY CONDITIONS DEPEND ON THE MANNER IN
*      WHICH THE ROUTINE IS ACCESSED AND ARE DOCUMENTED WITH
*      THE INDIVIDUAL ROUTINES AS REQUIRED.
*
*      THE ORDER OF THESE ROUTINES IS ALPHABETICAL WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      THE ROUTINES FOR SEBLK AND EXBLK ENTRIES OCCUR FIRST SO
*      THAT EXPRESSIONS CAN BE QUICKLY IDENTIFIED FROM THE FACT
*      THAT THEIR ROUTINES LIE BEFORE THE SYMBOL B$E$$.
*
*      THESE ARE IMMEDIATELY FOLLOWED BY THE ROUTINE FOR A TRBLK
*      SO THAT THE TEST AGAINST THE SYMBOL B$T$$ CHECKS FOR
*      TRAPPED VALUES OR EXPRESSION VALUES (SEE PROCEDURE EVALP)
*
*      THE PATTERN ROUTINES LIE AFTER THIS SECTION SO THAT
*      PATTERNS ARE IDENTIFIED WITH ROUTINES STARTING AT OR
*      AFTER THE INITIAL INSTRUCTION IN THESE ROUTINES (P$AAA).
*
*      THE SYMBOL B$AAA DEFINES THE FIRST LOCATION FOR BLOCK
*      ROUTINES AND THE SYMBOL P$YYY (AT THE END OF THE PATTERN
*      MATCH ROUTINES SECTION) DEFINES THE LAST SUCH ENTRY POINT
*
{B$AAA{ENT{2,BL$$I{{{ENTRY POINT OF FIRST BLOCK ROUTINE{12224
{{EJC{{{{{12225
*
*      EXBLK
*
*      THE ROUTINE FOR AN EXBLK LOADS THE EXPRESSION ONTO
*      THE STACK AS A VALUE.
*
*      (XR)                  POINTER TO EXBLK
*
{B$EXL{ENT{2,BL$EX{{{ENTRY POINT (EXBLK){12234
{{MOV{7,XR{11,-(XS){{STACK RESULT{12235
{{LCW{7,XR{{{GET NEXT CODE WORD{12236
{{BRI{9,(XR){{{EXECUTE IT{12237
{{EJC{{{{{12238
*
*      SEBLK
*
*      THE ROUTINE FOR SEBLK IS ACCESSED FROM THE GENERATED
*      CODE TO LOAD THE EXPRESSION VALUE ONTO THE STACK.
*
{B$SEL{ENT{2,BL$SE{{{ENTRY POINT (SEBLK){12245
{{MOV{7,XR{11,-(XS){{STACK RESULT{12246
{{LCW{7,XR{{{GET NEXT CODE WORD{12247
{{BRI{9,(XR){{{EXECUTE IT{12248
*
*      DEFINE SYMBOL WHICH MARKS END OF ENTRIES FOR EXPRESSIONS
*
{B$E$${ENT{2,BL$$I{{{ENTRY POINT{12252
{{EJC{{{{{12253
*
*      TRBLK
*
*      THE ROUTINE FOR A TRBLK IS NEVER EXECUTED
*
{B$TRT{ENT{2,BL$TR{{{ENTRY POINT (TRBLK){12259
*
*      DEFINE SYMBOL MARKING END OF TRAP AND EXPRESSION BLOCKS
*
{B$T$${ENT{2,BL$$I{{{END OF TRBLK,SEBLK,EXBLK ENTRIES{12263
{{EJC{{{{{12264
*
*      ARBLK
*
*      THE ROUTINE FOR ARBLK IS NEVER EXECUTED
*
{B$ART{ENT{2,BL$AR{{{ENTRY POINT (ARBLK){12270
{{EJC{{{{{12271
*
*      BCBLK
*
*      THE ROUTINE FOR A BCBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BCBLK
*
{B$BCT{ENT{2,BL$BC{{{ENTRY POINT (BCBLK){12279
{{EJC{{{{{12280
*
*      BFBLK
*
*      THE ROUTINE FOR A BFBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BFBLK
*
{B$BFT{ENT{2,BL$BF{{{ENTRY POINT (BFBLK){12288
{{EJC{{{{{12289
*
*      CCBLK
*
*      THE ROUTINE FOR CCBLK IS NEVER ENTERED
*
{B$CCT{ENT{2,BL$CC{{{ENTRY POINT (CCBLK){12295
{{EJC{{{{{12296
*
*      CDBLK
*
*      THE CDBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE TWO CASES DEPENDING ON THE FORM OF CDFAL.
*
*      ENTRY FOR COMPLEX FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B$CDC{ENT{2,BL$CD{{{ENTRY POINT (CDBLK){12307
{BCDC0{MOV{3,FLPTR{7,XS{{POP GARBAGE OFF STACK{12308
{{MOV{13,CDFAL(XR){9,(XS){{SET FAILURE OFFSET{12309
{{BRN{6,STMGO{{{ENTER STMT{12310
{{EJC{{{{{12311
*
*      CDBLK (CONTINUED)
*
*      ENTRY FOR SIMPLE FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B$CDS{ENT{2,BL$CD{{{ENTRY POINT (CDBLK){12319
{BCDS0{MOV{3,FLPTR{7,XS{{POP GARBAGE OFF STACK{12320
{{MOV{19,*CDFAL{9,(XS){{SET FAILURE OFFSET{12321
{{BRN{6,STMGO{{{ENTER STMT{12322
{{EJC{{{{{12323
*
*      CMBLK
*
*      THE ROUTINE FOR A CMBLK IS NEVER EXECUTED
*
{B$CMT{ENT{2,BL$CM{{{ENTRY POINT (CMBLK){12329
{{EJC{{{{{12330
*
*      CTBLK
*
*      THE ROUTINE FOR A CTBLK IS NEVER EXECUTED
*
{B$CTT{ENT{2,BL$CT{{{ENTRY POINT (CTBLK){12336
{{EJC{{{{{12337
*
*      DFBLK
*
*      THE ROUTINE FOR A DFBLK IS ACCESSED FROM THE O$FNC ENTRY
*      TO CALL A DATATYPE FUNCTION AND BUILD A PDBLK.
*
*      (XL)                  POINTER TO DFBLK
*
{B$DFC{ENT{2,BL$DF{{{ENTRY POINT{12346
{{MOV{13,DFPDL(XL){8,WA{{LOAD LENGTH OF PDBLK{12347
{{JSR{6,ALLOC{{{ALLOCATE PDBLK{12348
{{MOV{22,=B$PDT{9,(XR){{STORE TYPE WORD{12349
{{MOV{7,XL{13,PDDFP(XR){{STORE DFBLK POINTER{12350
{{MOV{7,XR{8,WC{{SAVE POINTER TO PDBLK{12351
{{ADD{8,WA{7,XR{{POINT PAST PDBLK{12352
{{LCT{8,WA{13,FARGS(XL){{SET TO COUNT FIELDS{12353
*
*      LOOP TO ACQUIRE FIELD VALUES FROM STACK
*
{BDFC1{MOV{10,(XS)+{11,-(XR){{MOVE A FIELD VALUE{12357
{{BCT{8,WA{6,BDFC1{{LOOP TILL ALL MOVED{12358
{{MOV{8,WC{7,XR{{RECALL POINTER TO PDBLK{12359
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{12360
{{EJC{{{{{12361
*
*      EFBLK
*
*      THE ROUTINE FOR AN EFBLK IS PASSED CONTROL FORM THE O$FNC
*      ENTRY TO CALL AN EXTERNAL FUNCTION.
*
*      (XL)                  POINTER TO EFBLK
*
{B$EFC{ENT{2,BL$EF{{{ENTRY POINT (EFBLK){12370
{{MOV{13,FARGS(XL){8,WC{{LOAD NUMBER OF ARGUMENTS{12373
{{WTB{8,WC{{{CONVERT TO OFFSET{12374
{{MOV{7,XL{11,-(XS){{SAVE POINTER TO EFBLK{12375
{{MOV{7,XS{7,XT{{COPY POINTER TO ARGUMENTS{12376
*
*      LOOP TO CONVERT ARGUMENTS
*
{BEFC1{ICA{7,XT{{{POINT TO NEXT ENTRY{12380
{{MOV{9,(XS){7,XR{{LOAD POINTER TO EFBLK{12381
{{DCA{8,WC{{{DECREMENT EFTAR OFFSET{12382
{{ADD{8,WC{7,XR{{POINT TO NEXT EFTAR ENTRY{12383
{{MOV{13,EFTAR(XR){7,XR{{LOAD EFTAR ENTRY{12384
{{BSW{7,XR{1,5{{SWITCH ON TYPE{12393
{{IFF{1,0{6,BEFC7{{NO CONVERSION NEEDED{12411
{{IFF{1,1{6,BEFC2{{STRING{12411
{{IFF{1,2{6,BEFC3{{INTEGER{12411
{{IFF{1,3{6,BEFC4{{REAL{12411
{{IFF{1,4{6,BEFF1{{FILE{12411
{{ESW{{{{END OF SWITCH ON TYPE{12411
*
*      HERE TO CONVERT TO FILE
*
{BEFF1{MOV{7,XT{11,-(XS){{SAVE ENTRY POINTER{12416
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12417
{{MOV{9,(XT){11,-(XS){{STACK ARG POINTER{12418
{{JSR{6,IOFCB{{{CONVERT TO FCB{12419
{{ERR{1,298{26,External function argument is not file{{{12420
{{ERR{1,298{26,External function argument is not file{{{12421
{{ERR{1,298{26,External function argument is not file{{{12422
{{MOV{8,WA{7,XR{{POINT TO FCB{12423
{{MOV{10,(XS)+{7,XT{{RELOAD ENTRY POINTER{12424
{{BRN{6,BEFC5{{{JUMP TO MERGE{12425
*
*      HERE TO CONVERT TO STRING
*
{BEFC2{MOV{9,(XT){11,-(XS){{STACK ARG PTR{12430
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{12431
{{ERR{1,039{26,External function argument is not a string{{{12432
{{BRN{6,BEFC6{{{JUMP TO MERGE{12433
{{EJC{{{{{12434
*
*      EFBLK (CONTINUED)
*
*      HERE TO CONVERT AN INTEGER
*
{BEFC3{MOV{9,(XT){7,XR{{LOAD NEXT ARGUMENT{12440
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12441
{{JSR{6,GTINT{{{CONVERT TO INTEGER{12442
{{ERR{1,040{26,External function argument is not integer{{{12443
{{BRN{6,BEFC5{{{MERGE WITH REAL CASE{12446
*
*      HERE TO CONVERT A REAL
*
{BEFC4{MOV{9,(XT){7,XR{{LOAD NEXT ARGUMENT{12450
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12451
{{JSR{6,GTREA{{{CONVERT TO REAL{12452
{{ERR{1,265{26,External function argument is not real{{{12453
*
*      INTEGER CASE MERGES HERE
*
{BEFC5{MOV{3,BEFOF{8,WC{{RESTORE OFFSET{12458
*
*      STRING MERGES HERE
*
{BEFC6{MOV{7,XR{9,(XT){{STORE CONVERTED RESULT{12462
*
*      NO CONVERSION MERGES HERE
*
{BEFC7{BNZ{8,WC{6,BEFC1{{LOOP BACK IF MORE TO GO{12466
*
*      HERE AFTER CONVERTING ALL THE ARGUMENTS
*
{{MOV{10,(XS)+{7,XL{{RESTORE EFBLK POINTER{12470
{{MOV{13,FARGS(XL){8,WA{{GET NUMBER OF ARGS{12471
{{JSR{6,SYSEX{{{CALL ROUTINE TO CALL EXTERNAL FNC{12472
{{PPM{6,EXFAL{{{FAIL IF FAILURE{12473
{{ERR{1,327{26,Calling external function - not found{{{12474
{{ERR{1,326{26,Calling external function - bad argument type{{{12475
{{WTB{8,WA{{{CONVERT NUMBER OF ARGS TO BYTES{12477
{{ADD{8,WA{7,XS{{REMOVE ARGUMENTS FROM STACK{12478
{{EJC{{{{{12480
*
*      EFBLK (CONTINUED)
*
*      RETURN HERE WITH RESULT IN XR
*
*      FIRST DEFEND AGAINST NON-STANDARD NULL STRING RETURNED
*
{{MOV{13,EFRSL(XL){8,WB{{GET RESULT TYPE ID{12488
{{BNZ{8,WB{6,BEFA8{{BRANCH IF NOT UNCONVERTED{12489
{{BNE{9,(XR){22,=B$SCL{6,BEFC8{JUMP IF NOT A STRING{12490
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{12491
*
*      HERE IF CONVERTED RESULT TO CHECK FOR NULL STRING
*
{BEFA8{BNE{8,WB{18,=NUM01{6,BEFC8{JUMP IF NOT A STRING{12495
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{12496
*
*      RETURN IF RESULT IS IN DYNAMIC STORAGE
*
{BEFC8{BLT{7,XR{3,DNAMB{6,BEFC9{JUMP IF NOT IN DYNAMIC STORAGE{12500
{{BLE{7,XR{3,DNAMP{6,EXIXR{RETURN RESULT IF ALREADY DYNAMIC{12501
*
*      HERE WE COPY A RESULT INTO THE DYNAMIC REGION
*
{BEFC9{MOV{9,(XR){8,WA{{GET POSSIBLE TYPE WORD{12505
{{BZE{8,WB{6,BEF11{{JUMP IF UNCONVERTED RESULT{12506
{{MOV{22,=B$SCL{8,WA{{STRING{12507
{{BEQ{8,WB{18,=NUM01{6,BEF10{YES JUMP{12508
{{MOV{22,=B$ICL{8,WA{{INTEGER{12509
{{BEQ{8,WB{18,=NUM02{6,BEF10{YES JUMP{12510
{{MOV{22,=B$RCL{8,WA{{REAL{12513
*
*      STORE TYPE WORD IN RESULT
*
{BEF10{MOV{8,WA{9,(XR){{STORED BEFORE COPYING TO DYNAMIC{12518
*
*      MERGE FOR UNCONVERTED RESULT
*
{BEF11{BEQ{9,(XR){22,=B$SCL{6,BEF12{BRANCH IF STRING RESULT{12522
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{12523
{{MOV{7,XR{7,XL{{COPY ADDRESS OF OLD BLOCK{12524
{{JSR{6,ALLOC{{{ALLOCATE DYNAMIC BLOCK SAME SIZE{12525
{{MOV{7,XR{11,-(XS){{SET POINTER TO NEW BLOCK AS RESULT{12526
{{MVW{{{{COPY OLD BLOCK TO DYNAMIC BLOCK{12527
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{12528
{{LCW{7,XR{{{GET NEXT CODE WORD{12529
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12530
*
*      HERE TO RETURN A STRING RESULT THAT WAS NOT IN DYNAMIC.
*      CANNOT USE THE SIMPLE WORD COPY ABOVE BECAUSE IT WILL NOT
*      GUARANTEE ZERO PADDING IN THE LAST WORD.
*
{BEF12{MOV{7,XR{7,XL{{SAVE SOURCE STRING POINTER{12536
{{MOV{13,SCLEN(XR){8,WA{{FETCH STRING LENGTH{12537
{{BZE{8,WA{6,EXNUL{{RETURN NULL STRING IF LENGTH ZERO{12538
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{12539
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT POINTER{12540
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{12541
{{PLC{7,XL{{{POINT TO CHARS IN SOURCE STRING{12542
{{MOV{8,WC{8,WA{{NUMBER OF CHARACTERS TO COPY{12543
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{12544
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{12545
{{LCW{7,XR{{{GET NEXT CODE WORD{12546
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12547
{{EJC{{{{{12549
*
*      EVBLK
*
*      THE ROUTINE FOR AN EVBLK IS NEVER EXECUTED
*
{B$EVT{ENT{2,BL$EV{{{ENTRY POINT (EVBLK){12555
{{EJC{{{{{12556
*
*      FFBLK
*
*      THE ROUTINE FOR AN FFBLK IS EXECUTED FROM THE O$FNC ENTRY
*      TO CALL A FIELD FUNCTION AND EXTRACT A FIELD VALUE/NAME.
*
*      (XL)                  POINTER TO FFBLK
*
{B$FFC{ENT{2,BL$FF{{{ENTRY POINT (FFBLK){12565
{{MOV{7,XL{7,XR{{COPY FFBLK POINTER{12566
{{LCW{8,WC{{{LOAD NEXT CODE WORD{12567
{{MOV{9,(XS){7,XL{{LOAD PDBLK POINTER{12568
{{BNE{9,(XL){22,=B$PDT{6,BFFC2{JUMP IF NOT PDBLK AT ALL{12569
{{MOV{13,PDDFP(XL){8,WA{{LOAD DFBLK POINTER FROM PDBLK{12570
*
*      LOOP TO FIND CORRECT FFBLK FOR THIS PDBLK
*
{BFFC1{BEQ{8,WA{13,FFDFP(XR){6,BFFC3{JUMP IF THIS IS THE CORRECT FFBLK{12574
{{MOV{13,FFNXT(XR){7,XR{{ELSE LINK TO NEXT FFBLK ON CHAIN{12575
{{BNZ{7,XR{6,BFFC1{{LOOP BACK IF ANOTHER ENTRY TO CHECK{12576
*
*      HERE FOR BAD ARGUMENT
*
{BFFC2{ERB{1,041{26,FIELD function argument is wrong datatype{{{12580
{{EJC{{{{{12581
*
*      FFBLK (CONTINUED)
*
*      HERE AFTER LOCATING CORRECT FFBLK
*
{BFFC3{MOV{13,FFOFS(XR){8,WA{{LOAD FIELD OFFSET{12587
{{BEQ{8,WC{21,=OFNE${6,BFFC5{JUMP IF CALLED BY NAME{12588
{{ADD{8,WA{7,XL{{ELSE POINT TO VALUE FIELD{12589
{{MOV{9,(XL){7,XR{{LOAD VALUE{12590
{{BNE{9,(XR){22,=B$TRT{6,BFFC4{JUMP IF NOT TRAPPED{12591
{{SUB{8,WA{7,XL{{ELSE RESTORE NAME BASE,OFFSET{12592
{{MOV{8,WC{9,(XS){{SAVE NEXT CODE WORD OVER PDBLK PTR{12593
{{JSR{6,ACESS{{{ACCESS VALUE{12594
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{12595
{{MOV{9,(XS){8,WC{{RESTORE NEXT CODE WORD{12596
*
*      HERE AFTER GETTING VALUE IN (XR), XL IS GARBAGE
*
{BFFC4{MOV{7,XR{9,(XS){{STORE VALUE ON STACK (OVER PDBLK){12600
{{MOV{8,WC{7,XR{{COPY NEXT CODE WORD{12601
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{12602
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{12603
*
*      HERE IF CALLED BY NAME
*
{BFFC5{MOV{8,WA{11,-(XS){{STORE NAME OFFSET (BASE IS SET){12607
{{LCW{7,XR{{{GET NEXT CODE WORD{12608
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12609
{{EJC{{{{{12610
*
*      ICBLK
*
*      THE ROUTINE FOR ICBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD AN INTEGER VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO ICBLK
*
{B$ICL{ENT{2,BL$IC{{{ENTRY POINT (ICBLK){12619
{{MOV{7,XR{11,-(XS){{STACK RESULT{12620
{{LCW{7,XR{{{GET NEXT CODE WORD{12621
{{BRI{9,(XR){{{EXECUTE IT{12622
{{EJC{{{{{12623
*
*      KVBLK
*
*      THE ROUTINE FOR A KVBLK IS NEVER EXECUTED.
*
{B$KVT{ENT{2,BL$KV{{{ENTRY POINT (KVBLK){12629
{{EJC{{{{{12630
*
*      NMBLK
*
*      THE ROUTINE FOR A NMBLK IS EXECUTED FROM THE GENERATED
*      CODE FOR THE CASE OF LOADING A NAME ONTO THE STACK
*      WHERE THE NAME IS THAT OF A NATURAL VARIABLE WHICH CAN
*      BE PREEVALUATED AT COMPILE TIME.
*
*      (XR)                  POINTER TO NMBLK
*
{B$NML{ENT{2,BL$NM{{{ENTRY POINT (NMBLK){12641
{{MOV{7,XR{11,-(XS){{STACK RESULT{12642
{{LCW{7,XR{{{GET NEXT CODE WORD{12643
{{BRI{9,(XR){{{EXECUTE IT{12644
{{EJC{{{{{12645
*
*      PDBLK
*
*      THE ROUTINE FOR A PDBLK IS NEVER EXECUTED
*
{B$PDT{ENT{2,BL$PD{{{ENTRY POINT (PDBLK){12651
{{EJC{{{{{12652
*
*      PFBLK
*
*      THE ROUTINE FOR A PFBLK IS EXECUTED FROM THE ENTRY O$FNC
*      TO CALL A PROGRAM DEFINED FUNCTION.
*
*      (XL)                  POINTER TO PFBLK
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE PROGRAM DEFINED FUNCTION.
*
*                            SAVED VALUE OF FIRST ARGUMENT
*                            .
*                            SAVED VALUE OF LAST ARGUMENT
*                            SAVED VALUE OF FIRST LOCAL
*                            .
*                            SAVED VALUE OF LAST LOCAL
*                            SAVED VALUE OF FUNCTION NAME
*                            SAVED CODE BLOCK PTR (R$COD)
*                            SAVED CODE POINTER (-R$COD)
*                            SAVED VALUE OF FLPRT
*                            SAVED VALUE OF FLPTR
*                            POINTER TO PFBLK
*      FLPTR --------------- ZERO (TO BE OVERWRITTEN WITH OFFS)
*
{B$PFC{ENT{2,BL$PF{{{ENTRY POINT (PFBLK){12678
{{MOV{7,XL{3,BPFPF{{SAVE PFBLK PTR (NEED NOT BE RELOC){12679
{{MOV{7,XL{7,XR{{COPY FOR THE MOMENT{12680
{{MOV{13,PFVBL(XR){7,XL{{POINT TO VRBLK FOR FUNCTION{12681
*
*      LOOP TO FIND OLD VALUE OF FUNCTION
*
{BPF01{MOV{7,XL{8,WB{{SAVE POINTER{12685
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{12686
{{BEQ{9,(XL){22,=B$TRT{6,BPF01{LOOP IF TRBLK{12687
*
*      SET VALUE TO NULL AND SAVE OLD FUNCTION VALUE
*
{{MOV{7,XL{3,BPFSV{{SAVE OLD VALUE{12691
{{MOV{8,WB{7,XL{{POINT BACK TO BLOCK WITH VALUE{12692
{{MOV{21,=NULLS{13,VRVAL(XL){{SET VALUE TO NULL{12693
{{MOV{13,FARGS(XR){8,WA{{LOAD NUMBER OF ARGUMENTS{12694
{{ADD{19,*PFARG{7,XR{{POINT TO PFARG ENTRIES{12695
{{BZE{8,WA{6,BPF04{{JUMP IF NO ARGUMENTS{12696
{{MOV{7,XS{7,XT{{PTR TO LAST ARG{12697
{{WTB{8,WA{{{CONVERT NO. OF ARGS TO BYTES OFFSET{12698
{{ADD{8,WA{7,XT{{POINT BEFORE FIRST ARG{12699
{{MOV{7,XT{3,BPFXT{{REMEMBER ARG POINTER{12700
{{EJC{{{{{12701
*
*      PFBLK (CONTINUED)
*
*      LOOP TO SAVE OLD ARGUMENT VALUES AND SET NEW ONES
*
{BPF02{MOV{10,(XR)+{7,XL{{LOAD VRBLK PTR FOR NEXT ARGUMENT{12707
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF03{MOV{7,XL{8,WC{{SAVE POINTER{12711
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE{12712
{{BEQ{9,(XL){22,=B$TRT{6,BPF03{LOOP BACK IF TRBLK{12713
*
*      SAVE OLD VALUE AND GET NEW VALUE
*
{{MOV{7,XL{8,WA{{KEEP OLD VALUE{12717
{{MOV{3,BPFXT{7,XT{{POINT BEFORE NEXT STACKED ARG{12718
{{MOV{11,-(XT){8,WB{{LOAD ARGUMENT (NEW VALUE){12719
{{MOV{8,WA{9,(XT){{SAVE OLD VALUE{12720
{{MOV{7,XT{3,BPFXT{{KEEP ARG PTR FOR NEXT TIME{12721
{{MOV{8,WC{7,XL{{POINT BACK TO BLOCK WITH VALUE{12722
{{MOV{8,WB{13,VRVAL(XL){{SET NEW VALUE{12723
{{BNE{7,XS{3,BPFXT{6,BPF02{LOOP IF NOT ALL DONE{12724
*
*      NOW PROCESS LOCALS
*
{BPF04{MOV{3,BPFPF{7,XL{{RESTORE PFBLK POINTER{12728
{{MOV{13,PFNLO(XL){8,WA{{LOAD NUMBER OF LOCALS{12729
{{BZE{8,WA{6,BPF07{{JUMP IF NO LOCALS{12730
{{MOV{21,=NULLS{8,WB{{GET NULL CONSTANT{12731
{{LCT{8,WA{8,WA{{SET LOCAL COUNTER{12732
*
*      LOOP TO PROCESS LOCALS
*
{BPF05{MOV{10,(XR)+{7,XL{{LOAD VRBLK PTR FOR NEXT LOCAL{12736
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF06{MOV{7,XL{8,WC{{SAVE POINTER{12740
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE{12741
{{BEQ{9,(XL){22,=B$TRT{6,BPF06{LOOP BACK IF TRBLK{12742
*
*      SAVE OLD VALUE AND SET NULL AS NEW VALUE
*
{{MOV{7,XL{11,-(XS){{STACK OLD VALUE{12746
{{MOV{8,WC{7,XL{{POINT BACK TO BLOCK WITH VALUE{12747
{{MOV{8,WB{13,VRVAL(XL){{SET NULL AS NEW VALUE{12748
{{BCT{8,WA{6,BPF05{{LOOP TILL ALL LOCALS PROCESSED{12749
{{EJC{{{{{12750
*
*      PFBLK (CONTINUED)
*
*      HERE AFTER PROCESSING ARGUMENTS AND LOCALS
*
{BPF07{ZER{7,XR{{{ZERO REG XR IN CASE{12759
{{BZE{3,KVPFL{6,BPF7C{{SKIP IF PROFILING IS OFF{12760
{{BEQ{3,KVPFL{18,=NUM02{6,BPF7A{BRANCH ON TYPE OF PROFILE{12761
*
*      HERE IF &PROFILE = 1
*
{{JSR{6,SYSTM{{{GET CURRENT TIME{12765
{{STI{3,PFETM{{{SAVE FOR A SEC{12766
{{SBI{3,PFSTM{{{FIND TIME USED BY CALLER{12767
{{JSR{6,ICBLD{{{BUILD INTO AN ICBLK{12768
{{LDI{3,PFETM{{{RELOAD CURRENT TIME{12769
{{BRN{6,BPF7B{{{MERGE{12770
*
*       HERE IF &PROFILE = 2
*
{BPF7A{LDI{3,PFSTM{{{GET START TIME OF CALLING STMT{12774
{{JSR{6,ICBLD{{{ASSEMBLE AN ICBLK ROUND IT{12775
{{JSR{6,SYSTM{{{GET NOW TIME{12776
*
*      BOTH TYPES OF PROFILE MERGE HERE
*
{BPF7B{STI{3,PFSTM{{{SET START TIME OF 1ST FUNC STMT{12780
{{MNZ{3,PFFNC{{{FLAG FUNCTION ENTRY{12781
*
*      NO PROFILING MERGES HERE
*
{BPF7C{MOV{7,XR{11,-(XS){{STACK ICBLK PTR (OR ZERO){12785
{{MOV{3,R$COD{8,WA{{LOAD OLD CODE BLOCK POINTER{12786
{{SCP{8,WB{{{GET CODE POINTER{12788
{{SUB{8,WA{8,WB{{MAKE CODE POINTER INTO OFFSET{12789
{{MOV{3,BPFPF{7,XL{{RECALL PFBLK POINTER{12790
{{MOV{3,BPFSV{11,-(XS){{STACK OLD VALUE OF FUNCTION NAME{12791
{{MOV{8,WA{11,-(XS){{STACK CODE BLOCK POINTER{12792
{{MOV{8,WB{11,-(XS){{STACK CODE OFFSET{12793
{{MOV{3,FLPRT{11,-(XS){{STACK OLD FLPRT{12794
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{12795
{{MOV{7,XL{11,-(XS){{STACK POINTER TO PFBLK{12796
{{ZER{11,-(XS){{{DUMMY ZERO ENTRY FOR FAIL RETURN{12797
{{CHK{{{{CHECK FOR STACK OVERFLOW{12798
{{MOV{7,XS{3,FLPTR{{SET NEW FAIL RETURN VALUE{12799
{{MOV{7,XS{3,FLPRT{{SET NEW FLPRT{12800
{{MOV{3,KVTRA{8,WA{{LOAD TRACE VALUE{12801
{{ADD{3,KVFTR{8,WA{{ADD FTRACE VALUE{12802
{{BNZ{8,WA{6,BPF09{{JUMP IF TRACING POSSIBLE{12803
{{ICV{3,KVFNC{{{ELSE BUMP FNCLEVEL{12804
*
*      HERE TO ACTUALLY JUMP TO FUNCTION
*
{BPF08{MOV{13,PFCOD(XL){7,XR{{POINT TO VRBLK OF ENTRY LABEL{12808
{{MOV{13,VRLBL(XR){7,XR{{POINT TO TARGET CODE{12809
{{BEQ{7,XR{21,=STNDL{6,BPF17{TEST FOR UNDEFINED LABEL{12810
{{BNE{9,(XR){22,=B$TRT{6,BPF8A{JUMP IF NOT TRAPPED{12811
{{MOV{13,TRLBL(XR){7,XR{{ELSE LOAD PTR TO REAL LABEL CODE{12812
{BPF8A{BRI{9,(XR){{{OFF TO EXECUTE FUNCTION{12813
*
*      HERE IF TRACING IS POSSIBLE
*
{BPF09{MOV{13,PFCTR(XL){7,XR{{LOAD POSSIBLE CALL TRACE TRBLK{12817
{{MOV{13,PFVBL(XL){7,XL{{LOAD VRBLK POINTER FOR FUNCTION{12818
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET FOR VARIABLE{12819
{{BZE{3,KVTRA{6,BPF10{{JUMP IF TRACE MODE IS OFF{12820
{{BZE{7,XR{6,BPF10{{OR IF THERE IS NO CALL TRACE{12821
*
*      HERE IF CALL TRACED
*
{{DCV{3,KVTRA{{{DECREMENT TRACE COUNT{12825
{{BZE{13,TRFNC(XR){6,BPF11{{JUMP IF PRINT TRACE{12826
{{JSR{6,TRXEQ{{{EXECUTE FUNCTION TYPE TRACE{12827
{{EJC{{{{{12828
*
*      PFBLK (CONTINUED)
*
*      HERE TO TEST FOR FTRACE TRACE
*
{BPF10{BZE{3,KVFTR{6,BPF16{{JUMP IF FTRACE IS OFF{12834
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{12835
*
*      HERE FOR PRINT TRACE
*
{BPF11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{12839
{{JSR{6,PRTNM{{{PRINT FUNCTION NAME{12840
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{12841
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{12842
{{MOV{13,NUM01(XS){7,XL{{RECOVER PFBLK POINTER{12843
{{BZE{13,FARGS(XL){6,BPF15{{SKIP IF NO ARGUMENTS{12844
{{ZER{8,WB{{{ELSE SET ARGUMENT COUNTER{12845
{{BRN{6,BPF13{{{JUMP INTO LOOP{12846
*
*      LOOP TO PRINT ARGUMENT VALUES
*
{BPF12{MOV{18,=CH$CM{8,WA{{LOAD COMMA{12850
{{JSR{6,PRTCH{{{PRINT TO SEPARATE FROM LAST ARG{12851
*
*      MERGE HERE FIRST TIME (NO COMMA REQUIRED)
*
{BPF13{MOV{8,WB{9,(XS){{SAVE ARG CTR (OVER FAILOFFS IS OK){12855
{{WTB{8,WB{{{CONVERT TO BYTE OFFSET{12856
{{ADD{8,WB{7,XL{{POINT TO NEXT ARGUMENT POINTER{12857
{{MOV{13,PFARG(XL){7,XR{{LOAD NEXT ARGUMENT VRBLK PTR{12858
{{SUB{8,WB{7,XL{{RESTORE PFBLK POINTER{12859
{{MOV{13,VRVAL(XR){7,XR{{LOAD NEXT VALUE{12860
{{JSR{6,PRTVL{{{PRINT ARGUMENT VALUE{12861
{{EJC{{{{{12862
*
*      HERE AFTER DEALING WITH ONE ARGUMENT
*
{{MOV{9,(XS){8,WB{{RESTORE ARGUMENT COUNTER{12866
{{ICV{8,WB{{{INCREMENT ARGUMENT COUNTER{12867
{{BLT{8,WB{13,FARGS(XL){6,BPF12{LOOP IF MORE TO PRINT{12868
*
*      MERGE HERE IN NO ARGS CASE TO PRINT PAREN
*
{BPF15{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN{12872
{{JSR{6,PRTCH{{{PRINT TO TERMINATE OUTPUT{12873
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{12874
*
*      MERGE HERE TO EXIT WITH TEST FOR FNCLEVEL TRACE
*
{BPF16{ICV{3,KVFNC{{{INCREMENT FNCLEVEL{12878
{{MOV{3,R$FNC{7,XL{{LOAD PTR TO POSSIBLE TRBLK{12879
{{JSR{6,KTREX{{{CALL KEYWORD TRACE ROUTINE{12880
*
*      CALL FUNCTION AFTER TRACE TESTS COMPLETE
*
{{MOV{13,NUM01(XS){7,XL{{RESTORE PFBLK POINTER{12884
{{BRN{6,BPF08{{{JUMP BACK TO EXECUTE FUNCTION{12885
*
*      HERE IF CALLING A FUNCTION WHOSE ENTRY LABEL IS UNDEFINED
*
{BPF17{MOV{13,NUM02(XS){3,FLPTR{{RESET SO EXFAL CAN RETURN TO EVALX{12889
{{ERB{1,286{26,Function call to undefined entry label{{{12890
{{EJC{{{{{12893
*
*      RCBLK
*
*      THE ROUTINE FOR AN RCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A REAL VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO RCBLK
*
{B$RCL{ENT{2,BL$RC{{{ENTRY POINT (RCBLK){12902
{{MOV{7,XR{11,-(XS){{STACK RESULT{12903
{{LCW{7,XR{{{GET NEXT CODE WORD{12904
{{BRI{9,(XR){{{EXECUTE IT{12905
{{EJC{{{{{12907
*
*      SCBLK
*
*      THE ROUTINE FOR AN SCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A STRING VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO SCBLK
*
{B$SCL{ENT{2,BL$SC{{{ENTRY POINT (SCBLK){12916
{{MOV{7,XR{11,-(XS){{STACK RESULT{12917
{{LCW{7,XR{{{GET NEXT CODE WORD{12918
{{BRI{9,(XR){{{EXECUTE IT{12919
{{EJC{{{{{12920
*
*      TBBLK
*
*      THE ROUTINE FOR A TBBLK IS NEVER EXECUTED
*
{B$TBT{ENT{2,BL$TB{{{ENTRY POINT (TBBLK){12926
{{EJC{{{{{12927
*
*      TEBLK
*
*      THE ROUTINE FOR A TEBLK IS NEVER EXECUTED
*
{B$TET{ENT{2,BL$TE{{{ENTRY POINT (TEBLK){12933
{{EJC{{{{{12934
*
*      VCBLK
*
*      THE ROUTINE FOR A VCBLK IS NEVER EXECUTED
*
{B$VCT{ENT{2,BL$VC{{{ENTRY POINT (VCBLK){12940
{{EJC{{{{{12941
*
*      VRBLK
*
*      THE VRBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE SIX ENTRIES FOR VRBLK COVERING VARIOUS CASES
*
{B$VR${ENT{2,BL$$I{{{MARK START OF VRBLK ENTRY POINTS{12948
*
*      ENTRY FOR VRGET (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*      THIS ENTRY POINT IS USED IF AN ACCESS TRACE OR INPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRGET FIELD OF VRBLK
*
{B$VRA{ENT{2,BL$$I{{{ENTRY POINT{12957
{{MOV{7,XR{7,XL{{COPY NAME BASE (VRGET = 0){12958
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{12959
{{JSR{6,ACESS{{{ACCESS VALUE{12960
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{12961
{{MOV{7,XR{11,-(XS){{STACK RESULT{12962
{{LCW{7,XR{{{GET NEXT CODE WORD{12963
{{BRI{9,(XR){{{EXECUTE IT{12964
{{EJC{{{{{12965
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (ERROR CASE. THIS ROUTINE IS CALLED FROM
*      THE EXECUTED CODE FOR AN ATTEMPT TO MODIFY THE VALUE
*      OF A PROTECTED (PATTERN VALUED) NATURAL VARIABLE.
*
{B$VRE{ENT{{{{ENTRY POINT{12973
{{ERB{1,042{26,Attempt to change value of protected variable{{{12974
{{EJC{{{{{12975
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRTRA (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE EXECUTED CODE TO TRANSFER TO A LABEL.
*
*      (XR)                  POINTER TO VRTRA FIELD OF VRBLK
*
{B$VRG{ENT{{{{ENTRY POINT{12984
{{MOV{13,VRLBO(XR){7,XR{{LOAD CODE POINTER{12985
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{12986
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{12987
{{EJC{{{{{12988
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRGET (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTS TO VRGET FIELD OF VRBLK
*
{B$VRL{ENT{{{{ENTRY POINT{12997
{{MOV{13,VRVAL(XR){11,-(XS){{LOAD VALUE ONTO STACK (VRGET = 0){12998
{{LCW{7,XR{{{GET NEXT CODE WORD{12999
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13000
{{EJC{{{{{13001
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B$VRS{ENT{{{{ENTRY POINT{13010
{{MOV{9,(XS){13,VRVLO(XR){{STORE VALUE, LEAVE ON STACK{13011
{{LCW{7,XR{{{GET NEXT CODE WORD{13012
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13013
{{EJC{{{{{13014
*
*      VRBLK (CONTINUED)
*
*      VRTRA (TRAPPED CASE). THIS ROUTINE IS CALLED FROM THE
*      GENERATED CODE TO TRANSFER TO A LABEL WHEN A LABEL
*      TRACE IS CURRENTLY ACTIVE.
*
{B$VRT{ENT{{{{ENTRY POINT{13022
{{SUB{19,*VRTRA{7,XR{{POINT BACK TO START OF VRBLK{13023
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{13024
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{13025
{{MOV{13,VRLBL(XL){7,XR{{LOAD POINTER TO TRBLK{13026
{{BZE{3,KVTRA{6,BVRT2{{JUMP IF TRACE IS OFF{13027
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{13028
{{BZE{13,TRFNC(XR){6,BVRT1{{JUMP IF PRINT TRACE CASE{13029
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{13030
{{BRN{6,BVRT2{{{MERGE TO JUMP TO LABEL{13031
*
*      HERE FOR PRINT TRACE -- PRINT COLON ( LABEL NAME )
*
{BVRT1{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{13035
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER{13036
{{MOV{18,=CH$CL{8,WA{{COLON{13037
{{JSR{6,PRTCH{{{PRINT IT{13038
{{MOV{18,=CH$PP{8,WA{{LEFT PAREN{13039
{{JSR{6,PRTCH{{{PRINT IT{13040
{{JSR{6,PRTVN{{{PRINT LABEL NAME{13041
{{MOV{18,=CH$RP{8,WA{{RIGHT PAREN{13042
{{JSR{6,PRTCH{{{PRINT IT{13043
{{JSR{6,PRTNL{{{TERMINATE LINE{13044
{{MOV{13,VRLBL(XL){7,XR{{POINT BACK TO TRBLK{13045
*
*      MERGE HERE TO JUMP TO LABEL
*
{BVRT2{MOV{13,TRLBL(XR){7,XR{{LOAD POINTER TO ACTUAL CODE{13049
{{BRI{9,(XR){{{EXECUTE STATEMENT AT LABEL{13050
{{EJC{{{{{13051
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*      THIS ENTRY IS USED WHEN A VALUE TRACE OR OUTPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B$VRV{ENT{{{{ENTRY POINT{13062
{{MOV{9,(XS){8,WB{{LOAD VALUE (LEAVE COPY ON STACK){13063
{{SUB{19,*VRSTO{7,XR{{POINT TO VRBLK{13064
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{13065
{{MOV{19,*VRVAL{8,WA{{SET OFFSET{13066
{{JSR{6,ASIGN{{{CALL ASSIGNMENT ROUTINE{13067
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{13068
{{LCW{7,XR{{{ELSE GET NEXT CODE WORD{13069
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13070
{{EJC{{{{{13071
*
*      XNBLK
*
*      THE ROUTINE FOR AN XNBLK IS NEVER EXECUTED
*
{B$XNT{ENT{2,BL$XN{{{ENTRY POINT (XNBLK){13077
{{EJC{{{{{13078
*
*      XRBLK
*
*      THE ROUTINE FOR AN XRBLK IS NEVER EXECUTED
*
{B$XRT{ENT{2,BL$XR{{{ENTRY POINT (XRBLK){13084
*
*      MARK ENTRY ADDRESS PAST LAST BLOCK ACTION ROUTINE
*
{B$YYY{ENT{2,BL$$I{{{LAST BLOCK ROUTINE ENTRY POINT{13088
{{TTL{27,S P I T B O L -- PATTERN MATCHING ROUTINES{{{{13089
*
*      THE FOLLOWING SECTION CONSISTS OF THE PATTERN MATCHING
*      ROUTINES. ALL PATTERN NODES CONTAIN A POINTER (PCODE)
*      TO ONE OF THE ROUTINES IN THIS SECTION (P$XXX).
*
*      NOTE THAT THIS SECTION FOLLOWS THE B$XXX ROUTINES TO
*      ENABLE A FAST TEST FOR THE PATTERN DATATYPE.
*
{P$AAA{ENT{2,BL$$I{{{ENTRY TO MARK FIRST PATTERN{13098
*
*
*      THE ENTRY CONDITIONS TO THE MATCH ROUTINE ARE AS FOLLOWS
*      (SEE O$PMN, O$PMV, O$PMS AND PROCEDURE MATCH).
*
*      STACK CONTENTS.
*
*                            NAME BASE (O$PMN ONLY)
*                            NAME OFFSET (O$PMN ONLY)
*                            TYPE (0-O$PMN, 1-O$PMV, 2-O$PMS)
*      PMHBS --------------- INITIAL CURSOR (ZERO)
*                            INITIAL NODE POINTER
*      XS ------------------ =NDABO (ANCHORED), =NDUNA (UNANCH)
*
*      REGISTER VALUES.
*
*           (XS)             SET AS SHOWN IN STACK DIAGRAM
*           (XR)             POINTER TO INITIAL PATTERN NODE
*           (WB)             INITIAL CURSOR (ZERO)
*
*      GLOBAL PATTERN VALUES
*
*           R$PMS            POINTER TO SUBJECT STRING SCBLK
*           PMSSL            LENGTH OF SUBJECT STRING IN CHARS
*           PMDFL            DOT FLAG, INITIALLY ZERO
*           PMHBS            SET AS SHOWN IN STACK DIAGRAM
*
*      CONTROL IS PASSED BY BRANCHING THROUGH THE PCODE
*      FIELD OF THE INITIAL PATTERN NODE (BRI (XR)).
{{EJC{{{{{13128
*
*      DESCRIPTION OF ALGORITHM
*
*      A PATTERN STRUCTURE IS REPRESENTED AS A LINKED GRAPH
*      OF NODES WITH THE FOLLOWING STRUCTURE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
*      PCODE IS A POINTER TO THE ROUTINE WHICH WILL PERFORM
*      THE MATCH OF THIS PARTICULAR NODE TYPE.
*
*      PTHEN IS A POINTER TO THE SUCCESSOR NODE. I.E. THE NODE
*      TO BE MATCHED IF THE ATTEMPT TO MATCH THIS NODE SUCCEEDS.
*      IF THIS IS THE LAST NODE OF THE PATTERN PTHEN POINTS
*      TO THE DUMMY NODE NDNTH WHICH INITIATES PATTERN EXIT.
*
*      PARM1, PARM2 ARE PARAMETERS WHOSE USE VARIES WITH THE
*      PARTICULAR NODE. THEY ARE ONLY PRESENT IF REQUIRED.
*
*      ALTERNATIVES ARE HANDLED WITH THE SPECIAL ALTERNATIVE
*      NODE WHOSE PARAMETER POINTS TO THE NODE TO BE MATCHED
*      IF THERE IS A FAILURE ON THE SUCCESSOR PATH.
*
*      THE FOLLOWING EXAMPLE ILLUSTRATES THE MANNER IN WHICH
*      THE STRUCTURE IS BUILT UP. THE PATTERN IS
*
*      (A / B / C) (D / E)   WHERE / IS ALTERNATION
*
*      IN THE DIAGRAM, THE NODE MARKED + REPRESENTS AN
*      ALTERNATIVE NODE AND THE DOTTED LINE FROM A + NODE
*      REPRESENTS THE PARAMETER POINTER TO THE ALTERNATIVE.
*
*      +---+     +---+     +---+     +---+
*      I + I-----I A I-----I + I-----I D I-----
*      +---+     +---+  I  +---+     +---+
*        .              I    .
*        .              I    .
*      +---+     +---+  I  +---+
*      I + I-----I B I--I  I E I-----
*      +---+     +---+  I  +---+
*        .              I
*        .              I
*      +---+            I
*      I C I------------I
*      +---+
{{EJC{{{{{13182
*
*      DURING THE MATCH, THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  POINTS TO THE CURRENT NODE
*      (XL)                  SCRATCH
*      (XS)                  MAIN STACK POINTER
*      (WB)                  CURSOR (NUMBER OF CHARS MATCHED)
*      (WA,WC)               SCRATCH
*
*      TO KEEP TRACK OF ALTERNATIVES, THE MAIN STACK IS USED AS
*      A HISTORY STACK AND CONTAINS TWO WORD ENTRIES.
*
*      WORD 1                SAVED CURSOR VALUE
*      WORD 2                NODE TO MATCH ON FAILURE
*
*      WHEN A FAILURE OCCURS, THE MOST RECENT ENTRY ON THIS
*      STACK IS POPPED OFF TO RESTORE THE CURSOR AND POINT
*      TO THE NODE TO BE MATCHED AS AN ALTERNATIVE. THE ENTRY
*      AT THE BOTTOM OF THE STACK POINTS TO THE FOLLOWING
*      SPECIAL NODES DEPENDING ON THE SCAN MODE.
*
*      ANCHORED MODE         THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDABO WHICH CAUSES AN
*                            ABORT. THE CURSOR VALUE STORED
*                            WITH THIS ENTRY IS ALWAYS ZERO.
*
*      UNANCHORED MODE       THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDUNA WHICH MOVES THE
*                            ANCHOR POINT AND RESTARTS THE MATCH
*                            THE CURSOR SAVED WITH THIS ENTRY
*                            IS THE NUMBER OF CHARACTERS WHICH
*                            LIE BEFORE THE INITIAL ANCHOR POINT
*                            (I.E. THE NUMBER OF ANCHOR MOVES).
*                            THIS ENTRY IS THREE WORDS LONG AND
*                            ALSO CONTAINS THE INITIAL PATTERN.
*
*      ENTRIES ARE MADE ON THIS HISTORY STACK BY ALTERNATIVE
*      NODES AND BY SOME SPECIAL COMPOUND PATTERNS AS DESCRIBED
*      LATER ON. THE FOLLOWING GLOBAL LOCATIONS ARE USED DURING
*      PATTERN MATCHING.
*
*      R$PMS                 POINTER TO SUBJECT STRING
*      PMSSL                 LENGTH OF SUBJECT STRING
*      PMDFL                 FLAG SET NON-ZERO FOR DOT PATTERNS
*      PMHBS                 BASE PTR FOR CURRENT HISTORY STACK
*
*      THE FOLLOWING EXIT POINTS ARE AVAILABLE TO MATCH ROUTINES
*
*      SUCCP                 SUCCESS IN MATCHING CURRENT NODE
*      FAILP                 FAILURE IN MATCHING CURRENT NODE
{{EJC{{{{{13233
*
*      COMPOUND PATTERNS
*
*      SOME PATTERNS HAVE IMPLICIT ALTERNATIVES AND THEIR
*      REPRESENTATION IN THE PATTERN STRUCTURE CONSISTS OF A
*      LINKED SET OF NODES AS INDICATED BY THESE DIAGRAMS.
*
*      AS BEFORE, THE + REPRESENTS AN ALTERNATIVE NODE AND
*      THE DOTTED LINE FROM A + NODE IS THE PARAMETER POINTER
*      TO THE ALTERNATIVE PATTERN.
*
*      ARB
*      ---
*
*           +---+            THIS NODE (P$ARB) MATCHES NULL
*           I B I-----       AND STACKS CURSOR, SUCCESSOR PTR,
*           +---+            CURSOR (COPY) AND A PTR TO NDARC.
*
*
*
*
*      BAL
*      ---
*
*           +---+            THE P$BAL NODE SCANS A BALANCED
*           I B I-----       STRING AND THEN STACKS A POINTER
*           +---+            TO ITSELF ON THE HISTORY STACK.
{{EJC{{{{{13261
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*
*      ARBNO
*      -----
*
*           +---+            THIS ALTERNATIVE NODE MATCHES NULL
*      +----I + I-----       THE FIRST TIME AND STACKS A POINTER
*      I    +---+            TO THE ARGUMENT PATTERN X.
*      I      .
*      I      .
*      I    +---+            NODE (P$ABA) TO STACK CURSOR
*      I    I A I            AND HISTORY STACK BASE PTR.
*      I    +---+
*      I      I
*      I      I
*      I    +---+            THIS IS THE ARGUMENT PATTERN. AS
*      I    I X I            INDICATED, THE SUCCESSOR OF THE
*      I    +---+            PATTERN IS THE P$ABC NODE
*      I      I
*      I      I
*      I    +---+            THIS NODE (P$ABC) POPS PMHBS,
*      +----I C I            STACKS OLD PMHBS AND PTR TO NDABD
*           +---+            (UNLESS OPTIMIZATION HAS OCCURRED)
*
*      STRUCTURE AND EXECUTION OF THIS PATTERN RESEMBLE THOSE OF
*      RECURSIVE PATTERN MATCHING AND IMMEDIATE ASSIGNMENT.
*      THE ALTERNATIVE NODE AT THE HEAD OF THE STRUCTURE MATCHES
*      NULL INITIALLY BUT ON SUBSEQUENT FAILURE ENSURES ATTEMPT
*      TO MATCH THE ARGUMENT.  BEFORE THE ARGUMENT IS MATCHED
*      P$ABA STACKS THE CURSOR, PMHBS AND A PTR TO P$ABB.  IF
*      THE ARGUMENT CANT BE MATCHED , P$ABB REMOVES THIS SPECIAL
*      STACK ENTRY AND FAILS.
*      IF ARGUMENT IS MATCHED , P$ABC RESTORES THE OUTER PMHBS
*      VALUE (SAVED BY P$ABA) .  THEN IF THE ARGUMENT HAS LEFT
*      ALTERNATIVES ON STACK IT STACKS THE INNER VALUE OF PMHBS
*      AND A PTR TO NDABD. IF ARGUMENT LEFT NOTHING ON THE STACK
*      IT OPTIMISES BY REMOVING ITEMS STACKED BY P$ABA.  FINALLY
*      A CHECK IS MADE THAT ARGUMENT MATCHED MORE THAN THE NULL
*      STRING (CHECK IS INTENDED TO PREVENT USELESS LOOPING).
*      IF SO THE SUCCESSOR IS AGAIN THE ALTERNATIVE NODE AT THE
*      HEAD OF THE STRUCTURE , ENSURING A POSSIBLE EXTRA ATTEMPT
*      TO MATCH THE ARG IF NECESSARY.  IF NOT , THE SUCCESSOR TO
*      ALTERNATIVE IS TAKEN SO AS TO TERMINATE THE LOOP.  P$ABD
*      RESTORES INNER PMHBS PTR AND FAILS , THUS TRYING TO MATCH
*      ALTERNATIVES LEFT BY THE ARBNO ARGUMENT.
{{EJC{{{{{13309
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*      BREAKX
*      ------
*
*           +---+            THIS NODE IS A BREAK NODE FOR
*      +----I B I            THE ARGUMENT TO BREAKX, IDENTICAL
*      I    +---+            TO AN ORDINARY BREAK NODE.
*      I      I
*      I      I
*      I    +---+            THIS ALTERNATIVE NODE STACKS A
*      I    I + I-----       POINTER TO THE BREAKX NODE TO
*      I    +---+            ALLOW FOR SUBSEQUENT FAILURE
*      I      .
*      I      .
*      I    +---+            THIS IS THE BREAKX NODE ITSELF. IT
*      +----I X I            MATCHES ONE CHARACTER AND THEN
*           +---+            PROCEEDS BACK TO THE BREAK NODE.
*
*
*
*
*      FENCE
*      -----
*
*           +---+            THE FENCE NODE MATCHES NULL AND
*           I F I-----       STACKS A POINTER TO NODE NDABO TO
*           +---+            ABORT ON A SUBSEQUENT REMATCH
*
*
*
*
*      SUCCEED
*      -------
*
*           +---+            THE NODE FOR SUCCEED MATCHES NULL
*           I S I-----       AND STACKS A POINTER TO ITSELF
*           +---+            TO REPEAT THE MATCH ON A FAILURE.
{{EJC{{{{{13349
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*      -------------------------------
*
*           +---+            THIS NODE (P$PAA) SAVES THE CURRENT
*           I A I            CURSOR AND A POINTER TO THE
*           +---+            SPECIAL NODE NDPAB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            PATTERN ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P$PAC) SAVES THE CURSOR,
*           I C I-----       A PTR TO ITSELF, THE CURSOR (COPY)
*           +---+            AND A PTR TO NDPAD ON THE STACK.
*
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAB (P$PAB)
*      IS SIMPLY TO UNSTACK ITSELF AND FAIL BACK ONTO THE STACK.
*
*      THE MATCH ROUTINE FOR P$PAC ALSO SETS THE GLOBAL PATTERN
*      FLAG PMDFL NON-ZERO TO INDICATE THAT PATTERN ASSIGNMENTS
*      MAY HAVE OCCURED IN THE PATTERN MATCH
*
*      IF PMDFL IS SET AT THE END OF THE MATCH (SEE P$NTH), THE
*      HISTORY STACK IS SCANNED FOR MATCHING NDPAB-NDPAD PAIRS
*      AND THE CORRESPONDING PATTERN ASSIGNMENTS ARE EXECUTED.
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAD (P$PAD)
*      IS SIMPLY TO REMOVE ITS ENTRY FROM THE STACK AND FAIL.
*      THIS INCLUDES REMOVING THE SPECIAL NODE POINTER STORED
*      IN ADDITION TO THE STANDARD TWO ENTRIES ON THE STACK.
{{EJC{{{{{13386
*
*      COMPOUNT PATTERN STRUCTURES (CONTINUED)
*
*      FENCE (FUNCTION)
*      ----------------
*
*           +---+            THIS NODE (P$FNA) SAVES THE
*           I A I            CURRENT HISTORY STACK AND A
*           +---+            POINTER TO NDFNB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE PATTERN STRUCTURE
*           I X I            GIVEN AS THE ARGUMENT TO THE
*           +---+            FENCE FUNCTION.
*             I
*             I
*           +---+            THIS NODE P$FNC RESTORES THE OUTER
*           I C I            HISTORY STACK PTR SAVED IN P$FNA,
*           +---+            AND STACKS THE INNER STACK BASE
*                            PTR AND A POINTER TO NDFND ON THE
*                            STACK.
*
*      NDFNB (F$FNB) SIMPLY IS THE FAILURE EXIT FOR PATTERN
*      ARGUMENT FAILURE, AND IT POPS ITSELF AND FAILS ONTO THE
*      STACK.
*
*      THE MATCH ROUTINE P$FNC ALLOWS FOR AN OPTIMIZATION WHEN
*      THE FENCE PATTERN LEAVES NO ALTERNATIVES.  IN THIS CASE,
*      THE NDFNB ENTRY IS POPPED, AND THE MATCH CONTINUES.
*
*      NDFND (P$FND) IS ENTERED WHEN THE PATTERN FAILS AFTER
*      GOING THROUGH A NON-OPTIMIZED P$FNC, AND IT POPS THE
*      STACK BACK PAST THE INNTER STACK BASE CREATED BY P$FNA
{{EJC{{{{{13420
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      EXPRESSION PATTERNS (RECURSIVE PATTERN MATCHES)
*      -----------------------------------------------
*
*      INITIAL ENTRY FOR A PATTERN NODE IS TO THE ROUTINE P$EXA.
*      IF THE EVALUATED RESULT OF THE EXPRESSION IS ITSELF A
*      PATTERN, THEN THE FOLLOWING STEPS ARE TAKEN TO ARRANGE
*      FOR PROPER RECURSIVE PROCESSING.
*
*      1)   A POINTER TO THE CURRENT NODE (THE P$EXA NODE) IS
*           STORED ON THE HISTORY STACK WITH A DUMMY CURSOR.
*
*      2)   A SPECIAL HISTORY STACK ENTRY IS MADE IN WHICH THE
*           NODE POINTER POINTS TO NDEXB, AND THE CURSOR VALUE
*           IS THE SAVED VALUE OF PMHBS ON ENTRY TO THIS NODE.
*           THE MATCH ROUTINE FOR NDEXB (P$EXB) RESTORES PMHBS
*           FROM THIS CURSOR ENTRY, POPS OFF THE P$EXA NODE
*           POINTER AND FAILS.
*
*      3)   THE RESULTING HISTORY STACK POINTER IS SAVED IN
*           PMHBS TO ESTABLISH A NEW LEVEL OF HISTORY STACK.
*
*      AFTER MATCHING A PATTERN, THE END OF MATCH ROUTINE GETS
*      CONTROL (P$NTH). THIS ROUTINE PROCEEDS AS FOLLOWS.
*
*      1)   LOAD THE CURRENT VALUE OF PMHBS AND RECOGNIZE THE
*           OUTER LEVEL CASE BY THE FACT THAT THE ASSOCIATED
*           CURSOR IN THIS CASE IS THE PATTERN MATCH TYPE CODE
*           WHICH IS LESS THAN 3. TERMINATE THE MATCH IN THIS
*           CASE AND CONTINUE EXECUTION OF THE PROGRAM.
*
*      2)   OTHERWISE MAKE A SPECIAL HISTORY STACK ENTRY IN
*           WHICH THE NODE POINTER POINTS TO THE SPECIAL NODE
*           NDEXC AND THE CURSOR IS THE CURRENT VALUE OF PMHBS.
*           THE MATCH ROUTINE FOR NDEXC (P$EXC) RESETS PMHBS TO
*           THIS (INNER) VALUE AND AND THEN FAILS.
*
*      3)   USING THE HISTORY STACK ENTRY MADE ON STARTING THE
*           EXPRESSION (ACCESSIBLE WITH THE CURRENT VALUE OF
*           PMHBS), RESTORE THE P$EXA NODE POINTER AND THE OLD
*           PMHBS SETTING. TAKE THE SUCCESSOR AND CONTINUE.
*
*      AN OPTIMIZATION IS POSSIBLE IF THE EXPRESSION PATTERN
*      MAKES NO ENTRIES ON THE HISTORY STACK. IN THIS CASE,
*      INSTEAD OF BUILDING THE P$EXC NODE IN STEP 2, IT IS MORE
*      EFFICIENT TO SIMPLY POP OFF THE P$EXB ENTRY AND ITS
*      ASSOCIATED NODE POINTER. THE EFFECT IS THE SAME.
{{EJC{{{{{13470
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*      ------------------------------------
*
*           +---+            THIS NODE (P$IMA) STACKS THE CURSOR
*           I A I            PMHBS AND A PTR TO NDIMB AND RESETS
*           +---+            THE STACK PTR PMHBS.
*             I
*             I
*           +---+            THIS IS THE LEFT STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            IMMEDIATE ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P$IMC) PERFORMS THE
*           I C I-----       ASSIGNMENT, POPS PMHBS AND STACKS
*           +---+            THE OLD PMHBS AND A PTR TO NDIMD.
*
*
*      THE STRUCTURE AND EXECUTION OF THIS PATTERN ARE SIMILAR
*      TO THOSE OF THE RECURSIVE EXPRESSION PATTERN MATCHING.
*
*      THE MATCH ROUTINE FOR NDIMB (P$IMB) RESTORES THE OUTER
*      LEVEL VALUE OF PMHBS, UNSTACKS THE SAVED CURSOR AND FAILS
*
*      THE MATCH ROUTINE P$IMC USES THE CURRENT VALUE OF PMHBS
*      TO LOCATE THE P$IMB ENTRY. THIS ENTRY IS USED TO MAKE
*      THE ASSIGNMENT AND RESTORE THE OUTER LEVEL VALUE OF
*      PMHBS. FINALLY, THE INNER LEVEL VALUE OF PMHBS AND A
*      POINTER TO THE SPECIAL NODE NDIMD ARE STACKED.
*
*      THE MATCH ROUTINE FOR NDIMD (P$IMD) RESTORES THE INNER
*      LEVEL VALUE OF PMHBS AND FAILS BACK INTO THE STACK.
*
*      AN OPTIMIZATION OCCURS IF THE INNER PATTERN MAKES NO
*      ENTRIES ON THE HISTORY STACK. IN THIS CASE, P$IMC POPS
*      THE P$IMB ENTRY INSTEAD OF MAKING A P$IMD ENTRY.
{{EJC{{{{{13510
*
*      ARBNO
*
*      SEE COMPOUND PATTERNS SECTION FOR STUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$ABA{ENT{2,BL$P0{{{P0BLK{13519
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13520
{{MOV{7,XR{11,-(XS){{STACK DUMMY NODE PTR{13521
{{MOV{3,PMHBS{11,-(XS){{STACK OLD STACK BASE PTR{13522
{{MOV{21,=NDABB{11,-(XS){{STACK PTR TO NODE NDABB{13523
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE PTR{13524
{{BRN{6,SUCCP{{{SUCCEED{13525
{{EJC{{{{{13526
*
*      ARBNO (REMOVE P$ABA SPECIAL STACK ENTRY)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABB{ENT{{{{ENTRY POINT{13532
{{MOV{8,WB{3,PMHBS{{RESTORE HISTORY STACK BASE PTR{13533
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{13534
{{EJC{{{{{13535
*
*      ARBNO (CHECK IF ARG MATCHED NULL STRING)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABC{ENT{2,BL$P0{{{P0BLK{13541
{{MOV{3,PMHBS{7,XT{{KEEP P$ABB STACK BASE{13542
{{MOV{13,NUM03(XT){8,WA{{LOAD INITIAL CURSOR{13543
{{MOV{13,NUM01(XT){3,PMHBS{{RESTORE OUTER STACK BASE PTR{13544
{{BEQ{7,XT{7,XS{6,PABC1{JUMP IF NO HISTORY STACK ENTRIES{13545
{{MOV{7,XT{11,-(XS){{ELSE SAVE INNER PMHBS ENTRY{13546
{{MOV{21,=NDABD{11,-(XS){{STACK PTR TO SPECIAL NODE NDABD{13547
{{BRN{6,PABC2{{{MERGE{13548
*
*      OPTIMISE CASE OF NO EXTRA ENTRIES ON STACK FROM ARBNO ARG
*
{PABC1{ADD{19,*NUM04{7,XS{{REMOVE NDABB ENTRY AND CURSOR{13552
*
*      MERGE TO CHECK FOR MATCHING OF NULL STRING
*
{PABC2{BNE{8,WA{8,WB{6,SUCCP{ALLOW FURTHER ATTEMPT IF NON-NULL{13556
{{MOV{13,PTHEN(XR){7,XR{{BYPASS ALTERNATIVE NODE SO AS TO ...{13557
{{BRN{6,SUCCP{{{... REFUSE FURTHER MATCH ATTEMPTS{13558
{{EJC{{{{{13559
*
*      ARBNO (TRY FOR ALTERNATIVES IN ARBNO ARGUMENT)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABD{ENT{{{{ENTRY POINT{13565
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE PTR{13566
{{BRN{6,FAILP{{{AND FAIL{13567
{{EJC{{{{{13568
*
*      ABORT
*
*      NO PARAMETERS
*
{P$ABO{ENT{2,BL$P0{{{P0BLK{13574
{{BRN{6,EXFAL{{{SIGNAL STATEMENT FAILURE{13575
{{EJC{{{{{13576
*
*      ALTERNATION
*
*      PARM1                 ALTERNATIVE NODE
*
{P$ALT{ENT{2,BL$P1{{{P1BLK{13582
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13583
{{MOV{13,PARM1(XR){11,-(XS){{STACK POINTER TO ALTERNATIVE{13584
{{CHK{{{{CHECK FOR STACK OVERFLOW{13585
{{BRN{6,SUCCP{{{IF ALL OK, THEN SUCCEED{13586
{{EJC{{{{{13587
*
*      ANY (ONE CHARACTER ARGUMENT) (1-CHAR STRING ALSO)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$ANS{ENT{2,BL$P1{{{P1BLK{13593
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{13594
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13595
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13596
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{13597
{{BNE{8,WA{13,PARM1(XR){6,FAILP{FAIL IF NO MATCH{13598
{{ICV{8,WB{{{ELSE BUMP CURSOR{13599
{{BRN{6,SUCCP{{{AND SUCCEED{13600
{{EJC{{{{{13601
*
*      ANY (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT IN CTBLK
*
{P$ANY{ENT{2,BL$P2{{{P2BLK{13608
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PANY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{13612
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13613
{{PLC{7,XL{8,WB{{GET CHAR PTR TO CURRENT CHARACTER{13614
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{13615
{{MOV{13,PARM1(XR){7,XL{{POINT TO CTBLK{13616
{{WTB{8,WA{{{CHANGE TO BYTE OFFSET{13617
{{ADD{8,WA{7,XL{{POINT TO ENTRY IN CTBLK{13618
{{MOV{13,CTCHS(XL){8,WA{{LOAD WORD FROM CTBLK{13619
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{13620
{{ZRB{8,WA{6,FAILP{{FAIL IF NO MATCH{13621
{{ICV{8,WB{{{ELSE BUMP CURSOR{13622
{{BRN{6,SUCCP{{{AND SUCCEED{13623
{{EJC{{{{{13624
*
*      ANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$AYD{ENT{2,BL$P1{{{P1BLK{13630
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{13631
{{ERR{1,043{26,ANY evaluated argument is not a string{{{13632
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILURE{13633
{{PPM{6,PANY1{{{MERGE MULTI-CHAR CASE IF OK{13634
{{EJC{{{{{13635
*
*      P$ARB                 INITIAL ARB MATCH
*
*      NO PARAMETERS
*
*      THE P$ARB NODE IS PART OF A COMPOUND PATTERN STRUCTURE
*      FOR AN ARB PATTERN (SEE DESCRIPTION OF COMPOUND PATTERNS)
*
{P$ARB{ENT{2,BL$P0{{{P0BLK{13644
{{MOV{13,PTHEN(XR){7,XR{{LOAD SUCCESSOR POINTER{13645
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13646
{{MOV{7,XR{11,-(XS){{STACK SUCCESSOR POINTER{13647
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13648
{{MOV{21,=NDARC{11,-(XS){{STACK PTR TO SPECIAL NODE NDARC{13649
{{BRI{9,(XR){{{EXECUTE NEXT NODE MATCHING NULL{13650
{{EJC{{{{{13651
*
*      P$ARC                 EXTEND ARB MATCH
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ARC{ENT{{{{ENTRY POINT{13657
{{BEQ{8,WB{3,PMSSL{6,FLPOP{FAIL AND POP STACK TO SUCCESSOR{13658
{{ICV{8,WB{{{ELSE BUMP CURSOR{13659
{{MOV{8,WB{11,-(XS){{STACK UPDATED CURSOR{13660
{{MOV{7,XR{11,-(XS){{RESTACK POINTER TO NDARC NODE{13661
{{MOV{13,NUM02(XS){7,XR{{LOAD SUCCESSOR POINTER{13662
{{BRI{9,(XR){{{OFF TO REEXECUTE SUCCESSOR NODE{13663
{{EJC{{{{{13664
*
*      BAL
*
*      NO PARAMETERS
*
*      THE P$BAL NODE IS PART OF THE COMPOUND STRUCTURE BUILT
*      FOR BAL (SEE SECTION ON COMPOUND PATTERNS).
*
{P$BAL{ENT{2,BL$P0{{{P0BLK{13673
{{ZER{8,WC{{{ZERO PARENTHESES LEVEL COUNTER{13674
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{13675
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13676
{{BRN{6,PBAL2{{{JUMP INTO SCAN LOOP{13677
*
*      LOOP TO SCAN OUT CHARACTERS
*
{PBAL1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{13681
{{ICV{8,WB{{{PUSH CURSOR FOR CHARACTER{13682
{{BEQ{8,WA{18,=CH$PP{6,PBAL3{JUMP IF LEFT PAREN{13683
{{BEQ{8,WA{18,=CH$RP{6,PBAL4{JUMP IF RIGHT PAREN{13684
{{BZE{8,WC{6,PBAL5{{ELSE SUCCEED IF AT OUTER LEVEL{13685
*
*      HERE AFTER PROCESSING ONE CHARACTER
*
{PBAL2{BNE{8,WB{3,PMSSL{6,PBAL1{LOOP BACK UNLESS END OF STRING{13689
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{13690
*
*      HERE ON LEFT PAREN
*
{PBAL3{ICV{8,WC{{{BUMP PAREN LEVEL{13694
{{BRN{6,PBAL2{{{LOOP BACK TO CHECK END OF STRING{13695
*
*      HERE FOR RIGHT PAREN
*
{PBAL4{BZE{8,WC{6,FAILP{{FAIL IF NO MATCHING LEFT PAREN{13699
{{DCV{8,WC{{{ELSE DECREMENT LEVEL COUNTER{13700
{{BNZ{8,WC{6,PBAL2{{LOOP BACK IF NOT AT OUTER LEVEL{13701
*
*      HERE AFTER SUCCESSFULLY SCANNING A BALANCED STRING
*
{PBAL5{MOV{8,WB{11,-(XS){{STACK CURSOR{13705
{{MOV{7,XR{11,-(XS){{STACK PTR TO BAL NODE FOR EXTEND{13706
{{BRN{6,SUCCP{{{AND SUCCEED{13707
{{EJC{{{{{13708
*
*      BREAK (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$BKD{ENT{2,BL$P1{{{P1BLK{13714
{{JSR{6,EVALS{{{EVALUATE STRING EXPRESSION{13715
{{ERR{1,044{26,BREAK evaluated argument is not a string{{{13716
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13717
{{PPM{6,PBRK1{{{MERGE WITH MULTI-CHAR CASE IF OK{13718
{{EJC{{{{{13719
*
*      BREAK (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$BKS{ENT{2,BL$P1{{{P1BLK{13725
{{MOV{3,PMSSL{8,WC{{GET SUBJECT STRING LENGTH{13726
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS LEFT{13727
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{13728
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{13729
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{13730
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13731
*
*      LOOP TO SCAN TILL BREAK CHARACTER FOUND
*
{PBKS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{13735
{{BEQ{8,WA{13,PARM1(XR){6,SUCCP{SUCCEED IF BREAK CHARACTER FOUND{13736
{{ICV{8,WB{{{ELSE PUSH CURSOR{13737
{{BCT{8,WC{6,PBKS1{{LOOP BACK IF MORE TO GO{13738
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{13739
{{EJC{{{{{13740
*
*      BREAK (MULTI-CHARACTER ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$BRK{ENT{2,BL$P2{{{P2BLK{13747
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PBRK1{MOV{3,PMSSL{8,WC{{LOAD SUBJECT STRING LENGTH{13751
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS LEFT{13752
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{13753
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{13754
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13755
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13756
{{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{13757
*
*      LOOP TO SEARCH FOR BREAK CHARACTER
*
{PBRK2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{13761
{{MOV{13,PARM1(XR){7,XR{{LOAD POINTER TO CTBLK{13762
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{13763
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{13764
{{MOV{13,CTCHS(XR){8,WA{{LOAD CTBLK WORD{13765
{{MOV{3,PSAVE{7,XR{{RESTORE NODE POINTER{13766
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{13767
{{NZB{8,WA{6,SUCCP{{SUCCEED IF BREAK CHARACTER FOUND{13768
{{ICV{8,WB{{{ELSE PUSH CURSOR{13769
{{BCT{8,WC{6,PBRK2{{LOOP BACK UNLESS END OF STRING{13770
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{13771
{{EJC{{{{{13772
*
*      BREAKX (EXTENSION)
*
*      THIS IS THE ENTRY WHICH CAUSES AN EXTENSION OF A BREAKX
*      MATCH WHEN FAILURE OCCURS. SEE SECTION ON COMPOUND
*      PATTERNS FOR FULL DETAILS OF BREAKX MATCHING.
*
*      NO PARAMETERS
*
{P$BKX{ENT{2,BL$P0{{{P0BLK{13782
{{ICV{8,WB{{{STEP CURSOR PAST PREVIOUS BREAK CHR{13783
{{BRN{6,SUCCP{{{SUCCEED TO REMATCH BREAK{13784
{{EJC{{{{{13785
*
*      BREAKX (EXPRESSION ARGUMENT)
*
*      SEE SECTION ON COMPOUND PATTERNS FOR FULL STRUCTURE OF
*      BREAKX PATTERN. THE ACTUAL CHARACTER MATCHING USES A
*      BREAK NODE. HOWEVER, THE ENTRY FOR THE EXPRESSION
*      ARGUMENT CASE IS SEPARATED TO GET PROPER ERROR MESSAGES.
*
*      PARM1                 EXPRESSION POINTER
*
{P$BXD{ENT{2,BL$P1{{{P1BLK{13796
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{13797
{{ERR{1,045{26,BREAKX evaluated argument is not a string{{{13798
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13799
{{PPM{6,PBRK1{{{MERGE WITH BREAK IF ALL OK{13800
{{EJC{{{{{13801
*
*      CURSOR ASSIGNMENT
*
*      PARM1                 NAME BASE
*      PARM2                 NAME OFFSET
*
{P$CAS{ENT{2,BL$P2{{{P2BLK{13808
{{MOV{7,XR{11,-(XS){{SAVE NODE POINTER{13809
{{MOV{8,WB{11,-(XS){{SAVE CURSOR{13810
{{MOV{13,PARM1(XR){7,XL{{LOAD NAME BASE{13811
{{MTI{8,WB{{{LOAD CURSOR AS INTEGER{13812
{{MOV{13,PARM2(XR){8,WB{{LOAD NAME OFFSET{13813
{{JSR{6,ICBLD{{{GET ICBLK FOR CURSOR VALUE{13814
{{MOV{8,WB{8,WA{{MOVE NAME OFFSET{13815
{{MOV{7,XR{8,WB{{MOVE VALUE TO ASSIGN{13816
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{13817
{{PPM{6,FLPOP{{{FAIL ON ASSIGNMENT FAILURE{13818
{{MOV{10,(XS)+{8,WB{{ELSE RESTORE CURSOR{13819
{{MOV{10,(XS)+{7,XR{{RESTORE NODE POINTER{13820
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{13821
{{EJC{{{{{13822
*
*      EXPRESSION NODE (P$EXA, INITIAL ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      PARM1                 EXPRESSION POINTER
*
{P$EXA{ENT{2,BL$P1{{{P1BLK{13831
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{13832
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13833
{{BLO{8,WA{22,=P$AAA{6,PEXA1{JUMP IF RESULT IS NOT A PATTERN{13834
*
*      HERE IF RESULT OF EXPRESSION IS A PATTERN
*
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13838
{{MOV{7,XR{11,-(XS){{STACK PTR TO P$EXA NODE{13839
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE PTR{13840
{{MOV{21,=NDEXB{11,-(XS){{STACK PTR TO SPECIAL NODE NDEXB{13841
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE POINTER{13842
{{MOV{7,XL{7,XR{{COPY NODE POINTER{13843
{{BRI{9,(XR){{{MATCH FIRST NODE IN EXPRESSION PAT{13844
*
*      HERE IF RESULT OF EXPRESSION IS NOT A PATTERN
*
{PEXA1{BEQ{8,WA{22,=B$SCL{6,PEXA2{JUMP IF IT IS ALREADY A STRING{13848
{{MOV{7,XL{11,-(XS){{ELSE STACK RESULT{13849
{{MOV{7,XR{7,XL{{SAVE NODE POINTER{13850
{{JSR{6,GTSTG{{{CONVERT RESULT TO STRING{13851
{{ERR{1,046{26,Expression does not evaluate to pattern{{{13852
{{MOV{7,XR{8,WC{{COPY STRING POINTER{13853
{{MOV{7,XL{7,XR{{RESTORE NODE POINTER{13854
{{MOV{8,WC{7,XL{{COPY STRING POINTER AGAIN{13855
*
*      MERGE HERE WITH STRING POINTER IN XL
*
{PEXA2{BZE{13,SCLEN(XL){6,SUCCP{{JUST SUCCEED IF NULL STRING{13859
{{BRN{6,PSTR1{{{ELSE MERGE WITH STRING CIRCUIT{13860
{{EJC{{{{{13861
*
*      EXPRESSION NODE (P$EXB, REMOVE NDEXB ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$EXB{ENT{{{{ENTRY POINT{13870
{{MOV{8,WB{3,PMHBS{{RESTORE OUTER LEVEL STACK POINTER{13871
{{BRN{6,FLPOP{{{FAIL AND POP P$EXA NODE PTR{13872
{{EJC{{{{{13873
*
*      EXPRESSION NODE (P$EXC, REMOVE NDEXC ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$EXC{ENT{{{{ENTRY POINT{13882
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE POINTER{13883
{{BRN{6,FAILP{{{AND FAIL INTO EXPR PATTERN ALTERNVS{13884
{{EJC{{{{{13885
*
*      FAIL
*
*      NO PARAMETERS
*
{P$FAL{ENT{2,BL$P0{{{P0BLK{13891
{{BRN{6,FAILP{{{JUST SIGNAL FAILURE{13892
{{EJC{{{{{13893
*
*      FENCE
*
*      SEE COMPOUND PATTERNS SECTION FOR THE STRUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$FEN{ENT{2,BL$P0{{{P0BLK{13902
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13903
{{MOV{21,=NDABO{11,-(XS){{STACK PTR TO ABORT NODE{13904
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{13905
{{EJC{{{{{13906
*
*      FENCE (FUNCTION)
*
*      SEE COMPOUND PATTERNS COMMENTS AT START OF THIS SECTION
*      FOR DETAILS OF SCHEME
*
*      NO PARAMETERS
*
{P$FNA{ENT{2,BL$P0{{{P0BLK{13915
{{MOV{3,PMHBS{11,-(XS){{STACK CURRENT HISTORY STACK BASE{13916
{{MOV{21,=NDFNB{11,-(XS){{STACK INDIR PTR TO P$FNB (FAILURE){13917
{{MOV{7,XS{3,PMHBS{{BEGIN NEW HISTORY STACK{13918
{{BRN{6,SUCCP{{{SUCCEED{13919
{{EJC{{{{{13920
*
*      FENCE (FUNCTION) (RESET HISTORY STACK AND FAIL)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FNB{ENT{2,BL$P0{{{P0BLK{13926
{{MOV{8,WB{3,PMHBS{{RESTORE OUTER PMHBS STACK BASE{13927
{{BRN{6,FAILP{{{...AND FAIL{13928
{{EJC{{{{{13929
*
*      FENCE (FUNCTION) (MAKE FENCE TRAP ENTRY ON STACK)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FNC{ENT{2,BL$P0{{{P0BLK{13935
{{MOV{3,PMHBS{7,XT{{GET INNER STACK BASE PTR{13936
{{MOV{13,NUM01(XT){3,PMHBS{{RESTORE OUTER STACK BASE{13937
{{BEQ{7,XT{7,XS{6,PFNC1{OPTIMIZE IF NO ALTERNATIVES{13938
{{MOV{7,XT{11,-(XS){{ELSE STACK INNER STACK BASE{13939
{{MOV{21,=NDFND{11,-(XS){{STACK PTR TO NDFND{13940
{{BRN{6,SUCCP{{{SUCCEED{13941
*
*      HERE WHEN FENCE FUNCTION LEFT NOTHING ON THE STACK
*
{PFNC1{ADD{19,*NUM02{7,XS{{POP OFF P$FNB ENTRY{13945
{{BRN{6,SUCCP{{{SUCCEED{13946
{{EJC{{{{{13947
*
*      FENCE (FUNCTION) (SKIP PAST ALTERNATIVES ON FAILURE)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FND{ENT{2,BL$P0{{{P0BLK{13953
{{MOV{8,WB{7,XS{{POP STACK TO FENCE() HISTORY BASE{13954
{{BRN{6,FLPOP{{{POP BASE ENTRY AND FAIL{13955
{{EJC{{{{{13956
*
*      IMMEDIATE ASSIGNMENT (INITIAL ENTRY, SAVE CURRENT CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$IMA{ENT{2,BL$P0{{{P0BLK{13965
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13966
{{MOV{7,XR{11,-(XS){{STACK DUMMY NODE POINTER{13967
{{MOV{3,PMHBS{11,-(XS){{STACK OLD STACK BASE POINTER{13968
{{MOV{21,=NDIMB{11,-(XS){{STACK PTR TO SPECIAL NODE NDIMB{13969
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE POINTER{13970
{{BRN{6,SUCCP{{{AND SUCCEED{13971
{{EJC{{{{{13972
*
*      IMMEDIATE ASSIGNMENT (REMOVE CURSOR MARK ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$IMB{ENT{{{{ENTRY POINT{13981
{{MOV{8,WB{3,PMHBS{{RESTORE HISTORY STACK BASE PTR{13982
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{13983
{{EJC{{{{{13984
*
*      IMMEDIATE ASSIGNMENT (PERFORM ACTUAL ASSIGNMENT)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P$IMC{ENT{2,BL$P2{{{P2BLK{13994
{{MOV{3,PMHBS{7,XT{{LOAD POINTER TO P$IMB ENTRY{13995
{{MOV{8,WB{8,WA{{COPY FINAL CURSOR{13996
{{MOV{13,NUM03(XT){8,WB{{LOAD INITIAL CURSOR{13997
{{MOV{13,NUM01(XT){3,PMHBS{{RESTORE OUTER STACK BASE POINTER{13998
{{BEQ{7,XT{7,XS{6,PIMC1{JUMP IF NO HISTORY STACK ENTRIES{13999
{{MOV{7,XT{11,-(XS){{ELSE SAVE INNER PMHBS POINTER{14000
{{MOV{21,=NDIMD{11,-(XS){{AND A PTR TO SPECIAL NODE NDIMD{14001
{{BRN{6,PIMC2{{{MERGE{14002
*
*      HERE IF NO ENTRIES MADE ON HISTORY STACK
*
{PIMC1{ADD{19,*NUM04{7,XS{{REMOVE NDIMB ENTRY AND CURSOR{14006
*
*      MERGE HERE TO PERFORM ASSIGNMENT
*
{PIMC2{MOV{8,WA{11,-(XS){{SAVE CURRENT (FINAL) CURSOR{14010
{{MOV{7,XR{11,-(XS){{SAVE CURRENT NODE POINTER{14011
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14012
{{SUB{8,WB{8,WA{{COMPUTE SUBSTRING LENGTH{14013
{{JSR{6,SBSTR{{{BUILD SUBSTRING{14014
{{MOV{7,XR{8,WB{{MOVE RESULT{14015
{{MOV{9,(XS){7,XR{{RELOAD NODE POINTER{14016
{{MOV{13,PARM1(XR){7,XL{{LOAD NAME BASE{14017
{{MOV{13,PARM2(XR){8,WA{{LOAD NAME OFFSET{14018
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{14019
{{PPM{6,FLPOP{{{FAIL IF ASSIGNMENT FAILS{14020
{{MOV{10,(XS)+{7,XR{{ELSE RESTORE NODE POINTER{14021
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{14022
{{BRN{6,SUCCP{{{AND SUCCEED{14023
{{EJC{{{{{14024
*
*      IMMEDIATE ASSIGNMENT (REMOVE NDIMD ENTRY ON FAILURE)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$IMD{ENT{{{{ENTRY POINT{14033
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE POINTER{14034
{{BRN{6,FAILP{{{AND FAIL{14035
{{EJC{{{{{14036
*
*      LEN (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$LEN{ENT{2,BL$P1{{{P1BLK{14042
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PLEN1{ADD{13,PARM1(XR){8,WB{{PUSH CURSOR INDICATED AMOUNT{14046
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{14047
{{BRN{6,FAILP{{{ELSE FAIL{14048
{{EJC{{{{{14049
*
*      LEN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$LND{ENT{2,BL$P1{{{P1BLK{14055
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14056
{{ERR{1,047{26,LEN evaluated argument is not integer{{{14057
{{ERR{1,048{26,LEN evaluated argument is negative or too large{{{14058
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14059
{{PPM{6,PLEN1{{{MERGE WITH NORMAL CIRCUIT IF OK{14060
{{EJC{{{{{14061
*
*      NOTANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$NAD{ENT{2,BL$P1{{{P1BLK{14067
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{14068
{{ERR{1,049{26,NOTANY evaluated argument is not a string{{{14069
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14070
{{PPM{6,PNAY1{{{MERGE WITH MULTI-CHAR CASE IF OK{14071
{{EJC{{{{{14072
*
*      NOTANY (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$NAS{ENT{2,BL$P1{{{ENTRY POINT{14078
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{14079
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14080
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER IN STRIN{14081
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{14082
{{BEQ{8,WA{13,PARM1(XR){6,FAILP{FAIL IF MATCH{14083
{{ICV{8,WB{{{ELSE BUMP CURSOR{14084
{{BRN{6,SUCCP{{{AND SUCCEED{14085
{{EJC{{{{{14086
*
*      NOTANY (MULTI-CHARACTER STRING ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$NAY{ENT{2,BL$P2{{{P2BLK{14093
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PNAY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{14097
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14098
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14099
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{14100
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{14101
{{MOV{13,PARM1(XR){7,XL{{LOAD POINTER TO CTBLK{14102
{{ADD{8,WA{7,XL{{POINT TO ENTRY IN CTBLK{14103
{{MOV{13,CTCHS(XL){8,WA{{LOAD ENTRY FROM CTBLK{14104
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{14105
{{NZB{8,WA{6,FAILP{{FAIL IF CHARACTER IS MATCHED{14106
{{ICV{8,WB{{{ELSE BUMP CURSOR{14107
{{BRN{6,SUCCP{{{AND SUCCEED{14108
{{EJC{{{{{14109
*
*      END OF PATTERN MATCH
*
*      THIS ROUTINE IS ENTERED ON SUCCESSFUL COMPLETION.
*      SEE DESCRIPTION OF EXPRESSION PATTERNS IN COMPOUND
*      PATTERN SECTION FOR HANDLING OF RECURSION IN MATCHING.
*
*      THIS PATTERN ALSO RESULTS FROM AN ATTEMPT TO CONVERT THE
*      NULL STRING TO A PATTERN VIA CONVERT()
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$NTH{ENT{2,BL$P0{{{P0BLK (DUMMY){14122
{{MOV{3,PMHBS{7,XT{{LOAD POINTER TO BASE OF STACK{14123
{{MOV{13,NUM01(XT){8,WA{{LOAD SAVED PMHBS (OR PATTERN TYPE){14124
{{BLE{8,WA{18,=NUM02{6,PNTH2{JUMP IF OUTER LEVEL (PATTERN TYPE){14125
*
*      HERE WE ARE AT THE END OF MATCHING AN EXPRESSION PATTERN
*
{{MOV{8,WA{3,PMHBS{{RESTORE OUTER STACK BASE POINTER{14129
{{MOV{13,NUM02(XT){7,XR{{RESTORE POINTER TO P$EXA NODE{14130
{{BEQ{7,XT{7,XS{6,PNTH1{JUMP IF NO HISTORY STACK ENTRIES{14131
{{MOV{7,XT{11,-(XS){{ELSE STACK INNER STACK BASE PTR{14132
{{MOV{21,=NDEXC{11,-(XS){{STACK PTR TO SPECIAL NODE NDEXC{14133
{{BRN{6,SUCCP{{{AND SUCCEED{14134
*
*      HERE IF NO HISTORY STACK ENTRIES DURING PATTERN
*
{PNTH1{ADD{19,*NUM04{7,XS{{REMOVE P$EXB ENTRY AND NODE PTR{14138
{{BRN{6,SUCCP{{{AND SUCCEED{14139
*
*      HERE IF END OF MATCH AT OUTER LEVEL
*
{PNTH2{MOV{8,WB{3,PMSSL{{SAVE FINAL CURSOR IN SAFE PLACE{14143
{{BZE{3,PMDFL{6,PNTH6{{JUMP IF NO PATTERN ASSIGNMENTS{14144
{{EJC{{{{{14145
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      NOW WE MUST PERFORM PATTERN ASSIGNMENTS. THIS IS DONE BY
*      SCANNING THE HISTORY STACK FOR MATCHING NDPAB-NDPAD PAIRS
*
{PNTH3{DCA{7,XT{{{POINT PAST CURSOR ENTRY{14152
{{MOV{11,-(XT){8,WA{{LOAD NODE POINTER{14153
{{BEQ{8,WA{21,=NDPAD{6,PNTH4{JUMP IF NDPAD ENTRY{14154
{{BNE{8,WA{21,=NDPAB{6,PNTH5{JUMP IF NOT NDPAB ENTRY{14155
*
*      HERE FOR NDPAB ENTRY, STACK INITIAL CURSOR
*      NOTE THAT THERE MUST BE MORE ENTRIES ON THE STACK.
*
{{MOV{13,NUM01(XT){11,-(XS){{STACK INITIAL CURSOR{14160
{{CHK{{{{CHECK FOR STACK OVERFLOW{14161
{{BRN{6,PNTH3{{{LOOP BACK IF OK{14162
*
*      HERE FOR NDPAD ENTRY. THE STARTING CURSOR FROM THE
*      MATCHING NDPAD ENTRY IS NOW THE TOP STACK ENTRY.
*
{PNTH4{MOV{13,NUM01(XT){8,WA{{LOAD FINAL CURSOR{14167
{{MOV{9,(XS){8,WB{{LOAD INITIAL CURSOR FROM STACK{14168
{{MOV{7,XT{9,(XS){{SAVE HISTORY STACK SCAN PTR{14169
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF STRING{14170
*
*      BUILD SUBSTRING AND PERFORM ASSIGNMENT
*
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14174
{{JSR{6,SBSTR{{{CONSTRUCT SUBSTRING{14175
{{MOV{7,XR{8,WB{{COPY SUBSTRING POINTER{14176
{{MOV{9,(XS){7,XT{{RELOAD HISTORY STACK SCAN PTR{14177
{{MOV{13,NUM02(XT){7,XL{{LOAD POINTER TO P$PAC NODE WITH NAM{14178
{{MOV{13,PARM2(XL){8,WA{{LOAD NAME OFFSET{14179
{{MOV{13,PARM1(XL){7,XL{{LOAD NAME BASE{14180
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{14181
{{PPM{6,EXFAL{{{MATCH FAILS IF NAME EVAL FAILS{14182
{{MOV{10,(XS)+{7,XT{{ELSE RESTORE HISTORY STACK PTR{14183
{{EJC{{{{{14184
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      HERE CHECK FOR END OF ENTRIES
*
{PNTH5{BNE{7,XT{7,XS{6,PNTH3{LOOP IF MORE ENTRIES TO SCAN{14190
*
*      HERE AFTER DEALING WITH PATTERN ASSIGNMENTS
*
{PNTH6{MOV{3,PMHBS{7,XS{{WIPE OUT HISTORY STACK{14194
{{MOV{10,(XS)+{8,WB{{LOAD INITIAL CURSOR{14195
{{MOV{10,(XS)+{8,WC{{LOAD MATCH TYPE CODE{14196
{{MOV{3,PMSSL{8,WA{{LOAD FINAL CURSOR VALUE{14197
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14198
{{ZER{3,R$PMS{{{CLEAR SUBJECT STRING PTR FOR GBCOL{14199
{{BZE{8,WC{6,PNTH7{{JUMP IF CALL BY NAME{14200
{{BEQ{8,WC{18,=NUM02{6,PNTH9{EXIT IF STATEMENT LEVEL CALL{14201
*
*      HERE WE HAVE A CALL BY VALUE, BUILD SUBSTRING
*
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF STRING{14205
{{JSR{6,SBSTR{{{BUILD SUBSTRING{14206
{{MOV{7,XR{11,-(XS){{STACK RESULT{14207
{{LCW{7,XR{{{GET NEXT CODE WORD{14208
{{BRI{9,(XR){{{EXECUTE IT{14209
*
*      HERE FOR CALL BY NAME, MAKE STACK ENTRIES FOR O$RPL
*
{PNTH7{MOV{8,WB{11,-(XS){{STACK INITIAL CURSOR{14213
{{MOV{8,WA{11,-(XS){{STACK FINAL CURSOR{14214
*
*      HERE WITH XL POINTING TO SCBLK OR BCBLK
*
{PNTH8{MOV{7,XL{11,-(XS){{STACK SUBJECT POINTER{14223
*
*      HERE TO OBEY NEXT CODE WORD
*
{PNTH9{LCW{7,XR{{{GET NEXT CODE WORD{14227
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14228
{{EJC{{{{{14229
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$POS{ENT{2,BL$P1{{{P1BLK{14235
*
*      OPTIMIZE POS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND POS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLE PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT.)
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14253
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14254
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14255
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14256
*
*      EXPRESSION ARGUMENT CIRCUIT MERGES HERE
*
{PPOS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{14260
{{MOV{13,PARM1(XR){8,WB{{GET DESIRED CURSOR POSITION{14261
{{BGT{8,WB{3,PMSSL{6,EXFAL{ABORT IF OFF END{14262
{{MOV{8,WB{13,NUM02(XT){{FAKE NUMBER OF UNANCHORED MOVES{14263
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{14264
{{EJC{{{{{14265
*
*      POS (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$PSD{ENT{2,BL$P1{{{P1BLK{14271
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14272
{{ERR{1,050{26,POS evaluated argument is not integer{{{14273
{{ERR{1,051{26,POS evaluated argument is negative or too large{{{14274
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14275
{{PPM{6,PPOS1{{{PROCESS EXPRESSION CASE{14276
*
{PPOS1{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14278
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14279
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{14280
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14281
{{MOV{3,EVLIO{8,WA{{GET ORIGINAL NODE PTR{14282
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14283
{{BRN{6,PPOS2{{{MERGE WITH INTEGER ARGUMENT CODE{14284
{{EJC{{{{{14285
*
*      PATTERN ASSIGNMENT (INITIAL ENTRY, SAVE CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$PAA{ENT{2,BL$P0{{{P0BLK{14294
{{MOV{8,WB{11,-(XS){{STACK INITIAL CURSOR{14295
{{MOV{21,=NDPAB{11,-(XS){{STACK PTR TO NDPAB SPECIAL NODE{14296
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{14297
{{EJC{{{{{14298
*
*      PATTERN ASSIGNMENT (REMOVE SAVED CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$PAB{ENT{{{{ENTRY POINT{14307
{{BRN{6,FAILP{{{JUST FAIL (ENTRY IS ALREADY POPPED){14308
{{EJC{{{{{14309
*
*      PATTERN ASSIGNMENT (END OF MATCH, MAKE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P$PAC{ENT{2,BL$P2{{{P2BLK{14319
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR VALUE{14320
{{MOV{7,XR{11,-(XS){{STACK POINTER TO P$PAC NODE{14321
{{MOV{8,WB{11,-(XS){{STACK FINAL CURSOR{14322
{{MOV{21,=NDPAD{11,-(XS){{STACK PTR TO SPECIAL NDPAD NODE{14323
{{MNZ{3,PMDFL{{{SET DOT FLAG NON-ZERO{14324
{{BRN{6,SUCCP{{{AND SUCCEED{14325
{{EJC{{{{{14326
*
*      PATTERN ASSIGNMENT (REMOVE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY NODE)
*
{P$PAD{ENT{{{{ENTRY POINT{14335
{{BRN{6,FLPOP{{{FAIL AND REMOVE P$PAC NODE{14336
{{EJC{{{{{14337
*
*      REM
*
*      NO PARAMETERS
*
{P$REM{ENT{2,BL$P0{{{P0BLK{14343
{{MOV{3,PMSSL{8,WB{{POINT CURSOR TO END OF STRING{14344
{{BRN{6,SUCCP{{{AND SUCCEED{14345
{{EJC{{{{{14346
*
*      RPOS (EXPRESSION ARGUMENT)
*
*      OPTIMIZE RPOS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND RPOS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLY PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT).
*
*      PARM1                 EXPRESSION POINTER
*
{P$RPD{ENT{2,BL$P1{{{P1BLK{14364
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14365
{{ERR{1,052{26,RPOS evaluated argument is not integer{{{14366
{{ERR{1,053{26,RPOS evaluated argument is negative or too large{{{14367
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14368
{{PPM{6,PRPS1{{{MERGE WITH NORMAL CASE IF OK{14369
*
{PRPS1{MOV{3,PMSSL{8,WC{{GET LENGTH OF STRING{14371
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS REMAINING{14372
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14373
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14374
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{14375
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14376
{{MOV{3,EVLIO{8,WA{{GET ORIGINAL NODE PTR{14377
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14378
{{BRN{6,PRPS2{{{MERGE WITH INTEGER ARG CODE{14379
{{EJC{{{{{14380
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$RPS{ENT{2,BL$P1{{{P1BLK{14386
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{MOV{3,PMSSL{8,WC{{GET LENGTH OF STRING{14392
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS REMAINING{14393
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14394
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14395
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14396
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF RPOS IS NOT FIRST NODE{14397
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PRPS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{14401
{{MOV{3,PMSSL{8,WB{{POINT TO END OF STRING{14402
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{14403
{{SUB{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR{14404
{{MOV{8,WB{13,NUM02(XT){{FAKE NUMBER OF UNANCHORED MOVES{14405
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{14406
{{EJC{{{{{14407
*
*      RTAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$RTB{ENT{2,BL$P1{{{P1BLK{14413
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PRTB1{MOV{8,WB{8,WC{{SAVE INITIAL CURSOR{14417
{{MOV{3,PMSSL{8,WB{{POINT TO END OF STRING{14418
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{14419
{{SUB{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR{14420
{{BGE{8,WB{8,WC{6,SUCCP{AND SUCCEED IF NOT TOO FAR ALREADY{14421
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{14422
{{EJC{{{{{14423
*
*      RTAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$RTD{ENT{2,BL$P1{{{P1BLK{14429
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14430
{{ERR{1,054{26,RTAB evaluated argument is not integer{{{14431
{{ERR{1,055{26,RTAB evaluated argument is negative or too large{{{14432
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14433
{{PPM{6,PRTB1{{{MERGE WITH NORMAL CASE IF SUCCESS{14434
{{EJC{{{{{14435
*
*      SPAN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$SPD{ENT{2,BL$P1{{{P1BLK{14441
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{14442
{{ERR{1,056{26,SPAN evaluated argument is not a string{{{14443
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14444
{{PPM{6,PSPN1{{{MERGE WITH MULTI-CHAR CASE IF OK{14445
{{EJC{{{{{14446
*
*      SPAN (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$SPN{ENT{2,BL$P2{{{P2BLK{14453
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PSPN1{MOV{3,PMSSL{8,WC{{COPY SUBJECT STRING LENGTH{14457
{{SUB{8,WB{8,WC{{CALCULATE NUMBER OF CHARACTERS LEFT{14458
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{14459
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14460
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14461
{{MOV{8,WB{3,PSAVC{{SAVE INITIAL CURSOR{14462
{{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{14463
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{14464
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPN2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{14468
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{14469
{{MOV{13,PARM1(XR){7,XR{{POINT TO CTBLK{14470
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{14471
{{MOV{13,CTCHS(XR){8,WA{{LOAD CTBLK ENTRY{14472
{{MOV{3,PSAVE{7,XR{{RESTORE NODE POINTER{14473
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{14474
{{ZRB{8,WA{6,PSPN3{{JUMP IF NO MATCH{14475
{{ICV{8,WB{{{ELSE PUSH CURSOR{14476
{{BCT{8,WC{6,PSPN2{{LOOP BACK UNLESS END OF STRING{14477
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPN3{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{14481
{{BRN{6,FAILP{{{ELSE FAIL IF NULL STRING MATCHED{14482
{{EJC{{{{{14483
*
*      SPAN (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$SPS{ENT{2,BL$P1{{{P1BLK{14489
{{MOV{3,PMSSL{8,WC{{GET SUBJECT STRING LENGTH{14490
{{SUB{8,WB{8,WC{{CALCULATE NUMBER OF CHARACTERS LEFT{14491
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{14492
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14493
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14494
{{MOV{8,WB{3,PSAVC{{SAVE INITIAL CURSOR{14495
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{14496
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{14500
{{BNE{8,WA{13,PARM1(XR){6,PSPS2{JUMP IF NO MATCH{14501
{{ICV{8,WB{{{ELSE PUSH CURSOR{14502
{{BCT{8,WC{6,PSPS1{{AND LOOP UNLESS END OF STRING{14503
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPS2{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{14507
{{BRN{6,FAILP{{{FAIL IF NULL STRING MATCHED{14508
{{EJC{{{{{14509
*
*      MULTI-CHARACTER STRING
*
*      NOTE THAT ONE CHARACTER STRINGS USE THE CIRCUIT FOR
*      ONE CHARACTER ANY ARGUMENTS (P$AN1).
*
*      PARM1                 POINTER TO SCBLK FOR STRING ARG
*
{P$STR{ENT{2,BL$P1{{{P1BLK{14518
{{MOV{13,PARM1(XR){7,XL{{GET POINTER TO STRING{14519
*
*      MERGE HERE AFTER EVALUATING EXPRESSION WITH STRING VALUE
*
{PSTR1{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{14523
{{MOV{3,R$PMS{7,XR{{LOAD SUBJECT STRING POINTER{14524
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{14525
{{ADD{13,SCLEN(XL){8,WB{{COMPUTE NEW CURSOR POSITION{14526
{{BGT{8,WB{3,PMSSL{6,FAILP{FAIL IF PAST END OF STRING{14527
{{MOV{8,WB{3,PSAVC{{SAVE UPDATED CURSOR{14528
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARS TO COMPARE{14529
{{PLC{7,XL{{{POINT TO CHARS OF TEST STRING{14530
{{CMC{6,FAILP{6,FAILP{{COMPARE, FAIL IF NOT EQUAL{14531
{{MOV{3,PSAVE{7,XR{{IF ALL MATCHED, RESTORE NODE PTR{14532
{{MOV{3,PSAVC{8,WB{{RESTORE UPDATED CURSOR{14533
{{BRN{6,SUCCP{{{AND SUCCEED{14534
{{EJC{{{{{14535
*
*      SUCCEED
*
*      SEE SECTION ON COMPOUND PATTERNS FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE
*
*      NO PARAMETERS
*
{P$SUC{ENT{2,BL$P0{{{P0BLK{14544
{{MOV{8,WB{11,-(XS){{STACK CURSOR{14545
{{MOV{7,XR{11,-(XS){{STACK POINTER TO THIS NODE{14546
{{BRN{6,SUCCP{{{SUCCEED MATCHING NULL{14547
{{EJC{{{{{14548
*
*      TAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$TAB{ENT{2,BL$P1{{{P1BLK{14554
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PTAB1{BGT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF TOO FAR ALREADY{14558
{{MOV{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR POSITION{14559
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{14560
{{BRN{6,FAILP{{{ELSE FAIL{14561
{{EJC{{{{{14562
*
*      TAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$TBD{ENT{2,BL$P1{{{P1BLK{14568
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14569
{{ERR{1,057{26,TAB evaluated argument is not integer{{{14570
{{ERR{1,058{26,TAB evaluated argument is negative or too large{{{14571
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14572
{{PPM{6,PTAB1{{{MERGE WITH NORMAL CASE IF OK{14573
{{EJC{{{{{14574
*
*      ANCHOR MOVEMENT
*
*      NO PARAMETERS (DUMMY NODE)
*
{P$UNA{ENT{{{{ENTRY POINT{14580
{{MOV{8,WB{7,XR{{COPY INITIAL PATTERN NODE POINTER{14581
{{MOV{9,(XS){8,WB{{GET INITIAL CURSOR{14582
{{BEQ{8,WB{3,PMSSL{6,EXFAL{MATCH FAILS IF AT END OF STRING{14583
{{ICV{8,WB{{{ELSE INCREMENT CURSOR{14584
{{MOV{8,WB{9,(XS){{STORE INCREMENTED CURSOR{14585
{{MOV{7,XR{11,-(XS){{RESTACK INITIAL NODE PTR{14586
{{MOV{21,=NDUNA{11,-(XS){{RESTACK UNANCHORED NODE{14587
{{BRI{9,(XR){{{REMATCH FIRST NODE{14588
{{EJC{{{{{14589
*
*      END OF PATTERN MATCH ROUTINES
*
*      THE FOLLOWING ENTRY POINT MARKS THE END OF THE PATTERN
*      MATCHING ROUTINES AND ALSO THE END OF THE ENTRY POINTS
*      REFERENCED FROM THE FIRST WORD OF BLOCKS IN DYNAMIC STORE
*
{P$YYY{ENT{2,BL$$I{{{MARK LAST ENTRY IN PATTERN SECTION{14597
{{TTL{27,S P I T B O L -- SNOBOL4 BUILT-IN LABEL ROUTINES{{{{14598
*
*      THE FOLLOWING SECTION CONTAINS THE ROUTINES FOR LABELS
*      WHICH HAVE A PREDEFINED MEANING IN SNOBOL4.
*
*      CONTROL IS PASSED DIRECTLY TO THE LABEL NAME ENTRY POINT.
*
*      ENTRY NAMES ARE OF THE FORM L$XXX WHERE XXX IS THE THREE
*      LETTER VARIABLE NAME IDENTIFIER.
*
*      ENTRIES ARE IN ALPHABETICAL ORDER
{{EJC{{{{{14609
*
*      ABORT
*
{L$ABO{ENT{{{{ENTRY POINT{14613
*
*      MERGE HERE IF EXECUTION TERMINATES IN ERROR
*
{LABO1{MOV{3,KVERT{8,WA{{LOAD ERROR CODE{14617
{{BZE{8,WA{6,LABO3{{JUMP IF NO ERROR HAS OCCURED{14618
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{14620
{{MOV{3,KVSTN{8,WC{{CURRENT STATEMENT{14624
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{14625
{{MOV{3,R$COD{7,XR{{CURRENT CODE BLOCK{14628
{{MOV{13,CDSLN(XR){8,WC{{LINE NUMBER{14629
{{ZER{8,WB{{{COLUMN NUMBER{14633
{{MOV{3,STAGE{7,XR{{{14634
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{14635
{{PPM{6,STPR4{{{IF SYSTEM DOES NOT WANT PRINT{14636
{{JSR{6,PRTPG{{{ELSE EJECT PRINTER{14638
{{BZE{7,XR{6,LABO2{{DID SYSEA REQUEST PRINT{14640
{{JSR{6,PRTST{{{PRINT TEXT FROM SYSEA{14641
{LABO2{JSR{6,ERMSG{{{PRINT ERROR MESSAGE{14643
{{ZER{7,XR{{{INDICATE NO MESSAGE TO PRINT{14644
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{14645
*
*      HERE IF NO ERROR HAD OCCURED
*
{LABO3{ERB{1,036{26,Goto ABORT with no preceding error{{{14649
{{EJC{{{{{14650
*
*      CONTINUE
*
{L$CNT{ENT{{{{ENTRY POINT{14654
*
*      MERGE HERE AFTER EXECUTION ERROR
*
{LCNT1{MOV{3,R$CNT{7,XR{{LOAD CONTINUATION CODE BLOCK PTR{14658
{{BZE{7,XR{6,LCNT3{{JUMP IF NO PREVIOUS ERROR{14659
{{ZER{3,R$CNT{{{CLEAR FLAG{14660
{{MOV{7,XR{3,R$COD{{ELSE STORE AS NEW CODE BLOCK PTR{14661
{{BNE{9,(XR){22,=B$CDC{6,LCNT2{JUMP IF NOT COMPLEX GO{14662
{{MOV{3,STXOC{8,WA{{GET OFFSET OF ERROR{14663
{{BGE{8,WA{3,STXOF{6,LCNT4{JUMP IF ERROR IN GOTO EVALUATION{14664
*
*      HERE IF ERROR DID NOT OCCUR IN COMPLEX FAILURE GOTO
*
{LCNT2{ADD{3,STXOF{7,XR{{ADD FAILURE OFFSET{14668
{{LCP{7,XR{{{LOAD CODE POINTER{14669
{{MOV{3,FLPTR{7,XS{{RESET STACK POINTER{14670
{{LCW{7,XR{{{GET NEXT CODE WORD{14671
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14672
*
*      HERE IF NO PREVIOUS ERROR
*
{LCNT3{ICV{3,ERRFT{{{FATAL ERROR{14676
{{ERB{1,037{26,Goto CONTINUE with no preceding error{{{14677
*
*      HERE IF ERROR IN EVALUATION OF FAILURE GOTO.
*      CANNOT CONTINUE BACK TO FAILURE GOTO!
*
{LCNT4{ICV{3,ERRFT{{{FATAL ERROR{14682
{{ERB{1,332{26,Goto CONTINUE with error in failure goto{{{14683
{{EJC{{{{{14684
*
*      END
*
{L$END{ENT{{{{ENTRY POINT{14688
*
*      MERGE HERE FROM END CODE CIRCUIT
*
{LEND0{MOV{21,=ENDMS{7,XR{{POINT TO MESSAGE /NORMAL TERM.../{14692
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{14693
{{EJC{{{{{14694
*
*      FRETURN
*
{L$FRT{ENT{{{{ENTRY POINT{14698
{{MOV{21,=SCFRT{8,WA{{POINT TO STRING /FRETURN/{14699
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14700
{{EJC{{{{{14701
*
*      NRETURN
*
{L$NRT{ENT{{{{ENTRY POINT{14705
{{MOV{21,=SCNRT{8,WA{{POINT TO STRING /NRETURN/{14706
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14707
{{EJC{{{{{14708
*
*      RETURN
*
{L$RTN{ENT{{{{ENTRY POINT{14712
{{MOV{21,=SCRTN{8,WA{{POINT TO STRING /RETURN/{14713
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14714
{{EJC{{{{{14715
*
*      SCONTINUE
*
{L$SCN{ENT{{{{ENTRY POINT{14719
{{MOV{3,R$CNT{7,XR{{LOAD CONTINUATION CODE BLOCK PTR{14720
{{BZE{7,XR{6,LSCN2{{JUMP IF NO PREVIOUS ERROR{14721
{{ZER{3,R$CNT{{{CLEAR FLAG{14722
{{BNE{3,KVERT{18,=NM320{6,LSCN1{ERROR MUST BE USER INTERRUPT{14723
{{BEQ{3,KVERT{18,=NM321{6,LSCN2{DETECT SCONTINUE LOOP{14724
{{MOV{7,XR{3,R$COD{{ELSE STORE AS NEW CODE BLOCK PTR{14725
{{ADD{3,STXOC{7,XR{{ADD RESUME OFFSET{14726
{{LCP{7,XR{{{LOAD CODE POINTER{14727
{{LCW{7,XR{{{GET NEXT CODE WORD{14728
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14729
*
*      HERE IF NO USER INTERRUPT
*
{LSCN1{ICV{3,ERRFT{{{FATAL ERROR{14733
{{ERB{1,331{26,Goto SCONTINUE with no user interrupt{{{14734
*
*      HERE IF IN SCONTINUE LOOP OR IF NO PREVIOUS ERROR
*
{LSCN2{ICV{3,ERRFT{{{FATAL ERROR{14738
{{ERB{1,321{26,Goto SCONTINUE with no preceding error{{{14739
{{EJC{{{{{14740
*
*      UNDEFINED LABEL
*
{L$UND{ENT{{{{ENTRY POINT{14744
{{ERB{1,038{26,Goto undefined label{{{14745
{{TTL{27,S P I T B O L -- PREDEFINED SNOBOL4 FUNCTIONS{{{{14746
*
*      THE FOLLOWING SECTION CONTAINS CODING FOR FUNCTIONS
*      WHICH ARE PREDEFINED AND AVAILABLE AT THE SNOBOL LEVEL.
*
*      THESE ROUTINES RECEIVE CONTROL DIRECTLY FROM THE CODE OR
*      INDIRECTLY THROUGH THE O$FNC, O$FNS OR CFUNC ROUTINES.
*      IN BOTH CASES THE CONDITIONS ON ENTRY ARE AS FOLLOWS
*
*      THE ARGUMENTS ARE ON THE STACK. THE NUMBER OF ARGUMENTS
*      HAS BEEN ADJUSTED TO CORRESPOND TO THE SVBLK SVNAR FIELD.
*
*      IN CERTAIN FUNCTIONS THE DIRECT CALL IS NOT PERMITTED
*      AND IN THESE INSTANCES WE ALSO HAVE.
*
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS IN CALL
*
*      CONTROL RETURNS BY PLACING THE FUNCTION RESULT VALUE ON
*      ON THE STACK AND CONTINUING EXECUTION WITH THE NEXT
*      WORD FROM THE GENERATED CODE.
*
*      THE NAMES OF THE ENTRY POINTS OF THESE FUNCTIONS ARE OF
*      THE FORM S$XXX WHERE XXX IS THE THREE LETTER CODE FOR
*      THE SYSTEM VARIABLE NAME. THE FUNCTIONS ARE IN ORDER
*      ALPHABETICALLY BY THEIR ENTRY NAMES.
{{EJC{{{{{14771
*
*      ANY
*
{S$ANY{ENT{{{{ENTRY POINT{14825
{{MOV{22,=P$ANS{8,WB{{SET PCODE FOR SINGLE CHAR CASE{14826
{{MOV{22,=P$ANY{7,XL{{PCODE FOR MULTI-CHAR CASE{14827
{{MOV{22,=P$AYD{8,WC{{PCODE FOR EXPRESSION CASE{14828
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{14829
{{ERR{1,059{26,ANY argument is not a string or expression{{{14830
{{MOV{7,XR{11,-(XS){{STACK RESULT{14831
{{LCW{7,XR{{{GET NEXT CODE WORD{14832
{{BRI{9,(XR){{{EXECUTE IT{14833
{{EJC{{{{{14834
*
*      APPLY
*
*      APPLY DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S$APP{ENT{{{{ENTRY POINT{14860
{{BZE{8,WA{6,SAPP3{{JUMP IF NO ARGUMENTS{14861
{{DCV{8,WA{{{ELSE GET APPLIED FUNC ARG COUNT{14862
{{MOV{8,WA{8,WB{{COPY{14863
{{WTB{8,WB{{{CONVERT TO BYTES{14864
{{MOV{7,XS{7,XT{{COPY STACK POINTER{14865
{{ADD{8,WB{7,XT{{POINT TO FUNCTION ARGUMENT ON STACK{14866
{{MOV{9,(XT){7,XR{{LOAD FUNCTION PTR (APPLY 1ST ARG){14867
{{BZE{8,WA{6,SAPP2{{JUMP IF NO ARGS FOR APPLIED FUNC{14868
{{LCT{8,WB{8,WA{{ELSE SET COUNTER FOR LOOP{14869
*
*      LOOP TO MOVE ARGUMENTS UP ON STACK
*
{SAPP1{DCA{7,XT{{{POINT TO NEXT ARGUMENT{14873
{{MOV{9,(XT){13,NUM01(XT){{MOVE ARGUMENT UP{14874
{{BCT{8,WB{6,SAPP1{{LOOP TILL ALL MOVED{14875
*
*      MERGE HERE TO CALL FUNCTION (WA = NUMBER OF ARGUMENTS)
*
{SAPP2{ICA{7,XS{{{ADJUST STACK PTR FOR APPLY 1ST ARG{14879
{{JSR{6,GTNVR{{{GET VARIABLE BLOCK ADDR FOR FUNC{14880
{{PPM{6,SAPP3{{{JUMP IF NOT NATURAL VARIABLE{14881
{{MOV{13,VRFNC(XR){7,XL{{ELSE POINT TO FUNCTION BLOCK{14882
{{BRN{6,CFUNC{{{GO CALL APPLIED FUNCTION{14883
*
*      HERE FOR INVALID FIRST ARGUMENT
*
{SAPP3{ERB{1,060{26,APPLY first arg is not natural variable name{{{14887
{{EJC{{{{{14888
*
*      ARBNO
*
*      ARBNO BUILDS A COMPOUND PATTERN. SEE DESCRIPTION AT
*      START OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S$ABN{ENT{{{{ENTRY POINT{14895
{{ZER{7,XR{{{SET PARM1 = 0 FOR THE MOMENT{14896
{{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATIVE NODE{14897
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{14898
{{MOV{7,XR{7,XL{{SAVE PTR TO ALTERNATIVE PATTERN{14899
{{MOV{22,=P$ABC{8,WB{{PCODE FOR P$ABC{14900
{{ZER{7,XR{{{P0BLK{14901
{{JSR{6,PBILD{{{BUILD P$ABC NODE{14902
{{MOV{7,XL{13,PTHEN(XR){{PUT ALTERNATIVE NODE AS SUCCESSOR{14903
{{MOV{7,XL{8,WA{{REMEMBER ALTERNATIVE NODE POINTER{14904
{{MOV{7,XR{7,XL{{COPY P$ABC NODE PTR{14905
{{MOV{9,(XS){7,XR{{LOAD ARBNO ARGUMENT{14906
{{MOV{8,WA{9,(XS){{STACK ALTERNATIVE NODE POINTER{14907
{{JSR{6,GTPAT{{{GET ARBNO ARGUMENT AS PATTERN{14908
{{ERR{1,061{26,ARBNO argument is not pattern{{{14909
{{JSR{6,PCONC{{{CONCAT ARG WITH P$ABC NODE{14910
{{MOV{7,XR{7,XL{{REMEMBER PTR TO CONCD PATTERNS{14911
{{MOV{22,=P$ABA{8,WB{{PCODE FOR P$ABA{14912
{{ZER{7,XR{{{P0BLK{14913
{{JSR{6,PBILD{{{BUILD P$ABA NODE{14914
{{MOV{7,XL{13,PTHEN(XR){{CONCATENATE NODES{14915
{{MOV{9,(XS){7,XL{{RECALL PTR TO ALTERNATIVE NODE{14916
{{MOV{7,XR{13,PARM1(XL){{POINT ALTERNATIVE BACK TO ARGUMENT{14917
{{LCW{7,XR{{{GET NEXT CODE WORD{14918
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14919
{{EJC{{{{{14920
*
*      ARG
*
{S$ARG{ENT{{{{ENTRY POINT{14924
{{JSR{6,GTSMI{{{GET SECOND ARG AS SMALL INTEGER{14925
{{ERR{1,062{26,ARG second argument is not integer{{{14926
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE OR NEGATIVE{14927
{{MOV{7,XR{8,WA{{SAVE ARGUMENT NUMBER{14928
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{14929
{{JSR{6,GTNVR{{{LOCATE VRBLK{14930
{{PPM{6,SARG1{{{JUMP IF NOT NATURAL VARIABLE{14931
{{MOV{13,VRFNC(XR){7,XR{{ELSE LOAD FUNCTION BLOCK POINTER{14932
{{BNE{9,(XR){22,=B$PFC{6,SARG1{JUMP IF NOT PROGRAM DEFINED{14933
{{BZE{8,WA{6,EXFAL{{FAIL IF ARG NUMBER IS ZERO{14934
{{BGT{8,WA{13,FARGS(XR){6,EXFAL{FAIL IF ARG NUMBER IS TOO LARGE{14935
{{WTB{8,WA{{{ELSE CONVERT TO BYTE OFFSET{14936
{{ADD{8,WA{7,XR{{POINT TO ARGUMENT SELECTED{14937
{{MOV{13,PFAGB(XR){7,XR{{LOAD ARGUMENT VRBLK POINTER{14938
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{14939
*
*      HERE IF 1ST ARGUMENT IS BAD
*
{SARG1{ERB{1,063{26,ARG first argument is not program function name{{{14943
{{EJC{{{{{14944
*
*      ARRAY
*
{S$ARR{ENT{{{{ENTRY POINT{14948
{{MOV{10,(XS)+{7,XL{{LOAD INITIAL ELEMENT VALUE{14949
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{14950
{{JSR{6,GTINT{{{CONVERT FIRST ARG TO INTEGER{14951
{{PPM{6,SAR02{{{JUMP IF NOT INTEGER{14952
*
*      HERE FOR INTEGER FIRST ARGUMENT, BUILD VCBLK
*
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{14956
{{ILE{6,SAR10{{{JUMP IF ZERO OR NEG (BAD DIMENSION){14957
{{MFI{8,WA{6,SAR11{{ELSE CONVERT TO ONE WORD, TEST OVFL{14958
{{JSR{6,VMAKE{{{CREATE VECTOR{14959
{{PPM{6,SAR11{{{FAIL IF TOO LARGE{14960
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{14961
{{EJC{{{{{14962
*
*      ARRAY (CONTINUED)
*
*      HERE IF FIRST ARGUMENT IS NOT AN INTEGER
*
{SAR02{MOV{7,XR{11,-(XS){{REPLACE ARGUMENT ON STACK{14968
{{JSR{6,XSCNI{{{INITIALIZE SCAN OF FIRST ARGUMENT{14969
{{ERR{1,064{26,ARRAY first argument is not integer or string{{{14970
{{PPM{6,EXNUL{{{DUMMY (UNUSED) NULL STRING EXIT{14971
{{MOV{3,R$XSC{11,-(XS){{SAVE PROTOTYPE POINTER{14972
{{MOV{7,XL{11,-(XS){{SAVE DEFAULT VALUE{14973
{{ZER{3,ARCDM{{{ZERO COUNT OF DIMENSIONS{14974
{{ZER{3,ARPTR{{{ZERO OFFSET TO INDICATE PASS ONE{14975
{{LDI{4,INTV1{{{LOAD INTEGER ONE{14976
{{STI{3,ARNEL{{{INITIALIZE ELEMENT COUNT{14977
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. THE FIRST TIME
*      (ARPTR EQ 0), IT IS USED TO COUNT THE NUMBER OF ELEMENTS
*      AND NUMBER OF DIMENSIONS. THE SECOND TIME (ARPTR GT 0) IS
*      USED TO ACTUALLY FILL IN THE DIM,LBD FIELDS OF THE ARBLK.
*
{SAR03{LDI{4,INTV1{{{LOAD ONE AS DEFAULT LOW BOUND{14984
{{STI{3,ARSVL{{{SAVE AS LOW BOUND{14985
{{MOV{18,=CH$CL{8,WC{{SET DELIMITER ONE = COLON{14986
{{MOV{18,=CH$CM{7,XL{{SET DELIMITER TWO = COMMA{14987
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{14988
{{JSR{6,XSCAN{{{SCAN NEXT BOUND{14989
{{BNE{8,WA{18,=NUM01{6,SAR04{JUMP IF NOT COLON{14990
*
*      HERE WE HAVE A COLON ENDING A LOW BOUND
*
{{JSR{6,GTINT{{{CONVERT LOW BOUND{14994
{{ERR{1,065{26,ARRAY first argument lower bound is not integer{{{14995
{{LDI{13,ICVAL(XR){{{LOAD VALUE OF LOW BOUND{14996
{{STI{3,ARSVL{{{STORE LOW BOUND VALUE{14997
{{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{14998
{{MOV{8,WC{7,XL{{AND DELIMITER TWO = COMMA{14999
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{15000
{{JSR{6,XSCAN{{{SCAN HIGH BOUND{15001
{{EJC{{{{{15002
*
*      ARRAY (CONTINUED)
*
*      MERGE HERE TO PROCESS UPPER BOUND
*
{SAR04{JSR{6,GTINT{{{CONVERT HIGH BOUND TO INTEGER{15008
{{ERR{1,066{26,ARRAY first argument upper bound is not integer{{{15009
{{LDI{13,ICVAL(XR){{{GET HIGH BOUND{15010
{{SBI{3,ARSVL{{{SUBTRACT LOWER BOUND{15011
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{15012
{{ILT{6,SAR10{{{BAD DIMENSION IF NEGATIVE{15013
{{ADI{4,INTV1{{{ADD 1 TO GET DIMENSION{15014
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{15015
{{MOV{3,ARPTR{7,XL{{LOAD OFFSET (ALSO PASS INDICATOR){15016
{{BZE{7,XL{6,SAR05{{JUMP IF FIRST PASS{15017
*
*      HERE IN SECOND PASS TO STORE LBD AND DIM IN ARBLK
*
{{ADD{9,(XS){7,XL{{POINT TO CURRENT LOCATION IN ARBLK{15021
{{STI{13,CFP$I(XL){{{STORE DIMENSION{15022
{{LDI{3,ARSVL{{{LOAD LOW BOUND{15023
{{STI{9,(XL){{{STORE LOW BOUND{15024
{{ADD{19,*ARDMS{3,ARPTR{{BUMP OFFSET TO NEXT BOUNDS{15025
{{BRN{6,SAR06{{{JUMP TO CHECK FOR END OF BOUNDS{15026
*
*      HERE IN PASS 1
*
{SAR05{ICV{3,ARCDM{{{BUMP DIMENSION COUNT{15030
{{MLI{3,ARNEL{{{MULTIPLY DIMENSION BY COUNT SO FAR{15031
{{IOV{6,SAR11{{{TOO LARGE IF OVERFLOW{15032
{{STI{3,ARNEL{{{ELSE STORE UPDATED ELEMENT COUNT{15033
*
*      MERGE HERE AFTER PROCESSING ONE SET OF BOUNDS
*
{SAR06{BNZ{8,WA{6,SAR03{{LOOP BACK UNLESS END OF BOUNDS{15037
{{BNZ{3,ARPTR{6,SAR09{{JUMP IF END OF PASS 2{15038
{{EJC{{{{{15039
*
*      ARRAY (CONTINUED)
*
*      HERE AT END OF PASS ONE, BUILD ARBLK
*
{{LDI{3,ARNEL{{{GET NUMBER OF ELEMENTS{15045
{{MFI{8,WB{6,SAR11{{GET AS ADDR INTEGER, TEST OVFLO{15046
{{WTB{8,WB{{{ELSE CONVERT TO LENGTH IN BYTES{15047
{{MOV{19,*ARSI${8,WA{{SET SIZE OF STANDARD FIELDS{15048
{{LCT{8,WC{3,ARCDM{{SET DIMENSION COUNT TO CONTROL LOOP{15049
*
*      LOOP TO ALLOW SPACE FOR DIMENSIONS
*
{SAR07{ADD{19,*ARDMS{8,WA{{ALLOW SPACE FOR ONE SET OF BOUNDS{15053
{{BCT{8,WC{6,SAR07{{LOOP BACK TILL ALL ACCOUNTED FOR{15054
{{MOV{8,WA{7,XL{{SAVE SIZE (=AROFS){15055
*
*      NOW ALLOCATE SPACE FOR ARBLK
*
{{ADD{8,WB{8,WA{{ADD SPACE FOR ELEMENTS{15059
{{ICA{8,WA{{{ALLOW FOR ARPRO PROTOTYPE FIELD{15060
{{BGT{8,WA{3,MXLEN{6,SAR11{FAIL IF TOO LARGE{15061
{{JSR{6,ALLOC{{{ELSE ALLOCATE ARBLK{15062
{{MOV{9,(XS){8,WB{{LOAD DEFAULT VALUE{15063
{{MOV{7,XR{9,(XS){{SAVE ARBLK POINTER{15064
{{MOV{8,WA{8,WC{{SAVE LENGTH IN BYTES{15065
{{BTW{8,WA{{{CONVERT LENGTH BACK TO WORDS{15066
{{LCT{8,WA{8,WA{{SET COUNTER TO CONTROL LOOP{15067
*
*      LOOP TO CLEAR ENTIRE ARBLK TO DEFAULT VALUE
*
{SAR08{MOV{8,WB{10,(XR)+{{SET ONE WORD{15071
{{BCT{8,WA{6,SAR08{{LOOP TILL ALL SET{15072
{{EJC{{{{{15073
*
*      ARRAY (CONTINUED)
*
*      NOW SET INITIAL FIELDS OF ARBLK
*
{{MOV{10,(XS)+{7,XR{{RELOAD ARBLK POINTER{15079
{{MOV{9,(XS){8,WB{{LOAD PROTOTYPE{15080
{{MOV{22,=B$ART{9,(XR){{SET TYPE WORD{15081
{{MOV{8,WC{13,ARLEN(XR){{STORE LENGTH IN BYTES{15082
{{ZER{13,IDVAL(XR){{{ZERO ID TILL WE GET IT BUILT{15083
{{MOV{7,XL{13,AROFS(XR){{SET PROTOTYPE FIELD PTR{15084
{{MOV{3,ARCDM{13,ARNDM(XR){{SET NUMBER OF DIMENSIONS{15085
{{MOV{7,XR{8,WC{{SAVE ARBLK POINTER{15086
{{ADD{7,XL{7,XR{{POINT TO PROTOTYPE FIELD{15087
{{MOV{8,WB{9,(XR){{STORE PROTOTYPE PTR IN ARBLK{15088
{{MOV{19,*ARLBD{3,ARPTR{{SET OFFSET FOR PASS 2 BOUNDS SCAN{15089
{{MOV{8,WB{3,R$XSC{{RESET STRING POINTER FOR XSCAN{15090
{{MOV{8,WC{9,(XS){{STORE ARBLK POINTER ON STACK{15091
{{ZER{3,XSOFS{{{RESET OFFSET PTR TO START OF STRING{15092
{{BRN{6,SAR03{{{JUMP BACK TO RESCAN BOUNDS{15093
*
*      HERE AFTER FILLING IN BOUNDS INFORMATION (END PASS TWO)
*
{SAR09{MOV{10,(XS)+{7,XR{{RELOAD POINTER TO ARBLK{15097
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{15098
*
*      HERE FOR BAD DIMENSION
*
{SAR10{ERB{1,067{26,ARRAY dimension is zero, negative or out of range{{{15102
*
*      HERE IF ARRAY IS TOO LARGE
*
{SAR11{ERB{1,068{26,ARRAY size exceeds maximum permitted{{{15106
{{EJC{{{{{15107
*
*      ATAN
*
{S$ATN{ENT{{{{ENTRY POINT{15112
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15113
{{JSR{6,GTREA{{{CONVERT TO REAL{15114
{{ERR{1,301{26,ATAN argument not numeric{{{15115
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15116
{{ATN{{{{TAKE ARCTANGENT{15117
{{BRN{6,EXREA{{{OVERFLOW, OUT OF RANGE NOT POSSIBLE{15118
{{EJC{{{{{15119
{{EJC{{{{{15122
*
*      BACKSPACE
*
{S$BSP{ENT{{{{ENTRY POINT{15126
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{15127
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{15128
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{15129
{{ERR{1,317{26,BACKSPACE file does not exist{{{15130
{{JSR{6,SYSBS{{{CALL BACKSPACE FILE FUNCTION{15131
{{ERR{1,317{26,BACKSPACE file does not exist{{{15132
{{ERR{1,318{26,BACKSPACE file does not permit backspace{{{15133
{{ERR{1,319{26,BACKSPACE caused non-recoverable error{{{15134
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{15135
{{EJC{{{{{15136
*
*      BREAK
*
{S$BRK{ENT{{{{ENTRY POINT{15169
{{MOV{22,=P$BKS{8,WB{{SET PCODE FOR SINGLE CHAR CASE{15170
{{MOV{22,=P$BRK{7,XL{{PCODE FOR MULTI-CHAR CASE{15171
{{MOV{22,=P$BKD{8,WC{{PCODE FOR EXPRESSION CASE{15172
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{15173
{{ERR{1,069{26,BREAK argument is not a string or expression{{{15174
{{MOV{7,XR{11,-(XS){{STACK RESULT{15175
{{LCW{7,XR{{{GET NEXT CODE WORD{15176
{{BRI{9,(XR){{{EXECUTE IT{15177
{{EJC{{{{{15178
*
*      BREAKX
*
*      BREAKX IS A COMPOUND PATTERN. SEE DESCRIPTION AT START
*      OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S$BKX{ENT{{{{ENTRY POINT{15185
{{MOV{22,=P$BKS{8,WB{{PCODE FOR SINGLE CHAR ARGUMENT{15186
{{MOV{22,=P$BRK{7,XL{{PCODE FOR MULTI-CHAR ARGUMENT{15187
{{MOV{22,=P$BXD{8,WC{{PCODE FOR EXPRESSION CASE{15188
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{15189
{{ERR{1,070{26,BREAKX argument is not a string or expression{{{15190
*
*      NOW HOOK BREAKX NODE ON AT FRONT END
*
{{MOV{7,XR{11,-(XS){{SAVE PTR TO BREAK NODE{15194
{{MOV{22,=P$BKX{8,WB{{SET PCODE FOR BREAKX NODE{15195
{{JSR{6,PBILD{{{BUILD IT{15196
{{MOV{9,(XS){13,PTHEN(XR){{SET BREAK NODE AS SUCCESSOR{15197
{{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATION NODE{15198
{{JSR{6,PBILD{{{BUILD (PARM1=ALT=BREAKX NODE){15199
{{MOV{7,XR{8,WA{{SAVE PTR TO ALTERNATION NODE{15200
{{MOV{9,(XS){7,XR{{POINT TO BREAK NODE{15201
{{MOV{8,WA{13,PTHEN(XR){{SET ALTERNATE NODE AS SUCCESSOR{15202
{{LCW{7,XR{{{RESULT ON STACK{15203
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{15204
{{EJC{{{{{15205
*
*      CHAR
*
{S$CHR{ENT{{{{ENTRY POINT{15209
{{JSR{6,GTSMI{{{CONVERT ARG TO INTEGER{15210
{{ERR{1,281{26,CHAR argument not integer{{{15211
{{PPM{6,SCHR1{{{TOO BIG ERROR EXIT{15212
{{BGE{8,WC{18,=CFP$A{6,SCHR1{SEE IF OUT OF RANGE OF HOST SET{15213
{{MOV{18,=NUM01{8,WA{{IF NOT SET SCBLK ALLOCATION{15214
{{MOV{8,WC{8,WB{{SAVE CHAR CODE{15215
{{JSR{6,ALOCS{{{ALLOCATE 1 BAU SCBLK{15216
{{MOV{7,XR{7,XL{{COPY SCBLK POINTER{15217
{{PSC{7,XL{{{GET SET TO STUFF CHAR{15218
{{SCH{8,WB{9,(XL){{STUFF IT{15219
{{CSC{7,XL{{{COMPLETE STORE CHARACTER{15220
{{ZER{7,XL{{{CLEAR SLOP IN XL{15221
{{MOV{7,XR{11,-(XS){{STACK RESULT{15222
{{LCW{7,XR{{{GET NEXT CODE WORD{15223
{{BRI{9,(XR){{{EXECUTE IT{15224
*
*      HERE IF CHAR ARGUMENT IS OUT OF RANGE
*
{SCHR1{ERB{1,282{26,CHAR argument not in range{{{15228
{{EJC{{{{{15229
*
*      CHOP
*
{S$CHP{ENT{{{{ENTRY POINT{15234
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15235
{{JSR{6,GTREA{{{CONVERT TO REAL{15236
{{ERR{1,302{26,CHOP argument not numeric{{{15237
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15238
{{CHP{{{{TRUNCATE TO INTEGER VALUED REAL{15239
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE{15240
{{EJC{{{{{15241
*
*      CLEAR
*
{S$CLR{ENT{{{{ENTRY POINT{15246
{{JSR{6,XSCNI{{{INITIALIZE TO SCAN ARGUMENT{15247
{{ERR{1,071{26,CLEAR argument is not a string{{{15248
{{PPM{6,SCLR2{{{JUMP IF NULL{15249
*
*      LOOP TO SCAN OUT NAMES IN FIRST ARGUMENT. VARIABLES IN
*      THE LIST ARE FLAGGED BY SETTING VRGET OF VRBLK TO ZERO.
*
{SCLR1{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{15254
{{MOV{8,WC{7,XL{{DELIMITER TWO = COMMA{15255
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15256
{{JSR{6,XSCAN{{{SCAN NEXT VARIABLE NAME{15257
{{JSR{6,GTNVR{{{LOCATE VRBLK{15258
{{ERR{1,072{26,CLEAR argument has null variable name{{{15259
{{ZER{13,VRGET(XR){{{ELSE FLAG BY ZEROING VRGET FIELD{15260
{{BNZ{8,WA{6,SCLR1{{LOOP BACK IF STOPPED BY COMMA{15261
*
*      HERE AFTER FLAGGING VARIABLES IN ARGUMENT LIST
*
{SCLR2{MOV{3,HSHTB{8,WB{{POINT TO START OF HASH TABLE{15265
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
{SCLR3{BEQ{8,WB{3,HSHTE{6,EXNUL{EXIT RETURNING NULL IF NONE LEFT{15269
{{MOV{8,WB{7,XR{{ELSE COPY SLOT POINTER{15270
{{ICA{8,WB{{{BUMP SLOT POINTER{15271
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE INTO LOOP{15272
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{SCLR4{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{15276
{{BZE{7,XR{6,SCLR3{{JUMP FOR NEXT BUCKET IF CHAIN END{15277
{{BNZ{13,VRGET(XR){6,SCLR5{{JUMP IF NOT FLAGGED{15278
{{EJC{{{{{15279
*
*      CLEAR (CONTINUED)
*
*      HERE FOR FLAGGED VARIABLE, DO NOT SET VALUE TO NULL
*
{{JSR{6,SETVR{{{FOR FLAGGED VAR, RESTORE VRGET{15285
{{BRN{6,SCLR4{{{AND LOOP BACK FOR NEXT VRBLK{15286
*
*      HERE TO SET VALUE OF A VARIABLE TO NULL
*      PROTECTED VARIABLES (ARB, ETC) ARE EXEMPT
*
{SCLR5{BEQ{13,VRSTO(XR){22,=B$VRE{6,SCLR4{CHECK FOR PROTECTED VARIABLE{15291
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{15292
*
*      LOOP TO LOCATE VALUE AT END OF POSSIBLE TRBLK CHAIN
*
{SCLR6{MOV{7,XL{8,WA{{SAVE BLOCK POINTER{15296
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE FIELD{15297
{{BEQ{9,(XL){22,=B$TRT{6,SCLR6{LOOP BACK IF TRAPPED{15298
*
*      NOW STORE THE NULL VALUE
*
{{MOV{8,WA{7,XL{{RESTORE BLOCK POINTER{15302
{{MOV{21,=NULLS{13,VRVAL(XL){{STORE NULL CONSTANT VALUE{15303
{{BRN{6,SCLR4{{{LOOP BACK FOR NEXT VRBLK{15304
{{EJC{{{{{15305
*
*      CODE
*
{S$COD{ENT{{{{ENTRY POINT{15309
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15310
{{JSR{6,GTCOD{{{CONVERT TO CODE{15311
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS IMPOSSIBLE{15312
{{MOV{7,XR{11,-(XS){{STACK RESULT{15313
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15314
{{LCW{7,XR{{{GET NEXT CODE WORD{15315
{{BRI{9,(XR){{{EXECUTE IT{15316
{{EJC{{{{{15317
*
*      COLLECT
*
{S$COL{ENT{{{{ENTRY POINT{15321
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15322
{{JSR{6,GTINT{{{CONVERT TO INTEGER{15323
{{ERR{1,073{26,COLLECT argument is not integer{{{15324
{{LDI{13,ICVAL(XR){{{LOAD COLLECT ARGUMENT{15325
{{STI{3,CLSVI{{{SAVE COLLECT ARGUMENT{15326
{{ZER{8,WB{{{SET NO MOVE UP{15327
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15328
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{15330
{{JSR{6,GBCOL{{{PERFORM GARBAGE COLLECTION{15331
{{MOV{7,XR{3,DNAMS{{RECORD NEW SEDIMENT SIZE{15332
{{MOV{3,DNAME{8,WA{{POINT TO END OF MEMORY{15336
{{SUB{3,DNAMP{8,WA{{SUBTRACT NEXT LOCATION{15337
{{BTW{8,WA{{{CONVERT BYTES TO WORDS{15338
{{MTI{8,WA{{{CONVERT WORDS AVAILABLE AS INTEGER{15339
{{SBI{3,CLSVI{{{SUBTRACT ARGUMENT{15340
{{IOV{6,EXFAL{{{FAIL IF OVERFLOW{15341
{{ILT{6,EXFAL{{{FAIL IF NOT ENOUGH{15342
{{ADI{3,CLSVI{{{ELSE RECOMPUTE AVAILABLE{15343
{{BRN{6,EXINT{{{AND EXIT WITH INTEGER RESULT{15344
{{EJC{{{{{15345
*
*      CONVERT
*
{S$CNV{ENT{{{{ENTRY POINT{15374
{{JSR{6,GTSTG{{{CONVERT SECOND ARGUMENT TO STRING{15375
{{PPM{6,SCV29{{{ERROR IF SECOND ARGUMENT NOT STRING{15376
{{BZE{8,WA{6,SCV29{{OR IF NULL STRING{15377
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{15379
{{MOV{9,(XS){7,XL{{LOAD FIRST ARGUMENT{15381
{{BNE{9,(XL){22,=B$PDT{6,SCV01{JUMP IF NOT PROGRAM DEFINED{15382
*
*      HERE FOR PROGRAM DEFINED DATATYPE
*
{{MOV{13,PDDFP(XL){7,XL{{POINT TO DFBLK{15386
{{MOV{13,DFNAM(XL){7,XL{{LOAD DATATYPE NAME{15387
{{JSR{6,IDENT{{{COMPARE WITH SECOND ARG{15388
{{PPM{6,EXITS{{{EXIT IF IDENT WITH ARG AS RESULT{15389
{{BRN{6,EXFAL{{{ELSE FAIL{15390
*
*      HERE IF NOT PROGRAM DEFINED DATATYPE
*
{SCV01{MOV{7,XR{11,-(XS){{SAVE STRING ARGUMENT{15394
{{MOV{21,=SVCTB{7,XL{{POINT TO TABLE OF NAMES TO COMPARE{15395
{{ZER{8,WB{{{INITIALIZE COUNTER{15396
{{MOV{8,WA{8,WC{{SAVE LENGTH OF ARGUMENT STRING{15397
*
*      LOOP THROUGH TABLE ENTRIES
*
{SCV02{MOV{10,(XL)+{7,XR{{LOAD NEXT TABLE ENTRY, BUMP POINTER{15401
{{BZE{7,XR{6,EXFAL{{FAIL IF ZERO MARKING END OF LIST{15402
{{BNE{8,WC{13,SCLEN(XR){6,SCV05{JUMP IF WRONG LENGTH{15403
{{MOV{7,XL{3,CNVTP{{ELSE STORE TABLE POINTER{15404
{{PLC{7,XR{{{POINT TO CHARS OF TABLE ENTRY{15405
{{MOV{9,(XS){7,XL{{LOAD POINTER TO STRING ARGUMENT{15406
{{PLC{7,XL{{{POINT TO CHARS OF STRING ARG{15407
{{MOV{8,WC{8,WA{{SET NUMBER OF CHARS TO COMPARE{15408
{{CMC{6,SCV04{6,SCV04{{COMPARE, JUMP IF NO MATCH{15409
{{EJC{{{{{15410
*
*      CONVERT (CONTINUED)
*
*      HERE WE HAVE A MATCH
*
{SCV03{MOV{8,WB{7,XL{{COPY ENTRY NUMBER{15416
{{ICA{7,XS{{{POP STRING ARG OFF STACK{15417
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{15418
{{BSW{7,XL{2,CNVTT{{JUMP TO APPROPRIATE ROUTINE{15419
{{IFF{1,0{6,SCV06{{STRING{15437
{{IFF{1,1{6,SCV07{{INTEGER{15437
{{IFF{1,2{6,SCV09{{NAME{15437
{{IFF{1,3{6,SCV10{{PATTERN{15437
{{IFF{1,4{6,SCV11{{ARRAY{15437
{{IFF{1,5{6,SCV19{{TABLE{15437
{{IFF{1,6{6,SCV25{{EXPRESSION{15437
{{IFF{1,7{6,SCV26{{CODE{15437
{{IFF{1,8{6,SCV27{{NUMERIC{15437
{{IFF{2,CNVRT{6,SCV08{{REAL{15437
{{ESW{{{{END OF SWITCH TABLE{15437
*
*      HERE IF NO MATCH WITH TABLE ENTRY
*
{SCV04{MOV{3,CNVTP{7,XL{{RESTORE TABLE POINTER, MERGE{15441
*
*      MERGE HERE IF LENGTHS DID NOT MATCH
*
{SCV05{ICV{8,WB{{{BUMP ENTRY NUMBER{15445
{{BRN{6,SCV02{{{LOOP BACK TO CHECK NEXT ENTRY{15446
*
*      HERE TO CONVERT TO STRING
*
{SCV06{MOV{7,XR{11,-(XS){{REPLACE STRING ARGUMENT ON STACK{15450
{{JSR{6,GTSTG{{{CONVERT TO STRING{15451
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15452
{{MOV{7,XR{11,-(XS){{STACK RESULT{15453
{{LCW{7,XR{{{GET NEXT CODE WORD{15454
{{BRI{9,(XR){{{EXECUTE IT{15455
{{EJC{{{{{15456
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT TO INTEGER
*
{SCV07{JSR{6,GTINT{{{CONVERT TO INTEGER{15462
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15463
{{MOV{7,XR{11,-(XS){{STACK RESULT{15464
{{LCW{7,XR{{{GET NEXT CODE WORD{15465
{{BRI{9,(XR){{{EXECUTE IT{15466
*
*      HERE TO CONVERT TO REAL
*
{SCV08{JSR{6,GTREA{{{CONVERT TO REAL{15472
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15473
{{MOV{7,XR{11,-(XS){{STACK RESULT{15474
{{LCW{7,XR{{{GET NEXT CODE WORD{15475
{{BRI{9,(XR){{{EXECUTE IT{15476
*
*      HERE TO CONVERT TO NAME
*
{SCV09{BEQ{9,(XR){22,=B$NML{6,EXIXR{RETURN IF ALREADY A NAME{15481
{{JSR{6,GTNVR{{{ELSE TRY STRING TO NAME CONVERT{15482
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15483
{{BRN{6,EXVNM{{{ELSE EXIT BUILDING NMBLK FOR VRBLK{15484
*
*      HERE TO CONVERT TO PATTERN
*
{SCV10{JSR{6,GTPAT{{{CONVERT TO PATTERN{15488
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15489
{{MOV{7,XR{11,-(XS){{STACK RESULT{15490
{{LCW{7,XR{{{GET NEXT CODE WORD{15491
{{BRI{9,(XR){{{EXECUTE IT{15492
*
*      CONVERT TO ARRAY
*
*      IF THE FIRST ARGUMENT IS A TABLE, THEN WE GO THROUGH
*      AN INTERMEDIATE ARRAY OF ADDRESSES THAT IS SORTED TO
*      PROVIDE A RESULT ORDERED BY TIME OF ENTRY IN THE
*      ORIGINAL TABLE.  SEE C3.762.
*
{SCV11{MOV{7,XR{11,-(XS){{SAVE ARGUMENT ON STACK{15501
{{ZER{8,WA{{{USE TABLE CHAIN BLOCK ADDRESSES{15502
{{JSR{6,GTARR{{{GET AN ARRAY{15503
{{PPM{6,EXFAL{{{FAIL IF EMPTY TABLE{15504
{{PPM{6,EXFAL{{{FAIL IF NOT CONVERTIBLE{15505
{{MOV{10,(XS)+{7,XL{{RELOAD ORIGINAL ARG{15506
{{BNE{9,(XL){22,=B$TBT{6,EXSID{EXIT IF ORIGINAL NOT A TABLE{15507
{{MOV{7,XR{11,-(XS){{SORT THE INTERMEDIATE ARRAY{15508
{{MOV{21,=NULLS{11,-(XS){{ON FIRST COLUMN{15509
{{ZER{8,WA{{{SORT ASCENDING{15510
{{JSR{6,SORTA{{{DO SORT{15511
{{PPM{6,EXFAL{{{IF SORT FAILS, SO SHALL WE{15512
{{MOV{7,XR{8,WB{{SAVE ARRAY RESULT{15513
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){15514
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{15515
{{LCT{8,WA{8,WA{{COPY TO CONTROL LOOP{15516
{{ADD{19,*ARVL2{7,XR{{POINT TO FIRST ELEMENT IN ARRAY{15517
*
*      HERE FOR EACH ROW OF THIS 2-COLUMN ARRAY
*
{SCV12{MOV{9,(XR){7,XL{{GET TEBLK ADDRESS{15521
{{MOV{13,TESUB(XL){10,(XR)+{{REPLACE WITH SUBSCRIPT{15522
{{MOV{13,TEVAL(XL){10,(XR)+{{REPLACE WITH VALUE{15523
{{BCT{8,WA{6,SCV12{{LOOP TILL ALL COPIED OVER{15524
{{MOV{8,WB{7,XR{{RETRIEVE ARRAY ADDRESS{15525
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{15526
*
*      CONVERT TO TABLE
*
{SCV19{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{15530
{{MOV{7,XR{11,-(XS){{REPLACE ARBLK POINTER ON STACK{15531
{{BEQ{8,WA{22,=B$TBT{6,EXITS{RETURN ARG IF ALREADY A TABLE{15532
{{BNE{8,WA{22,=B$ART{6,EXFAL{ELSE FAIL IF NOT AN ARRAY{15533
{{EJC{{{{{15534
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT AN ARRAY TO TABLE
*
{{BNE{13,ARNDM(XR){18,=NUM02{6,EXFAL{FAIL IF NOT 2-DIM ARRAY{15540
{{LDI{13,ARDM2(XR){{{LOAD DIM 2{15541
{{SBI{4,INTV2{{{SUBTRACT 2 TO COMPARE{15542
{{INE{6,EXFAL{{{FAIL IF DIM2 NOT 2{15543
*
*      HERE WE HAVE AN ARBLK OF THE RIGHT SHAPE
*
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){15547
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{15548
{{LCT{8,WB{8,WA{{COPY TO CONTROL LOOP{15549
{{ADD{18,=TBSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{15550
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15551
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{15552
{{MOV{7,XR{8,WC{{COPY TBBLK POINTER{15553
{{MOV{7,XR{11,-(XS){{SAVE TBBLK POINTER{15554
{{MOV{22,=B$TBT{10,(XR)+{{STORE TYPE WORD{15555
{{ZER{10,(XR)+{{{STORE ZERO FOR IDVAL FOR NOW{15556
{{MOV{8,WA{10,(XR)+{{STORE LENGTH{15557
{{MOV{21,=NULLS{10,(XR)+{{NULL INITIAL LOOKUP VALUE{15558
*
*      LOOP TO INITIALIZE BUCKET PTRS TO POINT TO TABLE
*
{SCV20{MOV{8,WC{10,(XR)+{{SET BUCKET PTR TO POINT TO TBBLK{15562
{{BCT{8,WB{6,SCV20{{LOOP TILL ALL INITIALIZED{15563
{{MOV{19,*ARVL2{8,WB{{SET OFFSET TO FIRST ARBLK ELEMENT{15564
*
*      LOOP TO COPY ELEMENTS FROM ARRAY TO TABLE
*
{SCV21{MOV{13,NUM01(XS){7,XL{{POINT TO ARBLK{15568
{{BEQ{8,WB{13,ARLEN(XL){6,SCV24{JUMP IF ALL MOVED{15569
{{ADD{8,WB{7,XL{{ELSE POINT TO CURRENT LOCATION{15570
{{ADD{19,*NUM02{8,WB{{BUMP OFFSET{15571
{{MOV{9,(XL){7,XR{{LOAD SUBSCRIPT NAME{15572
{{DCA{7,XL{{{ADJUST PTR TO MERGE (TRVAL=1+1){15573
{{EJC{{{{{15574
*
*      CONVERT (CONTINUED)
*
*      LOOP TO CHASE DOWN TRBLK CHAIN FOR VALUE
*
{SCV22{MOV{13,TRVAL(XL){7,XL{{POINT TO NEXT VALUE{15580
{{BEQ{9,(XL){22,=B$TRT{6,SCV22{LOOP BACK IF TRAPPED{15581
*
*      HERE WITH NAME IN XR, VALUE IN XL
*
{SCV23{MOV{7,XL{11,-(XS){{STACK VALUE{15585
{{MOV{13,NUM01(XS){7,XL{{LOAD TBBLK POINTER{15586
{{JSR{6,TFIND{{{BUILD TEBLK (NOTE WB GT 0 BY NAME){15587
{{PPM{6,EXFAL{{{FAIL IF ACESS FAILS{15588
{{MOV{10,(XS)+{13,TEVAL(XL){{STORE VALUE IN TEBLK{15589
{{BRN{6,SCV21{{{LOOP BACK FOR NEXT ELEMENT{15590
*
*      HERE AFTER MOVING ALL ELEMENTS TO TBBLK
*
{SCV24{MOV{10,(XS)+{7,XR{{LOAD TBBLK POINTER{15594
{{ICA{7,XS{{{POP ARBLK POINTER{15595
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{15596
*
*      CONVERT TO EXPRESSION
*
{SCV25{ZER{8,WB{{{BY VALUE{15601
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{15602
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15606
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15607
{{MOV{7,XR{11,-(XS){{STACK RESULT{15608
{{LCW{7,XR{{{GET NEXT CODE WORD{15609
{{BRI{9,(XR){{{EXECUTE IT{15610
*
*      CONVERT TO CODE
*
{SCV26{JSR{6,GTCOD{{{CONVERT TO CODE{15614
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS NOT POSSIBLE{15615
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15616
{{MOV{7,XR{11,-(XS){{STACK RESULT{15617
{{LCW{7,XR{{{GET NEXT CODE WORD{15618
{{BRI{9,(XR){{{EXECUTE IT{15619
*
*      CONVERT TO NUMERIC
*
{SCV27{JSR{6,GTNUM{{{CONVERT TO NUMERIC{15623
{{PPM{6,EXFAL{{{FAIL IF UNCONVERTIBLE{15624
{SCV31{MOV{7,XR{11,-(XS){{STACK RESULT{15625
{{LCW{7,XR{{{GET NEXT CODE WORD{15626
{{BRI{9,(XR){{{EXECUTE IT{15627
{{EJC{{{{{15628
*
*      SECOND ARGUMENT NOT STRING OR NULL
*
{SCV29{ERB{1,074{26,CONVERT second argument is not a string{{{15654
*
*      COPY
*
{S$COP{ENT{{{{ENTRY POINT{15658
{{JSR{6,COPYB{{{COPY THE BLOCK{15659
{{PPM{6,EXITS{{{RETURN IF NO IDVAL FIELD{15660
{{BRN{6,EXSID{{{EXIT SETTING ID VALUE{15661
{{EJC{{{{{15662
*
*      COS
*
{S$COS{ENT{{{{ENTRY POINT{15667
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15668
{{JSR{6,GTREA{{{CONVERT TO REAL{15669
{{ERR{1,303{26,COS argument not numeric{{{15670
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15671
{{COS{{{{TAKE COSINE{15672
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{15673
{{ERB{1,322{26,COS argument is out of range{{{15674
{{EJC{{{{{15675
*
*      DATA
*
{S$DAT{ENT{{{{ENTRY POINT{15680
{{JSR{6,XSCNI{{{PREPARE TO SCAN ARGUMENT{15681
{{ERR{1,075{26,DATA argument is not a string{{{15682
{{ERR{1,076{26,DATA argument is null{{{15683
*
*      SCAN OUT DATATYPE NAME
*
{{MOV{18,=CH$PP{8,WC{{DELIMITER ONE = LEFT PAREN{15687
{{MOV{8,WC{7,XL{{DELIMITER TWO = LEFT PAREN{15688
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15689
{{JSR{6,XSCAN{{{SCAN DATATYPE NAME{15690
{{BNZ{8,WA{6,SDAT1{{SKIP IF LEFT PAREN FOUND{15691
{{ERB{1,077{26,DATA argument is missing a left paren{{{15692
*
*      HERE AFTER SCANNING DATATYPE NAME
*
{SDAT1{MOV{13,SCLEN(XR){8,WA{{GET LENGTH{15697
{{BZE{8,WA{6,SDT1A{{AVOID FOLDING IF NULL STRING{15698
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{15699
{SDT1A{MOV{7,XR{7,XL{{SAVE NAME PTR{15700
{{MOV{13,SCLEN(XR){8,WA{{GET LENGTH{15704
{{CTB{8,WA{2,SCSI${{COMPUTE SPACE NEEDED{15705
{{JSR{6,ALOST{{{REQUEST STATIC STORE FOR NAME{15706
{{MOV{7,XR{11,-(XS){{SAVE DATATYPE NAME{15707
{{MVW{{{{COPY NAME TO STATIC{15708
{{MOV{9,(XS){7,XR{{GET NAME PTR{15709
{{ZER{7,XL{{{SCRUB DUD REGISTER{15710
{{JSR{6,GTNVR{{{LOCATE VRBLK FOR DATATYPE NAME{15711
{{ERR{1,078{26,DATA argument has null datatype name{{{15712
{{MOV{7,XR{3,DATDV{{SAVE VRBLK POINTER FOR DATATYPE{15713
{{MOV{7,XS{3,DATXS{{STORE STARTING STACK VALUE{15714
{{ZER{8,WB{{{ZERO COUNT OF FIELD NAMES{15715
*
*      LOOP TO SCAN FIELD NAMES AND STACK VRBLK POINTERS
*
{SDAT2{MOV{18,=CH$RP{8,WC{{DELIMITER ONE = RIGHT PAREN{15719
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO = COMMA{15720
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15721
{{JSR{6,XSCAN{{{SCAN NEXT FIELD NAME{15722
{{BNZ{8,WA{6,SDAT3{{JUMP IF DELIMITER FOUND{15723
{{ERB{1,079{26,DATA argument is missing a right paren{{{15724
*
*      HERE AFTER SCANNING OUT ONE FIELD NAME
*
{SDAT3{JSR{6,GTNVR{{{LOCATE VRBLK FOR FIELD NAME{15728
{{ERR{1,080{26,DATA argument has null field name{{{15729
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{15730
{{ICV{8,WB{{{INCREMENT COUNTER{15731
{{BEQ{8,WA{18,=NUM02{6,SDAT2{LOOP BACK IF STOPPED BY COMMA{15732
{{EJC{{{{{15733
*
*      DATA (CONTINUED)
*
*      NOW BUILD THE DFBLK
*
{{MOV{18,=DFSI${8,WA{{SET SIZE OF DFBLK STANDARD FIELDS{15739
{{ADD{8,WB{8,WA{{ADD NUMBER OF FIELDS{15740
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15741
{{MOV{8,WB{8,WC{{PRESERVE NO. OF FIELDS{15742
{{JSR{6,ALOST{{{ALLOCATE SPACE FOR DFBLK{15743
{{MOV{8,WC{8,WB{{GET NO OF FIELDS{15744
{{MOV{3,DATXS{7,XT{{POINT TO START OF STACK{15745
{{MOV{9,(XT){8,WC{{LOAD DATATYPE NAME{15746
{{MOV{7,XR{9,(XT){{SAVE DFBLK POINTER ON STACK{15747
{{MOV{22,=B$DFC{10,(XR)+{{STORE TYPE WORD{15748
{{MOV{8,WB{10,(XR)+{{STORE NUMBER OF FIELDS (FARGS){15749
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (DFLEN){15750
{{SUB{19,*PDDFS{8,WA{{COMPUTE PDBLK LENGTH (FOR DFPDL){15751
{{MOV{8,WA{10,(XR)+{{STORE PDBLK LENGTH (DFPDL){15752
{{MOV{8,WC{10,(XR)+{{STORE DATATYPE NAME (DFNAM){15753
{{LCT{8,WC{8,WB{{COPY NUMBER OF FIELDS{15754
*
*      LOOP TO MOVE FIELD NAME VRBLK POINTERS TO DFBLK
*
{SDAT4{MOV{11,-(XT){10,(XR)+{{MOVE ONE FIELD NAME VRBLK POINTER{15758
{{BCT{8,WC{6,SDAT4{{LOOP TILL ALL MOVED{15759
*
*      NOW DEFINE THE DATATYPE FUNCTION
*
{{MOV{8,WA{8,WC{{COPY LENGTH OF PDBLK FOR LATER LOOP{15763
{{MOV{3,DATDV{7,XR{{POINT TO VRBLK{15764
{{MOV{3,DATXS{7,XT{{POINT BACK ON STACK{15765
{{MOV{9,(XT){7,XL{{LOAD DFBLK POINTER{15766
{{JSR{6,DFFNC{{{DEFINE FUNCTION{15767
{{EJC{{{{{15768
*
*      DATA (CONTINUED)
*
*      LOOP TO BUILD FFBLKS
*
*
*      NOTICE THAT THE FFBLKS ARE CONSTRUCTED IN REVERSE ORDER
*      SO THAT THE REQUIRED OFFSETS CAN BE OBTAINED FROM
*      SUCCESSIVE DECREMENTATION OF THE PDBLK LENGTH (IN WC).
*
{SDAT5{MOV{19,*FFSI${8,WA{{SET LENGTH OF FFBLK{15779
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR FFBLK{15780
{{MOV{22,=B$FFC{9,(XR){{SET TYPE WORD{15781
{{MOV{18,=NUM01{13,FARGS(XR){{STORE FARGS (ALWAYS ONE){15782
{{MOV{3,DATXS{7,XT{{POINT BACK ON STACK{15783
{{MOV{9,(XT){13,FFDFP(XR){{COPY DFBLK PTR TO FFBLK{15784
{{DCA{8,WC{{{DECREMENT OLD DFPDL TO GET NEXT OFS{15785
{{MOV{8,WC{13,FFOFS(XR){{SET OFFSET TO THIS FIELD{15786
{{ZER{13,FFNXT(XR){{{TENTATIVELY SET ZERO FORWARD PTR{15787
{{MOV{7,XR{7,XL{{COPY FFBLK POINTER FOR DFFNC{15788
{{MOV{9,(XS){7,XR{{LOAD VRBLK POINTER FOR FIELD{15789
{{MOV{13,VRFNC(XR){7,XR{{LOAD CURRENT FUNCTION POINTER{15790
{{BNE{9,(XR){22,=B$FFC{6,SDAT6{SKIP IF NOT CURRENTLY A FIELD FUNC{15791
*
*      HERE WE MUST CHAIN AN OLD FFBLK PTR TO PRESERVE IT IN THE
*      CASE OF MULTIPLE FIELD FUNCTIONS WITH THE SAME NAME
*
{{MOV{7,XR{13,FFNXT(XL){{LINK NEW FFBLK TO PREVIOUS CHAIN{15796
*
*      MERGE HERE TO DEFINE FIELD FUNCTION
*
{SDAT6{MOV{10,(XS)+{7,XR{{LOAD VRBLK POINTER{15800
{{JSR{6,DFFNC{{{DEFINE FIELD FUNCTION{15801
{{BNE{7,XS{3,DATXS{6,SDAT5{LOOP BACK TILL ALL DONE{15802
{{ICA{7,XS{{{POP DFBLK POINTER{15803
{{BRN{6,EXNUL{{{RETURN WITH NULL RESULT{15804
{{EJC{{{{{15805
*
*      DATATYPE
*
{S$DTP{ENT{{{{ENTRY POINT{15809
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15810
{{JSR{6,DTYPE{{{GET DATATYPE{15811
{{MOV{7,XR{11,-(XS){{STACK RESULT{15812
{{LCW{7,XR{{{GET NEXT CODE WORD{15813
{{BRI{9,(XR){{{EXECUTE IT{15814
{{EJC{{{{{15815
*
*      DATE
*
{S$DTE{ENT{{{{ENTRY POINT{15819
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15820
{{JSR{6,GTINT{{{CONVERT TO AN INTEGER{15821
{{ERR{1,330{26,DATE argument is not integer{{{15822
{{JSR{6,SYSDT{{{CALL SYSTEM DATE ROUTINE{15823
{{MOV{13,NUM01(XL){8,WA{{LOAD LENGTH FOR SBSTR{15824
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF LENGTH IS ZERO{15825
{{ZER{8,WB{{{SET ZERO OFFSET{15826
{{JSR{6,SBSTR{{{USE SBSTR TO BUILD SCBLK{15827
{{MOV{7,XR{11,-(XS){{STACK RESULT{15828
{{LCW{7,XR{{{GET NEXT CODE WORD{15829
{{BRI{9,(XR){{{EXECUTE IT{15830
{{EJC{{{{{15831
*
*      DEFINE
*
{S$DEF{ENT{{{{ENTRY POINT{15835
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{15836
{{ZER{3,DEFLB{{{ZERO LABEL POINTER IN CASE NULL{15837
{{BEQ{7,XR{21,=NULLS{6,SDF01{JUMP IF NULL SECOND ARGUMENT{15838
{{JSR{6,GTNVR{{{ELSE FIND VRBLK FOR LABEL{15839
{{PPM{6,SDF12{{{JUMP IF NOT A VARIABLE NAME{15840
{{MOV{7,XR{3,DEFLB{{ELSE SET SPECIFIED ENTRY{15841
*
*      SCAN FUNCTION NAME
*
{SDF01{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{15845
{{ERR{1,081{26,DEFINE first argument is not a string{{{15846
{{ERR{1,082{26,DEFINE first argument is null{{{15847
{{MOV{18,=CH$PP{8,WC{{DELIMITER ONE = LEFT PAREN{15848
{{MOV{8,WC{7,XL{{DELIMITER TWO = LEFT PAREN{15849
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15850
{{JSR{6,XSCAN{{{SCAN OUT FUNCTION NAME{15851
{{BNZ{8,WA{6,SDF02{{JUMP IF LEFT PAREN FOUND{15852
{{ERB{1,083{26,DEFINE first argument is missing a left paren{{{15853
*
*      HERE AFTER SCANNING OUT FUNCTION NAME
*
{SDF02{JSR{6,GTNVR{{{GET VARIABLE NAME{15857
{{ERR{1,084{26,DEFINE first argument has null function name{{{15858
{{MOV{7,XR{3,DEFVR{{SAVE VRBLK POINTER FOR FUNCTION NAM{15859
{{ZER{8,WB{{{ZERO COUNT OF ARGUMENTS{15860
{{MOV{7,XS{3,DEFXS{{SAVE INITIAL STACK POINTER{15861
{{BNZ{3,DEFLB{6,SDF03{{JUMP IF SECOND ARGUMENT GIVEN{15862
{{MOV{7,XR{3,DEFLB{{ELSE DEFAULT IS FUNCTION NAME{15863
*
*      LOOP TO SCAN ARGUMENT NAMES AND STACK VRBLK POINTERS
*
{SDF03{MOV{18,=CH$RP{8,WC{{DELIMITER ONE = RIGHT PAREN{15867
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO = COMMA{15868
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15869
{{JSR{6,XSCAN{{{SCAN OUT NEXT ARGUMENT NAME{15870
{{BNZ{8,WA{6,SDF04{{SKIP IF DELIMITER FOUND{15871
{{ERB{1,085{26,Null arg name or missing ) in DEFINE first arg.{{{15872
{{EJC{{{{{15873
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING AN ARGUMENT NAME
*
{SDF04{BNE{7,XR{21,=NULLS{6,SDF05{SKIP IF NON-NULL{15879
{{BZE{8,WB{6,SDF06{{IGNORE NULL IF CASE OF NO ARGUMENTS{15880
*
*      HERE AFTER DEALING WITH THE CASE OF NO ARGUMENTS
*
{SDF05{JSR{6,GTNVR{{{GET VRBLK POINTER{15884
{{PPM{6,SDF03{{{LOOP BACK TO IGNORE NULL NAME{15885
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT VRBLK POINTER{15886
{{ICV{8,WB{{{INCREMENT COUNTER{15887
{{BEQ{8,WA{18,=NUM02{6,SDF03{LOOP BACK IF STOPPED BY A COMMA{15888
*
*      HERE AFTER SCANNING OUT FUNCTION ARGUMENT NAMES
*
{SDF06{MOV{8,WB{3,DEFNA{{SAVE NUMBER OF ARGUMENTS{15892
{{ZER{8,WB{{{ZERO COUNT OF LOCALS{15893
*
*      LOOP TO SCAN LOCAL NAMES AND STACK VRBLK POINTERS
*
{SDF07{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{15897
{{MOV{8,WC{7,XL{{SET DELIMITER TWO = COMMA{15898
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15899
{{JSR{6,XSCAN{{{SCAN OUT NEXT LOCAL NAME{15900
{{BNE{7,XR{21,=NULLS{6,SDF08{SKIP IF NON-NULL{15901
{{BZE{8,WA{6,SDF09{{EXIT SCAN IF END OF STRING{15902
*
*      HERE AFTER SCANNING OUT A LOCAL NAME
*
{SDF08{JSR{6,GTNVR{{{GET VRBLK POINTER{15906
{{PPM{6,SDF07{{{LOOP BACK TO IGNORE NULL NAME{15907
{{ICV{8,WB{{{IF OK, INCREMENT COUNT{15908
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{15909
{{BNZ{8,WA{6,SDF07{{LOOP BACK IF STOPPED BY A COMMA{15910
{{EJC{{{{{15911
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING LOCALS, BUILD PFBLK
*
{SDF09{MOV{8,WB{8,WA{{COPY COUNT OF LOCALS{15917
{{ADD{3,DEFNA{8,WA{{ADD NUMBER OF ARGUMENTS{15918
{{MOV{8,WA{8,WC{{SET SUM ARGS+LOCALS AS LOOP COUNT{15919
{{ADD{18,=PFSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{15920
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15921
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR PFBLK{15922
{{MOV{7,XR{7,XL{{SAVE POINTER TO PFBLK{15923
{{MOV{22,=B$PFC{10,(XR)+{{STORE FIRST WORD{15924
{{MOV{3,DEFNA{10,(XR)+{{STORE NUMBER OF ARGUMENTS{15925
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (PFLEN){15926
{{MOV{3,DEFVR{10,(XR)+{{STORE VRBLK PTR FOR FUNCTION NAME{15927
{{MOV{8,WB{10,(XR)+{{STORE NUMBER OF LOCALS{15928
{{ZER{10,(XR)+{{{DEAL WITH LABEL LATER{15929
{{ZER{10,(XR)+{{{ZERO PFCTR{15930
{{ZER{10,(XR)+{{{ZERO PFRTR{15931
{{BZE{8,WC{6,SDF11{{SKIP IF NO ARGS OR LOCALS{15932
{{MOV{7,XL{8,WA{{KEEP PFBLK POINTER{15933
{{MOV{3,DEFXS{7,XT{{POINT BEFORE ARGUMENTS{15934
{{LCT{8,WC{8,WC{{GET COUNT OF ARGS+LOCALS FOR LOOP{15935
*
*      LOOP TO MOVE LOCALS AND ARGS TO PFBLK
*
{SDF10{MOV{11,-(XT){10,(XR)+{{STORE ONE ENTRY AND BUMP POINTERS{15939
{{BCT{8,WC{6,SDF10{{LOOP TILL ALL STORED{15940
{{MOV{8,WA{7,XL{{RECOVER PFBLK POINTER{15941
{{EJC{{{{{15942
*
*      DEFINE (CONTINUED)
*
*      NOW DEAL WITH LABEL
*
{SDF11{MOV{3,DEFXS{7,XS{{POP STACK{15948
{{MOV{3,DEFLB{13,PFCOD(XL){{STORE LABEL VRBLK IN PFBLK{15949
{{MOV{3,DEFVR{7,XR{{POINT BACK TO VRBLK FOR FUNCTION{15950
{{JSR{6,DFFNC{{{DEFINE FUNCTION{15951
{{BRN{6,EXNUL{{{AND EXIT RETURNING NULL{15952
*
*      HERE FOR ERRONEOUS LABEL
*
{SDF12{ERB{1,086{26,DEFINE function entry point is not defined label{{{15956
{{EJC{{{{{15957
*
*      DETACH
*
{S$DET{ENT{{{{ENTRY POINT{15961
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15962
{{JSR{6,GTVAR{{{LOCATE VARIABLE{15963
{{ERR{1,087{26,DETACH argument is not appropriate name{{{15964
{{JSR{6,DTACH{{{DETACH I/O ASSOCIATION FROM NAME{15965
{{BRN{6,EXNUL{{{RETURN NULL RESULT{15966
{{EJC{{{{{15967
*
*      DIFFER
*
{S$DIF{ENT{{{{ENTRY POINT{15971
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{15972
{{MOV{10,(XS)+{7,XL{{LOAD FIRST ARGUMENT{15973
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{15974
{{PPM{6,EXFAL{{{FAIL IF IDENT{15975
{{BRN{6,EXNUL{{{RETURN NULL IF DIFFER{15976
{{EJC{{{{{15977
*
*      DUMP
*
{S$DMP{ENT{{{{ENTRY POINT{15981
{{JSR{6,GTSMI{{{LOAD DUMP ARG AS SMALL INTEGER{15982
{{ERR{1,088{26,DUMP argument is not integer{{{15983
{{ERR{1,089{26,DUMP argument is negative or too large{{{15984
{{JSR{6,DUMPR{{{ELSE CALL DUMP ROUTINE{15985
{{BRN{6,EXNUL{{{AND RETURN NULL AS RESULT{15986
{{EJC{{{{{15987
*
*      DUPL
*
{S$DUP{ENT{{{{ENTRY POINT{15991
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT AS SMALL INTEGR{15992
{{ERR{1,090{26,DUPL second argument is not integer{{{15993
{{PPM{6,SDUP7{{{JUMP IF NEGATIVE OR TOO BIG{15994
{{MOV{7,XR{8,WB{{SAVE DUPLICATION FACTOR{15995
{{JSR{6,GTSTG{{{GET FIRST ARG AS STRING{15996
{{PPM{6,SDUP4{{{JUMP IF NOT A STRING{15997
*
*      HERE FOR CASE OF DUPLICATION OF A STRING
*
{{MTI{8,WA{{{ACQUIRE LENGTH AS INTEGER{16001
{{STI{3,DUPSI{{{SAVE FOR THE MOMENT{16002
{{MTI{8,WB{{{GET DUPLICATION FACTOR AS INTEGER{16003
{{MLI{3,DUPSI{{{FORM PRODUCT{16004
{{IOV{6,SDUP3{{{JUMP IF OVERFLOW{16005
{{IEQ{6,EXNUL{{{RETURN NULL IF RESULT LENGTH = 0{16006
{{MFI{8,WA{6,SDUP3{{GET AS ADDR INTEGER, CHECK OVFLO{16007
*
*      MERGE HERE WITH RESULT LENGTH IN WA
*
{SDUP1{MOV{7,XR{7,XL{{SAVE STRING POINTER{16011
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{16012
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT POINTER{16013
{{MOV{7,XL{8,WC{{SAVE POINTER TO ARGUMENT STRING{16014
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{16015
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{16016
*
*      LOOP THROUGH DUPLICATIONS
*
{SDUP2{MOV{8,WC{7,XL{{POINT BACK TO ARGUMENT STRING{16020
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARACTERS{16021
{{PLC{7,XL{{{POINT TO CHARS IN ARGUMENT STRING{16022
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{16023
{{BCT{8,WB{6,SDUP2{{LOOP TILL ALL DUPLICATIONS DONE{16024
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{16025
{{LCW{7,XR{{{GET NEXT CODE WORD{16026
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16027
{{EJC{{{{{16028
*
*      DUPL (CONTINUED)
*
*      HERE IF TOO LARGE, SET MAX LENGTH AND LET ALOCS CATCH IT
*
{SDUP3{MOV{3,DNAME{8,WA{{SET IMPOSSIBLE LENGTH FOR ALOCS{16034
{{BRN{6,SDUP1{{{MERGE BACK{16035
*
*      HERE IF NOT A STRING
*
{SDUP4{JSR{6,GTPAT{{{CONVERT ARGUMENT TO PATTERN{16039
{{ERR{1,091{26,DUPL first argument is not a string or pattern{{{16040
*
*      HERE TO DUPLICATE A PATTERN ARGUMENT
*
{{MOV{7,XR{11,-(XS){{STORE PATTERN ON STACK{16044
{{MOV{21,=NDNTH{7,XR{{START OFF WITH NULL PATTERN{16045
{{BZE{8,WB{6,SDUP6{{NULL PATTERN IS RESULT IF DUPFAC=0{16046
{{MOV{8,WB{11,-(XS){{PRESERVE LOOP COUNT{16047
*
*      LOOP TO DUPLICATE BY SUCCESSIVE CONCATENATION
*
{SDUP5{MOV{7,XR{7,XL{{COPY CURRENT VALUE AS RIGHT ARGUMNT{16051
{{MOV{13,NUM01(XS){7,XR{{GET A NEW COPY OF LEFT{16052
{{JSR{6,PCONC{{{CONCATENATE{16053
{{DCV{9,(XS){{{COUNT DOWN{16054
{{BNZ{9,(XS){6,SDUP5{{LOOP{16055
{{ICA{7,XS{{{POP LOOP COUNT{16056
*
*      HERE TO EXIT AFTER CONSTRUCTING PATTERN
*
{SDUP6{MOV{7,XR{9,(XS){{STORE RESULT ON STACK{16060
{{LCW{7,XR{{{GET NEXT CODE WORD{16061
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16062
*
*      FAIL IF SECOND ARG IS OUT OF RANGE
*
{SDUP7{ICA{7,XS{{{POP FIRST ARGUMENT{16066
{{BRN{6,EXFAL{{{FAIL{16067
{{EJC{{{{{16068
*
*      EJECT
*
{S$EJC{ENT{{{{ENTRY POINT{16072
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{16073
{{ERR{1,092{26,EJECT argument is not a suitable name{{{16074
{{PPM{6,SEJC1{{{NULL ARGUMENT{16075
{{ERR{1,093{26,EJECT file does not exist{{{16076
{{JSR{6,SYSEF{{{CALL EJECT FILE FUNCTION{16077
{{ERR{1,093{26,EJECT file does not exist{{{16078
{{ERR{1,094{26,EJECT file does not permit page eject{{{16079
{{ERR{1,095{26,EJECT caused non-recoverable output error{{{16080
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{16081
*
*      HERE TO EJECT STANDARD OUTPUT FILE
*
{SEJC1{JSR{6,SYSEP{{{CALL ROUTINE TO EJECT PRINTER{16085
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{16086
{{EJC{{{{{16087
*
*      ENDFILE
*
{S$ENF{ENT{{{{ENTRY POINT{16091
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{16092
{{ERR{1,096{26,ENDFILE argument is not a suitable name{{{16093
{{ERR{1,097{26,ENDFILE argument is null{{{16094
{{ERR{1,098{26,ENDFILE file does not exist{{{16095
{{JSR{6,SYSEN{{{CALL ENDFILE ROUTINE{16096
{{ERR{1,098{26,ENDFILE file does not exist{{{16097
{{ERR{1,099{26,ENDFILE file does not permit endfile{{{16098
{{ERR{1,100{26,ENDFILE caused non-recoverable output error{{{16099
{{MOV{7,XL{8,WB{{REMEMBER VRBLK PTR FROM IOFCB CALL{16100
{{MOV{7,XL{7,XR{{COPY POINTER{16101
*
*      LOOP TO FIND TRTRF BLOCK
*
{SENF1{MOV{7,XR{7,XL{{REMEMBER PREVIOUS ENTRY{16105
{{MOV{13,TRVAL(XR){7,XR{{CHAIN ALONG{16106
{{BNE{9,(XR){22,=B$TRT{6,EXNUL{SKIP OUT IF CHAIN END{16107
{{BNE{13,TRTYP(XR){18,=TRTFC{6,SENF1{LOOP IF NOT FOUND{16108
{{MOV{13,TRVAL(XR){13,TRVAL(XL){{REMOVE TRTRF{16109
{{MOV{13,TRTRF(XR){3,ENFCH{{POINT TO HEAD OF IOCHN{16110
{{MOV{13,TRFPT(XR){8,WC{{POINT TO FCBLK{16111
{{MOV{8,WB{7,XR{{FILEARG1 VRBLK FROM IOFCB{16112
{{JSR{6,SETVR{{{RESET IT{16113
{{MOV{20,=R$FCB{7,XL{{PTR TO HEAD OF FCBLK CHAIN{16114
{{SUB{19,*NUM02{7,XL{{ADJUST READY TO ENTER LOOP{16115
*
*      FIND FCBLK
*
{SENF2{MOV{7,XL{7,XR{{COPY PTR{16119
{{MOV{13,NUM02(XL){7,XL{{GET NEXT LINK{16120
{{BZE{7,XL{6,SENF4{{STOP IF CHAIN END{16121
{{BEQ{13,NUM03(XL){8,WC{6,SENF3{JUMP IF FCBLK FOUND{16122
{{BRN{6,SENF2{{{LOOP{16123
*
*      REMOVE FCBLK
*
{SENF3{MOV{13,NUM02(XL){13,NUM02(XR){{DELETE FCBLK FROM CHAIN{16127
*
*      LOOP WHICH DETACHES ALL VBLS ON IOCHN CHAIN
*
{SENF4{MOV{3,ENFCH{7,XL{{GET CHAIN HEAD{16131
{{BZE{7,XL{6,EXNUL{{FINISHED IF CHAIN END{16132
{{MOV{13,TRTRF(XL){3,ENFCH{{CHAIN ALONG{16133
{{MOV{13,IONMO(XL){8,WA{{NAME OFFSET{16134
{{MOV{13,IONMB(XL){7,XL{{NAME BASE{16135
{{JSR{6,DTACH{{{DETACH NAME{16136
{{BRN{6,SENF4{{{LOOP TILL DONE{16137
{{EJC{{{{{16138
*
*      EQ
*
{S$EQF{ENT{{{{ENTRY POINT{16142
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16143
{{ERR{1,101{26,EQ first argument is not numeric{{{16144
{{ERR{1,102{26,EQ second argument is not numeric{{{16145
{{PPM{6,EXFAL{{{FAIL IF LT{16146
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16147
{{PPM{6,EXFAL{{{FAIL IF GT{16148
{{EJC{{{{{16149
*
*      EVAL
*
{S$EVL{ENT{{{{ENTRY POINT{16153
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16154
{{LCW{8,WC{{{LOAD NEXT CODE WORD{16160
{{BNE{8,WC{21,=OFNE${6,SEVL1{JUMP IF CALLED BY VALUE{16161
{{SCP{7,XL{{{COPY CODE POINTER{16162
{{MOV{9,(XL){8,WA{{GET NEXT CODE WORD{16163
{{BNE{8,WA{21,=ORNM${6,SEVL2{BY NAME UNLESS EXPRESSION{16164
{{BNZ{13,NUM01(XS){6,SEVL2{{JUMP IF BY NAME{16165
*
*      HERE IF CALLED BY VALUE
*
{SEVL1{ZER{8,WB{{{SET FLAG FOR BY VALUE{16169
{{MOV{8,WC{11,-(XS){{SAVE CODE WORD{16171
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{16172
{{ERR{1,103{26,EVAL argument is not expression{{{16173
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16174
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{16175
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY VALUE{16179
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{16180
{{MOV{7,XR{7,XL{{COPY RESULT{16181
{{MOV{9,(XS){7,XR{{RELOAD NEXT CODE WORD{16182
{{MOV{7,XL{9,(XS){{STACK RESULT{16183
{{BRI{9,(XR){{{JUMP TO EXECUTE NEXT CODE WORD{16184
*
*      HERE IF CALLED BY NAME
*
{SEVL2{MOV{18,=NUM01{8,WB{{SET FLAG FOR BY NAME{16188
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{16190
{{ERR{1,103{26,EVAL argument is not expression{{{16191
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16192
{{MOV{18,=NUM01{8,WB{{SET FLAG FOR BY NAME{16193
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{16195
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{16196
{{BRN{6,EXNAM{{{EXIT WITH NAME{16197
{{EJC{{{{{16200
*
*      EXIT
*
{S$EXT{ENT{{{{ENTRY POINT{16204
{{ZER{8,WB{{{CLEAR AMOUNT OF STATIC SHIFT{16205
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16206
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{16208
{{JSR{6,GBCOL{{{COMPACT MEMORY BY COLLECTING{16209
{{MOV{7,XR{3,DNAMS{{RECORD NEW SEDIMENT SIZE{16210
{{JSR{6,GTSTG{{{{16214
{{ERR{1,288{26,EXIT second argument is not a string{{{16215
{{MOV{7,XR{7,XL{{COPY SECOND ARG STRING POINTER{16216
{{JSR{6,GTSTG{{{CONVERT ARG TO STRING{16217
{{ERR{1,104{26,EXIT first argument is not suitable integer or string{{{16218
{{MOV{7,XL{11,-(XS){{SAVE SECOND ARGUMENT{16219
{{MOV{7,XR{7,XL{{COPY FIRST ARG STRING PTR{16220
{{JSR{6,GTINT{{{CHECK IT IS INTEGER{16221
{{PPM{6,SEXT1{{{SKIP IF UNCONVERTIBLE{16222
{{ZER{7,XL{{{NOTE IT IS INTEGER{16223
{{LDI{13,ICVAL(XR){{{GET INTEGER ARG{16224
*
*      MERGE TO CALL OSINT EXIT ROUTINE
*
{SEXT1{MOV{3,R$FCB{8,WB{{GET FCBLK CHAIN HEADER{16228
{{MOV{21,=HEADV{7,XR{{POINT TO V.V STRING{16229
{{MOV{10,(XS)+{8,WA{{PROVIDE SECOND ARGUMENT SCBLK{16230
{{JSR{6,SYSXI{{{CALL EXTERNAL ROUTINE{16231
{{ERR{1,105{26,EXIT action not available in this implementation{{{16232
{{ERR{1,106{26,EXIT action caused irrecoverable error{{{16233
{{IEQ{6,EXNUL{{{RETURN IF ARGUMENT 0{16234
{{IGT{6,SEXT2{{{SKIP IF POSITIVE{16235
{{NGI{{{{MAKE POSITIVE{16236
*
*      CHECK FOR OPTION RESPECIFICATION
*
*      SYSXI RETURNS 0 IN WA WHEN A FILE HAS BEEN RESUMED,
*      1 WHEN THIS IS A CONTINUATION OF AN EXIT(4) OR EXIT(-4)
*      ACTION.
*
{SEXT2{MFI{8,WC{{{GET VALUE IN WORK REG{16244
{{ADD{8,WC{8,WA{{PREPARE TO TEST FOR CONTINUE{16245
{{BEQ{8,WA{18,=NUM05{6,SEXT5{CONTINUED EXECUTION IF 4 PLUS 1{16246
{{ZER{3,GBCNT{{{RESUMING EXECUTION SO RESET{16247
{{BGE{8,WC{18,=NUM03{6,SEXT3{SKIP IF WAS 3 OR 4{16248
{{MOV{8,WC{11,-(XS){{SAVE VALUE{16249
{{ZER{8,WC{{{SET TO READ OPTIONS{16250
{{JSR{6,PRPAR{{{READ SYSPP OPTIONS{16251
{{MOV{10,(XS)+{8,WC{{RESTORE VALUE{16252
*
*      DEAL WITH HEADER OPTION (FIDDLED BY PRPAR)
*
{SEXT3{MNZ{3,HEADP{{{ASSUME NO HEADERS{16256
{{BNE{8,WC{18,=NUM01{6,SEXT4{SKIP IF NOT 1{16257
{{ZER{3,HEADP{{{REQUEST HEADER PRINTING{16258
*
*      ALMOST READY TO RESUME RUNNING
*
{SEXT4{JSR{6,SYSTM{{{GET EXECUTION TIME START (SGD11){16262
{{STI{3,TIMSX{{{SAVE AS INITIAL TIME{16263
{{LDI{3,KVSTC{{{RESET TO ENSURE ...{16264
{{STI{3,KVSTL{{{... CORRECT EXECUTION STATS{16265
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{16266
{{BRN{6,EXNUL{{{RESUME EXECUTION{16267
*
*      HERE AFTER EXIT(4) OR EXIT(-4) -- CREATE SAVE FILE
*      OR LOAD MODULE AND CONTINUE EXECUTION.
*
*      RETURN INTEGER 1 TO SIGNAL THE CONTINUATION OF THE
*      ORIGINAL EXECUTION.
*
{SEXT5{MOV{21,=INTON{7,XR{{INTEGER ONE{16275
{{BRN{6,EXIXR{{{RETURN AS RESULT{16276
{{EJC{{{{{16278
*
*      EXP
*
{S$EXP{ENT{{{{ENTRY POINT{16283
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16284
{{JSR{6,GTREA{{{CONVERT TO REAL{16285
{{ERR{1,304{26,EXP argument not numeric{{{16286
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{16287
{{ETX{{{{TAKE EXPONENTIAL{16288
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{16289
{{ERB{1,305{26,EXP produced real overflow{{{16290
{{EJC{{{{{16291
*
*      FIELD
*
{S$FLD{ENT{{{{ENTRY POINT{16296
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (FIELD NUMBER){16297
{{ERR{1,107{26,FIELD second argument is not integer{{{16298
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{16299
{{MOV{7,XR{8,WB{{ELSE SAVE INTEGER VALUE{16300
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16301
{{JSR{6,GTNVR{{{POINT TO VRBLK{16302
{{PPM{6,SFLD1{{{JUMP (ERROR) IF NOT VARIABLE NAME{16303
{{MOV{13,VRFNC(XR){7,XR{{ELSE POINT TO FUNCTION BLOCK{16304
{{BNE{9,(XR){22,=B$DFC{6,SFLD1{ERROR IF NOT DATATYPE FUNCTION{16305
*
*      HERE IF FIRST ARGUMENT IS A DATATYPE FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF ARGUMENT NUMBER IS ZERO{16309
{{BGT{8,WB{13,FARGS(XR){6,EXFAL{FAIL IF TOO LARGE{16310
{{WTB{8,WB{{{ELSE CONVERT TO BYTE OFFSET{16311
{{ADD{8,WB{7,XR{{POINT TO FIELD NAME{16312
{{MOV{13,DFFLB(XR){7,XR{{LOAD VRBLK POINTER{16313
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{16314
*
*      HERE FOR BAD FIRST ARGUMENT
*
{SFLD1{ERB{1,108{26,FIELD first argument is not datatype name{{{16318
{{EJC{{{{{16319
*
*      FENCE
*
{S$FNC{ENT{{{{ENTRY POINT{16323
{{MOV{22,=P$FNC{8,WB{{SET PCODE FOR P$FNC{16324
{{ZER{7,XR{{{P0BLK{16325
{{JSR{6,PBILD{{{BUILD P$FNC NODE{16326
{{MOV{7,XR{7,XL{{SAVE POINTER TO IT{16327
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16328
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{16329
{{ERR{1,259{26,FENCE argument is not pattern{{{16330
{{JSR{6,PCONC{{{CONCATENATE TO P$FNC NODE{16331
{{MOV{7,XR{7,XL{{SAVE PTR TO CONCATENATED PATTERN{16332
{{MOV{22,=P$FNA{8,WB{{SET FOR P$FNA PCODE{16333
{{ZER{7,XR{{{P0BLK{16334
{{JSR{6,PBILD{{{CONSTRUCT P$FNA NODE{16335
{{MOV{7,XL{13,PTHEN(XR){{SET PATTERN AS PTHEN{16336
{{MOV{7,XR{11,-(XS){{SET AS RESULT{16337
{{LCW{7,XR{{{GET NEXT CODE WORD{16338
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16339
{{EJC{{{{{16340
*
*      GE
*
{S$GEF{ENT{{{{ENTRY POINT{16344
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16345
{{ERR{1,109{26,GE first argument is not numeric{{{16346
{{ERR{1,110{26,GE second argument is not numeric{{{16347
{{PPM{6,EXFAL{{{FAIL IF LT{16348
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16349
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16350
{{EJC{{{{{16351
*
*      GT
*
{S$GTF{ENT{{{{ENTRY POINT{16355
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16356
{{ERR{1,111{26,GT first argument is not numeric{{{16357
{{ERR{1,112{26,GT second argument is not numeric{{{16358
{{PPM{6,EXFAL{{{FAIL IF LT{16359
{{PPM{6,EXFAL{{{FAIL IF EQ{16360
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16361
{{EJC{{{{{16362
*
*      HOST
*
{S$HST{ENT{{{{ENTRY POINT{16366
{{MOV{10,(XS)+{8,WC{{GET FIFTH ARG{16367
{{MOV{10,(XS)+{8,WB{{GET FOURTH ARG{16368
{{MOV{10,(XS)+{7,XR{{GET THIRD ARG{16369
{{MOV{10,(XS)+{7,XL{{GET SECOND ARG{16370
{{MOV{10,(XS)+{8,WA{{GET FIRST ARG{16371
{{JSR{6,SYSHS{{{ENTER SYSHS ROUTINE{16372
{{ERR{1,254{26,Erroneous argument for HOST{{{16373
{{ERR{1,255{26,Error during execution of HOST{{{16374
{{PPM{6,SHST1{{{STORE HOST STRING{16375
{{PPM{6,EXNUL{{{RETURN NULL RESULT{16376
{{PPM{6,EXIXR{{{RETURN XR{16377
{{PPM{6,EXFAL{{{FAIL RETURN{16378
{{PPM{6,SHST3{{{STORE ACTUAL STRING{16379
{{PPM{6,SHST4{{{RETURN COPY OF XR{16380
*
*      RETURN HOST STRING
*
{SHST1{BZE{7,XL{6,EXNUL{{NULL STRING IF SYSHS UNCOOPERATIVE{16384
{{MOV{13,SCLEN(XL){8,WA{{LENGTH{16385
{{ZER{8,WB{{{ZERO OFFSET{16386
*
*      COPY STRING AND RETURN
*
{SHST2{JSR{6,SBSTR{{{BUILD COPY OF STRING{16390
{{MOV{7,XR{11,-(XS){{STACK THE RESULT{16391
{{LCW{7,XR{{{LOAD NEXT CODE WORD{16392
{{BRI{9,(XR){{{EXECUTE IT{16393
*
*      RETURN ACTUAL STRING POINTED TO BY XL
*
{SHST3{ZER{8,WB{{{TREAT XL LIKE AN SCBLK PTR{16397
{{SUB{18,=CFP$F{8,WB{{BY CREATING A NEGATIVE OFFSET{16398
{{BRN{6,SHST2{{{JOIN TO COPY STRING{16399
*
*      RETURN COPY OF BLOCK POINTED TO BY XR
*
{SHST4{MOV{7,XR{11,-(XS){{STACK RESULTS{16403
{{JSR{6,COPYB{{{MAKE COPY OF BLOCK{16404
{{PPM{6,EXITS{{{IF NOT AN AGGREGATE STRUCTURE{16405
{{BRN{6,EXSID{{{SET CURRENT ID VALUE OTHERWISE{16406
{{EJC{{{{{16407
*
*      IDENT
*
{S$IDN{ENT{{{{ENTRY POINT{16411
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{16412
{{MOV{10,(XS)+{7,XL{{LOAD FIRST ARGUMENT{16413
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{16414
{{PPM{6,EXNUL{{{RETURN NULL IF IDENT{16415
{{BRN{6,EXFAL{{{FAIL IF DIFFER{16416
{{EJC{{{{{16417
*
*      INPUT
*
{S$INP{ENT{{{{ENTRY POINT{16421
{{ZER{8,WB{{{INPUT FLAG{16422
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{16423
{{ERR{1,113{26,INPUT third argument is not a string{{{16424
{{ERR{1,114{26,Inappropriate second argument for INPUT{{{16425
{{ERR{1,115{26,Inappropriate first argument for INPUT{{{16426
{{ERR{1,116{26,Inappropriate file specification for INPUT{{{16427
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{16428
{{ERR{1,117{26,INPUT file cannot be read{{{16429
{{ERR{1,289{26,INPUT channel currently in use{{{16430
{{BRN{6,EXNUL{{{RETURN NULL STRING{16431
{{EJC{{{{{16432
*
*      INTEGER
*
{S$INT{ENT{{{{ENTRY POINT{16465
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16466
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{16467
{{PPM{6,EXFAL{{{FAIL IF NON-NUMERIC{16468
{{BEQ{8,WA{22,=B$ICL{6,EXNUL{RETURN NULL IF INTEGER{16469
{{BRN{6,EXFAL{{{FAIL IF REAL{16470
{{EJC{{{{{16471
*
*      ITEM
*
*      ITEM DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S$ITM{ENT{{{{ENTRY POINT{16478
*
*      DEAL WITH CASE OF NO ARGS
*
{{BNZ{8,WA{6,SITM1{{JUMP IF AT LEAST ONE ARG{16482
{{MOV{21,=NULLS{11,-(XS){{ELSE SUPPLY GARBAGE NULL ARG{16483
{{MOV{18,=NUM01{8,WA{{AND FIX ARGUMENT COUNT{16484
*
*      CHECK FOR NAME/VALUE CASES
*
{SITM1{SCP{7,XR{{{GET CURRENT CODE POINTER{16488
{{MOV{9,(XR){7,XL{{LOAD NEXT CODE WORD{16489
{{DCV{8,WA{{{GET NUMBER OF SUBSCRIPTS{16490
{{MOV{8,WA{7,XR{{COPY FOR ARREF{16491
{{BEQ{7,XL{21,=OFNE${6,SITM2{JUMP IF CALLED BY NAME{16492
*
*      HERE IF CALLED BY VALUE
*
{{ZER{8,WB{{{SET CODE FOR CALL BY VALUE{16496
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{16497
*
*      HERE FOR CALL BY NAME
*
{SITM2{MNZ{8,WB{{{SET CODE FOR CALL BY NAME{16501
{{LCW{8,WA{{{LOAD AND IGNORE OFNE$ CALL{16502
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{16503
{{EJC{{{{{16504
*
*      LE
*
{S$LEF{ENT{{{{ENTRY POINT{16508
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16509
{{ERR{1,118{26,LE first argument is not numeric{{{16510
{{ERR{1,119{26,LE second argument is not numeric{{{16511
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16512
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16513
{{PPM{6,EXFAL{{{FAIL IF GT{16514
{{EJC{{{{{16515
*
*      LEN
*
{S$LEN{ENT{{{{ENTRY POINT{16519
{{MOV{22,=P$LEN{8,WB{{SET PCODE FOR INTEGER ARG CASE{16520
{{MOV{22,=P$LND{8,WA{{SET PCODE FOR EXPR ARG CASE{16521
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{16522
{{ERR{1,120{26,LEN argument is not integer or expression{{{16523
{{ERR{1,121{26,LEN argument is negative or too large{{{16524
{{MOV{7,XR{11,-(XS){{STACK RESULT{16525
{{LCW{7,XR{{{GET NEXT CODE WORD{16526
{{BRI{9,(XR){{{EXECUTE IT{16527
{{EJC{{{{{16528
*
*      LEQ
*
{S$LEQ{ENT{{{{ENTRY POINT{16532
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16533
{{ERR{1,122{26,LEQ first argument is not a string{{{16534
{{ERR{1,123{26,LEQ second argument is not a string{{{16535
{{PPM{6,EXFAL{{{FAIL IF LLT{16536
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16537
{{PPM{6,EXFAL{{{FAIL IF LGT{16538
{{EJC{{{{{16539
*
*      LGE
*
{S$LGE{ENT{{{{ENTRY POINT{16543
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16544
{{ERR{1,124{26,LGE first argument is not a string{{{16545
{{ERR{1,125{26,LGE second argument is not a string{{{16546
{{PPM{6,EXFAL{{{FAIL IF LLT{16547
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16548
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16549
{{EJC{{{{{16550
*
*      LGT
*
{S$LGT{ENT{{{{ENTRY POINT{16554
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16555
{{ERR{1,126{26,LGT first argument is not a string{{{16556
{{ERR{1,127{26,LGT second argument is not a string{{{16557
{{PPM{6,EXFAL{{{FAIL IF LLT{16558
{{PPM{6,EXFAL{{{FAIL IF LEQ{16559
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16560
{{EJC{{{{{16561
*
*      LLE
*
{S$LLE{ENT{{{{ENTRY POINT{16565
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16566
{{ERR{1,128{26,LLE first argument is not a string{{{16567
{{ERR{1,129{26,LLE second argument is not a string{{{16568
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16569
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16570
{{PPM{6,EXFAL{{{FAIL IF LGT{16571
{{EJC{{{{{16572
*
*      LLT
*
{S$LLT{ENT{{{{ENTRY POINT{16576
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16577
{{ERR{1,130{26,LLT first argument is not a string{{{16578
{{ERR{1,131{26,LLT second argument is not a string{{{16579
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16580
{{PPM{6,EXFAL{{{FAIL IF LEQ{16581
{{PPM{6,EXFAL{{{FAIL IF LGT{16582
{{EJC{{{{{16583
*
*      LNE
*
{S$LNE{ENT{{{{ENTRY POINT{16587
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16588
{{ERR{1,132{26,LNE first argument is not a string{{{16589
{{ERR{1,133{26,LNE second argument is not a string{{{16590
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16591
{{PPM{6,EXFAL{{{FAIL IF LEQ{16592
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16593
{{EJC{{{{{16594
*
*      LN
*
{S$LNF{ENT{{{{ENTRY POINT{16599
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16600
{{JSR{6,GTREA{{{CONVERT TO REAL{16601
{{ERR{1,306{26,LN argument not numeric{{{16602
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{16603
{{REQ{6,SLNF1{{{OVERFLOW IF ARGUMENT IS 0{16604
{{RLT{6,SLNF2{{{ERROR IF ARGUMENT LESS THAN 0{16605
{{LNF{{{{TAKE NATURAL LOGARITHM{16606
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{16607
{SLNF1{ERB{1,307{26,LN produced real overflow{{{16608
*
*      HERE FOR BAD ARGUMENT
*
{SLNF2{ERB{1,315{26,LN argument negative{{{16612
{{EJC{{{{{16613
*
*      LOCAL
*
{S$LOC{ENT{{{{ENTRY POINT{16618
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (LOCAL NUMBER){16619
{{ERR{1,134{26,LOCAL second argument is not integer{{{16620
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{16621
{{MOV{7,XR{8,WB{{SAVE LOCAL NUMBER{16622
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16623
{{JSR{6,GTNVR{{{POINT TO VRBLK{16624
{{PPM{6,SLOC1{{{JUMP IF NOT VARIABLE NAME{16625
{{MOV{13,VRFNC(XR){7,XR{{ELSE LOAD FUNCTION POINTER{16626
{{BNE{9,(XR){22,=B$PFC{6,SLOC1{JUMP IF NOT PROGRAM DEFINED{16627
*
*      HERE IF WE HAVE A PROGRAM DEFINED FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF SECOND ARG IS ZERO{16631
{{BGT{8,WB{13,PFNLO(XR){6,EXFAL{OR TOO LARGE{16632
{{ADD{13,FARGS(XR){8,WB{{ELSE ADJUST OFFSET TO INCLUDE ARGS{16633
{{WTB{8,WB{{{CONVERT TO BYTES{16634
{{ADD{8,WB{7,XR{{POINT TO LOCAL POINTER{16635
{{MOV{13,PFAGB(XR){7,XR{{LOAD VRBLK POINTER{16636
{{BRN{6,EXVNM{{{EXIT BUILDING NMBLK{16637
*
*      HERE IF FIRST ARGUMENT IS NO GOOD
*
{SLOC1{ERB{1,135{26,LOCAL first arg is not a program function name{{{16641
{{EJC{{{{{16644
*
*      LOAD
*
{S$LOD{ENT{{{{ENTRY POINT{16648
{{JSR{6,GTSTG{{{LOAD LIBRARY NAME{16649
{{ERR{1,136{26,LOAD second argument is not a string{{{16650
{{MOV{7,XR{7,XL{{SAVE LIBRARY NAME{16651
{{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{16652
{{ERR{1,137{26,LOAD first argument is not a string{{{16653
{{ERR{1,138{26,LOAD first argument is null{{{16654
{{MOV{7,XL{11,-(XS){{STACK LIBRARY NAME{16655
{{MOV{18,=CH$PP{8,WC{{SET DELIMITER ONE = LEFT PAREN{16656
{{MOV{8,WC{7,XL{{SET DELIMITER TWO = LEFT PAREN{16657
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16658
{{JSR{6,XSCAN{{{SCAN FUNCTION NAME{16659
{{MOV{7,XR{11,-(XS){{SAVE PTR TO FUNCTION NAME{16660
{{BNZ{8,WA{6,SLOD1{{JUMP IF LEFT PAREN FOUND{16661
{{ERB{1,139{26,LOAD first argument is missing a left paren{{{16662
*
*      HERE AFTER SUCCESSFULLY SCANNING FUNCTION NAME
*
{SLOD1{JSR{6,GTNVR{{{LOCATE VRBLK{16666
{{ERR{1,140{26,LOAD first argument has null function name{{{16667
{{MOV{7,XR{3,LODFN{{SAVE VRBLK POINTER{16668
{{ZER{3,LODNA{{{ZERO COUNT OF ARGUMENTS{16669
*
*      LOOP TO SCAN ARGUMENT DATATYPE NAMES
*
{SLOD2{MOV{18,=CH$RP{8,WC{{DELIMITER ONE IS RIGHT PAREN{16673
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO IS COMMA{16674
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16675
{{JSR{6,XSCAN{{{SCAN NEXT ARGUMENT NAME{16676
{{ICV{3,LODNA{{{BUMP ARGUMENT COUNT{16677
{{BNZ{8,WA{6,SLOD3{{JUMP IF OK DELIMITER WAS FOUND{16678
{{ERB{1,141{26,LOAD first argument is missing a right paren{{{16679
{{EJC{{{{{16680
*
*      LOAD (CONTINUED)
*
*      COME HERE TO ANALYZE THE DATATYPE POINTER IN (XR). THIS
*      CODE IS USED BOTH FOR ARGUMENTS (WA=1,2) AND FOR THE
*      RESULT DATATYPE (WITH WA SET TO ZERO).
*
{SLOD3{MOV{8,WA{8,WB{{SAVE SCAN MODE{16689
{{MOV{13,SCLEN(XR){8,WA{{DATATYPE LENGTH{16690
{{BZE{8,WA{6,SLD3A{{BYPASS IF NULL STRING{16691
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{16692
{SLD3A{MOV{8,WB{8,WA{{RESTORE SCAN MODE{16693
{{MOV{7,XR{11,-(XS){{STACK DATATYPE NAME POINTER{16694
{{MOV{18,=NUM01{8,WB{{SET STRING CODE IN CASE{16698
{{MOV{21,=SCSTR{7,XL{{POINT TO /STRING/{16699
{{JSR{6,IDENT{{{CHECK FOR MATCH{16700
{{PPM{6,SLOD4{{{JUMP IF MATCH{16701
{{MOV{9,(XS){7,XR{{ELSE RELOAD NAME{16702
{{ADD{8,WB{8,WB{{SET CODE FOR INTEGER (2){16703
{{MOV{21,=SCINT{7,XL{{POINT TO /INTEGER/{16704
{{JSR{6,IDENT{{{CHECK FOR MATCH{16705
{{PPM{6,SLOD4{{{JUMP IF MATCH{16706
{{MOV{9,(XS){7,XR{{ELSE RELOAD STRING POINTER{16709
{{ICV{8,WB{{{SET CODE FOR REAL (3){16710
{{MOV{21,=SCREA{7,XL{{POINT TO /REAL/{16711
{{JSR{6,IDENT{{{CHECK FOR MATCH{16712
{{PPM{6,SLOD4{{{JUMP IF MATCH{16713
{{MOV{9,(XS){7,XR{{RELOAD STRING POINTER{16716
{{ICV{8,WB{{{CODE FOR FILE (4, OR 3 IF NO REALS){16717
{{MOV{21,=SCFIL{7,XL{{POINT TO /FILE/{16718
{{JSR{6,IDENT{{{CHECK FOR MATCH{16719
{{PPM{6,SLOD4{{{JUMP IF MATCH{16720
{{ZER{8,WB{{{ELSE GET CODE FOR NO CONVERT{16722
*
*      MERGE HERE WITH PROPER DATATYPE CODE IN WB
*
{SLOD4{MOV{8,WB{9,(XS){{STORE CODE ON STACK{16726
{{BEQ{8,WA{18,=NUM02{6,SLOD2{LOOP BACK IF ARG STOPPED BY COMMA{16727
{{BZE{8,WA{6,SLOD5{{JUMP IF THAT WAS THE RESULT TYPE{16728
*
*      HERE WE SCAN OUT THE RESULT TYPE (ARG STOPPED BY ) )
*
{{MOV{3,MXLEN{8,WC{{SET DUMMY (IMPOSSIBLE) DELIMITER 1{16732
{{MOV{8,WC{7,XL{{AND DELIMITER TWO{16733
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16734
{{JSR{6,XSCAN{{{SCAN RESULT NAME{16735
{{ZER{8,WA{{{SET CODE FOR PROCESSING RESULT{16736
{{BRN{6,SLOD3{{{JUMP BACK TO PROCESS RESULT NAME{16737
{{EJC{{{{{16738
*
*      LOAD (CONTINUED)
*
*      HERE AFTER PROCESSING ALL ARGS AND RESULT
*
{SLOD5{MOV{3,LODNA{8,WA{{GET NUMBER OF ARGUMENTS{16744
{{MOV{8,WA{8,WC{{COPY FOR LATER{16745
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{16746
{{ADD{19,*EFSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{16747
{{JSR{6,ALLOC{{{ALLOCATE EFBLK{16748
{{MOV{22,=B$EFC{9,(XR){{SET TYPE WORD{16749
{{MOV{8,WC{13,FARGS(XR){{SET NUMBER OF ARGUMENTS{16750
{{ZER{13,EFUSE(XR){{{SET USE COUNT (DFFNC WILL SET TO 1){16751
{{ZER{13,EFCOD(XR){{{ZERO CODE POINTER FOR NOW{16752
{{MOV{10,(XS)+{13,EFRSL(XR){{STORE RESULT TYPE CODE{16753
{{MOV{3,LODFN{13,EFVAR(XR){{STORE FUNCTION VRBLK POINTER{16754
{{MOV{8,WA{13,EFLEN(XR){{STORE EFBLK LENGTH{16755
{{MOV{7,XR{8,WB{{SAVE EFBLK POINTER{16756
{{ADD{8,WA{7,XR{{POINT PAST END OF EFBLK{16757
{{LCT{8,WC{8,WC{{SET NUMBER OF ARGUMENTS FOR LOOP{16758
*
*      LOOP TO SET ARGUMENT TYPE CODES FROM STACK
*
{SLOD6{MOV{10,(XS)+{11,-(XR){{STORE ONE TYPE CODE FROM STACK{16762
{{BCT{8,WC{6,SLOD6{{LOOP TILL ALL STORED{16763
*
*      NOW LOAD THE EXTERNAL FUNCTION AND PERFORM DEFINITION
*
{{MOV{10,(XS)+{7,XR{{LOAD FUNCTION STRING NAME{16767
{{MOV{13,SCLEN(XR){8,WA{{FUNCTION NAME LENGTH{16769
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{16770
{{MOV{9,(XS){7,XL{{LOAD LIBRARY NAME{16772
{{MOV{8,WB{9,(XS){{STORE EFBLK POINTER{16773
{{JSR{6,SYSLD{{{CALL FUNCTION TO LOAD EXTERNAL FUNC{16774
{{ERR{1,142{26,LOAD function does not exist{{{16775
{{ERR{1,143{26,LOAD function caused input error during load{{{16776
{{ERR{1,328{26,LOAD function - insufficient memory{{{16777
{{MOV{10,(XS)+{7,XL{{RECALL EFBLK POINTER{16778
{{MOV{7,XR{13,EFCOD(XL){{STORE CODE POINTER{16779
{{MOV{3,LODFN{7,XR{{POINT TO VRBLK FOR FUNCTION{16780
{{JSR{6,DFFNC{{{PERFORM FUNCTION DEFINITION{16781
{{BRN{6,EXNUL{{{RETURN NULL RESULT{16782
{{EJC{{{{{16784
*
*      LPAD
*
{S$LPD{ENT{{{{ENTRY POINT{16788
{{JSR{6,GTSTG{{{GET PAD CHARACTER{16789
{{ERR{1,144{26,LPAD third argument is not a string{{{16790
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){16791
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{16792
{{JSR{6,GTSMI{{{GET PAD LENGTH{16793
{{ERR{1,145{26,LPAD second argument is not integer{{{16794
{{PPM{6,SLPD4{{{SKIP IF NEGATIVE OR LARGE{16795
*
*      MERGE TO CHECK FIRST ARG
*
{SLPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){16799
{{ERR{1,146{26,LPAD first argument is not a string{{{16800
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{16801
{{MOV{7,XR{7,XL{{ELSE MOVE PTR TO STRING TO PAD{16802
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WC{8,WA{{COPY LENGTH{16810
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{16811
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT{16812
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH OF ARGUMENT{16813
{{SUB{8,WA{8,WC{{CALCULATE NUMBER OF PAD CHARACTERS{16814
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{16815
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{16816
*
*      LOOP TO PERFORM PAD
*
{SLPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{16820
{{BCT{8,WC{6,SLPD2{{LOOP TILL ALL PAD CHARS STORED{16821
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{16822
*
*      NOW COPY STRING
*
{{BZE{8,WA{6,SLPD3{{EXIT IF NULL STRING{16826
{{PLC{7,XL{{{ELSE POINT TO CHARS IN ARGUMENT{16827
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{16828
{{ZER{7,XL{{{CLEAR GARBAGE XL{16829
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{SLPD3{LCW{7,XR{{{LOAD NEXT CODE WORD{16833
{{BRI{9,(XR){{{EXECUTE IT{16834
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SLPD4{ZER{8,WC{{{ZERO PAD COUNT{16838
{{BRN{6,SLPD1{{{MERGE{16839
{{EJC{{{{{16840
*
*      LT
*
{S$LTF{ENT{{{{ENTRY POINT{16844
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16845
{{ERR{1,147{26,LT first argument is not numeric{{{16846
{{ERR{1,148{26,LT second argument is not numeric{{{16847
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16848
{{PPM{6,EXFAL{{{FAIL IF EQ{16849
{{PPM{6,EXFAL{{{FAIL IF GT{16850
{{EJC{{{{{16851
*
*      NE
*
{S$NEF{ENT{{{{ENTRY POINT{16855
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16856
{{ERR{1,149{26,NE first argument is not numeric{{{16857
{{ERR{1,150{26,NE second argument is not numeric{{{16858
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16859
{{PPM{6,EXFAL{{{FAIL IF EQ{16860
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16861
{{EJC{{{{{16862
*
*      NOTANY
*
{S$NAY{ENT{{{{ENTRY POINT{16866
{{MOV{22,=P$NAS{8,WB{{SET PCODE FOR SINGLE CHAR ARG{16867
{{MOV{22,=P$NAY{7,XL{{PCODE FOR MULTI-CHAR ARG{16868
{{MOV{22,=P$NAD{8,WC{{SET PCODE FOR EXPR ARG{16869
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{16870
{{ERR{1,151{26,NOTANY argument is not a string or expression{{{16871
{{MOV{7,XR{11,-(XS){{STACK RESULT{16872
{{LCW{7,XR{{{GET NEXT CODE WORD{16873
{{BRI{9,(XR){{{EXECUTE IT{16874
{{EJC{{{{{16875
*
*      OPSYN
*
{S$OPS{ENT{{{{ENTRY POINT{16879
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{16880
{{ERR{1,152{26,OPSYN third argument is not integer{{{16881
{{ERR{1,153{26,OPSYN third argument is negative or too large{{{16882
{{MOV{8,WC{8,WB{{IF OK, SAVE THIRD ARGUMNET{16883
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{16884
{{JSR{6,GTNVR{{{LOCATE VARIABLE BLOCK{16885
{{ERR{1,154{26,OPSYN second arg is not natural variable name{{{16886
{{MOV{13,VRFNC(XR){7,XL{{IF OK, LOAD FUNCTION BLOCK POINTER{16887
{{BNZ{8,WB{6,SOPS2{{JUMP IF OPERATOR OPSYN CASE{16888
*
*      HERE FOR FUNCTION OPSYN (THIRD ARG ZERO)
*
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16892
{{JSR{6,GTNVR{{{GET VRBLK POINTER{16893
{{ERR{1,155{26,OPSYN first arg is not natural variable name{{{16894
*
*      MERGE HERE TO PERFORM FUNCTION DEFINITION
*
{SOPS1{JSR{6,DFFNC{{{CALL FUNCTION DEFINER{16898
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{16899
*
*      HERE FOR OPERATOR OPSYN (THIRD ARG NON-ZERO)
*
{SOPS2{JSR{6,GTSTG{{{GET OPERATOR NAME{16903
{{PPM{6,SOPS5{{{JUMP IF NOT STRING{16904
{{BNE{8,WA{18,=NUM01{6,SOPS5{ERROR IF NOT ONE CHAR LONG{16905
{{PLC{7,XR{{{ELSE POINT TO CHARACTER{16906
{{LCH{8,WC{9,(XR){{LOAD CHARACTER NAME{16907
{{EJC{{{{{16908
*
*      OPSYN (CONTINUED)
*
*      NOW SET TO SEARCH FOR MATCHING UNARY OR BINARY OPERATOR
*      NAME AS APPROPRIATE. NOTE THAT THERE ARE =OPBUN UNDEFINED
*      BINARY OPERATORS AND =OPUUN UNDEFINED UNARY OPERATORS.
*
{{MOV{20,=R$UUB{8,WA{{POINT TO UNOP POINTERS IN CASE{16916
{{MOV{21,=OPNSU{7,XR{{POINT TO NAMES OF UNARY OPERATORS{16917
{{ADD{18,=OPBUN{8,WB{{ADD NO. OF UNDEFINED BINARY OPS{16918
{{BEQ{8,WB{18,=OPUUN{6,SOPS3{JUMP IF UNOP (THIRD ARG WAS 1){16919
{{MOV{20,=R$UBA{8,WA{{ELSE POINT TO BINARY OPERATOR PTRS{16920
{{MOV{21,=OPSNB{7,XR{{POINT TO NAMES OF BINARY OPERATORS{16921
{{MOV{18,=OPBUN{8,WB{{SET NUMBER OF UNDEFINED BINOPS{16922
*
*      MERGE HERE TO CHECK LIST (WB = NUMBER TO CHECK)
*
{SOPS3{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{16926
*
*      LOOP TO SEARCH FOR NAME MATCH
*
{SOPS4{BEQ{8,WC{9,(XR){6,SOPS6{JUMP IF NAMES MATCH{16930
{{ICA{8,WA{{{ELSE PUSH POINTER TO FUNCTION PTR{16931
{{ICA{7,XR{{{BUMP POINTER{16932
{{BCT{8,WB{6,SOPS4{{LOOP BACK TILL ALL CHECKED{16933
*
*      HERE IF BAD OPERATOR NAME
*
{SOPS5{ERB{1,156{26,OPSYN first arg is not correct operator name{{{16937
*
*      COME HERE ON FINDING A MATCH IN THE OPERATOR NAME TABLE
*
{SOPS6{MOV{8,WA{7,XR{{COPY POINTER TO FUNCTION BLOCK PTR{16941
{{SUB{19,*VRFNC{7,XR{{MAKE IT LOOK LIKE DUMMY VRBLK{16942
{{BRN{6,SOPS1{{{MERGE BACK TO DEFINE OPERATOR{16943
{{EJC{{{{{16944
*
*      OUTPUT
*
{S$OUP{ENT{{{{ENTRY POINT{16969
{{MOV{18,=NUM03{8,WB{{OUTPUT FLAG{16970
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{16971
{{ERR{1,157{26,OUTPUT third argument is not a string{{{16972
{{ERR{1,158{26,Inappropriate second argument for OUTPUT{{{16973
{{ERR{1,159{26,Inappropriate first argument for OUTPUT{{{16974
{{ERR{1,160{26,Inappropriate file specification for OUTPUT{{{16975
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{16976
{{ERR{1,161{26,OUTPUT file cannot be written to{{{16977
{{ERR{1,290{26,OUTPUT channel currently in use{{{16978
{{BRN{6,EXNUL{{{RETURN NULL STRING{16979
{{EJC{{{{{16980
*
*      POS
*
{S$POS{ENT{{{{ENTRY POINT{16984
{{MOV{22,=P$POS{8,WB{{SET PCODE FOR INTEGER ARG CASE{16985
{{MOV{22,=P$PSD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{16986
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{16987
{{ERR{1,162{26,POS argument is not integer or expression{{{16988
{{ERR{1,163{26,POS argument is negative or too large{{{16989
{{MOV{7,XR{11,-(XS){{STACK RESULT{16990
{{LCW{7,XR{{{GET NEXT CODE WORD{16991
{{BRI{9,(XR){{{EXECUTE IT{16992
{{EJC{{{{{16993
*
*      PROTOTYPE
*
{S$PRO{ENT{{{{ENTRY POINT{16997
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16998
{{MOV{13,TBLEN(XR){8,WB{{LENGTH IF TABLE, VECTOR (=VCLEN){16999
{{BTW{8,WB{{{CONVERT TO WORDS{17000
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD OF ARGUMENT BLOCK{17001
{{BEQ{8,WA{22,=B$ART{6,SPRO4{JUMP IF ARRAY{17002
{{BEQ{8,WA{22,=B$TBT{6,SPRO1{JUMP IF TABLE{17003
{{BEQ{8,WA{22,=B$VCT{6,SPRO3{JUMP IF VECTOR{17004
{{ERB{1,164{26,PROTOTYPE argument is not valid object{{{17009
*
*      HERE FOR TABLE
*
{SPRO1{SUB{18,=TBSI${8,WB{{SUBTRACT STANDARD FIELDS{17013
*
*      MERGE FOR VECTOR
*
{SPRO2{MTI{8,WB{{{CONVERT TO INTEGER{17017
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{17018
*
*      HERE FOR VECTOR
*
{SPRO3{SUB{18,=VCSI${8,WB{{SUBTRACT STANDARD FIELDS{17022
{{BRN{6,SPRO2{{{MERGE{17023
*
*      HERE FOR ARRAY
*
{SPRO4{ADD{13,AROFS(XR){7,XR{{POINT TO PROTOTYPE FIELD{17027
{{MOV{9,(XR){7,XR{{LOAD PROTOTYPE{17028
{{MOV{7,XR{11,-(XS){{STACK RESULT{17029
{{LCW{7,XR{{{GET NEXT CODE WORD{17030
{{BRI{9,(XR){{{EXECUTE IT{17031
{{EJC{{{{{17041
*
*      REMDR
*
{S$RMD{ENT{{{{ENTRY POINT{17045
{{JSR{6,ARITH{{{GET TWO INTEGERS OR TWO REALS{17047
{{ERR{1,166{26,REMDR first argument is not numeric{{{17048
{{ERR{1,165{26,REMDR second argument is not numeric{{{17049
{{PPM{6,SRM06{{{IF REAL{17050
*
*      BOTH ARGUMENTS INTEGER
*
{{ZER{8,WB{{{SET POSITIVE FLAG{17067
{{LDI{13,ICVAL(XR){{{LOAD LEFT ARGUMENT VALUE{17068
{{IGE{6,SRM01{{{JUMP IF POSITIVE{17069
{{MNZ{8,WB{{{SET NEGATIVE FLAG{17070
{SRM01{RMI{13,ICVAL(XL){{{GET REMAINDER{17071
{{IOV{6,SRM05{{{ERROR IF OVERFLOW{17072
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*
{{BZE{8,WB{6,SRM03{{IF RESULT SHOULD BE POSITIVE{17076
{{ILE{6,EXINT{{{IF SHOULD BE NEGATIVE, AND IS{17077
{SRM02{NGI{{{{ADJUST SIGN OF RESULT{17078
{{BRN{6,EXINT{{{RETURN RESULT{17079
{SRM03{ILT{6,SRM02{{{SHOULD BE POS, AND RESULT NEGATIVE{17080
{{BRN{6,EXINT{{{SHOULD BE POSITIVE, AND IS{17081
*
*      FAIL FIRST ARGUMENT
*
{SRM04{ERB{1,166{26,REMDR first argument is not numeric{{{17085
*
*      FAIL IF OVERFLOW
*
{SRM05{ERB{1,167{26,REMDR caused integer overflow{{{17089
*
*      HERE WITH 1ST ARGUMENT IN (XR), 2ND IN (XL), BOTH REAL
*
*      RESULT = N1 - CHOP(N1/N2)*N2
*
{SRM06{ZER{8,WB{{{SET POSITIVE FLAG{17096
{{LDR{13,RCVAL(XR){{{LOAD LEFT ARGUMENT VALUE{17097
{{RGE{6,SRM07{{{JUMP IF POSITIVE{17098
{{MNZ{8,WB{{{SET NEGATIVE FLAG{17099
{SRM07{DVR{13,RCVAL(XL){{{COMPUTE N1/N2{17100
{{ROV{6,SRM10{{{JUMP IF OVERFLOW{17101
{{CHP{{{{CHOP RESULT{17102
{{MLR{13,RCVAL(XL){{{TIMES N2{17103
{{SBR{13,RCVAL(XR){{{COMPUTE DIFFERENCE{17104
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*      -RESULT IS IN RA AT THIS POINT
*
{{BZE{8,WB{6,SRM09{{IF RESULT SHOULD BE POSITIVE{17109
{{RLE{6,EXREA{{{IF SHOULD BE NEGATIVE, AND IS{17110
{SRM08{NGR{{{{ADJUST SIGN OF RESULT{17111
{{BRN{6,EXREA{{{RETURN RESULT{17112
{SRM09{RLT{6,SRM08{{{SHOULD BE POS, AND RESULT NEGATIVE{17113
{{BRN{6,EXREA{{{SHOULD BE POSITIVE, AND IS{17114
*
*      FAIL IF OVERFLOW
*
{SRM10{ERB{1,312{26,REMDR caused real overflow{{{17118
{{EJC{{{{{17120
*
*      REPLACE
*
*      THE ACTUAL REPLACE OPERATION USES AN SCBLK WHOSE CFP$A
*      CHARS CONTAIN THE TRANSLATED VERSIONS OF ALL THE CHARS.
*      THE TABLE POINTER IS REMEMBERED FROM CALL TO CALL AND
*      THE TABLE IS ONLY BUILT WHEN THE ARGUMENTS CHANGE.
*
*      WE ALSO PERFORM AN OPTIMIZATION GLEANED FROM SPITBOL 370.
*      IF THE SECOND ARGUMENT IS &ALPHABET, THERE IS NO NEED TO
*      TO BUILD A REPLACE TABLE.  THE THIRD ARGUMENT CAN BE
*      USED DIRECTLY AS THE REPLACE TABLE.
*
{S$RPL{ENT{{{{ENTRY POINT{17134
{{JSR{6,GTSTG{{{LOAD THIRD ARGUMENT AS STRING{17135
{{ERR{1,168{26,REPLACE third argument is not a string{{{17136
{{MOV{7,XR{7,XL{{SAVE THIRD ARG PTR{17137
{{JSR{6,GTSTG{{{GET SECOND ARGUMENT{17138
{{ERR{1,169{26,REPLACE second argument is not a string{{{17139
*
*      CHECK TO SEE IF THIS IS THE SAME TABLE AS LAST TIME
*
{{BNE{7,XR{3,R$RA2{6,SRPL1{JUMP IF 2ND ARGUMENT DIFFERENT{17143
{{BEQ{7,XL{3,R$RA3{6,SRPL4{JUMP IF ARGS SAME AS LAST TIME{17144
*
*      HERE WE BUILD A NEW REPLACE TABLE (NOTE WA = 2ND ARG LEN)
*
{SRPL1{MOV{13,SCLEN(XL){8,WB{{LOAD 3RD ARGUMENT LENGTH{17148
{{BNE{8,WA{8,WB{6,SRPL6{JUMP IF ARGUMENTS NOT SAME LENGTH{17149
{{BEQ{7,XR{3,KVALP{6,SRPL5{JUMP IF 2ND ARG IS ALPHABET STRING{17150
{{BZE{8,WB{6,SRPL6{{JUMP IF NULL 2ND ARGUMENT{17151
{{MOV{7,XL{3,R$RA3{{SAVE THIRD ARG FOR NEXT TIME IN{17152
{{MOV{7,XR{3,R$RA2{{SAVE SECOND ARG FOR NEXT TIME IN{17153
{{MOV{3,KVALP{7,XL{{POINT TO ALPHABET STRING{17154
{{MOV{13,SCLEN(XL){8,WA{{LOAD ALPHABET SCBLK LENGTH{17155
{{MOV{3,R$RPT{7,XR{{POINT TO CURRENT TABLE (IF ANY){17156
{{BNZ{7,XR{6,SRPL2{{JUMP IF WE ALREADY HAVE A TABLE{17157
*
*      HERE WE ALLOCATE A NEW TABLE
*
{{JSR{6,ALOCS{{{ALLOCATE NEW TABLE{17161
{{MOV{8,WC{8,WA{{KEEP SCBLK LENGTH{17162
{{MOV{7,XR{3,R$RPT{{SAVE TABLE POINTER FOR NEXT TIME{17163
*
*      MERGE HERE WITH POINTER TO NEW TABLE BLOCK IN (XR)
*
{SRPL2{CTB{8,WA{2,SCSI${{COMPUTE LENGTH OF SCBLK{17167
{{MVW{{{{COPY TO GET INITIAL TABLE VALUES{17168
{{EJC{{{{{17169
*
*      REPLACE (CONTINUED)
*
*      NOW WE MUST PLUG SELECTED ENTRIES AS REQUIRED. NOTE THAT
*      WE ARE SHORT OF INDEX REGISTERS FOR THE FOLLOWING LOOP.
*      HENCE THE NEED TO REPEATEDLY RE-INITIALISE CHAR PTR XL
*
{{MOV{3,R$RA2{7,XL{{POINT TO SECOND ARGUMENT{17177
{{LCT{8,WB{8,WB{{NUMBER OF CHARS TO PLUG{17178
{{ZER{8,WC{{{ZERO CHAR OFFSET{17179
{{MOV{3,R$RA3{7,XR{{POINT TO 3RD ARG{17180
{{PLC{7,XR{{{GET CHAR PTR FOR 3RD ARG{17181
*
*      LOOP TO PLUG CHARS
*
{SRPL3{MOV{3,R$RA2{7,XL{{POINT TO 2ND ARG{17185
{{PLC{7,XL{8,WC{{POINT TO NEXT CHAR{17186
{{ICV{8,WC{{{INCREMENT OFFSET{17187
{{LCH{8,WA{9,(XL){{GET NEXT CHAR{17188
{{MOV{3,R$RPT{7,XL{{POINT TO TRANSLATE TABLE{17189
{{PSC{7,XL{8,WA{{CONVERT CHAR TO OFFSET INTO TABLE{17190
{{LCH{8,WA{10,(XR)+{{GET TRANSLATED CHAR{17191
{{SCH{8,WA{9,(XL){{STORE IN TABLE{17192
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{17193
{{BCT{8,WB{6,SRPL3{{LOOP TILL DONE{17194
{{EJC{{{{{17195
*
*      REPLACE (CONTINUED)
*
*      HERE TO USE R$RPT AS REPLACE TABLE.
*
{SRPL4{MOV{3,R$RPT{7,XL{{REPLACE TABLE TO USE{17201
*
*      HERE TO PERFORM TRANSLATE USING TABLE IN XL.
*
{SRPL5{JSR{6,GTSTG{{{GET FIRST ARGUMENT{17206
{{ERR{1,170{26,REPLACE first argument is not a string{{{17207
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF NULL ARGUMENT{17216
{{MOV{7,XL{11,-(XS){{STACK REPLACE TABLE TO USE{17217
{{MOV{7,XR{7,XL{{COPY POINTER{17218
{{MOV{8,WA{8,WC{{SAVE LENGTH{17219
{{CTB{8,WA{2,SCHAR{{GET SCBLK LENGTH{17220
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{17221
{{MOV{7,XR{8,WB{{SAVE ADDRESS OF COPY{17222
{{MVW{{{{MOVE SCBLK CONTENTS TO COPY{17223
{{MOV{10,(XS)+{7,XR{{UNSTACK REPLACE TABLE{17224
{{PLC{7,XR{{{POINT TO CHARS OF TABLE{17225
{{MOV{8,WB{7,XL{{POINT TO STRING TO TRANSLATE{17226
{{PLC{7,XL{{{POINT TO CHARS OF STRING{17227
{{MOV{8,WC{8,WA{{SET NUMBER OF CHARS TO TRANSLATE{17228
{{TRC{{{{PERFORM TRANSLATION{17229
{SRPL8{MOV{8,WB{11,-(XS){{STACK RESULT{17230
{{LCW{7,XR{{{LOAD NEXT CODE WORD{17231
{{BRI{9,(XR){{{EXECUTE IT{17232
*
*      ERROR POINT
*
{SRPL6{ERB{1,171{26,Null or unequally long 2nd, 3rd args to REPLACE{{{17236
{{EJC{{{{{17251
*
*      REWIND
*
{S$REW{ENT{{{{ENTRY POINT{17255
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{17256
{{ERR{1,172{26,REWIND argument is not a suitable name{{{17257
{{ERR{1,173{26,REWIND argument is null{{{17258
{{ERR{1,174{26,REWIND file does not exist{{{17259
{{JSR{6,SYSRW{{{CALL SYSTEM REWIND FUNCTION{17260
{{ERR{1,174{26,REWIND file does not exist{{{17261
{{ERR{1,175{26,REWIND file does not permit rewind{{{17262
{{ERR{1,176{26,REWIND caused non-recoverable error{{{17263
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT IF NO ERROR{17264
{{EJC{{{{{17265
*
*      REVERSE
*
{S$RVS{ENT{{{{ENTRY POINT{17269
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{17271
{{ERR{1,177{26,REVERSE argument is not a string{{{17272
{{BZE{8,WA{6,EXIXR{{RETURN ARGUMENT IF NULL{17278
{{MOV{7,XR{7,XL{{ELSE SAVE POINTER TO STRING ARG{17279
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR NEW SCBLK{17280
{{MOV{7,XR{11,-(XS){{STORE SCBLK PTR ON STACK AS RESULT{17281
{{PSC{7,XR{{{PREPARE TO STORE IN NEW SCBLK{17282
{{PLC{7,XL{8,WC{{POINT PAST LAST CHAR IN ARGUMENT{17283
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{17284
*
*      LOOP TO MOVE CHARS IN REVERSE ORDER
*
{SRVS1{LCH{8,WB{11,-(XL){{LOAD NEXT CHAR FROM ARGUMENT{17288
{{SCH{8,WB{10,(XR)+{{STORE IN RESULT{17289
{{BCT{8,WC{6,SRVS1{{LOOP TILL ALL MOVED{17290
*
*      HERE WHEN COMPLETE TO EXECUTE NEXT CODE WORD
*
{SRVS4{CSC{7,XR{{{COMPLETE STORE CHARACTERS{17294
{{ZER{7,XL{{{CLEAR GARBAGE XL{17295
{SRVS2{LCW{7,XR{{{LOAD NEXT CODE WORD{17296
{{BRI{9,(XR){{{EXECUTE IT{17297
{{EJC{{{{{17321
*
*      RPAD
*
{S$RPD{ENT{{{{ENTRY POINT{17325
{{JSR{6,GTSTG{{{GET PAD CHARACTER{17326
{{ERR{1,178{26,RPAD third argument is not a string{{{17327
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){17328
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{17329
{{JSR{6,GTSMI{{{GET PAD LENGTH{17330
{{ERR{1,179{26,RPAD second argument is not integer{{{17331
{{PPM{6,SRPD3{{{SKIP IF NEGATIVE OR LARGE{17332
*
*      MERGE TO CHECK FIRST ARG.
*
{SRPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){17336
{{ERR{1,180{26,RPAD first argument is not a string{{{17337
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{17338
{{MOV{7,XR{7,XL{{ELSE MOVE PTR TO STRING TO PAD{17339
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WC{8,WA{{COPY LENGTH{17347
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{17348
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT{17349
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH OF ARGUMENT{17350
{{SUB{8,WA{8,WC{{CALCULATE NUMBER OF PAD CHARACTERS{17351
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{17352
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{17353
*
*      COPY ARGUMENT STRING
*
{{BZE{8,WA{6,SRPD2{{JUMP IF ARGUMENT IS NULL{17357
{{PLC{7,XL{{{ELSE POINT TO ARGUMENT CHARS{17358
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{17359
{{ZER{7,XL{{{CLEAR GARBAGE XL{17360
*
*      LOOP TO SUPPLY PAD CHARACTERS
*
{SRPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{17364
{{BCT{8,WC{6,SRPD2{{LOOP TILL ALL PAD CHARS STORED{17365
{{CSC{7,XR{{{COMPLETE CHARACTER STORING{17366
{{LCW{7,XR{{{LOAD NEXT CODE WORD{17367
{{BRI{9,(XR){{{EXECUTE IT{17368
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SRPD3{ZER{8,WC{{{ZERO PAD COUNT{17372
{{BRN{6,SRPD1{{{MERGE{17373
{{EJC{{{{{17374
*
*      RTAB
*
{S$RTB{ENT{{{{ENTRY POINT{17378
{{MOV{22,=P$RTB{8,WB{{SET PCODE FOR INTEGER ARG CASE{17379
{{MOV{22,=P$RTD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17380
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17381
{{ERR{1,181{26,RTAB argument is not integer or expression{{{17382
{{ERR{1,182{26,RTAB argument is negative or too large{{{17383
{{MOV{7,XR{11,-(XS){{STACK RESULT{17384
{{LCW{7,XR{{{GET NEXT CODE WORD{17385
{{BRI{9,(XR){{{EXECUTE IT{17386
{{EJC{{{{{17387
*
*      SET
*
{S$SET{ENT{{{{ENTRY POINT{17392
{{MOV{10,(XS)+{3,R$IO2{{SAVE THIRD ARG (WHENCE){17393
{{MOV{10,(XS)+{3,R$IO1{{SAVE SECOND ARG (OFFSET){17400
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{17402
{{ERR{1,291{26,SET first argument is not a suitable name{{{17403
{{ERR{1,292{26,SET first argument is null{{{17404
{{ERR{1,295{26,SET file does not exist{{{17405
{{MOV{3,R$IO1{8,WB{{LOAD SECOND ARG{17408
{{MOV{3,R$IO2{8,WC{{LOAD THIRD ARG{17410
{{JSR{6,SYSST{{{CALL SYSTEM SET ROUTINE{17411
{{ERR{1,293{26,Inappropriate second argument to SET{{{17412
{{ERR{1,294{26,Inappropriate third argument to SET{{{17413
{{ERR{1,295{26,SET file does not exist{{{17414
{{ERR{1,296{26,SET file does not permit setting file pointer{{{17415
{{ERR{1,297{26,SET caused non-recoverable I/O error{{{17416
{{BRN{6,EXINT{{{OTHERWISE RETURN POSITION{17421
{{EJC{{{{{17423
*
*      TAB
*
{S$TAB{ENT{{{{ENTRY POINT{17428
{{MOV{22,=P$TAB{8,WB{{SET PCODE FOR INTEGER ARG CASE{17429
{{MOV{22,=P$TBD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17430
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17431
{{ERR{1,183{26,TAB argument is not integer or expression{{{17432
{{ERR{1,184{26,TAB argument is negative or too large{{{17433
{{MOV{7,XR{11,-(XS){{STACK RESULT{17434
{{LCW{7,XR{{{GET NEXT CODE WORD{17435
{{BRI{9,(XR){{{EXECUTE IT{17436
{{EJC{{{{{17437
*
*      RPOS
*
{S$RPS{ENT{{{{ENTRY POINT{17441
{{MOV{22,=P$RPS{8,WB{{SET PCODE FOR INTEGER ARG CASE{17442
{{MOV{22,=P$RPD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17443
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17444
{{ERR{1,185{26,RPOS argument is not integer or expression{{{17445
{{ERR{1,186{26,RPOS argument is negative or too large{{{17446
{{MOV{7,XR{11,-(XS){{STACK RESULT{17447
{{LCW{7,XR{{{GET NEXT CODE WORD{17448
{{BRI{9,(XR){{{EXECUTE IT{17449
{{EJC{{{{{17452
*
*      RSORT
*
{S$RSR{ENT{{{{ENTRY POINT{17456
{{MNZ{8,WA{{{MARK AS RSORT{17457
{{JSR{6,SORTA{{{CALL SORT ROUTINE{17458
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{17459
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{17460
{{EJC{{{{{17462
*
*      SETEXIT
*
{S$STX{ENT{{{{ENTRY POINT{17466
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{17467
{{MOV{3,STXVR{8,WA{{LOAD OLD VRBLK POINTER{17468
{{ZER{7,XL{{{LOAD ZERO IN CASE NULL ARG{17469
{{BEQ{7,XR{21,=NULLS{6,SSTX1{JUMP IF NULL ARGUMENT (RESET CALL){17470
{{JSR{6,GTNVR{{{ELSE GET SPECIFIED VRBLK{17471
{{PPM{6,SSTX2{{{JUMP IF NOT NATURAL VARIABLE{17472
{{MOV{13,VRLBL(XR){7,XL{{ELSE LOAD LABEL{17473
{{BEQ{7,XL{21,=STNDL{6,SSTX2{JUMP IF LABEL IS NOT DEFINED{17474
{{BNE{9,(XL){22,=B$TRT{6,SSTX1{JUMP IF NOT TRAPPED{17475
{{MOV{13,TRLBL(XL){7,XL{{ELSE LOAD PTR TO REAL LABEL CODE{17476
*
*      HERE TO SET/RESET SETEXIT TRAP
*
{SSTX1{MOV{7,XR{3,STXVR{{STORE NEW VRBLK POINTER (OR NULL){17480
{{MOV{7,XL{3,R$SXC{{STORE NEW CODE PTR (OR ZERO){17481
{{BEQ{8,WA{21,=NULLS{6,EXNUL{RETURN NULL IF NULL RESULT{17482
{{MOV{8,WA{7,XR{{ELSE COPY VRBLK POINTER{17483
{{BRN{6,EXVNM{{{AND RETURN BUILDING NMBLK{17484
*
*      HERE IF BAD ARGUMENT
*
{SSTX2{ERB{1,187{26,SETEXIT argument is not label name or null{{{17488
*
*      SIN
*
{S$SIN{ENT{{{{ENTRY POINT{17493
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17494
{{JSR{6,GTREA{{{CONVERT TO REAL{17495
{{ERR{1,308{26,SIN argument not numeric{{{17496
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17497
{{SIN{{{{TAKE SINE{17498
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{17499
{{ERB{1,323{26,SIN argument is out of range{{{17500
{{EJC{{{{{17501
*
*      SQRT
*
{S$SQR{ENT{{{{ENTRY POINT{17507
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17508
{{JSR{6,GTREA{{{CONVERT TO REAL{17509
{{ERR{1,313{26,SQRT argument not numeric{{{17510
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17511
{{RLT{6,SSQR1{{{NEGATIVE NUMBER{17512
{{SQR{{{{TAKE SQUARE ROOT{17513
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE, RESULT IN RA{17514
*
*      HERE IF BAD ARGUMENT
*
{SSQR1{ERB{1,314{26,SQRT argument negative{{{17518
{{EJC{{{{{17519
{{EJC{{{{{17523
*
*      SORT
*
{S$SRT{ENT{{{{ENTRY POINT{17527
{{ZER{8,WA{{{MARK AS SORT{17528
{{JSR{6,SORTA{{{CALL SORT ROUTINE{17529
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{17530
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{17531
{{EJC{{{{{17533
*
*      SPAN
*
{S$SPN{ENT{{{{ENTRY POINT{17537
{{MOV{22,=P$SPS{8,WB{{SET PCODE FOR SINGLE CHAR ARG{17538
{{MOV{22,=P$SPN{7,XL{{SET PCODE FOR MULTI-CHAR ARG{17539
{{MOV{22,=P$SPD{8,WC{{SET PCODE FOR EXPRESSION ARG{17540
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{17541
{{ERR{1,188{26,SPAN argument is not a string or expression{{{17542
{{MOV{7,XR{11,-(XS){{STACK RESULT{17543
{{LCW{7,XR{{{GET NEXT CODE WORD{17544
{{BRI{9,(XR){{{EXECUTE IT{17545
{{EJC{{{{{17546
*
*      SIZE
*
{S$SI${ENT{{{{ENTRY POINT{17550
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{17552
{{ERR{1,189{26,SIZE argument is not a string{{{17553
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH.
*
{{MTI{8,WA{{{LOAD LENGTH AS INTEGER{17561
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{17562
{{EJC{{{{{17563
*
*      STOPTR
*
{S$STT{ENT{{{{ENTRY POINT{17567
{{ZER{7,XL{{{INDICATE STOPTR CASE{17568
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{17569
{{ERR{1,190{26,STOPTR first argument is not appropriate name{{{17570
{{ERR{1,191{26,STOPTR second argument is not trace type{{{17571
{{BRN{6,EXNUL{{{RETURN NULL{17572
{{EJC{{{{{17573
*
*      SUBSTR
*
{S$SUB{ENT{{{{ENTRY POINT{17577
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{17578
{{ERR{1,192{26,SUBSTR third argument is not integer{{{17579
{{PPM{6,EXFAL{{{JUMP IF NEGATIVE OR TOO LARGE{17580
{{MOV{7,XR{3,SBSSV{{SAVE THIRD ARGUMENT{17581
{{JSR{6,GTSMI{{{LOAD SECOND ARGUMENT{17582
{{ERR{1,193{26,SUBSTR second argument is not integer{{{17583
{{PPM{6,EXFAL{{{JUMP IF OUT OF RANGE{17584
{{MOV{7,XR{8,WC{{SAVE SECOND ARGUMENT{17585
{{BZE{8,WC{6,EXFAL{{JUMP IF SECOND ARGUMENT ZERO{17586
{{DCV{8,WC{{{ELSE DECREMENT FOR ONES ORIGIN{17587
{{JSR{6,GTSTG{{{LOAD FIRST ARGUMENT{17589
{{ERR{1,194{26,SUBSTR first argument is not a string{{{17590
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH
*
{{MOV{8,WC{8,WB{{COPY SECOND ARG TO WB{17598
{{MOV{3,SBSSV{8,WC{{RELOAD THIRD ARGUMENT{17599
{{BNZ{8,WC{6,SSUB2{{SKIP IF THIRD ARG GIVEN{17600
{{MOV{8,WA{8,WC{{ELSE GET STRING LENGTH{17601
{{BGT{8,WB{8,WC{6,EXFAL{FAIL IF IMPROPER{17602
{{SUB{8,WB{8,WC{{REDUCE BY OFFSET TO START{17603
*
*      MERGE
*
{SSUB2{MOV{8,WA{7,XL{{SAVE STRING LENGTH{17607
{{MOV{8,WC{8,WA{{SET LENGTH OF SUBSTRING{17608
{{ADD{8,WB{8,WC{{ADD 2ND ARG TO 3RD ARG{17609
{{BGT{8,WC{7,XL{6,EXFAL{JUMP IF IMPROPER SUBSTRING{17610
{{MOV{7,XR{7,XL{{COPY POINTER TO FIRST ARG{17611
{{JSR{6,SBSTR{{{BUILD SUBSTRING{17612
{{MOV{7,XR{11,-(XS){{STACK RESULT{17613
{{LCW{7,XR{{{GET NEXT CODE WORD{17614
{{BRI{9,(XR){{{EXECUTE IT{17615
{{EJC{{{{{17616
*
*      TABLE
*
{S$TBL{ENT{{{{ENTRY POINT{17620
{{MOV{10,(XS)+{7,XL{{GET INITIAL LOOKUP VALUE{17621
{{ICA{7,XS{{{POP SECOND ARGUMENT{17622
{{JSR{6,GTSMI{{{LOAD ARGUMENT{17623
{{ERR{1,195{26,TABLE argument is not integer{{{17624
{{ERR{1,196{26,TABLE argument is out of range{{{17625
{{BNZ{8,WC{6,STBL1{{JUMP IF NON-ZERO{17626
{{MOV{18,=TBNBK{8,WC{{ELSE SUPPLY DEFAULT VALUE{17627
*
*      MERGE HERE WITH NUMBER OF HEADERS IN WC
*
{STBL1{JSR{6,TMAKE{{{MAKE TABLE{17631
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{17632
{{EJC{{{{{17633
*
*      TAN
*
{S$TAN{ENT{{{{ENTRY POINT{17638
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17639
{{JSR{6,GTREA{{{CONVERT TO REAL{17640
{{ERR{1,309{26,TAN argument not numeric{{{17641
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17642
{{TAN{{{{TAKE TANGENT{17643
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{17644
{{ERB{1,310{26,TAN produced real overflow or argument is out of range{{{17645
{{EJC{{{{{17646
*
*      TIME
*
{S$TIM{ENT{{{{ENTRY POINT{17651
{{JSR{6,SYSTM{{{GET TIMER VALUE{17652
{{SBI{3,TIMSX{{{SUBTRACT STARTING TIME{17653
{{BRN{6,EXINT{{{EXIT WITH INTEGER VALUE{17654
{{EJC{{{{{17655
*
*      TRACE
*
{S$TRA{ENT{{{{ENTRY POINT{17659
{{BEQ{13,NUM03(XS){21,=NULLS{6,STR02{JUMP IF FIRST ARGUMENT IS NULL{17660
{{MOV{10,(XS)+{7,XR{{LOAD FOURTH ARGUMENT{17661
{{ZER{7,XL{{{TENTATIVELY SET ZERO POINTER{17662
{{BEQ{7,XR{21,=NULLS{6,STR01{JUMP IF 4TH ARGUMENT IS NULL{17663
{{JSR{6,GTNVR{{{ELSE POINT TO VRBLK{17664
{{PPM{6,STR03{{{JUMP IF NOT VARIABLE NAME{17665
{{MOV{7,XR{7,XL{{ELSE SAVE VRBLK IN TRFNC{17666
*
*      HERE WITH VRBLK OR ZERO IN XL
*
{STR01{MOV{10,(XS)+{7,XR{{LOAD THIRD ARGUMENT (TAG){17670
{{ZER{8,WB{{{SET ZERO AS TRTYP VALUE FOR NOW{17671
{{JSR{6,TRBLD{{{BUILD TRBLK FOR TRACE CALL{17672
{{MOV{7,XR{7,XL{{MOVE TRBLK POINTER FOR TRACE{17673
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{17674
{{ERR{1,198{26,TRACE first argument is not appropriate name{{{17675
{{ERR{1,199{26,TRACE second argument is not trace type{{{17676
{{BRN{6,EXNUL{{{RETURN NULL{17677
*
*      HERE TO CALL SYSTEM TRACE TOGGLE ROUTINE
*
{STR02{JSR{6,SYSTT{{{CALL IT{17681
{{ADD{19,*NUM04{7,XS{{POP TRACE ARGUMENTS{17682
{{BRN{6,EXNUL{{{RETURN{17683
*
*      HERE FOR BAD FOURTH ARGUMENT
*
{STR03{ERB{1,197{26,TRACE fourth arg is not function name or null{{{17687
{{EJC{{{{{17688
*
*      TRIM
*
{S$TRM{ENT{{{{ENTRY POINT{17692
{{JSR{6,GTSTG{{{LOAD ARGUMENT AS STRING{17694
{{ERR{1,200{26,TRIM argument is not a string{{{17695
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF ARGUMENT IS NULL{17701
{{MOV{7,XR{7,XL{{COPY STRING POINTER{17702
{{CTB{8,WA{2,SCHAR{{GET BLOCK LENGTH{17703
{{JSR{6,ALLOC{{{ALLOCATE COPY SAME SIZE{17704
{{MOV{7,XR{8,WB{{SAVE POINTER TO COPY{17705
{{MVW{{{{COPY OLD STRING BLOCK TO NEW{17706
{{MOV{8,WB{7,XR{{RESTORE PTR TO NEW BLOCK{17707
{{JSR{6,TRIMR{{{TRIM BLANKS (WB IS NON-ZERO){17708
{{MOV{7,XR{11,-(XS){{STACK RESULT{17709
{{LCW{7,XR{{{GET NEXT CODE WORD{17710
{{BRI{9,(XR){{{EXECUTE IT{17711
{{EJC{{{{{17754
*
*      UNLOAD
*
{S$UNL{ENT{{{{ENTRY POINT{17758
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{17759
{{JSR{6,GTNVR{{{POINT TO VRBLK{17760
{{ERR{1,201{26,UNLOAD argument is not natural variable name{{{17761
{{MOV{21,=STNDF{7,XL{{GET PTR TO UNDEFINED FUNCTION{17762
{{JSR{6,DFFNC{{{UNDEFINE NAMED FUNCTION{17763
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{17764
{{TTL{27,S P I T B O L -- UTILITY ROUTINES{{{{17786
*
*      THE FOLLOWING SECTION CONTAINS UTILITY ROUTINES USED FOR
*      VARIOUS PURPOSES THROUGHOUT THE SYSTEM. THESE DIFFER
*      FROM THE PROCEDURES IN THE UTILITY PROCEDURES SECTION IN
*      THEY ARE NOT IN PROCEDURE FORM AND THEY DO NOT RETURN
*      TO THEIR CALLERS. THEY ARE ACCESSED WITH A BRANCH TYPE
*      INSTRUCTION AFTER SETTING THE REGISTERS TO APPROPRIATE
*      PARAMETER VALUES.
*
*      THE REGISTER VALUES REQUIRED FOR EACH ROUTINE ARE
*      DOCUMENTED AT THE START OF EACH ROUTINE. REGISTERS NOT
*      MENTIONED MAY CONTAIN ANY VALUES EXCEPT THAT XR,XL
*      CAN ONLY CONTAIN PROPER COLLECTABLE POINTERS.
*
*      SOME OF THESE ROUTINES WILL TOLERATE GARBAGE POINTERS
*      IN XL,XR ON ENTRY. THIS IS ALWAYS DOCUMENTED AND IN
*      EACH CASE, THE ROUTINE CLEARS THESE GARBAGE VALUES BEFORE
*      EXITING AFTER COMPLETING ITS TASK.
*
*      THE ROUTINES HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE ASSEMBLED IN ALPHABETICAL ORDER.
{{EJC{{{{{17808
*      ARREF -- ARRAY REFERENCE
*
*      (XL)                  MAY BE NON-COLLECTABLE
*      (XR)                  NUMBER OF SUBSCRIPTS
*      (WB)                  SET ZERO/NONZERO FOR VALUE/NAME
*                            THE VALUE IN WB MUST BE COLLECTABLE
*      STACK                 SUBSCRIPTS AND ARRAY OPERAND
*      BRN  ARREF            JUMP TO CALL FUNCTION
*
*      ARREF CONTINUES BY EXECUTING THE NEXT CODE WORD WITH
*      THE RESULT NAME OR VALUE PLACED ON TOP OF THE STACK.
*      TO DEAL WITH THE PROBLEM OF ACCESSING SUBSCRIPTS IN THE
*      ORDER OF STACKING, XL IS USED AS A SUBSCRIPT POINTER
*      WORKING BELOW THE STACK POINTER.
*
{ARREF{RTN{{{{{17824
{{MOV{7,XR{8,WA{{COPY NUMBER OF SUBSCRIPTS{17825
{{MOV{7,XS{7,XT{{POINT TO STACK FRONT{17826
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{17827
{{ADD{7,XR{7,XT{{POINT TO ARRAY OPERAND ON STACK{17828
{{ICA{7,XT{{{FINAL VALUE FOR STACK POPPING{17829
{{MOV{7,XT{3,ARFXS{{KEEP FOR LATER{17830
{{MOV{11,-(XT){7,XR{{LOAD ARRAY OPERAND POINTER{17831
{{MOV{7,XR{3,R$ARF{{KEEP ARRAY POINTER{17832
{{MOV{7,XT{7,XR{{SAVE POINTER TO SUBSCRIPTS{17833
{{MOV{3,R$ARF{7,XL{{POINT XL TO POSSIBLE VCBLK OR TBBLK{17834
{{MOV{9,(XL){8,WC{{LOAD FIRST WORD{17835
{{BEQ{8,WC{22,=B$ART{6,ARF01{JUMP IF ARBLK{17836
{{BEQ{8,WC{22,=B$VCT{6,ARF07{JUMP IF VCBLK{17837
{{BEQ{8,WC{22,=B$TBT{6,ARF10{JUMP IF TBBLK{17838
{{ERB{1,235{26,Subscripted operand is not table or array{{{17839
*
*      HERE FOR ARRAY (ARBLK)
*
{ARF01{BNE{8,WA{13,ARNDM(XL){6,ARF09{JUMP IF WRONG NUMBER OF DIMS{17843
{{LDI{4,INTV0{{{GET INITIAL SUBSCRIPT OF ZERO{17844
{{MOV{7,XR{7,XT{{POINT BEFORE SUBSCRIPTS{17845
{{ZER{8,WA{{{INITIAL OFFSET TO BOUNDS{17846
{{BRN{6,ARF03{{{JUMP INTO LOOP{17847
*
*      LOOP TO COMPUTE SUBSCRIPTS BY MULTIPLICATIONS
*
{ARF02{MLI{13,ARDM2(XR){{{MULTIPLY TOTAL BY NEXT DIMENSION{17851
*
*      MERGE HERE FIRST TIME
*
{ARF03{MOV{11,-(XT){7,XR{{LOAD NEXT SUBSCRIPT{17855
{{STI{3,ARFSI{{{SAVE CURRENT SUBSCRIPT{17856
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE IN CASE{17857
{{BEQ{9,(XR){22,=B$ICL{6,ARF04{JUMP IF IT WAS AN INTEGER{17858
{{EJC{{{{{17859
*
*      ARREF (CONTINUED)
*
*
{{JSR{6,GTINT{{{CONVERT TO INTEGER{17864
{{PPM{6,ARF12{{{JUMP IF NOT INTEGER{17865
{{LDI{13,ICVAL(XR){{{IF OK, LOAD INTEGER VALUE{17866
*
*      HERE WITH INTEGER SUBSCRIPT IN (IA)
*
{ARF04{MOV{3,R$ARF{7,XR{{POINT TO ARRAY{17870
{{ADD{8,WA{7,XR{{OFFSET TO NEXT BOUNDS{17871
{{SBI{13,ARLBD(XR){{{SUBTRACT LOW BOUND TO COMPARE{17872
{{IOV{6,ARF13{{{OUT OF RANGE FAIL IF OVERFLOW{17873
{{ILT{6,ARF13{{{OUT OF RANGE FAIL IF TOO SMALL{17874
{{SBI{13,ARDIM(XR){{{SUBTRACT DIMENSION{17875
{{IGE{6,ARF13{{{OUT OF RANGE FAIL IF TOO LARGE{17876
{{ADI{13,ARDIM(XR){{{ELSE RESTORE SUBSCRIPT OFFSET{17877
{{ADI{3,ARFSI{{{ADD TO CURRENT TOTAL{17878
{{ADD{19,*ARDMS{8,WA{{POINT TO NEXT BOUNDS{17879
{{BNE{7,XT{7,XS{6,ARF02{LOOP BACK IF MORE TO GO{17880
*
*      HERE WITH INTEGER SUBSCRIPT COMPUTED
*
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{17884
{{WTB{8,WA{{{CONVERT TO OFFSET{17885
{{MOV{3,R$ARF{7,XL{{POINT TO ARBLK{17886
{{ADD{13,AROFS(XL){8,WA{{ADD OFFSET PAST BOUNDS{17887
{{ICA{8,WA{{{ADJUST FOR ARPRO FIELD{17888
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{17889
*
*      MERGE HERE TO GET VALUE FOR VALUE CALL
*
{ARF05{JSR{6,ACESS{{{GET VALUE{17893
{{PPM{6,ARF13{{{FAIL IF ACESS FAILS{17894
*
*      RETURN VALUE
*
{ARF06{MOV{3,ARFXS{7,XS{{POP STACK ENTRIES{17898
{{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17899
{{MOV{7,XR{11,-(XS){{STACK RESULT{17900
{{LCW{7,XR{{{GET NEXT CODE WORD{17901
{{BRI{9,(XR){{{EXECUTE IT{17902
{{EJC{{{{{17903
*
*      ARREF (CONTINUED)
*
*      HERE FOR VECTOR
*
{ARF07{BNE{8,WA{18,=NUM01{6,ARF09{ERROR IF MORE THAN 1 SUBSCRIPT{17909
{{MOV{9,(XS){7,XR{{ELSE LOAD SUBSCRIPT{17910
{{JSR{6,GTINT{{{CONVERT TO INTEGER{17911
{{PPM{6,ARF12{{{ERROR IF NOT INTEGER{17912
{{LDI{13,ICVAL(XR){{{ELSE LOAD INTEGER VALUE{17913
{{SBI{4,INTV1{{{SUBTRACT FOR ONES OFFSET{17914
{{MFI{8,WA{6,ARF13{{GET SUBSCRIPT AS ONE WORD{17915
{{ADD{18,=VCVLS{8,WA{{ADD OFFSET FOR STANDARD FIELDS{17916
{{WTB{8,WA{{{CONVERT OFFSET TO BYTES{17917
{{BGE{8,WA{13,VCLEN(XL){6,ARF13{FAIL IF OUT OF RANGE SUBSCRIPT{17918
{{BZE{8,WB{6,ARF05{{BACK TO GET VALUE IF VALUE CALL{17919
*
*      RETURN NAME
*
{ARF08{MOV{3,ARFXS{7,XS{{POP STACK ENTRIES{17923
{{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17924
{{BRN{6,EXNAM{{{ELSE EXIT WITH NAME{17925
*
*      HERE IF SUBSCRIPT COUNT IS WRONG
*
{ARF09{ERB{1,236{26,Array referenced with wrong number of subscripts{{{17929
*
*      TABLE
*
{ARF10{BNE{8,WA{18,=NUM01{6,ARF11{ERROR IF MORE THAN 1 SUBSCRIPT{17933
{{MOV{9,(XS){7,XR{{ELSE LOAD SUBSCRIPT{17934
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{17935
{{PPM{6,ARF13{{{FAIL IF FAILED{17936
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{17937
{{BRN{6,ARF06{{{ELSE EXIT WITH VALUE{17938
*
*      HERE FOR BAD TABLE REFERENCE
*
{ARF11{ERB{1,237{26,Table referenced with more than one subscript{{{17942
*
*      HERE FOR BAD SUBSCRIPT
*
{ARF12{ERB{1,238{26,Array subscript is not integer{{{17946
*
*      HERE TO SIGNAL FAILURE
*
{ARF13{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17950
{{BRN{6,EXFAL{{{FAIL{17951
{{EJC{{{{{17952
*
*      CFUNC -- CALL A FUNCTION
*
*      CFUNC IS USED TO CALL A SNOBOL LEVEL FUNCTION. IT IS
*      USED BY THE APPLY FUNCTION (S$APP), THE FUNCTION
*      TRACE ROUTINE (TRXEQ) AND THE MAIN FUNCTION CALL ENTRY
*      (O$FNC, O$FNS). IN THE LATTER CASES, CFUNC IS USED ONLY
*      IF THE NUMBER OF ARGUMENTS IS INCORRECT.
*
*      (XL)                  POINTER TO FUNCTION BLOCK
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS
*      (XS)                  POINTS TO STACKED ARGUMENTS
*      BRN  CFUNC            JUMP TO CALL FUNCTION
*
*      CFUNC CONTINUES BY EXECUTING THE FUNCTION
*
{CFUNC{RTN{{{{{17969
{{BLT{8,WA{13,FARGS(XL){6,CFNC1{JUMP IF TOO FEW ARGUMENTS{17970
{{BEQ{8,WA{13,FARGS(XL){6,CFNC3{JUMP IF CORRECT NUMBER OF ARGS{17971
*
*      HERE IF TOO MANY ARGUMENTS SUPPLIED, POP THEM OFF
*
{{MOV{8,WA{8,WB{{COPY ACTUAL NUMBER{17975
{{SUB{13,FARGS(XL){8,WB{{GET NUMBER OF EXTRA ARGS{17976
{{WTB{8,WB{{{CONVERT TO BYTES{17977
{{ADD{8,WB{7,XS{{POP OFF UNWANTED ARGUMENTS{17978
{{BRN{6,CFNC3{{{JUMP TO GO OFF TO FUNCTION{17979
*
*      HERE IF TOO FEW ARGUMENTS
*
{CFNC1{MOV{13,FARGS(XL){8,WB{{LOAD REQUIRED NUMBER OF ARGUMENTS{17983
{{BEQ{8,WB{18,=NINI9{6,CFNC3{JUMP IF CASE OF VAR NUM OF ARGS{17984
{{SUB{8,WA{8,WB{{CALCULATE NUMBER MISSING{17985
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{17986
*
*      LOOP TO SUPPLY EXTRA NULL ARGUMENTS
*
{CFNC2{MOV{21,=NULLS{11,-(XS){{STACK A NULL ARGUMENT{17990
{{BCT{8,WB{6,CFNC2{{LOOP TILL PROPER NUMBER STACKED{17991
*
*      MERGE HERE TO JUMP TO FUNCTION
*
{CFNC3{BRI{9,(XL){{{JUMP THROUGH FCODE FIELD{17995
{{EJC{{{{{17996
*
*      EXFAL -- EXIT SIGNALLING SNOBOL FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXFAL            JUMP TO FAIL
*
*      EXFAL CONTINUES BY EXECUTING THE APPROPRIATE FAIL GOTO
*
{EXFAL{RTN{{{{{18005
{{MOV{3,FLPTR{7,XS{{POP STACK{18006
{{MOV{9,(XS){7,XR{{LOAD FAILURE OFFSET{18007
{{ADD{3,R$COD{7,XR{{POINT TO FAILURE CODE LOCATION{18008
{{LCP{7,XR{{{SET CODE POINTER{18009
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18010
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18011
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18012
{{EJC{{{{{18013
*
*      EXINT -- EXIT WITH INTEGER RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (IA)                  INTEGER VALUE
*      BRN  EXINT            JUMP TO EXIT WITH INTEGER
*
*      EXINT CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXIXR
*
{EXINT{RTN{{{{{18024
{{ZER{7,XL{{{CLEAR DUD VALUE{18025
{{JSR{6,ICBLD{{{BUILD ICBLK{18026
{{EJC{{{{{18027
*      EXIXR -- EXIT WITH RESULT IN (XR)
*
*      (XR)                  RESULT
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXIXR            JUMP TO EXIT WITH RESULT IN (XR)
*
*      EXIXR CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXITS.
{EXIXR{RTN{{{{{18036
*
{{MOV{7,XR{11,-(XS){{STACK RESULT{18038
*
*
*      EXITS -- EXIT WITH RESULT IF ANY STACKED
*
*      (XR,XL)               MAY BE NON-COLLECTABLE
*
*      BRN  EXITS            ENTER EXITS ROUTINE
*
{EXITS{RTN{{{{{18047
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18048
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18049
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18050
{{EJC{{{{{18051
*
*      EXNAM -- EXIT WITH NAME IN (XL,WA)
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      (XR)                  MAY BE NON-COLLECTABLE
*      BRN  EXNAM            JUMP TO EXIT WITH NAME IN (XL,WA)
*
*      EXNAM CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNAM{RTN{{{{{18062
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{18063
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{18064
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18065
{{BRI{9,(XR){{{EXECUTE IT{18066
{{EJC{{{{{18067
*
*      EXNUL -- EXIT WITH NULL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXNUL            JUMP TO EXIT WITH NULL VALUE
*
*      EXNUL CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNUL{RTN{{{{{18076
{{MOV{21,=NULLS{11,-(XS){{STACK NULL VALUE{18077
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18078
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18079
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18080
{{EJC{{{{{18081
*
*      EXREA -- EXIT WITH REAL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (RA)                  REAL VALUE
*      BRN  EXREA            JUMP TO EXIT WITH REAL VALUE
*
*      EXREA CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXREA{RTN{{{{{18093
{{ZER{7,XL{{{CLEAR DUD VALUE{18094
{{JSR{6,RCBLD{{{BUILD RCBLK{18095
{{BRN{6,EXIXR{{{JUMP TO EXIT WITH RESULT IN XR{18096
{{EJC{{{{{18098
*
*      EXSID -- EXIT SETTING ID FIELD
*
*      EXSID IS USED TO EXIT AFTER BUILDING ANY OF THE FOLLOWING
*      BLOCKS (ARBLK, TBBLK, PDBLK, VCBLK). IT SETS THE IDVAL.
*
*      (XR)                  PTR TO BLOCK WITH IDVAL FIELD
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXSID            JUMP TO EXIT AFTER SETTING ID FIELD
*
*      EXSID CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXSID{RTN{{{{{18111
{{MOV{3,CURID{8,WA{{LOAD CURRENT ID VALUE{18112
{{BNE{8,WA{18,=CFP$M{6,EXSI1{JUMP IF NO OVERFLOW{18113
{{ZER{8,WA{{{ELSE RESET FOR WRAPAROUND{18114
*
*      HERE WITH OLD IDVAL IN WA
*
{EXSI1{ICV{8,WA{{{BUMP ID VALUE{18118
{{MOV{8,WA{3,CURID{{STORE FOR NEXT TIME{18119
{{MOV{8,WA{13,IDVAL(XR){{STORE ID VALUE{18120
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN (XR){18121
{{EJC{{{{{18122
*
*      EXVNM -- EXIT WITH NAME OF VARIABLE
*
*      EXVNM EXITS AFTER STACKING A VALUE WHICH IS A NMBLK
*      REFERENCING THE NAME OF A GIVEN NATURAL VARIABLE.
*
*      (XR)                  VRBLK POINTER
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXVNM            EXIT WITH VRBLK POINTER IN XR
*
{EXVNM{RTN{{{{{18133
{{MOV{7,XR{7,XL{{COPY NAME BASE POINTER{18134
{{MOV{19,*NMSI${8,WA{{SET SIZE OF NMBLK{18135
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{18136
{{MOV{22,=B$NML{9,(XR){{STORE TYPE WORD{18137
{{MOV{7,XL{13,NMBAS(XR){{STORE NAME BASE{18138
{{MOV{19,*VRVAL{13,NMOFS(XR){{STORE NAME OFFSET{18139
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN XR{18140
{{EJC{{{{{18141
*
*      FLPOP -- FAIL AND POP IN PATTERN MATCHING
*
*      FLPOP POPS THE NODE AND CURSOR ON THE STACK AND THEN
*      DROPS THROUGH INTO FAILP TO CAUSE PATTERN FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FLPOP            JUMP TO FAIL AND POP STACK
*
{FLPOP{RTN{{{{{18151
{{ADD{19,*NUM02{7,XS{{POP TWO ENTRIES OFF STACK{18152
{{EJC{{{{{18153
*
*      FAILP -- FAILURE IN MATCHING PATTERN NODE
*
*      FAILP IS USED AFTER FAILING TO MATCH A PATTERN NODE.
*      SEE PATTERN MATCH ROUTINES FOR DETAILS OF USE.
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FAILP            SIGNAL FAILURE TO MATCH
*
*      FAILP CONTINUES BY MATCHING AN ALTERNATIVE FROM THE STACK
*
{FAILP{RTN{{{{{18165
{{MOV{10,(XS)+{7,XR{{LOAD ALTERNATIVE NODE POINTER{18166
{{MOV{10,(XS)+{8,WB{{RESTORE OLD CURSOR{18167
{{MOV{9,(XR){7,XL{{LOAD PCODE ENTRY POINTER{18168
{{BRI{7,XL{{{JUMP TO EXECUTE CODE FOR NODE{18169
{{EJC{{{{{18170
*
*      INDIR -- COMPUTE INDIRECT REFERENCE
*
*      (WB)                  NONZERO/ZERO FOR BY NAME/VALUE
*      BRN  INDIR            JUMP TO GET INDIRECT REF ON STACK
*
*      INDIR CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{INDIR{RTN{{{{{18179
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{18180
{{BEQ{9,(XR){22,=B$NML{6,INDR2{JUMP IF A NAME{18181
{{JSR{6,GTNVR{{{ELSE CONVERT TO VARIABLE{18182
{{ERR{1,239{26,Indirection operand is not name{{{18183
{{BZE{8,WB{6,INDR1{{SKIP IF BY VALUE{18184
{{MOV{7,XR{11,-(XS){{ELSE STACK VRBLK PTR{18185
{{MOV{19,*VRVAL{11,-(XS){{STACK NAME OFFSET{18186
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18187
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18188
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18189
*
*      HERE TO GET VALUE OF NATURAL VARIABLE
*
{INDR1{BRI{9,(XR){{{JUMP THROUGH VRGET FIELD OF VRBLK{18193
*
*      HERE IF OPERAND IS A NAME
*
{INDR2{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{18197
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{18198
{{BNZ{8,WB{6,EXNAM{{EXIT IF CALLED BY NAME{18199
{{JSR{6,ACESS{{{ELSE GET VALUE FIRST{18200
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18201
{{BRN{6,EXIXR{{{ELSE RETURN WITH VALUE IN XR{18202
{{EJC{{{{{18203
*
*      MATCH -- INITIATE PATTERN MATCH
*
*      (WB)                  MATCH TYPE CODE
*      BRN  MATCH            JUMP TO INITIATE PATTERN MATCH
*
*      MATCH CONTINUES BY EXECUTING THE PATTERN MATCH. SEE
*      PATTERN MATCH ROUTINES (P$XXX) FOR FULL DETAILS.
*
{MATCH{RTN{{{{{18213
{{MOV{10,(XS)+{7,XR{{LOAD PATTERN OPERAND{18214
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{18215
{{ERR{1,240{26,Pattern match right operand is not pattern{{{18216
{{MOV{7,XR{7,XL{{IF OK, SAVE PATTERN POINTER{18217
{{BNZ{8,WB{6,MTCH1{{JUMP IF NOT MATCH BY NAME{18218
{{MOV{9,(XS){8,WA{{ELSE LOAD NAME OFFSET{18219
{{MOV{7,XL{11,-(XS){{SAVE PATTERN POINTER{18220
{{MOV{13,NUM02(XS){7,XL{{LOAD NAME BASE{18221
{{JSR{6,ACESS{{{ACCESS SUBJECT VALUE{18222
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18223
{{MOV{9,(XS){7,XL{{RESTORE PATTERN POINTER{18224
{{MOV{7,XR{9,(XS){{STACK SUBJECT STRING VAL FOR MERGE{18225
{{ZER{8,WB{{{RESTORE TYPE CODE{18226
*
*      MERGE HERE WITH SUBJECT VALUE ON STACK
*
{MTCH1{JSR{6,GTSTG{{{CONVERT SUBJECT TO STRING{18231
{{ERR{1,241{26,Pattern match left operand is not a string{{{18232
{{MOV{8,WB{11,-(XS){{STACK MATCH TYPE CODE{18233
{{MOV{7,XR{3,R$PMS{{IF OK, STORE SUBJECT STRING POINTER{18241
{{MOV{8,WA{3,PMSSL{{AND LENGTH{18242
{{ZER{11,-(XS){{{STACK INITIAL CURSOR (ZERO){18243
{{ZER{8,WB{{{SET INITIAL CURSOR{18244
{{MOV{7,XS{3,PMHBS{{SET HISTORY STACK BASE PTR{18245
{{ZER{3,PMDFL{{{RESET PATTERN ASSIGNMENT FLAG{18246
{{MOV{7,XL{7,XR{{SET INITIAL NODE POINTER{18247
{{BNZ{3,KVANC{6,MTCH2{{JUMP IF ANCHORED{18248
*
*      HERE FOR UNANCHORED
*
{{MOV{7,XR{11,-(XS){{STACK INITIAL NODE POINTER{18252
{{MOV{21,=NDUNA{11,-(XS){{STACK POINTER TO ANCHOR MOVE NODE{18253
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{18254
*
*      HERE IN ANCHORED MODE
*
{MTCH2{ZER{11,-(XS){{{DUMMY CURSOR VALUE{18258
{{MOV{21,=NDABO{11,-(XS){{STACK POINTER TO ABORT NODE{18259
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{18260
{{EJC{{{{{18261
*
*      RETRN -- RETURN FROM FUNCTION
*
*      (WA)                  STRING POINTER FOR RETURN TYPE
*      BRN  RETRN            JUMP TO RETURN FROM (SNOBOL) FUNC
*
*      RETRN CONTINUES BY EXECUTING THE CODE AT THE RETURN POINT
*      THE STACK IS CLEANED OF ANY GARBAGE LEFT BY OTHER
*      ROUTINES WHICH MAY HAVE ALTERED FLPTR SINCE FUNCTION
*      ENTRY BY USING FLPRT, RESERVED FOR USE ONLY BY
*      FUNCTION CALL AND RETURN.
*
{RETRN{RTN{{{{{18274
{{BNZ{3,KVFNC{6,RTN01{{JUMP IF NOT LEVEL ZERO{18275
{{ERB{1,242{26,Function return from level zero{{{18276
*
*      HERE IF NOT LEVEL ZERO RETURN
*
{RTN01{MOV{3,FLPRT{7,XS{{POP STACK{18280
{{ICA{7,XS{{{REMOVE FAILURE OFFSET{18281
{{MOV{10,(XS)+{7,XR{{POP PFBLK POINTER{18282
{{MOV{10,(XS)+{3,FLPTR{{POP FAILURE POINTER{18283
{{MOV{10,(XS)+{3,FLPRT{{POP OLD FLPRT{18284
{{MOV{10,(XS)+{8,WB{{POP CODE POINTER OFFSET{18285
{{MOV{10,(XS)+{8,WC{{POP OLD CODE BLOCK POINTER{18286
{{ADD{8,WC{8,WB{{MAKE OLD CODE POINTER ABSOLUTE{18287
{{LCP{8,WB{{{RESTORE OLD CODE POINTER{18288
{{MOV{8,WC{3,R$COD{{RESTORE OLD CODE BLOCK POINTER{18289
{{DCV{3,KVFNC{{{DECREMENT FUNCTION LEVEL{18290
{{MOV{3,KVTRA{8,WB{{LOAD TRACE{18291
{{ADD{3,KVFTR{8,WB{{ADD FTRACE{18292
{{BZE{8,WB{6,RTN06{{JUMP IF NO TRACING POSSIBLE{18293
*
*      HERE IF THERE MAY BE A TRACE
*
{{MOV{8,WA{11,-(XS){{SAVE FUNCTION RETURN TYPE{18297
{{MOV{7,XR{11,-(XS){{SAVE PFBLK POINTER{18298
{{MOV{8,WA{3,KVRTN{{SET RTNTYPE FOR TRACE FUNCTION{18299
{{MOV{3,R$FNC{7,XL{{LOAD FNCLEVEL TRBLK PTR (IF ANY){18300
{{JSR{6,KTREX{{{EXECUTE POSSIBLE FNCLEVEL TRACE{18301
{{MOV{13,PFVBL(XR){7,XL{{LOAD VRBLK PTR (SGD13){18302
{{BZE{3,KVTRA{6,RTN02{{JUMP IF TRACE IS OFF{18303
{{MOV{13,PFRTR(XR){7,XR{{ELSE LOAD RETURN TRACE TRBLK PTR{18304
{{BZE{7,XR{6,RTN02{{JUMP IF NOT RETURN TRACED{18305
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{18306
{{BZE{13,TRFNC(XR){6,RTN03{{JUMP IF PRINT TRACE{18307
{{MOV{19,*VRVAL{8,WA{{ELSE SET NAME OFFSET{18308
{{MOV{13,NUM01(XS){3,KVRTN{{MAKE SURE RTNTYPE IS SET RIGHT{18309
{{JSR{6,TRXEQ{{{EXECUTE FULL TRACE{18310
{{EJC{{{{{18311
*
*      RETRN (CONTINUED)
*
*      HERE TO TEST FOR FTRACE
*
{RTN02{BZE{3,KVFTR{6,RTN05{{JUMP IF FTRACE IS OFF{18317
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{18318
*
*      HERE FOR PRINT TRACE OF FUNCTION RETURN
*
{RTN03{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{18322
{{MOV{13,NUM01(XS){7,XR{{LOAD RETURN TYPE{18323
{{JSR{6,PRTST{{{PRINT IT{18324
{{MOV{18,=CH$BL{8,WA{{LOAD BLANK{18325
{{JSR{6,PRTCH{{{PRINT IT{18326
{{MOV{12,0(XS){7,XL{{LOAD PFBLK PTR{18327
{{MOV{13,PFVBL(XL){7,XL{{LOAD FUNCTION VRBLK PTR{18328
{{MOV{19,*VRVAL{8,WA{{SET VRBLK NAME OFFSET{18329
{{BNE{7,XR{21,=SCFRT{6,RTN04{JUMP IF NOT FRETURN CASE{18330
*
*      FOR FRETURN, JUST PRINT FUNCTION NAME
*
{{JSR{6,PRTNM{{{PRINT NAME{18334
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{18335
{{BRN{6,RTN05{{{MERGE{18336
*
*      HERE FOR RETURN OR NRETURN, PRINT FUNCTION NAME = VALUE
*
{RTN04{JSR{6,PRTNV{{{PRINT NAME = VALUE{18340
*
*      HERE AFTER COMPLETING TRACE
*
{RTN05{MOV{10,(XS)+{7,XR{{POP PFBLK POINTER{18344
{{MOV{10,(XS)+{8,WA{{POP RETURN TYPE STRING{18345
*
*      MERGE HERE IF NO TRACE REQUIRED
*
{RTN06{MOV{8,WA{3,KVRTN{{SET RTNTYPE KEYWORD{18349
{{MOV{13,PFVBL(XR){7,XL{{LOAD POINTER TO FN VRBLK{18350
{{EJC{{{{{18351
*      RETRN (CONTINUED)
*
*      GET VALUE OF FUNCTION
*
{RTN07{MOV{7,XL{3,RTNBP{{SAVE BLOCK POINTER{18356
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{18357
{{BEQ{9,(XL){22,=B$TRT{6,RTN07{LOOP BACK IF TRAPPED{18358
{{MOV{7,XL{3,RTNFV{{ELSE SAVE FUNCTION RESULT VALUE{18359
{{MOV{10,(XS)+{3,RTNSV{{SAVE ORIGINAL FUNCTION VALUE{18360
{{MOV{10,(XS)+{7,XL{{POP SAVED POINTER{18364
{{BZE{7,XL{6,RTN7C{{NO ACTION IF NONE{18365
{{BZE{3,KVPFL{6,RTN7C{{JUMP IF NO PROFILING{18366
{{JSR{6,PRFLU{{{ELSE PROFILE LAST FUNC STMT{18367
{{BEQ{3,KVPFL{18,=NUM02{6,RTN7A{BRANCH ON VALUE OF PROFILE KEYWD{18368
*
*      HERE IF &PROFILE = 1. START TIME MUST BE FRIGGED TO
*      APPEAR EARLIER THAN IT ACTUALLY IS, BY AMOUNT USED BEFORE
*      THE CALL.
*
{{LDI{3,PFSTM{{{LOAD CURRENT TIME{18374
{{SBI{13,ICVAL(XL){{{FRIG BY SUBTRACTING SAVED AMOUNT{18375
{{BRN{6,RTN7B{{{AND MERGE{18376
*
*      HERE IF &PROFILE = 2
*
{RTN7A{LDI{13,ICVAL(XL){{{LOAD SAVED TIME{18380
*
*      BOTH PROFILE TYPES MERGE HERE
*
{RTN7B{STI{3,PFSTM{{{STORE BACK CORRECT START TIME{18384
*
*      MERGE HERE IF NO PROFILING
*
{RTN7C{MOV{13,FARGS(XR){8,WB{{GET NUMBER OF ARGS{18388
{{ADD{13,PFNLO(XR){8,WB{{ADD NUMBER OF LOCALS{18390
{{BZE{8,WB{6,RTN10{{JUMP IF NO ARGS/LOCALS{18391
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{18392
{{ADD{13,PFLEN(XR){7,XR{{AND POINT TO END OF PFBLK{18393
*
*      LOOP TO RESTORE FUNCTIONS AND LOCALS
*
{RTN08{MOV{11,-(XR){7,XL{{LOAD NEXT VRBLK POINTER{18397
*
*      LOOP TO FIND VALUE BLOCK
*
{RTN09{MOV{7,XL{8,WA{{SAVE BLOCK POINTER{18401
{{MOV{13,VRVAL(XL){7,XL{{LOAD POINTER TO NEXT VALUE{18402
{{BEQ{9,(XL){22,=B$TRT{6,RTN09{LOOP BACK IF TRAPPED{18403
{{MOV{8,WA{7,XL{{ELSE RESTORE LAST BLOCK POINTER{18404
{{MOV{10,(XS)+{13,VRVAL(XL){{RESTORE OLD VARIABLE VALUE{18405
{{BCT{8,WB{6,RTN08{{LOOP TILL ALL PROCESSED{18406
*
*      NOW RESTORE FUNCTION VALUE AND EXIT
*
{RTN10{MOV{3,RTNBP{7,XL{{RESTORE PTR TO LAST FUNCTION BLOCK{18410
{{MOV{3,RTNSV{13,VRVAL(XL){{RESTORE OLD FUNCTION VALUE{18411
{{MOV{3,RTNFV{7,XR{{RELOAD FUNCTION RESULT{18412
{{MOV{3,R$COD{7,XL{{POINT TO NEW CODE BLOCK{18413
{{MOV{3,KVSTN{3,KVLST{{SET LASTNO FROM STNO{18414
{{MOV{13,CDSTM(XL){3,KVSTN{{RESET PROPER STNO VALUE{18415
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE FROM LINE{18417
{{MOV{13,CDSLN(XL){3,KVLIN{{RESET PROPER LINE VALUE{18418
{{MOV{3,KVRTN{8,WA{{LOAD RETURN TYPE{18420
{{BEQ{8,WA{21,=SCRTN{6,EXIXR{EXIT WITH RESULT IN XR IF RETURN{18421
{{BEQ{8,WA{21,=SCFRT{6,EXFAL{FAIL IF FRETURN{18422
{{EJC{{{{{18423
*
*      RETRN (CONTINUED)
*
*      HERE FOR NRETURN
*
{{BEQ{9,(XR){22,=B$NML{6,RTN11{JUMP IF IS A NAME{18429
{{JSR{6,GTNVR{{{ELSE TRY CONVERT TO VARIABLE NAME{18430
{{ERR{1,243{26,Function result in NRETURN is not name{{{18431
{{MOV{7,XR{7,XL{{IF OK, COPY VRBLK (NAME BASE) PTR{18432
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{18433
{{BRN{6,RTN12{{{AND MERGE{18434
*
*      HERE IF RETURNED RESULT IS A NAME
*
{RTN11{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{18438
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{18439
*
*      MERGE HERE WITH RETURNED NAME IN (XL,WA)
*
{RTN12{MOV{7,XL{7,XR{{PRESERVE XL{18443
{{LCW{8,WB{{{LOAD NEXT WORD{18444
{{MOV{7,XR{7,XL{{RESTORE XL{18445
{{BEQ{8,WB{21,=OFNE${6,EXNAM{EXIT IF CALLED BY NAME{18446
{{MOV{8,WB{11,-(XS){{ELSE SAVE CODE WORD{18447
{{JSR{6,ACESS{{{GET VALUE{18448
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18449
{{MOV{7,XR{7,XL{{IF OK, COPY RESULT{18450
{{MOV{9,(XS){7,XR{{RELOAD NEXT CODE WORD{18451
{{MOV{7,XL{9,(XS){{STORE RESULT ON STACK{18452
{{MOV{9,(XR){7,XL{{LOAD ROUTINE ADDRESS{18453
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18454
{{EJC{{{{{18455
*
*      STCOV -- SIGNAL STATEMENT COUNTER OVERFLOW
*
*      BRN  STCOV            JUMP TO SIGNAL STATEMENT COUNT OFLO
*
*      PERMIT UP TO 10 MORE STATEMENTS TO BE OBEYED SO THAT
*      SETEXIT TRAP CAN REGAIN CONTROL.
*      STCOV CONTINUES BY ISSUING THE ERROR MESSAGE
*
{STCOV{RTN{{{{{18465
{{ICV{3,ERRFT{{{FATAL ERROR{18466
{{LDI{4,INTVT{{{GET 10{18467
{{ADI{3,KVSTL{{{ADD TO FORMER LIMIT{18468
{{STI{3,KVSTL{{{STORE AS NEW STLIMIT{18469
{{LDI{4,INTVT{{{GET 10{18470
{{STI{3,KVSTC{{{SET AS NEW COUNT{18471
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{18472
{{ERB{1,244{26,Statement count exceeds value of STLIMIT keyword{{{18473
{{EJC{{{{{18474
*
*      STMGO -- START EXECUTION OF NEW STATEMENT
*
*      (XR)                  POINTER TO CDBLK FOR NEW STATEMENT
*      BRN  STMGO            JUMP TO EXECUTE NEW STATEMENT
*
*      STMGO CONTINUES BY EXECUTING THE NEXT STATEMENT
*
{STMGO{RTN{{{{{18483
{{MOV{7,XR{3,R$COD{{SET NEW CODE BLOCK POINTER{18484
{{DCV{3,STMCT{{{SEE IF TIME TO CHECK SOMETHING{18485
{{BZE{3,STMCT{6,STGO2{{JUMP IF SO{18486
{{MOV{3,KVSTN{3,KVLST{{SET LASTNO{18487
{{MOV{13,CDSTM(XR){3,KVSTN{{SET STNO{18488
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE{18490
{{MOV{13,CDSLN(XR){3,KVLIN{{SET LINE{18491
{{ADD{19,*CDCOD{7,XR{{POINT TO FIRST CODE WORD{18493
{{LCP{7,XR{{{SET CODE POINTER{18494
*
*      HERE TO EXECUTE FIRST CODE WORD OF STATEMENT
*
{STGO1{LCW{7,XR{{{LOAD NEXT CODE WORD{18498
{{ZER{7,XL{{{CLEAR GARBAGE XL{18499
{{BRI{9,(XR){{{EXECUTE IT{18500
*
*      CHECK PROFILING, POLLING, STLIMIT, STATEMENT TRACING
*
{STGO2{BZE{3,KVPFL{6,STGO3{{SKIP IF NO PROFILING{18504
{{JSR{6,PRFLU{{{ELSE PROFILE THE STATEMENT IN KVSTN{18505
*
*      HERE WHEN FINISHED WITH PROFILING
*
{STGO3{MOV{3,KVSTN{3,KVLST{{SET LASTNO{18509
{{MOV{13,CDSTM(XR){3,KVSTN{{SET STNO{18510
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE{18512
{{MOV{13,CDSLN(XR){3,KVLIN{{SET LINE{18513
{{ADD{19,*CDCOD{7,XR{{POINT TO FIRST CODE WORD{18515
{{LCP{7,XR{{{SET CODE POINTER{18516
*
*      HERE TO CHECK FOR POLLING
*
{{MOV{3,STMCS{11,-(XS){{SAVE PRESENT COUNT START ON STACK{18521
{{DCV{3,POLCT{{{POLL INTERVAL WITHIN STMCT{18522
{{BNZ{3,POLCT{6,STGO4{{JUMP IF NOT POLL TIME YET{18523
{{ZER{8,WA{{{=0 FOR POLL{18524
{{MOV{3,KVSTN{8,WB{{STATEMENT NUMBER{18525
{{MOV{7,XR{7,XL{{MAKE COLLECTABLE{18526
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{18527
{{ERR{1,320{26,User interrupt{{{18528
{{PPM{{{{SINGLE STEP{18529
{{PPM{{{{EXPRESSION EVALUATION{18530
{{MOV{7,XL{7,XR{{RESTORE CODE BLOCK POINTER{18531
{{MOV{8,WA{3,POLCS{{POLL INTERVAL START VALUE{18532
{{JSR{6,STGCC{{{RECOMPUTE COUNTER VALUES{18533
*
*      CHECK STATEMENT LIMIT
*
{STGO4{LDI{3,KVSTC{{{GET STMT COUNT{18538
{{ILT{6,STGO5{{{OMIT COUNTING IF NEGATIVE{18539
{{MTI{10,(XS)+{{{RELOAD START VALUE OF COUNTER{18540
{{NGI{{{{NEGATE{18541
{{ADI{3,KVSTC{{{STMT COUNT MINUS COUNTER{18542
{{STI{3,KVSTC{{{REPLACE IT{18543
{{ILE{6,STCOV{{{FAIL IF STLIMIT REACHED{18544
{{BZE{3,R$STC{6,STGO5{{JUMP IF NO STATEMENT TRACE{18545
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{18546
{{MOV{3,R$STC{7,XL{{LOAD POINTER TO STCOUNT TRBLK{18547
{{JSR{6,KTREX{{{EXECUTE KEYWORD TRACE{18548
*
*      RESET STMGO COUNTER
*
{STGO5{MOV{3,STMCS{3,STMCT{{RESET COUNTER{18552
{{BRN{6,STGO1{{{FETCH NEXT CODE WORD{18553
{{EJC{{{{{18554
*
*      STOPR -- TERMINATE RUN
*
*      (XR)                  POINTS TO ENDING MESSAGE
*      BRN STOPR             JUMP TO TERMINATE RUN
*
*      TERMINATE RUN AND PRINT STATISTICS.  ON ENTRY XR POINTS
*      TO ENDING MESSAGE OR IS ZERO IF MESSAGE  PRINTED ALREADY.
*
{STOPR{RTN{{{{{18564
{{BZE{7,XR{6,STPRA{{SKIP IF SYSAX ALREADY CALLED{18566
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{18567
{STPRA{ADD{3,RSMEM{3,DNAME{{USE THE RESERVE MEMORY{18568
{{BNE{7,XR{21,=ENDMS{6,STPR0{SKIP IF NOT NORMAL END MESSAGE{18572
{{BNZ{3,EXSTS{6,STPR3{{SKIP IF EXEC STATS SUPPRESSED{18573
{{ZER{3,ERICH{{{CLEAR ERRORS TO INT.CH. FLAG{18574
*
*      LOOK TO SEE IF AN ENDING MESSAGE IS SUPPLIED
*
{STPR0{JSR{6,PRTPG{{{EJECT PRINTER{18578
{{BZE{7,XR{6,STPR1{{SKIP IF NO MESSAGE{18579
{{JSR{6,PRTST{{{PRINT MESSAGE{18580
*
*      MERGE HERE IF NO MESSAGE TO PRINT
*
{STPR1{JSR{6,PRTIS{{{PRINT BLANK LINE{18584
{{BNZ{3,GBCFL{6,STPR5{{IF IN GARBAGE COLLECTION, SKIP{18586
{{MOV{21,=STPM7{7,XR{{POINT TO MESSAGE /IN FILE XXX/{18587
{{JSR{6,PRTST{{{PRINT IT{18588
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{18589
{{MOV{3,KVSTN{8,WC{{GET STATEMENT NUMBER{18590
{{JSR{6,FILNM{{{GET FILE NAME{18591
{{MOV{7,XL{7,XR{{PREPARE TO PRINT{18592
{{JSR{6,PRTST{{{PRINT FILE NAME{18593
{{JSR{6,PRTIS{{{PRINT TO INTERACTIVE CHANNEL{18594
{{MOV{3,R$COD{7,XR{{GET CODE POINTER{18601
{{MTI{13,CDSLN(XR){{{GET SOURCE LINE NUMBER{18602
{{MOV{21,=STPM6{7,XR{{POINT TO MESSAGE /IN LINE XXX/{18603
{{JSR{6,PRTMX{{{PRINT IT{18604
{STPR5{MTI{3,KVSTN{{{GET STATEMENT NUMBER{18606
{{MOV{21,=STPM1{7,XR{{POINT TO MESSAGE /IN STATEMENT XXX/{18607
{{JSR{6,PRTMX{{{PRINT IT{18608
{{JSR{6,SYSTM{{{GET CURRENT TIME{18609
{{SBI{3,TIMSX{{{MINUS START TIME = ELAPSED EXEC TIM{18610
{{STI{3,STPTI{{{SAVE FOR LATER{18611
{{MOV{21,=STPM3{7,XR{{POINT TO MSG /EXECUTION TIME MSEC /{18612
{{JSR{6,PRTMX{{{PRINT IT{18613
{{LDI{3,KVSTL{{{GET STATEMENT LIMIT{18614
{{ILT{6,STPR2{{{SKIP IF NEGATIVE{18615
{{SBI{3,KVSTC{{{MINUS COUNTER = COURSE COUNT{18616
{{STI{3,STPSI{{{SAVE{18617
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER START VALUE{18618
{{SUB{3,STMCT{8,WA{{MINUS CURRENT COUNTER{18619
{{MTI{8,WA{{{CONVERT TO INTEGER{18620
{{ADI{3,STPSI{{{ADD IN COURSE COUNT{18621
{{STI{3,STPSI{{{SAVE{18622
{{MOV{21,=STPM2{7,XR{{POINT TO MESSAGE /STMTS EXECUTED/{18623
{{JSR{6,PRTMX{{{PRINT IT{18624
{{LDI{3,STPTI{{{RELOAD ELAPSED TIME{18627
{{MLI{4,INTTH{{{*1000 (MICROSECS){18628
{{IOV{6,STPR2{{{JUMP IF WE CANNOT COMPUTE{18629
{{DVI{3,STPSI{{{DIVIDE BY STATEMENT COUNT{18630
{{IOV{6,STPR2{{{JUMP IF OVERFLOW{18631
{{MOV{21,=STPM4{7,XR{{POINT TO MSG (MCSEC PER STATEMENT /{18632
{{JSR{6,PRTMX{{{PRINT IT{18633
{{EJC{{{{{18635
*
*      STOPR (CONTINUED)
*
*      MERGE TO SKIP MESSAGE (OVERFLOW OR NEGATIVE STLIMIT)
*
{STPR2{MTI{3,GBCNT{{{LOAD COUNT OF COLLECTIONS{18641
{{MOV{21,=STPM5{7,XR{{POINT TO MESSAGE /REGENERATIONS /{18642
{{JSR{6,PRTMX{{{PRINT IT{18643
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{18644
{{JSR{6,PRTIS{{{ONE MORE BLANK FOR LUCK{18645
*
*      CHECK IF DUMP REQUESTED
*
{STPR3{JSR{6,PRFLR{{{PRINT PROFILE IF WANTED{18652
*
{{MOV{3,KVDMP{7,XR{{LOAD DUMP KEYWORD{18654
{{JSR{6,DUMPR{{{EXECUTE DUMP IF REQUESTED{18656
{{MOV{3,R$FCB{7,XL{{GET FCBLK CHAIN HEAD{18657
{{MOV{3,KVABE{8,WA{{LOAD ABEND VALUE{18658
{{MOV{3,KVCOD{8,WB{{LOAD CODE VALUE{18659
{{JSR{6,SYSEJ{{{EXIT TO SYSTEM{18660
*
*      HERE AFTER SYSEA CALL AND SUPPRESSING ERROR MSG PRINT
*
{STPR4{RTN{{{{{18665
{{ADD{3,RSMEM{3,DNAME{{USE THE RESERVE MEMORY{18666
{{BZE{3,EXSTS{6,STPR1{{IF EXECUTION STATS REQUESTED{18667
{{BRN{6,STPR3{{{CHECK IF DUMP OR PROFILE NEEDED{18668
{{EJC{{{{{18671
*
*      SUCCP -- SIGNAL SUCCESSFUL MATCH OF A PATTERN NODE
*
*      SEE PATTERN MATCH ROUTINES FOR DETAILS
*
*      (XR)                  CURRENT NODE
*      (WB)                  CURRENT CURSOR
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  SUCCP            SIGNAL SUCCESSFUL PATTERN MATCH
*
*      SUCCP CONTINUES BY MATCHING THE SUCCESSOR NODE
*
{SUCCP{RTN{{{{{18684
{{MOV{13,PTHEN(XR){7,XR{{LOAD SUCCESSOR NODE{18685
{{MOV{9,(XR){7,XL{{LOAD NODE CODE ENTRY ADDRESS{18686
{{BRI{7,XL{{{JUMP TO MATCH SUCCESSOR NODE{18687
{{EJC{{{{{18688
*
*      SYSAB -- PRINT /ABNORMAL END/ AND TERMINATE
*
{SYSAB{RTN{{{{{18692
{{MOV{21,=ENDAB{7,XR{{POINT TO MESSAGE{18693
{{MOV{18,=NUM01{3,KVABE{{SET ABEND FLAG{18694
{{JSR{6,PRTNL{{{SKIP TO NEW LINE{18695
{{BRN{6,STOPR{{{JUMP TO PACK UP{18696
{{EJC{{{{{18697
*
*      SYSTU -- PRINT /TIME UP/ AND TERMINATE
*
{SYSTU{RTN{{{{{18701
{{MOV{21,=ENDTU{7,XR{{POINT TO MESSAGE{18702
{{MOV{4,STRTU{8,WA{{GET CHARS /TU/{18703
{{MOV{8,WA{3,KVCOD{{PUT IN KVCOD{18704
{{MOV{3,TIMUP{8,WA{{CHECK STATE OF TIMEUP SWITCH{18705
{{MNZ{3,TIMUP{{{SET SWITCH{18706
{{BNZ{8,WA{6,STOPR{{STOP RUN IF ALREADY SET{18707
{{ERB{1,245{26,Translation/execution time expired{{{18708
{{TTL{27,S P I T B O L -- UTILITY PROCEDURES{{{{18709
*
*      THE FOLLOWING SECTION CONTAINS PROCEDURES WHICH ARE
*      USED FOR VARIOUS PURPOSES THROUGHOUT THE SYSTEM.
*
*      EACH PROCEDURE IS PRECEDED BY A DESCRIPTION OF THE
*      CALLING SEQUENCE. USUALLY THE ARGUMENTS ARE IN REGISTERS
*      BUT ARGUMENTS CAN ALSO OCCUR ON THE STACK AND AS
*      PARAMETERS ASSEMBLED AFTER THE JSR INSTRUCTION.
*
*      THE FOLLOWING CONSIDERATIONS APPLY TO THESE DESCRIPTIONS.
*
*      1)   THE STACK POINTER (XS) IS NOT CHANGED UNLESS THE
*           CHANGE IS EXPLICITLY DOCUMENTED IN THE CALL.
*
*      2)   REGISTERS WHOSE ENTRY VALUES ARE NOT MENTIONED
*           MAY CONTAIN ANY VALUE EXCEPT THAT XL,XR MAY ONLY
*           CONTAIN PROPER (COLLECTABLE) POINTER VALUES.
*           THIS CONDITION ON MEANS THAT THE CALLED ROUTINE
*           MAY IF IT CHOOSES PRESERVE XL,XR BY STACKING.
*
*      3)   REGISTERS NOT MENTIONED ON EXIT CONTAIN THE SAME
*           VALUES AS THEY DID ON ENTRY EXCEPT THAT VALUES IN
*           XR,XL MAY HAVE BEEN RELOCATED BY THE COLLECTOR.
*
*      4)   REGISTERS WHICH ARE DESTROYED ON EXIT MAY CONTAIN
*           ANY VALUE EXCEPT THAT VALUES IN XL,XR ARE PROPER
*           (COLLECTABLE) POINTERS.
*
*      5)   THE CODE POINTER REGISTER POINTS TO THE CURRENT
*           CODE LOCATION ON ENTRY AND IS UNCHANGED ON EXIT.
*
*      IN THE ABOVE DESCRIPTION, A COLLECTABLE POINTER IS ONE
*      WHICH EITHER POINTS OUTSIDE THE DYNAMIC REGION OR
*      POINTS TO THE START OF A BLOCK IN THE DYNAMIC REGION.
*
*      IN THOSE CASES WHERE THE CALLING SEQUENCE CONTAINS
*      PARAMETERS WHICH ARE USED AS ALTERNATE RETURN POINTS,
*      THESE PARAMETERS MAY BE REPLACED BY ERROR CODES
*      ASSEMBLED WITH THE ERR INSTRUCTION. THIS WILL RESULT
*      IN THE POSTING OF THE ERROR IF THE RETURN IS TAKEN.
*
*      THE PROCEDURES ALL HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE IN ALPHABETICAL ORDER BY THEIR NAMES.
{{EJC{{{{{18753
*
*      ACESS - ACCESS VARIABLE VALUE WITH TRACE/INPUT CHECKS
*
*      ACESS LOADS THE VALUE OF A VARIABLE. TRACE AND INPUT
*      ASSOCIATIONS ARE TESTED FOR AND EXECUTED AS REQUIRED.
*      ACESS ALSO HANDLES THE SPECIAL CASES OF PSEUDO-VARIABLES.
*
*      (XL)                  VARIABLE NAME BASE
*      (WA)                  VARIABLE NAME OFFSET
*      JSR  ACESS            CALL TO ACCESS VALUE
*      PPM  LOC              TRANSFER LOC IF ACCESS FAILURE
*      (XR)                  VARIABLE VALUE
*      (WA,WB,WC)            DESTROYED
*      (XL,RA)               DESTROYED
*
*      FAILURE CAN OCCUR IF AN INPUT ASSOCIATION CAUSES AN END
*      OF FILE CONDITION OR IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ACESS{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){18773
{{MOV{7,XL{7,XR{{COPY NAME BASE{18774
{{ADD{8,WA{7,XR{{POINT TO VARIABLE LOCATION{18775
{{MOV{9,(XR){7,XR{{LOAD VARIABLE VALUE{18776
*
*      LOOP HERE TO CHECK FOR SUCCESSIVE TRBLKS
*
{ACS02{BNE{9,(XR){22,=B$TRT{6,ACS18{JUMP IF NOT TRAPPED{18780
*
*      HERE IF TRAPPED
*
{{BEQ{7,XR{21,=TRBKV{6,ACS12{JUMP IF KEYWORD VARIABLE{18784
{{BNE{7,XR{21,=TRBEV{6,ACS05{JUMP IF NOT EXPRESSION VARIABLE{18785
*
*      HERE FOR EXPRESSION VARIABLE, EVALUATE VARIABLE
*
{{MOV{13,EVEXP(XL){7,XR{{LOAD EXPRESSION POINTER{18789
{{ZER{8,WB{{{EVALUATE BY VALUE{18790
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{18791
{{PPM{6,ACS04{{{JUMP IF EVALUATION FAILURE{18792
{{BRN{6,ACS02{{{CHECK VALUE FOR MORE TRBLKS{18793
{{EJC{{{{{18794
*
*      ACESS (CONTINUED)
*
*      HERE ON READING END OF FILE
*
{ACS03{ADD{19,*NUM03{7,XS{{POP TRBLK PTR, NAME BASE AND OFFSET{18800
{{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{18801
*
*      MERGE HERE WHEN EVALUATION OF EXPRESSION FAILS
*
{ACS04{EXI{1,1{{{TAKE ALTERNATE (FAILURE) RETURN{18805
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ACS05{MOV{13,TRTYP(XR){8,WB{{LOAD TRAP TYPE CODE{18809
{{BNZ{8,WB{6,ACS10{{JUMP IF NOT INPUT ASSOCIATION{18810
{{BZE{3,KVINP{6,ACS09{{IGNORE INPUT ASSOC IF INPUT IS OFF{18811
*
*      HERE FOR INPUT ASSOCIATION
*
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{18815
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{18816
{{MOV{7,XR{11,-(XS){{STACK TRBLK POINTER{18817
{{MOV{3,KVTRM{3,ACTRM{{TEMP TO HOLD TRIM KEYWORD{18818
{{MOV{13,TRFPT(XR){7,XL{{GET FILE CTRL BLK PTR OR ZERO{18819
{{BNZ{7,XL{6,ACS06{{JUMP IF NOT STANDARD INPUT FILE{18820
{{BEQ{13,TRTER(XR){21,=V$TER{6,ACS21{JUMP IF TERMINAL{18821
*
*      HERE TO READ FROM STANDARD INPUT FILE
*
{{MOV{3,CSWIN{8,WA{{LENGTH FOR READ BUFFER{18825
{{JSR{6,ALOCS{{{BUILD STRING OF APPROPRIATE LENGTH{18826
{{JSR{6,SYSRD{{{READ NEXT STANDARD INPUT IMAGE{18827
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{18828
{{BRN{6,ACS07{{{ELSE MERGE WITH OTHER FILE CASE{18829
*
*      HERE FOR INPUT FROM OTHER THAN STANDARD INPUT FILE
*
{ACS06{MOV{7,XL{8,WA{{FCBLK PTR{18833
{{JSR{6,SYSIL{{{GET INPUT RECORD MAX LENGTH (TO WA){18834
{{BNZ{8,WC{6,ACS6A{{JUMP IF NOT BINARY FILE{18835
{{MOV{8,WC{3,ACTRM{{DISABLE TRIM FOR BINARY FILE{18836
{ACS6A{JSR{6,ALOCS{{{ALLOCATE STRING OF CORRECT SIZE{18837
{{MOV{7,XL{8,WA{{FCBLK PTR{18838
{{JSR{6,SYSIN{{{CALL SYSTEM INPUT ROUTINE{18839
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{18840
{{PPM{6,ACS22{{{ERROR{18841
{{PPM{6,ACS23{{{ERROR{18842
{{EJC{{{{{18843
*
*      ACESS (CONTINUED)
*
*      MERGE HERE AFTER OBTAINING INPUT RECORD
*
{ACS07{MOV{3,ACTRM{8,WB{{LOAD TRIM INDICATOR{18849
{{JSR{6,TRIMR{{{TRIM RECORD AS REQUIRED{18850
{{MOV{7,XR{8,WB{{COPY RESULT POINTER{18851
{{MOV{9,(XS){7,XR{{RELOAD POINTER TO TRBLK{18852
*
*      LOOP TO CHASE TO END OF TRBLK CHAIN AND STORE VALUE
*
{ACS08{MOV{7,XR{7,XL{{SAVE POINTER TO THIS TRBLK{18856
{{MOV{13,TRNXT(XR){7,XR{{LOAD FORWARD POINTER{18857
{{BEQ{9,(XR){22,=B$TRT{6,ACS08{LOOP IF THIS IS ANOTHER TRBLK{18858
{{MOV{8,WB{13,TRNXT(XL){{ELSE STORE RESULT AT END OF CHAIN{18859
{{MOV{10,(XS)+{7,XR{{RESTORE INITIAL TRBLK POINTER{18860
{{MOV{10,(XS)+{8,WA{{RESTORE NAME OFFSET{18861
{{MOV{10,(XS)+{7,XL{{RESTORE NAME BASE POINTER{18862
*
*      COME HERE TO MOVE TO NEXT TRBLK
*
{ACS09{MOV{13,TRNXT(XR){7,XR{{LOAD FORWARD PTR TO NEXT VALUE{18866
{{BRN{6,ACS02{{{BACK TO CHECK IF TRAPPED{18867
*
*      HERE TO CHECK FOR ACCESS TRACE TRBLK
*
{ACS10{BNE{8,WB{18,=TRTAC{6,ACS09{LOOP BACK IF NOT ACCESS TRACE{18871
{{BZE{3,KVTRA{6,ACS09{{IGNORE ACCESS TRACE IF TRACE OFF{18872
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{18873
{{BZE{13,TRFNC(XR){6,ACS11{{JUMP IF PRINT TRACE{18874
{{EJC{{{{{18875
*
*      ACESS (CONTINUED)
*
*      HERE FOR FULL FUNCTION TRACE
*
{{JSR{6,TRXEQ{{{CALL ROUTINE TO EXECUTE TRACE{18881
{{BRN{6,ACS09{{{JUMP FOR NEXT TRBLK{18882
*
*      HERE FOR CASE OF PRINT TRACE
*
{ACS11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{18886
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{18887
{{BRN{6,ACS09{{{JUMP BACK FOR NEXT TRBLK{18888
*
*      HERE FOR KEYWORD VARIABLE
*
{ACS12{MOV{13,KVNUM(XL){7,XR{{LOAD KEYWORD NUMBER{18892
{{BGE{7,XR{18,=K$V$${6,ACS14{JUMP IF NOT ONE WORD VALUE{18893
{{MTI{15,KVABE(XR){{{ELSE LOAD VALUE AS INTEGER{18894
*
*      COMMON EXIT WITH KEYWORD VALUE AS INTEGER IN (IA)
*
{ACS13{JSR{6,ICBLD{{{BUILD ICBLK{18898
{{BRN{6,ACS18{{{JUMP TO EXIT{18899
*
*      HERE IF NOT ONE WORD KEYWORD VALUE
*
{ACS14{BGE{7,XR{18,=K$S$${6,ACS15{JUMP IF SPECIAL CASE{18903
{{SUB{18,=K$V$${7,XR{{ELSE GET OFFSET{18904
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{18905
{{ADD{21,=NDABO{7,XR{{POINT TO PATTERN VALUE{18906
{{BRN{6,ACS18{{{JUMP TO EXIT{18907
*
*      HERE IF SPECIAL KEYWORD CASE
*
{ACS15{MOV{3,KVRTN{7,XL{{LOAD RTNTYPE IN CASE{18911
{{LDI{3,KVSTL{{{LOAD STLIMIT IN CASE{18912
{{SUB{18,=K$S$${7,XR{{GET CASE NUMBER{18913
{{BSW{7,XR{2,K$$N${{SWITCH ON KEYWORD NUMBER{18914
{{IFF{2,K$$AL{6,ACS16{{JUMP IF ALPHABET{18928
{{IFF{2,K$$RT{6,ACS17{{RTNTYPE{18928
{{IFF{2,K$$SC{6,ACS19{{STCOUNT{18928
{{IFF{2,K$$ET{6,ACS20{{ERRTEXT{18928
{{IFF{2,K$$FL{6,ACS26{{FILE{18928
{{IFF{2,K$$LF{6,ACS27{{LASTFILE{18928
{{IFF{2,K$$SL{6,ACS13{{STLIMIT{18928
{{IFF{2,K$$LC{6,ACS24{{LCASE{18928
{{IFF{2,K$$UC{6,ACS25{{UCASE{18928
{{ESW{{{{END SWITCH ON KEYWORD NUMBER{18928
{{EJC{{{{{18929
*
*      ACESS (CONTINUED)
*
*      LCASE
*
{ACS24{MOV{21,=LCASE{7,XR{{LOAD POINTER TO LCASE STRING{18936
{{BRN{6,ACS18{{{COMMON RETURN{18937
*
*      UCASE
*
{ACS25{MOV{21,=UCASE{7,XR{{LOAD POINTER TO UCASE STRING{18941
{{BRN{6,ACS18{{{COMMON RETURN{18942
*
*      FILE
*
{ACS26{MOV{3,KVSTN{8,WC{{LOAD CURRENT STMT NUMBER{18948
{{BRN{6,ACS28{{{MERGE TO OBTAIN FILE NAME{18949
*
*      LASTFILE
*
{ACS27{MOV{3,KVLST{8,WC{{LOAD LAST STMT NUMBER{18953
*
*      MERGE HERE TO MAP STATEMENT NUMBER IN WC TO FILE NAME
*
{ACS28{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STMT{18957
{{BRN{6,ACS17{{{MERGE TO RETURN STRING IN XL{18958
*      ALPHABET
*
{ACS16{MOV{3,KVALP{7,XL{{LOAD POINTER TO ALPHABET STRING{18962
*
*      RTNTYPE MERGES HERE
*
{ACS17{MOV{7,XL{7,XR{{COPY STRING PTR TO PROPER REG{18966
*
*      COMMON RETURN POINT
*
{ACS18{EXI{{{{RETURN TO ACESS CALLER{18970
*
*      HERE FOR STCOUNT (IA HAS STLIMIT)
*
{ACS19{ILT{6,ACS29{{{IF COUNTING SUPPRESSED{18974
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER START VALUE{18975
{{SUB{3,STMCT{8,WA{{MINUS CURRENT COUNTER{18976
{{MTI{8,WA{{{CONVERT TO INTEGER{18977
{{ADI{3,KVSTL{{{ADD STLIMIT{18978
{ACS29{SBI{3,KVSTC{{{STCOUNT = LIMIT - LEFT{18979
{{BRN{6,ACS13{{{MERGE BACK WITH INTEGER RESULT{18980
*
*      ERRTEXT
*
{ACS20{MOV{3,R$ETX{7,XR{{GET ERRTEXT STRING{18984
{{BRN{6,ACS18{{{MERGE WITH RESULT{18985
*
*      HERE TO READ A RECORD FROM TERMINAL
*
{ACS21{MOV{18,=RILEN{8,WA{{BUFFER LENGTH{18989
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{18990
{{JSR{6,SYSRI{{{READ RECORD{18991
{{PPM{6,ACS03{{{ENDFILE{18992
{{BRN{6,ACS07{{{MERGE WITH RECORD READ{18993
*
*      ERROR RETURNS
*
{ACS22{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{18997
{{ERB{1,202{26,Input from file caused non-recoverable error{{{18998
*
{ACS23{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{19000
{{ERB{1,203{26,Input file record has incorrect format{{{19001
{{ENP{{{{END PROCEDURE ACESS{19002
{{EJC{{{{{19003
*
*      ACOMP -- COMPARE TWO ARITHMETIC VALUES
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  ACOMP            CALL TO COMPARE VALUES
*      PPM  LOC              TRANSFER LOC IF ARG1 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC IF ARG2 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR ARG1 LT ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 EQ ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 GT ARG2
*      (NORMAL RETURN IS NEVER GIVEN)
*      (WA,WB,WC,IA,RA)      DESTROYED
*      (XL,XR)               DESTROYED
*
{ACOMP{PRC{25,N{1,5{{ENTRY POINT{19019
{{JSR{6,ARITH{{{LOAD ARITHMETIC OPERANDS{19020
{{PPM{6,ACMP7{{{JUMP IF FIRST ARG NON-NUMERIC{19021
{{PPM{6,ACMP8{{{JUMP IF SECOND ARG NON-NUMERIC{19022
{{PPM{6,ACMP4{{{JUMP IF REAL ARGUMENTS{19025
*
*      HERE FOR INTEGER ARGUMENTS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT TO COMPARE{19030
{{IOV{6,ACMP3{{{JUMP IF OVERFLOW{19031
{{ILT{6,ACMP5{{{ELSE JUMP IF ARG1 LT ARG2{19032
{{IEQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{19033
*
*      HERE IF ARG1 GT ARG2
*
{ACMP1{EXI{1,5{{{TAKE GT EXIT{19037
*
*      HERE IF ARG1 EQ ARG2
*
{ACMP2{EXI{1,4{{{TAKE EQ EXIT{19041
{{EJC{{{{{19042
*
*      ACOMP (CONTINUED)
*
*      HERE FOR INTEGER OVERFLOW ON SUBTRACT
*
{ACMP3{LDI{13,ICVAL(XL){{{LOAD SECOND ARGUMENT{19048
{{ILT{6,ACMP1{{{GT IF NEGATIVE{19049
{{BRN{6,ACMP5{{{ELSE LT{19050
*
*      HERE FOR REAL OPERANDS
*
{ACMP4{SBR{13,RCVAL(XL){{{SUBTRACT TO COMPARE{19056
{{ROV{6,ACMP6{{{JUMP IF OVERFLOW{19057
{{RGT{6,ACMP1{{{ELSE JUMP IF ARG1 GT{19058
{{REQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{19059
*
*      HERE IF ARG1 LT ARG2
*
{ACMP5{EXI{1,3{{{TAKE LT EXIT{19064
*
*      HERE IF OVERFLOW ON REAL SUBTRACTION
*
{ACMP6{LDR{13,RCVAL(XL){{{RELOAD ARG2{19070
{{RLT{6,ACMP1{{{GT IF NEGATIVE{19071
{{BRN{6,ACMP5{{{ELSE LT{19072
*
*      HERE IF ARG1 NON-NUMERIC
*
{ACMP7{EXI{1,1{{{TAKE ERROR EXIT{19077
*
*      HERE IF ARG2 NON-NUMERIC
*
{ACMP8{EXI{1,2{{{TAKE ERROR EXIT{19081
{{ENP{{{{END PROCEDURE ACOMP{19082
{{EJC{{{{{19083
*
*      ALLOC                 ALLOCATE BLOCK OF DYNAMIC STORAGE
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALLOC            CALL TO ALLOCATE BLOCK
*      (XR)                  POINTER TO ALLOCATED BLOCK
*
*      A POSSIBLE ALTERNATIVE TO AOV ... AND FOLLOWING STMT IS -
*      MOV  DNAME,XR .  SUB  WA,XR .  BLO XR,DNAMP,ALOC2 .
*      MOV  DNAMP,XR .  ADD  WA,XR
*
{ALLOC{PRC{25,E{1,0{{ENTRY POINT{19095
*
*      COMMON EXIT POINT
*
{ALOC1{MOV{3,DNAMP{7,XR{{POINT TO NEXT AVAILABLE LOC{19099
{{AOV{8,WA{7,XR{6,ALOC2{POINT PAST ALLOCATED BLOCK{19100
{{BGT{7,XR{3,DNAME{6,ALOC2{JUMP IF NOT ENOUGH ROOM{19101
{{MOV{7,XR{3,DNAMP{{STORE NEW POINTER{19102
{{SUB{8,WA{7,XR{{POINT BACK TO START OF ALLOCATED BK{19103
{{EXI{{{{RETURN TO CALLER{19104
*
*      HERE IF INSUFFICIENT ROOM, TRY A GARBAGE COLLECTION
*
{ALOC2{MOV{8,WB{3,ALLSV{{SAVE WB{19108
{ALC2A{ZER{8,WB{{{SET NO UPWARD MOVE FOR GBCOL{19109
{{JSR{6,GBCOL{{{GARBAGE COLLECT{19110
{{MOV{7,XR{8,WB{{REMEMBER NEW SEDIMENT SIZE{19112
*
*      SEE IF ROOM AFTER GBCOL OR SYSMM CALL
*
{ALOC3{MOV{3,DNAMP{7,XR{{POINT TO FIRST AVAILABLE LOC{19117
{{AOV{8,WA{7,XR{6,ALC3A{POINT PAST NEW BLOCK{19118
{{BLO{7,XR{3,DNAME{6,ALOC4{JUMP IF THERE IS ROOM NOW{19119
*
*      FAILED AGAIN, SEE IF WE CAN GET MORE CORE
*
{ALC3A{JSR{6,SYSMM{{{TRY TO GET MORE MEMORY{19123
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){19124
{{ADD{7,XR{3,DNAME{{BUMP PTR BY AMOUNT OBTAINED{19125
{{BNZ{7,XR{6,ALOC3{{JUMP IF GOT MORE CORE{19126
{{BZE{3,DNAMS{6,ALC3B{{JUMP IF THERE WAS NO SEDIMENT{19128
{{ZER{3,DNAMS{{{TRY COLLECTING THE SEDIMENT{19129
{{BRN{6,ALC2A{{{{19130
*
*      SYSMM FAILED AND THERE WAS NO SEDIMENT TO COLLECT
*
{ALC3B{ADD{3,RSMEM{3,DNAME{{GET THE RESERVE MEMORY{19134
{{ZER{3,RSMEM{{{ONLY PERMISSIBLE ONCE{19138
{{ICV{3,ERRFT{{{FATAL ERROR{19139
{{ERB{1,204{26,Memory overflow{{{19140
{{EJC{{{{{19141
*
*      HERE AFTER SUCCESSFUL GARBAGE COLLECTION
*
{ALOC4{STI{3,ALLIA{{{SAVE IA{19145
{{MOV{8,WB{3,DNAMS{{RECORD NEW SEDIMENT SIZE{19147
{{MOV{3,DNAME{8,WB{{GET DYNAMIC END ADRS{19149
{{SUB{3,DNAMP{8,WB{{COMPUTE FREE STORE{19150
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{19151
{{MTI{8,WB{{{PUT FREE STORE IN IA{19152
{{MLI{3,ALFSF{{{MULTIPLY BY FREE STORE FACTOR{19153
{{IOV{6,ALOC5{{{JUMP IF OVERFLOWED{19154
{{MOV{3,DNAME{8,WB{{DYNAMIC END ADRS{19155
{{SUB{3,DNAMB{8,WB{{COMPUTE TOTAL AMOUNT OF DYNAMIC{19156
{{BTW{8,WB{{{CONVERT TO WORDS{19157
{{MOV{8,WB{3,ALDYN{{STORE IT{19158
{{SBI{3,ALDYN{{{SUBTRACT FROM SCALED UP FREE STORE{19159
{{IGT{6,ALOC5{{{JUMP IF SUFFICIENT FREE STORE{19160
{{JSR{6,SYSMM{{{TRY TO GET MORE STORE{19161
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){19162
{{ADD{7,XR{3,DNAME{{ADJUST DYNAMIC END ADRS{19163
*
*      MERGE TO RESTORE IA AND WB
*
{ALOC5{LDI{3,ALLIA{{{RECOVER IA{19167
{{MOV{3,ALLSV{8,WB{{RESTORE WB{19168
{{BRN{6,ALOC1{{{JUMP BACK TO EXIT{19169
{{ENP{{{{END PROCEDURE ALLOC{19170
{{EJC{{{{{19171
*
*      ALOCS -- ALLOCATE STRING BLOCK
*
*      ALOCS IS USED TO BUILD A FRAME FOR A STRING BLOCK INTO
*      WHICH THE ACTUAL CHARACTERS ARE PLACED BY THE CALLER.
*      ALL STRINGS ARE CREATED WITH A CALL TO ALOCS (THE
*      EXCEPTIONS OCCUR IN TRIMR AND S$RPL PROCEDURES).
*
*      (WA)                  LENGTH OF STRING TO BE ALLOCATED
*      JSR  ALOCS            CALL TO ALLOCATE SCBLK
*      (XR)                  POINTER TO RESULTING SCBLK
*      (WA)                  DESTROYED
*      (WC)                  CHARACTER COUNT (ENTRY VALUE OF WA)
*
*      THE RESULTING SCBLK HAS THE TYPE WORD AND THE LENGTH
*      FILLED IN AND THE LAST WORD IS CLEARED TO ZERO CHARACTERS
*      TO ENSURE CORRECT RIGHT PADDING OF THE FINAL WORD.
*
{ALOCS{PRC{25,E{1,0{{ENTRY POINT{19231
{{BGT{8,WA{3,KVMXL{6,ALCS2{JUMP IF LENGTH EXCEEDS MAXLENGTH{19232
{{MOV{8,WA{8,WC{{ELSE COPY LENGTH{19233
{{CTB{8,WA{2,SCSI${{COMPUTE LENGTH OF SCBLK IN BYTES{19234
{{MOV{3,DNAMP{7,XR{{POINT TO NEXT AVAILABLE LOCATION{19235
{{AOV{8,WA{7,XR{6,ALCS0{POINT PAST BLOCK{19236
{{BLO{7,XR{3,DNAME{6,ALCS1{JUMP IF THERE IS ROOM{19237
*
*      INSUFFICIENT MEMORY
*
{ALCS0{ZER{7,XR{{{ELSE CLEAR GARBAGE XR VALUE{19241
{{JSR{6,ALLOC{{{AND USE STANDARD ALLOCATOR{19242
{{ADD{8,WA{7,XR{{POINT PAST END OF BLOCK TO MERGE{19243
*
*      MERGE HERE WITH XR POINTING BEYOND NEW BLOCK
*
{ALCS1{MOV{7,XR{3,DNAMP{{SET UPDATED STORAGE POINTER{19247
{{ZER{11,-(XR){{{STORE ZERO CHARS IN LAST WORD{19248
{{DCA{8,WA{{{DECREMENT LENGTH{19249
{{SUB{8,WA{7,XR{{POINT BACK TO START OF BLOCK{19250
{{MOV{22,=B$SCL{9,(XR){{SET TYPE WORD{19251
{{MOV{8,WC{13,SCLEN(XR){{STORE LENGTH IN CHARS{19252
{{EXI{{{{RETURN TO ALOCS CALLER{19253
*
*      COME HERE IF STRING IS TOO LONG
*
{ALCS2{ERB{1,205{26,String length exceeds value of MAXLNGTH keyword{{{19257
{{ENP{{{{END PROCEDURE ALOCS{19258
{{EJC{{{{{19259
*
*      ALOST -- ALLOCATE SPACE IN STATIC REGION
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALOST            CALL TO ALLOCATE SPACE
*      (XR)                  POINTER TO ALLOCATED BLOCK
*      (WB)                  DESTROYED
*
*      NOTE THAT THE CODING ENSURES THAT THE RESULTING VALUE
*      OF STATE IS ALWAYS LESS THAN DNAMB. THIS FACT IS USED
*      IN TESTING A VARIABLE NAME FOR BEING IN THE STATIC REGION
*
{ALOST{PRC{25,E{1,0{{ENTRY POINT{19272
*
*      MERGE BACK HERE AFTER ALLOCATING NEW CHUNK
*
{ALST1{MOV{3,STATE{7,XR{{POINT TO CURRENT END OF AREA{19276
{{AOV{8,WA{7,XR{6,ALST2{POINT BEYOND PROPOSED BLOCK{19277
{{BGE{7,XR{3,DNAMB{6,ALST2{JUMP IF OVERLAP WITH DYNAMIC AREA{19278
{{MOV{7,XR{3,STATE{{ELSE STORE NEW POINTER{19279
{{SUB{8,WA{7,XR{{POINT BACK TO START OF BLOCK{19280
{{EXI{{{{RETURN TO ALOST CALLER{19281
*
*      HERE IF NO ROOM, PREPARE TO MOVE DYNAMIC STORAGE UP
*
{ALST2{MOV{8,WA{3,ALSTA{{SAVE WA{19285
{{BGE{8,WA{19,*E$STS{6,ALST3{SKIP IF REQUESTED CHUNK IS LARGE{19286
{{MOV{19,*E$STS{8,WA{{ELSE SET TO GET LARGE ENOUGH CHUNK{19287
*
*      HERE WITH AMOUNT TO MOVE UP IN WA
*
{ALST3{JSR{6,ALLOC{{{ALLOCATE BLOCK TO ENSURE ROOM{19291
{{MOV{7,XR{3,DNAMP{{AND DELETE IT{19292
{{MOV{8,WA{8,WB{{COPY MOVE UP AMOUNT{19293
{{JSR{6,GBCOL{{{CALL GBCOL TO MOVE DYNAMIC AREA UP{19294
{{MOV{7,XR{3,DNAMS{{REMEMBER NEW SEDIMENT SIZE{19296
{{MOV{3,ALSTA{8,WA{{RESTORE WA{19298
{{BRN{6,ALST1{{{LOOP BACK TO TRY AGAIN{19299
{{ENP{{{{END PROCEDURE ALOST{19300
{{EJC{{{{{19301
*
*      ARITH -- FETCH ARITHMETIC OPERANDS
*
*      ARITH IS USED BY FUNCTIONS AND OPERATORS WHICH EXPECT
*      TWO NUMERIC ARGUMENTS (OPERANDS) WHICH MUST BOTH BE
*      INTEGER OR BOTH BE REAL. ARITH FETCHES TWO ARGUMENTS FROM
*      THE STACK AND PERFORMS ANY NECESSARY CONVERSIONS.
*
*      1(XS)                 FIRST ARGUMENT (LEFT OPERAND)
*      0(XS)                 SECOND ARGUMENT (RIGHT OPERAND)
*      JSR  ARITH            CALL TO FETCH NUMERIC ARGUMENTS
*      PPM  LOC              TRANSFER LOC FOR OPND 1 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR OPND 2 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR REAL OPERANDS
*
*      FOR INTEGER ARGS, CONTROL RETURNS PAST THE PARAMETERS
*
*      (IA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO ICBLK FOR LEFT OPERAND
*      (XL)                  PTR TO ICBLK FOR RIGHT OPERAND
*      (XS)                  POPPED TWICE
*      (WA,WB,RA)            DESTROYED
*
*      FOR REAL ARGUMENTS, CONTROL RETURNS TO THE LOCATION
*      SPECIFIED BY THE THIRD PARAMETER.
*
*      (RA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO RCBLK FOR LEFT OPERAND
*      (XL)                  PTR TO RCBLK FOR RIGHT OPERAND
*      (WA,WB,WC)            DESTROYED
*      (XS)                  POPPED TWICE
{{EJC{{{{{19375
*
*      ARITH (CONTINUED)
*
*      ENTRY POINT
*
{ARITH{PRC{25,N{1,3{{ENTRY POINT{19384
{{MOV{10,(XS)+{7,XL{{LOAD RIGHT OPERAND{19386
{{MOV{10,(XS)+{7,XR{{LOAD LEFT OPERAND{19387
{{MOV{9,(XL){8,WA{{GET RIGHT OPERAND TYPE WORD{19388
{{BEQ{8,WA{22,=B$ICL{6,ARTH1{JUMP IF INTEGER{19389
{{BEQ{8,WA{22,=B$RCL{6,ARTH4{JUMP IF REAL{19392
{{MOV{7,XR{11,-(XS){{ELSE REPLACE LEFT ARG ON STACK{19394
{{MOV{7,XL{7,XR{{COPY LEFT ARG POINTER{19395
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{19396
{{PPM{6,ARTH6{{{JUMP IF UNCONVERTIBLE{19397
{{MOV{7,XR{7,XL{{ELSE COPY CONVERTED RESULT{19398
{{MOV{9,(XL){8,WA{{GET RIGHT OPERAND TYPE WORD{19399
{{MOV{10,(XS)+{7,XR{{RELOAD LEFT ARGUMENT{19400
{{BEQ{8,WA{22,=B$RCL{6,ARTH4{JUMP IF RIGHT ARG IS REAL{19403
*
*      HERE IF RIGHT ARG IS AN INTEGER
*
{ARTH1{BNE{9,(XR){22,=B$ICL{6,ARTH3{JUMP IF LEFT ARG NOT INTEGER{19408
*
*      EXIT FOR INTEGER CASE
*
{ARTH2{LDI{13,ICVAL(XR){{{LOAD LEFT OPERAND VALUE{19412
{{EXI{{{{RETURN TO ARITH CALLER{19413
*
*      HERE FOR RIGHT OPERAND INTEGER, LEFT OPERAND NOT
*
{ARTH3{JSR{6,GTNUM{{{CONVERT LEFT ARG TO NUMERIC{19417
{{PPM{6,ARTH7{{{JUMP IF NOT CONVERTIBLE{19418
{{BEQ{8,WA{22,=B$ICL{6,ARTH2{JUMP BACK IF INTEGER-INTEGER{19419
*
*      HERE WE MUST CONVERT REAL-INTEGER TO REAL-REAL
*
{{MOV{7,XR{11,-(XS){{PUT LEFT ARG BACK ON STACK{19425
{{LDI{13,ICVAL(XL){{{LOAD RIGHT ARGUMENT VALUE{19426
{{ITR{{{{CONVERT TO REAL{19427
{{JSR{6,RCBLD{{{GET REAL BLOCK FOR RIGHT ARG, MERGE{19428
{{MOV{7,XR{7,XL{{COPY RIGHT ARG PTR{19429
{{MOV{10,(XS)+{7,XR{{LOAD LEFT ARGUMENT{19430
{{BRN{6,ARTH5{{{MERGE FOR REAL-REAL CASE{19431
{{EJC{{{{{19432
*
*      ARITH (CONTINUED)
*
*      HERE IF RIGHT ARGUMENT IS REAL
*
{ARTH4{BEQ{9,(XR){22,=B$RCL{6,ARTH5{JUMP IF LEFT ARG REAL{19438
{{JSR{6,GTREA{{{ELSE CONVERT TO REAL{19439
{{PPM{6,ARTH7{{{ERROR IF UNCONVERTIBLE{19440
*
*      HERE FOR REAL-REAL
*
{ARTH5{LDR{13,RCVAL(XR){{{LOAD LEFT OPERAND VALUE{19444
{{EXI{1,3{{{TAKE REAL-REAL EXIT{19445
*
*      HERE FOR ERROR CONVERTING RIGHT ARGUMENT
*
{ARTH6{ICA{7,XS{{{POP UNWANTED LEFT ARG{19450
{{EXI{1,2{{{TAKE APPROPRIATE ERROR EXIT{19451
*
*      HERE FOR ERROR CONVERTING LEFT OPERAND
*
{ARTH7{EXI{1,1{{{TAKE APPROPRIATE ERROR RETURN{19455
{{ENP{{{{END PROCEDURE ARITH{19456
{{EJC{{{{{19457
*
*      ASIGN -- PERFORM ASSIGNMENT
*
*      ASIGN PERFORMS THE ASSIGNMENT OF A VALUE TO A VARIABLE
*      WITH APPROPRIATE CHECKS FOR OUTPUT ASSOCIATIONS AND
*      VALUE TRACE ASSOCIATIONS WHICH ARE EXECUTED AS REQUIRED.
*      ASIGN ALSO HANDLES THE SPECIAL CASES OF ASSIGNMENT TO
*      PATTERN AND EXPRESSION VARIABLES.
*
*      (WB)                  VALUE TO BE ASSIGNED
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      JSR  ASIGN            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC FOR FAILURE
*      (XR,XL,WA,WB,WC)      DESTROYED
*      (RA)                  DESTROYED
*
*      FAILURE OCCURS IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ASIGN{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){19478
*
*      MERGE BACK HERE TO ASSIGN RESULT TO EXPRESSION VARIABLE.
*
{ASG01{ADD{8,WA{7,XL{{POINT TO VARIABLE VALUE{19482
{{MOV{9,(XL){7,XR{{LOAD VARIABLE VALUE{19483
{{BEQ{9,(XR){22,=B$TRT{6,ASG02{JUMP IF TRAPPED{19484
{{MOV{8,WB{9,(XL){{ELSE PERFORM ASSIGNMENT{19485
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{19486
{{EXI{{{{AND RETURN TO ASIGN CALLER{19487
*
*      HERE IF VALUE IS TRAPPED
*
{ASG02{SUB{8,WA{7,XL{{RESTORE NAME BASE{19491
{{BEQ{7,XR{21,=TRBKV{6,ASG14{JUMP IF KEYWORD VARIABLE{19492
{{BNE{7,XR{21,=TRBEV{6,ASG04{JUMP IF NOT EXPRESSION VARIABLE{19493
*
*      HERE FOR ASSIGNMENT TO EXPRESSION VARIABLE
*
{{MOV{13,EVEXP(XL){7,XR{{POINT TO EXPRESSION{19497
{{MOV{8,WB{11,-(XS){{STORE VALUE TO ASSIGN ON STACK{19498
{{MOV{18,=NUM01{8,WB{{SET FOR EVALUATION BY NAME{19499
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{19500
{{PPM{6,ASG03{{{JUMP IF EVALUATION FAILS{19501
{{MOV{10,(XS)+{8,WB{{ELSE RELOAD VALUE TO ASSIGN{19502
{{BRN{6,ASG01{{{LOOP BACK TO PERFORM ASSIGNMENT{19503
{{EJC{{{{{19504
*
*      ASIGN (CONTINUED)
*
*      HERE FOR FAILURE DURING EXPRESSION EVALUATION
*
{ASG03{ICA{7,XS{{{REMOVE STACKED VALUE ENTRY{19510
{{EXI{1,1{{{TAKE FAILURE EXIT{19511
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ASG04{MOV{7,XR{11,-(XS){{SAVE PTR TO FIRST TRBLK{19515
*
*      LOOP TO CHASE DOWN TRBLK CHAIN AND ASSIGN VALUE AT END
*
{ASG05{MOV{7,XR{8,WC{{SAVE PTR TO THIS TRBLK{19519
{{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK{19520
{{BEQ{9,(XR){22,=B$TRT{6,ASG05{LOOP BACK IF ANOTHER TRBLK{19521
{{MOV{8,WC{7,XR{{ELSE POINT BACK TO LAST TRBLK{19522
{{MOV{8,WB{13,TRVAL(XR){{STORE VALUE AT END OF CHAIN{19523
{{MOV{10,(XS)+{7,XR{{RESTORE PTR TO FIRST TRBLK{19524
*
*      LOOP TO PROCESS TRBLK ENTRIES ON CHAIN
*
{ASG06{MOV{13,TRTYP(XR){8,WB{{LOAD TYPE CODE OF TRBLK{19528
{{BEQ{8,WB{18,=TRTVL{6,ASG08{JUMP IF VALUE TRACE{19529
{{BEQ{8,WB{18,=TRTOU{6,ASG10{JUMP IF OUTPUT ASSOCIATION{19530
*
*      HERE TO MOVE TO NEXT TRBLK ON CHAIN
*
{ASG07{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK ON CHAIN{19534
{{BEQ{9,(XR){22,=B$TRT{6,ASG06{LOOP BACK IF ANOTHER TRBLK{19535
{{EXI{{{{ELSE END OF CHAIN, RETURN TO CALLER{19536
*
*      HERE TO PROCESS VALUE TRACE
*
{ASG08{BZE{3,KVTRA{6,ASG07{{IGNORE VALUE TRACE IF TRACE OFF{19540
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{19541
{{BZE{13,TRFNC(XR){6,ASG09{{JUMP IF PRINT TRACE{19542
{{JSR{6,TRXEQ{{{ELSE EXECUTE FUNCTION TRACE{19543
{{BRN{6,ASG07{{{AND LOOP BACK{19544
{{EJC{{{{{19545
*
*      ASIGN (CONTINUED)
*
*      HERE FOR PRINT TRACE
*
{ASG09{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{19551
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{19552
{{BRN{6,ASG07{{{LOOP BACK FOR NEXT TRBLK{19553
*
*      HERE FOR OUTPUT ASSOCIATION
*
{ASG10{BZE{3,KVOUP{6,ASG07{{IGNORE OUTPUT ASSOC IF OUTPUT OFF{19557
{ASG1B{MOV{7,XR{7,XL{{COPY TRBLK POINTER{19558
{{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK{19559
{{BEQ{9,(XR){22,=B$TRT{6,ASG1B{LOOP BACK IF ANOTHER TRBLK{19560
{{MOV{7,XL{7,XR{{ELSE POINT BACK TO LAST TRBLK{19561
{{MOV{13,TRVAL(XR){11,-(XS){{STACK VALUE TO OUTPUT{19563
{{JSR{6,GTSTG{{{CONVERT TO STRING{19569
{{PPM{6,ASG12{{{GET DATATYPE NAME IF UNCONVERTIBLE{19570
*
*      MERGE WITH STRING OR BUFFER TO OUTPUT IN XR
*
{ASG11{MOV{13,TRFPT(XL){8,WA{{FCBLK PTR{19574
{{BZE{8,WA{6,ASG13{{JUMP IF STANDARD OUTPUT FILE{19575
*
*      HERE FOR OUTPUT TO FILE
*
{ASG1A{JSR{6,SYSOU{{{CALL SYSTEM OUTPUT ROUTINE{19579
{{ERR{1,206{26,Output caused file overflow{{{19580
{{ERR{1,207{26,Output caused non-recoverable error{{{19581
{{EXI{{{{ELSE ALL DONE, RETURN TO CALLER{19582
*
*      IF NOT PRINTABLE, GET DATATYPE NAME INSTEAD
*
{ASG12{JSR{6,DTYPE{{{CALL DATATYPE ROUTINE{19586
{{BRN{6,ASG11{{{MERGE{19587
*
*      HERE TO PRINT A STRING TO STANDARD OUTPUT OR TERMINAL
*
{ASG13{BEQ{13,TRTER(XL){21,=V$TER{6,ASG1A{JUMP IF TERMINAL OUTPUT{19592
{{ICV{8,WA{{{SIGNAL STANDARD OUTPUT{19593
{{BRN{6,ASG1A{{{USE SYSOU TO PERFORM OUTPUT{19594
{{EJC{{{{{19609
*
*      ASIGN (CONTINUED)
*
*      HERE FOR KEYWORD ASSIGNMENT
*
{ASG14{MOV{13,KVNUM(XL){7,XL{{LOAD KEYWORD NUMBER{19615
{{BEQ{7,XL{18,=K$ETX{6,ASG19{JUMP IF ERRTEXT{19616
{{MOV{8,WB{7,XR{{COPY VALUE TO BE ASSIGNED{19617
{{JSR{6,GTINT{{{CONVERT TO INTEGER{19618
{{ERR{1,208{26,Keyword value assigned is not integer{{{19619
{{LDI{13,ICVAL(XR){{{ELSE LOAD VALUE{19620
{{BEQ{7,XL{18,=K$STL{6,ASG16{JUMP IF SPECIAL CASE OF STLIMIT{19621
{{MFI{8,WA{6,ASG18{{ELSE GET ADDR INTEGER, TEST OVFLOW{19622
{{BGT{8,WA{3,MXLEN{6,ASG18{FAIL IF TOO LARGE{19623
{{BEQ{7,XL{18,=K$ERT{6,ASG17{JUMP IF SPECIAL CASE OF ERRTYPE{19624
{{BEQ{7,XL{18,=K$PFL{6,ASG21{JUMP IF SPECIAL CASE OF PROFILE{19627
{{BEQ{7,XL{18,=K$MXL{6,ASG24{JUMP IF SPECIAL CASE OF MAXLNGTH{19629
{{BEQ{7,XL{18,=K$FLS{6,ASG26{JUMP IF SPECIAL CASE OF FULLSCAN{19630
{{BLT{7,XL{18,=K$P$${6,ASG15{JUMP UNLESS PROTECTED{19631
{{ERB{1,209{26,Keyword in assignment is protected{{{19632
*
*      HERE TO DO ASSIGNMENT IF NOT PROTECTED
*
{ASG15{MOV{8,WA{15,KVABE(XL){{STORE NEW VALUE{19636
{{EXI{{{{RETURN TO ASIGN CALLER{19637
*
*      HERE FOR SPECIAL CASE OF STLIMIT
*
*      SINCE STCOUNT IS MAINTAINED AS (STLIMIT-STCOUNT)
*      IT IS ALSO NECESSARY TO MODIFY STCOUNT APPROPRIATELY.
*
{ASG16{SBI{3,KVSTL{{{SUBTRACT OLD LIMIT{19644
{{ADI{3,KVSTC{{{ADD OLD COUNTER{19645
{{STI{3,KVSTC{{{STORE COURSE COUNTER VALUE{19646
{{LDI{3,KVSTL{{{CHECK IF COUNTING SUPPRESSED{19647
{{ILT{6,ASG25{{{DO NOT REFINE IF SO{19648
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER BREAKOUT{19649
{{SUB{3,STMCT{8,WA{{VALUES{19650
{{MTI{8,WA{{{CONVERT TO INTEGER{19651
{{NGI{{{{CURRENT-START VALUE{19652
{{ADI{3,KVSTC{{{ADD IN COURSE COUNTER VALUE{19653
{{STI{3,KVSTC{{{SAVE REFINED VALUE{19654
{ASG25{LDI{13,ICVAL(XR){{{RELOAD NEW LIMIT VALUE{19655
{{STI{3,KVSTL{{{STORE NEW LIMIT VALUE{19656
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{19657
{{EXI{{{{RETURN TO ASIGN CALLER{19658
*
*      HERE FOR SPECIAL CASE OF ERRTYPE
*
{ASG17{BLE{8,WA{18,=NINI9{6,ERROR{OK TO SIGNAL IF IN RANGE{19662
*
*      HERE IF VALUE ASSIGNED IS OUT OF RANGE
*
{ASG18{ERB{1,210{26,Keyword value assigned is negative or too large{{{19666
*
*      HERE FOR SPECIAL CASE OF ERRTEXT
*
{ASG19{MOV{8,WB{11,-(XS){{STACK VALUE{19670
{{JSR{6,GTSTG{{{CONVERT TO STRING{19671
{{ERR{1,211{26,Value assigned to keyword ERRTEXT not a string{{{19672
{{MOV{7,XR{3,R$ETX{{MAKE ASSIGNMENT{19673
{{EXI{{{{RETURN TO CALLER{19674
*
*      HERE FOR KEYWORD PROFILE
*
{ASG21{BGT{8,WA{18,=NUM02{6,ASG18{MOAN IF NOT 0,1, OR 2{19688
{{BZE{8,WA{6,ASG15{{JUST ASSIGN IF ZERO{19689
{{BZE{3,PFDMP{6,ASG22{{BRANCH IF FIRST ASSIGNMENT{19690
{{BEQ{8,WA{3,PFDMP{6,ASG23{ALSO IF SAME VALUE AS BEFORE{19691
{{ERB{1,268{26,Inconsistent value assigned to keyword PROFILE{{{19692
*
{ASG22{MOV{8,WA{3,PFDMP{{NOTE VALUE ON FIRST ASSIGNMENT{19694
{ASG23{MOV{8,WA{3,KVPFL{{STORE NEW VALUE{19695
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTS{19696
{{JSR{6,SYSTM{{{GET THE TIME{19697
{{STI{3,PFSTM{{{FUDGE SOME KIND OF START TIME{19698
{{EXI{{{{RETURN TO ASIGN CALLER{19699
*
*      HERE FOR KEYWORD MAXLNGTH
*
{ASG24{BGE{8,WA{18,=MNLEN{6,ASG15{IF ACCEPTABLE VALUE{19704
{{ERB{1,287{26,Value assigned to keyword MAXLNGTH is too small{{{19705
*
*      HERE FOR KEYWORD FULLSCAN
*
{ASG26{BNZ{8,WA{6,ASG15{{IF ACCEPTABLE VALUE{19709
{{ERB{1,274{26,Value assigned to keyword FULLSCAN is zero{{{19710
*
{{ENP{{{{END PROCEDURE ASIGN{19712
{{EJC{{{{{19713
*
*      ASINP -- ASSIGN DURING PATTERN MATCH
*
*      ASINP IS LIKE ASIGN AND HAS A SIMILAR CALLING SEQUENCE
*      AND EFFECT. THE DIFFERENCE IS THAT THE GLOBAL PATTERN
*      VARIABLES ARE SAVED AND RESTORED IF REQUIRED.
*
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      (WB)                  VALUE TO BE ASSIGNED
*      JSR  ASINP            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC IF FAILURE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{ASINP{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{19729
{{ADD{8,WA{7,XL{{POINT TO VARIABLE{19730
{{MOV{9,(XL){7,XR{{LOAD CURRENT CONTENTS{19731
{{BEQ{9,(XR){22,=B$TRT{6,ASNP1{JUMP IF TRAPPED{19732
{{MOV{8,WB{9,(XL){{ELSE PERFORM ASSIGNMENT{19733
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{19734
{{EXI{{{{RETURN TO ASINP CALLER{19735
*
*      HERE IF VARIABLE IS TRAPPED
*
{ASNP1{SUB{8,WA{7,XL{{RESTORE BASE POINTER{19739
{{MOV{3,PMSSL{11,-(XS){{STACK SUBJECT STRING LENGTH{19740
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE PTR{19741
{{MOV{3,R$PMS{11,-(XS){{STACK SUBJECT STRING POINTER{19742
{{MOV{3,PMDFL{11,-(XS){{STACK DOT FLAG{19743
{{JSR{6,ASIGN{{{CALL FULL-BLOWN ASSIGNMENT ROUTINE{19744
{{PPM{6,ASNP2{{{JUMP IF FAILURE{19745
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{19746
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{19747
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{19748
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{19749
{{EXI{{{{RETURN TO ASINP CALLER{19750
*
*      HERE IF FAILURE IN ASIGN CALL
*
{ASNP2{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{19754
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{19755
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{19756
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{19757
{{EXI{1,1{{{TAKE FAILURE EXIT{19758
{{ENP{{{{END PROCEDURE ASINP{19759
{{EJC{{{{{19760
*
*      BLKLN -- DETERMINE LENGTH OF BLOCK
*
*      BLKLN DETERMINES THE LENGTH OF A BLOCK IN DYNAMIC STORE.
*
*      (WA)                  FIRST WORD OF BLOCK
*      (XR)                  POINTER TO BLOCK
*      JSR  BLKLN            CALL TO GET BLOCK LENGTH
*      (WA)                  LENGTH OF BLOCK IN BYTES
*      (XL)                  DESTROYED
*
*      BLKLN IS USED BY THE GARBAGE COLLECTOR AND IS NOT
*      PERMITTED TO CALL GBCOL DIRECTLY OR INDIRECTLY.
*
*      THE FIRST WORD STORED IN THE BLOCK (I.E. AT XR) MAY
*      BE ANYTHING, BUT THE CONTENTS OF WA MUST BE CORRECT.
*
{BLKLN{PRC{25,E{1,0{{ENTRY POINT{19778
{{MOV{8,WA{7,XL{{COPY FIRST WORD{19779
{{LEI{7,XL{{{GET ENTRY ID (BL$XX){19780
{{BSW{7,XL{2,BL$$${6,BLN00{SWITCH ON BLOCK TYPE{19781
{{IFF{2,BL$AR{6,BLN01{{ARBLK{19821
{{IFF{2,BL$CD{6,BLN12{{CDBLK{19821
{{IFF{2,BL$EX{6,BLN12{{EXBLK{19821
{{IFF{2,BL$IC{6,BLN07{{ICBLK{19821
{{IFF{2,BL$NM{6,BLN03{{NMBLK{19821
{{IFF{2,BL$P0{6,BLN02{{P0BLK{19821
{{IFF{2,BL$P1{6,BLN03{{P1BLK{19821
{{IFF{2,BL$P2{6,BLN04{{P2BLK{19821
{{IFF{2,BL$RC{6,BLN09{{RCBLK{19821
{{IFF{2,BL$SC{6,BLN10{{SCBLK{19821
{{IFF{2,BL$SE{6,BLN02{{SEBLK{19821
{{IFF{2,BL$TB{6,BLN01{{TBBLK{19821
{{IFF{2,BL$VC{6,BLN01{{VCBLK{19821
{{IFF{1,13{6,BLN00{{{19821
{{IFF{1,14{6,BLN00{{{19821
{{IFF{1,15{6,BLN00{{{19821
{{IFF{2,BL$PD{6,BLN08{{PDBLK{19821
{{IFF{2,BL$TR{6,BLN05{{TRBLK{19821
{{IFF{1,18{6,BLN00{{{19821
{{IFF{1,19{6,BLN00{{{19821
{{IFF{1,20{6,BLN00{{{19821
{{IFF{2,BL$CT{6,BLN06{{CTBLK{19821
{{IFF{2,BL$DF{6,BLN01{{DFBLK{19821
{{IFF{2,BL$EF{6,BLN01{{EFBLK{19821
{{IFF{2,BL$EV{6,BLN03{{EVBLK{19821
{{IFF{2,BL$FF{6,BLN05{{FFBLK{19821
{{IFF{2,BL$KV{6,BLN03{{KVBLK{19821
{{IFF{2,BL$PF{6,BLN01{{PFBLK{19821
{{IFF{2,BL$TE{6,BLN04{{TEBLK{19821
{{ESW{{{{END OF JUMP TABLE ON BLOCK TYPE{19821
{{EJC{{{{{19822
*
*      BLKLN (CONTINUED)
*
*      HERE FOR BLOCKS WITH LENGTH IN SECOND WORD
*
{BLN00{MOV{13,NUM01(XR){8,WA{{LOAD LENGTH{19828
{{EXI{{{{RETURN TO BLKLN CALLER{19829
*
*      HERE FOR LENGTH IN THIRD WORD (AR,CD,DF,EF,EX,PF,TB,VC)
*
{BLN01{MOV{13,NUM02(XR){8,WA{{LOAD LENGTH FROM THIRD WORD{19833
{{EXI{{{{RETURN TO BLKLN CALLER{19834
*
*      HERE FOR TWO WORD BLOCKS (P0,SE)
*
{BLN02{MOV{19,*NUM02{8,WA{{LOAD LENGTH (TWO WORDS){19838
{{EXI{{{{RETURN TO BLKLN CALLER{19839
*
*      HERE FOR THREE WORD BLOCKS (NM,P1,EV,KV)
*
{BLN03{MOV{19,*NUM03{8,WA{{LOAD LENGTH (THREE WORDS){19843
{{EXI{{{{RETURN TO BLKLN CALLER{19844
*
*      HERE FOR FOUR WORD BLOCKS (P2,TE,BC)
*
{BLN04{MOV{19,*NUM04{8,WA{{LOAD LENGTH (FOUR WORDS){19848
{{EXI{{{{RETURN TO BLKLN CALLER{19849
*
*      HERE FOR FIVE WORD BLOCKS (FF,TR)
*
{BLN05{MOV{19,*NUM05{8,WA{{LOAD LENGTH{19853
{{EXI{{{{RETURN TO BLKLN CALLER{19854
{{EJC{{{{{19855
*
*      BLKLN (CONTINUED)
*
*      HERE FOR CTBLK
*
{BLN06{MOV{19,*CTSI${8,WA{{SET SIZE OF CTBLK{19861
{{EXI{{{{RETURN TO BLKLN CALLER{19862
*
*      HERE FOR ICBLK
*
{BLN07{MOV{19,*ICSI${8,WA{{SET SIZE OF ICBLK{19866
{{EXI{{{{RETURN TO BLKLN CALLER{19867
*
*      HERE FOR PDBLK
*
{BLN08{MOV{13,PDDFP(XR){7,XL{{POINT TO DFBLK{19871
{{MOV{13,DFPDL(XL){8,WA{{LOAD PDBLK LENGTH FROM DFBLK{19872
{{EXI{{{{RETURN TO BLKLN CALLER{19873
*
*      HERE FOR RCBLK
*
{BLN09{MOV{19,*RCSI${8,WA{{SET SIZE OF RCBLK{19879
{{EXI{{{{RETURN TO BLKLN CALLER{19880
*
*      HERE FOR SCBLK
*
{BLN10{MOV{13,SCLEN(XR){8,WA{{LOAD LENGTH IN CHARACTERS{19885
{{CTB{8,WA{2,SCSI${{CALCULATE LENGTH IN BYTES{19886
{{EXI{{{{RETURN TO BLKLN CALLER{19887
*
*      HERE FOR LENGTH IN FOURTH WORD (CD,EX)
*
{BLN12{MOV{13,NUM03(XR){8,WA{{LOAD LENGTH FROM CDLEN/EXLEN{19901
{{EXI{{{{RETURN TO BLKLN CALLER{19902
{{ENP{{{{END PROCEDURE BLKLN{19904
{{EJC{{{{{19905
*
*      COPYB -- COPY A BLOCK
*
*      (XS)                  BLOCK TO BE COPIED
*      JSR  COPYB            CALL TO COPY BLOCK
*      PPM  LOC              RETURN IF BLOCK HAS NO IDVAL FIELD
*                            NORMAL RETURN IF IDVAL FIELD
*      (XR)                  COPY OF BLOCK
*      (XS)                  POPPED
*      (XL,WA,WB,WC)         DESTROYED
*
{COPYB{PRC{25,N{1,1{{ENTRY POINT{19917
{{MOV{9,(XS){7,XR{{LOAD ARGUMENT{19918
{{BEQ{7,XR{21,=NULLS{6,COP10{RETURN ARGUMENT IF IT IS NULL{19919
{{MOV{9,(XR){8,WA{{ELSE LOAD TYPE WORD{19920
{{MOV{8,WA{8,WB{{COPY TYPE WORD{19921
{{JSR{6,BLKLN{{{GET LENGTH OF ARGUMENT BLOCK{19922
{{MOV{7,XR{7,XL{{COPY POINTER{19923
{{JSR{6,ALLOC{{{ALLOCATE BLOCK OF SAME SIZE{19924
{{MOV{7,XR{9,(XS){{STORE POINTER TO COPY{19925
{{MVW{{{{COPY CONTENTS OF OLD BLOCK TO NEW{19926
{{ZER{7,XL{{{CLEAR GARBAGE XL{19927
{{MOV{9,(XS){7,XR{{RELOAD POINTER TO START OF COPY{19928
{{BEQ{8,WB{22,=B$TBT{6,COP05{JUMP IF TABLE{19929
{{BEQ{8,WB{22,=B$VCT{6,COP01{JUMP IF VECTOR{19930
{{BEQ{8,WB{22,=B$PDT{6,COP01{JUMP IF PROGRAM DEFINED{19931
{{BNE{8,WB{22,=B$ART{6,COP10{RETURN COPY IF NOT ARRAY{19936
*
*      HERE FOR ARRAY (ARBLK)
*
{{ADD{13,AROFS(XR){7,XR{{POINT TO PROTOTYPE FIELD{19940
{{BRN{6,COP02{{{JUMP TO MERGE{19941
*
*      HERE FOR VECTOR, PROGRAM DEFINED
*
{COP01{ADD{19,*PDFLD{7,XR{{POINT TO PDFLD = VCVLS{19945
*
*      MERGE HERE FOR ARBLK, VCBLK, PDBLK TO DELETE TRAP
*      BLOCKS FROM ALL VALUE FIELDS (THE COPY IS UNTRAPPED)
*
{COP02{MOV{9,(XR){7,XL{{LOAD NEXT POINTER{19950
*
*      LOOP TO GET VALUE AT END OF TRBLK CHAIN
*
{COP03{BNE{9,(XL){22,=B$TRT{6,COP04{JUMP IF NOT TRAPPED{19954
{{MOV{13,TRVAL(XL){7,XL{{ELSE POINT TO NEXT VALUE{19955
{{BRN{6,COP03{{{AND LOOP BACK{19956
{{EJC{{{{{19957
*
*      COPYB (CONTINUED)
*
*      HERE WITH UNTRAPPED VALUE IN XL
*
{COP04{MOV{7,XL{10,(XR)+{{STORE REAL VALUE, BUMP POINTER{19963
{{BNE{7,XR{3,DNAMP{6,COP02{LOOP BACK IF MORE TO GO{19964
{{BRN{6,COP09{{{ELSE JUMP TO EXIT{19965
*
*      HERE TO COPY A TABLE
*
{COP05{ZER{13,IDVAL(XR){{{ZERO ID TO STOP DUMP BLOWING UP{19969
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{19970
{{MOV{19,*TBBUK{8,WC{{SET INITIAL OFFSET{19971
*
*      LOOP THROUGH BUCKETS IN TABLE
*
{COP06{MOV{9,(XS){7,XR{{LOAD TABLE POINTER{19975
{{BEQ{8,WC{13,TBLEN(XR){6,COP09{JUMP TO EXIT IF ALL DONE{19976
{{MOV{8,WC{8,WB{{ELSE COPY OFFSET{19977
{{SUB{19,*TENXT{8,WB{{SUBTRACT LINK OFFSET TO MERGE{19978
{{ADD{8,WB{7,XR{{NEXT BUCKET HEADER LESS LINK OFFSET{19979
{{ICA{8,WC{{{BUMP OFFSET{19980
*
*      LOOP THROUGH TEBLKS ON ONE CHAIN
*
{COP07{MOV{13,TENXT(XR){7,XL{{LOAD POINTER TO NEXT TEBLK{19984
{{MOV{9,(XS){13,TENXT(XR){{SET END OF CHAIN POINTER IN CASE{19985
{{BEQ{9,(XL){22,=B$TBT{6,COP06{BACK FOR NEXT BUCKET IF CHAIN END{19986
{{SUB{8,WB{7,XR{{POINT TO HEAD OF PREVIOUS BLOCK{19987
{{MOV{7,XR{11,-(XS){{STACK PTR TO PREVIOUS BLOCK{19988
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{19989
{{JSR{6,ALLOC{{{ALLOCATE NEW TEBLK{19990
{{MOV{7,XR{11,-(XS){{STACK PTR TO NEW TEBLK{19991
{{MVW{{{{COPY OLD TEBLK TO NEW TEBLK{19992
{{MOV{10,(XS)+{7,XR{{RESTORE POINTER TO NEW TEBLK{19993
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER TO PREVIOUS BLOCK{19994
{{ADD{8,WB{7,XL{{ADD OFFSET BACK IN{19995
{{MOV{7,XR{13,TENXT(XL){{LINK NEW BLOCK TO PREVIOUS{19996
{{MOV{7,XR{7,XL{{COPY POINTER TO NEW BLOCK{19997
*
*      LOOP TO SET REAL VALUE AFTER REMOVING TRAP CHAIN
*
{COP08{MOV{13,TEVAL(XL){7,XL{{LOAD VALUE{20001
{{BEQ{9,(XL){22,=B$TRT{6,COP08{LOOP BACK IF TRAPPED{20002
{{MOV{7,XL{13,TEVAL(XR){{STORE UNTRAPPED VALUE IN TEBLK{20003
{{ZER{8,WB{{{ZERO OFFSET WITHIN TEBLK{20004
{{BRN{6,COP07{{{BACK FOR NEXT TEBLK{20005
*
*      COMMON EXIT POINT
*
{COP09{MOV{10,(XS)+{7,XR{{LOAD POINTER TO BLOCK{20009
{{EXI{{{{RETURN{20010
*
*      ALTERNATIVE RETURN
*
{COP10{EXI{1,1{{{RETURN{20014
{{EJC{{{{{20015
{{ENP{{{{END PROCEDURE COPYB{20033
*
*      CDGCG -- GENERATE CODE FOR COMPLEX GOTO
*
*      USED BY CMPIL TO PROCESS COMPLEX GOTO TREE
*
*      (WB)                  MUST BE COLLECTABLE
*      (XR)                  EXPRESSION POINTER
*      JSR  CDGCG            CALL TO GENERATE COMPLEX GOTO
*      (XL,XR,WA)            DESTROYED
*
{CDGCG{PRC{25,E{1,0{{ENTRY POINT{20044
{{MOV{13,CMOPN(XR){7,XL{{GET UNARY GOTO OPERATOR{20045
{{MOV{13,CMROP(XR){7,XR{{POINT TO GOTO OPERAND{20046
{{BEQ{7,XL{21,=OPDVD{6,CDGC2{JUMP IF DIRECT GOTO{20047
{{JSR{6,CDGNM{{{GENERATE OPND BY NAME IF NOT DIRECT{20048
*
*      RETURN POINT
*
{CDGC1{MOV{7,XL{8,WA{{GOTO OPERATOR{20052
{{JSR{6,CDWRD{{{GENERATE IT{20053
{{EXI{{{{RETURN TO CALLER{20054
*
*      DIRECT GOTO
*
{CDGC2{JSR{6,CDGVL{{{GENERATE OPERAND BY VALUE{20058
{{BRN{6,CDGC1{{{MERGE TO RETURN{20059
{{ENP{{{{END PROCEDURE CDGCG{20060
{{EJC{{{{{20061
*
*      CDGEX -- BUILD EXPRESSION BLOCK
*
*      CDGEX IS PASSED A POINTER TO AN EXPRESSION TREE (SEE
*      EXPAN) AND RETURNS AN EXPRESSION (SEBLK OR EXBLK).
*
*      (WA)                  0 IF BY VALUE, 1 IF BY NAME
*      (WC)                  SOME COLLECTABLE VALUE
*      (WB)                  INTEGER IN RANGE 0 LE X LE MXLEN
*      (XL)                  PTR TO EXPRESSION TREE
*      JSR  CDGEX            CALL TO BUILD EXPRESSION
*      (XR)                  PTR TO SEBLK OR EXBLK
*      (XL,WA,WB)            DESTROYED
*
{CDGEX{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20078
{{BLO{9,(XL){22,=B$VR${6,CDGX1{JUMP IF NOT VARIABLE{20079
*
*      HERE FOR NATURAL VARIABLE, BUILD SEBLK
*
{{MOV{19,*SESI${8,WA{{SET SIZE OF SEBLK{20083
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR SEBLK{20084
{{MOV{22,=B$SEL{9,(XR){{SET TYPE WORD{20085
{{MOV{7,XL{13,SEVAR(XR){{STORE VRBLK POINTER{20086
{{EXI{{{{RETURN TO CDGEX CALLER{20087
*
*      HERE IF NOT VARIABLE, BUILD EXBLK
*
{CDGX1{MOV{7,XL{7,XR{{COPY TREE POINTER{20091
{{MOV{8,WC{11,-(XS){{SAVE WC{20092
{{MOV{3,CWCOF{7,XL{{SAVE CURRENT OFFSET{20093
{{BZE{8,WA{6,CDGX2{{JUMP IF BY VALUE{20095
{{MOV{9,(XR){8,WA{{GET TYPE WORD{20097
{{BNE{8,WA{22,=B$CMT{6,CDGX2{CALL BY VALUE IF NOT CMBLK{20098
{{BGE{13,CMTYP(XR){18,=C$$NM{6,CDGX2{JUMP IF CMBLK ONLY BY VALUE{20099
{{EJC{{{{{20100
*
*      CDGEX (CONTINUED)
*
*      HERE IF EXPRESSION CAN BE EVALUATED BY NAME
*
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME{20106
{{MOV{21,=ORNM${8,WA{{LOAD RETURN BY NAME WORD{20107
{{BRN{6,CDGX3{{{MERGE WITH VALUE CASE{20108
*
*      HERE IF EXPRESSION CAN ONLY BE EVALUATED BY VALUE
*
{CDGX2{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20112
{{MOV{21,=ORVL${8,WA{{LOAD RETURN BY VALUE WORD{20113
*
*      MERGE HERE TO CONSTRUCT EXBLK
*
{CDGX3{JSR{6,CDWRD{{{GENERATE RETURN WORD{20117
{{JSR{6,EXBLD{{{BUILD EXBLK{20118
{{MOV{10,(XS)+{8,WC{{RESTORE WC{20119
{{EXI{{{{RETURN TO CDGEX CALLER{20120
{{ENP{{{{END PROCEDURE CDGEX{20121
{{EJC{{{{{20122
*
*      CDGNM -- GENERATE CODE BY NAME
*
*      CDGNM IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY NAME FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF CODE GENERATED. THE INPUT
*      TO CDGNM IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGNM IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGNM            CALL TO GENERATE CODE BY NAME
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGNM{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20147
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20148
{{MOV{8,WB{11,-(XS){{SAVE ENTRY WB{20149
{{CHK{{{{CHECK FOR STACK OVERFLOW{20150
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{20151
{{BEQ{8,WA{22,=B$CMT{6,CGN04{JUMP IF CMBLK{20152
{{BHI{8,WA{22,=B$VR${6,CGN02{JUMP IF SIMPLE VARIABLE{20153
*
*      MERGE HERE FOR OPERAND YIELDING VALUE (E.G. CONSTANT)
*
{CGN01{ERB{1,212{26,Syntax error: Value used where name is required{{{20157
*
*      HERE FOR NATURAL VARIABLE REFERENCE
*
{CGN02{MOV{21,=OLVN${8,WA{{LOAD VARIABLE LOAD CALL{20161
{{JSR{6,CDWRD{{{GENERATE IT{20162
{{MOV{7,XR{8,WA{{COPY VRBLK POINTER{20163
{{JSR{6,CDWRD{{{GENERATE VRBLK POINTER{20164
{{EJC{{{{{20165
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT WITH WC SET CORRECTLY
*
{CGN03{MOV{10,(XS)+{8,WB{{RESTORE ENTRY WB{20171
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{20172
{{EXI{{{{RETURN TO CDGNM CALLER{20173
*
*      HERE FOR CMBLK
*
{CGN04{MOV{7,XR{7,XL{{COPY CMBLK POINTER{20177
{{MOV{13,CMTYP(XR){7,XR{{LOAD CMBLK TYPE{20178
{{BGE{7,XR{18,=C$$NM{6,CGN01{ERROR IF NOT NAME OPERAND{20179
{{BSW{7,XR{2,C$$NM{{ELSE SWITCH ON TYPE{20180
{{IFF{2,C$ARR{6,CGN05{{ARRAY REFERENCE{20188
{{IFF{2,C$FNC{6,CGN08{{FUNCTION CALL{20188
{{IFF{2,C$DEF{6,CGN09{{DEFERRED EXPRESSION{20188
{{IFF{2,C$IND{6,CGN10{{INDIRECT REFERENCE{20188
{{IFF{2,C$KEY{6,CGN11{{KEYWORD REFERENCE{20188
{{IFF{2,C$UBO{6,CGN08{{UNDEFINED BINARY OP{20188
{{IFF{2,C$UUO{6,CGN08{{UNDEFINED UNARY OP{20188
{{ESW{{{{END SWITCH ON CMBLK TYPE{20188
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGN05{MOV{19,*CMOPN{8,WB{{POINT TO ARRAY OPERAND{20192
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGN06{JSR{6,CMGEN{{{GENERATE CODE FOR NEXT OPERAND{20196
{{MOV{13,CMLEN(XL){8,WC{{LOAD LENGTH OF CMBLK{20197
{{BLT{8,WB{8,WC{6,CGN06{LOOP TILL ALL GENERATED{20198
*
*      GENERATE APPROPRIATE ARRAY CALL
*
{{MOV{21,=OAON${8,WA{{LOAD ONE-SUBSCRIPT CASE CALL{20202
{{BEQ{8,WC{19,*CMAR1{6,CGN07{JUMP TO EXIT IF ONE SUBSCRIPT CASE{20203
{{MOV{21,=OAMN${8,WA{{ELSE LOAD MULTI-SUBSCRIPT CASE CALL{20204
{{JSR{6,CDWRD{{{GENERATE CALL{20205
{{MOV{8,WC{8,WA{{COPY CMBLK LENGTH{20206
{{BTW{8,WA{{{CONVERT TO WORDS{20207
{{SUB{18,=CMVLS{8,WA{{CALCULATE NUMBER OF SUBSCRIPTS{20208
{{EJC{{{{{20209
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT GENERATING WORD (NON-CONSTANT)
*
{CGN07{MNZ{8,WC{{{SET RESULT NON-CONSTANT{20215
{{JSR{6,CDWRD{{{GENERATE WORD{20216
{{BRN{6,CGN03{{{BACK TO EXIT{20217
*
*      HERE TO GENERATE CODE FOR FUNCTIONS AND UNDEFINED OPRS
*
{CGN08{MOV{7,XL{7,XR{{COPY CMBLK POINTER{20221
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR CALL{20222
{{MOV{21,=OFNE${8,WA{{GET EXTRA CALL FOR BY NAME{20223
{{BRN{6,CGN07{{{BACK TO GENERATE AND EXIT{20224
*
*      HERE TO GENERATE CODE FOR DEFERED EXPRESSION
*
{CGN09{MOV{13,CMROP(XL){7,XR{{CHECK IF VARIABLE{20228
{{BHI{9,(XR){22,=B$VR${6,CGN02{TREAT *VARIABLE AS SIMPLE VAR{20229
{{MOV{7,XR{7,XL{{COPY PTR TO EXPRESSION TREE{20230
{{MOV{18,=NUM01{8,WA{{RETURN NAME{20232
{{JSR{6,CDGEX{{{ELSE BUILD EXBLK{20234
{{MOV{21,=OLEX${8,WA{{SET CALL TO LOAD EXPR BY NAME{20235
{{JSR{6,CDWRD{{{GENERATE IT{20236
{{MOV{7,XR{8,WA{{COPY EXBLK POINTER{20237
{{JSR{6,CDWRD{{{GENERATE EXBLK POINTER{20238
{{BRN{6,CGN03{{{BACK TO EXIT{20239
*
*      HERE TO GENERATE CODE FOR INDIRECT REFERENCE
*
{CGN10{MOV{13,CMROP(XL){7,XR{{GET OPERAND{20243
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE FOR IT{20244
{{MOV{21,=OINN${8,WA{{LOAD CALL FOR INDIRECT BY NAME{20245
{{BRN{6,CGN12{{{MERGE{20246
*
*      HERE TO GENERATE CODE FOR KEYWORD REFERENCE
*
{CGN11{MOV{13,CMROP(XL){7,XR{{GET OPERAND{20250
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME FOR IT{20251
{{MOV{21,=OKWN${8,WA{{LOAD CALL FOR KEYWORD BY NAME{20252
*
*      KEYWORD, INDIRECT MERGE HERE
*
{CGN12{JSR{6,CDWRD{{{GENERATE CODE FOR OPERATOR{20256
{{BRN{6,CGN03{{{EXIT{20257
{{ENP{{{{END PROCEDURE CDGNM{20258
{{EJC{{{{{20259
*
*      CDGVL -- GENERATE CODE BY VALUE
*
*      CDGVL IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY VALUE FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF THE CODE GENERATED. THE INPUT
*      TO CDGVL IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGVL IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGVL            CALL TO GENERATE CODE BY VALUE
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      IF WC IS NON-ZERO ON ENTRY, THEN PREEVALUATION IS NOT
*      ALLOWED REGARDLESS OF THE NATURE OF THE OPERAND.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20287
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{20288
{{BEQ{8,WA{22,=B$CMT{6,CGV01{JUMP IF CMBLK{20289
{{BLT{8,WA{22,=B$VRA{6,CGV00{JUMP IF ICBLK, RCBLK, SCBLK{20290
{{BNZ{13,VRLEN(XR){6,CGVL0{{JUMP IF NOT SYSTEM VARIABLE{20291
{{MOV{7,XR{11,-(XS){{STACK XR{20292
{{MOV{13,VRSVP(XR){7,XR{{POINT TO SVBLK{20293
{{MOV{13,SVBIT(XR){8,WA{{GET SVBLK PROPERTY BITS{20294
{{MOV{10,(XS)+{7,XR{{RECOVER XR{20295
{{ANB{4,BTKWV{8,WA{{CHECK IF CONSTANT KEYWORD VALUE{20296
{{BEQ{8,WA{4,BTKWV{6,CGV00{JUMP IF CONSTANT KEYWORD VALUE{20297
*
*      HERE FOR VARIABLE VALUE REFERENCE
*
{CGVL0{MNZ{8,WC{{{INDICATE NON-CONSTANT VALUE{20301
*
*      MERGE HERE FOR SIMPLE CONSTANT (ICBLK,RCBLK,SCBLK)
*      AND FOR VARIABLES CORRESPONDING TO CONSTANT KEYWORDS.
*
{CGV00{MOV{7,XR{8,WA{{COPY PTR TO VAR OR CONSTANT{20306
{{JSR{6,CDWRD{{{GENERATE AS CODE WORD{20307
{{EXI{{{{RETURN TO CALLER{20308
{{EJC{{{{{20309
*
*      CDGVL (CONTINUED)
*
*      HERE FOR TREE NODE (CMBLK)
*
{CGV01{MOV{8,WB{11,-(XS){{SAVE ENTRY WB{20315
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20316
{{MOV{8,WC{11,-(XS){{SAVE ENTRY CONSTANT FLAG{20317
{{MOV{3,CWCOF{11,-(XS){{SAVE INITIAL CODE OFFSET{20318
{{CHK{{{{CHECK FOR STACK OVERFLOW{20319
*
*      PREPARE TO GENERATE CODE FOR CMBLK. WC IS SET TO THE
*      VALUE OF CSWNO (ZERO IF -OPTIMISE, 1 IF -NOOPT) TO
*      START WITH AND IS RESET NON-ZERO FOR ANY NON-CONSTANT
*      CODE GENERATED. IF IT IS STILL ZERO AFTER GENERATING ALL
*      THE CMBLK CODE, THEN ITS VALUE IS COMPUTED AS THE RESULT.
*
{{MOV{7,XR{7,XL{{COPY CMBLK POINTER{20327
{{MOV{13,CMTYP(XR){7,XR{{LOAD CMBLK TYPE{20328
{{MOV{3,CSWNO{8,WC{{RESET CONSTANT FLAG{20329
{{BLE{7,XR{18,=C$PR${6,CGV02{JUMP IF NOT PREDICATE VALUE{20330
{{MNZ{8,WC{{{ELSE FORCE NON-CONSTANT CASE{20331
*
*      HERE WITH WC SET APPROPRIATELY
*
{CGV02{BSW{7,XR{2,C$$NV{{SWITCH TO APPROPRIATE GENERATOR{20335
{{IFF{2,C$ARR{6,CGV03{{ARRAY REFERENCE{20355
{{IFF{2,C$FNC{6,CGV05{{FUNCTION CALL{20355
{{IFF{2,C$DEF{6,CGV14{{DEFERRED EXPRESSION{20355
{{IFF{2,C$IND{6,CGV31{{INDIRECT REFERENCE{20355
{{IFF{2,C$KEY{6,CGV27{{KEYWORD REFERENCE{20355
{{IFF{2,C$UBO{6,CGV29{{UNDEFINED BINOP{20355
{{IFF{2,C$UUO{6,CGV30{{UNDEFINED UNOP{20355
{{IFF{2,C$BVL{6,CGV18{{BINOPS WITH VAL OPDS{20355
{{IFF{2,C$UVL{6,CGV19{{UNOPS WITH VALU OPND{20355
{{IFF{2,C$ALT{6,CGV18{{ALTERNATION{20355
{{IFF{2,C$CNC{6,CGV24{{CONCATENATION{20355
{{IFF{2,C$CNP{6,CGV24{{CONCATENATION (NOT PATTERN MATCH){20355
{{IFF{2,C$UNM{6,CGV27{{UNOPS WITH NAME OPND{20355
{{IFF{2,C$BVN{6,CGV26{{BINARY $ AND .{20355
{{IFF{2,C$ASS{6,CGV21{{ASSIGNMENT{20355
{{IFF{2,C$INT{6,CGV31{{INTERROGATION{20355
{{IFF{2,C$NEG{6,CGV28{{NEGATION{20355
{{IFF{2,C$SEL{6,CGV15{{SELECTION{20355
{{IFF{2,C$PMT{6,CGV18{{PATTERN MATCH{20355
{{ESW{{{{END SWITCH ON CMBLK TYPE{20355
{{EJC{{{{{20356
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGV03{MOV{19,*CMOPN{8,WB{{SET OFFSET TO ARRAY OPERAND{20362
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGV04{JSR{6,CMGEN{{{GEN VALUE CODE FOR NEXT OPERAND{20366
{{MOV{13,CMLEN(XL){8,WC{{LOAD CMBLK LENGTH{20367
{{BLT{8,WB{8,WC{6,CGV04{LOOP BACK IF MORE TO GO{20368
*
*      GENERATE CALL TO APPROPRIATE ARRAY REFERENCE ROUTINE
*
{{MOV{21,=OAOV${8,WA{{SET ONE SUBSCRIPT CALL IN CASE{20372
{{BEQ{8,WC{19,*CMAR1{6,CGV32{JUMP TO EXIT IF 1-SUB CASE{20373
{{MOV{21,=OAMV${8,WA{{ELSE SET CALL FOR MULTI-SUBSCRIPTS{20374
{{JSR{6,CDWRD{{{GENERATE CALL{20375
{{MOV{8,WC{8,WA{{COPY LENGTH OF CMBLK{20376
{{SUB{19,*CMVLS{8,WA{{SUBTRACT STANDARD LENGTH{20377
{{BTW{8,WA{{{GET NUMBER OF WORDS{20378
{{BRN{6,CGV32{{{JUMP TO GENERATE SUBSCRIPT COUNT{20379
*
*      HERE TO GENERATE CODE FOR FUNCTION CALL
*
{CGV05{MOV{19,*CMVLS{8,WB{{SET OFFSET TO FIRST ARGUMENT{20383
*
*      LOOP TO GENERATE CODE FOR ARGUMENTS
*
{CGV06{BEQ{8,WB{13,CMLEN(XL){6,CGV07{JUMP IF ALL GENERATED{20387
{{JSR{6,CMGEN{{{ELSE GEN VALUE CODE FOR NEXT ARG{20388
{{BRN{6,CGV06{{{BACK TO GENERATE NEXT ARGUMENT{20389
*
*      HERE TO GENERATE ACTUAL FUNCTION CALL
*
{CGV07{SUB{19,*CMVLS{8,WB{{GET NUMBER OF ARG PTRS (BYTES){20393
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{20394
{{MOV{13,CMOPN(XL){7,XR{{LOAD FUNCTION VRBLK POINTER{20395
{{BNZ{13,VRLEN(XR){6,CGV12{{JUMP IF NOT SYSTEM FUNCTION{20396
{{MOV{13,VRSVP(XR){7,XL{{LOAD SVBLK PTR IF SYSTEM VAR{20397
{{MOV{13,SVBIT(XL){8,WA{{LOAD BIT MASK{20398
{{ANB{4,BTFFC{8,WA{{TEST FOR FAST FUNCTION CALL ALLOWED{20399
{{ZRB{8,WA{6,CGV12{{JUMP IF NOT{20400
{{EJC{{{{{20401
*
*      CDGVL (CONTINUED)
*
*      HERE IF FAST FUNCTION CALL IS ALLOWED
*
{{MOV{13,SVBIT(XL){8,WA{{RELOAD BIT INDICATORS{20407
{{ANB{4,BTPRE{8,WA{{TEST FOR PREEVALUATION OK{20408
{{NZB{8,WA{6,CGV08{{JUMP IF PREEVALUATION PERMITTED{20409
{{MNZ{8,WC{{{ELSE SET RESULT NON-CONSTANT{20410
*
*      TEST FOR CORRECT NUMBER OF ARGS FOR FAST CALL
*
{CGV08{MOV{13,VRFNC(XR){7,XL{{LOAD PTR TO SVFNC FIELD{20414
{{MOV{13,FARGS(XL){8,WA{{LOAD SVNAR FIELD VALUE{20415
{{BEQ{8,WA{8,WB{6,CGV11{JUMP IF ARGUMENT COUNT IS CORRECT{20416
{{BHI{8,WA{8,WB{6,CGV09{JUMP IF TOO FEW ARGUMENTS GIVEN{20417
*
*      HERE IF TOO MANY ARGUMENTS, PREPARE TO GENERATE O$POPS
*
{{SUB{8,WA{8,WB{{GET NUMBER OF EXTRA ARGS{20421
{{LCT{8,WB{8,WB{{SET AS COUNT TO CONTROL LOOP{20422
{{MOV{21,=OPOP${8,WA{{SET POP CALL{20423
{{BRN{6,CGV10{{{JUMP TO COMMON LOOP{20424
*
*      HERE IF TOO FEW ARGUMENTS, PREPARE TO GENERATE NULLS
*
{CGV09{SUB{8,WB{8,WA{{GET NUMBER OF MISSING ARGUMENTS{20428
{{LCT{8,WB{8,WA{{LOAD AS COUNT TO CONTROL LOOP{20429
{{MOV{21,=NULLS{8,WA{{LOAD PTR TO NULL CONSTANT{20430
*
*      LOOP TO GENERATE CALLS TO FIX ARGUMENT COUNT
*
{CGV10{JSR{6,CDWRD{{{GENERATE ONE CALL{20434
{{BCT{8,WB{6,CGV10{{LOOP TILL ALL GENERATED{20435
*
*      HERE AFTER ADJUSTING ARG COUNT AS REQUIRED
*
{CGV11{MOV{7,XL{8,WA{{COPY POINTER TO SVFNC FIELD{20439
{{BRN{6,CGV36{{{JUMP TO GENERATE CALL{20440
{{EJC{{{{{20441
*
*      CDGVL (CONTINUED)
*
*      COME HERE IF FAST CALL IS NOT PERMITTED
*
{CGV12{MOV{21,=OFNS${8,WA{{SET ONE ARG CALL IN CASE{20447
{{BEQ{8,WB{18,=NUM01{6,CGV13{JUMP IF ONE ARG CASE{20448
{{MOV{21,=OFNC${8,WA{{ELSE LOAD CALL FOR MORE THAN 1 ARG{20449
{{JSR{6,CDWRD{{{GENERATE IT{20450
{{MOV{8,WB{8,WA{{COPY ARGUMENT COUNT{20451
*
*      ONE ARG CASE MERGES HERE
*
{CGV13{JSR{6,CDWRD{{{GENERATE =O$FNS OR ARG COUNT{20455
{{MOV{7,XR{8,WA{{COPY VRBLK POINTER{20456
{{BRN{6,CGV32{{{JUMP TO GENERATE VRBLK PTR{20457
*
*      HERE FOR DEFERRED EXPRESSION
*
{CGV14{MOV{13,CMROP(XL){7,XL{{POINT TO EXPRESSION TREE{20461
{{ZER{8,WA{{{RETURN VALUE{20463
{{JSR{6,CDGEX{{{BUILD EXBLK OR SEBLK{20465
{{MOV{7,XR{8,WA{{COPY BLOCK PTR{20466
{{JSR{6,CDWRD{{{GENERATE PTR TO EXBLK OR SEBLK{20467
{{BRN{6,CGV34{{{JUMP TO EXIT, CONSTANT TEST{20468
*
*      HERE TO GENERATE CODE FOR SELECTION
*
{CGV15{ZER{11,-(XS){{{ZERO PTR TO CHAIN OF FORWARD JUMPS{20472
{{ZER{11,-(XS){{{ZERO PTR TO PREV O$SLC FORWARD PTR{20473
{{MOV{19,*CMVLS{8,WB{{POINT TO FIRST ALTERNATIVE{20474
{{MOV{21,=OSLA${8,WA{{SET INITIAL CODE WORD{20475
*
*      0(XS)                 IS THE OFFSET TO THE PREVIOUS WORD
*                            WHICH REQUIRES FILLING IN WITH AN
*                            OFFSET TO THE FOLLOWING O$SLC,O$SLD
*
*      1(XS)                 IS THE HEAD OF A CHAIN OF OFFSET
*                            POINTERS INDICATING THOSE LOCATIONS
*                            TO BE FILLED WITH OFFSETS PAST
*                            THE END OF ALL THE ALTERNATIVES
*
{CGV16{JSR{6,CDWRD{{{GENERATE O$SLC (O$SLA FIRST TIME){20486
{{MOV{3,CWCOF{9,(XS){{SET CURRENT LOC AS PTR TO FILL IN{20487
{{JSR{6,CDWRD{{{GENERATE GARBAGE WORD THERE FOR NOW{20488
{{JSR{6,CMGEN{{{GEN VALUE CODE FOR ALTERNATIVE{20489
{{MOV{21,=OSLB${8,WA{{LOAD O$SLB POINTER{20490
{{JSR{6,CDWRD{{{GENERATE O$SLB CALL{20491
{{MOV{13,NUM01(XS){8,WA{{LOAD OLD CHAIN PTR{20492
{{MOV{3,CWCOF{13,NUM01(XS){{SET CURRENT LOC AS NEW CHAIN HEAD{20493
{{JSR{6,CDWRD{{{GENERATE FORWARD CHAIN LINK{20494
{{EJC{{{{{20495
*
*      CDGVL (CONTINUED)
*
*      NOW TO FILL IN THE SKIP OFFSET TO O$SLC,O$SLD
*
{{MOV{9,(XS){7,XR{{LOAD OFFSET TO WORD TO PLUG{20501
{{ADD{3,R$CCB{7,XR{{POINT TO ACTUAL LOCATION TO PLUG{20502
{{MOV{3,CWCOF{9,(XR){{PLUG PROPER OFFSET IN{20503
{{MOV{21,=OSLC${8,WA{{LOAD O$SLC PTR FOR NEXT ALTERNATIVE{20504
{{MOV{8,WB{7,XR{{COPY OFFSET (DESTROY GARBAGE XR){20505
{{ICA{7,XR{{{BUMP EXTRA TIME FOR TEST{20506
{{BLT{7,XR{13,CMLEN(XL){6,CGV16{LOOP BACK IF NOT LAST ALTERNATIVE{20507
*
*      HERE TO GENERATE CODE FOR LAST ALTERNATIVE
*
{{MOV{21,=OSLD${8,WA{{GET HEADER CALL{20511
{{JSR{6,CDWRD{{{GENERATE O$SLD CALL{20512
{{JSR{6,CMGEN{{{GENERATE CODE FOR LAST ALTERNATIVE{20513
{{ICA{7,XS{{{POP OFFSET PTR{20514
{{MOV{10,(XS)+{7,XR{{LOAD CHAIN PTR{20515
*
*      LOOP TO PLUG OFFSETS PAST STRUCTURE
*
{CGV17{ADD{3,R$CCB{7,XR{{MAKE NEXT PTR ABSOLUTE{20519
{{MOV{9,(XR){8,WA{{LOAD FORWARD PTR{20520
{{MOV{3,CWCOF{9,(XR){{PLUG REQUIRED OFFSET{20521
{{MOV{8,WA{7,XR{{COPY FORWARD PTR{20522
{{BNZ{8,WA{6,CGV17{{LOOP BACK IF MORE TO GO{20523
{{BRN{6,CGV33{{{ELSE JUMP TO EXIT (NOT CONSTANT){20524
*
*      HERE FOR BINARY OPS WITH VALUE OPERANDS
*
{CGV18{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND POINTER{20528
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR LEFT OPERAND{20529
*
*      HERE FOR UNARY OPS WITH VALUE OPERAND (BINOPS MERGE)
*
{CGV19{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT (ONLY) OPERAND PTR{20533
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20534
{{EJC{{{{{20535
*
*      CDGVL (CONTINUED)
*
*      MERGE HERE TO GENERATE OPERATOR CALL FROM CMOPN FIELD
*
{CGV20{MOV{13,CMOPN(XL){8,WA{{LOAD OPERATOR CALL POINTER{20541
{{BRN{6,CGV36{{{JUMP TO GENERATE IT WITH CONS TEST{20542
*
*      HERE FOR ASSIGNMENT
*
{CGV21{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND POINTER{20546
{{BLO{9,(XR){22,=B$VR${6,CGV22{JUMP IF NOT VARIABLE{20547
*
*      HERE FOR ASSIGNMENT TO SIMPLE VARIABLE
*
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20551
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20552
{{MOV{13,CMLOP(XL){8,WA{{RELOAD LEFT OPERAND VRBLK PTR{20553
{{ADD{19,*VRSTO{8,WA{{POINT TO VRSTO FIELD{20554
{{BRN{6,CGV32{{{JUMP TO GENERATE STORE PTR{20555
*
*      HERE IF NOT SIMPLE VARIABLE ASSIGNMENT
*
{CGV22{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH ON LEFT SIDE{20559
{{PPM{6,CGV23{{{JUMP IF NOT PATTERN MATCH{20560
*
*      HERE FOR PATTERN REPLACEMENT
*
{{MOV{13,CMROP(XR){13,CMLOP(XL){{SAVE PATTERN PTR IN SAFE PLACE{20564
{{MOV{13,CMLOP(XR){7,XR{{LOAD SUBJECT PTR{20565
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR SUBJECT{20566
{{MOV{13,CMLOP(XL){7,XR{{LOAD PATTERN PTR{20567
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR PATTERN{20568
{{MOV{21,=OPMN${8,WA{{LOAD MATCH BY NAME CALL{20569
{{JSR{6,CDWRD{{{GENERATE IT{20570
{{MOV{13,CMROP(XL){7,XR{{LOAD REPLACEMENT VALUE PTR{20571
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20572
{{MOV{21,=ORPL${8,WA{{LOAD REPLACE CALL{20573
{{BRN{6,CGV32{{{JUMP TO GEN AND EXIT (NOT CONSTANT){20574
*
*      HERE FOR ASSIGNMENT TO COMPLEX VARIABLE
*
{CGV23{MNZ{8,WC{{{INHIBIT PRE-EVALUATION{20578
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR LEFT SIDE{20579
{{BRN{6,CGV31{{{MERGE WITH UNOP CIRCUIT{20580
{{EJC{{{{{20581
*
*      CDGVL (CONTINUED)
*
*      HERE FOR CONCATENATION
*
{CGV24{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND PTR{20587
{{BNE{9,(XR){22,=B$CMT{6,CGV18{ORDINARY BINOP IF NOT CMBLK{20588
{{MOV{13,CMTYP(XR){8,WB{{LOAD CMBLK TYPE CODE{20589
{{BEQ{8,WB{18,=C$INT{6,CGV25{SPECIAL CASE IF INTERROGATION{20590
{{BEQ{8,WB{18,=C$NEG{6,CGV25{OR NEGATION{20591
{{BNE{8,WB{18,=C$FNC{6,CGV18{ELSE ORDINARY BINOP IF NOT FUNCTION{20592
{{MOV{13,CMOPN(XR){7,XR{{ELSE LOAD FUNCTION VRBLK PTR{20593
{{BNZ{13,VRLEN(XR){6,CGV18{{ORDINARY BINOP IF NOT SYSTEM VAR{20594
{{MOV{13,VRSVP(XR){7,XR{{ELSE POINT TO SVBLK{20595
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT INDICATORS{20596
{{ANB{4,BTPRD{8,WA{{TEST FOR PREDICATE FUNCTION{20597
{{ZRB{8,WA{6,CGV18{{ORDINARY BINOP IF NOT{20598
*
*      HERE IF LEFT ARG OF CONCATENATION IS PREDICATE FUNCTION
*
{CGV25{MOV{13,CMLOP(XL){7,XR{{RELOAD LEFT ARG{20602
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20603
{{MOV{21,=OPOP${8,WA{{LOAD POP CALL{20604
{{JSR{6,CDWRD{{{GENERATE IT{20605
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND{20606
{{JSR{6,CDGVL{{{GEN CODE BY VALUE AS RESULT CODE{20607
{{BRN{6,CGV33{{{EXIT (NOT CONSTANT){20608
*
*      HERE TO GENERATE CODE FOR PATTERN, IMMEDIATE ASSIGNMENT
*
{CGV26{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND{20612
{{JSR{6,CDGVL{{{GEN CODE BY VALUE, MERGE{20613
*
*      HERE FOR UNOPS WITH ARG BY NAME (BINARY $ . MERGE)
*
{CGV27{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20617
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR RIGHT ARG{20618
{{MOV{13,CMOPN(XL){7,XR{{GET OPERATOR CODE WORD{20619
{{BNE{9,(XR){22,=O$KWV{6,CGV20{GEN CALL UNLESS KEYWORD VALUE{20620
{{EJC{{{{{20621
*
*      CDGVL (CONTINUED)
*
*      HERE FOR KEYWORD BY VALUE. THIS IS CONSTANT ONLY IF
*      THE OPERAND IS ONE OF THE SPECIAL SYSTEM VARIABLES WITH
*      THE SVCKW BIT SET TO INDICATE A CONSTANT KEYWORD VALUE.
*      NOTE THAT THE ONLY CONSTANT OPERAND BY NAME IS A VARIABLE
*
{{BNZ{8,WC{6,CGV20{{GEN CALL IF NON-CONSTANT (NOT VAR){20630
{{MNZ{8,WC{{{ELSE SET NON-CONSTANT IN CASE{20631
{{MOV{13,CMROP(XL){7,XR{{LOAD PTR TO OPERAND VRBLK{20632
{{BNZ{13,VRLEN(XR){6,CGV20{{GEN (NON-CONSTANT) IF NOT SYS VAR{20633
{{MOV{13,VRSVP(XR){7,XR{{ELSE LOAD PTR TO SVBLK{20634
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT MASK{20635
{{ANB{4,BTCKW{8,WA{{TEST FOR CONSTANT KEYWORD{20636
{{ZRB{8,WA{6,CGV20{{GO GEN IF NOT CONSTANT{20637
{{ZER{8,WC{{{ELSE SET RESULT CONSTANT{20638
{{BRN{6,CGV20{{{AND JUMP BACK TO GENERATE CALL{20639
*
*      HERE TO GENERATE CODE FOR NEGATION
*
{CGV28{MOV{21,=ONTA${8,WA{{GET INITIAL WORD{20643
{{JSR{6,CDWRD{{{GENERATE IT{20644
{{MOV{3,CWCOF{8,WB{{SAVE NEXT OFFSET{20645
{{JSR{6,CDWRD{{{GENERATE GUNK WORD FOR NOW{20646
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20647
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20648
{{MOV{21,=ONTB${8,WA{{LOAD END OF EVALUATION CALL{20649
{{JSR{6,CDWRD{{{GENERATE IT{20650
{{MOV{8,WB{7,XR{{COPY OFFSET TO WORD TO PLUG{20651
{{ADD{3,R$CCB{7,XR{{POINT TO ACTUAL WORD TO PLUG{20652
{{MOV{3,CWCOF{9,(XR){{PLUG WORD WITH CURRENT OFFSET{20653
{{MOV{21,=ONTC${8,WA{{LOAD FINAL CALL{20654
{{BRN{6,CGV32{{{JUMP TO GENERATE IT (NOT CONSTANT){20655
*
*      HERE TO GENERATE CODE FOR UNDEFINED BINARY OPERATOR
*
{CGV29{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND PTR{20659
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20660
{{EJC{{{{{20661
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR UNDEFINED UNARY OPERATOR
*
{CGV30{MOV{18,=C$UO${8,WB{{SET UNOP CODE + 1{20667
{{SUB{13,CMTYP(XL){8,WB{{SET NUMBER OF ARGS (1 OR 2){20668
*
*      MERGE HERE FOR UNDEFINED OPERATORS
*
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT (ONLY) OPERAND POINTER{20672
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR RIGHT OPERAND{20673
{{MOV{13,CMOPN(XL){7,XR{{LOAD POINTER TO OPERATOR DV{20674
{{MOV{13,DVOPN(XR){7,XR{{LOAD POINTER OFFSET{20675
{{WTB{7,XR{{{CONVERT WORD OFFSET TO BYTES{20676
{{ADD{20,=R$UBA{7,XR{{POINT TO PROPER FUNCTION PTR{20677
{{SUB{19,*VRFNC{7,XR{{SET STANDARD FUNCTION OFFSET{20678
{{BRN{6,CGV12{{{MERGE WITH FUNCTION CALL CIRCUIT{20679
*
*      HERE TO GENERATE CODE FOR INTERROGATION, INDIRECTION
*
{CGV31{MNZ{8,WC{{{SET NON CONSTANT{20683
{{BRN{6,CGV19{{{MERGE{20684
*
*      HERE TO EXIT GENERATING A WORD, RESULT NOT CONSTANT
*
{CGV32{JSR{6,CDWRD{{{GENERATE WORD, MERGE{20688
*
*      HERE TO EXIT WITH NO WORD GENERATED, NOT CONSTANT
*
{CGV33{MNZ{8,WC{{{INDICATE RESULT IS NOT CONSTANT{20692
*
*      COMMON EXIT POINT
*
{CGV34{ICA{7,XS{{{POP INITIAL CODE OFFSET{20696
{{MOV{10,(XS)+{8,WA{{RESTORE OLD CONSTANT FLAG{20697
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{20698
{{MOV{10,(XS)+{8,WB{{RESTORE ENTRY WB{20699
{{BNZ{8,WC{6,CGV35{{JUMP IF NOT CONSTANT{20700
{{MOV{8,WA{8,WC{{ELSE RESTORE ENTRY CONSTANT FLAG{20701
*
*      HERE TO RETURN AFTER DEALING WITH WC SETTING
*
{CGV35{EXI{{{{RETURN TO CDGVL CALLER{20705
*
*      EXIT HERE TO GENERATE WORD AND TEST FOR CONSTANT
*
{CGV36{JSR{6,CDWRD{{{GENERATE WORD{20709
{{BNZ{8,WC{6,CGV34{{JUMP TO EXIT IF NOT CONSTANT{20710
{{EJC{{{{{20711
*
*      CDGVL (CONTINUED)
*
*      HERE TO PREEVALUATE CONSTANT SUB-EXPRESSION
*
{{MOV{21,=ORVL${8,WA{{LOAD CALL TO RETURN VALUE{20717
{{JSR{6,CDWRD{{{GENERATE IT{20718
{{MOV{9,(XS){7,XL{{LOAD INITIAL CODE OFFSET{20719
{{JSR{6,EXBLD{{{BUILD EXBLK FOR EXPRESSION{20720
{{ZER{8,WB{{{SET TO EVALUATE BY VALUE{20721
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{20722
{{PPM{{{{SHOULD NOT FAIL{20723
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD OF RESULT{20724
{{BLO{8,WA{22,=P$AAA{6,CGV37{JUMP IF NOT PATTERN{20725
{{MOV{21,=OLPT${8,WA{{ELSE LOAD SPECIAL PATTERN LOAD CALL{20726
{{JSR{6,CDWRD{{{GENERATE IT{20727
*
*      MERGE HERE TO GENERATE POINTER TO RESULTING CONSTANT
*
{CGV37{MOV{7,XR{8,WA{{COPY CONSTANT POINTER{20731
{{JSR{6,CDWRD{{{GENERATE PTR{20732
{{ZER{8,WC{{{SET RESULT CONSTANT{20733
{{BRN{6,CGV34{{{JUMP BACK TO EXIT{20734
{{ENP{{{{END PROCEDURE CDGVL{20735
{{EJC{{{{{20736
*
*      CDWRD -- GENERATE ONE WORD OF CODE
*
*      CDWRD WRITES ONE WORD INTO THE CURRENT CODE BLOCK UNDER
*      CONSTRUCTION. A NEW, LARGER, BLOCK IS ALLOCATED IF THERE
*      IS INSUFFICIENT ROOM IN THE CURRENT BLOCK. CDWRD ENSURES
*      THAT THERE ARE AT LEAST FOUR WORDS LEFT IN THE BLOCK
*      AFTER ENTERING THE NEW WORD. THIS GUARANTEES THAT ANY
*      EXTRA SPACE AT THE END CAN BE SPLIT OFF AS A CCBLK.
*
*      (WA)                  WORD TO BE GENERATED
*      JSR  CDWRD            CALL TO GENERATE WORD
*
{CDWRD{PRC{25,E{1,0{{ENTRY POINT{20754
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{20755
{{MOV{8,WA{11,-(XS){{SAVE CODE WORD TO BE GENERATED{20756
*
*      MERGE BACK HERE AFTER ALLOCATING LARGER BLOCK
*
{CDWD1{MOV{3,R$CCB{7,XR{{LOAD PTR TO CCBLK BEING BUILT{20760
{{BNZ{7,XR{6,CDWD2{{JUMP IF BLOCK ALLOCATED{20761
*
*      HERE WE ALLOCATE AN ENTIRELY FRESH BLOCK
*
{{MOV{19,*E$CBS{8,WA{{LOAD INITIAL LENGTH{20765
{{JSR{6,ALLOC{{{ALLOCATE CCBLK{20766
{{MOV{22,=B$CCT{9,(XR){{STORE TYPE WORD{20767
{{MOV{19,*CCCOD{3,CWCOF{{SET INITIAL OFFSET{20768
{{MOV{8,WA{13,CCLEN(XR){{STORE BLOCK LENGTH{20769
{{ZER{13,CCSLN(XR){{{ZERO LINE NUMBER{20771
{{MOV{7,XR{3,R$CCB{{STORE PTR TO NEW BLOCK{20773
*
*      HERE WE HAVE A BLOCK WE CAN USE
*
{CDWD2{MOV{3,CWCOF{8,WA{{LOAD CURRENT OFFSET{20777
{{ADD{19,*NUM05{8,WA{{ADJUST FOR TEST (FIVE WORDS){20779
{{BLO{8,WA{13,CCLEN(XR){6,CDWD4{JUMP IF ROOM IN THIS BLOCK{20783
*
*      HERE IF NO ROOM IN CURRENT BLOCK
*
{{BGE{8,WA{3,MXLEN{6,CDWD5{JUMP IF ALREADY AT MAX SIZE{20787
{{ADD{19,*E$CBS{8,WA{{ELSE GET NEW SIZE{20788
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20789
{{MOV{7,XR{7,XL{{COPY POINTER{20790
{{BLT{8,WA{3,MXLEN{6,CDWD3{JUMP IF NOT TOO LARGE{20791
{{MOV{3,MXLEN{8,WA{{ELSE RESET TO MAX ALLOWED SIZE{20792
{{EJC{{{{{20793
*
*      CDWRD (CONTINUED)
*
*      HERE WITH NEW BLOCK SIZE IN WA
*
{CDWD3{JSR{6,ALLOC{{{ALLOCATE NEW BLOCK{20799
{{MOV{7,XR{3,R$CCB{{STORE POINTER TO NEW BLOCK{20800
{{MOV{22,=B$CCT{10,(XR)+{{STORE TYPE WORD IN NEW BLOCK{20801
{{MOV{8,WA{10,(XR)+{{STORE BLOCK LENGTH{20802
{{MOV{13,CCSLN(XL){10,(XR)+{{COPY SOURCE LINE NUMBER WORD{20804
{{ADD{19,*CCUSE{7,XL{{POINT TO CCUSE,CCCOD FIELDS IN OLD{20806
{{MOV{9,(XL){8,WA{{LOAD CCUSE VALUE{20807
{{MVW{{{{COPY USEFUL WORDS FROM OLD BLOCK{20808
{{MOV{10,(XS)+{7,XL{{RESTORE XL{20809
{{BRN{6,CDWD1{{{MERGE BACK TO TRY AGAIN{20810
*
*      HERE WITH ROOM IN CURRENT BLOCK
*
{CDWD4{MOV{3,CWCOF{8,WA{{LOAD CURRENT OFFSET{20814
{{ICA{8,WA{{{GET NEW OFFSET{20815
{{MOV{8,WA{3,CWCOF{{STORE NEW OFFSET{20816
{{MOV{8,WA{13,CCUSE(XR){{STORE IN CCBLK FOR GBCOL{20817
{{DCA{8,WA{{{RESTORE PTR TO THIS WORD{20818
{{ADD{8,WA{7,XR{{POINT TO CURRENT ENTRY{20819
{{MOV{10,(XS)+{8,WA{{RELOAD WORD TO GENERATE{20820
{{MOV{8,WA{9,(XR){{STORE WORD IN BLOCK{20821
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{20822
{{EXI{{{{RETURN TO CALLER{20823
*
*      HERE IF COMPILED CODE IS TOO LONG FOR CDBLK
*
{CDWD5{ERB{1,213{26,Syntax error: Statement is too complicated.{{{20827
{{ENP{{{{END PROCEDURE CDWRD{20828
{{EJC{{{{{20829
*
*      CMGEN -- GENERATE CODE FOR CMBLK PTR
*
*      CMGEN IS A SUBSIDIARY PROCEDURE USED TO GENERATE VALUE
*      CODE FOR A CMBLK PTR FROM THE MAIN CODE GENERATORS.
*
*      (XL)                  CMBLK POINTER
*      (WB)                  OFFSET TO POINTER IN CMBLK
*      JSR  CMGEN            CALL TO GENERATE CODE
*      (XR,WA)               DESTROYED
*      (WB)                  BUMPED BY ONE WORD
*
{CMGEN{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20842
{{MOV{7,XL{7,XR{{COPY CMBLK POINTER{20843
{{ADD{8,WB{7,XR{{POINT TO CMBLK POINTER{20844
{{MOV{9,(XR){7,XR{{LOAD CMBLK POINTER{20845
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20846
{{ICA{8,WB{{{BUMP OFFSET{20847
{{EXI{{{{RETURN TO CALLER{20848
{{ENP{{{{END PROCEDURE CMGEN{20849
{{EJC{{{{{20850
*
*      CMPIL (COMPILE SOURCE CODE)
*
*      CMPIL IS USED TO CONVERT SNOBOL4 SOURCE CODE TO INTERNAL
*      FORM (SEE CDBLK FORMAT). IT IS USED BOTH FOR THE INITIAL
*      COMPILE AND AT RUN TIME BY THE CODE AND CONVERT FUNCTIONS
*      THIS PROCEDURE HAS CONTROL FOR THE ENTIRE DURATION OF
*      INITIAL COMPILATION. AN ERROR IN ANY PROCEDURE CALLED
*      DURING COMPILATION WILL LEAD FIRST TO THE ERROR SECTION
*      AND ULTIMATELY BACK HERE FOR RESUMED COMPILATION. THE
*      RE-ENTRY POINTS AFTER AN ERROR ARE SPECIALLY LABELLED -
*
*      CMPCE                 RESUME AFTER CONTROL CARD ERROR
*      CMPLE                 RESUME AFTER LABEL ERROR
*      CMPSE                 RESUME AFTER STATEMENT ERROR
*
*      JSR  CMPIL            CALL TO COMPILE CODE
*      (XR)                  PTR TO CDBLK FOR ENTRY STATEMENT
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE FOLLOWING GLOBAL VARIABLES ARE REFERENCED
*
*      CMPLN                 LINE NUMBER OF FIRST LINE OF
*                            STATEMENT TO BE COMPILED
*
*      CMPSN                 NUMBER OF NEXT STATEMENT
*                            TO BE COMPILED.
*
*      CSWXX                 CONTROL CARD SWITCH VALUES ARE
*                            CHANGED WHEN RELEVANT CONTROL
*                            CARDS ARE MET.
*
*      CWCOF                 OFFSET TO NEXT WORD IN CODE BLOCK
*                            BEING BUILT (SEE CDWRD).
*
*      LSTSN                 NUMBER OF STATEMENT MOST RECENTLY
*                            COMPILED (INITIALLY SET TO ZERO).
*
*      R$CIM                 CURRENT (INITIAL) COMPILER IMAGE
*                            (ZERO FOR INITIAL COMPILE CALL)
*
*      R$CNI                 USED TO POINT TO FOLLOWING IMAGE.
*                            (SEE READR PROCEDURE).
*
*      SCNGO                 GOTO SWITCH FOR SCANE PROCEDURE
*
*      SCNIL                 LENGTH OF CURRENT IMAGE EXCLUDING
*                            CHARACTERS REMOVED BY -INPUT.
*
*      SCNPT                 CURRENT SCAN OFFSET, SEE SCANE.
*
*      SCNRS                 RESCAN SWITCH FOR SCANE PROCEDURE.
*
*      SCNSE                 OFFSET (IN R$CIM) OF MOST RECENTLY
*                            SCANNED ELEMENT. SET ZERO IF NOT
*                            CURRENTLY SCANNING ITEMS
{{EJC{{{{{20907
*
*      CMPIL (CONTINUED)
*
*      STAGE               STGIC  INITIAL COMPILE IN PROGRESS
*                          STGXC  CODE/CONVERT COMPILE
*                          STGEV  BUILDING EXBLK FOR EVAL
*                          STGXT  EXECUTE TIME (OUTSIDE COMPILE)
*                          STGCE  INITIAL COMPILE AFTER END LINE
*                          STGXE  EXECUTE COMPILE AFTER END LINE
*
*      CMPIL ALSO USES A FIXED NUMBER OF LOCATIONS ON THE
*      MAIN STACK AS FOLLOWS. (THE DEFINITIONS OF THE ACTUAL
*      OFFSETS ARE IN THE DEFINITIONS SECTION).
*
*      CMSTM(XS)             POINTER TO EXPAN TREE FOR BODY OF
*                            STATEMENT (SEE EXPAN PROCEDURE).
*
*      CMSGO(XS)             POINTER TO TREE REPRESENTATION OF
*                            SUCCESS GOTO (SEE PROCEDURE SCNGO)
*                            ZERO IF NO SUCCESS GOTO IS GIVEN
*
*      CMFGO(XS)             LIKE CMSGO FOR FAILURE GOTO.
*
*      CMCGO(XS)             SET NON-ZERO ONLY IF THERE IS A
*                            CONDITIONAL GOTO. USED FOR -FAIL,
*                            -NOFAIL CODE GENERATION.
*
*      CMPCD(XS)             POINTER TO CDBLK FOR PREVIOUS
*                            STATEMENT. ZERO FOR 1ST STATEMENT.
*
*      CMFFP(XS)             SET NON-ZERO IF CDFAL IN PREVIOUS
*                            CDBLK NEEDS FILLING WITH FORWARD
*                            POINTER, ELSE SET TO ZERO.
*
*      CMFFC(XS)             SAME AS CMFFP FOR CURRENT CDBLK
*
*      CMSOP(XS)             OFFSET TO WORD IN PREVIOUS CDBLK
*                            TO BE FILLED IN WITH FORWARD PTR
*                            TO NEXT CDBLK FOR SUCCESS GOTO.
*                            ZERO IF NO FILL IN IS REQUIRED.
*
*      CMSOC(XS)             SAME AS CMSOP FOR CURRENT CDBLK.
*
*      CMLBL(XS)             POINTER TO VRBLK FOR LABEL OF
*                            CURRENT STATEMENT. ZERO IF NO LABEL
*
*      CMTRA(XS)             POINTER TO CDBLK FOR ENTRY STMNT.
{{EJC{{{{{20955
*
*      CMPIL (CONTINUED)
*
*      ENTRY POINT
*
{CMPIL{PRC{25,E{1,0{{ENTRY POINT{20961
{{LCT{8,WB{18,=CMNEN{{SET NUMBER OF STACK WORK LOCATIONS{20962
*
*      LOOP TO INITIALIZE STACK WORKING LOCATIONS
*
{CMP00{ZER{11,-(XS){{{STORE A ZERO, MAKE ONE ENTRY{20966
{{BCT{8,WB{6,CMP00{{LOOP BACK UNTIL ALL SET{20967
{{MOV{7,XS{3,CMPXS{{SAVE STACK POINTER FOR ERROR SEC{20968
{{SSS{3,CMPSS{{{SAVE S-R STACK POINTER IF ANY{20969
*
*      LOOP THROUGH STATEMENTS
*
{CMP01{MOV{3,SCNPT{8,WB{{SET SCAN POINTER OFFSET{20973
{{MOV{8,WB{3,SCNSE{{SET START OF ELEMENT LOCATION{20974
{{MOV{21,=OCER${8,WA{{POINT TO COMPILE ERROR CALL{20975
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY CDFAL{20976
{{BLT{8,WB{3,SCNIL{6,CMP04{JUMP IF CHARS LEFT ON THIS IMAGE{20977
*
*      LOOP HERE AFTER COMMENT OR CONTROL CARD
*      ALSO SPECIAL ENTRY AFTER CONTROL CARD ERROR
*
{CMPCE{ZER{7,XR{{{CLEAR POSSIBLE GARBAGE XR VALUE{20982
{{BNZ{3,CNIND{6,CMPC2{{IF WITHIN INCLUDE FILE{20984
{{BNE{3,STAGE{18,=STGIC{6,CMP02{SKIP UNLESS INITIAL COMPILE{20986
{CMPC2{JSR{6,READR{{{READ NEXT INPUT IMAGE{20987
{{BZE{7,XR{6,CMP09{{JUMP IF NO INPUT AVAILABLE{20988
{{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{20989
{{MOV{3,CMPSN{3,LSTSN{{STORE STMT NO FOR USE BY LISTR{20990
{{MOV{3,RDCLN{3,CMPLN{{STORE LINE NUMBER AT START OF STMT{20991
{{ZER{3,SCNPT{{{RESET SCAN POINTER{20992
{{BRN{6,CMP04{{{GO PROCESS IMAGE{20993
*
*      FOR EXECUTE TIME COMPILE, PERMIT EMBEDDED CONTROL CARDS
*      AND COMMENTS (BY SKIPPING TO NEXT SEMI-COLON)
*
{CMP02{MOV{3,R$CIM{7,XR{{GET CURRENT IMAGE{20998
{{MOV{3,SCNPT{8,WB{{GET CURRENT OFFSET{20999
{{PLC{7,XR{8,WB{{PREPARE TO GET CHARS{21000
*
*      SKIP TO SEMI-COLON
*
{CMP03{BGE{3,SCNPT{3,SCNIL{6,CMP09{END LOOP IF END OF IMAGE{21004
{{LCH{8,WC{10,(XR)+{{GET CHAR{21005
{{ICV{3,SCNPT{{{ADVANCE OFFSET{21006
{{BNE{8,WC{18,=CH$SM{6,CMP03{LOOP IF NOT SEMI-COLON{21007
{{EJC{{{{{21008
*
*      CMPIL (CONTINUED)
*
*      HERE WITH IMAGE AVAILABLE TO SCAN. NOTE THAT IF THE INPUT
*      STRING IS NULL, THEN EVERYTHING IS OK SINCE NULL IS
*      ACTUALLY ASSEMBLED AS A WORD OF BLANKS.
*
{CMP04{MOV{3,R$CIM{7,XR{{POINT TO CURRENT IMAGE{21016
{{MOV{3,SCNPT{8,WB{{LOAD CURRENT OFFSET{21017
{{MOV{8,WB{8,WA{{COPY FOR LABEL SCAN{21018
{{PLC{7,XR{8,WB{{POINT TO FIRST CHARACTER{21019
{{LCH{8,WC{10,(XR)+{{LOAD FIRST CHARACTER{21020
{{BEQ{8,WC{18,=CH$SM{6,CMP12{NO LABEL IF SEMICOLON{21021
{{BEQ{8,WC{18,=CH$AS{6,CMPCE{LOOP BACK IF COMMENT CARD{21022
{{BEQ{8,WC{18,=CH$MN{6,CMP32{JUMP IF CONTROL CARD{21023
{{MOV{3,R$CIM{3,R$CMP{{ABOUT TO DESTROY R$CIM{21024
{{MOV{20,=CMLAB{7,XL{{POINT TO LABEL WORK STRING{21025
{{MOV{7,XL{3,R$CIM{{SCANE IS TO SCAN WORK STRING{21026
{{PSC{7,XL{{{POINT TO FIRST CHARACTER POSITION{21027
{{SCH{8,WC{10,(XL)+{{STORE CHAR JUST LOADED{21028
{{MOV{18,=CH$SM{8,WC{{GET A SEMICOLON{21029
{{SCH{8,WC{9,(XL){{STORE AFTER FIRST CHAR{21030
{{CSC{7,XL{{{FINISHED CHARACTER STORING{21031
{{ZER{7,XL{{{CLEAR POINTER{21032
{{ZER{3,SCNPT{{{START AT FIRST CHARACTER{21033
{{MOV{3,SCNIL{11,-(XS){{PRESERVE IMAGE LENGTH{21034
{{MOV{18,=NUM02{3,SCNIL{{READ 2 CHARS AT MOST{21035
{{JSR{6,SCANE{{{SCAN FIRST CHAR FOR TYPE{21036
{{MOV{10,(XS)+{3,SCNIL{{RESTORE IMAGE LENGTH{21037
{{MOV{7,XL{8,WC{{NOTE RETURN CODE{21038
{{MOV{3,R$CMP{7,XL{{GET OLD R$CIM{21039
{{MOV{7,XL{3,R$CIM{{PUT IT BACK{21040
{{MOV{8,WB{3,SCNPT{{REINSTATE OFFSET{21041
{{BNZ{3,SCNBL{6,CMP12{{BLANK SEEN - CANT BE LABEL{21042
{{MOV{7,XL{7,XR{{POINT TO CURRENT IMAGE{21043
{{PLC{7,XR{8,WB{{POINT TO FIRST CHAR AGAIN{21044
{{BEQ{8,WC{18,=T$VAR{6,CMP06{OK IF LETTER{21045
{{BEQ{8,WC{18,=T$CON{6,CMP06{OK IF DIGIT{21046
*
*      DROP IN OR JUMP FROM ERROR SECTION IF SCANE FAILED
*
{CMPLE{MOV{3,R$CMP{3,R$CIM{{POINT TO BAD LINE{21050
{{ERB{1,214{26,Bad label or misplaced continuation line{{{21051
*
*      LOOP TO SCAN LABEL
*
{CMP05{BEQ{8,WC{18,=CH$SM{6,CMP07{SKIP IF SEMICOLON{21055
{{ICV{8,WA{{{BUMP OFFSET{21056
{{BEQ{8,WA{3,SCNIL{6,CMP07{JUMP IF END OF IMAGE (LABEL END){21057
{{EJC{{{{{21058
*
*      CMPIL (CONTINUED)
*
*      ENTER LOOP AT THIS POINT
*
{CMP06{LCH{8,WC{10,(XR)+{{ELSE LOAD NEXT CHARACTER{21064
{{BEQ{8,WC{18,=CH$HT{6,CMP07{JUMP IF HORIZONTAL TAB{21066
{{BNE{8,WC{18,=CH$BL{6,CMP05{LOOP BACK IF NON-BLANK{21071
*
*      HERE AFTER SCANNING OUT LABEL
*
{CMP07{MOV{8,WA{3,SCNPT{{SAVE UPDATED SCAN OFFSET{21075
{{SUB{8,WB{8,WA{{GET LENGTH OF LABEL{21076
{{BZE{8,WA{6,CMP12{{SKIP IF LABEL LENGTH ZERO{21077
{{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{21078
{{JSR{6,SBSTR{{{BUILD SCBLK FOR LABEL NAME{21079
{{JSR{6,GTNVR{{{LOCATE/CONTRUCT VRBLK{21080
{{PPM{{{{DUMMY (IMPOSSIBLE) ERROR RETURN{21081
{{MOV{7,XR{13,CMLBL(XS){{STORE LABEL POINTER{21082
{{BNZ{13,VRLEN(XR){6,CMP11{{JUMP IF NOT SYSTEM LABEL{21083
{{BNE{13,VRSVP(XR){21,=V$END{6,CMP11{JUMP IF NOT END LABEL{21084
*
*      HERE FOR END LABEL SCANNED OUT
*
{{ADD{18,=STGND{3,STAGE{{ADJUST STAGE APPROPRIATELY{21088
{{JSR{6,SCANE{{{SCAN OUT NEXT ELEMENT{21089
{{BEQ{7,XL{18,=T$SMC{6,CMP10{JUMP IF END OF IMAGE{21090
{{BNE{7,XL{18,=T$VAR{6,CMP08{ELSE ERROR IF NOT VARIABLE{21091
*
*      HERE CHECK FOR VALID INITIAL TRANSFER
*
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP08{JUMP IF NOT DEFINED (ERROR){21095
{{MOV{13,VRLBL(XR){13,CMTRA(XS){{ELSE SET INITIAL ENTRY POINTER{21096
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21097
{{BEQ{7,XL{18,=T$SMC{6,CMP10{JUMP IF OK (END OF IMAGE){21098
*
*      HERE FOR BAD TRANSFER LABEL
*
{CMP08{ERB{1,215{26,Syntax error: Undefined or erroneous entry label{{{21102
*
*      HERE FOR END OF INPUT (NO END LABEL DETECTED)
*
{CMP09{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{21106
{{ADD{18,=STGND{3,STAGE{{ADJUST STAGE APPROPRIATELY{21107
{{BEQ{3,STAGE{18,=STGXE{6,CMP10{JUMP IF CODE CALL (OK){21108
{{ERB{1,216{26,Syntax error: Missing END line{{{21109
*
*      HERE AFTER PROCESSING END LINE (MERGE HERE ON END ERROR)
*
{CMP10{MOV{21,=OSTP${8,WA{{SET STOP CALL POINTER{21113
{{JSR{6,CDWRD{{{GENERATE AS STATEMENT CALL{21114
{{BRN{6,CMPSE{{{JUMP TO GENERATE AS FAILURE{21115
{{EJC{{{{{21116
*
*      CMPIL (CONTINUED)
*
*      HERE AFTER PROCESSING LABEL OTHER THAN END
*
{CMP11{BNE{3,STAGE{18,=STGIC{6,CMP12{JUMP IF CODE CALL - REDEF. OK{21122
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP12{ELSE CHECK FOR REDEFINITION{21123
{{ZER{13,CMLBL(XS){{{LEAVE FIRST LABEL DECLN UNDISTURBED{21124
{{ERB{1,217{26,Syntax error: Duplicate label{{{21125
*
*      HERE AFTER DEALING WITH LABEL
*      NULL STATEMENTS AND STATEMENTS JUST CONTAINING A
*      CONSTANT SUBJECT ARE OPTIMIZED OUT BY RESETTING THE
*      CURRENT CCBLK TO EMPTY.
*
{CMP12{ZER{8,WB{{{SET FLAG FOR STATEMENT BODY{21132
{{JSR{6,EXPAN{{{GET TREE FOR STATEMENT BODY{21133
{{MOV{7,XR{13,CMSTM(XS){{STORE FOR LATER USE{21134
{{ZER{13,CMSGO(XS){{{CLEAR SUCCESS GOTO POINTER{21135
{{ZER{13,CMFGO(XS){{{CLEAR FAILURE GOTO POINTER{21136
{{ZER{13,CMCGO(XS){{{CLEAR CONDITIONAL GOTO FLAG{21137
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21138
{{BEQ{7,XL{18,=T$COL{6,CMP13{JUMP IF COLON (GOTO){21139
{{BNZ{3,CSWNO{6,CMP18{{JUMP IF NOT OPTIMIZING{21140
{{BNZ{13,CMLBL(XS){6,CMP18{{JUMP IF LABEL PRESENT{21141
{{MOV{13,CMSTM(XS){7,XR{{LOAD TREE PTR FOR STATEMENT BODY{21142
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{21143
{{BEQ{8,WA{22,=B$CMT{6,CMP18{JUMP IF CMBLK{21144
{{BGE{8,WA{22,=B$VRA{6,CMP18{JUMP IF NOT ICBLK, SCBLK, OR RCBLK{21145
{{MOV{3,R$CCB{7,XL{{LOAD PTR TO CCBLK{21146
{{MOV{19,*CCCOD{13,CCUSE(XL){{RESET USE OFFSET IN CCBLK{21147
{{MOV{19,*CCCOD{3,CWCOF{{AND IN GLOBAL{21148
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{21149
{{BRN{6,CMP01{{{GENERATE NO CODE FOR STATEMENT{21150
*
*      LOOP TO PROCESS GOTO FIELDS
*
{CMP13{MNZ{3,SCNGO{{{SET GOTO FLAG{21154
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21155
{{BEQ{7,XL{18,=T$SMC{6,CMP31{JUMP IF NO FIELDS LEFT{21156
{{BEQ{7,XL{18,=T$SGO{6,CMP14{JUMP IF S FOR SUCCESS GOTO{21157
{{BEQ{7,XL{18,=T$FGO{6,CMP16{JUMP IF F FOR FAILURE GOTO{21158
*
*      HERE FOR UNCONDITIONAL GOTO (I.E. NOT F OR S)
*
{{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT NOT F,S{21162
{{JSR{6,SCNGF{{{SCAN OUT GOTO FIELD{21163
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY{21164
{{MOV{7,XR{13,CMFGO(XS){{ELSE SET AS FGOTO{21165
{{BRN{6,CMP15{{{MERGE WITH SGOTO CIRCUIT{21166
*
*      HERE FOR SUCCESS GOTO
*
{CMP14{JSR{6,SCNGF{{{SCAN SUCCESS GOTO FIELD{21170
{{MOV{18,=NUM01{13,CMCGO(XS){{SET CONDITIONAL GOTO FLAG{21171
*
*      UNCONTIONAL GOTO MERGES HERE
*
{CMP15{BNZ{13,CMSGO(XS){6,CMP17{{ERROR IF SGOTO ALREADY GIVEN{21175
{{MOV{7,XR{13,CMSGO(XS){{ELSE SET SGOTO{21176
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT GOTO FIELD{21177
*
*      HERE FOR FAILURE GOTO
*
{CMP16{JSR{6,SCNGF{{{SCAN GOTO FIELD{21181
{{MOV{18,=NUM01{13,CMCGO(XS){{SET CONDITONAL GOTO FLAG{21182
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY GIVEN{21183
{{MOV{7,XR{13,CMFGO(XS){{ELSE STORE FGOTO POINTER{21184
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT FIELD{21185
{{EJC{{{{{21186
*
*      CMPIL (CONTINUED)
*
*      HERE FOR DUPLICATED GOTO FIELD
*
{CMP17{ERB{1,218{26,Syntax error: Duplicated goto field{{{21192
*
*      HERE TO GENERATE CODE
*
{CMP18{ZER{3,SCNSE{{{STOP POSITIONAL ERROR FLAGS{21196
{{MOV{13,CMSTM(XS){7,XR{{LOAD TREE PTR FOR STATEMENT BODY{21197
{{ZER{8,WB{{{COLLECTABLE VALUE FOR WB FOR CDGVL{21198
{{ZER{8,WC{{{RESET CONSTANT FLAG FOR CDGVL{21199
{{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH{21200
{{PPM{6,CMP19{{{JUMP IF NOT PATTERN MATCH{21201
{{MOV{21,=OPMS${13,CMOPN(XR){{ELSE SET PATTERN MATCH POINTER{21202
{{MOV{18,=C$PMT{13,CMTYP(XR){{{21203
*
*      HERE AFTER DEALING WITH SPECIAL PATTERN MATCH CASE
*
{CMP19{JSR{6,CDGVL{{{GENERATE CODE FOR BODY OF STATEMENT{21207
{{MOV{13,CMSGO(XS){7,XR{{LOAD SGOTO POINTER{21208
{{MOV{7,XR{8,WA{{COPY IT{21209
{{BZE{7,XR{6,CMP21{{JUMP IF NO SUCCESS GOTO{21210
{{ZER{13,CMSOC(XS){{{CLEAR SUCCESS OFFSET FILLIN PTR{21211
{{BHI{7,XR{3,STATE{6,CMP20{JUMP IF COMPLEX GOTO{21212
*
*      HERE FOR SIMPLE SUCCESS GOTO (LABEL)
*
{{ADD{19,*VRTRA{8,WA{{POINT TO VRTRA FIELD AS REQUIRED{21216
{{JSR{6,CDWRD{{{GENERATE SUCCESS GOTO{21217
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{21218
*
*      HERE FOR COMPLEX SUCCESS GOTO
*
{CMP20{BEQ{7,XR{13,CMFGO(XS){6,CMP22{NO CODE IF SAME AS FGOTO{21222
{{ZER{8,WB{{{ELSE SET OK VALUE FOR CDGVL IN WB{21223
{{JSR{6,CDGCG{{{GENERATE CODE FOR SUCCESS GOTO{21224
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{21225
*
*      HERE FOR NO SUCCESS GOTO
*
{CMP21{MOV{3,CWCOF{13,CMSOC(XS){{SET SUCCESS FILL IN OFFSET{21229
{{MOV{21,=OCER${8,WA{{POINT TO COMPILE ERROR CALL{21230
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY VALUE{21231
{{EJC{{{{{21232
*
*      CMPIL (CONTINUED)
*
*      HERE TO DEAL WITH FAILURE GOTO
*
{CMP22{MOV{13,CMFGO(XS){7,XR{{LOAD FAILURE GOTO POINTER{21238
{{MOV{7,XR{8,WA{{COPY IT{21239
{{ZER{13,CMFFC(XS){{{SET NO FILL IN REQUIRED YET{21240
{{BZE{7,XR{6,CMP23{{JUMP IF NO FAILURE GOTO GIVEN{21241
{{ADD{19,*VRTRA{8,WA{{POINT TO VRTRA FIELD IN CASE{21242
{{BLO{7,XR{3,STATE{6,CMPSE{JUMP TO GEN IF SIMPLE FGOTO{21243
*
*      HERE FOR COMPLEX FAILURE GOTO
*
{{MOV{3,CWCOF{8,WB{{SAVE OFFSET TO O$GOF CALL{21247
{{MOV{21,=OGOF${8,WA{{POINT TO FAILURE GOTO CALL{21248
{{JSR{6,CDWRD{{{GENERATE{21249
{{MOV{21,=OFIF${8,WA{{POINT TO FAIL IN FAIL WORD{21250
{{JSR{6,CDWRD{{{GENERATE{21251
{{JSR{6,CDGCG{{{GENERATE CODE FOR FAILURE GOTO{21252
{{MOV{8,WB{8,WA{{COPY OFFSET TO O$GOF FOR CDFAL{21253
{{MOV{22,=B$CDC{8,WB{{SET COMPLEX CASE CDTYP{21254
{{BRN{6,CMP25{{{JUMP TO BUILD CDBLK{21255
*
*      HERE IF NO FAILURE GOTO GIVEN
*
{CMP23{MOV{21,=OUNF${8,WA{{LOAD UNEXPECTED FAILURE CALL IN CAS{21259
{{MOV{3,CSWFL{8,WC{{GET -NOFAIL FLAG{21260
{{ORB{13,CMCGO(XS){8,WC{{CHECK IF CONDITIONAL GOTO{21261
{{ZRB{8,WC{6,CMPSE{{JUMP IF -NOFAIL AND NO COND. GOTO{21262
{{MNZ{13,CMFFC(XS){{{ELSE SET FILL IN FLAG{21263
{{MOV{21,=OCER${8,WA{{AND SET COMPILE ERROR FOR TEMPORARY{21264
*
*      MERGE HERE WITH CDFAL VALUE IN WA, SIMPLE CDBLK
*      ALSO SPECIAL ENTRY AFTER STATEMENT ERROR
*
{CMPSE{MOV{22,=B$CDS{8,WB{{SET CDTYP FOR SIMPLE CASE{21269
{{EJC{{{{{21270
*
*      CMPIL (CONTINUED)
*
*      MERGE HERE TO BUILD CDBLK
*
*      (WA)                  CDFAL VALUE TO BE GENERATED
*      (WB)                  CDTYP VALUE TO BE GENERATED
*
*      AT THIS STAGE, WE CHOP OFF AN APPROPRIATE CHUNK OF THE
*      CURRENT CCBLK AND CONVERT IT INTO A CDBLK. THE REMAINDER
*      OF THE CCBLK IS REFORMATTED TO BE THE NEW CCBLK.
*
{CMP25{MOV{3,R$CCB{7,XR{{POINT TO CCBLK{21283
{{MOV{13,CMLBL(XS){7,XL{{GET POSSIBLE LABEL POINTER{21284
{{BZE{7,XL{6,CMP26{{SKIP IF NO LABEL{21285
{{ZER{13,CMLBL(XS){{{CLEAR FLAG FOR NEXT STATEMENT{21286
{{MOV{7,XR{13,VRLBL(XL){{PUT CDBLK PTR IN VRBLK LABEL FIELD{21287
*
*      MERGE AFTER DOING LABEL
*
{CMP26{MOV{8,WB{9,(XR){{SET TYPE WORD FOR NEW CDBLK{21291
{{MOV{8,WA{13,CDFAL(XR){{SET FAILURE WORD{21292
{{MOV{7,XR{7,XL{{COPY POINTER TO CCBLK{21293
{{MOV{13,CCUSE(XR){8,WB{{LOAD LENGTH GEN (= NEW CDLEN){21294
{{MOV{13,CCLEN(XR){8,WC{{LOAD TOTAL CCBLK LENGTH{21295
{{ADD{8,WB{7,XL{{POINT PAST CDBLK{21296
{{SUB{8,WB{8,WC{{GET LENGTH LEFT FOR CHOP OFF{21297
{{MOV{22,=B$CCT{9,(XL){{SET TYPE CODE FOR NEW CCBLK AT END{21298
{{MOV{19,*CCCOD{13,CCUSE(XL){{SET INITIAL CODE OFFSET{21299
{{MOV{19,*CCCOD{3,CWCOF{{REINITIALISE CWCOF{21300
{{MOV{8,WC{13,CCLEN(XL){{SET NEW LENGTH{21301
{{MOV{7,XL{3,R$CCB{{SET NEW CCBLK POINTER{21302
{{ZER{13,CCSLN(XL){{{INITIALIZE NEW LINE NUMBER{21304
{{MOV{3,CMPLN{13,CDSLN(XR){{SET LINE NUMBER IN OLD BLOCK{21305
{{MOV{3,CMPSN{13,CDSTM(XR){{SET STATEMENT NUMBER{21307
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{21308
*
*      SET POINTERS IN PREVIOUS CODE BLOCK AS REQUIRED
*
{{MOV{13,CMPCD(XS){7,XL{{LOAD PTR TO PREVIOUS CDBLK{21312
{{BZE{13,CMFFP(XS){6,CMP27{{JUMP IF NO FAILURE FILL IN REQUIRED{21313
{{MOV{7,XR{13,CDFAL(XL){{ELSE SET FAILURE PTR IN PREVIOUS{21314
*
*      HERE TO DEAL WITH SUCCESS FORWARD POINTER
*
{CMP27{MOV{13,CMSOP(XS){8,WA{{LOAD SUCCESS OFFSET{21318
{{BZE{8,WA{6,CMP28{{JUMP IF NO FILL IN REQUIRED{21319
{{ADD{8,WA{7,XL{{ELSE POINT TO FILL IN LOCATION{21320
{{MOV{7,XR{9,(XL){{STORE FORWARD POINTER{21321
{{ZER{7,XL{{{CLEAR GARBAGE XL VALUE{21322
{{EJC{{{{{21323
*
*      CMPIL (CONTINUED)
*
*      NOW SET FILL IN POINTERS FOR THIS STATEMENT
*
{CMP28{MOV{13,CMFFC(XS){13,CMFFP(XS){{COPY FAILURE FILL IN FLAG{21329
{{MOV{13,CMSOC(XS){13,CMSOP(XS){{COPY SUCCESS FILL IN OFFSET{21330
{{MOV{7,XR{13,CMPCD(XS){{SAVE PTR TO THIS CDBLK{21331
{{BNZ{13,CMTRA(XS){6,CMP29{{JUMP IF INITIAL ENTRY ALREADY SET{21332
{{MOV{7,XR{13,CMTRA(XS){{ELSE SET PTR HERE AS DEFAULT{21333
*
*      HERE AFTER COMPILING ONE STATEMENT
*
{CMP29{BLT{3,STAGE{18,=STGCE{6,CMP01{JUMP IF NOT END LINE JUST DONE{21337
{{BZE{3,CSWLS{6,CMP30{{SKIP IF -NOLIST{21338
{{JSR{6,LISTR{{{LIST LAST LINE{21339
*
*      RETURN
*
{CMP30{MOV{13,CMTRA(XS){7,XR{{LOAD INITIAL ENTRY CDBLK POINTER{21343
{{ADD{19,*CMNEN{7,XS{{POP WORK LOCATIONS OFF STACK{21344
{{EXI{{{{AND RETURN TO CMPIL CALLER{21345
*
*      HERE AT END OF GOTO FIELD
*
{CMP31{MOV{13,CMFGO(XS){8,WB{{GET FAIL GOTO{21349
{{ORB{13,CMSGO(XS){8,WB{{OR IN SUCCESS GOTO{21350
{{BNZ{8,WB{6,CMP18{{OK IF NON-NULL FIELD{21351
{{ERB{1,219{26,Syntax error: Empty goto field{{{21352
*
*      CONTROL CARD FOUND
*
{CMP32{ICV{8,WB{{{POINT PAST CH$MN{21356
{{JSR{6,CNCRD{{{PROCESS CONTROL CARD{21357
{{ZER{3,SCNSE{{{CLEAR START OF ELEMENT LOC.{21358
{{BRN{6,CMPCE{{{LOOP FOR NEXT STATEMENT{21359
{{ENP{{{{END PROCEDURE CMPIL{21360
{{EJC{{{{{21361
*
*      CNCRD -- CONTROL CARD PROCESSOR
*
*      CALLED TO DEAL WITH CONTROL CARDS
*
*      R$CIM                 POINTS TO CURRENT IMAGE
*      (WB)                  OFFSET TO 1ST CHAR OF CONTROL CARD
*      JSR  CNCRD            CALL TO PROCESS CONTROL CARDS
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{CNCRD{PRC{25,E{1,0{{ENTRY POINT{21372
{{MOV{8,WB{3,SCNPT{{OFFSET FOR CONTROL CARD SCAN{21373
{{MOV{18,=CCNOC{8,WA{{NUMBER OF CHARS FOR COMPARISON{21374
{{CTW{8,WA{1,0{{CONVERT TO WORD COUNT{21375
{{MOV{8,WA{3,CNSWC{{SAVE WORD COUNT{21376
*
*      LOOP HERE IF MORE THAN ONE CONTROL CARD
*
{CNC01{BGE{3,SCNPT{3,SCNIL{6,CNC09{RETURN IF END OF IMAGE{21380
{{MOV{3,R$CIM{7,XR{{POINT TO IMAGE{21381
{{PLC{7,XR{3,SCNPT{{CHAR PTR FOR FIRST CHAR{21382
{{LCH{8,WA{10,(XR)+{{GET FIRST CHAR{21383
{{FLC{8,WA{{{FOLD TO UPPER CASE{21385
{{BEQ{8,WA{18,=CH$LI{6,CNC07{SPECIAL CASE OF -INXXX{21387
{CNC0A{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21388
{{JSR{6,SCANE{{{SCAN CARD NAME{21389
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21390
{{BNZ{7,XL{6,CNC06{{FAIL UNLESS CONTROL CARD NAME{21391
{{MOV{18,=CCNOC{8,WA{{NO. OF CHARS TO BE COMPARED{21392
{{BLT{13,SCLEN(XR){8,WA{6,CNC08{FAIL IF TOO FEW CHARS{21394
{{MOV{7,XR{7,XL{{POINT TO CONTROL CARD NAME{21398
{{ZER{8,WB{{{ZERO OFFSET FOR SUBSTRING{21399
{{JSR{6,SBSTR{{{EXTRACT SUBSTRING FOR COMPARISON{21400
{{MOV{13,SCLEN(XR){8,WA{{RELOAD LENGTH{21402
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{21403
{{MOV{7,XR{3,CNSCC{{KEEP CONTROL CARD SUBSTRING PTR{21405
{{MOV{21,=CCNMS{7,XR{{POINT TO LIST OF STANDARD NAMES{21406
{{ZER{8,WB{{{INITIALISE NAME OFFSET{21407
{{LCT{8,WC{18,=CC$NC{{NUMBER OF STANDARD NAMES{21408
*
*      TRY TO MATCH NAME
*
{CNC02{MOV{3,CNSCC{7,XL{{POINT TO NAME{21412
{{LCT{8,WA{3,CNSWC{{COUNTER FOR INNER LOOP{21413
{{BRN{6,CNC04{{{JUMP INTO LOOP{21414
*
*      INNER LOOP TO MATCH CARD NAME CHARS
*
{CNC03{ICA{7,XR{{{BUMP STANDARD NAMES PTR{21418
{{ICA{7,XL{{{BUMP NAME POINTER{21419
*
*      HERE TO INITIATE THE LOOP
*
{CNC04{CNE{13,SCHAR(XL){9,(XR){6,CNC05{COMP. UP TO CFP$C CHARS AT ONCE{21423
{{BCT{8,WA{6,CNC03{{LOOP IF MORE WORDS TO COMPARE{21424
{{EJC{{{{{21425
*
*      CNCRD (CONTINUED)
*
*      MATCHED - BRANCH ON CARD OFFSET
*
{{MOV{8,WB{7,XL{{GET NAME OFFSET{21431
{{BSW{7,XL{2,CC$NC{6,CNC08{SWITCH{21433
{{IFF{2,CC$CA{6,CNC37{{-CASE{21472
{{IFF{2,CC$DO{6,CNC10{{-DOUBLE{21472
{{IFF{1,2{6,CNC08{{{21472
{{IFF{2,CC$DU{6,CNC11{{-DUMP{21472
{{IFF{2,CC$CP{6,CNC41{{-COPY{21472
{{IFF{2,CC$EJ{6,CNC12{{-EJECT{21472
{{IFF{2,CC$ER{6,CNC13{{-ERRORS{21472
{{IFF{2,CC$EX{6,CNC14{{-EXECUTE{21472
{{IFF{2,CC$FA{6,CNC15{{-FAIL{21472
{{IFF{2,CC$IN{6,CNC41{{-INCLUDE{21472
{{IFF{2,CC$LN{6,CNC44{{-LINE{21472
{{IFF{2,CC$LI{6,CNC16{{-LIST{21472
{{IFF{2,CC$NR{6,CNC17{{-NOERRORS{21472
{{IFF{2,CC$NX{6,CNC18{{-NOEXECUTE{21472
{{IFF{2,CC$NF{6,CNC19{{-NOFAIL{21472
{{IFF{2,CC$NL{6,CNC20{{-NOLIST{21472
{{IFF{2,CC$NO{6,CNC21{{-NOOPT{21472
{{IFF{2,CC$NP{6,CNC22{{-NOPRINT{21472
{{IFF{2,CC$OP{6,CNC24{{-OPTIMISE{21472
{{IFF{2,CC$PR{6,CNC25{{-PRINT{21472
{{IFF{2,CC$SI{6,CNC27{{-SINGLE{21472
{{IFF{2,CC$SP{6,CNC28{{-SPACE{21472
{{IFF{2,CC$ST{6,CNC31{{-STITLE{21472
{{IFF{2,CC$TI{6,CNC32{{-TITLE{21472
{{IFF{2,CC$TR{6,CNC36{{-TRACE{21472
{{ESW{{{{END SWITCH{21472
*
*      NOT MATCHED YET. ALIGN STD NAMES PTR AND TRY AGAIN
*
{CNC05{ICA{7,XR{{{BUMP STANDARD NAMES PTR{21476
{{BCT{8,WA{6,CNC05{{LOOP{21477
{{ICV{8,WB{{{BUMP NAMES OFFSET{21478
{{BCT{8,WC{6,CNC02{{CONTINUE IF MORE NAMES{21479
{{BRN{6,CNC08{{{IGNORE UNRECOGNIZED CONTROL CARD{21481
*
*      INVALID CONTROL CARD NAME
*
{CNC06{ERB{1,247{26,Invalid control statement{{{21486
*
*      SPECIAL PROCESSING FOR -INXXX
*
{CNC07{LCH{8,WA{10,(XR)+{{GET NEXT CHAR{21490
{{FLC{8,WA{{{FOLD TO UPPER CASE{21492
{{BNE{8,WA{18,=CH$LN{6,CNC0A{IF NOT LETTER N{21494
{{LCH{8,WA{9,(XR){{GET THIRD CHAR{21495
{{BLT{8,WA{18,=CH$D0{6,CNC0A{IF NOT DIGIT{21496
{{BGT{8,WA{18,=CH$D9{6,CNC0A{IF NOT DIGIT{21497
{{ADD{18,=NUM02{3,SCNPT{{BUMP OFFSET PAST -IN{21498
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -IN{21499
{{MOV{7,XR{11,-(XS){{STACK SCANNED ITEM{21500
{{JSR{6,GTSMI{{{CHECK IF INTEGER{21501
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21502
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{21503
{{MOV{7,XR{3,CSWIN{{KEEP INTEGER{21504
{{EJC{{{{{21505
*
*      CNCRD (CONTINUED)
*
*      CHECK FOR MORE CONTROL CARDS BEFORE RETURNING
*
{CNC08{MOV{3,SCNPT{8,WA{{PRESERVE IN CASE XEQ TIME COMPILE{21511
{{JSR{6,SCANE{{{LOOK FOR COMMA{21512
{{BEQ{7,XL{18,=T$CMA{6,CNC01{LOOP IF COMMA FOUND{21513
{{MOV{8,WA{3,SCNPT{{RESTORE SCNPT IN CASE XEQ TIME{21514
*
*      RETURN POINT
*
{CNC09{EXI{{{{RETURN{21518
*
*      -DOUBLE
*
{CNC10{MNZ{3,CSWDB{{{SET SWITCH{21522
{{BRN{6,CNC08{{{MERGE{21523
*
*      -DUMP
*      THIS IS USED FOR SYSTEM DEBUGGING . IT HAS THE EFFECT OF
*      PRODUCING A CORE DUMP AT COMPILATION TIME
*
{CNC11{JSR{6,SYSDM{{{CALL DUMPER{21529
{{BRN{6,CNC09{{{FINISHED{21530
*
*      -EJECT
*
{CNC12{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{21534
{{JSR{6,PRTPS{{{EJECT{21535
{{JSR{6,LISTT{{{LIST TITLE{21536
{{BRN{6,CNC09{{{FINISHED{21537
*
*      -ERRORS
*
{CNC13{ZER{3,CSWER{{{CLEAR SWITCH{21541
{{BRN{6,CNC08{{{MERGE{21542
*
*      -EXECUTE
*
{CNC14{ZER{3,CSWEX{{{CLEAR SWITCH{21546
{{BRN{6,CNC08{{{MERGE{21547
*
*      -FAIL
*
{CNC15{MNZ{3,CSWFL{{{SET SWITCH{21551
{{BRN{6,CNC08{{{MERGE{21552
*
*      -LIST
*
{CNC16{MNZ{3,CSWLS{{{SET SWITCH{21556
{{BEQ{3,STAGE{18,=STGIC{6,CNC08{DONE IF COMPILE TIME{21557
*
*      LIST CODE LINE IF EXECUTE TIME COMPILE
*
{{ZER{3,LSTPF{{{PERMIT LISTING{21561
{{JSR{6,LISTR{{{LIST LINE{21562
{{BRN{6,CNC08{{{MERGE{21563
{{EJC{{{{{21564
*
*      CNCRD (CONTINUED)
*
*      -NOERRORS
*
{CNC17{MNZ{3,CSWER{{{SET SWITCH{21570
{{BRN{6,CNC08{{{MERGE{21571
*
*      -NOEXECUTE
*
{CNC18{MNZ{3,CSWEX{{{SET SWITCH{21575
{{BRN{6,CNC08{{{MERGE{21576
*
*      -NOFAIL
*
{CNC19{ZER{3,CSWFL{{{CLEAR SWITCH{21580
{{BRN{6,CNC08{{{MERGE{21581
*
*      -NOLIST
*
{CNC20{ZER{3,CSWLS{{{CLEAR SWITCH{21585
{{BRN{6,CNC08{{{MERGE{21586
*
*      -NOOPTIMISE
*
{CNC21{MNZ{3,CSWNO{{{SET SWITCH{21590
{{BRN{6,CNC08{{{MERGE{21591
*
*      -NOPRINT
*
{CNC22{ZER{3,CSWPR{{{CLEAR SWITCH{21595
{{BRN{6,CNC08{{{MERGE{21596
*
*      -OPTIMISE
*
{CNC24{ZER{3,CSWNO{{{CLEAR SWITCH{21600
{{BRN{6,CNC08{{{MERGE{21601
*
*      -PRINT
*
{CNC25{MNZ{3,CSWPR{{{SET SWITCH{21605
{{BRN{6,CNC08{{{MERGE{21606
{{EJC{{{{{21607
*
*      CNCRD (CONTINUED)
*
*      -SINGLE
*
{CNC27{ZER{3,CSWDB{{{CLEAR SWITCH{21613
{{BRN{6,CNC08{{{MERGE{21614
*
*      -SPACE
*
{CNC28{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{21618
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -SPACE{21619
{{MOV{18,=NUM01{8,WC{{1 SPACE IN CASE{21620
{{BEQ{7,XR{18,=T$SMC{6,CNC29{JUMP IF NO INTEGER{21621
{{MOV{7,XR{11,-(XS){{STACK IT{21622
{{JSR{6,GTSMI{{{CHECK INTEGER{21623
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21624
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{21625
{{BNZ{8,WC{6,CNC29{{JUMP IF NON ZERO{21626
{{MOV{18,=NUM01{8,WC{{ELSE 1 SPACE{21627
*
*      MERGE WITH COUNT OF LINES TO SKIP
*
{CNC29{ADD{8,WC{3,LSTLC{{BUMP LINE COUNT{21631
{{LCT{8,WC{8,WC{{CONVERT TO LOOP COUNTER{21632
{{BLT{3,LSTLC{3,LSTNP{6,CNC30{JUMP IF FITS ON PAGE{21633
{{JSR{6,PRTPS{{{EJECT{21634
{{JSR{6,LISTT{{{LIST TITLE{21635
{{BRN{6,CNC09{{{MERGE{21636
*
*      SKIP LINES
*
{CNC30{JSR{6,PRTNL{{{PRINT A BLANK{21640
{{BCT{8,WC{6,CNC30{{LOOP{21641
{{BRN{6,CNC09{{{MERGE{21642
{{EJC{{{{{21643
*
*      CNCRD (CONTINUED)
*
*      -STITL
*
{CNC31{MOV{20,=R$STL{3,CNR$T{{PTR TO R$STL{21649
{{BRN{6,CNC33{{{MERGE{21650
*
*      -TITLE
*
{CNC32{MOV{21,=NULLS{3,R$STL{{CLEAR SUBTITLE{21654
{{MOV{20,=R$TTL{3,CNR$T{{PTR TO R$TTL{21655
*
*      COMMON PROCESSING FOR -TITLE, -STITL
*
{CNC33{MOV{21,=NULLS{7,XR{{NULL IN CASE NEEDED{21659
{{MNZ{3,CNTTL{{{SET FLAG FOR NEXT LISTR CALL{21660
{{MOV{18,=CCOFS{8,WB{{OFFSET TO TITLE/SUBTITLE{21661
{{MOV{3,SCNIL{8,WA{{INPUT IMAGE LENGTH{21662
{{BLO{8,WA{8,WB{6,CNC34{JUMP IF NO CHARS LEFT{21663
{{SUB{8,WB{8,WA{{NO OF CHARS TO EXTRACT{21664
{{MOV{3,R$CIM{7,XL{{POINT TO IMAGE{21665
{{JSR{6,SBSTR{{{GET TITLE/SUBTITLE{21666
*
*      STORE TITLE/SUBTITLE
*
{CNC34{MOV{3,CNR$T{7,XL{{POINT TO STORAGE LOCATION{21670
{{MOV{7,XR{9,(XL){{STORE TITLE/SUBTITLE{21671
{{BEQ{7,XL{20,=R$STL{6,CNC09{RETURN IF STITL{21672
{{BNZ{3,PRECL{6,CNC09{{RETURN IF EXTENDED LISTING{21673
{{BZE{3,PRICH{6,CNC09{{RETURN IF REGULAR PRINTER{21674
{{MOV{13,SCLEN(XR){7,XL{{GET LENGTH OF TITLE{21675
{{MOV{7,XL{8,WA{{COPY IT{21676
{{BZE{7,XL{6,CNC35{{JUMP IF NULL{21677
{{ADD{18,=NUM10{7,XL{{INCREMENT{21678
{{BHI{7,XL{3,PRLEN{6,CNC09{USE DEFAULT LSTP0 VAL IF TOO LONG{21679
{{ADD{18,=NUM04{8,WA{{POINT JUST PAST TITLE{21680
*
*      STORE OFFSET TO PAGE NN MESSAGE FOR SHORT TITLE
*
{CNC35{MOV{8,WA{3,LSTPO{{STORE OFFSET{21684
{{BRN{6,CNC09{{{RETURN{21685
*
*      -TRACE
*      PROVIDED FOR SYSTEM DEBUGGING.  TOGGLES THE SYSTEM LABEL
*      TRACE SWITCH AT COMPILE TIME
*
{CNC36{JSR{6,SYSTT{{{TOGGLE SWITCH{21691
{{BRN{6,CNC08{{{MERGE{21692
*
*      -CASE
*      SETS VALUE OF KVCAS SO THAT NAMES ARE FOLDED OR NOT
*      DURING COMPILATION.
*
{CNC37{JSR{6,SCANE{{{SCAN INTEGER AFTER -CASE{21699
{{ZER{8,WC{{{GET 0 IN CASE NONE THERE{21700
{{BEQ{7,XL{18,=T$SMC{6,CNC38{SKIP IF NO INTEGER{21701
{{MOV{7,XR{11,-(XS){{STACK IT{21702
{{JSR{6,GTSMI{{{CHECK INTEGER{21703
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21704
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR TOO LARGE{21705
{CNC38{MOV{8,WC{3,KVCAS{{STORE NEW CASE VALUE{21706
{{BRN{6,CNC09{{{MERGE{21707
*
*      -INCLUDE
*
{CNC41{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21730
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{21731
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21732
{{BNE{7,XL{18,=T$CON{6,CNC06{IF NOT CONSTANT{21733
{{BNE{9,(XR){22,=B$SCL{6,CNC06{IF NOT STRING CONSTANT{21734
{{MOV{7,XR{3,R$IFN{{SAVE FILE NAME{21735
{{MOV{3,R$INC{7,XL{{EXAMINE INCLUDE FILE NAME TABLE{21736
{{ZER{8,WB{{{LOOKUP BY VALUE{21737
{{JSR{6,TFIND{{{DO LOOKUP{21738
{{PPM{{{{NEVER FAILS{21739
{{BEQ{7,XR{21,=INTON{6,CNC09{IGNORE IF ALREADY IN TABLE{21740
{{MNZ{8,WB{{{SET FOR TRIM{21741
{{MOV{3,R$IFN{7,XR{{FILE NAME{21742
{{JSR{6,TRIMR{{{REMOVE TRAILING BLANKS{21743
{{MOV{3,R$INC{7,XL{{INCLUDE FILE NAME TABLE{21744
{{MNZ{8,WB{{{LOOKUP BY NAME THIS TIME{21745
{{JSR{6,TFIND{{{DO LOOKUP{21746
{{PPM{{{{NEVER FAILS{21747
{{MOV{21,=INTON{13,TEVAL(XL){{MAKE TABLE VALUE INTEGER 1{21748
{{ICV{3,CNIND{{{INCREASE NESTING LEVEL{21749
{{MOV{3,CNIND{8,WA{{LOAD NEW NEST LEVEL{21750
{{BGT{8,WA{18,=CCINM{6,CNC42{FAIL IF EXCESSIVE NESTING{21751
*
*      RECORD THE NAME AND LINE NUMBER OF THE CURRENT INPUT FILE
*
{{MOV{3,R$IFA{7,XL{{ARRAY OF NESTED FILE NAMES{21756
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{21757
{{WTB{8,WA{{{CONVERT TO BYTES{21758
{{ADD{8,WA{7,XL{{POINT TO ELEMENT{21759
{{MOV{3,R$SFC{9,(XL){{RECORD CURRENT FILE NAME{21760
{{MOV{8,WA{7,XL{{PRESERVE NESTING BYTE OFFSET{21761
{{MTI{3,RDNLN{{{FETCH SOURCE LINE NUMBER AS INTEGER{21762
{{JSR{6,ICBLD{{{CONVERT TO ICBLK{21763
{{ADD{3,R$IFL{7,XL{{ENTRY IN NESTED LINE NUMBER ARRAY{21764
{{MOV{7,XR{9,(XL){{RECORD IN ARRAY{21765
*
*      HERE TO SWITCH TO INCLUDE FILE NAMED IN R$IFN
*
{{MOV{3,CSWIN{8,WA{{MAX READ LENGTH{21770
{{MOV{3,R$IFN{7,XL{{INCLUDE FILE NAME{21771
{{JSR{6,ALOCS{{{GET BUFFER FOR COMPLETE FILE NAME{21772
{{JSR{6,SYSIF{{{OPEN INCLUDE FILE{21773
{{PPM{6,CNC43{{{COULD NOT OPEN{21774
*
*      MAKE NOTE OF THE COMPLETE FILE NAME FOR ERROR MESSAGES
*
{{ZER{8,WB{{{DO NOT TRIM TRAILING BLANKS{21779
{{JSR{6,TRIMR{{{ADJUST SCBLK FOR ACTUAL LENGTH{21780
{{MOV{7,XR{3,R$SFC{{SAVE PTR TO FILE NAME{21781
{{MTI{3,CMPSN{{{CURRENT STATEMENT AS INTEGER{21782
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{21783
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{21784
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{21785
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{21786
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{21787
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{21788
{{ZER{3,RDNLN{{{RESTART LINE COUNTER FOR NEW FILE{21792
{{BEQ{3,STAGE{18,=STGIC{6,CNC09{IF INITIAL COMPILE{21793
{{BNE{3,CNIND{18,=NUM01{6,CNC09{IF NOT FIRST EXECUTE-TIME NESTING{21794
*
*      HERE FOR -INCLUDE DURING EXECUTE-TIME COMPILE
*
{{MOV{3,R$CIM{3,R$ICI{{REMEMBER CODE ARGUMENT STRING{21798
{{MOV{3,SCNPT{3,CNSPT{{SAVE POSITION IN STRING{21799
{{MOV{3,SCNIL{3,CNSIL{{AND LENGTH OF STRING{21800
{{BRN{6,CNC09{{{ALL DONE, MERGE{21801
*
*      HERE FOR EXCESSIVE INCLUDE FILE NESTING
*
{CNC42{ERB{1,284{26,Excessively nested INCLUDE files{{{21805
*
*      HERE IF INCLUDE FILE COULD NOT BE OPENED
*
{CNC43{MOV{7,XR{3,DNAMP{{RELEASE ALLOCATED SCBLK{21809
{{ERB{1,285{26,INCLUDE file cannot be opened{{{21810
*
*
*      -LINE N FILENAME
*
{CNC44{JSR{6,SCANE{{{SCAN INTEGER AFTER -LINE{21817
{{BNE{7,XL{18,=T$CON{6,CNC06{JUMP IF NO LINE NUMBER{21818
{{BNE{9,(XR){22,=B$ICL{6,CNC06{JUMP IF NOT INTEGER{21819
{{LDI{13,ICVAL(XR){{{FETCH INTEGER LINE NUMBER{21820
{{ILE{6,CNC06{{{ERROR IF NEGATIVE OR ZERO{21821
{{BEQ{3,STAGE{18,=STGIC{6,CNC45{SKIP IF INITIAL COMPILE{21822
{{MFI{3,CMPLN{{{SET DIRECTLY FOR OTHER COMPILES{21823
{{BRN{6,CNC46{{{NO NEED TO SET RDNLN{21824
{CNC45{SBI{4,INTV1{{{ADJUST NUMBER BY ONE{21825
{{MFI{3,RDNLN{{{SAVE LINE NUMBER{21826
{CNC46{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21828
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{21829
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21830
{{BEQ{7,XL{18,=T$SMC{6,CNC47{DONE IF NO FILE NAME{21831
{{BNE{7,XL{18,=T$CON{6,CNC06{ERROR IF NOT CONSTANT{21832
{{BNE{9,(XR){22,=B$SCL{6,CNC06{IF NOT STRING CONSTANT{21833
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{21834
{{BRN{6,CNC09{{{MERGE{21835
*
*      HERE IF FILE NAME NOT PRESENT
*
{CNC47{DCV{3,SCNPT{{{SET TO RESCAN THE TERMINATOR{21839
{{BRN{6,CNC09{{{MERGE{21840
{{ENP{{{{END PROCEDURE CNCRD{21845
{{EJC{{{{{21846
*
*      DFFNC -- DEFINE FUNCTION
*
*      DFFNC IS CALLED WHENEVER A NEW FUNCTION IS ASSIGNED TO
*      A VARIABLE. IT DEALS WITH EXTERNAL FUNCTION USE COUNTS.
*
*      (XR)                  POINTER TO VRBLK
*      (XL)                  POINTER TO NEW FUNCTION BLOCK
*      JSR  DFFNC            CALL TO DEFINE FUNCTION
*      (WA,WB)               DESTROYED
*
{DFFNC{PRC{25,E{1,0{{ENTRY POINT{21928
{{BNE{9,(XL){22,=B$EFC{6,DFFN1{SKIP IF NEW FUNCTION NOT EXTERNAL{21931
{{ICV{13,EFUSE(XL){{{ELSE INCREMENT ITS USE COUNT{21932
*
*      HERE AFTER DEALING WITH NEW FUNCTION USE COUNT
*
{DFFN1{MOV{7,XR{8,WA{{SAVE VRBLK POINTER{21936
{{MOV{13,VRFNC(XR){7,XR{{LOAD OLD FUNCTION POINTER{21937
{{BNE{9,(XR){22,=B$EFC{6,DFFN2{JUMP IF OLD FUNCTION NOT EXTERNAL{21938
{{MOV{13,EFUSE(XR){8,WB{{ELSE GET USE COUNT{21939
{{DCV{8,WB{{{DECREMENT{21940
{{MOV{8,WB{13,EFUSE(XR){{STORE DECREMENTED VALUE{21941
{{BNZ{8,WB{6,DFFN2{{JUMP IF USE COUNT STILL NON-ZERO{21942
{{JSR{6,SYSUL{{{ELSE CALL SYSTEM UNLOAD FUNCTION{21943
*
*      HERE AFTER DEALING WITH OLD FUNCTION USE COUNT
*
{DFFN2{MOV{8,WA{7,XR{{RESTORE VRBLK POINTER{21947
{{MOV{7,XL{8,WA{{COPY FUNCTION BLOCK PTR{21949
{{BLT{7,XR{20,=R$YYY{6,DFFN3{SKIP CHECKS IF OPSYN OP DEFINITION{21950
{{BNZ{13,VRLEN(XR){6,DFFN3{{JUMP IF NOT SYSTEM VARIABLE{21951
*
*      FOR SYSTEM VARIABLE, CHECK FOR ILLEGAL REDEFINITION
*
{{MOV{13,VRSVP(XR){7,XL{{POINT TO SVBLK{21955
{{MOV{13,SVBIT(XL){8,WB{{LOAD BIT INDICATORS{21956
{{ANB{4,BTFNC{8,WB{{IS IT A SYSTEM FUNCTION{21957
{{ZRB{8,WB{6,DFFN3{{REDEF OK IF NOT{21958
{{ERB{1,248{26,Attempted redefinition of system function{{{21959
*
*      HERE IF REDEFINITION IS PERMITTED
*
{DFFN3{MOV{8,WA{13,VRFNC(XR){{STORE NEW FUNCTION POINTER{21963
{{MOV{8,WA{7,XL{{RESTORE FUNCTION BLOCK POINTER{21964
{{EXI{{{{RETURN TO DFFNC CALLER{21965
{{ENP{{{{END PROCEDURE DFFNC{21966
{{EJC{{{{{21967
*
*      DTACH -- DETACH I/O ASSOCIATED NAMES
*
*      DETACHES TRBLKS FROM I/O ASSOCIATED VARIABLES, REMOVES
*      ENTRY FROM IOCHN CHAIN ATTACHED TO FILEARG1 VRBLK AND MAY
*      REMOVE VRBLK ACCESS AND STORE TRAPS.
*      INPUT, OUTPUT, TERMINAL ARE HANDLED SPECIALLY.
*
*      (XL)                  I/O ASSOC. VBL NAME BASE PTR
*      (WA)                  OFFSET TO NAME
*      JSR  DTACH            CALL FOR DETACH OPERATION
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{DTACH{PRC{25,E{1,0{{ENTRY POINT{21981
{{MOV{7,XL{3,DTCNB{{STORE NAME BASE (GBCOL NOT CALLED){21982
{{ADD{8,WA{7,XL{{POINT TO NAME LOCATION{21983
{{MOV{7,XL{3,DTCNM{{STORE IT{21984
*
*      LOOP TO SEARCH FOR I/O TRBLK
*
{DTCH1{MOV{7,XL{7,XR{{COPY NAME POINTER{21988
*
*      CONTINUE AFTER BLOCK DELETION
*
{DTCH2{MOV{9,(XL){7,XL{{POINT TO NEXT VALUE{21992
{{BNE{9,(XL){22,=B$TRT{6,DTCH6{JUMP AT CHAIN END{21993
{{MOV{13,TRTYP(XL){8,WA{{GET TRAP BLOCK TYPE{21994
{{BEQ{8,WA{18,=TRTIN{6,DTCH3{JUMP IF INPUT{21995
{{BEQ{8,WA{18,=TRTOU{6,DTCH3{JUMP IF OUTPUT{21996
{{ADD{19,*TRNXT{7,XL{{POINT TO NEXT LINK{21997
{{BRN{6,DTCH1{{{LOOP{21998
*
*      DELETE AN OLD ASSOCIATION
*
{DTCH3{MOV{13,TRVAL(XL){9,(XR){{DELETE TRBLK{22002
{{MOV{7,XL{8,WA{{DUMP XL ...{22003
{{MOV{7,XR{8,WB{{... AND XR{22004
{{MOV{13,TRTRF(XL){7,XL{{POINT TO TRTRF TRAP BLOCK{22005
{{BZE{7,XL{6,DTCH5{{JUMP IF NO IOCHN{22006
{{BNE{9,(XL){22,=B$TRT{6,DTCH5{JUMP IF INPUT, OUTPUT, TERMINAL{22007
*
*      LOOP TO SEARCH IOCHN CHAIN FOR NAME PTR
*
{DTCH4{MOV{7,XL{7,XR{{REMEMBER LINK PTR{22011
{{MOV{13,TRTRF(XL){7,XL{{POINT TO NEXT LINK{22012
{{BZE{7,XL{6,DTCH5{{JUMP IF END OF CHAIN{22013
{{MOV{13,IONMB(XL){8,WC{{GET NAME BASE{22014
{{ADD{13,IONMO(XL){8,WC{{ADD OFFSET{22015
{{BNE{8,WC{3,DTCNM{6,DTCH4{LOOP IF NO MATCH{22016
{{MOV{13,TRTRF(XL){13,TRTRF(XR){{REMOVE NAME FROM CHAIN{22017
{{EJC{{{{{22018
*
*      DTACH (CONTINUED)
*
*      PREPARE TO RESUME I/O TRBLK SCAN
*
{DTCH5{MOV{8,WA{7,XL{{RECOVER XL ...{22024
{{MOV{8,WB{7,XR{{... AND XR{22025
{{ADD{19,*TRVAL{7,XL{{POINT TO VALUE FIELD{22026
{{BRN{6,DTCH2{{{CONTINUE{22027
*
*      EXIT POINT
*
{DTCH6{MOV{3,DTCNB{7,XR{{POSSIBLE VRBLK PTR{22031
{{JSR{6,SETVR{{{RESET VRBLK IF NECESSARY{22032
{{EXI{{{{RETURN{22033
{{ENP{{{{END PROCEDURE DTACH{22034
{{EJC{{{{{22035
*
*      DTYPE -- GET DATATYPE NAME
*
*      (XR)                  OBJECT WHOSE DATATYPE IS REQUIRED
*      JSR  DTYPE            CALL TO GET DATATYPE
*      (XR)                  RESULT DATATYPE
*
{DTYPE{PRC{25,E{1,0{{ENTRY POINT{22043
{{BEQ{9,(XR){22,=B$PDT{6,DTYP1{JUMP IF PROG.DEFINED{22044
{{MOV{9,(XR){7,XR{{LOAD TYPE WORD{22045
{{LEI{7,XR{{{GET ENTRY POINT ID (BLOCK CODE){22046
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{22047
{{MOV{14,SCNMT(XR){7,XR{{LOAD TABLE ENTRY{22048
{{EXI{{{{EXIT TO DTYPE CALLER{22049
*
*      HERE IF PROGRAM DEFINED
*
{DTYP1{MOV{13,PDDFP(XR){7,XR{{POINT TO DFBLK{22053
{{MOV{13,DFNAM(XR){7,XR{{GET DATATYPE NAME FROM DFBLK{22054
{{EXI{{{{RETURN TO DTYPE CALLER{22055
{{ENP{{{{END PROCEDURE DTYPE{22056
{{EJC{{{{{22057
*
*      DUMPR -- PRINT DUMP OF STORAGE
*
*      (XR)                  DUMP ARGUMENT (SEE BELOW)
*      JSR  DUMPR            CALL TO PRINT DUMP
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      THE DUMP ARGUMENT HAS THE FOLLOWING SIGNIFICANCE
*
*      DMARG = 0             NO DUMP PRINTED
*      DMARG = 1             PARTIAL DUMP (NAT VARS, KEYWORDS)
*      DMARG = 2             FULL DUMP (ARRAYS, TABLES, ETC.)
*      DMARG = 3             FULL DUMP + NULL VARIABLES
*      DMARG GE 4            CORE DUMP
*
*      SINCE DUMPR SCRAMBLES STORE, IT IS NOT PERMISSIBLE TO
*      COLLECT IN MID-DUMP. HENCE A COLLECT IS DONE INITIALLY
*      AND THEN IF STORE RUNS OUT AN ERROR MESSAGE IS PRODUCED.
*
{DUMPR{PRC{25,E{1,0{{ENTRY POINT{22078
{{BZE{7,XR{6,DMP28{{SKIP DUMP IF ARGUMENT IS ZERO{22079
{{BGT{7,XR{18,=NUM03{6,DMP29{JUMP IF CORE DUMP REQUIRED{22080
{{ZER{7,XL{{{CLEAR XL{22081
{{ZER{8,WB{{{ZERO MOVE OFFSET{22082
{{MOV{7,XR{3,DMARG{{SAVE DUMP ARGUMENT{22083
{{ZER{3,DNAMS{{{COLLECT SEDIMENT TOO{22085
{{JSR{6,GBCOL{{{COLLECT GARBAGE{22087
{{JSR{6,PRTPG{{{EJECT PRINTER{22088
{{MOV{21,=DMHDV{7,XR{{POINT TO HEADING FOR VARIABLES{22089
{{JSR{6,PRTST{{{PRINT IT{22090
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{22091
{{JSR{6,PRTNL{{{AND PRINT A BLANK LINE{22092
*
*      FIRST ALL NATURAL VARIABLE BLOCKS (VRBLK) WHOSE VALUES
*      ARE NON-NULL ARE LINKED IN LEXICAL ORDER USING DMVCH AS
*      THE CHAIN HEAD AND CHAINING THROUGH THE VRGET FIELDS.
*      NOTE THAT THIS SCRAMBLES STORE IF THE PROCESS IS
*      INTERRUPTED BEFORE COMPLETION E.G. BY EXCEEDING TIME  OR
*      PRINT LIMITS. SINCE THE SUBSEQUENT CORE DUMPS AND
*      FAILURES IF EXECUTION IS RESUMED ARE VERY CONFUSING, THE
*      EXECUTION TIME ERROR ROUTINE CHECKS FOR THIS EVENT AND
*      ATTEMPTS AN UNSCRAMBLE. SIMILAR PRECAUTIONS SHOULD BE
*      OBSERVED IF TRANSLATE TIME DUMPING IS IMPLEMENTED.
*
{{ZER{3,DMVCH{{{SET NULL CHAIN TO START{22105
{{MOV{3,HSHTB{8,WA{{POINT TO HASH TABLE{22106
*
*      LOOP THROUGH HEADERS IN HASH TABLE
*
{DMP00{MOV{8,WA{7,XR{{COPY HASH BUCKET POINTER{22110
{{ICA{8,WA{{{BUMP POINTER{22111
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE{22112
*
*      LOOP THROUGH VRBLKS ON ONE CHAIN
*
{DMP01{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{22116
{{BZE{7,XR{6,DMP09{{JUMP IF END OF THIS HASH CHAIN{22117
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK POINTER{22118
{{EJC{{{{{22119
*
*      DUMPR (CONTINUED)
*
*      LOOP TO FIND VALUE AND SKIP IF NULL
*
{DMP02{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{22125
{{BEQ{3,DMARG{18,=NUM03{6,DMP2A{SKIP NULL VALUE CHECK IF DUMP(3){22126
{{BEQ{7,XL{21,=NULLS{6,DMP01{LOOP FOR NEXT VRBLK IF NULL VALUE{22127
{DMP2A{BEQ{9,(XL){22,=B$TRT{6,DMP02{LOOP BACK IF VALUE IS TRAPPED{22128
*
*      NON-NULL VALUE, PREPARE TO SEARCH CHAIN
*
{{MOV{7,XR{8,WC{{SAVE VRBLK POINTER{22132
{{ADD{19,*VRSOF{7,XR{{ADJUST PTR TO BE LIKE SCBLK PTR{22133
{{BNZ{13,SCLEN(XR){6,DMP03{{JUMP IF NON-SYSTEM VARIABLE{22134
{{MOV{13,VRSVO(XR){7,XR{{ELSE LOAD PTR TO NAME IN SVBLK{22135
*
*      HERE WITH NAME POINTER FOR NEW BLOCK IN XR
*
{DMP03{MOV{7,XR{8,WB{{SAVE POINTER TO CHARS{22139
{{MOV{8,WA{3,DMPSV{{SAVE HASH BUCKET POINTER{22140
{{MOV{20,=DMVCH{8,WA{{POINT TO CHAIN HEAD{22141
*
*      LOOP TO SEARCH CHAIN FOR CORRECT INSERTION POINT
*
{DMP04{MOV{8,WA{3,DMPCH{{SAVE CHAIN POINTER{22145
{{MOV{8,WA{7,XL{{COPY IT{22146
{{MOV{9,(XL){7,XR{{LOAD POINTER TO NEXT ENTRY{22147
{{BZE{7,XR{6,DMP08{{JUMP IF END OF CHAIN TO INSERT{22148
{{ADD{19,*VRSOF{7,XR{{ELSE GET NAME PTR FOR CHAINED VRBLK{22149
{{BNZ{13,SCLEN(XR){6,DMP05{{JUMP IF NOT SYSTEM VARIABLE{22150
{{MOV{13,VRSVO(XR){7,XR{{ELSE POINT TO NAME IN SVBLK{22151
*
*      HERE PREPARE TO COMPARE THE NAMES
*
*      (WA)                  SCRATCH
*      (WB)                  POINTER TO STRING OF ENTERING VRBLK
*      (WC)                  POINTER TO ENTERING VRBLK
*      (XR)                  POINTER TO STRING OF CURRENT BLOCK
*      (XL)                  SCRATCH
*
{DMP05{MOV{8,WB{7,XL{{POINT TO ENTERING VRBLK STRING{22161
{{MOV{13,SCLEN(XL){8,WA{{LOAD ITS LENGTH{22162
{{PLC{7,XL{{{POINT TO CHARS OF ENTERING STRING{22163
{{BHI{8,WA{13,SCLEN(XR){6,DMP06{JUMP IF ENTERING LENGTH HIGH{22186
{{PLC{7,XR{{{ELSE POINT TO CHARS OF OLD STRING{22187
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW IS LLT OLD{22188
{{BRN{6,DMP08{{{OR IF LEQ (WE HAD SHORTER LENGTH){22189
*
*      HERE WHEN NEW LENGTH IS LONGER THAN OLD LENGTH
*
{DMP06{MOV{13,SCLEN(XR){8,WA{{LOAD SHORTER LENGTH{22193
{{PLC{7,XR{{{POINT TO CHARS OF OLD STRING{22194
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW ONE LOW{22195
{{EJC{{{{{22196
*
*      DUMPR (CONTINUED)
*
*      HERE WE MOVE OUT ON THE CHAIN
*
{DMP07{MOV{3,DMPCH{7,XL{{COPY CHAIN POINTER{22202
{{MOV{9,(XL){8,WA{{MOVE TO NEXT ENTRY ON CHAIN{22204
{{BRN{6,DMP04{{{LOOP BACK{22205
*
*      HERE AFTER LOCATING THE PROPER INSERTION POINT
*
{DMP08{MOV{3,DMPCH{7,XL{{COPY CHAIN POINTER{22209
{{MOV{3,DMPSV{8,WA{{RESTORE HASH BUCKET POINTER{22210
{{MOV{8,WC{7,XR{{RESTORE VRBLK POINTER{22211
{{MOV{9,(XL){13,VRGET(XR){{LINK VRBLK TO REST OF CHAIN{22212
{{MOV{7,XR{9,(XL){{LINK VRBLK INTO CURRENT CHAIN LOC{22213
{{BRN{6,DMP01{{{LOOP BACK FOR NEXT VRBLK{22214
*
*      HERE AFTER PROCESSING ALL VRBLKS ON ONE CHAIN
*
{DMP09{BNE{8,WA{3,HSHTE{6,DMP00{LOOP BACK IF MORE BUCKETS TO GO{22218
*
*      LOOP TO GENERATE DUMP OF NATURAL VARIABLE VALUES
*
{DMP10{MOV{3,DMVCH{7,XR{{LOAD POINTER TO NEXT ENTRY ON CHAIN{22222
{{BZE{7,XR{6,DMP11{{JUMP IF END OF CHAIN{22223
{{MOV{9,(XR){3,DMVCH{{ELSE UPDATE CHAIN PTR TO NEXT ENTRY{22224
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{22225
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER (NAME BASE){22226
{{MOV{19,*VRVAL{8,WA{{SET OFFSET FOR VRBLK NAME{22227
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{22228
{{BRN{6,DMP10{{{LOOP BACK TILL ALL PRINTED{22229
*
*      PREPARE TO PRINT KEYWORDS
*
{DMP11{JSR{6,PRTNL{{{PRINT BLANK LINE{22233
{{JSR{6,PRTNL{{{AND ANOTHER{22234
{{MOV{21,=DMHDK{7,XR{{POINT TO KEYWORD HEADING{22235
{{JSR{6,PRTST{{{PRINT HEADING{22236
{{JSR{6,PRTNL{{{END LINE{22237
{{JSR{6,PRTNL{{{PRINT ONE BLANK LINE{22238
{{MOV{21,=VDMKW{7,XL{{POINT TO LIST OF KEYWORD SVBLK PTRS{22239
{{EJC{{{{{22240
*
*      DUMPR (CONTINUED)
*
*      LOOP TO DUMP KEYWORD VALUES
*
{DMP12{MOV{10,(XL)+{7,XR{{LOAD NEXT SVBLK PTR FROM TABLE{22246
{{BZE{7,XR{6,DMP13{{JUMP IF END OF LIST{22247
{{BEQ{7,XR{18,=NUM01{6,DMP12{&COMPARE IGNORED IF NOT IMPLEMENTED{22249
{{MOV{18,=CH$AM{8,WA{{LOAD AMPERSAND{22251
{{JSR{6,PRTCH{{{PRINT AMPERSAND{22252
{{JSR{6,PRTST{{{PRINT KEYWORD NAME{22253
{{MOV{13,SVLEN(XR){8,WA{{LOAD NAME LENGTH FROM SVBLK{22254
{{CTB{8,WA{2,SVCHS{{GET LENGTH OF NAME{22255
{{ADD{8,WA{7,XR{{POINT TO SVKNM FIELD{22256
{{MOV{9,(XR){3,DMPKN{{STORE IN DUMMY KVBLK{22257
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK-EQUAL-BLANK{22258
{{JSR{6,PRTST{{{PRINT IT{22259
{{MOV{7,XL{3,DMPSV{{SAVE TABLE POINTER{22260
{{MOV{20,=DMPKB{7,XL{{POINT TO DUMMY KVBLK{22261
{{MOV{22,=B$KVT{9,(XL){{BUILD TYPE WORD{22262
{{MOV{21,=TRBKV{13,KVVAR(XL){{BUILD PTR TO DUMMY TRACE BLOCK{22263
{{MOV{19,*KVVAR{8,WA{{SET ZERO OFFSET{22264
{{JSR{6,ACESS{{{GET KEYWORD VALUE{22265
{{PPM{{{{FAILURE IS IMPOSSIBLE{22266
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{22267
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{22268
{{MOV{3,DMPSV{7,XL{{RESTORE TABLE POINTER{22269
{{BRN{6,DMP12{{{LOOP BACK TILL ALL PRINTED{22270
*
*      HERE AFTER COMPLETING PARTIAL DUMP
*
{DMP13{BEQ{3,DMARG{18,=NUM01{6,DMP27{EXIT IF PARTIAL DUMP COMPLETE{22274
{{MOV{3,DNAMB{7,XR{{ELSE POINT TO FIRST DYNAMIC BLOCK{22275
*
*      LOOP THROUGH BLOCKS IN DYNAMIC STORAGE
*
{DMP14{BEQ{7,XR{3,DNAMP{6,DMP27{JUMP IF END OF USED REGION{22279
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF BLOCK{22280
{{BEQ{8,WA{22,=B$VCT{6,DMP16{JUMP IF VECTOR{22281
{{BEQ{8,WA{22,=B$ART{6,DMP17{JUMP IF ARRAY{22282
{{BEQ{8,WA{22,=B$PDT{6,DMP18{JUMP IF PROGRAM DEFINED{22283
{{BEQ{8,WA{22,=B$TBT{6,DMP19{JUMP IF TABLE{22284
*
*      MERGE HERE TO MOVE TO NEXT BLOCK
*
{DMP15{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{22292
{{ADD{8,WA{7,XR{{POINT PAST THIS BLOCK{22293
{{BRN{6,DMP14{{{LOOP BACK FOR NEXT BLOCK{22294
{{EJC{{{{{22295
*
*      DUMPR (CONTINUED)
*
*      HERE FOR VECTOR
*
{DMP16{MOV{19,*VCVLS{8,WB{{SET OFFSET TO FIRST VALUE{22301
{{BRN{6,DMP19{{{JUMP TO MERGE{22302
*
*      HERE FOR ARRAY
*
{DMP17{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO ARPRO FIELD{22306
{{ICA{8,WB{{{BUMP TO GET OFFSET TO VALUES{22307
{{BRN{6,DMP19{{{JUMP TO MERGE{22308
*
*      HERE FOR PROGRAM DEFINED
*
{DMP18{MOV{19,*PDFLD{8,WB{{POINT TO VALUES, MERGE{22312
*
*      HERE FOR TABLE (OTHERS MERGE)
*
{DMP19{BZE{13,IDVAL(XR){6,DMP15{{IGNORE BLOCK IF ZERO ID VALUE{22316
{{JSR{6,BLKLN{{{ELSE GET BLOCK LENGTH{22317
{{MOV{7,XR{7,XL{{COPY BLOCK POINTER{22318
{{MOV{8,WA{3,DMPSV{{SAVE LENGTH{22319
{{MOV{8,WB{8,WA{{COPY OFFSET TO FIRST VALUE{22320
{{JSR{6,PRTNL{{{PRINT BLANK LINE{22321
{{MOV{8,WA{3,DMPSA{{PRESERVE OFFSET{22322
{{JSR{6,PRTVL{{{PRINT BLOCK VALUE (FOR TITLE){22323
{{MOV{3,DMPSA{8,WA{{RECOVER OFFSET{22324
{{JSR{6,PRTNL{{{END PRINT LINE{22325
{{BEQ{9,(XR){22,=B$TBT{6,DMP22{JUMP IF TABLE{22326
{{DCA{8,WA{{{POINT BEFORE FIRST WORD{22327
*
*      LOOP TO PRINT CONTENTS OF ARRAY, VECTOR, OR PROGRAM DEF
*
{DMP20{MOV{7,XL{7,XR{{COPY BLOCK POINTER{22331
{{ICA{8,WA{{{BUMP OFFSET{22332
{{ADD{8,WA{7,XR{{POINT TO NEXT VALUE{22333
{{BEQ{8,WA{3,DMPSV{6,DMP14{EXIT IF END (XR PAST BLOCK){22334
{{SUB{19,*VRVAL{7,XR{{SUBTRACT OFFSET TO MERGE INTO LOOP{22335
*
*      LOOP TO FIND VALUE AND IGNORE NULLS
*
{DMP21{MOV{13,VRVAL(XR){7,XR{{LOAD NEXT VALUE{22339
{{BEQ{3,DMARG{18,=NUM03{6,DMP2B{SKIP NULL VALUE CHECK IF DUMP(3){22340
{{BEQ{7,XR{21,=NULLS{6,DMP20{LOOP BACK IF NULL VALUE{22341
{DMP2B{BEQ{9,(XR){22,=B$TRT{6,DMP21{LOOP BACK IF TRAPPED{22342
{{JSR{6,PRTNV{{{ELSE PRINT NAME = VALUE{22343
{{BRN{6,DMP20{{{LOOP BACK FOR NEXT FIELD{22344
{{EJC{{{{{22345
*
*      DUMPR (CONTINUED)
*
*      HERE TO DUMP A TABLE
*
{DMP22{MOV{19,*TBBUK{8,WC{{SET OFFSET TO FIRST BUCKET{22351
{{MOV{19,*TEVAL{8,WA{{SET NAME OFFSET FOR ALL TEBLKS{22352
*
*      LOOP THROUGH TABLE BUCKETS
*
{DMP23{MOV{7,XL{11,-(XS){{SAVE TBBLK POINTER{22356
{{ADD{8,WC{7,XL{{POINT TO NEXT BUCKET HEADER{22357
{{ICA{8,WC{{{BUMP BUCKET OFFSET{22358
{{SUB{19,*TENXT{7,XL{{SUBTRACT OFFSET TO MERGE INTO LOOP{22359
*
*      LOOP TO PROCESS TEBLKS ON ONE CHAIN
*
{DMP24{MOV{13,TENXT(XL){7,XL{{POINT TO NEXT TEBLK{22363
{{BEQ{7,XL{9,(XS){6,DMP26{JUMP IF END OF CHAIN{22364
{{MOV{7,XL{7,XR{{ELSE COPY TEBLK POINTER{22365
*
*      LOOP TO FIND VALUE AND IGNORE IF NULL
*
{DMP25{MOV{13,TEVAL(XR){7,XR{{LOAD NEXT VALUE{22369
{{BEQ{7,XR{21,=NULLS{6,DMP24{IGNORE IF NULL VALUE{22370
{{BEQ{9,(XR){22,=B$TRT{6,DMP25{LOOP BACK IF TRAPPED{22371
{{MOV{8,WC{3,DMPSV{{ELSE SAVE OFFSET POINTER{22372
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{22373
{{MOV{3,DMPSV{8,WC{{RELOAD OFFSET{22374
{{BRN{6,DMP24{{{LOOP BACK FOR NEXT TEBLK{22375
*
*      HERE TO MOVE TO NEXT HASH CHAIN
*
{DMP26{MOV{10,(XS)+{7,XL{{RESTORE TBBLK POINTER{22379
{{BNE{8,WC{13,TBLEN(XL){6,DMP23{LOOP BACK IF MORE BUCKETS TO GO{22380
{{MOV{7,XL{7,XR{{ELSE COPY TABLE POINTER{22381
{{ADD{8,WC{7,XR{{POINT TO FOLLOWING BLOCK{22382
{{BRN{6,DMP14{{{LOOP BACK TO PROCESS NEXT BLOCK{22383
*
*      HERE AFTER COMPLETING DUMP
*
{DMP27{JSR{6,PRTPG{{{EJECT PRINTER{22387
*
*      MERGE HERE IF NO DUMP GIVEN (DMARG=0)
*
{DMP28{EXI{{{{RETURN TO DUMP CALLER{22391
*
*      CALL SYSTEM CORE DUMP ROUTINE
*
{DMP29{JSR{6,SYSDM{{{CALL IT{22395
{{BRN{6,DMP28{{{RETURN{22396
{{ENP{{{{END PROCEDURE DUMPR{22432
{{EJC{{{{{22433
*
*      ERMSG -- PRINT ERROR CODE AND ERROR MESSAGE
*
*      KVERT                 ERROR CODE
*      JSR  ERMSG            CALL TO PRINT MESSAGE
*      (XR,XL,WA,WB,WC,IA)   DESTROYED
*
{ERMSG{PRC{25,E{1,0{{ENTRY POINT{22441
{{MOV{3,KVERT{8,WA{{LOAD ERROR CODE{22442
{{MOV{21,=ERMMS{7,XR{{POINT TO ERROR MESSAGE /ERROR/{22443
{{JSR{6,PRTST{{{PRINT IT{22444
{{JSR{6,ERTEX{{{GET ERROR MESSAGE TEXT{22445
{{ADD{18,=THSND{8,WA{{BUMP ERROR CODE FOR PRINT{22446
{{MTI{8,WA{{{FAIL CODE IN INT ACC{22447
{{MOV{3,PROFS{8,WB{{SAVE CURRENT BUFFER POSITION{22448
{{JSR{6,PRTIN{{{PRINT CODE (NOW HAVE ERROR1XXX){22449
{{MOV{3,PRBUF{7,XL{{POINT TO PRINT BUFFER{22450
{{PSC{7,XL{8,WB{{POINT TO THE 1{22451
{{MOV{18,=CH$BL{8,WA{{LOAD A BLANK{22452
{{SCH{8,WA{9,(XL){{STORE BLANK OVER 1 (ERROR XXX){22453
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{22454
{{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{22455
{{MOV{7,XR{8,WA{{KEEP ERROR TEXT{22456
{{MOV{21,=ERMNS{7,XR{{POINT TO / -- /{22457
{{JSR{6,PRTST{{{PRINT IT{22458
{{MOV{8,WA{7,XR{{GET ERROR TEXT AGAIN{22459
{{JSR{6,PRTST{{{PRINT ERROR MESSAGE TEXT{22460
{{JSR{6,PRTIS{{{PRINT LINE{22461
{{JSR{6,PRTIS{{{PRINT BLANK LINE{22462
{{EXI{{{{RETURN TO ERMSG CALLER{22463
{{ENP{{{{END PROCEDURE ERMSG{22464
{{EJC{{{{{22465
*
*      ERTEX -- GET ERROR MESSAGE TEXT
*
*      (WA)                  ERROR CODE
*      JSR  ERTEX            CALL TO GET ERROR TEXT
*      (XR)                  PTR TO ERROR TEXT IN DYNAMIC
*      (R$ETX)               COPY OF PTR TO ERROR TEXT
*      (XL,WC,IA)            DESTROYED
*
{ERTEX{PRC{25,E{1,0{{ENTRY POINT{22475
{{MOV{8,WA{3,ERTWA{{SAVE WA{22476
{{MOV{8,WB{3,ERTWB{{SAVE WB{22477
{{JSR{6,SYSEM{{{GET FAILURE MESSAGE TEXT{22478
{{MOV{7,XR{7,XL{{COPY POINTER TO IT{22479
{{MOV{13,SCLEN(XR){8,WA{{GET LENGTH OF STRING{22480
{{BZE{8,WA{6,ERT02{{JUMP IF NULL{22481
{{ZER{8,WB{{{OFFSET OF ZERO{22482
{{JSR{6,SBSTR{{{COPY INTO DYNAMIC STORE{22483
{{MOV{7,XR{3,R$ETX{{STORE FOR RELOCATION{22484
*
*      RETURN
*
{ERT01{MOV{3,ERTWB{8,WB{{RESTORE WB{22488
{{MOV{3,ERTWA{8,WA{{RESTORE WA{22489
{{EXI{{{{RETURN TO CALLER{22490
*
*      RETURN ERRTEXT CONTENTS INSTEAD OF NULL
*
{ERT02{MOV{3,R$ETX{7,XR{{GET ERRTEXT{22494
{{BRN{6,ERT01{{{RETURN{22495
{{ENP{{{{{22496
{{EJC{{{{{22497
*
*      EVALI -- EVALUATE INTEGER ARGUMENT
*
*      EVALI IS USED BY PATTERN PRIMITIVES LEN,TAB,RTAB,POS,RPOS
*      WHEN THEIR ARGUMENT IS AN EXPRESSION VALUE.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALI            CALL TO EVALUATE INTEGER
*      PPM  LOC              TRANSFER LOC FOR NON-INTEGER ARG
*      PPM  LOC              TRANSFER LOC FOR OUT OF RANGE ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH INTEGER ARGUMENT
*      (WC,XL,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS THE INTEGER ARGUMENT
*      IN PARM1 AND THE PROPER SUCCESSOR POINTER IN PTHEN.
*      THIS ALLOWS MERGING WITH THE NORMAL (INTEGER ARG) CASE.
*
{EVALI{PRC{25,R{1,4{{ENTRY POINT (RECURSIVE){22519
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{22520
{{PPM{6,EVLI1{{{JUMP ON FAILURE{22521
{{MOV{7,XL{11,-(XS){{STACK RESULT FOR GTSMI{22522
{{MOV{13,PTHEN(XR){7,XL{{LOAD SUCCESSOR POINTER{22523
{{MOV{7,XR{3,EVLIO{{SAVE ORIGINAL NODE POINTER{22524
{{MOV{8,WC{3,EVLIF{{ZERO IF SIMPLE ARGUMENT{22525
{{JSR{6,GTSMI{{{CONVERT ARG TO SMALL INTEGER{22526
{{PPM{6,EVLI2{{{JUMP IF NOT INTEGER{22527
{{PPM{6,EVLI3{{{JUMP IF OUT OF RANGE{22528
{{MOV{7,XR{3,EVLIV{{STORE RESULT IN SPECIAL DUMMY NODE{22529
{{MOV{20,=EVLIN{7,XR{{POINT TO DUMMY NODE WITH RESULT{22530
{{MOV{22,=P$LEN{9,(XR){{DUMMY PATTERN BLOCK PCODE{22531
{{MOV{7,XL{13,PTHEN(XR){{STORE SUCCESSOR POINTER{22532
{{EXI{1,4{{{TAKE SUCCESSFUL EXIT{22533
*
*      HERE IF EVALUATION FAILS
*
{EVLI1{EXI{1,3{{{TAKE FAILURE RETURN{22537
*
*      HERE IF ARGUMENT IS NOT INTEGER
*
{EVLI2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{22541
*
*      HERE IF ARGUMENT IS OUT OF RANGE
*
{EVLI3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{22545
{{ENP{{{{END PROCEDURE EVALI{22546
{{EJC{{{{{22547
*
*      EVALP -- EVALUATE EXPRESSION DURING PATTERN MATCH
*
*      EVALP IS USED TO EVALUATE AN EXPRESSION (BY VALUE) DURING
*      A PATTERN MATCH. THE EFFECT IS LIKE EVALX, BUT PATTERN
*      VARIABLES ARE STACKED AND RESTORED IF NECESSARY.
*
*      EVALP ALSO DIFFERS FROM EVALX IN THAT IF THE RESULT IS
*      AN EXPRESSION IT IS REEVALUATED. THIS OCCURS REPEATEDLY.
*
*      TO SUPPORT OPTIMIZATION OF POS AND RPOS, EVALP USES WC
*      TO SIGNAL THE CALLER FOR THE CASE OF A SIMPLE VRBLK
*      THAT IS NOT AN EXPRESSION AND IS NOT TRAPPED.  BECAUSE
*      THIS CASE CANNOT HAVE ANY SIDE EFFECTS, OPTIMIZATION IS
*      POSSIBLE.
*
*      (XR)                  NODE POINTER
*      (WB)                  PATTERN MATCH CURSOR
*      JSR  EVALP            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XL)                  RESULT
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WC)                  ZERO IF SIMPLE VRBLK, ELSE NON-ZERO
*      (XR,WB)               DESTROYED (FAILURE CASE ONLY)
*      (RA)                  DESTROYED
*
*      THE EXPRESSION POINTER IS STORED IN PARM1 OF THE NODE
*
*      CONTROL RETURNS TO FAILP ON FAILURE OF EVALUATION
*
{EVALP{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){22578
{{MOV{13,PARM1(XR){7,XL{{LOAD EXPRESSION POINTER{22579
{{BEQ{9,(XL){22,=B$EXL{6,EVLP1{JUMP IF EXBLK CASE{22580
*
*      HERE FOR CASE OF SEBLK
*
*      WE CAN GIVE A FAST RETURN IF THE VALUE OF THE VRBLK IS
*      NOT AN EXPRESSION AND IS NOT TRAPPED.
*
{{MOV{13,SEVAR(XL){7,XL{{LOAD VRBLK POINTER{22587
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE OF VRBLK{22588
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF VALUE{22589
{{BHI{8,WA{22,=B$T$${6,EVLP3{JUMP IF NOT SEBLK, TRBLK OR EXBLK{22590
*
*      HERE FOR EXBLK OR SEBLK WITH EXPR VALUE OR TRAPPED VALUE
*
{EVLP1{CHK{{{{CHECK FOR STACK SPACE{22594
{{MOV{7,XR{11,-(XS){{STACK NODE POINTER{22595
{{MOV{8,WB{11,-(XS){{STACK CURSOR{22596
{{MOV{3,R$PMS{11,-(XS){{STACK SUBJECT STRING POINTER{22597
{{MOV{3,PMSSL{11,-(XS){{STACK SUBJECT STRING LENGTH{22598
{{MOV{3,PMDFL{11,-(XS){{STACK DOT FLAG{22599
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE POINTER{22600
{{MOV{13,PARM1(XR){7,XR{{LOAD EXPRESSION POINTER{22601
{{EJC{{{{{22602
*
*      EVALP (CONTINUED)
*
*      LOOP BACK HERE TO REEVALUATE EXPRESSION RESULT
*
{EVLP2{ZER{8,WB{{{SET FLAG FOR BY VALUE{22608
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{22609
{{PPM{6,EVLP4{{{JUMP ON FAILURE{22610
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF VALUE{22611
{{BLO{8,WA{22,=B$E$${6,EVLP2{LOOP BACK TO REEVALUATE EXPRESSION{22612
*
*      HERE TO RESTORE PATTERN VALUES AFTER SUCCESSFUL EVAL
*
{{MOV{7,XR{7,XL{{COPY RESULT POINTER{22616
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{22617
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{22618
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{22619
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{22620
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{22621
{{MOV{10,(XS)+{7,XR{{RESTORE NODE POINTER{22622
{{MOV{7,XR{8,WC{{NON-ZERO FOR SIMPLE VRBLK{22623
{{EXI{{{{RETURN TO EVALP CALLER{22624
*
*      HERE TO RETURN AFTER SIMPLE VRBLK CASE
*
{EVLP3{ZER{8,WC{{{SIMPLE VRBLK, NO SIDE EFFECTS{22628
{{EXI{{{{RETURN TO EVALP CALLER{22629
*
*      HERE FOR FAILURE DURING EVALUATION
*
{EVLP4{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{22633
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{22634
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{22635
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{22636
{{ADD{19,*NUM02{7,XS{{REMOVE NODE PTR, CURSOR{22637
{{EXI{1,1{{{TAKE FAILURE EXIT{22638
{{ENP{{{{END PROCEDURE EVALP{22639
{{EJC{{{{{22640
*
*      EVALS -- EVALUATE STRING ARGUMENT
*
*      EVALS IS USED BY SPAN, ANY, NOTANY, BREAK, BREAKX WHEN
*      THEY ARE PASSED AN EXPRESSION ARGUMENT.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALS            CALL TO EVALUATE STRING
*      PPM  LOC              TRANSFER LOC FOR NON-STRING ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH PARMS SET
*      (XL,WC,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS A CHARACTER TABLE
*      POINTER IN PARM1 AND A BIT MASK IN PARM2. THE PROPER
*      SUCCESSOR IS STORED IN PTHEN OF THIS NODE. THUS IT IS
*      OK FOR MERGING WITH THE NORMAL (MULTI-CHAR STRING) CASE.
*
{EVALS{PRC{25,R{1,3{{ENTRY POINT (RECURSIVE){22662
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{22663
{{PPM{6,EVLS1{{{JUMP IF EVALUATION FAILS{22664
{{MOV{13,PTHEN(XR){11,-(XS){{SAVE SUCCESSOR POINTER{22665
{{MOV{8,WB{11,-(XS){{SAVE CURSOR{22666
{{MOV{7,XL{11,-(XS){{STACK RESULT PTR FOR PATST{22667
{{ZER{8,WB{{{DUMMY PCODE FOR ONE CHAR STRING{22668
{{ZER{8,WC{{{DUMMY PCODE FOR EXPRESSION ARG{22669
{{MOV{22,=P$BRK{7,XL{{APPROPRIATE PCODE FOR OUR USE{22670
{{JSR{6,PATST{{{CALL ROUTINE TO BUILD NODE{22671
{{PPM{6,EVLS2{{{JUMP IF NOT STRING{22672
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{22673
{{MOV{10,(XS)+{13,PTHEN(XR){{STORE SUCCESSOR POINTER{22674
{{EXI{1,3{{{TAKE SUCCESS RETURN{22675
*
*      HERE IF EVALUATION FAILS
*
{EVLS1{EXI{1,2{{{TAKE FAILURE RETURN{22679
*
*      HERE IF ARGUMENT IS NOT STRING
*
{EVLS2{ADD{19,*NUM02{7,XS{{POP SUCCESSOR AND CURSOR{22683
{{EXI{1,1{{{TAKE NON-STRING ERROR EXIT{22684
{{ENP{{{{END PROCEDURE EVALS{22685
{{EJC{{{{{22686
*
*      EVALX -- EVALUATE EXPRESSION
*
*      EVALX IS CALLED TO EVALUATE AN EXPRESSION
*
*      (XR)                  POINTER TO EXBLK OR SEBLK
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      JSR  EVALX            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XR)                  RESULT IF CALLED BY VALUE
*      (XL,WA)               RESULT NAME BASE,OFFSET IF BY NAME
*      (XR)                  DESTROYED (NAME CASE ONLY)
*      (XL,WA)               DESTROYED (VALUE CASE ONLY)
*      (WB,WC,RA)            DESTROYED
*
{EVALX{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{22702
{{BEQ{9,(XR){22,=B$EXL{6,EVLX2{JUMP IF EXBLK CASE{22703
*
*      HERE FOR SEBLK
*
{{MOV{13,SEVAR(XR){7,XL{{LOAD VRBLK POINTER (NAME BASE){22707
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{22708
{{BNZ{8,WB{6,EVLX1{{JUMP IF CALLED BY NAME{22709
{{JSR{6,ACESS{{{CALL ROUTINE TO ACCESS VALUE{22710
{{PPM{6,EVLX9{{{JUMP IF FAILURE ON ACCESS{22711
*
*      MERGE HERE TO EXIT FOR SEBLK CASE
*
{EVLX1{EXI{{{{RETURN TO EVALX CALLER{22715
{{EJC{{{{{22716
*
*      EVALX (CONTINUED)
*
*      HERE FOR FULL EXPRESSION (EXBLK) CASE
*
*      IF AN ERROR OCCURS IN THE EXPRESSION CODE AT EXECUTION
*      TIME, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*      THE FOLLOWING ENTRIES ARE MADE ON THE STACK BEFORE
*      GIVING CONTROL TO THE EXPRESSION CODE
*
*                            EVALX RETURN POINT
*                            SAVED VALUE OF R$COD
*                            CODE POINTER (-R$COD)
*                            SAVED VALUE OF FLPTR
*                            0 IF BY VALUE, 1 IF BY NAME
*      FLPTR --------------- *EXFLC, FAIL OFFSET IN EXBLK
*
{EVLX2{SCP{8,WC{{{GET CODE POINTER{22735
{{MOV{3,R$COD{8,WA{{LOAD CODE BLOCK POINTER{22736
{{SUB{8,WA{8,WC{{GET CODE POINTER AS OFFSET{22737
{{MOV{8,WA{11,-(XS){{STACK OLD CODE BLOCK POINTER{22738
{{MOV{8,WC{11,-(XS){{STACK RELATIVE CODE OFFSET{22739
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{22740
{{MOV{8,WB{11,-(XS){{STACK NAME/VALUE INDICATOR{22741
{{MOV{19,*EXFLC{11,-(XS){{STACK NEW FAIL OFFSET{22742
{{MOV{3,FLPTR{3,GTCEF{{KEEP IN CASE OF ERROR{22743
{{MOV{3,R$COD{3,R$GTC{{KEEP CODE BLOCK POINTER SIMILARLY{22744
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{22745
{{MOV{7,XR{3,R$COD{{SET NEW CODE BLOCK POINTER{22746
{{MOV{3,KVSTN{13,EXSTM(XR){{REMEMBER STMNT NUMBER{22747
{{ADD{19,*EXCOD{7,XR{{POINT TO FIRST CODE WORD{22748
{{LCP{7,XR{{{SET CODE POINTER{22749
{{BNE{3,STAGE{18,=STGXT{6,EVLX0{JUMP IF NOT EXECUTION TIME{22750
{{MOV{18,=STGEE{3,STAGE{{EVALUATING EXPRESSION{22751
*
*      HERE TO EXECUTE FIRST CODE WORD OF EXPRESSION
*
{EVLX0{ZER{7,XL{{{CLEAR GARBAGE XL{22755
{{LCW{7,XR{{{LOAD FIRST CODE WORD{22756
{{BRI{9,(XR){{{EXECUTE IT{22757
{{EJC{{{{{22758
*
*      EVALX (CONTINUED)
*
*      COME HERE IF SUCCESSFUL RETURN BY VALUE (SEE O$RVL)
*
{EVLX3{MOV{10,(XS)+{7,XR{{LOAD VALUE{22764
{{BZE{13,NUM01(XS){6,EVLX5{{JUMP IF CALLED BY VALUE{22765
{{ERB{1,249{26,Expression evaluated by name returned value{{{22766
*
*      HERE FOR EXPRESSION RETURNING BY NAME (SEE O$RNM)
*
{EVLX4{MOV{10,(XS)+{8,WA{{LOAD NAME OFFSET{22770
{{MOV{10,(XS)+{7,XL{{LOAD NAME BASE{22771
{{BNZ{13,NUM01(XS){6,EVLX5{{JUMP IF CALLED BY NAME{22772
{{JSR{6,ACESS{{{ELSE ACCESS VALUE FIRST{22773
{{PPM{6,EVLX6{{{JUMP IF FAILURE DURING ACCESS{22774
*
*      HERE AFTER LOADING CORRECT RESULT INTO XR OR XL,WA
*
{EVLX5{ZER{8,WB{{{NOTE SUCCESSFUL{22778
{{BRN{6,EVLX7{{{MERGE{22779
*
*      HERE FOR FAILURE IN EXPRESSION EVALUATION (SEE O$FEX)
*
{EVLX6{MNZ{8,WB{{{NOTE UNSUCCESSFUL{22783
*
*      RESTORE ENVIRONMENT
*
{EVLX7{BNE{3,STAGE{18,=STGEE{6,EVLX8{SKIP IF WAS NOT PREVIOUSLY XT{22787
{{MOV{18,=STGXT{3,STAGE{{EXECUTE TIME{22788
*
*      MERGE WITH STAGE SET UP
*
{EVLX8{ADD{19,*NUM02{7,XS{{POP NAME/VALUE INDICATOR, *EXFAL{22792
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{22793
{{MOV{10,(XS)+{8,WC{{LOAD CODE OFFSET{22794
{{ADD{9,(XS){8,WC{{MAKE CODE POINTER ABSOLUTE{22795
{{MOV{10,(XS)+{3,R$COD{{RESTORE OLD CODE BLOCK POINTER{22796
{{LCP{8,WC{{{RESTORE OLD CODE POINTER{22797
{{BZE{8,WB{6,EVLX1{{JUMP FOR SUCCESSFUL RETURN{22798
*
*      MERGE HERE FOR FAILURE IN SEBLK CASE
*
{EVLX9{EXI{1,1{{{TAKE FAILURE EXIT{22802
{{ENP{{{{END OF PROCEDURE EVALX{22803
{{EJC{{{{{22804
*
*      EXBLD -- BUILD EXBLK
*
*      EXBLD IS USED TO BUILD AN EXPRESSION BLOCK FROM THE
*      CODE COMPILED MOST RECENTLY IN THE CURRENT CCBLK.
*
*      (XL)                  OFFSET IN CCBLK TO START OF CODE
*      (WB)                  INTEGER IN RANGE 0 LE N LE MXLEN
*      JSR  EXBLD            CALL TO BUILD EXBLK
*      (XR)                  PTR TO CONSTRUCTED EXBLK
*      (WA,WB,XL)            DESTROYED
*
{EXBLD{PRC{25,E{1,0{{ENTRY POINT{22817
{{MOV{7,XL{8,WA{{COPY OFFSET TO START OF CODE{22818
{{SUB{19,*EXCOD{8,WA{{CALC REDUCTION IN OFFSET IN EXBLK{22819
{{MOV{8,WA{11,-(XS){{STACK FOR LATER{22820
{{MOV{3,CWCOF{8,WA{{LOAD FINAL OFFSET{22821
{{SUB{7,XL{8,WA{{COMPUTE LENGTH OF CODE{22822
{{ADD{19,*EXSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{22823
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EXBLK{22824
{{MOV{7,XR{11,-(XS){{SAVE POINTER TO EXBLK{22825
{{MOV{22,=B$EXL{13,EXTYP(XR){{STORE TYPE WORD{22826
{{ZER{13,EXSTM(XR){{{ZEROISE STMNT NUMBER FIELD{22827
{{MOV{3,CMPLN{13,EXSLN(XR){{SET LINE NUMBER FIELD{22829
{{MOV{8,WA{13,EXLEN(XR){{STORE LENGTH{22831
{{MOV{21,=OFEX${13,EXFLC(XR){{STORE FAILURE WORD{22832
{{ADD{19,*EXSI${7,XR{{SET XR FOR MVW{22833
{{MOV{7,XL{3,CWCOF{{RESET OFFSET TO START OF CODE{22834
{{ADD{3,R$CCB{7,XL{{POINT TO START OF CODE{22835
{{SUB{19,*EXSI${8,WA{{LENGTH OF CODE TO MOVE{22836
{{MOV{8,WA{11,-(XS){{STACK LENGTH OF CODE{22837
{{MVW{{{{MOVE CODE TO EXBLK{22838
{{MOV{10,(XS)+{8,WA{{GET LENGTH OF CODE{22839
{{BTW{8,WA{{{CONVERT BYTE COUNT TO WORD COUNT{22840
{{LCT{8,WA{8,WA{{PREPARE COUNTER FOR LOOP{22841
{{MOV{9,(XS){7,XL{{COPY EXBLK PTR, DONT UNSTACK{22842
{{ADD{19,*EXCOD{7,XL{{POINT TO CODE ITSELF{22843
{{MOV{13,NUM01(XS){8,WB{{GET REDUCTION IN OFFSET{22844
*
*      THIS LOOP SEARCHES FOR NEGATION AND SELECTION CODE SO
*      THAT THE OFFSETS COMPUTED WHILST CODE WAS IN CODE BLOCK
*      CAN BE TRANSFORMED TO REDUCED VALUES APPLICABLE IN AN
*      EXBLK.
*
{EXBL1{MOV{10,(XL)+{7,XR{{GET NEXT CODE WORD{22851
{{BEQ{7,XR{21,=OSLA${6,EXBL3{JUMP IF SELECTION FOUND{22852
{{BEQ{7,XR{21,=ONTA${6,EXBL3{JUMP IF NEGATION FOUND{22853
{{BCT{8,WA{6,EXBL1{{LOOP TO END OF CODE{22854
*
*      NO SELECTION FOUND OR MERGE TO EXIT ON TERMINATION
*
{EXBL2{MOV{10,(XS)+{7,XR{{POP EXBLK PTR INTO XR{22858
{{MOV{10,(XS)+{7,XL{{POP REDUCTION CONSTANT{22859
{{EXI{{{{RETURN TO CALLER{22860
{{EJC{{{{{22861
*
*      EXBLD (CONTINUED)
*
*      SELECTION OR NEGATION FOUND
*      REDUCE THE OFFSETS AS NEEDED. OFFSETS OCCUR IN WORDS
*      FOLLOWING CODE WORDS -
*           =ONTA$, =OSLA$, =OSLB$, =OSLC$
*
{EXBL3{SUB{8,WB{10,(XL)+{{ADJUST OFFSET{22870
{{BCT{8,WA{6,EXBL4{{DECREMENT COUNT{22871
*
{EXBL4{BCT{8,WA{6,EXBL5{{DECREMENT COUNT{22873
*
*      CONTINUE SEARCH FOR MORE OFFSETS
*
{EXBL5{MOV{10,(XL)+{7,XR{{GET NEXT CODE WORD{22877
{{BEQ{7,XR{21,=OSLA${6,EXBL3{JUMP IF OFFSET FOUND{22878
{{BEQ{7,XR{21,=OSLB${6,EXBL3{JUMP IF OFFSET FOUND{22879
{{BEQ{7,XR{21,=OSLC${6,EXBL3{JUMP IF OFFSET FOUND{22880
{{BEQ{7,XR{21,=ONTA${6,EXBL3{JUMP IF OFFSET FOUND{22881
{{BCT{8,WA{6,EXBL5{{LOOP{22882
{{BRN{6,EXBL2{{{MERGE TO RETURN{22883
{{ENP{{{{END PROCEDURE EXBLD{22884
{{EJC{{{{{22885
*
*      EXPAN -- ANALYZE EXPRESSION
*
*      THE EXPRESSION ANALYZER (EXPAN) PROCEDURE IS USED TO SCAN
*      AN EXPRESSION AND CONVERT IT INTO A TREE REPRESENTATION.
*      SEE THE DESCRIPTION OF CMBLK IN THE STRUCTURES SECTION
*      FOR DETAILED FORMAT OF TREE BLOCKS.
*
*      THE ANALYZER USES A SIMPLE PRECEDENCE SCHEME IN WHICH
*      OPERANDS AND OPERATORS ARE PLACED ON A SINGLE STACK
*      AND CONDENSATIONS ARE MADE WHEN LOW PRECEDENCE OPERATORS
*      ARE STACKED AFTER A HIGHER PRECEDENCE OPERATOR. A GLOBAL
*      VARIABLE (IN WB) KEEPS TRACK OF THE LEVEL AS FOLLOWS.
*
*      0    SCANNING OUTER LEVEL OF STATEMENT OR EXPRESSION
*      1    SCANNING OUTER LEVEL OF NORMAL GOTO
*      2    SCANNING OUTER LEVEL OF DIRECT GOTO
*      3    SCANNING INSIDE ARRAY BRACKETS
*      4    SCANNING INSIDE GROUPING PARENTHESES
*      5    SCANNING INSIDE FUNCTION PARENTHESES
*
*      THIS VARIABLE IS SAVED ON THE STACK ON ENCOUNTERING A
*      GROUPING AND RESTORED AT THE END OF THE GROUPING.
*
*      ANOTHER GLOBAL VARIABLE (IN WC) COUNTS THE NUMBER OF
*      ITEMS AT ONE GROUPING LEVEL AND IS INCREMENTED FOR EACH
*      COMMA ENCOUNTERED. IT IS STACKED WITH THE LEVEL INDICATOR
*
*      THE SCAN IS CONTROLLED BY A THREE STATE FINITE MACHINE.
*      A GLOBAL VARIABLE STORED IN WA IS THE CURRENT STATE.
*
*      WA=0                  NOTHING SCANNED AT THIS LEVEL
*      WA=1                  OPERAND EXPECTED
*      WA=2                  OPERATOR EXPECTED
*
*      (WB)                  CALL TYPE (SEE BELOW)
*      JSR  EXPAN            CALL TO ANALYZE EXPRESSION
*      (XR)                  POINTER TO RESULTING TREE
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE ENTRY VALUE OF WB INDICATES THE CALL TYPE AS FOLLOWS.
*
*      0    SCANNING EITHER THE MAIN BODY OF A STATEMENT OR THE
*           TEXT OF AN EXPRESSION (FROM EVAL CALL). VALID
*           TERMINATORS ARE COLON, SEMICOLON. THE RESCAN FLAG IS
*           SET TO RETURN THE TERMINATOR ON THE NEXT SCANE CALL.
*
*      1    SCANNING A NORMAL GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT PAREN.
*
*      2    SCANNING A DIRECT GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT BRACKET.
{{EJC{{{{{22938
*
*      EXPAN (CONTINUED)
*
*      ENTRY POINT
*
{EXPAN{PRC{25,E{1,0{{ENTRY POINT{22944
{{ZER{11,-(XS){{{SET TOP OF STACK INDICATOR{22945
{{ZER{8,WA{{{SET INITIAL STATE TO ZERO{22946
{{ZER{8,WC{{{ZERO COUNTER VALUE{22947
*
*      LOOP HERE FOR SUCCESSIVE ENTRIES
*
{EXP01{JSR{6,SCANE{{{SCAN NEXT ELEMENT{22951
{{ADD{8,WA{7,XL{{ADD STATE TO SYNTAX CODE{22952
{{BSW{7,XL{2,T$NES{{SWITCH ON ELEMENT TYPE/STATE{22953
{{IFF{2,T$UO0{6,EXP27{{UNOP, S=0{22990
{{IFF{2,T$UO1{6,EXP27{{UNOP, S=1{22990
{{IFF{2,T$UO2{6,EXP04{{UNOP, S=2{22990
{{IFF{2,T$LP0{6,EXP06{{LEFT PAREN, S=0{22990
{{IFF{2,T$LP1{6,EXP06{{LEFT PAREN, S=1{22990
{{IFF{2,T$LP2{6,EXP04{{LEFT PAREN, S=2{22990
{{IFF{2,T$LB0{6,EXP08{{LEFT BRKT, S=0{22990
{{IFF{2,T$LB1{6,EXP08{{LEFT BRKT, S=1{22990
{{IFF{2,T$LB2{6,EXP09{{LEFT BRKT, S=2{22990
{{IFF{2,T$CM0{6,EXP02{{COMMA, S=0{22990
{{IFF{2,T$CM1{6,EXP05{{COMMA, S=1{22990
{{IFF{2,T$CM2{6,EXP11{{COMMA, S=2{22990
{{IFF{2,T$FN0{6,EXP10{{FUNCTION, S=0{22990
{{IFF{2,T$FN1{6,EXP10{{FUNCTION, S=1{22990
{{IFF{2,T$FN2{6,EXP04{{FUNCTION, S=2{22990
{{IFF{2,T$VA0{6,EXP03{{VARIABLE, S=0{22990
{{IFF{2,T$VA1{6,EXP03{{VARIABLE, STATE ONE{22990
{{IFF{2,T$VA2{6,EXP04{{VARIABLE, S=2{22990
{{IFF{2,T$CO0{6,EXP03{{CONSTANT, S=0{22990
{{IFF{2,T$CO1{6,EXP03{{CONSTANT, S=1{22990
{{IFF{2,T$CO2{6,EXP04{{CONSTANT, S=2{22990
{{IFF{2,T$BO0{6,EXP05{{BINOP, S=0{22990
{{IFF{2,T$BO1{6,EXP05{{BINOP, S=1{22990
{{IFF{2,T$BO2{6,EXP26{{BINOP, S=2{22990
{{IFF{2,T$RP0{6,EXP02{{RIGHT PAREN, S=0{22990
{{IFF{2,T$RP1{6,EXP05{{RIGHT PAREN, S=1{22990
{{IFF{2,T$RP2{6,EXP12{{RIGHT PAREN, S=2{22990
{{IFF{2,T$RB0{6,EXP02{{RIGHT BRKT, S=0{22990
{{IFF{2,T$RB1{6,EXP05{{RIGHT BRKT, S=1{22990
{{IFF{2,T$RB2{6,EXP18{{RIGHT BRKT, S=2{22990
{{IFF{2,T$CL0{6,EXP02{{COLON, S=0{22990
{{IFF{2,T$CL1{6,EXP05{{COLON, S=1{22990
{{IFF{2,T$CL2{6,EXP19{{COLON, S=2{22990
{{IFF{2,T$SM0{6,EXP02{{SEMICOLON, S=0{22990
{{IFF{2,T$SM1{6,EXP05{{SEMICOLON, S=1{22990
{{IFF{2,T$SM2{6,EXP19{{SEMICOLON, S=2{22990
{{ESW{{{{END SWITCH ON ELEMENT TYPE/STATE{22990
{{EJC{{{{{22991
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RBR,RPR,COL,SMC,CMA IN STATE 0
*
*      SET TO RESCAN THE TERMINATOR ENCOUNTERED AND CREATE
*      A NULL CONSTANT (CASE OF OMITTED NULL)
*
{EXP02{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{23000
{{MOV{21,=NULLS{7,XR{{POINT TO NULL, MERGE{23001
*
*      HERE FOR VAR OR CON IN STATES 0,1
*
*      STACK THE VARIABLE/CONSTANT AND SET STATE=2
*
{EXP03{MOV{7,XR{11,-(XS){{STACK POINTER TO OPERAND{23007
{{MOV{18,=NUM02{8,WA{{SET STATE 2{23008
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{23009
*
*      HERE FOR VAR,CON,LPR,FNC,UOP IN STATE 2
*
*      WE RESCAN THE ELEMENT AND CREATE A CONCATENATION OPERATOR
*      THIS IS THE CASE OF THE BLANK CONCATENATION OPERATOR.
*
{EXP04{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{23016
{{MOV{21,=OPDVC{7,XR{{POINT TO CONCAT OPERATOR DV{23017
{{BZE{8,WB{6,EXP4A{{OK IF AT TOP LEVEL{23018
{{MOV{21,=OPDVP{7,XR{{ELSE POINT TO UNMISTAKABLE CONCAT.{23019
*
*      MERGE HERE WHEN XR SET UP WITH PROPER CONCATENATION DVBLK
*
{EXP4A{BNZ{3,SCNBL{6,EXP26{{MERGE BOP IF BLANKS, ELSE ERROR{23023
*      DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{{ERB{1,220{26,Syntax error: Missing operator{{{23025
*
*      HERE FOR CMA,RPR,RBR,COL,SMC,BOP(S=1) BOP(S=0)
*
*      THIS IS AN ERRONOUS CONTRUCTION
*
*EXP05 DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{EXP05{ERB{1,221{26,Syntax error: Missing operand{{{23033
*
*      HERE FOR LPR (S=0,1)
*
{EXP06{MOV{18,=NUM04{7,XL{{SET NEW LEVEL INDICATOR{23037
{{ZER{7,XR{{{SET ZERO VALUE FOR CMOPN{23038
{{EJC{{{{{23039
*
*      EXPAN (CONTINUED)
*
*      MERGE HERE TO STORE OLD LEVEL ON STACK AND START NEW ONE
*
{EXP07{MOV{7,XR{11,-(XS){{STACK CMOPN VALUE{23045
{{MOV{8,WC{11,-(XS){{STACK OLD COUNTER{23046
{{MOV{8,WB{11,-(XS){{STACK OLD LEVEL INDICATOR{23047
{{CHK{{{{CHECK FOR STACK OVERFLOW{23048
{{ZER{8,WA{{{SET NEW STATE TO ZERO{23049
{{MOV{7,XL{8,WB{{SET NEW LEVEL INDICATOR{23050
{{MOV{18,=NUM01{8,WC{{INITIALIZE NEW COUNTER{23051
{{BRN{6,EXP01{{{JUMP TO SCAN NEXT ELEMENT{23052
*
*      HERE FOR LBR (S=0,1)
*
*      THIS IS AN ILLEGAL USE OF LEFT BRACKET
*
{EXP08{ERB{1,222{26,Syntax error: Invalid use of left bracket{{{23058
*
*      HERE FOR LBR (S=2)
*
*      SET NEW LEVEL AND START TO SCAN SUBSCRIPTS
*
{EXP09{MOV{10,(XS)+{7,XR{{LOAD ARRAY PTR FOR CMOPN{23064
{{MOV{18,=NUM03{7,XL{{SET NEW LEVEL INDICATOR{23065
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{23066
*
*      HERE FOR FNC (S=0,1)
*
*      STACK OLD LEVEL AND START TO SCAN ARGUMENTS
*
{EXP10{MOV{18,=NUM05{7,XL{{SET NEW LEV INDIC (XR=VRBLK=CMOPN){23072
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{23073
*
*      HERE FOR CMA (S=2)
*
*      INCREMENT ARGUMENT COUNT AND CONTINUE
*
{EXP11{ICV{8,WC{{{INCREMENT COUNTER{23079
{{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23080
{{ZER{11,-(XS){{{SET NEW LEVEL FOR PARAMETER{23081
{{ZER{8,WA{{{SET NEW STATE{23082
{{BGT{8,WB{18,=NUM02{6,EXP01{LOOP BACK UNLESS OUTER LEVEL{23083
{{ERB{1,223{26,Syntax error: Invalid use of comma{{{23084
{{EJC{{{{{23085
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RPR (S=2)
*
*      AT OUTER LEVEL IN A NORMAL GOTO THIS IS A TERMINATOR
*      OTHERWISE IT MUST TERMINATE A FUNCTION OR GROUPING
*
{EXP12{BEQ{8,WB{18,=NUM01{6,EXP20{END OF NORMAL GOTO{23094
{{BEQ{8,WB{18,=NUM05{6,EXP13{END OF FUNCTION ARGUMENTS{23095
{{BEQ{8,WB{18,=NUM04{6,EXP14{END OF GROUPING / SELECTION{23096
{{ERB{1,224{26,Syntax error: Unbalanced right parenthesis{{{23097
*
*      HERE AT END OF FUNCTION ARGUMENTS
*
{EXP13{MOV{18,=C$FNC{7,XL{{SET CMTYP VALUE FOR FUNCTION{23101
{{BRN{6,EXP15{{{JUMP TO BUILD CMBLK{23102
*
*      HERE FOR END OF GROUPING
*
{EXP14{BEQ{8,WC{18,=NUM01{6,EXP17{JUMP IF END OF GROUPING{23106
{{MOV{18,=C$SEL{7,XL{{ELSE SET CMTYP FOR SELECTION{23107
*
*      MERGE HERE TO BUILD CMBLK FOR LEVEL JUST SCANNED AND
*      TO POP UP TO THE PREVIOUS SCAN LEVEL BEFORE CONTINUING.
*
{EXP15{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23112
{{MOV{8,WC{8,WA{{COPY COUNT{23113
{{ADD{18,=CMVLS{8,WA{{ADD FOR STANDARD FIELDS AT START{23114
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{23115
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23116
{{MOV{22,=B$CMT{9,(XR){{STORE TYPE CODE FOR CMBLK{23117
{{MOV{7,XL{13,CMTYP(XR){{STORE CMBLK NODE TYPE INDICATOR{23118
{{MOV{8,WA{13,CMLEN(XR){{STORE LENGTH{23119
{{ADD{8,WA{7,XR{{POINT PAST END OF BLOCK{23120
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{23121
*
*      LOOP TO MOVE REMAINING WORDS TO CMBLK
*
{EXP16{MOV{10,(XS)+{11,-(XR){{MOVE ONE OPERAND PTR FROM STACK{23125
{{MOV{10,(XS)+{8,WB{{POP TO OLD LEVEL INDICATOR{23126
{{BCT{8,WC{6,EXP16{{LOOP TILL ALL MOVED{23127
{{EJC{{{{{23128
*
*      EXPAN (CONTINUED)
*
*      COMPLETE CMBLK AND STACK POINTER TO IT ON STACK
*
{{SUB{19,*CMVLS{7,XR{{POINT BACK TO START OF BLOCK{23134
{{MOV{10,(XS)+{8,WC{{RESTORE OLD COUNTER{23135
{{MOV{9,(XS){13,CMOPN(XR){{STORE OPERAND PTR IN CMBLK{23136
{{MOV{7,XR{9,(XS){{STACK CMBLK POINTER{23137
{{MOV{18,=NUM02{8,WA{{SET NEW STATE{23138
{{BRN{6,EXP01{{{BACK FOR NEXT ELEMENT{23139
*
*      HERE AT END OF A PARENTHESIZED EXPRESSION
*
{EXP17{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23143
{{MOV{10,(XS)+{7,XR{{RESTORE XR{23144
{{MOV{10,(XS)+{8,WB{{RESTORE OUTER LEVEL{23145
{{MOV{10,(XS)+{8,WC{{RESTORE OUTER COUNT{23146
{{MOV{7,XR{9,(XS){{STORE OPND OVER UNUSED CMOPN VAL{23147
{{MOV{18,=NUM02{8,WA{{SET NEW STATE{23148
{{BRN{6,EXP01{{{BACK FOR NEXT ELE8ENT{23149
*
*      HERE FOR RBR (S=2)
*
*      AT OUTER LEVEL IN A DIRECT GOTO, THIS IS A TERMINATOR.
*      OTHERWISE IT MUST TERMINATE A SUBSCRIPT LIST.
*
{EXP18{MOV{18,=C$ARR{7,XL{{SET CMTYP FOR ARRAY REFERENCE{23156
{{BEQ{8,WB{18,=NUM03{6,EXP15{JUMP TO BUILD CMBLK IF END ARRAYREF{23157
{{BEQ{8,WB{18,=NUM02{6,EXP20{JUMP IF END OF DIRECT GOTO{23158
{{ERB{1,225{26,Syntax error: Unbalanced right bracket{{{23159
{{EJC{{{{{23160
*
*      EXPAN (CONTINUED)
*
*      HERE FOR COL,SMC (S=2)
*
*      ERROR UNLESS TERMINATING STATEMENT BODY AT OUTER LEVEL
*
{EXP19{MNZ{3,SCNRS{{{RESCAN TERMINATOR{23168
{{MOV{8,WB{7,XL{{COPY LEVEL INDICATOR{23169
{{BSW{7,XL{1,6{{SWITCH ON LEVEL INDICATOR{23170
{{IFF{1,0{6,EXP20{{NORMAL OUTER LEVEL{23177
{{IFF{1,1{6,EXP22{{FAIL IF NORMAL GOTO{23177
{{IFF{1,2{6,EXP23{{FAIL IF DIRECT GOTO{23177
{{IFF{1,3{6,EXP24{{FAIL ARRAY BRACKETS{23177
{{IFF{1,4{6,EXP21{{FAIL IF IN GROUPING{23177
{{IFF{1,5{6,EXP21{{FAIL FUNCTION ARGS{23177
{{ESW{{{{END SWITCH ON LEVEL{23177
*
*      HERE AT NORMAL END OF EXPRESSION
*
{EXP20{JSR{6,EXPDM{{{DUMP REMAINING OPERATORS{23181
{{MOV{10,(XS)+{7,XR{{LOAD TREE POINTER{23182
{{ICA{7,XS{{{POP OFF BOTTOM OF STACK MARKER{23183
{{EXI{{{{RETURN TO EXPAN CALLER{23184
*
*      MISSING RIGHT PAREN
*
{EXP21{ERB{1,226{26,Syntax error: Missing right paren{{{23188
*
*      MISSING RIGHT PAREN IN GOTO FIELD
*
{EXP22{ERB{1,227{26,Syntax error: Right paren missing from goto{{{23192
*
*      MISSING BRACKET IN GOTO
*
{EXP23{ERB{1,228{26,Syntax error: Right bracket missing from goto{{{23196
*
*      MISSING ARRAY BRACKET
*
{EXP24{ERB{1,229{26,Syntax error: Missing right array bracket{{{23200
{{EJC{{{{{23201
*
*      EXPAN (CONTINUED)
*
*      LOOP HERE WHEN AN OPERATOR CAUSES AN OPERATOR DUMP
*
{EXP25{MOV{7,XR{3,EXPSV{{{23207
{{JSR{6,EXPOP{{{POP ONE OPERATOR{23208
{{MOV{3,EXPSV{7,XR{{RESTORE OP DV POINTER AND MERGE{23209
*
*      HERE FOR BOP (S=2)
*
*      REMOVE OPERATORS (CONDENSE) FROM STACK UNTIL NO MORE
*      LEFT AT THIS LEVEL OR TOP ONE HAS LOWER PRECEDENCE.
*      LOOP HERE TILL THIS CONDITION IS MET.
*
{EXP26{MOV{13,NUM01(XS){7,XL{{LOAD OPERATOR DVPTR FROM STACK{23217
{{BLE{7,XL{18,=NUM05{6,EXP27{JUMP IF BOTTOM OF STACK LEVEL{23218
{{BLT{13,DVRPR(XR){13,DVLPR(XL){6,EXP25{ELSE POP IF NEW PREC IS LO{23219
*
*      HERE FOR UOP (S=0,1)
*
*      BINARY OPERATOR MERGES AFTER PRECEDENCE CHECK
*
*      THE OPERATOR DV IS STORED ON THE STACK AND THE SCAN
*      CONTINUES AFTER SETTING THE SCAN STATE TO ONE.
*
{EXP27{MOV{7,XR{11,-(XS){{STACK OPERATOR DVPTR ON STACK{23228
{{CHK{{{{CHECK FOR STACK OVERFLOW{23229
{{MOV{18,=NUM01{8,WA{{SET NEW STATE{23230
{{BNE{7,XR{21,=OPDVS{6,EXP01{BACK FOR NEXT ELEMENT UNLESS ={23231
*
*      HERE FOR SPECIAL CASE OF BINARY =. THE SYNTAX ALLOWS A
*      NULL RIGHT ARGUMENT FOR THIS OPERATOR TO BE LEFT
*      OUT. ACCORDINGLY WE RESET TO STATE ZERO TO GET PROPER
*      ACTION ON A TERMINATOR (SUPPLY A NULL CONSTANT).
*
{{ZER{8,WA{{{SET STATE ZERO{23238
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{23239
{{ENP{{{{END PROCEDURE EXPAN{23240
{{EJC{{{{{23241
*
*      EXPAP -- TEST FOR PATTERN MATCH TREE
*
*      EXPAP IS PASSED AN EXPRESSION TREE TO DETERMINE IF IT
*      IS A PATTERN MATCH. THE FOLLOWING ARE RECOGIZED AS
*      MATCHES IN THE CONTEXT OF THIS CALL.
*
*      1)   AN EXPLICIT USE OF BINARY QUESTION MARK
*      2)   A CONCATENATION
*      3)   AN ALTERNATION WHOSE LEFT OPERAND IS A CONCATENATION
*
*      (XR)                  PTR TO EXPAN TREE
*      JSR  EXPAP            CALL TO TEST FOR PATTERN MATCH
*      PPM  LOC              TRANSFER LOC IF NOT A PATTERN MATCH
*      (WA)                  DESTROYED
*      (XR)                  UNCHANGED (IF NOT MATCH)
*      (XR)                  PTR TO BINARY OPERATOR BLK IF MATCH
*
{EXPAP{PRC{25,E{1,1{{ENTRY POINT{23260
{{MOV{7,XL{11,-(XS){{SAVE XL{23261
{{BNE{9,(XR){22,=B$CMT{6,EXPP2{NO MATCH IF NOT COMPLEX{23262
{{MOV{13,CMTYP(XR){8,WA{{ELSE LOAD TYPE CODE{23263
{{BEQ{8,WA{18,=C$CNC{6,EXPP1{CONCATENATION IS A MATCH{23264
{{BEQ{8,WA{18,=C$PMT{6,EXPP1{BINARY QUESTION MARK IS A MATCH{23265
{{BNE{8,WA{18,=C$ALT{6,EXPP2{ELSE NOT MATCH UNLESS ALTERNATION{23266
*
*      HERE FOR ALTERNATION. CHANGE (A B) / C TO A QM (B / C)
*
{{MOV{13,CMLOP(XR){7,XL{{LOAD LEFT OPERAND POINTER{23270
{{BNE{9,(XL){22,=B$CMT{6,EXPP2{NOT MATCH IF LEFT OPND NOT COMPLEX{23271
{{BNE{13,CMTYP(XL){18,=C$CNC{6,EXPP2{NOT MATCH IF LEFT OP NOT CONC{23272
{{MOV{13,CMROP(XL){13,CMLOP(XR){{XR POINTS TO (B / C){23273
{{MOV{7,XR{13,CMROP(XL){{SET XL OPNDS TO A, (B / C){23274
{{MOV{7,XL{7,XR{{POINT TO THIS ALTERED NODE{23275
*
*      EXIT HERE FOR PATTERN MATCH
*
{EXPP1{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23279
{{EXI{{{{GIVE PATTERN MATCH RETURN{23280
*
*      EXIT HERE IF NOT PATTERN MATCH
*
{EXPP2{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23284
{{EXI{1,1{{{GIVE NON-MATCH RETURN{23285
{{ENP{{{{END PROCEDURE EXPAP{23286
{{EJC{{{{{23287
*
*      EXPDM -- DUMP OPERATORS AT CURRENT LEVEL (FOR EXPAN)
*
*      EXPDM USES EXPOP TO CONDENSE ALL OPERATORS AT THIS SYNTAX
*      LEVEL. THE STACK BOTTOM IS RECOGNIZED FROM THE LEVEL
*      VALUE WHICH IS SAVED ON THE TOP OF THE STACK.
*
*      JSR  EXPDM            CALL TO DUMP OPERATORS
*      (XS)                  POPPED AS REQUIRED
*      (XR,WA)               DESTROYED
*
{EXPDM{PRC{25,N{1,0{{ENTRY POINT{23299
{{MOV{7,XL{3,R$EXS{{SAVE XL VALUE{23300
*
*      LOOP TO DUMP OPERATORS
*
{EXDM1{BLE{13,NUM01(XS){18,=NUM05{6,EXDM2{JUMP IF STACK BOTTOM (SAVED LEVEL{23304
{{JSR{6,EXPOP{{{ELSE POP ONE OPERATOR{23305
{{BRN{6,EXDM1{{{AND LOOP BACK{23306
*
*      HERE AFTER POPPING ALL OPERATORS
*
{EXDM2{MOV{3,R$EXS{7,XL{{RESTORE XL{23310
{{ZER{3,R$EXS{{{RELEASE SAVE LOCATION{23311
{{EXI{{{{RETURN TO EXPDM CALLER{23312
{{ENP{{{{END PROCEDURE EXPDM{23313
{{EJC{{{{{23314
*
*      EXPOP-- POP OPERATOR (FOR EXPAN)
*
*      EXPOP IS USED BY THE EXPAN ROUTINE TO CONDENSE ONE
*      OPERATOR FROM THE TOP OF THE SYNTAX STACK. AN APPROPRIATE
*      CMBLK IS BUILT FOR THE OPERATOR (UNARY OR BINARY) AND A
*      POINTER TO THIS CMBLK IS STACKED.
*
*      EXPOP IS ALSO USED BY SCNGF (GOTO FIELD SCAN) PROCEDURE
*
*      JSR  EXPOP            CALL TO POP OPERATOR
*      (XS)                  POPPED APPROPRIATELY
*      (XR,XL,WA)            DESTROYED
*
{EXPOP{PRC{25,N{1,0{{ENTRY POINT{23329
{{MOV{13,NUM01(XS){7,XR{{LOAD OPERATOR DV POINTER{23330
{{BEQ{13,DVLPR(XR){18,=LLUNO{6,EXPO2{JUMP IF UNARY{23331
*
*      HERE FOR BINARY OPERATOR
*
{{MOV{19,*CMBS${8,WA{{SET SIZE OF BINARY OPERATOR CMBLK{23335
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23336
{{MOV{10,(XS)+{13,CMROP(XR){{POP AND STORE RIGHT OPERAND PTR{23337
{{MOV{10,(XS)+{7,XL{{POP AND LOAD OPERATOR DV PTR{23338
{{MOV{9,(XS){13,CMLOP(XR){{STORE LEFT OPERAND POINTER{23339
*
*      COMMON EXIT POINT
*
{EXPO1{MOV{22,=B$CMT{9,(XR){{STORE TYPE CODE FOR CMBLK{23343
{{MOV{13,DVTYP(XL){13,CMTYP(XR){{STORE CMBLK NODE TYPE CODE{23344
{{MOV{7,XL{13,CMOPN(XR){{STORE DVPTR (=PTR TO DAC O$XXX){23345
{{MOV{8,WA{13,CMLEN(XR){{STORE CMBLK LENGTH{23346
{{MOV{7,XR{9,(XS){{STORE RESULTING NODE PTR ON STACK{23347
{{EXI{{{{RETURN TO EXPOP CALLER{23348
*
*      HERE FOR UNARY OPERATOR
*
{EXPO2{MOV{19,*CMUS${8,WA{{SET SIZE OF UNARY OPERATOR CMBLK{23352
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23353
{{MOV{10,(XS)+{13,CMROP(XR){{POP AND STORE OPERAND POINTER{23354
{{MOV{9,(XS){7,XL{{LOAD OPERATOR DV POINTER{23355
{{BRN{6,EXPO1{{{MERGE BACK TO EXIT{23356
{{ENP{{{{END PROCEDURE EXPOP{23357
{{EJC{{{{{23358
*
*      FILNM -- OBTAIN FILE NAME FROM STATEMENT NUMBER
*
*      FILNM TAKES A STATEMENT NUMBER AND EXAMINES THE FILE NAME
*      TABLE POINTED TO BY R$SFN TO FIND THE NAME OF THE FILE
*      CONTAINING THE GIVEN STATEMENT.  TABLE ENTRIES ARE
*      ARRANGED IN ORDER OF ASCENDING STATEMENT NUMBER (THERE
*      IS ONLY ONE HASH BUCKET IN THIS TABLE).  ELEMENTS ARE
*      ADDED TO THE TABLE EACH TIME THERE IS A CHANGE IN
*      FILE NAME, RECORDING THE THEN CURRENT STATEMENT NUMBER.
*
*      TO FIND THE FILE NAME, THE LINKED LIST OF TEBLKS IS
*      SCANNED FOR AN ELEMENT CONTAINING A SUBSCRIPT (STATEMENT
*      NUMBER) GREATER THAN THE ARGUMENT STATEMENT NUMBER, OR
*      THE END OF CHAIN.  WHEN THIS CONDITION IS MET, THE
*      PREVIOUS TEBLK CONTAINS THE DESIRED FILE NAME AS ITS
*      VALUE ENTRY.
*
*      (WC)                  STATEMENT NUMBER
*      JSR  FILNM            CALL TO OBTAIN FILE NAME
*      (XL)                  FILE NAME (SCBLK)
*      (IA)                  DESTROYED
*
{FILNM{PRC{25,E{1,0{{ENTRY POINT{23383
{{MOV{8,WB{11,-(XS){{PRESERVE WB{23384
{{BZE{8,WC{6,FILN3{{RETURN NULLS IF STNO IS ZERO{23385
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{23386
{{BZE{7,XL{6,FILN3{{IF NO TABLE{23387
{{MOV{13,TBBUK(XL){8,WB{{GET BUCKET ENTRY{23388
{{BEQ{8,WB{3,R$SFN{6,FILN3{JUMP IF NO TEBLKS ON CHAIN{23389
{{MOV{7,XR{11,-(XS){{PRESERVE XR{23390
{{MOV{8,WB{7,XR{{PREVIOUS BLOCK POINTER{23391
{{MOV{8,WC{11,-(XS){{PRESERVE STMT NUMBER{23392
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{FILN1{MOV{7,XR{7,XL{{NEXT ELEMENT TO EXAMINE{23396
{{MOV{13,TESUB(XL){7,XR{{LOAD SUBSCRIPT VALUE (AN ICBLK){23397
{{LDI{13,ICVAL(XR){{{LOAD THE STATEMENT NUMBER{23398
{{MFI{8,WC{{{CONVERT TO ADDRESS CONSTANT{23399
{{BLT{9,(XS){8,WC{6,FILN2{COMPARE ARG WITH TEBLK STMT NUMBER{23400
*
*      HERE IF DESIRED STMT NUMBER IS GE TEBLK STMT NUMBER
*
{{MOV{7,XL{8,WB{{SAVE PREVIOUS ENTRY POINTER{23404
{{MOV{13,TENXT(XL){7,XR{{POINT TO NEXT TEBLK ON CHAIN{23405
{{BNE{7,XR{3,R$SFN{6,FILN1{JUMP IF THERE IS ONE{23406
*
*      HERE IF CHAIN EXHAUSTED OR DESIRED BLOCK FOUND.
*
{FILN2{MOV{8,WB{7,XL{{PREVIOUS TEBLK{23410
{{MOV{13,TEVAL(XL){7,XL{{GET PTR TO FILE NAME SCBLK{23411
{{MOV{10,(XS)+{8,WC{{RESTORE STMT NUMBER{23412
{{MOV{10,(XS)+{7,XR{{RESTORE XR{23413
{{MOV{10,(XS)+{8,WB{{RESTORE WB{23414
{{EXI{{{{{23415
*
*      NO TABLE OR NO TABLE ENTRIES
*
{FILN3{MOV{10,(XS)+{8,WB{{RESTORE WB{23419
{{MOV{21,=NULLS{7,XL{{RETURN NULL STRING{23420
{{EXI{{{{{23421
{{ENP{{{{{23422
{{EJC{{{{{23423
*
*
*      FLSTG -- FOLD STRING TO UPPER CASE
*
*      FLSTG FOLDS A CHARACTER STRING CONTAINING LOWER CASE
*      CHARACCTERS TO ONE CONTAINING UPPER CASE CHARACTERS.
*      FOLDING IS ONLY DONE IF &CASE (KVCAS) IS NOT ZERO.
*
*      (XR)                  STRING ARGUMENT
*      (WA)                  LENGTH OF STRING
*      JSR  FLSTG            CALL TO FOLD STRING
*      (XR)                  RESULT STRING (POSSIBLY ORIGINAL)
*      (WC)                  DESTROYED
*
{FLSTG{PRC{25,E{1,0{{ENTRY POINT{23440
{{BZE{3,KVCAS{6,FST99{{SKIP IF &CASE IS 0{23441
{{MOV{7,XL{11,-(XS){{SAVE XL ACROSS CALL{23442
{{MOV{7,XR{11,-(XS){{SAVE ORIGINAL SCBLK PTR{23443
{{JSR{6,ALOCS{{{ALLOCATE NEW STRING BLOCK{23444
{{MOV{9,(XS){7,XL{{POINT TO ORIGINAL SCBLK{23445
{{MOV{7,XR{11,-(XS){{SAVE POINTER TO NEW SCBLK{23446
{{PLC{7,XL{{{POINT TO ORIGINAL CHARS{23447
{{PSC{7,XR{{{POINT TO NEW CHARS{23448
{{ZER{11,-(XS){{{INIT DID FOLD FLAG{23449
{{LCT{8,WC{8,WC{{LOAD LOOP COUNTER{23450
{FST01{LCH{8,WA{10,(XL)+{{LOAD CHARACTER{23451
{{BLT{8,WA{18,=CH$$A{6,FST02{SKIP IF LESS THAN LC A{23452
{{BGT{8,WA{18,=CH$$${6,FST02{SKIP IF GREATER THAN LC Z{23453
{{FLC{8,WA{{{FOLD CHARACTER TO UPPER CASE{23454
{{MNZ{9,(XS){{{SET DID FOLD CHARACTER FLAG{23455
{FST02{SCH{8,WA{10,(XR)+{{STORE (POSSIBLY FOLDED) CHARACTER{23456
{{BCT{8,WC{6,FST01{{LOOP THRU ENTIRE STRING{23457
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{23458
{{MOV{10,(XS)+{7,XR{{SEE IF ANY CHANGE{23459
{{BNZ{7,XR{6,FST10{{SKIP IF FOLDING DONE (NO CHANGE){23460
{{MOV{10,(XS)+{3,DNAMP{{DO NOT NEED NEW SCBLK{23461
{{MOV{10,(XS)+{7,XR{{RETURN ORIGINAL SCBLK{23462
{{BRN{6,FST20{{{MERGE BELOW{23463
{FST10{MOV{10,(XS)+{7,XR{{RETURN NEW SCBLK{23464
{{ICA{7,XS{{{THROW AWAY ORIGINAL SCBLK POINTER{23465
{FST20{MOV{13,SCLEN(XR){8,WA{{RELOAD STRING LENGTH{23466
{{MOV{10,(XS)+{7,XL{{RESTORE XL{23467
{FST99{EXI{{{{RETURN{23468
{{ENP{{{{{23469
{{EJC{{{{{23470
*
*      GBCOL -- PERFORM GARBAGE COLLECTION
*
*      GBCOL PERFORMS A GARBAGE COLLECTION ON THE DYNAMIC REGION
*      ALL BLOCKS WHICH ARE NO LONGER IN USE ARE ELIMINATED
*      BY MOVING BLOCKS WHICH ARE IN USE DOWN AND RESETTING
*      DNAMP, THE POINTER TO THE NEXT AVAILABLE LOCATION.
*
*      (WB)                  MOVE OFFSET (SEE BELOW)
*      JSR  GBCOL            CALL TO COLLECT GARBAGE
*      (XR)                  SEDIMENT SIZE AFTER COLLECTION
*
*      THE FOLLOWING CONDITIONS MUST BE MET AT THE TIME WHEN
*      GBCOL IS CALLED.
*
*      1)   ALL POINTERS TO BLOCKS IN THE DYNAMIC AREA MUST BE
*           ACCESSIBLE TO THE GARBAGE COLLECTOR. THIS MEANS
*           THAT THEY MUST OCCUR IN ONE OF THE FOLLOWING.
*
*           A)               MAIN STACK, WITH CURRENT TOP
*                            ELEMENT BEING INDICATED BY XS
*
*           B)               IN RELOCATABLE FIELDS OF VRBLKS.
*
*           C)               IN REGISTER XL AT THE TIME OF CALL
*
*           E)               IN THE SPECIAL REGION OF WORKING
*                            STORAGE WHERE NAMES BEGIN WITH R$.
*
*      2)   ALL POINTERS MUST POINT TO THE START OF BLOCKS WITH
*           THE SOLE EXCEPTION OF THE CONTENTS OF THE CODE
*           POINTER REGISTER WHICH POINTS INTO THE R$COD BLOCK.
*
*      3)   NO LOCATION WHICH APPEARS TO CONTAIN A POINTER
*           INTO THE DYNAMIC REGION MAY OCCUR UNLESS IT IS IN
*           FACT A POINTER TO THE START OF THE BLOCK. HOWEVER
*           POINTERS OUTSIDE THIS AREA MAY OCCUR AND WILL
*           NOT BE CHANGED BY THE GARBAGE COLLECTOR.
*           IT IS ESPECIALLY IMPORTANT TO MAKE SURE THAT XL
*           DOES NOT CONTAIN A GARBAGE VALUE FROM SOME PROCESS
*           CARRIED OUT BEFORE THE CALL TO THE COLLECTOR.
*
*      GBCOL HAS THE CAPABILITY OF MOVING THE FINAL COMPACTED
*      RESULT UP IN MEMORY (WITH ADDRESSES ADJUSTED ACCORDINGLY)
*      THIS IS USED TO ADD SPACE TO THE STATIC REGION. THE
*      ENTRY VALUE OF WB IS THE NUMBER OF BYTES TO MOVE UP.
*      THE CALLER MUST GUARANTEE THAT THERE IS ENOUGH ROOM.
*      FURTHERMORE THE VALUE IN WB IF IT IS NON-ZERO, MUST BE AT
*      LEAST 256 SO THAT THE MWB INSTRUCTION CONDITIONS ARE MET.
{{EJC{{{{{23525
*
*      GBCOL (CONTINUED)
*
*      THE ALGORITHM, WHICH IS A MODIFICATION OF THE LISP-2
*      GARBAGE COLLECTOR DEVISED BY R.DEWAR AND K.BELCHER
*      TAKES THREE PASSES AS FOLLOWS.
*
*      1)   ALL POINTERS IN MEMORY ARE SCANNED AND BLOCKS IN USE
*           DETERMINED FROM THIS SCAN. NOTE THAT THIS PROCEDURE
*           IS RECURSIVE AND USES THE MAIN STACK FOR LINKAGE.
*           THE MARKING PROCESS IS THUS SIMILAR TO THAT USED IN
*           A STANDARD LISP COLLECTOR. HOWEVER THE METHOD OF
*           ACTUALLY MARKING THE BLOCKS IS DIFFERENT.
*
*           THE FIRST FIELD OF A BLOCK NORMALLY CONTAINS A
*           CODE ENTRY POINT POINTER. SUCH AN ENTRY POINTER
*           CAN BE DISTINGUISHED FROM THE ADDRESS OF ANY POINTER
*           TO BE PROCESSED BY THE COLLECTOR. DURING GARBAGE
*           COLLECTION, THIS WORD IS USED TO BUILD A BACK CHAIN
*           OF POINTERS THROUGH FIELDS WHICH POINT TO THE BLOCK.
*           THE END OF THE CHAIN IS MARKED BY THE OCCURENCE
*           OF THE WORD WHICH USED TO BE IN THE FIRST WORD OF
*           THE BLOCK. THIS BACKCHAIN SERVES BOTH AS A MARK
*           INDICATING THAT THE BLOCK IS IN USE AND AS A LIST OF
*           REFERENCES FOR THE RELOCATION PHASE.
*
*      2)   STORAGE IS SCANNED SEQUENTIALLY TO DISCOVER WHICH
*           BLOCKS ARE CURRENTLY IN USE AS INDICATED BY THE
*           PRESENCE OF A BACKCHAIN. TWO POINTERS ARE MAINTAINED
*           ONE SCANS THROUGH LOOKING AT EACH BLOCK. THE OTHER
*           IS INCREMENTED ONLY FOR BLOCKS FOUND TO BE IN USE.
*           IN THIS WAY, THE EVENTUAL LOCATION OF EACH BLOCK CAN
*           BE DETERMINED WITHOUT ACTUALLY MOVING ANY BLOCKS.
*           AS EACH BLOCK WHICH IS IN USE IS PROCESSED, THE BACK
*           CHAIN IS USED TO RESET ALL POINTERS WHICH POINT TO
*           THIS BLOCK TO CONTAIN ITS NEW ADDRESS, I.E. THE
*           ADDRESS IT WILL OCCUPY AFTER THE BLOCKS ARE MOVED.
*           THE FIRST WORD OF THE BLOCK, TAKEN FROM THE END OF
*           THE CHAIN IS RESTORED AT THIS POINT.
*
*           DURING PASS 2, THE COLLECTOR BUILDS BLOCKS WHICH
*           DESCRIBE THE REGIONS OF STORAGE WHICH ARE TO BE
*           MOVED IN THE THIRD PASS. THERE IS ONE DESCRIPTOR FOR
*           EACH CONTIGUOUS SET OF GOOD BLOCKS. THE DESCRIPTOR
*           IS BUILT JUST BEHIND THE BLOCK TO BE MOVED AND
*           CONTAINS A POINTER TO THE NEXT BLOCK AND THE NUMBER
*           OF WORDS TO BE MOVED.
*
*      3)   IN THE THIRD AND FINAL PASS, THE MOVE DESCRIPTOR
*           BLOCKS BUILT IN PASS TWO ARE USED TO ACTUALLY MOVE
*           THE BLOCKS DOWN TO THE BOTTOM OF THE DYNAMIC REGION.
*           THE COLLECTION IS THEN COMPLETE AND THE NEXT
*           AVAILABLE LOCATION POINTER IS RESET.
{{EJC{{{{{23579
*
*      GBCOL (CONTINUED)
*
*      THE GARBAGE COLLECTOR ALSO RECOGNIZES THE CONCEPT OF
*      SEDIMENT.  SEDIMENT IS DEFINED AS LONG-LIVED OBJECTS
*      WHICH PERCIPITATE TO THE BOTTOM OF DYNAMIC STORAGE.
*      MOVING THESE OBJECTS DURING REPEATED COLLECTIONS IS
*      INEFFICIENT.  IT ALSO CONTRIBUTES TO THRASHING ON
*      SYSTEMS WITH VIRTUAL MEMORY.  IN A TYPICAL WORST-CASE
*      SITUATION, THERE MAY BE SEVERAL MEGABYTES OF LIVE OBJECTS
*      IN THE SEDIMENT, AND ONLY A FEW DEAD OBJECTS IN NEED OF
*      COLLECTION.  WITHOUT RECOGNISING SEDIMENT, THE STANDARD
*      COLLECTOR WOULD MOVE THOSE MEGABYTES OF OBJECTS DOWNWARD
*      TO SQUEEZE OUT THE DEAD OBJECTS.  THIS TYPE OF MOVE
*      WOULD RESULT IN EXCESSIVE THRASING FOR VERY LITTLE MEMORY
*      GAIN.
*
*      SCANNING OF BLOCKS IN THE SEDIMENT CANNOT BE AVOIDED
*      ENTIRELY, BECAUSE THESE BLOCKS MAY CONTAIN POINTERS TO
*      LIVE OBJECTS ABOVE THE SEDIMENT.  HOWEVER, SEDIMENT
*      BLOCKS NEED NOT BE LINKED TO A BACK CHAIN AS DESCRIBED
*      IN PASS ONE ABOVE.  SINCE THESE BLOCKS WILL NOT BE MOVED,
*      POINTERS TO THEM DO NOT NEED TO BE ADJUSTED.  ELIMINATING
*      UNNECESSARY BACK CHAIN LINKS INCREASES LOCALITY OF
*      REFERENCE, IMPROVING VIRTUAL MEMORY PERFORMANCE.
*
*      BECAUSE BACK CHAINS ARE USED TO MARK BLOCKS WHOSE CON-
*      TENTS HAVE BEEN PROCESSED, A DIFFERENT MARKING SYSTEM
*      IS NEEDED FOR BLOCKS IN THE SEDIMENT.  SINCE BLOCK TYPE
*      WORDS POINT TO ODD-PARITY ENTRY ADDRESSES, MERELY INCRE-
*      MENTING THE TYPE WORD SERVES TO MARK THE BLOCK AS PRO-
*      CESSED.  DURING PASS THREE, THE TYPE WORDS ARE DECRE-
*      MENTED TO RESTORE THEM TO THEIR ORIGINAL VALUE.
{{EJC{{{{{23623
*
*      GBCOL (CONTINUED)
*
*
*      THE VARIABLE DNAMS CONTAINS THE NUMBER OF BYTES OF MEMORY
*      CURRENTLY IN THE SEDIMENT.  SETTING DNAMS TO ZERO WILL
*      ELIMINATE THE SEDIMENT AND FORCE IT TO BE INCLUDED IN A
*      FULL GARBAGE COLLECTION.  GBCOL RETURNS A SUGGESTED NEW
*      VALUE FOR DNAMS (USUALLY DNAMP-DNAMB) IN XR WHICH THE
*      CALLER CAN STORE IN DNAMS IF IT WISHES TO MAINTAIN THE
*      SEDIMENT.  THAT IS, DATA REMAINING AFTER A GARBAGE
*      COLLECTION IS CONSIDERED TO BE SEDIMENT.  IF ONE ACCEPTS
*      THE COMMON LORE THAT MOST OBJECTS ARE EITHER VERY SHORT-
*      OR VERY LONG-LIVED, THEN THIS NAIVE SETTING OF DNAMS
*      PROBABLY INCLUDES SOME SHORT-LIVED OBJECTS TOWARD THE END
*      OF THE SEDIMENT.
*
*      KNOWING WHEN TO RESET DNAMS TO ZERO TO COLLECT THE SEDI-
*      MENT IS NOT PRECISELY KNOWN.  WE FORCE IT TO ZERO PRIOR
*      TO PRODUCING A DUMP, WHEN GBCOL IS INVOKED BY COLLECT()
*      (SO THAT THE SEDIMENT IS INVISIBLE TO THE USER), WHEN
*      SYSMM IS UNABLE TO OBTAIN ADDITIONAL MEMORY, AND WHEN
*      GBCOL IS CALLED TO RELOCATE THE DYNAMIC AREA UP IN MEMORY
*      (TO MAKE ROOM FOR ENLARGING THE STATIC AREA).  IF THERE
*      ARE NO OTHER RESET SITUATIONS, THIS LEADS TO THE INEXO-
*      RABLE GROWTH OF THE SEDIMENT, POSSIBLE FORCING A MODEST
*      PROGRAM TO BEGIN TO USE VIRTUAL MEMORY THAT IT OTHERWISE
*      WOULD NOT.
*
*      AS WE SCAN SEDIMENT BLOCKS IN PASS THREE, WE MAINTAIN
*      AGGREGATE COUNTS OF THE AMOUNT OF DEAD AND LIVE STORAGE,
*      WHICH IS USED TO DECIDE WHEN TO RESET DNAMS.  WHEN THE
*      RATIO OF FREE STORAGE FOUND IN THE SEDIMENT TO TOTAL
*      SEDIMENT SIZE EXCEEDS A THRESHOLD, THE SEDIMENT IS MARKED
*      FOR COLLECTION ON THE NEXT GBCOL CALL.
*
{{EJC{{{{{23661
*
*      GBCOL (CONTINUED)
*
{GBCOL{PRC{25,E{1,0{{ENTRY POINT{23665
{{BNZ{3,DMVCH{6,GBC14{{FAIL IF IN MID-DUMP{23666
{{MNZ{3,GBCFL{{{NOTE GBCOL ENTERED{23667
{{MOV{8,WA{3,GBSVA{{SAVE ENTRY WA{23668
{{MOV{8,WB{3,GBSVB{{SAVE ENTRY WB{23669
{{MOV{8,WC{3,GBSVC{{SAVE ENTRY WC{23670
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{23671
{{SCP{8,WA{{{GET CODE POINTER VALUE{23672
{{SUB{3,R$COD{8,WA{{MAKE RELATIVE{23673
{{LCP{8,WA{{{AND RESTORE{23674
{{BZE{8,WB{6,GBC0A{{CHECK THERE IS NO MOVE OFFSET{23676
{{ZER{3,DNAMS{{{COLLECT SEDIMENT IF MUST MOVE IT{23677
{GBC0A{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23678
{{ADD{3,DNAMS{8,WA{{SIZE OF SEDIMENT{23679
{{MOV{8,WA{3,GBCSD{{FIRST LOCATION PAST SEDIMENT{23680
*
*      INFORM SYSGC THAT COLLECTION TO COMMENCE
*
{{MNZ{7,XR{{{NON-ZERO FLAGS START OF COLLECTION{23693
{{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23694
{{MOV{3,DNAMP{8,WB{{NEXT AVAILABLE LOCATION{23695
{{MOV{3,DNAME{8,WC{{LAST AVAILABLE LOCATION + 1{23696
{{JSR{6,SYSGC{{{INFORM OF COLLECTION{23697
*
*      PROCESS STACK ENTRIES
*
{{MOV{7,XS{7,XR{{POINT TO STACK FRONT{23702
{{MOV{3,STBAS{7,XL{{POINT PAST END OF STACK{23703
{{BGE{7,XL{7,XR{6,GBC00{OK IF D-STACK{23704
{{MOV{7,XL{7,XR{{REVERSE IF ...{23705
{{MOV{7,XS{7,XL{{... U-STACK{23706
*
*      PROCESS THE STACK
*
{GBC00{JSR{6,GBCPF{{{PROCESS POINTERS ON STACK{23710
*
*      PROCESS SPECIAL WORK LOCATIONS
*
{{MOV{20,=R$AAA{7,XR{{POINT TO START OF RELOCATABLE LOCS{23714
{{MOV{20,=R$YYY{7,XL{{POINT PAST END OF RELOCATABLE LOCS{23715
{{JSR{6,GBCPF{{{PROCESS WORK FIELDS{23716
*
*      PREPARE TO PROCESS VARIABLE BLOCKS
*
{{MOV{3,HSHTB{8,WA{{POINT TO FIRST HASH SLOT POINTER{23720
*
*      LOOP THROUGH HASH SLOTS
*
{GBC01{MOV{8,WA{7,XL{{POINT TO NEXT SLOT{23724
{{ICA{8,WA{{{BUMP BUCKET POINTER{23725
{{MOV{8,WA{3,GBCNM{{SAVE BUCKET POINTER{23726
{{EJC{{{{{23727
*
*      GBCOL (CONTINUED)
*
*      LOOP THROUGH VARIABLES ON ONE HASH CHAIN
*
{GBC02{MOV{9,(XL){7,XR{{LOAD PTR TO NEXT VRBLK{23733
{{BZE{7,XR{6,GBC03{{JUMP IF END OF CHAIN{23734
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK POINTER{23735
{{ADD{19,*VRVAL{7,XR{{POINT TO FIRST RELOC FLD{23736
{{ADD{19,*VRNXT{7,XL{{POINT PAST LAST (AND TO LINK PTR){23737
{{JSR{6,GBCPF{{{PROCESS RELOC FIELDS IN VRBLK{23738
{{BRN{6,GBC02{{{LOOP BACK FOR NEXT BLOCK{23739
*
*      HERE AT END OF ONE HASH CHAIN
*
{GBC03{MOV{3,GBCNM{8,WA{{RESTORE BUCKET POINTER{23743
{{BNE{8,WA{3,HSHTE{6,GBC01{LOOP BACK IF MORE BUCKETS TO GO{23744
{{EJC{{{{{23745
*
*      GBCOL (CONTINUED)
*
*      NOW WE ARE READY TO START PASS TWO. REGISTERS ARE USED
*      AS FOLLOWS IN PASS TWO.
*
*      (XR)                  SCANS THROUGH ALL BLOCKS
*      (WC)                  POINTER TO EVENTUAL LOCATION
*
*      THE MOVE DESCRIPTION BLOCKS BUILT IN THIS PASS HAVE
*      THE FOLLOWING FORMAT.
*
*      WORD 1                POINTER TO NEXT MOVE BLOCK,
*                            ZERO IF END OF CHAIN OF BLOCKS
*
*      WORD 2                LENGTH OF BLOCKS TO BE MOVED IN
*                            BYTES. SET TO THE ADDRESS OF THE
*                            FIRST BYTE WHILE ACTUALLY SCANNING
*                            THE BLOCKS.
*
*      THE FIRST ENTRY ON THIS CHAIN IS A SPECIAL ENTRY
*      CONSISTING OF THE TWO WORDS GBCNM AND GBCNS. AFTER
*      BUILDING THE CHAIN OF MOVE DESCRIPTORS, GBCNM POINTS TO
*      THE FIRST REAL MOVE BLOCK, AND GBCNS IS THE LENGTH OF
*      BLOCKS IN USE AT THE START OF STORAGE WHICH NEED NOT
*      BE MOVED SINCE THEY ARE IN THE CORRECT POSITION.
*
{{MOV{3,DNAMB{7,XR{{POINT TO FIRST BLOCK{23774
{{ZER{8,WB{{{ACCUMULATE SIZE OF DEAD BLOCKS{23775
{GBC04{BEQ{7,XR{3,GBCSD{6,GBC4C{JUMP IF END OF SEDIMENT{23776
{{MOV{9,(XR){8,WA{{ELSE GET FIRST WORD{23777
{{BOD{8,WA{6,GBC4B{{JUMP IF ENTRY POINTER (UNUSED){23779
{{DCV{8,WA{{{RESTORE ENTRY POINTER{23780
{{MOV{8,WA{9,(XR){{RESTORE FIRST WORD{23786
{{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{23787
{{ADD{8,WA{7,XR{{BUMP ACTUAL POINTER{23788
{{BRN{6,GBC04{{{CONTINUE SCAN THROUGH SEDIMENT{23789
*
*      HERE FOR UNUSED SEDIMENT BLOCK
*
{GBC4B{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{23793
{{ADD{8,WA{7,XR{{BUMP ACTUAL POINTER{23794
{{ADD{8,WA{8,WB{{COUNT SIZE OF UNUSED BLOCKS{23795
{{BRN{6,GBC04{{{CONTINUE SCAN THROUGH SEDIMENT{23796
*
*      HERE AT END OF SEDIMENT.  REMEMBER SIZE OF FREE BLOCKS
*      WITHIN THE SEDIMENT.  THIS WILL BE USED LATER TO DECIDE
*      HOW TO SET THE SEDIMENT SIZE RETURNED TO CALLER.
*
*      THEN SCAN REST OF DYNAMIC AREA ABOVE SEDIMENT.
*
*      (WB) = AGGREGATE SIZE OF FREE BLOCKS IN SEDIMENT
*      (XR) = FIRST LOCATION PAST SEDIMENT
*
{GBC4C{MOV{8,WB{3,GBCSF{{SIZE OF SEDIMENT FREE SPACE{23807
{{MOV{7,XR{8,WC{{SET AS FIRST EVENTUAL LOCATION{23811
{{ADD{3,GBSVB{8,WC{{ADD OFFSET FOR EVENTUAL MOVE UP{23812
{{ZER{3,GBCNM{{{CLEAR INITIAL FORWARD POINTER{23813
{{MOV{20,=GBCNM{3,GBCLM{{INITIALIZE PTR TO LAST MOVE BLOCK{23814
{{MOV{7,XR{3,GBCNS{{INITIALIZE FIRST ADDRESS{23815
*
*      LOOP THROUGH A SERIES OF BLOCKS IN USE
*
{GBC05{BEQ{7,XR{3,DNAMP{6,GBC07{JUMP IF END OF USED REGION{23819
{{MOV{9,(XR){8,WA{{ELSE GET FIRST WORD{23820
{{BOD{8,WA{6,GBC07{{JUMP IF ENTRY POINTER (UNUSED){23822
*
*      HERE FOR BLOCK IN USE, LOOP TO RELOCATE REFERENCES
*
{GBC06{MOV{8,WA{7,XL{{COPY POINTER{23830
{{MOV{9,(XL){8,WA{{LOAD FORWARD POINTER{23831
{{MOV{8,WC{9,(XL){{RELOCATE REFERENCE{23832
{{BEV{8,WA{6,GBC06{{LOOP BACK IF NOT END OF CHAIN{23834
{{EJC{{{{{23839
*
*      GBCOL (CONTINUED)
*
*      AT END OF CHAIN, RESTORE FIRST WORD AND BUMP PAST
*
{{MOV{8,WA{9,(XR){{RESTORE FIRST WORD{23845
{{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{23846
{{ADD{8,WA{7,XR{{BUMP ACTUAL POINTER{23847
{{ADD{8,WA{8,WC{{BUMP EVENTUAL POINTER{23848
{{BRN{6,GBC05{{{LOOP BACK FOR NEXT BLOCK{23849
*
*      HERE AT END OF A SERIES OF BLOCKS IN USE
*
{GBC07{MOV{7,XR{8,WA{{COPY POINTER PAST LAST BLOCK{23853
{{MOV{3,GBCLM{7,XL{{POINT TO PREVIOUS MOVE BLOCK{23854
{{SUB{13,NUM01(XL){8,WA{{SUBTRACT STARTING ADDRESS{23855
{{MOV{8,WA{13,NUM01(XL){{STORE LENGTH OF BLOCK TO BE MOVED{23856
*
*      LOOP THROUGH A SERIES OF BLOCKS NOT IN USE
*
{GBC08{BEQ{7,XR{3,DNAMP{6,GBC10{JUMP IF END OF USED REGION{23860
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF NEXT BLOCK{23861
{{BEV{8,WA{6,GBC09{{JUMP IF IN USE{23863
{{JSR{6,BLKLN{{{ELSE GET LENGTH OF NEXT BLOCK{23868
{{ADD{8,WA{7,XR{{PUSH POINTER{23869
{{BRN{6,GBC08{{{AND LOOP BACK{23870
*
*      HERE FOR A BLOCK IN USE AFTER PROCESSING A SERIES OF
*      BLOCKS WHICH WERE NOT IN USE, BUILD NEW MOVE BLOCK.
*
{GBC09{SUB{19,*NUM02{7,XR{{POINT 2 WORDS BEHIND FOR MOVE BLOCK{23875
{{MOV{3,GBCLM{7,XL{{POINT TO PREVIOUS MOVE BLOCK{23876
{{MOV{7,XR{9,(XL){{SET FORWARD PTR IN PREVIOUS BLOCK{23877
{{ZER{9,(XR){{{ZERO FORWARD PTR OF NEW BLOCK{23878
{{MOV{7,XR{3,GBCLM{{REMEMBER ADDRESS OF THIS BLOCK{23879
{{MOV{7,XR{7,XL{{COPY PTR TO MOVE BLOCK{23880
{{ADD{19,*NUM02{7,XR{{POINT BACK TO BLOCK IN USE{23881
{{MOV{7,XR{13,NUM01(XL){{STORE STARTING ADDRESS{23882
{{BRN{6,GBC06{{{JUMP TO PROCESS BLOCK IN USE{23883
{{EJC{{{{{23884
*
*      GBCOL (CONTINUED)
*
*      HERE FOR PASS THREE -- ACTUALLY MOVE THE BLOCKS DOWN
*
*      (XL)                  POINTER TO OLD LOCATION
*      (XR)                  POINTER TO NEW LOCATION
*
{GBC10{MOV{3,GBCSD{7,XR{{POINT TO STORAGE ABOVE SEDIMENT{23894
{{ADD{3,GBCNS{7,XR{{BUMP PAST UNMOVED BLOCKS AT START{23898
*
*      LOOP THROUGH MOVE DESCRIPTORS
*
{GBC11{MOV{3,GBCNM{7,XL{{POINT TO NEXT MOVE BLOCK{23902
{{BZE{7,XL{6,GBC12{{JUMP IF END OF CHAIN{23903
{{MOV{10,(XL)+{3,GBCNM{{MOVE POINTER DOWN CHAIN{23904
{{MOV{10,(XL)+{8,WA{{GET LENGTH TO MOVE{23905
{{MVW{{{{PERFORM MOVE{23906
{{BRN{6,GBC11{{{LOOP BACK{23907
*
*      NOW TEST FOR MOVE UP
*
{GBC12{MOV{7,XR{3,DNAMP{{SET NEXT AVAILABLE LOC PTR{23911
{{MOV{3,GBSVB{8,WB{{RELOAD MOVE OFFSET{23912
{{BZE{8,WB{6,GBC13{{JUMP IF NO MOVE REQUIRED{23913
{{MOV{7,XR{7,XL{{ELSE COPY OLD TOP OF CORE{23914
{{ADD{8,WB{7,XR{{POINT TO NEW TOP OF CORE{23915
{{MOV{7,XR{3,DNAMP{{SAVE NEW TOP OF CORE POINTER{23916
{{MOV{7,XL{8,WA{{COPY OLD TOP{23917
{{SUB{3,DNAMB{8,WA{{MINUS OLD BOTTOM = LENGTH{23918
{{ADD{8,WB{3,DNAMB{{BUMP BOTTOM TO GET NEW VALUE{23919
{{MWB{{{{PERFORM MOVE (BACKWARDS){23920
*
*      MERGE HERE TO EXIT
*
{GBC13{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{23924
{{MOV{7,XR{3,GBCFL{{NOTE EXIT FROM GBCOL{23925
{{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23927
{{MOV{3,DNAMP{8,WB{{NEXT AVAILABLE LOCATION{23928
{{MOV{3,DNAME{8,WC{{LAST AVAILABLE LOCATION + 1{23929
{{JSR{6,SYSGC{{{INFORM SYSGC OF COMPLETION{23930
*
*      DECIDE WHETHER TO MARK SEDIMENT FOR COLLECTION NEXT TIME.
*      THIS IS DONE BY EXAMINING THE RATIO OF PREVIOUS SEDIMENT
*      FREE SPACE TO THE NEW SEDIMENT SIZE.
*
{{STI{3,GBCIA{{{SAVE IA{23938
{{ZER{7,XR{{{PRESUME NO SEDIMENT WILL REMAIN{23939
{{MOV{3,GBCSF{8,WB{{FREE SPACE IN SEDIMENT{23940
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{23941
{{MTI{8,WB{{{PUT SEDIMENT FREE STORE IN IA{23942
{{MLI{3,GBSED{{{MULTIPLY BY SEDIMENT FACTOR{23943
{{IOV{6,GB13A{{{JUMP IF OVERFLOWED{23944
{{MOV{3,DNAMP{8,WB{{END OF DYNAMIC AREA IN USE{23945
{{SUB{3,DNAMB{8,WB{{MINUS START IS SEDIMENT REMAINING{23946
{{BTW{8,WB{{{CONVERT TO WORDS{23947
{{MOV{8,WB{3,GBCSF{{STORE IT{23948
{{SBI{3,GBCSF{{{SUBTRACT FROM SCALED UP FREE STORE{23949
{{IGT{6,GB13A{{{JUMP IF LARGE FREE STORE IN SEDIMNT{23950
{{MOV{3,DNAMP{7,XR{{BELOW THRESHOLD, RETURN SEDIMENT{23951
{{SUB{3,DNAMB{7,XR{{FOR USE BY CALLER{23952
{GB13A{LDI{3,GBCIA{{{RESTORE IA{23953
{{MOV{3,GBSVA{8,WA{{RESTORE WA{23955
{{MOV{3,GBSVB{8,WB{{RESTORE WB{23956
{{SCP{8,WC{{{GET CODE POINTER{23957
{{ADD{3,R$COD{8,WC{{MAKE ABSOLUTE AGAIN{23958
{{LCP{8,WC{{{AND REPLACE ABSOLUTE VALUE{23959
{{MOV{3,GBSVC{8,WC{{RESTORE WC{23960
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23961
{{ICV{3,GBCNT{{{INCREMENT COUNT OF COLLECTIONS{23962
{{EXI{{{{EXIT TO GBCOL CALLER{23963
*
*      GARBAGE COLLECTION NOT ALLOWED WHILST DUMPING
*
{GBC14{ICV{3,ERRFT{{{FATAL ERROR{23967
{{ERB{1,250{26,Insufficient memory to complete dump{{{23968
{{ENP{{{{END PROCEDURE GBCOL{23969
{{EJC{{{{{23970
*
*      GBCPF -- PROCESS FIELDS FOR GARBAGE COLLECTOR
*
*      THIS PROCEDURE IS USED BY THE GARBAGE COLLECTOR TO
*      PROCESS FIELDS IN PASS ONE. SEE GBCOL FOR FULL DETAILS.
*
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (XL)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  GBCPF            CALL TO PROCESS FIELDS
*      (XR,WA,WB,WC,IA)      DESTROYED
*
*      NOTE THAT ALTHOUGH THIS PROCEDURE USES A RECURSIVE
*      APPROACH, IT CONTROLS ITS OWN STACK AND IS NOT RECURSIVE.
*
{GBCPF{PRC{25,E{1,0{{ENTRY POINT{23985
{{ZER{11,-(XS){{{SET ZERO TO MARK BOTTOM OF STACK{23986
{{MOV{7,XL{11,-(XS){{SAVE END POINTER{23987
*
*      MERGE HERE TO GO DOWN A LEVEL AND START A NEW LOOP
*
*      1(XS)                 NEXT LVL FIELD PTR (0 AT OUTER LVL)
*      0(XS)                 PTR PAST LAST FIELD TO PROCESS
*      (XR)                  PTR TO FIRST FIELD TO PROCESS
*
*      LOOP TO PROCESS SUCCESSIVE FIELDS
*
{GPF01{MOV{9,(XR){7,XL{{LOAD FIELD CONTENTS{23997
{{MOV{7,XR{8,WC{{SAVE FIELD POINTER{23998
{{BLT{7,XL{3,DNAMB{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{24002
{{BGE{7,XL{3,DNAMP{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{24003
*
*      HERE WE HAVE A PTR TO A BLOCK IN THE DYNAMIC AREA.
*      LINK THIS FIELD ONTO THE REFERENCE BACKCHAIN.
*
{{MOV{9,(XL){8,WA{{LOAD PTR TO CHAIN (OR ENTRY PTR){24008
{{BLT{7,XL{3,GBCSD{6,GPF1A{DO NOT CHAIN IF WITHIN SEDIMENT{24010
{{MOV{7,XR{9,(XL){{SET THIS FIELD AS NEW HEAD OF CHAIN{24012
{{MOV{8,WA{9,(XR){{SET FORWARD POINTER{24013
*
*      NOW SEE IF THIS BLOCK HAS BEEN PROCESSED BEFORE
*
{GPF1A{BOD{8,WA{6,GPF03{{JUMP IF NOT ALREADY PROCESSED{24018
*
*      HERE TO RESTORE POINTER IN XR TO FIELD JUST PROCESSED
*
{GPF02{MOV{8,WC{7,XR{{RESTORE FIELD POINTER{24026
*
*      HERE TO MOVE TO NEXT FIELD
*
{GPF2A{ICA{7,XR{{{BUMP TO NEXT FIELD{24030
{{BNE{7,XR{9,(XS){6,GPF01{LOOP BACK IF MORE TO GO{24031
{{EJC{{{{{24032
*
*      GBCPF (CONTINUED)
*
*      HERE WE POP UP A LEVEL AFTER FINISHING A BLOCK
*
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER PAST END{24038
{{MOV{10,(XS)+{7,XR{{RESTORE BLOCK POINTER{24039
{{BNZ{7,XR{6,GPF2A{{CONTINUE LOOP UNLESS OUTER LEVL{24040
{{EXI{{{{RETURN TO CALLER IF OUTER LEVEL{24041
*
*      HERE TO PROCESS AN ACTIVE BLOCK WHICH HAS NOT BEEN DONE
*
*
*      SINCE SEDIMENT BLOCKS ARE NOT MARKED BY PUTTING THEM ON
*      THE BACK CHAIN, THEY MUST BE EXPLICITLY MARKED IN ANOTHER
*      MANNER.  IF ODD PARITY ENTRY POINTS ARE PRESENT, MARK BY
*      TEMPORARILY CONVERTING TO EVEN PARITY.  IF ODD PARITY NOT
*      AVAILABLE, THE ENTRY POINT IS ADJUSTED BY THE VALUE IN
*      GBCMK.
*
{GPF03{BGE{7,XL{3,GBCSD{6,GPF3A{IF NOT WITHIN SEDIMENT{24054
{{ICV{9,(XL){{{MARK BY MAKING ENTRY POINT EVEN{24056
{GPF3A{MOV{7,XL{7,XR{{COPY BLOCK POINTER{24060
{{MOV{8,WA{7,XL{{COPY FIRST WORD OF BLOCK{24064
{{LEI{7,XL{{{LOAD ENTRY POINT ID (BL$XX){24065
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO GPF02 HERE TO CONTINUE TO NEXT FLD.
*
{{BSW{7,XL{2,BL$$${{SWITCH ON BLOCK TYPE{24070
{{IFF{2,BL$AR{6,GPF06{{ARBLK{24108
{{IFF{2,BL$CD{6,GPF19{{CDBLK{24108
{{IFF{2,BL$EX{6,GPF17{{EXBLK{24108
{{IFF{2,BL$IC{6,GPF02{{ICBLK{24108
{{IFF{2,BL$NM{6,GPF10{{NMBLK{24108
{{IFF{2,BL$P0{6,GPF10{{P0BLK{24108
{{IFF{2,BL$P1{6,GPF12{{P1BLK{24108
{{IFF{2,BL$P2{6,GPF12{{P2BLK{24108
{{IFF{2,BL$RC{6,GPF02{{RCBLK{24108
{{IFF{2,BL$SC{6,GPF02{{SCBLK{24108
{{IFF{2,BL$SE{6,GPF02{{SEBLK{24108
{{IFF{2,BL$TB{6,GPF08{{TBBLK{24108
{{IFF{2,BL$VC{6,GPF08{{VCBLK{24108
{{IFF{2,BL$XN{6,GPF02{{XNBLK{24108
{{IFF{2,BL$XR{6,GPF09{{XRBLK{24108
{{IFF{2,BL$BC{6,GPF02{{BCBLK - DUMMY TO FILL OUT IFFS{24108
{{IFF{2,BL$PD{6,GPF13{{PDBLK{24108
{{IFF{2,BL$TR{6,GPF16{{TRBLK{24108
{{IFF{2,BL$BF{6,GPF02{{BFBLK{24108
{{IFF{2,BL$CC{6,GPF07{{CCBLK{24108
{{IFF{2,BL$CM{6,GPF04{{CMBLK{24108
{{IFF{2,BL$CT{6,GPF02{{CTBLK{24108
{{IFF{2,BL$DF{6,GPF02{{DFBLK{24108
{{IFF{2,BL$EF{6,GPF02{{EFBLK{24108
{{IFF{2,BL$EV{6,GPF10{{EVBLK{24108
{{IFF{2,BL$FF{6,GPF11{{FFBLK{24108
{{IFF{2,BL$KV{6,GPF02{{KVBLK{24108
{{IFF{2,BL$PF{6,GPF14{{PFBLK{24108
{{IFF{2,BL$TE{6,GPF15{{TEBLK{24108
{{ESW{{{{END OF JUMP TABLE{24108
{{EJC{{{{{24109
*
*      GBCPF (CONTINUED)
*
*      CMBLK
*
{GPF04{MOV{13,CMLEN(XR){8,WA{{LOAD LENGTH{24115
{{MOV{19,*CMTYP{8,WB{{SET OFFSET{24116
*
*      HERE TO PUSH DOWN TO NEW LEVEL
*
*      (WC)                  FIELD PTR AT PREVIOUS LEVEL
*      (XR)                  PTR TO NEW BLOCK
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
{GPF05{ADD{7,XR{8,WA{{POINT PAST LAST RELOC FIELD{24125
{{ADD{8,WB{7,XR{{POINT TO FIRST RELOC FIELD{24126
{{MOV{8,WC{11,-(XS){{STACK OLD FIELD POINTER{24127
{{MOV{8,WA{11,-(XS){{STACK NEW LIMIT POINTER{24128
{{CHK{{{{CHECK FOR STACK OVERFLOW{24129
{{BRN{6,GPF01{{{IF OK, BACK TO PROCESS{24130
*
*      ARBLK
*
{GPF06{MOV{13,ARLEN(XR){8,WA{{LOAD LENGTH{24134
{{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO 1ST RELOC FLD (ARPRO){24135
{{BRN{6,GPF05{{{ALL SET{24136
*
*      CCBLK
*
{GPF07{MOV{13,CCUSE(XR){8,WA{{SET LENGTH IN USE{24140
{{MOV{19,*CCUSE{8,WB{{1ST WORD (MAKE SURE AT LEAST ONE){24141
{{BRN{6,GPF05{{{ALL SET{24142
{{EJC{{{{{24143
*
*      GBCPF (CONTINUED)
*
*      CDBLK
*
{GPF19{MOV{13,CDLEN(XR){8,WA{{LOAD LENGTH{24150
{{MOV{19,*CDFAL{8,WB{{SET OFFSET{24151
{{BRN{6,GPF05{{{JUMP BACK{24152
*
*      TBBLK, VCBLK
*
{GPF08{MOV{13,OFFS2(XR){8,WA{{LOAD LENGTH{24159
{{MOV{19,*OFFS3{8,WB{{SET OFFSET{24160
{{BRN{6,GPF05{{{JUMP BACK{24161
*
*      XRBLK
*
{GPF09{MOV{13,XRLEN(XR){8,WA{{LOAD LENGTH{24165
{{MOV{19,*XRPTR{8,WB{{SET OFFSET{24166
{{BRN{6,GPF05{{{JUMP BACK{24167
*
*      EVBLK, NMBLK, P0BLK
*
{GPF10{MOV{19,*OFFS2{8,WA{{POINT PAST SECOND FIELD{24171
{{MOV{19,*OFFS1{8,WB{{OFFSET IS ONE (ONLY RELOC FLD IS 2){24172
{{BRN{6,GPF05{{{ALL SET{24173
*
*      FFBLK
*
{GPF11{MOV{19,*FFOFS{8,WA{{SET LENGTH{24177
{{MOV{19,*FFNXT{8,WB{{SET OFFSET{24178
{{BRN{6,GPF05{{{ALL SET{24179
*
*      P1BLK, P2BLK
*
{GPF12{MOV{19,*PARM2{8,WA{{LENGTH (PARM2 IS NON-RELOCATABLE){24183
{{MOV{19,*PTHEN{8,WB{{SET OFFSET{24184
{{BRN{6,GPF05{{{ALL SET{24185
{{EJC{{{{{24186
*
*      GBCPF (CONTINUED)
*
*      PDBLK
*
{GPF13{MOV{13,PDDFP(XR){7,XL{{LOAD PTR TO DFBLK{24192
{{MOV{13,DFPDL(XL){8,WA{{GET PDBLK LENGTH{24193
{{MOV{19,*PDFLD{8,WB{{SET OFFSET{24194
{{BRN{6,GPF05{{{ALL SET{24195
*
*      PFBLK
*
{GPF14{MOV{19,*PFARG{8,WA{{LENGTH PAST LAST RELOC{24199
{{MOV{19,*PFCOD{8,WB{{OFFSET TO FIRST RELOC{24200
{{BRN{6,GPF05{{{ALL SET{24201
*
*      TEBLK
*
{GPF15{MOV{19,*TESI${8,WA{{SET LENGTH{24205
{{MOV{19,*TESUB{8,WB{{AND OFFSET{24206
{{BRN{6,GPF05{{{ALL SET{24207
*
*      TRBLK
*
{GPF16{MOV{19,*TRSI${8,WA{{SET LENGTH{24211
{{MOV{19,*TRVAL{8,WB{{AND OFFSET{24212
{{BRN{6,GPF05{{{ALL SET{24213
*
*      EXBLK
*
{GPF17{MOV{13,EXLEN(XR){8,WA{{LOAD LENGTH{24217
{{MOV{19,*EXFLC{8,WB{{SET OFFSET{24218
{{BRN{6,GPF05{{{JUMP BACK{24219
{{ENP{{{{END PROCEDURE GBCPF{24229
{{EJC{{{{{24230
*
*      GTARR -- GET ARRAY
*
*      GTARR IS PASSED AN OBJECT AND RETURNS AN ARRAY IF POSSIBL
*
*      (XR)                  VALUE TO BE CONVERTED
*      (WA)                  0 TO PLACE TABLE ADDRESSES IN ARRAY
*                            NON-ZERO FOR KEYS/VALUES IN ARRAY
*      JSR  GTARR            CALL TO GET ARRAY
*      PPM  LOC              TRANSFER LOC FOR ALL NULL TABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING ARRAY
*      (XL,WA,WB,WC)         DESTROYED
*
{GTARR{PRC{25,E{1,2{{ENTRY POINT{24245
{{MOV{8,WA{3,GTAWA{{SAVE WA INDICATOR{24246
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{24247
{{BEQ{8,WA{22,=B$ART{6,GTAR8{EXIT IF ALREADY AN ARRAY{24248
{{BEQ{8,WA{22,=B$VCT{6,GTAR8{EXIT IF ALREADY AN ARRAY{24249
{{BNE{8,WA{22,=B$TBT{6,GTA9A{ELSE FAIL IF NOT A TABLE (SGD02){24250
*
*      HERE WE CONVERT A TABLE TO AN ARRAY
*
{{MOV{7,XR{11,-(XS){{REPLACE TBBLK POINTER ON STACK{24254
{{ZER{7,XR{{{SIGNAL FIRST PASS{24255
{{ZER{8,WB{{{ZERO NON-NULL ELEMENT COUNT{24256
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. ON THE FIRST PASS,
*      SIGNALLED BY XR=0, THE NUMBER OF NON-NULL ELEMENTS IN
*      THE TABLE IS COUNTED IN WB. IN THE SECOND PASS, WHERE
*      XR IS A POINTER INTO THE ARBLK, THE NAME AND VALUE ARE
*      ENTERED INTO THE CURRENT ARBLK LOCATION PROVIDED GTAWA
*      IS NON-ZERO.  IF GTAWA IS ZERO, THE ADDRESS OF THE TEBLK
*      IS ENTERED INTO THE ARBLK TWICE (C3.762).
*
{GTAR1{MOV{9,(XS){7,XL{{POINT TO TABLE{24266
{{ADD{13,TBLEN(XL){7,XL{{POINT PAST LAST BUCKET{24267
{{SUB{19,*TBBUK{7,XL{{SET FIRST BUCKET OFFSET{24268
{{MOV{7,XL{8,WA{{COPY ADJUSTED POINTER{24269
*
*      LOOP THROUGH BUCKETS IN TABLE BLOCK
*      NEXT THREE LINES OF CODE RELY ON TENXT HAVING A VALUE
*      1 LESS THAN TBBUK.
*
{GTAR2{MOV{8,WA{7,XL{{COPY BUCKET POINTER{24275
{{DCA{8,WA{{{DECREMENT BUCKET POINTER{24276
*
*      LOOP THROUGH TEBLKS ON ONE BUCKET CHAIN
*
{GTAR3{MOV{13,TENXT(XL){7,XL{{POINT TO NEXT TEBLK{24280
{{BEQ{7,XL{9,(XS){6,GTAR6{JUMP IF CHAIN END (TBBLK PTR){24281
{{MOV{7,XL{3,CNVTP{{ELSE SAVE TEBLK POINTER{24282
*
*      LOOP TO FIND VALUE DOWN TRBLK CHAIN
*
{GTAR4{MOV{13,TEVAL(XL){7,XL{{LOAD VALUE{24286
{{BEQ{9,(XL){22,=B$TRT{6,GTAR4{LOOP TILL VALUE FOUND{24287
{{MOV{7,XL{8,WC{{COPY VALUE{24288
{{MOV{3,CNVTP{7,XL{{RESTORE TEBLK POINTER{24289
{{EJC{{{{{24290
*
*      GTARR (CONTINUED)
*
*      NOW CHECK FOR NULL AND TEST CASES
*
{{BEQ{8,WC{21,=NULLS{6,GTAR3{LOOP BACK TO IGNORE NULL VALUE{24296
{{BNZ{7,XR{6,GTAR5{{JUMP IF SECOND PASS{24297
{{ICV{8,WB{{{FOR THE FIRST PASS, BUMP COUNT{24298
{{BRN{6,GTAR3{{{AND LOOP BACK FOR NEXT TEBLK{24299
*
*      HERE IN SECOND PASS
*
{GTAR5{BZE{3,GTAWA{6,GTA5A{{JUMP IF ADDRESS WANTED{24303
{{MOV{13,TESUB(XL){10,(XR)+{{STORE SUBSCRIPT NAME{24304
{{MOV{8,WC{10,(XR)+{{STORE VALUE IN ARBLK{24305
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{24306
*
*      HERE TO RECORD TEBLK ADDRESS IN ARBLK.  THIS ALLOWS
*      A SORT ROUTINE TO SORT BY ASCENDING ADDRESS.
*
{GTA5A{MOV{7,XL{10,(XR)+{{STORE TEBLK ADDRESS IN NAME{24311
{{MOV{7,XL{10,(XR)+{{AND VALUE SLOTS{24312
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{24313
*
*      HERE AFTER SCANNING TEBLKS ON ONE CHAIN
*
{GTAR6{BNE{8,WA{9,(XS){6,GTAR2{LOOP BACK IF MORE BUCKETS TO GO{24317
{{BNZ{7,XR{6,GTAR7{{ELSE JUMP IF SECOND PASS{24318
*
*      HERE AFTER COUNTING NON-NULL ELEMENTS
*
{{BZE{8,WB{6,GTAR9{{FAIL IF NO NON-NULL ELEMENTS{24322
{{MOV{8,WB{8,WA{{ELSE COPY COUNT{24323
{{ADD{8,WB{8,WA{{DOUBLE (TWO WORDS/ELEMENT){24324
{{ADD{18,=ARVL2{8,WA{{ADD SPACE FOR STANDARD FIELDS{24325
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{24326
{{BGT{8,WA{3,MXLEN{6,GTA9B{ERROR IF TOO LONG FOR ARRAY{24327
{{JSR{6,ALLOC{{{ELSE ALLOCATE SPACE FOR ARBLK{24328
{{MOV{22,=B$ART{9,(XR){{STORE TYPE WORD{24329
{{ZER{13,IDVAL(XR){{{ZERO ID FOR THE MOMENT{24330
{{MOV{8,WA{13,ARLEN(XR){{STORE LENGTH{24331
{{MOV{18,=NUM02{13,ARNDM(XR){{SET DIMENSIONS = 2{24332
{{LDI{4,INTV1{{{GET INTEGER ONE{24333
{{STI{13,ARLBD(XR){{{STORE AS LBD 1{24334
{{STI{13,ARLB2(XR){{{STORE AS LBD 2{24335
{{LDI{4,INTV2{{{LOAD INTEGER TWO{24336
{{STI{13,ARDM2(XR){{{STORE AS DIM 2{24337
{{MTI{8,WB{{{GET ELEMENT COUNT AS INTEGER{24338
{{STI{13,ARDIM(XR){{{STORE AS DIM 1{24339
{{ZER{13,ARPR2(XR){{{ZERO PROTOTYPE FIELD FOR NOW{24340
{{MOV{19,*ARPR2{13,AROFS(XR){{SET OFFSET FIELD (SIGNAL PASS 2){24341
{{MOV{7,XR{8,WB{{SAVE ARBLK POINTER{24342
{{ADD{19,*ARVL2{7,XR{{POINT TO FIRST ELEMENT LOCATION{24343
{{BRN{6,GTAR1{{{JUMP BACK TO FILL IN ELEMENTS{24344
{{EJC{{{{{24345
*
*      GTARR (CONTINUED)
*
*      HERE AFTER FILLING IN ELEMENT VALUES
*
{GTAR7{MOV{8,WB{7,XR{{RESTORE ARBLK POINTER{24351
{{MOV{8,WB{9,(XS){{STORE AS RESULT{24352
*
*      NOW WE NEED THE ARRAY PROTOTYPE WHICH IS OF THE FORM NN,2
*      THIS IS OBTAINED BY BUILDING THE STRING FOR NN02 AND
*      CHANGING THE ZERO TO A COMMA BEFORE STORING IT.
*
{{LDI{13,ARDIM(XR){{{GET NUMBER OF ELEMENTS (NN){24358
{{MLI{4,INTVH{{{MULTIPLY BY 100{24359
{{ADI{4,INTV2{{{ADD 2 (NN02){24360
{{JSR{6,ICBLD{{{BUILD INTEGER{24361
{{MOV{7,XR{11,-(XS){{STORE PTR FOR GTSTG{24362
{{JSR{6,GTSTG{{{CONVERT TO STRING{24363
{{PPM{{{{CONVERT FAIL IS IMPOSSIBLE{24364
{{MOV{7,XR{7,XL{{COPY STRING POINTER{24365
{{MOV{10,(XS)+{7,XR{{RELOAD ARBLK POINTER{24366
{{MOV{7,XL{13,ARPR2(XR){{STORE PROTOTYPE PTR (NN02){24367
{{SUB{18,=NUM02{8,WA{{ADJUST LENGTH TO POINT TO ZERO{24368
{{PSC{7,XL{8,WA{{POINT TO ZERO{24369
{{MOV{18,=CH$CM{8,WB{{LOAD A COMMA{24370
{{SCH{8,WB{9,(XL){{STORE A COMMA OVER THE ZERO{24371
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{24372
*
*      NORMAL RETURN
*
{GTAR8{EXI{{{{RETURN TO CALLER{24376
*
*      NULL TABLE NON-CONVERSION RETURN
*
{GTAR9{MOV{10,(XS)+{7,XR{{RESTORE STACK FOR CONV ERR (SGD02){24380
{{EXI{1,1{{{RETURN{24381
*
*      IMPOSSIBLE CONVERSION RETURN
*
{GTA9A{EXI{1,2{{{RETURN{24385
*
*      ARRAY SIZE TOO LARGE
*
{GTA9B{ERB{1,260{26,Conversion array size exceeds maximum permitted{{{24389
{{ENP{{{{PROCEDURE GTARR{24390
{{EJC{{{{{24391
*
*      GTCOD -- CONVERT TO CODE
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTCOD            CALL TO CONVERT TO CODE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING CDBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTCOD{PRC{25,E{1,1{{ENTRY POINT{24405
{{BEQ{9,(XR){22,=B$CDS{6,GTCD1{JUMP IF ALREADY CODE{24406
{{BEQ{9,(XR){22,=B$CDC{6,GTCD1{JUMP IF ALREADY CODE{24407
*
*      HERE WE MUST GENERATE A CDBLK BY COMPILATION
*
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24411
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24412
{{PPM{6,GTCD2{{{JUMP IF NON-CONVERTIBLE{24413
{{MOV{3,FLPTR{3,GTCEF{{SAVE FAIL PTR IN CASE OF ERROR{24414
{{MOV{3,R$COD{3,R$GTC{{ALSO SAVE CODE PTR{24415
{{MOV{7,XR{3,R$CIM{{ELSE SET IMAGE POINTER{24416
{{MOV{8,WA{3,SCNIL{{SET IMAGE LENGTH{24417
{{ZER{3,SCNPT{{{SET SCAN POINTER{24418
{{MOV{18,=STGXC{3,STAGE{{SET STAGE FOR EXECUTE COMPILE{24419
{{MOV{3,CMPSN{3,LSTSN{{IN CASE LISTR CALLED{24420
{{ICV{3,CMPLN{{{BUMP LINE NUMBER{24422
{{JSR{6,CMPIL{{{COMPILE STRING{24424
{{MOV{18,=STGXT{3,STAGE{{RESET STAGE FOR EXECUTE TIME{24425
{{ZER{3,R$CIM{{{CLEAR IMAGE{24426
*
*      MERGE HERE IF NO CONVERT REQUIRED
*
{GTCD1{EXI{{{{GIVE NORMAL GTCOD RETURN{24430
*
*      HERE IF UNCONVERTIBLE
*
{GTCD2{EXI{1,1{{{GIVE ERROR RETURN{24434
{{ENP{{{{END PROCEDURE GTCOD{24435
{{EJC{{{{{24436
*
*      GTEXP -- CONVERT TO EXPRESSION
*
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      (XR)                  INPUT VALUE TO BE CONVERTED
*      JSR  GTEXP            CALL TO CONVERT TO EXPRESSION
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT EXBLK OR SEBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTEXP{PRC{25,E{1,1{{ENTRY POINT{24453
{{BLO{9,(XR){22,=B$E$${6,GTEX1{JUMP IF ALREADY AN EXPRESSION{24454
{{MOV{7,XR{11,-(XS){{STORE ARGUMENT FOR GTSTG{24455
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24456
{{PPM{6,GTEX2{{{JUMP IF UNCONVERTIBLE{24457
*
*      CHECK THE LAST CHARACTER OF THE STRING FOR COLON OR
*      SEMICOLON.  THESE CHARACTERS CAN LEGITIMATELY END AN
*      EXPRESSION IN OPEN CODE, SO EXPAN WILL NOT DETECT THEM
*      AS ERRORS, BUT THEY ARE INVALID AS TERMINATORS FOR A
*      STRING THAT IS BEING CONVERTED TO EXPRESSION FORM.
*
{{MOV{7,XR{7,XL{{COPY INPUT STRING POINTER{24465
{{PLC{7,XL{8,WA{{POINT ONE PAST THE STRING END{24466
{{LCH{7,XL{11,-(XL){{FETCH THE LAST CHARACTER{24467
{{BEQ{7,XL{18,=CH$CL{6,GTEX2{ERROR IF IT IS A SEMICOLON{24468
{{BEQ{7,XL{18,=CH$SM{6,GTEX2{OR IF IT IS A COLON{24469
*
*      HERE WE CONVERT A STRING BY COMPILATION
*
{{MOV{7,XR{3,R$CIM{{SET INPUT IMAGE POINTER{24473
{{ZER{3,SCNPT{{{SET SCAN POINTER{24474
{{MOV{8,WA{3,SCNIL{{SET INPUT IMAGE LENGTH{24475
{{MOV{8,WB{11,-(XS){{SAVE VALUE/NAME FLAG{24477
{{ZER{8,WB{{{SET CODE FOR NORMAL SCAN{24479
{{MOV{3,FLPTR{3,GTCEF{{SAVE FAIL PTR IN CASE OF ERROR{24480
{{MOV{3,R$COD{3,R$GTC{{ALSO SAVE CODE PTR{24481
{{MOV{18,=STGEV{3,STAGE{{ADJUST STAGE FOR COMPILE{24482
{{MOV{18,=T$UOK{3,SCNTP{{INDICATE UNARY OPERATOR ACCEPTABLE{24483
{{JSR{6,EXPAN{{{BUILD TREE FOR EXPRESSION{24484
{{ZER{3,SCNRS{{{RESET RESCAN FLAG{24485
{{MOV{10,(XS)+{8,WA{{RESTORE VALUE/NAME FLAG{24487
{{BNE{3,SCNPT{3,SCNIL{6,GTEX2{ERROR IF NOT END OF IMAGE{24489
{{ZER{8,WB{{{SET OK VALUE FOR CDGEX CALL{24490
{{MOV{7,XR{7,XL{{COPY TREE POINTER{24491
{{JSR{6,CDGEX{{{BUILD EXPRESSION BLOCK{24492
{{ZER{3,R$CIM{{{CLEAR POINTER{24493
{{MOV{18,=STGXT{3,STAGE{{RESTORE STAGE FOR EXECUTE TIME{24494
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTEX1{EXI{{{{RETURN TO GTEXP CALLER{24498
*
*      HERE IF UNCONVERTIBLE
*
{GTEX2{EXI{1,1{{{TAKE ERROR EXIT{24502
{{ENP{{{{END PROCEDURE GTEXP{24503
{{EJC{{{{{24504
*
*      GTINT -- GET INTEGER VALUE
*
*      GTINT IS PASSED AN OBJECT AND RETURNS AN INTEGER AFTER
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  VALUE TO BE CONVERTED
*      JSR  GTINT            CALL TO CONVERT TO INTEGER
*      PPM  LOC              TRANSFER LOC FOR CONVERT IMPOSSIBLE
*      (XR)                  RESULTING INTEGER
*      (WC,RA)               DESTROYED
*      (WA,WB)               DESTROYED (ONLY ON CONVERSION ERR)
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTINT{PRC{25,E{1,1{{ENTRY POINT{24519
{{BEQ{9,(XR){22,=B$ICL{6,GTIN2{JUMP IF ALREADY AN INTEGER{24520
{{MOV{8,WA{3,GTINA{{ELSE SAVE WA{24521
{{MOV{8,WB{3,GTINB{{SAVE WB{24522
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{24523
{{PPM{6,GTIN3{{{JUMP IF UNCONVERTIBLE{24524
{{BEQ{8,WA{22,=B$ICL{6,GTIN1{JUMP IF INTEGER{24527
*
*      HERE WE CONVERT A REAL TO INTEGER
*
{{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{24531
{{RTI{6,GTIN3{{{CONVERT TO INTEGER (ERR IF OVFLOW){24532
{{JSR{6,ICBLD{{{IF OK BUILD ICBLK{24533
*
*      HERE AFTER SUCCESSFUL CONVERSION TO INTEGER
*
{GTIN1{MOV{3,GTINA{8,WA{{RESTORE WA{24538
{{MOV{3,GTINB{8,WB{{RESTORE WB{24539
*
*      COMMON EXIT POINT
*
{GTIN2{EXI{{{{RETURN TO GTINT CALLER{24543
*
*      HERE ON CONVERSION ERROR
*
{GTIN3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{24547
{{ENP{{{{END PROCEDURE GTINT{24548
{{EJC{{{{{24549
*
*      GTNUM -- GET NUMERIC VALUE
*
*      GTNUM IS GIVEN AN OBJECT AND RETURNS EITHER AN INTEGER
*      OR A REAL, PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTNUM            CALL TO CONVERT TO NUMERIC
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT (INT OR REAL)
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WB,WC,RA)            DESTROYED
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTNUM{PRC{25,E{1,1{{ENTRY POINT{24564
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{24565
{{BEQ{8,WA{22,=B$ICL{6,GTN34{JUMP IF INTEGER (NO CONVERSION){24566
{{BEQ{8,WA{22,=B$RCL{6,GTN34{JUMP IF REAL (NO CONVERSION){24569
*
*      AT THIS POINT THE ONLY POSSIBILITY IS TO CONVERT A STRING
*      TO AN INTEGER OR REAL AS APPROPRIATE.
*
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT IN CASE CONVERT ERR{24575
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24576
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24578
{{PPM{6,GTN36{{{JUMP IF UNCONVERTIBLE{24582
*
*      INITIALIZE NUMERIC CONVERSION
*
{{LDI{4,INTV0{{{INITIALIZE INTEGER RESULT TO ZERO{24586
{{BZE{8,WA{6,GTN32{{JUMP TO EXIT WITH ZERO IF NULL{24587
{{LCT{8,WA{8,WA{{SET BCT COUNTER FOR FOLLOWING LOOPS{24588
{{ZER{3,GTNNF{{{TENTATIVELY INDICATE RESULT +{24589
{{STI{3,GTNEX{{{INITIALISE EXPONENT TO ZERO{24592
{{ZER{3,GTNSC{{{ZERO SCALE IN CASE REAL{24593
{{ZER{3,GTNDF{{{RESET FLAG FOR DEC POINT FOUND{24594
{{ZER{3,GTNRD{{{RESET FLAG FOR DIGITS FOUND{24595
{{LDR{4,REAV0{{{ZERO REAL ACCUM IN CASE REAL{24596
{{PLC{7,XR{{{POINT TO ARGUMENT CHARACTERS{24598
*
*      MERGE BACK HERE AFTER IGNORING LEADING BLANK
*
{GTN01{LCH{8,WB{10,(XR)+{{LOAD FIRST CHARACTER{24602
{{BLT{8,WB{18,=CH$D0{6,GTN02{JUMP IF NOT DIGIT{24603
{{BLE{8,WB{18,=CH$D9{6,GTN06{JUMP IF FIRST CHAR IS A DIGIT{24604
{{EJC{{{{{24605
*
*      GTNUM (CONTINUED)
*
*      HERE IF FIRST DIGIT IS NON-DIGIT
*
{GTN02{BNE{8,WB{18,=CH$BL{6,GTN03{JUMP IF NON-BLANK{24611
{GTNA2{BCT{8,WA{6,GTN01{{ELSE DECR COUNT AND LOOP BACK{24612
{{BRN{6,GTN07{{{JUMP TO RETURN ZERO IF ALL BLANKS{24613
*
*      HERE FOR FIRST CHARACTER NON-BLANK, NON-DIGIT
*
{GTN03{BEQ{8,WB{18,=CH$PL{6,GTN04{JUMP IF PLUS SIGN{24617
{{BEQ{8,WB{18,=CH$HT{6,GTNA2{HORIZONTAL TAB EQUIV TO BLANK{24619
{{BNE{8,WB{18,=CH$MN{6,GTN12{JUMP IF NOT MINUS (MAY BE REAL){24627
{{MNZ{3,GTNNF{{{IF MINUS SIGN, SET NEGATIVE FLAG{24629
*
*      MERGE HERE AFTER PROCESSING SIGN
*
{GTN04{BCT{8,WA{6,GTN05{{JUMP IF CHARS LEFT{24633
{{BRN{6,GTN36{{{ELSE ERROR{24634
*
*      LOOP TO FETCH CHARACTERS OF AN INTEGER
*
{GTN05{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24638
{{BLT{8,WB{18,=CH$D0{6,GTN08{JUMP IF NOT A DIGIT{24639
{{BGT{8,WB{18,=CH$D9{6,GTN08{JUMP IF NOT A DIGIT{24640
*
*      MERGE HERE FOR FIRST DIGIT
*
{GTN06{STI{3,GTNSI{{{SAVE CURRENT VALUE{24644
{{CVM{6,GTN35{{{CURRENT*10-(NEW DIG) JUMP IF OVFLOW{24648
{{MNZ{3,GTNRD{{{SET DIGIT READ FLAG{24649
{{BCT{8,WA{6,GTN05{{ELSE LOOP BACK IF MORE CHARS{24651
*
*      HERE TO EXIT WITH CONVERTED INTEGER VALUE
*
{GTN07{BNZ{3,GTNNF{6,GTN32{{JUMP IF NEGATIVE (ALL SET){24655
{{NGI{{{{ELSE NEGATE{24656
{{INO{6,GTN32{{{JUMP IF NO OVERFLOW{24657
{{BRN{6,GTN36{{{ELSE SIGNAL ERROR{24658
{{EJC{{{{{24659
*
*      GTNUM (CONTINUED)
*
*      HERE FOR A NON-DIGIT CHARACTER WHILE ATTEMPTING TO
*      CONVERT AN INTEGER, CHECK FOR TRAILING BLANKS OR REAL.
*
{GTN08{BEQ{8,WB{18,=CH$BL{6,GTNA9{JUMP IF A BLANK{24666
{{BEQ{8,WB{18,=CH$HT{6,GTNA9{JUMP IF HORIZONTAL TAB{24668
{{ITR{{{{ELSE CONVERT INTEGER TO REAL{24676
{{NGR{{{{NEGATE TO GET POSITIVE VALUE{24677
{{BRN{6,GTN12{{{JUMP TO TRY FOR REAL{24678
*
*      HERE WE SCAN OUT BLANKS TO END OF STRING
*
{GTN09{LCH{8,WB{10,(XR)+{{GET NEXT CHAR{24683
{{BEQ{8,WB{18,=CH$HT{6,GTNA9{JUMP IF HORIZONTAL TAB{24685
{{BNE{8,WB{18,=CH$BL{6,GTN36{ERROR IF NON-BLANK{24690
{GTNA9{BCT{8,WA{6,GTN09{{LOOP BACK IF MORE CHARS TO CHECK{24691
{{BRN{6,GTN07{{{RETURN INTEGER IF ALL BLANKS{24692
*
*      LOOP TO COLLECT MANTISSA OF REAL
*
{GTN10{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24698
{{BLT{8,WB{18,=CH$D0{6,GTN12{JUMP IF NON-NUMERIC{24699
{{BGT{8,WB{18,=CH$D9{6,GTN12{JUMP IF NON-NUMERIC{24700
*
*      MERGE HERE TO COLLECT FIRST REAL DIGIT
*
{GTN11{SUB{18,=CH$D0{8,WB{{CONVERT DIGIT TO NUMBER{24704
{{MLR{4,REAVT{{{MULTIPLY REAL BY 10.0{24705
{{ROV{6,GTN36{{{CONVERT ERROR IF OVERFLOW{24706
{{STR{3,GTNSR{{{SAVE RESULT{24707
{{MTI{8,WB{{{GET NEW DIGIT AS INTEGER{24708
{{ITR{{{{CONVERT NEW DIGIT TO REAL{24709
{{ADR{3,GTNSR{{{ADD TO GET NEW TOTAL{24710
{{ADD{3,GTNDF{3,GTNSC{{INCREMENT SCALE IF AFTER DEC POINT{24711
{{MNZ{3,GTNRD{{{SET DIGIT FOUND FLAG{24712
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{24713
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24714
{{EJC{{{{{24715
*
*      GTNUM (CONTINUED)
*
*      HERE IF NON-DIGIT FOUND WHILE COLLECTING A REAL
*
{GTN12{BNE{8,WB{18,=CH$DT{6,GTN13{JUMP IF NOT DEC POINT{24721
{{BNZ{3,GTNDF{6,GTN36{{IF DEC POINT, ERROR IF ONE ALREADY{24722
{{MOV{18,=NUM01{3,GTNDF{{ELSE SET FLAG FOR DEC POINT{24723
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{24724
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24725
*
*      HERE IF NOT DECIMAL POINT
*
{GTN13{BEQ{8,WB{18,=CH$LE{6,GTN15{JUMP IF E FOR EXPONENT{24729
{{BEQ{8,WB{18,=CH$LD{6,GTN15{JUMP IF D FOR EXPONENT{24730
{{BEQ{8,WB{18,=CH$$E{6,GTN15{JUMP IF E FOR EXPONENT{24732
{{BEQ{8,WB{18,=CH$$D{6,GTN15{JUMP IF D FOR EXPONENT{24733
*
*      HERE CHECK FOR TRAILING BLANKS
*
{GTN14{BEQ{8,WB{18,=CH$BL{6,GTNB4{JUMP IF BLANK{24738
{{BEQ{8,WB{18,=CH$HT{6,GTNB4{JUMP IF HORIZONTAL TAB{24740
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{24745
*
{GTNB4{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{24747
{{BCT{8,WA{6,GTN14{{LOOP BACK TO CHECK IF MORE{24748
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24749
*
*      HERE TO READ AND PROCESS AN EXPONENT
*
{GTN15{ZER{3,GTNES{{{SET EXPONENT SIGN POSITIVE{24753
{{LDI{4,INTV0{{{INITIALIZE EXPONENT TO ZERO{24754
{{MNZ{3,GTNDF{{{RESET NO DEC POINT INDICATION{24755
{{BCT{8,WA{6,GTN16{{JUMP SKIPPING PAST E OR D{24756
{{BRN{6,GTN36{{{ERROR IF NULL EXPONENT{24757
*
*      CHECK FOR EXPONENT SIGN
*
{GTN16{LCH{8,WB{10,(XR)+{{LOAD FIRST EXPONENT CHARACTER{24761
{{BEQ{8,WB{18,=CH$PL{6,GTN17{JUMP IF PLUS SIGN{24762
{{BNE{8,WB{18,=CH$MN{6,GTN19{ELSE JUMP IF NOT MINUS SIGN{24763
{{MNZ{3,GTNES{{{SET SIGN NEGATIVE IF MINUS SIGN{24764
*
*      MERGE HERE AFTER PROCESSING EXPONENT SIGN
*
{GTN17{BCT{8,WA{6,GTN18{{JUMP IF CHARS LEFT{24768
{{BRN{6,GTN36{{{ELSE ERROR{24769
*
*      LOOP TO CONVERT EXPONENT DIGITS
*
{GTN18{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24773
{{EJC{{{{{24774
*
*      GTNUM (CONTINUED)
*
*      MERGE HERE FOR FIRST EXPONENT DIGIT
*
{GTN19{BLT{8,WB{18,=CH$D0{6,GTN20{JUMP IF NOT DIGIT{24780
{{BGT{8,WB{18,=CH$D9{6,GTN20{JUMP IF NOT DIGIT{24781
{{CVM{6,GTN36{{{ELSE CURRENT*10, SUBTRACT NEW DIGIT{24782
{{BCT{8,WA{6,GTN18{{LOOP BACK IF MORE CHARS{24783
{{BRN{6,GTN21{{{JUMP IF EXPONENT FIELD IS EXHAUSTED{24784
*
*      HERE TO CHECK FOR TRAILING BLANKS AFTER EXPONENT
*
{GTN20{BEQ{8,WB{18,=CH$BL{6,GTNC0{JUMP IF BLANK{24788
{{BEQ{8,WB{18,=CH$HT{6,GTNC0{JUMP IF HORIZONTAL TAB{24790
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{24795
*
{GTNC0{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{24797
{{BCT{8,WA{6,GTN20{{LOOP BACK TILL ALL BLANKS SCANNED{24798
*
*      MERGE HERE AFTER COLLECTING EXPONENT
*
{GTN21{STI{3,GTNEX{{{SAVE COLLECTED EXPONENT{24802
{{BNZ{3,GTNES{6,GTN22{{JUMP IF IT WAS NEGATIVE{24803
{{NGI{{{{ELSE COMPLEMENT{24804
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24805
{{STI{3,GTNEX{{{AND STORE POSITIVE EXPONENT{24806
*
*      MERGE HERE WITH EXPONENT (0 IF NONE GIVEN)
*
{GTN22{BZE{3,GTNRD{6,GTN36{{ERROR IF NOT DIGITS COLLECTED{24810
{{BZE{3,GTNDF{6,GTN36{{ERROR IF NO EXPONENT OR DEC POINT{24811
{{MTI{3,GTNSC{{{ELSE LOAD SCALE AS INTEGER{24812
{{SBI{3,GTNEX{{{SUBTRACT EXPONENT{24813
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24814
{{ILT{6,GTN26{{{JUMP IF WE MUST SCALE UP{24815
*
*      HERE WE HAVE A NEGATIVE EXPONENT, SO SCALE DOWN
*
{{MFI{8,WA{6,GTN36{{LOAD SCALE FACTOR, ERR IF OVFLOW{24819
*
*      LOOP TO SCALE DOWN IN STEPS OF 10**10
*
{GTN23{BLE{8,WA{18,=NUM10{6,GTN24{JUMP IF 10 OR LESS TO GO{24823
{{DVR{4,REATT{{{ELSE DIVIDE BY 10**10{24824
{{SUB{18,=NUM10{8,WA{{DECREMENT SCALE{24825
{{BRN{6,GTN23{{{AND LOOP BACK{24826
{{EJC{{{{{24827
*
*      GTNUM (CONTINUED)
*
*      HERE SCALE REST OF WAY FROM POWERS OF TEN TABLE
*
{GTN24{BZE{8,WA{6,GTN30{{JUMP IF SCALED{24833
{{LCT{8,WB{18,=CFP$R{{ELSE GET INDEXING FACTOR{24834
{{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{24835
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{24836
*
*      LOOP TO POINT TO POWERS OF TEN TABLE ENTRY
*
{GTN25{ADD{8,WA{7,XR{{BUMP POINTER{24840
{{BCT{8,WB{6,GTN25{{ONCE FOR EACH VALUE WORD{24841
{{DVR{9,(XR){{{SCALE DOWN AS REQUIRED{24842
{{BRN{6,GTN30{{{AND JUMP{24843
*
*      COME HERE TO SCALE RESULT UP (POSITIVE EXPONENT)
*
{GTN26{NGI{{{{GET ABSOLUTE VALUE OF EXPONENT{24847
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24848
{{MFI{8,WA{6,GTN36{{ACQUIRE SCALE, ERROR IF OVFLOW{24849
*
*      LOOP TO SCALE UP IN STEPS OF 10**10
*
{GTN27{BLE{8,WA{18,=NUM10{6,GTN28{JUMP IF 10 OR LESS TO GO{24853
{{MLR{4,REATT{{{ELSE MULTIPLY BY 10**10{24854
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{24855
{{SUB{18,=NUM10{8,WA{{ELSE DECREMENT SCALE{24856
{{BRN{6,GTN27{{{AND LOOP BACK{24857
*
*      HERE TO SCALE UP REST OF WAY WITH TABLE
*
{GTN28{BZE{8,WA{6,GTN30{{JUMP IF SCALED{24861
{{LCT{8,WB{18,=CFP$R{{ELSE GET INDEXING FACTOR{24862
{{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{24863
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{24864
*
*      LOOP TO POINT TO PROPER ENTRY IN POWERS OF TEN TABLE
*
{GTN29{ADD{8,WA{7,XR{{BUMP POINTER{24868
{{BCT{8,WB{6,GTN29{{ONCE FOR EACH WORD IN VALUE{24869
{{MLR{9,(XR){{{SCALE UP{24870
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{24871
{{EJC{{{{{24872
*
*      GTNUM (CONTINUED)
*
*      HERE WITH REAL VALUE SCALED AND READY EXCEPT FOR SIGN
*
{GTN30{BZE{3,GTNNF{6,GTN31{{JUMP IF POSITIVE{24878
{{NGR{{{{ELSE NEGATE{24879
*
*      HERE WITH PROPERLY SIGNED REAL VALUE IN (RA)
*
{GTN31{JSR{6,RCBLD{{{BUILD REAL BLOCK{24883
{{BRN{6,GTN33{{{MERGE TO EXIT{24884
*
*      HERE WITH PROPERLY SIGNED INTEGER VALUE IN (IA)
*
{GTN32{JSR{6,ICBLD{{{BUILD ICBLK{24889
*
*      REAL MERGES HERE
*
{GTN33{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF RESULT BLOCK{24893
{{ICA{7,XS{{{POP ARGUMENT OFF STACK{24894
*
*      COMMON EXIT POINT
*
{GTN34{EXI{{{{RETURN TO GTNUM CALLER{24898
*
*      COME HERE IF OVERFLOW OCCURS DURING COLLECTION OF INTEGER
*      HAVE TO RESTORE WB WHICH CVM MAY HAVE DESTROYED.
*
{GTN35{LCH{8,WB{11,-(XR){{RELOAD CURRENT CHARACTER{24905
{{LCH{8,WB{10,(XR)+{{BUMP CHARACTER POINTER{24906
{{LDI{3,GTNSI{{{RELOAD INTEGER SO FAR{24907
{{ITR{{{{CONVERT TO REAL{24908
{{NGR{{{{MAKE VALUE POSITIVE{24909
{{BRN{6,GTN11{{{MERGE WITH REAL CIRCUIT{24910
*
*      HERE FOR UNCONVERTIBLE TO STRING OR CONVERSION ERROR
*
{GTN36{MOV{10,(XS)+{7,XR{{RELOAD ORIGINAL ARGUMENT{24915
{{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{24916
{{ENP{{{{END PROCEDURE GTNUM{24917
{{EJC{{{{{24918
*
*      GTNVR -- CONVERT TO NATURAL VARIABLE
*
*      GTNVR LOCATES A VARIABLE BLOCK (VRBLK) GIVEN EITHER AN
*      APPROPRIATE NAME (NMBLK) OR A NON-NULL STRING (SCBLK).
*
*      (XR)                  ARGUMENT
*      JSR  GTNVR            CALL TO CONVERT TO NATURAL VARIABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO VRBLK
*      (WA,WB)               DESTROYED (CONVERSION ERROR ONLY)
*      (WC)                  DESTROYED
*
{GTNVR{PRC{25,E{1,1{{ENTRY POINT{24932
{{BNE{9,(XR){22,=B$NML{6,GNV02{JUMP IF NOT NAME{24933
{{MOV{13,NMBAS(XR){7,XR{{ELSE LOAD NAME BASE IF NAME{24934
{{BLO{7,XR{3,STATE{6,GNV07{SKIP IF VRBLK (IN STATIC REGION){24935
*
*      COMMON ERROR EXIT
*
{GNV01{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{24939
*
*      HERE IF NOT NAME
*
{GNV02{MOV{8,WA{3,GNVSA{{SAVE WA{24943
{{MOV{8,WB{3,GNVSB{{SAVE WB{24944
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24945
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24946
{{PPM{6,GNV01{{{JUMP IF CONVERSION ERROR{24947
{{BZE{8,WA{6,GNV01{{NULL STRING IS AN ERROR{24948
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{24950
{{MOV{7,XL{11,-(XS){{SAVE XL{24952
{{MOV{7,XR{11,-(XS){{STACK STRING PTR FOR LATER{24953
{{MOV{7,XR{8,WB{{COPY STRING POINTER{24954
{{ADD{19,*SCHAR{8,WB{{POINT TO CHARACTERS OF STRING{24955
{{MOV{8,WB{3,GNVST{{SAVE POINTER TO CHARACTERS{24956
{{MOV{8,WA{8,WB{{COPY LENGTH{24957
{{CTW{8,WB{1,0{{GET NUMBER OF WORDS IN NAME{24958
{{MOV{8,WB{3,GNVNW{{SAVE FOR LATER{24959
{{JSR{6,HASHS{{{COMPUTE HASH INDEX FOR STRING{24960
{{RMI{3,HSHNB{{{COMPUTE HASH OFFSET BY TAKING MOD{24961
{{MFI{8,WC{{{GET AS OFFSET{24962
{{WTB{8,WC{{{CONVERT OFFSET TO BYTES{24963
{{ADD{3,HSHTB{8,WC{{POINT TO PROPER HASH CHAIN{24964
{{SUB{19,*VRNXT{8,WC{{SUBTRACT OFFSET TO MERGE INTO LOOP{24965
{{EJC{{{{{24966
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH HASH CHAIN
*
{GNV03{MOV{8,WC{7,XL{{COPY HASH CHAIN POINTER{24972
{{MOV{13,VRNXT(XL){7,XL{{POINT TO NEXT VRBLK ON CHAIN{24973
{{BZE{7,XL{6,GNV08{{JUMP IF END OF CHAIN{24974
{{MOV{7,XL{8,WC{{SAVE POINTER TO THIS VRBLK{24975
{{BNZ{13,VRLEN(XL){6,GNV04{{JUMP IF NOT SYSTEM VARIABLE{24976
{{MOV{13,VRSVP(XL){7,XL{{ELSE POINT TO SVBLK{24977
{{SUB{19,*VRSOF{7,XL{{ADJUST OFFSET FOR MERGE{24978
*
*      MERGE HERE WITH STRING PTR (LIKE VRBLK) IN XL
*
{GNV04{BNE{8,WA{13,VRLEN(XL){6,GNV03{BACK FOR NEXT VRBLK IF LENGTHS NE{24982
{{ADD{19,*VRCHS{7,XL{{ELSE POINT TO CHARS OF CHAIN ENTRY{24983
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{24984
{{MOV{3,GNVST{7,XR{{POINT TO CHARS OF NEW NAME{24985
*
*      LOOP TO COMPARE CHARACTERS OF THE TWO NAMES
*
{GNV05{CNE{9,(XR){9,(XL){6,GNV03{JUMP IF NO MATCH FOR NEXT VRBLK{24989
{{ICA{7,XR{{{BUMP NEW NAME POINTER{24990
{{ICA{7,XL{{{BUMP VRBLK IN CHAIN NAME POINTER{24991
{{BCT{8,WB{6,GNV05{{ELSE LOOP TILL ALL COMPARED{24992
{{MOV{8,WC{7,XR{{WE HAVE FOUND A MATCH, GET VRBLK{24993
*
*      EXIT POINT AFTER FINDING VRBLK OR BUILDING NEW ONE
*
{GNV06{MOV{3,GNVSA{8,WA{{RESTORE WA{24997
{{MOV{3,GNVSB{8,WB{{RESTORE WB{24998
{{ICA{7,XS{{{POP STRING POINTER{24999
{{MOV{10,(XS)+{7,XL{{RESTORE XL{25000
*
*      COMMON EXIT POINT
*
{GNV07{EXI{{{{RETURN TO GTNVR CALLER{25004
*
*      NOT FOUND, PREPARE TO SEARCH SYSTEM VARIABLE TABLE
*
{GNV08{ZER{7,XR{{{CLEAR GARBAGE XR POINTER{25008
{{MOV{8,WC{3,GNVHE{{SAVE PTR TO END OF HASH CHAIN{25009
{{BGT{8,WA{18,=NUM09{6,GNV14{CANNOT BE SYSTEM VAR IF LENGTH GT 9{25010
{{MOV{8,WA{7,XL{{ELSE COPY LENGTH{25011
{{WTB{7,XL{{{CONVERT TO BYTE OFFSET{25012
{{MOV{14,VSRCH(XL){7,XL{{POINT TO FIRST SVBLK OF THIS LENGTH{25013
{{EJC{{{{{25014
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH ENTRIES IN STANDARD VARIABLE TABLE
*
{GNV09{MOV{7,XL{3,GNVSP{{SAVE TABLE POINTER{25020
{{MOV{10,(XL)+{8,WC{{LOAD SVBIT BIT STRING{25021
{{MOV{10,(XL)+{8,WB{{LOAD LENGTH FROM TABLE ENTRY{25022
{{BNE{8,WA{8,WB{6,GNV14{JUMP IF END OF RIGHT LENGTH ENTRIES{25023
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{25024
{{MOV{3,GNVST{7,XR{{POINT TO CHARS OF NEW NAME{25025
*
*      LOOP TO CHECK FOR MATCHING NAMES
*
{GNV10{CNE{9,(XR){9,(XL){6,GNV11{JUMP IF NAME MISMATCH{25029
{{ICA{7,XR{{{ELSE BUMP NEW NAME POINTER{25030
{{ICA{7,XL{{{BUMP SVBLK POINTER{25031
{{BCT{8,WB{6,GNV10{{ELSE LOOP UNTIL ALL CHECKED{25032
*
*      HERE WE HAVE A MATCH IN THE STANDARD VARIABLE TABLE
*
{{ZER{8,WC{{{SET VRLEN VALUE ZERO{25036
{{MOV{19,*VRSI${8,WA{{SET STANDARD SIZE{25037
{{BRN{6,GNV15{{{JUMP TO BUILD VRBLK{25038
*
*      HERE IF NO MATCH WITH TABLE ENTRY IN SVBLKS TABLE
*
{GNV11{ICA{7,XL{{{BUMP PAST WORD OF CHARS{25042
{{BCT{8,WB{6,GNV11{{LOOP BACK IF MORE TO GO{25043
{{RSH{8,WC{2,SVNBT{{REMOVE UNINTERESTING BITS{25044
*
*      LOOP TO BUMP TABLE PTR FOR EACH FLAGGED WORD
*
{GNV12{MOV{4,BITS1{8,WB{{LOAD BIT TO TEST{25048
{{ANB{8,WC{8,WB{{TEST FOR WORD PRESENT{25049
{{ZRB{8,WB{6,GNV13{{JUMP IF NOT PRESENT{25050
{{ICA{7,XL{{{ELSE BUMP TABLE POINTER{25051
*
*      HERE AFTER DEALING WITH ONE WORD (ONE BIT)
*
{GNV13{RSH{8,WC{1,1{{REMOVE BIT ALREADY PROCESSED{25055
{{NZB{8,WC{6,GNV12{{LOOP BACK IF MORE BITS TO TEST{25056
{{BRN{6,GNV09{{{ELSE LOOP BACK FOR NEXT SVBLK{25057
*
*      HERE IF NOT SYSTEM VARIABLE
*
{GNV14{MOV{8,WA{8,WC{{COPY VRLEN VALUE{25061
{{MOV{18,=VRCHS{8,WA{{LOAD STANDARD SIZE -CHARS{25062
{{ADD{3,GNVNW{8,WA{{ADJUST FOR CHARS OF NAME{25063
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{25064
{{EJC{{{{{25065
*
*      GTNVR (CONTINUED)
*
*      MERGE HERE TO BUILD VRBLK
*
{GNV15{JSR{6,ALOST{{{ALLOCATE SPACE FOR VRBLK (STATIC){25071
{{MOV{7,XR{8,WB{{SAVE VRBLK POINTER{25072
{{MOV{21,=STNVR{7,XL{{POINT TO MODEL VARIABLE BLOCK{25073
{{MOV{19,*VRLEN{8,WA{{SET LENGTH OF STANDARD FIELDS{25074
{{MVW{{{{SET INITIAL FIELDS OF NEW BLOCK{25075
{{MOV{3,GNVHE{7,XL{{LOAD POINTER TO END OF HASH CHAIN{25076
{{MOV{8,WB{13,VRNXT(XL){{ADD NEW BLOCK TO END OF CHAIN{25077
{{MOV{8,WC{10,(XR)+{{SET VRLEN FIELD, BUMP PTR{25078
{{MOV{3,GNVNW{8,WA{{GET LENGTH IN WORDS{25079
{{WTB{8,WA{{{CONVERT TO LENGTH IN BYTES{25080
{{BZE{8,WC{6,GNV16{{JUMP IF SYSTEM VARIABLE{25081
*
*      HERE FOR NON-SYSTEM VARIABLE -- SET CHARS OF NAME
*
{{MOV{9,(XS){7,XL{{POINT BACK TO STRING NAME{25085
{{ADD{19,*SCHAR{7,XL{{POINT TO CHARS OF NAME{25086
{{MVW{{{{MOVE CHARACTERS INTO PLACE{25087
{{MOV{8,WB{7,XR{{RESTORE VRBLK POINTER{25088
{{BRN{6,GNV06{{{JUMP BACK TO EXIT{25089
*
*      HERE FOR SYSTEM VARIABLE CASE TO FILL IN FIELDS WHERE
*      NECESSARY FROM THE FIELDS PRESENT IN THE SVBLK.
*
{GNV16{MOV{3,GNVSP{7,XL{{LOAD POINTER TO SVBLK{25094
{{MOV{7,XL{9,(XR){{SET SVBLK PTR IN VRBLK{25095
{{MOV{8,WB{7,XR{{RESTORE VRBLK POINTER{25096
{{MOV{13,SVBIT(XL){8,WB{{LOAD BIT INDICATORS{25097
{{ADD{19,*SVCHS{7,XL{{POINT TO CHARACTERS OF NAME{25098
{{ADD{8,WA{7,XL{{POINT PAST CHARACTERS{25099
*
*      SKIP PAST KEYWORD NUMBER (SVKNM) IF PRESENT
*
{{MOV{4,BTKNM{8,WC{{LOAD TEST BIT{25103
{{ANB{8,WB{8,WC{{AND TO TEST{25104
{{ZRB{8,WC{6,GNV17{{JUMP IF NO KEYWORD NUMBER{25105
{{ICA{7,XL{{{ELSE BUMP POINTER{25106
{{EJC{{{{{25107
*
*      GTNVR (CONTINUED)
*
*      HERE TEST FOR FUNCTION (SVFNC AND SVNAR)
*
{GNV17{MOV{4,BTFNC{8,WC{{GET TEST BIT{25113
{{ANB{8,WB{8,WC{{AND TO TEST{25114
{{ZRB{8,WC{6,GNV18{{SKIP IF NO SYSTEM FUNCTION{25115
{{MOV{7,XL{13,VRFNC(XR){{ELSE POINT VRFNC TO SVFNC FIELD{25116
{{ADD{19,*NUM02{7,XL{{AND BUMP PAST SVFNC, SVNAR FIELDS{25117
*
*      NOW TEST FOR LABEL (SVLBL)
*
{GNV18{MOV{4,BTLBL{8,WC{{GET TEST BIT{25121
{{ANB{8,WB{8,WC{{AND TO TEST{25122
{{ZRB{8,WC{6,GNV19{{JUMP IF BIT IS OFF (NO SYSTEM LABL){25123
{{MOV{7,XL{13,VRLBL(XR){{ELSE POINT VRLBL TO SVLBL FIELD{25124
{{ICA{7,XL{{{BUMP PAST SVLBL FIELD{25125
*
*      NOW TEST FOR VALUE (SVVAL)
*
{GNV19{MOV{4,BTVAL{8,WC{{LOAD TEST BIT{25129
{{ANB{8,WB{8,WC{{AND TO TEST{25130
{{ZRB{8,WC{6,GNV06{{ALL DONE IF NO VALUE{25131
{{MOV{9,(XL){13,VRVAL(XR){{ELSE SET INITIAL VALUE{25132
{{MOV{22,=B$VRE{13,VRSTO(XR){{SET ERROR STORE ACCESS{25133
{{BRN{6,GNV06{{{MERGE BACK TO EXIT TO CALLER{25134
{{ENP{{{{END PROCEDURE GTNVR{25135
{{EJC{{{{{25136
*
*      GTPAT -- GET PATTERN
*
*      GTPAT IS PASSED AN OBJECT IN (XR) AND RETURNS A
*      PATTERN AFTER PERFORMING ANY NECESSARY CONVERSIONS
*
*      (XR)                  INPUT ARGUMENT
*      JSR  GTPAT            CALL TO CONVERT TO PATTERN
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING PATTERN
*      (WA)                  DESTROYED
*      (WB)                  DESTROYED (ONLY ON CONVERT ERROR)
*      (XR)                  UNCHANGED (ONLY ON CONVERT ERROR)
*
{GTPAT{PRC{25,E{1,1{{ENTRY POINT{25151
{{BHI{9,(XR){22,=P$AAA{6,GTPT5{JUMP IF PATTERN ALREADY{25152
*
*      HERE IF NOT PATTERN, TRY FOR STRING
*
{{MOV{8,WB{3,GTPSB{{SAVE WB{25156
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{25157
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{25158
{{PPM{6,GTPT2{{{JUMP IF IMPOSSIBLE{25159
*
*      HERE WE HAVE A STRING
*
{{BNZ{8,WA{6,GTPT1{{JUMP IF NON-NULL{25163
*
*      HERE FOR NULL STRING. GENERATE POINTER TO NULL PATTERN.
*
{{MOV{21,=NDNTH{7,XR{{POINT TO NOTHEN NODE{25167
{{BRN{6,GTPT4{{{JUMP TO EXIT{25168
{{EJC{{{{{25169
*
*      GTPAT (CONTINUED)
*
*      HERE FOR NON-NULL STRING
*
{GTPT1{MOV{22,=P$STR{8,WB{{LOAD PCODE FOR MULTI-CHAR STRING{25175
{{BNE{8,WA{18,=NUM01{6,GTPT3{JUMP IF MULTI-CHAR STRING{25176
*
*      HERE FOR ONE CHARACTER STRING, SHARE ONE CHARACTER ANY
*
{{PLC{7,XR{{{POINT TO CHARACTER{25180
{{LCH{8,WA{9,(XR){{LOAD CHARACTER{25181
{{MOV{8,WA{7,XR{{SET AS PARM1{25182
{{MOV{22,=P$ANS{8,WB{{POINT TO PCODE FOR 1-CHAR ANY{25183
{{BRN{6,GTPT3{{{JUMP TO BUILD NODE{25184
*
*      HERE IF ARGUMENT IS NOT CONVERTIBLE TO STRING
*
{GTPT2{MOV{22,=P$EXA{8,WB{{SET PCODE FOR EXPRESSION IN CASE{25188
{{BLO{9,(XR){22,=B$E$${6,GTPT3{JUMP TO BUILD NODE IF EXPRESSION{25189
*
*      HERE WE HAVE AN ERROR (CONVERSION IMPOSSIBLE)
*
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25193
*
*      MERGE HERE TO BUILD NODE FOR STRING OR EXPRESSION
*
{GTPT3{JSR{6,PBILD{{{CALL ROUTINE TO BUILD PATTERN NODE{25197
*
*      COMMON EXIT AFTER SUCCESSFUL CONVERSION
*
{GTPT4{MOV{3,GTPSB{8,WB{{RESTORE WB{25201
*
*      MERGE HERE TO EXIT IF NO CONVERSION REQUIRED
*
{GTPT5{EXI{{{{RETURN TO GTPAT CALLER{25205
{{ENP{{{{END PROCEDURE GTPAT{25206
{{EJC{{{{{25209
*
*      GTREA -- GET REAL VALUE
*
*      GTREA IS PASSED AN OBJECT AND RETURNS A REAL VALUE
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTREA            CALL TO CONVERT OBJECT TO REAL
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING REAL
*      (WA,WB,WC,RA)         DESTROYED
*      (XR)                  UNCHANGED (CONVERT ERROR ONLY)
*
{GTREA{PRC{25,E{1,1{{ENTRY POINT{25223
{{MOV{9,(XR){8,WA{{GET FIRST WORD OF BLOCK{25224
{{BEQ{8,WA{22,=B$RCL{6,GTRE2{JUMP IF REAL{25225
{{JSR{6,GTNUM{{{ELSE CONVERT ARGUMENT TO NUMERIC{25226
{{PPM{6,GTRE3{{{JUMP IF UNCONVERTIBLE{25227
{{BEQ{8,WA{22,=B$RCL{6,GTRE2{JUMP IF REAL WAS RETURNED{25228
*
*      HERE FOR CASE OF AN INTEGER TO CONVERT TO REAL
*
{GTRE1{LDI{13,ICVAL(XR){{{LOAD INTEGER{25232
{{ITR{{{{CONVERT TO REAL{25233
{{JSR{6,RCBLD{{{BUILD RCBLK{25234
*
*      EXIT WITH REAL
*
{GTRE2{EXI{{{{RETURN TO GTREA CALLER{25238
*
*      HERE ON CONVERSION ERROR
*
{GTRE3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25242
{{ENP{{{{END PROCEDURE GTREA{25243
{{EJC{{{{{25245
*
*      GTSMI -- GET SMALL INTEGER
*
*      GTSMI IS PASSED A SNOBOL OBJECT AND RETURNS AN ADDRESS
*      INTEGER IN THE RANGE (0 LE N LE DNAMB). SUCH A VALUE CAN
*      ONLY BE DERIVED FROM AN INTEGER IN THE APPROPRIATE RANGE.
*      SMALL INTEGERS NEVER APPEAR AS SNOBOL VALUES. HOWEVER,
*      THEY ARE USED INTERNALLY FOR A VARIETY OF PURPOSES.
*
*      -(XS)                 ARGUMENT TO CONVERT (ON STACK)
*      JSR  GTSMI            CALL TO CONVERT TO SMALL INTEGER
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER
*      PPM  LOC              TRANSFER LOC FOR LT 0, GT DNAMB
*      (XR,WC)               RESULTING SMALL INT (TWO COPIES)
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (WA,WB)               DESTROYED (ON CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSMI{PRC{25,N{1,2{{ENTRY POINT{25265
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{25266
{{BEQ{9,(XR){22,=B$ICL{6,GTSM1{SKIP IF ALREADY AN INTEGER{25267
*
*      HERE IF NOT AN INTEGER
*
{{JSR{6,GTINT{{{CONVERT ARGUMENT TO INTEGER{25271
{{PPM{6,GTSM2{{{JUMP IF CONVERT IS IMPOSSIBLE{25272
*
*      MERGE HERE WITH INTEGER
*
{GTSM1{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{25276
{{MFI{8,WC{6,GTSM3{{MOVE AS ONE WORD, JUMP IF OVFLOW{25277
{{BGT{8,WC{3,MXLEN{6,GTSM3{OR IF TOO LARGE{25278
{{MOV{8,WC{7,XR{{COPY RESULT TO XR{25279
{{EXI{{{{RETURN TO GTSMI CALLER{25280
*
*      HERE IF UNCONVERTIBLE TO INTEGER
*
{GTSM2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{25284
*
*      HERE IF OUT OF RANGE
*
{GTSM3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{25288
{{ENP{{{{END PROCEDURE GTSMI{25289
{{EJC{{{{{25290
*
*      GTSTG -- GET STRING
*
*      GTSTG IS PASSED AN OBJECT AND RETURNS A STRING WITH
*      ANY NECESSARY CONVERSIONS PERFORMED.
*
*      -(XS)                 INPUT ARGUMENT (ON STACK)
*      JSR  GTSTG            CALL TO CONVERT TO STRING
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING STRING
*      (WA)                  LENGTH OF STRING IN CHARACTERS
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSTG{PRC{25,N{1,1{{ENTRY POINT{25356
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT, POP STACK{25357
{{BEQ{9,(XR){22,=B$SCL{6,GTS30{JUMP IF ALREADY A STRING{25358
*
*      HERE IF NOT A STRING ALREADY
*
{GTS01{MOV{7,XR{11,-(XS){{RESTACK ARGUMENT IN CASE ERROR{25362
{{MOV{7,XL{11,-(XS){{SAVE XL{25363
{{MOV{8,WB{3,GTSVB{{SAVE WB{25364
{{MOV{8,WC{3,GTSVC{{SAVE WC{25365
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{25366
{{BEQ{8,WA{22,=B$ICL{6,GTS05{JUMP TO CONVERT INTEGER{25367
{{BEQ{8,WA{22,=B$RCL{6,GTS10{JUMP TO CONVERT REAL{25370
{{BEQ{8,WA{22,=B$NML{6,GTS03{JUMP TO CONVERT NAME{25372
*
*      HERE ON CONVERSION ERROR
*
{GTS02{MOV{10,(XS)+{7,XL{{RESTORE XL{25380
{{MOV{10,(XS)+{7,XR{{RELOAD INPUT ARGUMENT{25381
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25382
{{EJC{{{{{25383
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A NAME (ONLY POSSIBLE IF NATURAL VAR)
*
{GTS03{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{25389
{{BHI{7,XL{3,STATE{6,GTS02{ERROR IF NOT NATURAL VAR (STATIC){25390
{{ADD{19,*VRSOF{7,XL{{ELSE POINT TO POSSIBLE STRING NAME{25391
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH{25392
{{BNZ{8,WA{6,GTS04{{JUMP IF NOT SYSTEM VARIABLE{25393
{{MOV{13,VRSVO(XL){7,XL{{ELSE POINT TO SVBLK{25394
{{MOV{13,SVLEN(XL){8,WA{{AND LOAD NAME LENGTH{25395
*
*      MERGE HERE WITH STRING IN XR, LENGTH IN WA
*
{GTS04{ZER{8,WB{{{SET OFFSET TO ZERO{25399
{{JSR{6,SBSTR{{{USE SBSTR TO COPY STRING{25400
{{BRN{6,GTS29{{{JUMP TO EXIT{25401
*
*      COME HERE TO CONVERT AN INTEGER
*
{GTS05{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{25405
{{MOV{18,=NUM01{3,GTSSF{{SET SIGN FLAG NEGATIVE{25413
{{ILT{6,GTS06{{{SKIP IF INTEGER IS NEGATIVE{25414
{{NGI{{{{ELSE NEGATE INTEGER{25415
{{ZER{3,GTSSF{{{AND RESET NEGATIVE FLAG{25416
{{EJC{{{{{25417
*
*      GTSTG (CONTINUED)
*
*      HERE WITH SIGN FLAG SET AND SIGN FORCED NEGATIVE AS
*      REQUIRED BY THE CVD INSTRUCTION.
*
{GTS06{MOV{3,GTSWK{7,XR{{POINT TO RESULT WORK AREA{25424
{{MOV{18,=NSTMX{8,WB{{INITIALIZE COUNTER TO MAX LENGTH{25425
{{PSC{7,XR{8,WB{{PREPARE TO STORE (RIGHT-LEFT){25426
*
*      LOOP TO CONVERT DIGITS INTO WORK AREA
*
{GTS07{CVD{{{{CONVERT ONE DIGIT INTO WA{25430
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25431
{{DCV{8,WB{{{DECREMENT COUNTER{25432
{{INE{6,GTS07{{{LOOP IF MORE DIGITS TO GO{25433
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25434
*
*      MERGE HERE AFTER CONVERTING INTEGER OR REAL INTO WORK
*      AREA. WB IS SET TO NSTMX - (NUMBER OF CHARS IN RESULT).
*
{GTS08{MOV{18,=NSTMX{8,WA{{GET MAX NUMBER OF CHARACTERS{25440
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF RESULT{25441
{{MOV{8,WA{7,XL{{REMEMBER LENGTH FOR MOVE LATER ON{25442
{{ADD{3,GTSSF{8,WA{{ADD ONE FOR NEGATIVE SIGN IF NEEDED{25443
{{JSR{6,ALOCS{{{ALLOCATE STRING FOR RESULT{25444
{{MOV{7,XR{8,WC{{SAVE RESULT POINTER FOR THE MOMENT{25445
{{PSC{7,XR{{{POINT TO CHARS OF RESULT BLOCK{25446
{{BZE{3,GTSSF{6,GTS09{{SKIP IF POSITIVE{25447
{{MOV{18,=CH$MN{8,WA{{ELSE LOAD NEGATIVE SIGN{25448
{{SCH{8,WA{10,(XR)+{{AND STORE IT{25449
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25450
*
*      HERE AFTER DEALING WITH SIGN
*
{GTS09{MOV{7,XL{8,WA{{RECALL LENGTH TO MOVE{25454
{{MOV{3,GTSWK{7,XL{{POINT TO RESULT WORK AREA{25455
{{PLC{7,XL{8,WB{{POINT TO FIRST RESULT CHARACTER{25456
{{MVC{{{{MOVE CHARS TO RESULT STRING{25457
{{MOV{8,WC{7,XR{{RESTORE RESULT POINTER{25458
{{BRN{6,GTS29{{{JUMP TO EXIT{25461
{{EJC{{{{{25462
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A REAL
*
{GTS10{LDR{13,RCVAL(XR){{{LOAD REAL{25468
{{ZER{3,GTSSF{{{RESET NEGATIVE FLAG{25480
{{REQ{6,GTS31{{{SKIP IF ZERO{25481
{{RGE{6,GTS11{{{JUMP IF REAL IS POSITIVE{25482
{{MOV{18,=NUM01{3,GTSSF{{ELSE SET NEGATIVE FLAG{25483
{{NGR{{{{AND GET ABSOLUTE VALUE OF REAL{25484
*
*      NOW SCALE THE REAL TO THE RANGE (0.1 LE X LT 1.0)
*
{GTS11{LDI{4,INTV0{{{INITIALIZE EXPONENT TO ZERO{25488
*
*      LOOP TO SCALE UP IN STEPS OF 10**10
*
{GTS12{STR{3,GTSRS{{{SAVE REAL VALUE{25492
{{SBR{4,REAP1{{{SUBTRACT 0.1 TO COMPARE{25493
{{RGE{6,GTS13{{{JUMP IF SCALE UP NOT REQUIRED{25494
{{LDR{3,GTSRS{{{ELSE RELOAD VALUE{25495
{{MLR{4,REATT{{{MULTIPLY BY 10**10{25496
{{SBI{4,INTVT{{{DECREMENT EXPONENT BY 10{25497
{{BRN{6,GTS12{{{LOOP BACK TO TEST AGAIN{25498
*
*      TEST FOR SCALE DOWN REQUIRED
*
{GTS13{LDR{3,GTSRS{{{RELOAD VALUE{25502
{{SBR{4,REAV1{{{SUBTRACT 1.0{25503
{{RLT{6,GTS17{{{JUMP IF NO SCALE DOWN REQUIRED{25504
{{LDR{3,GTSRS{{{ELSE RELOAD VALUE{25505
*
*      LOOP TO SCALE DOWN IN STEPS OF 10**10
*
{GTS14{SBR{4,REATT{{{SUBTRACT 10**10 TO COMPARE{25509
{{RLT{6,GTS15{{{JUMP IF LARGE STEP NOT REQUIRED{25510
{{LDR{3,GTSRS{{{ELSE RESTORE VALUE{25511
{{DVR{4,REATT{{{DIVIDE BY 10**10{25512
{{STR{3,GTSRS{{{STORE NEW VALUE{25513
{{ADI{4,INTVT{{{INCREMENT EXPONENT BY 10{25514
{{BRN{6,GTS14{{{LOOP BACK{25515
{{EJC{{{{{25516
*
*      GTSTG (CONTINUED)
*
*      AT THIS POINT WE HAVE (1.0 LE X LT 10**10)
*      COMPLETE SCALING WITH POWERS OF TEN TABLE
*
{GTS15{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{25523
*
*      LOOP TO LOCATE CORRECT ENTRY IN TABLE
*
{GTS16{LDR{3,GTSRS{{{RELOAD VALUE{25527
{{ADI{4,INTV1{{{INCREMENT EXPONENT{25528
{{ADD{19,*CFP$R{7,XR{{POINT TO NEXT ENTRY IN TABLE{25529
{{SBR{9,(XR){{{SUBTRACT IT TO COMPARE{25530
{{RGE{6,GTS16{{{LOOP TILL WE FIND A LARGER ENTRY{25531
{{LDR{3,GTSRS{{{THEN RELOAD THE VALUE{25532
{{DVR{9,(XR){{{AND COMPLETE SCALING{25533
{{STR{3,GTSRS{{{STORE VALUE{25534
*
*      WE ARE NOW SCALED, SO ROUND BY ADDING 0.5 * 10**(-CFP$S)
*
{GTS17{LDR{3,GTSRS{{{GET VALUE AGAIN{25538
{{ADR{3,GTSRN{{{ADD ROUNDING FACTOR{25539
{{STR{3,GTSRS{{{STORE RESULT{25540
*
*      THE ROUNDING OPERATION MAY HAVE PUSHED US UP PAST
*      1.0 AGAIN, SO CHECK ONE MORE TIME.
*
{{SBR{4,REAV1{{{SUBTRACT 1.0 TO COMPARE{25545
{{RLT{6,GTS18{{{SKIP IF OK{25546
{{ADI{4,INTV1{{{ELSE INCREMENT EXPONENT{25547
{{LDR{3,GTSRS{{{RELOAD VALUE{25548
{{DVR{4,REAVT{{{DIVIDE BY 10.0 TO RESCALE{25549
{{BRN{6,GTS19{{{JUMP TO MERGE{25550
*
*      HERE IF ROUNDING DID NOT MUCK UP SCALING
*
{GTS18{LDR{3,GTSRS{{{RELOAD ROUNDED VALUE{25554
{{EJC{{{{{25555
*
*      GTSTG (CONTINUED)
*
*      NOW WE HAVE COMPLETED THE SCALING AS FOLLOWS
*
*      (IA)                  SIGNED EXPONENT
*      (RA)                  SCALED REAL (ABSOLUTE VALUE)
*
*      IF THE EXPONENT IS NEGATIVE OR GREATER THAN CFP$S, THEN
*      WE CONVERT THE NUMBER IN THE FORM.
*
*      (NEG SIGN) 0 . (CPF$S DIGITS) E (EXP SIGN) (EXP DIGITS)
*
*      IF THE EXPONENT IS POSITIVE AND LESS THAN OR EQUAL TO
*      CFP$S, THE NUMBER IS CONVERTED IN THE FORM.
*
*      (NEG SIGN) (EXPONENT DIGITS) . (CFP$S-EXPONENT DIGITS)
*
*      IN BOTH CASES, THE FORMATS OBTAINED FROM THE ABOVE
*      RULES ARE MODIFIED BY DELETING TRAILING ZEROS AFTER THE
*      DECIMAL POINT. THERE ARE NO LEADING ZEROS IN THE EXPONENT
*      AND THE EXPONENT SIGN IS ALWAYS PRESENT.
*
{GTS19{MOV{18,=CFP$S{7,XL{{SET NUM DEC DIGITS = CFP$S{25579
{{MOV{18,=CH$MN{3,GTSES{{SET EXPONENT SIGN NEGATIVE{25580
{{ILT{6,GTS21{{{ALL SET IF EXPONENT IS NEGATIVE{25581
{{MFI{8,WA{{{ELSE FETCH EXPONENT{25582
{{BLE{8,WA{18,=CFP$S{6,GTS20{SKIP IF WE CAN USE SPECIAL FORMAT{25583
{{MTI{8,WA{{{ELSE RESTORE EXPONENT{25584
{{NGI{{{{SET NEGATIVE FOR CVD{25585
{{MOV{18,=CH$PL{3,GTSES{{SET PLUS SIGN FOR EXPONENT SIGN{25586
{{BRN{6,GTS21{{{JUMP TO GENERATE EXPONENT{25587
*
*      HERE IF WE CAN USE THE FORMAT WITHOUT AN EXPONENT
*
{GTS20{SUB{8,WA{7,XL{{COMPUTE DIGITS AFTER DECIMAL POINT{25591
{{LDI{4,INTV0{{{RESET EXPONENT TO ZERO{25592
{{EJC{{{{{25593
*
*      GTSTG (CONTINUED)
*
*      MERGE HERE AS FOLLOWS
*
*      (IA)                  EXPONENT ABSOLUTE VALUE
*      GTSES                 CHARACTER FOR EXPONENT SIGN
*      (RA)                  POSITIVE FRACTION
*      (XL)                  NUMBER OF DIGITS AFTER DEC POINT
*
{GTS21{MOV{3,GTSWK{7,XR{{POINT TO WORK AREA{25604
{{MOV{18,=NSTMX{8,WB{{SET CHARACTER CTR TO MAX LENGTH{25605
{{PSC{7,XR{8,WB{{PREPARE TO STORE (RIGHT TO LEFT){25606
{{IEQ{6,GTS23{{{SKIP EXPONENT IF IT IS ZERO{25607
*
*      LOOP TO GENERATE DIGITS OF EXPONENT
*
{GTS22{CVD{{{{CONVERT A DIGIT INTO WA{25611
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25612
{{DCV{8,WB{{{DECREMENT COUNTER{25613
{{INE{6,GTS22{{{LOOP BACK IF MORE DIGITS TO GO{25614
*
*      HERE GENERATE EXPONENT SIGN AND E
*
{{MOV{3,GTSES{8,WA{{LOAD EXPONENT SIGN{25618
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25619
{{MOV{18,=CH$LE{8,WA{{GET CHARACTER LETTER E{25620
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25621
{{SUB{18,=NUM02{8,WB{{DECREMENT COUNTER FOR SIGN AND E{25622
*
*      HERE TO GENERATE THE FRACTION
*
{GTS23{MLR{3,GTSSC{{{CONVERT REAL TO INTEGER (10**CFP$S){25626
{{RTI{{{{GET INTEGER (OVERFLOW IMPOSSIBLE){25627
{{NGI{{{{NEGATE AS REQUIRED BY CVD{25628
*
*      LOOP TO SUPPRESS TRAILING ZEROS
*
{GTS24{BZE{7,XL{6,GTS27{{JUMP IF NO DIGITS LEFT TO DO{25632
{{CVD{{{{ELSE CONVERT ONE DIGIT{25633
{{BNE{8,WA{18,=CH$D0{6,GTS26{JUMP IF NOT A ZERO{25634
{{DCV{7,XL{{{DECREMENT COUNTER{25635
{{BRN{6,GTS24{{{LOOP BACK FOR NEXT DIGIT{25636
{{EJC{{{{{25637
*
*      GTSTG (CONTINUED)
*
*      LOOP TO GENERATE DIGITS AFTER DECIMAL POINT
*
{GTS25{CVD{{{{CONVERT A DIGIT INTO WA{25643
*
*      MERGE HERE FIRST TIME
*
{GTS26{SCH{8,WA{11,-(XR){{STORE DIGIT{25647
{{DCV{8,WB{{{DECREMENT COUNTER{25648
{{DCV{7,XL{{{DECREMENT COUNTER{25649
{{BNZ{7,XL{6,GTS25{{LOOP BACK IF MORE TO GO{25650
*
*      HERE GENERATE THE DECIMAL POINT
*
{GTS27{MOV{18,=CH$DT{8,WA{{LOAD DECIMAL POINT{25654
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25655
{{DCV{8,WB{{{DECREMENT COUNTER{25656
*
*      HERE GENERATE THE DIGITS BEFORE THE DECIMAL POINT
*
{GTS28{CVD{{{{CONVERT A DIGIT INTO WA{25660
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25661
{{DCV{8,WB{{{DECREMENT COUNTER{25662
{{INE{6,GTS28{{{LOOP BACK IF MORE TO GO{25663
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25664
{{BRN{6,GTS08{{{ELSE JUMP BACK TO EXIT{25665
*
*      EXIT POINT AFTER SUCCESSFUL CONVERSION
*
{GTS29{MOV{10,(XS)+{7,XL{{RESTORE XL{25671
{{ICA{7,XS{{{POP ARGUMENT{25672
{{MOV{3,GTSVB{8,WB{{RESTORE WB{25673
{{MOV{3,GTSVC{8,WC{{RESTORE WC{25674
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTS30{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{25678
{{EXI{{{{RETURN TO CALLER{25679
*
*      HERE TO RETURN STRING FOR REAL ZERO
*
{GTS31{MOV{21,=SCRE0{7,XL{{POINT TO STRING{25685
{{MOV{18,=NUM02{8,WA{{2 CHARS{25686
{{ZER{8,WB{{{ZERO OFFSET{25687
{{JSR{6,SBSTR{{{COPY STRING{25688
{{BRN{6,GTS29{{{RETURN{25689
{{ENP{{{{END PROCEDURE GTSTG{25716
{{EJC{{{{{25717
*
*      GTVAR -- GET VARIABLE FOR I/O/TRACE ASSOCIATION
*
*      GTVAR IS USED TO POINT TO AN ACTUAL VARIABLE LOCATION
*      FOR THE DETACH,INPUT,OUTPUT,TRACE,STOPTR SYSTEM FUNCTIONS
*
*      (XR)                  ARGUMENT TO FUNCTION
*      JSR  GTVAR            CALL TO LOCATE VARIABLE POINTER
*      PPM  LOC              TRANSFER LOC IF NOT OK VARIABLE
*      (XL,WA)               NAME BASE,OFFSET OF VARIABLE
*      (XR,RA)               DESTROYED
*      (WB,WC)               DESTROYED (CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTVAR{PRC{25,E{1,1{{ENTRY POINT{25732
{{BNE{9,(XR){22,=B$NML{6,GTVR2{JUMP IF NOT A NAME{25733
{{MOV{13,NMOFS(XR){8,WA{{ELSE LOAD NAME OFFSET{25734
{{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{25735
{{BEQ{9,(XL){22,=B$EVT{6,GTVR1{ERROR IF EXPRESSION VARIABLE{25736
{{BNE{9,(XL){22,=B$KVT{6,GTVR3{ALL OK IF NOT KEYWORD VARIABLE{25737
*
*      HERE ON CONVERSION ERROR
*
{GTVR1{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25741
*
*      HERE IF NOT A NAME, TRY CONVERT TO NATURAL VARIABLE
*
{GTVR2{MOV{8,WC{3,GTVRC{{SAVE WC{25745
{{JSR{6,GTNVR{{{LOCATE VRBLK IF POSSIBLE{25746
{{PPM{6,GTVR1{{{JUMP IF CONVERT ERROR{25747
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK NAME BASE{25748
{{MOV{19,*VRVAL{8,WA{{AND SET OFFSET{25749
{{MOV{3,GTVRC{8,WC{{RESTORE WC{25750
*
*      HERE FOR NAME OBTAINED
*
{GTVR3{BHI{7,XL{3,STATE{6,GTVR4{ALL OK IF NOT NATURAL VARIABLE{25754
{{BEQ{13,VRSTO(XL){22,=B$VRE{6,GTVR1{ERROR IF PROTECTED VARIABLE{25755
*
*      COMMON EXIT POINT
*
{GTVR4{EXI{{{{RETURN TO CALLER{25759
{{ENP{{{{END PROCEDURE GTVAR{25760
{{EJC{{{{{25761
*
*      HASHS -- COMPUTE HASH INDEX FOR STRING
*
*      HASHS IS USED TO CONVERT A STRING TO A UNIQUE INTEGER
*      VALUE. THE RESULTING HASH VALUE IS A POSITIVE INTEGER
*      IN THE RANGE 0 TO CFP$M
*
*      (XR)                  STRING TO BE HASHED
*      JSR  HASHS            CALL TO HASH STRING
*      (IA)                  HASH VALUE
*      (XR,WB,WC)            DESTROYED
*
*      THE HASH FUNCTION USED IS AS FOLLOWS.
*
*      START WITH THE LENGTH OF THE STRING (SGD07)
*
*      TAKE THE FIRST E$HNW WORDS OF THE CHARACTERS FROM
*      THE STRING OR ALL THE WORDS IF FEWER THAN E$HNW.
*
*      COMPUTE THE EXCLUSIVE OR OF ALL THESE WORDS TREATING
*      THEM AS ONE WORD BIT STRING VALUES.
*
*      MOVE THE RESULT AS AN INTEGER WITH THE MTI INSTRUCTION.
*
{HASHS{PRC{25,E{1,0{{ENTRY POINT{25786
{{MOV{13,SCLEN(XR){8,WC{{LOAD STRING LENGTH IN CHARACTERS{25787
{{MOV{8,WC{8,WB{{INITIALIZE WITH LENGTH{25788
{{BZE{8,WC{6,HSHS3{{JUMP IF NULL STRING{25789
{{ZGB{8,WB{{{CORRECT BYTE ORDERING IF NECESSARY{25790
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS OF CHARS{25791
{{ADD{19,*SCHAR{7,XR{{POINT TO CHARACTERS OF STRING{25792
{{BLO{8,WC{18,=E$HNW{6,HSHS1{USE WHOLE STRING IF SHORT{25793
{{MOV{18,=E$HNW{8,WC{{ELSE SET TO INVOLVE FIRST E$HNW WDS{25794
*
*      HERE WITH COUNT OF WORDS TO CHECK IN WC
*
{HSHS1{LCT{8,WC{8,WC{{SET COUNTER TO CONTROL LOOP{25798
*
*      LOOP TO COMPUTE EXCLUSIVE OR
*
{HSHS2{XOB{10,(XR)+{8,WB{{EXCLUSIVE OR NEXT WORD OF CHARS{25802
{{BCT{8,WC{6,HSHS2{{LOOP TILL ALL PROCESSED{25803
*
*      MERGE HERE WITH EXCLUSIVE OR IN WB
*
{HSHS3{ZGB{8,WB{{{ZEROISE UNDEFINED BITS{25807
{{ANB{4,BITSM{8,WB{{ENSURE IN RANGE 0 TO CFP$M{25808
{{MTI{8,WB{{{MOVE RESULT AS INTEGER{25809
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{25810
{{EXI{{{{RETURN TO HASHS CALLER{25811
{{ENP{{{{END PROCEDURE HASHS{25812
{{EJC{{{{{25813
*
*      ICBLD -- BUILD INTEGER BLOCK
*
*      (IA)                  INTEGER VALUE FOR ICBLK
*      JSR  ICBLD            CALL TO BUILD INTEGER BLOCK
*      (XR)                  POINTER TO RESULT ICBLK
*      (WA)                  DESTROYED
*
{ICBLD{PRC{25,E{1,0{{ENTRY POINT{25822
{{MFI{7,XR{6,ICBL1{{COPY SMALL INTEGERS{25823
{{BLE{7,XR{18,=NUM02{6,ICBL3{JUMP IF 0,1 OR 2{25824
*
*      CONSTRUCT ICBLK
*
{ICBL1{MOV{3,DNAMP{7,XR{{LOAD POINTER TO NEXT AVAILABLE LOC{25828
{{ADD{19,*ICSI${7,XR{{POINT PAST NEW ICBLK{25829
{{BLO{7,XR{3,DNAME{6,ICBL2{JUMP IF THERE IS ROOM{25830
{{MOV{19,*ICSI${8,WA{{ELSE LOAD LENGTH OF ICBLK{25831
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{25832
{{ADD{8,WA{7,XR{{POINT PAST BLOCK TO MERGE{25833
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{ICBL2{MOV{7,XR{3,DNAMP{{SET NEW POINTER{25837
{{SUB{19,*ICSI${7,XR{{POINT BACK TO START OF BLOCK{25838
{{MOV{22,=B$ICL{9,(XR){{STORE TYPE WORD{25839
{{STI{13,ICVAL(XR){{{STORE INTEGER VALUE IN ICBLK{25840
{{EXI{{{{RETURN TO ICBLD CALLER{25841
*
*      OPTIMISE BY NOT BUILDING ICBLKS FOR SMALL INTEGERS
*
{ICBL3{WTB{7,XR{{{CONVERT INTEGER TO OFFSET{25845
{{MOV{14,INTAB(XR){7,XR{{POINT TO PRE-BUILT ICBLK{25846
{{EXI{{{{RETURN{25847
{{ENP{{{{END PROCEDURE ICBLD{25848
{{EJC{{{{{25849
*
*      IDENT -- COMPARE TWO VALUES
*
*      IDENT COMPARES TWO VALUES IN THE SENSE OF THE IDENT
*      DIFFER FUNCTIONS AVAILABLE AT THE SNOBOL LEVEL.
*
*      (XR)                  FIRST ARGUMENT
*      (XL)                  SECOND ARGUMENT
*      JSR  IDENT            CALL TO COMPARE ARGUMENTS
*      PPM  LOC              TRANSFER LOC IF IDENT
*      (NORMAL RETURN IF DIFFER)
*      (XR,XL,WC,RA)         DESTROYED
*
{IDENT{PRC{25,E{1,1{{ENTRY POINT{25863
{{BEQ{7,XR{7,XL{6,IDEN7{JUMP IF SAME POINTER (IDENT){25864
{{MOV{9,(XR){8,WC{{ELSE LOAD ARG 1 TYPE WORD{25865
{{BNE{8,WC{9,(XL){6,IDEN1{DIFFER IF ARG 2 TYPE WORD DIFFER{25867
{{BEQ{8,WC{22,=B$SCL{6,IDEN2{JUMP IF STRINGS{25871
{{BEQ{8,WC{22,=B$ICL{6,IDEN4{JUMP IF INTEGERS{25872
{{BEQ{8,WC{22,=B$RCL{6,IDEN5{JUMP IF REALS{25875
{{BEQ{8,WC{22,=B$NML{6,IDEN6{JUMP IF NAMES{25877
*
*      FOR ALL OTHER DATATYPES, MUST BE DIFFER IF XR NE XL
*
*      MERGE HERE FOR DIFFER
*
{IDEN1{EXI{{{{TAKE DIFFER EXIT{25920
*
*      HERE FOR STRINGS, IDENT ONLY IF LENGTHS AND CHARS SAME
*
{IDEN2{MOV{13,SCLEN(XR){8,WC{{LOAD ARG 1 LENGTH{25924
{{BNE{8,WC{13,SCLEN(XL){6,IDEN1{DIFFER IF LENGTHS DIFFER{25925
*
*      BUFFER AND STRING COMPARISONS MERGE HERE
*
{IDN2A{ADD{19,*SCHAR{7,XR{{POINT TO CHARS OF ARG 1{25929
{{ADD{19,*SCHAR{7,XL{{POINT TO CHARS OF ARG 2{25930
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN STRINGS{25931
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{25932
*
*      LOOP TO COMPARE CHARACTERS. NOTE THAT WC CANNOT BE ZERO
*      SINCE ALL NULL STRINGS POINT TO NULLS AND GIVE XL=XR.
*
{IDEN3{CNE{9,(XR){9,(XL){6,IDEN8{DIFFER IF CHARS DO NOT MATCH{25937
{{ICA{7,XR{{{ELSE BUMP ARG ONE POINTER{25938
{{ICA{7,XL{{{BUMP ARG TWO POINTER{25939
{{BCT{8,WC{6,IDEN3{{LOOP BACK TILL ALL CHECKED{25940
{{EJC{{{{{25941
*
*      IDENT (CONTINUED)
*
*      HERE TO EXIT FOR CASE OF TWO IDENT STRINGS
*
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{25947
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{25948
{{EXI{1,1{{{TAKE IDENT EXIT{25949
*
*      HERE FOR INTEGERS, IDENT IF SAME VALUES
*
{IDEN4{LDI{13,ICVAL(XR){{{LOAD ARG 1{25953
{{SBI{13,ICVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{25954
{{IOV{6,IDEN1{{{DIFFER IF OVERFLOW{25955
{{INE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{25956
{{EXI{1,1{{{TAKE IDENT EXIT{25957
*
*      HERE FOR REALS, IDENT IF SAME VALUES
*
{IDEN5{LDR{13,RCVAL(XR){{{LOAD ARG 1{25963
{{SBR{13,RCVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{25964
{{ROV{6,IDEN1{{{DIFFER IF OVERFLOW{25965
{{RNE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{25966
{{EXI{1,1{{{TAKE IDENT EXIT{25967
*
*      HERE FOR NAMES, IDENT IF BASES AND OFFSETS SAME
*
{IDEN6{BNE{13,NMOFS(XR){13,NMOFS(XL){6,IDEN1{DIFFER IF DIFFERENT OFFSET{25972
{{BNE{13,NMBAS(XR){13,NMBAS(XL){6,IDEN1{DIFFER IF DIFFERENT BASE{25973
*
*      MERGE HERE TO SIGNAL IDENT FOR IDENTICAL POINTERS
*
{IDEN7{EXI{1,1{{{TAKE IDENT EXIT{25977
*
*      HERE FOR DIFFER STRINGS
*
{IDEN8{ZER{7,XR{{{CLEAR GARBAGE PTR IN XR{25981
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{25982
{{EXI{{{{RETURN TO CALLER (DIFFER){25983
{{ENP{{{{END PROCEDURE IDENT{25984
{{EJC{{{{{25985
*
*      INOUT - USED TO INITIALISE INPUT AND OUTPUT VARIABLES
*
*      (XL)                  POINTER TO VBL NAME STRING
*      (WB)                  TRBLK TYPE
*      JSR  INOUT            CALL TO PERFORM INITIALISATION
*      (XL)                  VRBLK PTR
*      (XR)                  TRBLK PTR
*      (WA,WC)               DESTROYED
*
*      NOTE THAT TRTER (= TRTRF) FIELD OF STANDARD I/O VARIABLES
*      POINTS TO CORRESPONDING SVBLK NOT TO A TRBLK AS IS THE
*      CASE FOR ORDINARY VARIABLES.
*
{INOUT{PRC{25,E{1,0{{ENTRY POINT{26000
{{MOV{8,WB{11,-(XS){{STACK TRBLK TYPE{26001
{{MOV{13,SCLEN(XL){8,WA{{GET NAME LENGTH{26002
{{ZER{8,WB{{{POINT TO START OF NAME{26003
{{JSR{6,SBSTR{{{BUILD A PROPER SCBLK{26004
{{JSR{6,GTNVR{{{BUILD VRBLK{26005
{{PPM{{{{NO ERROR RETURN{26006
{{MOV{7,XR{8,WC{{SAVE VRBLK POINTER{26007
{{MOV{10,(XS)+{8,WB{{GET TRTER FIELD{26008
{{ZER{7,XL{{{ZERO TRFPT{26009
{{JSR{6,TRBLD{{{BUILD TRBLK{26010
{{MOV{8,WC{7,XL{{RECALL VRBLK POINTER{26011
{{MOV{13,VRSVP(XL){13,TRTER(XR){{STORE SVBLK POINTER{26012
{{MOV{7,XR{13,VRVAL(XL){{STORE TRBLK PTR IN VRBLK{26013
{{MOV{22,=B$VRA{13,VRGET(XL){{SET TRAPPED ACCESS{26014
{{MOV{22,=B$VRV{13,VRSTO(XL){{SET TRAPPED STORE{26015
{{EXI{{{{RETURN TO CALLER{26016
{{ENP{{{{END PROCEDURE INOUT{26017
{{EJC{{{{{26018
*
*      INSTA - USED TO INITIALIZE STRUCTURES IN STATIC REGION
*
*      (XR)                  POINTER TO STARTING STATIC LOCATION
*      JSR  INSTA            CALL TO INITIALIZE STATIC STRUCTURE
*      (XR)                  PTR TO NEXT FREE STATIC LOCATION
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT THIS PROCEDURE ESTABLISHES THE POINTERS
*      PRBUF, GTSWK, AND KVALP.
*
{INSTA{PRC{25,E{1,0{{ENTRY POINT{26197
*
*      INITIALIZE PRINT BUFFER WITH BLANK WORDS
*
{{MOV{3,PRLEN{8,WC{{NO. OF CHARS IN PRINT BFR{26201
{{MOV{7,XR{3,PRBUF{{PRINT BFR IS PUT AT STATIC START{26202
{{MOV{22,=B$SCL{10,(XR)+{{STORE STRING TYPE CODE{26203
{{MOV{8,WC{10,(XR)+{{AND STRING LENGTH{26204
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN BUFFER{26205
{{MOV{8,WC{3,PRLNW{{STORE FOR BUFFER CLEAR{26206
{{LCT{8,WC{8,WC{{WORDS TO CLEAR{26207
*
*      LOOP TO CLEAR BUFFER
*
{INST1{MOV{4,NULLW{10,(XR)+{{STORE BLANK{26211
{{BCT{8,WC{6,INST1{{LOOP{26212
*
*      ALLOCATE WORK AREA FOR GTSTG CONVERSION PROCEDURE
*
{{MOV{18,=NSTMX{8,WA{{GET MAX NUM CHARS IN OUTPUT NUMBER{26216
{{CTB{8,WA{2,SCSI${{NO OF BYTES NEEDED{26217
{{MOV{7,XR{3,GTSWK{{STORE BFR ADRS{26218
{{ADD{8,WA{7,XR{{BUMP FOR WORK BFR{26219
*
*      BUILD ALPHABET STRING FOR ALPHABET KEYWORD AND REPLACE
*
{{MOV{7,XR{3,KVALP{{SAVE ALPHABET POINTER{26223
{{MOV{22,=B$SCL{9,(XR){{STRING BLK TYPE{26224
{{MOV{18,=CFP$A{8,WC{{NO OF CHARS IN ALPHABET{26225
{{MOV{8,WC{13,SCLEN(XR){{STORE AS STRING LENGTH{26226
{{MOV{8,WC{8,WB{{COPY CHAR COUNT{26227
{{CTB{8,WB{2,SCSI${{NO. OF BYTES NEEDED{26228
{{ADD{7,XR{8,WB{{CURRENT END ADDRESS FOR STATIC{26229
{{MOV{8,WB{8,WA{{SAVE ADRS PAST ALPHABET STRING{26230
{{LCT{8,WC{8,WC{{LOOP COUNTER{26231
{{PSC{7,XR{{{POINT TO CHARS OF STRING{26232
{{ZER{8,WB{{{SET INITIAL CHARACTER VALUE{26233
*
*      LOOP TO ENTER CHARACTER CODES IN ORDER
*
{INST2{SCH{8,WB{10,(XR)+{{STORE NEXT CODE{26237
{{ICV{8,WB{{{BUMP CODE VALUE{26238
{{BCT{8,WC{6,INST2{{LOOP TILL ALL STORED{26239
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{26240
{{MOV{8,WA{7,XR{{RETURN CURRENT STATIC PTR{26241
{{EXI{{{{RETURN TO CALLER{26242
{{ENP{{{{END PROCEDURE INSTA{26243
{{EJC{{{{{26244
*
*      IOFCB -- GET INPUT/OUTPUT FCBLK POINTER
*
*      USED BY ENDFILE, EJECT AND REWIND TO FIND THE FCBLK
*      (IF ANY) CORRESPONDING TO THEIR ARGUMENT.
*
*      -(XS)                 ARGUMENT
*      JSR  IOFCB            CALL TO FIND FCBLK
*      PPM  LOC              ARG IS AN UNSUITABLE NAME
*      PPM  LOC              ARG IS NULL STRING
*      PPM  LOC              ARG FILE NOT FOUND
*      (XS)                  POPPED
*      (XL)                  PTR TO FILEARG1 VRBLK
*      (XR)                  ARGUMENT
*      (WA)                  FCBLK PTR OR 0
*      (WB,WC)               DESTROYED
*
{IOFCB{PRC{25,N{1,3{{ENTRY POINT{26262
{{JSR{6,GTSTG{{{GET ARG AS STRING{26263
{{PPM{6,IOFC2{{{FAIL{26264
{{MOV{7,XR{7,XL{{COPY STRING PTR{26265
{{JSR{6,GTNVR{{{GET AS NATURAL VARIABLE{26266
{{PPM{6,IOFC3{{{FAIL IF NULL{26267
{{MOV{7,XL{8,WB{{COPY STRING POINTER AGAIN{26268
{{MOV{7,XR{7,XL{{COPY VRBLK PTR FOR RETURN{26269
{{ZER{8,WA{{{IN CASE NO TRBLK FOUND{26270
*
*      LOOP TO FIND FILE ARG1 TRBLK
*
{IOFC1{MOV{13,VRVAL(XR){7,XR{{GET POSSIBLE TRBLK PTR{26274
{{BNE{9,(XR){22,=B$TRT{6,IOFC4{FAIL IF END OF CHAIN{26275
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOFC1{LOOP IF NOT FILE ARG TRBLK{26276
{{MOV{13,TRFPT(XR){8,WA{{GET FCBLK PTR{26277
{{MOV{8,WB{7,XR{{COPY ARG{26278
{{EXI{{{{RETURN{26279
*
*      FAIL RETURN
*
{IOFC2{EXI{1,1{{{FAIL{26283
*
*      NULL ARG
*
{IOFC3{EXI{1,2{{{NULL ARG RETURN{26287
*
*      FILE NOT FOUND
*
{IOFC4{EXI{1,3{{{FILE NOT FOUND RETURN{26291
{{ENP{{{{END PROCEDURE IOFCB{26292
{{EJC{{{{{26293
*
*      IOPPF -- PROCESS FILEARG2 FOR IOPUT
*
*      (R$XSC)               FILEARG2 PTR
*      JSR  IOPPF            CALL TO PROCESS FILEARG2
*      (XL)                  FILEARG1 PTR
*      (XR)                  FILE ARG2 PTR
*      -(XS)...-(XS)         FIELDS EXTRACTED FROM FILEARG2
*      (WC)                  NO. OF FIELDS EXTRACTED
*      (WB)                  INPUT/OUTPUT FLAG
*      (WA)                  FCBLK PTR OR 0
*
{IOPPF{PRC{25,N{1,0{{ENTRY POINT{26306
{{ZER{8,WB{{{TO COUNT FIELDS EXTRACTED{26307
*
*      LOOP TO EXTRACT FIELDS
*
{IOPP1{MOV{18,=IODEL{7,XL{{GET DELIMITER{26311
{{MOV{7,XL{8,WC{{COPY IT{26312
{{ZER{8,WA{{{RETAIN LEADING BLANKS IN FILEARG2{26313
{{JSR{6,XSCAN{{{GET NEXT FIELD{26314
{{MOV{7,XR{11,-(XS){{STACK IT{26315
{{ICV{8,WB{{{INCREMENT COUNT{26316
{{BNZ{8,WA{6,IOPP1{{LOOP{26317
{{MOV{8,WB{8,WC{{COUNT OF FIELDS{26318
{{MOV{3,IOPTT{8,WB{{I/O MARKER{26319
{{MOV{3,R$IOF{8,WA{{FCBLK PTR OR 0{26320
{{MOV{3,R$IO2{7,XR{{FILE ARG2 PTR{26321
{{MOV{3,R$IO1{7,XL{{FILEARG1{26322
{{EXI{{{{RETURN{26323
{{ENP{{{{END PROCEDURE IOPPF{26324
{{EJC{{{{{26325
*
*      IOPUT -- ROUTINE USED BY INPUT AND OUTPUT
*
*      IOPUT SETS UP INPUT/OUTPUT  ASSOCIATIONS. IT BUILDS
*      SUCH TRACE AND FILE CONTROL BLOCKS AS ARE NECESSARY AND
*      CALLS SYSFC,SYSIO TO PERFORM CHECKS ON THE
*      ARGUMENTS AND TO OPEN THE FILES.
*
*         +-----------+   +---------------+       +-----------+
*      +-.I           I   I               I------.I   =B$XRT  I
*      I  +-----------+   +---------------+       +-----------+
*      I  /           /        (R$FCB)            I    *4     I
*      I  /           /                           +-----------+
*      I  +-----------+   +---------------+       I           I-
*      I  I   NAME    +--.I    =B$TRT     I       +-----------+
*      I  /           /   +---------------+       I           I
*      I   (FIRST ARG)    I =TRTIN/=TRTOU I       +-----------+
*      I                  +---------------+             I
*      I                  I     VALUE     I             I
*      I                  +---------------+             I
*      I                  I(TRTRF) 0   OR I--+          I
*      I                  +---------------+  I          I
*      I                  I(TRFPT) 0   OR I----+        I
*      I                  +---------------+  I I        I
*      I                     (I/O TRBLK)     I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+   +---------------+  I I        I
*      I  I           +--.I    =B$TRT     I.-+ I        I
*      I  +-----------+   +---------------+    I        I
*      I  /           /   I    =TRTFC     I    I        I
*      I  /           /   +---------------+    I        I
*      I    (FILEARG1     I     VALUE     I    I        I
*      I         VRBLK)   +---------------+    I        I
*      I                  I(TRTRF) 0   OR I--+ I        .
*      I                  +---------------+  I .  +-----------+
*      I                  I(TRFPT) 0   OR I------./   FCBLK   /
*      I                  +---------------+  I    +-----------+
*      I                       (TRTRF)       I
*      I                                     I
*      I                                     I
*      I                  +---------------+  I
*      I                  I    =B$XRT     I.-+
*      I                  +---------------+
*      I                  I      *5       I
*      I                  +---------------+
*      +------------------I               I
*                         +---------------+       +-----------+
*                         I(TRTRF) O   OR I------.I  =B$XRT   I
*                         +---------------+       +-----------+
*                         I  NAME OFFSET  I       I    ETC    I
*                         +---------------+
*                           (IOCHN - CHAIN OF NAME POINTERS)
{{EJC{{{{{26381
*
*      IOPUT (CONTINUED)
*
*      NO ADDITIONAL TRAP BLOCKS ARE USED FOR STANDARD INPUT/OUT
*      FILES. OTHERWISE AN I/O TRAP BLOCK IS ATTACHED TO SECOND
*      ARG (FILEARG1) VRBLK. SEE DIAGRAM ABOVE FOR DETAILS OF
*      THE STRUCTURE BUILT.
*
*      -(XS)                 1ST ARG (VBL TO BE ASSOCIATED)
*      -(XS)                 2ND ARG (FILE ARG1)
*      -(XS)                 3RD ARG (FILE ARG2)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT ASSOC.
*      JSR  IOPUT            CALL FOR INPUT/OUTPUT ASSOCIATION
*      PPM  LOC              3RD ARG NOT A STRING
*      PPM  LOC              2ND ARG NOT A SUITABLE NAME
*      PPM  LOC              1ST ARG NOT A SUITABLE NAME
*      PPM  LOC              INAPPROPRIATE FILE SPEC FOR I/O
*      PPM  LOC              I/O FILE DOES NOT EXIST
*      PPM  LOC              I/O FILE CANNOT BE READ/WRITTEN
*      PPM  LOC              I/O FCBLK CURRENTLY IN USE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{IOPUT{PRC{25,N{1,7{{ENTRY POINT{26405
{{ZER{3,R$IOT{{{IN CASE NO TRTRF BLOCK USED{26406
{{ZER{3,R$IOF{{{IN CASE NO FCBLK ALOCATED{26407
{{ZER{3,R$IOP{{{IN CASE SYSIO FAILS{26408
{{MOV{8,WB{3,IOPTT{{STORE I/O TRACE TYPE{26409
{{JSR{6,XSCNI{{{PREPARE TO SCAN FILEARG2{26410
{{PPM{6,IOP13{{{FAIL{26411
{{PPM{6,IOPA0{{{NULL FILE ARG2{26412
*
{IOPA0{MOV{7,XR{3,R$IO2{{KEEP FILE ARG2{26414
{{MOV{8,WA{7,XL{{COPY LENGTH{26415
{{JSR{6,GTSTG{{{CONVERT FILEARG1 TO STRING{26416
{{PPM{6,IOP14{{{FAIL{26417
{{MOV{7,XR{3,R$IO1{{KEEP FILEARG1 PTR{26418
{{JSR{6,GTNVR{{{CONVERT TO NATURAL VARIABLE{26419
{{PPM{6,IOP00{{{JUMP IF NULL{26420
{{BRN{6,IOP04{{{JUMP TO PROCESS NON-NULL ARGS{26421
*
*      NULL FILEARG1
*
{IOP00{BZE{7,XL{6,IOP01{{SKIP IF BOTH ARGS NULL{26425
{{JSR{6,IOPPF{{{PROCESS FILEARG2{26426
{{JSR{6,SYSFC{{{CALL FOR FILEARG2 CHECK{26427
{{PPM{6,IOP16{{{FAIL{26428
{{PPM{6,IOP26{{{FAIL{26429
{{BRN{6,IOP11{{{COMPLETE FILE ASSOCIATION{26430
{{EJC{{{{{26431
*
*      IOPUT (CONTINUED)
*
*      HERE WITH 0 OR FCBLK PTR IN (XL)
*
{IOP01{MOV{3,IOPTT{8,WB{{GET TRACE TYPE{26437
{{MOV{3,R$IOT{7,XR{{GET 0 OR TRTRF PTR{26438
{{JSR{6,TRBLD{{{BUILD TRBLK{26439
{{MOV{7,XR{8,WC{{COPY TRBLK POINTER{26440
{{MOV{10,(XS)+{7,XR{{GET VARIABLE FROM STACK{26441
{{MOV{8,WC{11,-(XS){{MAKE TRBLK COLLECTABLE{26442
{{JSR{6,GTVAR{{{POINT TO VARIABLE{26443
{{PPM{6,IOP15{{{FAIL{26444
{{MOV{10,(XS)+{8,WC{{RECOVER TRBLK POINTER{26445
{{MOV{7,XL{3,R$ION{{SAVE NAME POINTER{26446
{{MOV{7,XL{7,XR{{COPY NAME POINTER{26447
{{ADD{8,WA{7,XR{{POINT TO VARIABLE{26448
{{SUB{19,*VRVAL{7,XR{{SUBTRACT OFFSET,MERGE INTO LOOP{26449
*
*      LOOP TO END OF TRBLK CHAIN IF ANY
*
{IOP02{MOV{7,XR{7,XL{{COPY BLK PTR{26453
{{MOV{13,VRVAL(XR){7,XR{{LOAD PTR TO NEXT TRBLK{26454
{{BNE{9,(XR){22,=B$TRT{6,IOP03{JUMP IF NOT TRAPPED{26455
{{BNE{13,TRTYP(XR){3,IOPTT{6,IOP02{LOOP IF NOT SAME ASSOCN{26456
{{MOV{13,TRNXT(XR){7,XR{{GET VALUE AND DELETE OLD TRBLK{26457
*
*      IOPUT (CONTINUED)
*
*      STORE NEW ASSOCIATION
*
{IOP03{MOV{8,WC{13,VRVAL(XL){{LINK TO THIS TRBLK{26463
{{MOV{8,WC{7,XL{{COPY POINTER{26464
{{MOV{7,XR{13,TRNXT(XL){{STORE VALUE IN TRBLK{26465
{{MOV{3,R$ION{7,XR{{RESTORE POSSIBLE VRBLK POINTER{26466
{{MOV{8,WA{8,WB{{KEEP OFFSET TO NAME{26467
{{JSR{6,SETVR{{{IF VRBLK, SET VRGET,VRSTO{26468
{{MOV{3,R$IOT{7,XR{{GET 0 OR TRTRF PTR{26469
{{BNZ{7,XR{6,IOP19{{JUMP IF TRTRF BLOCK EXISTS{26470
{{EXI{{{{RETURN TO CALLER{26471
*
*      NON STANDARD FILE
*      SEE IF AN FCBLK HAS ALREADY BEEN ALLOCATED.
*
{IOP04{ZER{8,WA{{{IN CASE NO FCBLK FOUND{26476
{{EJC{{{{{26477
*
*      IOPUT (CONTINUED)
*
*      SEARCH POSSIBLE TRBLK CHAIN TO PICK UP THE FCBLK
*
{IOP05{MOV{7,XR{8,WB{{REMEMBER BLK PTR{26483
{{MOV{13,VRVAL(XR){7,XR{{CHAIN ALONG{26484
{{BNE{9,(XR){22,=B$TRT{6,IOP06{JUMP IF END OF TRBLK CHAIN{26485
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOP05{LOOP IF MORE TO GO{26486
{{MOV{7,XR{3,R$IOT{{POINT TO FILE ARG1 TRBLK{26487
{{MOV{13,TRFPT(XR){8,WA{{GET FCBLK PTR FROM TRBLK{26488
*
*      WA = 0 OR FCBLK PTR
*      WB = PTR TO PRECEDING BLK TO WHICH ANY TRTRF BLOCK
*           FOR FILE ARG1 MUST BE CHAINED.
*
{IOP06{MOV{8,WA{3,R$IOF{{KEEP POSSIBLE FCBLK PTR{26494
{{MOV{8,WB{3,R$IOP{{KEEP PRECEDING BLK PTR{26495
{{JSR{6,IOPPF{{{PROCESS FILEARG2{26496
{{JSR{6,SYSFC{{{SEE IF FCBLK REQUIRED{26497
{{PPM{6,IOP16{{{FAIL{26498
{{PPM{6,IOP26{{{FAIL{26499
{{BZE{8,WA{6,IOP12{{SKIP IF NO NEW FCBLK WANTED{26500
{{BLT{8,WC{18,=NUM02{6,IOP6A{JUMP IF FCBLK IN DYNAMIC{26501
{{JSR{6,ALOST{{{GET IT IN STATIC{26502
{{BRN{6,IOP6B{{{SKIP{26503
*
*      OBTAIN FCBLK IN DYNAMIC
*
{IOP6A{JSR{6,ALLOC{{{GET SPACE FOR FCBLK{26507
*
*      MERGE
*
{IOP6B{MOV{7,XR{7,XL{{POINT TO FCBLK{26511
{{MOV{8,WA{8,WB{{COPY ITS LENGTH{26512
{{BTW{8,WB{{{GET COUNT AS WORDS (SGD APR80){26513
{{LCT{8,WB{8,WB{{LOOP COUNTER{26514
*
*      CLEAR FCBLK
*
{IOP07{ZER{10,(XR)+{{{CLEAR A WORD{26518
{{BCT{8,WB{6,IOP07{{LOOP{26519
{{BEQ{8,WC{18,=NUM02{6,IOP09{SKIP IF IN STATIC - DONT SET FIELDS{26520
{{MOV{22,=B$XNT{9,(XL){{STORE XNBLK CODE IN CASE{26521
{{MOV{8,WA{13,NUM01(XL){{STORE LENGTH{26522
{{BNZ{8,WC{6,IOP09{{JUMP IF XNBLK WANTED{26523
{{MOV{22,=B$XRT{9,(XL){{XRBLK CODE REQUESTED{26524
*
{{EJC{{{{{26526
*      IOPUT (CONTINUED)
*
*      COMPLETE FCBLK INITIALISATION
*
{IOP09{MOV{3,R$IOT{7,XR{{GET POSSIBLE TRBLK PTR{26531
{{MOV{7,XL{3,R$IOF{{STORE FCBLK PTR{26532
{{BNZ{7,XR{6,IOP10{{JUMP IF TRBLK ALREADY FOUND{26533
*
*      A NEW TRBLK IS NEEDED
*
{{MOV{18,=TRTFC{8,WB{{TRTYP FOR FCBLK TRAP BLK{26537
{{JSR{6,TRBLD{{{MAKE THE BLOCK{26538
{{MOV{7,XR{3,R$IOT{{COPY TRTRF PTR{26539
{{MOV{3,R$IOP{7,XL{{POINT TO PRECEDING BLK{26540
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{COPY VALUE FIELD TO TRBLK{26541
{{MOV{7,XR{13,VRVAL(XL){{LINK NEW TRBLK INTO CHAIN{26542
{{MOV{7,XL{7,XR{{POINT TO PREDECESSOR BLK{26543
{{JSR{6,SETVR{{{SET TRACE INTERCEPTS{26544
{{MOV{13,VRVAL(XR){7,XR{{RECOVER TRBLK PTR{26545
{{BRN{6,IOP1A{{{STORE FCBLK PTR{26546
*
*      HERE IF EXISTING TRBLK
*
{IOP10{ZER{3,R$IOP{{{DO NOT RELEASE IF SYSIO FAILS{26550
*
*      XR IS PTR TO TRBLK, XL IS FCBLK PTR OR 0
*
{IOP1A{MOV{3,R$IOF{13,TRFPT(XR){{STORE FCBLK PTR{26554
*
*      CALL SYSIO TO COMPLETE FILE ACCESSING
*
{IOP11{MOV{3,R$IOF{8,WA{{COPY FCBLK PTR OR 0{26558
{{MOV{3,IOPTT{8,WB{{GET INPUT/OUTPUT FLAG{26559
{{MOV{3,R$IO2{7,XR{{GET FILE ARG2{26560
{{MOV{3,R$IO1{7,XL{{GET FILE ARG1{26561
{{JSR{6,SYSIO{{{ASSOCIATE TO THE FILE{26562
{{PPM{6,IOP17{{{FAIL{26563
{{PPM{6,IOP18{{{FAIL{26564
{{BNZ{3,R$IOT{6,IOP01{{NOT STD INPUT IF NON-NULL TRTRF BLK{26565
{{BNZ{3,IOPTT{6,IOP01{{JUMP IF OUTPUT{26566
{{BZE{8,WC{6,IOP01{{NO CHANGE TO STANDARD READ LENGTH{26567
{{MOV{8,WC{3,CSWIN{{STORE NEW READ LENGTH FOR STD FILE{26568
{{BRN{6,IOP01{{{MERGE TO FINISH THE TASK{26569
*
*      SYSFC MAY HAVE RETURNED A POINTER TO A PRIVATE FCBLK
*
{IOP12{BNZ{7,XL{6,IOP09{{JUMP IF PRIVATE FCBLK{26573
{{BRN{6,IOP11{{{FINISH THE ASSOCIATION{26574
*
*      FAILURE RETURNS
*
{IOP13{EXI{1,1{{{3RD ARG NOT A STRING{26578
{IOP14{EXI{1,2{{{2ND ARG UNSUITABLE{26579
{IOP15{ICA{7,XS{{{DISCARD TRBLK POINTER{26580
{{EXI{1,3{{{1ST ARG UNSUITABLE{26581
{IOP16{EXI{1,4{{{FILE SPEC WRONG{26582
{IOP26{EXI{1,7{{{FCBLK IN USE{26583
*
*      I/O FILE DOES NOT EXIST
*
{IOP17{MOV{3,R$IOP{7,XR{{IS THERE A TRBLK TO RELEASE{26587
{{BZE{7,XR{6,IOPA7{{IF NOT{26588
{{MOV{13,VRVAL(XR){7,XL{{POINT TO TRBLK{26589
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{UNSPLICE IT{26590
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{26591
{IOPA7{EXI{1,5{{{I/O FILE DOES NOT EXIST{26592
*
*      I/O FILE CANNOT BE READ/WRITTEN
*
{IOP18{MOV{3,R$IOP{7,XR{{IS THERE A TRBLK TO RELEASE{26596
{{BZE{7,XR{6,IOPA7{{IF NOT{26597
{{MOV{13,VRVAL(XR){7,XL{{POINT TO TRBLK{26598
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{UNSPLICE IT{26599
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{26600
{IOPA8{EXI{1,6{{{I/O FILE CANNOT BE READ/WRITTEN{26601
{{EJC{{{{{26602
*
*      IOPUT (CONTINUED)
*
*      ADD TO IOCHN CHAIN OF ASSOCIATED VARIABLES UNLESS
*      ALREADY PRESENT.
*
{IOP19{MOV{3,R$ION{8,WC{{WC = NAME BASE, WB = NAME OFFSET{26609
*
*      SEARCH LOOP
*
{IOP20{MOV{13,TRTRF(XR){7,XR{{NEXT LINK OF CHAIN{26613
{{BZE{7,XR{6,IOP21{{NOT FOUND{26614
{{BNE{8,WC{13,IONMB(XR){6,IOP20{NO MATCH{26615
{{BEQ{8,WB{13,IONMO(XR){6,IOP22{EXIT IF MATCHED{26616
{{BRN{6,IOP20{{{LOOP{26617
*
*      NOT FOUND
*
{IOP21{MOV{19,*NUM05{8,WA{{SPACE NEEDED{26621
{{JSR{6,ALLOC{{{GET IT{26622
{{MOV{22,=B$XRT{9,(XR){{STORE XRBLK CODE{26623
{{MOV{8,WA{13,NUM01(XR){{STORE LENGTH{26624
{{MOV{8,WC{13,IONMB(XR){{STORE NAME BASE{26625
{{MOV{8,WB{13,IONMO(XR){{STORE NAME OFFSET{26626
{{MOV{3,R$IOT{7,XL{{POINT TO TRTRF BLK{26627
{{MOV{13,TRTRF(XL){8,WA{{GET PTR FIELD CONTENTS{26628
{{MOV{7,XR{13,TRTRF(XL){{STORE PTR TO NEW BLOCK{26629
{{MOV{8,WA{13,TRTRF(XR){{COMPLETE THE LINKING{26630
*
*      INSERT FCBLK ON FCBLK CHAIN FOR SYSEJ, SYSXI
*
{IOP22{BZE{3,R$IOF{6,IOP25{{SKIP IF NO FCBLK{26634
{{MOV{3,R$FCB{7,XL{{PTR TO HEAD OF EXISTING CHAIN{26635
*
*      SEE IF FCBLK ALREADY ON CHAIN
*
{IOP23{BZE{7,XL{6,IOP24{{NOT ON IF END OF CHAIN{26639
{{BEQ{13,NUM03(XL){3,R$IOF{6,IOP25{DONT DUPLICATE IF FIND IT{26640
{{MOV{13,NUM02(XL){7,XL{{GET NEXT LINK{26641
{{BRN{6,IOP23{{{LOOP{26642
*
*      NOT FOUND SO ADD AN ENTRY FOR THIS FCBLK
*
{IOP24{MOV{19,*NUM04{8,WA{{SPACE NEEDED{26646
{{JSR{6,ALLOC{{{GET IT{26647
{{MOV{22,=B$XRT{9,(XR){{STORE BLOCK CODE{26648
{{MOV{8,WA{13,NUM01(XR){{STORE LENGTH{26649
{{MOV{3,R$FCB{13,NUM02(XR){{STORE PREVIOUS LINK IN THIS NODE{26650
{{MOV{3,R$IOF{13,NUM03(XR){{STORE FCBLK PTR{26651
{{MOV{7,XR{3,R$FCB{{INSERT NODE INTO FCBLK CHAIN{26652
*
*      RETURN
*
{IOP25{EXI{{{{RETURN TO CALLER{26656
{{ENP{{{{END PROCEDURE IOPUT{26657
{{EJC{{{{{26658
*
*      KTREX -- EXECUTE KEYWORD TRACE
*
*      KTREX IS USED TO EXECUTE A POSSIBLE KEYWORD TRACE. IT
*      INCLUDES THE TEST ON TRACE AND TESTS FOR TRACE ACTIVE.
*
*      (XL)                  PTR TO TRBLK (OR 0 IF UNTRACED)
*      JSR  KTREX            CALL TO EXECUTE KEYWORD TRACE
*      (XL,WA,WB,WC)         DESTROYED
*      (RA)                  DESTROYED
*
{KTREX{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){26670
{{BZE{7,XL{6,KTRX3{{IMMEDIATE EXIT IF KEYWORD UNTRACED{26671
{{BZE{3,KVTRA{6,KTRX3{{IMMEDIATE EXIT IF TRACE = 0{26672
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE{26673
{{MOV{7,XR{11,-(XS){{SAVE XR{26674
{{MOV{7,XL{7,XR{{COPY TRBLK POINTER{26675
{{MOV{13,TRKVR(XR){7,XL{{LOAD VRBLK POINTER (NMBAS){26676
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{26677
{{BZE{13,TRFNC(XR){6,KTRX1{{JUMP IF PRINT TRACE{26678
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{26679
{{BRN{6,KTRX2{{{AND JUMP TO EXIT{26680
*
*      HERE FOR PRINT TRACE
*
{KTRX1{MOV{7,XL{11,-(XS){{STACK VRBLK PTR FOR KWNAM{26684
{{MOV{8,WA{11,-(XS){{STACK OFFSET FOR KWNAM{26685
{{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{26686
{{MOV{18,=CH$AM{8,WA{{LOAD AMPERSAND{26687
{{JSR{6,PRTCH{{{PRINT AMPERSAND{26688
{{JSR{6,PRTNM{{{PRINT KEYWORD NAME{26689
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK-EQUAL-BLANK{26690
{{JSR{6,PRTST{{{PRINT BLANK-EQUAL-BLANK{26691
{{JSR{6,KWNAM{{{GET KEYWORD PSEUDO-VARIABLE NAME{26692
{{MOV{7,XR{3,DNAMP{{RESET PTR TO DELETE KVBLK{26693
{{JSR{6,ACESS{{{GET KEYWORD VALUE{26694
{{PPM{{{{FAILURE IS IMPOSSIBLE{26695
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{26696
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{26697
*
*      HERE TO EXIT AFTER COMPLETING TRACE
*
{KTRX2{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{26701
*
*      MERGE HERE TO EXIT IF NO TRACE REQUIRED
*
{KTRX3{EXI{{{{RETURN TO KTREX CALLER{26705
{{ENP{{{{END PROCEDURE KTREX{26706
{{EJC{{{{{26707
*
*      KWNAM -- GET PSEUDO-VARIABLE NAME FOR KEYWORD
*
*      1(XS)                 NAME BASE FOR VRBLK
*      0(XS)                 OFFSET (SHOULD BE *VRVAL)
*      JSR  KWNAM            CALL TO GET PSEUDO-VARIABLE NAME
*      (XS)                  POPPED TWICE
*      (XL,WA)               RESULTING PSEUDO-VARIABLE NAME
*      (XR,WA,WB)            DESTROYED
*
{KWNAM{PRC{25,N{1,0{{ENTRY POINT{26718
{{ICA{7,XS{{{IGNORE NAME OFFSET{26719
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE{26720
{{BGE{7,XR{3,STATE{6,KWNM1{JUMP IF NOT NATURAL VARIABLE NAME{26721
{{BNZ{13,VRLEN(XR){6,KWNM1{{ERROR IF NOT SYSTEM VARIABLE{26722
{{MOV{13,VRSVP(XR){7,XR{{ELSE POINT TO SVBLK{26723
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT MASK{26724
{{ANB{4,BTKNM{8,WA{{AND WITH KEYWORD BIT{26725
{{ZRB{8,WA{6,KWNM1{{ERROR IF NO KEYWORD ASSOCIATION{26726
{{MOV{13,SVLEN(XR){8,WA{{ELSE LOAD NAME LENGTH IN CHARACTERS{26727
{{CTB{8,WA{2,SVCHS{{COMPUTE OFFSET TO FIELD WE WANT{26728
{{ADD{8,WA{7,XR{{POINT TO SVKNM FIELD{26729
{{MOV{9,(XR){8,WB{{LOAD SVKNM VALUE{26730
{{MOV{19,*KVSI${8,WA{{SET SIZE OF KVBLK{26731
{{JSR{6,ALLOC{{{ALLOCATE KVBLK{26732
{{MOV{22,=B$KVT{9,(XR){{STORE TYPE WORD{26733
{{MOV{8,WB{13,KVNUM(XR){{STORE KEYWORD NUMBER{26734
{{MOV{21,=TRBKV{13,KVVAR(XR){{SET DUMMY TRBLK POINTER{26735
{{MOV{7,XR{7,XL{{COPY KVBLK POINTER{26736
{{MOV{19,*KVVAR{8,WA{{SET PROPER OFFSET{26737
{{EXI{{{{RETURN TO KVNAM CALLER{26738
*
*      HERE IF NOT KEYWORD NAME
*
{KWNM1{ERB{1,251{26,Keyword operand is not name of defined keyword{{{26742
{{ENP{{{{END PROCEDURE KWNAM{26743
{{EJC{{{{{26744
*
*      LCOMP-- COMPARE TWO STRINGS LEXICALLY
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  LCOMP            CALL TO COMPARE ARUMENTS
*      PPM  LOC              TRANSFER LOC FOR ARG1 NOT STRING
*      PPM  LOC              TRANSFER LOC FOR ARG2 NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARG1 LLT ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LEQ ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LGT ARG2
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XS)                  POPPED TWICE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{LCOMP{PRC{25,N{1,5{{ENTRY POINT{26761
{{JSR{6,GTSTG{{{CONVERT SECOND ARG TO STRING{26763
{{PPM{6,LCMP6{{{JUMP IF SECOND ARG NOT STRING{26767
{{MOV{7,XR{7,XL{{ELSE SAVE POINTER{26768
{{MOV{8,WA{8,WC{{AND LENGTH{26769
{{JSR{6,GTSTG{{{CONVERT FIRST ARGUMENT TO STRING{26771
{{PPM{6,LCMP5{{{JUMP IF NOT STRING{26775
{{MOV{8,WA{8,WB{{SAVE ARG 1 LENGTH{26776
{{PLC{7,XR{{{POINT TO CHARS OF ARG 1{26777
{{PLC{7,XL{{{POINT TO CHARS OF ARG 2{26778
{{BLO{8,WA{8,WC{6,LCMP1{JUMP IF ARG 1 LENGTH IS SMALLER{26790
{{MOV{8,WC{8,WA{{ELSE SET ARG 2 LENGTH AS SMALLER{26791
*
*      HERE WITH SMALLER LENGTH IN (WA)
*
{LCMP1{BZE{8,WA{6,LCMP7{{IF NULL STRING, COMPARE LENGTHS{26795
{{CMC{6,LCMP4{6,LCMP3{{COMPARE STRINGS, JUMP IF UNEQUAL{26796
{LCMP7{BNE{8,WB{8,WC{6,LCMP2{IF EQUAL, JUMP IF LENGTHS UNEQUAL{26797
{{EXI{1,4{{{ELSE IDENTICAL STRINGS, LEQ EXIT{26798
{{EJC{{{{{26799
*
*      LCOMP (CONTINUED)
*
*      HERE IF INITIAL STRINGS IDENTICAL, BUT LENGTHS UNEQUAL
*
{LCMP2{BHI{8,WB{8,WC{6,LCMP4{JUMP IF ARG 1 LENGTH GT ARG 2 LENG{26805
*
*      HERE IF FIRST ARG LLT SECOND ARG
*
{LCMP3{EXI{1,3{{{TAKE LLT EXIT{26810
*
*      HERE IF FIRST ARG LGT SECOND ARG
*
{LCMP4{EXI{1,5{{{TAKE LGT EXIT{26814
*
*      HERE IF FIRST ARG IS NOT A STRING
*
{LCMP5{EXI{1,1{{{TAKE BAD FIRST ARG EXIT{26818
*
*      HERE FOR SECOND ARG NOT A STRING
*
{LCMP6{EXI{1,2{{{TAKE BAD SECOND ARG ERROR EXIT{26822
{{ENP{{{{END PROCEDURE LCOMP{26823
{{EJC{{{{{26824
*
*      LISTR -- LIST SOURCE LINE
*
*      LISTR IS USED TO LIST A SOURCE LINE DURING THE INITIAL
*      COMPILATION. IT IS CALLED FROM SCANE AND SCANL.
*
*      JSR  LISTR            CALL TO LIST LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL LOCATIONS USED BY LISTR
*
*      CNTTL                 FLAG FOR -TITLE, -STITL
*
*      ERLST                 IF LISTING ON ACCOUNT OF AN ERROR
*
*      LSTID                 INCLUDE DEPTH OF CURRENT IMAGE
*
*      LSTLC                 COUNT LINES ON CURRENT PAGE
*
*      LSTNP                 MAX NUMBER OF LINES/PAGE
*
*      LSTPF                 SET NON-ZERO IF THE CURRENT SOURCE
*                            LINE HAS BEEN LISTED, ELSE ZERO.
*
*      LSTPG                 COMPILER LISTING PAGE NUMBER
*
*      LSTSN                 SET IF STMNT NUM TO BE LISTED
*
*      R$CIM                 POINTER TO CURRENT INPUT LINE.
*
*      R$TTL                 TITLE FOR SOURCE LISTING
*
*      R$STL                 PTR TO SUB-TITLE STRING
*
*      ENTRY POINT
*
{LISTR{PRC{25,E{1,0{{ENTRY POINT{26863
{{BNZ{3,CNTTL{6,LIST5{{JUMP IF -TITLE OR -STITL{26864
{{BNZ{3,LSTPF{6,LIST4{{IMMEDIATE EXIT IF ALREADY LISTED{26865
{{BGE{3,LSTLC{3,LSTNP{6,LIST6{JUMP IF NO ROOM{26866
*
*      HERE AFTER PRINTING TITLE (IF NEEDED)
*
{LIST0{MOV{3,R$CIM{7,XR{{LOAD POINTER TO CURRENT IMAGE{26870
{{BZE{7,XR{6,LIST4{{JUMP IF NO IMAGE TO PRINT{26871
{{PLC{7,XR{{{POINT TO CHARACTERS{26872
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{26873
{{MOV{3,LSTSN{7,XR{{LOAD STATEMENT NUMBER{26874
{{BZE{7,XR{6,LIST2{{JUMP IF NO STATEMENT NUMBER{26875
{{MTI{7,XR{{{ELSE GET STMNT NUMBER AS INTEGER{26876
{{BNE{3,STAGE{18,=STGIC{6,LIST1{SKIP IF EXECUTE TIME{26877
{{BEQ{8,WA{18,=CH$AS{6,LIST2{NO STMNT NUMBER LIST IF COMMENT{26878
{{BEQ{8,WA{18,=CH$MN{6,LIST2{NO STMNT NO. IF CONTROL CARD{26879
*
*      PRINT STATEMENT NUMBER
*
{LIST1{JSR{6,PRTIN{{{ELSE PRINT STATEMENT NUMBER{26883
{{ZER{3,LSTSN{{{AND CLEAR FOR NEXT TIME IN{26884
*
*      HERE TO TEST FOR PRINTING INCLUDE DEPTH
*
{LIST2{MOV{3,LSTID{7,XR{{INCLUDE DEPTH OF IMAGE{26889
{{BZE{7,XR{6,LIST8{{IF NOT FROM AN INCLUDE FILE{26890
{{MOV{18,=STNPD{8,WA{{POSITION FOR START OF STATEMENT{26891
{{SUB{18,=NUM03{8,WA{{POSITION TO PLACE INCLUDE DEPTH{26892
{{MOV{8,WA{3,PROFS{{SET AS STARTING POSITION{26893
{{MTI{7,XR{{{INCLUDE DEPTH AS INTEGER{26894
{{JSR{6,PRTIN{{{PRINT INCLUDE DEPTH{26895
{{EJC{{{{{26896
*
*      LISTR (CONTINUED)
*
*      HERE AFTER PRINTING STATEMENT NUMBER AND INCLUDE DEPTH
*
{LIST8{MOV{18,=STNPD{3,PROFS{{POINT PAST STATEMENT NUMBER{26902
{{MOV{3,R$CIM{7,XR{{LOAD POINTER TO CURRENT IMAGE{26912
{{JSR{6,PRTST{{{PRINT IT{26913
{{ICV{3,LSTLC{{{BUMP LINE COUNTER{26914
{{BNZ{3,ERLST{6,LIST3{{JUMP IF ERROR COPY TO INT.CH.{26915
{{JSR{6,PRTNL{{{TERMINATE LINE{26916
{{BZE{3,CSWDB{6,LIST3{{JUMP IF -SINGLE MODE{26917
{{JSR{6,PRTNL{{{ELSE ADD A BLANK LINE{26918
{{ICV{3,LSTLC{{{AND BUMP LINE COUNTER{26919
*
*      HERE AFTER PRINTING SOURCE IMAGE
*
{LIST3{MNZ{3,LSTPF{{{SET FLAG FOR LINE PRINTED{26923
*
*      MERGE HERE TO EXIT
*
{LIST4{EXI{{{{RETURN TO LISTR CALLER{26927
*
*      PRINT TITLE AFTER -TITLE OR -STITL CARD
*
{LIST5{ZER{3,CNTTL{{{CLEAR FLAG{26931
*
*      EJECT TO NEW PAGE AND LIST TITLE
*
{LIST6{JSR{6,PRTPS{{{EJECT{26935
{{BZE{3,PRICH{6,LIST7{{SKIP IF LISTING TO REGULAR PRINTER{26936
{{BEQ{3,R$TTL{21,=NULLS{6,LIST0{TERMINAL LISTING OMITS NULL TITLE{26937
*
*      LIST TITLE
*
{LIST7{JSR{6,LISTT{{{LIST TITLE{26941
{{BRN{6,LIST0{{{MERGE{26942
{{ENP{{{{END PROCEDURE LISTR{26943
{{EJC{{{{{26944
*
*      LISTT -- LIST TITLE AND SUBTITLE
*
*      USED DURING COMPILATION TO PRINT PAGE HEADING
*
*      JSR  LISTT            CALL TO LIST TITLE
*      (XR,WA)               DESTROYED
*
{LISTT{PRC{25,E{1,0{{ENTRY POINT{26953
{{MOV{3,R$TTL{7,XR{{POINT TO SOURCE LISTING TITLE{26954
{{JSR{6,PRTST{{{PRINT TITLE{26955
{{MOV{3,LSTPO{3,PROFS{{SET OFFSET{26956
{{MOV{21,=LSTMS{7,XR{{SET PAGE MESSAGE{26957
{{JSR{6,PRTST{{{PRINT PAGE MESSAGE{26958
{{ICV{3,LSTPG{{{BUMP PAGE NUMBER{26959
{{MTI{3,LSTPG{{{LOAD PAGE NUMBER AS INTEGER{26960
{{JSR{6,PRTIN{{{PRINT PAGE NUMBER{26961
{{JSR{6,PRTNL{{{TERMINATE TITLE LINE{26962
{{ADD{18,=NUM02{3,LSTLC{{COUNT TITLE LINE AND BLANK LINE{26963
*
*      PRINT SUB-TITLE (IF ANY)
*
{{MOV{3,R$STL{7,XR{{LOAD POINTER TO SUB-TITLE{26967
{{BZE{7,XR{6,LSTT1{{JUMP IF NO SUB-TITLE{26968
{{JSR{6,PRTST{{{ELSE PRINT SUB-TITLE{26969
{{JSR{6,PRTNL{{{TERMINATE LINE{26970
{{ICV{3,LSTLC{{{BUMP LINE COUNT{26971
*
*      RETURN POINT
*
{LSTT1{JSR{6,PRTNL{{{PRINT A BLANK LINE{26975
{{EXI{{{{RETURN TO CALLER{26976
{{ENP{{{{END PROCEDURE LISTT{26977
{{EJC{{{{{26978
*
*      NEWFN -- RECORD NEW SOURCE FILE NAME
*
*      NEWFN IS USED AFTER SWITCHING TO A NEW INCLUDE FILE, OR
*      AFTER A -LINE STATEMENT WHICH CONTAINS A FILE NAME.
*
*      (XR)                  FILE NAME SCBLK
*      JSR  NEWFN
*      (WA,WB,WC,XL,XR,RA)   DESTROYED
*
*      ON RETURN, THE TABLE THAT MAPS STATEMENT NUMBERS TO FILE
*      NAMES HAS BEEN UPDATED TO INCLUDE THIS NEW FILE NAME AND
*      THE CURRENT STATEMENT NUMBER.  THE ENTRY IS MADE ONLY IF
*      THE FILE NAME HAD CHANGED FROM ITS PREVIOUS VALUE.
*
{NEWFN{PRC{25,E{1,0{{ENTRY POINT{26995
{{MOV{7,XR{11,-(XS){{SAVE NEW NAME{26996
{{MOV{3,R$SFC{7,XL{{LOAD PREVIOUS NAME{26997
{{JSR{6,IDENT{{{CHECK FOR EQUALITY{26998
{{PPM{6,NWFN1{{{JUMP IF IDENTICAL{26999
{{MOV{10,(XS)+{7,XR{{DIFFERENT, RESTORE NAME{27000
{{MOV{7,XR{3,R$SFC{{RECORD CURRENT FILE NAME{27001
{{MOV{3,CMPSN{8,WB{{GET CURRENT STATEMENT{27002
{{MTI{8,WB{{{CONVERT TO INTEGER{27003
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{27004
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{27005
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{27006
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{27007
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{27008
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{27009
{{EXI{{{{{27010
*
*     HERE IF NEW NAME AND OLD NAME IDENTICAL
*
{NWFN1{ICA{7,XS{{{POP STACK{27014
{{EXI{{{{{27015
{{EJC{{{{{27016
*
*      NEXTS -- ACQUIRE NEXT SOURCE IMAGE
*
*      NEXTS IS USED TO ACQUIRE THE NEXT SOURCE IMAGE AT COMPILE
*      TIME. IT ASSUMES THAT A PRIOR CALL TO READR HAS INPUT
*      A LINE IMAGE (SEE PROCEDURE READR). BEFORE THE CURRENT
*      IMAGE IS FINALLY LOST IT MAY BE LISTED HERE.
*
*      JSR  NEXTS            CALL TO ACQUIRE NEXT INPUT LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL VALUES AFFECTED
*
*      LSTID                 INCLUDE DEPTH OF NEXT IMAGE
*
*      R$CNI                 ON INPUT, NEXT IMAGE. ON
*                            EXIT RESET TO ZERO
*
*      R$CIM                 ON EXIT, SET TO POINT TO IMAGE
*
*      RDCLN                 CURRENT LN SET FROM NEXT LINE NUM
*
*      SCNIL                 INPUT IMAGE LENGTH ON EXIT
*
*      SCNSE                 RESET TO ZERO ON EXIT
*
*      LSTPF                 SET ON EXIT IF LINE IS LISTED
*
{NEXTS{PRC{25,E{1,0{{ENTRY POINT{27048
{{BZE{3,CSWLS{6,NXTS2{{JUMP IF -NOLIST{27049
{{MOV{3,R$CIM{7,XR{{POINT TO IMAGE{27050
{{BZE{7,XR{6,NXTS2{{JUMP IF NO IMAGE{27051
{{PLC{7,XR{{{GET CHAR PTR{27052
{{LCH{8,WA{9,(XR){{GET FIRST CHAR{27053
{{BNE{8,WA{18,=CH$MN{6,NXTS1{JUMP IF NOT CTRL CARD{27054
{{BZE{3,CSWPR{6,NXTS2{{JUMP IF -NOPRINT{27055
*
*      HERE TO CALL LISTER
*
{NXTS1{JSR{6,LISTR{{{LIST LINE{27059
*
*      HERE AFTER POSSIBLE LISTING
*
{NXTS2{MOV{3,R$CNI{7,XR{{POINT TO NEXT IMAGE{27063
{{MOV{7,XR{3,R$CIM{{SET AS NEXT IMAGE{27064
{{MOV{3,RDNLN{3,RDCLN{{SET AS CURRENT LINE NUMBER{27065
{{MOV{3,CNIND{3,LSTID{{SET AS CURRENT INCLUDE DEPTH{27067
{{ZER{3,R$CNI{{{CLEAR NEXT IMAGE POINTER{27069
{{MOV{13,SCLEN(XR){8,WA{{GET INPUT IMAGE LENGTH{27070
{{MOV{3,CSWIN{8,WB{{GET MAX ALLOWABLE LENGTH{27071
{{BLO{8,WA{8,WB{6,NXTS3{SKIP IF NOT TOO LONG{27072
{{MOV{8,WB{8,WA{{ELSE TRUNCATE{27073
*
*      HERE WITH LENGTH IN (WA)
*
{NXTS3{MOV{8,WA{3,SCNIL{{USE AS RECORD LENGTH{27077
{{ZER{3,SCNSE{{{RESET SCNSE{27078
{{ZER{3,LSTPF{{{SET LINE NOT LISTED YET{27079
{{EXI{{{{RETURN TO NEXTS CALLER{27080
{{ENP{{{{END PROCEDURE NEXTS{27081
{{EJC{{{{{27082
*
*      PATIN -- PATTERN CONSTRUCTION FOR LEN,POS,RPOS,TAB,RTAB
*
*      THESE PATTERN TYPES ALL GENERATE A SIMILAR NODE TYPE. SO
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE FUNCTIONS.
*
*      (WA)                  PCODE FOR EXPRESSION ARG CASE
*      (WB)                  PCODE FOR INTEGER ARG CASE
*      JSR  PATIN            CALL TO BUILD PATTERN NODE
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER OR EXP
*      PPM  LOC              TRANSFER LOC FOR INT OUT OF RANGE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL,WA,WB,WC,IA)      DESTROYED
*
{PATIN{PRC{25,N{1,2{{ENTRY POINT{27098
{{MOV{8,WA{7,XL{{PRESERVE EXPRESSION ARG PCODE{27099
{{JSR{6,GTSMI{{{TRY TO CONVERT ARG AS SMALL INTEGER{27100
{{PPM{6,PTIN2{{{JUMP IF NOT INTEGER{27101
{{PPM{6,PTIN3{{{JUMP IF OUT OF RANGE{27102
*
*      COMMON SUCCESSFUL EXIT POINT
*
{PTIN1{JSR{6,PBILD{{{BUILD PATTERN NODE{27106
{{EXI{{{{RETURN TO CALLER{27107
*
*      HERE IF ARGUMENT IS NOT AN INTEGER
*
{PTIN2{MOV{7,XL{8,WB{{COPY EXPR ARG CASE PCODE{27111
{{BLO{9,(XR){22,=B$E$${6,PTIN1{ALL OK IF EXPRESSION ARG{27112
{{EXI{1,1{{{ELSE TAKE ERROR EXIT FOR WRONG TYPE{27113
*
*      HERE FOR ERROR OF OUT OF RANGE INTEGER ARGUMENT
*
{PTIN3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{27117
{{ENP{{{{END PROCEDURE PATIN{27118
{{EJC{{{{{27119
*
*      PATST -- PATTERN CONSTRUCTION FOR ANY,NOTANY,
*               BREAK,SPAN AND BREAKX PATTERN FUNCTIONS.
*
*      THESE PATTERN FUNCTIONS BUILD SIMILAR TYPES OF NODES AND
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE PATTERN FUNCTIONS.
*
*      0(XS)                 STRING ARGUMENT
*      (WB)                  PCODE FOR ONE CHAR ARGUMENT
*      (XL)                  PCODE FOR MULTI-CHAR ARGUMENT
*      (WC)                  PCODE FOR EXPRESSION ARGUMENT
*      JSR  PATST            CALL TO BUILD NODE
*      PPM  LOC              IF NOT STRING OR EXPR (OR NULL)
*      (XS)                  POPPED PAST STRING ARGUMENT
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL)                  DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      NOTE THAT THERE IS A SPECIAL CALL TO PATST IN THE EVALS
*      PROCEDURE WITH A SLIGHTLY DIFFERENT FORM. SEE EVALS
*      FOR DETAILS OF THE FORM OF THIS CALL.
*
{PATST{PRC{25,N{1,1{{ENTRY POINT{27143
{{JSR{6,GTSTG{{{CONVERT ARGUMENT AS STRING{27144
{{PPM{6,PATS7{{{JUMP IF NOT STRING{27145
{{BZE{8,WA{6,PATS7{{JUMP IF NULL STRING (CATSPAW){27146
{{BNE{8,WA{18,=NUM01{6,PATS2{JUMP IF NOT ONE CHAR STRING{27147
*
*      HERE FOR ONE CHAR STRING CASE
*
{{BZE{8,WB{6,PATS2{{TREAT AS MULTI-CHAR IF EVALS CALL{27151
{{PLC{7,XR{{{POINT TO CHARACTER{27152
{{LCH{7,XR{9,(XR){{LOAD CHARACTER{27153
*
*      COMMON EXIT POINT AFTER SUCCESSFUL CONSTRUCTION
*
{PATS1{JSR{6,PBILD{{{CALL ROUTINE TO BUILD NODE{27157
{{EXI{{{{RETURN TO PATST CALLER{27158
{{EJC{{{{{27159
*
*      PATST (CONTINUED)
*
*      HERE FOR MULTI-CHARACTER STRING CASE
*
{PATS2{MOV{7,XL{11,-(XS){{SAVE MULTI-CHAR PCODE{27165
{{MOV{3,CTMSK{8,WC{{LOAD CURRENT MASK BIT{27166
{{BEQ{7,XR{3,R$CTS{6,PATS6{JUMP IF SAME AS LAST STRING C3.738{27167
{{MOV{7,XR{11,-(XS){{SAVE STRING POINTER{27168
{{LSH{8,WC{1,1{{SHIFT TO NEXT POSITION{27169
{{NZB{8,WC{6,PATS4{{SKIP IF POSITION LEFT IN THIS TBL{27170
*
*      HERE WE MUST ALLOCATE A NEW CHARACTER TABLE
*
{{MOV{19,*CTSI${8,WA{{SET SIZE OF CTBLK{27174
{{JSR{6,ALLOC{{{ALLOCATE CTBLK{27175
{{MOV{7,XR{3,R$CTP{{STORE PTR TO NEW CTBLK{27176
{{MOV{22,=B$CTT{10,(XR)+{{STORE TYPE CODE, BUMP PTR{27177
{{LCT{8,WB{18,=CFP$A{{SET NUMBER OF WORDS TO CLEAR{27178
{{MOV{4,BITS0{8,WC{{LOAD ALL ZERO BITS{27179
*
*      LOOP TO CLEAR ALL BITS IN TABLE TO ZEROS
*
{PATS3{MOV{8,WC{10,(XR)+{{MOVE WORD OF ZERO BITS{27183
{{BCT{8,WB{6,PATS3{{LOOP TILL ALL CLEARED{27184
{{MOV{4,BITS1{8,WC{{SET INITIAL BIT POSITION{27185
*
*      MERGE HERE WITH BIT POSITION AVAILABLE
*
{PATS4{MOV{8,WC{3,CTMSK{{SAVE PARM2 (NEW BIT POSITION){27189
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER TO ARGUMENT STRING{27190
{{MOV{7,XL{3,R$CTS{{SAVE FOR NEXT TIME   C3.738{27191
{{MOV{13,SCLEN(XL){8,WB{{LOAD STRING LENGTH{27192
{{BZE{8,WB{6,PATS6{{JUMP IF NULL STRING CASE{27193
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{27194
{{PLC{7,XL{{{POINT TO CHARACTERS IN ARGUMENT{27195
{{EJC{{{{{27196
*
*      PATST (CONTINUED)
*
*      LOOP TO SET BITS IN COLUMN OF TABLE
*
{PATS5{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{27202
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{27203
{{MOV{3,R$CTP{7,XR{{POINT TO CTBLK{27204
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{27205
{{MOV{8,WC{8,WA{{COPY BIT MASK{27206
{{ORB{13,CTCHS(XR){8,WA{{OR IN BITS ALREADY SET{27207
{{MOV{8,WA{13,CTCHS(XR){{STORE RESULTING BIT STRING{27208
{{BCT{8,WB{6,PATS5{{LOOP TILL ALL BITS SET{27209
*
*      COMPLETE PROCESSING FOR MULTI-CHAR STRING CASE
*
{PATS6{MOV{3,R$CTP{7,XR{{LOAD CTBLK PTR AS PARM1 FOR PBILD{27213
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{27214
{{MOV{10,(XS)+{8,WB{{LOAD PCODE FOR MULTI-CHAR STR CASE{27215
{{BRN{6,PATS1{{{BACK TO EXIT (WC=BITSTRING=PARM2){27216
*
*      HERE IF ARGUMENT IS NOT A STRING
*
*      NOTE THAT THE CALL FROM EVALS CANNOT PASS AN EXPRESSION
*      SINCE EVALP ALWAYS REEVALUATES EXPRESSIONS.
*
{PATS7{MOV{8,WC{8,WB{{SET PCODE FOR EXPRESSION ARGUMENT{27223
{{BLO{9,(XR){22,=B$E$${6,PATS1{JUMP TO EXIT IF EXPRESSION ARG{27224
{{EXI{1,1{{{ELSE TAKE WRONG TYPE ERROR EXIT{27225
{{ENP{{{{END PROCEDURE PATST{27226
{{EJC{{{{{27227
*
*      PBILD -- BUILD PATTERN NODE
*
*      (XR)                  PARM1 (ONLY IF REQUIRED)
*      (WB)                  PCODE FOR NODE
*      (WC)                  PARM2 (ONLY IF REQUIRED)
*      JSR  PBILD            CALL TO BUILD NODE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (WA)                  DESTROYED
*
{PBILD{PRC{25,E{1,0{{ENTRY POINT{27238
{{MOV{7,XR{11,-(XS){{STACK POSSIBLE PARM1{27239
{{MOV{8,WB{7,XR{{COPY PCODE{27240
{{LEI{7,XR{{{LOAD ENTRY POINT ID (BL$PX){27241
{{BEQ{7,XR{18,=BL$P1{6,PBLD1{JUMP IF ONE PARAMETER{27242
{{BEQ{7,XR{18,=BL$P0{6,PBLD3{JUMP IF NO PARAMETERS{27243
*
*      HERE FOR TWO PARAMETER CASE
*
{{MOV{19,*PCSI${8,WA{{SET SIZE OF P2BLK{27247
{{JSR{6,ALLOC{{{ALLOCATE BLOCK{27248
{{MOV{8,WC{13,PARM2(XR){{STORE SECOND PARAMETER{27249
{{BRN{6,PBLD2{{{MERGE WITH ONE PARM CASE{27250
*
*      HERE FOR ONE PARAMETER CASE
*
{PBLD1{MOV{19,*PBSI${8,WA{{SET SIZE OF P1BLK{27254
{{JSR{6,ALLOC{{{ALLOCATE NODE{27255
*
*      MERGE HERE FROM TWO PARM CASE
*
{PBLD2{MOV{9,(XS){13,PARM1(XR){{STORE FIRST PARAMETER{27259
{{BRN{6,PBLD4{{{MERGE WITH NO PARAMETER CASE{27260
*
*      HERE FOR CASE OF NO PARAMETERS
*
{PBLD3{MOV{19,*PASI${8,WA{{SET SIZE OF P0BLK{27264
{{JSR{6,ALLOC{{{ALLOCATE NODE{27265
*
*      MERGE HERE FROM OTHER CASES
*
{PBLD4{MOV{8,WB{9,(XR){{STORE PCODE{27269
{{ICA{7,XS{{{POP FIRST PARAMETER{27270
{{MOV{21,=NDNTH{13,PTHEN(XR){{SET NOTHEN SUCCESSOR POINTER{27271
{{EXI{{{{RETURN TO PBILD CALLER{27272
{{ENP{{{{END PROCEDURE PBILD{27273
{{EJC{{{{{27274
*
*      PCONC -- CONCATENATE TWO PATTERNS
*
*      (XL)                  PTR TO RIGHT PATTERN
*      (XR)                  PTR TO LEFT PATTERN
*      JSR  PCONC            CALL TO CONCATENATE PATTERNS
*      (XR)                  PTR TO CONCATENATED PATTERN
*      (XL,WA,WB,WC)         DESTROYED
*
*
*      TO CONCATENATE TWO PATTERNS, ALL SUCCESSORS IN THE LEFT
*      PATTERN WHICH POINT TO THE NOTHEN NODE MUST BE CHANGED TO
*      POINT TO THE RIGHT PATTERN. HOWEVER, THIS MODIFICATION
*      MUST BE PERFORMED ON A COPY OF THE LEFT ARGUMENT RATHER
*      THAN THE LEFT ARGUMENT ITSELF, SINCE THE LEFT ARGUMENT
*      MAY BE POINTED TO BY SOME OTHER VARIABLE VALUE.
*
*      ACCORDINGLY, IT IS NECESSARY TO COPY THE LEFT ARGUMENT.
*      THIS IS NOT A TRIVIAL PROCESS SINCE WE MUST AVOID COPYING
*      NODES MORE THAN ONCE AND THE PATTERN IS A GRAPH STRUCTURE
*      THE FOLLOWING ALGORITHM IS EMPLOYED.
*
*      THE STACK IS USED TO STORE A LIST OF NODES WHICH
*      HAVE ALREADY BEEN COPIED. THE FORMAT OF THE ENTRIES ON
*      THIS LIST CONSISTS OF A TWO WORD BLOCK. THE FIRST WORD
*      IS THE OLD ADDRESS AND THE SECOND WORD IS THE ADDRESS
*      OF THE COPY. THIS LIST IS SEARCHED BY THE PCOPY
*      ROUTINE TO AVOID MAKING DUPLICATE COPIES. A TRICK IS
*      USED TO ACCOMPLISH THE CONCATENATION AT THE SAME TIME.
*      A SPECIAL ENTRY IS MADE TO START WITH ON THE STACK. THIS
*      ENTRY RECORDS THAT THE NOTHEN NODE HAS BEEN COPIED
*      ALREADY AND THE ADDRESS OF ITS COPY IS THE RIGHT PATTERN.
*      THIS AUTOMATICALLY PERFORMS THE CORRECT REPLACEMENTS.
*
{PCONC{PRC{25,E{1,0{{ENTRY POINT{27309
{{ZER{11,-(XS){{{MAKE ROOM FOR ONE ENTRY AT BOTTOM{27310
{{MOV{7,XS{8,WC{{STORE POINTER TO START OF LIST{27311
{{MOV{21,=NDNTH{11,-(XS){{STACK NOTHEN NODE AS OLD NODE{27312
{{MOV{7,XL{11,-(XS){{STORE RIGHT ARG AS COPY OF NOTHEN{27313
{{MOV{7,XS{7,XT{{INITIALIZE POINTER TO STACK ENTRIES{27314
{{JSR{6,PCOPY{{{COPY FIRST NODE OF LEFT ARG{27315
{{MOV{8,WA{13,NUM02(XT){{STORE AS RESULT UNDER LIST{27316
{{EJC{{{{{27317
*
*      PCONC (CONTINUED)
*
*      THE FOLLOWING LOOP SCANS ENTRIES IN THE LIST AND MAKES
*      SURE THAT THEIR SUCCESSORS HAVE BEEN COPIED.
*
{PCNC1{BEQ{7,XT{7,XS{6,PCNC2{JUMP IF ALL ENTRIES PROCESSED{27324
{{MOV{11,-(XT){7,XR{{ELSE LOAD NEXT OLD ADDRESS{27325
{{MOV{13,PTHEN(XR){7,XR{{LOAD POINTER TO SUCCESSOR{27326
{{JSR{6,PCOPY{{{COPY SUCCESSOR NODE{27327
{{MOV{11,-(XT){7,XR{{LOAD POINTER TO NEW NODE (COPY){27328
{{MOV{8,WA{13,PTHEN(XR){{STORE PTR TO NEW SUCCESSOR{27329
*
*      NOW CHECK FOR SPECIAL CASE OF ALTERNATION NODE WHERE
*      PARM1 POINTS TO A NODE AND MUST BE COPIED LIKE PTHEN.
*
{{BNE{9,(XR){22,=P$ALT{6,PCNC1{LOOP BACK IF NOT{27334
{{MOV{13,PARM1(XR){7,XR{{ELSE LOAD POINTER TO ALTERNATIVE{27335
{{JSR{6,PCOPY{{{COPY IT{27336
{{MOV{9,(XT){7,XR{{RESTORE PTR TO NEW NODE{27337
{{MOV{8,WA{13,PARM1(XR){{STORE PTR TO COPIED ALTERNATIVE{27338
{{BRN{6,PCNC1{{{LOOP BACK FOR NEXT ENTRY{27339
*
*      HERE AT END OF COPY PROCESS
*
{PCNC2{MOV{8,WC{7,XS{{RESTORE STACK POINTER{27343
{{MOV{10,(XS)+{7,XR{{LOAD POINTER TO COPY{27344
{{EXI{{{{RETURN TO PCONC CALLER{27345
{{ENP{{{{END PROCEDURE PCONC{27346
{{EJC{{{{{27347
*
*      PCOPY -- COPY A PATTERN NODE
*
*      PCOPY IS CALLED FROM THE PCONC PROCEDURE TO COPY A SINGLE
*      PATTERN NODE. THE COPY IS ONLY CARRIED OUT IF THE NODE
*      HAS NOT BEEN COPIED ALREADY.
*
*      (XR)                  POINTER TO NODE TO BE COPIED
*      (XT)                  PTR TO CURRENT LOC IN COPY LIST
*      (WC)                  POINTER TO LIST OF COPIED NODES
*      JSR  PCOPY            CALL TO COPY A NODE
*      (WA)                  POINTER TO COPY
*      (WB,XR)               DESTROYED
*
{PCOPY{PRC{25,N{1,0{{ENTRY POINT{27362
{{MOV{7,XT{8,WB{{SAVE XT{27363
{{MOV{8,WC{7,XT{{POINT TO START OF LIST{27364
*
*      LOOP TO SEARCH LIST OF NODES COPIED ALREADY
*
{PCOP1{DCA{7,XT{{{POINT TO NEXT ENTRY ON LIST{27368
{{BEQ{7,XR{9,(XT){6,PCOP2{JUMP IF MATCH{27369
{{DCA{7,XT{{{ELSE SKIP OVER COPIED ADDRESS{27370
{{BNE{7,XT{7,XS{6,PCOP1{LOOP BACK IF MORE TO TEST{27371
*
*      HERE IF NOT IN LIST, PERFORM COPY
*
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{27375
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{27376
{{MOV{7,XR{7,XL{{SAVE POINTER TO OLD NODE{27377
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{27378
{{MOV{7,XL{11,-(XS){{STORE OLD ADDRESS ON LIST{27379
{{MOV{7,XR{11,-(XS){{STORE NEW ADDRESS ON LIST{27380
{{CHK{{{{CHECK FOR STACK OVERFLOW{27381
{{MVW{{{{MOVE WORDS FROM OLD BLOCK TO COPY{27382
{{MOV{9,(XS){8,WA{{LOAD POINTER TO COPY{27383
{{BRN{6,PCOP3{{{JUMP TO EXIT{27384
*
*      HERE IF WE FIND ENTRY IN LIST
*
{PCOP2{MOV{11,-(XT){8,WA{{LOAD ADDRESS OF COPY FROM LIST{27388
*
*      COMMON EXIT POINT
*
{PCOP3{MOV{8,WB{7,XT{{RESTORE XT{27392
{{EXI{{{{RETURN TO PCOPY CALLER{27393
{{ENP{{{{END PROCEDURE PCOPY{27394
{{EJC{{{{{27395
*
*      PRFLR -- PRINT PROFILE
*      PRFLR IS CALLED TO PRINT THE CONTENTS OF THE PROFILE
*      TABLE IN A FAIRLY READABLE TABULAR FORMAT.
*
*      JSR  PRFLR            CALL TO PRINT PROFILE
*      (WA,IA)               DESTROYED
*
{PRFLR{PRC{25,E{1,0{{{27406
{{BZE{3,PFDMP{6,PRFL4{{NO PRINTING IF NO PROFILING DONE{27407
{{MOV{7,XR{11,-(XS){{PRESERVE ENTRY XR{27408
{{MOV{8,WB{3,PFSVW{{AND ALSO WB{27409
{{JSR{6,PRTPG{{{EJECT{27410
{{MOV{21,=PFMS1{7,XR{{LOAD MSG /PROGRAM PROFILE/{27411
{{JSR{6,PRTST{{{AND PRINT IT{27412
{{JSR{6,PRTNL{{{FOLLOWED BY NEWLINE{27413
{{JSR{6,PRTNL{{{AND ANOTHER{27414
{{MOV{21,=PFMS2{7,XR{{POINT TO FIRST HDR{27415
{{JSR{6,PRTST{{{PRINT IT{27416
{{JSR{6,PRTNL{{{NEW LINE{27417
{{MOV{21,=PFMS3{7,XR{{SECOND HDR{27418
{{JSR{6,PRTST{{{PRINT IT{27419
{{JSR{6,PRTNL{{{NEW LINE{27420
{{JSR{6,PRTNL{{{AND ANOTHER BLANK LINE{27421
{{ZER{8,WB{{{INITIAL STMT COUNT{27422
{{MOV{3,PFTBL{7,XR{{POINT TO TABLE ORIGIN{27423
{{ADD{19,*XNDTA{7,XR{{BIAS PAST XNBLK HEADER (SGD07){27424
*
*      LOOP HERE TO PRINT SUCCESSIVE ENTRIES
*
{PRFL1{ICV{8,WB{{{BUMP STMT NR{27428
{{LDI{9,(XR){{{LOAD NR OF EXECUTIONS{27429
{{IEQ{6,PRFL3{{{NO PRINTING IF ZERO{27430
{{MOV{18,=PFPD1{3,PROFS{{POINT WHERE TO PRINT{27431
{{JSR{6,PRTIN{{{AND PRINT IT{27432
{{ZER{3,PROFS{{{BACK TO START OF LINE{27433
{{MTI{8,WB{{{LOAD STMT NR{27434
{{JSR{6,PRTIN{{{PRINT IT THERE{27435
{{MOV{18,=PFPD2{3,PROFS{{AND PAD PAST COUNT{27436
{{LDI{13,CFP$I(XR){{{LOAD TOTAL EXEC TIME{27437
{{JSR{6,PRTIN{{{PRINT THAT TOO{27438
{{LDI{13,CFP$I(XR){{{RELOAD TIME{27439
{{MLI{4,INTTH{{{CONVERT TO MICROSEC{27440
{{IOV{6,PRFL2{{{OMIT NEXT BIT IF OVERFLOW{27441
{{DVI{9,(XR){{{DIVIDE BY EXECUTIONS{27442
{{MOV{18,=PFPD3{3,PROFS{{PAD LAST PRINT{27443
{{JSR{6,PRTIN{{{AND PRINT MCSEC/EXECN{27444
*
*      MERGE AFTER PRINTING TIME
*
{PRFL2{JSR{6,PRTNL{{{THATS ANOTHER LINE{27448
*
*      HERE TO GO TO NEXT ENTRY
*
{PRFL3{ADD{19,*PF$I2{7,XR{{BUMP INDEX PTR (SGD07){27452
{{BLT{8,WB{3,PFNTE{6,PRFL1{LOOP IF MORE STMTS{27453
{{MOV{10,(XS)+{7,XR{{RESTORE CALLERS XR{27454
{{MOV{3,PFSVW{8,WB{{AND WB TOO{27455
*
*      HERE TO EXIT
*
{PRFL4{EXI{{{{RETURN{27459
{{ENP{{{{END OF PRFLR{27460
{{EJC{{{{{27461
*
*      PRFLU -- UPDATE AN ENTRY IN THE PROFILE TABLE
*
*      ON ENTRY, KVSTN CONTAINS NR OF STMT TO PROFILE
*
*      JSR  PRFLU            CALL TO UPDATE ENTRY
*      (IA)                  DESTROYED
*
{PRFLU{PRC{25,E{1,0{{{27470
{{BNZ{3,PFFNC{6,PFLU4{{SKIP IF JUST ENTERED FUNCTION{27471
{{MOV{7,XR{11,-(XS){{PRESERVE ENTRY XR{27472
{{MOV{8,WA{3,PFSVW{{SAVE WA (SGD07){27473
{{BNZ{3,PFTBL{6,PFLU2{{BRANCH IF TABLE ALLOCATED{27474
*
*      HERE IF SPACE FOR PROFILE TABLE NOT YET ALLOCATED.
*      CALCULATE SIZE NEEDED, ALLOCATE A STATIC XNBLK, AND
*      INITIALIZE IT ALL TO ZERO.
*      THE TIME TAKEN FOR THIS WILL BE ATTRIBUTED TO THE CURRENT
*      STATEMENT (ASSIGNMENT TO KEYWD PROFILE), BUT SINCE THE
*      TIMING FOR THIS STATEMENT IS UP THE POLE ANYWAY, THIS
*      DOESNT REALLY MATTER...
*
{{SUB{18,=NUM01{3,PFNTE{{ADJUST FOR EXTRA COUNT (SGD07){27484
{{MTI{4,PFI2A{{{CONVRT ENTRY SIZE TO INT{27485
{{STI{3,PFSTE{{{AND STORE SAFELY FOR LATER{27486
{{MTI{3,PFNTE{{{LOAD TABLE LENGTH AS INTEGER{27487
{{MLI{3,PFSTE{{{MULTIPLY BY ENTRY SIZE{27488
{{MFI{8,WA{{{GET BACK ADDRESS-STYLE{27489
{{ADD{18,=NUM02{8,WA{{ADD ON 2 WORD OVERHEAD{27490
{{WTB{8,WA{{{CONVERT THE WHOLE LOT TO BYTES{27491
{{JSR{6,ALOST{{{GIMME THE SPACE{27492
{{MOV{7,XR{3,PFTBL{{SAVE BLOCK POINTER{27493
{{MOV{22,=B$XNT{10,(XR)+{{PUT BLOCK TYPE AND ...{27494
{{MOV{8,WA{10,(XR)+{{... LENGTH INTO HEADER{27495
{{MFI{8,WA{{{GET BACK NR OF WDS IN DATA AREA{27496
{{LCT{8,WA{8,WA{{LOAD THE COUNTER{27497
*
*      LOOP HERE TO ZERO THE BLOCK DATA
*
{PFLU1{ZER{10,(XR)+{{{BLANK A WORD{27501
{{BCT{8,WA{6,PFLU1{{AND ALLLLLLL THE REST{27502
*
*      END OF ALLOCATION. MERGE BACK INTO ROUTINE
*
{PFLU2{MTI{3,KVSTN{{{LOAD NR OF STMT JUST ENDED{27506
{{SBI{4,INTV1{{{MAKE INTO INDEX OFFSET{27507
{{MLI{3,PFSTE{{{MAKE OFFSET OF TABLE ENTRY{27508
{{MFI{8,WA{{{CONVERT TO ADDRESS{27509
{{WTB{8,WA{{{GET AS BAUS{27510
{{ADD{19,*NUM02{8,WA{{OFFSET INCLUDES TABLE HEADER{27511
{{MOV{3,PFTBL{7,XR{{GET TABLE START{27512
{{BGE{8,WA{13,NUM01(XR){6,PFLU3{IF OUT OF TABLE, SKIP IT{27513
{{ADD{8,WA{7,XR{{ELSE POINT TO ENTRY{27514
{{LDI{9,(XR){{{GET NR OF EXECUTIONS SO FAR{27515
{{ADI{4,INTV1{{{NUDGE UP ONE{27516
{{STI{9,(XR){{{AND PUT BACK{27517
{{JSR{6,SYSTM{{{GET TIME NOW{27518
{{STI{3,PFETM{{{STASH ENDING TIME{27519
{{SBI{3,PFSTM{{{SUBTRACT START TIME{27520
{{ADI{13,CFP$I(XR){{{ADD CUMULATIVE TIME SO FAR{27521
{{STI{13,CFP$I(XR){{{AND PUT BACK NEW TOTAL{27522
{{LDI{3,PFETM{{{LOAD END TIME OF THIS STMT ...{27523
{{STI{3,PFSTM{{{... WHICH IS START TIME OF NEXT{27524
*
*      MERGE HERE TO EXIT
*
{PFLU3{MOV{10,(XS)+{7,XR{{RESTORE CALLERS XR{27528
{{MOV{3,PFSVW{8,WA{{RESTORE SAVED REG{27529
{{EXI{{{{AND RETURN{27530
*
*      HERE IF PROFILE IS SUPPRESSED BECAUSE A PROGRAM DEFINED
*      FUNCTION IS ABOUT TO BE ENTERED, AND SO THE CURRENT STMT
*      HAS NOT YET FINISHED
*
{PFLU4{ZER{3,PFFNC{{{RESET THE CONDITION FLAG{27536
{{EXI{{{{AND IMMEDIATE RETURN{27537
{{ENP{{{{END OF PROCEDURE PRFLU{27538
{{EJC{{{{{27539
*
*      PRPAR - PROCESS PRINT PARAMETERS
*
*      (WC)                  IF NONZERO ASSOCIATE TERMINAL ONLY
*      JSR  PRPAR            CALL TO PROCESS PRINT PARAMETERS
*      (XL,XR,WA,WB,WC)      DESTROYED
*
*      SINCE MEMORY ALLOCATION IS UNDECIDED ON INITIAL CALL,
*      TERMINAL CANNOT BE ASSOCIATED. THE ENTRY WITH WC NON-ZERO
*      IS PROVIDED SO A LATER CALL CAN BE MADE TO COMPLETE THIS.
*
{PRPAR{PRC{25,E{1,0{{ENTRY POINT{27552
{{BNZ{8,WC{6,PRPA8{{JUMP TO ASSOCIATE TERMINAL{27553
{{JSR{6,SYSPP{{{GET PRINT PARAMETERS{27554
{{BNZ{8,WB{6,PRPA1{{JUMP IF LINES/PAGE SPECIFIED{27555
{{MOV{18,=CFP$M{8,WB{{ELSE USE A LARGE VALUE{27556
{{RSH{8,WB{1,1{{BUT NOT TOO LARGE{27557
*
*      STORE LINE COUNT/PAGE
*
{PRPA1{MOV{8,WB{3,LSTNP{{STORE NUMBER OF LINES/PAGE{27561
{{MOV{8,WB{3,LSTLC{{PRETEND PAGE IS FULL INITIALLY{27562
{{ZER{3,LSTPG{{{CLEAR PAGE NUMBER{27563
{{MOV{3,PRLEN{8,WB{{GET PRIOR LENGTH IF ANY{27564
{{BZE{8,WB{6,PRPA2{{SKIP IF NO LENGTH{27565
{{BGT{8,WA{8,WB{6,PRPA3{SKIP STORING IF TOO BIG{27566
*
*      STORE PRINT BUFFER LENGTH
*
{PRPA2{MOV{8,WA{3,PRLEN{{STORE VALUE{27570
*
*      PROCESS BITS OPTIONS
*
{PRPA3{MOV{4,BITS3{8,WB{{BIT 3 MASK{27574
{{ANB{8,WC{8,WB{{GET -NOLIST BIT{27575
{{ZRB{8,WB{6,PRPA4{{SKIP IF CLEAR{27576
{{ZER{3,CSWLS{{{SET -NOLIST{27577
*
*      CHECK IF FAIL REPORTS GOTO INTERACTIVE CHANNEL
*
{PRPA4{MOV{4,BITS1{8,WB{{BIT 1 MASK{27581
{{ANB{8,WC{8,WB{{GET BIT{27582
{{MOV{8,WB{3,ERICH{{STORE INT. CHAN. ERROR FLAG{27583
{{MOV{4,BITS2{8,WB{{BIT 2 MASK{27584
{{ANB{8,WC{8,WB{{GET BIT{27585
{{MOV{8,WB{3,PRICH{{FLAG FOR STD PRINTER ON INT. CHAN.{27586
{{MOV{4,BITS4{8,WB{{BIT 4 MASK{27587
{{ANB{8,WC{8,WB{{GET BIT{27588
{{MOV{8,WB{3,CPSTS{{FLAG FOR COMPILE STATS SUPPRESSN.{27589
{{MOV{4,BITS5{8,WB{{BIT 5 MASK{27590
{{ANB{8,WC{8,WB{{GET BIT{27591
{{MOV{8,WB{3,EXSTS{{FLAG FOR EXEC STATS SUPPRESSION{27592
{{EJC{{{{{27593
*
*      PRPAR (CONTINUED)
*
{{MOV{4,BITS6{8,WB{{BIT 6 MASK{27597
{{ANB{8,WC{8,WB{{GET BIT{27598
{{MOV{8,WB{3,PRECL{{EXTENDED/COMPACT LISTING FLAG{27599
{{SUB{18,=NUM08{8,WA{{POINT 8 CHARS FROM LINE END{27600
{{ZRB{8,WB{6,PRPA5{{JUMP IF NOT EXTENDED{27601
{{MOV{8,WA{3,LSTPO{{STORE FOR LISTING PAGE HEADINGS{27602
*
*       CONTINUE OPTION PROCESSING
*
{PRPA5{MOV{4,BITS7{8,WB{{BIT 7 MASK{27606
{{ANB{8,WC{8,WB{{GET BIT 7{27607
{{MOV{8,WB{3,CSWEX{{SET -NOEXECUTE IF NON-ZERO{27608
{{MOV{4,BIT10{8,WB{{BIT 10 MASK{27609
{{ANB{8,WC{8,WB{{GET BIT 10{27610
{{MOV{8,WB{3,HEADP{{PRETEND PRINTED TO OMIT HEADERS{27611
{{MOV{4,BITS9{8,WB{{BIT 9 MASK{27612
{{ANB{8,WC{8,WB{{GET BIT 9{27613
{{MOV{8,WB{3,PRSTO{{KEEP IT AS STD LISTING OPTION{27614
{{MOV{8,WC{8,WB{{COPY FLAGS{27616
{{RSH{8,WB{1,12{{RIGHT JUSTIFY BIT 13{27617
{{ANB{4,BITS1{8,WB{{GET BIT{27618
{{MOV{8,WB{3,KVCAS{{SET -CASE{27619
{{MOV{4,BIT12{8,WB{{BIT 12 MASK{27621
{{ANB{8,WC{8,WB{{GET BIT 12{27622
{{MOV{8,WB{3,CSWER{{KEEP IT AS ERRORS/NOERRORS OPTION{27623
{{ZRB{8,WB{6,PRPA6{{SKIP IF CLEAR{27624
{{MOV{3,PRLEN{8,WA{{GET PRINT BUFFER LENGTH{27625
{{SUB{18,=NUM08{8,WA{{POINT 8 CHARS FROM LINE END{27626
{{MOV{8,WA{3,LSTPO{{STORE PAGE OFFSET{27627
*
*      CHECK FOR -PRINT/-NOPRINT
*
{PRPA6{MOV{4,BIT11{8,WB{{BIT 11 MASK{27631
{{ANB{8,WC{8,WB{{GET BIT 11{27632
{{MOV{8,WB{3,CSWPR{{SET -PRINT IF NON-ZERO{27633
*
*      CHECK FOR TERMINAL
*
{{ANB{4,BITS8{8,WC{{SEE IF TERMINAL TO BE ACTIVATED{27637
{{BNZ{8,WC{6,PRPA8{{JUMP IF TERMINAL REQUIRED{27638
{{BZE{3,INITR{6,PRPA9{{JUMP IF NO TERMINAL TO DETACH{27639
{{MOV{21,=V$TER{7,XL{{PTR TO /TERMINAL/{27640
{{JSR{6,GTNVR{{{GET VRBLK POINTER{27641
{{PPM{{{{CANT FAIL{27642
{{MOV{21,=NULLS{13,VRVAL(XR){{CLEAR VALUE OF TERMINAL{27643
{{JSR{6,SETVR{{{REMOVE ASSOCIATION{27644
{{BRN{6,PRPA9{{{RETURN{27645
*
*      ASSOCIATE TERMINAL
*
{PRPA8{MNZ{3,INITR{{{NOTE TERMINAL ASSOCIATED{27649
{{BZE{3,DNAMB{6,PRPA9{{CANT IF MEMORY NOT ORGANISED{27650
{{MOV{21,=V$TER{7,XL{{POINT TO TERMINAL STRING{27651
{{MOV{18,=TRTOU{8,WB{{OUTPUT TRACE TYPE{27652
{{JSR{6,INOUT{{{ATTACH OUTPUT TRBLK TO VRBLK{27653
{{MOV{7,XR{11,-(XS){{STACK TRBLK PTR{27654
{{MOV{21,=V$TER{7,XL{{POINT TO TERMINAL STRING{27655
{{MOV{18,=TRTIN{8,WB{{INPUT TRACE TYPE{27656
{{JSR{6,INOUT{{{ATTACH INPUT TRACE BLK{27657
{{MOV{10,(XS)+{13,VRVAL(XR){{ADD OUTPUT TRBLK TO CHAIN{27658
*
*      RETURN POINT
*
{PRPA9{EXI{{{{RETURN{27662
{{ENP{{{{END PROCEDURE PRPAR{27663
{{EJC{{{{{27664
*
*      PRTCH -- PRINT A CHARACTER
*
*      PRTCH IS USED TO PRINT A SINGLE CHARACTER
*
*      (WA)                  CHARACTER TO BE PRINTED
*      JSR  PRTCH            CALL TO PRINT CHARACTER
*
{PRTCH{PRC{25,E{1,0{{ENTRY POINT{27673
{{MOV{7,XR{11,-(XS){{SAVE XR{27674
{{BNE{3,PROFS{3,PRLEN{6,PRCH1{JUMP IF ROOM IN BUFFER{27675
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{27676
*
*      HERE AFTER MAKING SURE WE HAVE ROOM
*
{PRCH1{MOV{3,PRBUF{7,XR{{POINT TO PRINT BUFFER{27680
{{PSC{7,XR{3,PROFS{{POINT TO NEXT CHARACTER LOCATION{27681
{{SCH{8,WA{9,(XR){{STORE NEW CHARACTER{27682
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{27683
{{ICV{3,PROFS{{{BUMP POINTER{27684
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27685
{{EXI{{{{RETURN TO PRTCH CALLER{27686
{{ENP{{{{END PROCEDURE PRTCH{27687
{{EJC{{{{{27688
*
*      PRTIC -- PRINT TO INTERACTIVE CHANNEL
*
*      PRTIC IS CALLED TO PRINT THE CONTENTS OF THE STANDARD
*      PRINT BUFFER TO THE INTERACTIVE CHANNEL. IT IS ONLY
*      CALLED AFTER PRTST HAS SET UP THE STRING FOR PRINTING.
*      IT DOES NOT CLEAR THE BUFFER.
*
*      JSR  PRTIC            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTIC{PRC{25,E{1,0{{ENTRY POINT{27700
{{MOV{7,XR{11,-(XS){{SAVE XR{27701
{{MOV{3,PRBUF{7,XR{{POINT TO BUFFER{27702
{{MOV{3,PROFS{8,WA{{NO OF CHARS{27703
{{JSR{6,SYSPI{{{PRINT{27704
{{PPM{6,PRTC2{{{FAIL RETURN{27705
*
*      RETURN
*
{PRTC1{MOV{10,(XS)+{7,XR{{RESTORE XR{27709
{{EXI{{{{RETURN{27710
*
*      ERROR OCCURED
*
{PRTC2{ZER{3,ERICH{{{PREVENT LOOPING{27714
{{ERB{1,252{26,Error on printing to interactive channel{{{27715
{{BRN{6,PRTC1{{{RETURN{27716
{{ENP{{{{PROCEDURE PRTIC{27717
{{EJC{{{{{27718
*
*      PRTIS -- PRINT TO INTERACTIVE AND STANDARD PRINTER
*
*      PRTIS PUTS A LINE FROM THE PRINT BUFFER ONTO THE
*      INTERACTIVE CHANNEL (IF ANY) AND THE STANDARD PRINTER.
*      IT ALWAYS PRINTS TO THE STANDARD PRINTER BUT DOES
*      NOT DUPLICATE LINES IF THE STANDARD PRINTER IS
*      INTERACTIVE.  IT CLEARS DOWN THE PRINT BUFFER.
*
*      JSR  PRTIS            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTIS{PRC{25,E{1,0{{ENTRY POINT{27731
{{BNZ{3,PRICH{6,PRTS1{{JUMP IF STANDARD PRINTER IS INT.CH.{27732
{{BZE{3,ERICH{6,PRTS1{{SKIP IF NOT DOING INT. ERROR REPS.{27733
{{JSR{6,PRTIC{{{PRINT TO INTERACTIVE CHANNEL{27734
*
*      MERGE AND EXIT
*
{PRTS1{JSR{6,PRTNL{{{PRINT TO STANDARD PRINTER{27738
{{EXI{{{{RETURN{27739
{{ENP{{{{END PROCEDURE PRTIS{27740
{{EJC{{{{{27741
*
*      PRTIN -- PRINT AN INTEGER
*
*      PRTIN PRINTS THE INTEGER VALUE WHICH IS IN THE INTEGER
*      ACCUMULATOR. BLOCKS BUILT IN DYNAMIC STORAGE
*      DURING THIS PROCESS ARE IMMEDIATELY DELETED.
*
*      (IA)                  INTEGER VALUE TO BE PRINTED
*      JSR  PRTIN            CALL TO PRINT INTEGER
*      (IA,RA)               DESTROYED
*
{PRTIN{PRC{25,E{1,0{{ENTRY POINT{27753
{{MOV{7,XR{11,-(XS){{SAVE XR{27754
{{JSR{6,ICBLD{{{BUILD INTEGER BLOCK{27755
{{BLO{7,XR{3,DNAMB{6,PRTI1{JUMP IF ICBLK BELOW DYNAMIC{27756
{{BHI{7,XR{3,DNAMP{6,PRTI1{JUMP IF ABOVE DYNAMIC{27757
{{MOV{7,XR{3,DNAMP{{IMMEDIATELY DELETE IT{27758
*
*      DELETE ICBLK FROM DYNAMIC STORE
*
{PRTI1{MOV{7,XR{11,-(XS){{STACK PTR FOR GTSTG{27762
{{JSR{6,GTSTG{{{CONVERT TO STRING{27763
{{PPM{{{{CONVERT ERROR IS IMPOSSIBLE{27764
{{MOV{7,XR{3,DNAMP{{RESET POINTER TO DELETE SCBLK{27765
{{JSR{6,PRTST{{{PRINT INTEGER STRING{27766
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27767
{{EXI{{{{RETURN TO PRTIN CALLER{27768
{{ENP{{{{END PROCEDURE PRTIN{27769
{{EJC{{{{{27770
*
*      PRTMI -- PRINT MESSAGE AND INTEGER
*
*      PRTMI IS USED TO PRINT MESSAGES TOGETHER WITH AN INTEGER
*      VALUE STARTING IN COLUMN 15 (USED BY THE ROUTINES AT
*      THE END OF COMPILATION).
*
*      JSR  PRTMI            CALL TO PRINT MESSAGE AND INTEGER
*
{PRTMI{PRC{25,E{1,0{{ENTRY POINT{27780
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{27781
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{27782
{{JSR{6,PRTIN{{{PRINT INTEGER{27783
{{JSR{6,PRTNL{{{PRINT LINE{27784
{{EXI{{{{RETURN TO PRTMI CALLER{27785
{{ENP{{{{END PROCEDURE PRTMI{27786
{{EJC{{{{{27787
*
*      PRTMM -- PRINT MEMORY USED AND AVAILABLE
*
*      PRTMM IS USED TO PROVIDE MEMORY USAGE INFORMATION IN
*      BOTH THE END-OF-COMPILE AND END-OF-RUN STATISTICS.
*
*      JSR  PRTMM            CALL TO PRINT MEMORY STATS
*
{PRTMM{PRC{25,E{1,0{{{27796
{{MOV{3,DNAMP{8,WA{{NEXT AVAILABLE LOC{27797
{{SUB{3,STATB{8,WA{{MINUS START{27798
{{MTI{8,WA{{{CONVERT TO INTEGER{27803
{{MOV{21,=ENCM1{7,XR{{POINT TO /MEMORY USED (WORDS)/{27804
{{JSR{6,PRTMI{{{PRINT MESSAGE{27805
{{MOV{3,DNAME{8,WA{{END OF MEMORY{27806
{{SUB{3,DNAMP{8,WA{{MINUS NEXT AVAILABLE LOC{27807
{{MTI{8,WA{{{CONVERT TO INTEGER{27812
{{MOV{21,=ENCM2{7,XR{{POINT TO /MEMORY AVAILABLE (WORDS)/{27813
{{JSR{6,PRTMI{{{PRINT LINE{27814
{{EXI{{{{RETURN TO PRTMM CALLER{27815
{{ENP{{{{END OF PROCEDURE PRTMM{27816
{{EJC{{{{{27817
*
*      PRTMX  -- AS PRTMI WITH EXTRA COPY TO INTERACTIVE CHAN.
*
*      JSR  PRTMX            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTMX{PRC{25,E{1,0{{ENTRY POINT{27824
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{27825
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{27826
{{JSR{6,PRTIN{{{PRINT INTEGER{27827
{{JSR{6,PRTIS{{{PRINT LINE{27828
{{EXI{{{{RETURN{27829
{{ENP{{{{END PROCEDURE PRTMX{27830
{{EJC{{{{{27831
*
*      PRTNL -- PRINT NEW LINE (END PRINT LINE)
*
*      PRTNL PRINTS THE CONTENTS OF THE PRINT BUFFER, RESETS
*      THE BUFFER TO ALL BLANKS AND RESETS THE PRINT POINTER.
*
*      JSR  PRTNL            CALL TO PRINT LINE
*
{PRTNL{PRC{25,R{1,0{{ENTRY POINT{27840
{{BNZ{3,HEADP{6,PRNL0{{WERE HEADERS PRINTED{27841
{{JSR{6,PRTPS{{{NO - PRINT THEM{27842
*
*      CALL SYSPR
*
{PRNL0{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{27846
{{MOV{8,WA{3,PRTSA{{SAVE WA{27847
{{MOV{8,WB{3,PRTSB{{SAVE WB{27848
{{MOV{3,PRBUF{7,XR{{LOAD POINTER TO BUFFER{27849
{{MOV{3,PROFS{8,WA{{LOAD NUMBER OF CHARS IN BUFFER{27850
{{JSR{6,SYSPR{{{CALL SYSTEM PRINT ROUTINE{27851
{{PPM{6,PRNL2{{{JUMP IF FAILED{27852
{{LCT{8,WA{3,PRLNW{{LOAD LENGTH OF BUFFER IN WORDS{27853
{{ADD{19,*SCHAR{7,XR{{POINT TO CHARS OF BUFFER{27854
{{MOV{4,NULLW{8,WB{{GET WORD OF BLANKS{27855
*
*      LOOP TO BLANK BUFFER
*
{PRNL1{MOV{8,WB{10,(XR)+{{STORE WORD OF BLANKS, BUMP PTR{27859
{{BCT{8,WA{6,PRNL1{{LOOP TILL ALL BLANKED{27860
*
*      EXIT POINT
*
{{MOV{3,PRTSB{8,WB{{RESTORE WB{27864
{{MOV{3,PRTSA{8,WA{{RESTORE WA{27865
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27866
{{ZER{3,PROFS{{{RESET PRINT BUFFER POINTER{27867
{{EXI{{{{RETURN TO PRTNL CALLER{27868
*
*      FILE FULL OR NO OUTPUT FILE FOR LOAD MODULE
*
{PRNL2{BNZ{3,PRTEF{6,PRNL3{{JUMP IF NOT FIRST TIME{27872
{{MNZ{3,PRTEF{{{MARK FIRST OCCURRENCE{27873
{{ERB{1,253{26,Print limit exceeded on standard output channel{{{27874
*
*      STOP AT ONCE
*
{PRNL3{MOV{18,=NINI8{8,WB{{ENDING CODE{27878
{{MOV{3,KVSTN{8,WA{{STATEMENT NUMBER{27879
{{MOV{3,R$FCB{7,XL{{GET FCBLK CHAIN HEAD{27880
{{JSR{6,SYSEJ{{{STOP{27881
{{ENP{{{{END PROCEDURE PRTNL{27882
{{EJC{{{{{27883
*
*      PRTNM -- PRINT VARIABLE NAME
*
*      PRTNM IS USED TO PRINT A CHARACTER REPRESENTATION OF THE
*      NAME OF A VARIABLE (NOT A VALUE OF DATATYPE NAME)
*      NAMES OF PSEUDO-VARIABLES MAY NOT BE PASSED TO PRTNM.
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNM            CALL TO PRINT NAME
*      (WB,WC,RA)            DESTROYED
*
{PRTNM{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE, SEE PRTVL){27896
{{MOV{8,WA{11,-(XS){{SAVE WA (OFFSET IS COLLECTABLE){27897
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{27898
{{MOV{7,XL{11,-(XS){{SAVE NAME BASE{27899
{{BHI{7,XL{3,STATE{6,PRN02{JUMP IF NOT NATURAL VARIABLE{27900
*
*      HERE FOR NATURAL VARIABLE NAME, RECOGNIZED BY THE FACT
*      THAT THE NAME BASE POINTS INTO THE STATIC AREA.
*
{{MOV{7,XL{7,XR{{POINT TO VRBLK{27905
{{JSR{6,PRTVN{{{PRINT NAME OF VARIABLE{27906
*
*      COMMON EXIT POINT
*
{PRN01{MOV{10,(XS)+{7,XL{{RESTORE NAME BASE{27910
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY VALUE OF XR{27911
{{MOV{10,(XS)+{8,WA{{RESTORE WA{27912
{{EXI{{{{RETURN TO PRTNM CALLER{27913
*
*      HERE FOR CASE OF NON-NATURAL VARIABLE
*
{PRN02{MOV{8,WA{8,WB{{COPY NAME OFFSET{27917
{{BNE{9,(XL){22,=B$PDT{6,PRN03{JUMP IF ARRAY OR TABLE{27918
*
*      FOR PROGRAM DEFINED DATATYPE, PRT FLD NAME, LEFT PAREN
*
{{MOV{13,PDDFP(XL){7,XR{{LOAD POINTER TO DFBLK{27922
{{ADD{8,WA{7,XR{{ADD NAME OFFSET{27923
{{MOV{13,PDFOF(XR){7,XR{{LOAD VRBLK POINTER FOR FIELD{27924
{{JSR{6,PRTVN{{{PRINT FIELD NAME{27925
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{27926
{{JSR{6,PRTCH{{{PRINT CHARACTER{27927
{{EJC{{{{{27928
*
*      PRTNM (CONTINUED)
*
*      NOW WE PRINT AN IDENTIFYING NAME FOR THE OBJECT IF ONE
*      CAN BE FOUND. THE FOLLOWING CODE SEARCHES FOR A NATURAL
*      VARIABLE WHICH CONTAINS THIS OBJECT AS VALUE. IF SUCH A
*      VARIABLE IS FOUND, ITS NAME IS PRINTED, ELSE THE VALUE
*      OF THE OBJECT (AS PRINTED BY PRTVL) IS USED INSTEAD.
*
*      FIRST WE POINT TO THE PARENT TBBLK IF THIS IS THE CASE OF
*      A TABLE ELEMENT. TO DO THIS, CHASE DOWN THE TRNXT CHAIN.
*
{PRN03{BNE{9,(XL){22,=B$TET{6,PRN04{JUMP IF WE GOT THERE (OR NOT TE){27941
{{MOV{13,TENXT(XL){7,XL{{ELSE MOVE OUT ON CHAIN{27942
{{BRN{6,PRN03{{{AND LOOP BACK{27943
*
*      NOW WE ARE READY FOR THE SEARCH. TO SPEED THINGS UP IN
*      THE CASE OF CALLS FROM DUMP WHERE THE SAME NAME BASE
*      WILL OCCUR REPEATEDLY WHILE DUMPING AN ARRAY OR TABLE,
*      WE REMEMBER THE LAST VRBLK POINTER FOUND IN PRNMV. SO
*      FIRST CHECK TO SEE IF WE HAVE THIS ONE AGAIN.
*
{PRN04{MOV{3,PRNMV{7,XR{{POINT TO VRBLK WE FOUND LAST TIME{27951
{{MOV{3,HSHTB{8,WA{{POINT TO HASH TABLE IN CASE NOT{27952
{{BRN{6,PRN07{{{JUMP INTO SEARCH FOR SPECIAL CHECK{27953
*
*      LOOP THROUGH HASH SLOTS
*
{PRN05{MOV{8,WA{7,XR{{COPY SLOT POINTER{27957
{{ICA{8,WA{{{BUMP SLOT POINTER{27958
{{SUB{19,*VRNXT{7,XR{{INTRODUCE STANDARD VRBLK OFFSET{27959
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{PRN06{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON HASH CHAIN{27963
*
*      MERGE HERE FIRST TIME TO CHECK BLOCK WE FOUND LAST TIME
*
{PRN07{MOV{7,XR{8,WC{{COPY VRBLK POINTER{27967
{{BZE{8,WC{6,PRN09{{JUMP IF CHAIN END (OR PRNMV ZERO){27968
{{EJC{{{{{27969
*
*      PRTNM (CONTINUED)
*
*      LOOP TO FIND VALUE (CHASE DOWN POSSIBLE TRBLK CHAIN)
*
{PRN08{MOV{13,VRVAL(XR){7,XR{{LOAD VALUE{27975
{{BEQ{9,(XR){22,=B$TRT{6,PRN08{LOOP IF THAT WAS A TRBLK{27976
*
*      NOW WE HAVE THE VALUE, IS THIS THE BLOCK WE WANT
*
{{BEQ{7,XR{7,XL{6,PRN10{JUMP IF THIS MATCHES THE NAME BASE{27980
{{MOV{8,WC{7,XR{{ELSE POINT BACK TO THAT VRBLK{27981
{{BRN{6,PRN06{{{AND LOOP BACK{27982
*
*      HERE TO MOVE TO NEXT HASH SLOT
*
{PRN09{BLT{8,WA{3,HSHTE{6,PRN05{LOOP BACK IF MORE TO GO{27986
{{MOV{7,XL{7,XR{{ELSE NOT FOUND, COPY VALUE POINTER{27987
{{JSR{6,PRTVL{{{PRINT VALUE{27988
{{BRN{6,PRN11{{{AND MERGE AHEAD{27989
*
*      HERE WHEN WE FIND A MATCHING ENTRY
*
{PRN10{MOV{8,WC{7,XR{{COPY VRBLK POINTER{27993
{{MOV{7,XR{3,PRNMV{{SAVE FOR NEXT TIME IN{27994
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{27995
*
*      MERGE HERE IF NO ENTRY FOUND
*
{PRN11{MOV{9,(XL){8,WC{{LOAD FIRST WORD OF NAME BASE{27999
{{BNE{8,WC{22,=B$PDT{6,PRN13{JUMP IF NOT PROGRAM DEFINED{28000
*
*      FOR PROGRAM DEFINED DATATYPE, ADD RIGHT PAREN AND EXIT
*
{{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN, MERGE{28004
*
*      MERGE HERE TO PRINT FINAL RIGHT PAREN OR BRACKET
*
{PRN12{JSR{6,PRTCH{{{PRINT FINAL CHARACTER{28008
{{MOV{8,WB{8,WA{{RESTORE NAME OFFSET{28009
{{BRN{6,PRN01{{{MERGE BACK TO EXIT{28010
{{EJC{{{{{28011
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY OR TABLE
*
{PRN13{MOV{18,=CH$BB{8,WA{{LOAD LEFT BRACKET{28017
{{JSR{6,PRTCH{{{AND PRINT IT{28018
{{MOV{9,(XS){7,XL{{RESTORE BLOCK POINTER{28019
{{MOV{9,(XL){8,WC{{LOAD TYPE WORD AGAIN{28020
{{BNE{8,WC{22,=B$TET{6,PRN15{JUMP IF NOT TABLE{28021
*
*      HERE FOR TABLE, PRINT SUBSCRIPT VALUE
*
{{MOV{13,TESUB(XL){7,XR{{LOAD SUBSCRIPT VALUE{28025
{{MOV{8,WB{7,XL{{SAVE NAME OFFSET{28026
{{JSR{6,PRTVL{{{PRINT SUBSCRIPT VALUE{28027
{{MOV{7,XL{8,WB{{RESTORE NAME OFFSET{28028
*
*      MERGE HERE FROM ARRAY CASE TO PRINT RIGHT BRACKET
*
{PRN14{MOV{18,=CH$RB{8,WA{{LOAD RIGHT BRACKET{28032
{{BRN{6,PRN12{{{MERGE BACK TO PRINT IT{28033
*
*      HERE FOR ARRAY OR VECTOR, TO PRINT SUBSCRIPT(S)
*
{PRN15{MOV{8,WB{8,WA{{COPY NAME OFFSET{28037
{{BTW{8,WA{{{CONVERT TO WORDS{28038
{{BEQ{8,WC{22,=B$ART{6,PRN16{JUMP IF ARBLK{28039
*
*      HERE FOR VECTOR
*
{{SUB{18,=VCVLB{8,WA{{ADJUST FOR STANDARD FIELDS{28043
{{MTI{8,WA{{{MOVE TO INTEGER ACCUM{28044
{{JSR{6,PRTIN{{{PRINT LINEAR SUBSCRIPT{28045
{{BRN{6,PRN14{{{MERGE BACK FOR RIGHT BRACKET{28046
{{EJC{{{{{28047
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY. FIRST CALCULATE ABSOLUTE SUBSCRIPT
*      OFFSETS BY SUCCESSIVE DIVISIONS BY THE DIMENSION VALUES.
*      THIS MUST BE DONE RIGHT TO LEFT SINCE THE ELEMENTS ARE
*      STORED ROW-WISE. THE SUBSCRIPTS ARE STACKED AS INTEGERS.
*
{PRN16{MOV{13,AROFS(XL){8,WC{{LOAD LENGTH OF BOUNDS INFO{28056
{{ICA{8,WC{{{ADJUST FOR ARPRO FIELD{28057
{{BTW{8,WC{{{CONVERT TO WORDS{28058
{{SUB{8,WC{8,WA{{GET LINEAR ZERO-ORIGIN SUBSCRIPT{28059
{{MTI{8,WA{{{GET INTEGER VALUE{28060
{{LCT{8,WA{13,ARNDM(XL){{SET NUM OF DIMENSIONS AS LOOP COUNT{28061
{{ADD{13,AROFS(XL){7,XL{{POINT PAST BOUNDS INFORMATION{28062
{{SUB{19,*ARLBD{7,XL{{SET OK OFFSET FOR PROPER PTR LATER{28063
*
*      LOOP TO STACK SUBSCRIPT OFFSETS
*
{PRN17{SUB{19,*ARDMS{7,XL{{POINT TO NEXT SET OF BOUNDS{28067
{{STI{3,PRNSI{{{SAVE CURRENT OFFSET{28068
{{RMI{13,ARDIM(XL){{{GET REMAINDER ON DIVIDING BY DIMENS{28069
{{MFI{11,-(XS){{{STORE ON STACK (ONE WORD){28070
{{LDI{3,PRNSI{{{RELOAD ARGUMENT{28071
{{DVI{13,ARDIM(XL){{{DIVIDE TO GET QUOTIENT{28072
{{BCT{8,WA{6,PRN17{{LOOP TILL ALL STACKED{28073
{{ZER{7,XR{{{SET OFFSET TO FIRST SET OF BOUNDS{28074
{{LCT{8,WB{13,ARNDM(XL){{LOAD COUNT OF DIMS TO CONTROL LOOP{28075
{{BRN{6,PRN19{{{JUMP INTO PRINT LOOP{28076
*
*      LOOP TO PRINT SUBSCRIPTS FROM STACK ADJUSTING BY ADDING
*      THE APPROPRIATE LOW BOUND VALUE FROM THE ARBLK
*
{PRN18{MOV{18,=CH$CM{8,WA{{LOAD A COMMA{28081
{{JSR{6,PRTCH{{{PRINT IT{28082
*
*      MERGE HERE FIRST TIME IN (NO COMMA REQUIRED)
*
{PRN19{MTI{10,(XS)+{{{LOAD SUBSCRIPT OFFSET AS INTEGER{28086
{{ADD{7,XR{7,XL{{POINT TO CURRENT LBD{28087
{{ADI{13,ARLBD(XL){{{ADD LBD TO GET SIGNED SUBSCRIPT{28088
{{SUB{7,XR{7,XL{{POINT BACK TO START OF ARBLK{28089
{{JSR{6,PRTIN{{{PRINT SUBSCRIPT{28090
{{ADD{19,*ARDMS{7,XR{{BUMP OFFSET TO NEXT BOUNDS{28091
{{BCT{8,WB{6,PRN18{{LOOP BACK TILL ALL PRINTED{28092
{{BRN{6,PRN14{{{MERGE BACK TO PRINT RIGHT BRACKET{28093
{{ENP{{{{END PROCEDURE PRTNM{28094
{{EJC{{{{{28095
*
*      PRTNV -- PRINT NAME VALUE
*
*      PRTNV IS USED BY THE TRACE AND DUMP ROUTINES TO PRINT
*      A LINE OF THE FORM
*
*      NAME = VALUE
*
*      NOTE THAT THE NAME INVOLVED CAN NEVER BE A PSEUDO-VAR
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNV            CALL TO PRINT NAME = VALUE
*      (WB,WC,RA)            DESTROYED
*
{PRTNV{PRC{25,E{1,0{{ENTRY POINT{28111
{{JSR{6,PRTNM{{{PRINT ARGUMENT NAME{28112
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{28113
{{MOV{8,WA{11,-(XS){{SAVE NAME OFFSET (COLLECTABLE){28114
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK EQUAL BLANK{28115
{{JSR{6,PRTST{{{PRINT IT{28116
{{MOV{7,XL{7,XR{{COPY NAME BASE{28117
{{ADD{8,WA{7,XR{{POINT TO VALUE{28118
{{MOV{9,(XR){7,XR{{LOAD VALUE POINTER{28119
{{JSR{6,PRTVL{{{PRINT VALUE{28120
{{JSR{6,PRTNL{{{TERMINATE LINE{28121
{{MOV{10,(XS)+{8,WA{{RESTORE NAME OFFSET{28122
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{28123
{{EXI{{{{RETURN TO CALLER{28124
{{ENP{{{{END PROCEDURE PRTNV{28125
{{EJC{{{{{28126
*
*      PRTPG  -- PRINT A PAGE THROW
*
*      PRINTS A PAGE THROW OR A FEW BLANK LINES ON THE STANDARD
*      LISTING CHANNEL DEPENDING ON THE LISTING OPTIONS CHOSEN.
*
*      JSR  PRTPG            CALL FOR PAGE EJECT
*
{PRTPG{PRC{25,E{1,0{{ENTRY POINT{28135
{{BEQ{3,STAGE{18,=STGXT{6,PRP01{JUMP IF EXECUTION TIME{28136
{{BZE{3,LSTLC{6,PRP06{{RETURN IF TOP OF PAGE ALREADY{28137
{{ZER{3,LSTLC{{{CLEAR LINE COUNT{28138
*
*      CHECK TYPE OF LISTING
*
{PRP01{MOV{7,XR{11,-(XS){{PRESERVE XR{28142
{{BNZ{3,PRSTD{6,PRP02{{EJECT IF FLAG SET{28143
{{BNZ{3,PRICH{6,PRP03{{JUMP IF INTERACTIVE LISTING CHANNEL{28144
{{BZE{3,PRECL{6,PRP03{{JUMP IF COMPACT LISTING{28145
*
*      PERFORM AN EJECT
*
{PRP02{JSR{6,SYSEP{{{EJECT{28149
{{BRN{6,PRP04{{{MERGE{28150
*
*      COMPACT OR INTERACTIVE CHANNEL LISTING. CANT PRINT
*      BLANKS UNTIL CHECK MADE FOR HEADERS PRINTED AND FLAG SET.
*
*
{PRP03{MOV{3,HEADP{7,XR{{REMEMBER HEADP{28156
{{MNZ{3,HEADP{{{SET TO AVOID REPEATED PRTPG CALLS{28157
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28158
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28159
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28160
{{MOV{18,=NUM03{3,LSTLC{{COUNT BLANK LINES{28161
{{MOV{7,XR{3,HEADP{{RESTORE HEADER FLAG{28162
{{EJC{{{{{28163
*
*      PRPTG (CONTINUED)
*
*      PRINT THE HEADING
*
{PRP04{BNZ{3,HEADP{6,PRP05{{JUMP IF HEADER LISTED{28169
{{MNZ{3,HEADP{{{MARK HEADERS PRINTED{28170
{{MOV{7,XL{11,-(XS){{KEEP XL{28171
{{MOV{21,=HEADR{7,XR{{POINT TO LISTING HEADER{28172
{{JSR{6,PRTST{{{PLACE IT{28173
{{JSR{6,SYSID{{{GET SYSTEM IDENTIFICATION{28174
{{JSR{6,PRTST{{{APPEND EXTRA CHARS{28175
{{JSR{6,PRTNL{{{PRINT IT{28176
{{MOV{7,XL{7,XR{{EXTRA HEADER LINE{28177
{{JSR{6,PRTST{{{PLACE IT{28178
{{JSR{6,PRTNL{{{PRINT IT{28179
{{JSR{6,PRTNL{{{PRINT A BLANK{28180
{{JSR{6,PRTNL{{{AND ANOTHER{28181
{{ADD{18,=NUM04{3,LSTLC{{FOUR HEADER LINES PRINTED{28182
{{MOV{10,(XS)+{7,XL{{RESTORE XL{28183
*
*      MERGE IF HEADER NOT PRINTED
*
{PRP05{MOV{10,(XS)+{7,XR{{RESTORE XR{28187
*
*      RETURN
*
{PRP06{EXI{{{{RETURN{28191
{{ENP{{{{END PROCEDURE PRTPG{28192
{{EJC{{{{{28193
*
*      PRTPS - PRINT PAGE WITH TEST FOR STANDARD LISTING OPTION
*
*      IF THE STANDARD LISTING OPTION IS SELECTED, INSIST THAT
*      AN EJECT BE DONE
*
*      JSR  PRTPS            CALL FOR EJECT
*
{PRTPS{PRC{25,E{1,0{{ENTRY POINT{28202
{{MOV{3,PRSTO{3,PRSTD{{COPY OPTION FLAG{28203
{{JSR{6,PRTPG{{{PRINT PAGE{28204
{{ZER{3,PRSTD{{{CLEAR FLAG{28205
{{EXI{{{{RETURN{28206
{{ENP{{{{END PROCEDURE PRTPS{28207
{{EJC{{{{{28208
*
*      PRTSN -- PRINT STATEMENT NUMBER
*
*      PRTSN IS USED TO INITIATE A PRINT TRACE LINE BY PRINTING
*      ASTERISKS AND THE CURRENT STATEMENT NUMBER. THE ACTUAL
*      FORMAT OF THE OUTPUT GENERATED IS.
*
*      ***NNNNN**** III.....IIII
*
*      NNNNN IS THE STATEMENT NUMBER WITH LEADING ZEROS REPLACED
*      BY ASTERISKS (E.G. *******9****)
*
*      III...III REPRESENTS A VARIABLE LENGTH OUTPUT CONSISTING
*      OF A NUMBER OF LETTER I CHARACTERS EQUAL TO FNCLEVEL.
*
*      JSR  PRTSN            CALL TO PRINT STATEMENT NUMBER
*      (WC)                  DESTROYED
*
{PRTSN{PRC{25,E{1,0{{ENTRY POINT{28227
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{28228
{{MOV{8,WA{3,PRSNA{{SAVE ENTRY WA{28229
{{MOV{21,=TMASB{7,XR{{POINT TO ASTERISKS{28230
{{JSR{6,PRTST{{{PRINT ASTERISKS{28231
{{MOV{18,=NUM04{3,PROFS{{POINT INTO MIDDLE OF ASTERISKS{28232
{{MTI{3,KVSTN{{{LOAD STATEMENT NUMBER AS INTEGER{28233
{{JSR{6,PRTIN{{{PRINT INTEGER STATEMENT NUMBER{28234
{{MOV{18,=PRSNF{3,PROFS{{POINT PAST ASTERISKS PLUS BLANK{28235
{{MOV{3,KVFNC{7,XR{{GET FNCLEVEL{28236
{{MOV{18,=CH$LI{8,WA{{SET LETTER I{28237
*
*      LOOP TO GENERATE LETTER I FNCLEVEL TIMES
*
{PRSN1{BZE{7,XR{6,PRSN2{{JUMP IF ALL SET{28241
{{JSR{6,PRTCH{{{ELSE PRINT AN I{28242
{{DCV{7,XR{{{DECREMENT COUNTER{28243
{{BRN{6,PRSN1{{{LOOP BACK{28244
*
*      MERGE WITH ALL LETTER I CHARACTERS GENERATED
*
{PRSN2{MOV{18,=CH$BL{8,WA{{GET BLANK{28248
{{JSR{6,PRTCH{{{PRINT BLANK{28249
{{MOV{3,PRSNA{8,WA{{RESTORE ENTRY WA{28250
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{28251
{{EXI{{{{RETURN TO PRTSN CALLER{28252
{{ENP{{{{END PROCEDURE PRTSN{28253
{{EJC{{{{{28254
*
*      PRTST -- PRINT STRING
*
*      PRTST PLACES A STRING OF CHARACTERS IN THE PRINT BUFFER
*
*      SEE PRTNL FOR GLOBAL LOCATIONS USED
*
*      NOTE THAT THE FIRST WORD OF THE BLOCK (NORMALLY B$SCL)
*      IS NOT USED AND NEED NOT BE SET CORRECTLY (SEE PRTVN)
*
*      (XR)                  STRING TO BE PRINTED
*      JSR  PRTST            CALL TO PRINT STRING
*      (PROFS)               UPDATED PAST CHARS PLACED
*
{PRTST{PRC{25,R{1,0{{ENTRY POINT{28269
{{BNZ{3,HEADP{6,PRST0{{WERE HEADERS PRINTED{28270
{{JSR{6,PRTPS{{{NO - PRINT THEM{28271
*
*      CALL SYSPR
*
{PRST0{MOV{8,WA{3,PRSVA{{SAVE WA{28275
{{MOV{8,WB{3,PRSVB{{SAVE WB{28276
{{ZER{8,WB{{{SET CHARS PRINTED COUNT TO ZERO{28277
*
*      LOOP TO PRINT SUCCESSIVE LINES FOR LONG STRING
*
{PRST1{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{28281
{{SUB{8,WB{8,WA{{SUBTRACT COUNT OF CHARS ALREADY OUT{28282
{{BZE{8,WA{6,PRST4{{JUMP TO EXIT IF NONE LEFT{28283
{{MOV{7,XL{11,-(XS){{ELSE STACK ENTRY XL{28284
{{MOV{7,XR{11,-(XS){{SAVE ARGUMENT{28285
{{MOV{7,XR{7,XL{{COPY FOR EVENTUAL MOVE{28286
{{MOV{3,PRLEN{7,XR{{LOAD PRINT BUFFER LENGTH{28287
{{SUB{3,PROFS{7,XR{{GET CHARS LEFT IN PRINT BUFFER{28288
{{BNZ{7,XR{6,PRST2{{SKIP IF ROOM LEFT ON THIS LINE{28289
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{28290
{{MOV{3,PRLEN{7,XR{{AND SET FULL WIDTH AVAILABLE{28291
{{EJC{{{{{28292
*
*      PRTST (CONTINUED)
*
*      HERE WITH CHARS TO PRINT AND SOME ROOM IN BUFFER
*
{PRST2{BLO{8,WA{7,XR{6,PRST3{JUMP IF ROOM FOR REST OF STRING{28298
{{MOV{7,XR{8,WA{{ELSE SET TO FILL LINE{28299
*
*      MERGE HERE WITH CHARACTER COUNT IN WA
*
{PRST3{MOV{3,PRBUF{7,XR{{POINT TO PRINT BUFFER{28303
{{PLC{7,XL{8,WB{{POINT TO LOCATION IN STRING{28304
{{PSC{7,XR{3,PROFS{{POINT TO LOCATION IN BUFFER{28305
{{ADD{8,WA{8,WB{{BUMP STRING CHARS COUNT{28306
{{ADD{8,WA{3,PROFS{{BUMP BUFFER POINTER{28307
{{MOV{8,WB{3,PRSVC{{PRESERVE CHAR COUNTER{28308
{{MVC{{{{MOVE CHARACTERS TO BUFFER{28309
{{MOV{3,PRSVC{8,WB{{RECOVER CHAR COUNTER{28310
{{MOV{10,(XS)+{7,XR{{RESTORE ARGUMENT POINTER{28311
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{28312
{{BRN{6,PRST1{{{LOOP BACK TO TEST FOR MORE{28313
*
*      HERE TO EXIT AFTER PRINTING STRING
*
{PRST4{MOV{3,PRSVB{8,WB{{RESTORE ENTRY WB{28317
{{MOV{3,PRSVA{8,WA{{RESTORE ENTRY WA{28318
{{EXI{{{{RETURN TO PRTST CALLER{28319
{{ENP{{{{END PROCEDURE PRTST{28320
{{EJC{{{{{28321
*
*      PRTTR -- PRINT TO TERMINAL
*
*      CALLED TO PRINT CONTENTS OF STANDARD PRINT BUFFER TO
*      ONLINE TERMINAL. CLEARS BUFFER DOWN AND RESETS PROFS.
*
*      JSR  PRTTR            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTTR{PRC{25,E{1,0{{ENTRY POINT{28331
{{MOV{7,XR{11,-(XS){{SAVE XR{28332
{{JSR{6,PRTIC{{{PRINT BUFFER CONTENTS{28333
{{MOV{3,PRBUF{7,XR{{POINT TO PRINT BFR TO CLEAR IT{28334
{{LCT{8,WA{3,PRLNW{{GET BUFFER LENGTH{28335
{{ADD{19,*SCHAR{7,XR{{POINT PAST SCBLK HEADER{28336
{{MOV{4,NULLW{8,WB{{GET BLANKS{28337
*
*      LOOP TO CLEAR BUFFER
*
{PRTT1{MOV{8,WB{10,(XR)+{{CLEAR A WORD{28341
{{BCT{8,WA{6,PRTT1{{LOOP{28342
{{ZER{3,PROFS{{{RESET PROFS{28343
{{MOV{10,(XS)+{7,XR{{RESTORE XR{28344
{{EXI{{{{RETURN{28345
{{ENP{{{{END PROCEDURE PRTTR{28346
{{EJC{{{{{28347
*
*      PRTVL -- PRINT A VALUE
*
*      PRTVL PLACES AN APPROPRIATE CHARACTER REPRESENTATION OF
*      A DATA VALUE IN THE PRINT BUFFER FOR DUMP/TRACE USE.
*
*      (XR)                  VALUE TO BE PRINTED
*      JSR  PRTVL            CALL TO PRINT VALUE
*      (WA,WB,WC,RA)         DESTROYED
*
{PRTVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{28358
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{28359
{{MOV{7,XR{11,-(XS){{SAVE ARGUMENT{28360
{{CHK{{{{CHECK FOR STACK OVERFLOW{28361
*
*      LOOP BACK HERE AFTER FINDING A TRAP BLOCK (TRBLK)
*
{PRV01{MOV{13,IDVAL(XR){3,PRVSI{{COPY IDVAL (IF ANY){28365
{{MOV{9,(XR){7,XL{{LOAD FIRST WORD OF BLOCK{28366
{{LEI{7,XL{{{LOAD ENTRY POINT ID{28367
{{BSW{7,XL{2,BL$$T{6,PRV02{SWITCH ON BLOCK TYPE{28368
{{IFF{2,BL$AR{6,PRV05{{ARBLK{28386
{{IFF{1,1{6,PRV02{{{28386
{{IFF{1,2{6,PRV02{{{28386
{{IFF{2,BL$IC{6,PRV08{{ICBLK{28386
{{IFF{2,BL$NM{6,PRV09{{NMBLK{28386
{{IFF{1,5{6,PRV02{{{28386
{{IFF{1,6{6,PRV02{{{28386
{{IFF{1,7{6,PRV02{{{28386
{{IFF{2,BL$RC{6,PRV08{{RCBLK{28386
{{IFF{2,BL$SC{6,PRV11{{SCBLK{28386
{{IFF{2,BL$SE{6,PRV12{{SEBLK{28386
{{IFF{2,BL$TB{6,PRV13{{TBBLK{28386
{{IFF{2,BL$VC{6,PRV13{{VCBLK{28386
{{IFF{1,13{6,PRV02{{{28386
{{IFF{1,14{6,PRV02{{{28386
{{IFF{1,15{6,PRV02{{{28386
{{IFF{2,BL$PD{6,PRV10{{PDBLK{28386
{{IFF{2,BL$TR{6,PRV04{{TRBLK{28386
{{ESW{{{{END OF SWITCH ON BLOCK TYPE{28386
*
*      HERE FOR BLOCKS FOR WHICH WE JUST PRINT DATATYPE NAME
*
{PRV02{JSR{6,DTYPE{{{GET DATATYPE NAME{28390
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28391
*
*      COMMON EXIT POINT
*
{PRV03{MOV{10,(XS)+{7,XR{{RELOAD ARGUMENT{28395
{{MOV{10,(XS)+{7,XL{{RESTORE XL{28396
{{EXI{{{{RETURN TO PRTVL CALLER{28397
*
*      HERE FOR TRBLK
*
{PRV04{MOV{13,TRVAL(XR){7,XR{{LOAD REAL VALUE{28401
{{BRN{6,PRV01{{{AND LOOP BACK{28402
{{EJC{{{{{28403
*
*      PRTVL (CONTINUED)
*
*      HERE FOR ARRAY (ARBLK)
*
*      PRINT ARRAY ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV05{MOV{7,XR{7,XL{{PRESERVE ARGUMENT{28411
{{MOV{21,=SCARR{7,XR{{POINT TO DATATYPE NAME (ARRAY){28412
{{JSR{6,PRTST{{{PRINT IT{28413
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{28414
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{28415
{{ADD{13,AROFS(XL){7,XL{{POINT TO PROTOTYPE{28416
{{MOV{9,(XL){7,XR{{LOAD PROTOTYPE{28417
{{JSR{6,PRTST{{{PRINT PROTOTYPE{28418
*
*      VCBLK, TBBLK, BCBLK MERGE HERE FOR ) BLANK NUMBER IDVAL
*
{PRV06{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN{28422
{{JSR{6,PRTCH{{{PRINT RIGHT PAREN{28423
*
*      PDBLK MERGES HERE TO PRINT BLANK NUMBER IDVAL
*
{PRV07{MOV{18,=CH$BL{8,WA{{LOAD BLANK{28427
{{JSR{6,PRTCH{{{PRINT IT{28428
{{MOV{18,=CH$NM{8,WA{{LOAD NUMBER SIGN{28429
{{JSR{6,PRTCH{{{PRINT IT{28430
{{MTI{3,PRVSI{{{GET IDVAL{28431
{{JSR{6,PRTIN{{{PRINT ID NUMBER{28432
{{BRN{6,PRV03{{{BACK TO EXIT{28433
*
*      HERE FOR INTEGER (ICBLK), REAL (RCBLK)
*
*      PRINT CHARACTER REPRESENTATION OF VALUE
*
{PRV08{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{28439
{{JSR{6,GTSTG{{{CONVERT TO STRING{28440
{{PPM{{{{ERROR RETURN IS IMPOSSIBLE{28441
{{JSR{6,PRTST{{{PRINT THE STRING{28442
{{MOV{7,XR{3,DNAMP{{DELETE GARBAGE STRING FROM STORAGE{28443
{{BRN{6,PRV03{{{BACK TO EXIT{28444
{{EJC{{{{{28445
*
*      PRTVL (CONTINUED)
*
*      NAME (NMBLK)
*
*      FOR PSEUDO-VARIABLE, JUST PRINT DATATYPE NAME (NAME)
*      FOR ALL OTHER NAMES, PRINT DOT FOLLOWED BY NAME REP
*
{PRV09{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{28454
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF BLOCK{28455
{{BEQ{8,WA{22,=B$KVT{6,PRV02{JUST PRINT NAME IF KEYWORD{28456
{{BEQ{8,WA{22,=B$EVT{6,PRV02{JUST PRINT NAME IF EXPRESSION VAR{28457
{{MOV{18,=CH$DT{8,WA{{ELSE GET DOT{28458
{{JSR{6,PRTCH{{{AND PRINT IT{28459
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{28460
{{JSR{6,PRTNM{{{PRINT NAME{28461
{{BRN{6,PRV03{{{BACK TO EXIT{28462
*
*      PROGRAM DATATYPE (PDBLK)
*
*      PRINT DATATYPE NAME CH$BL CH$NM IDVAL
*
{PRV10{JSR{6,DTYPE{{{GET DATATYPE NAME{28468
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28469
{{BRN{6,PRV07{{{MERGE BACK TO PRINT ID{28470
*
*      HERE FOR STRING (SCBLK)
*
*      PRINT QUOTE STRING-CHARACTERS QUOTE
*
{PRV11{MOV{18,=CH$SQ{8,WA{{LOAD SINGLE QUOTE{28476
{{JSR{6,PRTCH{{{PRINT QUOTE{28477
{{JSR{6,PRTST{{{PRINT STRING VALUE{28478
{{JSR{6,PRTCH{{{PRINT ANOTHER QUOTE{28479
{{BRN{6,PRV03{{{BACK TO EXIT{28480
{{EJC{{{{{28481
*
*      PRTVL (CONTINUED)
*
*      HERE FOR SIMPLE EXPRESSION (SEBLK)
*
*      PRINT ASTERISK VARIABLE-NAME
*
{PRV12{MOV{18,=CH$AS{8,WA{{LOAD ASTERISK{28489
{{JSR{6,PRTCH{{{PRINT ASTERISK{28490
{{MOV{13,SEVAR(XR){7,XR{{LOAD VARIABLE POINTER{28491
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{28492
{{BRN{6,PRV03{{{JUMP BACK TO EXIT{28493
*
*      HERE FOR TABLE (TBBLK) AND ARRAY (VCBLK)
*
*      PRINT DATATYPE ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV13{MOV{7,XR{7,XL{{PRESERVE ARGUMENT{28499
{{JSR{6,DTYPE{{{GET DATATYPE NAME{28500
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28501
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{28502
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{28503
{{MOV{13,TBLEN(XL){8,WA{{LOAD LENGTH OF BLOCK (=VCLEN){28504
{{BTW{8,WA{{{CONVERT TO WORD COUNT{28505
{{SUB{18,=TBSI${8,WA{{ALLOW FOR STANDARD FIELDS{28506
{{BEQ{9,(XL){22,=B$TBT{6,PRV14{JUMP IF TABLE{28507
{{ADD{18,=VCTBD{8,WA{{FOR VCBLK, ADJUST SIZE{28508
*
*      PRINT PROTOTYPE
*
{PRV14{MTI{8,WA{{{MOVE AS INTEGER{28512
{{JSR{6,PRTIN{{{PRINT INTEGER PROTOTYPE{28513
{{BRN{6,PRV06{{{MERGE BACK FOR REST{28514
{{ENP{{{{END PROCEDURE PRTVL{28537
{{EJC{{{{{28538
*
*      PRTVN -- PRINT NATURAL VARIABLE NAME
*
*      PRTVN PRINTS THE NAME OF A NATURAL VARIABLE
*
*      (XR)                  POINTER TO VRBLK
*      JSR  PRTVN            CALL TO PRINT VARIABLE NAME
*
{PRTVN{PRC{25,E{1,0{{ENTRY POINT{28547
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{28548
{{ADD{19,*VRSOF{7,XR{{POINT TO POSSIBLE STRING NAME{28549
{{BNZ{13,SCLEN(XR){6,PRVN1{{JUMP IF NOT SYSTEM VARIABLE{28550
{{MOV{13,VRSVO(XR){7,XR{{POINT TO SVBLK WITH NAME{28551
*
*      MERGE HERE WITH DUMMY SCBLK POINTER IN XR
*
{PRVN1{JSR{6,PRTST{{{PRINT STRING NAME OF VARIABLE{28555
{{MOV{10,(XS)+{7,XR{{RESTORE VRBLK POINTER{28556
{{EXI{{{{RETURN TO PRTVN CALLER{28557
{{ENP{{{{END PROCEDURE PRTVN{28558
{{EJC{{{{{28561
*
*      RCBLD -- BUILD A REAL BLOCK
*
*      (RA)                  REAL VALUE FOR RCBLK
*      JSR  RCBLD            CALL TO BUILD REAL BLOCK
*      (XR)                  POINTER TO RESULT RCBLK
*      (WA)                  DESTROYED
*
{RCBLD{PRC{25,E{1,0{{ENTRY POINT{28570
{{MOV{3,DNAMP{7,XR{{LOAD POINTER TO NEXT AVAILABLE LOC{28571
{{ADD{19,*RCSI${7,XR{{POINT PAST NEW RCBLK{28572
{{BLO{7,XR{3,DNAME{6,RCBL1{JUMP IF THERE IS ROOM{28573
{{MOV{19,*RCSI${8,WA{{ELSE LOAD RCBLK LENGTH{28574
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{28575
{{ADD{8,WA{7,XR{{POINT PAST BLOCK TO MERGE{28576
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{RCBL1{MOV{7,XR{3,DNAMP{{SET NEW POINTER{28580
{{SUB{19,*RCSI${7,XR{{POINT BACK TO START OF BLOCK{28581
{{MOV{22,=B$RCL{9,(XR){{STORE TYPE WORD{28582
{{STR{13,RCVAL(XR){{{STORE REAL VALUE IN RCBLK{28583
{{EXI{{{{RETURN TO RCBLD CALLER{28584
{{ENP{{{{END PROCEDURE RCBLD{28585
{{EJC{{{{{28587
*
*      READR -- READ NEXT SOURCE IMAGE AT COMPILE TIME
*
*      READR IS USED TO READ THE NEXT SOURCE IMAGE. TO PROCESS
*      CONTINUATION CARDS PROPERLY, THE COMPILER MUST READ ONE
*      LINE AHEAD. THUS READR DOES NOT DESTROY THE CURRENT IMAGE
*      SEE ALSO THE NEXTS ROUTINE WHICH ACTUALLY GETS THE IMAGE.
*
*      JSR  READR            CALL TO READ NEXT IMAGE
*      (XR)                  PTR TO NEXT IMAGE (0 IF NONE)
*      (R$CNI)               COPY OF POINTER
*      (WA,WB,WC,XL)         DESTROYED
*
{READR{PRC{25,E{1,0{{ENTRY POINT{28601
{{MOV{3,R$CNI{7,XR{{GET PTR TO NEXT IMAGE{28602
{{BNZ{7,XR{6,READ3{{EXIT IF ALREADY READ{28603
{{BNZ{3,CNIND{6,READA{{IF WITHIN INCLUDE FILE{28605
{{BNE{3,STAGE{18,=STGIC{6,READ3{EXIT IF NOT INITIAL COMPILE{28607
{READA{MOV{3,CSWIN{8,WA{{MAX READ LENGTH{28608
{{ZER{7,XL{{{CLEAR ANY DUD VALUE IN XL{28609
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{28610
{{JSR{6,SYSRD{{{READ INPUT IMAGE{28611
{{PPM{6,READ4{{{JUMP IF EOF OR NEW FILE NAME{28612
{{ICV{3,RDNLN{{{INCREMENT NEXT LINE NUMBER{28613
{{DCV{3,POLCT{{{TEST IF TIME TO POLL INTERFACE{28615
{{BNZ{3,POLCT{6,READ0{{NOT YET{28616
{{ZER{8,WA{{{=0 FOR POLL{28617
{{MOV{3,RDNLN{8,WB{{LINE NUMBER{28618
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{28619
{{ERR{1,320{26,User interrupt{{{28620
{{PPM{{{{SINGLE STEP{28621
{{PPM{{{{EXPRESSION EVALUATION{28622
{{MOV{8,WA{3,POLCS{{NEW COUNTDOWN START VALUE{28623
{{MOV{8,WA{3,POLCT{{NEW COUNTER VALUE{28624
{READ0{BLE{13,SCLEN(XR){3,CSWIN{6,READ1{USE SMALLER OF STRING LNTH ...{28626
{{MOV{3,CSWIN{13,SCLEN(XR){{... AND XXX OF -INXXX{28627
*
*      PERFORM THE TRIM
*
{READ1{MNZ{8,WB{{{SET TRIMR TO PERFORM TRIM{28631
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS{28632
*
*      MERGE HERE AFTER READ
*
{READ2{MOV{7,XR{3,R$CNI{{STORE COPY OF POINTER{28636
*
*      MERGE HERE IF NO READ ATTEMPTED
*
{READ3{EXI{{{{RETURN TO READR CALLER{28640
*
*      HERE ON END OF FILE OR NEW SOURCE FILE NAME.
*      IF THIS IS A NEW SOURCE FILE NAME, THE R$SFN TABLE WILL
*      BE AUGMENTED WITH A NEW TABLE ENTRY CONSISTING OF THE
*      CURRENT COMPILER STATEMENT NUMBER AS SUBSCRIPT, AND THE
*      FILE NAME AS VALUE.
*
{READ4{BZE{13,SCLEN(XR){6,READ5{{JUMP IF TRUE END OF FILE{28649
{{ZER{8,WB{{{NEW SOURCE FILE NAME{28650
{{MOV{8,WB{3,RDNLN{{RESTART LINE COUNTER FOR NEW FILE{28651
{{JSR{6,TRIMR{{{REMOVE UNUSED SPACE IN BLOCK{28652
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{28653
{{BRN{6,READA{{{NOW REISSUE READ FOR RECORD DATA{28654
*
*      HERE ON END OF FILE
*
{READ5{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{28658
{{BZE{3,CNIND{6,READ6{{JUMP IF NOT WITHIN AN INCLUDE FILE{28660
{{ZER{7,XL{{{EOF WITHIN INCLUDE FILE{28661
{{JSR{6,SYSIF{{{SWITCH STREAM BACK TO PREVIOUS FILE{28662
{{PPM{{{{{28663
{{MOV{3,CNIND{8,WA{{RESTORE PREV LINE NUMBER, FILE NAME{28664
{{ADD{18,=VCVLB{8,WA{{VECTOR OFFSET IN WORDS{28665
{{WTB{8,WA{{{CONVERT TO BYTES{28666
{{MOV{3,R$IFA{7,XR{{FILE NAME ARRAY{28667
{{ADD{8,WA{7,XR{{PTR TO ELEMENT{28668
{{MOV{9,(XR){3,R$SFC{{CHANGE SOURCE FILE NAME{28669
{{MOV{21,=NULLS{9,(XR){{RELEASE SCBLK{28670
{{MOV{3,R$IFL{7,XR{{LINE NUMBER ARRAY{28671
{{ADD{8,WA{7,XR{{PTR TO ELEMENT{28672
{{MOV{9,(XR){7,XL{{ICBLK CONTAINING SAVED LINE NUMBER{28673
{{LDI{13,ICVAL(XL){{{LINE NUMBER INTEGER{28674
{{MFI{3,RDNLN{{{CHANGE SOURCE LINE NUMBER{28675
{{MOV{21,=INTON{9,(XR){{RELEASE ICBLK{28676
{{DCV{3,CNIND{{{DECREMENT NESTING LEVEL{28677
{{MOV{3,CMPSN{8,WB{{CURRENT STATEMENT NUMBER{28678
{{ICV{8,WB{{{ANTICIPATE END OF PREVIOUS STMT{28679
{{MTI{8,WB{{{CONVERT TO INTEGER{28680
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{28681
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{28682
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{28683
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{28684
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{28685
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{28686
{{BEQ{3,STAGE{18,=STGIC{6,READA{IF INITIAL COMPILE, REISSUE READ{28687
{{BNZ{3,CNIND{6,READA{{STILL READING FROM INCLUDE FILE{28688
*
*      OUTER NESTING OF EXECUTE-TIME COMPILE OF -INCLUDE
*      RESUME WITH ANY STRING REMAINING PRIOR TO -INCLUDE.
*
{{MOV{3,R$ICI{7,XL{{RESTORE CODE ARGUMENT STRING{28693
{{ZER{3,R$ICI{{{RELEASE ORIGINAL STRING{28694
{{MOV{3,CNSIL{8,WA{{GET LENGTH OF STRING{28695
{{MOV{3,CNSPT{8,WB{{OFFSET OF CHARACTERS LEFT{28696
{{SUB{8,WB{8,WA{{NUMBER OF CHARACTERS LEFT{28697
{{MOV{8,WA{3,SCNIL{{SET NEW SCAN LENGTH{28698
{{ZER{3,SCNPT{{{SCAN FROM START OF SUBSTRING{28699
{{JSR{6,SBSTR{{{CREATE SUBSTRING OF REMAINDER{28700
{{MOV{7,XR{3,R$CIM{{SET SCAN IMAGE{28701
{{BRN{6,READ2{{{RETURN{28702
{READ6{ZER{7,XR{{{ZERO PTR AS RESULT{28718
{{BRN{6,READ2{{{MERGE{28719
{{ENP{{{{END PROCEDURE READR{28720
{{EJC{{{{{28721
*
*      SBSTR -- BUILD A SUBSTRING
*
*      (XL)                  PTR TO SCBLK/BFBLK WITH CHARS
*      (WA)                  NUMBER OF CHARS IN SUBSTRING
*      (WB)                  OFFSET TO FIRST CHAR IN SCBLK
*      JSR  SBSTR            CALL TO BUILD SUBSTRING
*      (XR)                  PTR TO NEW SCBLK WITH SUBSTRING
*      (XL)                  ZERO
*      (WA,WB,WC,XL,IA)      DESTROYED
*
*      NOTE THAT SBSTR IS CALLED WITH A DUMMY STRING POINTER
*      (POINTING INTO A VRBLK OR SVBLK) TO COPY THE NAME OF A
*      VARIABLE AS A STANDARD STRING VALUE.
*
{SBSTR{PRC{25,E{1,0{{ENTRY POINT{28816
{{BZE{8,WA{6,SBST2{{JUMP IF NULL SUBSTRING{28817
{{JSR{6,ALOCS{{{ELSE ALLOCATE SCBLK{28818
{{MOV{8,WC{8,WA{{MOVE NUMBER OF CHARACTERS{28819
{{MOV{7,XR{8,WC{{SAVE PTR TO NEW SCBLK{28820
{{PLC{7,XL{8,WB{{PREPARE TO LOAD CHARS FROM OLD BLK{28821
{{PSC{7,XR{{{PREPARE TO STORE CHARS IN NEW BLK{28822
{{MVC{{{{MOVE CHARACTERS TO NEW STRING{28823
{{MOV{8,WC{7,XR{{THEN RESTORE SCBLK POINTER{28824
*
*      RETURN POINT
*
{SBST1{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{28828
{{EXI{{{{RETURN TO SBSTR CALLER{28829
*
*      HERE FOR NULL SUBSTRING
*
{SBST2{MOV{21,=NULLS{7,XR{{SET NULL STRING AS RESULT{28833
{{BRN{6,SBST1{{{RETURN{28834
{{ENP{{{{END PROCEDURE SBSTR{28835
{{EJC{{{{{28836
*
*      STGCC -- COMPUTE COUNTERS FOR STMT STARTUP TESTING
*
*      JSR  STGCC            CALL TO RECOMPUTE COUNTERS
*      (WA,WB)               DESTROYED
*
*      ON EXIT, STMCS AND STMCT CONTAIN THE COUNTER VALUE TO
*      TESTED IN STMGO.
*
*
{STGCC{PRC{25,E{1,0{{{28847
{{MOV{3,POLCS{8,WA{{ASSUME NO PROFILING OR STCOUNT TRACING{28849
{{MOV{18,=NUM01{8,WB{{POLL EACH TIME POLCS EXPIRES{28850
{{LDI{3,KVSTL{{{GET STMT LIMIT{28854
{{BNZ{3,KVPFL{6,STGC1{{JUMP IF PROFILING ENABLED{28855
{{ILT{6,STGC3{{{NO STCOUNT TRACING IF NEGATIVE{28856
{{BZE{3,R$STC{6,STGC2{{JUMP IF NOT STCOUNT TRACING{28857
*
*      HERE IF PROFILING OR IF STCOUNT TRACING ENABLED
*
{STGC1{MOV{8,WA{8,WB{{COUNT POLCS TIMES WITHIN STMG{28862
{{MOV{18,=NUM01{8,WA{{BREAK OUT OF STMGO ON EACH STMT{28863
{{BRN{6,STGC3{{{{28867
*
*      CHECK THAT STMCS DOES NOT EXCEED KVSTL
*
{STGC2{MTI{8,WA{{{BREAKOUT COUNT START VALUE{28871
{{SBI{3,KVSTL{{{PROPOSED STMCS MINUS STMT LIMIT{28872
{{ILE{6,STGC3{{{JUMP IF STMT COUNT DOES NOT LIMIT{28873
{{LDI{3,KVSTL{{{STLIMIT LIMITS BREAKCOUNT COUNT{28874
{{MFI{8,WA{{{USE IT INSTEAD{28875
*
*      RE-INITIALIZE COUNTER
*
{STGC3{MOV{8,WA{3,STMCS{{UPDATE BREAKOUT COUNT START VALUE{28879
{{MOV{8,WA{3,STMCT{{RESET BREAKOUT COUNTER{28880
{{MOV{8,WB{3,POLCT{{{28882
{{EXI{{{{{28884
{{EJC{{{{{28885
*
*      TFIND -- LOCATE TABLE ELEMENT
*
*      (XR)                  SUBSCRIPT VALUE FOR ELEMENT
*      (XL)                  POINTER TO TABLE
*      (WB)                  ZERO BY VALUE, NON-ZERO BY NAME
*      JSR  TFIND            CALL TO LOCATE ELEMENT
*      PPM  LOC              TRANSFER LOCATION IF ACCESS FAILS
*      (XR)                  ELEMENT VALUE (IF BY VALUE)
*      (XR)                  DESTROYED (IF BY NAME)
*      (XL,WA)               TEBLK NAME (IF BY NAME)
*      (XL,WA)               DESTROYED (IF BY VALUE)
*      (WC,RA)               DESTROYED
*
*      NOTE THAT IF A CALL BY VALUE SPECIFIES A NON-EXISTENT
*      SUBSCRIPT, THE DEFAULT VALUE IS RETURNED WITHOUT BUILDING
*      A NEW TEBLK.
*
{TFIND{PRC{25,E{1,1{{ENTRY POINT{28904
{{MOV{8,WB{11,-(XS){{SAVE NAME/VALUE INDICATOR{28905
{{MOV{7,XR{11,-(XS){{SAVE SUBSCRIPT VALUE{28906
{{MOV{7,XL{11,-(XS){{SAVE TABLE POINTER{28907
{{MOV{13,TBLEN(XL){8,WA{{LOAD LENGTH OF TBBLK{28908
{{BTW{8,WA{{{CONVERT TO WORD COUNT{28909
{{SUB{18,=TBBUK{8,WA{{GET NUMBER OF BUCKETS{28910
{{MTI{8,WA{{{CONVERT TO INTEGER VALUE{28911
{{STI{3,TFNSI{{{SAVE FOR LATER{28912
{{MOV{9,(XR){7,XL{{LOAD FIRST WORD OF SUBSCRIPT{28913
{{LEI{7,XL{{{LOAD BLOCK ENTRY ID (BL$XX){28914
{{BSW{7,XL{2,BL$$D{6,TFN00{SWITCH ON BLOCK TYPE{28915
{{IFF{1,0{6,TFN00{{{28926
{{IFF{1,1{6,TFN00{{{28926
{{IFF{1,2{6,TFN00{{{28926
{{IFF{2,BL$IC{6,TFN02{{JUMP IF INTEGER{28926
{{IFF{2,BL$NM{6,TFN04{{JUMP IF NAME{28926
{{IFF{2,BL$P0{6,TFN03{{JUMP IF PATTERN{28926
{{IFF{2,BL$P1{6,TFN03{{JUMP IF PATTERN{28926
{{IFF{2,BL$P2{6,TFN03{{JUMP IF PATTERN{28926
{{IFF{2,BL$RC{6,TFN02{{REAL{28926
{{IFF{2,BL$SC{6,TFN05{{JUMP IF STRING{28926
{{IFF{1,10{6,TFN00{{{28926
{{IFF{1,11{6,TFN00{{{28926
{{IFF{1,12{6,TFN00{{{28926
{{IFF{1,13{6,TFN00{{{28926
{{IFF{1,14{6,TFN00{{{28926
{{IFF{1,15{6,TFN00{{{28926
{{IFF{1,16{6,TFN00{{{28926
{{ESW{{{{END SWITCH ON BLOCK TYPE{28926
*
*      HERE FOR BLOCKS FOR WHICH WE USE THE SECOND WORD OF THE
*      BLOCK AS THE HASH SOURCE (SEE BLOCK FORMATS FOR DETAILS).
*
{TFN00{MOV{12,1(XR){8,WA{{LOAD SECOND WORD{28931
*
*      MERGE HERE WITH ONE WORD HASH SOURCE IN WA
*
{TFN01{MTI{8,WA{{{CONVERT TO INTEGER{28935
{{BRN{6,TFN06{{{JUMP TO MERGE{28936
{{EJC{{{{{28937
*
*      TFIND (CONTINUED)
*
*      HERE FOR INTEGER OR REAL
*      POSSIBILITY OF OVERFLOW EXIST ON TWOS COMPLEMENT
*      MACHINE IF HASH SOURCE IS MOST NEGATIVE INTEGER OR IS
*      A REAL HAVING THE SAME BIT PATTERN.
*
*
{TFN02{LDI{12,1(XR){{{LOAD VALUE AS HASH SOURCE{28947
{{IGE{6,TFN06{{{OK IF POSITIVE OR ZERO{28948
{{NGI{{{{MAKE POSITIVE{28949
{{IOV{6,TFN06{{{CLEAR POSSIBLE OVERFLOW{28950
{{BRN{6,TFN06{{{MERGE{28951
*
*      FOR PATTERN, USE FIRST WORD (PCODE) AS SOURCE
*
{TFN03{MOV{9,(XR){8,WA{{LOAD FIRST WORD AS HASH SOURCE{28955
{{BRN{6,TFN01{{{MERGE BACK{28956
*
*      FOR NAME, USE OFFSET AS HASH SOURCE
*
{TFN04{MOV{13,NMOFS(XR){8,WA{{LOAD OFFSET AS HASH SOURCE{28960
{{BRN{6,TFN01{{{MERGE BACK{28961
*
*      HERE FOR STRING
*
{TFN05{JSR{6,HASHS{{{CALL ROUTINE TO COMPUTE HASH{28965
*
*      MERGE HERE WITH HASH SOURCE IN (IA)
*
{TFN06{RMI{3,TFNSI{{{COMPUTE HASH INDEX BY REMAINDERING{28969
{{MFI{8,WC{{{GET AS ONE WORD INTEGER{28970
{{WTB{8,WC{{{CONVERT TO BYTE OFFSET{28971
{{MOV{9,(XS){7,XL{{GET TABLE PTR AGAIN{28972
{{ADD{8,WC{7,XL{{POINT TO PROPER BUCKET{28973
{{MOV{13,TBBUK(XL){7,XR{{LOAD FIRST TEBLK POINTER{28974
{{BEQ{7,XR{9,(XS){6,TFN10{JUMP IF NO TEBLKS ON CHAIN{28975
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{TFN07{MOV{7,XR{8,WB{{SAVE TEBLK POINTER{28979
{{MOV{13,TESUB(XR){7,XR{{LOAD SUBSCRIPT VALUE{28980
{{MOV{12,1(XS){7,XL{{LOAD INPUT ARGUMENT SUBSCRIPT VAL{28981
{{JSR{6,IDENT{{{COMPARE THEM{28982
{{PPM{6,TFN08{{{JUMP IF EQUAL (IDENT){28983
*
*      HERE IF NO MATCH WITH THAT TEBLK
*
{{MOV{8,WB{7,XL{{RESTORE TEBLK POINTER{28987
{{MOV{13,TENXT(XL){7,XR{{POINT TO NEXT TEBLK ON CHAIN{28988
{{BNE{7,XR{9,(XS){6,TFN07{JUMP IF THERE IS ONE{28989
*
*      HERE IF NO MATCH WITH ANY TEBLK ON CHAIN
*
{{MOV{19,*TENXT{8,WC{{SET OFFSET TO LINK FIELD (XL BASE){28993
{{BRN{6,TFN11{{{JUMP TO MERGE{28994
{{EJC{{{{{28995
*
*      TFIND (CONTINUED)
*
*      HERE WE HAVE FOUND A MATCHING ELEMENT
*
{TFN08{MOV{8,WB{7,XL{{RESTORE TEBLK POINTER{29001
{{MOV{19,*TEVAL{8,WA{{SET TEBLK NAME OFFSET{29002
{{MOV{12,2(XS){8,WB{{RESTORE NAME/VALUE INDICATOR{29003
{{BNZ{8,WB{6,TFN09{{JUMP IF CALLED BY NAME{29004
{{JSR{6,ACESS{{{ELSE GET VALUE{29005
{{PPM{6,TFN12{{{JUMP IF REFERENCE FAILS{29006
{{ZER{8,WB{{{RESTORE NAME/VALUE INDICATOR{29007
*
*      COMMON EXIT FOR ENTRY FOUND
*
{TFN09{ADD{19,*NUM03{7,XS{{POP STACK ENTRIES{29011
{{EXI{{{{RETURN TO TFIND CALLER{29012
*
*      HERE IF NO TEBLKS ON THE HASH CHAIN
*
{TFN10{ADD{19,*TBBUK{8,WC{{GET OFFSET TO BUCKET PTR{29016
{{MOV{9,(XS){7,XL{{SET TBBLK PTR AS BASE{29017
*
*      MERGE HERE WITH (XL,WC) BASE,OFFSET OF FINAL LINK
*
{TFN11{MOV{9,(XS){7,XR{{TBBLK POINTER{29021
{{MOV{13,TBINV(XR){7,XR{{LOAD DEFAULT VALUE IN CASE{29022
{{MOV{12,2(XS){8,WB{{LOAD NAME/VALUE INDICATOR{29023
{{BZE{8,WB{6,TFN09{{EXIT WITH DEFAULT IF VALUE CALL{29024
{{MOV{7,XR{8,WB{{COPY DEFAULT VALUE{29025
*
*      HERE WE MUST BUILD A NEW TEBLK
*
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{29029
{{JSR{6,ALLOC{{{ALLOCATE TEBLK{29030
{{ADD{8,WC{7,XL{{POINT TO HASH LINK{29031
{{MOV{7,XR{9,(XL){{LINK NEW TEBLK AT END OF CHAIN{29032
{{MOV{22,=B$TET{9,(XR){{STORE TYPE WORD{29033
{{MOV{8,WB{13,TEVAL(XR){{SET DEFAULT AS INITIAL VALUE{29034
{{MOV{10,(XS)+{13,TENXT(XR){{SET TBBLK PTR TO MARK END OF CHAIN{29035
{{MOV{10,(XS)+{13,TESUB(XR){{STORE SUBSCRIPT VALUE{29036
{{MOV{10,(XS)+{8,WB{{RESTORE NAME/VALUE INDICATOR{29037
{{MOV{7,XR{7,XL{{COPY TEBLK POINTER (NAME BASE){29038
{{MOV{19,*TEVAL{8,WA{{SET OFFSET{29039
{{EXI{{{{RETURN TO CALLER WITH NEW TEBLK{29040
*
*      ACESS FAIL RETURN
*
{TFN12{EXI{1,1{{{ALTERNATIVE RETURN{29044
{{ENP{{{{END PROCEDURE TFIND{29045
{{EJC{{{{{29046
*
*      TMAKE -- MAKE NEW TABLE
*
*      (XL)                  INITIAL LOOKUP VALUE
*      (WC)                  NUMBER OF BUCKETS DESIRED
*      JSR  TMAKE            CALL TO MAKE NEW TABLE
*      (XR)                  NEW TABLE
*      (WA,WB)               DESTROYED
*
{TMAKE{PRC{25,E{1,0{{{29056
{{MOV{8,WC{8,WA{{COPY NUMBER OF HEADERS{29057
{{ADD{18,=TBSI${8,WA{{ADJUST FOR STANDARD FIELDS{29058
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{29059
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{29060
{{MOV{7,XR{8,WB{{COPY POINTER TO TBBLK{29061
{{MOV{22,=B$TBT{10,(XR)+{{STORE TYPE WORD{29062
{{ZER{10,(XR)+{{{ZERO ID FOR THE MOMENT{29063
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (TBLEN){29064
{{MOV{7,XL{10,(XR)+{{STORE INITIAL LOOKUP VALUE{29065
{{LCT{8,WC{8,WC{{SET LOOP COUNTER (NUM HEADERS){29066
*
*      LOOP TO INITIALIZE ALL BUCKET POINTERS
*
{TMA01{MOV{8,WB{10,(XR)+{{STORE TBBLK PTR IN BUCKET HEADER{29070
{{BCT{8,WC{6,TMA01{{LOOP TILL ALL STORED{29071
{{MOV{8,WB{7,XR{{RECALL POINTER TO TBBLK{29072
{{EXI{{{{{29073
{{ENP{{{{{29074
{{EJC{{{{{29075
*
*      VMAKE -- CREATE A VECTOR
*
*      (WA)                  NUMBER OF ELEMENTS IN VECTOR
*      (XL)                  DEFAULT VALUE FOR VECTOR ELEMENTS
*      JSR  VMAKE            CALL TO CREATE VECTOR
*      PPM  LOC              IF VECTOR TOO LARGE
*
*      (XR)                  POINTER TO VCBLK
*      (WA,WB,WC,XL)         DESTROYED
*
{VMAKE{PRC{25,E{1,1{{ENTRY POINT{29087
{{LCT{8,WB{8,WA{{COPY ELEMENTS FOR LOOP LATER ON{29088
{{ADD{18,=VCSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{29089
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{29090
{{BGT{8,WA{3,MXLEN{6,VMAK2{FAIL IF TOO LARGE{29091
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR VCBLK{29092
{{MOV{22,=B$VCT{9,(XR){{STORE TYPE WORD{29093
{{ZER{13,IDVAL(XR){{{INITIALIZE IDVAL{29094
{{MOV{8,WA{13,VCLEN(XR){{SET LENGTH{29095
{{MOV{7,XL{8,WC{{COPY DEFAULT VALUE{29096
{{MOV{7,XR{7,XL{{COPY VCBLK POINTER{29097
{{ADD{19,*VCVLS{7,XL{{POINT TO FIRST ELEMENT VALUE{29098
*
*      LOOP TO SET VECTOR ELEMENTS TO DEFAULT VALUE
*
{VMAK1{MOV{8,WC{10,(XL)+{{STORE ONE VALUE{29102
{{BCT{8,WB{6,VMAK1{{LOOP TILL ALL STORED{29103
{{EXI{{{{SUCCESS RETURN{29104
*
*      HERE IF DESIRED VECTOR SIZE TOO LARGE
*
{VMAK2{EXI{1,1{{{FAIL RETURN{29108
{{ENP{{{{{29109
{{EJC{{{{{29110
*
*      SCANE -- SCAN AN ELEMENT
*
*      SCANE IS CALLED AT COMPILE TIME (BY EXPAN ,CMPIL,CNCRD)
*      TO SCAN ONE ELEMENT FROM THE INPUT IMAGE.
*
*      (SCNCC)               NON-ZERO IF CALLED FROM CNCRD
*      JSR  SCANE            CALL TO SCAN ELEMENT
*      (XR)                  RESULT POINTER (SEE BELOW)
*      (XL)                  SYNTAX TYPE CODE (T$XXX)
*
*      THE FOLLOWING GLOBAL LOCATIONS ARE USED.
*
*      R$CIM                 POINTER TO STRING BLOCK (SCBLK)
*                            FOR CURRENT INPUT IMAGE.
*
*      R$CNI                 POINTER TO NEXT INPUT IMAGE STRING
*                            POINTER (ZERO IF NONE).
*
*      R$SCP                 SAVE POINTER (EXIT XR) FROM LAST
*                            CALL IN CASE RESCAN IS SET.
*
*      SCNBL                 THIS LOCATION IS SET NON-ZERO ON
*                            EXIT IF SCANE SCANNED PAST BLANKS
*                            BEFORE LOCATING THE CURRENT ELEMENT
*                            THE END OF A LINE COUNTS AS BLANKS.
*
*      SCNCC                 CNCRD SETS THIS NON-ZERO TO SCAN
*                            CONTROL CARD NAMES AND CLEARS IT
*                            ON RETURN
*
*      SCNIL                 LENGTH OF CURRENT INPUT IMAGE
*
*      SCNGO                 IF SET NON-ZERO ON ENTRY, F AND S
*                            ARE RETURNED AS SEPARATE SYNTAX
*                            TYPES (NOT LETTERS) (GOTO PRO-
*                            CESSING). SCNGO IS RESET ON EXIT.
*
*      SCNPT                 OFFSET TO CURRENT LOC IN R$CIM
*
*      SCNRS                 IF SET NON-ZERO ON ENTRY, SCANE
*                            RETURNS THE SAME RESULT AS ON THE
*                            LAST CALL (RESCAN). SCNRS IS RESET
*                            ON EXIT FROM ANY CALL TO SCANE.
*
*      SCNTP                 SAVE SYNTAX TYPE FROM LAST
*                            CALL (IN CASE RESCAN IS SET).
{{EJC{{{{{29158
*
*      SCANE (CONTINUED)
*
*
*
*      ELEMENT SCANNED       XL        XR
*      ---------------       --        --
*
*      CONTROL CARD NAME     0         POINTER TO SCBLK FOR NAME
*
*      UNARY OPERATOR        T$UOP     PTR TO OPERATOR DVBLK
*
*      LEFT PAREN            T$LPR     T$LPR
*
*      LEFT BRACKET          T$LBR     T$LBR
*
*      COMMA                 T$CMA     T$CMA
*
*      FUNCTION CALL         T$FNC     PTR TO FUNCTION VRBLK
*
*      VARIABLE              T$VAR     PTR TO VRBLK
*
*      STRING CONSTANT       T$CON     PTR TO SCBLK
*
*      INTEGER CONSTANT      T$CON     PTR TO ICBLK
*
*      REAL CONSTANT         T$CON     PTR TO RCBLK
*
*      BINARY OPERATOR       T$BOP     PTR TO OPERATOR DVBLK
*
*      RIGHT PAREN           T$RPR     T$RPR
*
*      RIGHT BRACKET         T$RBR     T$RBR
*
*      COLON                 T$COL     T$COL
*
*      SEMI-COLON            T$SMC     T$SMC
*
*      F (SCNGO NE 0)        T$FGO     T$FGO
*
*      S (SCNGO NE 0)        T$SGO     T$SGO
{{EJC{{{{{29203
*
*      SCANE (CONTINUED)
*
*      ENTRY POINT
*
{SCANE{PRC{25,E{1,0{{ENTRY POINT{29209
{{ZER{3,SCNBL{{{RESET BLANKS FLAG{29210
{{MOV{8,WA{3,SCNSA{{SAVE WA{29211
{{MOV{8,WB{3,SCNSB{{SAVE WB{29212
{{MOV{8,WC{3,SCNSC{{SAVE WC{29213
{{BZE{3,SCNRS{6,SCN03{{JUMP IF NO RESCAN{29214
*
*      HERE FOR RESCAN REQUEST
*
{{MOV{3,SCNTP{7,XL{{SET PREVIOUS RETURNED SCAN TYPE{29218
{{MOV{3,R$SCP{7,XR{{SET PREVIOUS RETURNED POINTER{29219
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH{29220
{{BRN{6,SCN13{{{JUMP TO EXIT{29221
*
*      COME HERE TO READ NEW IMAGE TO TEST FOR CONTINUATION
*
{SCN01{JSR{6,READR{{{READ NEXT IMAGE{29225
{{MOV{19,*DVUBS{8,WB{{SET WB FOR NOT READING NAME{29226
{{BZE{7,XR{6,SCN30{{TREAT AS SEMI-COLON IF NONE{29227
{{PLC{7,XR{{{ELSE POINT TO FIRST CHARACTER{29228
{{LCH{8,WC{9,(XR){{LOAD FIRST CHARACTER{29229
{{BEQ{8,WC{18,=CH$DT{6,SCN02{JUMP IF DOT FOR CONTINUATION{29230
{{BNE{8,WC{18,=CH$PL{6,SCN30{ELSE TREAT AS SEMICOLON UNLESS PLUS{29231
*
*      HERE FOR CONTINUATION LINE
*
{SCN02{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{29235
{{MOV{18,=NUM01{3,SCNPT{{SET SCAN POINTER PAST CONTINUATION{29236
{{MNZ{3,SCNBL{{{SET BLANKS FLAG{29237
{{EJC{{{{{29238
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO SCAN NEXT ELEMENT ON CURRENT LINE
*
{SCN03{MOV{3,SCNPT{8,WA{{LOAD CURRENT OFFSET{29244
{{BEQ{8,WA{3,SCNIL{6,SCN01{CHECK CONTINUATION IF END{29245
{{MOV{3,R$CIM{7,XL{{POINT TO CURRENT LINE{29246
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHARACTER{29247
{{MOV{8,WA{3,SCNSE{{SET START OF ELEMENT LOCATION{29248
{{MOV{21,=OPDVS{8,WC{{POINT TO OPERATOR DV LIST{29249
{{MOV{19,*DVUBS{8,WB{{SET CONSTANT FOR OPERATOR CIRCUIT{29250
{{BRN{6,SCN06{{{START SCANNING{29251
*
*      LOOP HERE TO IGNORE LEADING BLANKS AND TABS
*
{SCN05{BZE{8,WB{6,SCN10{{JUMP IF TRAILING{29255
{{ICV{3,SCNSE{{{INCREMENT START OF ELEMENT{29256
{{BEQ{8,WA{3,SCNIL{6,SCN01{JUMP IF END OF IMAGE{29257
{{MNZ{3,SCNBL{{{NOTE BLANKS SEEN{29258
*
*      THE FOLLOWING JUMP IS USED REPEATEDLY FOR SCANNING OUT
*      THE CHARACTERS OF A NUMERIC CONSTANT OR VARIABLE NAME.
*      THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  SCRATCH
*      (XL)                  PTR TO NEXT CHARACTER
*      (WA)                  CURRENT SCAN OFFSET
*      (WB)                  *DVUBS (0 IF SCANNING NAME,CONST)
*      (WC)                  =OPDVS (0 IF SCANNING CONSTANT)
*
{SCN06{LCH{7,XR{10,(XL)+{{GET NEXT CHARACTER{29270
{{ICV{8,WA{{{BUMP SCAN OFFSET{29271
{{MOV{8,WA{3,SCNPT{{STORE OFFSET PAST CHAR SCANNED{29272
{{BSW{7,XR{2,CFP$U{6,SCN07{SWITCH ON SCANNED CHARACTER{29274
*
*      SWITCH TABLE FOR SWITCH ON CHARACTER
*
{{EJC{{{{{29301
*
*      SCANE (CONTINUED)
*
{{EJC{{{{{29357
*
*      SCANE (CONTINUED)
*
{{IFF{1,0{6,SCN07{{{29390
{{IFF{1,1{6,SCN07{{{29390
{{IFF{1,2{6,SCN07{{{29390
{{IFF{1,3{6,SCN07{{{29390
{{IFF{1,4{6,SCN07{{{29390
{{IFF{1,5{6,SCN07{{{29390
{{IFF{1,6{6,SCN07{{{29390
{{IFF{1,7{6,SCN07{{{29390
{{IFF{1,8{6,SCN07{{{29390
{{IFF{2,CH$HT{6,SCN05{{HORIZONTAL TAB{29390
{{IFF{1,10{6,SCN07{{{29390
{{IFF{1,11{6,SCN07{{{29390
{{IFF{1,12{6,SCN07{{{29390
{{IFF{1,13{6,SCN07{{{29390
{{IFF{1,14{6,SCN07{{{29390
{{IFF{1,15{6,SCN07{{{29390
{{IFF{1,16{6,SCN07{{{29390
{{IFF{1,17{6,SCN07{{{29390
{{IFF{1,18{6,SCN07{{{29390
{{IFF{1,19{6,SCN07{{{29390
{{IFF{1,20{6,SCN07{{{29390
{{IFF{1,21{6,SCN07{{{29390
{{IFF{1,22{6,SCN07{{{29390
{{IFF{1,23{6,SCN07{{{29390
{{IFF{1,24{6,SCN07{{{29390
{{IFF{1,25{6,SCN07{{{29390
{{IFF{1,26{6,SCN07{{{29390
{{IFF{1,27{6,SCN07{{{29390
{{IFF{1,28{6,SCN07{{{29390
{{IFF{1,29{6,SCN07{{{29390
{{IFF{1,30{6,SCN07{{{29390
{{IFF{1,31{6,SCN07{{{29390
{{IFF{2,CH$BL{6,SCN05{{BLANK{29390
{{IFF{2,CH$EX{6,SCN37{{EXCLAMATION MARK{29390
{{IFF{2,CH$DQ{6,SCN17{{DOUBLE QUOTE{29390
{{IFF{2,CH$NM{6,SCN41{{NUMBER SIGN{29390
{{IFF{2,CH$DL{6,SCN36{{DOLLAR{29390
{{IFF{2,CH$PC{6,SCN38{{PERCENT{29390
{{IFF{2,CH$AM{6,SCN44{{AMPERSAND{29390
{{IFF{2,CH$SQ{6,SCN16{{SINGLE QUOTE{29390
{{IFF{2,CH$PP{6,SCN25{{LEFT PAREN{29390
{{IFF{2,CH$RP{6,SCN26{{RIGHT PAREN{29390
{{IFF{2,CH$AS{6,SCN49{{ASTERISK{29390
{{IFF{2,CH$PL{6,SCN33{{PLUS{29390
{{IFF{2,CH$CM{6,SCN31{{COMMA{29390
{{IFF{2,CH$MN{6,SCN34{{MINUS{29390
{{IFF{2,CH$DT{6,SCN32{{DOT{29390
{{IFF{2,CH$SL{6,SCN40{{SLASH{29390
{{IFF{2,CH$D0{6,SCN08{{DIGIT 0{29390
{{IFF{2,CH$D1{6,SCN08{{DIGIT 1{29390
{{IFF{2,CH$D2{6,SCN08{{DIGIT 2{29390
{{IFF{2,CH$D3{6,SCN08{{DIGIT 3{29390
{{IFF{2,CH$D4{6,SCN08{{DIGIT 4{29390
{{IFF{2,CH$D5{6,SCN08{{DIGIT 5{29390
{{IFF{2,CH$D6{6,SCN08{{DIGIT 6{29390
{{IFF{2,CH$D7{6,SCN08{{DIGIT 7{29390
{{IFF{2,CH$D8{6,SCN08{{DIGIT 8{29390
{{IFF{2,CH$D9{6,SCN08{{DIGIT 9{29390
{{IFF{2,CH$CL{6,SCN29{{COLON{29390
{{IFF{2,CH$SM{6,SCN30{{SEMI-COLON{29390
{{IFF{2,CH$BB{6,SCN28{{LEFT BRACKET{29390
{{IFF{2,CH$EQ{6,SCN46{{EQUAL{29390
{{IFF{2,CH$RB{6,SCN27{{RIGHT BRACKET{29390
{{IFF{2,CH$QU{6,SCN45{{QUESTION MARK{29390
{{IFF{2,CH$AT{6,SCN42{{AT{29390
{{IFF{2,CH$LA{6,SCN09{{LETTER A{29390
{{IFF{2,CH$LB{6,SCN09{{LETTER B{29390
{{IFF{2,CH$LC{6,SCN09{{LETTER C{29390
{{IFF{2,CH$LD{6,SCN09{{LETTER D{29390
{{IFF{2,CH$LE{6,SCN09{{LETTER E{29390
{{IFF{2,CH$LF{6,SCN20{{LETTER F{29390
{{IFF{2,CH$LG{6,SCN09{{LETTER G{29390
{{IFF{2,CH$LH{6,SCN09{{LETTER H{29390
{{IFF{2,CH$LI{6,SCN09{{LETTER I{29390
{{IFF{2,CH$LJ{6,SCN09{{LETTER J{29390
{{IFF{2,CH$LK{6,SCN09{{LETTER K{29390
{{IFF{2,CH$LL{6,SCN09{{LETTER L{29390
{{IFF{2,CH$LM{6,SCN09{{LETTER M{29390
{{IFF{2,CH$LN{6,SCN09{{LETTER N{29390
{{IFF{2,CH$LO{6,SCN09{{LETTER O{29390
{{IFF{2,CH$LP{6,SCN09{{LETTER P{29390
{{IFF{2,CH$LQ{6,SCN09{{LETTER Q{29390
{{IFF{2,CH$LR{6,SCN09{{LETTER R{29390
{{IFF{2,CH$LS{6,SCN21{{LETTER S{29390
{{IFF{2,CH$LT{6,SCN09{{LETTER T{29390
{{IFF{2,CH$LU{6,SCN09{{LETTER U{29390
{{IFF{2,CH$LV{6,SCN09{{LETTER V{29390
{{IFF{2,CH$LW{6,SCN09{{LETTER W{29390
{{IFF{2,CH$LX{6,SCN09{{LETTER X{29390
{{IFF{2,CH$LY{6,SCN09{{LETTER Y{29390
{{IFF{2,CH$L${6,SCN09{{LETTER Z{29390
{{IFF{2,CH$OB{6,SCN28{{LEFT BRACKET{29390
{{IFF{1,92{6,SCN07{{{29390
{{IFF{2,CH$CB{6,SCN27{{RIGHT BRACKET{29390
{{IFF{2,CH$EY{6,SCN37{{UP ARROW{29390
{{IFF{2,CH$UN{6,SCN24{{UNDERLINE{29390
{{IFF{1,96{6,SCN07{{{29390
{{IFF{2,CH$$A{6,SCN09{{SHIFTED A{29390
{{IFF{2,CH$$B{6,SCN09{{SHIFTED B{29390
{{IFF{2,CH$$C{6,SCN09{{SHIFTED C{29390
{{IFF{2,CH$$D{6,SCN09{{SHIFTED D{29390
{{IFF{2,CH$$E{6,SCN09{{SHIFTED E{29390
{{IFF{2,CH$$F{6,SCN20{{SHIFTED F{29390
{{IFF{2,CH$$G{6,SCN09{{SHIFTED G{29390
{{IFF{2,CH$$H{6,SCN09{{SHIFTED H{29390
{{IFF{2,CH$$I{6,SCN09{{SHIFTED I{29390
{{IFF{2,CH$$J{6,SCN09{{SHIFTED J{29390
{{IFF{2,CH$$K{6,SCN09{{SHIFTED K{29390
{{IFF{2,CH$$L{6,SCN09{{SHIFTED L{29390
{{IFF{2,CH$$M{6,SCN09{{SHIFTED M{29390
{{IFF{2,CH$$N{6,SCN09{{SHIFTED N{29390
{{IFF{2,CH$$O{6,SCN09{{SHIFTED O{29390
{{IFF{2,CH$$P{6,SCN09{{SHIFTED P{29390
{{IFF{2,CH$$Q{6,SCN09{{SHIFTED Q{29390
{{IFF{2,CH$$R{6,SCN09{{SHIFTED R{29390
{{IFF{2,CH$$S{6,SCN21{{SHIFTED S{29390
{{IFF{2,CH$$T{6,SCN09{{SHIFTED T{29390
{{IFF{2,CH$$U{6,SCN09{{SHIFTED U{29390
{{IFF{2,CH$$V{6,SCN09{{SHIFTED V{29390
{{IFF{2,CH$$W{6,SCN09{{SHIFTED W{29390
{{IFF{2,CH$$X{6,SCN09{{SHIFTED X{29390
{{IFF{2,CH$$Y{6,SCN09{{SHIFTED Y{29390
{{IFF{2,CH$$${6,SCN09{{SHIFTED Z{29390
{{IFF{1,123{6,SCN07{{{29390
{{IFF{2,CH$BR{6,SCN43{{VERTICAL BAR{29390
{{IFF{1,125{6,SCN07{{{29390
{{IFF{2,CH$NT{6,SCN35{{NOT{29390
{{IFF{1,127{6,SCN07{{{29390
{{ESW{{{{END SWITCH ON CHARACTER{29390
*
*      HERE FOR ILLEGAL CHARACTER (UNDERLINE MERGES)
*
{SCN07{BZE{8,WB{6,SCN10{{JUMP IF SCANNING NAME OR CONSTANT{29394
{{ERB{1,230{26,Syntax error: Illegal character{{{29395
{{EJC{{{{{29396
*
*      SCANE (CONTINUED)
*
*      HERE FOR DIGITS 0-9
*
{SCN08{BZE{8,WB{6,SCN09{{KEEP SCANNING IF NAME/CONSTANT{29402
{{ZER{8,WC{{{ELSE SET FLAG FOR SCANNING CONSTANT{29403
*
*      HERE FOR LETTER. LOOP HERE WHEN SCANNING NAME/CONSTANT
*
{SCN09{BEQ{8,WA{3,SCNIL{6,SCN11{JUMP IF END OF IMAGE{29407
{{ZER{8,WB{{{SET FLAG FOR SCANNING NAME/CONST{29408
{{BRN{6,SCN06{{{MERGE BACK TO CONTINUE SCAN{29409
*
*      COME HERE FOR DELIMITER ENDING NAME OR CONSTANT
*
{SCN10{DCV{8,WA{{{RESET OFFSET TO POINT TO DELIMITER{29413
*
*      COME HERE AFTER FINISHING SCAN OF NAME OR CONSTANT
*
{SCN11{MOV{8,WA{3,SCNPT{{STORE UPDATED SCAN OFFSET{29417
{{MOV{3,SCNSE{8,WB{{POINT TO START OF ELEMENT{29418
{{SUB{8,WB{8,WA{{GET NUMBER OF CHARACTERS{29419
{{MOV{3,R$CIM{7,XL{{POINT TO LINE IMAGE{29420
{{BNZ{8,WC{6,SCN15{{JUMP IF NAME{29421
*
*      HERE AFTER SCANNING OUT NUMERIC CONSTANT
*
{{JSR{6,SBSTR{{{GET STRING FOR CONSTANT{29425
{{MOV{7,XR{3,DNAMP{{DELETE FROM STORAGE (NOT NEEDED){29426
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{29427
{{PPM{6,SCN14{{{JUMP IF CONVERSION FAILURE{29428
*
*      MERGE HERE TO EXIT WITH CONSTANT
*
{SCN12{MOV{18,=T$CON{7,XL{{SET RESULT TYPE OF CONSTANT{29432
{{EJC{{{{{29433
*
*      SCANE (CONTINUED)
*
*      COMMON EXIT POINT (XR,XL) SET
*
{SCN13{MOV{3,SCNSA{8,WA{{RESTORE WA{29439
{{MOV{3,SCNSB{8,WB{{RESTORE WB{29440
{{MOV{3,SCNSC{8,WC{{RESTORE WC{29441
{{MOV{7,XR{3,R$SCP{{SAVE XR IN CASE RESCAN{29442
{{MOV{7,XL{3,SCNTP{{SAVE XL IN CASE RESCAN{29443
{{ZER{3,SCNGO{{{RESET POSSIBLE GOTO FLAG{29444
{{EXI{{{{RETURN TO SCANE CALLER{29445
*
*      HERE IF CONVERSION ERROR ON NUMERIC ITEM
*
{SCN14{ERB{1,231{26,Syntax error: Invalid numeric item{{{29449
*
*      HERE AFTER SCANNING OUT VARIABLE NAME
*
{SCN15{JSR{6,SBSTR{{{BUILD STRING NAME OF VARIABLE{29453
{{BNZ{3,SCNCC{6,SCN13{{RETURN IF CNCRD CALL{29454
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{29455
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{29456
{{MOV{18,=T$VAR{7,XL{{SET TYPE AS VARIABLE{29457
{{BRN{6,SCN13{{{BACK TO EXIT{29458
*
*      HERE FOR SINGLE QUOTE (START OF STRING CONSTANT)
*
{SCN16{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{29462
{{MOV{18,=CH$SQ{8,WB{{SET TERMINATOR AS SINGLE QUOTE{29463
{{BRN{6,SCN18{{{MERGE{29464
*
*      HERE FOR DOUBLE QUOTE (START OF STRING CONSTANT)
*
{SCN17{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{29468
{{MOV{18,=CH$DQ{8,WB{{SET DOUBLE QUOTE TERMINATOR, MERGE{29469
*
*      LOOP TO SCAN OUT STRING CONSTANT
*
{SCN18{BEQ{8,WA{3,SCNIL{6,SCN19{ERROR IF END OF IMAGE{29473
{{LCH{8,WC{10,(XL)+{{ELSE LOAD NEXT CHARACTER{29474
{{ICV{8,WA{{{BUMP OFFSET{29475
{{BNE{8,WC{8,WB{6,SCN18{LOOP BACK IF NOT TERMINATOR{29476
{{EJC{{{{{29477
*
*      SCANE (CONTINUED)
*
*      HERE AFTER SCANNING OUT STRING CONSTANT
*
{{MOV{3,SCNPT{8,WB{{POINT TO FIRST CHARACTER{29483
{{MOV{8,WA{3,SCNPT{{SAVE OFFSET PAST FINAL QUOTE{29484
{{DCV{8,WA{{{POINT BACK PAST LAST CHARACTER{29485
{{SUB{8,WB{8,WA{{GET NUMBER OF CHARACTERS{29486
{{MOV{3,R$CIM{7,XL{{POINT TO INPUT IMAGE{29487
{{JSR{6,SBSTR{{{BUILD SUBSTRING VALUE{29488
{{BRN{6,SCN12{{{BACK TO EXIT WITH CONSTANT RESULT{29489
*
*      HERE IF NO MATCHING QUOTE FOUND
*
{SCN19{MOV{8,WA{3,SCNPT{{SET UPDATED SCAN POINTER{29493
{{ERB{1,232{26,Syntax error: Unmatched string quote{{{29494
*
*      HERE FOR F (POSSIBLE FAILURE GOTO)
*
{SCN20{MOV{18,=T$FGO{7,XR{{SET RETURN CODE FOR FAIL GOTO{29498
{{BRN{6,SCN22{{{JUMP TO MERGE{29499
*
*      HERE FOR S (POSSIBLE SUCCESS GOTO)
*
{SCN21{MOV{18,=T$SGO{7,XR{{SET SUCCESS GOTO AS RETURN CODE{29503
*
*      SPECIAL GOTO CASES MERGE HERE
*
{SCN22{BZE{3,SCNGO{6,SCN09{{TREAT AS NORMAL LETTER IF NOT GOTO{29507
*
*      MERGE HERE FOR SPECIAL CHARACTER EXIT
*
{SCN23{BZE{8,WB{6,SCN10{{JUMP IF END OF NAME/CONSTANT{29511
{{MOV{7,XR{7,XL{{ELSE COPY CODE{29512
{{BRN{6,SCN13{{{AND JUMP TO EXIT{29513
*
*      HERE FOR UNDERLINE
*
{SCN24{BZE{8,WB{6,SCN09{{PART OF NAME IF SCANNING NAME{29517
{{BRN{6,SCN07{{{ELSE ILLEGAL{29518
{{EJC{{{{{29519
*
*      SCANE (CONTINUED)
*
*      HERE FOR LEFT PAREN
*
{SCN25{MOV{18,=T$LPR{7,XR{{SET LEFT PAREN RETURN CODE{29525
{{BNZ{8,WB{6,SCN23{{RETURN LEFT PAREN UNLESS NAME{29526
{{BZE{8,WC{6,SCN10{{DELIMITER IF SCANNING CONSTANT{29527
*
*      HERE FOR LEFT PAREN AFTER NAME (FUNCTION CALL)
*
{{MOV{3,SCNSE{8,WB{{POINT TO START OF NAME{29531
{{MOV{8,WA{3,SCNPT{{SET POINTER PAST LEFT PAREN{29532
{{DCV{8,WA{{{POINT BACK PAST LAST CHAR OF NAME{29533
{{SUB{8,WB{8,WA{{GET NAME LENGTH{29534
{{MOV{3,R$CIM{7,XL{{POINT TO INPUT IMAGE{29535
{{JSR{6,SBSTR{{{GET STRING NAME FOR FUNCTION{29536
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{29537
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{29538
{{MOV{18,=T$FNC{7,XL{{SET CODE FOR FUNCTION CALL{29539
{{BRN{6,SCN13{{{BACK TO EXIT{29540
*
*      PROCESSING FOR SPECIAL CHARACTERS
*
{SCN26{MOV{18,=T$RPR{7,XR{{RIGHT PAREN, SET CODE{29544
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29545
*
{SCN27{MOV{18,=T$RBR{7,XR{{RIGHT BRACKET, SET CODE{29547
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29548
*
{SCN28{MOV{18,=T$LBR{7,XR{{LEFT BRACKET, SET CODE{29550
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29551
*
{SCN29{MOV{18,=T$COL{7,XR{{COLON, SET CODE{29553
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29554
*
{SCN30{MOV{18,=T$SMC{7,XR{{SEMI-COLON, SET CODE{29556
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29557
*
{SCN31{MOV{18,=T$CMA{7,XR{{COMMA, SET CODE{29559
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29560
{{EJC{{{{{29561
*
*      SCANE (CONTINUED)
*
*      HERE FOR OPERATORS. ON ENTRY, WC POINTS TO THE TABLE OF
*      OPERATOR DOPE VECTORS AND WB IS THE INCREMENT TO STEP
*      TO THE NEXT PAIR (BINARY/UNARY) OF DOPE VECTORS IN THE
*      LIST. ON REACHING SCN46, THE POINTER HAS BEEN ADJUSTED TO
*      POINT TO THE APPROPRIATE PAIR OF DOPE VECTORS.
*      THE FIRST THREE ENTRIES ARE SPECIAL SINCE THEY CAN OCCUR
*      AS PART OF A VARIABLE NAME (.) OR CONSTANT (.+-).
*
{SCN32{BZE{8,WB{6,SCN09{{DOT CAN BE PART OF NAME OR CONSTANT{29573
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29574
*
{SCN33{BZE{8,WC{6,SCN09{{PLUS CAN BE PART OF CONSTANT{29576
{{BZE{8,WB{6,SCN48{{PLUS CANNOT BE PART OF NAME{29577
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29578
*
{SCN34{BZE{8,WC{6,SCN09{{MINUS CAN BE PART OF CONSTANT{29580
{{BZE{8,WB{6,SCN48{{MINUS CANNOT BE PART OF NAME{29581
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29582
*
{SCN35{ADD{8,WB{8,WC{{NOT{29584
{SCN36{ADD{8,WB{8,WC{{DOLLAR{29585
{SCN37{ADD{8,WB{8,WC{{EXCLAMATION{29586
{SCN38{ADD{8,WB{8,WC{{PERCENT{29587
{SCN39{ADD{8,WB{8,WC{{ASTERISK{29588
{SCN40{ADD{8,WB{8,WC{{SLASH{29589
{SCN41{ADD{8,WB{8,WC{{NUMBER SIGN{29590
{SCN42{ADD{8,WB{8,WC{{AT SIGN{29591
{SCN43{ADD{8,WB{8,WC{{VERTICAL BAR{29592
{SCN44{ADD{8,WB{8,WC{{AMPERSAND{29593
{SCN45{ADD{8,WB{8,WC{{QUESTION MARK{29594
*
*      ALL OPERATORS COME HERE (EQUAL MERGES DIRECTLY)
*      (WC) POINTS TO THE BINARY/UNARY PAIR OF OPERATOR DVBLKS.
*
{SCN46{BZE{8,WB{6,SCN10{{OPERATOR TERMINATES NAME/CONSTANT{29599
{{MOV{8,WC{7,XR{{ELSE COPY DV POINTER{29600
{{LCH{8,WC{9,(XL){{LOAD NEXT CHARACTER{29601
{{MOV{18,=T$BOP{7,XL{{SET BINARY OP IN CASE{29602
{{BEQ{8,WA{3,SCNIL{6,SCN47{SHOULD BE BINARY IF IMAGE END{29603
{{BEQ{8,WC{18,=CH$BL{6,SCN47{SHOULD BE BINARY IF FOLLOWED BY BLK{29604
{{BEQ{8,WC{18,=CH$HT{6,SCN47{JUMP IF HORIZONTAL TAB{29606
{{BEQ{8,WC{18,=CH$SM{6,SCN47{SEMICOLON CAN IMMEDIATELY FOLLOW ={29611
{{BEQ{8,WC{18,=CH$CL{6,SCN47{COLON CAN IMMEDIATELY FOLLOW ={29612
{{BEQ{8,WC{18,=CH$RP{6,SCN47{RIGHT PAREN CAN IMMEDIATELY FOLLOW ={29613
{{BEQ{8,WC{18,=CH$RB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={29614
{{BEQ{8,WC{18,=CH$CB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={29615
*
*      HERE FOR UNARY OPERATOR
*
{{ADD{19,*DVBS${7,XR{{POINT TO DV FOR UNARY OP{29619
{{MOV{18,=T$UOP{7,XL{{SET TYPE FOR UNARY OPERATOR{29620
{{BLE{3,SCNTP{18,=T$UOK{6,SCN13{OK UNARY IF OK PRECEDING ELEMENT{29621
{{EJC{{{{{29622
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO REQUIRE PRECEDING BLANKS
*
{SCN47{BNZ{3,SCNBL{6,SCN13{{ALL OK IF PRECEDING BLANKS, EXIT{29628
*
*      FAIL OPERATOR IN THIS POSITION
*
{SCN48{ERB{1,233{26,Syntax error: Invalid use of operator{{{29632
*
*      HERE FOR ASTERISK, COULD BE ** SUBSTITUTE FOR EXCLAMATION
*
{SCN49{BZE{8,WB{6,SCN10{{END OF NAME IF SCANNING NAME{29636
{{BEQ{8,WA{3,SCNIL{6,SCN39{NOT ** IF * AT IMAGE END{29637
{{MOV{8,WA{7,XR{{ELSE SAVE OFFSET PAST FIRST *{29638
{{MOV{8,WA{3,SCNOF{{SAVE ANOTHER COPY{29639
{{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{29640
{{BNE{8,WA{18,=CH$AS{6,SCN50{NOT ** IF NEXT CHAR NOT *{29641
{{ICV{7,XR{{{ELSE STEP OFFSET PAST SECOND *{29642
{{BEQ{7,XR{3,SCNIL{6,SCN51{OK EXCLAM IF END OF IMAGE{29643
{{LCH{8,WA{9,(XL){{ELSE LOAD NEXT CHARACTER{29644
{{BEQ{8,WA{18,=CH$BL{6,SCN51{EXCLAMATION IF BLANK{29645
{{BEQ{8,WA{18,=CH$HT{6,SCN51{EXCLAMATION IF HORIZONTAL TAB{29647
*
*      UNARY *
*
{SCN50{MOV{3,SCNOF{8,WA{{RECOVER STORED OFFSET{29655
{{MOV{3,R$CIM{7,XL{{POINT TO LINE AGAIN{29656
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHAR{29657
{{BRN{6,SCN39{{{MERGE WITH UNARY *{29658
*
*      HERE FOR ** AS SUBSTITUTE FOR EXCLAMATION
*
{SCN51{MOV{7,XR{3,SCNPT{{SAVE SCAN POINTER PAST 2ND *{29662
{{MOV{7,XR{8,WA{{COPY SCAN POINTER{29663
{{BRN{6,SCN37{{{MERGE WITH EXCLAMATION{29664
{{ENP{{{{END PROCEDURE SCANE{29665
{{EJC{{{{{29666
*
*      SCNGF -- SCAN GOTO FIELD
*
*      SCNGF IS CALLED FROM CMPIL TO SCAN AND ANALYZE A GOTO
*      FIELD INCLUDING THE SURROUNDING BRACKETS OR PARENTHESES.
*      FOR A NORMAL GOTO, THE RESULT RETURNED IS EITHER A VRBLK
*      POINTER FOR A SIMPLE LABEL OPERAND, OR A POINTER TO AN
*      EXPRESSION TREE WITH A SPECIAL OUTER UNARY OPERATOR
*      (O$GOC). FOR A DIRECT GOTO, THE RESULT RETURNED IS A
*      POINTER TO AN EXPRESSION TREE WITH THE SPECIAL OUTER
*      UNARY OPERATOR O$GOD.
*
*      JSR  SCNGF            CALL TO SCAN GOTO FIELD
*      (XR)                  RESULT (SEE ABOVE)
*      (XL,WA,WB,WC)         DESTROYED
*
{SCNGF{PRC{25,E{1,0{{ENTRY POINT{29683
{{JSR{6,SCANE{{{SCAN INITIAL ELEMENT{29684
{{BEQ{7,XL{18,=T$LPR{6,SCNG1{SKIP IF LEFT PAREN (NORMAL GOTO){29685
{{BEQ{7,XL{18,=T$LBR{6,SCNG2{SKIP IF LEFT BRACKET (DIRECT GOTO){29686
{{ERB{1,234{26,Syntax error: Goto field incorrect{{{29687
*
*      HERE FOR LEFT PAREN (NORMAL GOTO)
*
{SCNG1{MOV{18,=NUM01{8,WB{{SET EXPAN FLAG FOR NORMAL GOTO{29691
{{JSR{6,EXPAN{{{ANALYZE GOTO FIELD{29692
{{MOV{21,=OPDVN{8,WA{{POINT TO OPDV FOR COMPLEX GOTO{29693
{{BLE{7,XR{3,STATB{6,SCNG3{JUMP IF NOT IN STATIC (SGD15){29694
{{BLO{7,XR{3,STATE{6,SCNG4{JUMP TO EXIT IF SIMPLE LABEL NAME{29695
{{BRN{6,SCNG3{{{COMPLEX GOTO - MERGE{29696
*
*      HERE FOR LEFT BRACKET (DIRECT GOTO)
*
{SCNG2{MOV{18,=NUM02{8,WB{{SET EXPAN FLAG FOR DIRECT GOTO{29700
{{JSR{6,EXPAN{{{SCAN GOTO FIELD{29701
{{MOV{21,=OPDVD{8,WA{{SET OPDV POINTER FOR DIRECT GOTO{29702
{{EJC{{{{{29703
*
*      SCNGF (CONTINUED)
*
*      MERGE HERE TO BUILD OUTER UNARY OPERATOR BLOCK
*
{SCNG3{MOV{8,WA{11,-(XS){{STACK OPERATOR DV POINTER{29709
{{MOV{7,XR{11,-(XS){{STACK POINTER TO EXPRESSION TREE{29710
{{JSR{6,EXPOP{{{POP OPERATOR OFF{29711
{{MOV{10,(XS)+{7,XR{{RELOAD NEW EXPRESSION TREE POINTER{29712
*
*      COMMON EXIT POINT
*
{SCNG4{EXI{{{{RETURN TO CALLER{29716
{{ENP{{{{END PROCEDURE SCNGF{29717
{{EJC{{{{{29718
*
*      SETVR -- SET VRGET,VRSTO FIELDS OF VRBLK
*
*      SETVR SETS THE PROPER VALUES IN THE VRGET AND VRSTO
*      FIELDS OF A VRBLK. IT IS CALLED WHENEVER TRBLKS ARE
*      ADDED OR SUBTRACTED (TRACE,STOPTR,INPUT,OUTPUT,DETACH)
*
*      (XR)                  POINTER TO VRBLK
*      JSR  SETVR            CALL TO SET FIELDS
*      (XL,WA)               DESTROYED
*
*      NOTE THAT SETVR IGNORES THE CALL IF XR DOES NOT POINT
*      INTO THE STATIC REGION (I.E. IS SOME OTHER NAME BASE)
*
{SETVR{PRC{25,E{1,0{{ENTRY POINT{29733
{{BHI{7,XR{3,STATE{6,SETV1{EXIT IF NOT NATURAL VARIABLE{29734
*
*      HERE IF WE HAVE A VRBLK
*
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{29738
{{MOV{22,=B$VRL{13,VRGET(XR){{STORE NORMAL GET VALUE{29739
{{BEQ{13,VRSTO(XR){22,=B$VRE{6,SETV1{SKIP IF PROTECTED VARIABLE{29740
{{MOV{22,=B$VRS{13,VRSTO(XR){{STORE NORMAL STORE VALUE{29741
{{MOV{13,VRVAL(XL){7,XL{{POINT TO NEXT ENTRY ON CHAIN{29742
{{BNE{9,(XL){22,=B$TRT{6,SETV1{JUMP IF END OF TRBLK CHAIN{29743
{{MOV{22,=B$VRA{13,VRGET(XR){{STORE TRAPPED ROUTINE ADDRESS{29744
{{MOV{22,=B$VRV{13,VRSTO(XR){{SET TRAPPED ROUTINE ADDRESS{29745
*
*      MERGE HERE TO EXIT TO CALLER
*
{SETV1{EXI{{{{RETURN TO SETVR CALLER{29749
{{ENP{{{{END PROCEDURE SETVR{29750
{{EJC{{{{{29753
*
*      SORTA -- SORT ARRAY
*
*      ROUTINE TO SORT AN ARRAY OR TABLE ON SAME BASIS AS IN
*      SITBOL. A TABLE IS CONVERTED TO AN ARRAY, LEAVING TWO
*      DIMENSIONAL ARRAYS AND VECTORS AS CASES TO BE CONSIDERED.
*      WHOLE ROWS OF ARRAYS ARE PERMUTED ACCORDING TO THE
*      ORDERING OF THE KEYS THEY CONTAIN, AND THE STRIDE
*      REFERRED TO, IS THE THE LENGTH OF A ROW. IT IS ONE
*      FOR A VECTOR.
*      THE SORT USED IS HEAPSORT, FUNDAMENTALS OF DATA STRUCTURE
*      HOROWITZ AND SAHNI, PITMAN 1977, PAGE 347.
*      IT IS AN ORDER N*LOG(N) ALGORITHM. IN ORDER
*      TO MAKE IT STABLE, COMPARANDS MAY NOT COMPARE EQUAL. THIS
*      IS ACHIEVED BY SORTING A COPY ARRAY (REFERRED TO AS THE
*      SORT ARRAY) CONTAINING AT ITS HIGH ADDRESS END, BYTE
*      OFFSETS TO THE ROWS TO BE SORTED HELD IN THE ORIGINAL
*      ARRAY (REFERRED TO AS THE KEY ARRAY). SORTC, THE
*      COMPARISON ROUTINE, ACCESSES THE KEYS THROUGH THESE
*      OFFSETS AND IN THE CASE OF EQUALITY, RESOLVES IT BY
*      COMPARING THE OFFSETS THEMSELVES. THE SORT PERMUTES THE
*      OFFSETS WHICH ARE THEN USED IN A FINAL OPERATION TO COPY
*      THE ACTUAL ITEMS INTO THE NEW ARRAY IN SORTED ORDER.
*      REFERENCES TO ZEROTH ITEM ARE TO NOTIONAL ITEM
*      PRECEDING FIRST ACTUAL ITEM.
*      REVERSE SORTING FOR RSORT IS DONE BY HAVING THE LESS THAN
*      TEST FOR KEYS EFFECTIVELY BE REPLACED BY A
*      GREATER THAN TEST.
*
*      1(XS)                 FIRST ARG - ARRAY OR TABLE
*      0(XS)                 2ND ARG - INDEX OR PDTYPE NAME
*      (WA)                  0 , NON-ZERO FOR SORT , RSORT
*      JSR  SORTA            CALL TO SORT ARRAY
*      PPM  LOC              TRANSFER LOC IF TABLE IS EMPTY
*      (XR)                  SORTED ARRAY
*      (XL,WA,WB,WC)         DESTROYED
{{EJC{{{{{29790
*
*      SORTA (CONTINUED)
*
{SORTA{PRC{25,N{1,1{{ENTRY POINT{29794
{{MOV{8,WA{3,SRTSR{{SORT/RSORT INDICATOR{29795
{{MOV{19,*NUM01{3,SRTST{{DEFAULT STRIDE OF 1{29796
{{ZER{3,SRTOF{{{DEFAULT ZERO OFFSET TO SORT KEY{29797
{{MOV{21,=NULLS{3,SRTDF{{CLEAR DATATYPE FIELD NAME{29798
{{MOV{10,(XS)+{3,R$SXR{{UNSTACK ARGUMENT 2{29799
{{MOV{10,(XS)+{7,XR{{GET FIRST ARGUMENT{29800
{{MNZ{8,WA{{{USE KEY/VALUES OF TABLE ENTRIES{29801
{{JSR{6,GTARR{{{CONVERT TO ARRAY{29802
{{PPM{6,SRT18{{{SIGNAL THAT TABLE IS EMPTY{29803
{{PPM{6,SRT16{{{ERROR IF NON-CONVERTABLE{29804
{{MOV{7,XR{11,-(XS){{STACK PTR TO RESULTING KEY ARRAY{29805
{{MOV{7,XR{11,-(XS){{ANOTHER COPY FOR COPYB{29806
{{JSR{6,COPYB{{{GET COPY ARRAY FOR SORTING INTO{29807
{{PPM{{{{CANT FAIL{29808
{{MOV{7,XR{11,-(XS){{STACK POINTER TO SORT ARRAY{29809
{{MOV{3,R$SXR{7,XR{{GET SECOND ARG{29810
{{MOV{13,NUM01(XS){7,XL{{GET PTR TO KEY ARRAY{29811
{{BNE{9,(XL){22,=B$VCT{6,SRT02{JUMP IF ARBLK{29812
{{BEQ{7,XR{21,=NULLS{6,SRT01{JUMP IF NULL SECOND ARG{29813
{{JSR{6,GTNVR{{{GET VRBLK PTR FOR IT{29814
{{ERR{1,257{26,Erroneous 2nd arg in SORT/RSORT of vector{{{29815
{{MOV{7,XR{3,SRTDF{{STORE DATATYPE FIELD NAME VRBLK{29816
*
*      COMPUTE N AND OFFSET TO ITEM A(0) IN VECTOR CASE
*
{SRT01{MOV{19,*VCLEN{8,WC{{OFFSET TO A(0){29820
{{MOV{19,*VCVLS{8,WB{{OFFSET TO FIRST ITEM{29821
{{MOV{13,VCLEN(XL){8,WA{{GET BLOCK LENGTH{29822
{{SUB{19,*VCSI${8,WA{{GET NO. OF ENTRIES, N (IN BYTES){29823
{{BRN{6,SRT04{{{MERGE{29824
*
*      HERE FOR ARRAY
*
{SRT02{LDI{13,ARDIM(XL){{{GET POSSIBLE DIMENSION{29828
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{29829
{{WTB{8,WA{{{FURTHER CONVERT TO BAUS{29830
{{MOV{19,*ARVLS{8,WB{{OFFSET TO FIRST VALUE IF ONE{29831
{{MOV{19,*ARPRO{8,WC{{OFFSET BEFORE VALUES IF ONE DIM.{29832
{{BEQ{13,ARNDM(XL){18,=NUM01{6,SRT04{JUMP IN FACT IF ONE DIM.{29833
{{BNE{13,ARNDM(XL){18,=NUM02{6,SRT16{FAIL UNLESS TWO DIMENS{29834
{{LDI{13,ARLB2(XL){{{GET LOWER BOUND 2 AS DEFAULT{29835
{{BEQ{7,XR{21,=NULLS{6,SRT03{JUMP IF DEFAULT SECOND ARG{29836
{{JSR{6,GTINT{{{CONVERT TO INTEGER{29837
{{PPM{6,SRT17{{{FAIL{29838
{{LDI{13,ICVAL(XR){{{GET ACTUAL INTEGER VALUE{29839
{{EJC{{{{{29840
*
*      SORTA (CONTINUED)
*
*      HERE WITH SORT COLUMN INDEX IN IA IN ARRAY CASE
*
{SRT03{SBI{13,ARLB2(XL){{{SUBTRACT LOW BOUND{29846
{{IOV{6,SRT17{{{FAIL IF OVERFLOW{29847
{{ILT{6,SRT17{{{FAIL IF BELOW LOW BOUND{29848
{{SBI{13,ARDM2(XL){{{CHECK AGAINST DIMENSION{29849
{{IGE{6,SRT17{{{FAIL IF TOO LARGE{29850
{{ADI{13,ARDM2(XL){{{RESTORE VALUE{29851
{{MFI{8,WA{{{GET AS SMALL INTEGER{29852
{{WTB{8,WA{{{OFFSET WITHIN ROW TO KEY{29853
{{MOV{8,WA{3,SRTOF{{KEEP OFFSET{29854
{{LDI{13,ARDM2(XL){{{SECOND DIMENSION IS ROW LENGTH{29855
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{29856
{{MOV{8,WA{7,XR{{COPY ROW LENGTH{29857
{{WTB{8,WA{{{CONVERT TO BYTES{29858
{{MOV{8,WA{3,SRTST{{STORE AS STRIDE{29859
{{LDI{13,ARDIM(XL){{{GET NUMBER OF ROWS{29860
{{MFI{8,WA{{{AS A SHORT INTEGER{29861
{{WTB{8,WA{{{CONVERT N TO BAUS{29862
{{MOV{13,ARLEN(XL){8,WC{{OFFSET PAST ARRAY END{29863
{{SUB{8,WA{8,WC{{ADJUST, GIVING SPACE FOR N OFFSETS{29864
{{DCA{8,WC{{{POINT TO A(0){29865
{{MOV{13,AROFS(XL){8,WB{{OFFSET TO WORD BEFORE FIRST ITEM{29866
{{ICA{8,WB{{{OFFSET TO FIRST ITEM{29867
*
*      SEPARATE PRE-PROCESSING FOR ARRAYS AND VECTORS DONE.
*      TO SIMPLIFY LATER KEY COMPARISONS, REMOVAL OF ANY TRBLK
*      TRAP BLOCKS FROM ENTRIES IN KEY ARRAY IS EFFECTED.
*
*      (XL) = 1(XS) = POINTER TO KEY ARRAY
*      (XS) = POINTER TO SORT ARRAY
*      WA = NUMBER OF ITEMS, N (CONVERTED TO BYTES).
*      WB = OFFSET TO FIRST ITEM OF ARRAYS.
*      WC = OFFSET TO A(0)
*
{SRT04{BLE{8,WA{19,*NUM01{6,SRT15{RETURN IF ONLY A SINGLE ITEM{29879
{{MOV{8,WA{3,SRTSN{{STORE NUMBER OF ITEMS (IN BAUS){29880
{{MOV{8,WC{3,SRTSO{{STORE OFFSET TO A(0){29881
{{MOV{13,ARLEN(XL){8,WC{{LENGTH OF ARRAY OR VEC (=VCLEN){29882
{{ADD{7,XL{8,WC{{POINT PAST END OF ARRAY OR VECTOR{29883
{{MOV{8,WB{3,SRTSF{{STORE OFFSET TO FIRST ROW{29884
{{ADD{8,WB{7,XL{{POINT TO FIRST ITEM IN KEY ARRAY{29885
*
*      LOOP THROUGH ARRAY
*
{SRT05{MOV{9,(XL){7,XR{{GET AN ENTRY{29889
*
*      HUNT ALONG TRBLK CHAIN
*
{SRT06{BNE{9,(XR){22,=B$TRT{6,SRT07{JUMP OUT IF NOT TRBLK{29893
{{MOV{13,TRVAL(XR){7,XR{{GET VALUE FIELD{29894
{{BRN{6,SRT06{{{LOOP{29895
{{EJC{{{{{29896
*
*      SORTA (CONTINUED)
*
*      XR IS VALUE FROM END OF CHAIN
*
{SRT07{MOV{7,XR{10,(XL)+{{STORE AS ARRAY ENTRY{29902
{{BLT{7,XL{8,WC{6,SRT05{LOOP IF NOT DONE{29903
{{MOV{9,(XS){7,XL{{GET ADRS OF SORT ARRAY{29904
{{MOV{3,SRTSF{7,XR{{INITIAL OFFSET TO FIRST KEY{29905
{{MOV{3,SRTST{8,WB{{GET STRIDE{29906
{{ADD{3,SRTSO{7,XL{{OFFSET TO A(0){29907
{{ICA{7,XL{{{POINT TO A(1){29908
{{MOV{3,SRTSN{8,WC{{GET N{29909
{{BTW{8,WC{{{CONVERT FROM BYTES{29910
{{MOV{8,WC{3,SRTNR{{STORE AS ROW COUNT{29911
{{LCT{8,WC{8,WC{{LOOP COUNTER{29912
*
*      STORE KEY OFFSETS AT TOP OF SORT ARRAY
*
{SRT08{MOV{7,XR{10,(XL)+{{STORE AN OFFSET{29916
{{ADD{8,WB{7,XR{{BUMP OFFSET BY STRIDE{29917
{{BCT{8,WC{6,SRT08{{LOOP THROUGH ROWS{29918
*
*      PERFORM THE SORT ON OFFSETS IN SORT ARRAY.
*
*      (SRTSN)               NUMBER OF ITEMS TO SORT, N (BYTES)
*      (SRTSO)               OFFSET TO A(0)
*
{SRT09{MOV{3,SRTSN{8,WA{{GET N{29925
{{MOV{3,SRTNR{8,WC{{GET NUMBER OF ROWS{29926
{{RSH{8,WC{1,1{{I = N / 2 (WC=I, INDEX INTO ARRAY){29927
{{WTB{8,WC{{{CONVERT BACK TO BYTES{29928
*
*      LOOP TO FORM INITIAL HEAP
*
{SRT10{JSR{6,SORTH{{{SORTH(I,N){29932
{{DCA{8,WC{{{I = I - 1{29933
{{BNZ{8,WC{6,SRT10{{LOOP IF I GT 0{29934
{{MOV{8,WA{8,WC{{I = N{29935
*
*      SORTING LOOP. AT THIS POINT, A(1) IS THE LARGEST
*      ITEM, SINCE ALGORITHM INITIALISES IT AS, AND THEN MAINTAINS
*      IT AS, ROOT OF TREE.
*
{SRT11{DCA{8,WC{{{I = I - 1 (N - 1 INITIALLY){29941
{{BZE{8,WC{6,SRT12{{JUMP IF DONE{29942
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADDRESS{29943
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){29944
{{MOV{7,XR{7,XL{{A(0) ADDRESS{29945
{{ADD{8,WC{7,XL{{A(I) ADDRESS{29946
{{MOV{13,NUM01(XL){8,WB{{COPY A(I+1){29947
{{MOV{13,NUM01(XR){13,NUM01(XL){{MOVE A(1) TO A(I+1){29948
{{MOV{8,WB{13,NUM01(XR){{COMPLETE EXCHANGE OF A(1), A(I+1){29949
{{MOV{8,WC{8,WA{{N = I FOR SORTH{29950
{{MOV{19,*NUM01{8,WC{{I = 1 FOR SORTH{29951
{{JSR{6,SORTH{{{SORTH(1,N){29952
{{MOV{8,WA{8,WC{{RESTORE WC{29953
{{BRN{6,SRT11{{{LOOP{29954
{{EJC{{{{{29955
*
*      SORTA (CONTINUED)
*
*      OFFSETS HAVE BEEN PERMUTED INTO REQUIRED ORDER BY SORT.
*      COPY ARRAY ELEMENTS OVER THEM.
*
{SRT12{MOV{9,(XS){7,XR{{BASE ADRS OF KEY ARRAY{29962
{{MOV{7,XR{8,WC{{COPY IT{29963
{{ADD{3,SRTSO{8,WC{{OFFSET OF A(0){29964
{{ADD{3,SRTSF{7,XR{{ADRS OF FIRST ROW OF SORT ARRAY{29965
{{MOV{3,SRTST{8,WB{{GET STRIDE{29966
*
*      COPYING LOOP FOR SUCCESSIVE ITEMS. SORTED OFFSETS ARE
*      HELD AT END OF SORT ARRAY.
*
{SRT13{ICA{8,WC{{{ADRS OF NEXT OF SORTED OFFSETS{29971
{{MOV{8,WC{7,XL{{COPY IT FOR ACCESS{29972
{{MOV{9,(XL){7,XL{{GET OFFSET{29973
{{ADD{13,NUM01(XS){7,XL{{ADD KEY ARRAY BASE ADRS{29974
{{MOV{8,WB{8,WA{{GET COUNT OF CHARACTERS IN ROW{29975
{{MVW{{{{COPY A COMPLETE ROW{29976
{{DCV{3,SRTNR{{{DECREMENT ROW COUNT{29977
{{BNZ{3,SRTNR{6,SRT13{{REPEAT TILL ALL ROWS DONE{29978
*
*      RETURN POINT
*
{SRT15{MOV{10,(XS)+{7,XR{{POP RESULT ARRAY PTR{29982
{{ICA{7,XS{{{POP KEY ARRAY PTR{29983
{{ZER{3,R$SXL{{{CLEAR JUNK{29984
{{ZER{3,R$SXR{{{CLEAR JUNK{29985
{{EXI{{{{RETURN{29986
*
*      ERROR POINT
*
{SRT16{ERB{1,256{26,SORT/RSORT 1st arg not suitable ARRAY or TABLE{{{29990
{SRT17{ERB{1,258{26,SORT/RSORT 2nd arg out of range or non-integer{{{29991
*
*      RETURN POINT IF INPUT TABLE IS EMPTY
*
{SRT18{EXI{1,1{{{RETURN INDICATION OF NULL TABLE{29995
{{ENP{{{{END PROCUDURE SORTA{29996
{{EJC{{{{{29997
*
*      SORTC --  COMPARE SORT KEYS
*
*      COMPARE TWO SORT KEYS GIVEN THEIR OFFSETS. IF
*      EQUAL, COMPARE KEY OFFSETS TO GIVE STABLE SORT.
*      NOTE THAT IF SRTSR IS NON-ZERO (REQUEST FOR REVERSE
*      SORT), THE QUOTED RETURNS ARE INVERTED.
*      FOR OBJECTS OF DIFFERING DATATYPES, THE ENTRY POINT
*      IDENTIFICATIONS ARE COMPARED.
*
*      (XL)                  BASE ADRS FOR KEYS
*      (WA)                  OFFSET TO KEY 1 ITEM
*      (WB)                  OFFSET TO KEY 2 ITEM
*      (SRTSR)               ZERO/NON-ZERO FOR SORT/RSORT
*      (SRTOF)               OFFSET WITHIN ROW TO COMPARANDS
*      JSR  SORTC            CALL TO COMPARE KEYS
*      PPM  LOC              KEY1 LESS THAN KEY2
*                            NORMAL RETURN, KEY1 GT THAN KEY2
*      (XL,XR,WA,WB)         DESTROYED
*
{SORTC{PRC{25,E{1,1{{ENTRY POINT{30018
{{MOV{8,WA{3,SRTS1{{SAVE OFFSET 1{30019
{{MOV{8,WB{3,SRTS2{{SAVE OFFSET 2{30020
{{MOV{8,WC{3,SRTSC{{SAVE WC{30021
{{ADD{3,SRTOF{7,XL{{ADD OFFSET TO COMPARAND FIELD{30022
{{MOV{7,XL{7,XR{{COPY BASE + OFFSET{30023
{{ADD{8,WA{7,XL{{ADD KEY1 OFFSET{30024
{{ADD{8,WB{7,XR{{ADD KEY2 OFFSET{30025
{{MOV{9,(XL){7,XL{{GET KEY1{30026
{{MOV{9,(XR){7,XR{{GET KEY2{30027
{{BNE{3,SRTDF{21,=NULLS{6,SRC12{JUMP IF DATATYPE FIELD NAME USED{30028
{{EJC{{{{{30029
*
*      SORTC (CONTINUED)
*
*      MERGE AFTER DEALING WITH FIELD NAME. TRY FOR STRINGS.
*
{SRC01{MOV{9,(XL){8,WC{{GET TYPE CODE{30035
{{BNE{8,WC{9,(XR){6,SRC02{SKIP IF NOT SAME DATATYPE{30036
{{BEQ{8,WC{22,=B$SCL{6,SRC09{JUMP IF BOTH STRINGS{30037
{{BEQ{8,WC{22,=B$ICL{6,SRC14{JUMP IF BOTH INTEGERS{30038
*
*      DATATYPES DIFFERENT.  NOW TRY FOR NUMERIC
*
{SRC02{MOV{7,XL{3,R$SXL{{KEEP ARG1{30046
{{MOV{7,XR{3,R$SXR{{KEEP ARG2{30047
{{BEQ{8,WC{22,=B$SCL{6,SRC11{DO NOT ALLOW CONVERSION TO NUMBER{30050
{{BEQ{9,(XR){22,=B$SCL{6,SRC11{IF EITHER ARG IS A STRING{30051
{SRC14{MOV{7,XL{11,-(XS){{STACK{30094
{{MOV{7,XR{11,-(XS){{ARGS{30095
{{JSR{6,ACOMP{{{COMPARE OBJECTS{30096
{{PPM{6,SRC10{{{NOT NUMERIC{30097
{{PPM{6,SRC10{{{NOT NUMERIC{30098
{{PPM{6,SRC03{{{KEY1 LESS{30099
{{PPM{6,SRC08{{{KEYS EQUAL{30100
{{PPM{6,SRC05{{{KEY1 GREATER{30101
*
*      RETURN IF KEY1 SMALLER (SORT), GREATER (RSORT)
*
{SRC03{BNZ{3,SRTSR{6,SRC06{{JUMP IF RSORT{30105
*
{SRC04{MOV{3,SRTSC{8,WC{{RESTORE WC{30107
{{EXI{1,1{{{RETURN{30108
*
*      RETURN IF KEY1 GREATER (SORT), SMALLER (RSORT)
*
{SRC05{BNZ{3,SRTSR{6,SRC04{{JUMP IF RSORT{30112
*
{SRC06{MOV{3,SRTSC{8,WC{{RESTORE WC{30114
{{EXI{{{{RETURN{30115
*
*      KEYS ARE OF SAME DATATYPE
*
{SRC07{BLT{7,XL{7,XR{6,SRC03{ITEM FIRST CREATED IS LESS{30119
{{BGT{7,XL{7,XR{6,SRC05{ADDRESSES RISE IN ORDER OF CREATION{30120
*
*      DROP THROUGH OR MERGE FOR IDENTICAL OR EQUAL OBJECTS
*
{SRC08{BLT{3,SRTS1{3,SRTS2{6,SRC04{TEST OFFSETS OR KEY ADDRSS INSTEAD{30124
{{BRN{6,SRC06{{{OFFSET 1 GREATER{30125
{{EJC{{{{{30126
*
*      SORTC (CONTINUED)
*
*      STRINGS
*
{SRC09{MOV{7,XL{11,-(XS){{STACK{30136
{{MOV{7,XR{11,-(XS){{ARGS{30137
{{JSR{6,LCOMP{{{COMPARE OBJECTS{30138
{{PPM{{{{CANT{30139
{{PPM{{{{FAIL{30140
{{PPM{6,SRC03{{{KEY1 LESS{30141
{{PPM{6,SRC08{{{KEYS EQUAL{30142
{{PPM{6,SRC05{{{KEY1 GREATER{30143
*
*      ARITHMETIC COMPARISON FAILED - RECOVER ARGS
*
{SRC10{MOV{3,R$SXL{7,XL{{GET ARG1{30147
{{MOV{3,R$SXR{7,XR{{GET ARG2{30148
{{MOV{9,(XL){8,WC{{GET TYPE OF KEY1{30149
{{BEQ{8,WC{9,(XR){6,SRC07{JUMP IF KEYS OF SAME TYPE{30150
*
*      HERE TO COMPARE DATATYPE IDS
*
{SRC11{MOV{8,WC{7,XL{{GET BLOCK TYPE WORD{30154
{{MOV{9,(XR){7,XR{{GET BLOCK TYPE WORD{30155
{{LEI{7,XL{{{ENTRY POINT ID FOR KEY1{30156
{{LEI{7,XR{{{ENTRY POINT ID FOR KEY2{30157
{{BGT{7,XL{7,XR{6,SRC05{JUMP IF KEY1 GT KEY2{30158
{{BRN{6,SRC03{{{KEY1 LT KEY2{30159
*
*      DATATYPE FIELD NAME USED
*
{SRC12{JSR{6,SORTF{{{CALL ROUTINE TO FIND FIELD 1{30163
{{MOV{7,XL{11,-(XS){{STACK ITEM POINTER{30164
{{MOV{7,XR{7,XL{{GET KEY2{30165
{{JSR{6,SORTF{{{FIND FIELD 2{30166
{{MOV{7,XL{7,XR{{PLACE AS KEY2{30167
{{MOV{10,(XS)+{7,XL{{RECOVER KEY1{30168
{{BRN{6,SRC01{{{MERGE{30169
{{ENP{{{{PROCEDURE SORTC{30170
{{EJC{{{{{30171
*
*      SORTF -- FIND FIELD FOR SORTC
*
*      ROUTINE USED BY SORTC TO OBTAIN ITEM CORRESPONDING
*      TO A GIVEN FIELD NAME, IF THIS EXISTS, IN A PROGRAMMER
*      DEFINED OBJECT PASSED AS ARGUMENT.
*      IF SUCH A MATCH OCCURS, RECORD IS KEPT OF DATATYPE
*      NAME, FIELD NAME AND OFFSET TO FIELD IN ORDER TO
*      SHORT-CIRCUIT LATER SEARCHES ON SAME TYPE. NOTE THAT
*      DFBLKS ARE STORED IN STATIC AND HENCE CANNOT BE MOVED.
*
*      (SRTDF)               VRBLK POINTER OF FIELD NAME
*      (XL)                  POSSIBLE PDBLK POINTER
*      JSR  SORTF            CALL TO SEARCH FOR FIELD NAME
*      (XL)                  ITEM FOUND OR ORIGINAL PDBLK PTR
*      (WC)                  DESTROYED
*
{SORTF{PRC{25,E{1,0{{ENTRY POINT{30189
{{BNE{9,(XL){22,=B$PDT{6,SRTF3{RETURN IF NOT PDBLK{30190
{{MOV{7,XR{11,-(XS){{KEEP XR{30191
{{MOV{3,SRTFD{7,XR{{GET POSSIBLE FORMER DFBLK PTR{30192
{{BZE{7,XR{6,SRTF4{{JUMP IF NOT{30193
{{BNE{7,XR{13,PDDFP(XL){6,SRTF4{JUMP IF NOT RIGHT DATATYPE{30194
{{BNE{3,SRTDF{3,SRTFF{6,SRTF4{JUMP IF NOT RIGHT FIELD NAME{30195
{{ADD{3,SRTFO{7,XL{{ADD OFFSET TO REQUIRED FIELD{30196
*
*      HERE WITH XL POINTING TO FOUND FIELD
*
{SRTF1{MOV{9,(XL){7,XL{{GET ITEM FROM FIELD{30200
*
*      RETURN POINT
*
{SRTF2{MOV{10,(XS)+{7,XR{{RESTORE XR{30204
*
{SRTF3{EXI{{{{RETURN{30206
{{EJC{{{{{30207
*
*      SORTF (CONTINUED)
*
*      CONDUCT A SEARCH
*
{SRTF4{MOV{7,XL{7,XR{{COPY ORIGINAL POINTER{30213
{{MOV{13,PDDFP(XR){7,XR{{POINT TO DFBLK{30214
{{MOV{7,XR{3,SRTFD{{KEEP A COPY{30215
{{MOV{13,FARGS(XR){8,WC{{GET NUMBER OF FIELDS{30216
{{WTB{8,WC{{{CONVERT TO BYTES{30217
{{ADD{13,DFLEN(XR){7,XR{{POINT PAST LAST FIELD{30218
*
*      LOOP TO FIND NAME IN PDFBLK
*
{SRTF5{DCA{8,WC{{{COUNT DOWN{30222
{{DCA{7,XR{{{POINT IN FRONT{30223
{{BEQ{9,(XR){3,SRTDF{6,SRTF6{SKIP OUT IF FOUND{30224
{{BNZ{8,WC{6,SRTF5{{LOOP{30225
{{BRN{6,SRTF2{{{RETURN - NOT FOUND{30226
*
*      FOUND
*
{SRTF6{MOV{9,(XR){3,SRTFF{{KEEP FIELD NAME PTR{30230
{{ADD{19,*PDFLD{8,WC{{ADD OFFSET TO FIRST FIELD{30231
{{MOV{8,WC{3,SRTFO{{STORE AS FIELD OFFSET{30232
{{ADD{8,WC{7,XL{{POINT TO FIELD{30233
{{BRN{6,SRTF1{{{RETURN{30234
{{ENP{{{{PROCEDURE SORTF{30235
{{EJC{{{{{30236
*
*      SORTH -- HEAP ROUTINE FOR SORTA
*
*      THIS ROUTINE CONSTRUCTS A HEAP FROM ELEMENTS OF ARRAY, A.
*      IN THIS APPLICATION, THE ELEMENTS ARE OFFSETS TO KEYS IN
*      A KEY ARRAY.
*
*      (XS)                  POINTER TO SORT ARRAY BASE
*      1(XS)                 POINTER TO KEY ARRAY BASE
*      (WA)                  MAX ARRAY INDEX, N (IN BYTES)
*      (WC)                  OFFSET J IN A TO ROOT (IN *1 TO *N)
*      JSR  SORTH            CALL SORTH(J,N) TO MAKE HEAP
*      (XL,XR,WB)            DESTROYED
*
{SORTH{PRC{25,N{1,0{{ENTRY POINT{30251
{{MOV{8,WA{3,SRTSN{{SAVE N{30252
{{MOV{8,WC{3,SRTWC{{KEEP WC{30253
{{MOV{9,(XS){7,XL{{SORT ARRAY BASE ADRS{30254
{{ADD{3,SRTSO{7,XL{{ADD OFFSET TO A(0){30255
{{ADD{8,WC{7,XL{{POINT TO A(J){30256
{{MOV{9,(XL){3,SRTRT{{GET OFFSET TO ROOT{30257
{{ADD{8,WC{8,WC{{DOUBLE J - CANT EXCEED N{30258
*
*      LOOP TO MOVE DOWN TREE USING DOUBLED INDEX J
*
{SRH01{BGT{8,WC{3,SRTSN{6,SRH03{DONE IF J GT N{30262
{{BEQ{8,WC{3,SRTSN{6,SRH02{SKIP IF J EQUALS N{30263
{{MOV{9,(XS){7,XR{{SORT ARRAY BASE ADRS{30264
{{MOV{13,NUM01(XS){7,XL{{KEY ARRAY BASE ADRS{30265
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){30266
{{ADD{8,WC{7,XR{{ADRS OF A(J){30267
{{MOV{13,NUM01(XR){8,WA{{GET A(J+1){30268
{{MOV{9,(XR){8,WB{{GET A(J){30269
*
*      COMPARE SONS. (WA) RIGHT SON, (WB) LEFT SON
*
{{JSR{6,SORTC{{{COMPARE KEYS - LT(A(J+1),A(J)){30273
{{PPM{6,SRH02{{{A(J+1) LT A(J){30274
{{ICA{8,WC{{{POINT TO GREATER SON, A(J+1){30275
{{EJC{{{{{30276
*
*      SORTH (CONTINUED)
*
*      COMPARE ROOT WITH GREATER SON
*
{SRH02{MOV{13,NUM01(XS){7,XL{{KEY ARRAY BASE ADRS{30282
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADDRESS{30283
{{ADD{3,SRTSO{7,XR{{ADRS OF A(0){30284
{{MOV{7,XR{8,WB{{COPY THIS ADRS{30285
{{ADD{8,WC{7,XR{{ADRS OF GREATER SON, A(J){30286
{{MOV{9,(XR){8,WA{{GET A(J){30287
{{MOV{8,WB{7,XR{{POINT BACK TO A(0){30288
{{MOV{3,SRTRT{8,WB{{GET ROOT{30289
{{JSR{6,SORTC{{{COMPARE THEM - LT(A(J),ROOT){30290
{{PPM{6,SRH03{{{FATHER EXCEEDS SONS - DONE{30291
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADRS{30292
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){30293
{{MOV{7,XR{7,XL{{COPY IT{30294
{{MOV{8,WC{8,WA{{COPY J{30295
{{BTW{8,WC{{{CONVERT TO WORDS{30296
{{RSH{8,WC{1,1{{GET J/2{30297
{{WTB{8,WC{{{CONVERT BACK TO BYTES{30298
{{ADD{8,WA{7,XL{{POINT TO A(J){30299
{{ADD{8,WC{7,XR{{ADRS OF A(J/2){30300
{{MOV{9,(XL){9,(XR){{A(J/2) = A(J){30301
{{MOV{8,WA{8,WC{{RECOVER J{30302
{{AOV{8,WC{8,WC{6,SRH03{J = J*2. DONE IF TOO BIG{30303
{{BRN{6,SRH01{{{LOOP{30304
*
*      FINISH BY COPYING ROOT OFFSET BACK INTO ARRAY
*
{SRH03{BTW{8,WC{{{CONVERT TO WORDS{30308
{{RSH{8,WC{1,1{{J = J/2{30309
{{WTB{8,WC{{{CONVERT BACK TO BYTES{30310
{{MOV{9,(XS){7,XR{{SORT ARRAY ADRS{30311
{{ADD{3,SRTSO{7,XR{{ADRS OF A(0){30312
{{ADD{8,WC{7,XR{{ADRS OF A(J/2){30313
{{MOV{3,SRTRT{9,(XR){{A(J/2) = ROOT{30314
{{MOV{3,SRTSN{8,WA{{RESTORE WA{30315
{{MOV{3,SRTWC{8,WC{{RESTORE WC{30316
{{EXI{{{{RETURN{30317
{{ENP{{{{END PROCEDURE SORTH{30318
{{EJC{{{{{30320
*
*      TRACE -- SET/RESET A TRACE ASSOCIATION
*
*      THIS PROCEDURE IS SHARED BY TRACE AND STOPTR TO
*      EITHER INITIATE OR STOP A TRACE RESPECTIVELY.
*
*      (XL)                  TRBLK PTR (TRACE) OR ZERO (STOPTR)
*      1(XS)                 FIRST ARGUMENT (NAME)
*      0(XS)                 SECOND ARGUMENT (TRACE TYPE)
*      JSR  TRACE            CALL TO SET/RESET TRACE
*      PPM  LOC              TRANSFER LOC IF 1ST ARG IS BAD NAME
*      PPM  LOC              TRANSFER LOC IF 2ND ARG IS BAD TYPE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{TRACE{PRC{25,N{1,2{{ENTRY POINT{30336
{{JSR{6,GTSTG{{{GET TRACE TYPE STRING{30337
{{PPM{6,TRC15{{{JUMP IF NOT STRING{30338
{{PLC{7,XR{{{ELSE POINT TO STRING{30339
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{30340
{{FLC{8,WA{{{FOLD TO UPPER CASE{30342
{{MOV{9,(XS){7,XR{{LOAD NAME ARGUMENT{30344
{{MOV{7,XL{9,(XS){{STACK TRBLK PTR OR ZERO{30345
{{MOV{18,=TRTAC{8,WC{{SET TRTYP FOR ACCESS TRACE{30346
{{BEQ{8,WA{18,=CH$LA{6,TRC10{JUMP IF A (ACCESS){30347
{{MOV{18,=TRTVL{8,WC{{SET TRTYP FOR VALUE TRACE{30348
{{BEQ{8,WA{18,=CH$LV{6,TRC10{JUMP IF V (VALUE){30349
{{BEQ{8,WA{18,=CH$BL{6,TRC10{JUMP IF BLANK (VALUE){30350
*
*      HERE FOR L,K,F,C,R
*
{{BEQ{8,WA{18,=CH$LF{6,TRC01{JUMP IF F (FUNCTION){30354
{{BEQ{8,WA{18,=CH$LR{6,TRC01{JUMP IF R (RETURN){30355
{{BEQ{8,WA{18,=CH$LL{6,TRC03{JUMP IF L (LABEL){30356
{{BEQ{8,WA{18,=CH$LK{6,TRC06{JUMP IF K (KEYWORD){30357
{{BNE{8,WA{18,=CH$LC{6,TRC15{ELSE ERROR IF NOT C (CALL){30358
*
*      HERE FOR F,C,R
*
{TRC01{JSR{6,GTNVR{{{POINT TO VRBLK FOR NAME{30362
{{PPM{6,TRC16{{{JUMP IF BAD NAME{30363
{{ICA{7,XS{{{POP STACK{30364
{{MOV{13,VRFNC(XR){7,XR{{POINT TO FUNCTION BLOCK{30365
{{BNE{9,(XR){22,=B$PFC{6,TRC17{ERROR IF NOT PROGRAM FUNCTION{30366
{{BEQ{8,WA{18,=CH$LR{6,TRC02{JUMP IF R (RETURN){30367
{{EJC{{{{{30368
*
*      TRACE (CONTINUED)
*
*      HERE FOR F,C TO SET/RESET CALL TRACE
*
{{MOV{7,XL{13,PFCTR(XR){{SET/RESET CALL TRACE{30374
{{BEQ{8,WA{18,=CH$LC{6,EXNUL{EXIT WITH NULL IF C (CALL){30375
*
*      HERE FOR F,R TO SET/RESET RETURN TRACE
*
{TRC02{MOV{7,XL{13,PFRTR(XR){{SET/RESET RETURN TRACE{30379
{{EXI{{{{RETURN{30380
*
*      HERE FOR L TO SET/RESET LABEL TRACE
*
{TRC03{JSR{6,GTNVR{{{POINT TO VRBLK{30384
{{PPM{6,TRC16{{{JUMP IF BAD NAME{30385
{{MOV{13,VRLBL(XR){7,XL{{LOAD LABEL POINTER{30386
{{BNE{9,(XL){22,=B$TRT{6,TRC04{JUMP IF NO OLD TRACE{30387
{{MOV{13,TRLBL(XL){7,XL{{ELSE DELETE OLD TRACE ASSOCIATION{30388
*
*      HERE WITH OLD LABEL TRACE ASSOCIATION DELETED
*
{TRC04{BEQ{7,XL{21,=STNDL{6,TRC16{ERROR IF UNDEFINED LABEL{30392
{{MOV{10,(XS)+{8,WB{{GET TRBLK PTR AGAIN{30393
{{BZE{8,WB{6,TRC05{{JUMP IF STOPTR CASE{30394
{{MOV{8,WB{13,VRLBL(XR){{ELSE SET NEW TRBLK POINTER{30395
{{MOV{22,=B$VRT{13,VRTRA(XR){{SET LABEL TRACE ROUTINE ADDRESS{30396
{{MOV{8,WB{7,XR{{COPY TRBLK POINTER{30397
{{MOV{7,XL{13,TRLBL(XR){{STORE REAL LABEL IN TRBLK{30398
{{EXI{{{{RETURN{30399
*
*      HERE FOR STOPTR CASE FOR LABEL
*
{TRC05{MOV{7,XL{13,VRLBL(XR){{STORE LABEL PTR BACK IN VRBLK{30403
{{MOV{22,=B$VRG{13,VRTRA(XR){{STORE NORMAL TRANSFER ADDRESS{30404
{{EXI{{{{RETURN{30405
{{EJC{{{{{30406
*
*      TRACE (CONTINUED)
*
*      HERE FOR K (KEYWORD)
*
{TRC06{JSR{6,GTNVR{{{POINT TO VRBLK{30412
{{PPM{6,TRC16{{{ERROR IF NOT NATURAL VAR{30413
{{BNZ{13,VRLEN(XR){6,TRC16{{ERROR IF NOT SYSTEM VAR{30414
{{ICA{7,XS{{{POP STACK{30415
{{BZE{7,XL{6,TRC07{{JUMP IF STOPTR CASE{30416
{{MOV{7,XR{13,TRKVR(XL){{STORE VRBLK PTR IN TRBLK FOR KTREX{30417
*
*      MERGE HERE WITH TRBLK SET UP IN WB (OR ZERO)
*
{TRC07{MOV{13,VRSVP(XR){7,XR{{POINT TO SVBLK{30421
{{BEQ{7,XR{21,=V$ERT{6,TRC08{JUMP IF ERRTYPE{30422
{{BEQ{7,XR{21,=V$STC{6,TRC09{JUMP IF STCOUNT{30423
{{BNE{7,XR{21,=V$FNC{6,TRC17{ELSE ERROR IF NOT FNCLEVEL{30424
*
*      FNCLEVEL
*
{{MOV{7,XL{3,R$FNC{{SET/RESET FNCLEVEL TRACE{30428
{{EXI{{{{RETURN{30429
*
*      ERRTYPE
*
{TRC08{MOV{7,XL{3,R$ERT{{SET/RESET ERRTYPE TRACE{30433
{{EXI{{{{RETURN{30434
*
*      STCOUNT
*
{TRC09{MOV{7,XL{3,R$STC{{SET/RESET STCOUNT TRACE{30438
{{JSR{6,STGCC{{{UPDATE COUNTDOWN COUNTERS{30439
{{EXI{{{{RETURN{30440
{{EJC{{{{{30441
*
*      TRACE (CONTINUED)
*
*      A,V MERGE HERE WITH TRTYP VALUE IN WC
*
{TRC10{JSR{6,GTVAR{{{LOCATE VARIABLE{30447
{{PPM{6,TRC16{{{ERROR IF NOT APPROPRIATE NAME{30448
{{MOV{10,(XS)+{8,WB{{GET NEW TRBLK PTR AGAIN{30449
{{ADD{7,XL{8,WA{{POINT TO VARIABLE LOCATION{30450
{{MOV{8,WA{7,XR{{COPY VARIABLE POINTER{30451
*
*      LOOP TO SEARCH TRBLK CHAIN
*
{TRC11{MOV{9,(XR){7,XL{{POINT TO NEXT ENTRY{30455
{{BNE{9,(XL){22,=B$TRT{6,TRC13{JUMP IF NOT TRBLK{30456
{{BLT{8,WC{13,TRTYP(XL){6,TRC13{JUMP IF TOO FAR OUT ON CHAIN{30457
{{BEQ{8,WC{13,TRTYP(XL){6,TRC12{JUMP IF THIS MATCHES OUR TYPE{30458
{{ADD{19,*TRNXT{7,XL{{ELSE POINT TO LINK FIELD{30459
{{MOV{7,XL{7,XR{{COPY POINTER{30460
{{BRN{6,TRC11{{{AND LOOP BACK{30461
*
*      HERE TO DELETE AN OLD TRBLK OF THE TYPE WE WERE GIVEN
*
{TRC12{MOV{13,TRNXT(XL){7,XL{{GET PTR TO NEXT BLOCK OR VALUE{30465
{{MOV{7,XL{9,(XR){{STORE TO DELETE THIS TRBLK{30466
*
*      HERE AFTER DELETING ANY OLD ASSOCIATION OF THIS TYPE
*
{TRC13{BZE{8,WB{6,TRC14{{JUMP IF STOPTR CASE{30470
{{MOV{8,WB{9,(XR){{ELSE LINK NEW TRBLK IN{30471
{{MOV{8,WB{7,XR{{COPY TRBLK POINTER{30472
{{MOV{7,XL{13,TRNXT(XR){{STORE FORWARD POINTER{30473
{{MOV{8,WC{13,TRTYP(XR){{STORE APPROPRIATE TRAP TYPE CODE{30474
*
*      HERE TO MAKE SURE VRGET,VRSTO ARE SET PROPERLY
*
{TRC14{MOV{8,WA{7,XR{{RECALL POSSIBLE VRBLK POINTER{30478
{{SUB{19,*VRVAL{7,XR{{POINT BACK TO VRBLK{30479
{{JSR{6,SETVR{{{SET FIELDS IF VRBLK{30480
{{EXI{{{{RETURN{30481
*
*      HERE FOR BAD TRACE TYPE
*
{TRC15{EXI{1,2{{{TAKE BAD TRACE TYPE ERROR EXIT{30485
*
*      POP STACK BEFORE FAILING
*
{TRC16{ICA{7,XS{{{POP STACK{30489
*
*      HERE FOR BAD NAME ARGUMENT
*
{TRC17{EXI{1,1{{{TAKE BAD NAME ERROR EXIT{30493
{{ENP{{{{END PROCEDURE TRACE{30494
{{EJC{{{{{30495
*
*      TRBLD -- BUILD TRBLK
*
*      TRBLK IS USED BY THE INPUT, OUTPUT AND TRACE FUNCTIONS
*      TO CONSTRUCT A TRBLK (TRAP BLOCK)
*
*      (XR)                  TRTAG OR TRTER
*      (XL)                  TRFNC OR TRFPT
*      (WB)                  TRTYP
*      JSR  TRBLD            CALL TO BUILD TRBLK
*      (XR)                  POINTER TO TRBLK
*      (WA)                  DESTROYED
*
{TRBLD{PRC{25,E{1,0{{ENTRY POINT{30509
{{MOV{7,XR{11,-(XS){{STACK TRTAG (OR TRFNM){30510
{{MOV{19,*TRSI${8,WA{{SET SIZE OF TRBLK{30511
{{JSR{6,ALLOC{{{ALLOCATE TRBLK{30512
{{MOV{22,=B$TRT{9,(XR){{STORE FIRST WORD{30513
{{MOV{7,XL{13,TRFNC(XR){{STORE TRFNC (OR TRFPT){30514
{{MOV{10,(XS)+{13,TRTAG(XR){{STORE TRTAG (OR TRFNM){30515
{{MOV{8,WB{13,TRTYP(XR){{STORE TYPE{30516
{{MOV{21,=NULLS{13,TRVAL(XR){{FOR NOW, A NULL VALUE{30517
{{EXI{{{{RETURN TO CALLER{30518
{{ENP{{{{END PROCEDURE TRBLD{30519
{{EJC{{{{{30520
*
*      TRIMR -- TRIM TRAILING BLANKS
*
*      TRIMR IS PASSED A POINTER TO AN SCBLK WHICH MUST BE THE
*      LAST BLOCK IN DYNAMIC STORAGE. TRAILING BLANKS ARE
*      TRIMMED OFF AND THE DYNAMIC STORAGE POINTER RESET TO
*      THE END OF THE (POSSIBLY) SHORTENED BLOCK.
*
*      (WB)                  NON-ZERO TO TRIM TRAILING BLANKS
*      (XR)                  POINTER TO STRING TO TRIM
*      JSR  TRIMR            CALL TO TRIM STRING
*      (XR)                  POINTER TO TRIMMED STRING
*      (XL,WA,WB,WC)         DESTROYED
*
*      THE CALL WITH WB ZERO STILL PERFORMS THE END ZERO PAD
*      AND DNAMP READJUSTMENT. IT IS USED FROM ACESS IF KVTRM=0.
*
{TRIMR{PRC{25,E{1,0{{ENTRY POINT{30538
{{MOV{7,XR{7,XL{{COPY STRING POINTER{30539
{{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{30540
{{BZE{8,WA{6,TRIM2{{JUMP IF NULL INPUT{30541
{{PLC{7,XL{8,WA{{ELSE POINT PAST LAST CHARACTER{30542
{{BZE{8,WB{6,TRIM3{{JUMP IF NO TRIM{30543
{{MOV{18,=CH$BL{8,WC{{LOAD BLANK CHARACTER{30544
*
*      LOOP THROUGH CHARACTERS FROM RIGHT TO LEFT
*
{TRIM0{LCH{8,WB{11,-(XL){{LOAD NEXT CHARACTER{30548
{{BEQ{8,WB{18,=CH$HT{6,TRIM1{JUMP IF HORIZONTAL TAB{30550
{{BNE{8,WB{8,WC{6,TRIM3{JUMP IF NON-BLANK FOUND{30552
{TRIM1{DCV{8,WA{{{ELSE DECREMENT CHARACTER COUNT{30553
{{BNZ{8,WA{6,TRIM0{{LOOP BACK IF MORE TO CHECK{30554
*
*      HERE IF RESULT IS NULL (NULL OR ALL-BLANK INPUT)
*
{TRIM2{MOV{7,XR{3,DNAMP{{WIPE OUT INPUT STRING BLOCK{30558
{{MOV{21,=NULLS{7,XR{{LOAD NULL RESULT{30559
{{BRN{6,TRIM5{{{MERGE TO EXIT{30560
{{EJC{{{{{30561
*
*      TRIMR (CONTINUED)
*
*      HERE WITH NON-BLANK FOUND (MERGE FOR NO TRIM)
*
{TRIM3{MOV{8,WA{13,SCLEN(XR){{SET NEW LENGTH{30567
{{MOV{7,XR{7,XL{{COPY STRING POINTER{30568
{{PSC{7,XL{8,WA{{READY FOR STORING BLANKS{30569
{{CTB{8,WA{2,SCHAR{{GET LENGTH OF BLOCK IN BYTES{30570
{{ADD{7,XR{8,WA{{POINT PAST NEW BLOCK{30571
{{MOV{8,WA{3,DNAMP{{SET NEW TOP OF STORAGE POINTER{30572
{{LCT{8,WA{18,=CFP$C{{GET COUNT OF CHARS IN WORD{30573
{{ZER{8,WC{{{SET ZERO CHAR{30574
*
*      LOOP TO ZERO PAD LAST WORD OF CHARACTERS
*
{TRIM4{SCH{8,WC{10,(XL)+{{STORE ZERO CHARACTER{30578
{{BCT{8,WA{6,TRIM4{{LOOP BACK TILL ALL STORED{30579
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{30580
*
*      COMMON EXIT POINT
*
{TRIM5{ZER{7,XL{{{CLEAR GARBAGE XL POINTER{30584
{{EXI{{{{RETURN TO CALLER{30585
{{ENP{{{{END PROCEDURE TRIMR{30586
{{EJC{{{{{30587
*
*      TRXEQ -- EXECUTE FUNCTION TYPE TRACE
*
*      TRXEQ IS USED TO EXECUTE A TRACE WHEN A FOURTH ARGUMENT
*      HAS BEEN SUPPLIED. TRACE HAS ALREADY BEEN DECREMENTED.
*
*      (XR)                  POINTER TO TRBLK
*      (XL,WA)               NAME BASE,OFFSET FOR VARIABLE
*      JSR  TRXEQ            CALL TO EXECUTE TRACE
*      (WB,WC,RA)            DESTROYED
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE TRACE FUNCTION USING THE CFUNC ROUTINE.
*
*                            TRXEQ RETURN POINT WORD(S)
*                            SAVED VALUE OF TRACE KEYWORD
*                            TRBLK POINTER
*                            NAME BASE
*                            NAME OFFSET
*                            SAVED VALUE OF R$COD
*                            SAVED CODE PTR (-R$COD)
*                            SAVED VALUE OF FLPTR
*      FLPTR --------------- ZERO (DUMMY FAIL OFFSET)
*                            NMBLK FOR VARIABLE NAME
*      XS ------------------ TRACE TAG
*
*      R$COD AND THE CODE PTR ARE SET TO DUMMY VALUES WHICH
*      CAUSE CONTROL TO RETURN TO THE TRXEQ PROCEDURE ON SUCCESS
*      OR FAILURE (TRXEQ IGNORES A FAILURE CONDITION).
*
{TRXEQ{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){30618
{{MOV{3,R$COD{8,WC{{LOAD CODE BLOCK POINTER{30619
{{SCP{8,WB{{{GET CURRENT CODE POINTER{30620
{{SUB{8,WC{8,WB{{MAKE CODE POINTER INTO OFFSET{30621
{{MOV{3,KVTRA{11,-(XS){{STACK TRACE KEYWORD VALUE{30622
{{MOV{7,XR{11,-(XS){{STACK TRBLK POINTER{30623
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{30624
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{30625
{{MOV{8,WC{11,-(XS){{STACK CODE BLOCK POINTER{30626
{{MOV{8,WB{11,-(XS){{STACK CODE POINTER OFFSET{30627
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{30628
{{ZER{11,-(XS){{{SET DUMMY FAIL OFFSET{30629
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{30630
{{ZER{3,KVTRA{{{RESET TRACE KEYWORD TO ZERO{30631
{{MOV{21,=TRXDC{8,WC{{LOAD NEW (DUMMY) CODE BLK POINTER{30632
{{MOV{8,WC{3,R$COD{{SET AS CODE BLOCK POINTER{30633
{{LCP{8,WC{{{AND NEW CODE POINTER{30634
{{EJC{{{{{30635
*
*      TRXEQ (CONTINUED)
*
*      NOW PREPARE ARGUMENTS FOR FUNCTION
*
{{MOV{8,WA{8,WB{{SAVE NAME OFFSET{30641
{{MOV{19,*NMSI${8,WA{{LOAD NMBLK SIZE{30642
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR NMBLK{30643
{{MOV{22,=B$NML{9,(XR){{SET TYPE WORD{30644
{{MOV{7,XL{13,NMBAS(XR){{STORE NAME BASE{30645
{{MOV{8,WB{13,NMOFS(XR){{STORE NAME OFFSET{30646
{{MOV{12,6(XS){7,XL{{RELOAD POINTER TO TRBLK{30647
{{MOV{7,XR{11,-(XS){{STACK NMBLK POINTER (1ST ARGUMENT){30648
{{MOV{13,TRTAG(XL){11,-(XS){{STACK TRACE TAG (2ND ARGUMENT){30649
{{MOV{13,TRFNC(XL){7,XL{{LOAD TRACE VRBLK POINTER{30650
{{MOV{13,VRFNC(XL){7,XL{{LOAD TRACE FUNCTION POINTER{30651
{{BEQ{7,XL{21,=STNDF{6,TRXQ2{JUMP IF NOT A DEFINED FUNCTION{30652
{{MOV{18,=NUM02{8,WA{{SET NUMBER OF ARGUMENTS TO TWO{30653
{{BRN{6,CFUNC{{{JUMP TO CALL FUNCTION{30654
*
*      SEE O$TXR FOR DETAILS OF RETURN TO THIS POINT
*
{TRXQ1{MOV{3,FLPTR{7,XS{{POINT BACK TO OUR STACK ENTRIES{30658
{{ICA{7,XS{{{POP OFF GARBAGE FAIL OFFSET{30659
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{30660
{{MOV{10,(XS)+{8,WB{{RELOAD CODE OFFSET{30661
{{MOV{10,(XS)+{8,WC{{LOAD OLD CODE BASE POINTER{30662
{{MOV{8,WC{7,XR{{COPY CDBLK POINTER{30663
{{MOV{13,CDSTM(XR){3,KVSTN{{RESTORE STMNT NO{30664
{{MOV{10,(XS)+{8,WA{{RELOAD NAME OFFSET{30665
{{MOV{10,(XS)+{7,XL{{RELOAD NAME BASE{30666
{{MOV{10,(XS)+{7,XR{{RELOAD TRBLK POINTER{30667
{{MOV{10,(XS)+{3,KVTRA{{RESTORE TRACE KEYWORD VALUE{30668
{{ADD{8,WC{8,WB{{RECOMPUTE ABSOLUTE CODE POINTER{30669
{{LCP{8,WB{{{RESTORE CODE POINTER{30670
{{MOV{8,WC{3,R$COD{{AND CODE BLOCK POINTER{30671
{{EXI{{{{RETURN TO TRXEQ CALLER{30672
*
*      HERE IF THE TARGET FUNCTION IS NOT DEFINED
*
{TRXQ2{ERB{1,197{26,TRACE fourth arg is not function name or null{{{30676
*
{{ENP{{{{END PROCEDURE TRXEQ{30678
{{EJC{{{{{30679
*
*      XSCAN -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCAN SCANS OUT ONE TOKEN IN A PROTOTYPE ARGUMENT IN
*      ARRAY,CLEAR,DATA,DEFINE,LOAD FUNCTION CALLS. XSCAN
*      CALLS MUST BE PRECEDED BY A CALL TO THE INITIALIZATION
*      PROCEDURE XSCNI. THE FOLLOWING VARIABLES ARE USED.
*
*      R$XSC                 POINTER TO SCBLK FOR FUNCTION ARG
*      XSOFS                 OFFSET (NUM CHARS SCANNED SO FAR)
*
*      (WA)                  NON-ZERO TO SKIP AND TRIM BLANKS
*      (WC)                  DELIMITER ONE (CH$XX)
*      (XL)                  DELIMITER TWO (CH$XX)
*      JSR  XSCAN            CALL TO SCAN NEXT ITEM
*      (XR)                  POINTER TO SCBLK FOR TOKEN SCANNED
*      (WA)                  COMPLETION CODE (SEE BELOW)
*      (WC,XL)               DESTROYED
*
*      THE SCAN STARTS FROM THE CURRENT POSITION AND CONTINUES
*      UNTIL ONE OF THE FOLLOWING THREE CONDITIONS OCCURS.
*
*      1)   DELIMITER ONE IS ENCOUNTERED  (WA SET TO 1)
*
*      2)   DELIMITER TWO ENCOUNTERED  (WA SET TO 2)
*
*      3)   END OF STRING ENCOUNTERED  (WA SET TO 0)
*
*      THE RESULT IS A STRING CONTAINING ALL CHARACTERS SCANNED
*      UP TO BUT NOT INCLUDING ANY DELIMITER CHARACTER.
*      THE POINTER IS LEFT POINTING PAST THE DELIMITER.
*
*      IF ONLY ONE DELIMITER IS TO BE DETECTED, DELIMITER ONE
*      AND DELIMITER TWO SHOULD BE SET TO THE SAME VALUE.
*
*      IN THE CASE WHERE THE END OF STRING IS ENCOUNTERED, THE
*      STRING INCLUDES ALL THE CHARACTERS TO THE END OF THE
*      STRING. NO FURTHER CALLS CAN BE MADE TO XSCAN UNTIL
*      XSCNI IS CALLED TO INITIALIZE A NEW ARGUMENT SCAN
{{EJC{{{{{30719
*
*      XSCAN (CONTINUED)
*
{XSCAN{PRC{25,E{1,0{{ENTRY POINT{30723
{{MOV{8,WB{3,XSCWB{{PRESERVE WB{30724
{{MOV{8,WA{11,-(XS){{RECORD BLANK SKIP FLAG{30725
{{MOV{8,WA{11,-(XS){{AND SECOND COPY{30726
{{MOV{3,R$XSC{7,XR{{POINT TO ARGUMENT STRING{30727
{{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{30728
{{MOV{3,XSOFS{8,WB{{LOAD CURRENT OFFSET{30729
{{SUB{8,WB{8,WA{{GET NUMBER OF REMAINING CHARACTERS{30730
{{BZE{8,WA{6,XSCN3{{JUMP IF NO CHARACTERS LEFT{30731
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{30732
*
*      LOOP TO SEARCH FOR DELIMITER
*
{XSCN1{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{30736
{{BEQ{8,WB{8,WC{6,XSCN4{JUMP IF DELIMITER ONE FOUND{30737
{{BEQ{8,WB{7,XL{6,XSCN5{JUMP IF DELIMITER TWO FOUND{30738
{{BZE{9,(XS){6,XSCN2{{JUMP IF NOT SKIPPING BLANKS{30739
{{ICV{3,XSOFS{{{ASSUME BLANK AND DELETE IT{30740
{{BEQ{8,WB{18,=CH$HT{6,XSCN2{JUMP IF HORIZONTAL TAB{30742
{{BEQ{8,WB{18,=CH$BL{6,XSCN2{JUMP IF BLANK{30747
{{DCV{3,XSOFS{{{UNDELETE NON-BLANK CHARACTER{30748
{{ZER{9,(XS){{{AND DISCONTINUE BLANK CHECKING{30749
*
*      HERE AFTER PERFORMING ANY LEADING BLANK TRIMMING.
*
{XSCN2{DCV{8,WA{{{DECREMENT COUNT OF CHARS LEFT{30753
{{BNZ{8,WA{6,XSCN1{{LOOP BACK IF MORE CHARS TO GO{30754
*
*      HERE FOR RUNOUT
*
{XSCN3{MOV{3,R$XSC{7,XL{{POINT TO STRING BLOCK{30758
{{MOV{13,SCLEN(XL){8,WA{{GET STRING LENGTH{30759
{{MOV{3,XSOFS{8,WB{{LOAD OFFSET{30760
{{SUB{8,WB{8,WA{{GET SUBSTRING LENGTH{30761
{{ZER{3,R$XSC{{{CLEAR STRING PTR FOR COLLECTOR{30762
{{ZER{3,XSCRT{{{SET ZERO (RUNOUT) RETURN CODE{30763
{{BRN{6,XSCN7{{{JUMP TO EXIT{30764
{{EJC{{{{{30765
*
*      XSCAN (CONTINUED)
*
*      HERE IF DELIMITER ONE FOUND
*
{XSCN4{MOV{18,=NUM01{3,XSCRT{{SET RETURN CODE{30771
{{BRN{6,XSCN6{{{JUMP TO MERGE{30772
*
*      HERE IF DELIMITER TWO FOUND
*
{XSCN5{MOV{18,=NUM02{3,XSCRT{{SET RETURN CODE{30776
*
*      MERGE HERE AFTER DETECTING A DELIMITER
*
{XSCN6{MOV{3,R$XSC{7,XL{{RELOAD POINTER TO STRING{30780
{{MOV{13,SCLEN(XL){8,WC{{GET ORIGINAL LENGTH OF STRING{30781
{{SUB{8,WA{8,WC{{MINUS CHARS LEFT = CHARS SCANNED{30782
{{MOV{8,WC{8,WA{{MOVE TO REG FOR SBSTR{30783
{{MOV{3,XSOFS{8,WB{{SET OFFSET{30784
{{SUB{8,WB{8,WA{{COMPUTE LENGTH FOR SBSTR{30785
{{ICV{8,WC{{{ADJUST NEW CURSOR PAST DELIMITER{30786
{{MOV{8,WC{3,XSOFS{{STORE NEW OFFSET{30787
*
*      COMMON EXIT POINT
*
{XSCN7{ZER{7,XR{{{CLEAR GARBAGE CHARACTER PTR IN XR{30791
{{JSR{6,SBSTR{{{BUILD SUB-STRING{30792
{{ICA{7,XS{{{REMOVE COPY OF BLANK FLAG{30793
{{MOV{10,(XS)+{8,WB{{ORIGINAL BLANK SKIP/TRIM FLAG{30794
{{BZE{13,SCLEN(XR){6,XSCN8{{CANNOT TRIM THE NULL STRING{30795
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS IF REQUESTED{30796
*
*      FINAL EXIT POINT
*
{XSCN8{MOV{3,XSCRT{8,WA{{LOAD RETURN CODE{30800
{{MOV{3,XSCWB{8,WB{{RESTORE WB{30801
{{EXI{{{{RETURN TO XSCAN CALLER{30802
{{ENP{{{{END PROCEDURE XSCAN{30803
{{EJC{{{{{30804
*
*      XSCNI -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCNI INITIALIZES THE SCAN USED FOR PROTOTYPE ARGUMENTS
*      IN THE CLEAR, DEFINE, LOAD, DATA, ARRAY FUNCTIONS. SEE
*      XSCAN FOR THE PROCEDURE WHICH IS USED AFTER THIS CALL.
*
*      -(XS)                 ARGUMENT TO BE SCANNED (ON STACK)
*      JSR  XSCNI            CALL TO SCAN ARGUMENT
*      PPM  LOC              TRANSFER LOC IF ARG IS NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARGUMENT IS NULL
*      (XS)                  POPPED
*      (XR,R$XSC)            ARGUMENT (SCBLK PTR)
*      (WA)                  ARGUMENT LENGTH
*      (IA,RA)               DESTROYED
*
{XSCNI{PRC{25,N{1,2{{ENTRY POINT{30821
{{JSR{6,GTSTG{{{FETCH ARGUMENT AS STRING{30822
{{PPM{6,XSCI1{{{JUMP IF NOT CONVERTIBLE{30823
{{MOV{7,XR{3,R$XSC{{ELSE STORE SCBLK PTR FOR XSCAN{30824
{{ZER{3,XSOFS{{{SET OFFSET TO ZERO{30825
{{BZE{8,WA{6,XSCI2{{JUMP IF NULL STRING{30826
{{EXI{{{{RETURN TO XSCNI CALLER{30827
*
*      HERE IF ARGUMENT IS NOT A STRING
*
{XSCI1{EXI{1,1{{{TAKE NOT-STRING ERROR EXIT{30831
*
*      HERE FOR NULL STRING
*
{XSCI2{EXI{1,2{{{TAKE NULL-STRING ERROR EXIT{30835
{{ENP{{{{END PROCEDURE XSCNI{30836
{{TTL{27,S P I T B O L -- STACK OVERFLOW SECTION{{{{30837
*
*      CONTROL COMES HERE IF THE MAIN STACK OVERFLOWS
*
{{SEC{{{{START OF STACK OVERFLOW SECTION{30841
*
{{ADD{18,=NUM04{3,ERRFT{{FORCE CONCLUSIVE FATAL ERROR{30843
{{MOV{3,FLPTR{7,XS{{POP STACK TO AVOID MORE FAILS{30844
{{BNZ{3,GBCFL{6,STAK1{{JUMP IF GARBAGE COLLECTING{30845
{{ERB{1,246{26,Stack overflow{{{30846
*
*      NO CHANCE OF RECOVERY IN MID GARBAGE COLLECTION
*
{STAK1{MOV{21,=ENDSO{7,XR{{POINT TO MESSAGE{30850
{{ZER{3,KVDMP{{{MEMORY IS UNDUMPABLE{30851
{{BRN{6,STOPR{{{GIVE UP{30852
{{TTL{27,S P I T B O L -- ERROR SECTION{{{{30853
*
*      THIS SECTION OF CODE IS ENTERED WHENEVER A PROCEDURE
*      RETURN VIA AN ERR PARAMETER OR AN ERB OPCODE IS OBEYED.
*
*      (WA)                  IS THE ERROR CODE
*
*      THE GLOBAL VARIABLE STAGE INDICATES THE POINT AT WHICH
*      THE ERROR OCCURED AS FOLLOWS.
*
*      STAGE=STGIC           ERROR DURING INITIAL COMPILE
*
*      STAGE=STGXC           ERROR DURING COMPILE AT EXECUTE
*                            TIME (CODE, CONVERT FUNCTION CALLS)
*
*      STAGE=STGEV           ERROR DURING COMPILATION OF
*                            EXPRESSION AT EXECUTION TIME
*                            (EVAL, CONVERT FUNCTION CALL).
*
*      STAGE=STGXT           ERROR AT EXECUTE TIME. COMPILER
*                            NOT ACTIVE.
*
*      STAGE=STGCE           ERROR DURING INITIAL COMPILE AFTER
*                            SCANNING OUT THE END LINE.
*
*      STAGE=STGXE           ERROR DURING COMPILE AT EXECUTE
*                            TIME AFTER SCANNING END LINE.
*
*      STAGE=STGEE           ERROR DURING EXPRESSION EVALUATION
*
{{SEC{{{{START OF ERROR SECTION{30883
*
{ERROR{BEQ{3,R$CIM{20,=CMLAB{6,CMPLE{JUMP IF ERROR IN SCANNING LABEL{30885
{{MOV{8,WA{3,KVERT{{SAVE ERROR CODE{30886
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH FOR SCANE{30887
{{ZER{3,SCNGO{{{RESET GOTO SWITCH FOR SCANE{30888
{{MOV{18,=NUM01{3,POLCS{{RESET POLL COUNT{30890
{{MOV{18,=NUM01{3,POLCT{{RESET POLL COUNT{30891
{{MOV{3,STAGE{7,XR{{LOAD CURRENT STAGE{30893
{{BSW{7,XR{2,STGNO{{JUMP TO APPROPRIATE ERROR CIRCUIT{30894
{{IFF{2,STGIC{6,ERR01{{INITIAL COMPILE{30902
{{IFF{2,STGXC{6,ERR04{{EXECUTE TIME COMPILE{30902
{{IFF{2,STGEV{6,ERR04{{EVAL COMPILING EXPR.{30902
{{IFF{2,STGXT{6,ERR05{{EXECUTE TIME{30902
{{IFF{2,STGCE{6,ERR01{{COMPILE - AFTER END{30902
{{IFF{2,STGXE{6,ERR04{{XEQ COMPILE-PAST END{30902
{{IFF{2,STGEE{6,ERR04{{EVAL EVALUATING EXPR{30902
{{ESW{{{{END SWITCH ON ERROR TYPE{30902
{{EJC{{{{{30903
*
*      ERROR DURING INITIAL COMPILE
*
*      THE ERROR MESSAGE IS PRINTED AS PART OF THE COMPILER
*      OUTPUT. THIS PRINTOUT INCLUDES THE OFFENDING LINE (IF NOT
*      PRINTED ALREADY) AND AN ERROR FLAG UNDER THE APPROPRIATE
*      COLUMN AS INDICATED BY SCNSE UNLESS SCNSE IS SET TO ZERO.
*
*      AFTER PRINTING THE MESSAGE, THE GENERATED CODE IS
*      MODIFIED TO AN ERROR CALL AND CONTROL IS RETURNED TO
*      THE CMPIL PROCEDURE AFTER RESETTING THE STACK POINTER.
*
*      IF THE ERROR OCCURS AFTER THE END LINE, CONTROL RETURNS
*      IN A SLIGHTLY DIFFERENT MANNER TO ENSURE PROPER CLEANUP.
*
{ERR01{MOV{3,CMPXS{7,XS{{RESET STACK POINTER{30919
{{SSL{3,CMPSS{{{RESTORE S-R STACK PTR FOR CMPIL{30920
{{BNZ{3,ERRSP{6,ERR03{{JUMP IF ERROR SUPPRESS FLAG SET{30921
{{MOV{3,CMPSN{8,WC{{CURRENT STATEMENT{30924
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{30925
{{MOV{3,SCNSE{8,WB{{COLUMN NUMBER{30927
{{MOV{3,RDCLN{8,WC{{LINE NUMBER{30928
{{MOV{3,STAGE{7,XR{{{30929
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{30930
{{PPM{6,ERRA3{{{IF SYSTEM DOES NOT WANT PRINT{30931
{{MOV{7,XR{11,-(XS){{SAVE ANY PROVIDED PRINT MESSAGE{30932
{{MOV{3,ERICH{3,ERLST{{SET FLAG FOR LISTR{30934
{{JSR{6,LISTR{{{LIST LINE{30935
{{JSR{6,PRTIS{{{TERMINATE LISTING{30936
{{ZER{3,ERLST{{{CLEAR LISTR FLAG{30937
{{MOV{3,SCNSE{8,WA{{LOAD SCAN ELEMENT OFFSET{30938
{{BZE{8,WA{6,ERR02{{SKIP IF NOT SET{30939
{{LCT{8,WB{8,WA{{LOOP COUNTER{30941
{{ICV{8,WA{{{INCREASE FOR CH$EX{30942
{{MOV{3,R$CIM{7,XL{{POINT TO BAD STATEMENT{30943
{{JSR{6,ALOCS{{{STRING BLOCK FOR ERROR FLAG{30944
{{MOV{7,XR{8,WA{{REMEMBER STRING PTR{30945
{{PSC{7,XR{{{READY FOR CHARACTER STORING{30946
{{PLC{7,XL{{{READY TO GET CHARS{30947
*
*      LOOP TO REPLACE ALL CHARS BUT TABS BY BLANKS
*
{ERRA1{LCH{8,WC{10,(XL)+{{GET NEXT CHAR{30951
{{BEQ{8,WC{18,=CH$HT{6,ERRA2{SKIP IF TAB{30952
{{MOV{18,=CH$BL{8,WC{{GET A BLANK{30953
{{EJC{{{{{30954
*
*      MERGE TO STORE BLANK OR TAB IN ERROR LINE
*
{ERRA2{SCH{8,WC{10,(XR)+{{STORE CHAR{30958
{{BCT{8,WB{6,ERRA1{{LOOP{30959
{{MOV{18,=CH$EX{7,XL{{EXCLAMATION MARK{30960
{{SCH{7,XL{9,(XR){{STORE AT END OF ERROR LINE{30961
{{CSC{7,XR{{{END OF SCH LOOP{30962
{{MOV{18,=STNPD{3,PROFS{{ALLOW FOR STATEMENT NUMBER{30963
{{MOV{8,WA{7,XR{{POINT TO ERROR LINE{30964
{{JSR{6,PRTST{{{PRINT ERROR LINE{30965
*
*      HERE AFTER PLACING ERROR FLAG AS REQUIRED
*
{ERR02{JSR{6,PRTIS{{{PRINT BLANK LINE{30979
{{MOV{10,(XS)+{7,XR{{RESTORE ANY SYSEA MESSAGE{30981
{{BZE{7,XR{6,ERRA0{{DID SYSEA PROVIDE MESSAGE TO PRINT{30982
{{JSR{6,PRTST{{{PRINT SYSEA MESSAGE{30983
{ERRA0{JSR{6,ERMSG{{{GENERATE FLAG AND ERROR MESSAGE{30985
{{ADD{18,=NUM03{3,LSTLC{{BUMP PAGE CTR FOR BLANK, ERROR, BLK{30986
{ERRA3{ZER{7,XR{{{IN CASE OF FATAL ERROR{30987
{{BHI{3,ERRFT{18,=NUM03{6,STOPR{PACK UP IF SEVERAL FATALS{30988
*
*      COUNT ERROR, INHIBIT EXECUTION IF REQUIRED
*
{{ICV{3,CMERC{{{BUMP ERROR COUNT{30992
{{ADD{3,CSWER{3,NOXEQ{{INHIBIT XEQ IF -NOERRORS{30993
{{BNE{3,STAGE{18,=STGIC{6,CMP10{SPECIAL RETURN IF AFTER END LINE{30994
{{EJC{{{{{30995
*
*      LOOP TO SCAN TO END OF STATEMENT
*
{ERR03{MOV{3,R$CIM{7,XR{{POINT TO START OF IMAGE{30999
{{PLC{7,XR{{{POINT TO FIRST CHAR{31000
{{LCH{7,XR{9,(XR){{GET FIRST CHAR{31001
{{BEQ{7,XR{18,=CH$MN{6,CMPCE{JUMP IF ERROR IN CONTROL CARD{31002
{{ZER{3,SCNRS{{{CLEAR RESCAN FLAG{31003
{{MNZ{3,ERRSP{{{SET ERROR SUPPRESS FLAG{31004
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{31005
{{BNE{7,XL{18,=T$SMC{6,ERR03{LOOP BACK IF NOT STATEMENT END{31006
{{ZER{3,ERRSP{{{CLEAR ERROR SUPPRESS FLAG{31007
*
*      GENERATE ERROR CALL IN CODE AND RETURN TO CMPIL
*
{{MOV{19,*CDCOD{3,CWCOF{{RESET OFFSET IN CCBLK{31011
{{MOV{21,=OCER${8,WA{{LOAD COMPILE ERROR CALL{31012
{{JSR{6,CDWRD{{{GENERATE IT{31013
{{MOV{3,CWCOF{13,CMSOC(XS){{SET SUCCESS FILL IN OFFSET{31014
{{MNZ{13,CMFFC(XS){{{SET FAILURE FILL IN FLAG{31015
{{JSR{6,CDWRD{{{GENERATE SUCC. FILL IN WORD{31016
{{BRN{6,CMPSE{{{MERGE TO GENERATE ERROR AS CDFAL{31017
*
*      ERROR DURING EXECUTE TIME COMPILE OR EXPRESSION EVALUATIO
*
*      EXECUTE TIME COMPILATION IS INITIATED THROUGH GTCOD OR
*      GTEXP WHICH ARE CALLED BY COMPILE, CODE OR EVAL.
*      BEFORE CAUSING STATEMENT FAILURE THROUGH EXFAL IT IS
*      HELPFUL TO SET KEYWORD ERRTEXT AND FOR GENERALITY
*      THESE ERRORS MAY BE HANDLED BY THE SETEXIT MECHANISM.
*
{ERR04{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{31027
{{BEQ{3,KVERT{18,=NM320{6,ERR06{TREAT USER INTERRUPT SPECIALLY{31029
{{ZER{3,R$CCB{{{FORGET GARBAGE CODE BLOCK{31031
{{MOV{19,*CCCOD{3,CWCOF{{SET INITIAL OFFSET (MBE CATSPAW){31032
{{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{31033
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{31034
{{DCA{7,XS{{{ENSURE STACK OK ON LOOP START{31035
*
*      POP STACK UNTIL FIND FLPTR FOR MOST DEEPLY NESTED PROG.
*      DEFINED FUNCTION CALL OR CALL OF EVAL / CODE.
*
{ERRA4{ICA{7,XS{{{POP STACK{31040
{{BEQ{7,XS{3,FLPRT{6,ERRC4{JUMP IF PROG DEFINED FN CALL FOUND{31041
{{BNE{7,XS{3,GTCEF{6,ERRA4{LOOP IF NOT EVAL OR CODE CALL YET{31042
{{MOV{18,=STGXT{3,STAGE{{RE-SET STAGE FOR EXECUTE{31043
{{MOV{3,R$GTC{3,R$COD{{RECOVER CODE PTR{31044
{{MOV{7,XS{3,FLPTR{{RESTORE FAIL POINTER{31045
{{ZER{3,R$CIM{{{FORGET POSSIBLE IMAGE{31046
{{ZER{3,CNIND{{{FORGET POSSIBLE INCLUDE{31048
*
*      TEST ERRLIMIT
*
{ERRB4{BNZ{3,KVERL{6,ERR07{{JUMP IF ERRLIMIT NON-ZERO{31053
{{BRN{6,EXFAL{{{FAIL{31054
*
*      RETURN FROM PROG. DEFINED FUNCTION IS OUTSTANDING
*
{ERRC4{MOV{3,FLPTR{7,XS{{RESTORE STACK FROM FLPTR{31058
{{BRN{6,ERRB4{{{MERGE{31059
{{EJC{{{{{31060
*
*      ERROR AT EXECUTE TIME.
*
*      THE ACTION TAKEN ON AN ERROR IS AS FOLLOWS.
*
*      IF ERRLIMIT KEYWORD IS ZERO, AN ABORT IS SIGNALLED,
*      SEE CODING FOR SYSTEM LABEL ABORT AT L$ABO.
*
*      OTHERWISE, ERRLIMIT IS DECREMENTED AND AN ERRTYPE TRACE
*      GENERATED IF REQUIRED. CONTROL RETURNS EITHER VIA A JUMP
*      TO CONTINUE (TO TAKE THE FAILURE EXIT) OR A SPECIFIED
*      SETEXIT TRAP IS EXECUTED AND CONTROL PASSES TO THE TRAP.
*      IF 3 OR MORE FATAL ERRORS OCCUR AN ABORT IS SIGNALLED
*      REGARDLESS OF ERRLIMIT AND SETEXIT - LOOPING IS ALL TOO
*      PROBABLE OTHERWISE. FATAL ERRORS INCLUDE STACK OVERFLOW
*      AND EXCEEDING STLIMIT.
*
{ERR05{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{31078
{{BNZ{3,DMVCH{6,ERR08{{JUMP IF IN MID-DUMP{31079
*
*      MERGE HERE FROM ERR08 AND ERR04 (ERROR 320)
*
{ERR06{BZE{3,KVERL{6,LABO1{{ABORT IF ERRLIMIT IS ZERO{31083
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{31084
*
*      MERGE FROM ERR04
*
{ERR07{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{31088
{{DCV{3,KVERL{{{DECREMENT ERRLIMIT{31089
{{MOV{3,R$ERT{7,XL{{LOAD ERRTYPE TRACE POINTER{31090
{{JSR{6,KTREX{{{GENERATE ERRTYPE TRACE IF REQUIRED{31091
{{MOV{3,R$COD{8,WA{{GET CURRENT CODE BLOCK{31092
{{MOV{8,WA{3,R$CNT{{SET CDBLK PTR FOR CONTINUATION{31093
{{SCP{8,WB{{{CURRENT CODE POINTER{31094
{{SUB{8,WA{8,WB{{OFFSET WITHIN CODE BLOCK{31095
{{MOV{8,WB{3,STXOC{{SAVE CODE PTR OFFSET FOR SCONTINUE{31096
{{MOV{3,FLPTR{7,XR{{SET PTR TO FAILURE OFFSET{31097
{{MOV{9,(XR){3,STXOF{{SAVE FAILURE OFFSET FOR CONTINUE{31098
{{MOV{3,R$SXC{7,XR{{LOAD SETEXIT CDBLK POINTER{31099
{{BZE{7,XR{6,LCNT1{{CONTINUE IF NO SETEXIT TRAP{31100
{{ZER{3,R$SXC{{{ELSE RESET TRAP{31101
{{MOV{21,=NULLS{3,STXVR{{RESET SETEXIT ARG TO NULL{31102
{{MOV{9,(XR){7,XL{{LOAD PTR TO CODE BLOCK ROUTINE{31103
{{BRI{7,XL{{{EXECUTE FIRST TRAP STATEMENT{31104
*
*      INTERRUPTED PARTLY THROUGH A DUMP WHILST STORE IS IN A
*      MESS SO DO A TIDY UP OPERATION. SEE DUMPR FOR DETAILS.
*
{ERR08{MOV{3,DMVCH{7,XR{{CHAIN HEAD FOR AFFECTED VRBLKS{31109
{{BZE{7,XR{6,ERR06{{DONE IF ZERO{31110
{{MOV{9,(XR){3,DMVCH{{SET NEXT LINK AS CHAIN HEAD{31111
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{31112
*
*      LABEL TO MARK END OF CODE
*
{S$YYY{BRN{6,ERR08{{{LOOP THROUGH CHAIN{31116
{{TTL{27,S P I T B O L -- HERE ENDETH THE CODE{{{{31117
*
*      END OF ASSEMBLY
*
{{END{{{{END MACRO-SPITBOL ASSEMBLY{31121
