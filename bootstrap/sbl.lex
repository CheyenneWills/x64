||ttl|27,l i c e n s e -- software license for this program||||1
||ttl|27,s p i t b o l -- notes to implementors||||21
||ttl|27,s p i t b o l - revision history||||57
||ejc|||||58
||ejc|||||634
||ejc|||||690
||ejc|||||697
||ejc|||||751
||ejc|||||781
||ejc|||||811
||ejc|||||852
||ejc|||||904
||ejc|||||954
||ejc|||||1011
||ejc|||||1018
||ejc|||||1069
||ejc|||||1104
||ejc|||||1161
||ttl|27,minimal -- machine independent macro assembly lang.||||1188
||ejc|||||1189
||ttl|27,s p i t b o l  -- basic information||||1190
||ejc|||||1191
||ejc|||||1246
||ejc|||||1293
||ejc|||||1332
||ejc|||||1385
||ejc|||||1419
||ejc|||||1482
||ejc|||||1523
||ttl|27,s p i t b o l -- procedures section||||1694
||sec||||start of procedures section|1732
||ejc|||||1734
|sysax|exp|1,0|||define external entry point|1738
||ejc|||||1750
|sysbs|exp|1,3|||define external entry point|1755
||ejc|||||1775
|sysbx|exp|1,0|||define external entry point|1780
||ejc|||||1789
|sysdc|exp|1,0|||define external entry point|1883
||ejc|||||1890
|sysdm|exp|1,0|||define external entry point|1894
||ejc|||||1904
|sysdt|exp|1,0|||define external entry point|1908
||ejc|||||1924
|sysea|exp|1,1|||define external entry point|1928
||ejc|||||1950
|sysef|exp|1,3|||define external entry point|1954
||ejc|||||1967
|sysej|exp|1,0|||define external entry point|1971
||ejc|||||1991
|sysem|exp|1,0|||define external entry point|1995
||ejc|||||2012
|sysen|exp|1,3|||define external entry point|2016
||ejc|||||2038
|sysep|exp|1,0|||define external entry point|2042
||ejc|||||2048
|sysex|exp|1,3|||define external entry point|2052
||ejc|||||2097
|sysfc|exp|1,2|||define external entry point|2101
||ejc|||||2147
||ejc|||||2202
|sysgc|exp|1,0|||define external entry point|2206
||ejc|||||2230
|syshs|exp|1,8|||define external entry point|2234
||ejc|||||2273
|sysid|exp|1,0|||define external entry point|2277
||ejc|||||2302
|sysif|exp|1,1|||define external entry point|2307
||ejc|||||2340
|sysil|exp|1,0|||define external entry point|2345
||ejc|||||2364
|sysin|exp|1,3|||define external entry point|2368
||ejc|||||2387
|sysio|exp|1,2|||define external entry point|2391
||ejc|||||2426
|sysld|exp|1,3|||define external entry point|2430
||ejc|||||2449
|sysmm|exp|1,0|||define external entry point|2453
||ejc|||||2465
|sysmx|exp|1,0|||define external entry point|2469
||ejc|||||2495
|sysou|exp|1,2|||define external entry point|2499
||ejc|||||2521
|syspi|exp|1,1|||define external entry point|2525
||ejc|||||2541
|syspl|exp|1,3|||define external entry point|2545
||ejc|||||2568
|syspp|exp|1,0|||define external entry point|2572
||ejc|||||2634
|syspr|exp|1,1|||define external entry point|2638
||ejc|||||2664
|sysrd|exp|1,1|||define external entry point|2668
||ejc|||||2700
|sysri|exp|1,1|||define external entry point|2704
||ejc|||||2723
|sysrw|exp|1,3|||define external entry point|2727
||ejc|||||2740
|systm|exp|1,0|||define external entry point|2767
||ejc|||||2781
|systt|exp|1,0|||define external entry point|2785
||ejc|||||2792
|sysul|exp|1,0|||define external entry point|2796
||ejc|||||2812
|sysxi|exp|1,2|||define external entry point|2816
||ejc|||||2872
||ejc|||||2912
|acess|inp|25,r|1,1|||2916
|acomp|inp|25,n|1,5|||2917
|alloc|inp|25,e|1,0|||2918
|alocs|inp|25,e|1,0|||2923
|alost|inp|25,e|1,0|||2924
|arith|inp|25,n|1,3|||2932
|asign|inp|25,r|1,1|||2934
|asinp|inp|25,r|1,1|||2935
|blkln|inp|25,e|1,0|||2936
|cdgcg|inp|25,e|1,0|||2937
|cdgex|inp|25,r|1,0|||2938
|cdgnm|inp|25,r|1,0|||2939
|cdgvl|inp|25,r|1,0|||2940
|cdwrd|inp|25,e|1,0|||2941
|cmgen|inp|25,r|1,0|||2942
|cmpil|inp|25,e|1,0|||2943
|cncrd|inp|25,e|1,0|||2944
|copyb|inp|25,n|1,1|||2945
|dffnc|inp|25,e|1,0|||2946
|dtach|inp|25,e|1,0|||2947
|dtype|inp|25,e|1,0|||2948
|dumpr|inp|25,e|1,0|||2949
|ermsg|inp|25,e|1,0|||2954
|ertex|inp|25,e|1,0|||2955
|evali|inp|25,r|1,4|||2956
|evalp|inp|25,r|1,1|||2957
|evals|inp|25,r|1,3|||2958
|evalx|inp|25,r|1,1|||2959
|exbld|inp|25,e|1,0|||2960
|expan|inp|25,e|1,0|||2961
|expap|inp|25,e|1,1|||2962
|expdm|inp|25,n|1,0|||2963
|expop|inp|25,n|1,0|||2964
|filnm|inp|25,e|1,0|||2966
|flstg|inp|25,e|1,0|||2969
|gbcol|inp|25,e|1,0|||2971
|gbcpf|inp|25,e|1,0|||2972
|gtarr|inp|25,e|1,2|||2973
||ejc|||||2974
|gtcod|inp|25,e|1,1|||2975
|gtexp|inp|25,e|1,1|||2976
|gtint|inp|25,e|1,1|||2977
|gtnum|inp|25,e|1,1|||2978
|gtnvr|inp|25,e|1,1|||2979
|gtpat|inp|25,e|1,1|||2980
|gtrea|inp|25,e|1,1|||2983
|gtsmi|inp|25,n|1,2|||2985
|gtstg|inp|25,n|1,1|||2990
|gtvar|inp|25,e|1,1|||2991
|hashs|inp|25,e|1,0|||2992
|icbld|inp|25,e|1,0|||2993
|ident|inp|25,e|1,1|||2994
|inout|inp|25,e|1,0|||2995
|insta|inp|25,e|1,0|||3000
|iofcb|inp|25,n|1,3|||3001
|ioppf|inp|25,n|1,0|||3002
|ioput|inp|25,n|1,7|||3003
|ktrex|inp|25,r|1,0|||3004
|kwnam|inp|25,n|1,0|||3005
|lcomp|inp|25,n|1,5|||3006
|listr|inp|25,e|1,0|||3007
|listt|inp|25,e|1,0|||3008
|newfn|inp|25,e|1,0|||3010
|nexts|inp|25,e|1,0|||3012
|patin|inp|25,n|1,2|||3013
|patst|inp|25,n|1,1|||3014
|pbild|inp|25,e|1,0|||3015
|pconc|inp|25,e|1,0|||3016
|pcopy|inp|25,n|1,0|||3017
|prflr|inp|25,e|1,0|||3020
|prflu|inp|25,e|1,0|||3021
|prpar|inp|25,e|1,0|||3023
|prtch|inp|25,e|1,0|||3024
|prtic|inp|25,e|1,0|||3025
|prtis|inp|25,e|1,0|||3026
|prtin|inp|25,e|1,0|||3027
|prtmi|inp|25,e|1,0|||3028
|prtmm|inp|25,e|1,0|||3029
|prtmx|inp|25,e|1,0|||3030
|prtnl|inp|25,r|1,0|||3031
|prtnm|inp|25,r|1,0|||3032
|prtnv|inp|25,e|1,0|||3033
|prtpg|inp|25,e|1,0|||3034
|prtps|inp|25,e|1,0|||3035
|prtsn|inp|25,e|1,0|||3036
|prtst|inp|25,r|1,0|||3037
||ejc|||||3038
|prttr|inp|25,e|1,0|||3039
|prtvl|inp|25,r|1,0|||3040
|prtvn|inp|25,e|1,0|||3041
|rcbld|inp|25,e|1,0|||3044
|readr|inp|25,e|1,0|||3046
|relaj|inp|25,e|1,0|||3048
|relcr|inp|25,e|1,0|||3049
|reldn|inp|25,e|1,0|||3050
|reloc|inp|25,e|1,0|||3051
|relst|inp|25,e|1,0|||3052
|relws|inp|25,e|1,0|||3053
|rstrt|inp|25,e|1,0|||3055
|sbstr|inp|25,e|1,0|||3059
|scane|inp|25,e|1,0|||3060
|scngf|inp|25,e|1,0|||3061
|setvr|inp|25,e|1,0|||3062
|sorta|inp|25,n|1,1|||3065
|sortc|inp|25,e|1,1|||3066
|sortf|inp|25,e|1,0|||3067
|sorth|inp|25,n|1,0|||3068
|start|inp|25,e|1,0|||3070
|stgcc|inp|25,e|1,0|||3071
|tfind|inp|25,e|1,1|||3072
|tmake|inp|25,e|1,0|||3073
|trace|inp|25,n|1,2|||3074
|trbld|inp|25,e|1,0|||3075
|trimr|inp|25,e|1,0|||3076
|trxeq|inp|25,r|1,0|||3077
|vmake|inp|25,e|1,1|||3078
|xscan|inp|25,e|1,0|||3079
|xscni|inp|25,n|1,2|||3080
|arref|inr|||||3084
|cfunc|inr|||||3085
|exfal|inr|||||3086
|exint|inr|||||3087
|exits|inr|||||3088
|exixr|inr|||||3089
|exnam|inr|||||3090
|exnul|inr|||||3091
|exrea|inr|||||3094
|exsid|inr|||||3096
|exvnm|inr|||||3097
|failp|inr|||||3098
|flpop|inr|||||3099
|indir|inr|||||3100
|match|inr|||||3101
|retrn|inr|||||3102
|stcov|inr|||||3103
|stmgo|inr|||||3104
|stopr|inr|||||3105
|succp|inr|||||3106
|sysab|inr|||||3107
|systu|inr|||||3108
||ttl|27,s p i t b o l -- definitions and data structures||||3109
||sec||||start of definitions section|3113
|cfp_a|equ|24,256|||number of characters in alphabet|3126
|cfp_b|equ|24,8|||bytes/word addressing factor|3128
|cfp_c|equ|24,8|||number of characters per word|3130
|cfp_f|equ|24,16|||offset in bytes to chars in|3132
|cfp_i|equ|24,1|||number of words in integer constant|3135
|cfp_m|equ|24,9223372036854775807|||max positive integer in one word|3137
|cfp_n|equ|24,64|||number of bits in one word|3139
|cfp_r|equ|24,1|||number of words in real constant|3149
|cfp_s|equ|24,9|||number of sig digs for real output|3151
|cfp_x|equ|24,3|||max digits in real exponent|3153
|mxdgs|equ|24,cfp_s+cfp_x|||max digits in real number|3164
|nstmx|equ|24,mxdgs+5|||max space for real|3169
|cfp_u|equ|24,128|||realistic upper bound on alphabet|3179
||ejc|||||3181
|e_srs|equ|24,100|||30 words|3198
|e_sts|equ|24,1000|||500 words|3205
|e_cbs|equ|24,500|||500 words|3213
|e_hnb|equ|24,257|||127 bucket headers|3220
|e_hnw|equ|24,3|||6 words|3227
|e_fsp|equ|24,15|||15 percent|3237
|e_sed|equ|24,25|||25 percent|3245
||ejc|||||3247
|ch_la|equ|24,97|||letter a|3251
|ch_lb|equ|24,98|||letter b|3252
|ch_lc|equ|24,99|||letter c|3253
|ch_ld|equ|24,100|||letter d|3254
|ch_le|equ|24,101|||letter e|3255
|ch_lf|equ|24,102|||letter f|3256
|ch_lg|equ|24,103|||letter g|3257
|ch_lh|equ|24,104|||letter h|3258
|ch_li|equ|24,105|||letter i|3259
|ch_lj|equ|24,106|||letter j|3260
|ch_lk|equ|24,107|||letter k|3261
|ch_ll|equ|24,108|||letter l|3262
|ch_lm|equ|24,109|||letter m|3263
|ch_ln|equ|24,110|||letter n|3264
|ch_lo|equ|24,111|||letter o|3265
|ch_lp|equ|24,112|||letter p|3266
|ch_lq|equ|24,113|||letter q|3267
|ch_lr|equ|24,114|||letter r|3268
|ch_ls|equ|24,115|||letter s|3269
|ch_lt|equ|24,116|||letter t|3270
|ch_lu|equ|24,117|||letter u|3271
|ch_lv|equ|24,118|||letter v|3272
|ch_lw|equ|24,119|||letter w|3273
|ch_lx|equ|24,120|||letter x|3274
|ch_ly|equ|24,121|||letter y|3275
|ch_l_|equ|24,122|||letter z|3276
|ch_d0|equ|24,48|||digit 0|3280
|ch_d1|equ|24,49|||digit 1|3281
|ch_d2|equ|24,50|||digit 2|3282
|ch_d3|equ|24,51|||digit 3|3283
|ch_d4|equ|24,52|||digit 4|3284
|ch_d5|equ|24,53|||digit 5|3285
|ch_d6|equ|24,54|||digit 6|3286
|ch_d7|equ|24,55|||digit 7|3287
|ch_d8|equ|24,56|||digit 8|3288
|ch_d9|equ|24,57|||digit 9|3289
||ejc|||||3290
|ch_am|equ|24,38|||keyword operator (ampersand)|3298
|ch_as|equ|24,42|||multiplication symbol (asterisk)|3299
|ch_at|equ|24,64|||cursor position operator (at)|3300
|ch_bb|equ|24,60|||left array bracket (less than)|3301
|ch_bl|equ|24,32|||blank|3302
|ch_br|equ|24,124|||alternation operator (vertical bar)|3303
|ch_cl|equ|24,58|||goto symbol (colon)|3304
|ch_cm|equ|24,44|||comma|3305
|ch_dl|equ|24,36|||indirection operator (dollar)|3306
|ch_dt|equ|24,46|||name operator (dot)|3307
|ch_dq|equ|24,34|||double quote|3308
|ch_eq|equ|24,61|||equal sign|3309
|ch_ex|equ|24,33|||exponentiation operator (exclm)|3310
|ch_mn|equ|24,45|||minus sign / hyphen|3311
|ch_nm|equ|24,35|||number sign|3312
|ch_nt|equ|24,126|||negation operator (not)|3313
|ch_pc|equ|24,94|||percent|3314
|ch_pl|equ|24,43|||plus sign|3315
|ch_pp|equ|24,40|||left parenthesis|3316
|ch_rb|equ|24,62|||right array bracket (grtr than)|3317
|ch_rp|equ|24,41|||right parenthesis|3318
|ch_qu|equ|24,63|||interrogation operator (question)|3319
|ch_sl|equ|24,47|||slash|3320
|ch_sm|equ|24,59|||semicolon|3321
|ch_sq|equ|24,39|||single quote|3322
|ch_u_|equ|24,95|||special identifier char (underline)|3323
|ch_ob|equ|24,91|||opening bracket|3324
|ch_cb|equ|24,93|||closing bracket|3325
||ejc|||||3326
|ch_ht|equ|24,9|||horizontal tab|3333
|ch_ua|equ|24,65|||shifted a|3348
|ch_ub|equ|24,66|||shifted b|3349
|ch_uc|equ|24,67|||shifted c|3350
|ch_ud|equ|24,68|||shifted d|3351
|ch_ue|equ|24,69|||shifted e|3352
|ch_uf|equ|24,70|||shifted f|3353
|ch_ug|equ|24,71|||shifted g|3354
|ch_uh|equ|24,72|||shifted h|3355
|ch_ui|equ|24,73|||shifted i|3356
|ch_uj|equ|24,74|||shifted j|3357
|ch_uk|equ|24,75|||shifted k|3358
|ch_ul|equ|24,76|||shifted l|3359
|ch_um|equ|24,77|||shifted m|3360
|ch_un|equ|24,78|||shifted n|3361
|ch_uo|equ|24,79|||shifted o|3362
|ch_up|equ|24,80|||shifted p|3363
|ch_uq|equ|24,81|||shifted q|3364
|ch_ur|equ|24,82|||shifted r|3365
|ch_us|equ|24,83|||shifted s|3366
|ch_ut|equ|24,84|||shifted t|3367
|ch_uu|equ|24,85|||shifted u|3368
|ch_uv|equ|24,86|||shifted v|3369
|ch_uw|equ|24,87|||shifted w|3370
|ch_ux|equ|24,88|||shifted x|3371
|ch_uy|equ|24,89|||shifted y|3372
|ch_uz|equ|24,90|||shifted z|3373
|iodel|equ|24,32||||3380
||ejc|||||3384
||ejc|||||3415
|offs1|equ|24,1||||3443
|offs2|equ|24,2||||3444
|offs3|equ|24,3||||3445
||ejc|||||3451
|bl_ar|equ|24,0|||arblk     array|3472
|bl_cd|equ|24,bl_ar+1|||cdblk     code|3473
|bl_ex|equ|24,bl_cd+1|||exblk     expression|3474
|bl_ic|equ|24,bl_ex+1|||icblk     integer|3475
|bl_nm|equ|24,bl_ic+1|||nmblk     name|3476
|bl_p0|equ|24,bl_nm+1|||p0blk     pattern|3477
|bl_p1|equ|24,bl_p0+1|||p1blk     pattern|3478
|bl_p2|equ|24,bl_p1+1|||p2blk     pattern|3479
|bl_rc|equ|24,bl_p2+1|||rcblk     real|3480
|bl_sc|equ|24,bl_rc+1|||scblk     string|3481
|bl_se|equ|24,bl_sc+1|||seblk     expression|3482
|bl_tb|equ|24,bl_se+1|||tbblk     table|3483
|bl_vc|equ|24,bl_tb+1|||vcblk     array|3484
|bl_xn|equ|24,bl_vc+1|||xnblk     external|3485
|bl_xr|equ|24,bl_xn+1|||xrblk     external|3486
|bl_bc|equ|24,bl_xr+1|||bcblk     buffer|3487
|bl_pd|equ|24,bl_bc+1|||pdblk     program defined datatype|3488
|bl__d|equ|24,bl_pd+1|||number of block codes for data|3490
|bl_tr|equ|24,bl_pd+1|||trblk|3494
|bl_bf|equ|24,bl_tr+1|||bfblk|3495
|bl_cc|equ|24,bl_bf+1|||ccblk|3496
|bl_cm|equ|24,bl_cc+1|||cmblk|3497
|bl_ct|equ|24,bl_cm+1|||ctblk|3498
|bl_df|equ|24,bl_ct+1|||dfblk|3499
|bl_ef|equ|24,bl_df+1|||efblk|3500
|bl_ev|equ|24,bl_ef+1|||evblk|3501
|bl_ff|equ|24,bl_ev+1|||ffblk|3502
|bl_kv|equ|24,bl_ff+1|||kvblk|3503
|bl_pf|equ|24,bl_kv+1|||pfblk|3504
|bl_te|equ|24,bl_pf+1|||teblk|3505
|bl__i|equ|24,0|||default identification code|3507
|bl__t|equ|24,bl_tr+1|||code for data or trace block|3508
|bl___|equ|24,bl_te+1|||number of block codes|3509
||ejc|||||3510
||ejc|||||3548
|fcode|equ|24,0|||pointer to code for function|3565
|fargs|equ|24,1|||number of arguments|3566
||ejc|||||3584
|idval|equ|24,1|||id value field|3596
||ejc|||||3611
||ejc|||||3645
|artyp|equ|24,0|||pointer to dummy routine b_art|3649
|arlen|equ|24,idval+1|||length of arblk in bytes|3650
|arofs|equ|24,arlen+1|||offset in arblk to arpro field|3651
|arndm|equ|24,arofs+1|||number of dimensions|3652
|arlbd|equ|24,arndm+1|||low bound (first subscript)|3653
|ardim|equ|24,arlbd+cfp_i|||dimension (first subscript)|3654
|arlb2|equ|24,ardim+cfp_i|||low bound (second subscript)|3655
|ardm2|equ|24,arlb2+cfp_i|||dimension (second subscript)|3656
|arpro|equ|24,ardim+cfp_i|||array prototype (one dimension)|3657
|arvls|equ|24,arpro+1|||start of values (one dimension)|3658
|arpr2|equ|24,ardm2+cfp_i|||array prototype (two dimensions)|3659
|arvl2|equ|24,arpr2+1|||start of values (two dimensions)|3660
|arsi_|equ|24,arlbd|||number of standard fields in block|3661
|ardms|equ|24,arlb2-arlbd|||size of info for one set of bounds|3662
||ejc|||||3748
|cctyp|equ|24,0|||pointer to dummy routine b_cct|3771
|cclen|equ|24,cctyp+1|||length of ccblk in bytes|3772
|ccsln|equ|24,cclen+1|||source line number|3774
|ccuse|equ|24,ccsln+1|||offset past last used word (bytes)|3775
|cccod|equ|24,ccuse+1|||start of generated code in block|3779
||ejc|||||3784
|cdjmp|equ|24,0|||ptr to routine to execute statement|3809
|cdstm|equ|24,cdjmp+1|||statement number|3810
|cdsln|equ|24,cdstm+1|||source line number|3812
|cdlen|equ|24,cdsln+1|||length of cdblk in bytes|3813
|cdfal|equ|24,cdlen+1|||failure exit (see below)|3814
|cdcod|equ|24,cdfal+1|||executable pseudo-code|3819
|cdsi_|equ|24,cdcod|||number of standard fields in cdblk|3820
||ejc|||||3845
||ejc|||||3899
||ejc|||||3946
||ejc|||||3993
||ejc|||||4032
||ejc|||||4080
||ejc|||||4131
|cmidn|equ|24,0|||pointer to dummy routine b_cmt|4153
|cmlen|equ|24,cmidn+1|||length of cmblk in bytes|4154
|cmtyp|equ|24,cmlen+1|||type (c_xxx, see list below)|4155
|cmopn|equ|24,cmtyp+1|||operand pointer (see below)|4156
|cmvls|equ|24,cmopn+1|||operand value pointers (see below)|4157
|cmrop|equ|24,cmvls|||right (only) operator operand|4158
|cmlop|equ|24,cmvls+1|||left operator operand|4159
|cmsi_|equ|24,cmvls|||number of standard fields in cmblk|4160
|cmus_|equ|24,cmsi_+1|||size of unary operator cmblk|4161
|cmbs_|equ|24,cmsi_+2|||size of binary operator cmblk|4162
|cmar1|equ|24,cmvls+1|||array subscript pointers|4163
||ejc|||||4182
|c_arr|equ|24,0|||array reference|4187
|c_fnc|equ|24,c_arr+1|||function call|4188
|c_def|equ|24,c_fnc+1|||deferred expression (unary *)|4189
|c_ind|equ|24,c_def+1|||indirection (unary _)|4190
|c_key|equ|24,c_ind+1|||keyword reference (unary ampersand)|4191
|c_ubo|equ|24,c_key+1|||undefined binary operator|4192
|c_uuo|equ|24,c_ubo+1|||undefined unary operator|4193
|c_uo_|equ|24,c_uuo+1|||test value (=c_uuo+1=c_ubo+2)|4194
|c__nm|equ|24,c_uuo+1|||number of codes for name operands|4195
|c_bvl|equ|24,c_uuo+1|||binary op with value operands|4200
|c_uvl|equ|24,c_bvl+1|||unary operator with value operand|4201
|c_alt|equ|24,c_uvl+1|||alternation (binary bar)|4202
|c_cnc|equ|24,c_alt+1|||concatenation|4203
|c_cnp|equ|24,c_cnc+1|||concatenation, not pattern match|4204
|c_unm|equ|24,c_cnp+1|||unary op with name operand|4205
|c_bvn|equ|24,c_unm+1|||binary op (operands by value, name)|4206
|c_ass|equ|24,c_bvn+1|||assignment|4207
|c_int|equ|24,c_ass+1|||interrogation|4208
|c_neg|equ|24,c_int+1|||negation (unary not)|4209
|c_sel|equ|24,c_neg+1|||selection|4210
|c_pmt|equ|24,c_sel+1|||pattern match|4211
|c_pr_|equ|24,c_bvn|||last preevaluable code|4213
|c__nv|equ|24,c_pmt+1|||number of different cmblk types|4214
||ejc|||||4215
|cttyp|equ|24,0|||pointer to dummy routine b_ctt|4236
|ctchs|equ|24,cttyp+1|||start of character table words|4237
|ctsi_|equ|24,ctchs+cfp_a|||number of words in ctblk|4238
||ejc|||||4246
|dflen|equ|24,fargs+1|||length of dfblk in bytes|4278
|dfpdl|equ|24,dflen+1|||length of corresponding pdblk|4279
|dfnam|equ|24,dfpdl+1|||pointer to scblk for datatype name|4280
|dffld|equ|24,dfnam+1|||start of vrblk ptrs for field names|4281
|dfflb|equ|24,dffld-1|||offset behind dffld for field func|4282
|dfsi_|equ|24,dffld|||number of standard fields in dfblk|4283
||ejc|||||4288
|dvopn|equ|24,0|||entry address (ptr to o_xxx)|4305
|dvtyp|equ|24,dvopn+1|||type code (c_xxx, see cmblk)|4306
|dvlpr|equ|24,dvtyp+1|||left precedence (llxxx, see below)|4307
|dvrpr|equ|24,dvlpr+1|||right precedence (rrxxx, see below)|4308
|dvus_|equ|24,dvlpr+1|||size of unary operator dv|4309
|dvbs_|equ|24,dvrpr+1|||size of binary operator dv|4310
|dvubs|equ|24,dvus_+dvbs_|||size of unop + binop (see scane)|4311
||ejc|||||4341
|rrass|equ|24,10|||right     equal|4345
|llass|equ|24,00|||left      equal|4346
|rrpmt|equ|24,20|||right     question mark|4347
|llpmt|equ|24,30|||left      question mark|4348
|rramp|equ|24,40|||right     ampersand|4349
|llamp|equ|24,50|||left      ampersand|4350
|rralt|equ|24,70|||right     vertical bar|4351
|llalt|equ|24,60|||left      vertical bar|4352
|rrcnc|equ|24,90|||right     blank|4353
|llcnc|equ|24,80|||left      blank|4354
|rrats|equ|24,110|||right     at|4355
|llats|equ|24,100|||left      at|4356
|rrplm|equ|24,120|||right     plus, minus|4357
|llplm|equ|24,130|||left      plus, minus|4358
|rrnum|equ|24,140|||right     number|4359
|llnum|equ|24,150|||left      number|4360
|rrdvd|equ|24,160|||right     slash|4361
|lldvd|equ|24,170|||left      slash|4362
|rrmlt|equ|24,180|||right     asterisk|4363
|llmlt|equ|24,190|||left      asterisk|4364
|rrpct|equ|24,200|||right     percent|4365
|llpct|equ|24,210|||left      percent|4366
|rrexp|equ|24,230|||right     exclamation|4367
|llexp|equ|24,220|||left      exclamation|4368
|rrdld|equ|24,240|||right     dollar, dot|4369
|lldld|equ|24,250|||left      dollar, dot|4370
|rrnot|equ|24,270|||right     not|4371
|llnot|equ|24,260|||left      not|4372
|lluno|equ|24,999|||left      all unary operators|4373
||ejc|||||4389
|eflen|equ|24,fargs+1|||length of efblk in bytes|4416
|efuse|equ|24,eflen+1|||use count (for opsyn)|4417
|efcod|equ|24,efuse+1|||ptr to code (from sysld)|4418
|efvar|equ|24,efcod+1|||ptr to associated vrblk|4419
|efrsl|equ|24,efvar+1|||result type (see below)|4420
|eftar|equ|24,efrsl+1|||argument types (see below)|4421
|efsi_|equ|24,eftar|||number of standard fields in efblk|4422
||ejc|||||4445
|evtyp|equ|24,0|||pointer to dummy routine b_evt|4464
|evexp|equ|24,evtyp+1|||pointer to exblk for expression|4465
|evvar|equ|24,evexp+1|||pointer to trbev dummy trblk|4466
|evsi_|equ|24,evvar+1|||size of evblk|4467
||ejc|||||4476
|extyp|equ|24,0|||ptr to routine b_exl to load expr|4502
|exstm|equ|24,cdstm|||stores stmnt no. during evaluation|4503
|exsln|equ|24,exstm+1|||stores line no. during evaluation|4505
|exlen|equ|24,exsln+1|||length of exblk in bytes|4506
|exflc|equ|24,exlen+1|||failure code (=o_fex)|4510
|excod|equ|24,exflc+1|||pseudo-code for expression|4511
|exsi_|equ|24,excod|||number of standard fields in exblk|4512
||ejc|||||4527
|ffdfp|equ|24,fargs+1|||pointer to associated dfblk|4547
|ffnxt|equ|24,ffdfp+1|||ptr to next ffblk on chain or zero|4548
|ffofs|equ|24,ffnxt+1|||offset (bytes) to field in pdblk|4549
|ffsi_|equ|24,ffofs+1|||size of ffblk in words|4550
||ejc|||||4566
|icget|equ|24,0|||ptr to routine b_icl to load int|4581
|icval|equ|24,icget+1|||integer value|4582
|icsi_|equ|24,icval+cfp_i|||size of icblk|4583
||ejc|||||4586
|kvtyp|equ|24,0|||pointer to dummy routine b_kvt|4601
|kvvar|equ|24,kvtyp+1|||pointer to dummy block trbkv|4602
|kvnum|equ|24,kvvar+1|||keyword number|4603
|kvsi_|equ|24,kvnum+1|||size of kvblk|4604
||ejc|||||4609
|nmtyp|equ|24,0|||ptr to routine b_nml to load name|4624
|nmbas|equ|24,nmtyp+1|||base pointer for variable|4625
|nmofs|equ|24,nmbas+1|||offset for variable|4626
|nmsi_|equ|24,nmofs+1|||size of nmblk|4627
||ejc|||||4639
|pcode|equ|24,0|||ptr to match routine (p_xxx)|4652
|pthen|equ|24,pcode+1|||pointer to subsequent node|4653
|pasi_|equ|24,pthen+1|||size of p0blk|4654
||ejc|||||4661
|parm1|equ|24,pthen+1|||first parameter value|4676
|pbsi_|equ|24,parm1+1|||size of p1blk in words|4677
||ejc|||||4687
|parm2|equ|24,parm1+1|||second parameter value|4704
|pcsi_|equ|24,parm2+1|||size of p2blk in words|4705
||ejc|||||4715
|pdtyp|equ|24,0|||ptr to dummy routine b_pdt|4734
|pddfp|equ|24,idval+1|||ptr to associated dfblk|4735
|pdfld|equ|24,pddfp+1|||start of field value pointers|4736
|pdfof|equ|24,dffld-pdfld|||difference in offset to field ptrs|4737
|pdsi_|equ|24,pdfld|||size of standard fields in pdblk|4738
|pddfs|equ|24,dfsi_-pdsi_|||difference in dfblk, pdblk sizes|4739
||ejc|||||4748
|pflen|equ|24,fargs+1|||length of pfblk in bytes|4777
|pfvbl|equ|24,pflen+1|||pointer to vrblk for function name|4778
|pfnlo|equ|24,pfvbl+1|||number of locals|4779
|pfcod|equ|24,pfnlo+1|||ptr to vrblk for entry label|4780
|pfctr|equ|24,pfcod+1|||trblk ptr if call traced else 0|4781
|pfrtr|equ|24,pfctr+1|||trblk ptr if return traced else 0|4782
|pfarg|equ|24,pfrtr+1|||vrblk ptrs for arguments and locals|4783
|pfagb|equ|24,pfarg-1|||offset behind pfarg for arg, local|4784
|pfsi_|equ|24,pfarg|||number of standard fields in pfblk|4785
||ejc|||||4795
|rcget|equ|24,0|||ptr to routine b_rcl to load real|4808
|rcval|equ|24,rcget+1|||real value|4809
|rcsi_|equ|24,rcval+cfp_r|||size of rcblk|4810
||ejc|||||4814
|scget|equ|24,0|||ptr to routine b_scl to load string|4831
|sclen|equ|24,scget+1|||length of string in characters|4832
|schar|equ|24,sclen+1|||characters of string|4833
|scsi_|equ|24,schar|||size of standard fields in scblk|4834
||ejc|||||4849
|setyp|equ|24,0|||ptr to routine b_sel to load expr|4862
|sevar|equ|24,setyp+1|||ptr to vrblk for variable|4863
|sesi_|equ|24,sevar+1|||length of seblk in words|4864
||ejc|||||4865
||ejc|||||4898
|svbit|equ|24,0|||bit string indicating attributes|4902
|svlen|equ|24,1|||(=sclen) length of name in chars|4903
|svchs|equ|24,2|||(=schar) characters of name|4904
|svsi_|equ|24,2|||number of standard fields in svblk|4905
|svpre|equ|24,1|||set if preevaluation permitted|4906
|svffc|equ|24,svpre+svpre|||set on if fast call permitted|4907
|svckw|equ|24,svffc+svffc|||set on if keyword value constant|4908
|svprd|equ|24,svckw+svckw|||set on if predicate function|4909
|svnbt|equ|24,4|||number of bits to right of svknm|4910
|svknm|equ|24,svprd+svprd|||set on if keyword association|4911
|svfnc|equ|24,svknm+svknm|||set on if system function|4912
|svnar|equ|24,svfnc+svfnc|||set on if system function|4913
|svlbl|equ|24,svnar+svnar|||set on if system label|4914
|svval|equ|24,svlbl+svlbl|||set on if predefined value|4915
|svfnf|equ|24,svfnc+svnar|||function with no fast call|4922
|svfnn|equ|24,svfnf+svffc|||function with fast call, no preeval|4923
|svfnp|equ|24,svfnn+svpre|||function allowing preevaluation|4924
|svfpr|equ|24,svfnn+svprd|||predicate function|4925
|svfnk|equ|24,svfnn+svknm|||no preeval func + keyword|4926
|svkwv|equ|24,svknm+svval|||keyword + value|4927
|svkwc|equ|24,svckw+svknm|||keyword with constant value|4928
|svkvc|equ|24,svkwv+svckw|||constant keyword + value|4929
|svkvl|equ|24,svkvc+svlbl|||constant keyword + value + label|4930
|svfpk|equ|24,svfnp+svkvc|||preeval fcn + const keywd + val|4931
||ejc|||||4948
||ejc|||||4996
|k_abe|equ|24,0|||abend|5009
|k_anc|equ|24,k_abe+cfp_b|||anchor|5010
|k_cas|equ|24,k_anc+cfp_b|||case|5012
|k_cod|equ|24,k_cas+cfp_b|||code|5013
|k_com|equ|24,k_cod+cfp_b|||compare|5018
|k_dmp|equ|24,k_com+cfp_b|||dump|5019
|k_erl|equ|24,k_dmp+cfp_b|||errlimit|5023
|k_ert|equ|24,k_erl+cfp_b|||errtype|5024
|k_ftr|equ|24,k_ert+cfp_b|||ftrace|5025
|k_fls|equ|24,k_ftr+cfp_b|||fullscan|5026
|k_inp|equ|24,k_fls+cfp_b|||input|5027
|k_mxl|equ|24,k_inp+cfp_b|||maxlength|5028
|k_oup|equ|24,k_mxl+cfp_b|||output|5029
|k_pfl|equ|24,k_oup+cfp_b|||profile|5033
|k_tra|equ|24,k_pfl+cfp_b|||trace|5034
|k_trm|equ|24,k_tra+cfp_b|||trim|5036
|k_fnc|equ|24,k_trm+cfp_b|||fnclevel|5040
|k_lst|equ|24,k_fnc+cfp_b|||lastno|5041
|k_lln|equ|24,k_lst+cfp_b|||lastline|5043
|k_lin|equ|24,k_lln+cfp_b|||line|5044
|k_stn|equ|24,k_lin+cfp_b|||stno|5045
|k_abo|equ|24,k_stn+cfp_b|||abort|5052
|k_arb|equ|24,k_abo+pasi_|||arb|5053
|k_bal|equ|24,k_arb+pasi_|||bal|5054
|k_fal|equ|24,k_bal+pasi_|||fail|5055
|k_fen|equ|24,k_fal+pasi_|||fence|5056
|k_rem|equ|24,k_fen+pasi_|||rem|5057
|k_suc|equ|24,k_rem+pasi_|||succeed|5058
||ejc|||||5059
|k_alp|equ|24,k_suc+1|||alphabet|5065
|k_rtn|equ|24,k_alp+1|||rtntype|5066
|k_stc|equ|24,k_rtn+1|||stcount|5067
|k_etx|equ|24,k_stc+1|||errtext|5068
|k_fil|equ|24,k_etx+1|||file|5070
|k_lfl|equ|24,k_fil+1|||lastfile|5071
|k_stl|equ|24,k_lfl+1|||stlimit|5072
|k_lcs|equ|24,k_stl+1|||lcase|5077
|k_ucs|equ|24,k_lcs+1|||ucase|5078
|k__al|equ|24,k_alp-k_alp|||alphabet|5083
|k__rt|equ|24,k_rtn-k_alp|||rtntype|5084
|k__sc|equ|24,k_stc-k_alp|||stcount|5085
|k__et|equ|24,k_etx-k_alp|||errtext|5086
|k__fl|equ|24,k_fil-k_alp|||file|5088
|k__lf|equ|24,k_lfl-k_alp|||lastfile|5089
|k__sl|equ|24,k_stl-k_alp|||stlimit|5091
|k__lc|equ|24,k_lcs-k_alp|||lcase|5093
|k__uc|equ|24,k_ucs-k_alp|||ucase|5094
|k__n_|equ|24,k__uc+1|||number of special cases|5095
|k_p__|equ|24,k_fnc|||first protected keyword|5102
|k_v__|equ|24,k_abo|||first keyword with constant value|5103
|k_s__|equ|24,k_alp|||first keyword with special acess|5104
||ejc|||||5105
|tbtyp|equ|24,0|||pointer to dummy routine b_tbt|5126
|tblen|equ|24,offs2|||length of tbblk in bytes|5127
|tbinv|equ|24,offs3|||default initial lookup value|5128
|tbbuk|equ|24,tbinv+1|||start of hash bucket pointers|5129
|tbsi_|equ|24,tbbuk|||size of standard fields in tbblk|5130
|tbnbk|equ|24,11|||default no. of buckets|5131
||ejc|||||5140
|tetyp|equ|24,0|||pointer to dummy routine b_tet|5157
|tesub|equ|24,tetyp+1|||subscript value|5158
|teval|equ|24,tesub+1|||(=vrval) table element value|5159
|tenxt|equ|24,teval+1|||link to next teblk|5160
|tesi_|equ|24,tenxt+1|||size of teblk in words|5162
||ejc|||||5171
|tridn|equ|24,0|||pointer to dummy routine b_trt|5191
|trtyp|equ|24,tridn+1|||trap type code|5192
|trval|equ|24,trtyp+1|||value of trapped variable (=vrval)|5193
|trnxt|equ|24,trval|||ptr to next trblk on trblk chain|5194
|trlbl|equ|24,trval|||ptr to actual label (traced label)|5195
|trkvr|equ|24,trval|||vrblk pointer for keyword trace|5196
|trtag|equ|24,trval+1|||trace tag|5197
|trter|equ|24,trtag|||ptr to terminal vrblk or null|5198
|trtrf|equ|24,trtag|||ptr to trblk holding fcblk ptr|5199
|trfnc|equ|24,trtag+1|||trace function vrblk (zero if none)|5200
|trfpt|equ|24,trfnc|||fcblk ptr for sysio|5201
|trsi_|equ|24,trfnc+1|||number of words in trblk|5202
|trtin|equ|24,0|||trace type for input association|5204
|trtac|equ|24,trtin+1|||trace type for access trace|5205
|trtvl|equ|24,trtac+1|||trace type for value trace|5206
|trtou|equ|24,trtvl+1|||trace type for output association|5207
|trtfc|equ|24,trtou+1|||trace type for fcblk identification|5208
||ejc|||||5209
||ejc|||||5251
||ejc|||||5299
||ejc|||||5349
|vctyp|equ|24,0|||pointer to dummy routine b_vct|5368
|vclen|equ|24,offs2|||length of vcblk in bytes|5369
|vcvls|equ|24,offs3|||start of vector values|5370
|vcsi_|equ|24,vcvls|||size of standard fields in vcblk|5371
|vcvlb|equ|24,vcvls-1|||offset one word behind vcvls|5372
|vctbd|equ|24,tbsi_-vcsi_|||difference in sizes - see prtvl|5373
||ejc|||||5378
||ejc|||||5421
|vrget|equ|24,0|||pointer to routine to load value|5425
|vrsto|equ|24,vrget+1|||pointer to routine to store value|5426
|vrval|equ|24,vrsto+1|||variable value|5427
|vrvlo|equ|24,vrval-vrsto|||offset to value from store field|5428
|vrtra|equ|24,vrval+1|||pointer to routine to jump to label|5429
|vrlbl|equ|24,vrtra+1|||pointer to code for label|5430
|vrlbo|equ|24,vrlbl-vrtra|||offset to label from transfer field|5431
|vrfnc|equ|24,vrlbl+1|||pointer to function block|5432
|vrnxt|equ|24,vrfnc+1|||pointer to next vrblk on hash chain|5433
|vrlen|equ|24,vrnxt+1|||length of name (or zero)|5434
|vrchs|equ|24,vrlen+1|||characters of name (vrlen gt 0)|5435
|vrsvp|equ|24,vrlen+1|||ptr to svblk (vrlen eq 0)|5436
|vrsi_|equ|24,vrchs+1|||number of standard fields in vrblk|5437
|vrsof|equ|24,vrlen-sclen|||offset to dummy scblk for name|5438
|vrsvo|equ|24,vrsvp-vrsof|||pseudo-offset to vrsvp field|5439
||ejc|||||5475
|xntyp|equ|24,0|||pointer to dummy routine b_xnt|5497
|xnlen|equ|24,xntyp+1|||length of xnblk in bytes|5498
|xndta|equ|24,xnlen+1|||data words|5499
|xnsi_|equ|24,xndta|||size of standard fields in xnblk|5500
||ejc|||||5505
|xrtyp|equ|24,0|||pointer to dummy routine b_xrt|5527
|xrlen|equ|24,xrtyp+1|||length of xrblk in bytes|5528
|xrptr|equ|24,xrlen+1|||start of address pointers|5529
|xrsi_|equ|24,xrptr|||size of standard fields in xrblk|5530
||ejc|||||5531
|cnvst|equ|24,8|||max standard type code for convert|5537
|cnvrt|equ|24,cnvst+1|||convert code for reals|5541
|cnvbt|equ|24,cnvrt|||no buffers - same as real code|5544
|cnvtt|equ|24,cnvbt+1|||bsw code for convert|5548
|iniln|equ|24,1024|||default image length for compiler|5552
|inils|equ|24,1024|||image length if -sequ in effect|5553
|ionmb|equ|24,2|||name base used for iochn in sysio|5555
|ionmo|equ|24,4|||name offset used for iochn in sysio|5556
|mnlen|equ|24,1024|||min value allowed keyword maxlngth|5561
|mxern|equ|24,329|||err num inadequate startup memory|5562
|num01|equ|24,1||||5568
|num02|equ|24,2||||5569
|num03|equ|24,3||||5570
|num04|equ|24,4||||5571
|num05|equ|24,5||||5572
|num06|equ|24,6||||5573
|num07|equ|24,7||||5574
|num08|equ|24,8||||5575
|num09|equ|24,9||||5576
|num10|equ|24,10||||5577
|num25|equ|24,25||||5578
|nm320|equ|24,320||||5579
|nm321|equ|24,321||||5580
|nini8|equ|24,998||||5581
|nini9|equ|24,999||||5582
|thsnd|equ|24,1000||||5583
||ejc|||||5584
|opbun|equ|24,5|||no. of binary undefined ops|5588
|opuun|equ|24,6|||no of unary undefined ops|5589
|prsnf|equ|24,13|||offset used in prtsn|5593
|prtmf|equ|24,21|||offset to col 21 (prtmi)|5594
|rilen|equ|24,1024|||buffer length for sysri|5595
|stgic|equ|24,0|||initial compile|5599
|stgxc|equ|24,stgic+1|||execution compile (code)|5600
|stgev|equ|24,stgxc+1|||expression eval during execution|5601
|stgxt|equ|24,stgev+1|||execution time|5602
|stgce|equ|24,stgxt+1|||initial compile after end line|5603
|stgxe|equ|24,stgce+1|||exec. compile after end line|5604
|stgnd|equ|24,stgce-stgic|||difference in stage after end|5605
|stgee|equ|24,stgxe+1|||eval evaluating expression|5606
|stgno|equ|24,stgee+1|||number of codes|5607
||ejc|||||5608
|stnpd|equ|24,8|||statement no. pad count|5613
|t_uop|equ|24,0|||unary operator|5621
|t_lpr|equ|24,t_uop+3|||left paren|5622
|t_lbr|equ|24,t_lpr+3|||left bracket|5623
|t_cma|equ|24,t_lbr+3|||comma|5624
|t_fnc|equ|24,t_cma+3|||function call|5625
|t_var|equ|24,t_fnc+3|||variable|5626
|t_con|equ|24,t_var+3|||constant|5627
|t_bop|equ|24,t_con+3|||binary operator|5628
|t_rpr|equ|24,t_bop+3|||right paren|5629
|t_rbr|equ|24,t_rpr+3|||right bracket|5630
|t_col|equ|24,t_rbr+3|||colon|5631
|t_smc|equ|24,t_col+3|||semi-colon|5632
|t_fgo|equ|24,t_smc+1|||failure goto|5636
|t_sgo|equ|24,t_fgo+1|||success goto|5637
|t_uok|equ|24,t_fnc|||last code ok before unary operator|5643
||ejc|||||5644
|t_uo0|equ|24,t_uop+0|||unary operator, state zero|5648
|t_uo1|equ|24,t_uop+1|||unary operator, state one|5649
|t_uo2|equ|24,t_uop+2|||unary operator, state two|5650
|t_lp0|equ|24,t_lpr+0|||left paren, state zero|5651
|t_lp1|equ|24,t_lpr+1|||left paren, state one|5652
|t_lp2|equ|24,t_lpr+2|||left paren, state two|5653
|t_lb0|equ|24,t_lbr+0|||left bracket, state zero|5654
|t_lb1|equ|24,t_lbr+1|||left bracket, state one|5655
|t_lb2|equ|24,t_lbr+2|||left bracket, state two|5656
|t_cm0|equ|24,t_cma+0|||comma, state zero|5657
|t_cm1|equ|24,t_cma+1|||comma, state one|5658
|t_cm2|equ|24,t_cma+2|||comma, state two|5659
|t_fn0|equ|24,t_fnc+0|||function call, state zero|5660
|t_fn1|equ|24,t_fnc+1|||function call, state one|5661
|t_fn2|equ|24,t_fnc+2|||function call, state two|5662
|t_va0|equ|24,t_var+0|||variable, state zero|5663
|t_va1|equ|24,t_var+1|||variable, state one|5664
|t_va2|equ|24,t_var+2|||variable, state two|5665
|t_co0|equ|24,t_con+0|||constant, state zero|5666
|t_co1|equ|24,t_con+1|||constant, state one|5667
|t_co2|equ|24,t_con+2|||constant, state two|5668
|t_bo0|equ|24,t_bop+0|||binary operator, state zero|5669
|t_bo1|equ|24,t_bop+1|||binary operator, state one|5670
|t_bo2|equ|24,t_bop+2|||binary operator, state two|5671
|t_rp0|equ|24,t_rpr+0|||right paren, state zero|5672
|t_rp1|equ|24,t_rpr+1|||right paren, state one|5673
|t_rp2|equ|24,t_rpr+2|||right paren, state two|5674
|t_rb0|equ|24,t_rbr+0|||right bracket, state zero|5675
|t_rb1|equ|24,t_rbr+1|||right bracket, state one|5676
|t_rb2|equ|24,t_rbr+2|||right bracket, state two|5677
|t_cl0|equ|24,t_col+0|||colon, state zero|5678
|t_cl1|equ|24,t_col+1|||colon, state one|5679
|t_cl2|equ|24,t_col+2|||colon, state two|5680
|t_sm0|equ|24,t_smc+0|||semicolon, state zero|5681
|t_sm1|equ|24,t_smc+1|||semicolon, state one|5682
|t_sm2|equ|24,t_smc+2|||semicolon, state two|5683
|t_nes|equ|24,t_sm2+1|||number of entries in branch table|5685
||ejc|||||5686
|cc_ca|equ|24,0|||-case|5691
|cc_do|equ|24,cc_ca+1|||-double|5692
|cc_co|equ|24,cc_do+1|||-compare|5697
|cc_du|equ|24,cc_co+1|||-dump|5698
|cc_cp|equ|24,cc_du+1|||-copy|5703
|cc_ej|equ|24,cc_cp+1|||-eject|5704
|cc_er|equ|24,cc_ej+1|||-errors|5708
|cc_ex|equ|24,cc_er+1|||-execute|5709
|cc_fa|equ|24,cc_ex+1|||-fail|5710
|cc_in|equ|24,cc_fa+1|||-include|5712
|cc_ln|equ|24,cc_in+1|||-line|5714
|cc_li|equ|24,cc_ln+1|||-list|5715
|cc_nr|equ|24,cc_li+1|||-noerrors|5727
|cc_nx|equ|24,cc_nr+1|||-noexecute|5728
|cc_nf|equ|24,cc_nx+1|||-nofail|5729
|cc_nl|equ|24,cc_nf+1|||-nolist|5730
|cc_no|equ|24,cc_nl+1|||-noopt|5731
|cc_np|equ|24,cc_no+1|||-noprint|5732
|cc_op|equ|24,cc_np+1|||-optimise|5733
|cc_pr|equ|24,cc_op+1|||-print|5734
|cc_si|equ|24,cc_pr+1|||-single|5735
|cc_sp|equ|24,cc_si+1|||-space|5736
|cc_st|equ|24,cc_sp+1|||-stitl|5737
|cc_ti|equ|24,cc_st+1|||-title|5738
|cc_tr|equ|24,cc_ti+1|||-trace|5739
|cc_nc|equ|24,cc_tr+1|||number of control cards|5740
|ccnoc|equ|24,4|||no. of chars included in match|5741
|ccofs|equ|24,7|||offset to start of title/subtitle|5742
|ccinm|equ|24,9|||max depth of include file nesting|5744
||ejc|||||5746
|cmstm|equ|24,0|||tree for statement body|5753
|cmsgo|equ|24,cmstm+1|||tree for success goto|5754
|cmfgo|equ|24,cmsgo+1|||tree for fail goto|5755
|cmcgo|equ|24,cmfgo+1|||conditional goto flag|5756
|cmpcd|equ|24,cmcgo+1|||previous cdblk pointer|5757
|cmffp|equ|24,cmpcd+1|||failure fill in flag for previous|5758
|cmffc|equ|24,cmffp+1|||failure fill in flag for current|5759
|cmsop|equ|24,cmffc+1|||success fill in offset for previous|5760
|cmsoc|equ|24,cmsop+1|||success fill in offset for current|5761
|cmlbl|equ|24,cmsoc+1|||ptr to vrblk for current label|5762
|cmtra|equ|24,cmlbl+1|||ptr to entry cdblk|5763
|cmnen|equ|24,cmtra+1|||count of stack entries for cmpil|5765
|pfpd1|equ|24,8|||pad positions ...|5770
|pfpd2|equ|24,20|||... for profile ...|5771
|pfpd3|equ|24,32|||... printout|5772
|pf_i2|equ|24,cfp_i+cfp_i|||size of table entry (2 ints)|5773
||ejc|||||5776
|rlend|equ|24,0|||end|5816
|rladj|equ|24,rlend+1|||adjustment|5817
|rlstr|equ|24,rladj+1|||start|5818
|rssi_|equ|24,rlstr+1|||size of section|5819
|rnsi_|equ|24,5|||number of structures|5820
|rldye|equ|24,0|||dynamic region end|5824
|rldya|equ|24,rldye+1|||dynamic region adjustment|5825
|rldys|equ|24,rldya+1|||dynamic region start|5826
|rlste|equ|24,rldys+1|||static region end|5827
|rlsta|equ|24,rlste+1|||static region adjustment|5828
|rlsts|equ|24,rlsta+1|||static region start|5829
|rlwke|equ|24,rlsts+1|||working section globals end|5830
|rlwka|equ|24,rlwke+1|||working section globals adjustment|5831
|rlwks|equ|24,rlwka+1|||working section globals start|5832
|rlcne|equ|24,rlwks+1|||constants section end|5833
|rlcna|equ|24,rlcne+1|||constants section adjustment|5834
|rlcns|equ|24,rlcna+1|||constants section start|5835
|rlcde|equ|24,rlcns+1|||code section end|5836
|rlcda|equ|24,rlcde+1|||code section adjustment|5837
|rlcds|equ|24,rlcda+1|||code section start|5838
|rlsi_|equ|24,rlcds+1|||number of fields in structure|5839
||ttl|27,s p i t b o l -- constant section||||5842
||sec||||start of constant section|5855
|c_aaa|dac|1,0|||first location of constant section|5859
|alfsp|dac|2,e_fsp|||free store percentage|5863
|bits0|dbc|1,0|||all zero bits|5867
|bits1|dbc|1,1|||one bit in low order position|5868
|bits2|dbc|1,2|||bit in position 2|5869
|bits3|dbc|1,4|||bit in position 3|5870
|bits4|dbc|1,8|||bit in position 4|5871
|bits5|dbc|1,16|||bit in position 5|5872
|bits6|dbc|1,32|||bit in position 6|5873
|bits7|dbc|1,64|||bit in position 7|5874
|bits8|dbc|1,128|||bit in position 8|5875
|bits9|dbc|1,256|||bit in position 9|5876
|bit10|dbc|1,512|||bit in position 10|5877
|bit11|dbc|1,1024|||bit in position 11|5878
|bit12|dbc|1,2048|||bit in position 12|5879
|bitsm|dbc|1,0|||mask for max integer (value filled in at runtime)|5881
|btfnc|dbc|2,svfnc|||bit to test for function|5885
|btknm|dbc|2,svknm|||bit to test for keyword number|5886
|btlbl|dbc|2,svlbl|||bit to test for label|5887
|btffc|dbc|2,svffc|||bit to test for fast call|5888
|btckw|dbc|2,svckw|||bit to test for constant keyword|5889
|btkwv|dbc|2,svkwv|||bits to test for keword with value|5890
|btprd|dbc|2,svprd|||bit to test for predicate function|5891
|btpre|dbc|2,svpre|||bit to test for preevaluation|5892
|btval|dbc|2,svval|||bit to test for value|5893
||ejc|||||5894
|ccnms|dtc|27,/case/||||5899
||dtc|27,/doub/||||5900
||dtc|27,/comp/||||5905
||dtc|27,/dump/||||5907
||dtc|27,/copy/||||5909
||dtc|27,/ejec/||||5911
||dtc|27,/erro/||||5912
||dtc|27,/exec/||||5913
||dtc|27,/fail/||||5914
||dtc|27,/incl/||||5916
||dtc|27,/line/||||5919
||dtc|27,/list/||||5921
||dtc|27,/noer/||||5922
||dtc|27,/noex/||||5923
||dtc|27,/nofa/||||5924
||dtc|27,/noli/||||5925
||dtc|27,/noop/||||5926
||dtc|27,/nopr/||||5927
||dtc|27,/opti/||||5928
||dtc|27,/prin/||||5929
||dtc|27,/sing/||||5930
||dtc|27,/spac/||||5931
||dtc|27,/stit/||||5932
||dtc|27,/titl/||||5933
||dtc|27,/trac/||||5934
|dmhdk|dac|6,b_scl|||dump of keyword values|5938
||dac|1,22||||5939
||dtc|27,/dump of keyword values/||||5940
|dmhdv|dac|6,b_scl|||dump of natural variables|5942
||dac|1,25||||5943
||dtc|27,/dump of natural variables/||||5944
||ejc|||||5945
|encm1|dac|6,b_scl||||5949
||dac|1,19||||5951
||dtc|27,/memory used (bytes)/||||5952
|encm2|dac|6,b_scl||||5954
||dac|1,19||||5955
||dtc|27,/memory left (bytes)/||||5956
|encm3|dac|6,b_scl||||5966
||dac|1,11||||5967
||dtc|27,/comp errors/||||5968
|encm4|dac|6,b_scl||||5970
||dac|1,20||||5975
||dtc|27,/comp time (microsec)/||||5976
|encm5|dac|6,b_scl|||execution suppressed|5979
||dac|1,20||||5980
||dtc|27,/execution suppressed/||||5981
|endab|dac|6,b_scl||||5985
||dac|1,12||||5986
||dtc|27,/abnormal end/||||5987
||ejc|||||5988
|endmo|dac|6,b_scl||||5992
|endml|dac|1,15||||5993
||dtc|27,/memory overflow/||||5994
|endms|dac|6,b_scl||||5998
||dac|1,10||||5999
||dtc|27,/normal end/||||6000
|endso|dac|6,b_scl|||stack overflow in garbage collector|6004
||dac|1,36||||6005
||dtc|27,/stack overflow in garbage collection/||||6006
|endtu|dac|6,b_scl||||6010
||dac|1,15||||6011
||dtc|27,/error - time up/||||6012
||ejc|||||6013
|ermms|dac|6,b_scl|||error|6017
||dac|1,5||||6018
||dtc|27,/error/||||6019
|ermns|dac|6,b_scl|||string / -- /|6021
||dac|1,4||||6022
||dtc|27,/ -- /||||6023
|lstms|dac|6,b_scl|||page|6027
||dac|1,5||||6028
||dtc|27,/page /||||6029
|headr|dac|6,b_scl||||6033
||dac|1,26||||6034
||dtc|27,/macro spitbol version 4.0a/||||6035
|headv|dac|6,b_scl|||for exit() version no. check|6037
||dac|1,5||||6038
||dtc|27,/15.01/||||6039
|gbsdp|dac|2,e_sed|||sediment percentage|6043
|int_r|dac|6,b_icl||||6049
|intv0|dic|16,+0|||0|6050
|inton|dac|6,b_icl||||6051
|intv1|dic|16,+1|||1|6052
|inttw|dac|6,b_icl||||6053
|intv2|dic|16,+2|||2|6054
|intvt|dic|16,+10|||10|6055
|intvh|dic|16,+100|||100|6056
|intth|dic|16,+1000|||1000|6057
|intab|dac|4,int_r|||pointer to 0|6061
||dac|4,inton|||pointer to 1|6062
||dac|4,inttw|||pointer to 2|6063
||ejc|||||6064
|ndabb|dac|6,p_abb|||arbno|6070
|ndabd|dac|6,p_abd|||arbno|6071
|ndarc|dac|6,p_arc|||arb|6072
|ndexb|dac|6,p_exb|||expression|6073
|ndfnb|dac|6,p_fnb|||fence()|6074
|ndfnd|dac|6,p_fnd|||fence()|6075
|ndexc|dac|6,p_exc|||expression|6076
|ndimb|dac|6,p_imb|||immediate assignment|6077
|ndimd|dac|6,p_imd|||immediate assignment|6078
|ndnth|dac|6,p_nth|||pattern end (null pattern)|6079
|ndpab|dac|6,p_pab|||pattern assignment|6080
|ndpad|dac|6,p_pad|||pattern assignment|6081
|nduna|dac|6,p_una|||anchor point movement|6082
|ndabo|dac|6,p_abo|||abort|6090
||dac|4,ndnth||||6091
|ndarb|dac|6,p_arb|||arb|6092
||dac|4,ndnth||||6093
|ndbal|dac|6,p_bal|||bal|6094
||dac|4,ndnth||||6095
|ndfal|dac|6,p_fal|||fail|6096
||dac|4,ndnth||||6097
|ndfen|dac|6,p_fen|||fence|6098
||dac|4,ndnth||||6099
|ndrem|dac|6,p_rem|||rem|6100
||dac|4,ndnth||||6101
|ndsuc|dac|6,p_suc|||succeed|6102
||dac|4,ndnth||||6103
|nulls|dac|6,b_scl|||null string value|6111
||dac|1,0|||sclen = 0|6112
|nullw|dtc|27,/          /||||6113
|lcase|dac|6,b_scl||||6119
||dac|1,26||||6120
||dtc|27,/abcdefghijklmnopqrstuvwxyz/||||6121
|ucase|dac|6,b_scl||||6123
||dac|1,26||||6124
||dtc|27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/||||6125
||ejc|||||6127
|opdvc|dac|6,o_cnc|||concatenation|6131
||dac|2,c_cnc||||6132
||dac|2,llcnc||||6133
||dac|2,rrcnc||||6134
|opdvp|dac|6,o_cnc|||concatenation - not pattern match|6140
||dac|2,c_cnp||||6141
||dac|2,llcnc||||6142
||dac|2,rrcnc||||6143
|opdvs|dac|6,o_ass|||assignment|6148
||dac|2,c_ass||||6149
||dac|2,llass||||6150
||dac|2,rrass||||6151
||dac|1,6|||unary equal|6153
||dac|2,c_uuo||||6154
||dac|2,lluno||||6155
||dac|6,o_pmv|||pattern match|6157
||dac|2,c_pmt||||6158
||dac|2,llpmt||||6159
||dac|2,rrpmt||||6160
||dac|6,o_int|||interrogation|6162
||dac|2,c_uvl||||6163
||dac|2,lluno||||6164
||dac|1,1|||binary ampersand|6166
||dac|2,c_ubo||||6167
||dac|2,llamp||||6168
||dac|2,rramp||||6169
||dac|6,o_kwv|||keyword reference|6171
||dac|2,c_key||||6172
||dac|2,lluno||||6173
||dac|6,o_alt|||alternation|6175
||dac|2,c_alt||||6176
||dac|2,llalt||||6177
||dac|2,rralt||||6178
||ejc|||||6179
||dac|1,5|||unary vertical bar|6183
||dac|2,c_uuo||||6184
||dac|2,lluno||||6185
||dac|1,0|||binary at|6187
||dac|2,c_ubo||||6188
||dac|2,llats||||6189
||dac|2,rrats||||6190
||dac|6,o_cas|||cursor assignment|6192
||dac|2,c_unm||||6193
||dac|2,lluno||||6194
||dac|1,2|||binary number sign|6196
||dac|2,c_ubo||||6197
||dac|2,llnum||||6198
||dac|2,rrnum||||6199
||dac|1,7|||unary number sign|6201
||dac|2,c_uuo||||6202
||dac|2,lluno||||6203
||dac|6,o_dvd|||division|6205
||dac|2,c_bvl||||6206
||dac|2,lldvd||||6207
||dac|2,rrdvd||||6208
||dac|1,9|||unary slash|6210
||dac|2,c_uuo||||6211
||dac|2,lluno||||6212
||dac|6,o_mlt|||multiplication|6214
||dac|2,c_bvl||||6215
||dac|2,llmlt||||6216
||dac|2,rrmlt||||6217
||ejc|||||6218
||dac|1,0|||deferred expression|6222
||dac|2,c_def||||6223
||dac|2,lluno||||6224
||dac|1,3|||binary percent|6226
||dac|2,c_ubo||||6227
||dac|2,llpct||||6228
||dac|2,rrpct||||6229
||dac|1,8|||unary percent|6231
||dac|2,c_uuo||||6232
||dac|2,lluno||||6233
||dac|6,o_exp|||exponentiation|6235
||dac|2,c_bvl||||6236
||dac|2,llexp||||6237
||dac|2,rrexp||||6238
||dac|1,10|||unary exclamation|6240
||dac|2,c_uuo||||6241
||dac|2,lluno||||6242
||dac|6,o_ima|||immediate assignment|6244
||dac|2,c_bvn||||6245
||dac|2,lldld||||6246
||dac|2,rrdld||||6247
||dac|6,o_inv|||indirection|6249
||dac|2,c_ind||||6250
||dac|2,lluno||||6251
||dac|1,4|||binary not|6253
||dac|2,c_ubo||||6254
||dac|2,llnot||||6255
||dac|2,rrnot||||6256
||dac|1,0|||negation|6258
||dac|2,c_neg||||6259
||dac|2,lluno||||6260
||ejc|||||6261
||dac|6,o_sub|||subtraction|6265
||dac|2,c_bvl||||6266
||dac|2,llplm||||6267
||dac|2,rrplm||||6268
||dac|6,o_com|||complementation|6270
||dac|2,c_uvl||||6271
||dac|2,lluno||||6272
||dac|6,o_add|||addition|6274
||dac|2,c_bvl||||6275
||dac|2,llplm||||6276
||dac|2,rrplm||||6277
||dac|6,o_aff|||affirmation|6279
||dac|2,c_uvl||||6280
||dac|2,lluno||||6281
||dac|6,o_pas|||pattern assignment|6283
||dac|2,c_bvn||||6284
||dac|2,lldld||||6285
||dac|2,rrdld||||6286
||dac|6,o_nam|||name reference|6288
||dac|2,c_unm||||6289
||dac|2,lluno||||6290
|opdvd|dac|6,o_god|||direct goto|6294
||dac|2,c_uvl||||6295
||dac|2,lluno||||6296
|opdvn|dac|6,o_goc|||complex normal goto|6298
||dac|2,c_unm||||6299
||dac|2,lluno||||6300
||ejc|||||6301
|oamn_|dac|6,o_amn|||array ref (multi-subs by value)|6305
|oamv_|dac|6,o_amv|||array ref (multi-subs by value)|6306
|oaon_|dac|6,o_aon|||array ref (one sub by name)|6307
|oaov_|dac|6,o_aov|||array ref (one sub by value)|6308
|ocer_|dac|6,o_cer|||compilation error|6309
|ofex_|dac|6,o_fex|||failure in expression evaluation|6310
|ofif_|dac|6,o_fif|||failure during goto evaluation|6311
|ofnc_|dac|6,o_fnc|||function call (more than one arg)|6312
|ofne_|dac|6,o_fne|||function name error|6313
|ofns_|dac|6,o_fns|||function call (single argument)|6314
|ogof_|dac|6,o_gof|||set goto failure trap|6315
|oinn_|dac|6,o_inn|||indirection by name|6316
|okwn_|dac|6,o_kwn|||keyword reference by name|6317
|olex_|dac|6,o_lex|||load expression by name|6318
|olpt_|dac|6,o_lpt|||load pattern|6319
|olvn_|dac|6,o_lvn|||load variable name|6320
|onta_|dac|6,o_nta|||negation, first entry|6321
|ontb_|dac|6,o_ntb|||negation, second entry|6322
|ontc_|dac|6,o_ntc|||negation, third entry|6323
|opmn_|dac|6,o_pmn|||pattern match by name|6324
|opms_|dac|6,o_pms|||pattern match (statement)|6325
|opop_|dac|6,o_pop|||pop top stack item|6326
|ornm_|dac|6,o_rnm|||return name from expression|6327
|orpl_|dac|6,o_rpl|||pattern replacement|6328
|orvl_|dac|6,o_rvl|||return value from expression|6329
|osla_|dac|6,o_sla|||selection, first entry|6330
|oslb_|dac|6,o_slb|||selection, second entry|6331
|oslc_|dac|6,o_slc|||selection, third entry|6332
|osld_|dac|6,o_sld|||selection, fourth entry|6333
|ostp_|dac|6,o_stp|||stop execution|6334
|ounf_|dac|6,o_unf|||unexpected failure|6335
||ejc|||||6336
|opsnb|dac|2,ch_at|||at|6340
||dac|2,ch_am|||ampersand|6341
||dac|2,ch_nm|||number|6342
||dac|2,ch_pc|||percent|6343
||dac|2,ch_nt|||not|6344
|opnsu|dac|2,ch_br|||vertical bar|6348
||dac|2,ch_eq|||equal|6349
||dac|2,ch_nm|||number|6350
||dac|2,ch_pc|||percent|6351
||dac|2,ch_sl|||slash|6352
||dac|2,ch_ex|||exclamation|6353
|pfi2a|dac|2,pf_i2||||6359
|pfms1|dac|6,b_scl||||6363
||dac|1,15||||6364
||dtc|27,/program profile/||||6365
|pfms2|dac|6,b_scl||||6366
||dac|1,42||||6367
||dtc|27,/stmt    number of     -- execution time --/||||6368
|pfms3|dac|6,b_scl||||6369
||dac|1,47||||6370
||dtc|27,/number  executions  total(msec) per excn(mcsec)/||||6371
|reav0|drc|17,+0.0|||0.0|6381
|reap1|drc|17,+0.1|||0.1|6384
|reap5|drc|17,+0.5|||0.5|6385
|reav1|drc|17,+1.0|||10**0|6387
|reavt|drc|17,+1.0e+1|||10**1|6388
||drc|17,+1.0e+2|||10**2|6389
||drc|17,+1.0e+3|||10**3|6390
||drc|17,+1.0e+4|||10**4|6391
||drc|17,+1.0e+5|||10**5|6392
||drc|17,+1.0e+6|||10**6|6393
||drc|17,+1.0e+7|||10**7|6394
||drc|17,+1.0e+8|||10**8|6395
||drc|17,+1.0e+9|||10**9|6396
|reatt|drc|17,+1.0e+10|||10**10|6397
||ejc|||||6399
|scarr|dac|6,b_scl|||array|6403
||dac|1,5||||6404
||dtc|27,/array/||||6405
|sccod|dac|6,b_scl|||code|6414
||dac|1,4||||6415
||dtc|27,/code/||||6416
|scexp|dac|6,b_scl|||expression|6418
||dac|1,10||||6419
||dtc|27,/expression/||||6420
|scext|dac|6,b_scl|||external|6422
||dac|1,8||||6423
||dtc|27,/external/||||6424
|scint|dac|6,b_scl|||integer|6426
||dac|1,7||||6427
||dtc|27,/integer/||||6428
|scnam|dac|6,b_scl|||name|6430
||dac|1,4||||6431
||dtc|27,/name/||||6432
|scnum|dac|6,b_scl|||numeric|6434
||dac|1,7||||6435
||dtc|27,/numeric/||||6436
|scpat|dac|6,b_scl|||pattern|6438
||dac|1,7||||6439
||dtc|27,/pattern/||||6440
|screa|dac|6,b_scl|||real|6444
||dac|1,4||||6445
||dtc|27,/real/||||6446
|scstr|dac|6,b_scl|||string|6449
||dac|1,6||||6450
||dtc|27,/string/||||6451
|sctab|dac|6,b_scl|||table|6453
||dac|1,5||||6454
||dtc|27,/table/||||6455
|scfil|dac|6,b_scl|||file (for extended load arguments)|6457
||dac|1,4||||6458
||dtc|27,/file/||||6459
||ejc|||||6461
|scfrt|dac|6,b_scl|||freturn|6465
||dac|1,7||||6466
||dtc|27,/freturn/||||6467
|scnrt|dac|6,b_scl|||nreturn|6469
||dac|1,7||||6470
||dtc|27,/nreturn/||||6471
|scrtn|dac|6,b_scl|||return|6473
||dac|1,6||||6474
||dtc|27,/return/||||6475
|scnmt|dac|4,scarr|||arblk     array|6485
||dac|4,sccod|||cdblk     code|6486
||dac|4,scexp|||exblk     expression|6487
||dac|4,scint|||icblk     integer|6488
||dac|4,scnam|||nmblk     name|6489
||dac|4,scpat|||p0blk     pattern|6490
||dac|4,scpat|||p1blk     pattern|6491
||dac|4,scpat|||p2blk     pattern|6492
||dac|4,screa|||rcblk     real|6497
||dac|4,scstr|||scblk     string|6499
||dac|4,scexp|||seblk     expression|6500
||dac|4,sctab|||tbblk     table|6501
||dac|4,scarr|||vcblk     array|6502
||dac|4,scext|||xnblk     external|6503
||dac|4,scext|||xrblk     external|6504
||dac|4,nulls|||bfblk     no buffer in this version|6506
|scre0|dac|6,b_scl||||6515
||dac|1,2||||6516
||dtc|27,/0./||||6517
||ejc|||||6519
|stlim|dic|16,+2147483647|||default statement limit|6527
|stndf|dac|6,o_fun|||ptr to undefined function err call|6535
||dac|1,0|||dummy fargs count for call circuit|6536
|stndl|dac|6,l_und|||code ptr points to undefined lbl|6540
|stndo|dac|6,o_oun|||ptr to undefined operator err call|6544
||dac|1,0|||dummy fargs count for call circuit|6545
|stnvr|dac|6,b_vrl|||vrget|6551
||dac|6,b_vrs|||vrsto|6552
||dac|4,nulls|||vrval|6553
||dac|6,b_vrg|||vrtra|6554
||dac|4,stndl|||vrlbl|6555
||dac|4,stndf|||vrfnc|6556
||dac|1,0|||vrnxt|6557
||ejc|||||6558
|stpm1|dac|6,b_scl|||in statement|6562
||dac|1,12||||6563
||dtc|27,/in statement/||||6564
|stpm2|dac|6,b_scl||||6566
||dac|1,14||||6567
||dtc|27,/stmts executed/||||6568
|stpm3|dac|6,b_scl||||6570
||dac|1,20||||6571
||dtc|27,/execution time msec /||||6572
|stpm4|dac|6,b_scl|||in line|6575
||dac|1,7||||6576
||dtc|27,/in line/||||6577
|stpm5|dac|6,b_scl||||6580
||dac|1,13||||6581
||dtc|27,/regenerations/||||6582
|stpm6|dac|6,b_scl|||in file|6585
||dac|1,7||||6586
||dtc|27,/in file/||||6587
|stpm7|dac|6,b_scl||||6590
||dac|1,15||||6591
||dtc|27,_stmt / microsec_||||6592
|stpm8|dac|6,b_scl||||6594
||dac|1,15||||6595
||dtc|27,_stmt / millisec_||||6596
|stpm9|dac|6,b_scl||||6598
||dac|1,13||||6599
||dtc|27,_stmt / second_||||6600
|strtu|dtc|27,/tu/||||6604
|svctb|dac|4,scstr|||string|6610
||dac|4,scint|||integer|6611
||dac|4,scnam|||name|6612
||dac|4,scpat|||pattern|6613
||dac|4,scarr|||array|6614
||dac|4,sctab|||table|6615
||dac|4,scexp|||expression|6616
||dac|4,sccod|||code|6617
||dac|4,scnum|||numeric|6618
||dac|4,screa|||real|6621
||dac|1,0|||zero marks end of list|6627
||ejc|||||6628
|tmasb|dac|6,b_scl|||asterisks for trace statement no|6633
||dac|1,13||||6634
||dtc|27,/************ /||||6635
|tmbeb|dac|6,b_scl|||blank-equal-blank|6638
||dac|1,3||||6639
||dtc|27,/ = /||||6640
|trbev|dac|6,b_trt|||dummy trblk|6644
|trbkv|dac|6,b_trt|||dummy trblk|6648
|trxdr|dac|6,o_txr|||block points to return routine|6652
|trxdc|dac|4,trxdr|||pointer to block|6653
||ejc|||||6654
|v_eqf|dbc|2,svfpr|||eq|6662
||dac|1,2||||6663
||dtc|27,/eq/||||6664
||dac|6,s_eqf||||6665
||dac|1,2||||6666
|v_gef|dbc|2,svfpr|||ge|6668
||dac|1,2||||6669
||dtc|27,/ge/||||6670
||dac|6,s_gef||||6671
||dac|1,2||||6672
|v_gtf|dbc|2,svfpr|||gt|6674
||dac|1,2||||6675
||dtc|27,/gt/||||6676
||dac|6,s_gtf||||6677
||dac|1,2||||6678
|v_lef|dbc|2,svfpr|||le|6680
||dac|1,2||||6681
||dtc|27,/le/||||6682
||dac|6,s_lef||||6683
||dac|1,2||||6684
|v_lnf|dbc|2,svfnp|||ln|6687
||dac|1,2||||6688
||dtc|27,/ln/||||6689
||dac|6,s_lnf||||6690
||dac|1,1||||6691
|v_ltf|dbc|2,svfpr|||lt|6694
||dac|1,2||||6695
||dtc|27,/lt/||||6696
||dac|6,s_ltf||||6697
||dac|1,2||||6698
|v_nef|dbc|2,svfpr|||ne|6700
||dac|1,2||||6701
||dtc|27,/ne/||||6702
||dac|6,s_nef||||6703
||dac|1,2||||6704
|v_any|dbc|2,svfnp|||any|6730
||dac|1,3||||6731
||dtc|27,/any/||||6732
||dac|6,s_any||||6733
||dac|1,1||||6734
|v_arb|dbc|2,svkvc|||arb|6736
||dac|1,3||||6737
||dtc|27,/arb/||||6738
||dac|2,k_arb||||6739
||dac|4,ndarb||||6740
||ejc|||||6741
|v_arg|dbc|2,svfnn|||arg|6745
||dac|1,3||||6746
||dtc|27,/arg/||||6747
||dac|6,s_arg||||6748
||dac|1,2||||6749
|v_bal|dbc|2,svkvc|||bal|6751
||dac|1,3||||6752
||dtc|27,/bal/||||6753
||dac|2,k_bal||||6754
||dac|4,ndbal||||6755
|v_cos|dbc|2,svfnp|||cos|6758
||dac|1,3||||6759
||dtc|27,/cos/||||6760
||dac|6,s_cos||||6761
||dac|1,1||||6762
|v_end|dbc|2,svlbl|||end|6765
||dac|1,3||||6766
||dtc|27,/end/||||6767
||dac|6,l_end||||6768
|v_exp|dbc|2,svfnp|||exp|6771
||dac|1,3||||6772
||dtc|27,/exp/||||6773
||dac|6,s_exp||||6774
||dac|1,1||||6775
|v_len|dbc|2,svfnp|||len|6778
||dac|1,3||||6779
||dtc|27,/len/||||6780
||dac|6,s_len||||6781
||dac|1,1||||6782
|v_leq|dbc|2,svfpr|||leq|6784
||dac|1,3||||6785
||dtc|27,/leq/||||6786
||dac|6,s_leq||||6787
||dac|1,2||||6788
|v_lge|dbc|2,svfpr|||lge|6790
||dac|1,3||||6791
||dtc|27,/lge/||||6792
||dac|6,s_lge||||6793
||dac|1,2||||6794
|v_lgt|dbc|2,svfpr|||lgt|6796
||dac|1,3||||6797
||dtc|27,/lgt/||||6798
||dac|6,s_lgt||||6799
||dac|1,2||||6800
|v_lle|dbc|2,svfpr|||lle|6802
||dac|1,3||||6803
||dtc|27,/lle/||||6804
||dac|6,s_lle||||6805
||dac|1,2||||6806
||ejc|||||6807
|v_llt|dbc|2,svfpr|||llt|6811
||dac|1,3||||6812
||dtc|27,/llt/||||6813
||dac|6,s_llt||||6814
||dac|1,2||||6815
|v_lne|dbc|2,svfpr|||lne|6817
||dac|1,3||||6818
||dtc|27,/lne/||||6819
||dac|6,s_lne||||6820
||dac|1,2||||6821
|v_pos|dbc|2,svfnp|||pos|6823
||dac|1,3||||6824
||dtc|27,/pos/||||6825
||dac|6,s_pos||||6826
||dac|1,1||||6827
|v_rem|dbc|2,svkvc|||rem|6829
||dac|1,3||||6830
||dtc|27,/rem/||||6831
||dac|2,k_rem||||6832
||dac|4,ndrem||||6833
|v_sin|dbc|2,svfnp|||sin|6844
||dac|1,3||||6845
||dtc|27,/sin/||||6846
||dac|6,s_sin||||6847
||dac|1,1||||6848
|v_tab|dbc|2,svfnp|||tab|6851
||dac|1,3||||6852
||dtc|27,/tab/||||6853
||dac|6,s_tab||||6854
||dac|1,1||||6855
|v_tan|dbc|2,svfnp|||tan|6858
||dac|1,3||||6859
||dtc|27,/tan/||||6860
||dac|6,s_tan||||6861
||dac|1,1||||6862
|v_atn|dbc|2,svfnp|||atan|6874
||dac|1,4||||6875
||dtc|27,/atan/||||6876
||dac|6,s_atn||||6877
||dac|1,1||||6878
|v_cas|dbc|2,svknm|||case|6882
||dac|1,4||||6883
||dtc|27,/case/||||6884
||dac|2,k_cas||||6885
|v_chr|dbc|2,svfnp|||char|6888
||dac|1,4||||6889
||dtc|27,/char/||||6890
||dac|6,s_chr||||6891
||dac|1,1||||6892
|v_chp|dbc|2,svfnp|||chop|6896
||dac|1,4||||6897
||dtc|27,/chop/||||6898
||dac|6,s_chp||||6899
||dac|1,1||||6900
|v_cod|dbc|2,svfnk|||code|6902
||dac|1,4||||6903
||dtc|27,/code/||||6904
||dac|2,k_cod||||6905
||dac|6,s_cod||||6906
||dac|1,1||||6907
|v_cop|dbc|2,svfnn|||copy|6909
||dac|1,4||||6910
||dtc|27,/copy/||||6911
||dac|6,s_cop||||6912
||dac|1,1||||6913
||ejc|||||6914
|v_dat|dbc|2,svfnn|||data|6918
||dac|1,4||||6919
||dtc|27,/data/||||6920
||dac|6,s_dat||||6921
||dac|1,1||||6922
|v_dte|dbc|2,svfnn|||date|6924
||dac|1,4||||6925
||dtc|27,/date/||||6926
||dac|6,s_dte||||6927
||dac|1,1||||6928
|v_dmp|dbc|2,svfnk|||dump|6930
||dac|1,4||||6931
||dtc|27,/dump/||||6932
||dac|2,k_dmp||||6933
||dac|6,s_dmp||||6934
||dac|1,1||||6935
|v_dup|dbc|2,svfnn|||dupl|6937
||dac|1,4||||6938
||dtc|27,/dupl/||||6939
||dac|6,s_dup||||6940
||dac|1,2||||6941
|v_evl|dbc|2,svfnn|||eval|6943
||dac|1,4||||6944
||dtc|27,/eval/||||6945
||dac|6,s_evl||||6946
||dac|1,1||||6947
|v_ext|dbc|2,svfnn|||exit|6951
||dac|1,4||||6952
||dtc|27,/exit/||||6953
||dac|6,s_ext||||6954
||dac|1,2||||6955
|v_fal|dbc|2,svkvc|||fail|6958
||dac|1,4||||6959
||dtc|27,/fail/||||6960
||dac|2,k_fal||||6961
||dac|4,ndfal||||6962
|v_fil|dbc|2,svknm|||file|6965
||dac|1,4||||6966
||dtc|27,/file/||||6967
||dac|2,k_fil||||6968
|v_hst|dbc|2,svfnn|||host|6971
||dac|1,4||||6972
||dtc|27,/host/||||6973
||dac|6,s_hst||||6974
||dac|1,5||||6975
||ejc|||||6976
|v_itm|dbc|2,svfnf|||item|6980
||dac|1,4||||6981
||dtc|27,/item/||||6982
||dac|6,s_itm||||6983
||dac|1,999||||6984
|v_lin|dbc|2,svknm|||line|6987
||dac|1,4||||6988
||dtc|27,/line/||||6989
||dac|2,k_lin||||6990
|v_lod|dbc|2,svfnn|||load|6995
||dac|1,4||||6996
||dtc|27,/load/||||6997
||dac|6,s_lod||||6998
||dac|1,2||||6999
|v_lpd|dbc|2,svfnp|||lpad|7002
||dac|1,4||||7003
||dtc|27,/lpad/||||7004
||dac|6,s_lpd||||7005
||dac|1,3||||7006
|v_rpd|dbc|2,svfnp|||rpad|7008
||dac|1,4||||7009
||dtc|27,/rpad/||||7010
||dac|6,s_rpd||||7011
||dac|1,3||||7012
|v_rps|dbc|2,svfnp|||rpos|7014
||dac|1,4||||7015
||dtc|27,/rpos/||||7016
||dac|6,s_rps||||7017
||dac|1,1||||7018
|v_rtb|dbc|2,svfnp|||rtab|7020
||dac|1,4||||7021
||dtc|27,/rtab/||||7022
||dac|6,s_rtb||||7023
||dac|1,1||||7024
|v_si_|dbc|2,svfnp|||size|7026
||dac|1,4||||7027
||dtc|27,/size/||||7028
||dac|6,s_si_||||7029
||dac|1,1||||7030
|v_srt|dbc|2,svfnn|||sort|7035
||dac|1,4||||7036
||dtc|27,/sort/||||7037
||dac|6,s_srt||||7038
||dac|1,2||||7039
|v_spn|dbc|2,svfnp|||span|7041
||dac|1,4||||7042
||dtc|27,/span/||||7043
||dac|6,s_spn||||7044
||dac|1,1||||7045
||ejc|||||7046
|v_sqr|dbc|2,svfnp|||sqrt|7052
||dac|1,4||||7053
||dtc|27,/sqrt/||||7054
||dac|6,s_sqr||||7055
||dac|1,1||||7056
|v_stn|dbc|2,svknm|||stno|7058
||dac|1,4||||7059
||dtc|27,/stno/||||7060
||dac|2,k_stn||||7061
|v_tim|dbc|2,svfnn|||time|7063
||dac|1,4||||7064
||dtc|27,/time/||||7065
||dac|6,s_tim||||7066
||dac|1,0||||7067
|v_trm|dbc|2,svfnk|||trim|7069
||dac|1,4||||7070
||dtc|27,/trim/||||7071
||dac|2,k_trm||||7072
||dac|6,s_trm||||7073
||dac|1,1||||7074
|v_abe|dbc|2,svknm|||abend|7076
||dac|1,5||||7077
||dtc|27,/abend/||||7078
||dac|2,k_abe||||7079
|v_abo|dbc|2,svkvl|||abort|7081
||dac|1,5||||7082
||dtc|27,/abort/||||7083
||dac|2,k_abo||||7084
||dac|6,l_abo||||7085
||dac|4,ndabo||||7086
|v_app|dbc|2,svfnf|||apply|7088
||dac|1,5||||7089
||dtc|27,/apply/||||7090
||dac|6,s_app||||7091
||dac|1,999||||7092
|v_abn|dbc|2,svfnp|||arbno|7094
||dac|1,5||||7095
||dtc|27,/arbno/||||7096
||dac|6,s_abn||||7097
||dac|1,1||||7098
|v_arr|dbc|2,svfnn|||array|7100
||dac|1,5||||7101
||dtc|27,/array/||||7102
||dac|6,s_arr||||7103
||dac|1,2||||7104
||ejc|||||7105
|v_brk|dbc|2,svfnp|||break|7109
||dac|1,5||||7110
||dtc|27,/break/||||7111
||dac|6,s_brk||||7112
||dac|1,1||||7113
|v_clr|dbc|2,svfnn|||clear|7115
||dac|1,5||||7116
||dtc|27,/clear/||||7117
||dac|6,s_clr||||7118
||dac|1,1||||7119
|v_ejc|dbc|2,svfnn|||eject|7129
||dac|1,5||||7130
||dtc|27,/eject/||||7131
||dac|6,s_ejc||||7132
||dac|1,1||||7133
|v_fen|dbc|2,svfpk|||fence|7135
||dac|1,5||||7136
||dtc|27,/fence/||||7137
||dac|2,k_fen||||7138
||dac|6,s_fnc||||7139
||dac|1,1||||7140
||dac|4,ndfen||||7141
|v_fld|dbc|2,svfnn|||field|7143
||dac|1,5||||7144
||dtc|27,/field/||||7145
||dac|6,s_fld||||7146
||dac|1,2||||7147
|v_idn|dbc|2,svfpr|||ident|7149
||dac|1,5||||7150
||dtc|27,/ident/||||7151
||dac|6,s_idn||||7152
||dac|1,2||||7153
|v_inp|dbc|2,svfnk|||input|7155
||dac|1,5||||7156
||dtc|27,/input/||||7157
||dac|2,k_inp||||7158
||dac|6,s_inp||||7159
||dac|1,3||||7160
|v_lcs|dbc|2,svkwc|||lcase|7163
||dac|1,5||||7164
||dtc|27,/lcase/||||7165
||dac|2,k_lcs||||7166
|v_loc|dbc|2,svfnn|||local|7169
||dac|1,5||||7170
||dtc|27,/local/||||7171
||dac|6,s_loc||||7172
||dac|1,2||||7173
||ejc|||||7174
|v_ops|dbc|2,svfnn|||opsyn|7178
||dac|1,5||||7179
||dtc|27,/opsyn/||||7180
||dac|6,s_ops||||7181
||dac|1,3||||7182
|v_rmd|dbc|2,svfnp|||remdr|7184
||dac|1,5||||7185
||dtc|27,/remdr/||||7186
||dac|6,s_rmd||||7187
||dac|1,2||||7188
|v_rsr|dbc|2,svfnn|||rsort|7192
||dac|1,5||||7193
||dtc|27,/rsort/||||7194
||dac|6,s_rsr||||7195
||dac|1,2||||7196
|v_tbl|dbc|2,svfnn|||table|7199
||dac|1,5||||7200
||dtc|27,/table/||||7201
||dac|6,s_tbl||||7202
||dac|1,3||||7203
|v_tra|dbc|2,svfnk|||trace|7205
||dac|1,5||||7206
||dtc|27,/trace/||||7207
||dac|2,k_tra||||7208
||dac|6,s_tra||||7209
||dac|1,4||||7210
|v_ucs|dbc|2,svkwc|||ucase|7213
||dac|1,5||||7214
||dtc|27,/ucase/||||7215
||dac|2,k_ucs||||7216
|v_anc|dbc|2,svknm|||anchor|7219
||dac|1,6||||7220
||dtc|27,/anchor/||||7221
||dac|2,k_anc||||7222
|v_bkx|dbc|2,svfnp|||breakx|7233
||dac|1,6||||7234
||dtc|27,/breakx/||||7235
||dac|6,s_bkx||||7236
||dac|1,1||||7237
|v_def|dbc|2,svfnn|||define|7248
||dac|1,6||||7249
||dtc|27,/define/||||7250
||dac|6,s_def||||7251
||dac|1,2||||7252
|v_det|dbc|2,svfnn|||detach|7254
||dac|1,6||||7255
||dtc|27,/detach/||||7256
||dac|6,s_det||||7257
||dac|1,1||||7258
||ejc|||||7259
|v_dif|dbc|2,svfpr|||differ|7263
||dac|1,6||||7264
||dtc|27,/differ/||||7265
||dac|6,s_dif||||7266
||dac|1,2||||7267
|v_ftr|dbc|2,svknm|||ftrace|7269
||dac|1,6||||7270
||dtc|27,/ftrace/||||7271
||dac|2,k_ftr||||7272
|v_lst|dbc|2,svknm|||lastno|7283
||dac|1,6||||7284
||dtc|27,/lastno/||||7285
||dac|2,k_lst||||7286
|v_nay|dbc|2,svfnp|||notany|7288
||dac|1,6||||7289
||dtc|27,/notany/||||7290
||dac|6,s_nay||||7291
||dac|1,1||||7292
|v_oup|dbc|2,svfnk|||output|7294
||dac|1,6||||7295
||dtc|27,/output/||||7296
||dac|2,k_oup||||7297
||dac|6,s_oup||||7298
||dac|1,3||||7299
|v_ret|dbc|2,svlbl|||return|7301
||dac|1,6||||7302
||dtc|27,/return/||||7303
||dac|6,l_rtn||||7304
|v_rew|dbc|2,svfnn|||rewind|7306
||dac|1,6||||7307
||dtc|27,/rewind/||||7308
||dac|6,s_rew||||7309
||dac|1,1||||7310
|v_stt|dbc|2,svfnn|||stoptr|7312
||dac|1,6||||7313
||dtc|27,/stoptr/||||7314
||dac|6,s_stt||||7315
||dac|1,2||||7316
||ejc|||||7317
|v_sub|dbc|2,svfnn|||substr|7321
||dac|1,6||||7322
||dtc|27,/substr/||||7323
||dac|6,s_sub||||7324
||dac|1,3||||7325
|v_unl|dbc|2,svfnn|||unload|7327
||dac|1,6||||7328
||dtc|27,/unload/||||7329
||dac|6,s_unl||||7330
||dac|1,1||||7331
|v_col|dbc|2,svfnn|||collect|7333
||dac|1,7||||7334
||dtc|27,/collect/||||7335
||dac|6,s_col||||7336
||dac|1,1||||7337
|v_com|dbc|2,svknm|||compare|7340
||dac|1,7||||7341
||dtc|27,/compare/||||7342
||dac|2,k_com||||7343
|v_cnv|dbc|2,svfnn|||convert|7346
||dac|1,7||||7347
||dtc|27,/convert/||||7348
||dac|6,s_cnv||||7349
||dac|1,2||||7350
|v_enf|dbc|2,svfnn|||endfile|7352
||dac|1,7||||7353
||dtc|27,/endfile/||||7354
||dac|6,s_enf||||7355
||dac|1,1||||7356
|v_etx|dbc|2,svknm|||errtext|7358
||dac|1,7||||7359
||dtc|27,/errtext/||||7360
||dac|2,k_etx||||7361
|v_ert|dbc|2,svknm|||errtype|7363
||dac|1,7||||7364
||dtc|27,/errtype/||||7365
||dac|2,k_ert||||7366
|v_frt|dbc|2,svlbl|||freturn|7368
||dac|1,7||||7369
||dtc|27,/freturn/||||7370
||dac|6,l_frt||||7371
|v_int|dbc|2,svfpr|||integer|7373
||dac|1,7||||7374
||dtc|27,/integer/||||7375
||dac|6,s_int||||7376
||dac|1,1||||7377
|v_nrt|dbc|2,svlbl|||nreturn|7379
||dac|1,7||||7380
||dtc|27,/nreturn/||||7381
||dac|6,l_nrt||||7382
||ejc|||||7383
|v_pfl|dbc|2,svknm|||profile|7390
||dac|1,7||||7391
||dtc|27,/profile/||||7392
||dac|2,k_pfl||||7393
|v_rpl|dbc|2,svfnp|||replace|7396
||dac|1,7||||7397
||dtc|27,/replace/||||7398
||dac|6,s_rpl||||7399
||dac|1,3||||7400
|v_rvs|dbc|2,svfnp|||reverse|7402
||dac|1,7||||7403
||dtc|27,/reverse/||||7404
||dac|6,s_rvs||||7405
||dac|1,1||||7406
|v_rtn|dbc|2,svknm|||rtntype|7408
||dac|1,7||||7409
||dtc|27,/rtntype/||||7410
||dac|2,k_rtn||||7411
|v_stx|dbc|2,svfnn|||setexit|7413
||dac|1,7||||7414
||dtc|27,/setexit/||||7415
||dac|6,s_stx||||7416
||dac|1,1||||7417
|v_stc|dbc|2,svknm|||stcount|7419
||dac|1,7||||7420
||dtc|27,/stcount/||||7421
||dac|2,k_stc||||7422
|v_stl|dbc|2,svknm|||stlimit|7424
||dac|1,7||||7425
||dtc|27,/stlimit/||||7426
||dac|2,k_stl||||7427
|v_suc|dbc|2,svkvc|||succeed|7429
||dac|1,7||||7430
||dtc|27,/succeed/||||7431
||dac|2,k_suc||||7432
||dac|4,ndsuc||||7433
|v_alp|dbc|2,svkwc|||alphabet|7435
||dac|1,8||||7436
||dtc|27,/alphabet/||||7437
||dac|2,k_alp||||7438
|v_cnt|dbc|2,svlbl|||continue|7440
||dac|1,8||||7441
||dtc|27,/continue/||||7442
||dac|6,l_cnt||||7443
||ejc|||||7444
|v_dtp|dbc|2,svfnp|||datatype|7448
||dac|1,8||||7449
||dtc|27,/datatype/||||7450
||dac|6,s_dtp||||7451
||dac|1,1||||7452
|v_erl|dbc|2,svknm|||errlimit|7454
||dac|1,8||||7455
||dtc|27,/errlimit/||||7456
||dac|2,k_erl||||7457
|v_fnc|dbc|2,svknm|||fnclevel|7459
||dac|1,8||||7460
||dtc|27,/fnclevel/||||7461
||dac|2,k_fnc||||7462
|v_fls|dbc|2,svknm|||fullscan|7464
||dac|1,8||||7465
||dtc|27,/fullscan/||||7466
||dac|2,k_fls||||7467
|v_lfl|dbc|2,svknm|||lastfile|7470
||dac|1,8||||7471
||dtc|27,/lastfile/||||7472
||dac|2,k_lfl||||7473
|v_lln|dbc|2,svknm|||lastline|7477
||dac|1,8||||7478
||dtc|27,/lastline/||||7479
||dac|2,k_lln||||7480
|v_mxl|dbc|2,svknm|||maxlngth|7483
||dac|1,8||||7484
||dtc|27,/maxlngth/||||7485
||dac|2,k_mxl||||7486
|v_ter|dbc|1,0|||terminal|7488
||dac|1,8||||7489
||dtc|27,/terminal/||||7490
||dac|1,0||||7491
|v_bsp|dbc|2,svfnn|||backspace|7494
||dac|1,9||||7495
||dtc|27,/backspace/||||7496
||dac|6,s_bsp||||7497
||dac|1,1||||7498
|v_pro|dbc|2,svfnn|||prototype|7501
||dac|1,9||||7502
||dtc|27,/prototype/||||7503
||dac|6,s_pro||||7504
||dac|1,1||||7505
|v_scn|dbc|2,svlbl|||scontinue|7507
||dac|1,9||||7508
||dtc|27,/scontinue/||||7509
||dac|6,l_scn||||7510
||dbc|1,0|||dummy entry to end list|7512
||dac|1,10|||length gt 9 (scontinue)|7513
||ejc|||||7514
|vdmkw|dac|4,v_anc|||anchor|7519
||dac|4,v_cas|||ccase|7521
||dac|4,v_cod|||code|7523
||dac|1,1|||compare not printed|7528
||dac|4,v_dmp|||dump|7531
||dac|4,v_erl|||errlimit|7532
||dac|4,v_etx|||errtext|7533
||dac|4,v_ert|||errtype|7534
||dac|4,v_fil|||file|7536
||dac|4,v_fnc|||fnclevel|7538
||dac|4,v_ftr|||ftrace|7539
||dac|4,v_fls|||fullscan|7540
||dac|4,v_inp|||input|7541
||dac|4,v_lfl|||lastfile|7543
||dac|4,v_lln|||lastline|7546
||dac|4,v_lst|||lastno|7548
||dac|4,v_lin|||line|7550
||dac|4,v_mxl|||maxlength|7552
||dac|4,v_oup|||output|7553
||dac|4,v_pfl|||profile|7556
||dac|4,v_rtn|||rtntype|7558
||dac|4,v_stc|||stcount|7559
||dac|4,v_stl|||stlimit|7560
||dac|4,v_stn|||stno|7561
||dac|4,v_tra|||trace|7562
||dac|4,v_trm|||trim|7563
||dac|1,0|||end of list|7564
|vsrch|dac|1,0|||dummy entry to get proper indexing|7568
||dac|4,v_eqf|||start of 1 char variables (none)|7569
||dac|4,v_eqf|||start of 2 char variables|7570
||dac|4,v_any|||start of 3 char variables|7571
||dac|4,v_atn|||start of 4 char variables|7573
||dac|4,v_abe|||start of 5 char variables|7581
||dac|4,v_anc|||start of 6 char variables|7582
||dac|4,v_col|||start of 7 char variables|7583
||dac|4,v_alp|||start of 8 char variables|7584
||dac|4,v_bsp|||start of 9 char variables|7586
|c_yyy|dac|1,0|||last location in constant section|7593
||ttl|27,s p i t b o l -- working storage section||||7594
||sec||||start of working storage section|7640
||ejc|||||7641
|cmlab|dac|6,b_scl|||string used to check label legality|7645
||dac|1,2||||7646
||dtc|27,/  /||||7647
|w_aaa|dac|1,0||||7651
|actrm|dac|1,0|||trim indicator|7655
|aldyn|dac|1,0|||amount of dynamic store|7659
|allia|dic|16,+0|||dump ia|7660
|allsv|dac|1,0|||save wb in alloc|7661
|alsta|dac|1,0|||save wa in alost|7665
|arcdm|dac|1,0|||count dimensions|7669
|arnel|dic|16,+0|||count elements|7670
|arptr|dac|1,0|||offset ptr into arblk|7671
|arsvl|dic|16,+0|||save integer low bound|7672
||ejc|||||7673
|arfsi|dic|16,+0|||save current evolving subscript|7677
|arfxs|dac|1,0|||save base stack pointer|7678
|befof|dac|1,0|||save offset ptr into efblk|7682
|bpfpf|dac|1,0|||save pfblk pointer|7686
|bpfsv|dac|1,0|||save old function value|7687
|bpfxt|dac|1,0|||pointer to stacked arguments|7688
|clsvi|dic|16,+0|||save integer argument|7692
|cnscc|dac|1,0|||pointer to control card string|7696
|cnswc|dac|1,0|||word count|7697
|cnr_t|dac|1,0|||pointer to r_ttl or r_stl|7698
|cnvtp|dac|1,0|||save ptr into scvtb|7702
|datdv|dac|1,0|||save vrblk ptr for datatype name|7706
|datxs|dac|1,0|||save initial stack pointer|7707
|deflb|dac|1,0|||save vrblk ptr for label|7711
|defna|dac|1,0|||count function arguments|7712
|defvr|dac|1,0|||save vrblk ptr for function name|7713
|defxs|dac|1,0|||save initial stack pointer|7714
|dmarg|dac|1,0|||dump argument|7718
|dmpsa|dac|1,0|||preserve wa over prtvl call|7719
|dmpsb|dac|1,0|||preserve wb over syscm call|7721
|dmpsv|dac|1,0|||general scratch save|7723
|dmvch|dac|1,0|||chain pointer for variable blocks|7724
|dmpch|dac|1,0|||save sorted vrblk chain pointer|7725
|dmpkb|dac|1,0|||dummy kvblk for use in dumpr|7726
|dmpkt|dac|1,0|||kvvar trblk ptr (must follow dmpkb)|7727
|dmpkn|dac|1,0|||keyword number (must follow dmpkt)|7728
|dtcnb|dac|1,0|||name base|7732
|dtcnm|dac|1,0|||name ptr|7733
|dupsi|dic|16,+0|||store integer string length|7737
|enfch|dac|1,0|||for iochn chain head|7741
||ejc|||||7742
|ertwa|dac|1,0|||save wa|7746
|ertwb|dac|1,0|||save wb|7747
|evlin|dac|1,0|||dummy pattern block pcode|7751
|evlis|dac|1,0|||then node (must follow evlin)|7752
|evliv|dac|1,0|||value of parm1 (must follow evlis)|7753
|evlio|dac|1,0|||ptr to original node|7754
|evlif|dac|1,0|||flag for simple/complex argument|7755
|expsv|dac|1,0|||save op dope vector pointer|7759
|gbcfl|dac|1,0|||garbage collector active flag|7763
|gbclm|dac|1,0|||pointer to last move block (pass 3)|7764
|gbcnm|dac|1,0|||dummy first move block|7765
|gbcns|dac|1,0|||rest of dummy block (follows gbcnm)|7766
|gbcia|dic|16,+0|||dump ia|7772
|gbcsd|dac|1,0|||first address beyond sediment|7773
|gbcsf|dac|1,0|||free space within sediment|7774
|gbsva|dac|1,0|||save wa|7776
|gbsvb|dac|1,0|||save wb|7777
|gbsvc|dac|1,0|||save wc|7778
|gnvhe|dac|1,0|||ptr to end of hash chain|7782
|gnvnw|dac|1,0|||number of words in string name|7783
|gnvsa|dac|1,0|||save wa|7784
|gnvsb|dac|1,0|||save wb|7785
|gnvsp|dac|1,0|||pointer into vsrch table|7786
|gnvst|dac|1,0|||pointer to chars of string|7787
|gtawa|dac|1,0|||save wa|7791
|gtina|dac|1,0|||save wa|7795
|gtinb|dac|1,0|||save wb|7796
||ejc|||||7797
|gtnnf|dac|1,0|||zero/nonzero for result +/-|7801
|gtnsi|dic|16,+0|||general integer save|7802
|gtndf|dac|1,0|||0/1 for dec point so far no/yes|7805
|gtnes|dac|1,0|||zero/nonzero exponent +/-|7806
|gtnex|dic|16,+0|||real exponent|7807
|gtnsc|dac|1,0|||scale (places after point)|7808
|gtnsr|drc|17,+0.0|||general real save|7809
|gtnrd|dac|1,0|||flag for ok real number|7810
|gtpsb|dac|1,0|||save wb|7815
|gtssf|dac|1,0|||0/1 for result +/-|7819
|gtsvc|dac|1,0|||save wc|7820
|gtsvb|dac|1,0|||save wb|7821
|gtses|dac|1,0|||char + or - for exponent +/-|7826
|gtsrs|drc|17,+0.0|||general real save|7827
|gtvrc|dac|1,0|||save wc|7833
|ioptt|dac|1,0|||type of association|7848
|lodfn|dac|1,0|||pointer to vrblk for func name|7854
|lodna|dac|1,0|||count number of arguments|7855
|mxint|dac|1,0||||7861
|pfsvw|dac|1,0|||to save a w-reg|7867
|prnsi|dic|16,+0|||scratch integer loc|7872
|prsna|dac|1,0|||save wa|7876
|prsva|dac|1,0|||save wa|7880
|prsvb|dac|1,0|||save wb|7881
|prsvc|dac|1,0|||save char counter|7882
|prtsa|dac|1,0|||save wa|7886
|prtsb|dac|1,0|||save wb|7887
|prvsi|dac|1,0|||save idval|7891
|psave|dac|1,0|||temporary save for current node ptr|7895
|psavc|dac|1,0|||save cursor in p_spn, p_str|7896
|rlals|dac|1,0|||ptr to list of bounds and adjusts|7901
|rldcd|dac|1,0|||save code adjustment|7905
|rldst|dac|1,0|||save static adjustment|7906
|rldls|dac|1,0|||save list pointer|7907
|rtnbp|dac|1,0|||to save a block pointer|7912
|rtnfv|dac|1,0|||new function value (result)|7913
|rtnsv|dac|1,0|||old function value (saved value)|7914
|sbssv|dac|1,0|||save third argument|7918
|scnsa|dac|1,0|||save wa|7922
|scnsb|dac|1,0|||save wb|7923
|scnsc|dac|1,0|||save wc|7924
|scnof|dac|1,0|||save offset|7925
||ejc|||||7928
|srtdf|dac|1,0|||datatype field name|7932
|srtfd|dac|1,0|||found dfblk address|7933
|srtff|dac|1,0|||found field name|7934
|srtfo|dac|1,0|||offset to field name|7935
|srtnr|dac|1,0|||number of rows|7936
|srtof|dac|1,0|||offset within row to sort key|7937
|srtrt|dac|1,0|||root offset|7938
|srts1|dac|1,0|||save offset 1|7939
|srts2|dac|1,0|||save offset 2|7940
|srtsc|dac|1,0|||save wc|7941
|srtsf|dac|1,0|||sort array first row offset|7942
|srtsn|dac|1,0|||save n|7943
|srtso|dac|1,0|||offset to a(0)|7944
|srtsr|dac|1,0|||0, non-zero for sort, rsort|7945
|srtst|dac|1,0|||stride from one row to next|7946
|srtwc|dac|1,0|||dump wc|7947
|stpsi|dic|16,+0|||save value of stcount|7952
|stpti|dic|16,+0|||save time elapsed|7953
|tfnsi|dic|16,+0|||number of headers|7957
|xscrt|dac|1,0|||save return code|7961
|xscwb|dac|1,0|||save register wb|7962
|g_aaa|dac|1,0||||7966
|alfsf|dic|16,+0|||factor in free store pcntage check|7970
|cmerc|dac|1,0|||count of initial compile errors|7974
|cmpln|dac|1,0|||line number of first line of stmt|7975
|cmpxs|dac|1,0|||save stack ptr in case of errors|7976
|cmpsn|dac|1,1|||number of next statement to compile|7977
|cnsil|dac|1,0|||save scnil during include process.|7982
|cnind|dac|1,0|||current include file nest level|7983
|cnspt|dac|1,0|||save scnpt during include process.|7984
|cnttl|dac|1,0|||flag for -title, -stitl|7986
|cpsts|dac|1,0|||suppress comp. stats if non zero|7990
|cswdb|dac|1,0|||0/1 for -single/-double|7994
|cswer|dac|1,0|||0/1 for -errors/-noerrors|7995
|cswex|dac|1,0|||0/1 for -execute/-noexecute|7996
|cswfl|dac|1,1|||0/1 for -nofail/-fail|7997
|cswin|dac|2,iniln|||xxx for -inxxx|7998
|cswls|dac|1,1|||0/1 for -nolist/-list|7999
|cswno|dac|1,0|||0/1 for -optimise/-noopt|8000
|cswpr|dac|1,0|||0/1 for -noprint/-print|8001
|ctmsk|dbc|1,0|||last bit position used in r_ctp|8005
|curid|dac|1,0|||current id value|8006
||ejc|||||8007
|cwcof|dac|1,0|||next word offset in current ccblk|8011
|dnams|dac|1,0|||size of sediment in baus|8016
|erich|dac|1,0|||copy error reports to int.chan if 1|8021
|erlst|dac|1,0|||for listr when errors go to int.ch.|8022
|errft|dac|1,0|||fatal error flag|8023
|errsp|dac|1,0|||error suppression flag|8024
|exsts|dac|1,0|||suppress exec stats if set|8028
|flprt|dac|1,0|||location of fail offset for return|8032
|flptr|dac|1,0|||location of failure offset on stack|8033
|gbsed|dic|16,+0|||factor in sediment pcntage check|8038
|gbcnt|dac|1,0|||count of garbage collections|8040
|gtcef|dac|1,0|||save fail ptr in case of error|8044
|gtsrn|drc|17,+0.0|||rounding factor 0.5*10**-cfp_s|8052
|gtssc|drc|17,+0.0|||scaling value 10**cfp_s|8053
|gtswk|dac|1,0|||ptr to work area for gtstg|8056
|headp|dac|1,0|||header printed flag|8060
|hshnb|dic|16,+0|||number of hash buckets|8064
|initr|dac|1,0|||save terminal flag|8068
||ejc|||||8069
|kvabe|dac|1,0|||abend|8075
|kvanc|dac|1,1|||anchor|8076
|kvcas|dac|1,0|||case|8078
|kvcod|dac|1,0|||code|8080
|kvcom|dac|1,0|||compare|8082
|kvdmp|dac|1,0|||dump|8084
|kverl|dac|1,0|||errlimit|8085
|kvert|dac|1,0|||errtype|8086
|kvftr|dac|1,0|||ftrace|8087
|kvfls|dac|1,1|||fullscan|8088
|kvinp|dac|1,1|||input|8089
|kvmxl|dac|1,5000|||maxlength|8090
|kvoup|dac|1,1|||output|8091
|kvpfl|dac|1,0|||profile|8094
|kvtra|dac|1,0|||trace|8096
|kvtrm|dac|1,1|||trim|8097
|kvfnc|dac|1,0|||fnclevel|8098
|kvlst|dac|1,0|||lastno|8099
|kvlln|dac|1,0|||lastline|8101
|kvlin|dac|1,0|||line|8102
|kvstn|dac|1,0|||stno|8104
|kvalp|dac|1,0|||alphabet|8108
|kvrtn|dac|4,nulls|||rtntype (scblk pointer)|8109
|kvstl|dic|16,+2147483647|||stlimit|8115
|kvstc|dic|16,+2147483647|||stcount (counts down from stlimit)|8116
|lstid|dac|1,0|||include depth of current image|8126
|lstlc|dac|1,0|||count lines on source list page|8128
|lstnp|dac|1,0|||max number of lines on page|8129
|lstpf|dac|1,1|||set nonzero if current image listed|8130
|lstpg|dac|1,0|||current source list page number|8131
|lstpo|dac|1,0|||offset to   page nnn   message|8132
|lstsn|dac|1,0|||remember last stmnum listed|8133
|mxlen|dac|1,0|||initialised by sysmx call|8137
|noxeq|dac|1,0|||set non-zero to inhibit execution|8141
|pfdmp|dac|1,0|||set non-0 if &profile set non-0|8147
|pffnc|dac|1,0|||set non-0 if funct just entered|8148
|pfstm|dic|16,+0|||to store starting time of stmt|8149
|pfetm|dic|16,+0|||to store ending time of stmt|8150
|pfnte|dac|1,0|||nr of table entries|8151
|pfste|dic|16,+0|||gets int rep of table entry size|8152
||ejc|||||8155
|pmdfl|dac|1,0|||pattern assignment flag|8159
|pmhbs|dac|1,0|||history stack base pointer|8160
|pmssl|dac|1,0|||length of subject string in chars|8161
|polcs|dac|1,1|||poll interval start value|8166
|polct|dac|1,1|||poll interval counter|8167
|prich|dac|1,0|||printer on interactive channel|8172
|prstd|dac|1,0|||tested by prtpg|8173
|prsto|dac|1,0|||standard listing option flag|8174
|prbuf|dac|1,0|||ptr to print bfr in static|8178
|precl|dac|1,0|||extended/compact listing flag|8179
|prlen|dac|1,0|||length of print buffer in chars|8180
|prlnw|dac|1,0|||length of print buffer in words|8181
|profs|dac|1,0|||offset to next location in prbuf|8182
|prtef|dac|1,0|||endfile flag|8183
||ejc|||||8184
|rdcln|dac|1,0|||current statement line number|8188
|rdnln|dac|1,0|||next statement line number|8189
|rsmem|dac|1,0|||reserve memory|8193
|stmcs|dac|1,1|||counter startup value|8197
|stmct|dac|1,1|||counter active value|8198
|a_aaa|dac|1,0|||start of adjustable values|8220
|cmpss|dac|1,0|||save subroutine stack ptr|8221
|dnamb|dac|1,0|||start of dynamic area|8222
|dnamp|dac|1,0|||next available loc in dynamic area|8223
|dname|dac|1,0|||end of available dynamic area|8224
|hshtb|dac|1,0|||pointer to start of vrblk hash tabl|8225
|hshte|dac|1,0|||pointer past end of vrblk hash tabl|8226
|iniss|dac|1,0|||save subroutine stack ptr|8227
|pftbl|dac|1,0|||gets adrs of (imag) table base|8228
|prnmv|dac|1,0|||vrblk ptr from last name search|8229
|statb|dac|1,0|||start of static area|8230
|state|dac|1,0|||end of static area|8231
|stxvr|dac|4,nulls|||vrblk pointer or null|8232
|r_aaa|dac|1,0|||start of relocatable values|8241
|r_arf|dac|1,0|||array block pointer for arref|8242
|r_ccb|dac|1,0|||ptr to ccblk being built (cdwrd)|8243
|r_cim|dac|1,0|||ptr to current compiler input str|8244
|r_cmp|dac|1,0|||copy of r_cim used in cmpil|8245
|r_cni|dac|1,0|||ptr to next compiler input string|8246
|r_cnt|dac|1,0|||cdblk pointer for setexit continue|8247
|r_cod|dac|1,0|||pointer to current cdblk or exblk|8248
|r_ctp|dac|1,0|||ptr to current ctblk for patst|8249
|r_cts|dac|1,0|||ptr to last string scanned by patst|8250
|r_ert|dac|1,0|||trblk pointer for errtype trace|8251
|r_etx|dac|4,nulls|||pointer to errtext string|8252
|r_exs|dac|1,0|||= save xl in expdm|8253
|r_fcb|dac|1,0|||fcblk chain head|8254
|r_fnc|dac|1,0|||trblk pointer for fnclevel trace|8255
|r_gtc|dac|1,0|||keep code ptr for gtcod,gtexp|8256
|r_ici|dac|1,0|||saved r_cim during include process.|8258
|r_ifa|dac|1,0|||array of file names by incl. depth|8260
|r_ifl|dac|1,0|||array of line nums by include depth|8261
|r_ifn|dac|1,0|||last include file name|8263
|r_inc|dac|1,0|||table of include file names seen|8264
|r_io1|dac|1,0|||file arg1 for ioput|8266
|r_io2|dac|1,0|||file arg2 for ioput|8267
|r_iof|dac|1,0|||fcblk ptr or 0|8268
|r_ion|dac|1,0|||name base ptr|8269
|r_iop|dac|1,0|||predecessor block ptr for ioput|8270
|r_iot|dac|1,0|||trblk ptr for ioput|8271
|r_pms|dac|1,0|||subject string ptr in pattern match|8276
|r_ra2|dac|1,0|||replace second argument last time|8277
|r_ra3|dac|1,0|||replace third argument last time|8278
|r_rpt|dac|1,0|||ptr to ctblk replace table last usd|8279
|r_scp|dac|1,0|||save pointer from last scane call|8280
|r_sfc|dac|4,nulls|||current source file name|8282
|r_sfn|dac|1,0|||ptr to source file name table|8283
|r_sxl|dac|1,0|||preserve xl in sortc|8285
|r_sxr|dac|1,0|||preserve xr in sorta/sortc|8286
|r_stc|dac|1,0|||trblk pointer for stcount trace|8287
|r_stl|dac|1,0|||source listing sub-title|8288
|r_sxc|dac|1,0|||code (cdblk) ptr for setexit trap|8289
|r_ttl|dac|4,nulls|||source listing title|8290
|r_xsc|dac|1,0|||string pointer for xscan|8291
||ejc|||||8292
|r_uba|dac|4,stndo|||binary at|8297
|r_ubm|dac|4,stndo|||binary ampersand|8298
|r_ubn|dac|4,stndo|||binary number sign|8299
|r_ubp|dac|4,stndo|||binary percent|8300
|r_ubt|dac|4,stndo|||binary not|8301
|r_uub|dac|4,stndo|||unary vertical bar|8302
|r_uue|dac|4,stndo|||unary equal|8303
|r_uun|dac|4,stndo|||unary number sign|8304
|r_uup|dac|4,stndo|||unary percent|8305
|r_uus|dac|4,stndo|||unary slash|8306
|r_uux|dac|4,stndo|||unary exclamation|8307
|r_yyy|dac|1,0|||last relocatable location|8308
|scnbl|dac|1,0|||set non-zero if scanned past blanks|8312
|scncc|dac|1,0|||non-zero to scan control card name|8313
|scngo|dac|1,0|||set non-zero to scan goto field|8314
|scnil|dac|1,0|||length of current input image|8315
|scnpt|dac|1,0|||pointer to next location in r_cim|8316
|scnrs|dac|1,0|||set non-zero to signal rescan|8317
|scnse|dac|1,0|||start of current element|8318
|scntp|dac|1,0|||save syntax type from last call|8319
|stage|dac|1,0|||initial value = initial compile|8323
||ejc|||||8324
|stbas|dac|1,0|||pointer past stack base|8328
|stxoc|dac|1,0|||code pointer offset|8332
|stxof|dac|1,0|||failure offset|8333
|timsx|dic|16,+0|||time at start of execution|8337
|timup|dac|1,0|||set when time up occurs|8338
|xsofs|dac|1,0|||offset to current location in r_xsc|8342
|w_yyy|dac|1,0||||8346
||ttl|27,s p i t b o l -- minimal code||||8347
||sec||||start of program section|8348
|s_aaa|ent|2,bl__i|||mark start of code|8349
||ttl|27,s p i t b o l -- relocation||||8351
|relaj|prc|25,e|1,0||entry point|8367
||mov|11,-(xs)|7,xr||save xr|8368
||mov|11,-(xs)|8,wa||save wa|8369
||mov|3,rlals|7,xl||save ptr to list of bounds|8370
||mov|7,xr|8,wb||ptr to first pointer to process|8371
|rlaj0|mov|7,xl|3,rlals||restore xl|8375
||bne|7,xr|9,(xs)|6,rlaj1|proceed if more to do|8376
||mov|8,wa|10,(xs)+||restore wa|8377
||mov|7,xr|10,(xs)+||restore xr|8378
||exi||||return to caller|8379
|rlaj1|mov|8,wa|9,(xr)||load next pointer on list|8383
||lct|8,wb|18,=rnsi_||number of sections of adjusters|8384
|rlaj2|bgt|8,wa|13,rlend(xl)|6,rlaj3|ok if past end of section|8388
||blt|8,wa|13,rlstr(xl)|6,rlaj3|or if before start of section|8389
||add|8,wa|13,rladj(xl)||within section, add adjustment|8390
||mov|9,(xr)|8,wa||return updated ptr to memory|8391
||brn|6,rlaj4|||done with this pointer|8392
|rlaj3|add|7,xl|19,*rssi_||advance to next section|8396
||bct|8,wb|6,rlaj2||jump if more to go|8397
|rlaj4|ica|7,xr|||increment to next ptr on list|8401
||brn|6,rlaj0|||jump to check  for completion|8402
||enp||||end procedure relaj|8403
||ejc|||||8404
|relcr|prc|25,e|1,0||entry point|8425
||add|7,xl|19,*rlsi_||point past build area|8426
||mov|11,-(xl)|8,wa||save original code address|8427
||mov|8,wa|22,=s_aaa||compute adjustment|8428
||sub|8,wa|9,(xl)||as new s_aaa minus original s_aaa|8429
||mov|11,-(xl)|8,wa||save code adjustment|8430
||mov|8,wa|22,=s_yyy||end of target code section|8431
||sub|8,wa|22,=s_aaa||length of code section|8432
||add|8,wa|13,num01(xl)||plus original start address|8433
||mov|11,-(xl)|8,wa||end of original code section|8434
||mov|11,-(xl)|8,wb||save constant section address|8435
||mov|8,wb|21,=c_aaa||start of constants section|8436
||mov|8,wa|21,=c_yyy||end of constants section|8437
||sub|8,wa|8,wb||length of constants section|8438
||sub|8,wb|9,(xl)||new c_aaa minus original c_aaa|8439
||mov|11,-(xl)|8,wb||save constant adjustment|8440
||add|8,wa|13,num01(xl)||length plus original start adr|8441
||mov|11,-(xl)|8,wa||save as end of original constants|8442
||mov|11,-(xl)|8,wc||save working globals address|8443
||mov|8,wc|20,=g_aaa||start of working globals section|8444
||mov|8,wa|20,=w_yyy||end of working section|8445
||sub|8,wa|8,wc||length of working globals|8446
||sub|8,wc|9,(xl)||new g_aaa minus original g_aaa|8447
||mov|11,-(xl)|8,wc||save working globals adjustment|8448
||add|8,wa|13,num01(xl)||length plus original start adr|8449
||mov|11,-(xl)|8,wa||save as end of working globals|8450
||mov|8,wb|3,statb||old start of static region|8451
||mov|11,-(xl)|8,wb||save|8452
||sub|7,xr|8,wb||compute adjustment|8453
||mov|11,-(xl)|7,xr||save new statb minus old statb|8454
||mov|11,-(xl)|3,state||old end of static region|8455
||mov|8,wb|3,dnamb||old start of dynamic region|8456
||mov|11,-(xl)|8,wb||save|8457
||scp|8,wa|||new start of dynamic|8458
||sub|8,wa|8,wb||compute adjustment|8459
||mov|11,-(xl)|8,wa||save new dnamb minus old dnamb|8460
||mov|8,wc|3,dnamp||old end of dynamic region in use|8461
||mov|11,-(xl)|8,wc||save as end of old dynamic region|8462
||exi|||||8463
||enp|||||8464
||ejc|||||8465
|reldn|prc|25,e|1,0||entry point|8480
||mov|3,rldcd|13,rlcda(xl)||save code adjustment|8481
||mov|3,rldst|13,rlsta(xl)||save static adjustment|8482
||mov|3,rldls|7,xl||save list pointer|8483
|rld01|add|9,(xr)|3,rldcd||adjust block type word|8487
||mov|7,xl|9,(xr)||load block type word|8488
||lei|7,xl|||load entry point id (bl_xx)|8489
||ejc|||||8502
||bsw|7,xl|2,bl___||switch on block type|8506
||iff|2,bl_ar|6,rld03||arblk|8543
||iff|2,bl_cd|6,rld07||cdblk|8543
||iff|2,bl_ex|6,rld10||exblk|8543
||iff|2,bl_ic|6,rld05||icblk|8543
||iff|2,bl_nm|6,rld13||nmblk|8543
||iff|2,bl_p0|6,rld13||p0blk|8543
||iff|2,bl_p1|6,rld14||p1blk|8543
||iff|2,bl_p2|6,rld14||p2blk|8543
||iff|2,bl_rc|6,rld05||rcblk|8543
||iff|2,bl_sc|6,rld05||scblk|8543
||iff|2,bl_se|6,rld13||seblk|8543
||iff|2,bl_tb|6,rld17||tbblk|8543
||iff|2,bl_vc|6,rld17||vcblk|8543
||iff|2,bl_xn|6,rld05||xnblk|8543
||iff|2,bl_xr|6,rld20||xrblk|8543
||iff|2,bl_bc|6,rld05||bcblk - dummy to fill out iffs|8543
||iff|2,bl_pd|6,rld15||pdblk|8543
||iff|2,bl_tr|6,rld19||trblk|8543
||iff|2,bl_bf|6,rld05||bfblk|8543
||iff|2,bl_cc|6,rld05||ccblk|8543
||iff|2,bl_cm|6,rld05||cmblk|8543
||iff|2,bl_ct|6,rld05||ctblk|8543
||iff|2,bl_df|6,rld05||dfblk|8543
||iff|2,bl_ef|6,rld08||efblk|8543
||iff|2,bl_ev|6,rld09||evblk|8543
||iff|2,bl_ff|6,rld11||ffblk|8543
||iff|2,bl_kv|6,rld13||kvblk|8543
||iff|2,bl_pf|6,rld16||pfblk|8543
||iff|2,bl_te|6,rld18||teblk|8543
||esw||||end of jump table|8543
|rld03|mov|8,wa|13,arlen(xr)||load length|8547
||mov|8,wb|13,arofs(xr)||set offset to 1st reloc fld (arpro)|8548
|rld04|add|8,wa|7,xr||point past last reloc field|8557
||add|8,wb|7,xr||point to first reloc field|8558
||mov|7,xl|3,rldls||point to list of bounds|8559
||jsr|6,relaj|||adjust pointers|8560
||ejc|||||8561
|rld05|mov|8,wa|9,(xr)||block type word|8571
||jsr|6,blkln|||get length of block|8572
||add|7,xr|8,wa||point to next block|8573
||blt|7,xr|8,wc|6,rld01|continue if more to process|8574
||mov|7,xl|3,rldls||restore xl|8575
||exi||||return to caller if done|8576
|rld07|mov|8,wa|13,cdlen(xr)||load length|8589
||mov|8,wb|19,*cdfal||set offset|8590
||bne|9,(xr)|22,=b_cdc|6,rld04|jump back if not complex goto|8591
||mov|8,wb|19,*cdcod||do not process cdfal word|8592
||brn|6,rld04|||jump back|8593
|rld08|mov|8,wa|19,*efrsl||set length|8601
||mov|8,wb|19,*efcod||and offset|8602
||brn|6,rld04|||all set|8603
|rld09|mov|8,wa|19,*offs3||point past third field|8607
||mov|8,wb|19,*evexp||set offset|8608
||brn|6,rld04|||all set|8609
|rld10|mov|8,wa|13,exlen(xr)||load length|8613
||mov|8,wb|19,*exflc||set offset|8614
||brn|6,rld04|||jump back|8615
||ejc|||||8616
|rld11|bne|13,ffofs(xr)|19,*pdfld|6,rld12|skip dfblk if not first field|8630
||mov|11,-(xs)|7,xr||save xr|8631
||mov|7,xr|13,ffdfp(xr)||load old ptr to dfblk|8632
||add|7,xr|3,rldst||current location of dfblk|8633
||add|9,(xr)|3,rldcd||adjust dfblk type word|8634
||mov|8,wa|13,dflen(xr)||length of dfblk|8635
||mov|8,wb|19,*dfnam||offset to dfnam field|8636
||add|8,wa|7,xr||point past last reloc field|8637
||add|8,wb|7,xr||point to first reloc field|8638
||mov|7,xl|3,rldls||point to list of bounds|8639
||jsr|6,relaj|||adjust pointers|8640
||mov|7,xr|13,dfnam(xr)||pointer to static scblk|8641
||add|9,(xr)|3,rldcd||adjust scblk type word|8642
||mov|7,xr|10,(xs)+||restore ffblk pointer|8643
|rld12|mov|8,wa|19,*ffofs||set length|8649
||mov|8,wb|19,*ffdfp||set offset|8650
||brn|6,rld04|||all set|8651
|rld13|mov|8,wa|19,*offs2||point past second field|8655
||mov|8,wb|19,*offs1||offset is one (only reloc fld is 2)|8656
||brn|6,rld04|||all set|8657
|rld14|mov|8,wa|19,*parm2||length (parm2 is non-relocatable)|8664
||mov|8,wb|19,*pthen||set offset|8665
||brn|6,rld04|||all set|8666
|rld15|mov|7,xl|13,pddfp(xr)||load ptr to dfblk|8676
||add|7,xl|3,rldst||adjust for static relocation|8677
||mov|8,wa|13,dfpdl(xl)||get pdblk length|8678
||mov|8,wb|19,*pddfp||set offset|8679
||brn|6,rld04|||all set|8680
||ejc|||||8681
|rld16|add|13,pfvbl(xr)|3,rldst||adjust non-contiguous field|8688
||mov|8,wa|13,pflen(xr)||get pfblk length|8689
||mov|8,wb|19,*pfcod||offset to first reloc|8690
||brn|6,rld04|||all set|8691
|rld17|mov|8,wa|13,offs2(xr)||load length|8695
||mov|8,wb|19,*offs3||set offset|8696
||brn|6,rld04|||jump back|8697
|rld18|mov|8,wa|19,*tesi_||set length|8701
||mov|8,wb|19,*tesub||and offset|8702
||brn|6,rld04|||all set|8703
|rld19|mov|8,wa|19,*trsi_||set length|8707
||mov|8,wb|19,*trval||and offset|8708
||brn|6,rld04|||all set|8709
|rld20|mov|8,wa|13,xrlen(xr)||load length|8713
||mov|8,wb|19,*xrptr||set offset|8714
||brn|6,rld04|||jump back|8715
||enp||||end procedure reldn|8716
||ejc|||||8717
|reloc|prc|25,e|1,0||entry point|8729
||mov|7,xr|13,rldys(xl)||old start of dynamic|8730
||mov|8,wc|13,rldye(xl)||old end of dynamic|8731
||add|7,xr|13,rldya(xl)||create new start of dynamic|8732
||add|8,wc|13,rldya(xl)||create new end of dynamic|8733
||jsr|6,reldn|||relocate pointers in dynamic|8734
||jsr|6,relws|||relocate pointers in working sect|8735
||jsr|6,relst|||relocate pointers in static|8736
||exi||||return to caller|8737
||enp||||end procedure reloc|8738
||ejc|||||8739
|relst|prc|25,e|1,0||entry point|8754
||mov|7,xr|3,pftbl||profile table|8755
||bze|7,xr|6,rls01||branch if no table allocated|8756
||add|9,(xr)|13,rlcda(xl)||adjust block type word|8757
|rls01|mov|8,wc|3,hshtb||point to start of hash table|8761
||mov|8,wb|8,wc||point to first hash bucket|8762
||mov|8,wa|3,hshte||point beyond hash table|8763
||jsr|6,relaj|||adjust bucket pointers|8764
|rls02|beq|8,wc|3,hshte|6,rls05|done if none left|8768
||mov|7,xr|8,wc||else copy slot pointer|8769
||ica|8,wc|||bump slot pointer|8770
||sub|7,xr|19,*vrnxt||set offset to merge into loop|8771
|rls03|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|8775
||bze|7,xr|6,rls02||jump for next bucket if chain end|8776
||mov|8,wa|19,*vrlen||offset of first loc past ptr fields|8777
||mov|8,wb|19,*vrget||offset of first location in vrblk|8778
||bnz|13,vrlen(xr)|6,rls04||jump if not system variable|8779
||mov|8,wa|19,*vrsi_||offset to include vrsvp field|8780
|rls04|add|8,wa|7,xr||create end ptr|8784
||add|8,wb|7,xr||create start ptr|8785
||jsr|6,relaj|||adjust pointers in vrblk|8786
||brn|6,rls03|||check for another vrblk on chain|8787
|rls05|exi||||return to caller|8791
||enp||||end procedure relst|8792
||ejc|||||8793
|relws|prc|25,e|1,0||entry point|8809
||mov|8,wb|20,=a_aaa||point to start of adjustables|8810
||mov|8,wa|20,=r_yyy||point to end of adjustables|8811
||jsr|6,relaj|||relocate adjustable pointers|8812
||add|3,dname|13,rldya(xl)||adjust ptr missed by relaj|8813
||mov|8,wb|20,=kvrtn||case of kvrtn|8814
||mov|8,wa|8,wb||handled specially|8815
||ica|8,wa|||one value to adjust|8816
||jsr|6,relaj|||adjust kvrtn|8817
||exi||||return to caller|8818
||enp||||end procedure relws|8819
||ttl|27,s p i t b o l -- initialization||||8821
|start|prc|25,e|1,0||entry point|8831
||mov|3,mxint|8,wb|||8832
||mov|4,bitsm|8,wb|||8833
||zer|8,wb||||8834
||mov|7,xs|8,wa||discard return|8836
||jsr|6,systm|||initialise timer|8837
||sti|3,timsx|||store time|8840
||mov|3,statb|7,xr||start address of static|8841
||mov|3,rsmem|19,*e_srs||reserve memory|8893
||mov|3,stbas|7,xs||store stack base|8894
||sss|3,iniss|||save s-r stack ptr|8895
||ldi|4,intvh|||get 100|8900
||dvi|4,alfsp|||form 100 / alfsp|8901
||sti|3,alfsf|||store the factor|8902
||ldi|4,intvh|||get 100|8908
||dvi|4,gbsdp|||form 100 / gbsdp|8909
||sti|3,gbsed|||store the factor|8910
||lct|8,wb|18,=cfp_s||load counter for significant digits|8919
||ldr|4,reav1|||load 1.0|8920
|ini03|mlr|4,reavt|||* 10.0|8924
||bct|8,wb|6,ini03||loop till done|8925
||str|3,gtssc|||store 10**(max sig digits)|8926
||ldr|4,reap5|||load 0.5|8927
||dvr|3,gtssc|||compute 0.5*10**(max sig digits)|8928
||str|3,gtsrn|||store as rounding bias|8929
||zer|8,wc|||set to read parameters|8932
||jsr|6,prpar|||read them|8933
||ejc|||||8934
||sub|7,xl|19,*e_srs||allow for reserve memory|8939
||mov|8,wa|3,prlen||get print buffer length|8940
||add|8,wa|18,=cfp_a||add no. of chars in alphabet|8941
||add|8,wa|18,=nstmx||add chars for gtstg bfr|8942
||ctb|8,wa|1,8||convert to bytes, allowing a margin|8943
||mov|7,xr|3,statb||point to static base|8944
||add|7,xr|8,wa||increment for above buffers|8945
||add|7,xr|19,*e_hnb||increment for hash table|8946
||add|7,xr|19,*e_sts||bump for initial static block|8947
||jsr|6,sysmx|||get mxlen|8948
||mov|3,kvmxl|8,wa||provisionally store as maxlngth|8949
||mov|3,mxlen|8,wa||and as mxlen|8950
||bgt|7,xr|8,wa|6,ini06|skip if static hi exceeds mxlen|8951
||ctb|8,wa|1,1||round up and make bigger than mxlen|8952
||mov|7,xr|8,wa||use it instead|8953
|ini06|mov|3,dnamb|7,xr||dynamic base adrs|8958
||mov|3,dnamp|7,xr||dynamic ptr|8959
||bnz|8,wa|6,ini07||skip if non-zero mxlen|8960
||dca|7,xr|||point a word in front|8961
||mov|3,kvmxl|7,xr||use as maxlngth|8962
||mov|3,mxlen|7,xr||and as mxlen|8963
||ejc|||||8964
|ini07|mov|3,dname|7,xl||store dynamic end address|8969
||blt|3,dnamb|7,xl|6,ini09|skip if high enough|8970
||jsr|6,sysmm|||request more memory|8971
||wtb|7,xr|||get as baus (sgd05)|8972
||add|7,xl|7,xr||bump by amount obtained|8973
||bnz|7,xr|6,ini07||try again|8974
||mov|8,wa|18,=mxern||insufficient memory for maxlength|8976
||zer|8,wb|||no column number info|8977
||zer|8,wc|||no line number info|8978
||mov|7,xr|18,=stgic||initial compile stage|8979
||mov|7,xl|21,=nulls||no file name|8981
||jsr|6,sysea|||advise of error|8983
||ppm|6,ini08|||cant use error logic yet|8984
||brn|6,ini08|||force termination|8985
||erb|1,329|26,requested maxlngth too large|||8989
|ini08|mov|7,xr|21,=endmo||point to failure message|8991
||mov|8,wa|4,endml||message length|8992
||jsr|6,syspr|||print it (prtst not yet usable)|8993
||ppm||||should not fail|8994
||zer|7,xl|||no fcb chain yet|8995
||mov|8,wb|18,=num10||set special code value|8996
||jsr|6,sysej|||pack up (stopr not yet usable)|8997
|ini09|mov|7,xr|3,statb||point to static again|9001
||jsr|6,insta|||initialize static|9002
||mov|8,wa|18,=e_hnb||get number of hash headers|9006
||mti|8,wa|||convert to integer|9007
||sti|3,hshnb|||store for use by gtnvr procedure|9008
||lct|8,wa|8,wa||counter for clearing hash table|9009
||mov|3,hshtb|7,xr||pointer to hash table|9010
|ini11|zer|10,(xr)+|||blank a word|9014
||bct|8,wa|6,ini11||loop|9015
||mov|3,hshte|7,xr||end of hash table adrs is kept|9016
||mov|3,state|7,xr||store static end address|9017
||mov|8,wc|18,=num01||table will have only one bucket|9022
||mov|7,xl|21,=nulls||default table value|9023
||mov|3,r_sfc|7,xl||current source file name|9024
||jsr|6,tmake|||create table|9025
||mov|3,r_sfn|7,xr||save ptr to table|9026
||mov|8,wc|18,=num01||table will have only one bucket|9032
||mov|7,xl|21,=nulls||default table value|9033
||jsr|6,tmake|||create table|9034
||mov|3,r_inc|7,xr||save ptr to table|9035
||mov|8,wa|18,=ccinm||maximum nesting level|9040
||mov|7,xl|21,=nulls||null string default value|9041
||jsr|6,vmake|||create array|9042
||ppm|||||9043
||mov|3,r_ifa|7,xr||save ptr to array|9044
||mov|8,wa|18,=ccinm||maximum nesting level|9048
||mov|7,xl|21,=inton||integer one default value|9049
||jsr|6,vmake|||create array|9050
||ppm|||||9051
||mov|3,r_ifl|7,xr||save ptr to array|9052
||mov|7,xl|21,=v_inp||point to string /input/|9059
||mov|8,wb|18,=trtin||trblk type for input|9060
||jsr|6,inout|||perform input association|9061
||mov|7,xl|21,=v_oup||point to string /output/|9062
||mov|8,wb|18,=trtou||trblk type for output|9063
||jsr|6,inout|||perform output association|9064
||mov|8,wc|3,initr||terminal flag|9065
||bze|8,wc|6,ini13||skip if no terminal|9066
||jsr|6,prpar|||associate terminal|9067
||ejc|||||9068
|ini13|jsr|6,sysdc|||call date check|9072
||mov|3,flptr|7,xs||in case stack overflows in compiler|9073
||jsr|6,cmpil|||call compiler|9077
||mov|3,r_cod|7,xr||set ptr to first code block|9078
||mov|3,r_ttl|21,=nulls||forget title|9079
||mov|3,r_stl|21,=nulls||forget sub-title|9080
||zer|3,r_cim|||forget compiler input image|9081
||zer|3,r_ccb|||forget interim code block|9082
||zer|3,cnind|||in case end occurred with include|9084
||zer|3,lstid|||listing include depth|9085
||zer|7,xl|||clear dud value|9087
||zer|8,wb|||dont shift dynamic store up|9088
||zer|3,dnams|||collect sediment too|9090
||jsr|6,gbcol|||clear garbage left from compile|9091
||mov|3,dnams|7,xr||record new sediment size|9092
||bnz|3,cpsts|6,inix0||skip if no listing of comp stats|9096
||jsr|6,prtpg|||eject page|9097
||jsr|6,prtmm|||print memory usage|9101
||mti|3,cmerc|||get count of errors as integer|9102
||mov|7,xr|21,=encm3||point to /compile errors/|9103
||jsr|6,prtmi|||print it|9104
||mti|3,gbcnt|||garbage collection count|9105
||sbi|4,intv1|||adjust for unavoidable collect|9106
||mov|7,xr|21,=stpm5||point to /storage regenerations/|9107
||jsr|6,prtmi|||print gbcol count|9108
||jsr|6,systm|||get time|9109
||sbi|3,timsx|||get compilation time|9110
||mov|7,xr|21,=encm4||point to compilation time (msec)/|9111
||jsr|6,prtmi|||print message|9112
||add|3,lstlc|18,=num05||bump line count|9113
||bze|3,headp|6,inix0||no eject if nothing printed|9115
||jsr|6,prtpg|||eject printer|9116
||ejc|||||9118
|inix0|bgt|3,cswin|18,=iniln|6,inix1|skip if not default -in72 used|9124
||mov|3,cswin|18,=inils||else use default record length|9125
|inix1|jsr|6,systm|||get time again|9129
||sti|3,timsx|||store for end run processing|9130
||zer|3,gbcnt|||initialise collect count|9131
||jsr|6,sysbx|||call before starting execution|9132
||add|3,noxeq|3,cswex||add -noexecute flag|9133
||bnz|3,noxeq|6,inix2||jump if execution suppressed|9134
|iniy0|mnz|3,headp|||mark headers out regardless|9144
||zer|11,-(xs)|||set failure location on stack|9145
||mov|3,flptr|7,xs||save ptr to failure offset word|9146
||mov|7,xr|3,r_cod||load ptr to entry code block|9147
||mov|3,stage|18,=stgxt||set stage for execute time|9148
||mov|3,polcs|18,=num01||reset interface polling interval|9150
||mov|3,polct|18,=num01||reset interface polling interval|9151
||mov|3,pfnte|3,cmpsn||copy stmts compiled count in case|9155
||mov|3,pfdmp|3,kvpfl||start profiling if &profile set|9156
||jsr|6,systm|||time yet again|9157
||sti|3,pfstm||||9158
||jsr|6,stgcc|||compute stmgo countdown counters|9160
||bri|9,(xr)|||start xeq with first statement|9161
|inix2|zer|8,wa|||set abend value to zero|9166
||mov|8,wb|18,=nini9||set special code value|9174
||zer|7,xl|||no fcb chain|9175
||jsr|6,sysej|||end of job, exit to system|9176
||enp||||end procedure start|9177
|rstrt|prc|25,e|1,0||entry point|9181
||mov|7,xs|3,stbas||discard return|9182
||zer|7,xl|||clear xl|9183
||brn|6,iniy0|||resume execution|9184
||enp||||end procedure rstrt|9185
||ttl|27,s p i t b o l -- snobol4 operator routines||||9187
||ejc|||||9207
|o_add|ent||||entry point|9211
||jsr|6,arith|||fetch arithmetic operands|9213
||err|1,001|26,addition left operand is not numeric|||9214
||err|1,002|26,addition right operand is not numeric|||9215
||ppm|6,oadd1|||jump if real operands|9218
||adi|13,icval(xl)|||add right operand to left|9223
||ino|6,exint|||return integer if no overflow|9224
||erb|1,003|26,addition caused integer overflow|||9225
|oadd1|adr|13,rcval(xl)|||add right operand to left|9231
||rno|6,exrea|||return real if no overflow|9232
||erb|1,261|26,addition caused real overflow|||9233
||ejc|||||9235
|o_aff|ent||||entry point|9239
||mov|7,xr|10,(xs)+||load operand|9240
||jsr|6,gtnum|||convert to numeric|9241
||err|1,004|26,affirmation operand is not numeric|||9242
||mov|11,-(xs)|7,xr||result if converted to numeric|9243
||lcw|7,xr|||get next code word|9244
||bri|9,(xr)|||execute it|9245
||ejc|||||9246
|o_alt|ent||||entry point|9250
||mov|7,xr|10,(xs)+||load right operand|9251
||jsr|6,gtpat|||convert to pattern|9252
||err|1,005|26,alternation right operand is not pattern|||9253
|oalt1|mov|8,wb|22,=p_alt||set pcode for alternative node|9257
||jsr|6,pbild|||build alternative node|9258
||mov|7,xl|7,xr||save address of alternative node|9259
||mov|7,xr|10,(xs)+||load left operand|9260
||jsr|6,gtpat|||convert to pattern|9261
||err|1,006|26,alternation left operand is not pattern|||9262
||beq|7,xr|22,=p_alt|6,oalt2|jump if left arg is alternation|9263
||mov|13,pthen(xl)|7,xr||set left operand as successor|9264
||mov|11,-(xs)|7,xl||stack result|9265
||lcw|7,xr|||get next code word|9266
||bri|9,(xr)|||execute it|9267
|oalt2|mov|13,pthen(xl)|13,parm1(xr)||build the (b / c) node|9275
||mov|11,-(xs)|13,pthen(xr)||set a as new left arg|9276
||mov|7,xr|7,xl||set (b / c) as new right arg|9277
||brn|6,oalt1|||merge back to build a / (b / c)|9278
||ejc|||||9279
|o_amn|ent||||entry point|9283
||lcw|7,xr|||load number of subscripts|9284
||mov|8,wb|7,xr||set flag for by name|9285
||brn|6,arref|||jump to array reference routine|9286
||ejc|||||9287
|o_amv|ent||||entry point|9291
||lcw|7,xr|||load number of subscripts|9292
||zer|8,wb|||set flag for by value|9293
||brn|6,arref|||jump to array reference routine|9294
||ejc|||||9295
|o_aon|ent||||entry point|9299
||mov|7,xr|9,(xs)||load subscript value|9300
||mov|7,xl|13,num01(xs)||load array value|9301
||mov|8,wa|9,(xl)||load first word of array operand|9302
||beq|8,wa|22,=b_vct|6,oaon2|jump if vector reference|9303
||beq|8,wa|22,=b_tbt|6,oaon3|jump if table reference|9304
|oaon1|mov|7,xr|18,=num01||set number of subscripts to one|9308
||mov|8,wb|7,xr||set flag for by name|9309
||brn|6,arref|||jump to array reference routine|9310
|oaon2|bne|9,(xr)|22,=b_icl|6,oaon1|use long routine if not integer|9314
||ldi|13,icval(xr)|||load integer subscript value|9315
||mfi|8,wa|6,exfal||copy as address int, fail if ovflo|9316
||bze|8,wa|6,exfal||fail if zero|9317
||add|8,wa|18,=vcvlb||compute offset in words|9318
||wtb|8,wa|||convert to bytes|9319
||mov|9,(xs)|8,wa||complete name on stack|9320
||blt|8,wa|13,vclen(xl)|6,oaon4|exit if subscript not too large|9321
||brn|6,exfal|||else fail|9322
|oaon3|mnz|8,wb|||set flag for name reference|9326
||jsr|6,tfind|||locate/create table element|9327
||ppm|6,exfal|||fail if access fails|9328
||mov|13,num01(xs)|7,xl||store name base on stack|9329
||mov|9,(xs)|8,wa||store name offset on stack|9330
|oaon4|lcw|7,xr|||result on stack, get code word|9334
||bri|9,(xr)|||execute next code word|9335
||ejc|||||9336
|o_aov|ent||||entry point|9340
||mov|7,xr|10,(xs)+||load subscript value|9341
||mov|7,xl|10,(xs)+||load array value|9342
||mov|8,wa|9,(xl)||load first word of array operand|9343
||beq|8,wa|22,=b_vct|6,oaov2|jump if vector reference|9344
||beq|8,wa|22,=b_tbt|6,oaov3|jump if table reference|9345
|oaov1|mov|11,-(xs)|7,xl||restack array value|9349
||mov|11,-(xs)|7,xr||restack subscript|9350
||mov|7,xr|18,=num01||set number of subscripts to one|9351
||zer|8,wb|||set flag for value call|9352
||brn|6,arref|||jump to array reference routine|9353
|oaov2|bne|9,(xr)|22,=b_icl|6,oaov1|use long routine if not integer|9357
||ldi|13,icval(xr)|||load integer subscript value|9358
||mfi|8,wa|6,exfal||move as one word int, fail if ovflo|9359
||bze|8,wa|6,exfal||fail if zero|9360
||add|8,wa|18,=vcvlb||compute offset in words|9361
||wtb|8,wa|||convert to bytes|9362
||bge|8,wa|13,vclen(xl)|6,exfal|fail if subscript too large|9363
||jsr|6,acess|||access value|9364
||ppm|6,exfal|||fail if access fails|9365
||mov|11,-(xs)|7,xr||stack result|9366
||lcw|7,xr|||get next code word|9367
||bri|9,(xr)|||execute it|9368
|oaov3|zer|8,wb|||set flag for value reference|9372
||jsr|6,tfind|||call table search routine|9373
||ppm|6,exfal|||fail if access fails|9374
||mov|11,-(xs)|7,xr||stack result|9375
||lcw|7,xr|||get next code word|9376
||bri|9,(xr)|||execute it|9377
||ejc|||||9378
|o_ass|ent||||entry point|9382
|oass0|mov|8,wb|10,(xs)+||load value to be assigned|9386
||mov|8,wa|10,(xs)+||load name offset|9387
||mov|7,xl|9,(xs)||load name base|9388
||mov|9,(xs)|8,wb||store assigned value as result|9389
||jsr|6,asign|||perform assignment|9390
||ppm|6,exfal|||fail if assignment fails|9391
||lcw|7,xr|||result on stack, get code word|9392
||bri|9,(xr)|||execute next code word|9393
||ejc|||||9394
|o_cer|ent||||entry point|9398
||erb|1,007|26,compilation error encountered during execution|||9399
||ejc|||||9400
|o_cas|ent||||entry point|9404
||mov|8,wc|10,(xs)+||load name offset (parm2)|9405
||mov|7,xr|10,(xs)+||load name base (parm1)|9406
||mov|8,wb|22,=p_cas||set pcode for cursor assignment|9407
||jsr|6,pbild|||build node|9408
||mov|11,-(xs)|7,xr||stack result|9409
||lcw|7,xr|||get next code word|9410
||bri|9,(xr)|||execute it|9411
||ejc|||||9412
|o_cnc|ent||||entry point|9416
||mov|7,xr|9,(xs)||load right argument|9417
||beq|7,xr|21,=nulls|6,ocnc3|jump if right arg is null|9418
||mov|7,xl|12,1(xs)||load left argument|9419
||beq|7,xl|21,=nulls|6,ocnc4|jump if left argument is null|9420
||mov|8,wa|22,=b_scl||get constant to test for string|9421
||bne|8,wa|9,(xl)|6,ocnc2|jump if left arg not a string|9422
||bne|8,wa|9,(xr)|6,ocnc2|jump if right arg not a string|9423
|ocnc1|mov|8,wa|13,sclen(xl)||load left argument length|9427
||add|8,wa|13,sclen(xr)||compute result length|9428
||jsr|6,alocs|||allocate scblk for result|9429
||mov|12,1(xs)|7,xr||store result ptr over left argument|9430
||psc|7,xr|||prepare to store chars of result|9431
||mov|8,wa|13,sclen(xl)||get number of chars in left arg|9432
||plc|7,xl|||prepare to load left arg chars|9433
||mvc||||move characters of left argument|9434
||mov|7,xl|10,(xs)+||load right arg pointer, pop stack|9435
||mov|8,wa|13,sclen(xl)||load number of chars in right arg|9436
||plc|7,xl|||prepare to load right arg chars|9437
||mvc||||move characters of right argument|9438
||zer|7,xl|||clear garbage value in xl|9439
||lcw|7,xr|||result on stack, get code word|9440
||bri|9,(xr)|||execute next code word|9441
|ocnc2|jsr|6,gtstg|||convert right arg to string|9445
||ppm|6,ocnc5|||jump if right arg is not string|9446
||mov|7,xl|7,xr||save right arg ptr|9447
||jsr|6,gtstg|||convert left arg to string|9448
||ppm|6,ocnc6|||jump if left arg is not a string|9449
||mov|11,-(xs)|7,xr||stack left argument|9450
||mov|11,-(xs)|7,xl||stack right argument|9451
||mov|7,xl|7,xr||move left arg to proper reg|9452
||mov|7,xr|9,(xs)||move right arg to proper reg|9453
||brn|6,ocnc1|||merge back to concatenate strings|9454
||ejc|||||9455
|ocnc3|ica|7,xs|||remove right arg from stack|9461
||lcw|7,xr|||left argument on stack|9462
||bri|9,(xr)|||execute next code word|9463
|ocnc4|ica|7,xs|||unstack one argument|9467
||mov|9,(xs)|7,xr||store right argument|9468
||lcw|7,xr|||result on stack, get code word|9469
||bri|9,(xr)|||execute next code word|9470
|ocnc5|mov|7,xl|7,xr||move right argument ptr|9474
||mov|7,xr|10,(xs)+||load left arg pointer|9475
|ocnc6|jsr|6,gtpat|||convert left arg to pattern|9479
||err|1,008|26,concatenation left operand is not a string or pattern|||9480
||mov|11,-(xs)|7,xr||save result on stack|9481
||mov|7,xr|7,xl||point to right operand|9482
||jsr|6,gtpat|||convert to pattern|9483
||err|1,009|26,concatenation right operand is not a string or pattern|||9484
||mov|7,xl|7,xr||move for pconc|9485
||mov|7,xr|10,(xs)+||reload left operand ptr|9486
||jsr|6,pconc|||concatenate patterns|9487
||mov|11,-(xs)|7,xr||stack result|9488
||lcw|7,xr|||get next code word|9489
||bri|9,(xr)|||execute it|9490
||ejc|||||9491
|o_com|ent||||entry point|9495
||mov|7,xr|10,(xs)+||load operand|9496
||mov|8,wa|9,(xr)||load type word|9497
|ocom1|beq|8,wa|22,=b_icl|6,ocom2|jump if integer|9501
||beq|8,wa|22,=b_rcl|6,ocom3|jump if real|9504
||jsr|6,gtnum|||else convert to numeric|9506
||err|1,010|26,negation operand is not numeric|||9507
||brn|6,ocom1|||back to check cases|9508
|ocom2|ldi|13,icval(xr)|||load integer value|9512
||ngi||||negate|9513
||ino|6,exint|||return integer if no overflow|9514
||erb|1,011|26,negation caused integer overflow|||9515
|ocom3|ldr|13,rcval(xr)|||load real value|9521
||ngr||||negate|9522
||brn|6,exrea|||return real result|9523
||ejc|||||9525
|o_dvd|ent||||entry point|9529
||jsr|6,arith|||fetch arithmetic operands|9530
||err|1,012|26,division left operand is not numeric|||9531
||err|1,013|26,division right operand is not numeric|||9532
||ppm|6,odvd2|||jump if real operands|9535
||dvi|13,icval(xl)|||divide left operand by right|9540
||ino|6,exint|||result ok if no overflow|9541
||erb|1,014|26,division caused integer overflow|||9542
|odvd2|dvr|13,rcval(xl)|||divide left operand by right|9548
||rno|6,exrea|||return real if no overflow|9549
||erb|1,262|26,division caused real overflow|||9550
||ejc|||||9552
|o_exp|ent||||entry point|9556
||mov|7,xr|10,(xs)+||load exponent|9557
||jsr|6,gtnum|||convert to number|9558
||err|1,015|26,exponentiation right operand is not numeric|||9559
||mov|7,xl|7,xr||move exponent to xl|9560
||mov|7,xr|10,(xs)+||load base|9561
||jsr|6,gtnum|||convert to numeric|9562
||err|1,016|26,exponentiation left operand is not numeric|||9563
||beq|9,(xl)|22,=b_rcl|6,oexp7|jump if real exponent|9566
||ldi|13,icval(xl)|||load exponent|9568
||ilt|6,oex12|||jump if negative exponent|9569
||beq|8,wa|22,=b_rcl|6,oexp3|jump if base is real|9572
||mfi|8,wa|6,oexp2||convert exponent to 1 word integer|9577
||lct|8,wa|8,wa||set loop counter|9578
||ldi|13,icval(xr)|||load base as initial value|9579
||bnz|8,wa|6,oexp1||jump into loop if non-zero exponent|9580
||ieq|6,oexp4|||error if 0**0|9581
||ldi|4,intv1|||nonzero**0|9582
||brn|6,exint|||give one as result for nonzero**0|9583
|oex13|mli|13,icval(xr)|||multiply by base|9587
||iov|6,oexp2|||jump if overflow|9588
|oexp1|bct|8,wa|6,oex13||loop if more to go|9589
||brn|6,exint|||else return integer result|9590
|oexp2|erb|1,017|26,exponentiation caused integer overflow|||9594
||ejc|||||9595
|oexp3|mfi|8,wa|6,oexp6||convert exponent to one word|9603
||lct|8,wa|8,wa||set loop counter|9604
||ldr|13,rcval(xr)|||load base as initial value|9605
||bnz|8,wa|6,oexp5||jump into loop if non-zero exponent|9606
||req|6,oexp4|||error if 0.0**0|9607
||ldr|4,reav1|||nonzero**0|9608
||brn|6,exrea|||return 1.0 if nonzero**zero|9609
|oexp4|erb|1,018|26,exponentiation result is undefined|||9614
|oex14|mlr|13,rcval(xr)|||multiply by base|9620
||rov|6,oexp6|||jump if overflow|9621
|oexp5|bct|8,wa|6,oex14||loop till computation complete|9622
||brn|6,exrea|||then return real result|9623
|oexp6|erb|1,266|26,exponentiation caused real overflow|||9627
|oexp7|beq|9,(xr)|22,=b_rcl|6,oexp8|jump if base real|9632
||ldi|13,icval(xr)|||load integer base|9633
||itr||||convert to real|9634
||jsr|6,rcbld|||create real in (xr)|9635
|oexp8|zer|8,wb|||set positive result flag|9640
||ldr|13,rcval(xr)|||load base to ra|9641
||rne|6,oexp9|||jump if base non-zero|9642
||ldr|13,rcval(xl)|||base is zero.  check exponent|9643
||req|6,oexp4|||jump if 0.0 ** 0.0|9644
||ldr|4,reav0|||0.0 to non-zero exponent yields 0.0|9645
||brn|6,exrea|||return zero result|9646
|oexp9|rgt|6,oex10|||jump if base gt 0.0|9652
||ngr||||make base positive|9653
||jsr|6,rcbld|||create positive base in (xr)|9654
||ldr|13,rcval(xl)|||examine exponent|9655
||chp||||chop to integral value|9656
||rti|6,oexp6|||convert to integer, br if too large|9657
||sbr|13,rcval(xl)|||chop(exponent) - exponent|9658
||rne|6,oex11|||non-integral power with neg base|9659
||mfi|8,wb|||record even/odd exponent|9660
||anb|8,wb|4,bits1||odd exponent yields negative result|9661
||ldr|13,rcval(xr)|||restore base to ra|9662
|oex10|lnf||||log of base|9666
||rov|6,oexp6|||too large|9667
||mlr|13,rcval(xl)|||times exponent|9668
||rov|6,oexp6|||too large|9669
||etx||||e ** (exponent * ln(base))|9670
||rov|6,oexp6|||too large|9671
||bze|8,wb|6,exrea||if no sign fixup required|9672
||ngr||||negative result needed|9673
||brn|6,exrea||||9674
|oex11|erb|1,311|26,exponentiation of negative base to non-integral power|||9678
|oex12|mov|11,-(xs)|7,xr||stack base|9687
||itr||||convert to real exponent|9688
||jsr|6,rcbld|||real negative exponent in (xr)|9689
||mov|7,xl|7,xr||put exponent in xl|9690
||mov|7,xr|10,(xs)+||restore base value|9691
||brn|6,oexp7|||process real exponent|9692
||ejc|||||9696
|o_fex|ent||||entry point|9704
||brn|6,evlx6|||jump to failure loc in evalx|9705
||ejc|||||9706
|o_fif|ent||||entry point|9710
||erb|1,020|26,goto evaluation failure|||9711
||ejc|||||9712
|o_fnc|ent||||entry point|9716
||lcw|8,wa|||load number of arguments|9717
||lcw|7,xr|||load function vrblk pointer|9718
||mov|7,xl|13,vrfnc(xr)||load function pointer|9719
||bne|8,wa|13,fargs(xl)|6,cfunc|use central routine if wrong num|9720
||bri|9,(xl)|||jump to function if arg count ok|9721
||ejc|||||9722
|o_fne|ent||||entry point|9726
||lcw|8,wa|||get next code word|9727
||bne|8,wa|21,=ornm_|6,ofne1|fail if not evaluating expression|9728
||bze|13,num02(xs)|6,evlx3||ok if expr. was wanted by value|9729
|ofne1|erb|1,021|26,function called by name returned a value|||9733
||ejc|||||9734
|o_fns|ent||||entry point|9738
||lcw|7,xr|||load function vrblk pointer|9739
||mov|8,wa|18,=num01||set number of arguments to one|9740
||mov|7,xl|13,vrfnc(xr)||load function pointer|9741
||bne|8,wa|13,fargs(xl)|6,cfunc|use central routine if wrong num|9742
||bri|9,(xl)|||jump to function if arg count ok|9743
||ejc|||||9744
|o_fun|ent||||entry point|9747
||erb|1,022|26,undefined function called|||9748
||ejc|||||9749
|o_goc|ent||||entry point|9753
||mov|7,xr|13,num01(xs)||load name base pointer|9754
||bhi|7,xr|3,state|6,ogoc1|jump if not natural variable|9755
||add|7,xr|19,*vrtra||else point to vrtra field|9756
||bri|9,(xr)|||and jump through it|9757
|ogoc1|erb|1,023|26,goto operand is not a natural variable|||9761
||ejc|||||9762
|o_god|ent||||entry point|9766
||mov|7,xr|9,(xs)||load operand|9767
||mov|8,wa|9,(xr)||load first word|9768
||beq|8,wa|22,=b_cds|6,bcds0|jump if code block to code routine|9769
||beq|8,wa|22,=b_cdc|6,bcdc0|jump if code block to code routine|9770
||erb|1,024|26,goto operand in direct goto is not code|||9771
||ejc|||||9772
|o_gof|ent||||entry point|9779
||mov|7,xr|3,flptr||point to fail offset on stack|9780
||ica|9,(xr)|||point failure to o_fif word|9781
||icp||||point to next code word|9782
||lcw|7,xr|||fetch next code word|9783
||bri|9,(xr)|||execute it|9784
||ejc|||||9785
|o_ima|ent||||entry point|9793
||mov|8,wb|22,=p_imc||set pcode for last node|9794
||mov|8,wc|10,(xs)+||pop name offset (parm2)|9795
||mov|7,xr|10,(xs)+||pop name base (parm1)|9796
||jsr|6,pbild|||build p_imc node|9797
||mov|7,xl|7,xr||save ptr to node|9798
||mov|7,xr|9,(xs)||load left argument|9799
||jsr|6,gtpat|||convert to pattern|9800
||err|1,025|26,immediate assignment left operand is not pattern|||9801
||mov|9,(xs)|7,xr||save ptr to left operand pattern|9802
||mov|8,wb|22,=p_ima||set pcode for first node|9803
||jsr|6,pbild|||build p_ima node|9804
||mov|13,pthen(xr)|10,(xs)+||set left operand as p_ima successor|9805
||jsr|6,pconc|||concatenate to form final pattern|9806
||mov|11,-(xs)|7,xr||stack result|9807
||lcw|7,xr|||get next code word|9808
||bri|9,(xr)|||execute it|9809
||ejc|||||9810
|o_inn|ent||||entry point|9814
||mnz|8,wb|||set flag for result by name|9815
||brn|6,indir|||jump to common routine|9816
||ejc|||||9817
|o_int|ent||||entry point|9821
||mov|9,(xs)|21,=nulls||replace operand with null|9822
||lcw|7,xr|||get next code word|9823
||bri|9,(xr)|||execute next code word|9824
||ejc|||||9825
|o_inv|ent||||entry point|9829
||zer|8,wb|||set flag for by value|9830
||brn|6,indir|||jump to common routine|9831
||ejc|||||9832
|o_kwn|ent||||entry point|9836
||jsr|6,kwnam|||get keyword name|9837
||brn|6,exnam|||exit with result name|9838
||ejc|||||9839
|o_kwv|ent||||entry point|9843
||jsr|6,kwnam|||get keyword name|9844
||mov|3,dnamp|7,xr||delete kvblk|9845
||jsr|6,acess|||access value|9846
||ppm|6,exnul|||dummy (unused) failure return|9847
||mov|11,-(xs)|7,xr||stack result|9848
||lcw|7,xr|||get next code word|9849
||bri|9,(xr)|||execute it|9850
||ejc|||||9851
|o_lex|ent||||entry point|9855
||mov|8,wa|19,*evsi_||set size of evblk|9856
||jsr|6,alloc|||allocate space for evblk|9857
||mov|9,(xr)|22,=b_evt||set type word|9858
||mov|13,evvar(xr)|21,=trbev||set dummy trblk pointer|9859
||lcw|8,wa|||load exblk pointer|9860
||mov|13,evexp(xr)|8,wa||set exblk pointer|9861
||mov|7,xl|7,xr||move name base to proper reg|9862
||mov|8,wa|19,*evvar||set name offset = zero|9863
||brn|6,exnam|||exit with name in (xl,wa)|9864
||ejc|||||9865
|o_lpt|ent||||entry point|9869
||lcw|7,xr|||load pattern pointer|9870
||mov|11,-(xs)|7,xr||stack result|9871
||lcw|7,xr|||get next code word|9872
||bri|9,(xr)|||execute it|9873
||ejc|||||9874
|o_lvn|ent||||entry point|9878
||lcw|8,wa|||load vrblk pointer|9879
||mov|11,-(xs)|8,wa||stack vrblk ptr (name base)|9880
||mov|11,-(xs)|19,*vrval||stack name offset|9881
||lcw|7,xr|||get next code word|9882
||bri|9,(xr)|||execute next code word|9883
||ejc|||||9884
|o_mlt|ent||||entry point|9888
||jsr|6,arith|||fetch arithmetic operands|9889
||err|1,026|26,multiplication left operand is not numeric|||9890
||err|1,027|26,multiplication right operand is not numeric|||9891
||ppm|6,omlt1|||jump if real operands|9894
||mli|13,icval(xl)|||multiply left operand by right|9899
||ino|6,exint|||return integer if no overflow|9900
||erb|1,028|26,multiplication caused integer overflow|||9901
|omlt1|mlr|13,rcval(xl)|||multiply left operand by right|9907
||rno|6,exrea|||return real if no overflow|9908
||erb|1,263|26,multiplication caused real overflow|||9909
||ejc|||||9911
|o_nam|ent||||entry point|9915
||mov|8,wa|19,*nmsi_||set length of nmblk|9916
||jsr|6,alloc|||allocate nmblk|9917
||mov|9,(xr)|22,=b_nml||set name block code|9918
||mov|13,nmofs(xr)|10,(xs)+||set name offset from operand|9919
||mov|13,nmbas(xr)|10,(xs)+||set name base from operand|9920
||mov|11,-(xs)|7,xr||stack result|9921
||lcw|7,xr|||get next code word|9922
||bri|9,(xr)|||execute it|9923
||ejc|||||9924
|o_nta|ent||||entry point|9930
||lcw|8,wa|||load new failure offset|9931
||mov|11,-(xs)|3,flptr||stack old failure pointer|9932
||mov|11,-(xs)|8,wa||stack new failure offset|9933
||mov|3,flptr|7,xs||set new failure pointer|9934
||lcw|7,xr|||get next code word|9935
||bri|9,(xr)|||execute next code word|9936
|o_ntb|ent||||entry point|9940
||mov|3,flptr|13,num02(xs)||restore old failure pointer|9941
||brn|6,exfal|||and fail|9942
|o_ntc|ent||||entry point|9946
||ica|7,xs|||pop failure offset|9947
||mov|3,flptr|10,(xs)+||restore old failure pointer|9948
||brn|6,exnul|||exit giving null result|9949
||ejc|||||9950
|o_oun|ent||||entry point|9954
||erb|1,029|26,undefined operator referenced|||9955
||ejc|||||9956
|o_pas|ent||||entry point|9964
||mov|8,wb|22,=p_pac||load pcode for p_pac node|9965
||mov|8,wc|10,(xs)+||load name offset (parm2)|9966
||mov|7,xr|10,(xs)+||load name base (parm1)|9967
||jsr|6,pbild|||build p_pac node|9968
||mov|7,xl|7,xr||save ptr to node|9969
||mov|7,xr|9,(xs)||load left operand|9970
||jsr|6,gtpat|||convert to pattern|9971
||err|1,030|26,pattern assignment left operand is not pattern|||9972
||mov|9,(xs)|7,xr||save ptr to left operand pattern|9973
||mov|8,wb|22,=p_paa||set pcode for p_paa node|9974
||jsr|6,pbild|||build p_paa node|9975
||mov|13,pthen(xr)|10,(xs)+||set left operand as p_paa successor|9976
||jsr|6,pconc|||concatenate to form final pattern|9977
||mov|11,-(xs)|7,xr||stack result|9978
||lcw|7,xr|||get next code word|9979
||bri|9,(xr)|||execute it|9980
||ejc|||||9981
|o_pmn|ent||||entry point|9985
||zer|8,wb|||set type code for match by name|9986
||brn|6,match|||jump to routine to start match|9987
||ejc|||||9988
|o_pms|ent||||entry point|9996
||mov|8,wb|18,=num02||set flag for statement to match|9997
||brn|6,match|||jump to routine to start match|9998
||ejc|||||9999
|o_pmv|ent||||entry point|10003
||mov|8,wb|18,=num01||set type code for value match|10004
||brn|6,match|||jump to routine to start match|10005
||ejc|||||10006
|o_pop|ent||||entry point|10010
||ica|7,xs|||pop top stack entry|10011
||lcw|7,xr|||get next code word|10012
||bri|9,(xr)|||execute next code word|10013
||ejc|||||10014
|o_stp|ent||||entry point|10018
||brn|6,lend0|||jump to end circuit|10019
||ejc|||||10020
|o_rnm|ent||||entry point|10027
||brn|6,evlx4|||return to evalx procedure|10028
||ejc|||||10029
|o_rpl|ent||||entry point|10043
||jsr|6,gtstg|||convert replacement val to string|10044
||err|1,031|26,pattern replacement right operand is not a string|||10045
||mov|7,xl|9,(xs)||load subject string pointer|10049
||add|8,wa|13,sclen(xl)||add subject string length|10054
||add|8,wa|13,num02(xs)||add starting cursor|10055
||sub|8,wa|13,num01(xs)||minus final cursor = total length|10056
||bze|8,wa|6,orpl3||jump if result is null|10057
||mov|11,-(xs)|7,xr||restack replacement string|10058
||jsr|6,alocs|||allocate scblk for result|10059
||mov|8,wa|13,num03(xs)||get initial cursor (part 1 len)|10060
||mov|13,num03(xs)|7,xr||stack result pointer|10061
||psc|7,xr|||point to characters of result|10062
||bze|8,wa|6,orpl1||jump if first part is null|10066
||mov|7,xl|13,num01(xs)||else point to subject string|10067
||plc|7,xl|||point to subject string chars|10068
||mvc||||move first part to result|10069
||ejc|||||10070
|orpl1|mov|7,xl|10,(xs)+||load replacement string, pop|10075
||mov|8,wa|13,sclen(xl)||load length|10076
||bze|8,wa|6,orpl2||jump if null replacement|10077
||plc|7,xl|||else point to chars of replacement|10078
||mvc||||move in chars (part 2)|10079
|orpl2|mov|7,xl|10,(xs)+||load subject string pointer, pop|10083
||mov|8,wc|10,(xs)+||load final cursor, pop|10084
||mov|8,wa|13,sclen(xl)||load subject string length|10085
||sub|8,wa|8,wc||minus final cursor = part 3 length|10086
||bze|8,wa|6,oass0||jump to assign if part 3 is null|10087
||plc|7,xl|8,wc||else point to last part of string|10088
||mvc||||move part 3 to result|10089
||brn|6,oass0|||jump to perform assignment|10090
|orpl3|add|7,xs|19,*num02||pop subject str ptr, final cursor|10094
||mov|9,(xs)|21,=nulls||set null result|10095
||brn|6,oass0|||jump to assign null value|10096
||ejc|||||10115
|o_rvl|ent||||entry point|10123
||brn|6,evlx3|||return to evalx procedure|10124
||ejc|||||10125
|o_sla|ent||||entry point|10131
||lcw|8,wa|||load new failure offset|10132
||mov|11,-(xs)|3,flptr||stack old failure pointer|10133
||mov|11,-(xs)|8,wa||stack new failure offset|10134
||mov|3,flptr|7,xs||set new failure pointer|10135
||lcw|7,xr|||get next code word|10136
||bri|9,(xr)|||execute next code word|10137
|o_slb|ent||||entry point|10141
||mov|7,xr|10,(xs)+||load result|10142
||ica|7,xs|||pop fail offset|10143
||mov|3,flptr|9,(xs)||restore old failure pointer|10144
||mov|9,(xs)|7,xr||restack result|10145
||lcw|8,wa|||load new code offset|10146
||add|8,wa|3,r_cod||point to absolute code location|10147
||lcp|8,wa|||set new code pointer|10148
||lcw|7,xr|||get next code word|10149
||bri|9,(xr)|||execute next code word|10150
|o_slc|ent||||entry point|10154
||lcw|8,wa|||load new fail offset|10155
||mov|9,(xs)|8,wa||store new fail offset|10156
||lcw|7,xr|||get next code word|10157
||bri|9,(xr)|||execute next code word|10158
|o_sld|ent||||entry point|10162
||ica|7,xs|||pop failure offset|10163
||mov|3,flptr|10,(xs)+||restore old failure pointer|10164
||lcw|7,xr|||get next code word|10165
||bri|9,(xr)|||execute next code word|10166
||ejc|||||10167
|o_sub|ent||||entry point|10171
||jsr|6,arith|||fetch arithmetic operands|10172
||err|1,032|26,subtraction left operand is not numeric|||10173
||err|1,033|26,subtraction right operand is not numeric|||10174
||ppm|6,osub1|||jump if real operands|10177
||sbi|13,icval(xl)|||subtract right operand from left|10182
||ino|6,exint|||return integer if no overflow|10183
||erb|1,034|26,subtraction caused integer overflow|||10184
|osub1|sbr|13,rcval(xl)|||subtract right operand from left|10190
||rno|6,exrea|||return real if no overflow|10191
||erb|1,264|26,subtraction caused real overflow|||10192
||ejc|||||10194
|o_txr|ent||||entry point|10198
||brn|6,trxq1|||jump into trxeq procedure|10199
||ejc|||||10200
|o_unf|ent||||entry point|10210
||erb|1,035|26,unexpected failure in -nofail mode|||10211
||ttl|27,s p i t b o l -- block action routines||||10212
|b_aaa|ent|2,bl__i|||entry point of first block routine|10257
||ejc|||||10258
|b_exl|ent|2,bl_ex|||entry point (exblk)|10267
||mov|11,-(xs)|7,xr||stack result|10268
||lcw|7,xr|||get next code word|10269
||bri|9,(xr)|||execute it|10270
||ejc|||||10271
|b_sel|ent|2,bl_se|||entry point (seblk)|10278
||mov|11,-(xs)|7,xr||stack result|10279
||lcw|7,xr|||get next code word|10280
||bri|9,(xr)|||execute it|10281
|b_e__|ent|2,bl__i|||entry point|10285
||ejc|||||10286
|b_trt|ent|2,bl_tr|||entry point (trblk)|10292
|b_t__|ent|2,bl__i|||end of trblk,seblk,exblk entries|10296
||ejc|||||10297
|b_art|ent|2,bl_ar|||entry point (arblk)|10303
||ejc|||||10304
|b_bct|ent|2,bl_bc|||entry point (bcblk)|10312
||ejc|||||10313
|b_bft|ent|2,bl_bf|||entry point (bfblk)|10321
||ejc|||||10322
|b_cct|ent|2,bl_cc|||entry point (ccblk)|10328
||ejc|||||10329
|b_cdc|ent|2,bl_cd|||entry point (cdblk)|10340
|bcdc0|mov|7,xs|3,flptr||pop garbage off stack|10341
||mov|9,(xs)|13,cdfal(xr)||set failure offset|10342
||brn|6,stmgo|||enter stmt|10343
||ejc|||||10344
|b_cds|ent|2,bl_cd|||entry point (cdblk)|10352
|bcds0|mov|7,xs|3,flptr||pop garbage off stack|10353
||mov|9,(xs)|19,*cdfal||set failure offset|10354
||brn|6,stmgo|||enter stmt|10355
||ejc|||||10356
|b_cmt|ent|2,bl_cm|||entry point (cmblk)|10362
||ejc|||||10363
|b_ctt|ent|2,bl_ct|||entry point (ctblk)|10369
||ejc|||||10370
|b_dfc|ent|2,bl_df|||entry point|10379
||mov|8,wa|13,dfpdl(xl)||load length of pdblk|10380
||jsr|6,alloc|||allocate pdblk|10381
||mov|9,(xr)|22,=b_pdt||store type word|10382
||mov|13,pddfp(xr)|7,xl||store dfblk pointer|10383
||mov|8,wc|7,xr||save pointer to pdblk|10384
||add|7,xr|8,wa||point past pdblk|10385
||lct|8,wa|13,fargs(xl)||set to count fields|10386
|bdfc1|mov|11,-(xr)|10,(xs)+||move a field value|10390
||bct|8,wa|6,bdfc1||loop till all moved|10391
||mov|7,xr|8,wc||recall pointer to pdblk|10392
||brn|6,exsid|||exit setting id field|10393
||ejc|||||10394
|b_efc|ent|2,bl_ef|||entry point (efblk)|10403
||mov|8,wc|13,fargs(xl)||load number of arguments|10406
||wtb|8,wc|||convert to offset|10407
||mov|11,-(xs)|7,xl||save pointer to efblk|10408
||mov|7,xt|7,xs||copy pointer to arguments|10409
|befc1|ica|7,xt|||point to next entry|10413
||mov|7,xr|9,(xs)||load pointer to efblk|10414
||dca|8,wc|||decrement eftar offset|10415
||add|7,xr|8,wc||point to next eftar entry|10416
||mov|7,xr|13,eftar(xr)||load eftar entry|10417
||bsw|7,xr|1,5||switch on type|10426
||iff|1,0|6,befc7||no conversion needed|10444
||iff|1,1|6,befc2||string|10444
||iff|1,2|6,befc3||integer|10444
||iff|1,3|6,befc4||real|10444
||iff|1,4|6,beff1||file|10444
||esw||||end of switch on type|10444
|beff1|mov|11,-(xs)|7,xt||save entry pointer|10449
||mov|3,befof|8,wc||save offset|10450
||mov|11,-(xs)|9,(xt)||stack arg pointer|10451
||jsr|6,iofcb|||convert to fcb|10452
||err|1,298|26,external function argument is not file|||10453
||err|1,298|26,external function argument is not file|||10454
||err|1,298|26,external function argument is not file|||10455
||mov|7,xr|8,wa||point to fcb|10456
||mov|7,xt|10,(xs)+||reload entry pointer|10457
||brn|6,befc5|||jump to merge|10458
|befc2|mov|11,-(xs)|9,(xt)||stack arg ptr|10463
||jsr|6,gtstg|||convert argument to string|10464
||err|1,039|26,external function argument is not a string|||10465
||brn|6,befc6|||jump to merge|10466
||ejc|||||10467
|befc3|mov|7,xr|9,(xt)||load next argument|10473
||mov|3,befof|8,wc||save offset|10474
||jsr|6,gtint|||convert to integer|10475
||err|1,040|26,external function argument is not integer|||10476
||brn|6,befc5|||merge with real case|10479
|befc4|mov|7,xr|9,(xt)||load next argument|10483
||mov|3,befof|8,wc||save offset|10484
||jsr|6,gtrea|||convert to real|10485
||err|1,265|26,external function argument is not real|||10486
|befc5|mov|8,wc|3,befof||restore offset|10491
|befc6|mov|9,(xt)|7,xr||store converted result|10495
|befc7|bnz|8,wc|6,befc1||loop back if more to go|10499
||mov|7,xl|10,(xs)+||restore efblk pointer|10503
||mov|8,wa|13,fargs(xl)||get number of args|10504
||jsr|6,sysex|||call routine to call external fnc|10505
||ppm|6,exfal|||fail if failure|10506
||err|1,327|26,calling external function - not found|||10507
||err|1,326|26,calling external function - bad argument type|||10508
||wtb|8,wa|||convert number of args to bytes|10510
||add|7,xs|8,wa||remove arguments from stack|10511
||ejc|||||10513
||mov|8,wb|13,efrsl(xl)||get result type id|10521
||bnz|8,wb|6,befa8||branch if not unconverted|10522
||bne|9,(xr)|22,=b_scl|6,befc8|jump if not a string|10523
||bze|13,sclen(xr)|6,exnul||return null if null|10524
|befa8|bne|8,wb|18,=num01|6,befc8|jump if not a string|10528
||bze|13,sclen(xr)|6,exnul||return null if null|10529
|befc8|blt|7,xr|3,dnamb|6,befc9|jump if not in dynamic storage|10533
||ble|7,xr|3,dnamp|6,exixr|return result if already dynamic|10534
|befc9|mov|8,wa|9,(xr)||get possible type word|10538
||bze|8,wb|6,bef11||jump if unconverted result|10539
||mov|8,wa|22,=b_scl||string|10540
||beq|8,wb|18,=num01|6,bef10|yes jump|10541
||mov|8,wa|22,=b_icl||integer|10542
||beq|8,wb|18,=num02|6,bef10|yes jump|10543
||mov|8,wa|22,=b_rcl||real|10546
|bef10|mov|9,(xr)|8,wa||stored before copying to dynamic|10551
|bef11|beq|9,(xr)|22,=b_scl|6,bef12|branch if string result|10555
||jsr|6,blkln|||get length of block|10556
||mov|7,xl|7,xr||copy address of old block|10557
||jsr|6,alloc|||allocate dynamic block same size|10558
||mov|11,-(xs)|7,xr||set pointer to new block as result|10559
||mvw||||copy old block to dynamic block|10560
||zer|7,xl|||clear garbage value|10561
||lcw|7,xr|||get next code word|10562
||bri|9,(xr)|||execute next code word|10563
|bef12|mov|7,xl|7,xr||save source string pointer|10569
||mov|8,wa|13,sclen(xr)||fetch string length|10570
||bze|8,wa|6,exnul||return null string if length zero|10571
||jsr|6,alocs|||allocate space for string|10572
||mov|11,-(xs)|7,xr||save as result pointer|10573
||psc|7,xr|||prepare to store chars of result|10574
||plc|7,xl|||point to chars in source string|10575
||mov|8,wa|8,wc||number of characters to copy|10576
||mvc||||move characters to result string|10577
||zer|7,xl|||clear garbage value|10578
||lcw|7,xr|||get next code word|10579
||bri|9,(xr)|||execute next code word|10580
||ejc|||||10582
|b_evt|ent|2,bl_ev|||entry point (evblk)|10588
||ejc|||||10589
|b_ffc|ent|2,bl_ff|||entry point (ffblk)|10598
||mov|7,xr|7,xl||copy ffblk pointer|10599
||lcw|8,wc|||load next code word|10600
||mov|7,xl|9,(xs)||load pdblk pointer|10601
||bne|9,(xl)|22,=b_pdt|6,bffc2|jump if not pdblk at all|10602
||mov|8,wa|13,pddfp(xl)||load dfblk pointer from pdblk|10603
|bffc1|beq|8,wa|13,ffdfp(xr)|6,bffc3|jump if this is the correct ffblk|10607
||mov|7,xr|13,ffnxt(xr)||else link to next ffblk on chain|10608
||bnz|7,xr|6,bffc1||loop back if another entry to check|10609
|bffc2|erb|1,041|26,field function argument is wrong datatype|||10613
||ejc|||||10614
|bffc3|mov|8,wa|13,ffofs(xr)||load field offset|10620
||beq|8,wc|21,=ofne_|6,bffc5|jump if called by name|10621
||add|7,xl|8,wa||else point to value field|10622
||mov|7,xr|9,(xl)||load value|10623
||bne|9,(xr)|22,=b_trt|6,bffc4|jump if not trapped|10624
||sub|7,xl|8,wa||else restore name base,offset|10625
||mov|9,(xs)|8,wc||save next code word over pdblk ptr|10626
||jsr|6,acess|||access value|10627
||ppm|6,exfal|||fail if access fails|10628
||mov|8,wc|9,(xs)||restore next code word|10629
|bffc4|mov|9,(xs)|7,xr||store value on stack (over pdblk)|10633
||mov|7,xr|8,wc||copy next code word|10634
||mov|7,xl|9,(xr)||load entry address|10635
||bri|7,xl|||jump to routine for next code word|10636
|bffc5|mov|11,-(xs)|8,wa||store name offset (base is set)|10640
||lcw|7,xr|||get next code word|10641
||bri|9,(xr)|||execute next code word|10642
||ejc|||||10643
|b_icl|ent|2,bl_ic|||entry point (icblk)|10652
||mov|11,-(xs)|7,xr||stack result|10653
||lcw|7,xr|||get next code word|10654
||bri|9,(xr)|||execute it|10655
||ejc|||||10656
|b_kvt|ent|2,bl_kv|||entry point (kvblk)|10662
||ejc|||||10663
|b_nml|ent|2,bl_nm|||entry point (nmblk)|10674
||mov|11,-(xs)|7,xr||stack result|10675
||lcw|7,xr|||get next code word|10676
||bri|9,(xr)|||execute it|10677
||ejc|||||10678
|b_pdt|ent|2,bl_pd|||entry point (pdblk)|10684
||ejc|||||10685
|b_pfc|ent|2,bl_pf|||entry point (pfblk)|10711
||mov|3,bpfpf|7,xl||save pfblk ptr (need not be reloc)|10712
||mov|7,xr|7,xl||copy for the moment|10713
||mov|7,xl|13,pfvbl(xr)||point to vrblk for function|10714
|bpf01|mov|8,wb|7,xl||save pointer|10718
||mov|7,xl|13,vrval(xl)||load value|10719
||beq|9,(xl)|22,=b_trt|6,bpf01|loop if trblk|10720
||mov|3,bpfsv|7,xl||save old value|10724
||mov|7,xl|8,wb||point back to block with value|10725
||mov|13,vrval(xl)|21,=nulls||set value to null|10726
||mov|8,wa|13,fargs(xr)||load number of arguments|10727
||add|7,xr|19,*pfarg||point to pfarg entries|10728
||bze|8,wa|6,bpf04||jump if no arguments|10729
||mov|7,xt|7,xs||ptr to last arg|10730
||wtb|8,wa|||convert no. of args to bytes offset|10731
||add|7,xt|8,wa||point before first arg|10732
||mov|3,bpfxt|7,xt||remember arg pointer|10733
||ejc|||||10734
|bpf02|mov|7,xl|10,(xr)+||load vrblk ptr for next argument|10740
|bpf03|mov|8,wc|7,xl||save pointer|10744
||mov|7,xl|13,vrval(xl)||load next value|10745
||beq|9,(xl)|22,=b_trt|6,bpf03|loop back if trblk|10746
||mov|8,wa|7,xl||keep old value|10750
||mov|7,xt|3,bpfxt||point before next stacked arg|10751
||mov|8,wb|11,-(xt)||load argument (new value)|10752
||mov|9,(xt)|8,wa||save old value|10753
||mov|3,bpfxt|7,xt||keep arg ptr for next time|10754
||mov|7,xl|8,wc||point back to block with value|10755
||mov|13,vrval(xl)|8,wb||set new value|10756
||bne|7,xs|3,bpfxt|6,bpf02|loop if not all done|10757
|bpf04|mov|7,xl|3,bpfpf||restore pfblk pointer|10761
||mov|8,wa|13,pfnlo(xl)||load number of locals|10762
||bze|8,wa|6,bpf07||jump if no locals|10763
||mov|8,wb|21,=nulls||get null constant|10764
||lct|8,wa|8,wa||set local counter|10765
|bpf05|mov|7,xl|10,(xr)+||load vrblk ptr for next local|10769
|bpf06|mov|8,wc|7,xl||save pointer|10773
||mov|7,xl|13,vrval(xl)||load next value|10774
||beq|9,(xl)|22,=b_trt|6,bpf06|loop back if trblk|10775
||mov|11,-(xs)|7,xl||stack old value|10779
||mov|7,xl|8,wc||point back to block with value|10780
||mov|13,vrval(xl)|8,wb||set null as new value|10781
||bct|8,wa|6,bpf05||loop till all locals processed|10782
||ejc|||||10783
|bpf07|zer|7,xr|||zero reg xr in case|10792
||bze|3,kvpfl|6,bpf7c||skip if profiling is off|10793
||beq|3,kvpfl|18,=num02|6,bpf7a|branch on type of profile|10794
||jsr|6,systm|||get current time|10798
||sti|3,pfetm|||save for a sec|10799
||sbi|3,pfstm|||find time used by caller|10800
||jsr|6,icbld|||build into an icblk|10801
||ldi|3,pfetm|||reload current time|10802
||brn|6,bpf7b|||merge|10803
|bpf7a|ldi|3,pfstm|||get start time of calling stmt|10807
||jsr|6,icbld|||assemble an icblk round it|10808
||jsr|6,systm|||get now time|10809
|bpf7b|sti|3,pfstm|||set start time of 1st func stmt|10813
||mnz|3,pffnc|||flag function entry|10814
|bpf7c|mov|11,-(xs)|7,xr||stack icblk ptr (or zero)|10818
||mov|8,wa|3,r_cod||load old code block pointer|10819
||scp|8,wb|||get code pointer|10821
||sub|8,wb|8,wa||make code pointer into offset|10822
||mov|7,xl|3,bpfpf||recall pfblk pointer|10823
||mov|11,-(xs)|3,bpfsv||stack old value of function name|10824
||mov|11,-(xs)|8,wa||stack code block pointer|10825
||mov|11,-(xs)|8,wb||stack code offset|10826
||mov|11,-(xs)|3,flprt||stack old flprt|10827
||mov|11,-(xs)|3,flptr||stack old failure pointer|10828
||mov|11,-(xs)|7,xl||stack pointer to pfblk|10829
||zer|11,-(xs)|||dummy zero entry for fail return|10830
||chk||||check for stack overflow|10831
||mov|3,flptr|7,xs||set new fail return value|10832
||mov|3,flprt|7,xs||set new flprt|10833
||mov|8,wa|3,kvtra||load trace value|10834
||add|8,wa|3,kvftr||add ftrace value|10835
||bnz|8,wa|6,bpf09||jump if tracing possible|10836
||icv|3,kvfnc|||else bump fnclevel|10837
|bpf08|mov|7,xr|13,pfcod(xl)||point to vrblk of entry label|10841
||mov|7,xr|13,vrlbl(xr)||point to target code|10842
||beq|7,xr|21,=stndl|6,bpf17|test for undefined label|10843
||bne|9,(xr)|22,=b_trt|6,bpf8a|jump if not trapped|10844
||mov|7,xr|13,trlbl(xr)||else load ptr to real label code|10845
|bpf8a|bri|9,(xr)|||off to execute function|10846
|bpf09|mov|7,xr|13,pfctr(xl)||load possible call trace trblk|10850
||mov|7,xl|13,pfvbl(xl)||load vrblk pointer for function|10851
||mov|8,wa|19,*vrval||set name offset for variable|10852
||bze|3,kvtra|6,bpf10||jump if trace mode is off|10853
||bze|7,xr|6,bpf10||or if there is no call trace|10854
||dcv|3,kvtra|||decrement trace count|10858
||bze|13,trfnc(xr)|6,bpf11||jump if print trace|10859
||jsr|6,trxeq|||execute function type trace|10860
||ejc|||||10861
|bpf10|bze|3,kvftr|6,bpf16||jump if ftrace is off|10867
||dcv|3,kvftr|||else decrement ftrace|10868
|bpf11|jsr|6,prtsn|||print statement number|10872
||jsr|6,prtnm|||print function name|10873
||mov|8,wa|18,=ch_pp||load left paren|10874
||jsr|6,prtch|||print left paren|10875
||mov|7,xl|13,num01(xs)||recover pfblk pointer|10876
||bze|13,fargs(xl)|6,bpf15||skip if no arguments|10877
||zer|8,wb|||else set argument counter|10878
||brn|6,bpf13|||jump into loop|10879
|bpf12|mov|8,wa|18,=ch_cm||load comma|10883
||jsr|6,prtch|||print to separate from last arg|10884
|bpf13|mov|9,(xs)|8,wb||save arg ctr (over failoffs is ok)|10888
||wtb|8,wb|||convert to byte offset|10889
||add|7,xl|8,wb||point to next argument pointer|10890
||mov|7,xr|13,pfarg(xl)||load next argument vrblk ptr|10891
||sub|7,xl|8,wb||restore pfblk pointer|10892
||mov|7,xr|13,vrval(xr)||load next value|10893
||jsr|6,prtvl|||print argument value|10894
||ejc|||||10895
||mov|8,wb|9,(xs)||restore argument counter|10899
||icv|8,wb|||increment argument counter|10900
||blt|8,wb|13,fargs(xl)|6,bpf12|loop if more to print|10901
|bpf15|mov|8,wa|18,=ch_rp||load right paren|10905
||jsr|6,prtch|||print to terminate output|10906
||jsr|6,prtnl|||terminate print line|10907
|bpf16|icv|3,kvfnc|||increment fnclevel|10911
||mov|7,xl|3,r_fnc||load ptr to possible trblk|10912
||jsr|6,ktrex|||call keyword trace routine|10913
||mov|7,xl|13,num01(xs)||restore pfblk pointer|10917
||brn|6,bpf08|||jump back to execute function|10918
|bpf17|mov|3,flptr|13,num02(xs)||reset so exfal can return to evalx|10922
||erb|1,286|26,function call to undefined entry label|||10923
||ejc|||||10926
|b_rcl|ent|2,bl_rc|||entry point (rcblk)|10935
||mov|11,-(xs)|7,xr||stack result|10936
||lcw|7,xr|||get next code word|10937
||bri|9,(xr)|||execute it|10938
||ejc|||||10940
|b_scl|ent|2,bl_sc|||entry point (scblk)|10949
||mov|11,-(xs)|7,xr||stack result|10950
||lcw|7,xr|||get next code word|10951
||bri|9,(xr)|||execute it|10952
||ejc|||||10953
|b_tbt|ent|2,bl_tb|||entry point (tbblk)|10959
||ejc|||||10960
|b_tet|ent|2,bl_te|||entry point (teblk)|10966
||ejc|||||10967
|b_vct|ent|2,bl_vc|||entry point (vcblk)|10973
||ejc|||||10974
|b_vr_|ent|2,bl__i|||mark start of vrblk entry points|10981
|b_vra|ent|2,bl__i|||entry point|10990
||mov|7,xl|7,xr||copy name base (vrget = 0)|10991
||mov|8,wa|19,*vrval||set name offset|10992
||jsr|6,acess|||access value|10993
||ppm|6,exfal|||fail if access fails|10994
||mov|11,-(xs)|7,xr||stack result|10995
||lcw|7,xr|||get next code word|10996
||bri|9,(xr)|||execute it|10997
||ejc|||||10998
|b_vre|ent||||entry point|11006
||erb|1,042|26,attempt to change value of protected variable|||11007
||ejc|||||11008
|b_vrg|ent||||entry point|11017
||mov|7,xr|13,vrlbo(xr)||load code pointer|11018
||mov|7,xl|9,(xr)||load entry address|11019
||bri|7,xl|||jump to routine for next code word|11020
||ejc|||||11021
|b_vrl|ent||||entry point|11030
||mov|11,-(xs)|13,vrval(xr)||load value onto stack (vrget = 0)|11031
||lcw|7,xr|||get next code word|11032
||bri|9,(xr)|||execute next code word|11033
||ejc|||||11034
|b_vrs|ent||||entry point|11043
||mov|13,vrvlo(xr)|9,(xs)||store value, leave on stack|11044
||lcw|7,xr|||get next code word|11045
||bri|9,(xr)|||execute next code word|11046
||ejc|||||11047
|b_vrt|ent||||entry point|11055
||sub|7,xr|19,*vrtra||point back to start of vrblk|11056
||mov|7,xl|7,xr||copy vrblk pointer|11057
||mov|8,wa|19,*vrval||set name offset|11058
||mov|7,xr|13,vrlbl(xl)||load pointer to trblk|11059
||bze|3,kvtra|6,bvrt2||jump if trace is off|11060
||dcv|3,kvtra|||else decrement trace count|11061
||bze|13,trfnc(xr)|6,bvrt1||jump if print trace case|11062
||jsr|6,trxeq|||else execute full trace|11063
||brn|6,bvrt2|||merge to jump to label|11064
|bvrt1|jsr|6,prtsn|||print statement number|11068
||mov|7,xr|7,xl||copy vrblk pointer|11069
||mov|8,wa|18,=ch_cl||colon|11070
||jsr|6,prtch|||print it|11071
||mov|8,wa|18,=ch_pp||left paren|11072
||jsr|6,prtch|||print it|11073
||jsr|6,prtvn|||print label name|11074
||mov|8,wa|18,=ch_rp||right paren|11075
||jsr|6,prtch|||print it|11076
||jsr|6,prtnl|||terminate line|11077
||mov|7,xr|13,vrlbl(xl)||point back to trblk|11078
|bvrt2|mov|7,xr|13,trlbl(xr)||load pointer to actual code|11082
||bri|9,(xr)|||execute statement at label|11083
||ejc|||||11084
|b_vrv|ent||||entry point|11095
||mov|8,wb|9,(xs)||load value (leave copy on stack)|11096
||sub|7,xr|19,*vrsto||point to vrblk|11097
||mov|7,xl|7,xr||copy vrblk pointer|11098
||mov|8,wa|19,*vrval||set offset|11099
||jsr|6,asign|||call assignment routine|11100
||ppm|6,exfal|||fail if assignment fails|11101
||lcw|7,xr|||else get next code word|11102
||bri|9,(xr)|||execute next code word|11103
||ejc|||||11104
|b_xnt|ent|2,bl_xn|||entry point (xnblk)|11110
||ejc|||||11111
|b_xrt|ent|2,bl_xr|||entry point (xrblk)|11117
|b_yyy|ent|2,bl__i|||last block routine entry point|11121
||ttl|27,s p i t b o l -- pattern matching routines||||11122
|p_aaa|ent|2,bl__i|||entry to mark first pattern|11131
||ejc|||||11161
||ejc|||||11215
||ejc|||||11266
||ejc|||||11294
||ejc|||||11342
||ejc|||||11382
||ejc|||||11419
||ejc|||||11453
||ejc|||||11503
||ejc|||||11543
|p_aba|ent|2,bl_p0|||p0blk|11552
||mov|11,-(xs)|8,wb||stack cursor|11553
||mov|11,-(xs)|7,xr||stack dummy node ptr|11554
||mov|11,-(xs)|3,pmhbs||stack old stack base ptr|11555
||mov|11,-(xs)|21,=ndabb||stack ptr to node ndabb|11556
||mov|3,pmhbs|7,xs||store new stack base ptr|11557
||brn|6,succp|||succeed|11558
||ejc|||||11559
|p_abb|ent||||entry point|11565
||mov|3,pmhbs|8,wb||restore history stack base ptr|11566
||brn|6,flpop|||fail and pop dummy node ptr|11567
||ejc|||||11568
|p_abc|ent|2,bl_p0|||p0blk|11574
||mov|7,xt|3,pmhbs||keep p_abb stack base|11575
||mov|8,wa|13,num03(xt)||load initial cursor|11576
||mov|3,pmhbs|13,num01(xt)||restore outer stack base ptr|11577
||beq|7,xt|7,xs|6,pabc1|jump if no history stack entries|11578
||mov|11,-(xs)|7,xt||else save inner pmhbs entry|11579
||mov|11,-(xs)|21,=ndabd||stack ptr to special node ndabd|11580
||brn|6,pabc2|||merge|11581
|pabc1|add|7,xs|19,*num04||remove ndabb entry and cursor|11585
|pabc2|bne|8,wa|8,wb|6,succp|allow further attempt if non-null|11589
||mov|7,xr|13,pthen(xr)||bypass alternative node so as to ...|11590
||brn|6,succp|||... refuse further match attempts|11591
||ejc|||||11592
|p_abd|ent||||entry point|11598
||mov|3,pmhbs|8,wb||restore inner stack base ptr|11599
||brn|6,failp|||and fail|11600
||ejc|||||11601
|p_abo|ent|2,bl_p0|||p0blk|11607
||brn|6,exfal|||signal statement failure|11608
||ejc|||||11609
|p_alt|ent|2,bl_p1|||p1blk|11615
||mov|11,-(xs)|8,wb||stack cursor|11616
||mov|11,-(xs)|13,parm1(xr)||stack pointer to alternative|11617
||chk||||check for stack overflow|11618
||brn|6,succp|||if all ok, then succeed|11619
||ejc|||||11620
|p_ans|ent|2,bl_p1|||p1blk|11626
||beq|8,wb|3,pmssl|6,failp|fail if no chars left|11627
||mov|7,xl|3,r_pms||else point to subject string|11628
||plc|7,xl|8,wb||point to current character|11629
||lch|8,wa|9,(xl)||load current character|11630
||bne|8,wa|13,parm1(xr)|6,failp|fail if no match|11631
||icv|8,wb|||else bump cursor|11632
||brn|6,succp|||and succeed|11633
||ejc|||||11634
|p_any|ent|2,bl_p2|||p2blk|11641
|pany1|beq|8,wb|3,pmssl|6,failp|fail if no characters left|11645
||mov|7,xl|3,r_pms||else point to subject string|11646
||plc|7,xl|8,wb||get char ptr to current character|11647
||lch|8,wa|9,(xl)||load current character|11648
||mov|7,xl|13,parm1(xr)||point to ctblk|11649
||wtb|8,wa|||change to byte offset|11650
||add|7,xl|8,wa||point to entry in ctblk|11651
||mov|8,wa|13,ctchs(xl)||load word from ctblk|11652
||anb|8,wa|13,parm2(xr)||and with selected bit|11653
||zrb|8,wa|6,failp||fail if no match|11654
||icv|8,wb|||else bump cursor|11655
||brn|6,succp|||and succeed|11656
||ejc|||||11657
|p_ayd|ent|2,bl_p1|||p1blk|11663
||jsr|6,evals|||evaluate string argument|11664
||err|1,043|26,any evaluated argument is not a string|||11665
||ppm|6,failp|||fail if evaluation failure|11666
||ppm|6,pany1|||merge multi-char case if ok|11667
||ejc|||||11668
|p_arb|ent|2,bl_p0|||p0blk|11677
||mov|7,xr|13,pthen(xr)||load successor pointer|11678
||mov|11,-(xs)|8,wb||stack dummy cursor|11679
||mov|11,-(xs)|7,xr||stack successor pointer|11680
||mov|11,-(xs)|8,wb||stack cursor|11681
||mov|11,-(xs)|21,=ndarc||stack ptr to special node ndarc|11682
||bri|9,(xr)|||execute next node matching null|11683
||ejc|||||11684
|p_arc|ent||||entry point|11690
||beq|8,wb|3,pmssl|6,flpop|fail and pop stack to successor|11691
||icv|8,wb|||else bump cursor|11692
||mov|11,-(xs)|8,wb||stack updated cursor|11693
||mov|11,-(xs)|7,xr||restack pointer to ndarc node|11694
||mov|7,xr|13,num02(xs)||load successor pointer|11695
||bri|9,(xr)|||off to reexecute successor node|11696
||ejc|||||11697
|p_bal|ent|2,bl_p0|||p0blk|11706
||zer|8,wc|||zero parentheses level counter|11707
||mov|7,xl|3,r_pms||point to subject string|11708
||plc|7,xl|8,wb||point to current character|11709
||brn|6,pbal2|||jump into scan loop|11710
|pbal1|lch|8,wa|10,(xl)+||load next character, bump pointer|11714
||icv|8,wb|||push cursor for character|11715
||beq|8,wa|18,=ch_pp|6,pbal3|jump if left paren|11716
||beq|8,wa|18,=ch_rp|6,pbal4|jump if right paren|11717
||bze|8,wc|6,pbal5||else succeed if at outer level|11718
|pbal2|bne|8,wb|3,pmssl|6,pbal1|loop back unless end of string|11722
||brn|6,failp|||in which case, fail|11723
|pbal3|icv|8,wc|||bump paren level|11727
||brn|6,pbal2|||loop back to check end of string|11728
|pbal4|bze|8,wc|6,failp||fail if no matching left paren|11732
||dcv|8,wc|||else decrement level counter|11733
||bnz|8,wc|6,pbal2||loop back if not at outer level|11734
|pbal5|mov|11,-(xs)|8,wb||stack cursor|11738
||mov|11,-(xs)|7,xr||stack ptr to bal node for extend|11739
||brn|6,succp|||and succeed|11740
||ejc|||||11741
|p_bkd|ent|2,bl_p1|||p1blk|11747
||jsr|6,evals|||evaluate string expression|11748
||err|1,044|26,break evaluated argument is not a string|||11749
||ppm|6,failp|||fail if evaluation fails|11750
||ppm|6,pbrk1|||merge with multi-char case if ok|11751
||ejc|||||11752
|p_bks|ent|2,bl_p1|||p1blk|11758
||mov|8,wc|3,pmssl||get subject string length|11759
||sub|8,wc|8,wb||get number of characters left|11760
||bze|8,wc|6,failp||fail if no characters left|11761
||lct|8,wc|8,wc||set counter for chars left|11762
||mov|7,xl|3,r_pms||point to subject string|11763
||plc|7,xl|8,wb||point to current character|11764
|pbks1|lch|8,wa|10,(xl)+||load next char, bump pointer|11768
||beq|8,wa|13,parm1(xr)|6,succp|succeed if break character found|11769
||icv|8,wb|||else push cursor|11770
||bct|8,wc|6,pbks1||loop back if more to go|11771
||brn|6,failp|||fail if end of string, no break chr|11772
||ejc|||||11773
|p_brk|ent|2,bl_p2|||p2blk|11780
|pbrk1|mov|8,wc|3,pmssl||load subject string length|11784
||sub|8,wc|8,wb||get number of characters left|11785
||bze|8,wc|6,failp||fail if no characters left|11786
||lct|8,wc|8,wc||set counter for characters left|11787
||mov|7,xl|3,r_pms||else point to subject string|11788
||plc|7,xl|8,wb||point to current character|11789
||mov|3,psave|7,xr||save node pointer|11790
|pbrk2|lch|8,wa|10,(xl)+||load next char, bump pointer|11794
||mov|7,xr|13,parm1(xr)||load pointer to ctblk|11795
||wtb|8,wa|||convert to byte offset|11796
||add|7,xr|8,wa||point to ctblk entry|11797
||mov|8,wa|13,ctchs(xr)||load ctblk word|11798
||mov|7,xr|3,psave||restore node pointer|11799
||anb|8,wa|13,parm2(xr)||and with selected bit|11800
||nzb|8,wa|6,succp||succeed if break character found|11801
||icv|8,wb|||else push cursor|11802
||bct|8,wc|6,pbrk2||loop back unless end of string|11803
||brn|6,failp|||fail if end of string, no break chr|11804
||ejc|||||11805
|p_bkx|ent|2,bl_p0|||p0blk|11815
||icv|8,wb|||step cursor past previous break chr|11816
||brn|6,succp|||succeed to rematch break|11817
||ejc|||||11818
|p_bxd|ent|2,bl_p1|||p1blk|11829
||jsr|6,evals|||evaluate string argument|11830
||err|1,045|26,breakx evaluated argument is not a string|||11831
||ppm|6,failp|||fail if evaluation fails|11832
||ppm|6,pbrk1|||merge with break if all ok|11833
||ejc|||||11834
|p_cas|ent|2,bl_p2|||p2blk|11841
||mov|11,-(xs)|7,xr||save node pointer|11842
||mov|11,-(xs)|8,wb||save cursor|11843
||mov|7,xl|13,parm1(xr)||load name base|11844
||mti|8,wb|||load cursor as integer|11845
||mov|8,wb|13,parm2(xr)||load name offset|11846
||jsr|6,icbld|||get icblk for cursor value|11847
||mov|8,wa|8,wb||move name offset|11848
||mov|8,wb|7,xr||move value to assign|11849
||jsr|6,asinp|||perform assignment|11850
||ppm|6,flpop|||fail on assignment failure|11851
||mov|8,wb|10,(xs)+||else restore cursor|11852
||mov|7,xr|10,(xs)+||restore node pointer|11853
||brn|6,succp|||and succeed matching null|11854
||ejc|||||11855
|p_exa|ent|2,bl_p1|||p1blk|11864
||jsr|6,evalp|||evaluate expression|11865
||ppm|6,failp|||fail if evaluation fails|11866
||blo|8,wa|22,=p_aaa|6,pexa1|jump if result is not a pattern|11867
||mov|11,-(xs)|8,wb||stack dummy cursor|11871
||mov|11,-(xs)|7,xr||stack ptr to p_exa node|11872
||mov|11,-(xs)|3,pmhbs||stack history stack base ptr|11873
||mov|11,-(xs)|21,=ndexb||stack ptr to special node ndexb|11874
||mov|3,pmhbs|7,xs||store new stack base pointer|11875
||mov|7,xr|7,xl||copy node pointer|11876
||bri|9,(xr)|||match first node in expression pat|11877
|pexa1|beq|8,wa|22,=b_scl|6,pexa2|jump if it is already a string|11881
||mov|11,-(xs)|7,xl||else stack result|11882
||mov|7,xl|7,xr||save node pointer|11883
||jsr|6,gtstg|||convert result to string|11884
||err|1,046|26,expression does not evaluate to pattern|||11885
||mov|8,wc|7,xr||copy string pointer|11886
||mov|7,xr|7,xl||restore node pointer|11887
||mov|7,xl|8,wc||copy string pointer again|11888
|pexa2|bze|13,sclen(xl)|6,succp||just succeed if null string|11892
||brn|6,pstr1|||else merge with string circuit|11893
||ejc|||||11894
|p_exb|ent||||entry point|11903
||mov|3,pmhbs|8,wb||restore outer level stack pointer|11904
||brn|6,flpop|||fail and pop p_exa node ptr|11905
||ejc|||||11906
|p_exc|ent||||entry point|11915
||mov|3,pmhbs|8,wb||restore inner stack base pointer|11916
||brn|6,failp|||and fail into expr pattern alternvs|11917
||ejc|||||11918
|p_fal|ent|2,bl_p0|||p0blk|11924
||brn|6,failp|||just signal failure|11925
||ejc|||||11926
|p_fen|ent|2,bl_p0|||p0blk|11935
||mov|11,-(xs)|8,wb||stack dummy cursor|11936
||mov|11,-(xs)|21,=ndabo||stack ptr to abort node|11937
||brn|6,succp|||and succeed matching null|11938
||ejc|||||11939
|p_fna|ent|2,bl_p0|||p0blk|11948
||mov|11,-(xs)|3,pmhbs||stack current history stack base|11949
||mov|11,-(xs)|21,=ndfnb||stack indir ptr to p_fnb (failure)|11950
||mov|3,pmhbs|7,xs||begin new history stack|11951
||brn|6,succp|||succeed|11952
||ejc|||||11953
|p_fnb|ent|2,bl_p0|||p0blk|11959
||mov|3,pmhbs|8,wb||restore outer pmhbs stack base|11960
||brn|6,failp|||...and fail|11961
||ejc|||||11962
|p_fnc|ent|2,bl_p0|||p0blk|11968
||mov|7,xt|3,pmhbs||get inner stack base ptr|11969
||mov|3,pmhbs|13,num01(xt)||restore outer stack base|11970
||beq|7,xt|7,xs|6,pfnc1|optimize if no alternatives|11971
||mov|11,-(xs)|7,xt||else stack inner stack base|11972
||mov|11,-(xs)|21,=ndfnd||stack ptr to ndfnd|11973
||brn|6,succp|||succeed|11974
|pfnc1|add|7,xs|19,*num02||pop off p_fnb entry|11978
||brn|6,succp|||succeed|11979
||ejc|||||11980
|p_fnd|ent|2,bl_p0|||p0blk|11986
||mov|7,xs|8,wb||pop stack to fence() history base|11987
||brn|6,flpop|||pop base entry and fail|11988
||ejc|||||11989
|p_ima|ent|2,bl_p0|||p0blk|11998
||mov|11,-(xs)|8,wb||stack cursor|11999
||mov|11,-(xs)|7,xr||stack dummy node pointer|12000
||mov|11,-(xs)|3,pmhbs||stack old stack base pointer|12001
||mov|11,-(xs)|21,=ndimb||stack ptr to special node ndimb|12002
||mov|3,pmhbs|7,xs||store new stack base pointer|12003
||brn|6,succp|||and succeed|12004
||ejc|||||12005
|p_imb|ent||||entry point|12014
||mov|3,pmhbs|8,wb||restore history stack base ptr|12015
||brn|6,flpop|||fail and pop dummy node ptr|12016
||ejc|||||12017
|p_imc|ent|2,bl_p2|||p2blk|12027
||mov|7,xt|3,pmhbs||load pointer to p_imb entry|12028
||mov|8,wa|8,wb||copy final cursor|12029
||mov|8,wb|13,num03(xt)||load initial cursor|12030
||mov|3,pmhbs|13,num01(xt)||restore outer stack base pointer|12031
||beq|7,xt|7,xs|6,pimc1|jump if no history stack entries|12032
||mov|11,-(xs)|7,xt||else save inner pmhbs pointer|12033
||mov|11,-(xs)|21,=ndimd||and a ptr to special node ndimd|12034
||brn|6,pimc2|||merge|12035
|pimc1|add|7,xs|19,*num04||remove ndimb entry and cursor|12039
|pimc2|mov|11,-(xs)|8,wa||save current (final) cursor|12043
||mov|11,-(xs)|7,xr||save current node pointer|12044
||mov|7,xl|3,r_pms||point to subject string|12045
||sub|8,wa|8,wb||compute substring length|12046
||jsr|6,sbstr|||build substring|12047
||mov|8,wb|7,xr||move result|12048
||mov|7,xr|9,(xs)||reload node pointer|12049
||mov|7,xl|13,parm1(xr)||load name base|12050
||mov|8,wa|13,parm2(xr)||load name offset|12051
||jsr|6,asinp|||perform assignment|12052
||ppm|6,flpop|||fail if assignment fails|12053
||mov|7,xr|10,(xs)+||else restore node pointer|12054
||mov|8,wb|10,(xs)+||restore cursor|12055
||brn|6,succp|||and succeed|12056
||ejc|||||12057
|p_imd|ent||||entry point|12066
||mov|3,pmhbs|8,wb||restore inner stack base pointer|12067
||brn|6,failp|||and fail|12068
||ejc|||||12069
|p_len|ent|2,bl_p1|||p1blk|12075
|plen1|add|8,wb|13,parm1(xr)||push cursor indicated amount|12079
||ble|8,wb|3,pmssl|6,succp|succeed if not off end|12080
||brn|6,failp|||else fail|12081
||ejc|||||12082
|p_lnd|ent|2,bl_p1|||p1blk|12088
||jsr|6,evali|||evaluate integer argument|12089
||err|1,047|26,len evaluated argument is not integer|||12090
||err|1,048|26,len evaluated argument is negative or too large|||12091
||ppm|6,failp|||fail if evaluation fails|12092
||ppm|6,plen1|||merge with normal circuit if ok|12093
||ejc|||||12094
|p_nad|ent|2,bl_p1|||p1blk|12100
||jsr|6,evals|||evaluate string argument|12101
||err|1,049|26,notany evaluated argument is not a string|||12102
||ppm|6,failp|||fail if evaluation fails|12103
||ppm|6,pnay1|||merge with multi-char case if ok|12104
||ejc|||||12105
|p_nas|ent|2,bl_p1|||entry point|12111
||beq|8,wb|3,pmssl|6,failp|fail if no chars left|12112
||mov|7,xl|3,r_pms||else point to subject string|12113
||plc|7,xl|8,wb||point to current character in strin|12114
||lch|8,wa|9,(xl)||load current character|12115
||beq|8,wa|13,parm1(xr)|6,failp|fail if match|12116
||icv|8,wb|||else bump cursor|12117
||brn|6,succp|||and succeed|12118
||ejc|||||12119
|p_nay|ent|2,bl_p2|||p2blk|12126
|pnay1|beq|8,wb|3,pmssl|6,failp|fail if no characters left|12130
||mov|7,xl|3,r_pms||else point to subject string|12131
||plc|7,xl|8,wb||point to current character|12132
||lch|8,wa|9,(xl)||load current character|12133
||wtb|8,wa|||convert to byte offset|12134
||mov|7,xl|13,parm1(xr)||load pointer to ctblk|12135
||add|7,xl|8,wa||point to entry in ctblk|12136
||mov|8,wa|13,ctchs(xl)||load entry from ctblk|12137
||anb|8,wa|13,parm2(xr)||and with selected bit|12138
||nzb|8,wa|6,failp||fail if character is matched|12139
||icv|8,wb|||else bump cursor|12140
||brn|6,succp|||and succeed|12141
||ejc|||||12142
|p_nth|ent|2,bl_p0|||p0blk (dummy)|12155
||mov|7,xt|3,pmhbs||load pointer to base of stack|12156
||mov|8,wa|13,num01(xt)||load saved pmhbs (or pattern type)|12157
||ble|8,wa|18,=num02|6,pnth2|jump if outer level (pattern type)|12158
||mov|3,pmhbs|8,wa||restore outer stack base pointer|12162
||mov|7,xr|13,num02(xt)||restore pointer to p_exa node|12163
||beq|7,xt|7,xs|6,pnth1|jump if no history stack entries|12164
||mov|11,-(xs)|7,xt||else stack inner stack base ptr|12165
||mov|11,-(xs)|21,=ndexc||stack ptr to special node ndexc|12166
||brn|6,succp|||and succeed|12167
|pnth1|add|7,xs|19,*num04||remove p_exb entry and node ptr|12171
||brn|6,succp|||and succeed|12172
|pnth2|mov|3,pmssl|8,wb||save final cursor in safe place|12176
||bze|3,pmdfl|6,pnth6||jump if no pattern assignments|12177
||ejc|||||12178
|pnth3|dca|7,xt|||point past cursor entry|12185
||mov|8,wa|11,-(xt)||load node pointer|12186
||beq|8,wa|21,=ndpad|6,pnth4|jump if ndpad entry|12187
||bne|8,wa|21,=ndpab|6,pnth5|jump if not ndpab entry|12188
||mov|11,-(xs)|13,num01(xt)||stack initial cursor|12193
||chk||||check for stack overflow|12194
||brn|6,pnth3|||loop back if ok|12195
|pnth4|mov|8,wa|13,num01(xt)||load final cursor|12200
||mov|8,wb|9,(xs)||load initial cursor from stack|12201
||mov|9,(xs)|7,xt||save history stack scan ptr|12202
||sub|8,wa|8,wb||compute length of string|12203
||mov|7,xl|3,r_pms||point to subject string|12207
||jsr|6,sbstr|||construct substring|12208
||mov|8,wb|7,xr||copy substring pointer|12209
||mov|7,xt|9,(xs)||reload history stack scan ptr|12210
||mov|7,xl|13,num02(xt)||load pointer to p_pac node with nam|12211
||mov|8,wa|13,parm2(xl)||load name offset|12212
||mov|7,xl|13,parm1(xl)||load name base|12213
||jsr|6,asinp|||perform assignment|12214
||ppm|6,exfal|||match fails if name eval fails|12215
||mov|7,xt|10,(xs)+||else restore history stack ptr|12216
||ejc|||||12217
|pnth5|bne|7,xt|7,xs|6,pnth3|loop if more entries to scan|12223
|pnth6|mov|7,xs|3,pmhbs||wipe out history stack|12227
||mov|8,wb|10,(xs)+||load initial cursor|12228
||mov|8,wc|10,(xs)+||load match type code|12229
||mov|8,wa|3,pmssl||load final cursor value|12230
||mov|7,xl|3,r_pms||point to subject string|12231
||zer|3,r_pms|||clear subject string ptr for gbcol|12232
||bze|8,wc|6,pnth7||jump if call by name|12233
||beq|8,wc|18,=num02|6,pnth9|exit if statement level call|12234
||sub|8,wa|8,wb||compute length of string|12238
||jsr|6,sbstr|||build substring|12239
||mov|11,-(xs)|7,xr||stack result|12240
||lcw|7,xr|||get next code word|12241
||bri|9,(xr)|||execute it|12242
|pnth7|mov|11,-(xs)|8,wb||stack initial cursor|12246
||mov|11,-(xs)|8,wa||stack final cursor|12247
|pnth8|mov|11,-(xs)|7,xl||stack subject pointer|12256
|pnth9|lcw|7,xr|||get next code word|12260
||bri|9,(xr)|||execute next code word|12261
||ejc|||||12262
|p_pos|ent|2,bl_p1|||p1blk|12268
||beq|8,wb|13,parm1(xr)|6,succp|succeed if at right location|12286
||bnz|8,wb|6,failp||don't look further if cursor not 0|12287
||mov|7,xt|3,pmhbs||get history stack base ptr|12288
||bne|7,xr|11,-(xt)|6,failp|fail if pos is not first node|12289
|ppos2|bne|11,-(xt)|21,=nduna|6,failp|fail if not unanchored mode|12293
||mov|8,wb|13,parm1(xr)||get desired cursor position|12294
||bgt|8,wb|3,pmssl|6,exfal|abort if off end|12295
||mov|13,num02(xt)|8,wb||fake number of unanchored moves|12296
||brn|6,succp|||continue match with adjusted cursor|12297
||ejc|||||12298
|p_psd|ent|2,bl_p1|||p1blk|12304
||jsr|6,evali|||evaluate integer argument|12305
||err|1,050|26,pos evaluated argument is not integer|||12306
||err|1,051|26,pos evaluated argument is negative or too large|||12307
||ppm|6,failp|||fail if evaluation fails|12308
||ppm|6,ppos1|||process expression case|12309
|ppos1|beq|8,wb|13,parm1(xr)|6,succp|succeed if at right location|12311
||bnz|8,wb|6,failp||don't look further if cursor not 0|12312
||bnz|3,evlif|6,failp||fail if complex argument|12313
||mov|7,xt|3,pmhbs||get history stack base ptr|12314
||mov|8,wa|3,evlio||get original node ptr|12315
||bne|8,wa|11,-(xt)|6,failp|fail if pos is not first node|12316
||brn|6,ppos2|||merge with integer argument code|12317
||ejc|||||12318
|p_paa|ent|2,bl_p0|||p0blk|12327
||mov|11,-(xs)|8,wb||stack initial cursor|12328
||mov|11,-(xs)|21,=ndpab||stack ptr to ndpab special node|12329
||brn|6,succp|||and succeed matching null|12330
||ejc|||||12331
|p_pab|ent||||entry point|12340
||brn|6,failp|||just fail (entry is already popped)|12341
||ejc|||||12342
|p_pac|ent|2,bl_p2|||p2blk|12352
||mov|11,-(xs)|8,wb||stack dummy cursor value|12353
||mov|11,-(xs)|7,xr||stack pointer to p_pac node|12354
||mov|11,-(xs)|8,wb||stack final cursor|12355
||mov|11,-(xs)|21,=ndpad||stack ptr to special ndpad node|12356
||mnz|3,pmdfl|||set dot flag non-zero|12357
||brn|6,succp|||and succeed|12358
||ejc|||||12359
|p_pad|ent||||entry point|12368
||brn|6,flpop|||fail and remove p_pac node|12369
||ejc|||||12370
|p_rem|ent|2,bl_p0|||p0blk|12376
||mov|8,wb|3,pmssl||point cursor to end of string|12377
||brn|6,succp|||and succeed|12378
||ejc|||||12379
|p_rpd|ent|2,bl_p1|||p1blk|12397
||jsr|6,evali|||evaluate integer argument|12398
||err|1,052|26,rpos evaluated argument is not integer|||12399
||err|1,053|26,rpos evaluated argument is negative or too large|||12400
||ppm|6,failp|||fail if evaluation fails|12401
||ppm|6,prps1|||merge with normal case if ok|12402
|prps1|mov|8,wc|3,pmssl||get length of string|12404
||sub|8,wc|8,wb||get number of characters remaining|12405
||beq|8,wc|13,parm1(xr)|6,succp|succeed if at right location|12406
||bnz|8,wb|6,failp||don't look further if cursor not 0|12407
||bnz|3,evlif|6,failp||fail if complex argument|12408
||mov|7,xt|3,pmhbs||get history stack base ptr|12409
||mov|8,wa|3,evlio||get original node ptr|12410
||bne|8,wa|11,-(xt)|6,failp|fail if pos is not first node|12411
||brn|6,prps2|||merge with integer arg code|12412
||ejc|||||12413
|p_rps|ent|2,bl_p1|||p1blk|12419
||mov|8,wc|3,pmssl||get length of string|12425
||sub|8,wc|8,wb||get number of characters remaining|12426
||beq|8,wc|13,parm1(xr)|6,succp|succeed if at right location|12427
||bnz|8,wb|6,failp||don't look further if cursor not 0|12428
||mov|7,xt|3,pmhbs||get history stack base ptr|12429
||bne|7,xr|11,-(xt)|6,failp|fail if rpos is not first node|12430
|prps2|bne|11,-(xt)|21,=nduna|6,failp|fail if not unanchored mode|12434
||mov|8,wb|3,pmssl||point to end of string|12435
||blt|8,wb|13,parm1(xr)|6,failp|fail if string not long enough|12436
||sub|8,wb|13,parm1(xr)||else set new cursor|12437
||mov|13,num02(xt)|8,wb||fake number of unanchored moves|12438
||brn|6,succp|||continue match with adjusted cursor|12439
||ejc|||||12440
|p_rtb|ent|2,bl_p1|||p1blk|12446
|prtb1|mov|8,wc|8,wb||save initial cursor|12450
||mov|8,wb|3,pmssl||point to end of string|12451
||blt|8,wb|13,parm1(xr)|6,failp|fail if string not long enough|12452
||sub|8,wb|13,parm1(xr)||else set new cursor|12453
||bge|8,wb|8,wc|6,succp|and succeed if not too far already|12454
||brn|6,failp|||in which case, fail|12455
||ejc|||||12456
|p_rtd|ent|2,bl_p1|||p1blk|12462
||jsr|6,evali|||evaluate integer argument|12463
||err|1,054|26,rtab evaluated argument is not integer|||12464
||err|1,055|26,rtab evaluated argument is negative or too large|||12465
||ppm|6,failp|||fail if evaluation fails|12466
||ppm|6,prtb1|||merge with normal case if success|12467
||ejc|||||12468
|p_spd|ent|2,bl_p1|||p1blk|12474
||jsr|6,evals|||evaluate string argument|12475
||err|1,056|26,span evaluated argument is not a string|||12476
||ppm|6,failp|||fail if evaluation fails|12477
||ppm|6,pspn1|||merge with multi-char case if ok|12478
||ejc|||||12479
|p_spn|ent|2,bl_p2|||p2blk|12486
|pspn1|mov|8,wc|3,pmssl||copy subject string length|12490
||sub|8,wc|8,wb||calculate number of characters left|12491
||bze|8,wc|6,failp||fail if no characters left|12492
||mov|7,xl|3,r_pms||point to subject string|12493
||plc|7,xl|8,wb||point to current character|12494
||mov|3,psavc|8,wb||save initial cursor|12495
||mov|3,psave|7,xr||save node pointer|12496
||lct|8,wc|8,wc||set counter for chars left|12497
|pspn2|lch|8,wa|10,(xl)+||load next character, bump pointer|12501
||wtb|8,wa|||convert to byte offset|12502
||mov|7,xr|13,parm1(xr)||point to ctblk|12503
||add|7,xr|8,wa||point to ctblk entry|12504
||mov|8,wa|13,ctchs(xr)||load ctblk entry|12505
||mov|7,xr|3,psave||restore node pointer|12506
||anb|8,wa|13,parm2(xr)||and with selected bit|12507
||zrb|8,wa|6,pspn3||jump if no match|12508
||icv|8,wb|||else push cursor|12509
||bct|8,wc|6,pspn2||loop back unless end of string|12510
|pspn3|bne|8,wb|3,psavc|6,succp|succeed if chars matched|12514
||brn|6,failp|||else fail if null string matched|12515
||ejc|||||12516
|p_sps|ent|2,bl_p1|||p1blk|12522
||mov|8,wc|3,pmssl||get subject string length|12523
||sub|8,wc|8,wb||calculate number of characters left|12524
||bze|8,wc|6,failp||fail if no characters left|12525
||mov|7,xl|3,r_pms||else point to subject string|12526
||plc|7,xl|8,wb||point to current character|12527
||mov|3,psavc|8,wb||save initial cursor|12528
||lct|8,wc|8,wc||set counter for characters left|12529
|psps1|lch|8,wa|10,(xl)+||load next character, bump pointer|12533
||bne|8,wa|13,parm1(xr)|6,psps2|jump if no match|12534
||icv|8,wb|||else push cursor|12535
||bct|8,wc|6,psps1||and loop unless end of string|12536
|psps2|bne|8,wb|3,psavc|6,succp|succeed if chars matched|12540
||brn|6,failp|||fail if null string matched|12541
||ejc|||||12542
|p_str|ent|2,bl_p1|||p1blk|12551
||mov|7,xl|13,parm1(xr)||get pointer to string|12552
|pstr1|mov|3,psave|7,xr||save node pointer|12556
||mov|7,xr|3,r_pms||load subject string pointer|12557
||plc|7,xr|8,wb||point to current character|12558
||add|8,wb|13,sclen(xl)||compute new cursor position|12559
||bgt|8,wb|3,pmssl|6,failp|fail if past end of string|12560
||mov|3,psavc|8,wb||save updated cursor|12561
||mov|8,wa|13,sclen(xl)||get number of chars to compare|12562
||plc|7,xl|||point to chars of test string|12563
||cmc|6,failp|6,failp||compare, fail if not equal|12564
||mov|7,xr|3,psave||if all matched, restore node ptr|12565
||mov|8,wb|3,psavc||restore updated cursor|12566
||brn|6,succp|||and succeed|12567
||ejc|||||12568
|p_suc|ent|2,bl_p0|||p0blk|12577
||mov|11,-(xs)|8,wb||stack cursor|12578
||mov|11,-(xs)|7,xr||stack pointer to this node|12579
||brn|6,succp|||succeed matching null|12580
||ejc|||||12581
|p_tab|ent|2,bl_p1|||p1blk|12587
|ptab1|bgt|8,wb|13,parm1(xr)|6,failp|fail if too far already|12591
||mov|8,wb|13,parm1(xr)||else set new cursor position|12592
||ble|8,wb|3,pmssl|6,succp|succeed if not off end|12593
||brn|6,failp|||else fail|12594
||ejc|||||12595
|p_tbd|ent|2,bl_p1|||p1blk|12601
||jsr|6,evali|||evaluate integer argument|12602
||err|1,057|26,tab evaluated argument is not integer|||12603
||err|1,058|26,tab evaluated argument is negative or too large|||12604
||ppm|6,failp|||fail if evaluation fails|12605
||ppm|6,ptab1|||merge with normal case if ok|12606
||ejc|||||12607
|p_una|ent||||entry point|12613
||mov|7,xr|8,wb||copy initial pattern node pointer|12614
||mov|8,wb|9,(xs)||get initial cursor|12615
||beq|8,wb|3,pmssl|6,exfal|match fails if at end of string|12616
||icv|8,wb|||else increment cursor|12617
||mov|9,(xs)|8,wb||store incremented cursor|12618
||mov|11,-(xs)|7,xr||restack initial node ptr|12619
||mov|11,-(xs)|21,=nduna||restack unanchored node|12620
||bri|9,(xr)|||rematch first node|12621
||ejc|||||12622
|p_yyy|ent|2,bl__i|||mark last entry in pattern section|12630
||ttl|27,s p i t b o l -- snobol4 built-in label routines||||12631
||ejc|||||12642
|l_abo|ent||||entry point|12646
|labo1|mov|8,wa|3,kvert||load error code|12650
||bze|8,wa|6,labo3||jump if no error has occured|12651
||jsr|6,sysax|||call after execution proc|12653
||mov|8,wc|3,kvstn||current statement|12657
||jsr|6,filnm|||obtain file name for this statement|12658
||mov|7,xr|3,r_cod||current code block|12661
||mov|8,wc|13,cdsln(xr)||line number|12662
||zer|8,wb|||column number|12666
||mov|7,xr|3,stage|||12667
||jsr|6,sysea|||advise system of error|12668
||ppm|6,stpr4|||if system does not want print|12669
||jsr|6,prtpg|||else eject printer|12671
||bze|7,xr|6,labo2||did sysea request print|12673
||jsr|6,prtst|||print text from sysea|12674
|labo2|jsr|6,ermsg|||print error message|12676
||zer|7,xr|||indicate no message to print|12677
||brn|6,stopr|||jump to routine to stop run|12678
|labo3|erb|1,036|26,goto abort with no preceding error|||12682
||ejc|||||12683
|l_cnt|ent||||entry point|12687
|lcnt1|mov|7,xr|3,r_cnt||load continuation code block ptr|12691
||bze|7,xr|6,lcnt3||jump if no previous error|12692
||zer|3,r_cnt|||clear flag|12693
||mov|3,r_cod|7,xr||else store as new code block ptr|12694
||bne|9,(xr)|22,=b_cdc|6,lcnt2|jump if not complex go|12695
||mov|8,wa|3,stxoc||get offset of error|12696
||bge|8,wa|3,stxof|6,lcnt4|jump if error in goto evaluation|12697
|lcnt2|add|7,xr|3,stxof||add failure offset|12701
||lcp|7,xr|||load code pointer|12702
||mov|7,xs|3,flptr||reset stack pointer|12703
||lcw|7,xr|||get next code word|12704
||bri|9,(xr)|||execute next code word|12705
|lcnt3|icv|3,errft|||fatal error|12709
||erb|1,037|26,goto continue with no preceding error|||12710
|lcnt4|icv|3,errft|||fatal error|12715
||erb|1,332|26,goto continue with error in failure goto|||12716
||ejc|||||12717
|l_end|ent||||entry point|12721
|lend0|mov|7,xr|21,=endms||point to message /normal term.../|12725
||brn|6,stopr|||jump to routine to stop run|12726
||ejc|||||12727
|l_frt|ent||||entry point|12731
||mov|8,wa|21,=scfrt||point to string /freturn/|12732
||brn|6,retrn|||jump to common return routine|12733
||ejc|||||12734
|l_nrt|ent||||entry point|12738
||mov|8,wa|21,=scnrt||point to string /nreturn/|12739
||brn|6,retrn|||jump to common return routine|12740
||ejc|||||12741
|l_rtn|ent||||entry point|12745
||mov|8,wa|21,=scrtn||point to string /return/|12746
||brn|6,retrn|||jump to common return routine|12747
||ejc|||||12748
|l_scn|ent||||entry point|12752
||mov|7,xr|3,r_cnt||load continuation code block ptr|12753
||bze|7,xr|6,lscn2||jump if no previous error|12754
||zer|3,r_cnt|||clear flag|12755
||bne|3,kvert|18,=nm320|6,lscn1|error must be user interrupt|12756
||beq|3,kvert|18,=nm321|6,lscn2|detect scontinue loop|12757
||mov|3,r_cod|7,xr||else store as new code block ptr|12758
||add|7,xr|3,stxoc||add resume offset|12759
||lcp|7,xr|||load code pointer|12760
||lcw|7,xr|||get next code word|12761
||bri|9,(xr)|||execute next code word|12762
|lscn1|icv|3,errft|||fatal error|12766
||erb|1,331|26,goto scontinue with no user interrupt|||12767
|lscn2|icv|3,errft|||fatal error|12771
||erb|1,321|26,goto scontinue with no preceding error|||12772
||ejc|||||12773
|l_und|ent||||entry point|12777
||erb|1,038|26,goto undefined label|||12778
||ttl|27,s p i t b o l -- predefined snobol4 functions||||12779
||ejc|||||12804
|s_any|ent||||entry point|12858
||mov|8,wb|22,=p_ans||set pcode for single char case|12859
||mov|7,xl|22,=p_any||pcode for multi-char case|12860
||mov|8,wc|22,=p_ayd||pcode for expression case|12861
||jsr|6,patst|||call common routine to build node|12862
||err|1,059|26,any argument is not a string or expression|||12863
||mov|11,-(xs)|7,xr||stack result|12864
||lcw|7,xr|||get next code word|12865
||bri|9,(xr)|||execute it|12866
||ejc|||||12867
|s_app|ent||||entry point|12893
||bze|8,wa|6,sapp3||jump if no arguments|12894
||dcv|8,wa|||else get applied func arg count|12895
||mov|8,wb|8,wa||copy|12896
||wtb|8,wb|||convert to bytes|12897
||mov|7,xt|7,xs||copy stack pointer|12898
||add|7,xt|8,wb||point to function argument on stack|12899
||mov|7,xr|9,(xt)||load function ptr (apply 1st arg)|12900
||bze|8,wa|6,sapp2||jump if no args for applied func|12901
||lct|8,wb|8,wa||else set counter for loop|12902
|sapp1|dca|7,xt|||point to next argument|12906
||mov|13,num01(xt)|9,(xt)||move argument up|12907
||bct|8,wb|6,sapp1||loop till all moved|12908
|sapp2|ica|7,xs|||adjust stack ptr for apply 1st arg|12912
||jsr|6,gtnvr|||get variable block addr for func|12913
||ppm|6,sapp3|||jump if not natural variable|12914
||mov|7,xl|13,vrfnc(xr)||else point to function block|12915
||brn|6,cfunc|||go call applied function|12916
|sapp3|erb|1,060|26,apply first arg is not natural variable name|||12920
||ejc|||||12921
|s_abn|ent||||entry point|12928
||zer|7,xr|||set parm1 = 0 for the moment|12929
||mov|8,wb|22,=p_alt||set pcode for alternative node|12930
||jsr|6,pbild|||build alternative node|12931
||mov|7,xl|7,xr||save ptr to alternative pattern|12932
||mov|8,wb|22,=p_abc||pcode for p_abc|12933
||zer|7,xr|||p0blk|12934
||jsr|6,pbild|||build p_abc node|12935
||mov|13,pthen(xr)|7,xl||put alternative node as successor|12936
||mov|8,wa|7,xl||remember alternative node pointer|12937
||mov|7,xl|7,xr||copy p_abc node ptr|12938
||mov|7,xr|9,(xs)||load arbno argument|12939
||mov|9,(xs)|8,wa||stack alternative node pointer|12940
||jsr|6,gtpat|||get arbno argument as pattern|12941
||err|1,061|26,arbno argument is not pattern|||12942
||jsr|6,pconc|||concat arg with p_abc node|12943
||mov|7,xl|7,xr||remember ptr to concd patterns|12944
||mov|8,wb|22,=p_aba||pcode for p_aba|12945
||zer|7,xr|||p0blk|12946
||jsr|6,pbild|||build p_aba node|12947
||mov|13,pthen(xr)|7,xl||concatenate nodes|12948
||mov|7,xl|9,(xs)||recall ptr to alternative node|12949
||mov|13,parm1(xl)|7,xr||point alternative back to argument|12950
||lcw|7,xr|||get next code word|12951
||bri|9,(xr)|||execute next code word|12952
||ejc|||||12953
|s_arg|ent||||entry point|12957
||jsr|6,gtsmi|||get second arg as small integer|12958
||err|1,062|26,arg second argument is not integer|||12959
||ppm|6,exfal|||fail if out of range or negative|12960
||mov|8,wa|7,xr||save argument number|12961
||mov|7,xr|10,(xs)+||load first argument|12962
||jsr|6,gtnvr|||locate vrblk|12963
||ppm|6,sarg1|||jump if not natural variable|12964
||mov|7,xr|13,vrfnc(xr)||else load function block pointer|12965
||bne|9,(xr)|22,=b_pfc|6,sarg1|jump if not program defined|12966
||bze|8,wa|6,exfal||fail if arg number is zero|12967
||bgt|8,wa|13,fargs(xr)|6,exfal|fail if arg number is too large|12968
||wtb|8,wa|||else convert to byte offset|12969
||add|7,xr|8,wa||point to argument selected|12970
||mov|7,xr|13,pfagb(xr)||load argument vrblk pointer|12971
||brn|6,exvnm|||exit to build nmblk|12972
|sarg1|erb|1,063|26,arg first argument is not program function name|||12976
||ejc|||||12977
|s_arr|ent||||entry point|12981
||mov|7,xl|10,(xs)+||load initial element value|12982
||mov|7,xr|10,(xs)+||load first argument|12983
||jsr|6,gtint|||convert first arg to integer|12984
||ppm|6,sar02|||jump if not integer|12985
||ldi|13,icval(xr)|||load integer value|12989
||ile|6,sar10|||jump if zero or neg (bad dimension)|12990
||mfi|8,wa|6,sar11||else convert to one word, test ovfl|12991
||jsr|6,vmake|||create vector|12992
||ppm|6,sar11|||fail if too large|12993
||brn|6,exsid|||exit setting idval|12994
||ejc|||||12995
|sar02|mov|11,-(xs)|7,xr||replace argument on stack|13001
||jsr|6,xscni|||initialize scan of first argument|13002
||err|1,064|26,array first argument is not integer or string|||13003
||ppm|6,exnul|||dummy (unused) null string exit|13004
||mov|11,-(xs)|3,r_xsc||save prototype pointer|13005
||mov|11,-(xs)|7,xl||save default value|13006
||zer|3,arcdm|||zero count of dimensions|13007
||zer|3,arptr|||zero offset to indicate pass one|13008
||ldi|4,intv1|||load integer one|13009
||sti|3,arnel|||initialize element count|13010
|sar03|ldi|4,intv1|||load one as default low bound|13017
||sti|3,arsvl|||save as low bound|13018
||mov|8,wc|18,=ch_cl||set delimiter one = colon|13019
||mov|7,xl|18,=ch_cm||set delimiter two = comma|13020
||zer|8,wa|||retain blanks in prototype|13021
||jsr|6,xscan|||scan next bound|13022
||bne|8,wa|18,=num01|6,sar04|jump if not colon|13023
||jsr|6,gtint|||convert low bound|13027
||err|1,065|26,array first argument lower bound is not integer|||13028
||ldi|13,icval(xr)|||load value of low bound|13029
||sti|3,arsvl|||store low bound value|13030
||mov|8,wc|18,=ch_cm||set delimiter one = comma|13031
||mov|7,xl|8,wc||and delimiter two = comma|13032
||zer|8,wa|||retain blanks in prototype|13033
||jsr|6,xscan|||scan high bound|13034
||ejc|||||13035
|sar04|jsr|6,gtint|||convert high bound to integer|13041
||err|1,066|26,array first argument upper bound is not integer|||13042
||ldi|13,icval(xr)|||get high bound|13043
||sbi|3,arsvl|||subtract lower bound|13044
||iov|6,sar10|||bad dimension if overflow|13045
||ilt|6,sar10|||bad dimension if negative|13046
||adi|4,intv1|||add 1 to get dimension|13047
||iov|6,sar10|||bad dimension if overflow|13048
||mov|7,xl|3,arptr||load offset (also pass indicator)|13049
||bze|7,xl|6,sar05||jump if first pass|13050
||add|7,xl|9,(xs)||point to current location in arblk|13054
||sti|13,cfp_i(xl)|||store dimension|13055
||ldi|3,arsvl|||load low bound|13056
||sti|9,(xl)|||store low bound|13057
||add|3,arptr|19,*ardms||bump offset to next bounds|13058
||brn|6,sar06|||jump to check for end of bounds|13059
|sar05|icv|3,arcdm|||bump dimension count|13063
||mli|3,arnel|||multiply dimension by count so far|13064
||iov|6,sar11|||too large if overflow|13065
||sti|3,arnel|||else store updated element count|13066
|sar06|bnz|8,wa|6,sar03||loop back unless end of bounds|13070
||bnz|3,arptr|6,sar09||jump if end of pass 2|13071
||ejc|||||13072
||ldi|3,arnel|||get number of elements|13078
||mfi|8,wb|6,sar11||get as addr integer, test ovflo|13079
||wtb|8,wb|||else convert to length in bytes|13080
||mov|8,wa|19,*arsi_||set size of standard fields|13081
||lct|8,wc|3,arcdm||set dimension count to control loop|13082
|sar07|add|8,wa|19,*ardms||allow space for one set of bounds|13086
||bct|8,wc|6,sar07||loop back till all accounted for|13087
||mov|7,xl|8,wa||save size (=arofs)|13088
||add|8,wa|8,wb||add space for elements|13092
||ica|8,wa|||allow for arpro prototype field|13093
||bgt|8,wa|3,mxlen|6,sar11|fail if too large|13094
||jsr|6,alloc|||else allocate arblk|13095
||mov|8,wb|9,(xs)||load default value|13096
||mov|9,(xs)|7,xr||save arblk pointer|13097
||mov|8,wc|8,wa||save length in bytes|13098
||btw|8,wa|||convert length back to words|13099
||lct|8,wa|8,wa||set counter to control loop|13100
|sar08|mov|10,(xr)+|8,wb||set one word|13104
||bct|8,wa|6,sar08||loop till all set|13105
||ejc|||||13106
||mov|7,xr|10,(xs)+||reload arblk pointer|13112
||mov|8,wb|9,(xs)||load prototype|13113
||mov|9,(xr)|22,=b_art||set type word|13114
||mov|13,arlen(xr)|8,wc||store length in bytes|13115
||zer|13,idval(xr)|||zero id till we get it built|13116
||mov|13,arofs(xr)|7,xl||set prototype field ptr|13117
||mov|13,arndm(xr)|3,arcdm||set number of dimensions|13118
||mov|8,wc|7,xr||save arblk pointer|13119
||add|7,xr|7,xl||point to prototype field|13120
||mov|9,(xr)|8,wb||store prototype ptr in arblk|13121
||mov|3,arptr|19,*arlbd||set offset for pass 2 bounds scan|13122
||mov|3,r_xsc|8,wb||reset string pointer for xscan|13123
||mov|9,(xs)|8,wc||store arblk pointer on stack|13124
||zer|3,xsofs|||reset offset ptr to start of string|13125
||brn|6,sar03|||jump back to rescan bounds|13126
|sar09|mov|7,xr|10,(xs)+||reload pointer to arblk|13130
||brn|6,exsid|||exit setting idval|13131
|sar10|erb|1,067|26,array dimension is zero, negative or out of range|||13135
|sar11|erb|1,068|26,array size exceeds maximum permitted|||13139
||ejc|||||13140
|s_atn|ent||||entry point|13145
||mov|7,xr|10,(xs)+||get argument|13146
||jsr|6,gtrea|||convert to real|13147
||err|1,301|26,atan argument not numeric|||13148
||ldr|13,rcval(xr)|||load accumulator with argument|13149
||atn||||take arctangent|13150
||brn|6,exrea|||overflow, out of range not possible|13151
||ejc|||||13152
||ejc|||||13155
|s_bsp|ent||||entry point|13159
||jsr|6,iofcb|||call fcblk routine|13160
||err|1,316|26,backspace argument is not a suitable name|||13161
||err|1,316|26,backspace argument is not a suitable name|||13162
||err|1,317|26,backspace file does not exist|||13163
||jsr|6,sysbs|||call backspace file function|13164
||err|1,317|26,backspace file does not exist|||13165
||err|1,318|26,backspace file does not permit backspace|||13166
||err|1,319|26,backspace caused non-recoverable error|||13167
||brn|6,exnul|||return null as result|13168
||ejc|||||13169
|s_brk|ent||||entry point|13202
||mov|8,wb|22,=p_bks||set pcode for single char case|13203
||mov|7,xl|22,=p_brk||pcode for multi-char case|13204
||mov|8,wc|22,=p_bkd||pcode for expression case|13205
||jsr|6,patst|||call common routine to build node|13206
||err|1,069|26,break argument is not a string or expression|||13207
||mov|11,-(xs)|7,xr||stack result|13208
||lcw|7,xr|||get next code word|13209
||bri|9,(xr)|||execute it|13210
||ejc|||||13211
|s_bkx|ent||||entry point|13218
||mov|8,wb|22,=p_bks||pcode for single char argument|13219
||mov|7,xl|22,=p_brk||pcode for multi-char argument|13220
||mov|8,wc|22,=p_bxd||pcode for expression case|13221
||jsr|6,patst|||call common routine to build node|13222
||err|1,070|26,breakx argument is not a string or expression|||13223
||mov|11,-(xs)|7,xr||save ptr to break node|13227
||mov|8,wb|22,=p_bkx||set pcode for breakx node|13228
||jsr|6,pbild|||build it|13229
||mov|13,pthen(xr)|9,(xs)||set break node as successor|13230
||mov|8,wb|22,=p_alt||set pcode for alternation node|13231
||jsr|6,pbild|||build (parm1=alt=breakx node)|13232
||mov|8,wa|7,xr||save ptr to alternation node|13233
||mov|7,xr|9,(xs)||point to break node|13234
||mov|13,pthen(xr)|8,wa||set alternate node as successor|13235
||lcw|7,xr|||result on stack|13236
||bri|9,(xr)|||execute next code word|13237
||ejc|||||13238
|s_chr|ent||||entry point|13242
||jsr|6,gtsmi|||convert arg to integer|13243
||err|1,281|26,char argument not integer|||13244
||ppm|6,schr1|||too big error exit|13245
||bge|8,wc|18,=cfp_a|6,schr1|see if out of range of host set|13246
||mov|8,wa|18,=num01||if not set scblk allocation|13247
||mov|8,wb|8,wc||save char code|13248
||jsr|6,alocs|||allocate 1 bau scblk|13249
||mov|7,xl|7,xr||copy scblk pointer|13250
||psc|7,xl|||get set to stuff char|13251
||sch|8,wb|9,(xl)||stuff it|13252
||csc|7,xl|||complete store character|13253
||zer|7,xl|||clear slop in xl|13254
||mov|11,-(xs)|7,xr||stack result|13255
||lcw|7,xr|||get next code word|13256
||bri|9,(xr)|||execute it|13257
|schr1|erb|1,282|26,char argument not in range|||13261
||ejc|||||13262
|s_chp|ent||||entry point|13267
||mov|7,xr|10,(xs)+||get argument|13268
||jsr|6,gtrea|||convert to real|13269
||err|1,302|26,chop argument not numeric|||13270
||ldr|13,rcval(xr)|||load accumulator with argument|13271
||chp||||truncate to integer valued real|13272
||brn|6,exrea|||no overflow possible|13273
||ejc|||||13274
|s_clr|ent||||entry point|13279
||jsr|6,xscni|||initialize to scan argument|13280
||err|1,071|26,clear argument is not a string|||13281
||ppm|6,sclr2|||jump if null|13282
|sclr1|mov|8,wc|18,=ch_cm||set delimiter one = comma|13287
||mov|7,xl|8,wc||delimiter two = comma|13288
||mnz|8,wa|||skip/trim blanks in prototype|13289
||jsr|6,xscan|||scan next variable name|13290
||jsr|6,gtnvr|||locate vrblk|13291
||err|1,072|26,clear argument has null variable name|||13292
||zer|13,vrget(xr)|||else flag by zeroing vrget field|13293
||bnz|8,wa|6,sclr1||loop back if stopped by comma|13294
|sclr2|mov|8,wb|3,hshtb||point to start of hash table|13298
|sclr3|beq|8,wb|3,hshte|6,exnul|exit returning null if none left|13302
||mov|7,xr|8,wb||else copy slot pointer|13303
||ica|8,wb|||bump slot pointer|13304
||sub|7,xr|19,*vrnxt||set offset to merge into loop|13305
|sclr4|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|13309
||bze|7,xr|6,sclr3||jump for next bucket if chain end|13310
||bnz|13,vrget(xr)|6,sclr5||jump if not flagged|13311
||ejc|||||13312
||jsr|6,setvr|||for flagged var, restore vrget|13318
||brn|6,sclr4|||and loop back for next vrblk|13319
|sclr5|beq|13,vrsto(xr)|22,=b_vre|6,sclr4|check for protected variable|13324
||mov|7,xl|7,xr||copy vrblk pointer|13325
|sclr6|mov|8,wa|7,xl||save block pointer|13329
||mov|7,xl|13,vrval(xl)||load next value field|13330
||beq|9,(xl)|22,=b_trt|6,sclr6|loop back if trapped|13331
||mov|7,xl|8,wa||restore block pointer|13335
||mov|13,vrval(xl)|21,=nulls||store null constant value|13336
||brn|6,sclr4|||loop back for next vrblk|13337
||ejc|||||13338
|s_cod|ent||||entry point|13342
||mov|7,xr|10,(xs)+||load argument|13343
||jsr|6,gtcod|||convert to code|13344
||ppm|6,exfal|||fail if conversion is impossible|13345
||mov|11,-(xs)|7,xr||stack result|13346
||zer|3,r_ccb|||forget interim code block|13347
||lcw|7,xr|||get next code word|13348
||bri|9,(xr)|||execute it|13349
||ejc|||||13350
|s_col|ent||||entry point|13354
||mov|7,xr|10,(xs)+||load argument|13355
||jsr|6,gtint|||convert to integer|13356
||err|1,073|26,collect argument is not integer|||13357
||ldi|13,icval(xr)|||load collect argument|13358
||sti|3,clsvi|||save collect argument|13359
||zer|8,wb|||set no move up|13360
||zer|3,r_ccb|||forget interim code block|13361
||zer|3,dnams|||collect sediment too|13363
||jsr|6,gbcol|||perform garbage collection|13364
||mov|3,dnams|7,xr||record new sediment size|13365
||mov|8,wa|3,dname||point to end of memory|13369
||sub|8,wa|3,dnamp||subtract next location|13370
||btw|8,wa|||convert bytes to words|13371
||mti|8,wa|||convert words available as integer|13372
||sbi|3,clsvi|||subtract argument|13373
||iov|6,exfal|||fail if overflow|13374
||ilt|6,exfal|||fail if not enough|13375
||adi|3,clsvi|||else recompute available|13376
||brn|6,exint|||and exit with integer result|13377
||ejc|||||13378
|s_cnv|ent||||entry point|13407
||jsr|6,gtstg|||convert second argument to string|13408
||ppm|6,scv29|||error if second argument not string|13409
||bze|8,wa|6,scv29||or if null string|13410
||jsr|6,flstg|||fold upper case to lower case|13412
||mov|7,xl|9,(xs)||load first argument|13414
||bne|9,(xl)|22,=b_pdt|6,scv01|jump if not program defined|13415
||mov|7,xl|13,pddfp(xl)||point to dfblk|13419
||mov|7,xl|13,dfnam(xl)||load datatype name|13420
||jsr|6,ident|||compare with second arg|13421
||ppm|6,exits|||exit if ident with arg as result|13422
||brn|6,exfal|||else fail|13423
|scv01|mov|11,-(xs)|7,xr||save string argument|13427
||mov|7,xl|21,=svctb||point to table of names to compare|13428
||zer|8,wb|||initialize counter|13429
||mov|8,wc|8,wa||save length of argument string|13430
|scv02|mov|7,xr|10,(xl)+||load next table entry, bump pointer|13434
||bze|7,xr|6,exfal||fail if zero marking end of list|13435
||bne|8,wc|13,sclen(xr)|6,scv05|jump if wrong length|13436
||mov|3,cnvtp|7,xl||else store table pointer|13437
||plc|7,xr|||point to chars of table entry|13438
||mov|7,xl|9,(xs)||load pointer to string argument|13439
||plc|7,xl|||point to chars of string arg|13440
||mov|8,wa|8,wc||set number of chars to compare|13441
||cmc|6,scv04|6,scv04||compare, jump if no match|13442
||ejc|||||13443
|scv03|mov|7,xl|8,wb||copy entry number|13449
||ica|7,xs|||pop string arg off stack|13450
||mov|7,xr|10,(xs)+||load first argument|13451
||bsw|7,xl|2,cnvtt||jump to appropriate routine|13452
||iff|1,0|6,scv06||string|13470
||iff|1,1|6,scv07||integer|13470
||iff|1,2|6,scv09||name|13470
||iff|1,3|6,scv10||pattern|13470
||iff|1,4|6,scv11||array|13470
||iff|1,5|6,scv19||table|13470
||iff|1,6|6,scv25||expression|13470
||iff|1,7|6,scv26||code|13470
||iff|1,8|6,scv27||numeric|13470
||iff|2,cnvrt|6,scv08||real|13470
||esw||||end of switch table|13470
|scv04|mov|7,xl|3,cnvtp||restore table pointer, merge|13474
|scv05|icv|8,wb|||bump entry number|13478
||brn|6,scv02|||loop back to check next entry|13479
|scv06|mov|11,-(xs)|7,xr||replace string argument on stack|13483
||jsr|6,gtstg|||convert to string|13484
||ppm|6,exfal|||fail if conversion not possible|13485
||mov|11,-(xs)|7,xr||stack result|13486
||lcw|7,xr|||get next code word|13487
||bri|9,(xr)|||execute it|13488
||ejc|||||13489
|scv07|jsr|6,gtint|||convert to integer|13495
||ppm|6,exfal|||fail if conversion not possible|13496
||mov|11,-(xs)|7,xr||stack result|13497
||lcw|7,xr|||get next code word|13498
||bri|9,(xr)|||execute it|13499
|scv08|jsr|6,gtrea|||convert to real|13505
||ppm|6,exfal|||fail if conversion not possible|13506
||mov|11,-(xs)|7,xr||stack result|13507
||lcw|7,xr|||get next code word|13508
||bri|9,(xr)|||execute it|13509
|scv09|beq|9,(xr)|22,=b_nml|6,exixr|return if already a name|13514
||jsr|6,gtnvr|||else try string to name convert|13515
||ppm|6,exfal|||fail if conversion not possible|13516
||brn|6,exvnm|||else exit building nmblk for vrblk|13517
|scv10|jsr|6,gtpat|||convert to pattern|13521
||ppm|6,exfal|||fail if conversion not possible|13522
||mov|11,-(xs)|7,xr||stack result|13523
||lcw|7,xr|||get next code word|13524
||bri|9,(xr)|||execute it|13525
|scv11|mov|11,-(xs)|7,xr||save argument on stack|13534
||zer|8,wa|||use table chain block addresses|13535
||jsr|6,gtarr|||get an array|13536
||ppm|6,exfal|||fail if empty table|13537
||ppm|6,exfal|||fail if not convertible|13538
||mov|7,xl|10,(xs)+||reload original arg|13539
||bne|9,(xl)|22,=b_tbt|6,exsid|exit if original not a table|13540
||mov|11,-(xs)|7,xr||sort the intermediate array|13541
||mov|11,-(xs)|21,=nulls||on first column|13542
||zer|8,wa|||sort ascending|13543
||jsr|6,sorta|||do sort|13544
||ppm|6,exfal|||if sort fails, so shall we|13545
||mov|8,wb|7,xr||save array result|13546
||ldi|13,ardim(xr)|||load dim 1 (number of elements)|13547
||mfi|8,wa|||get as one word integer|13548
||lct|8,wa|8,wa||copy to control loop|13549
||add|7,xr|19,*arvl2||point to first element in array|13550
|scv12|mov|7,xl|9,(xr)||get teblk address|13554
||mov|10,(xr)+|13,tesub(xl)||replace with subscript|13555
||mov|10,(xr)+|13,teval(xl)||replace with value|13556
||bct|8,wa|6,scv12||loop till all copied over|13557
||mov|7,xr|8,wb||retrieve array address|13558
||brn|6,exsid|||exit setting id field|13559
|scv19|mov|8,wa|9,(xr)||load first word of block|13563
||mov|11,-(xs)|7,xr||replace arblk pointer on stack|13564
||beq|8,wa|22,=b_tbt|6,exits|return arg if already a table|13565
||bne|8,wa|22,=b_art|6,exfal|else fail if not an array|13566
||ejc|||||13567
||bne|13,arndm(xr)|18,=num02|6,exfal|fail if not 2-dim array|13573
||ldi|13,ardm2(xr)|||load dim 2|13574
||sbi|4,intv2|||subtract 2 to compare|13575
||ine|6,exfal|||fail if dim2 not 2|13576
||ldi|13,ardim(xr)|||load dim 1 (number of elements)|13580
||mfi|8,wa|||get as one word integer|13581
||lct|8,wb|8,wa||copy to control loop|13582
||add|8,wa|18,=tbsi_||add space for standard fields|13583
||wtb|8,wa|||convert length to bytes|13584
||jsr|6,alloc|||allocate space for tbblk|13585
||mov|8,wc|7,xr||copy tbblk pointer|13586
||mov|11,-(xs)|7,xr||save tbblk pointer|13587
||mov|10,(xr)+|22,=b_tbt||store type word|13588
||zer|10,(xr)+|||store zero for idval for now|13589
||mov|10,(xr)+|8,wa||store length|13590
||mov|10,(xr)+|21,=nulls||null initial lookup value|13591
|scv20|mov|10,(xr)+|8,wc||set bucket ptr to point to tbblk|13595
||bct|8,wb|6,scv20||loop till all initialized|13596
||mov|8,wb|19,*arvl2||set offset to first arblk element|13597
|scv21|mov|7,xl|13,num01(xs)||point to arblk|13601
||beq|8,wb|13,arlen(xl)|6,scv24|jump if all moved|13602
||add|7,xl|8,wb||else point to current location|13603
||add|8,wb|19,*num02||bump offset|13604
||mov|7,xr|9,(xl)||load subscript name|13605
||dca|7,xl|||adjust ptr to merge (trval=1+1)|13606
||ejc|||||13607
|scv22|mov|7,xl|13,trval(xl)||point to next value|13613
||beq|9,(xl)|22,=b_trt|6,scv22|loop back if trapped|13614
|scv23|mov|11,-(xs)|7,xl||stack value|13618
||mov|7,xl|13,num01(xs)||load tbblk pointer|13619
||jsr|6,tfind|||build teblk (note wb gt 0 by name)|13620
||ppm|6,exfal|||fail if acess fails|13621
||mov|13,teval(xl)|10,(xs)+||store value in teblk|13622
||brn|6,scv21|||loop back for next element|13623
|scv24|mov|7,xr|10,(xs)+||load tbblk pointer|13627
||ica|7,xs|||pop arblk pointer|13628
||brn|6,exsid|||exit setting idval|13629
|scv25|zer|8,wb|||by value|13634
||jsr|6,gtexp|||convert to expression|13635
||ppm|6,exfal|||fail if conversion not possible|13639
||zer|3,r_ccb|||forget interim code block|13640
||mov|11,-(xs)|7,xr||stack result|13641
||lcw|7,xr|||get next code word|13642
||bri|9,(xr)|||execute it|13643
|scv26|jsr|6,gtcod|||convert to code|13647
||ppm|6,exfal|||fail if conversion is not possible|13648
||zer|3,r_ccb|||forget interim code block|13649
||mov|11,-(xs)|7,xr||stack result|13650
||lcw|7,xr|||get next code word|13651
||bri|9,(xr)|||execute it|13652
|scv27|jsr|6,gtnum|||convert to numeric|13656
||ppm|6,exfal|||fail if unconvertible|13657
|scv31|mov|11,-(xs)|7,xr||stack result|13658
||lcw|7,xr|||get next code word|13659
||bri|9,(xr)|||execute it|13660
||ejc|||||13661
|scv29|erb|1,074|26,convert second argument is not a string|||13687
|s_cop|ent||||entry point|13691
||jsr|6,copyb|||copy the block|13692
||ppm|6,exits|||return if no idval field|13693
||brn|6,exsid|||exit setting id value|13694
||ejc|||||13695
|s_cos|ent||||entry point|13700
||mov|7,xr|10,(xs)+||get argument|13701
||jsr|6,gtrea|||convert to real|13702
||err|1,303|26,cos argument not numeric|||13703
||ldr|13,rcval(xr)|||load accumulator with argument|13704
||cos||||take cosine|13705
||rno|6,exrea|||if no overflow, return result in ra|13706
||erb|1,322|26,cos argument is out of range|||13707
||ejc|||||13708
|s_dat|ent||||entry point|13713
||jsr|6,xscni|||prepare to scan argument|13714
||err|1,075|26,data argument is not a string|||13715
||err|1,076|26,data argument is null|||13716
||mov|8,wc|18,=ch_pp||delimiter one = left paren|13720
||mov|7,xl|8,wc||delimiter two = left paren|13721
||mnz|8,wa|||skip/trim blanks in prototype|13722
||jsr|6,xscan|||scan datatype name|13723
||bnz|8,wa|6,sdat1||skip if left paren found|13724
||erb|1,077|26,data argument is missing a left paren|||13725
|sdat1|mov|8,wa|13,sclen(xr)||get length|13730
||bze|8,wa|6,sdt1a||avoid folding if null string|13731
||jsr|6,flstg|||fold upper case to lower case|13732
|sdt1a|mov|7,xl|7,xr||save name ptr|13733
||mov|8,wa|13,sclen(xr)||get length|13737
||ctb|8,wa|2,scsi_||compute space needed|13738
||jsr|6,alost|||request static store for name|13739
||mov|11,-(xs)|7,xr||save datatype name|13740
||mvw||||copy name to static|13741
||mov|7,xr|9,(xs)||get name ptr|13742
||zer|7,xl|||scrub dud register|13743
||jsr|6,gtnvr|||locate vrblk for datatype name|13744
||err|1,078|26,data argument has null datatype name|||13745
||mov|3,datdv|7,xr||save vrblk pointer for datatype|13746
||mov|3,datxs|7,xs||store starting stack value|13747
||zer|8,wb|||zero count of field names|13748
|sdat2|mov|8,wc|18,=ch_rp||delimiter one = right paren|13752
||mov|7,xl|18,=ch_cm||delimiter two = comma|13753
||mnz|8,wa|||skip/trim blanks in prototype|13754
||jsr|6,xscan|||scan next field name|13755
||bnz|8,wa|6,sdat3||jump if delimiter found|13756
||erb|1,079|26,data argument is missing a right paren|||13757
|sdat3|jsr|6,gtnvr|||locate vrblk for field name|13761
||err|1,080|26,data argument has null field name|||13762
||mov|11,-(xs)|7,xr||stack vrblk pointer|13763
||icv|8,wb|||increment counter|13764
||beq|8,wa|18,=num02|6,sdat2|loop back if stopped by comma|13765
||ejc|||||13766
||mov|8,wa|18,=dfsi_||set size of dfblk standard fields|13772
||add|8,wa|8,wb||add number of fields|13773
||wtb|8,wa|||convert length to bytes|13774
||mov|8,wc|8,wb||preserve no. of fields|13775
||jsr|6,alost|||allocate space for dfblk|13776
||mov|8,wb|8,wc||get no of fields|13777
||mov|7,xt|3,datxs||point to start of stack|13778
||mov|8,wc|9,(xt)||load datatype name|13779
||mov|9,(xt)|7,xr||save dfblk pointer on stack|13780
||mov|10,(xr)+|22,=b_dfc||store type word|13781
||mov|10,(xr)+|8,wb||store number of fields (fargs)|13782
||mov|10,(xr)+|8,wa||store length (dflen)|13783
||sub|8,wa|19,*pddfs||compute pdblk length (for dfpdl)|13784
||mov|10,(xr)+|8,wa||store pdblk length (dfpdl)|13785
||mov|10,(xr)+|8,wc||store datatype name (dfnam)|13786
||lct|8,wc|8,wb||copy number of fields|13787
|sdat4|mov|10,(xr)+|11,-(xt)||move one field name vrblk pointer|13791
||bct|8,wc|6,sdat4||loop till all moved|13792
||mov|8,wc|8,wa||copy length of pdblk for later loop|13796
||mov|7,xr|3,datdv||point to vrblk|13797
||mov|7,xt|3,datxs||point back on stack|13798
||mov|7,xl|9,(xt)||load dfblk pointer|13799
||jsr|6,dffnc|||define function|13800
||ejc|||||13801
|sdat5|mov|8,wa|19,*ffsi_||set length of ffblk|13812
||jsr|6,alloc|||allocate space for ffblk|13813
||mov|9,(xr)|22,=b_ffc||set type word|13814
||mov|13,fargs(xr)|18,=num01||store fargs (always one)|13815
||mov|7,xt|3,datxs||point back on stack|13816
||mov|13,ffdfp(xr)|9,(xt)||copy dfblk ptr to ffblk|13817
||dca|8,wc|||decrement old dfpdl to get next ofs|13818
||mov|13,ffofs(xr)|8,wc||set offset to this field|13819
||zer|13,ffnxt(xr)|||tentatively set zero forward ptr|13820
||mov|7,xl|7,xr||copy ffblk pointer for dffnc|13821
||mov|7,xr|9,(xs)||load vrblk pointer for field|13822
||mov|7,xr|13,vrfnc(xr)||load current function pointer|13823
||bne|9,(xr)|22,=b_ffc|6,sdat6|skip if not currently a field func|13824
||mov|13,ffnxt(xl)|7,xr||link new ffblk to previous chain|13829
|sdat6|mov|7,xr|10,(xs)+||load vrblk pointer|13833
||jsr|6,dffnc|||define field function|13834
||bne|7,xs|3,datxs|6,sdat5|loop back till all done|13835
||ica|7,xs|||pop dfblk pointer|13836
||brn|6,exnul|||return with null result|13837
||ejc|||||13838
|s_dtp|ent||||entry point|13842
||mov|7,xr|10,(xs)+||load argument|13843
||jsr|6,dtype|||get datatype|13844
||mov|11,-(xs)|7,xr||stack result|13845
||lcw|7,xr|||get next code word|13846
||bri|9,(xr)|||execute it|13847
||ejc|||||13848
|s_dte|ent||||entry point|13852
||mov|7,xr|10,(xs)+||load argument|13853
||jsr|6,gtint|||convert to an integer|13854
||err|1,330|26,date argument is not integer|||13855
||jsr|6,sysdt|||call system date routine|13856
||mov|8,wa|13,num01(xl)||load length for sbstr|13857
||bze|8,wa|6,exnul||return null if length is zero|13858
||zer|8,wb|||set zero offset|13859
||jsr|6,sbstr|||use sbstr to build scblk|13860
||mov|11,-(xs)|7,xr||stack result|13861
||lcw|7,xr|||get next code word|13862
||bri|9,(xr)|||execute it|13863
||ejc|||||13864
|s_def|ent||||entry point|13868
||mov|7,xr|10,(xs)+||load second argument|13869
||zer|3,deflb|||zero label pointer in case null|13870
||beq|7,xr|21,=nulls|6,sdf01|jump if null second argument|13871
||jsr|6,gtnvr|||else find vrblk for label|13872
||ppm|6,sdf12|||jump if not a variable name|13873
||mov|3,deflb|7,xr||else set specified entry|13874
|sdf01|jsr|6,xscni|||prepare to scan first argument|13878
||err|1,081|26,define first argument is not a string|||13879
||err|1,082|26,define first argument is null|||13880
||mov|8,wc|18,=ch_pp||delimiter one = left paren|13881
||mov|7,xl|8,wc||delimiter two = left paren|13882
||mnz|8,wa|||skip/trim blanks in prototype|13883
||jsr|6,xscan|||scan out function name|13884
||bnz|8,wa|6,sdf02||jump if left paren found|13885
||erb|1,083|26,define first argument is missing a left paren|||13886
|sdf02|jsr|6,gtnvr|||get variable name|13890
||err|1,084|26,define first argument has null function name|||13891
||mov|3,defvr|7,xr||save vrblk pointer for function nam|13892
||zer|8,wb|||zero count of arguments|13893
||mov|3,defxs|7,xs||save initial stack pointer|13894
||bnz|3,deflb|6,sdf03||jump if second argument given|13895
||mov|3,deflb|7,xr||else default is function name|13896
|sdf03|mov|8,wc|18,=ch_rp||delimiter one = right paren|13900
||mov|7,xl|18,=ch_cm||delimiter two = comma|13901
||mnz|8,wa|||skip/trim blanks in prototype|13902
||jsr|6,xscan|||scan out next argument name|13903
||bnz|8,wa|6,sdf04||skip if delimiter found|13904
||erb|1,085|26,null arg name or missing ) in define first arg.|||13905
||ejc|||||13906
|sdf04|bne|7,xr|21,=nulls|6,sdf05|skip if non-null|13912
||bze|8,wb|6,sdf06||ignore null if case of no arguments|13913
|sdf05|jsr|6,gtnvr|||get vrblk pointer|13917
||ppm|6,sdf03|||loop back to ignore null name|13918
||mov|11,-(xs)|7,xr||stack argument vrblk pointer|13919
||icv|8,wb|||increment counter|13920
||beq|8,wa|18,=num02|6,sdf03|loop back if stopped by a comma|13921
|sdf06|mov|3,defna|8,wb||save number of arguments|13925
||zer|8,wb|||zero count of locals|13926
|sdf07|mov|8,wc|18,=ch_cm||set delimiter one = comma|13930
||mov|7,xl|8,wc||set delimiter two = comma|13931
||mnz|8,wa|||skip/trim blanks in prototype|13932
||jsr|6,xscan|||scan out next local name|13933
||bne|7,xr|21,=nulls|6,sdf08|skip if non-null|13934
||bze|8,wa|6,sdf09||exit scan if end of string|13935
|sdf08|jsr|6,gtnvr|||get vrblk pointer|13939
||ppm|6,sdf07|||loop back to ignore null name|13940
||icv|8,wb|||if ok, increment count|13941
||mov|11,-(xs)|7,xr||stack vrblk pointer|13942
||bnz|8,wa|6,sdf07||loop back if stopped by a comma|13943
||ejc|||||13944
|sdf09|mov|8,wa|8,wb||copy count of locals|13950
||add|8,wa|3,defna||add number of arguments|13951
||mov|8,wc|8,wa||set sum args+locals as loop count|13952
||add|8,wa|18,=pfsi_||add space for standard fields|13953
||wtb|8,wa|||convert length to bytes|13954
||jsr|6,alloc|||allocate space for pfblk|13955
||mov|7,xl|7,xr||save pointer to pfblk|13956
||mov|10,(xr)+|22,=b_pfc||store first word|13957
||mov|10,(xr)+|3,defna||store number of arguments|13958
||mov|10,(xr)+|8,wa||store length (pflen)|13959
||mov|10,(xr)+|3,defvr||store vrblk ptr for function name|13960
||mov|10,(xr)+|8,wb||store number of locals|13961
||zer|10,(xr)+|||deal with label later|13962
||zer|10,(xr)+|||zero pfctr|13963
||zer|10,(xr)+|||zero pfrtr|13964
||bze|8,wc|6,sdf11||skip if no args or locals|13965
||mov|8,wa|7,xl||keep pfblk pointer|13966
||mov|7,xt|3,defxs||point before arguments|13967
||lct|8,wc|8,wc||get count of args+locals for loop|13968
|sdf10|mov|10,(xr)+|11,-(xt)||store one entry and bump pointers|13972
||bct|8,wc|6,sdf10||loop till all stored|13973
||mov|7,xl|8,wa||recover pfblk pointer|13974
||ejc|||||13975
|sdf11|mov|7,xs|3,defxs||pop stack|13981
||mov|13,pfcod(xl)|3,deflb||store label vrblk in pfblk|13982
||mov|7,xr|3,defvr||point back to vrblk for function|13983
||jsr|6,dffnc|||define function|13984
||brn|6,exnul|||and exit returning null|13985
|sdf12|erb|1,086|26,define function entry point is not defined label|||13989
||ejc|||||13990
|s_det|ent||||entry point|13994
||mov|7,xr|10,(xs)+||load argument|13995
||jsr|6,gtvar|||locate variable|13996
||err|1,087|26,detach argument is not appropriate name|||13997
||jsr|6,dtach|||detach i/o association from name|13998
||brn|6,exnul|||return null result|13999
||ejc|||||14000
|s_dif|ent||||entry point|14004
||mov|7,xr|10,(xs)+||load second argument|14005
||mov|7,xl|10,(xs)+||load first argument|14006
||jsr|6,ident|||call ident comparison routine|14007
||ppm|6,exfal|||fail if ident|14008
||brn|6,exnul|||return null if differ|14009
||ejc|||||14010
|s_dmp|ent||||entry point|14014
||jsr|6,gtsmi|||load dump arg as small integer|14015
||err|1,088|26,dump argument is not integer|||14016
||err|1,089|26,dump argument is negative or too large|||14017
||jsr|6,dumpr|||else call dump routine|14018
||brn|6,exnul|||and return null as result|14019
||ejc|||||14020
|s_dup|ent||||entry point|14024
||jsr|6,gtsmi|||get second argument as small integr|14025
||err|1,090|26,dupl second argument is not integer|||14026
||ppm|6,sdup7|||jump if negative or too big|14027
||mov|8,wb|7,xr||save duplication factor|14028
||jsr|6,gtstg|||get first arg as string|14029
||ppm|6,sdup4|||jump if not a string|14030
||mti|8,wa|||acquire length as integer|14034
||sti|3,dupsi|||save for the moment|14035
||mti|8,wb|||get duplication factor as integer|14036
||mli|3,dupsi|||form product|14037
||iov|6,sdup3|||jump if overflow|14038
||ieq|6,exnul|||return null if result length = 0|14039
||mfi|8,wa|6,sdup3||get as addr integer, check ovflo|14040
|sdup1|mov|7,xl|7,xr||save string pointer|14044
||jsr|6,alocs|||allocate space for string|14045
||mov|11,-(xs)|7,xr||save as result pointer|14046
||mov|8,wc|7,xl||save pointer to argument string|14047
||psc|7,xr|||prepare to store chars of result|14048
||lct|8,wb|8,wb||set counter to control loop|14049
|sdup2|mov|7,xl|8,wc||point back to argument string|14053
||mov|8,wa|13,sclen(xl)||get number of characters|14054
||plc|7,xl|||point to chars in argument string|14055
||mvc||||move characters to result string|14056
||bct|8,wb|6,sdup2||loop till all duplications done|14057
||zer|7,xl|||clear garbage value|14058
||lcw|7,xr|||get next code word|14059
||bri|9,(xr)|||execute next code word|14060
||ejc|||||14061
|sdup3|mov|8,wa|3,dname||set impossible length for alocs|14067
||brn|6,sdup1|||merge back|14068
|sdup4|jsr|6,gtpat|||convert argument to pattern|14072
||err|1,091|26,dupl first argument is not a string or pattern|||14073
||mov|11,-(xs)|7,xr||store pattern on stack|14077
||mov|7,xr|21,=ndnth||start off with null pattern|14078
||bze|8,wb|6,sdup6||null pattern is result if dupfac=0|14079
||mov|11,-(xs)|8,wb||preserve loop count|14080
|sdup5|mov|7,xl|7,xr||copy current value as right argumnt|14084
||mov|7,xr|13,num01(xs)||get a new copy of left|14085
||jsr|6,pconc|||concatenate|14086
||dcv|9,(xs)|||count down|14087
||bnz|9,(xs)|6,sdup5||loop|14088
||ica|7,xs|||pop loop count|14089
|sdup6|mov|9,(xs)|7,xr||store result on stack|14093
||lcw|7,xr|||get next code word|14094
||bri|9,(xr)|||execute next code word|14095
|sdup7|ica|7,xs|||pop first argument|14099
||brn|6,exfal|||fail|14100
||ejc|||||14101
|s_ejc|ent||||entry point|14105
||jsr|6,iofcb|||call fcblk routine|14106
||err|1,092|26,eject argument is not a suitable name|||14107
||ppm|6,sejc1|||null argument|14108
||err|1,093|26,eject file does not exist|||14109
||jsr|6,sysef|||call eject file function|14110
||err|1,093|26,eject file does not exist|||14111
||err|1,094|26,eject file does not permit page eject|||14112
||err|1,095|26,eject caused non-recoverable output error|||14113
||brn|6,exnul|||return null as result|14114
|sejc1|jsr|6,sysep|||call routine to eject printer|14118
||brn|6,exnul|||exit with null result|14119
||ejc|||||14120
|s_enf|ent||||entry point|14124
||jsr|6,iofcb|||call fcblk routine|14125
||err|1,096|26,endfile argument is not a suitable name|||14126
||err|1,097|26,endfile argument is null|||14127
||err|1,098|26,endfile file does not exist|||14128
||jsr|6,sysen|||call endfile routine|14129
||err|1,098|26,endfile file does not exist|||14130
||err|1,099|26,endfile file does not permit endfile|||14131
||err|1,100|26,endfile caused non-recoverable output error|||14132
||mov|8,wb|7,xl||remember vrblk ptr from iofcb call|14133
||mov|7,xr|7,xl||copy pointer|14134
|senf1|mov|7,xl|7,xr||remember previous entry|14138
||mov|7,xr|13,trval(xr)||chain along|14139
||bne|9,(xr)|22,=b_trt|6,exnul|skip out if chain end|14140
||bne|13,trtyp(xr)|18,=trtfc|6,senf1|loop if not found|14141
||mov|13,trval(xl)|13,trval(xr)||remove trtrf|14142
||mov|3,enfch|13,trtrf(xr)||point to head of iochn|14143
||mov|8,wc|13,trfpt(xr)||point to fcblk|14144
||mov|7,xr|8,wb||filearg1 vrblk from iofcb|14145
||jsr|6,setvr|||reset it|14146
||mov|7,xl|20,=r_fcb||ptr to head of fcblk chain|14147
||sub|7,xl|19,*num02||adjust ready to enter loop|14148
|senf2|mov|7,xr|7,xl||copy ptr|14152
||mov|7,xl|13,num02(xl)||get next link|14153
||bze|7,xl|6,senf4||stop if chain end|14154
||beq|13,num03(xl)|8,wc|6,senf3|jump if fcblk found|14155
||brn|6,senf2|||loop|14156
|senf3|mov|13,num02(xr)|13,num02(xl)||delete fcblk from chain|14160
|senf4|mov|7,xl|3,enfch||get chain head|14164
||bze|7,xl|6,exnul||finished if chain end|14165
||mov|3,enfch|13,trtrf(xl)||chain along|14166
||mov|8,wa|13,ionmo(xl)||name offset|14167
||mov|7,xl|13,ionmb(xl)||name base|14168
||jsr|6,dtach|||detach name|14169
||brn|6,senf4|||loop till done|14170
||ejc|||||14171
|s_eqf|ent||||entry point|14175
||jsr|6,acomp|||call arithmetic comparison routine|14176
||err|1,101|26,eq first argument is not numeric|||14177
||err|1,102|26,eq second argument is not numeric|||14178
||ppm|6,exfal|||fail if lt|14179
||ppm|6,exnul|||return null if eq|14180
||ppm|6,exfal|||fail if gt|14181
||ejc|||||14182
|s_evl|ent||||entry point|14186
||mov|7,xr|10,(xs)+||load argument|14187
||lcw|8,wc|||load next code word|14193
||bne|8,wc|21,=ofne_|6,sevl1|jump if called by value|14194
||scp|7,xl|||copy code pointer|14195
||mov|8,wa|9,(xl)||get next code word|14196
||bne|8,wa|21,=ornm_|6,sevl2|by name unless expression|14197
||bnz|13,num01(xs)|6,sevl2||jump if by name|14198
|sevl1|zer|8,wb|||set flag for by value|14202
||mov|11,-(xs)|8,wc||save code word|14204
||jsr|6,gtexp|||convert to expression|14205
||err|1,103|26,eval argument is not expression|||14206
||zer|3,r_ccb|||forget interim code block|14207
||zer|8,wb|||set flag for by value|14208
||jsr|6,evalx|||evaluate expression by value|14212
||ppm|6,exfal|||fail if evaluation fails|14213
||mov|7,xl|7,xr||copy result|14214
||mov|7,xr|9,(xs)||reload next code word|14215
||mov|9,(xs)|7,xl||stack result|14216
||bri|9,(xr)|||jump to execute next code word|14217
|sevl2|mov|8,wb|18,=num01||set flag for by name|14221
||jsr|6,gtexp|||convert to expression|14223
||err|1,103|26,eval argument is not expression|||14224
||zer|3,r_ccb|||forget interim code block|14225
||mov|8,wb|18,=num01||set flag for by name|14226
||jsr|6,evalx|||evaluate expression by name|14228
||ppm|6,exfal|||fail if evaluation fails|14229
||brn|6,exnam|||exit with name|14230
||ejc|||||14233
|s_ext|ent||||entry point|14237
||zer|8,wb|||clear amount of static shift|14238
||zer|3,r_ccb|||forget interim code block|14239
||zer|3,dnams|||collect sediment too|14241
||jsr|6,gbcol|||compact memory by collecting|14242
||mov|3,dnams|7,xr||record new sediment size|14243
||jsr|6,gtstg||||14247
||err|1,288|26,exit second argument is not a string|||14248
||mov|7,xl|7,xr||copy second arg string pointer|14249
||jsr|6,gtstg|||convert arg to string|14250
||err|1,104|26,exit first argument is not suitable integer or string|||14251
||mov|11,-(xs)|7,xl||save second argument|14252
||mov|7,xl|7,xr||copy first arg string ptr|14253
||jsr|6,gtint|||check it is integer|14254
||ppm|6,sext1|||skip if unconvertible|14255
||zer|7,xl|||note it is integer|14256
||ldi|13,icval(xr)|||get integer arg|14257
|sext1|mov|8,wb|3,r_fcb||get fcblk chain header|14261
||mov|7,xr|21,=headv||point to v.v string|14262
||mov|8,wa|10,(xs)+||provide second argument scblk|14263
||jsr|6,sysxi|||call external routine|14264
||err|1,105|26,exit action not available in this implementation|||14265
||err|1,106|26,exit action caused irrecoverable error|||14266
||ieq|6,exnul|||return if argument 0|14267
||igt|6,sext2|||skip if positive|14268
||ngi||||make positive|14269
|sext2|mfi|8,wc|||get value in work reg|14277
||add|8,wa|8,wc||prepare to test for continue|14278
||beq|8,wa|18,=num05|6,sext5|continued execution if 4 plus 1|14279
||zer|3,gbcnt|||resuming execution so reset|14280
||bge|8,wc|18,=num03|6,sext3|skip if was 3 or 4|14281
||mov|11,-(xs)|8,wc||save value|14282
||zer|8,wc|||set to read options|14283
||jsr|6,prpar|||read syspp options|14284
||mov|8,wc|10,(xs)+||restore value|14285
|sext3|mnz|3,headp|||assume no headers|14289
||bne|8,wc|18,=num01|6,sext4|skip if not 1|14290
||zer|3,headp|||request header printing|14291
|sext4|jsr|6,systm|||get execution time start (sgd11)|14295
||sti|3,timsx|||save as initial time|14296
||ldi|3,kvstc|||reset to ensure ...|14297
||sti|3,kvstl|||... correct execution stats|14298
||jsr|6,stgcc|||recompute countdown counters|14299
||brn|6,exnul|||resume execution|14300
|sext5|mov|7,xr|21,=inton||integer one|14308
||brn|6,exixr|||return as result|14309
||ejc|||||14311
|s_exp|ent||||entry point|14316
||mov|7,xr|10,(xs)+||get argument|14317
||jsr|6,gtrea|||convert to real|14318
||err|1,304|26,exp argument not numeric|||14319
||ldr|13,rcval(xr)|||load accumulator with argument|14320
||etx||||take exponential|14321
||rno|6,exrea|||if no overflow, return result in ra|14322
||erb|1,305|26,exp produced real overflow|||14323
||ejc|||||14324
|s_fld|ent||||entry point|14329
||jsr|6,gtsmi|||get second argument (field number)|14330
||err|1,107|26,field second argument is not integer|||14331
||ppm|6,exfal|||fail if out of range|14332
||mov|8,wb|7,xr||else save integer value|14333
||mov|7,xr|10,(xs)+||load first argument|14334
||jsr|6,gtnvr|||point to vrblk|14335
||ppm|6,sfld1|||jump (error) if not variable name|14336
||mov|7,xr|13,vrfnc(xr)||else point to function block|14337
||bne|9,(xr)|22,=b_dfc|6,sfld1|error if not datatype function|14338
||bze|8,wb|6,exfal||fail if argument number is zero|14342
||bgt|8,wb|13,fargs(xr)|6,exfal|fail if too large|14343
||wtb|8,wb|||else convert to byte offset|14344
||add|7,xr|8,wb||point to field name|14345
||mov|7,xr|13,dfflb(xr)||load vrblk pointer|14346
||brn|6,exvnm|||exit to build nmblk|14347
|sfld1|erb|1,108|26,field first argument is not datatype name|||14351
||ejc|||||14352
|s_fnc|ent||||entry point|14356
||mov|8,wb|22,=p_fnc||set pcode for p_fnc|14357
||zer|7,xr|||p0blk|14358
||jsr|6,pbild|||build p_fnc node|14359
||mov|7,xl|7,xr||save pointer to it|14360
||mov|7,xr|10,(xs)+||get argument|14361
||jsr|6,gtpat|||convert to pattern|14362
||err|1,259|26,fence argument is not pattern|||14363
||jsr|6,pconc|||concatenate to p_fnc node|14364
||mov|7,xl|7,xr||save ptr to concatenated pattern|14365
||mov|8,wb|22,=p_fna||set for p_fna pcode|14366
||zer|7,xr|||p0blk|14367
||jsr|6,pbild|||construct p_fna node|14368
||mov|13,pthen(xr)|7,xl||set pattern as pthen|14369
||mov|11,-(xs)|7,xr||set as result|14370
||lcw|7,xr|||get next code word|14371
||bri|9,(xr)|||execute next code word|14372
||ejc|||||14373
|s_gef|ent||||entry point|14377
||jsr|6,acomp|||call arithmetic comparison routine|14378
||err|1,109|26,ge first argument is not numeric|||14379
||err|1,110|26,ge second argument is not numeric|||14380
||ppm|6,exfal|||fail if lt|14381
||ppm|6,exnul|||return null if eq|14382
||ppm|6,exnul|||return null if gt|14383
||ejc|||||14384
|s_gtf|ent||||entry point|14388
||jsr|6,acomp|||call arithmetic comparison routine|14389
||err|1,111|26,gt first argument is not numeric|||14390
||err|1,112|26,gt second argument is not numeric|||14391
||ppm|6,exfal|||fail if lt|14392
||ppm|6,exfal|||fail if eq|14393
||ppm|6,exnul|||return null if gt|14394
||ejc|||||14395
|s_hst|ent||||entry point|14399
||mov|8,wc|10,(xs)+||get fifth arg|14400
||mov|8,wb|10,(xs)+||get fourth arg|14401
||mov|7,xr|10,(xs)+||get third arg|14402
||mov|7,xl|10,(xs)+||get second arg|14403
||mov|8,wa|10,(xs)+||get first arg|14404
||jsr|6,syshs|||enter syshs routine|14405
||err|1,254|26,erroneous argument for host|||14406
||err|1,255|26,error during execution of host|||14407
||ppm|6,shst1|||store host string|14408
||ppm|6,exnul|||return null result|14409
||ppm|6,exixr|||return xr|14410
||ppm|6,exfal|||fail return|14411
||ppm|6,shst3|||store actual string|14412
||ppm|6,shst4|||return copy of xr|14413
|shst1|bze|7,xl|6,exnul||null string if syshs uncooperative|14417
||mov|8,wa|13,sclen(xl)||length|14418
||zer|8,wb|||zero offset|14419
|shst2|jsr|6,sbstr|||build copy of string|14423
||mov|11,-(xs)|7,xr||stack the result|14424
||lcw|7,xr|||load next code word|14425
||bri|9,(xr)|||execute it|14426
|shst3|zer|8,wb|||treat xl like an scblk ptr|14430
||sub|8,wb|18,=cfp_f||by creating a negative offset|14431
||brn|6,shst2|||join to copy string|14432
|shst4|mov|11,-(xs)|7,xr||stack results|14436
||jsr|6,copyb|||make copy of block|14437
||ppm|6,exits|||if not an aggregate structure|14438
||brn|6,exsid|||set current id value otherwise|14439
||ejc|||||14440
|s_idn|ent||||entry point|14444
||mov|7,xr|10,(xs)+||load second argument|14445
||mov|7,xl|10,(xs)+||load first argument|14446
||jsr|6,ident|||call ident comparison routine|14447
||ppm|6,exnul|||return null if ident|14448
||brn|6,exfal|||fail if differ|14449
||ejc|||||14450
|s_inp|ent||||entry point|14454
||zer|8,wb|||input flag|14455
||jsr|6,ioput|||call input/output assoc. routine|14456
||err|1,113|26,input third argument is not a string|||14457
||err|1,114|26,inappropriate second argument for input|||14458
||err|1,115|26,inappropriate first argument for input|||14459
||err|1,116|26,inappropriate file specification for input|||14460
||ppm|6,exfal|||fail if file does not exist|14461
||err|1,117|26,input file cannot be read|||14462
||err|1,289|26,input channel currently in use|||14463
||brn|6,exnul|||return null string|14464
||ejc|||||14465
|s_int|ent||||entry point|14498
||mov|7,xr|10,(xs)+||load argument|14499
||jsr|6,gtnum|||convert to numeric|14500
||ppm|6,exfal|||fail if non-numeric|14501
||beq|8,wa|22,=b_icl|6,exnul|return null if integer|14502
||brn|6,exfal|||fail if real|14503
||ejc|||||14504
|s_itm|ent||||entry point|14511
||bnz|8,wa|6,sitm1||jump if at least one arg|14515
||mov|11,-(xs)|21,=nulls||else supply garbage null arg|14516
||mov|8,wa|18,=num01||and fix argument count|14517
|sitm1|scp|7,xr|||get current code pointer|14521
||mov|7,xl|9,(xr)||load next code word|14522
||dcv|8,wa|||get number of subscripts|14523
||mov|7,xr|8,wa||copy for arref|14524
||beq|7,xl|21,=ofne_|6,sitm2|jump if called by name|14525
||zer|8,wb|||set code for call by value|14529
||brn|6,arref|||off to array reference routine|14530
|sitm2|mnz|8,wb|||set code for call by name|14534
||lcw|8,wa|||load and ignore ofne_ call|14535
||brn|6,arref|||off to array reference routine|14536
||ejc|||||14537
|s_lef|ent||||entry point|14541
||jsr|6,acomp|||call arithmetic comparison routine|14542
||err|1,118|26,le first argument is not numeric|||14543
||err|1,119|26,le second argument is not numeric|||14544
||ppm|6,exnul|||return null if lt|14545
||ppm|6,exnul|||return null if eq|14546
||ppm|6,exfal|||fail if gt|14547
||ejc|||||14548
|s_len|ent||||entry point|14552
||mov|8,wb|22,=p_len||set pcode for integer arg case|14553
||mov|8,wa|22,=p_lnd||set pcode for expr arg case|14554
||jsr|6,patin|||call common routine to build node|14555
||err|1,120|26,len argument is not integer or expression|||14556
||err|1,121|26,len argument is negative or too large|||14557
||mov|11,-(xs)|7,xr||stack result|14558
||lcw|7,xr|||get next code word|14559
||bri|9,(xr)|||execute it|14560
||ejc|||||14561
|s_leq|ent||||entry point|14565
||jsr|6,lcomp|||call string comparison routine|14566
||err|1,122|26,leq first argument is not a string|||14567
||err|1,123|26,leq second argument is not a string|||14568
||ppm|6,exfal|||fail if llt|14569
||ppm|6,exnul|||return null if leq|14570
||ppm|6,exfal|||fail if lgt|14571
||ejc|||||14572
|s_lge|ent||||entry point|14576
||jsr|6,lcomp|||call string comparison routine|14577
||err|1,124|26,lge first argument is not a string|||14578
||err|1,125|26,lge second argument is not a string|||14579
||ppm|6,exfal|||fail if llt|14580
||ppm|6,exnul|||return null if leq|14581
||ppm|6,exnul|||return null if lgt|14582
||ejc|||||14583
|s_lgt|ent||||entry point|14587
||jsr|6,lcomp|||call string comparison routine|14588
||err|1,126|26,lgt first argument is not a string|||14589
||err|1,127|26,lgt second argument is not a string|||14590
||ppm|6,exfal|||fail if llt|14591
||ppm|6,exfal|||fail if leq|14592
||ppm|6,exnul|||return null if lgt|14593
||ejc|||||14594
|s_lle|ent||||entry point|14598
||jsr|6,lcomp|||call string comparison routine|14599
||err|1,128|26,lle first argument is not a string|||14600
||err|1,129|26,lle second argument is not a string|||14601
||ppm|6,exnul|||return null if llt|14602
||ppm|6,exnul|||return null if leq|14603
||ppm|6,exfal|||fail if lgt|14604
||ejc|||||14605
|s_llt|ent||||entry point|14609
||jsr|6,lcomp|||call string comparison routine|14610
||err|1,130|26,llt first argument is not a string|||14611
||err|1,131|26,llt second argument is not a string|||14612
||ppm|6,exnul|||return null if llt|14613
||ppm|6,exfal|||fail if leq|14614
||ppm|6,exfal|||fail if lgt|14615
||ejc|||||14616
|s_lne|ent||||entry point|14620
||jsr|6,lcomp|||call string comparison routine|14621
||err|1,132|26,lne first argument is not a string|||14622
||err|1,133|26,lne second argument is not a string|||14623
||ppm|6,exnul|||return null if llt|14624
||ppm|6,exfal|||fail if leq|14625
||ppm|6,exnul|||return null if lgt|14626
||ejc|||||14627
|s_lnf|ent||||entry point|14632
||mov|7,xr|10,(xs)+||get argument|14633
||jsr|6,gtrea|||convert to real|14634
||err|1,306|26,ln argument not numeric|||14635
||ldr|13,rcval(xr)|||load accumulator with argument|14636
||req|6,slnf1|||overflow if argument is 0|14637
||rlt|6,slnf2|||error if argument less than 0|14638
||lnf||||take natural logarithm|14639
||rno|6,exrea|||if no overflow, return result in ra|14640
|slnf1|erb|1,307|26,ln produced real overflow|||14641
|slnf2|erb|1,315|26,ln argument negative|||14645
||ejc|||||14646
|s_loc|ent||||entry point|14651
||jsr|6,gtsmi|||get second argument (local number)|14652
||err|1,134|26,local second argument is not integer|||14653
||ppm|6,exfal|||fail if out of range|14654
||mov|8,wb|7,xr||save local number|14655
||mov|7,xr|10,(xs)+||load first argument|14656
||jsr|6,gtnvr|||point to vrblk|14657
||ppm|6,sloc1|||jump if not variable name|14658
||mov|7,xr|13,vrfnc(xr)||else load function pointer|14659
||bne|9,(xr)|22,=b_pfc|6,sloc1|jump if not program defined|14660
||bze|8,wb|6,exfal||fail if second arg is zero|14664
||bgt|8,wb|13,pfnlo(xr)|6,exfal|or too large|14665
||add|8,wb|13,fargs(xr)||else adjust offset to include args|14666
||wtb|8,wb|||convert to bytes|14667
||add|7,xr|8,wb||point to local pointer|14668
||mov|7,xr|13,pfagb(xr)||load vrblk pointer|14669
||brn|6,exvnm|||exit building nmblk|14670
|sloc1|erb|1,135|26,local first arg is not a program function name|||14674
||ejc|||||14677
|s_lod|ent||||entry point|14681
||jsr|6,gtstg|||load library name|14682
||err|1,136|26,load second argument is not a string|||14683
||mov|7,xl|7,xr||save library name|14684
||jsr|6,xscni|||prepare to scan first argument|14685
||err|1,137|26,load first argument is not a string|||14686
||err|1,138|26,load first argument is null|||14687
||mov|11,-(xs)|7,xl||stack library name|14688
||mov|8,wc|18,=ch_pp||set delimiter one = left paren|14689
||mov|7,xl|8,wc||set delimiter two = left paren|14690
||mnz|8,wa|||skip/trim blanks in prototype|14691
||jsr|6,xscan|||scan function name|14692
||mov|11,-(xs)|7,xr||save ptr to function name|14693
||bnz|8,wa|6,slod1||jump if left paren found|14694
||erb|1,139|26,load first argument is missing a left paren|||14695
|slod1|jsr|6,gtnvr|||locate vrblk|14699
||err|1,140|26,load first argument has null function name|||14700
||mov|3,lodfn|7,xr||save vrblk pointer|14701
||zer|3,lodna|||zero count of arguments|14702
|slod2|mov|8,wc|18,=ch_rp||delimiter one is right paren|14706
||mov|7,xl|18,=ch_cm||delimiter two is comma|14707
||mnz|8,wa|||skip/trim blanks in prototype|14708
||jsr|6,xscan|||scan next argument name|14709
||icv|3,lodna|||bump argument count|14710
||bnz|8,wa|6,slod3||jump if ok delimiter was found|14711
||erb|1,141|26,load first argument is missing a right paren|||14712
||ejc|||||14713
|slod3|mov|8,wb|8,wa||save scan mode|14722
||mov|8,wa|13,sclen(xr)||datatype length|14723
||bze|8,wa|6,sld3a||bypass if null string|14724
||jsr|6,flstg|||fold to lower case|14725
|sld3a|mov|8,wa|8,wb||restore scan mode|14726
||mov|11,-(xs)|7,xr||stack datatype name pointer|14727
||mov|8,wb|18,=num01||set string code in case|14731
||mov|7,xl|21,=scstr||point to /string/|14732
||jsr|6,ident|||check for match|14733
||ppm|6,slod4|||jump if match|14734
||mov|7,xr|9,(xs)||else reload name|14735
||add|8,wb|8,wb||set code for integer (2)|14736
||mov|7,xl|21,=scint||point to /integer/|14737
||jsr|6,ident|||check for match|14738
||ppm|6,slod4|||jump if match|14739
||mov|7,xr|9,(xs)||else reload string pointer|14742
||icv|8,wb|||set code for real (3)|14743
||mov|7,xl|21,=screa||point to /real/|14744
||jsr|6,ident|||check for match|14745
||ppm|6,slod4|||jump if match|14746
||mov|7,xr|9,(xs)||reload string pointer|14749
||icv|8,wb|||code for file (4, or 3 if no reals)|14750
||mov|7,xl|21,=scfil||point to /file/|14751
||jsr|6,ident|||check for match|14752
||ppm|6,slod4|||jump if match|14753
||zer|8,wb|||else get code for no convert|14755
|slod4|mov|9,(xs)|8,wb||store code on stack|14759
||beq|8,wa|18,=num02|6,slod2|loop back if arg stopped by comma|14760
||bze|8,wa|6,slod5||jump if that was the result type|14761
||mov|8,wc|3,mxlen||set dummy (impossible) delimiter 1|14765
||mov|7,xl|8,wc||and delimiter two|14766
||mnz|8,wa|||skip/trim blanks in prototype|14767
||jsr|6,xscan|||scan result name|14768
||zer|8,wa|||set code for processing result|14769
||brn|6,slod3|||jump back to process result name|14770
||ejc|||||14771
|slod5|mov|8,wa|3,lodna||get number of arguments|14777
||mov|8,wc|8,wa||copy for later|14778
||wtb|8,wa|||convert length to bytes|14779
||add|8,wa|19,*efsi_||add space for standard fields|14780
||jsr|6,alloc|||allocate efblk|14781
||mov|9,(xr)|22,=b_efc||set type word|14782
||mov|13,fargs(xr)|8,wc||set number of arguments|14783
||zer|13,efuse(xr)|||set use count (dffnc will set to 1)|14784
||zer|13,efcod(xr)|||zero code pointer for now|14785
||mov|13,efrsl(xr)|10,(xs)+||store result type code|14786
||mov|13,efvar(xr)|3,lodfn||store function vrblk pointer|14787
||mov|13,eflen(xr)|8,wa||store efblk length|14788
||mov|8,wb|7,xr||save efblk pointer|14789
||add|7,xr|8,wa||point past end of efblk|14790
||lct|8,wc|8,wc||set number of arguments for loop|14791
|slod6|mov|11,-(xr)|10,(xs)+||store one type code from stack|14795
||bct|8,wc|6,slod6||loop till all stored|14796
||mov|7,xr|10,(xs)+||load function string name|14800
||mov|8,wa|13,sclen(xr)||function name length|14802
||jsr|6,flstg|||fold to lower case|14803
||mov|7,xl|9,(xs)||load library name|14805
||mov|9,(xs)|8,wb||store efblk pointer|14806
||jsr|6,sysld|||call function to load external func|14807
||err|1,142|26,load function does not exist|||14808
||err|1,143|26,load function caused input error during load|||14809
||err|1,328|26,load function - insufficient memory|||14810
||mov|7,xl|10,(xs)+||recall efblk pointer|14811
||mov|13,efcod(xl)|7,xr||store code pointer|14812
||mov|7,xr|3,lodfn||point to vrblk for function|14813
||jsr|6,dffnc|||perform function definition|14814
||brn|6,exnul|||return null result|14815
||ejc|||||14817
|s_lpd|ent||||entry point|14821
||jsr|6,gtstg|||get pad character|14822
||err|1,144|26,lpad third argument is not a string|||14823
||plc|7,xr|||point to character (null is blank)|14824
||lch|8,wb|9,(xr)||load pad character|14825
||jsr|6,gtsmi|||get pad length|14826
||err|1,145|26,lpad second argument is not integer|||14827
||ppm|6,slpd4|||skip if negative or large|14828
|slpd1|jsr|6,gtstg|||get first argument (string to pad)|14832
||err|1,146|26,lpad first argument is not a string|||14833
||bge|8,wa|8,wc|6,exixr|return 1st arg if too long to pad|14834
||mov|7,xl|7,xr||else move ptr to string to pad|14835
||mov|8,wa|8,wc||copy length|14843
||jsr|6,alocs|||allocate scblk for new string|14844
||mov|11,-(xs)|7,xr||save as result|14845
||mov|8,wa|13,sclen(xl)||load length of argument|14846
||sub|8,wc|8,wa||calculate number of pad characters|14847
||psc|7,xr|||point to chars in result string|14848
||lct|8,wc|8,wc||set counter for pad loop|14849
|slpd2|sch|8,wb|10,(xr)+||store pad character, bump ptr|14853
||bct|8,wc|6,slpd2||loop till all pad chars stored|14854
||csc|7,xr|||complete store characters|14855
||bze|8,wa|6,slpd3||exit if null string|14859
||plc|7,xl|||else point to chars in argument|14860
||mvc||||move characters to result string|14861
||zer|7,xl|||clear garbage xl|14862
|slpd3|lcw|7,xr|||load next code word|14866
||bri|9,(xr)|||execute it|14867
|slpd4|zer|8,wc|||zero pad count|14871
||brn|6,slpd1|||merge|14872
||ejc|||||14873
|s_ltf|ent||||entry point|14877
||jsr|6,acomp|||call arithmetic comparison routine|14878
||err|1,147|26,lt first argument is not numeric|||14879
||err|1,148|26,lt second argument is not numeric|||14880
||ppm|6,exnul|||return null if lt|14881
||ppm|6,exfal|||fail if eq|14882
||ppm|6,exfal|||fail if gt|14883
||ejc|||||14884
|s_nef|ent||||entry point|14888
||jsr|6,acomp|||call arithmetic comparison routine|14889
||err|1,149|26,ne first argument is not numeric|||14890
||err|1,150|26,ne second argument is not numeric|||14891
||ppm|6,exnul|||return null if lt|14892
||ppm|6,exfal|||fail if eq|14893
||ppm|6,exnul|||return null if gt|14894
||ejc|||||14895
|s_nay|ent||||entry point|14899
||mov|8,wb|22,=p_nas||set pcode for single char arg|14900
||mov|7,xl|22,=p_nay||pcode for multi-char arg|14901
||mov|8,wc|22,=p_nad||set pcode for expr arg|14902
||jsr|6,patst|||call common routine to build node|14903
||err|1,151|26,notany argument is not a string or expression|||14904
||mov|11,-(xs)|7,xr||stack result|14905
||lcw|7,xr|||get next code word|14906
||bri|9,(xr)|||execute it|14907
||ejc|||||14908
|s_ops|ent||||entry point|14912
||jsr|6,gtsmi|||load third argument|14913
||err|1,152|26,opsyn third argument is not integer|||14914
||err|1,153|26,opsyn third argument is negative or too large|||14915
||mov|8,wb|8,wc||if ok, save third argumnet|14916
||mov|7,xr|10,(xs)+||load second argument|14917
||jsr|6,gtnvr|||locate variable block|14918
||err|1,154|26,opsyn second arg is not natural variable name|||14919
||mov|7,xl|13,vrfnc(xr)||if ok, load function block pointer|14920
||bnz|8,wb|6,sops2||jump if operator opsyn case|14921
||mov|7,xr|10,(xs)+||load first argument|14925
||jsr|6,gtnvr|||get vrblk pointer|14926
||err|1,155|26,opsyn first arg is not natural variable name|||14927
|sops1|jsr|6,dffnc|||call function definer|14931
||brn|6,exnul|||exit with null result|14932
|sops2|jsr|6,gtstg|||get operator name|14936
||ppm|6,sops5|||jump if not string|14937
||bne|8,wa|18,=num01|6,sops5|error if not one char long|14938
||plc|7,xr|||else point to character|14939
||lch|8,wc|9,(xr)||load character name|14940
||ejc|||||14941
||mov|8,wa|20,=r_uub||point to unop pointers in case|14949
||mov|7,xr|21,=opnsu||point to names of unary operators|14950
||add|8,wb|18,=opbun||add no. of undefined binary ops|14951
||beq|8,wb|18,=opuun|6,sops3|jump if unop (third arg was 1)|14952
||mov|8,wa|20,=r_uba||else point to binary operator ptrs|14953
||mov|7,xr|21,=opsnb||point to names of binary operators|14954
||mov|8,wb|18,=opbun||set number of undefined binops|14955
|sops3|lct|8,wb|8,wb||set counter to control loop|14959
|sops4|beq|8,wc|9,(xr)|6,sops6|jump if names match|14963
||ica|8,wa|||else push pointer to function ptr|14964
||ica|7,xr|||bump pointer|14965
||bct|8,wb|6,sops4||loop back till all checked|14966
|sops5|erb|1,156|26,opsyn first arg is not correct operator name|||14970
|sops6|mov|7,xr|8,wa||copy pointer to function block ptr|14974
||sub|7,xr|19,*vrfnc||make it look like dummy vrblk|14975
||brn|6,sops1|||merge back to define operator|14976
||ejc|||||14977
|s_oup|ent||||entry point|15002
||mov|8,wb|18,=num03||output flag|15003
||jsr|6,ioput|||call input/output assoc. routine|15004
||err|1,157|26,output third argument is not a string|||15005
||err|1,158|26,inappropriate second argument for output|||15006
||err|1,159|26,inappropriate first argument for output|||15007
||err|1,160|26,inappropriate file specification for output|||15008
||ppm|6,exfal|||fail if file does not exist|15009
||err|1,161|26,output file cannot be written to|||15010
||err|1,290|26,output channel currently in use|||15011
||brn|6,exnul|||return null string|15012
||ejc|||||15013
|s_pos|ent||||entry point|15017
||mov|8,wb|22,=p_pos||set pcode for integer arg case|15018
||mov|8,wa|22,=p_psd||set pcode for expression arg case|15019
||jsr|6,patin|||call common routine to build node|15020
||err|1,162|26,pos argument is not integer or expression|||15021
||err|1,163|26,pos argument is negative or too large|||15022
||mov|11,-(xs)|7,xr||stack result|15023
||lcw|7,xr|||get next code word|15024
||bri|9,(xr)|||execute it|15025
||ejc|||||15026
|s_pro|ent||||entry point|15030
||mov|7,xr|10,(xs)+||load argument|15031
||mov|8,wb|13,tblen(xr)||length if table, vector (=vclen)|15032
||btw|8,wb|||convert to words|15033
||mov|8,wa|9,(xr)||load type word of argument block|15034
||beq|8,wa|22,=b_art|6,spro4|jump if array|15035
||beq|8,wa|22,=b_tbt|6,spro1|jump if table|15036
||beq|8,wa|22,=b_vct|6,spro3|jump if vector|15037
||erb|1,164|26,prototype argument is not valid object|||15042
|spro1|sub|8,wb|18,=tbsi_||subtract standard fields|15046
|spro2|mti|8,wb|||convert to integer|15050
||brn|6,exint|||exit with integer result|15051
|spro3|sub|8,wb|18,=vcsi_||subtract standard fields|15055
||brn|6,spro2|||merge|15056
|spro4|add|7,xr|13,arofs(xr)||point to prototype field|15060
||mov|7,xr|9,(xr)||load prototype|15061
||mov|11,-(xs)|7,xr||stack result|15062
||lcw|7,xr|||get next code word|15063
||bri|9,(xr)|||execute it|15064
||ejc|||||15074
|s_rmd|ent||||entry point|15078
||jsr|6,arith|||get two integers or two reals|15080
||err|1,166|26,remdr first argument is not numeric|||15081
||err|1,165|26,remdr second argument is not numeric|||15082
||ppm|6,srm06|||if real|15083
||zer|8,wb|||set positive flag|15100
||ldi|13,icval(xr)|||load left argument value|15101
||ige|6,srm01|||jump if positive|15102
||mnz|8,wb|||set negative flag|15103
|srm01|rmi|13,icval(xl)|||get remainder|15104
||iov|6,srm05|||error if overflow|15105
||bze|8,wb|6,srm03||if result should be positive|15109
||ile|6,exint|||if should be negative, and is|15110
|srm02|ngi||||adjust sign of result|15111
||brn|6,exint|||return result|15112
|srm03|ilt|6,srm02|||should be pos, and result negative|15113
||brn|6,exint|||should be positive, and is|15114
|srm04|erb|1,166|26,remdr first argument is not numeric|||15118
|srm05|erb|1,167|26,remdr caused integer overflow|||15122
|srm06|zer|8,wb|||set positive flag|15129
||ldr|13,rcval(xr)|||load left argument value|15130
||rge|6,srm07|||jump if positive|15131
||mnz|8,wb|||set negative flag|15132
|srm07|dvr|13,rcval(xl)|||compute n1/n2|15133
||rov|6,srm10|||jump if overflow|15134
||chp||||chop result|15135
||mlr|13,rcval(xl)|||times n2|15136
||sbr|13,rcval(xr)|||compute difference|15137
||bze|8,wb|6,srm09||if result should be positive|15142
||rle|6,exrea|||if should be negative, and is|15143
|srm08|ngr||||adjust sign of result|15144
||brn|6,exrea|||return result|15145
|srm09|rlt|6,srm08|||should be pos, and result negative|15146
||brn|6,exrea|||should be positive, and is|15147
|srm10|erb|1,312|26,remdr caused real overflow|||15151
||ejc|||||15153
|s_rpl|ent||||entry point|15167
||jsr|6,gtstg|||load third argument as string|15168
||err|1,168|26,replace third argument is not a string|||15169
||mov|7,xl|7,xr||save third arg ptr|15170
||jsr|6,gtstg|||get second argument|15171
||err|1,169|26,replace second argument is not a string|||15172
||bne|7,xr|3,r_ra2|6,srpl1|jump if 2nd argument different|15176
||beq|7,xl|3,r_ra3|6,srpl4|jump if args same as last time|15177
|srpl1|mov|8,wb|13,sclen(xl)||load 3rd argument length|15181
||bne|8,wa|8,wb|6,srpl6|jump if arguments not same length|15182
||beq|7,xr|3,kvalp|6,srpl5|jump if 2nd arg is alphabet string|15183
||bze|8,wb|6,srpl6||jump if null 2nd argument|15184
||mov|3,r_ra3|7,xl||save third arg for next time in|15185
||mov|3,r_ra2|7,xr||save second arg for next time in|15186
||mov|7,xl|3,kvalp||point to alphabet string|15187
||mov|8,wa|13,sclen(xl)||load alphabet scblk length|15188
||mov|7,xr|3,r_rpt||point to current table (if any)|15189
||bnz|7,xr|6,srpl2||jump if we already have a table|15190
||jsr|6,alocs|||allocate new table|15194
||mov|8,wa|8,wc||keep scblk length|15195
||mov|3,r_rpt|7,xr||save table pointer for next time|15196
|srpl2|ctb|8,wa|2,scsi_||compute length of scblk|15200
||mvw||||copy to get initial table values|15201
||ejc|||||15202
||mov|7,xl|3,r_ra2||point to second argument|15210
||lct|8,wb|8,wb||number of chars to plug|15211
||zer|8,wc|||zero char offset|15212
||mov|7,xr|3,r_ra3||point to 3rd arg|15213
||plc|7,xr|||get char ptr for 3rd arg|15214
|srpl3|mov|7,xl|3,r_ra2||point to 2nd arg|15218
||plc|7,xl|8,wc||point to next char|15219
||icv|8,wc|||increment offset|15220
||lch|8,wa|9,(xl)||get next char|15221
||mov|7,xl|3,r_rpt||point to translate table|15222
||psc|7,xl|8,wa||convert char to offset into table|15223
||lch|8,wa|10,(xr)+||get translated char|15224
||sch|8,wa|9,(xl)||store in table|15225
||csc|7,xl|||complete store characters|15226
||bct|8,wb|6,srpl3||loop till done|15227
||ejc|||||15228
|srpl4|mov|7,xl|3,r_rpt||replace table to use|15234
|srpl5|jsr|6,gtstg|||get first argument|15239
||err|1,170|26,replace first argument is not a string|||15240
||bze|8,wa|6,exnul||return null if null argument|15249
||mov|11,-(xs)|7,xl||stack replace table to use|15250
||mov|7,xl|7,xr||copy pointer|15251
||mov|8,wc|8,wa||save length|15252
||ctb|8,wa|2,schar||get scblk length|15253
||jsr|6,alloc|||allocate space for copy|15254
||mov|8,wb|7,xr||save address of copy|15255
||mvw||||move scblk contents to copy|15256
||mov|7,xr|10,(xs)+||unstack replace table|15257
||plc|7,xr|||point to chars of table|15258
||mov|7,xl|8,wb||point to string to translate|15259
||plc|7,xl|||point to chars of string|15260
||mov|8,wa|8,wc||set number of chars to translate|15261
||trc||||perform translation|15262
|srpl8|mov|11,-(xs)|8,wb||stack result|15263
||lcw|7,xr|||load next code word|15264
||bri|9,(xr)|||execute it|15265
|srpl6|erb|1,171|26,null or unequally long 2nd, 3rd args to replace|||15269
||ejc|||||15284
|s_rew|ent||||entry point|15288
||jsr|6,iofcb|||call fcblk routine|15289
||err|1,172|26,rewind argument is not a suitable name|||15290
||err|1,173|26,rewind argument is null|||15291
||err|1,174|26,rewind file does not exist|||15292
||jsr|6,sysrw|||call system rewind function|15293
||err|1,174|26,rewind file does not exist|||15294
||err|1,175|26,rewind file does not permit rewind|||15295
||err|1,176|26,rewind caused non-recoverable error|||15296
||brn|6,exnul|||exit with null result if no error|15297
||ejc|||||15298
|s_rvs|ent||||entry point|15302
||jsr|6,gtstg|||load string argument|15304
||err|1,177|26,reverse argument is not a string|||15305
||bze|8,wa|6,exixr||return argument if null|15311
||mov|7,xl|7,xr||else save pointer to string arg|15312
||jsr|6,alocs|||allocate space for new scblk|15313
||mov|11,-(xs)|7,xr||store scblk ptr on stack as result|15314
||psc|7,xr|||prepare to store in new scblk|15315
||plc|7,xl|8,wc||point past last char in argument|15316
||lct|8,wc|8,wc||set loop counter|15317
|srvs1|lch|8,wb|11,-(xl)||load next char from argument|15321
||sch|8,wb|10,(xr)+||store in result|15322
||bct|8,wc|6,srvs1||loop till all moved|15323
|srvs4|csc|7,xr|||complete store characters|15327
||zer|7,xl|||clear garbage xl|15328
|srvs2|lcw|7,xr|||load next code word|15329
||bri|9,(xr)|||execute it|15330
||ejc|||||15354
|s_rpd|ent||||entry point|15358
||jsr|6,gtstg|||get pad character|15359
||err|1,178|26,rpad third argument is not a string|||15360
||plc|7,xr|||point to character (null is blank)|15361
||lch|8,wb|9,(xr)||load pad character|15362
||jsr|6,gtsmi|||get pad length|15363
||err|1,179|26,rpad second argument is not integer|||15364
||ppm|6,srpd3|||skip if negative or large|15365
|srpd1|jsr|6,gtstg|||get first argument (string to pad)|15369
||err|1,180|26,rpad first argument is not a string|||15370
||bge|8,wa|8,wc|6,exixr|return 1st arg if too long to pad|15371
||mov|7,xl|7,xr||else move ptr to string to pad|15372
||mov|8,wa|8,wc||copy length|15380
||jsr|6,alocs|||allocate scblk for new string|15381
||mov|11,-(xs)|7,xr||save as result|15382
||mov|8,wa|13,sclen(xl)||load length of argument|15383
||sub|8,wc|8,wa||calculate number of pad characters|15384
||psc|7,xr|||point to chars in result string|15385
||lct|8,wc|8,wc||set counter for pad loop|15386
||bze|8,wa|6,srpd2||jump if argument is null|15390
||plc|7,xl|||else point to argument chars|15391
||mvc||||move characters to result string|15392
||zer|7,xl|||clear garbage xl|15393
|srpd2|sch|8,wb|10,(xr)+||store pad character, bump ptr|15397
||bct|8,wc|6,srpd2||loop till all pad chars stored|15398
||csc|7,xr|||complete character storing|15399
||lcw|7,xr|||load next code word|15400
||bri|9,(xr)|||execute it|15401
|srpd3|zer|8,wc|||zero pad count|15405
||brn|6,srpd1|||merge|15406
||ejc|||||15407
|s_rtb|ent||||entry point|15411
||mov|8,wb|22,=p_rtb||set pcode for integer arg case|15412
||mov|8,wa|22,=p_rtd||set pcode for expression arg case|15413
||jsr|6,patin|||call common routine to build node|15414
||err|1,181|26,rtab argument is not integer or expression|||15415
||err|1,182|26,rtab argument is negative or too large|||15416
||mov|11,-(xs)|7,xr||stack result|15417
||lcw|7,xr|||get next code word|15418
||bri|9,(xr)|||execute it|15419
||ejc|||||15420
|s_tab|ent||||entry point|15461
||mov|8,wb|22,=p_tab||set pcode for integer arg case|15462
||mov|8,wa|22,=p_tbd||set pcode for expression arg case|15463
||jsr|6,patin|||call common routine to build node|15464
||err|1,183|26,tab argument is not integer or expression|||15465
||err|1,184|26,tab argument is negative or too large|||15466
||mov|11,-(xs)|7,xr||stack result|15467
||lcw|7,xr|||get next code word|15468
||bri|9,(xr)|||execute it|15469
||ejc|||||15470
|s_rps|ent||||entry point|15474
||mov|8,wb|22,=p_rps||set pcode for integer arg case|15475
||mov|8,wa|22,=p_rpd||set pcode for expression arg case|15476
||jsr|6,patin|||call common routine to build node|15477
||err|1,185|26,rpos argument is not integer or expression|||15478
||err|1,186|26,rpos argument is negative or too large|||15479
||mov|11,-(xs)|7,xr||stack result|15480
||lcw|7,xr|||get next code word|15481
||bri|9,(xr)|||execute it|15482
||ejc|||||15485
|s_rsr|ent||||entry point|15489
||mnz|8,wa|||mark as rsort|15490
||jsr|6,sorta|||call sort routine|15491
||ppm|6,exfal|||if conversion fails, so shall we|15492
||brn|6,exsid|||return, setting idval|15493
||ejc|||||15495
|s_stx|ent||||entry point|15499
||mov|7,xr|10,(xs)+||load argument|15500
||mov|8,wa|3,stxvr||load old vrblk pointer|15501
||zer|7,xl|||load zero in case null arg|15502
||beq|7,xr|21,=nulls|6,sstx1|jump if null argument (reset call)|15503
||jsr|6,gtnvr|||else get specified vrblk|15504
||ppm|6,sstx2|||jump if not natural variable|15505
||mov|7,xl|13,vrlbl(xr)||else load label|15506
||beq|7,xl|21,=stndl|6,sstx2|jump if label is not defined|15507
||bne|9,(xl)|22,=b_trt|6,sstx1|jump if not trapped|15508
||mov|7,xl|13,trlbl(xl)||else load ptr to real label code|15509
|sstx1|mov|3,stxvr|7,xr||store new vrblk pointer (or null)|15513
||mov|3,r_sxc|7,xl||store new code ptr (or zero)|15514
||beq|8,wa|21,=nulls|6,exnul|return null if null result|15515
||mov|7,xr|8,wa||else copy vrblk pointer|15516
||brn|6,exvnm|||and return building nmblk|15517
|sstx2|erb|1,187|26,setexit argument is not label name or null|||15521
|s_sin|ent||||entry point|15526
||mov|7,xr|10,(xs)+||get argument|15527
||jsr|6,gtrea|||convert to real|15528
||err|1,308|26,sin argument not numeric|||15529
||ldr|13,rcval(xr)|||load accumulator with argument|15530
||sin||||take sine|15531
||rno|6,exrea|||if no overflow, return result in ra|15532
||erb|1,323|26,sin argument is out of range|||15533
||ejc|||||15534
|s_sqr|ent||||entry point|15540
||mov|7,xr|10,(xs)+||get argument|15541
||jsr|6,gtrea|||convert to real|15542
||err|1,313|26,sqrt argument not numeric|||15543
||ldr|13,rcval(xr)|||load accumulator with argument|15544
||rlt|6,ssqr1|||negative number|15545
||sqr||||take square root|15546
||brn|6,exrea|||no overflow possible, result in ra|15547
|ssqr1|erb|1,314|26,sqrt argument negative|||15551
||ejc|||||15552
||ejc|||||15556
|s_srt|ent||||entry point|15560
||zer|8,wa|||mark as sort|15561
||jsr|6,sorta|||call sort routine|15562
||ppm|6,exfal|||if conversion fails, so shall we|15563
||brn|6,exsid|||return, setting idval|15564
||ejc|||||15566
|s_spn|ent||||entry point|15570
||mov|8,wb|22,=p_sps||set pcode for single char arg|15571
||mov|7,xl|22,=p_spn||set pcode for multi-char arg|15572
||mov|8,wc|22,=p_spd||set pcode for expression arg|15573
||jsr|6,patst|||call common routine to build node|15574
||err|1,188|26,span argument is not a string or expression|||15575
||mov|11,-(xs)|7,xr||stack result|15576
||lcw|7,xr|||get next code word|15577
||bri|9,(xr)|||execute it|15578
||ejc|||||15579
|s_si_|ent||||entry point|15583
||jsr|6,gtstg|||load string argument|15585
||err|1,189|26,size argument is not a string|||15586
||mti|8,wa|||load length as integer|15594
||brn|6,exint|||exit with integer result|15595
||ejc|||||15596
|s_stt|ent||||entry point|15600
||zer|7,xl|||indicate stoptr case|15601
||jsr|6,trace|||call trace procedure|15602
||err|1,190|26,stoptr first argument is not appropriate name|||15603
||err|1,191|26,stoptr second argument is not trace type|||15604
||brn|6,exnul|||return null|15605
||ejc|||||15606
|s_sub|ent||||entry point|15610
||jsr|6,gtsmi|||load third argument|15611
||err|1,192|26,substr third argument is not integer|||15612
||ppm|6,exfal|||jump if negative or too large|15613
||mov|3,sbssv|7,xr||save third argument|15614
||jsr|6,gtsmi|||load second argument|15615
||err|1,193|26,substr second argument is not integer|||15616
||ppm|6,exfal|||jump if out of range|15617
||mov|8,wc|7,xr||save second argument|15618
||bze|8,wc|6,exfal||jump if second argument zero|15619
||dcv|8,wc|||else decrement for ones origin|15620
||jsr|6,gtstg|||load first argument|15622
||err|1,194|26,substr first argument is not a string|||15623
||mov|8,wb|8,wc||copy second arg to wb|15631
||mov|8,wc|3,sbssv||reload third argument|15632
||bnz|8,wc|6,ssub2||skip if third arg given|15633
||mov|8,wc|8,wa||else get string length|15634
||bgt|8,wb|8,wc|6,exfal|fail if improper|15635
||sub|8,wc|8,wb||reduce by offset to start|15636
|ssub2|mov|7,xl|8,wa||save string length|15640
||mov|8,wa|8,wc||set length of substring|15641
||add|8,wc|8,wb||add 2nd arg to 3rd arg|15642
||bgt|8,wc|7,xl|6,exfal|jump if improper substring|15643
||mov|7,xl|7,xr||copy pointer to first arg|15644
||jsr|6,sbstr|||build substring|15645
||mov|11,-(xs)|7,xr||stack result|15646
||lcw|7,xr|||get next code word|15647
||bri|9,(xr)|||execute it|15648
||ejc|||||15649
|s_tbl|ent||||entry point|15653
||mov|7,xl|10,(xs)+||get initial lookup value|15654
||ica|7,xs|||pop second argument|15655
||jsr|6,gtsmi|||load argument|15656
||err|1,195|26,table argument is not integer|||15657
||err|1,196|26,table argument is out of range|||15658
||bnz|8,wc|6,stbl1||jump if non-zero|15659
||mov|8,wc|18,=tbnbk||else supply default value|15660
|stbl1|jsr|6,tmake|||make table|15664
||brn|6,exsid|||exit setting idval|15665
||ejc|||||15666
|s_tan|ent||||entry point|15671
||mov|7,xr|10,(xs)+||get argument|15672
||jsr|6,gtrea|||convert to real|15673
||err|1,309|26,tan argument not numeric|||15674
||ldr|13,rcval(xr)|||load accumulator with argument|15675
||tan||||take tangent|15676
||rno|6,exrea|||if no overflow, return result in ra|15677
||erb|1,310|26,tan produced real overflow or argument is out of range|||15678
||ejc|||||15679
|s_tim|ent||||entry point|15684
||jsr|6,systm|||get timer value|15685
||sbi|3,timsx|||subtract starting time|15686
||brn|6,exint|||exit with integer value|15687
||ejc|||||15688
|s_tra|ent||||entry point|15692
||beq|13,num03(xs)|21,=nulls|6,str02|jump if first argument is null|15693
||mov|7,xr|10,(xs)+||load fourth argument|15694
||zer|7,xl|||tentatively set zero pointer|15695
||beq|7,xr|21,=nulls|6,str01|jump if 4th argument is null|15696
||jsr|6,gtnvr|||else point to vrblk|15697
||ppm|6,str03|||jump if not variable name|15698
||mov|7,xl|7,xr||else save vrblk in trfnc|15699
|str01|mov|7,xr|10,(xs)+||load third argument (tag)|15703
||zer|8,wb|||set zero as trtyp value for now|15704
||jsr|6,trbld|||build trblk for trace call|15705
||mov|7,xl|7,xr||move trblk pointer for trace|15706
||jsr|6,trace|||call trace procedure|15707
||err|1,198|26,trace first argument is not appropriate name|||15708
||err|1,199|26,trace second argument is not trace type|||15709
||brn|6,exnul|||return null|15710
|str02|jsr|6,systt|||call it|15714
||add|7,xs|19,*num04||pop trace arguments|15715
||brn|6,exnul|||return|15716
|str03|erb|1,197|26,trace fourth arg is not function name or null|||15720
||ejc|||||15721
|s_trm|ent||||entry point|15725
||jsr|6,gtstg|||load argument as string|15727
||err|1,200|26,trim argument is not a string|||15728
||bze|8,wa|6,exnul||return null if argument is null|15734
||mov|7,xl|7,xr||copy string pointer|15735
||ctb|8,wa|2,schar||get block length|15736
||jsr|6,alloc|||allocate copy same size|15737
||mov|8,wb|7,xr||save pointer to copy|15738
||mvw||||copy old string block to new|15739
||mov|7,xr|8,wb||restore ptr to new block|15740
||jsr|6,trimr|||trim blanks (wb is non-zero)|15741
||mov|11,-(xs)|7,xr||stack result|15742
||lcw|7,xr|||get next code word|15743
||bri|9,(xr)|||execute it|15744
||ejc|||||15787
|s_unl|ent||||entry point|15791
||mov|7,xr|10,(xs)+||load argument|15792
||jsr|6,gtnvr|||point to vrblk|15793
||err|1,201|26,unload argument is not natural variable name|||15794
||mov|7,xl|21,=stndf||get ptr to undefined function|15795
||jsr|6,dffnc|||undefine named function|15796
||brn|6,exnul|||return null as result|15797
||ttl|27,s p i t b o l -- utility routines||||15819
||ejc|||||15841
|arref|rtn|||||15857
||mov|8,wa|7,xr||copy number of subscripts|15858
||mov|7,xt|7,xs||point to stack front|15859
||wtb|7,xr|||convert to byte offset|15860
||add|7,xt|7,xr||point to array operand on stack|15861
||ica|7,xt|||final value for stack popping|15862
||mov|3,arfxs|7,xt||keep for later|15863
||mov|7,xr|11,-(xt)||load array operand pointer|15864
||mov|3,r_arf|7,xr||keep array pointer|15865
||mov|7,xr|7,xt||save pointer to subscripts|15866
||mov|7,xl|3,r_arf||point xl to possible vcblk or tbblk|15867
||mov|8,wc|9,(xl)||load first word|15868
||beq|8,wc|22,=b_art|6,arf01|jump if arblk|15869
||beq|8,wc|22,=b_vct|6,arf07|jump if vcblk|15870
||beq|8,wc|22,=b_tbt|6,arf10|jump if tbblk|15871
||erb|1,235|26,subscripted operand is not table or array|||15872
|arf01|bne|8,wa|13,arndm(xl)|6,arf09|jump if wrong number of dims|15876
||ldi|4,intv0|||get initial subscript of zero|15877
||mov|7,xt|7,xr||point before subscripts|15878
||zer|8,wa|||initial offset to bounds|15879
||brn|6,arf03|||jump into loop|15880
|arf02|mli|13,ardm2(xr)|||multiply total by next dimension|15884
|arf03|mov|7,xr|11,-(xt)||load next subscript|15888
||sti|3,arfsi|||save current subscript|15889
||ldi|13,icval(xr)|||load integer value in case|15890
||beq|9,(xr)|22,=b_icl|6,arf04|jump if it was an integer|15891
||ejc|||||15892
||jsr|6,gtint|||convert to integer|15897
||ppm|6,arf12|||jump if not integer|15898
||ldi|13,icval(xr)|||if ok, load integer value|15899
|arf04|mov|7,xr|3,r_arf||point to array|15903
||add|7,xr|8,wa||offset to next bounds|15904
||sbi|13,arlbd(xr)|||subtract low bound to compare|15905
||iov|6,arf13|||out of range fail if overflow|15906
||ilt|6,arf13|||out of range fail if too small|15907
||sbi|13,ardim(xr)|||subtract dimension|15908
||ige|6,arf13|||out of range fail if too large|15909
||adi|13,ardim(xr)|||else restore subscript offset|15910
||adi|3,arfsi|||add to current total|15911
||add|8,wa|19,*ardms||point to next bounds|15912
||bne|7,xt|7,xs|6,arf02|loop back if more to go|15913
||mfi|8,wa|||get as one word integer|15917
||wtb|8,wa|||convert to offset|15918
||mov|7,xl|3,r_arf||point to arblk|15919
||add|8,wa|13,arofs(xl)||add offset past bounds|15920
||ica|8,wa|||adjust for arpro field|15921
||bnz|8,wb|6,arf08||exit with name if name call|15922
|arf05|jsr|6,acess|||get value|15926
||ppm|6,arf13|||fail if acess fails|15927
|arf06|mov|7,xs|3,arfxs||pop stack entries|15931
||zer|3,r_arf|||finished with array pointer|15932
||mov|11,-(xs)|7,xr||stack result|15933
||lcw|7,xr|||get next code word|15934
||bri|9,(xr)|||execute it|15935
||ejc|||||15936
|arf07|bne|8,wa|18,=num01|6,arf09|error if more than 1 subscript|15942
||mov|7,xr|9,(xs)||else load subscript|15943
||jsr|6,gtint|||convert to integer|15944
||ppm|6,arf12|||error if not integer|15945
||ldi|13,icval(xr)|||else load integer value|15946
||sbi|4,intv1|||subtract for ones offset|15947
||mfi|8,wa|6,arf13||get subscript as one word|15948
||add|8,wa|18,=vcvls||add offset for standard fields|15949
||wtb|8,wa|||convert offset to bytes|15950
||bge|8,wa|13,vclen(xl)|6,arf13|fail if out of range subscript|15951
||bze|8,wb|6,arf05||back to get value if value call|15952
|arf08|mov|7,xs|3,arfxs||pop stack entries|15956
||zer|3,r_arf|||finished with array pointer|15957
||brn|6,exnam|||else exit with name|15958
|arf09|erb|1,236|26,array referenced with wrong number of subscripts|||15962
|arf10|bne|8,wa|18,=num01|6,arf11|error if more than 1 subscript|15966
||mov|7,xr|9,(xs)||else load subscript|15967
||jsr|6,tfind|||call table search routine|15968
||ppm|6,arf13|||fail if failed|15969
||bnz|8,wb|6,arf08||exit with name if name call|15970
||brn|6,arf06|||else exit with value|15971
|arf11|erb|1,237|26,table referenced with more than one subscript|||15975
|arf12|erb|1,238|26,array subscript is not integer|||15979
|arf13|zer|3,r_arf|||finished with array pointer|15983
||brn|6,exfal|||fail|15984
||ejc|||||15985
|cfunc|rtn|||||16002
||blt|8,wa|13,fargs(xl)|6,cfnc1|jump if too few arguments|16003
||beq|8,wa|13,fargs(xl)|6,cfnc3|jump if correct number of args|16004
||mov|8,wb|8,wa||copy actual number|16008
||sub|8,wb|13,fargs(xl)||get number of extra args|16009
||wtb|8,wb|||convert to bytes|16010
||add|7,xs|8,wb||pop off unwanted arguments|16011
||brn|6,cfnc3|||jump to go off to function|16012
|cfnc1|mov|8,wb|13,fargs(xl)||load required number of arguments|16016
||beq|8,wb|18,=nini9|6,cfnc3|jump if case of var num of args|16017
||sub|8,wb|8,wa||calculate number missing|16018
||lct|8,wb|8,wb||set counter to control loop|16019
|cfnc2|mov|11,-(xs)|21,=nulls||stack a null argument|16023
||bct|8,wb|6,cfnc2||loop till proper number stacked|16024
|cfnc3|bri|9,(xl)|||jump through fcode field|16028
||ejc|||||16029
|exfal|rtn|||||16038
||mov|7,xs|3,flptr||pop stack|16039
||mov|7,xr|9,(xs)||load failure offset|16040
||add|7,xr|3,r_cod||point to failure code location|16041
||lcp|7,xr|||set code pointer|16042
||lcw|7,xr|||load next code word|16043
||mov|7,xl|9,(xr)||load entry address|16044
||bri|7,xl|||jump to execute next code word|16045
||ejc|||||16046
|exint|rtn|||||16057
||zer|7,xl|||clear dud value|16058
||jsr|6,icbld|||build icblk|16059
||ejc|||||16060
|exixr|rtn|||||16069
||mov|11,-(xs)|7,xr||stack result|16071
|exits|rtn|||||16080
||lcw|7,xr|||load next code word|16081
||mov|7,xl|9,(xr)||load entry address|16082
||bri|7,xl|||jump to execute next code word|16083
||ejc|||||16084
|exnam|rtn|||||16095
||mov|11,-(xs)|7,xl||stack name base|16096
||mov|11,-(xs)|8,wa||stack name offset|16097
||lcw|7,xr|||load next code word|16098
||bri|9,(xr)|||execute it|16099
||ejc|||||16100
|exnul|rtn|||||16109
||mov|11,-(xs)|21,=nulls||stack null value|16110
||lcw|7,xr|||load next code word|16111
||mov|7,xl|9,(xr)||load entry address|16112
||bri|7,xl|||jump to execute next code word|16113
||ejc|||||16114
|exrea|rtn|||||16126
||zer|7,xl|||clear dud value|16127
||jsr|6,rcbld|||build rcblk|16128
||brn|6,exixr|||jump to exit with result in xr|16129
||ejc|||||16131
|exsid|rtn|||||16144
||mov|8,wa|3,curid||load current id value|16145
||bne|8,wa|3,mxint|6,exsi1|jump if no overflow|16146
||zer|8,wa|||else reset for wraparound|16147
|exsi1|icv|8,wa|||bump id value|16151
||mov|3,curid|8,wa||store for next time|16152
||mov|13,idval(xr)|8,wa||store id value|16153
||brn|6,exixr|||exit with result in (xr)|16154
||ejc|||||16155
|exvnm|rtn|||||16166
||mov|7,xl|7,xr||copy name base pointer|16167
||mov|8,wa|19,*nmsi_||set size of nmblk|16168
||jsr|6,alloc|||allocate nmblk|16169
||mov|9,(xr)|22,=b_nml||store type word|16170
||mov|13,nmbas(xr)|7,xl||store name base|16171
||mov|13,nmofs(xr)|19,*vrval||store name offset|16172
||brn|6,exixr|||exit with result in xr|16173
||ejc|||||16174
|flpop|rtn|||||16184
||add|7,xs|19,*num02||pop two entries off stack|16185
||ejc|||||16186
|failp|rtn|||||16198
||mov|7,xr|10,(xs)+||load alternative node pointer|16199
||mov|8,wb|10,(xs)+||restore old cursor|16200
||mov|7,xl|9,(xr)||load pcode entry pointer|16201
||bri|7,xl|||jump to execute code for node|16202
||ejc|||||16203
|indir|rtn|||||16212
||mov|7,xr|10,(xs)+||load argument|16213
||beq|9,(xr)|22,=b_nml|6,indr2|jump if a name|16214
||jsr|6,gtnvr|||else convert to variable|16215
||err|1,239|26,indirection operand is not name|||16216
||bze|8,wb|6,indr1||skip if by value|16217
||mov|11,-(xs)|7,xr||else stack vrblk ptr|16218
||mov|11,-(xs)|19,*vrval||stack name offset|16219
||lcw|7,xr|||load next code word|16220
||mov|7,xl|9,(xr)||load entry address|16221
||bri|7,xl|||jump to execute next code word|16222
|indr1|bri|9,(xr)|||jump through vrget field of vrblk|16226
|indr2|mov|7,xl|13,nmbas(xr)||load name base|16230
||mov|8,wa|13,nmofs(xr)||load name offset|16231
||bnz|8,wb|6,exnam||exit if called by name|16232
||jsr|6,acess|||else get value first|16233
||ppm|6,exfal|||fail if access fails|16234
||brn|6,exixr|||else return with value in xr|16235
||ejc|||||16236
|match|rtn|||||16246
||mov|7,xr|10,(xs)+||load pattern operand|16247
||jsr|6,gtpat|||convert to pattern|16248
||err|1,240|26,pattern match right operand is not pattern|||16249
||mov|7,xl|7,xr||if ok, save pattern pointer|16250
||bnz|8,wb|6,mtch1||jump if not match by name|16251
||mov|8,wa|9,(xs)||else load name offset|16252
||mov|11,-(xs)|7,xl||save pattern pointer|16253
||mov|7,xl|13,num02(xs)||load name base|16254
||jsr|6,acess|||access subject value|16255
||ppm|6,exfal|||fail if access fails|16256
||mov|7,xl|9,(xs)||restore pattern pointer|16257
||mov|9,(xs)|7,xr||stack subject string val for merge|16258
||zer|8,wb|||restore type code|16259
|mtch1|jsr|6,gtstg|||convert subject to string|16264
||err|1,241|26,pattern match left operand is not a string|||16265
||mov|11,-(xs)|8,wb||stack match type code|16266
||mov|3,r_pms|7,xr||if ok, store subject string pointer|16274
||mov|3,pmssl|8,wa||and length|16275
||zer|11,-(xs)|||stack initial cursor (zero)|16276
||zer|8,wb|||set initial cursor|16277
||mov|3,pmhbs|7,xs||set history stack base ptr|16278
||zer|3,pmdfl|||reset pattern assignment flag|16279
||mov|7,xr|7,xl||set initial node pointer|16280
||bnz|3,kvanc|6,mtch2||jump if anchored|16281
||mov|11,-(xs)|7,xr||stack initial node pointer|16285
||mov|11,-(xs)|21,=nduna||stack pointer to anchor move node|16286
||bri|9,(xr)|||start match of first node|16287
|mtch2|zer|11,-(xs)|||dummy cursor value|16291
||mov|11,-(xs)|21,=ndabo||stack pointer to abort node|16292
||bri|9,(xr)|||start match of first node|16293
||ejc|||||16294
|retrn|rtn|||||16307
||bnz|3,kvfnc|6,rtn01||jump if not level zero|16308
||erb|1,242|26,function return from level zero|||16309
|rtn01|mov|7,xs|3,flprt||pop stack|16313
||ica|7,xs|||remove failure offset|16314
||mov|7,xr|10,(xs)+||pop pfblk pointer|16315
||mov|3,flptr|10,(xs)+||pop failure pointer|16316
||mov|3,flprt|10,(xs)+||pop old flprt|16317
||mov|8,wb|10,(xs)+||pop code pointer offset|16318
||mov|8,wc|10,(xs)+||pop old code block pointer|16319
||add|8,wb|8,wc||make old code pointer absolute|16320
||lcp|8,wb|||restore old code pointer|16321
||mov|3,r_cod|8,wc||restore old code block pointer|16322
||dcv|3,kvfnc|||decrement function level|16323
||mov|8,wb|3,kvtra||load trace|16324
||add|8,wb|3,kvftr||add ftrace|16325
||bze|8,wb|6,rtn06||jump if no tracing possible|16326
||mov|11,-(xs)|8,wa||save function return type|16330
||mov|11,-(xs)|7,xr||save pfblk pointer|16331
||mov|3,kvrtn|8,wa||set rtntype for trace function|16332
||mov|7,xl|3,r_fnc||load fnclevel trblk ptr (if any)|16333
||jsr|6,ktrex|||execute possible fnclevel trace|16334
||mov|7,xl|13,pfvbl(xr)||load vrblk ptr (sgd13)|16335
||bze|3,kvtra|6,rtn02||jump if trace is off|16336
||mov|7,xr|13,pfrtr(xr)||else load return trace trblk ptr|16337
||bze|7,xr|6,rtn02||jump if not return traced|16338
||dcv|3,kvtra|||else decrement trace count|16339
||bze|13,trfnc(xr)|6,rtn03||jump if print trace|16340
||mov|8,wa|19,*vrval||else set name offset|16341
||mov|3,kvrtn|13,num01(xs)||make sure rtntype is set right|16342
||jsr|6,trxeq|||execute full trace|16343
||ejc|||||16344
|rtn02|bze|3,kvftr|6,rtn05||jump if ftrace is off|16350
||dcv|3,kvftr|||else decrement ftrace|16351
|rtn03|jsr|6,prtsn|||print statement number|16355
||mov|7,xr|13,num01(xs)||load return type|16356
||jsr|6,prtst|||print it|16357
||mov|8,wa|18,=ch_bl||load blank|16358
||jsr|6,prtch|||print it|16359
||mov|7,xl|12,0(xs)||load pfblk ptr|16360
||mov|7,xl|13,pfvbl(xl)||load function vrblk ptr|16361
||mov|8,wa|19,*vrval||set vrblk name offset|16362
||bne|7,xr|21,=scfrt|6,rtn04|jump if not freturn case|16363
||jsr|6,prtnm|||print name|16367
||jsr|6,prtnl|||terminate print line|16368
||brn|6,rtn05|||merge|16369
|rtn04|jsr|6,prtnv|||print name = value|16373
|rtn05|mov|7,xr|10,(xs)+||pop pfblk pointer|16377
||mov|8,wa|10,(xs)+||pop return type string|16378
|rtn06|mov|3,kvrtn|8,wa||set rtntype keyword|16382
||mov|7,xl|13,pfvbl(xr)||load pointer to fn vrblk|16383
||ejc|||||16384
|rtn07|mov|3,rtnbp|7,xl||save block pointer|16389
||mov|7,xl|13,vrval(xl)||load value|16390
||beq|9,(xl)|22,=b_trt|6,rtn07|loop back if trapped|16391
||mov|3,rtnfv|7,xl||else save function result value|16392
||mov|3,rtnsv|10,(xs)+||save original function value|16393
||mov|7,xl|10,(xs)+||pop saved pointer|16397
||bze|7,xl|6,rtn7c||no action if none|16398
||bze|3,kvpfl|6,rtn7c||jump if no profiling|16399
||jsr|6,prflu|||else profile last func stmt|16400
||beq|3,kvpfl|18,=num02|6,rtn7a|branch on value of profile keywd|16401
||ldi|3,pfstm|||load current time|16407
||sbi|13,icval(xl)|||frig by subtracting saved amount|16408
||brn|6,rtn7b|||and merge|16409
|rtn7a|ldi|13,icval(xl)|||load saved time|16413
|rtn7b|sti|3,pfstm|||store back correct start time|16417
|rtn7c|mov|8,wb|13,fargs(xr)||get number of args|16421
||add|8,wb|13,pfnlo(xr)||add number of locals|16423
||bze|8,wb|6,rtn10||jump if no args/locals|16424
||lct|8,wb|8,wb||else set loop counter|16425
||add|7,xr|13,pflen(xr)||and point to end of pfblk|16426
|rtn08|mov|7,xl|11,-(xr)||load next vrblk pointer|16430
|rtn09|mov|8,wa|7,xl||save block pointer|16434
||mov|7,xl|13,vrval(xl)||load pointer to next value|16435
||beq|9,(xl)|22,=b_trt|6,rtn09|loop back if trapped|16436
||mov|7,xl|8,wa||else restore last block pointer|16437
||mov|13,vrval(xl)|10,(xs)+||restore old variable value|16438
||bct|8,wb|6,rtn08||loop till all processed|16439
|rtn10|mov|7,xl|3,rtnbp||restore ptr to last function block|16443
||mov|13,vrval(xl)|3,rtnsv||restore old function value|16444
||mov|7,xr|3,rtnfv||reload function result|16445
||mov|7,xl|3,r_cod||point to new code block|16446
||mov|3,kvlst|3,kvstn||set lastno from stno|16447
||mov|3,kvstn|13,cdstm(xl)||reset proper stno value|16448
||mov|3,kvlln|3,kvlin||set lastline from line|16450
||mov|3,kvlin|13,cdsln(xl)||reset proper line value|16451
||mov|8,wa|3,kvrtn||load return type|16453
||beq|8,wa|21,=scrtn|6,exixr|exit with result in xr if return|16454
||beq|8,wa|21,=scfrt|6,exfal|fail if freturn|16455
||ejc|||||16456
||beq|9,(xr)|22,=b_nml|6,rtn11|jump if is a name|16462
||jsr|6,gtnvr|||else try convert to variable name|16463
||err|1,243|26,function result in nreturn is not name|||16464
||mov|7,xl|7,xr||if ok, copy vrblk (name base) ptr|16465
||mov|8,wa|19,*vrval||set name offset|16466
||brn|6,rtn12|||and merge|16467
|rtn11|mov|7,xl|13,nmbas(xr)||load name base|16471
||mov|8,wa|13,nmofs(xr)||load name offset|16472
|rtn12|mov|7,xr|7,xl||preserve xl|16476
||lcw|8,wb|||load next word|16477
||mov|7,xl|7,xr||restore xl|16478
||beq|8,wb|21,=ofne_|6,exnam|exit if called by name|16479
||mov|11,-(xs)|8,wb||else save code word|16480
||jsr|6,acess|||get value|16481
||ppm|6,exfal|||fail if access fails|16482
||mov|7,xl|7,xr||if ok, copy result|16483
||mov|7,xr|9,(xs)||reload next code word|16484
||mov|9,(xs)|7,xl||store result on stack|16485
||mov|7,xl|9,(xr)||load routine address|16486
||bri|7,xl|||jump to execute next code word|16487
||ejc|||||16488
|stcov|rtn|||||16498
||icv|3,errft|||fatal error|16499
||ldi|4,intvt|||get 10|16500
||adi|3,kvstl|||add to former limit|16501
||sti|3,kvstl|||store as new stlimit|16502
||ldi|4,intvt|||get 10|16503
||sti|3,kvstc|||set as new count|16504
||jsr|6,stgcc|||recompute countdown counters|16505
||erb|1,244|26,statement count exceeds value of stlimit keyword|||16506
||ejc|||||16507
|stmgo|rtn|||||16516
||mov|3,r_cod|7,xr||set new code block pointer|16517
||dcv|3,stmct|||see if time to check something|16518
||bze|3,stmct|6,stgo2||jump if so|16519
||mov|3,kvlst|3,kvstn||set lastno|16520
||mov|3,kvstn|13,cdstm(xr)||set stno|16521
||mov|3,kvlln|3,kvlin||set lastline|16523
||mov|3,kvlin|13,cdsln(xr)||set line|16524
||add|7,xr|19,*cdcod||point to first code word|16526
||lcp|7,xr|||set code pointer|16527
|stgo1|lcw|7,xr|||load next code word|16531
||zer|7,xl|||clear garbage xl|16532
||bri|9,(xr)|||execute it|16533
|stgo2|bze|3,kvpfl|6,stgo3||skip if no profiling|16537
||jsr|6,prflu|||else profile the statement in kvstn|16538
|stgo3|mov|3,kvlst|3,kvstn||set lastno|16542
||mov|3,kvstn|13,cdstm(xr)||set stno|16543
||mov|3,kvlln|3,kvlin||set lastline|16545
||mov|3,kvlin|13,cdsln(xr)||set line|16546
||add|7,xr|19,*cdcod||point to first code word|16548
||lcp|7,xr|||set code pointer|16549
||mov|11,-(xs)|3,stmcs||save present count start on stack|16554
||dcv|3,polct|||poll interval within stmct|16555
||bnz|3,polct|6,stgo4||jump if not poll time yet|16556
||zer|8,wa|||=0 for poll|16557
||mov|8,wb|3,kvstn||statement number|16558
||mov|7,xl|7,xr||make collectable|16559
||jsr|6,syspl|||allow interactive access|16560
||err|1,320|26,user interrupt|||16561
||ppm||||single step|16562
||ppm||||expression evaluation|16563
||mov|7,xr|7,xl||restore code block pointer|16564
||mov|3,polcs|8,wa||poll interval start value|16565
||jsr|6,stgcc|||recompute counter values|16566
|stgo4|ldi|3,kvstc|||get stmt count|16571
||ilt|6,stgo5|||omit counting if negative|16572
||mti|10,(xs)+|||reload start value of counter|16573
||ngi||||negate|16574
||adi|3,kvstc|||stmt count minus counter|16575
||sti|3,kvstc|||replace it|16576
||ile|6,stcov|||fail if stlimit reached|16577
||bze|3,r_stc|6,stgo5||jump if no statement trace|16578
||zer|7,xr|||clear garbage value in xr|16579
||mov|7,xl|3,r_stc||load pointer to stcount trblk|16580
||jsr|6,ktrex|||execute keyword trace|16581
|stgo5|mov|3,stmct|3,stmcs||reset counter|16585
||brn|6,stgo1|||fetch next code word|16586
||ejc|||||16587
|stopr|rtn|||||16597
||bze|7,xr|6,stpra||skip if sysax already called|16599
||jsr|6,sysax|||call after execution proc|16600
|stpra|add|3,dname|3,rsmem||use the reserve memory|16601
||bne|7,xr|21,=endms|6,stpr0|skip if not normal end message|16605
||bnz|3,exsts|6,stpr3||skip if exec stats suppressed|16606
||zer|3,erich|||clear errors to int.ch. flag|16607
|stpr0|jsr|6,prtpg|||eject printer|16611
||bze|7,xr|6,stpr1||skip if no message|16612
||jsr|6,prtst|||print message|16613
|stpr1|jsr|6,prtis|||print blank line|16617
||bnz|3,gbcfl|6,stpr5||if in garbage collection, skip|16619
||mov|7,xr|21,=stpm6||point to message /in file xxx/|16620
||jsr|6,prtst|||print it|16621
||mov|3,profs|18,=prtmf||set column offset|16622
||mov|8,wc|3,kvstn||get statement number|16623
||jsr|6,filnm|||get file name|16624
||mov|7,xr|7,xl||prepare to print|16625
||jsr|6,prtst|||print file name|16626
||jsr|6,prtis|||print to interactive channel|16627
||mov|7,xr|3,r_cod||get code pointer|16634
||mti|13,cdsln(xr)|||get source line number|16635
||mov|7,xr|21,=stpm4||point to message /in line xxx/|16636
||jsr|6,prtmx|||print it|16637
|stpr5|mti|3,kvstn|||get statement number|16639
||mov|7,xr|21,=stpm1||point to message /in statement xxx/|16640
||jsr|6,prtmx|||print it|16641
||ldi|3,kvstl|||get statement limit|16642
||ilt|6,stpr2|||skip if negative|16643
||sbi|3,kvstc|||minus counter = course count|16644
||sti|3,stpsi|||save|16645
||mov|8,wa|3,stmcs||refine with counter start value|16646
||sub|8,wa|3,stmct||minus current counter|16647
||mti|8,wa|||convert to integer|16648
||adi|3,stpsi|||add in course count|16649
||sti|3,stpsi|||save|16650
||mov|7,xr|21,=stpm2||point to message /stmts executed/|16651
||jsr|6,prtmx|||print it|16652
||jsr|6,systm|||get current time|16653
||sbi|3,timsx|||minus start time = elapsed exec tim in nanosec|16654
||sti|3,stpti|||save for later|16655
||dvi|4,intth|||divide by 1000 to convert to microseconds|16656
||iov|6,stpr2|||jump if we cannot compute|16657
||dvi|4,intth|||divide by 1000 to convert to milliseconds|16658
||iov|6,stpr2|||jump if we cannot compute|16659
||sti|3,stpti|||save elapsed time in milliseconds|16660
||mov|7,xr|21,=stpm3||point to msg /execution time msec /|16661
||jsr|6,prtmx|||print it|16662
||ldi|3,stpti|||reload execution time in milliseconds|16667
||ile|6,stpr2|||jump if exection time less than a millisecond|16668
||ldi|3,stpsi|||load statement count|16672
||dvi|3,stpti|||divide to get stmts per millisecond|16673
||iov|6,stpr2|||jump if we cannot compute|16674
||dvi|4,intth|||divide to get stmts per microsecond|16675
||iov|6,stpr2|||jump if we cannot compute|16676
||mov|7,xr|21,=stpm7||point to msg (stmt / microsec)|16677
||jsr|6,prtmx|||print it|16678
||ldi|3,stpsi|||reload statement count|16680
||dvi|3,stpti|||divide to get stmts per millisecond|16681
||iov|6,stpr2|||jump if we cannot compute|16682
||mov|7,xr|21,=stpm8||point to msg (stmt / millisec )|16683
||jsr|6,prtmx|||print it|16684
||ldi|3,stpsi|||reload statement count|16686
||dvi|3,stpti|||divide to get stmts per millisecond|16687
||iov|6,stpr2|||jump if we cannot compute|16688
||mli|4,intth|||multiply by 1000 to get stmts per microsecond|16689
||iov|6,stpr2|||jump if overflow|16690
||mov|7,xr|21,=stpm9||point to msg ( stmt / second )|16691
||jsr|6,prtmx|||print it|16692
||ejc|||||16694
|stpr2|mti|3,gbcnt|||load count of collections|16700
||mov|7,xr|21,=stpm4||point to message /regenerations /|16701
||jsr|6,prtmx|||print it|16702
||jsr|6,prtmm|||print memory usage|16703
||jsr|6,prtis|||one more blank for luck|16704
|stpr3|jsr|6,prflr|||print profile if wanted|16711
||mov|7,xr|3,kvdmp||load dump keyword|16713
||jsr|6,dumpr|||execute dump if requested|16715
||mov|7,xl|3,r_fcb||get fcblk chain head|16716
||mov|8,wa|3,kvabe||load abend value|16717
||mov|8,wb|3,kvcod||load code value|16718
||jsr|6,sysej|||exit to system|16719
|stpr4|rtn|||||16724
||add|3,dname|3,rsmem||use the reserve memory|16725
||bze|3,exsts|6,stpr1||if execution stats requested|16726
||brn|6,stpr3|||check if dump or profile needed|16727
||ejc|||||16730
|succp|rtn|||||16743
||mov|7,xr|13,pthen(xr)||load successor node|16744
||mov|7,xl|9,(xr)||load node code entry address|16745
||bri|7,xl|||jump to match successor node|16746
||ejc|||||16747
|sysab|rtn|||||16751
||mov|7,xr|21,=endab||point to message|16752
||mov|3,kvabe|18,=num01||set abend flag|16753
||jsr|6,prtnl|||skip to new line|16754
||brn|6,stopr|||jump to pack up|16755
||ejc|||||16756
|systu|rtn|||||16760
||mov|7,xr|21,=endtu||point to message|16761
||mov|8,wa|4,strtu||get chars /tu/|16762
||mov|3,kvcod|8,wa||put in kvcod|16763
||mov|8,wa|3,timup||check state of timeup switch|16764
||mnz|3,timup|||set switch|16765
||bnz|8,wa|6,stopr||stop run if already set|16766
||erb|1,245|26,translation/execution time expired|||16767
||ttl|27,s p i t b o l -- utility procedures||||16768
||ejc|||||16812
|acess|prc|25,r|1,1||entry point (recursive)|16832
||mov|7,xr|7,xl||copy name base|16833
||add|7,xr|8,wa||point to variable location|16834
||mov|7,xr|9,(xr)||load variable value|16835
|acs02|bne|9,(xr)|22,=b_trt|6,acs18|jump if not trapped|16839
||beq|7,xr|21,=trbkv|6,acs12|jump if keyword variable|16843
||bne|7,xr|21,=trbev|6,acs05|jump if not expression variable|16844
||mov|7,xr|13,evexp(xl)||load expression pointer|16848
||zer|8,wb|||evaluate by value|16849
||jsr|6,evalx|||evaluate expression|16850
||ppm|6,acs04|||jump if evaluation failure|16851
||brn|6,acs02|||check value for more trblks|16852
||ejc|||||16853
|acs03|add|7,xs|19,*num03||pop trblk ptr, name base and offset|16859
||mov|3,dnamp|7,xr||pop unused scblk|16860
|acs04|exi|1,1|||take alternate (failure) return|16864
|acs05|mov|8,wb|13,trtyp(xr)||load trap type code|16868
||bnz|8,wb|6,acs10||jump if not input association|16869
||bze|3,kvinp|6,acs09||ignore input assoc if input is off|16870
||mov|11,-(xs)|7,xl||stack name base|16874
||mov|11,-(xs)|8,wa||stack name offset|16875
||mov|11,-(xs)|7,xr||stack trblk pointer|16876
||mov|3,actrm|3,kvtrm||temp to hold trim keyword|16877
||mov|7,xl|13,trfpt(xr)||get file ctrl blk ptr or zero|16878
||bnz|7,xl|6,acs06||jump if not standard input file|16879
||beq|13,trter(xr)|21,=v_ter|6,acs21|jump if terminal|16880
||mov|8,wa|3,cswin||length for read buffer|16884
||jsr|6,alocs|||build string of appropriate length|16885
||jsr|6,sysrd|||read next standard input image|16886
||ppm|6,acs03|||jump to fail exit if end of file|16887
||brn|6,acs07|||else merge with other file case|16888
|acs06|mov|8,wa|7,xl||fcblk ptr|16892
||jsr|6,sysil|||get input record max length (to wa)|16893
||bnz|8,wc|6,acs6a||jump if not binary file|16894
||mov|3,actrm|8,wc||disable trim for binary file|16895
|acs6a|jsr|6,alocs|||allocate string of correct size|16896
||mov|8,wa|7,xl||fcblk ptr|16897
||jsr|6,sysin|||call system input routine|16898
||ppm|6,acs03|||jump to fail exit if end of file|16899
||ppm|6,acs22|||error|16900
||ppm|6,acs23|||error|16901
||ejc|||||16902
|acs07|mov|8,wb|3,actrm||load trim indicator|16908
||jsr|6,trimr|||trim record as required|16909
||mov|8,wb|7,xr||copy result pointer|16910
||mov|7,xr|9,(xs)||reload pointer to trblk|16911
|acs08|mov|7,xl|7,xr||save pointer to this trblk|16915
||mov|7,xr|13,trnxt(xr)||load forward pointer|16916
||beq|9,(xr)|22,=b_trt|6,acs08|loop if this is another trblk|16917
||mov|13,trnxt(xl)|8,wb||else store result at end of chain|16918
||mov|7,xr|10,(xs)+||restore initial trblk pointer|16919
||mov|8,wa|10,(xs)+||restore name offset|16920
||mov|7,xl|10,(xs)+||restore name base pointer|16921
|acs09|mov|7,xr|13,trnxt(xr)||load forward ptr to next value|16925
||brn|6,acs02|||back to check if trapped|16926
|acs10|bne|8,wb|18,=trtac|6,acs09|loop back if not access trace|16930
||bze|3,kvtra|6,acs09||ignore access trace if trace off|16931
||dcv|3,kvtra|||else decrement trace count|16932
||bze|13,trfnc(xr)|6,acs11||jump if print trace|16933
||ejc|||||16934
||jsr|6,trxeq|||call routine to execute trace|16940
||brn|6,acs09|||jump for next trblk|16941
|acs11|jsr|6,prtsn|||print statement number|16945
||jsr|6,prtnv|||print name = value|16946
||brn|6,acs09|||jump back for next trblk|16947
|acs12|mov|7,xr|13,kvnum(xl)||load keyword number|16951
||bge|7,xr|18,=k_v__|6,acs14|jump if not one word value|16952
||mti|15,kvabe(xr)|||else load value as integer|16953
|acs13|jsr|6,icbld|||build icblk|16957
||brn|6,acs18|||jump to exit|16958
|acs14|bge|7,xr|18,=k_s__|6,acs15|jump if special case|16962
||sub|7,xr|18,=k_v__||else get offset|16963
||wtb|7,xr|||convert to byte offset|16964
||add|7,xr|21,=ndabo||point to pattern value|16965
||brn|6,acs18|||jump to exit|16966
|acs15|mov|7,xl|3,kvrtn||load rtntype in case|16970
||ldi|3,kvstl|||load stlimit in case|16971
||sub|7,xr|18,=k_s__||get case number|16972
||bsw|7,xr|2,k__n_||switch on keyword number|16973
||iff|2,k__al|6,acs16||jump if alphabet|16987
||iff|2,k__rt|6,acs17||rtntype|16987
||iff|2,k__sc|6,acs19||stcount|16987
||iff|2,k__et|6,acs20||errtext|16987
||iff|2,k__fl|6,acs26||file|16987
||iff|2,k__lf|6,acs27||lastfile|16987
||iff|2,k__sl|6,acs13||stlimit|16987
||iff|2,k__lc|6,acs24||lcase|16987
||iff|2,k__uc|6,acs25||ucase|16987
||esw||||end switch on keyword number|16987
||ejc|||||16988
|acs24|mov|7,xr|21,=lcase||load pointer to lcase string|16995
||brn|6,acs18|||common return|16996
|acs25|mov|7,xr|21,=ucase||load pointer to ucase string|17000
||brn|6,acs18|||common return|17001
|acs26|mov|8,wc|3,kvstn||load current stmt number|17007
||brn|6,acs28|||merge to obtain file name|17008
|acs27|mov|8,wc|3,kvlst||load last stmt number|17012
|acs28|jsr|6,filnm|||obtain file name for this stmt|17016
||brn|6,acs17|||merge to return string in xl|17017
|acs16|mov|7,xl|3,kvalp||load pointer to alphabet string|17021
|acs17|mov|7,xr|7,xl||copy string ptr to proper reg|17025
|acs18|exi||||return to acess caller|17029
|acs19|ilt|6,acs29|||if counting suppressed|17033
||mov|8,wa|3,stmcs||refine with counter start value|17034
||sub|8,wa|3,stmct||minus current counter|17035
||mti|8,wa|||convert to integer|17036
||adi|3,kvstl|||add stlimit|17037
|acs29|sbi|3,kvstc|||stcount = limit - left|17038
||brn|6,acs13|||merge back with integer result|17039
|acs20|mov|7,xr|3,r_etx||get errtext string|17043
||brn|6,acs18|||merge with result|17044
|acs21|mov|8,wa|18,=rilen||buffer length|17048
||jsr|6,alocs|||allocate buffer|17049
||jsr|6,sysri|||read record|17050
||ppm|6,acs03|||endfile|17051
||brn|6,acs07|||merge with record read|17052
|acs22|mov|3,dnamp|7,xr||pop unused scblk|17056
||erb|1,202|26,input from file caused non-recoverable error|||17057
|acs23|mov|3,dnamp|7,xr||pop unused scblk|17059
||erb|1,203|26,input file record has incorrect format|||17060
||enp||||end procedure acess|17061
||ejc|||||17062
|acomp|prc|25,n|1,5||entry point|17078
||jsr|6,arith|||load arithmetic operands|17079
||ppm|6,acmp7|||jump if first arg non-numeric|17080
||ppm|6,acmp8|||jump if second arg non-numeric|17081
||ppm|6,acmp4|||jump if real arguments|17084
||sbi|13,icval(xl)|||subtract to compare|17089
||iov|6,acmp3|||jump if overflow|17090
||ilt|6,acmp5|||else jump if arg1 lt arg2|17091
||ieq|6,acmp2|||jump if arg1 eq arg2|17092
|acmp1|exi|1,5|||take gt exit|17096
|acmp2|exi|1,4|||take eq exit|17100
||ejc|||||17101
|acmp3|ldi|13,icval(xl)|||load second argument|17107
||ilt|6,acmp1|||gt if negative|17108
||brn|6,acmp5|||else lt|17109
|acmp4|sbr|13,rcval(xl)|||subtract to compare|17115
||rov|6,acmp6|||jump if overflow|17116
||rgt|6,acmp1|||else jump if arg1 gt|17117
||req|6,acmp2|||jump if arg1 eq arg2|17118
|acmp5|exi|1,3|||take lt exit|17123
|acmp6|ldr|13,rcval(xl)|||reload arg2|17129
||rlt|6,acmp1|||gt if negative|17130
||brn|6,acmp5|||else lt|17131
|acmp7|exi|1,1|||take error exit|17136
|acmp8|exi|1,2|||take error exit|17140
||enp||||end procedure acomp|17141
||ejc|||||17142
|alloc|prc|25,e|1,0||entry point|17154
|aloc1|mov|7,xr|3,dnamp||point to next available loc|17158
||aov|8,wa|7,xr|6,aloc2|point past allocated block|17159
||bgt|7,xr|3,dname|6,aloc2|jump if not enough room|17160
||mov|3,dnamp|7,xr||store new pointer|17161
||sub|7,xr|8,wa||point back to start of allocated bk|17162
||exi||||return to caller|17163
|aloc2|mov|3,allsv|8,wb||save wb|17167
|alc2a|zer|8,wb|||set no upward move for gbcol|17168
||jsr|6,gbcol|||garbage collect|17169
||mov|8,wb|7,xr||remember new sediment size|17171
|aloc3|mov|7,xr|3,dnamp||point to first available loc|17176
||aov|8,wa|7,xr|6,alc3a|point past new block|17177
||blo|7,xr|3,dname|6,aloc4|jump if there is room now|17178
|alc3a|jsr|6,sysmm|||try to get more memory|17182
||wtb|7,xr|||convert to baus (sgd05)|17183
||add|3,dname|7,xr||bump ptr by amount obtained|17184
||bnz|7,xr|6,aloc3||jump if got more core|17185
||bze|3,dnams|6,alc3b||jump if there was no sediment|17187
||zer|3,dnams|||try collecting the sediment|17188
||brn|6,alc2a||||17189
|alc3b|add|3,dname|3,rsmem||get the reserve memory|17193
||zer|3,rsmem|||only permissible once|17197
||icv|3,errft|||fatal error|17198
||erb|1,204|26,memory overflow|||17199
||ejc|||||17200
|aloc4|sti|3,allia|||save ia|17204
||mov|3,dnams|8,wb||record new sediment size|17206
||mov|8,wb|3,dname||get dynamic end adrs|17208
||sub|8,wb|3,dnamp||compute free store|17209
||btw|8,wb|||convert bytes to words|17210
||mti|8,wb|||put free store in ia|17211
||mli|3,alfsf|||multiply by free store factor|17212
||iov|6,aloc5|||jump if overflowed|17213
||mov|8,wb|3,dname||dynamic end adrs|17214
||sub|8,wb|3,dnamb||compute total amount of dynamic|17215
||btw|8,wb|||convert to words|17216
||mov|3,aldyn|8,wb||store it|17217
||sbi|3,aldyn|||subtract from scaled up free store|17218
||igt|6,aloc5|||jump if sufficient free store|17219
||jsr|6,sysmm|||try to get more store|17220
||wtb|7,xr|||convert to baus (sgd05)|17221
||add|3,dname|7,xr||adjust dynamic end adrs|17222
|aloc5|ldi|3,allia|||recover ia|17226
||mov|8,wb|3,allsv||restore wb|17227
||brn|6,aloc1|||jump back to exit|17228
||enp||||end procedure alloc|17229
||ejc|||||17230
|alocs|prc|25,e|1,0||entry point|17290
||bgt|8,wa|3,kvmxl|6,alcs2|jump if length exceeds maxlength|17291
||mov|8,wc|8,wa||else copy length|17292
||ctb|8,wa|2,scsi_||compute length of scblk in bytes|17293
||mov|7,xr|3,dnamp||point to next available location|17294
||aov|8,wa|7,xr|6,alcs0|point past block|17295
||blo|7,xr|3,dname|6,alcs1|jump if there is room|17296
|alcs0|zer|7,xr|||else clear garbage xr value|17300
||jsr|6,alloc|||and use standard allocator|17301
||add|7,xr|8,wa||point past end of block to merge|17302
|alcs1|mov|3,dnamp|7,xr||set updated storage pointer|17306
||zer|11,-(xr)|||store zero chars in last word|17307
||dca|8,wa|||decrement length|17308
||sub|7,xr|8,wa||point back to start of block|17309
||mov|9,(xr)|22,=b_scl||set type word|17310
||mov|13,sclen(xr)|8,wc||store length in chars|17311
||exi||||return to alocs caller|17312
|alcs2|erb|1,205|26,string length exceeds value of maxlngth keyword|||17316
||enp||||end procedure alocs|17317
||ejc|||||17318
|alost|prc|25,e|1,0||entry point|17331
|alst1|mov|7,xr|3,state||point to current end of area|17335
||aov|8,wa|7,xr|6,alst2|point beyond proposed block|17336
||bge|7,xr|3,dnamb|6,alst2|jump if overlap with dynamic area|17337
||mov|3,state|7,xr||else store new pointer|17338
||sub|7,xr|8,wa||point back to start of block|17339
||exi||||return to alost caller|17340
|alst2|mov|3,alsta|8,wa||save wa|17344
||bge|8,wa|19,*e_sts|6,alst3|skip if requested chunk is large|17345
||mov|8,wa|19,*e_sts||else set to get large enough chunk|17346
|alst3|jsr|6,alloc|||allocate block to ensure room|17350
||mov|3,dnamp|7,xr||and delete it|17351
||mov|8,wb|8,wa||copy move up amount|17352
||jsr|6,gbcol|||call gbcol to move dynamic area up|17353
||mov|3,dnams|7,xr||remember new sediment size|17355
||mov|8,wa|3,alsta||restore wa|17357
||brn|6,alst1|||loop back to try again|17358
||enp||||end procedure alost|17359
||ejc|||||17360
||ejc|||||17434
|arith|prc|25,n|1,3||entry point|17443
||mov|7,xl|10,(xs)+||load right operand|17445
||mov|7,xr|10,(xs)+||load left operand|17446
||mov|8,wa|9,(xl)||get right operand type word|17447
||beq|8,wa|22,=b_icl|6,arth1|jump if integer|17448
||beq|8,wa|22,=b_rcl|6,arth4|jump if real|17451
||mov|11,-(xs)|7,xr||else replace left arg on stack|17453
||mov|7,xr|7,xl||copy left arg pointer|17454
||jsr|6,gtnum|||convert to numeric|17455
||ppm|6,arth6|||jump if unconvertible|17456
||mov|7,xl|7,xr||else copy converted result|17457
||mov|8,wa|9,(xl)||get right operand type word|17458
||mov|7,xr|10,(xs)+||reload left argument|17459
||beq|8,wa|22,=b_rcl|6,arth4|jump if right arg is real|17462
|arth1|bne|9,(xr)|22,=b_icl|6,arth3|jump if left arg not integer|17467
|arth2|ldi|13,icval(xr)|||load left operand value|17471
||exi||||return to arith caller|17472
|arth3|jsr|6,gtnum|||convert left arg to numeric|17476
||ppm|6,arth7|||jump if not convertible|17477
||beq|8,wa|22,=b_icl|6,arth2|jump back if integer-integer|17478
||mov|11,-(xs)|7,xr||put left arg back on stack|17484
||ldi|13,icval(xl)|||load right argument value|17485
||itr||||convert to real|17486
||jsr|6,rcbld|||get real block for right arg, merge|17487
||mov|7,xl|7,xr||copy right arg ptr|17488
||mov|7,xr|10,(xs)+||load left argument|17489
||brn|6,arth5|||merge for real-real case|17490
||ejc|||||17491
|arth4|beq|9,(xr)|22,=b_rcl|6,arth5|jump if left arg real|17497
||jsr|6,gtrea|||else convert to real|17498
||ppm|6,arth7|||error if unconvertible|17499
|arth5|ldr|13,rcval(xr)|||load left operand value|17503
||exi|1,3|||take real-real exit|17504
|arth6|ica|7,xs|||pop unwanted left arg|17509
||exi|1,2|||take appropriate error exit|17510
|arth7|exi|1,1|||take appropriate error return|17514
||enp||||end procedure arith|17515
||ejc|||||17516
|asign|prc|25,r|1,1||entry point (recursive)|17537
|asg01|add|7,xl|8,wa||point to variable value|17541
||mov|7,xr|9,(xl)||load variable value|17542
||beq|9,(xr)|22,=b_trt|6,asg02|jump if trapped|17543
||mov|9,(xl)|8,wb||else perform assignment|17544
||zer|7,xl|||clear garbage value in xl|17545
||exi||||and return to asign caller|17546
|asg02|sub|7,xl|8,wa||restore name base|17550
||beq|7,xr|21,=trbkv|6,asg14|jump if keyword variable|17551
||bne|7,xr|21,=trbev|6,asg04|jump if not expression variable|17552
||mov|7,xr|13,evexp(xl)||point to expression|17556
||mov|11,-(xs)|8,wb||store value to assign on stack|17557
||mov|8,wb|18,=num01||set for evaluation by name|17558
||jsr|6,evalx|||evaluate expression by name|17559
||ppm|6,asg03|||jump if evaluation fails|17560
||mov|8,wb|10,(xs)+||else reload value to assign|17561
||brn|6,asg01|||loop back to perform assignment|17562
||ejc|||||17563
|asg03|ica|7,xs|||remove stacked value entry|17569
||exi|1,1|||take failure exit|17570
|asg04|mov|11,-(xs)|7,xr||save ptr to first trblk|17574
|asg05|mov|8,wc|7,xr||save ptr to this trblk|17578
||mov|7,xr|13,trnxt(xr)||point to next trblk|17579
||beq|9,(xr)|22,=b_trt|6,asg05|loop back if another trblk|17580
||mov|7,xr|8,wc||else point back to last trblk|17581
||mov|13,trval(xr)|8,wb||store value at end of chain|17582
||mov|7,xr|10,(xs)+||restore ptr to first trblk|17583
|asg06|mov|8,wb|13,trtyp(xr)||load type code of trblk|17587
||beq|8,wb|18,=trtvl|6,asg08|jump if value trace|17588
||beq|8,wb|18,=trtou|6,asg10|jump if output association|17589
|asg07|mov|7,xr|13,trnxt(xr)||point to next trblk on chain|17593
||beq|9,(xr)|22,=b_trt|6,asg06|loop back if another trblk|17594
||exi||||else end of chain, return to caller|17595
|asg08|bze|3,kvtra|6,asg07||ignore value trace if trace off|17599
||dcv|3,kvtra|||else decrement trace count|17600
||bze|13,trfnc(xr)|6,asg09||jump if print trace|17601
||jsr|6,trxeq|||else execute function trace|17602
||brn|6,asg07|||and loop back|17603
||ejc|||||17604
|asg09|jsr|6,prtsn|||print statement number|17610
||jsr|6,prtnv|||print name = value|17611
||brn|6,asg07|||loop back for next trblk|17612
|asg10|bze|3,kvoup|6,asg07||ignore output assoc if output off|17616
|asg1b|mov|7,xl|7,xr||copy trblk pointer|17617
||mov|7,xr|13,trnxt(xr)||point to next trblk|17618
||beq|9,(xr)|22,=b_trt|6,asg1b|loop back if another trblk|17619
||mov|7,xr|7,xl||else point back to last trblk|17620
||mov|11,-(xs)|13,trval(xr)||stack value to output|17622
||jsr|6,gtstg|||convert to string|17628
||ppm|6,asg12|||get datatype name if unconvertible|17629
|asg11|mov|8,wa|13,trfpt(xl)||fcblk ptr|17633
||bze|8,wa|6,asg13||jump if standard output file|17634
|asg1a|jsr|6,sysou|||call system output routine|17638
||err|1,206|26,output caused file overflow|||17639
||err|1,207|26,output caused non-recoverable error|||17640
||exi||||else all done, return to caller|17641
|asg12|jsr|6,dtype|||call datatype routine|17645
||brn|6,asg11|||merge|17646
|asg13|beq|13,trter(xl)|21,=v_ter|6,asg1a|jump if terminal output|17651
||icv|8,wa|||signal standard output|17652
||brn|6,asg1a|||use sysou to perform output|17653
||ejc|||||17668
|asg14|mov|7,xl|13,kvnum(xl)||load keyword number|17674
||beq|7,xl|18,=k_etx|6,asg19|jump if errtext|17675
||mov|7,xr|8,wb||copy value to be assigned|17676
||jsr|6,gtint|||convert to integer|17677
||err|1,208|26,keyword value assigned is not integer|||17678
||ldi|13,icval(xr)|||else load value|17679
||beq|7,xl|18,=k_stl|6,asg16|jump if special case of stlimit|17680
||mfi|8,wa|6,asg18||else get addr integer, test ovflow|17681
||bgt|8,wa|3,mxlen|6,asg18|fail if too large|17682
||beq|7,xl|18,=k_ert|6,asg17|jump if special case of errtype|17683
||beq|7,xl|18,=k_pfl|6,asg21|jump if special case of profile|17686
||beq|7,xl|18,=k_mxl|6,asg24|jump if special case of maxlngth|17688
||beq|7,xl|18,=k_fls|6,asg26|jump if special case of fullscan|17689
||blt|7,xl|18,=k_p__|6,asg15|jump unless protected|17690
||erb|1,209|26,keyword in assignment is protected|||17691
|asg15|mov|15,kvabe(xl)|8,wa||store new value|17695
||exi||||return to asign caller|17696
|asg16|sbi|3,kvstl|||subtract old limit|17703
||adi|3,kvstc|||add old counter|17704
||sti|3,kvstc|||store course counter value|17705
||ldi|3,kvstl|||check if counting suppressed|17706
||ilt|6,asg25|||do not refine if so|17707
||mov|8,wa|3,stmcs||refine with counter breakout|17708
||sub|8,wa|3,stmct||values|17709
||mti|8,wa|||convert to integer|17710
||ngi||||current-start value|17711
||adi|3,kvstc|||add in course counter value|17712
||sti|3,kvstc|||save refined value|17713
|asg25|ldi|13,icval(xr)|||reload new limit value|17714
||sti|3,kvstl|||store new limit value|17715
||jsr|6,stgcc|||recompute countdown counters|17716
||exi||||return to asign caller|17717
|asg17|ble|8,wa|18,=nini9|6,error|ok to signal if in range|17721
|asg18|erb|1,210|26,keyword value assigned is negative or too large|||17725
|asg19|mov|11,-(xs)|8,wb||stack value|17729
||jsr|6,gtstg|||convert to string|17730
||err|1,211|26,value assigned to keyword errtext not a string|||17731
||mov|3,r_etx|7,xr||make assignment|17732
||exi||||return to caller|17733
|asg21|bgt|8,wa|18,=num02|6,asg18|moan if not 0,1, or 2|17747
||bze|8,wa|6,asg15||just assign if zero|17748
||bze|3,pfdmp|6,asg22||branch if first assignment|17749
||beq|8,wa|3,pfdmp|6,asg23|also if same value as before|17750
||erb|1,268|26,inconsistent value assigned to keyword profile|||17751
|asg22|mov|3,pfdmp|8,wa||note value on first assignment|17753
|asg23|mov|3,kvpfl|8,wa||store new value|17754
||jsr|6,stgcc|||recompute countdown counts|17755
||jsr|6,systm|||get the time|17756
||sti|3,pfstm|||fudge some kind of start time|17757
||exi||||return to asign caller|17758
|asg24|bge|8,wa|18,=mnlen|6,asg15|if acceptable value|17763
||erb|1,287|26,value assigned to keyword maxlngth is too small|||17764
|asg26|bnz|8,wa|6,asg15||if acceptable value|17768
||erb|1,274|26,value assigned to keyword fullscan is zero|||17769
||enp||||end procedure asign|17771
||ejc|||||17772
|asinp|prc|25,r|1,1||entry point, recursive|17788
||add|7,xl|8,wa||point to variable|17789
||mov|7,xr|9,(xl)||load current contents|17790
||beq|9,(xr)|22,=b_trt|6,asnp1|jump if trapped|17791
||mov|9,(xl)|8,wb||else perform assignment|17792
||zer|7,xl|||clear garbage value in xl|17793
||exi||||return to asinp caller|17794
|asnp1|sub|7,xl|8,wa||restore base pointer|17798
||mov|11,-(xs)|3,pmssl||stack subject string length|17799
||mov|11,-(xs)|3,pmhbs||stack history stack base ptr|17800
||mov|11,-(xs)|3,r_pms||stack subject string pointer|17801
||mov|11,-(xs)|3,pmdfl||stack dot flag|17802
||jsr|6,asign|||call full-blown assignment routine|17803
||ppm|6,asnp2|||jump if failure|17804
||mov|3,pmdfl|10,(xs)+||restore dot flag|17805
||mov|3,r_pms|10,(xs)+||restore subject string pointer|17806
||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|17807
||mov|3,pmssl|10,(xs)+||restore subject string length|17808
||exi||||return to asinp caller|17809
|asnp2|mov|3,pmdfl|10,(xs)+||restore dot flag|17813
||mov|3,r_pms|10,(xs)+||restore subject string pointer|17814
||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|17815
||mov|3,pmssl|10,(xs)+||restore subject string length|17816
||exi|1,1|||take failure exit|17817
||enp||||end procedure asinp|17818
||ejc|||||17819
|blkln|prc|25,e|1,0||entry point|17837
||mov|7,xl|8,wa||copy first word|17838
||lei|7,xl|||get entry id (bl_xx)|17839
||bsw|7,xl|2,bl___|6,bln00|switch on block type|17840
||iff|2,bl_ar|6,bln01||arblk|17880
||iff|2,bl_cd|6,bln12||cdblk|17880
||iff|2,bl_ex|6,bln12||exblk|17880
||iff|2,bl_ic|6,bln07||icblk|17880
||iff|2,bl_nm|6,bln03||nmblk|17880
||iff|2,bl_p0|6,bln02||p0blk|17880
||iff|2,bl_p1|6,bln03||p1blk|17880
||iff|2,bl_p2|6,bln04||p2blk|17880
||iff|2,bl_rc|6,bln09||rcblk|17880
||iff|2,bl_sc|6,bln10||scblk|17880
||iff|2,bl_se|6,bln02||seblk|17880
||iff|2,bl_tb|6,bln01||tbblk|17880
||iff|2,bl_vc|6,bln01||vcblk|17880
||iff|1,13|6,bln00|||17880
||iff|1,14|6,bln00|||17880
||iff|1,15|6,bln00|||17880
||iff|2,bl_pd|6,bln08||pdblk|17880
||iff|2,bl_tr|6,bln05||trblk|17880
||iff|1,18|6,bln00|||17880
||iff|1,19|6,bln00|||17880
||iff|1,20|6,bln00|||17880
||iff|2,bl_ct|6,bln06||ctblk|17880
||iff|2,bl_df|6,bln01||dfblk|17880
||iff|2,bl_ef|6,bln01||efblk|17880
||iff|2,bl_ev|6,bln03||evblk|17880
||iff|2,bl_ff|6,bln05||ffblk|17880
||iff|2,bl_kv|6,bln03||kvblk|17880
||iff|2,bl_pf|6,bln01||pfblk|17880
||iff|2,bl_te|6,bln04||teblk|17880
||esw||||end of jump table on block type|17880
||ejc|||||17881
|bln00|mov|8,wa|13,num01(xr)||load length|17887
||exi||||return to blkln caller|17888
|bln01|mov|8,wa|13,num02(xr)||load length from third word|17892
||exi||||return to blkln caller|17893
|bln02|mov|8,wa|19,*num02||load length (two words)|17897
||exi||||return to blkln caller|17898
|bln03|mov|8,wa|19,*num03||load length (three words)|17902
||exi||||return to blkln caller|17903
|bln04|mov|8,wa|19,*num04||load length (four words)|17907
||exi||||return to blkln caller|17908
|bln05|mov|8,wa|19,*num05||load length|17912
||exi||||return to blkln caller|17913
||ejc|||||17914
|bln06|mov|8,wa|19,*ctsi_||set size of ctblk|17920
||exi||||return to blkln caller|17921
|bln07|mov|8,wa|19,*icsi_||set size of icblk|17925
||exi||||return to blkln caller|17926
|bln08|mov|7,xl|13,pddfp(xr)||point to dfblk|17930
||mov|8,wa|13,dfpdl(xl)||load pdblk length from dfblk|17931
||exi||||return to blkln caller|17932
|bln09|mov|8,wa|19,*rcsi_||set size of rcblk|17938
||exi||||return to blkln caller|17939
|bln10|mov|8,wa|13,sclen(xr)||load length in characters|17944
||ctb|8,wa|2,scsi_||calculate length in bytes|17945
||exi||||return to blkln caller|17946
|bln12|mov|8,wa|13,num03(xr)||load length from cdlen/exlen|17960
||exi||||return to blkln caller|17961
||enp||||end procedure blkln|17963
||ejc|||||17964
|copyb|prc|25,n|1,1||entry point|17976
||mov|7,xr|9,(xs)||load argument|17977
||beq|7,xr|21,=nulls|6,cop10|return argument if it is null|17978
||mov|8,wa|9,(xr)||else load type word|17979
||mov|8,wb|8,wa||copy type word|17980
||jsr|6,blkln|||get length of argument block|17981
||mov|7,xl|7,xr||copy pointer|17982
||jsr|6,alloc|||allocate block of same size|17983
||mov|9,(xs)|7,xr||store pointer to copy|17984
||mvw||||copy contents of old block to new|17985
||zer|7,xl|||clear garbage xl|17986
||mov|7,xr|9,(xs)||reload pointer to start of copy|17987
||beq|8,wb|22,=b_tbt|6,cop05|jump if table|17988
||beq|8,wb|22,=b_vct|6,cop01|jump if vector|17989
||beq|8,wb|22,=b_pdt|6,cop01|jump if program defined|17990
||bne|8,wb|22,=b_art|6,cop10|return copy if not array|17995
||add|7,xr|13,arofs(xr)||point to prototype field|17999
||brn|6,cop02|||jump to merge|18000
|cop01|add|7,xr|19,*pdfld||point to pdfld = vcvls|18004
|cop02|mov|7,xl|9,(xr)||load next pointer|18009
|cop03|bne|9,(xl)|22,=b_trt|6,cop04|jump if not trapped|18013
||mov|7,xl|13,trval(xl)||else point to next value|18014
||brn|6,cop03|||and loop back|18015
||ejc|||||18016
|cop04|mov|10,(xr)+|7,xl||store real value, bump pointer|18022
||bne|7,xr|3,dnamp|6,cop02|loop back if more to go|18023
||brn|6,cop09|||else jump to exit|18024
|cop05|zer|13,idval(xr)|||zero id to stop dump blowing up|18028
||mov|8,wa|19,*tesi_||set size of teblk|18029
||mov|8,wc|19,*tbbuk||set initial offset|18030
|cop06|mov|7,xr|9,(xs)||load table pointer|18034
||beq|8,wc|13,tblen(xr)|6,cop09|jump to exit if all done|18035
||mov|8,wb|8,wc||else copy offset|18036
||sub|8,wb|19,*tenxt||subtract link offset to merge|18037
||add|7,xr|8,wb||next bucket header less link offset|18038
||ica|8,wc|||bump offset|18039
|cop07|mov|7,xl|13,tenxt(xr)||load pointer to next teblk|18043
||mov|13,tenxt(xr)|9,(xs)||set end of chain pointer in case|18044
||beq|9,(xl)|22,=b_tbt|6,cop06|back for next bucket if chain end|18045
||sub|7,xr|8,wb||point to head of previous block|18046
||mov|11,-(xs)|7,xr||stack ptr to previous block|18047
||mov|8,wa|19,*tesi_||set size of teblk|18048
||jsr|6,alloc|||allocate new teblk|18049
||mov|11,-(xs)|7,xr||stack ptr to new teblk|18050
||mvw||||copy old teblk to new teblk|18051
||mov|7,xr|10,(xs)+||restore pointer to new teblk|18052
||mov|7,xl|10,(xs)+||restore pointer to previous block|18053
||add|7,xl|8,wb||add offset back in|18054
||mov|13,tenxt(xl)|7,xr||link new block to previous|18055
||mov|7,xl|7,xr||copy pointer to new block|18056
|cop08|mov|7,xl|13,teval(xl)||load value|18060
||beq|9,(xl)|22,=b_trt|6,cop08|loop back if trapped|18061
||mov|13,teval(xr)|7,xl||store untrapped value in teblk|18062
||zer|8,wb|||zero offset within teblk|18063
||brn|6,cop07|||back for next teblk|18064
|cop09|mov|7,xr|10,(xs)+||load pointer to block|18068
||exi||||return|18069
|cop10|exi|1,1|||return|18073
||ejc|||||18074
||enp||||end procedure copyb|18092
|cdgcg|prc|25,e|1,0||entry point|18103
||mov|7,xl|13,cmopn(xr)||get unary goto operator|18104
||mov|7,xr|13,cmrop(xr)||point to goto operand|18105
||beq|7,xl|21,=opdvd|6,cdgc2|jump if direct goto|18106
||jsr|6,cdgnm|||generate opnd by name if not direct|18107
|cdgc1|mov|8,wa|7,xl||goto operator|18111
||jsr|6,cdwrd|||generate it|18112
||exi||||return to caller|18113
|cdgc2|jsr|6,cdgvl|||generate operand by value|18117
||brn|6,cdgc1|||merge to return|18118
||enp||||end procedure cdgcg|18119
||ejc|||||18120
|cdgex|prc|25,r|1,0||entry point, recursive|18137
||blo|9,(xl)|22,=b_vr_|6,cdgx1|jump if not variable|18138
||mov|8,wa|19,*sesi_||set size of seblk|18142
||jsr|6,alloc|||allocate space for seblk|18143
||mov|9,(xr)|22,=b_sel||set type word|18144
||mov|13,sevar(xr)|7,xl||store vrblk pointer|18145
||exi||||return to cdgex caller|18146
|cdgx1|mov|7,xr|7,xl||copy tree pointer|18150
||mov|11,-(xs)|8,wc||save wc|18151
||mov|7,xl|3,cwcof||save current offset|18152
||bze|8,wa|6,cdgx2||jump if by value|18154
||mov|8,wa|9,(xr)||get type word|18156
||bne|8,wa|22,=b_cmt|6,cdgx2|call by value if not cmblk|18157
||bge|13,cmtyp(xr)|18,=c__nm|6,cdgx2|jump if cmblk only by value|18158
||ejc|||||18159
||jsr|6,cdgnm|||generate code by name|18165
||mov|8,wa|21,=ornm_||load return by name word|18166
||brn|6,cdgx3|||merge with value case|18167
|cdgx2|jsr|6,cdgvl|||generate code by value|18171
||mov|8,wa|21,=orvl_||load return by value word|18172
|cdgx3|jsr|6,cdwrd|||generate return word|18176
||jsr|6,exbld|||build exblk|18177
||mov|8,wc|10,(xs)+||restore wc|18178
||exi||||return to cdgex caller|18179
||enp||||end procedure cdgex|18180
||ejc|||||18181
|cdgnm|prc|25,r|1,0||entry point, recursive|18206
||mov|11,-(xs)|7,xl||save entry xl|18207
||mov|11,-(xs)|8,wb||save entry wb|18208
||chk||||check for stack overflow|18209
||mov|8,wa|9,(xr)||load type word|18210
||beq|8,wa|22,=b_cmt|6,cgn04|jump if cmblk|18211
||bhi|8,wa|22,=b_vr_|6,cgn02|jump if simple variable|18212
|cgn01|erb|1,212|26,syntax error: value used where name is required|||18216
|cgn02|mov|8,wa|21,=olvn_||load variable load call|18220
||jsr|6,cdwrd|||generate it|18221
||mov|8,wa|7,xr||copy vrblk pointer|18222
||jsr|6,cdwrd|||generate vrblk pointer|18223
||ejc|||||18224
|cgn03|mov|8,wb|10,(xs)+||restore entry wb|18230
||mov|7,xl|10,(xs)+||restore entry xl|18231
||exi||||return to cdgnm caller|18232
|cgn04|mov|7,xl|7,xr||copy cmblk pointer|18236
||mov|7,xr|13,cmtyp(xr)||load cmblk type|18237
||bge|7,xr|18,=c__nm|6,cgn01|error if not name operand|18238
||bsw|7,xr|2,c__nm||else switch on type|18239
||iff|2,c_arr|6,cgn05||array reference|18247
||iff|2,c_fnc|6,cgn08||function call|18247
||iff|2,c_def|6,cgn09||deferred expression|18247
||iff|2,c_ind|6,cgn10||indirect reference|18247
||iff|2,c_key|6,cgn11||keyword reference|18247
||iff|2,c_ubo|6,cgn08||undefined binary op|18247
||iff|2,c_uuo|6,cgn08||undefined unary op|18247
||esw||||end switch on cmblk type|18247
|cgn05|mov|8,wb|19,*cmopn||point to array operand|18251
|cgn06|jsr|6,cmgen|||generate code for next operand|18255
||mov|8,wc|13,cmlen(xl)||load length of cmblk|18256
||blt|8,wb|8,wc|6,cgn06|loop till all generated|18257
||mov|8,wa|21,=oaon_||load one-subscript case call|18261
||beq|8,wc|19,*cmar1|6,cgn07|jump to exit if one subscript case|18262
||mov|8,wa|21,=oamn_||else load multi-subscript case call|18263
||jsr|6,cdwrd|||generate call|18264
||mov|8,wa|8,wc||copy cmblk length|18265
||btw|8,wa|||convert to words|18266
||sub|8,wa|18,=cmvls||calculate number of subscripts|18267
||ejc|||||18268
|cgn07|mnz|8,wc|||set result non-constant|18274
||jsr|6,cdwrd|||generate word|18275
||brn|6,cgn03|||back to exit|18276
|cgn08|mov|7,xr|7,xl||copy cmblk pointer|18280
||jsr|6,cdgvl|||gen code by value for call|18281
||mov|8,wa|21,=ofne_||get extra call for by name|18282
||brn|6,cgn07|||back to generate and exit|18283
|cgn09|mov|7,xr|13,cmrop(xl)||check if variable|18287
||bhi|9,(xr)|22,=b_vr_|6,cgn02|treat *variable as simple var|18288
||mov|7,xl|7,xr||copy ptr to expression tree|18289
||mov|8,wa|18,=num01||return name|18291
||jsr|6,cdgex|||else build exblk|18293
||mov|8,wa|21,=olex_||set call to load expr by name|18294
||jsr|6,cdwrd|||generate it|18295
||mov|8,wa|7,xr||copy exblk pointer|18296
||jsr|6,cdwrd|||generate exblk pointer|18297
||brn|6,cgn03|||back to exit|18298
|cgn10|mov|7,xr|13,cmrop(xl)||get operand|18302
||jsr|6,cdgvl|||generate code by value for it|18303
||mov|8,wa|21,=oinn_||load call for indirect by name|18304
||brn|6,cgn12|||merge|18305
|cgn11|mov|7,xr|13,cmrop(xl)||get operand|18309
||jsr|6,cdgnm|||generate code by name for it|18310
||mov|8,wa|21,=okwn_||load call for keyword by name|18311
|cgn12|jsr|6,cdwrd|||generate code for operator|18315
||brn|6,cgn03|||exit|18316
||enp||||end procedure cdgnm|18317
||ejc|||||18318
|cdgvl|prc|25,r|1,0||entry point, recursive|18346
||mov|8,wa|9,(xr)||load type word|18347
||beq|8,wa|22,=b_cmt|6,cgv01|jump if cmblk|18348
||blt|8,wa|22,=b_vra|6,cgv00|jump if icblk, rcblk, scblk|18349
||bnz|13,vrlen(xr)|6,cgvl0||jump if not system variable|18350
||mov|11,-(xs)|7,xr||stack xr|18351
||mov|7,xr|13,vrsvp(xr)||point to svblk|18352
||mov|8,wa|13,svbit(xr)||get svblk property bits|18353
||mov|7,xr|10,(xs)+||recover xr|18354
||anb|8,wa|4,btkwv||check if constant keyword value|18355
||beq|8,wa|4,btkwv|6,cgv00|jump if constant keyword value|18356
|cgvl0|mnz|8,wc|||indicate non-constant value|18360
|cgv00|mov|8,wa|7,xr||copy ptr to var or constant|18365
||jsr|6,cdwrd|||generate as code word|18366
||exi||||return to caller|18367
||ejc|||||18368
|cgv01|mov|11,-(xs)|8,wb||save entry wb|18374
||mov|11,-(xs)|7,xl||save entry xl|18375
||mov|11,-(xs)|8,wc||save entry constant flag|18376
||mov|11,-(xs)|3,cwcof||save initial code offset|18377
||chk||||check for stack overflow|18378
||mov|7,xl|7,xr||copy cmblk pointer|18386
||mov|7,xr|13,cmtyp(xr)||load cmblk type|18387
||mov|8,wc|3,cswno||reset constant flag|18388
||ble|7,xr|18,=c_pr_|6,cgv02|jump if not predicate value|18389
||mnz|8,wc|||else force non-constant case|18390
|cgv02|bsw|7,xr|2,c__nv||switch to appropriate generator|18394
||iff|2,c_arr|6,cgv03||array reference|18414
||iff|2,c_fnc|6,cgv05||function call|18414
||iff|2,c_def|6,cgv14||deferred expression|18414
||iff|2,c_ind|6,cgv31||indirect reference|18414
||iff|2,c_key|6,cgv27||keyword reference|18414
||iff|2,c_ubo|6,cgv29||undefined binop|18414
||iff|2,c_uuo|6,cgv30||undefined unop|18414
||iff|2,c_bvl|6,cgv18||binops with val opds|18414
||iff|2,c_uvl|6,cgv19||unops with valu opnd|18414
||iff|2,c_alt|6,cgv18||alternation|18414
||iff|2,c_cnc|6,cgv24||concatenation|18414
||iff|2,c_cnp|6,cgv24||concatenation (not pattern match)|18414
||iff|2,c_unm|6,cgv27||unops with name opnd|18414
||iff|2,c_bvn|6,cgv26||binary _ and .|18414
||iff|2,c_ass|6,cgv21||assignment|18414
||iff|2,c_int|6,cgv31||interrogation|18414
||iff|2,c_neg|6,cgv28||negation|18414
||iff|2,c_sel|6,cgv15||selection|18414
||iff|2,c_pmt|6,cgv18||pattern match|18414
||esw||||end switch on cmblk type|18414
||ejc|||||18415
|cgv03|mov|8,wb|19,*cmopn||set offset to array operand|18421
|cgv04|jsr|6,cmgen|||gen value code for next operand|18425
||mov|8,wc|13,cmlen(xl)||load cmblk length|18426
||blt|8,wb|8,wc|6,cgv04|loop back if more to go|18427
||mov|8,wa|21,=oaov_||set one subscript call in case|18431
||beq|8,wc|19,*cmar1|6,cgv32|jump to exit if 1-sub case|18432
||mov|8,wa|21,=oamv_||else set call for multi-subscripts|18433
||jsr|6,cdwrd|||generate call|18434
||mov|8,wa|8,wc||copy length of cmblk|18435
||sub|8,wa|19,*cmvls||subtract standard length|18436
||btw|8,wa|||get number of words|18437
||brn|6,cgv32|||jump to generate subscript count|18438
|cgv05|mov|8,wb|19,*cmvls||set offset to first argument|18442
|cgv06|beq|8,wb|13,cmlen(xl)|6,cgv07|jump if all generated|18446
||jsr|6,cmgen|||else gen value code for next arg|18447
||brn|6,cgv06|||back to generate next argument|18448
|cgv07|sub|8,wb|19,*cmvls||get number of arg ptrs (bytes)|18452
||btw|8,wb|||convert bytes to words|18453
||mov|7,xr|13,cmopn(xl)||load function vrblk pointer|18454
||bnz|13,vrlen(xr)|6,cgv12||jump if not system function|18455
||mov|7,xl|13,vrsvp(xr)||load svblk ptr if system var|18456
||mov|8,wa|13,svbit(xl)||load bit mask|18457
||anb|8,wa|4,btffc||test for fast function call allowed|18458
||zrb|8,wa|6,cgv12||jump if not|18459
||ejc|||||18460
||mov|8,wa|13,svbit(xl)||reload bit indicators|18466
||anb|8,wa|4,btpre||test for preevaluation ok|18467
||nzb|8,wa|6,cgv08||jump if preevaluation permitted|18468
||mnz|8,wc|||else set result non-constant|18469
|cgv08|mov|7,xl|13,vrfnc(xr)||load ptr to svfnc field|18473
||mov|8,wa|13,fargs(xl)||load svnar field value|18474
||beq|8,wa|8,wb|6,cgv11|jump if argument count is correct|18475
||bhi|8,wa|8,wb|6,cgv09|jump if too few arguments given|18476
||sub|8,wb|8,wa||get number of extra args|18480
||lct|8,wb|8,wb||set as count to control loop|18481
||mov|8,wa|21,=opop_||set pop call|18482
||brn|6,cgv10|||jump to common loop|18483
|cgv09|sub|8,wa|8,wb||get number of missing arguments|18487
||lct|8,wb|8,wa||load as count to control loop|18488
||mov|8,wa|21,=nulls||load ptr to null constant|18489
|cgv10|jsr|6,cdwrd|||generate one call|18493
||bct|8,wb|6,cgv10||loop till all generated|18494
|cgv11|mov|8,wa|7,xl||copy pointer to svfnc field|18498
||brn|6,cgv36|||jump to generate call|18499
||ejc|||||18500
|cgv12|mov|8,wa|21,=ofns_||set one arg call in case|18506
||beq|8,wb|18,=num01|6,cgv13|jump if one arg case|18507
||mov|8,wa|21,=ofnc_||else load call for more than 1 arg|18508
||jsr|6,cdwrd|||generate it|18509
||mov|8,wa|8,wb||copy argument count|18510
|cgv13|jsr|6,cdwrd|||generate =o_fns or arg count|18514
||mov|8,wa|7,xr||copy vrblk pointer|18515
||brn|6,cgv32|||jump to generate vrblk ptr|18516
|cgv14|mov|7,xl|13,cmrop(xl)||point to expression tree|18520
||zer|8,wa|||return value|18522
||jsr|6,cdgex|||build exblk or seblk|18524
||mov|8,wa|7,xr||copy block ptr|18525
||jsr|6,cdwrd|||generate ptr to exblk or seblk|18526
||brn|6,cgv34|||jump to exit, constant test|18527
|cgv15|zer|11,-(xs)|||zero ptr to chain of forward jumps|18531
||zer|11,-(xs)|||zero ptr to prev o_slc forward ptr|18532
||mov|8,wb|19,*cmvls||point to first alternative|18533
||mov|8,wa|21,=osla_||set initial code word|18534
|cgv16|jsr|6,cdwrd|||generate o_slc (o_sla first time)|18545
||mov|9,(xs)|3,cwcof||set current loc as ptr to fill in|18546
||jsr|6,cdwrd|||generate garbage word there for now|18547
||jsr|6,cmgen|||gen value code for alternative|18548
||mov|8,wa|21,=oslb_||load o_slb pointer|18549
||jsr|6,cdwrd|||generate o_slb call|18550
||mov|8,wa|13,num01(xs)||load old chain ptr|18551
||mov|13,num01(xs)|3,cwcof||set current loc as new chain head|18552
||jsr|6,cdwrd|||generate forward chain link|18553
||ejc|||||18554
||mov|7,xr|9,(xs)||load offset to word to plug|18560
||add|7,xr|3,r_ccb||point to actual location to plug|18561
||mov|9,(xr)|3,cwcof||plug proper offset in|18562
||mov|8,wa|21,=oslc_||load o_slc ptr for next alternative|18563
||mov|7,xr|8,wb||copy offset (destroy garbage xr)|18564
||ica|7,xr|||bump extra time for test|18565
||blt|7,xr|13,cmlen(xl)|6,cgv16|loop back if not last alternative|18566
||mov|8,wa|21,=osld_||get header call|18570
||jsr|6,cdwrd|||generate o_sld call|18571
||jsr|6,cmgen|||generate code for last alternative|18572
||ica|7,xs|||pop offset ptr|18573
||mov|7,xr|10,(xs)+||load chain ptr|18574
|cgv17|add|7,xr|3,r_ccb||make next ptr absolute|18578
||mov|8,wa|9,(xr)||load forward ptr|18579
||mov|9,(xr)|3,cwcof||plug required offset|18580
||mov|7,xr|8,wa||copy forward ptr|18581
||bnz|8,wa|6,cgv17||loop back if more to go|18582
||brn|6,cgv33|||else jump to exit (not constant)|18583
|cgv18|mov|7,xr|13,cmlop(xl)||load left operand pointer|18587
||jsr|6,cdgvl|||gen value code for left operand|18588
|cgv19|mov|7,xr|13,cmrop(xl)||load right (only) operand ptr|18592
||jsr|6,cdgvl|||gen code by value|18593
||ejc|||||18594
|cgv20|mov|8,wa|13,cmopn(xl)||load operator call pointer|18600
||brn|6,cgv36|||jump to generate it with cons test|18601
|cgv21|mov|7,xr|13,cmlop(xl)||load left operand pointer|18605
||blo|9,(xr)|22,=b_vr_|6,cgv22|jump if not variable|18606
||mov|7,xr|13,cmrop(xl)||load right operand ptr|18610
||jsr|6,cdgvl|||generate code by value|18611
||mov|8,wa|13,cmlop(xl)||reload left operand vrblk ptr|18612
||add|8,wa|19,*vrsto||point to vrsto field|18613
||brn|6,cgv32|||jump to generate store ptr|18614
|cgv22|jsr|6,expap|||test for pattern match on left side|18618
||ppm|6,cgv23|||jump if not pattern match|18619
||mov|13,cmlop(xl)|13,cmrop(xr)||save pattern ptr in safe place|18623
||mov|7,xr|13,cmlop(xr)||load subject ptr|18624
||jsr|6,cdgnm|||gen code by name for subject|18625
||mov|7,xr|13,cmlop(xl)||load pattern ptr|18626
||jsr|6,cdgvl|||gen code by value for pattern|18627
||mov|8,wa|21,=opmn_||load match by name call|18628
||jsr|6,cdwrd|||generate it|18629
||mov|7,xr|13,cmrop(xl)||load replacement value ptr|18630
||jsr|6,cdgvl|||gen code by value|18631
||mov|8,wa|21,=orpl_||load replace call|18632
||brn|6,cgv32|||jump to gen and exit (not constant)|18633
|cgv23|mnz|8,wc|||inhibit pre-evaluation|18637
||jsr|6,cdgnm|||gen code by name for left side|18638
||brn|6,cgv31|||merge with unop circuit|18639
||ejc|||||18640
|cgv24|mov|7,xr|13,cmlop(xl)||load left operand ptr|18646
||bne|9,(xr)|22,=b_cmt|6,cgv18|ordinary binop if not cmblk|18647
||mov|8,wb|13,cmtyp(xr)||load cmblk type code|18648
||beq|8,wb|18,=c_int|6,cgv25|special case if interrogation|18649
||beq|8,wb|18,=c_neg|6,cgv25|or negation|18650
||bne|8,wb|18,=c_fnc|6,cgv18|else ordinary binop if not function|18651
||mov|7,xr|13,cmopn(xr)||else load function vrblk ptr|18652
||bnz|13,vrlen(xr)|6,cgv18||ordinary binop if not system var|18653
||mov|7,xr|13,vrsvp(xr)||else point to svblk|18654
||mov|8,wa|13,svbit(xr)||load bit indicators|18655
||anb|8,wa|4,btprd||test for predicate function|18656
||zrb|8,wa|6,cgv18||ordinary binop if not|18657
|cgv25|mov|7,xr|13,cmlop(xl)||reload left arg|18661
||jsr|6,cdgvl|||gen code by value|18662
||mov|8,wa|21,=opop_||load pop call|18663
||jsr|6,cdwrd|||generate it|18664
||mov|7,xr|13,cmrop(xl)||load right operand|18665
||jsr|6,cdgvl|||gen code by value as result code|18666
||brn|6,cgv33|||exit (not constant)|18667
|cgv26|mov|7,xr|13,cmlop(xl)||load left operand|18671
||jsr|6,cdgvl|||gen code by value, merge|18672
|cgv27|mov|7,xr|13,cmrop(xl)||load right operand ptr|18676
||jsr|6,cdgnm|||gen code by name for right arg|18677
||mov|7,xr|13,cmopn(xl)||get operator code word|18678
||bne|9,(xr)|22,=o_kwv|6,cgv20|gen call unless keyword value|18679
||ejc|||||18680
||bnz|8,wc|6,cgv20||gen call if non-constant (not var)|18689
||mnz|8,wc|||else set non-constant in case|18690
||mov|7,xr|13,cmrop(xl)||load ptr to operand vrblk|18691
||bnz|13,vrlen(xr)|6,cgv20||gen (non-constant) if not sys var|18692
||mov|7,xr|13,vrsvp(xr)||else load ptr to svblk|18693
||mov|8,wa|13,svbit(xr)||load bit mask|18694
||anb|8,wa|4,btckw||test for constant keyword|18695
||zrb|8,wa|6,cgv20||go gen if not constant|18696
||zer|8,wc|||else set result constant|18697
||brn|6,cgv20|||and jump back to generate call|18698
|cgv28|mov|8,wa|21,=onta_||get initial word|18702
||jsr|6,cdwrd|||generate it|18703
||mov|8,wb|3,cwcof||save next offset|18704
||jsr|6,cdwrd|||generate gunk word for now|18705
||mov|7,xr|13,cmrop(xl)||load right operand ptr|18706
||jsr|6,cdgvl|||gen code by value|18707
||mov|8,wa|21,=ontb_||load end of evaluation call|18708
||jsr|6,cdwrd|||generate it|18709
||mov|7,xr|8,wb||copy offset to word to plug|18710
||add|7,xr|3,r_ccb||point to actual word to plug|18711
||mov|9,(xr)|3,cwcof||plug word with current offset|18712
||mov|8,wa|21,=ontc_||load final call|18713
||brn|6,cgv32|||jump to generate it (not constant)|18714
|cgv29|mov|7,xr|13,cmlop(xl)||load left operand ptr|18718
||jsr|6,cdgvl|||generate code by value|18719
||ejc|||||18720
|cgv30|mov|8,wb|18,=c_uo_||set unop code + 1|18726
||sub|8,wb|13,cmtyp(xl)||set number of args (1 or 2)|18727
||mov|7,xr|13,cmrop(xl)||load right (only) operand pointer|18731
||jsr|6,cdgvl|||gen value code for right operand|18732
||mov|7,xr|13,cmopn(xl)||load pointer to operator dv|18733
||mov|7,xr|13,dvopn(xr)||load pointer offset|18734
||wtb|7,xr|||convert word offset to bytes|18735
||add|7,xr|20,=r_uba||point to proper function ptr|18736
||sub|7,xr|19,*vrfnc||set standard function offset|18737
||brn|6,cgv12|||merge with function call circuit|18738
|cgv31|mnz|8,wc|||set non constant|18742
||brn|6,cgv19|||merge|18743
|cgv32|jsr|6,cdwrd|||generate word, merge|18747
|cgv33|mnz|8,wc|||indicate result is not constant|18751
|cgv34|ica|7,xs|||pop initial code offset|18755
||mov|8,wa|10,(xs)+||restore old constant flag|18756
||mov|7,xl|10,(xs)+||restore entry xl|18757
||mov|8,wb|10,(xs)+||restore entry wb|18758
||bnz|8,wc|6,cgv35||jump if not constant|18759
||mov|8,wc|8,wa||else restore entry constant flag|18760
|cgv35|exi||||return to cdgvl caller|18764
|cgv36|jsr|6,cdwrd|||generate word|18768
||bnz|8,wc|6,cgv34||jump to exit if not constant|18769
||ejc|||||18770
||mov|8,wa|21,=orvl_||load call to return value|18776
||jsr|6,cdwrd|||generate it|18777
||mov|7,xl|9,(xs)||load initial code offset|18778
||jsr|6,exbld|||build exblk for expression|18779
||zer|8,wb|||set to evaluate by value|18780
||jsr|6,evalx|||evaluate expression|18781
||ppm||||should not fail|18782
||mov|8,wa|9,(xr)||load type word of result|18783
||blo|8,wa|22,=p_aaa|6,cgv37|jump if not pattern|18784
||mov|8,wa|21,=olpt_||else load special pattern load call|18785
||jsr|6,cdwrd|||generate it|18786
|cgv37|mov|8,wa|7,xr||copy constant pointer|18790
||jsr|6,cdwrd|||generate ptr|18791
||zer|8,wc|||set result constant|18792
||brn|6,cgv34|||jump back to exit|18793
||enp||||end procedure cdgvl|18794
||ejc|||||18795
|cdwrd|prc|25,e|1,0||entry point|18813
||mov|11,-(xs)|7,xr||save entry xr|18814
||mov|11,-(xs)|8,wa||save code word to be generated|18815
|cdwd1|mov|7,xr|3,r_ccb||load ptr to ccblk being built|18819
||bnz|7,xr|6,cdwd2||jump if block allocated|18820
||mov|8,wa|19,*e_cbs||load initial length|18824
||jsr|6,alloc|||allocate ccblk|18825
||mov|9,(xr)|22,=b_cct||store type word|18826
||mov|3,cwcof|19,*cccod||set initial offset|18827
||mov|13,cclen(xr)|8,wa||store block length|18828
||zer|13,ccsln(xr)|||zero line number|18830
||mov|3,r_ccb|7,xr||store ptr to new block|18832
|cdwd2|mov|8,wa|3,cwcof||load current offset|18836
||add|8,wa|19,*num05||adjust for test (five words)|18838
||blo|8,wa|13,cclen(xr)|6,cdwd4|jump if room in this block|18842
||bge|8,wa|3,mxlen|6,cdwd5|jump if already at max size|18846
||add|8,wa|19,*e_cbs||else get new size|18847
||mov|11,-(xs)|7,xl||save entry xl|18848
||mov|7,xl|7,xr||copy pointer|18849
||blt|8,wa|3,mxlen|6,cdwd3|jump if not too large|18850
||mov|8,wa|3,mxlen||else reset to max allowed size|18851
||ejc|||||18852
|cdwd3|jsr|6,alloc|||allocate new block|18858
||mov|3,r_ccb|7,xr||store pointer to new block|18859
||mov|10,(xr)+|22,=b_cct||store type word in new block|18860
||mov|10,(xr)+|8,wa||store block length|18861
||mov|10,(xr)+|13,ccsln(xl)||copy source line number word|18863
||add|7,xl|19,*ccuse||point to ccuse,cccod fields in old|18865
||mov|8,wa|9,(xl)||load ccuse value|18866
||mvw||||copy useful words from old block|18867
||mov|7,xl|10,(xs)+||restore xl|18868
||brn|6,cdwd1|||merge back to try again|18869
|cdwd4|mov|8,wa|3,cwcof||load current offset|18873
||ica|8,wa|||get new offset|18874
||mov|3,cwcof|8,wa||store new offset|18875
||mov|13,ccuse(xr)|8,wa||store in ccblk for gbcol|18876
||dca|8,wa|||restore ptr to this word|18877
||add|7,xr|8,wa||point to current entry|18878
||mov|8,wa|10,(xs)+||reload word to generate|18879
||mov|9,(xr)|8,wa||store word in block|18880
||mov|7,xr|10,(xs)+||restore entry xr|18881
||exi||||return to caller|18882
|cdwd5|erb|1,213|26,syntax error: statement is too complicated.|||18886
||enp||||end procedure cdwrd|18887
||ejc|||||18888
|cmgen|prc|25,r|1,0||entry point, recursive|18901
||mov|7,xr|7,xl||copy cmblk pointer|18902
||add|7,xr|8,wb||point to cmblk pointer|18903
||mov|7,xr|9,(xr)||load cmblk pointer|18904
||jsr|6,cdgvl|||generate code by value|18905
||ica|8,wb|||bump offset|18906
||exi||||return to caller|18907
||enp||||end procedure cmgen|18908
||ejc|||||18909
||ejc|||||18966
||ejc|||||19014
|cmpil|prc|25,e|1,0||entry point|19020
||lct|8,wb|18,=cmnen||set number of stack work locations|19021
|cmp00|zer|11,-(xs)|||store a zero, make one entry|19025
||bct|8,wb|6,cmp00||loop back until all set|19026
||mov|3,cmpxs|7,xs||save stack pointer for error sec|19027
||sss|3,cmpss|||save s-r stack pointer if any|19028
|cmp01|mov|8,wb|3,scnpt||set scan pointer offset|19032
||mov|3,scnse|8,wb||set start of element location|19033
||mov|8,wa|21,=ocer_||point to compile error call|19034
||jsr|6,cdwrd|||generate as temporary cdfal|19035
||blt|8,wb|3,scnil|6,cmp04|jump if chars left on this image|19036
|cmpce|zer|7,xr|||clear possible garbage xr value|19041
||bnz|3,cnind|6,cmpc2||if within include file|19043
||bne|3,stage|18,=stgic|6,cmp02|skip unless initial compile|19045
|cmpc2|jsr|6,readr|||read next input image|19046
||bze|7,xr|6,cmp09||jump if no input available|19047
||jsr|6,nexts|||acquire next source image|19048
||mov|3,lstsn|3,cmpsn||store stmt no for use by listr|19049
||mov|3,cmpln|3,rdcln||store line number at start of stmt|19050
||zer|3,scnpt|||reset scan pointer|19051
||brn|6,cmp04|||go process image|19052
|cmp02|mov|7,xr|3,r_cim||get current image|19057
||mov|8,wb|3,scnpt||get current offset|19058
||plc|7,xr|8,wb||prepare to get chars|19059
|cmp03|bge|3,scnpt|3,scnil|6,cmp09|end loop if end of image|19063
||lch|8,wc|10,(xr)+||get char|19064
||icv|3,scnpt|||advance offset|19065
||bne|8,wc|18,=ch_sm|6,cmp03|loop if not semi-colon|19066
||ejc|||||19067
|cmp04|mov|7,xr|3,r_cim||point to current image|19075
||mov|8,wb|3,scnpt||load current offset|19076
||mov|8,wa|8,wb||copy for label scan|19077
||plc|7,xr|8,wb||point to first character|19078
||lch|8,wc|10,(xr)+||load first character|19079
||beq|8,wc|18,=ch_sm|6,cmp12|no label if semicolon|19080
||beq|8,wc|18,=ch_as|6,cmpce|loop back if comment card|19081
||beq|8,wc|18,=ch_mn|6,cmp32|jump if control card|19082
||mov|3,r_cmp|3,r_cim||about to destroy r_cim|19083
||mov|7,xl|20,=cmlab||point to label work string|19084
||mov|3,r_cim|7,xl||scane is to scan work string|19085
||psc|7,xl|||point to first character position|19086
||sch|8,wc|10,(xl)+||store char just loaded|19087
||mov|8,wc|18,=ch_sm||get a semicolon|19088
||sch|8,wc|9,(xl)||store after first char|19089
||csc|7,xl|||finished character storing|19090
||zer|7,xl|||clear pointer|19091
||zer|3,scnpt|||start at first character|19092
||mov|11,-(xs)|3,scnil||preserve image length|19093
||mov|3,scnil|18,=num02||read 2 chars at most|19094
||jsr|6,scane|||scan first char for type|19095
||mov|3,scnil|10,(xs)+||restore image length|19096
||mov|8,wc|7,xl||note return code|19097
||mov|7,xl|3,r_cmp||get old r_cim|19098
||mov|3,r_cim|7,xl||put it back|19099
||mov|3,scnpt|8,wb||reinstate offset|19100
||bnz|3,scnbl|6,cmp12||blank seen - cant be label|19101
||mov|7,xr|7,xl||point to current image|19102
||plc|7,xr|8,wb||point to first char again|19103
||beq|8,wc|18,=t_var|6,cmp06|ok if letter|19104
||beq|8,wc|18,=t_con|6,cmp06|ok if digit|19105
|cmple|mov|3,r_cim|3,r_cmp||point to bad line|19109
||erb|1,214|26,bad label or misplaced continuation line|||19110
|cmp05|beq|8,wc|18,=ch_sm|6,cmp07|skip if semicolon|19114
||icv|8,wa|||bump offset|19115
||beq|8,wa|3,scnil|6,cmp07|jump if end of image (label end)|19116
||ejc|||||19117
|cmp06|lch|8,wc|10,(xr)+||else load next character|19123
||beq|8,wc|18,=ch_ht|6,cmp07|jump if horizontal tab|19125
||bne|8,wc|18,=ch_bl|6,cmp05|loop back if non-blank|19130
|cmp07|mov|3,scnpt|8,wa||save updated scan offset|19134
||sub|8,wa|8,wb||get length of label|19135
||bze|8,wa|6,cmp12||skip if label length zero|19136
||zer|7,xr|||clear garbage xr value|19137
||jsr|6,sbstr|||build scblk for label name|19138
||jsr|6,gtnvr|||locate/contruct vrblk|19139
||ppm||||dummy (impossible) error return|19140
||mov|13,cmlbl(xs)|7,xr||store label pointer|19141
||bnz|13,vrlen(xr)|6,cmp11||jump if not system label|19142
||bne|13,vrsvp(xr)|21,=v_end|6,cmp11|jump if not end label|19143
||add|3,stage|18,=stgnd||adjust stage appropriately|19147
||jsr|6,scane|||scan out next element|19148
||beq|7,xl|18,=t_smc|6,cmp10|jump if end of image|19149
||bne|7,xl|18,=t_var|6,cmp08|else error if not variable|19150
||beq|13,vrlbl(xr)|21,=stndl|6,cmp08|jump if not defined (error)|19154
||mov|13,cmtra(xs)|13,vrlbl(xr)||else set initial entry pointer|19155
||jsr|6,scane|||scan next element|19156
||beq|7,xl|18,=t_smc|6,cmp10|jump if ok (end of image)|19157
|cmp08|erb|1,215|26,syntax error: undefined or erroneous entry label|||19161
|cmp09|zer|7,xr|||clear garbage xr value|19165
||add|3,stage|18,=stgnd||adjust stage appropriately|19166
||beq|3,stage|18,=stgxe|6,cmp10|jump if code call (ok)|19167
||erb|1,216|26,syntax error: missing end line|||19168
|cmp10|mov|8,wa|21,=ostp_||set stop call pointer|19172
||jsr|6,cdwrd|||generate as statement call|19173
||brn|6,cmpse|||jump to generate as failure|19174
||ejc|||||19175
|cmp11|bne|3,stage|18,=stgic|6,cmp12|jump if code call - redef. ok|19181
||beq|13,vrlbl(xr)|21,=stndl|6,cmp12|else check for redefinition|19182
||zer|13,cmlbl(xs)|||leave first label decln undisturbed|19183
||erb|1,217|26,syntax error: duplicate label|||19184
|cmp12|zer|8,wb|||set flag for statement body|19191
||jsr|6,expan|||get tree for statement body|19192
||mov|13,cmstm(xs)|7,xr||store for later use|19193
||zer|13,cmsgo(xs)|||clear success goto pointer|19194
||zer|13,cmfgo(xs)|||clear failure goto pointer|19195
||zer|13,cmcgo(xs)|||clear conditional goto flag|19196
||jsr|6,scane|||scan next element|19197
||beq|7,xl|18,=t_col|6,cmp13|jump if colon (goto)|19198
||bnz|3,cswno|6,cmp18||jump if not optimizing|19199
||bnz|13,cmlbl(xs)|6,cmp18||jump if label present|19200
||mov|7,xr|13,cmstm(xs)||load tree ptr for statement body|19201
||mov|8,wa|9,(xr)||load type word|19202
||beq|8,wa|22,=b_cmt|6,cmp18|jump if cmblk|19203
||bge|8,wa|22,=b_vra|6,cmp18|jump if not icblk, scblk, or rcblk|19204
||mov|7,xl|3,r_ccb||load ptr to ccblk|19205
||mov|13,ccuse(xl)|19,*cccod||reset use offset in ccblk|19206
||mov|3,cwcof|19,*cccod||and in global|19207
||icv|3,cmpsn|||bump statement number|19208
||brn|6,cmp01|||generate no code for statement|19209
|cmp13|mnz|3,scngo|||set goto flag|19213
||jsr|6,scane|||scan next element|19214
||beq|7,xl|18,=t_smc|6,cmp31|jump if no fields left|19215
||beq|7,xl|18,=t_sgo|6,cmp14|jump if s for success goto|19216
||beq|7,xl|18,=t_fgo|6,cmp16|jump if f for failure goto|19217
||mnz|3,scnrs|||set to rescan element not f,s|19221
||jsr|6,scngf|||scan out goto field|19222
||bnz|13,cmfgo(xs)|6,cmp17||error if fgoto already|19223
||mov|13,cmfgo(xs)|7,xr||else set as fgoto|19224
||brn|6,cmp15|||merge with sgoto circuit|19225
|cmp14|jsr|6,scngf|||scan success goto field|19229
||mov|13,cmcgo(xs)|18,=num01||set conditional goto flag|19230
|cmp15|bnz|13,cmsgo(xs)|6,cmp17||error if sgoto already given|19234
||mov|13,cmsgo(xs)|7,xr||else set sgoto|19235
||brn|6,cmp13|||loop back for next goto field|19236
|cmp16|jsr|6,scngf|||scan goto field|19240
||mov|13,cmcgo(xs)|18,=num01||set conditonal goto flag|19241
||bnz|13,cmfgo(xs)|6,cmp17||error if fgoto already given|19242
||mov|13,cmfgo(xs)|7,xr||else store fgoto pointer|19243
||brn|6,cmp13|||loop back for next field|19244
||ejc|||||19245
|cmp17|erb|1,218|26,syntax error: duplicated goto field|||19251
|cmp18|zer|3,scnse|||stop positional error flags|19255
||mov|7,xr|13,cmstm(xs)||load tree ptr for statement body|19256
||zer|8,wb|||collectable value for wb for cdgvl|19257
||zer|8,wc|||reset constant flag for cdgvl|19258
||jsr|6,expap|||test for pattern match|19259
||ppm|6,cmp19|||jump if not pattern match|19260
||mov|13,cmopn(xr)|21,=opms_||else set pattern match pointer|19261
||mov|13,cmtyp(xr)|18,=c_pmt|||19262
|cmp19|jsr|6,cdgvl|||generate code for body of statement|19266
||mov|7,xr|13,cmsgo(xs)||load sgoto pointer|19267
||mov|8,wa|7,xr||copy it|19268
||bze|7,xr|6,cmp21||jump if no success goto|19269
||zer|13,cmsoc(xs)|||clear success offset fillin ptr|19270
||bhi|7,xr|3,state|6,cmp20|jump if complex goto|19271
||add|8,wa|19,*vrtra||point to vrtra field as required|19275
||jsr|6,cdwrd|||generate success goto|19276
||brn|6,cmp22|||jump to deal with fgoto|19277
|cmp20|beq|7,xr|13,cmfgo(xs)|6,cmp22|no code if same as fgoto|19281
||zer|8,wb|||else set ok value for cdgvl in wb|19282
||jsr|6,cdgcg|||generate code for success goto|19283
||brn|6,cmp22|||jump to deal with fgoto|19284
|cmp21|mov|13,cmsoc(xs)|3,cwcof||set success fill in offset|19288
||mov|8,wa|21,=ocer_||point to compile error call|19289
||jsr|6,cdwrd|||generate as temporary value|19290
||ejc|||||19291
|cmp22|mov|7,xr|13,cmfgo(xs)||load failure goto pointer|19297
||mov|8,wa|7,xr||copy it|19298
||zer|13,cmffc(xs)|||set no fill in required yet|19299
||bze|7,xr|6,cmp23||jump if no failure goto given|19300
||add|8,wa|19,*vrtra||point to vrtra field in case|19301
||blo|7,xr|3,state|6,cmpse|jump to gen if simple fgoto|19302
||mov|8,wb|3,cwcof||save offset to o_gof call|19306
||mov|8,wa|21,=ogof_||point to failure goto call|19307
||jsr|6,cdwrd|||generate|19308
||mov|8,wa|21,=ofif_||point to fail in fail word|19309
||jsr|6,cdwrd|||generate|19310
||jsr|6,cdgcg|||generate code for failure goto|19311
||mov|8,wa|8,wb||copy offset to o_gof for cdfal|19312
||mov|8,wb|22,=b_cdc||set complex case cdtyp|19313
||brn|6,cmp25|||jump to build cdblk|19314
|cmp23|mov|8,wa|21,=ounf_||load unexpected failure call in cas|19318
||mov|8,wc|3,cswfl||get -nofail flag|19319
||orb|8,wc|13,cmcgo(xs)||check if conditional goto|19320
||zrb|8,wc|6,cmpse||jump if -nofail and no cond. goto|19321
||mnz|13,cmffc(xs)|||else set fill in flag|19322
||mov|8,wa|21,=ocer_||and set compile error for temporary|19323
|cmpse|mov|8,wb|22,=b_cds||set cdtyp for simple case|19328
||ejc|||||19329
|cmp25|mov|7,xr|3,r_ccb||point to ccblk|19342
||mov|7,xl|13,cmlbl(xs)||get possible label pointer|19343
||bze|7,xl|6,cmp26||skip if no label|19344
||zer|13,cmlbl(xs)|||clear flag for next statement|19345
||mov|13,vrlbl(xl)|7,xr||put cdblk ptr in vrblk label field|19346
|cmp26|mov|9,(xr)|8,wb||set type word for new cdblk|19350
||mov|13,cdfal(xr)|8,wa||set failure word|19351
||mov|7,xl|7,xr||copy pointer to ccblk|19352
||mov|8,wb|13,ccuse(xr)||load length gen (= new cdlen)|19353
||mov|8,wc|13,cclen(xr)||load total ccblk length|19354
||add|7,xl|8,wb||point past cdblk|19355
||sub|8,wc|8,wb||get length left for chop off|19356
||mov|9,(xl)|22,=b_cct||set type code for new ccblk at end|19357
||mov|13,ccuse(xl)|19,*cccod||set initial code offset|19358
||mov|3,cwcof|19,*cccod||reinitialise cwcof|19359
||mov|13,cclen(xl)|8,wc||set new length|19360
||mov|3,r_ccb|7,xl||set new ccblk pointer|19361
||zer|13,ccsln(xl)|||initialize new line number|19363
||mov|13,cdsln(xr)|3,cmpln||set line number in old block|19364
||mov|13,cdstm(xr)|3,cmpsn||set statement number|19366
||icv|3,cmpsn|||bump statement number|19367
||mov|7,xl|13,cmpcd(xs)||load ptr to previous cdblk|19371
||bze|13,cmffp(xs)|6,cmp27||jump if no failure fill in required|19372
||mov|13,cdfal(xl)|7,xr||else set failure ptr in previous|19373
|cmp27|mov|8,wa|13,cmsop(xs)||load success offset|19377
||bze|8,wa|6,cmp28||jump if no fill in required|19378
||add|7,xl|8,wa||else point to fill in location|19379
||mov|9,(xl)|7,xr||store forward pointer|19380
||zer|7,xl|||clear garbage xl value|19381
||ejc|||||19382
|cmp28|mov|13,cmffp(xs)|13,cmffc(xs)||copy failure fill in flag|19388
||mov|13,cmsop(xs)|13,cmsoc(xs)||copy success fill in offset|19389
||mov|13,cmpcd(xs)|7,xr||save ptr to this cdblk|19390
||bnz|13,cmtra(xs)|6,cmp29||jump if initial entry already set|19391
||mov|13,cmtra(xs)|7,xr||else set ptr here as default|19392
|cmp29|blt|3,stage|18,=stgce|6,cmp01|jump if not end line just done|19396
||bze|3,cswls|6,cmp30||skip if -nolist|19397
||jsr|6,listr|||list last line|19398
|cmp30|mov|7,xr|13,cmtra(xs)||load initial entry cdblk pointer|19402
||add|7,xs|19,*cmnen||pop work locations off stack|19403
||exi||||and return to cmpil caller|19404
|cmp31|mov|8,wb|13,cmfgo(xs)||get fail goto|19408
||orb|8,wb|13,cmsgo(xs)||or in success goto|19409
||bnz|8,wb|6,cmp18||ok if non-null field|19410
||erb|1,219|26,syntax error: empty goto field|||19411
|cmp32|icv|8,wb|||point past ch_mn|19415
||jsr|6,cncrd|||process control card|19416
||zer|3,scnse|||clear start of element loc.|19417
||brn|6,cmpce|||loop for next statement|19418
||enp||||end procedure cmpil|19419
||ejc|||||19420
|cncrd|prc|25,e|1,0||entry point|19431
||mov|3,scnpt|8,wb||offset for control card scan|19432
||mov|8,wa|18,=ccnoc||number of chars for comparison|19433
||ctw|8,wa|1,0||convert to word count|19434
||mov|3,cnswc|8,wa||save word count|19435
|cnc01|bge|3,scnpt|3,scnil|6,cnc09|return if end of image|19439
||mov|7,xr|3,r_cim||point to image|19440
||plc|7,xr|3,scnpt||char ptr for first char|19441
||lch|8,wa|10,(xr)+||get first char|19442
||flc|8,wa|||fold to lower case|19444
||beq|8,wa|18,=ch_li|6,cnc07|special case of -inxxx|19446
|cnc0a|mnz|3,scncc|||set flag for scane|19447
||jsr|6,scane|||scan card name|19448
||zer|3,scncc|||clear scane flag|19449
||bnz|7,xl|6,cnc06||fail unless control card name|19450
||mov|8,wa|18,=ccnoc||no. of chars to be compared|19451
||blt|13,sclen(xr)|8,wa|6,cnc08|fail if too few chars|19453
||mov|7,xl|7,xr||point to control card name|19457
||zer|8,wb|||zero offset for substring|19458
||jsr|6,sbstr|||extract substring for comparison|19459
||mov|8,wa|13,sclen(xr)||reload length|19461
||jsr|6,flstg|||fold to lower case|19462
||mov|3,cnscc|7,xr||keep control card substring ptr|19464
||mov|7,xr|21,=ccnms||point to list of standard names|19465
||zer|8,wb|||initialise name offset|19466
||lct|8,wc|18,=cc_nc||number of standard names|19467
|cnc02|mov|7,xl|3,cnscc||point to name|19471
||lct|8,wa|3,cnswc||counter for inner loop|19472
||brn|6,cnc04|||jump into loop|19473
|cnc03|ica|7,xr|||bump standard names ptr|19477
||ica|7,xl|||bump name pointer|19478
|cnc04|cne|13,schar(xl)|9,(xr)|6,cnc05|comp. up to cfp_c chars at once|19482
||bct|8,wa|6,cnc03||loop if more words to compare|19483
||ejc|||||19484
||mov|7,xl|8,wb||get name offset|19490
||bsw|7,xl|2,cc_nc|6,cnc08|switch|19492
||iff|2,cc_ca|6,cnc37||-case|19531
||iff|2,cc_do|6,cnc10||-double|19531
||iff|1,2|6,cnc08|||19531
||iff|2,cc_du|6,cnc11||-dump|19531
||iff|2,cc_cp|6,cnc41||-copy|19531
||iff|2,cc_ej|6,cnc12||-eject|19531
||iff|2,cc_er|6,cnc13||-errors|19531
||iff|2,cc_ex|6,cnc14||-execute|19531
||iff|2,cc_fa|6,cnc15||-fail|19531
||iff|2,cc_in|6,cnc41||-include|19531
||iff|2,cc_ln|6,cnc44||-line|19531
||iff|2,cc_li|6,cnc16||-list|19531
||iff|2,cc_nr|6,cnc17||-noerrors|19531
||iff|2,cc_nx|6,cnc18||-noexecute|19531
||iff|2,cc_nf|6,cnc19||-nofail|19531
||iff|2,cc_nl|6,cnc20||-nolist|19531
||iff|2,cc_no|6,cnc21||-noopt|19531
||iff|2,cc_np|6,cnc22||-noprint|19531
||iff|2,cc_op|6,cnc24||-optimise|19531
||iff|2,cc_pr|6,cnc25||-print|19531
||iff|2,cc_si|6,cnc27||-single|19531
||iff|2,cc_sp|6,cnc28||-space|19531
||iff|2,cc_st|6,cnc31||-stitle|19531
||iff|2,cc_ti|6,cnc32||-title|19531
||iff|2,cc_tr|6,cnc36||-trace|19531
||esw||||end switch|19531
|cnc05|ica|7,xr|||bump standard names ptr|19535
||bct|8,wa|6,cnc05||loop|19536
||icv|8,wb|||bump names offset|19537
||bct|8,wc|6,cnc02||continue if more names|19538
||brn|6,cnc08|||ignore unrecognized control card|19540
|cnc06|erb|1,247|26,invalid control statement|||19545
|cnc07|lch|8,wa|10,(xr)+||get next char|19549
||flc|8,wa|||fold to lower case|19551
||bne|8,wa|18,=ch_ln|6,cnc0a|if not letter n|19553
||lch|8,wa|9,(xr)||get third char|19554
||blt|8,wa|18,=ch_d0|6,cnc0a|if not digit|19555
||bgt|8,wa|18,=ch_d9|6,cnc0a|if not digit|19556
||add|3,scnpt|18,=num02||bump offset past -in|19557
||jsr|6,scane|||scan integer after -in|19558
||mov|11,-(xs)|7,xr||stack scanned item|19559
||jsr|6,gtsmi|||check if integer|19560
||ppm|6,cnc06|||fail if not integer|19561
||ppm|6,cnc06|||fail if negative or large|19562
||mov|3,cswin|7,xr||keep integer|19563
||ejc|||||19564
|cnc08|mov|8,wa|3,scnpt||preserve in case xeq time compile|19570
||jsr|6,scane|||look for comma|19571
||beq|7,xl|18,=t_cma|6,cnc01|loop if comma found|19572
||mov|3,scnpt|8,wa||restore scnpt in case xeq time|19573
|cnc09|exi||||return|19577
|cnc10|mnz|3,cswdb|||set switch|19581
||brn|6,cnc08|||merge|19582
|cnc11|jsr|6,sysdm|||call dumper|19588
||brn|6,cnc09|||finished|19589
|cnc12|bze|3,cswls|6,cnc09||return if -nolist|19593
||jsr|6,prtps|||eject|19594
||jsr|6,listt|||list title|19595
||brn|6,cnc09|||finished|19596
|cnc13|zer|3,cswer|||clear switch|19600
||brn|6,cnc08|||merge|19601
|cnc14|zer|3,cswex|||clear switch|19605
||brn|6,cnc08|||merge|19606
|cnc15|mnz|3,cswfl|||set switch|19610
||brn|6,cnc08|||merge|19611
|cnc16|mnz|3,cswls|||set switch|19615
||beq|3,stage|18,=stgic|6,cnc08|done if compile time|19616
||zer|3,lstpf|||permit listing|19620
||jsr|6,listr|||list line|19621
||brn|6,cnc08|||merge|19622
||ejc|||||19623
|cnc17|mnz|3,cswer|||set switch|19629
||brn|6,cnc08|||merge|19630
|cnc18|mnz|3,cswex|||set switch|19634
||brn|6,cnc08|||merge|19635
|cnc19|zer|3,cswfl|||clear switch|19639
||brn|6,cnc08|||merge|19640
|cnc20|zer|3,cswls|||clear switch|19644
||brn|6,cnc08|||merge|19645
|cnc21|mnz|3,cswno|||set switch|19649
||brn|6,cnc08|||merge|19650
|cnc22|zer|3,cswpr|||clear switch|19654
||brn|6,cnc08|||merge|19655
|cnc24|zer|3,cswno|||clear switch|19659
||brn|6,cnc08|||merge|19660
|cnc25|mnz|3,cswpr|||set switch|19664
||brn|6,cnc08|||merge|19665
||ejc|||||19666
|cnc27|zer|3,cswdb|||clear switch|19672
||brn|6,cnc08|||merge|19673
|cnc28|bze|3,cswls|6,cnc09||return if -nolist|19677
||jsr|6,scane|||scan integer after -space|19678
||mov|8,wc|18,=num01||1 space in case|19679
||beq|7,xr|18,=t_smc|6,cnc29|jump if no integer|19680
||mov|11,-(xs)|7,xr||stack it|19681
||jsr|6,gtsmi|||check integer|19682
||ppm|6,cnc06|||fail if not integer|19683
||ppm|6,cnc06|||fail if negative or large|19684
||bnz|8,wc|6,cnc29||jump if non zero|19685
||mov|8,wc|18,=num01||else 1 space|19686
|cnc29|add|3,lstlc|8,wc||bump line count|19690
||lct|8,wc|8,wc||convert to loop counter|19691
||blt|3,lstlc|3,lstnp|6,cnc30|jump if fits on page|19692
||jsr|6,prtps|||eject|19693
||jsr|6,listt|||list title|19694
||brn|6,cnc09|||merge|19695
|cnc30|jsr|6,prtnl|||print a blank|19699
||bct|8,wc|6,cnc30||loop|19700
||brn|6,cnc09|||merge|19701
||ejc|||||19702
|cnc31|mov|3,cnr_t|20,=r_stl||ptr to r_stl|19708
||brn|6,cnc33|||merge|19709
|cnc32|mov|3,r_stl|21,=nulls||clear subtitle|19713
||mov|3,cnr_t|20,=r_ttl||ptr to r_ttl|19714
|cnc33|mov|7,xr|21,=nulls||null in case needed|19718
||mnz|3,cnttl|||set flag for next listr call|19719
||mov|8,wb|18,=ccofs||offset to title/subtitle|19720
||mov|8,wa|3,scnil||input image length|19721
||blo|8,wa|8,wb|6,cnc34|jump if no chars left|19722
||sub|8,wa|8,wb||no of chars to extract|19723
||mov|7,xl|3,r_cim||point to image|19724
||jsr|6,sbstr|||get title/subtitle|19725
|cnc34|mov|7,xl|3,cnr_t||point to storage location|19729
||mov|9,(xl)|7,xr||store title/subtitle|19730
||beq|7,xl|20,=r_stl|6,cnc09|return if stitl|19731
||bnz|3,precl|6,cnc09||return if extended listing|19732
||bze|3,prich|6,cnc09||return if regular printer|19733
||mov|7,xl|13,sclen(xr)||get length of title|19734
||mov|8,wa|7,xl||copy it|19735
||bze|7,xl|6,cnc35||jump if null|19736
||add|7,xl|18,=num10||increment|19737
||bhi|7,xl|3,prlen|6,cnc09|use default lstp0 val if too long|19738
||add|8,wa|18,=num04||point just past title|19739
|cnc35|mov|3,lstpo|8,wa||store offset|19743
||brn|6,cnc09|||return|19744
|cnc36|jsr|6,systt|||toggle switch|19750
||brn|6,cnc08|||merge|19751
|cnc37|jsr|6,scane|||scan integer after -case|19758
||zer|8,wc|||get 0 in case none there|19759
||beq|7,xl|18,=t_smc|6,cnc38|skip if no integer|19760
||mov|11,-(xs)|7,xr||stack it|19761
||jsr|6,gtsmi|||check integer|19762
||ppm|6,cnc06|||fail if not integer|19763
||ppm|6,cnc06|||fail if negative or too large|19764
|cnc38|mov|3,kvcas|8,wc||store new case value|19765
||brn|6,cnc09|||merge|19766
|cnc41|mnz|3,scncc|||set flag for scane|19789
||jsr|6,scane|||scan quoted file name|19790
||zer|3,scncc|||clear scane flag|19791
||bne|7,xl|18,=t_con|6,cnc06|if not constant|19792
||bne|9,(xr)|22,=b_scl|6,cnc06|if not string constant|19793
||mov|3,r_ifn|7,xr||save file name|19794
||mov|7,xl|3,r_inc||examine include file name table|19795
||zer|8,wb|||lookup by value|19796
||jsr|6,tfind|||do lookup|19797
||ppm||||never fails|19798
||beq|7,xr|21,=inton|6,cnc09|ignore if already in table|19799
||mnz|8,wb|||set for trim|19800
||mov|7,xr|3,r_ifn||file name|19801
||jsr|6,trimr|||remove trailing blanks|19802
||mov|7,xl|3,r_inc||include file name table|19803
||mnz|8,wb|||lookup by name this time|19804
||jsr|6,tfind|||do lookup|19805
||ppm||||never fails|19806
||mov|13,teval(xl)|21,=inton||make table value integer 1|19807
||icv|3,cnind|||increase nesting level|19808
||mov|8,wa|3,cnind||load new nest level|19809
||bgt|8,wa|18,=ccinm|6,cnc42|fail if excessive nesting|19810
||mov|7,xl|3,r_ifa||array of nested file names|19815
||add|8,wa|18,=vcvlb||compute offset in words|19816
||wtb|8,wa|||convert to bytes|19817
||add|7,xl|8,wa||point to element|19818
||mov|9,(xl)|3,r_sfc||record current file name|19819
||mov|7,xl|8,wa||preserve nesting byte offset|19820
||mti|3,rdnln|||fetch source line number as integer|19821
||jsr|6,icbld|||convert to icblk|19822
||add|7,xl|3,r_ifl||entry in nested line number array|19823
||mov|9,(xl)|7,xr||record in array|19824
||mov|8,wa|3,cswin||max read length|19829
||mov|7,xl|3,r_ifn||include file name|19830
||jsr|6,alocs|||get buffer for complete file name|19831
||jsr|6,sysif|||open include file|19832
||ppm|6,cnc43|||could not open|19833
||zer|8,wb|||do not trim trailing blanks|19838
||jsr|6,trimr|||adjust scblk for actual length|19839
||mov|3,r_sfc|7,xr||save ptr to file name|19840
||mti|3,cmpsn|||current statement as integer|19841
||jsr|6,icbld|||build icblk for stmt number|19842
||mov|7,xl|3,r_sfn||file name table|19843
||mnz|8,wb|||lookup statement number by name|19844
||jsr|6,tfind|||allocate new teblk|19845
||ppm||||always possible to allocate block|19846
||mov|13,teval(xl)|3,r_sfc||record file name as entry value|19847
||zer|3,rdnln|||restart line counter for new file|19851
||beq|3,stage|18,=stgic|6,cnc09|if initial compile|19852
||bne|3,cnind|18,=num01|6,cnc09|if not first execute-time nesting|19853
||mov|3,r_ici|3,r_cim||remember code argument string|19857
||mov|3,cnspt|3,scnpt||save position in string|19858
||mov|3,cnsil|3,scnil||and length of string|19859
||brn|6,cnc09|||all done, merge|19860
|cnc42|erb|1,284|26,excessively nested include files|||19864
|cnc43|mov|3,dnamp|7,xr||release allocated scblk|19868
||erb|1,285|26,include file cannot be opened|||19869
|cnc44|jsr|6,scane|||scan integer after -line|19876
||bne|7,xl|18,=t_con|6,cnc06|jump if no line number|19877
||bne|9,(xr)|22,=b_icl|6,cnc06|jump if not integer|19878
||ldi|13,icval(xr)|||fetch integer line number|19879
||ile|6,cnc06|||error if negative or zero|19880
||beq|3,stage|18,=stgic|6,cnc45|skip if initial compile|19881
||mfi|3,cmpln|||set directly for other compiles|19882
||brn|6,cnc46|||no need to set rdnln|19883
|cnc45|sbi|4,intv1|||adjust number by one|19884
||mfi|3,rdnln|||save line number|19885
|cnc46|mnz|3,scncc|||set flag for scane|19887
||jsr|6,scane|||scan quoted file name|19888
||zer|3,scncc|||clear scane flag|19889
||beq|7,xl|18,=t_smc|6,cnc47|done if no file name|19890
||bne|7,xl|18,=t_con|6,cnc06|error if not constant|19891
||bne|9,(xr)|22,=b_scl|6,cnc06|if not string constant|19892
||jsr|6,newfn|||record new file name|19893
||brn|6,cnc09|||merge|19894
|cnc47|dcv|3,scnpt|||set to rescan the terminator|19898
||brn|6,cnc09|||merge|19899
||enp||||end procedure cncrd|19904
||ejc|||||19905
|dffnc|prc|25,e|1,0||entry point|19987
||bne|9,(xl)|22,=b_efc|6,dffn1|skip if new function not external|19990
||icv|13,efuse(xl)|||else increment its use count|19991
|dffn1|mov|8,wa|7,xr||save vrblk pointer|19995
||mov|7,xr|13,vrfnc(xr)||load old function pointer|19996
||bne|9,(xr)|22,=b_efc|6,dffn2|jump if old function not external|19997
||mov|8,wb|13,efuse(xr)||else get use count|19998
||dcv|8,wb|||decrement|19999
||mov|13,efuse(xr)|8,wb||store decremented value|20000
||bnz|8,wb|6,dffn2||jump if use count still non-zero|20001
||jsr|6,sysul|||else call system unload function|20002
|dffn2|mov|7,xr|8,wa||restore vrblk pointer|20006
||mov|8,wa|7,xl||copy function block ptr|20008
||blt|7,xr|20,=r_yyy|6,dffn3|skip checks if opsyn op definition|20009
||bnz|13,vrlen(xr)|6,dffn3||jump if not system variable|20010
||mov|7,xl|13,vrsvp(xr)||point to svblk|20014
||mov|8,wb|13,svbit(xl)||load bit indicators|20015
||anb|8,wb|4,btfnc||is it a system function|20016
||zrb|8,wb|6,dffn3||redef ok if not|20017
||erb|1,248|26,attempted redefinition of system function|||20018
|dffn3|mov|13,vrfnc(xr)|8,wa||store new function pointer|20022
||mov|7,xl|8,wa||restore function block pointer|20023
||exi||||return to dffnc caller|20024
||enp||||end procedure dffnc|20025
||ejc|||||20026
|dtach|prc|25,e|1,0||entry point|20040
||mov|3,dtcnb|7,xl||store name base (gbcol not called)|20041
||add|7,xl|8,wa||point to name location|20042
||mov|3,dtcnm|7,xl||store it|20043
|dtch1|mov|7,xr|7,xl||copy name pointer|20047
|dtch2|mov|7,xl|9,(xl)||point to next value|20051
||bne|9,(xl)|22,=b_trt|6,dtch6|jump at chain end|20052
||mov|8,wa|13,trtyp(xl)||get trap block type|20053
||beq|8,wa|18,=trtin|6,dtch3|jump if input|20054
||beq|8,wa|18,=trtou|6,dtch3|jump if output|20055
||add|7,xl|19,*trnxt||point to next link|20056
||brn|6,dtch1|||loop|20057
|dtch3|mov|9,(xr)|13,trval(xl)||delete trblk|20061
||mov|8,wa|7,xl||dump xl ...|20062
||mov|8,wb|7,xr||... and xr|20063
||mov|7,xl|13,trtrf(xl)||point to trtrf trap block|20064
||bze|7,xl|6,dtch5||jump if no iochn|20065
||bne|9,(xl)|22,=b_trt|6,dtch5|jump if input, output, terminal|20066
|dtch4|mov|7,xr|7,xl||remember link ptr|20070
||mov|7,xl|13,trtrf(xl)||point to next link|20071
||bze|7,xl|6,dtch5||jump if end of chain|20072
||mov|8,wc|13,ionmb(xl)||get name base|20073
||add|8,wc|13,ionmo(xl)||add offset|20074
||bne|8,wc|3,dtcnm|6,dtch4|loop if no match|20075
||mov|13,trtrf(xr)|13,trtrf(xl)||remove name from chain|20076
||ejc|||||20077
|dtch5|mov|7,xl|8,wa||recover xl ...|20083
||mov|7,xr|8,wb||... and xr|20084
||add|7,xl|19,*trval||point to value field|20085
||brn|6,dtch2|||continue|20086
|dtch6|mov|7,xr|3,dtcnb||possible vrblk ptr|20090
||jsr|6,setvr|||reset vrblk if necessary|20091
||exi||||return|20092
||enp||||end procedure dtach|20093
||ejc|||||20094
|dtype|prc|25,e|1,0||entry point|20102
||beq|9,(xr)|22,=b_pdt|6,dtyp1|jump if prog.defined|20103
||mov|7,xr|9,(xr)||load type word|20104
||lei|7,xr|||get entry point id (block code)|20105
||wtb|7,xr|||convert to byte offset|20106
||mov|7,xr|14,scnmt(xr)||load table entry|20107
||exi||||exit to dtype caller|20108
|dtyp1|mov|7,xr|13,pddfp(xr)||point to dfblk|20112
||mov|7,xr|13,dfnam(xr)||get datatype name from dfblk|20113
||exi||||return to dtype caller|20114
||enp||||end procedure dtype|20115
||ejc|||||20116
|dumpr|prc|25,e|1,0||entry point|20137
||bze|7,xr|6,dmp28||skip dump if argument is zero|20138
||bgt|7,xr|18,=num03|6,dmp29|jump if core dump required|20139
||zer|7,xl|||clear xl|20140
||zer|8,wb|||zero move offset|20141
||mov|3,dmarg|7,xr||save dump argument|20142
||zer|3,dnams|||collect sediment too|20144
||jsr|6,gbcol|||collect garbage|20146
||jsr|6,prtpg|||eject printer|20147
||mov|7,xr|21,=dmhdv||point to heading for variables|20148
||jsr|6,prtst|||print it|20149
||jsr|6,prtnl|||terminate print line|20150
||jsr|6,prtnl|||and print a blank line|20151
||zer|3,dmvch|||set null chain to start|20164
||mov|8,wa|3,hshtb||point to hash table|20165
|dmp00|mov|7,xr|8,wa||copy hash bucket pointer|20169
||ica|8,wa|||bump pointer|20170
||sub|7,xr|19,*vrnxt||set offset to merge|20171
|dmp01|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|20175
||bze|7,xr|6,dmp09||jump if end of this hash chain|20176
||mov|7,xl|7,xr||else copy vrblk pointer|20177
||ejc|||||20178
|dmp02|mov|7,xl|13,vrval(xl)||load value|20184
||beq|3,dmarg|18,=num03|6,dmp2a|skip null value check if dump(3)|20185
||beq|7,xl|21,=nulls|6,dmp01|loop for next vrblk if null value|20186
|dmp2a|beq|9,(xl)|22,=b_trt|6,dmp02|loop back if value is trapped|20187
||mov|8,wc|7,xr||save vrblk pointer|20191
||add|7,xr|19,*vrsof||adjust ptr to be like scblk ptr|20192
||bnz|13,sclen(xr)|6,dmp03||jump if non-system variable|20193
||mov|7,xr|13,vrsvo(xr)||else load ptr to name in svblk|20194
|dmp03|mov|8,wb|7,xr||save pointer to chars|20198
||mov|3,dmpsv|8,wa||save hash bucket pointer|20199
||mov|8,wa|20,=dmvch||point to chain head|20200
|dmp04|mov|3,dmpch|8,wa||save chain pointer|20204
||mov|7,xl|8,wa||copy it|20205
||mov|7,xr|9,(xl)||load pointer to next entry|20206
||bze|7,xr|6,dmp08||jump if end of chain to insert|20207
||add|7,xr|19,*vrsof||else get name ptr for chained vrblk|20208
||bnz|13,sclen(xr)|6,dmp05||jump if not system variable|20209
||mov|7,xr|13,vrsvo(xr)||else point to name in svblk|20210
|dmp05|mov|7,xl|8,wb||point to entering vrblk string|20220
||mov|8,wa|13,sclen(xl)||load its length|20221
||plc|7,xl|||point to chars of entering string|20222
||bhi|8,wa|13,sclen(xr)|6,dmp06|jump if entering length high|20245
||plc|7,xr|||else point to chars of old string|20246
||cmc|6,dmp08|6,dmp07||compare, insert if new is llt old|20247
||brn|6,dmp08|||or if leq (we had shorter length)|20248
|dmp06|mov|8,wa|13,sclen(xr)||load shorter length|20252
||plc|7,xr|||point to chars of old string|20253
||cmc|6,dmp08|6,dmp07||compare, insert if new one low|20254
||ejc|||||20255
|dmp07|mov|7,xl|3,dmpch||copy chain pointer|20261
||mov|8,wa|9,(xl)||move to next entry on chain|20263
||brn|6,dmp04|||loop back|20264
|dmp08|mov|7,xl|3,dmpch||copy chain pointer|20268
||mov|8,wa|3,dmpsv||restore hash bucket pointer|20269
||mov|7,xr|8,wc||restore vrblk pointer|20270
||mov|13,vrget(xr)|9,(xl)||link vrblk to rest of chain|20271
||mov|9,(xl)|7,xr||link vrblk into current chain loc|20272
||brn|6,dmp01|||loop back for next vrblk|20273
|dmp09|bne|8,wa|3,hshte|6,dmp00|loop back if more buckets to go|20277
|dmp10|mov|7,xr|3,dmvch||load pointer to next entry on chain|20281
||bze|7,xr|6,dmp11||jump if end of chain|20282
||mov|3,dmvch|9,(xr)||else update chain ptr to next entry|20283
||jsr|6,setvr|||restore vrget field|20284
||mov|7,xl|7,xr||copy vrblk pointer (name base)|20285
||mov|8,wa|19,*vrval||set offset for vrblk name|20286
||jsr|6,prtnv|||print name = value|20287
||brn|6,dmp10|||loop back till all printed|20288
|dmp11|jsr|6,prtnl|||print blank line|20292
||jsr|6,prtnl|||and another|20293
||mov|7,xr|21,=dmhdk||point to keyword heading|20294
||jsr|6,prtst|||print heading|20295
||jsr|6,prtnl|||end line|20296
||jsr|6,prtnl|||print one blank line|20297
||mov|7,xl|21,=vdmkw||point to list of keyword svblk ptrs|20298
||ejc|||||20299
|dmp12|mov|7,xr|10,(xl)+||load next svblk ptr from table|20305
||bze|7,xr|6,dmp13||jump if end of list|20306
||beq|7,xr|18,=num01|6,dmp12|&compare ignored if not implemented|20308
||mov|8,wa|18,=ch_am||load ampersand|20310
||jsr|6,prtch|||print ampersand|20311
||jsr|6,prtst|||print keyword name|20312
||mov|8,wa|13,svlen(xr)||load name length from svblk|20313
||ctb|8,wa|2,svchs||get length of name|20314
||add|7,xr|8,wa||point to svknm field|20315
||mov|3,dmpkn|9,(xr)||store in dummy kvblk|20316
||mov|7,xr|21,=tmbeb||point to blank-equal-blank|20317
||jsr|6,prtst|||print it|20318
||mov|3,dmpsv|7,xl||save table pointer|20319
||mov|7,xl|20,=dmpkb||point to dummy kvblk|20320
||mov|9,(xl)|22,=b_kvt||build type word|20321
||mov|13,kvvar(xl)|21,=trbkv||build ptr to dummy trace block|20322
||mov|8,wa|19,*kvvar||set zero offset|20323
||jsr|6,acess|||get keyword value|20324
||ppm||||failure is impossible|20325
||jsr|6,prtvl|||print keyword value|20326
||jsr|6,prtnl|||terminate print line|20327
||mov|7,xl|3,dmpsv||restore table pointer|20328
||brn|6,dmp12|||loop back till all printed|20329
|dmp13|beq|3,dmarg|18,=num01|6,dmp27|exit if partial dump complete|20333
||mov|7,xr|3,dnamb||else point to first dynamic block|20334
|dmp14|beq|7,xr|3,dnamp|6,dmp27|jump if end of used region|20338
||mov|8,wa|9,(xr)||else load first word of block|20339
||beq|8,wa|22,=b_vct|6,dmp16|jump if vector|20340
||beq|8,wa|22,=b_art|6,dmp17|jump if array|20341
||beq|8,wa|22,=b_pdt|6,dmp18|jump if program defined|20342
||beq|8,wa|22,=b_tbt|6,dmp19|jump if table|20343
|dmp15|jsr|6,blkln|||get length of block|20351
||add|7,xr|8,wa||point past this block|20352
||brn|6,dmp14|||loop back for next block|20353
||ejc|||||20354
|dmp16|mov|8,wb|19,*vcvls||set offset to first value|20360
||brn|6,dmp19|||jump to merge|20361
|dmp17|mov|8,wb|13,arofs(xr)||set offset to arpro field|20365
||ica|8,wb|||bump to get offset to values|20366
||brn|6,dmp19|||jump to merge|20367
|dmp18|mov|8,wb|19,*pdfld||point to values, merge|20371
|dmp19|bze|13,idval(xr)|6,dmp15||ignore block if zero id value|20375
||jsr|6,blkln|||else get block length|20376
||mov|7,xl|7,xr||copy block pointer|20377
||mov|3,dmpsv|8,wa||save length|20378
||mov|8,wa|8,wb||copy offset to first value|20379
||jsr|6,prtnl|||print blank line|20380
||mov|3,dmpsa|8,wa||preserve offset|20381
||jsr|6,prtvl|||print block value (for title)|20382
||mov|8,wa|3,dmpsa||recover offset|20383
||jsr|6,prtnl|||end print line|20384
||beq|9,(xr)|22,=b_tbt|6,dmp22|jump if table|20385
||dca|8,wa|||point before first word|20386
|dmp20|mov|7,xr|7,xl||copy block pointer|20390
||ica|8,wa|||bump offset|20391
||add|7,xr|8,wa||point to next value|20392
||beq|8,wa|3,dmpsv|6,dmp14|exit if end (xr past block)|20393
||sub|7,xr|19,*vrval||subtract offset to merge into loop|20394
|dmp21|mov|7,xr|13,vrval(xr)||load next value|20398
||beq|3,dmarg|18,=num03|6,dmp2b|skip null value check if dump(3)|20399
||beq|7,xr|21,=nulls|6,dmp20|loop back if null value|20400
|dmp2b|beq|9,(xr)|22,=b_trt|6,dmp21|loop back if trapped|20401
||jsr|6,prtnv|||else print name = value|20402
||brn|6,dmp20|||loop back for next field|20403
||ejc|||||20404
|dmp22|mov|8,wc|19,*tbbuk||set offset to first bucket|20410
||mov|8,wa|19,*teval||set name offset for all teblks|20411
|dmp23|mov|11,-(xs)|7,xl||save tbblk pointer|20415
||add|7,xl|8,wc||point to next bucket header|20416
||ica|8,wc|||bump bucket offset|20417
||sub|7,xl|19,*tenxt||subtract offset to merge into loop|20418
|dmp24|mov|7,xl|13,tenxt(xl)||point to next teblk|20422
||beq|7,xl|9,(xs)|6,dmp26|jump if end of chain|20423
||mov|7,xr|7,xl||else copy teblk pointer|20424
|dmp25|mov|7,xr|13,teval(xr)||load next value|20428
||beq|7,xr|21,=nulls|6,dmp24|ignore if null value|20429
||beq|9,(xr)|22,=b_trt|6,dmp25|loop back if trapped|20430
||mov|3,dmpsv|8,wc||else save offset pointer|20431
||jsr|6,prtnv|||print name = value|20432
||mov|8,wc|3,dmpsv||reload offset|20433
||brn|6,dmp24|||loop back for next teblk|20434
|dmp26|mov|7,xl|10,(xs)+||restore tbblk pointer|20438
||bne|8,wc|13,tblen(xl)|6,dmp23|loop back if more buckets to go|20439
||mov|7,xr|7,xl||else copy table pointer|20440
||add|7,xr|8,wc||point to following block|20441
||brn|6,dmp14|||loop back to process next block|20442
|dmp27|jsr|6,prtpg|||eject printer|20446
|dmp28|exi||||return to dump caller|20450
|dmp29|jsr|6,sysdm|||call it|20454
||brn|6,dmp28|||return|20455
||enp||||end procedure dumpr|20491
||ejc|||||20492
|ermsg|prc|25,e|1,0||entry point|20500
||mov|8,wa|3,kvert||load error code|20501
||mov|7,xr|21,=ermms||point to error message /error/|20502
||jsr|6,prtst|||print it|20503
||jsr|6,ertex|||get error message text|20504
||add|8,wa|18,=thsnd||bump error code for print|20505
||mti|8,wa|||fail code in int acc|20506
||mov|8,wb|3,profs||save current buffer position|20507
||jsr|6,prtin|||print code (now have error1xxx)|20508
||mov|7,xl|3,prbuf||point to print buffer|20509
||psc|7,xl|8,wb||point to the 1|20510
||mov|8,wa|18,=ch_bl||load a blank|20511
||sch|8,wa|9,(xl)||store blank over 1 (error xxx)|20512
||csc|7,xl|||complete store characters|20513
||zer|7,xl|||clear garbage pointer in xl|20514
||mov|8,wa|7,xr||keep error text|20515
||mov|7,xr|21,=ermns||point to / -- /|20516
||jsr|6,prtst|||print it|20517
||mov|7,xr|8,wa||get error text again|20518
||jsr|6,prtst|||print error message text|20519
||jsr|6,prtis|||print line|20520
||jsr|6,prtis|||print blank line|20521
||exi||||return to ermsg caller|20522
||enp||||end procedure ermsg|20523
||ejc|||||20524
|ertex|prc|25,e|1,0||entry point|20534
||mov|3,ertwa|8,wa||save wa|20535
||mov|3,ertwb|8,wb||save wb|20536
||jsr|6,sysem|||get failure message text|20537
||mov|7,xl|7,xr||copy pointer to it|20538
||mov|8,wa|13,sclen(xr)||get length of string|20539
||bze|8,wa|6,ert02||jump if null|20540
||zer|8,wb|||offset of zero|20541
||jsr|6,sbstr|||copy into dynamic store|20542
||mov|3,r_etx|7,xr||store for relocation|20543
|ert01|mov|8,wb|3,ertwb||restore wb|20547
||mov|8,wa|3,ertwa||restore wa|20548
||exi||||return to caller|20549
|ert02|mov|7,xr|3,r_etx||get errtext|20553
||brn|6,ert01|||return|20554
||enp|||||20555
||ejc|||||20556
|evali|prc|25,r|1,4||entry point (recursive)|20578
||jsr|6,evalp|||evaluate expression|20579
||ppm|6,evli1|||jump on failure|20580
||mov|11,-(xs)|7,xl||stack result for gtsmi|20581
||mov|7,xl|13,pthen(xr)||load successor pointer|20582
||mov|3,evlio|7,xr||save original node pointer|20583
||mov|3,evlif|8,wc||zero if simple argument|20584
||jsr|6,gtsmi|||convert arg to small integer|20585
||ppm|6,evli2|||jump if not integer|20586
||ppm|6,evli3|||jump if out of range|20587
||mov|3,evliv|7,xr||store result in special dummy node|20588
||mov|7,xr|20,=evlin||point to dummy node with result|20589
||mov|9,(xr)|22,=p_len||dummy pattern block pcode|20590
||mov|13,pthen(xr)|7,xl||store successor pointer|20591
||exi|1,4|||take successful exit|20592
|evli1|exi|1,3|||take failure return|20596
|evli2|exi|1,1|||take non-integer error exit|20600
|evli3|exi|1,2|||take out-of-range error exit|20604
||enp||||end procedure evali|20605
||ejc|||||20606
|evalp|prc|25,r|1,1||entry point (recursive)|20637
||mov|7,xl|13,parm1(xr)||load expression pointer|20638
||beq|9,(xl)|22,=b_exl|6,evlp1|jump if exblk case|20639
||mov|7,xl|13,sevar(xl)||load vrblk pointer|20646
||mov|7,xl|13,vrval(xl)||load value of vrblk|20647
||mov|8,wa|9,(xl)||load first word of value|20648
||bhi|8,wa|22,=b_t__|6,evlp3|jump if not seblk, trblk or exblk|20649
|evlp1|chk||||check for stack space|20653
||mov|11,-(xs)|7,xr||stack node pointer|20654
||mov|11,-(xs)|8,wb||stack cursor|20655
||mov|11,-(xs)|3,r_pms||stack subject string pointer|20656
||mov|11,-(xs)|3,pmssl||stack subject string length|20657
||mov|11,-(xs)|3,pmdfl||stack dot flag|20658
||mov|11,-(xs)|3,pmhbs||stack history stack base pointer|20659
||mov|7,xr|13,parm1(xr)||load expression pointer|20660
||ejc|||||20661
|evlp2|zer|8,wb|||set flag for by value|20667
||jsr|6,evalx|||evaluate expression|20668
||ppm|6,evlp4|||jump on failure|20669
||mov|8,wa|9,(xr)||else load first word of value|20670
||blo|8,wa|22,=b_e__|6,evlp2|loop back to reevaluate expression|20671
||mov|7,xl|7,xr||copy result pointer|20675
||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|20676
||mov|3,pmdfl|10,(xs)+||restore dot flag|20677
||mov|3,pmssl|10,(xs)+||restore subject string length|20678
||mov|3,r_pms|10,(xs)+||restore subject string pointer|20679
||mov|8,wb|10,(xs)+||restore cursor|20680
||mov|7,xr|10,(xs)+||restore node pointer|20681
||mov|8,wc|7,xr||non-zero for simple vrblk|20682
||exi||||return to evalp caller|20683
|evlp3|zer|8,wc|||simple vrblk, no side effects|20687
||exi||||return to evalp caller|20688
|evlp4|mov|3,pmhbs|10,(xs)+||restore history stack base pointer|20692
||mov|3,pmdfl|10,(xs)+||restore dot flag|20693
||mov|3,pmssl|10,(xs)+||restore subject string length|20694
||mov|3,r_pms|10,(xs)+||restore subject string pointer|20695
||add|7,xs|19,*num02||remove node ptr, cursor|20696
||exi|1,1|||take failure exit|20697
||enp||||end procedure evalp|20698
||ejc|||||20699
|evals|prc|25,r|1,3||entry point (recursive)|20721
||jsr|6,evalp|||evaluate expression|20722
||ppm|6,evls1|||jump if evaluation fails|20723
||mov|11,-(xs)|13,pthen(xr)||save successor pointer|20724
||mov|11,-(xs)|8,wb||save cursor|20725
||mov|11,-(xs)|7,xl||stack result ptr for patst|20726
||zer|8,wb|||dummy pcode for one char string|20727
||zer|8,wc|||dummy pcode for expression arg|20728
||mov|7,xl|22,=p_brk||appropriate pcode for our use|20729
||jsr|6,patst|||call routine to build node|20730
||ppm|6,evls2|||jump if not string|20731
||mov|8,wb|10,(xs)+||restore cursor|20732
||mov|13,pthen(xr)|10,(xs)+||store successor pointer|20733
||exi|1,3|||take success return|20734
|evls1|exi|1,2|||take failure return|20738
|evls2|add|7,xs|19,*num02||pop successor and cursor|20742
||exi|1,1|||take non-string error exit|20743
||enp||||end procedure evals|20744
||ejc|||||20745
|evalx|prc|25,r|1,1||entry point, recursive|20761
||beq|9,(xr)|22,=b_exl|6,evlx2|jump if exblk case|20762
||mov|7,xl|13,sevar(xr)||load vrblk pointer (name base)|20766
||mov|8,wa|19,*vrval||set name offset|20767
||bnz|8,wb|6,evlx1||jump if called by name|20768
||jsr|6,acess|||call routine to access value|20769
||ppm|6,evlx9|||jump if failure on access|20770
|evlx1|exi||||return to evalx caller|20774
||ejc|||||20775
|evlx2|scp|8,wc|||get code pointer|20794
||mov|8,wa|3,r_cod||load code block pointer|20795
||sub|8,wc|8,wa||get code pointer as offset|20796
||mov|11,-(xs)|8,wa||stack old code block pointer|20797
||mov|11,-(xs)|8,wc||stack relative code offset|20798
||mov|11,-(xs)|3,flptr||stack old failure pointer|20799
||mov|11,-(xs)|8,wb||stack name/value indicator|20800
||mov|11,-(xs)|19,*exflc||stack new fail offset|20801
||mov|3,gtcef|3,flptr||keep in case of error|20802
||mov|3,r_gtc|3,r_cod||keep code block pointer similarly|20803
||mov|3,flptr|7,xs||set new failure pointer|20804
||mov|3,r_cod|7,xr||set new code block pointer|20805
||mov|13,exstm(xr)|3,kvstn||remember stmnt number|20806
||add|7,xr|19,*excod||point to first code word|20807
||lcp|7,xr|||set code pointer|20808
||bne|3,stage|18,=stgxt|6,evlx0|jump if not execution time|20809
||mov|3,stage|18,=stgee||evaluating expression|20810
|evlx0|zer|7,xl|||clear garbage xl|20814
||lcw|7,xr|||load first code word|20815
||bri|9,(xr)|||execute it|20816
||ejc|||||20817
|evlx3|mov|7,xr|10,(xs)+||load value|20823
||bze|13,num01(xs)|6,evlx5||jump if called by value|20824
||erb|1,249|26,expression evaluated by name returned value|||20825
|evlx4|mov|8,wa|10,(xs)+||load name offset|20829
||mov|7,xl|10,(xs)+||load name base|20830
||bnz|13,num01(xs)|6,evlx5||jump if called by name|20831
||jsr|6,acess|||else access value first|20832
||ppm|6,evlx6|||jump if failure during access|20833
|evlx5|zer|8,wb|||note successful|20837
||brn|6,evlx7|||merge|20838
|evlx6|mnz|8,wb|||note unsuccessful|20842
|evlx7|bne|3,stage|18,=stgee|6,evlx8|skip if was not previously xt|20846
||mov|3,stage|18,=stgxt||execute time|20847
|evlx8|add|7,xs|19,*num02||pop name/value indicator, *exfal|20851
||mov|3,flptr|10,(xs)+||restore old failure pointer|20852
||mov|8,wc|10,(xs)+||load code offset|20853
||add|8,wc|9,(xs)||make code pointer absolute|20854
||mov|3,r_cod|10,(xs)+||restore old code block pointer|20855
||lcp|8,wc|||restore old code pointer|20856
||bze|8,wb|6,evlx1||jump for successful return|20857
|evlx9|exi|1,1|||take failure exit|20861
||enp||||end of procedure evalx|20862
||ejc|||||20863
|exbld|prc|25,e|1,0||entry point|20876
||mov|8,wa|7,xl||copy offset to start of code|20877
||sub|8,wa|19,*excod||calc reduction in offset in exblk|20878
||mov|11,-(xs)|8,wa||stack for later|20879
||mov|8,wa|3,cwcof||load final offset|20880
||sub|8,wa|7,xl||compute length of code|20881
||add|8,wa|19,*exsi_||add space for standard fields|20882
||jsr|6,alloc|||allocate space for exblk|20883
||mov|11,-(xs)|7,xr||save pointer to exblk|20884
||mov|13,extyp(xr)|22,=b_exl||store type word|20885
||zer|13,exstm(xr)|||zeroise stmnt number field|20886
||mov|13,exsln(xr)|3,cmpln||set line number field|20888
||mov|13,exlen(xr)|8,wa||store length|20890
||mov|13,exflc(xr)|21,=ofex_||store failure word|20891
||add|7,xr|19,*exsi_||set xr for mvw|20892
||mov|3,cwcof|7,xl||reset offset to start of code|20893
||add|7,xl|3,r_ccb||point to start of code|20894
||sub|8,wa|19,*exsi_||length of code to move|20895
||mov|11,-(xs)|8,wa||stack length of code|20896
||mvw||||move code to exblk|20897
||mov|8,wa|10,(xs)+||get length of code|20898
||btw|8,wa|||convert byte count to word count|20899
||lct|8,wa|8,wa||prepare counter for loop|20900
||mov|7,xl|9,(xs)||copy exblk ptr, dont unstack|20901
||add|7,xl|19,*excod||point to code itself|20902
||mov|8,wb|13,num01(xs)||get reduction in offset|20903
|exbl1|mov|7,xr|10,(xl)+||get next code word|20910
||beq|7,xr|21,=osla_|6,exbl3|jump if selection found|20911
||beq|7,xr|21,=onta_|6,exbl3|jump if negation found|20912
||bct|8,wa|6,exbl1||loop to end of code|20913
|exbl2|mov|7,xr|10,(xs)+||pop exblk ptr into xr|20917
||mov|7,xl|10,(xs)+||pop reduction constant|20918
||exi||||return to caller|20919
||ejc|||||20920
|exbl3|sub|10,(xl)+|8,wb||adjust offset|20929
||bct|8,wa|6,exbl4||decrement count|20930
|exbl4|bct|8,wa|6,exbl5||decrement count|20932
|exbl5|mov|7,xr|10,(xl)+||get next code word|20936
||beq|7,xr|21,=osla_|6,exbl3|jump if offset found|20937
||beq|7,xr|21,=oslb_|6,exbl3|jump if offset found|20938
||beq|7,xr|21,=oslc_|6,exbl3|jump if offset found|20939
||beq|7,xr|21,=onta_|6,exbl3|jump if offset found|20940
||bct|8,wa|6,exbl5||loop|20941
||brn|6,exbl2|||merge to return|20942
||enp||||end procedure exbld|20943
||ejc|||||20944
||ejc|||||20997
|expan|prc|25,e|1,0||entry point|21003
||zer|11,-(xs)|||set top of stack indicator|21004
||zer|8,wa|||set initial state to zero|21005
||zer|8,wc|||zero counter value|21006
|exp01|jsr|6,scane|||scan next element|21010
||add|7,xl|8,wa||add state to syntax code|21011
||bsw|7,xl|2,t_nes||switch on element type/state|21012
||iff|2,t_uo0|6,exp27||unop, s=0|21049
||iff|2,t_uo1|6,exp27||unop, s=1|21049
||iff|2,t_uo2|6,exp04||unop, s=2|21049
||iff|2,t_lp0|6,exp06||left paren, s=0|21049
||iff|2,t_lp1|6,exp06||left paren, s=1|21049
||iff|2,t_lp2|6,exp04||left paren, s=2|21049
||iff|2,t_lb0|6,exp08||left brkt, s=0|21049
||iff|2,t_lb1|6,exp08||left brkt, s=1|21049
||iff|2,t_lb2|6,exp09||left brkt, s=2|21049
||iff|2,t_cm0|6,exp02||comma, s=0|21049
||iff|2,t_cm1|6,exp05||comma, s=1|21049
||iff|2,t_cm2|6,exp11||comma, s=2|21049
||iff|2,t_fn0|6,exp10||function, s=0|21049
||iff|2,t_fn1|6,exp10||function, s=1|21049
||iff|2,t_fn2|6,exp04||function, s=2|21049
||iff|2,t_va0|6,exp03||variable, s=0|21049
||iff|2,t_va1|6,exp03||variable, state one|21049
||iff|2,t_va2|6,exp04||variable, s=2|21049
||iff|2,t_co0|6,exp03||constant, s=0|21049
||iff|2,t_co1|6,exp03||constant, s=1|21049
||iff|2,t_co2|6,exp04||constant, s=2|21049
||iff|2,t_bo0|6,exp05||binop, s=0|21049
||iff|2,t_bo1|6,exp05||binop, s=1|21049
||iff|2,t_bo2|6,exp26||binop, s=2|21049
||iff|2,t_rp0|6,exp02||right paren, s=0|21049
||iff|2,t_rp1|6,exp05||right paren, s=1|21049
||iff|2,t_rp2|6,exp12||right paren, s=2|21049
||iff|2,t_rb0|6,exp02||right brkt, s=0|21049
||iff|2,t_rb1|6,exp05||right brkt, s=1|21049
||iff|2,t_rb2|6,exp18||right brkt, s=2|21049
||iff|2,t_cl0|6,exp02||colon, s=0|21049
||iff|2,t_cl1|6,exp05||colon, s=1|21049
||iff|2,t_cl2|6,exp19||colon, s=2|21049
||iff|2,t_sm0|6,exp02||semicolon, s=0|21049
||iff|2,t_sm1|6,exp05||semicolon, s=1|21049
||iff|2,t_sm2|6,exp19||semicolon, s=2|21049
||esw||||end switch on element type/state|21049
||ejc|||||21050
|exp02|mnz|3,scnrs|||set to rescan element|21059
||mov|7,xr|21,=nulls||point to null, merge|21060
|exp03|mov|11,-(xs)|7,xr||stack pointer to operand|21066
||mov|8,wa|18,=num02||set state 2|21067
||brn|6,exp01|||jump for next element|21068
|exp04|mnz|3,scnrs|||set to rescan element|21075
||mov|7,xr|21,=opdvc||point to concat operator dv|21076
||bze|8,wb|6,exp4a||ok if at top level|21077
||mov|7,xr|21,=opdvp||else point to unmistakable concat.|21078
|exp4a|bnz|3,scnbl|6,exp26||merge bop if blanks, else error|21082
||erb|1,220|26,syntax error: missing operator|||21084
|exp05|erb|1,221|26,syntax error: missing operand|||21092
|exp06|mov|7,xl|18,=num04||set new level indicator|21096
||zer|7,xr|||set zero value for cmopn|21097
||ejc|||||21098
|exp07|mov|11,-(xs)|7,xr||stack cmopn value|21104
||mov|11,-(xs)|8,wc||stack old counter|21105
||mov|11,-(xs)|8,wb||stack old level indicator|21106
||chk||||check for stack overflow|21107
||zer|8,wa|||set new state to zero|21108
||mov|8,wb|7,xl||set new level indicator|21109
||mov|8,wc|18,=num01||initialize new counter|21110
||brn|6,exp01|||jump to scan next element|21111
|exp08|erb|1,222|26,syntax error: invalid use of left bracket|||21117
|exp09|mov|7,xr|10,(xs)+||load array ptr for cmopn|21123
||mov|7,xl|18,=num03||set new level indicator|21124
||brn|6,exp07|||jump to stack old and start new|21125
|exp10|mov|7,xl|18,=num05||set new lev indic (xr=vrblk=cmopn)|21131
||brn|6,exp07|||jump to stack old and start new|21132
|exp11|icv|8,wc|||increment counter|21138
||jsr|6,expdm|||dump operators at this level|21139
||zer|11,-(xs)|||set new level for parameter|21140
||zer|8,wa|||set new state|21141
||bgt|8,wb|18,=num02|6,exp01|loop back unless outer level|21142
||erb|1,223|26,syntax error: invalid use of comma|||21143
||ejc|||||21144
|exp12|beq|8,wb|18,=num01|6,exp20|end of normal goto|21153
||beq|8,wb|18,=num05|6,exp13|end of function arguments|21154
||beq|8,wb|18,=num04|6,exp14|end of grouping / selection|21155
||erb|1,224|26,syntax error: unbalanced right parenthesis|||21156
|exp13|mov|7,xl|18,=c_fnc||set cmtyp value for function|21160
||brn|6,exp15|||jump to build cmblk|21161
|exp14|beq|8,wc|18,=num01|6,exp17|jump if end of grouping|21165
||mov|7,xl|18,=c_sel||else set cmtyp for selection|21166
|exp15|jsr|6,expdm|||dump operators at this level|21171
||mov|8,wa|8,wc||copy count|21172
||add|8,wa|18,=cmvls||add for standard fields at start|21173
||wtb|8,wa|||convert length to bytes|21174
||jsr|6,alloc|||allocate space for cmblk|21175
||mov|9,(xr)|22,=b_cmt||store type code for cmblk|21176
||mov|13,cmtyp(xr)|7,xl||store cmblk node type indicator|21177
||mov|13,cmlen(xr)|8,wa||store length|21178
||add|7,xr|8,wa||point past end of block|21179
||lct|8,wc|8,wc||set loop counter|21180
|exp16|mov|11,-(xr)|10,(xs)+||move one operand ptr from stack|21184
||mov|8,wb|10,(xs)+||pop to old level indicator|21185
||bct|8,wc|6,exp16||loop till all moved|21186
||ejc|||||21187
||sub|7,xr|19,*cmvls||point back to start of block|21193
||mov|8,wc|10,(xs)+||restore old counter|21194
||mov|13,cmopn(xr)|9,(xs)||store operand ptr in cmblk|21195
||mov|9,(xs)|7,xr||stack cmblk pointer|21196
||mov|8,wa|18,=num02||set new state|21197
||brn|6,exp01|||back for next element|21198
|exp17|jsr|6,expdm|||dump operators at this level|21202
||mov|7,xr|10,(xs)+||restore xr|21203
||mov|8,wb|10,(xs)+||restore outer level|21204
||mov|8,wc|10,(xs)+||restore outer count|21205
||mov|9,(xs)|7,xr||store opnd over unused cmopn val|21206
||mov|8,wa|18,=num02||set new state|21207
||brn|6,exp01|||back for next ele8ent|21208
|exp18|mov|7,xl|18,=c_arr||set cmtyp for array reference|21215
||beq|8,wb|18,=num03|6,exp15|jump to build cmblk if end arrayref|21216
||beq|8,wb|18,=num02|6,exp20|jump if end of direct goto|21217
||erb|1,225|26,syntax error: unbalanced right bracket|||21218
||ejc|||||21219
|exp19|mnz|3,scnrs|||rescan terminator|21227
||mov|7,xl|8,wb||copy level indicator|21228
||bsw|7,xl|1,6||switch on level indicator|21229
||iff|1,0|6,exp20||normal outer level|21236
||iff|1,1|6,exp22||fail if normal goto|21236
||iff|1,2|6,exp23||fail if direct goto|21236
||iff|1,3|6,exp24||fail array brackets|21236
||iff|1,4|6,exp21||fail if in grouping|21236
||iff|1,5|6,exp21||fail function args|21236
||esw||||end switch on level|21236
|exp20|jsr|6,expdm|||dump remaining operators|21240
||mov|7,xr|10,(xs)+||load tree pointer|21241
||ica|7,xs|||pop off bottom of stack marker|21242
||exi||||return to expan caller|21243
|exp21|erb|1,226|26,syntax error: missing right paren|||21247
|exp22|erb|1,227|26,syntax error: right paren missing from goto|||21251
|exp23|erb|1,228|26,syntax error: right bracket missing from goto|||21255
|exp24|erb|1,229|26,syntax error: missing right array bracket|||21259
||ejc|||||21260
|exp25|mov|3,expsv|7,xr|||21266
||jsr|6,expop|||pop one operator|21267
||mov|7,xr|3,expsv||restore op dv pointer and merge|21268
|exp26|mov|7,xl|13,num01(xs)||load operator dvptr from stack|21276
||ble|7,xl|18,=num05|6,exp27|jump if bottom of stack level|21277
||blt|13,dvrpr(xr)|13,dvlpr(xl)|6,exp25|else pop if new prec is lo|21278
|exp27|mov|11,-(xs)|7,xr||stack operator dvptr on stack|21287
||chk||||check for stack overflow|21288
||mov|8,wa|18,=num01||set new state|21289
||bne|7,xr|21,=opdvs|6,exp01|back for next element unless =|21290
||zer|8,wa|||set state zero|21297
||brn|6,exp01|||jump for next element|21298
||enp||||end procedure expan|21299
||ejc|||||21300
|expap|prc|25,e|1,1||entry point|21319
||mov|11,-(xs)|7,xl||save xl|21320
||bne|9,(xr)|22,=b_cmt|6,expp2|no match if not complex|21321
||mov|8,wa|13,cmtyp(xr)||else load type code|21322
||beq|8,wa|18,=c_cnc|6,expp1|concatenation is a match|21323
||beq|8,wa|18,=c_pmt|6,expp1|binary question mark is a match|21324
||bne|8,wa|18,=c_alt|6,expp2|else not match unless alternation|21325
||mov|7,xl|13,cmlop(xr)||load left operand pointer|21329
||bne|9,(xl)|22,=b_cmt|6,expp2|not match if left opnd not complex|21330
||bne|13,cmtyp(xl)|18,=c_cnc|6,expp2|not match if left op not conc|21331
||mov|13,cmlop(xr)|13,cmrop(xl)||xr points to (b / c)|21332
||mov|13,cmrop(xl)|7,xr||set xl opnds to a, (b / c)|21333
||mov|7,xr|7,xl||point to this altered node|21334
|expp1|mov|7,xl|10,(xs)+||restore entry xl|21338
||exi||||give pattern match return|21339
|expp2|mov|7,xl|10,(xs)+||restore entry xl|21343
||exi|1,1|||give non-match return|21344
||enp||||end procedure expap|21345
||ejc|||||21346
|expdm|prc|25,n|1,0||entry point|21358
||mov|3,r_exs|7,xl||save xl value|21359
|exdm1|ble|13,num01(xs)|18,=num05|6,exdm2|jump if stack bottom (saved level|21363
||jsr|6,expop|||else pop one operator|21364
||brn|6,exdm1|||and loop back|21365
|exdm2|mov|7,xl|3,r_exs||restore xl|21369
||zer|3,r_exs|||release save location|21370
||exi||||return to expdm caller|21371
||enp||||end procedure expdm|21372
||ejc|||||21373
|expop|prc|25,n|1,0||entry point|21388
||mov|7,xr|13,num01(xs)||load operator dv pointer|21389
||beq|13,dvlpr(xr)|18,=lluno|6,expo2|jump if unary|21390
||mov|8,wa|19,*cmbs_||set size of binary operator cmblk|21394
||jsr|6,alloc|||allocate space for cmblk|21395
||mov|13,cmrop(xr)|10,(xs)+||pop and store right operand ptr|21396
||mov|7,xl|10,(xs)+||pop and load operator dv ptr|21397
||mov|13,cmlop(xr)|9,(xs)||store left operand pointer|21398
|expo1|mov|9,(xr)|22,=b_cmt||store type code for cmblk|21402
||mov|13,cmtyp(xr)|13,dvtyp(xl)||store cmblk node type code|21403
||mov|13,cmopn(xr)|7,xl||store dvptr (=ptr to dac o_xxx)|21404
||mov|13,cmlen(xr)|8,wa||store cmblk length|21405
||mov|9,(xs)|7,xr||store resulting node ptr on stack|21406
||exi||||return to expop caller|21407
|expo2|mov|8,wa|19,*cmus_||set size of unary operator cmblk|21411
||jsr|6,alloc|||allocate space for cmblk|21412
||mov|13,cmrop(xr)|10,(xs)+||pop and store operand pointer|21413
||mov|7,xl|9,(xs)||load operator dv pointer|21414
||brn|6,expo1|||merge back to exit|21415
||enp||||end procedure expop|21416
||ejc|||||21417
|filnm|prc|25,e|1,0||entry point|21442
||mov|11,-(xs)|8,wb||preserve wb|21443
||bze|8,wc|6,filn3||return nulls if stno is zero|21444
||mov|7,xl|3,r_sfn||file name table|21445
||bze|7,xl|6,filn3||if no table|21446
||mov|8,wb|13,tbbuk(xl)||get bucket entry|21447
||beq|8,wb|3,r_sfn|6,filn3|jump if no teblks on chain|21448
||mov|11,-(xs)|7,xr||preserve xr|21449
||mov|7,xr|8,wb||previous block pointer|21450
||mov|11,-(xs)|8,wc||preserve stmt number|21451
|filn1|mov|7,xl|7,xr||next element to examine|21455
||mov|7,xr|13,tesub(xl)||load subscript value (an icblk)|21456
||ldi|13,icval(xr)|||load the statement number|21457
||mfi|8,wc|||convert to address constant|21458
||blt|9,(xs)|8,wc|6,filn2|compare arg with teblk stmt number|21459
||mov|8,wb|7,xl||save previous entry pointer|21463
||mov|7,xr|13,tenxt(xl)||point to next teblk on chain|21464
||bne|7,xr|3,r_sfn|6,filn1|jump if there is one|21465
|filn2|mov|7,xl|8,wb||previous teblk|21469
||mov|7,xl|13,teval(xl)||get ptr to file name scblk|21470
||mov|8,wc|10,(xs)+||restore stmt number|21471
||mov|7,xr|10,(xs)+||restore xr|21472
||mov|8,wb|10,(xs)+||restore wb|21473
||exi|||||21474
|filn3|mov|8,wb|10,(xs)+||restore wb|21478
||mov|7,xl|21,=nulls||return null string|21479
||exi|||||21480
||enp|||||21481
||ejc|||||21482
|flstg|prc|25,e|1,0||entry point|21499
||bze|3,kvcas|6,fst99||skip if &case is 0|21500
||mov|11,-(xs)|7,xl||save xl across call|21501
||mov|11,-(xs)|7,xr||save original scblk ptr|21502
||jsr|6,alocs|||allocate new string block|21503
||mov|7,xl|9,(xs)||point to original scblk|21504
||mov|11,-(xs)|7,xr||save pointer to new scblk|21505
||plc|7,xl|||point to original chars|21506
||psc|7,xr|||point to new chars|21507
||zer|11,-(xs)|||init did fold flag|21508
||lct|8,wc|8,wc||load loop counter|21509
|fst01|lch|8,wa|10,(xl)+||load character|21510
||blt|8,wa|18,=ch_ua|6,fst02|skip if less than uc a|21511
||bgt|8,wa|18,=ch_uz|6,fst02|skip if greater than uc z|21512
||flc|8,wa|||fold character to lower case|21513
||mnz|9,(xs)|||set did fold character flag|21514
|fst02|sch|8,wa|10,(xr)+||store (possibly folded) character|21515
||bct|8,wc|6,fst01||loop thru entire string|21516
||csc|7,xr|||complete store characters|21517
||mov|7,xr|10,(xs)+||see if any change|21518
||bnz|7,xr|6,fst10||skip if folding done (no change)|21519
||mov|3,dnamp|10,(xs)+||do not need new scblk|21520
||mov|7,xr|10,(xs)+||return original scblk|21521
||brn|6,fst20|||merge below|21522
|fst10|mov|7,xr|10,(xs)+||return new scblk|21523
||ica|7,xs|||throw away original scblk pointer|21524
|fst20|mov|8,wa|13,sclen(xr)||reload string length|21525
||mov|7,xl|10,(xs)+||restore xl|21526
|fst99|exi||||return|21527
||enp|||||21528
||ejc|||||21529
||ejc|||||21584
||ejc|||||21638
||ejc|||||21682
||ejc|||||21720
|gbcol|prc|25,e|1,0||entry point|21724
||bnz|3,dmvch|6,gbc14||fail if in mid-dump|21726
||mnz|3,gbcfl|||note gbcol entered|21727
||mov|3,gbsva|8,wa||save entry wa|21728
||mov|3,gbsvb|8,wb||save entry wb|21729
||mov|3,gbsvc|8,wc||save entry wc|21730
||mov|11,-(xs)|7,xl||save entry xl|21731
||scp|8,wa|||get code pointer value|21732
||sub|8,wa|3,r_cod||make relative|21733
||lcp|8,wa|||and restore|21734
||bze|8,wb|6,gbc0a||check there is no move offset|21736
||zer|3,dnams|||collect sediment if must move it|21737
|gbc0a|mov|8,wa|3,dnamb||start of dynamic area|21738
||add|8,wa|3,dnams||size of sediment|21739
||mov|3,gbcsd|8,wa||first location past sediment|21740
||mnz|7,xr|||non-zero flags start of collection|21753
||mov|8,wa|3,dnamb||start of dynamic area|21754
||mov|8,wb|3,dnamp||next available location|21755
||mov|8,wc|3,dname||last available location + 1|21756
||jsr|6,sysgc|||inform of collection|21757
||mov|7,xr|7,xs||point to stack front|21762
||mov|7,xl|3,stbas||point past end of stack|21763
||bge|7,xl|7,xr|6,gbc00|ok if d-stack|21764
||mov|7,xr|7,xl||reverse if ...|21765
||mov|7,xl|7,xs||... u-stack|21766
|gbc00|jsr|6,gbcpf|||process pointers on stack|21770
||mov|7,xr|20,=r_aaa||point to start of relocatable locs|21774
||mov|7,xl|20,=r_yyy||point past end of relocatable locs|21775
||jsr|6,gbcpf|||process work fields|21776
||mov|8,wa|3,hshtb||point to first hash slot pointer|21780
|gbc01|mov|7,xl|8,wa||point to next slot|21784
||ica|8,wa|||bump bucket pointer|21785
||mov|3,gbcnm|8,wa||save bucket pointer|21786
||ejc|||||21787
|gbc02|mov|7,xr|9,(xl)||load ptr to next vrblk|21793
||bze|7,xr|6,gbc03||jump if end of chain|21794
||mov|7,xl|7,xr||else copy vrblk pointer|21795
||add|7,xr|19,*vrval||point to first reloc fld|21796
||add|7,xl|19,*vrnxt||point past last (and to link ptr)|21797
||jsr|6,gbcpf|||process reloc fields in vrblk|21798
||brn|6,gbc02|||loop back for next block|21799
|gbc03|mov|8,wa|3,gbcnm||restore bucket pointer|21803
||bne|8,wa|3,hshte|6,gbc01|loop back if more buckets to go|21804
||ejc|||||21805
||mov|7,xr|3,dnamb||point to first block|21834
||zer|8,wb|||accumulate size of dead blocks|21835
|gbc04|beq|7,xr|3,gbcsd|6,gbc4c|jump if end of sediment|21836
||mov|8,wa|9,(xr)||else get first word|21837
||bod|8,wa|6,gbc4b||jump if entry pointer (unused)|21839
||dcv|8,wa|||restore entry pointer|21840
||mov|9,(xr)|8,wa||restore first word|21846
||jsr|6,blkln|||get length of this block|21847
||add|7,xr|8,wa||bump actual pointer|21848
||brn|6,gbc04|||continue scan through sediment|21849
|gbc4b|jsr|6,blkln|||get length of this block|21853
||add|7,xr|8,wa||bump actual pointer|21854
||add|8,wb|8,wa||count size of unused blocks|21855
||brn|6,gbc04|||continue scan through sediment|21856
|gbc4c|mov|3,gbcsf|8,wb||size of sediment free space|21867
||mov|8,wc|7,xr||set as first eventual location|21871
||add|8,wc|3,gbsvb||add offset for eventual move up|21872
||zer|3,gbcnm|||clear initial forward pointer|21873
||mov|3,gbclm|20,=gbcnm||initialize ptr to last move block|21874
||mov|3,gbcns|7,xr||initialize first address|21875
|gbc05|beq|7,xr|3,dnamp|6,gbc07|jump if end of used region|21879
||mov|8,wa|9,(xr)||else get first word|21880
||bod|8,wa|6,gbc07||jump if entry pointer (unused)|21882
|gbc06|mov|7,xl|8,wa||copy pointer|21890
||mov|8,wa|9,(xl)||load forward pointer|21891
||mov|9,(xl)|8,wc||relocate reference|21892
||bev|8,wa|6,gbc06||loop back if not end of chain|21894
||ejc|||||21899
||mov|9,(xr)|8,wa||restore first word|21905
||jsr|6,blkln|||get length of this block|21906
||add|7,xr|8,wa||bump actual pointer|21907
||add|8,wc|8,wa||bump eventual pointer|21908
||brn|6,gbc05|||loop back for next block|21909
|gbc07|mov|8,wa|7,xr||copy pointer past last block|21913
||mov|7,xl|3,gbclm||point to previous move block|21914
||sub|8,wa|13,num01(xl)||subtract starting address|21915
||mov|13,num01(xl)|8,wa||store length of block to be moved|21916
|gbc08|beq|7,xr|3,dnamp|6,gbc10|jump if end of used region|21920
||mov|8,wa|9,(xr)||else load first word of next block|21921
||bev|8,wa|6,gbc09||jump if in use|21923
||jsr|6,blkln|||else get length of next block|21928
||add|7,xr|8,wa||push pointer|21929
||brn|6,gbc08|||and loop back|21930
|gbc09|sub|7,xr|19,*num02||point 2 words behind for move block|21935
||mov|7,xl|3,gbclm||point to previous move block|21936
||mov|9,(xl)|7,xr||set forward ptr in previous block|21937
||zer|9,(xr)|||zero forward ptr of new block|21938
||mov|3,gbclm|7,xr||remember address of this block|21939
||mov|7,xl|7,xr||copy ptr to move block|21940
||add|7,xr|19,*num02||point back to block in use|21941
||mov|13,num01(xl)|7,xr||store starting address|21942
||brn|6,gbc06|||jump to process block in use|21943
||ejc|||||21944
|gbc10|mov|7,xr|3,gbcsd||point to storage above sediment|21954
||add|7,xr|3,gbcns||bump past unmoved blocks at start|21958
|gbc11|mov|7,xl|3,gbcnm||point to next move block|21962
||bze|7,xl|6,gbc12||jump if end of chain|21963
||mov|3,gbcnm|10,(xl)+||move pointer down chain|21964
||mov|8,wa|10,(xl)+||get length to move|21965
||mvw||||perform move|21966
||brn|6,gbc11|||loop back|21967
|gbc12|mov|3,dnamp|7,xr||set next available loc ptr|21971
||mov|8,wb|3,gbsvb||reload move offset|21972
||bze|8,wb|6,gbc13||jump if no move required|21973
||mov|7,xl|7,xr||else copy old top of core|21974
||add|7,xr|8,wb||point to new top of core|21975
||mov|3,dnamp|7,xr||save new top of core pointer|21976
||mov|8,wa|7,xl||copy old top|21977
||sub|8,wa|3,dnamb||minus old bottom = length|21978
||add|3,dnamb|8,wb||bump bottom to get new value|21979
||mwb||||perform move (backwards)|21980
|gbc13|zer|7,xr|||clear garbage value in xr|21984
||mov|3,gbcfl|7,xr||note exit from gbcol|21985
||mov|8,wa|3,dnamb||start of dynamic area|21987
||mov|8,wb|3,dnamp||next available location|21988
||mov|8,wc|3,dname||last available location + 1|21989
||jsr|6,sysgc|||inform sysgc of completion|21990
||sti|3,gbcia|||save ia|21998
||zer|7,xr|||presume no sediment will remain|21999
||mov|8,wb|3,gbcsf||free space in sediment|22000
||btw|8,wb|||convert bytes to words|22001
||mti|8,wb|||put sediment free store in ia|22002
||mli|3,gbsed|||multiply by sediment factor|22003
||iov|6,gb13a|||jump if overflowed|22004
||mov|8,wb|3,dnamp||end of dynamic area in use|22005
||sub|8,wb|3,dnamb||minus start is sediment remaining|22006
||btw|8,wb|||convert to words|22007
||mov|3,gbcsf|8,wb||store it|22008
||sbi|3,gbcsf|||subtract from scaled up free store|22009
||igt|6,gb13a|||jump if large free store in sedimnt|22010
||mov|7,xr|3,dnamp||below threshold, return sediment|22011
||sub|7,xr|3,dnamb||for use by caller|22012
|gb13a|ldi|3,gbcia|||restore ia|22013
||mov|8,wa|3,gbsva||restore wa|22015
||mov|8,wb|3,gbsvb||restore wb|22016
||scp|8,wc|||get code pointer|22017
||add|8,wc|3,r_cod||make absolute again|22018
||lcp|8,wc|||and replace absolute value|22019
||mov|8,wc|3,gbsvc||restore wc|22020
||mov|7,xl|10,(xs)+||restore entry xl|22021
||icv|3,gbcnt|||increment count of collections|22022
||exi||||exit to gbcol caller|22023
|gbc14|icv|3,errft|||fatal error|22027
||erb|1,250|26,insufficient memory to complete dump|||22028
||enp||||end procedure gbcol|22029
||ejc|||||22030
|gbcpf|prc|25,e|1,0||entry point|22045
||zer|11,-(xs)|||set zero to mark bottom of stack|22046
||mov|11,-(xs)|7,xl||save end pointer|22047
|gpf01|mov|7,xl|9,(xr)||load field contents|22057
||mov|8,wc|7,xr||save field pointer|22058
||blt|7,xl|3,dnamb|6,gpf2a|jump if not ptr into dynamic area|22062
||bge|7,xl|3,dnamp|6,gpf2a|jump if not ptr into dynamic area|22063
||mov|8,wa|9,(xl)||load ptr to chain (or entry ptr)|22068
||blt|7,xl|3,gbcsd|6,gpf1a|do not chain if within sediment|22070
||mov|9,(xl)|7,xr||set this field as new head of chain|22072
||mov|9,(xr)|8,wa||set forward pointer|22073
|gpf1a|bod|8,wa|6,gpf03||jump if not already processed|22078
|gpf02|mov|7,xr|8,wc||restore field pointer|22086
|gpf2a|ica|7,xr|||bump to next field|22090
||bne|7,xr|9,(xs)|6,gpf01|loop back if more to go|22091
||ejc|||||22092
||mov|7,xl|10,(xs)+||restore pointer past end|22098
||mov|7,xr|10,(xs)+||restore block pointer|22099
||bnz|7,xr|6,gpf2a||continue loop unless outer levl|22100
||exi||||return to caller if outer level|22101
|gpf03|bge|7,xl|3,gbcsd|6,gpf3a|if not within sediment|22114
||icv|9,(xl)|||mark by making entry point even|22116
|gpf3a|mov|7,xr|7,xl||copy block pointer|22120
||mov|7,xl|8,wa||copy first word of block|22124
||lei|7,xl|||load entry point id (bl_xx)|22125
||bsw|7,xl|2,bl___||switch on block type|22130
||iff|2,bl_ar|6,gpf06||arblk|22168
||iff|2,bl_cd|6,gpf19||cdblk|22168
||iff|2,bl_ex|6,gpf17||exblk|22168
||iff|2,bl_ic|6,gpf02||icblk|22168
||iff|2,bl_nm|6,gpf10||nmblk|22168
||iff|2,bl_p0|6,gpf10||p0blk|22168
||iff|2,bl_p1|6,gpf12||p1blk|22168
||iff|2,bl_p2|6,gpf12||p2blk|22168
||iff|2,bl_rc|6,gpf02||rcblk|22168
||iff|2,bl_sc|6,gpf02||scblk|22168
||iff|2,bl_se|6,gpf02||seblk|22168
||iff|2,bl_tb|6,gpf08||tbblk|22168
||iff|2,bl_vc|6,gpf08||vcblk|22168
||iff|2,bl_xn|6,gpf02||xnblk|22168
||iff|2,bl_xr|6,gpf09||xrblk|22168
||iff|2,bl_bc|6,gpf02||bcblk - dummy to fill out iffs|22168
||iff|2,bl_pd|6,gpf13||pdblk|22168
||iff|2,bl_tr|6,gpf16||trblk|22168
||iff|2,bl_bf|6,gpf02||bfblk|22168
||iff|2,bl_cc|6,gpf07||ccblk|22168
||iff|2,bl_cm|6,gpf04||cmblk|22168
||iff|2,bl_ct|6,gpf02||ctblk|22168
||iff|2,bl_df|6,gpf02||dfblk|22168
||iff|2,bl_ef|6,gpf02||efblk|22168
||iff|2,bl_ev|6,gpf10||evblk|22168
||iff|2,bl_ff|6,gpf11||ffblk|22168
||iff|2,bl_kv|6,gpf02||kvblk|22168
||iff|2,bl_pf|6,gpf14||pfblk|22168
||iff|2,bl_te|6,gpf15||teblk|22168
||esw||||end of jump table|22168
||ejc|||||22169
|gpf04|mov|8,wa|13,cmlen(xr)||load length|22175
||mov|8,wb|19,*cmtyp||set offset|22176
|gpf05|add|8,wa|7,xr||point past last reloc field|22185
||add|7,xr|8,wb||point to first reloc field|22186
||mov|11,-(xs)|8,wc||stack old field pointer|22187
||mov|11,-(xs)|8,wa||stack new limit pointer|22188
||chk||||check for stack overflow|22189
||brn|6,gpf01|||if ok, back to process|22190
|gpf06|mov|8,wa|13,arlen(xr)||load length|22194
||mov|8,wb|13,arofs(xr)||set offset to 1st reloc fld (arpro)|22195
||brn|6,gpf05|||all set|22196
|gpf07|mov|8,wa|13,ccuse(xr)||set length in use|22200
||mov|8,wb|19,*ccuse||1st word (make sure at least one)|22201
||brn|6,gpf05|||all set|22202
||ejc|||||22203
|gpf19|mov|8,wa|13,cdlen(xr)||load length|22210
||mov|8,wb|19,*cdfal||set offset|22211
||brn|6,gpf05|||jump back|22212
|gpf08|mov|8,wa|13,offs2(xr)||load length|22219
||mov|8,wb|19,*offs3||set offset|22220
||brn|6,gpf05|||jump back|22221
|gpf09|mov|8,wa|13,xrlen(xr)||load length|22225
||mov|8,wb|19,*xrptr||set offset|22226
||brn|6,gpf05|||jump back|22227
|gpf10|mov|8,wa|19,*offs2||point past second field|22231
||mov|8,wb|19,*offs1||offset is one (only reloc fld is 2)|22232
||brn|6,gpf05|||all set|22233
|gpf11|mov|8,wa|19,*ffofs||set length|22237
||mov|8,wb|19,*ffnxt||set offset|22238
||brn|6,gpf05|||all set|22239
|gpf12|mov|8,wa|19,*parm2||length (parm2 is non-relocatable)|22243
||mov|8,wb|19,*pthen||set offset|22244
||brn|6,gpf05|||all set|22245
||ejc|||||22246
|gpf13|mov|7,xl|13,pddfp(xr)||load ptr to dfblk|22252
||mov|8,wa|13,dfpdl(xl)||get pdblk length|22253
||mov|8,wb|19,*pdfld||set offset|22254
||brn|6,gpf05|||all set|22255
|gpf14|mov|8,wa|19,*pfarg||length past last reloc|22259
||mov|8,wb|19,*pfcod||offset to first reloc|22260
||brn|6,gpf05|||all set|22261
|gpf15|mov|8,wa|19,*tesi_||set length|22265
||mov|8,wb|19,*tesub||and offset|22266
||brn|6,gpf05|||all set|22267
|gpf16|mov|8,wa|19,*trsi_||set length|22271
||mov|8,wb|19,*trval||and offset|22272
||brn|6,gpf05|||all set|22273
|gpf17|mov|8,wa|13,exlen(xr)||load length|22277
||mov|8,wb|19,*exflc||set offset|22278
||brn|6,gpf05|||jump back|22279
||enp||||end procedure gbcpf|22289
||ejc|||||22290
|gtarr|prc|25,e|1,2||entry point|22306
||mov|3,gtawa|8,wa||save wa indicator|22307
||mov|8,wa|9,(xr)||load type word|22308
||beq|8,wa|22,=b_art|6,gtar8|exit if already an array|22309
||beq|8,wa|22,=b_vct|6,gtar8|exit if already an array|22310
||bne|8,wa|22,=b_tbt|6,gta9a|else fail if not a table (sgd02)|22311
||mov|11,-(xs)|7,xr||replace tbblk pointer on stack|22315
||zer|7,xr|||signal first pass|22316
||zer|8,wb|||zero non-null element count|22317
|gtar1|mov|7,xl|9,(xs)||point to table|22327
||add|7,xl|13,tblen(xl)||point past last bucket|22328
||sub|7,xl|19,*tbbuk||set first bucket offset|22329
||mov|8,wa|7,xl||copy adjusted pointer|22330
|gtar2|mov|7,xl|8,wa||copy bucket pointer|22336
||dca|8,wa|||decrement bucket pointer|22337
|gtar3|mov|7,xl|13,tenxt(xl)||point to next teblk|22341
||beq|7,xl|9,(xs)|6,gtar6|jump if chain end (tbblk ptr)|22342
||mov|3,cnvtp|7,xl||else save teblk pointer|22343
|gtar4|mov|7,xl|13,teval(xl)||load value|22347
||beq|9,(xl)|22,=b_trt|6,gtar4|loop till value found|22348
||mov|8,wc|7,xl||copy value|22349
||mov|7,xl|3,cnvtp||restore teblk pointer|22350
||ejc|||||22351
||beq|8,wc|21,=nulls|6,gtar3|loop back to ignore null value|22357
||bnz|7,xr|6,gtar5||jump if second pass|22358
||icv|8,wb|||for the first pass, bump count|22359
||brn|6,gtar3|||and loop back for next teblk|22360
|gtar5|bze|3,gtawa|6,gta5a||jump if address wanted|22364
||mov|10,(xr)+|13,tesub(xl)||store subscript name|22365
||mov|10,(xr)+|8,wc||store value in arblk|22366
||brn|6,gtar3|||loop back for next teblk|22367
|gta5a|mov|10,(xr)+|7,xl||store teblk address in name|22372
||mov|10,(xr)+|7,xl||and value slots|22373
||brn|6,gtar3|||loop back for next teblk|22374
|gtar6|bne|8,wa|9,(xs)|6,gtar2|loop back if more buckets to go|22378
||bnz|7,xr|6,gtar7||else jump if second pass|22379
||bze|8,wb|6,gtar9||fail if no non-null elements|22383
||mov|8,wa|8,wb||else copy count|22384
||add|8,wa|8,wb||double (two words/element)|22385
||add|8,wa|18,=arvl2||add space for standard fields|22386
||wtb|8,wa|||convert length to bytes|22387
||bgt|8,wa|3,mxlen|6,gta9b|error if too long for array|22388
||jsr|6,alloc|||else allocate space for arblk|22389
||mov|9,(xr)|22,=b_art||store type word|22390
||zer|13,idval(xr)|||zero id for the moment|22391
||mov|13,arlen(xr)|8,wa||store length|22392
||mov|13,arndm(xr)|18,=num02||set dimensions = 2|22393
||ldi|4,intv1|||get integer one|22394
||sti|13,arlbd(xr)|||store as lbd 1|22395
||sti|13,arlb2(xr)|||store as lbd 2|22396
||ldi|4,intv2|||load integer two|22397
||sti|13,ardm2(xr)|||store as dim 2|22398
||mti|8,wb|||get element count as integer|22399
||sti|13,ardim(xr)|||store as dim 1|22400
||zer|13,arpr2(xr)|||zero prototype field for now|22401
||mov|13,arofs(xr)|19,*arpr2||set offset field (signal pass 2)|22402
||mov|8,wb|7,xr||save arblk pointer|22403
||add|7,xr|19,*arvl2||point to first element location|22404
||brn|6,gtar1|||jump back to fill in elements|22405
||ejc|||||22406
|gtar7|mov|7,xr|8,wb||restore arblk pointer|22412
||mov|9,(xs)|8,wb||store as result|22413
||ldi|13,ardim(xr)|||get number of elements (nn)|22419
||mli|4,intvh|||multiply by 100|22420
||adi|4,intv2|||add 2 (nn02)|22421
||jsr|6,icbld|||build integer|22422
||mov|11,-(xs)|7,xr||store ptr for gtstg|22423
||jsr|6,gtstg|||convert to string|22424
||ppm||||convert fail is impossible|22425
||mov|7,xl|7,xr||copy string pointer|22426
||mov|7,xr|10,(xs)+||reload arblk pointer|22427
||mov|13,arpr2(xr)|7,xl||store prototype ptr (nn02)|22428
||sub|8,wa|18,=num02||adjust length to point to zero|22429
||psc|7,xl|8,wa||point to zero|22430
||mov|8,wb|18,=ch_cm||load a comma|22431
||sch|8,wb|9,(xl)||store a comma over the zero|22432
||csc|7,xl|||complete store characters|22433
|gtar8|exi||||return to caller|22437
|gtar9|mov|7,xr|10,(xs)+||restore stack for conv err (sgd02)|22441
||exi|1,1|||return|22442
|gta9a|exi|1,2|||return|22446
|gta9b|erb|1,260|26,conversion array size exceeds maximum permitted|||22450
||enp||||procedure gtarr|22451
||ejc|||||22452
|gtcod|prc|25,e|1,1||entry point|22466
||beq|9,(xr)|22,=b_cds|6,gtcd1|jump if already code|22467
||beq|9,(xr)|22,=b_cdc|6,gtcd1|jump if already code|22468
||mov|11,-(xs)|7,xr||stack argument for gtstg|22472
||jsr|6,gtstg|||convert argument to string|22473
||ppm|6,gtcd2|||jump if non-convertible|22474
||mov|3,gtcef|3,flptr||save fail ptr in case of error|22475
||mov|3,r_gtc|3,r_cod||also save code ptr|22476
||mov|3,r_cim|7,xr||else set image pointer|22477
||mov|3,scnil|8,wa||set image length|22478
||zer|3,scnpt|||set scan pointer|22479
||mov|3,stage|18,=stgxc||set stage for execute compile|22480
||mov|3,lstsn|3,cmpsn||in case listr called|22481
||icv|3,cmpln|||bump line number|22483
||jsr|6,cmpil|||compile string|22485
||mov|3,stage|18,=stgxt||reset stage for execute time|22486
||zer|3,r_cim|||clear image|22487
|gtcd1|exi||||give normal gtcod return|22491
|gtcd2|exi|1,1|||give error return|22495
||enp||||end procedure gtcod|22496
||ejc|||||22497
|gtexp|prc|25,e|1,1||entry point|22514
||blo|9,(xr)|22,=b_e__|6,gtex1|jump if already an expression|22515
||mov|11,-(xs)|7,xr||store argument for gtstg|22516
||jsr|6,gtstg|||convert argument to string|22517
||ppm|6,gtex2|||jump if unconvertible|22518
||mov|7,xl|7,xr||copy input string pointer|22526
||plc|7,xl|8,wa||point one past the string end|22527
||lch|7,xl|11,-(xl)||fetch the last character|22528
||beq|7,xl|18,=ch_cl|6,gtex2|error if it is a semicolon|22529
||beq|7,xl|18,=ch_sm|6,gtex2|or if it is a colon|22530
||mov|3,r_cim|7,xr||set input image pointer|22534
||zer|3,scnpt|||set scan pointer|22535
||mov|3,scnil|8,wa||set input image length|22536
||mov|11,-(xs)|8,wb||save value/name flag|22538
||zer|8,wb|||set code for normal scan|22540
||mov|3,gtcef|3,flptr||save fail ptr in case of error|22541
||mov|3,r_gtc|3,r_cod||also save code ptr|22542
||mov|3,stage|18,=stgev||adjust stage for compile|22543
||mov|3,scntp|18,=t_uok||indicate unary operator acceptable|22544
||jsr|6,expan|||build tree for expression|22545
||zer|3,scnrs|||reset rescan flag|22546
||mov|8,wa|10,(xs)+||restore value/name flag|22548
||bne|3,scnpt|3,scnil|6,gtex2|error if not end of image|22550
||zer|8,wb|||set ok value for cdgex call|22551
||mov|7,xl|7,xr||copy tree pointer|22552
||jsr|6,cdgex|||build expression block|22553
||zer|3,r_cim|||clear pointer|22554
||mov|3,stage|18,=stgxt||restore stage for execute time|22555
|gtex1|exi||||return to gtexp caller|22559
|gtex2|exi|1,1|||take error exit|22563
||enp||||end procedure gtexp|22564
||ejc|||||22565
|gtint|prc|25,e|1,1||entry point|22580
||beq|9,(xr)|22,=b_icl|6,gtin2|jump if already an integer|22581
||mov|3,gtina|8,wa||else save wa|22582
||mov|3,gtinb|8,wb||save wb|22583
||jsr|6,gtnum|||convert to numeric|22584
||ppm|6,gtin3|||jump if unconvertible|22585
||beq|8,wa|22,=b_icl|6,gtin1|jump if integer|22588
||ldr|13,rcval(xr)|||load real value|22592
||rti|6,gtin3|||convert to integer (err if ovflow)|22593
||jsr|6,icbld|||if ok build icblk|22594
|gtin1|mov|8,wa|3,gtina||restore wa|22599
||mov|8,wb|3,gtinb||restore wb|22600
|gtin2|exi||||return to gtint caller|22604
|gtin3|exi|1,1|||take convert error exit|22608
||enp||||end procedure gtint|22609
||ejc|||||22610
|gtnum|prc|25,e|1,1||entry point|22625
||mov|8,wa|9,(xr)||load first word of block|22626
||beq|8,wa|22,=b_icl|6,gtn34|jump if integer (no conversion)|22627
||beq|8,wa|22,=b_rcl|6,gtn34|jump if real (no conversion)|22630
||mov|11,-(xs)|7,xr||stack argument in case convert err|22636
||mov|11,-(xs)|7,xr||stack argument for gtstg|22637
||jsr|6,gtstg|||convert argument to string|22639
||ppm|6,gtn36|||jump if unconvertible|22643
||ldi|4,intv0|||initialize integer result to zero|22647
||bze|8,wa|6,gtn32||jump to exit with zero if null|22648
||lct|8,wa|8,wa||set bct counter for following loops|22649
||zer|3,gtnnf|||tentatively indicate result +|22650
||sti|3,gtnex|||initialise exponent to zero|22653
||zer|3,gtnsc|||zero scale in case real|22654
||zer|3,gtndf|||reset flag for dec point found|22655
||zer|3,gtnrd|||reset flag for digits found|22656
||ldr|4,reav0|||zero real accum in case real|22657
||plc|7,xr|||point to argument characters|22659
|gtn01|lch|8,wb|10,(xr)+||load first character|22663
||blt|8,wb|18,=ch_d0|6,gtn02|jump if not digit|22664
||ble|8,wb|18,=ch_d9|6,gtn06|jump if first char is a digit|22665
||ejc|||||22666
|gtn02|bne|8,wb|18,=ch_bl|6,gtn03|jump if non-blank|22672
|gtna2|bct|8,wa|6,gtn01||else decr count and loop back|22673
||brn|6,gtn07|||jump to return zero if all blanks|22674
|gtn03|beq|8,wb|18,=ch_pl|6,gtn04|jump if plus sign|22678
||beq|8,wb|18,=ch_ht|6,gtna2|horizontal tab equiv to blank|22680
||bne|8,wb|18,=ch_mn|6,gtn12|jump if not minus (may be real)|22688
||mnz|3,gtnnf|||if minus sign, set negative flag|22690
|gtn04|bct|8,wa|6,gtn05||jump if chars left|22694
||brn|6,gtn36|||else error|22695
|gtn05|lch|8,wb|10,(xr)+||load next character|22699
||blt|8,wb|18,=ch_d0|6,gtn08|jump if not a digit|22700
||bgt|8,wb|18,=ch_d9|6,gtn08|jump if not a digit|22701
|gtn06|sti|3,gtnsi|||save current value|22705
||cvm|6,gtn35|||current*10-(new dig) jump if ovflow|22709
||mnz|3,gtnrd|||set digit read flag|22710
||bct|8,wa|6,gtn05||else loop back if more chars|22712
|gtn07|bnz|3,gtnnf|6,gtn32||jump if negative (all set)|22716
||ngi||||else negate|22717
||ino|6,gtn32|||jump if no overflow|22718
||brn|6,gtn36|||else signal error|22719
||ejc|||||22720
|gtn08|beq|8,wb|18,=ch_bl|6,gtna9|jump if a blank|22727
||beq|8,wb|18,=ch_ht|6,gtna9|jump if horizontal tab|22729
||itr||||else convert integer to real|22737
||ngr||||negate to get positive value|22738
||brn|6,gtn12|||jump to try for real|22739
|gtn09|lch|8,wb|10,(xr)+||get next char|22744
||beq|8,wb|18,=ch_ht|6,gtna9|jump if horizontal tab|22746
||bne|8,wb|18,=ch_bl|6,gtn36|error if non-blank|22751
|gtna9|bct|8,wa|6,gtn09||loop back if more chars to check|22752
||brn|6,gtn07|||return integer if all blanks|22753
|gtn10|lch|8,wb|10,(xr)+||load next character|22759
||blt|8,wb|18,=ch_d0|6,gtn12|jump if non-numeric|22760
||bgt|8,wb|18,=ch_d9|6,gtn12|jump if non-numeric|22761
|gtn11|sub|8,wb|18,=ch_d0||convert digit to number|22765
||mlr|4,reavt|||multiply real by 10.0|22766
||rov|6,gtn36|||convert error if overflow|22767
||str|3,gtnsr|||save result|22768
||mti|8,wb|||get new digit as integer|22769
||itr||||convert new digit to real|22770
||adr|3,gtnsr|||add to get new total|22771
||add|3,gtnsc|3,gtndf||increment scale if after dec point|22772
||mnz|3,gtnrd|||set digit found flag|22773
||bct|8,wa|6,gtn10||loop back if more chars|22774
||brn|6,gtn22|||else jump to scale|22775
||ejc|||||22776
|gtn12|bne|8,wb|18,=ch_dt|6,gtn13|jump if not dec point|22782
||bnz|3,gtndf|6,gtn36||if dec point, error if one already|22783
||mov|3,gtndf|18,=num01||else set flag for dec point|22784
||bct|8,wa|6,gtn10||loop back if more chars|22785
||brn|6,gtn22|||else jump to scale|22786
|gtn13|beq|8,wb|18,=ch_le|6,gtn15|jump if e for exponent|22790
||beq|8,wb|18,=ch_ld|6,gtn15|jump if d for exponent|22791
||beq|8,wb|18,=ch_ue|6,gtn15|jump if e for exponent|22793
||beq|8,wb|18,=ch_ud|6,gtn15|jump if d for exponent|22794
|gtn14|beq|8,wb|18,=ch_bl|6,gtnb4|jump if blank|22799
||beq|8,wb|18,=ch_ht|6,gtnb4|jump if horizontal tab|22801
||brn|6,gtn36|||error if non-blank|22806
|gtnb4|lch|8,wb|10,(xr)+||get next character|22808
||bct|8,wa|6,gtn14||loop back to check if more|22809
||brn|6,gtn22|||else jump to scale|22810
|gtn15|zer|3,gtnes|||set exponent sign positive|22814
||ldi|4,intv0|||initialize exponent to zero|22815
||mnz|3,gtndf|||reset no dec point indication|22816
||bct|8,wa|6,gtn16||jump skipping past e or d|22817
||brn|6,gtn36|||error if null exponent|22818
|gtn16|lch|8,wb|10,(xr)+||load first exponent character|22822
||beq|8,wb|18,=ch_pl|6,gtn17|jump if plus sign|22823
||bne|8,wb|18,=ch_mn|6,gtn19|else jump if not minus sign|22824
||mnz|3,gtnes|||set sign negative if minus sign|22825
|gtn17|bct|8,wa|6,gtn18||jump if chars left|22829
||brn|6,gtn36|||else error|22830
|gtn18|lch|8,wb|10,(xr)+||load next character|22834
||ejc|||||22835
|gtn19|blt|8,wb|18,=ch_d0|6,gtn20|jump if not digit|22841
||bgt|8,wb|18,=ch_d9|6,gtn20|jump if not digit|22842
||cvm|6,gtn36|||else current*10, subtract new digit|22843
||bct|8,wa|6,gtn18||loop back if more chars|22844
||brn|6,gtn21|||jump if exponent field is exhausted|22845
|gtn20|beq|8,wb|18,=ch_bl|6,gtnc0|jump if blank|22849
||beq|8,wb|18,=ch_ht|6,gtnc0|jump if horizontal tab|22851
||brn|6,gtn36|||error if non-blank|22856
|gtnc0|lch|8,wb|10,(xr)+||get next character|22858
||bct|8,wa|6,gtn20||loop back till all blanks scanned|22859
|gtn21|sti|3,gtnex|||save collected exponent|22863
||bnz|3,gtnes|6,gtn22||jump if it was negative|22864
||ngi||||else complement|22865
||iov|6,gtn36|||error if overflow|22866
||sti|3,gtnex|||and store positive exponent|22867
|gtn22|bze|3,gtnrd|6,gtn36||error if not digits collected|22871
||bze|3,gtndf|6,gtn36||error if no exponent or dec point|22872
||mti|3,gtnsc|||else load scale as integer|22873
||sbi|3,gtnex|||subtract exponent|22874
||iov|6,gtn36|||error if overflow|22875
||ilt|6,gtn26|||jump if we must scale up|22876
||mfi|8,wa|6,gtn36||load scale factor, err if ovflow|22880
|gtn23|ble|8,wa|18,=num10|6,gtn24|jump if 10 or less to go|22884
||dvr|4,reatt|||else divide by 10**10|22885
||sub|8,wa|18,=num10||decrement scale|22886
||brn|6,gtn23|||and loop back|22887
||ejc|||||22888
|gtn24|bze|8,wa|6,gtn30||jump if scaled|22894
||lct|8,wb|18,=cfp_r||else get indexing factor|22895
||mov|7,xr|21,=reav1||point to powers of ten table|22896
||wtb|8,wa|||convert remaining scale to byte ofs|22897
|gtn25|add|7,xr|8,wa||bump pointer|22901
||bct|8,wb|6,gtn25||once for each value word|22902
||dvr|9,(xr)|||scale down as required|22903
||brn|6,gtn30|||and jump|22904
|gtn26|ngi||||get absolute value of exponent|22908
||iov|6,gtn36|||error if overflow|22909
||mfi|8,wa|6,gtn36||acquire scale, error if ovflow|22910
|gtn27|ble|8,wa|18,=num10|6,gtn28|jump if 10 or less to go|22914
||mlr|4,reatt|||else multiply by 10**10|22915
||rov|6,gtn36|||error if overflow|22916
||sub|8,wa|18,=num10||else decrement scale|22917
||brn|6,gtn27|||and loop back|22918
|gtn28|bze|8,wa|6,gtn30||jump if scaled|22922
||lct|8,wb|18,=cfp_r||else get indexing factor|22923
||mov|7,xr|21,=reav1||point to powers of ten table|22924
||wtb|8,wa|||convert remaining scale to byte ofs|22925
|gtn29|add|7,xr|8,wa||bump pointer|22929
||bct|8,wb|6,gtn29||once for each word in value|22930
||mlr|9,(xr)|||scale up|22931
||rov|6,gtn36|||error if overflow|22932
||ejc|||||22933
|gtn30|bze|3,gtnnf|6,gtn31||jump if positive|22939
||ngr||||else negate|22940
|gtn31|jsr|6,rcbld|||build real block|22944
||brn|6,gtn33|||merge to exit|22945
|gtn32|jsr|6,icbld|||build icblk|22950
|gtn33|mov|8,wa|9,(xr)||load first word of result block|22954
||ica|7,xs|||pop argument off stack|22955
|gtn34|exi||||return to gtnum caller|22959
|gtn35|lch|8,wb|11,-(xr)||reload current character|22966
||lch|8,wb|10,(xr)+||bump character pointer|22967
||ldi|3,gtnsi|||reload integer so far|22968
||itr||||convert to real|22969
||ngr||||make value positive|22970
||brn|6,gtn11|||merge with real circuit|22971
|gtn36|mov|7,xr|10,(xs)+||reload original argument|22976
||exi|1,1|||take convert-error exit|22977
||enp||||end procedure gtnum|22978
||ejc|||||22979
|gtnvr|prc|25,e|1,1||entry point|22993
||bne|9,(xr)|22,=b_nml|6,gnv02|jump if not name|22995
||mov|7,xr|13,nmbas(xr)||else load name base if name|22996
||blo|7,xr|3,state|6,gnv07|skip if vrblk (in static region)|22997
|gnv01|exi|1,1|||take convert-error exit|23001
|gnv02|mov|3,gnvsa|8,wa||save wa|23005
||mov|3,gnvsb|8,wb||save wb|23006
||mov|11,-(xs)|7,xr||stack argument for gtstg|23007
||jsr|6,gtstg|||convert argument to string|23008
||ppm|6,gnv01|||jump if conversion error|23009
||bze|8,wa|6,gnv01||null string is an error|23010
||jsr|6,flstg|||fold upper case to lower case|23012
||mov|11,-(xs)|7,xl||save xl|23014
||mov|11,-(xs)|7,xr||stack string ptr for later|23015
||mov|8,wb|7,xr||copy string pointer|23016
||add|8,wb|19,*schar||point to characters of string|23017
||mov|3,gnvst|8,wb||save pointer to characters|23018
||mov|8,wb|8,wa||copy length|23019
||ctw|8,wb|1,0||get number of words in name|23020
||mov|3,gnvnw|8,wb||save for later|23021
||jsr|6,hashs|||compute hash index for string|23022
||rmi|3,hshnb|||compute hash offset by taking mod|23023
||mfi|8,wc|||get as offset|23024
||wtb|8,wc|||convert offset to bytes|23025
||add|8,wc|3,hshtb||point to proper hash chain|23026
||sub|8,wc|19,*vrnxt||subtract offset to merge into loop|23027
||ejc|||||23028
|gnv03|mov|7,xl|8,wc||copy hash chain pointer|23034
||mov|7,xl|13,vrnxt(xl)||point to next vrblk on chain|23035
||bze|7,xl|6,gnv08||jump if end of chain|23036
||mov|8,wc|7,xl||save pointer to this vrblk|23037
||bnz|13,vrlen(xl)|6,gnv04||jump if not system variable|23038
||mov|7,xl|13,vrsvp(xl)||else point to svblk|23039
||sub|7,xl|19,*vrsof||adjust offset for merge|23040
|gnv04|bne|8,wa|13,vrlen(xl)|6,gnv03|back for next vrblk if lengths ne|23044
||add|7,xl|19,*vrchs||else point to chars of chain entry|23045
||lct|8,wb|3,gnvnw||get word counter to control loop|23046
||mov|7,xr|3,gnvst||point to chars of new name|23047
|gnv05|cne|9,(xr)|9,(xl)|6,gnv03|jump if no match for next vrblk|23051
||ica|7,xr|||bump new name pointer|23052
||ica|7,xl|||bump vrblk in chain name pointer|23053
||bct|8,wb|6,gnv05||else loop till all compared|23054
||mov|7,xr|8,wc||we have found a match, get vrblk|23055
|gnv06|mov|8,wa|3,gnvsa||restore wa|23059
||mov|8,wb|3,gnvsb||restore wb|23060
||ica|7,xs|||pop string pointer|23061
||mov|7,xl|10,(xs)+||restore xl|23062
|gnv07|exi||||return to gtnvr caller|23066
|gnv08|zer|7,xr|||clear garbage xr pointer|23070
||mov|3,gnvhe|8,wc||save ptr to end of hash chain|23071
||bgt|8,wa|18,=num09|6,gnv14|cannot be system var if length gt 9|23072
||mov|7,xl|8,wa||else copy length|23073
||wtb|7,xl|||convert to byte offset|23074
||mov|7,xl|14,vsrch(xl)||point to first svblk of this length|23075
||ejc|||||23076
|gnv09|mov|3,gnvsp|7,xl||save table pointer|23082
||mov|8,wc|10,(xl)+||load svbit bit string|23083
||mov|8,wb|10,(xl)+||load length from table entry|23084
||bne|8,wa|8,wb|6,gnv14|jump if end of right length entries|23085
||lct|8,wb|3,gnvnw||get word counter to control loop|23086
||mov|7,xr|3,gnvst||point to chars of new name|23087
|gnv10|cne|9,(xr)|9,(xl)|6,gnv11|jump if name mismatch|23091
||ica|7,xr|||else bump new name pointer|23092
||ica|7,xl|||bump svblk pointer|23093
||bct|8,wb|6,gnv10||else loop until all checked|23094
||zer|8,wc|||set vrlen value zero|23098
||mov|8,wa|19,*vrsi_||set standard size|23099
||brn|6,gnv15|||jump to build vrblk|23100
|gnv11|ica|7,xl|||bump past word of chars|23104
||bct|8,wb|6,gnv11||loop back if more to go|23105
||rsh|8,wc|2,svnbt||remove uninteresting bits|23106
|gnv12|mov|8,wb|4,bits1||load bit to test|23110
||anb|8,wb|8,wc||test for word present|23111
||zrb|8,wb|6,gnv13||jump if not present|23112
||ica|7,xl|||else bump table pointer|23113
|gnv13|rsh|8,wc|1,1||remove bit already processed|23117
||nzb|8,wc|6,gnv12||loop back if more bits to test|23118
||brn|6,gnv09|||else loop back for next svblk|23119
|gnv14|mov|8,wc|8,wa||copy vrlen value|23123
||mov|8,wa|18,=vrchs||load standard size -chars|23124
||add|8,wa|3,gnvnw||adjust for chars of name|23125
||wtb|8,wa|||convert length to bytes|23126
||ejc|||||23127
|gnv15|jsr|6,alost|||allocate space for vrblk (static)|23133
||mov|8,wb|7,xr||save vrblk pointer|23134
||mov|7,xl|21,=stnvr||point to model variable block|23135
||mov|8,wa|19,*vrlen||set length of standard fields|23136
||mvw||||set initial fields of new block|23137
||mov|7,xl|3,gnvhe||load pointer to end of hash chain|23138
||mov|13,vrnxt(xl)|8,wb||add new block to end of chain|23139
||mov|10,(xr)+|8,wc||set vrlen field, bump ptr|23140
||mov|8,wa|3,gnvnw||get length in words|23141
||wtb|8,wa|||convert to length in bytes|23142
||bze|8,wc|6,gnv16||jump if system variable|23143
||mov|7,xl|9,(xs)||point back to string name|23147
||add|7,xl|19,*schar||point to chars of name|23148
||mvw||||move characters into place|23149
||mov|7,xr|8,wb||restore vrblk pointer|23150
||brn|6,gnv06|||jump back to exit|23151
|gnv16|mov|7,xl|3,gnvsp||load pointer to svblk|23156
||mov|9,(xr)|7,xl||set svblk ptr in vrblk|23157
||mov|7,xr|8,wb||restore vrblk pointer|23158
||mov|8,wb|13,svbit(xl)||load bit indicators|23159
||add|7,xl|19,*svchs||point to characters of name|23160
||add|7,xl|8,wa||point past characters|23161
||mov|8,wc|4,btknm||load test bit|23165
||anb|8,wc|8,wb||and to test|23166
||zrb|8,wc|6,gnv17||jump if no keyword number|23167
||ica|7,xl|||else bump pointer|23168
||ejc|||||23169
|gnv17|mov|8,wc|4,btfnc||get test bit|23175
||anb|8,wc|8,wb||and to test|23176
||zrb|8,wc|6,gnv18||skip if no system function|23177
||mov|13,vrfnc(xr)|7,xl||else point vrfnc to svfnc field|23178
||add|7,xl|19,*num02||and bump past svfnc, svnar fields|23179
|gnv18|mov|8,wc|4,btlbl||get test bit|23183
||anb|8,wc|8,wb||and to test|23184
||zrb|8,wc|6,gnv19||jump if bit is off (no system labl)|23185
||mov|13,vrlbl(xr)|7,xl||else point vrlbl to svlbl field|23186
||ica|7,xl|||bump past svlbl field|23187
|gnv19|mov|8,wc|4,btval||load test bit|23191
||anb|8,wc|8,wb||and to test|23192
||zrb|8,wc|6,gnv06||all done if no value|23193
||mov|13,vrval(xr)|9,(xl)||else set initial value|23194
||mov|13,vrsto(xr)|22,=b_vre||set error store access|23195
||brn|6,gnv06|||merge back to exit to caller|23196
||enp||||end procedure gtnvr|23197
||ejc|||||23198
|gtpat|prc|25,e|1,1||entry point|23213
||bhi|9,(xr)|22,=p_aaa|6,gtpt5|jump if pattern already|23215
||mov|3,gtpsb|8,wb||save wb|23219
||mov|11,-(xs)|7,xr||stack argument for gtstg|23220
||jsr|6,gtstg|||convert argument to string|23221
||ppm|6,gtpt2|||jump if impossible|23222
||bnz|8,wa|6,gtpt1||jump if non-null|23226
||mov|7,xr|21,=ndnth||point to nothen node|23230
||brn|6,gtpt4|||jump to exit|23231
||ejc|||||23232
|gtpt1|mov|8,wb|22,=p_str||load pcode for multi-char string|23238
||bne|8,wa|18,=num01|6,gtpt3|jump if multi-char string|23239
||plc|7,xr|||point to character|23243
||lch|8,wa|9,(xr)||load character|23244
||mov|7,xr|8,wa||set as parm1|23245
||mov|8,wb|22,=p_ans||point to pcode for 1-char any|23246
||brn|6,gtpt3|||jump to build node|23247
|gtpt2|mov|8,wb|22,=p_exa||set pcode for expression in case|23251
||blo|9,(xr)|22,=b_e__|6,gtpt3|jump to build node if expression|23252
||exi|1,1|||take convert error exit|23256
|gtpt3|jsr|6,pbild|||call routine to build pattern node|23260
|gtpt4|mov|8,wb|3,gtpsb||restore wb|23264
|gtpt5|exi||||return to gtpat caller|23268
||enp||||end procedure gtpat|23269
||ejc|||||23272
|gtrea|prc|25,e|1,1||entry point|23286
||mov|8,wa|9,(xr)||get first word of block|23287
||beq|8,wa|22,=b_rcl|6,gtre2|jump if real|23288
||jsr|6,gtnum|||else convert argument to numeric|23289
||ppm|6,gtre3|||jump if unconvertible|23290
||beq|8,wa|22,=b_rcl|6,gtre2|jump if real was returned|23291
|gtre1|ldi|13,icval(xr)|||load integer|23295
||itr||||convert to real|23296
||jsr|6,rcbld|||build rcblk|23297
|gtre2|exi||||return to gtrea caller|23301
|gtre3|exi|1,1|||take convert error exit|23305
||enp||||end procedure gtrea|23306
||ejc|||||23308
|gtsmi|prc|25,n|1,2||entry point|23328
||mov|7,xr|10,(xs)+||load argument|23329
||beq|9,(xr)|22,=b_icl|6,gtsm1|skip if already an integer|23330
||jsr|6,gtint|||convert argument to integer|23334
||ppm|6,gtsm2|||jump if convert is impossible|23335
|gtsm1|ldi|13,icval(xr)|||load integer value|23339
||mfi|8,wc|6,gtsm3||move as one word, jump if ovflow|23340
||bgt|8,wc|3,mxlen|6,gtsm3|or if too large|23341
||mov|7,xr|8,wc||copy result to xr|23342
||exi||||return to gtsmi caller|23343
|gtsm2|exi|1,1|||take non-integer error exit|23347
|gtsm3|exi|1,2|||take out-of-range error exit|23351
||enp||||end procedure gtsmi|23352
||ejc|||||23353
|gtstg|prc|25,n|1,1||entry point|23419
||mov|7,xr|10,(xs)+||load argument, pop stack|23420
||beq|9,(xr)|22,=b_scl|6,gts30|jump if already a string|23421
|gts01|mov|11,-(xs)|7,xr||restack argument in case error|23425
||mov|11,-(xs)|7,xl||save xl|23426
||mov|3,gtsvb|8,wb||save wb|23427
||mov|3,gtsvc|8,wc||save wc|23428
||mov|8,wa|9,(xr)||load first word of block|23429
||beq|8,wa|22,=b_icl|6,gts05|jump to convert integer|23430
||beq|8,wa|22,=b_rcl|6,gts10|jump to convert real|23433
||beq|8,wa|22,=b_nml|6,gts03|jump to convert name|23435
|gts02|mov|7,xl|10,(xs)+||restore xl|23443
||mov|7,xr|10,(xs)+||reload input argument|23444
||exi|1,1|||take convert error exit|23445
||ejc|||||23446
|gts03|mov|7,xl|13,nmbas(xr)||load name base|23452
||bhi|7,xl|3,state|6,gts02|error if not natural var (static)|23453
||add|7,xl|19,*vrsof||else point to possible string name|23454
||mov|8,wa|13,sclen(xl)||load length|23455
||bnz|8,wa|6,gts04||jump if not system variable|23456
||mov|7,xl|13,vrsvo(xl)||else point to svblk|23457
||mov|8,wa|13,svlen(xl)||and load name length|23458
|gts04|zer|8,wb|||set offset to zero|23462
||jsr|6,sbstr|||use sbstr to copy string|23463
||brn|6,gts29|||jump to exit|23464
|gts05|ldi|13,icval(xr)|||load integer value|23468
||mov|3,gtssf|18,=num01||set sign flag negative|23476
||ilt|6,gts06|||skip if integer is negative|23477
||ngi||||else negate integer|23478
||zer|3,gtssf|||and reset negative flag|23479
||ejc|||||23480
|gts06|mov|7,xr|3,gtswk||point to result work area|23487
||mov|8,wb|18,=nstmx||initialize counter to max length|23488
||psc|7,xr|8,wb||prepare to store (right-left)|23489
|gts07|cvd||||convert one digit into wa|23493
||sch|8,wa|11,-(xr)||store in work area|23494
||dcv|8,wb|||decrement counter|23495
||ine|6,gts07|||loop if more digits to go|23496
||csc|7,xr|||complete store characters|23497
|gts08|mov|8,wa|18,=nstmx||get max number of characters|23503
||sub|8,wa|8,wb||compute length of result|23504
||mov|7,xl|8,wa||remember length for move later on|23505
||add|8,wa|3,gtssf||add one for negative sign if needed|23506
||jsr|6,alocs|||allocate string for result|23507
||mov|8,wc|7,xr||save result pointer for the moment|23508
||psc|7,xr|||point to chars of result block|23509
||bze|3,gtssf|6,gts09||skip if positive|23510
||mov|8,wa|18,=ch_mn||else load negative sign|23511
||sch|8,wa|10,(xr)+||and store it|23512
||csc|7,xr|||complete store characters|23513
|gts09|mov|8,wa|7,xl||recall length to move|23517
||mov|7,xl|3,gtswk||point to result work area|23518
||plc|7,xl|8,wb||point to first result character|23519
||mvc||||move chars to result string|23520
||mov|7,xr|8,wc||restore result pointer|23521
||brn|6,gts29|||jump to exit|23524
||ejc|||||23525
|gts10|ldr|13,rcval(xr)|||load real|23531
||zer|3,gtssf|||reset negative flag|23543
||req|6,gts31|||skip if zero|23544
||rge|6,gts11|||jump if real is positive|23545
||mov|3,gtssf|18,=num01||else set negative flag|23546
||ngr||||and get absolute value of real|23547
|gts11|ldi|4,intv0|||initialize exponent to zero|23551
|gts12|str|3,gtsrs|||save real value|23555
||sbr|4,reap1|||subtract 0.1 to compare|23556
||rge|6,gts13|||jump if scale up not required|23557
||ldr|3,gtsrs|||else reload value|23558
||mlr|4,reatt|||multiply by 10**10|23559
||sbi|4,intvt|||decrement exponent by 10|23560
||brn|6,gts12|||loop back to test again|23561
|gts13|ldr|3,gtsrs|||reload value|23565
||sbr|4,reav1|||subtract 1.0|23566
||rlt|6,gts17|||jump if no scale down required|23567
||ldr|3,gtsrs|||else reload value|23568
|gts14|sbr|4,reatt|||subtract 10**10 to compare|23572
||rlt|6,gts15|||jump if large step not required|23573
||ldr|3,gtsrs|||else restore value|23574
||dvr|4,reatt|||divide by 10**10|23575
||str|3,gtsrs|||store new value|23576
||adi|4,intvt|||increment exponent by 10|23577
||brn|6,gts14|||loop back|23578
||ejc|||||23579
|gts15|mov|7,xr|21,=reav1||point to powers of ten table|23586
|gts16|ldr|3,gtsrs|||reload value|23590
||adi|4,intv1|||increment exponent|23591
||add|7,xr|19,*cfp_r||point to next entry in table|23592
||sbr|9,(xr)|||subtract it to compare|23593
||rge|6,gts16|||loop till we find a larger entry|23594
||ldr|3,gtsrs|||then reload the value|23595
||dvr|9,(xr)|||and complete scaling|23596
||str|3,gtsrs|||store value|23597
|gts17|ldr|3,gtsrs|||get value again|23601
||adr|3,gtsrn|||add rounding factor|23602
||str|3,gtsrs|||store result|23603
||sbr|4,reav1|||subtract 1.0 to compare|23608
||rlt|6,gts18|||skip if ok|23609
||adi|4,intv1|||else increment exponent|23610
||ldr|3,gtsrs|||reload value|23611
||dvr|4,reavt|||divide by 10.0 to rescale|23612
||brn|6,gts19|||jump to merge|23613
|gts18|ldr|3,gtsrs|||reload rounded value|23617
||ejc|||||23618
|gts19|mov|7,xl|18,=cfp_s||set num dec digits = cfp_s|23642
||mov|3,gtses|18,=ch_mn||set exponent sign negative|23643
||ilt|6,gts21|||all set if exponent is negative|23644
||mfi|8,wa|||else fetch exponent|23645
||ble|8,wa|18,=cfp_s|6,gts20|skip if we can use special format|23646
||mti|8,wa|||else restore exponent|23647
||ngi||||set negative for cvd|23648
||mov|3,gtses|18,=ch_pl||set plus sign for exponent sign|23649
||brn|6,gts21|||jump to generate exponent|23650
|gts20|sub|7,xl|8,wa||compute digits after decimal point|23654
||ldi|4,intv0|||reset exponent to zero|23655
||ejc|||||23656
|gts21|mov|7,xr|3,gtswk||point to work area|23667
||mov|8,wb|18,=nstmx||set character ctr to max length|23668
||psc|7,xr|8,wb||prepare to store (right to left)|23669
||ieq|6,gts23|||skip exponent if it is zero|23670
|gts22|cvd||||convert a digit into wa|23674
||sch|8,wa|11,-(xr)||store in work area|23675
||dcv|8,wb|||decrement counter|23676
||ine|6,gts22|||loop back if more digits to go|23677
||mov|8,wa|3,gtses||load exponent sign|23681
||sch|8,wa|11,-(xr)||store in work area|23682
||mov|8,wa|18,=ch_le||get character letter e|23683
||sch|8,wa|11,-(xr)||store in work area|23684
||sub|8,wb|18,=num02||decrement counter for sign and e|23685
|gts23|mlr|3,gtssc|||convert real to integer (10**cfp_s)|23689
||rti||||get integer (overflow impossible)|23690
||ngi||||negate as required by cvd|23691
|gts24|bze|7,xl|6,gts27||jump if no digits left to do|23695
||cvd||||else convert one digit|23696
||bne|8,wa|18,=ch_d0|6,gts26|jump if not a zero|23697
||dcv|7,xl|||decrement counter|23698
||brn|6,gts24|||loop back for next digit|23699
||ejc|||||23700
|gts25|cvd||||convert a digit into wa|23706
|gts26|sch|8,wa|11,-(xr)||store digit|23710
||dcv|8,wb|||decrement counter|23711
||dcv|7,xl|||decrement counter|23712
||bnz|7,xl|6,gts25||loop back if more to go|23713
|gts27|mov|8,wa|18,=ch_dt||load decimal point|23717
||sch|8,wa|11,-(xr)||store in work area|23718
||dcv|8,wb|||decrement counter|23719
|gts28|cvd||||convert a digit into wa|23723
||sch|8,wa|11,-(xr)||store in work area|23724
||dcv|8,wb|||decrement counter|23725
||ine|6,gts28|||loop back if more to go|23726
||csc|7,xr|||complete store characters|23727
||brn|6,gts08|||else jump back to exit|23728
|gts29|mov|7,xl|10,(xs)+||restore xl|23734
||ica|7,xs|||pop argument|23735
||mov|8,wb|3,gtsvb||restore wb|23736
||mov|8,wc|3,gtsvc||restore wc|23737
|gts30|mov|8,wa|13,sclen(xr)||load string length|23741
||exi||||return to caller|23742
|gts31|mov|7,xl|21,=scre0||point to string|23748
||mov|8,wa|18,=num02||2 chars|23749
||zer|8,wb|||zero offset|23750
||jsr|6,sbstr|||copy string|23751
||brn|6,gts29|||return|23752
||enp||||end procedure gtstg|23779
||ejc|||||23780
|gtvar|prc|25,e|1,1||entry point|23795
||bne|9,(xr)|22,=b_nml|6,gtvr2|jump if not a name|23796
||mov|8,wa|13,nmofs(xr)||else load name offset|23797
||mov|7,xl|13,nmbas(xr)||load name base|23798
||beq|9,(xl)|22,=b_evt|6,gtvr1|error if expression variable|23799
||bne|9,(xl)|22,=b_kvt|6,gtvr3|all ok if not keyword variable|23800
|gtvr1|exi|1,1|||take convert error exit|23804
|gtvr2|mov|3,gtvrc|8,wc||save wc|23808
||jsr|6,gtnvr|||locate vrblk if possible|23809
||ppm|6,gtvr1|||jump if convert error|23810
||mov|7,xl|7,xr||else copy vrblk name base|23811
||mov|8,wa|19,*vrval||and set offset|23812
||mov|8,wc|3,gtvrc||restore wc|23813
|gtvr3|bhi|7,xl|3,state|6,gtvr4|all ok if not natural variable|23817
||beq|13,vrsto(xl)|22,=b_vre|6,gtvr1|error if protected variable|23818
|gtvr4|exi||||return to caller|23822
||enp||||end procedure gtvar|23823
||ejc|||||23824
||ejc|||||23825
|hashs|prc|25,e|1,0||entry point|23861
||mov|8,wc|18,=e_hnw||get number of words to use|23863
||bze|8,wc|6,hshsa||branch if one character per word|23864
||mov|8,wc|13,sclen(xr)||load string length in characters|23865
||mov|8,wb|8,wc||initialize with length|23866
||bze|8,wc|6,hshs3||jump if null string|23867
||zgb|8,wb|||correct byte ordering if necessary|23868
||ctw|8,wc|1,0||get number of words of chars|23869
||add|7,xr|19,*schar||point to characters of string|23870
||blo|8,wc|18,=e_hnw|6,hshs1|use whole string if short|23871
||mov|8,wc|18,=e_hnw||else set to involve first e_hnw wds|23872
|hshs1|lct|8,wc|8,wc||set counter to control loop|23876
|hshs2|xob|8,wb|10,(xr)+||exclusive or next word of chars|23880
||bct|8,wc|6,hshs2||loop till all processed|23881
|hshs3|zgb|8,wb|||zeroise undefined bits|23885
||anb|8,wb|4,bitsm||ensure in range 0 to cfp_m|23886
||mti|8,wb|||move result as integer|23887
||zer|7,xr|||clear garbage value in xr|23888
||exi||||return to hashs caller|23889
|hshsa|mov|8,wc|13,sclen(xr)||load string length in characters|23893
||mov|8,wb|8,wc||initialize with length|23894
||bze|8,wc|6,hshs3||jump if null string|23895
||zgb|8,wb|||correct byte ordering if necessary|23896
||ctw|8,wc|1,0||get number of words of chars|23897
||plc|7,xr||||23898
||mov|11,-(xs)|7,xl||save xl|23899
||mov|7,xl|8,wc||load length for branch|23900
||bge|7,xl|18,=num25|6,hsh24|use first characters if longer|23901
||bsw|7,xl|1,25||merge to compute hash|23902
||iff|1,0|6,hsh00|||23928
||iff|1,1|6,hsh01|||23928
||iff|1,2|6,hsh02|||23928
||iff|1,3|6,hsh03|||23928
||iff|1,4|6,hsh04|||23928
||iff|1,5|6,hsh05|||23928
||iff|1,6|6,hsh06|||23928
||iff|1,7|6,hsh07|||23928
||iff|1,8|6,hsh08|||23928
||iff|1,9|6,hsh09|||23928
||iff|1,10|6,hsh10|||23928
||iff|1,11|6,hsh11|||23928
||iff|1,12|6,hsh12|||23928
||iff|1,13|6,hsh13|||23928
||iff|1,14|6,hsh14|||23928
||iff|1,15|6,hsh15|||23928
||iff|1,16|6,hsh16|||23928
||iff|1,17|6,hsh17|||23928
||iff|1,18|6,hsh18|||23928
||iff|1,19|6,hsh19|||23928
||iff|1,20|6,hsh20|||23928
||iff|1,21|6,hsh21|||23928
||iff|1,22|6,hsh22|||23928
||iff|1,23|6,hsh23|||23928
||iff|1,24|6,hsh24|||23928
||esw|||||23928
|hsh24|lch|8,wc|10,(xr)+||load next character|23929
||lsh|8,wc|1,24||shift for hash|23930
||xob|8,wb|8,wc||hash character|23931
|hsh23|lch|8,wc|10,(xr)+||load next character|23932
||lsh|8,wc|1,16||shift for hash|23933
||xob|8,wb|8,wc||hash character|23934
|hsh22|lch|8,wc|10,(xr)+||load next character|23935
||lsh|8,wc|1,8||shift for hash|23936
||xob|8,wb|8,wc||hash character|23937
|hsh21|lch|8,wc|10,(xr)+||load next character|23938
||xob|8,wb|8,wc||hash character|23939
|hsh20|lch|8,wc|10,(xr)+||load next character|23940
||lsh|8,wc|1,24||shift for hash|23941
||xob|8,wb|8,wc||hash character|23942
|hsh19|lch|8,wc|10,(xr)+||load next character|23943
||lsh|8,wc|1,16||shift for hash|23944
||xob|8,wb|8,wc||hash character|23945
|hsh18|lch|8,wc|10,(xr)+||load next character|23946
||lsh|8,wc|1,8||shift for hash|23947
||xob|8,wb|8,wc||hash character|23948
|hsh17|lch|8,wc|10,(xr)+||load next character|23949
||xob|8,wb|8,wc||hash character|23950
|hsh16|lch|8,wc|10,(xr)+||load next character|23951
||lsh|8,wc|1,24||shift for hash|23952
||xob|8,wb|8,wc||hash character|23953
|hsh15|lch|8,wc|10,(xr)+||load next character|23954
||lsh|8,wc|1,16||shift for hash|23955
||xob|8,wb|8,wc||hash character|23956
|hsh14|lch|8,wc|10,(xr)+||load next character|23957
||lsh|8,wc|1,8||shift for hash|23958
||xob|8,wb|8,wc||hash character|23959
|hsh13|lch|8,wc|10,(xr)+||load next character|23960
||xob|8,wb|8,wc||hash character|23961
|hsh12|lch|8,wc|10,(xr)+||load next character|23962
||lsh|8,wc|1,24||shift for hash|23963
||xob|8,wb|8,wc||hash character|23964
|hsh11|lch|8,wc|10,(xr)+||load next character|23965
||lsh|8,wc|1,16||shift for hash|23966
||xob|8,wb|8,wc||hash character|23967
|hsh10|lch|8,wc|10,(xr)+||load next character|23968
||lsh|8,wc|1,8||shift for hash|23969
||xob|8,wb|8,wc||hash character|23970
|hsh09|lch|8,wc|10,(xr)+||load next character|23971
||xob|8,wb|8,wc||hash character|23972
|hsh08|lch|8,wc|10,(xr)+||load next character|23973
||lsh|8,wc|1,24||shift for hash|23974
||xob|8,wb|8,wc||hash character|23975
|hsh07|lch|8,wc|10,(xr)+||load next character|23976
||lsh|8,wc|1,16||shift for hash|23977
||xob|8,wb|8,wc||hash character|23978
|hsh06|lch|8,wc|10,(xr)+||load next character|23979
||lsh|8,wc|1,8||shift for hash|23980
||xob|8,wb|8,wc||hash character|23981
|hsh05|lch|8,wc|10,(xr)+||load next character|23982
||xob|8,wb|8,wc||hash character|23983
|hsh04|lch|8,wc|10,(xr)+||load next character|23984
||lsh|8,wc|1,24||shift for hash|23985
||xob|8,wb|8,wc||hash character|23986
|hsh03|lch|8,wc|10,(xr)+||load next character|23987
||lsh|8,wc|1,16||shift for hash|23988
||xob|8,wb|8,wc||hash character|23989
|hsh02|lch|8,wc|10,(xr)+||load next character|23990
||lsh|8,wc|1,8||shift for hash|23991
||xob|8,wb|8,wc||hash character|23992
|hsh01|lch|8,wc|10,(xr)+||load next character|23993
||xob|8,wb|8,wc||hash character|23994
|hsh00|mov|7,xl|10,(xs)+||restore xl|23995
||brn|6,hshs3|||merge to complete hash|23996
||enp||||end procedure hashs|23997
|icbld|prc|25,e|1,0||entry point|24006
||mfi|7,xr|6,icbl1||copy small integers|24008
||ble|7,xr|18,=num02|6,icbl3|jump if 0,1 or 2|24009
|icbl1|mov|7,xr|3,dnamp||load pointer to next available loc|24013
||add|7,xr|19,*icsi_||point past new icblk|24014
||blo|7,xr|3,dname|6,icbl2|jump if there is room|24015
||mov|8,wa|19,*icsi_||else load length of icblk|24016
||jsr|6,alloc|||use standard allocator to get block|24017
||add|7,xr|8,wa||point past block to merge|24018
|icbl2|mov|3,dnamp|7,xr||set new pointer|24022
||sub|7,xr|19,*icsi_||point back to start of block|24023
||mov|9,(xr)|22,=b_icl||store type word|24024
||sti|13,icval(xr)|||store integer value in icblk|24025
||exi||||return to icbld caller|24026
|icbl3|wtb|7,xr|||convert integer to offset|24030
||mov|7,xr|14,intab(xr)||point to pre-built icblk|24031
||exi||||return|24032
||enp||||end procedure icbld|24033
||ejc|||||24034
|ident|prc|25,e|1,1||entry point|24048
||beq|7,xr|7,xl|6,iden7|jump if same pointer (ident)|24049
||mov|8,wc|9,(xr)||else load arg 1 type word|24050
||bne|8,wc|9,(xl)|6,iden1|differ if arg 2 type word differ|24052
||beq|8,wc|22,=b_scl|6,iden2|jump if strings|24056
||beq|8,wc|22,=b_icl|6,iden4|jump if integers|24057
||beq|8,wc|22,=b_rcl|6,iden5|jump if reals|24060
||beq|8,wc|22,=b_nml|6,iden6|jump if names|24062
|iden1|exi||||take differ exit|24105
|iden2|mov|8,wc|13,sclen(xr)||load arg 1 length|24109
||bne|8,wc|13,sclen(xl)|6,iden1|differ if lengths differ|24110
|idn2a|add|7,xr|19,*schar||point to chars of arg 1|24114
||add|7,xl|19,*schar||point to chars of arg 2|24115
||ctw|8,wc|1,0||get number of words in strings|24116
||lct|8,wc|8,wc||set loop counter|24117
|iden3|cne|9,(xr)|9,(xl)|6,iden8|differ if chars do not match|24122
||ica|7,xr|||else bump arg one pointer|24123
||ica|7,xl|||bump arg two pointer|24124
||bct|8,wc|6,iden3||loop back till all checked|24125
||ejc|||||24126
||zer|7,xl|||clear garbage value in xl|24132
||zer|7,xr|||clear garbage value in xr|24133
||exi|1,1|||take ident exit|24134
|iden4|ldi|13,icval(xr)|||load arg 1|24138
||sbi|13,icval(xl)|||subtract arg 2 to compare|24139
||iov|6,iden1|||differ if overflow|24140
||ine|6,iden1|||differ if result is not zero|24141
||exi|1,1|||take ident exit|24142
|iden5|ldr|13,rcval(xr)|||load arg 1|24148
||sbr|13,rcval(xl)|||subtract arg 2 to compare|24149
||rov|6,iden1|||differ if overflow|24150
||rne|6,iden1|||differ if result is not zero|24151
||exi|1,1|||take ident exit|24152
|iden6|bne|13,nmofs(xr)|13,nmofs(xl)|6,iden1|differ if different offset|24157
||bne|13,nmbas(xr)|13,nmbas(xl)|6,iden1|differ if different base|24158
|iden7|exi|1,1|||take ident exit|24162
|iden8|zer|7,xr|||clear garbage ptr in xr|24166
||zer|7,xl|||clear garbage ptr in xl|24167
||exi||||return to caller (differ)|24168
||enp||||end procedure ident|24169
||ejc|||||24170
|inout|prc|25,e|1,0||entry point|24185
||mov|11,-(xs)|8,wb||stack trblk type|24186
||mov|8,wa|13,sclen(xl)||get name length|24187
||zer|8,wb|||point to start of name|24188
||jsr|6,sbstr|||build a proper scblk|24189
||jsr|6,gtnvr|||build vrblk|24190
||ppm||||no error return|24191
||mov|8,wc|7,xr||save vrblk pointer|24192
||mov|8,wb|10,(xs)+||get trter field|24193
||zer|7,xl|||zero trfpt|24194
||jsr|6,trbld|||build trblk|24195
||mov|7,xl|8,wc||recall vrblk pointer|24196
||mov|13,trter(xr)|13,vrsvp(xl)||store svblk pointer|24197
||mov|13,vrval(xl)|7,xr||store trblk ptr in vrblk|24198
||mov|13,vrget(xl)|22,=b_vra||set trapped access|24199
||mov|13,vrsto(xl)|22,=b_vrv||set trapped store|24200
||exi||||return to caller|24201
||enp||||end procedure inout|24202
||ejc|||||24203
|insta|prc|25,e|1,0||entry point|24382
||mov|8,wc|3,prlen||no. of chars in print bfr|24387
||mov|3,prbuf|7,xr||print bfr is put at static start|24388
||mov|10,(xr)+|22,=b_scl||store string type code|24389
||mov|10,(xr)+|8,wc||and string length|24390
||ctw|8,wc|1,0||get number of words in buffer|24391
||mov|3,prlnw|8,wc||store for buffer clear|24392
||lct|8,wc|8,wc||words to clear|24393
|inst1|mov|10,(xr)+|4,nullw||store blank|24397
||bct|8,wc|6,inst1||loop|24398
||mov|8,wa|18,=nstmx||get max num chars in output number|24402
||ctb|8,wa|2,scsi_||no of bytes needed|24403
||mov|3,gtswk|7,xr||store bfr adrs|24404
||add|7,xr|8,wa||bump for work bfr|24405
||mov|3,kvalp|7,xr||save alphabet pointer|24409
||mov|9,(xr)|22,=b_scl||string blk type|24410
||mov|8,wc|18,=cfp_a||no of chars in alphabet|24411
||mov|13,sclen(xr)|8,wc||store as string length|24412
||mov|8,wb|8,wc||copy char count|24413
||ctb|8,wb|2,scsi_||no. of bytes needed|24414
||add|8,wb|7,xr||current end address for static|24415
||mov|8,wa|8,wb||save adrs past alphabet string|24416
||lct|8,wc|8,wc||loop counter|24417
||psc|7,xr|||point to chars of string|24418
||zer|8,wb|||set initial character value|24419
|inst2|sch|8,wb|10,(xr)+||store next code|24423
||icv|8,wb|||bump code value|24424
||bct|8,wc|6,inst2||loop till all stored|24425
||csc|7,xr|||complete store characters|24426
||mov|7,xr|8,wa||return current static ptr|24427
||exi||||return to caller|24428
||enp||||end procedure insta|24429
||ejc|||||24430
|iofcb|prc|25,n|1,3||entry point|24448
||jsr|6,gtstg|||get arg as string|24450
||ppm|6,iofc2|||fail|24451
||mov|7,xl|7,xr||copy string ptr|24452
||jsr|6,gtnvr|||get as natural variable|24453
||ppm|6,iofc3|||fail if null|24454
||mov|8,wb|7,xl||copy string pointer again|24455
||mov|7,xl|7,xr||copy vrblk ptr for return|24456
||zer|8,wa|||in case no trblk found|24457
|iofc1|mov|7,xr|13,vrval(xr)||get possible trblk ptr|24461
||bne|9,(xr)|22,=b_trt|6,iofc4|fail if end of chain|24462
||bne|13,trtyp(xr)|18,=trtfc|6,iofc1|loop if not file arg trblk|24463
||mov|8,wa|13,trfpt(xr)||get fcblk ptr|24464
||mov|7,xr|8,wb||copy arg|24465
||exi||||return|24466
|iofc2|exi|1,1|||fail|24470
|iofc3|exi|1,2|||null arg return|24474
|iofc4|exi|1,3|||file not found return|24478
||enp||||end procedure iofcb|24479
||ejc|||||24480
|ioppf|prc|25,n|1,0||entry point|24493
||zer|8,wb|||to count fields extracted|24494
|iopp1|mov|7,xl|18,=iodel||get delimiter|24498
||mov|8,wc|7,xl||copy it|24499
||zer|8,wa|||retain leading blanks in filearg2|24500
||jsr|6,xscan|||get next field|24501
||mov|11,-(xs)|7,xr||stack it|24502
||icv|8,wb|||increment count|24503
||bnz|8,wa|6,iopp1||loop|24504
||mov|8,wc|8,wb||count of fields|24505
||mov|8,wb|3,ioptt||i/o marker|24506
||mov|8,wa|3,r_iof||fcblk ptr or 0|24507
||mov|7,xr|3,r_io2||file arg2 ptr|24508
||mov|7,xl|3,r_io1||filearg1|24509
||exi||||return|24510
||enp||||end procedure ioppf|24511
||ejc|||||24512
||ejc|||||24568
|ioput|prc|25,n|1,7||entry point|24592
||zer|3,r_iot|||in case no trtrf block used|24593
||zer|3,r_iof|||in case no fcblk alocated|24594
||zer|3,r_iop|||in case sysio fails|24595
||mov|3,ioptt|8,wb||store i/o trace type|24596
||jsr|6,xscni|||prepare to scan filearg2|24597
||ppm|6,iop13|||fail|24598
||ppm|6,iopa0|||null file arg2|24599
|iopa0|mov|3,r_io2|7,xr||keep file arg2|24601
||mov|7,xl|8,wa||copy length|24602
||jsr|6,gtstg|||convert filearg1 to string|24603
||ppm|6,iop14|||fail|24604
||mov|3,r_io1|7,xr||keep filearg1 ptr|24605
||jsr|6,gtnvr|||convert to natural variable|24606
||ppm|6,iop00|||jump if null|24607
||brn|6,iop04|||jump to process non-null args|24608
|iop00|bze|7,xl|6,iop01||skip if both args null|24612
||jsr|6,ioppf|||process filearg2|24613
||jsr|6,sysfc|||call for filearg2 check|24614
||ppm|6,iop16|||fail|24615
||ppm|6,iop26|||fail|24616
||brn|6,iop11|||complete file association|24617
||ejc|||||24618
|iop01|mov|8,wb|3,ioptt||get trace type|24624
||mov|7,xr|3,r_iot||get 0 or trtrf ptr|24625
||jsr|6,trbld|||build trblk|24626
||mov|8,wc|7,xr||copy trblk pointer|24627
||mov|7,xr|10,(xs)+||get variable from stack|24628
||mov|11,-(xs)|8,wc||make trblk collectable|24629
||jsr|6,gtvar|||point to variable|24630
||ppm|6,iop15|||fail|24631
||mov|8,wc|10,(xs)+||recover trblk pointer|24632
||mov|3,r_ion|7,xl||save name pointer|24633
||mov|7,xr|7,xl||copy name pointer|24634
||add|7,xr|8,wa||point to variable|24635
||sub|7,xr|19,*vrval||subtract offset,merge into loop|24636
|iop02|mov|7,xl|7,xr||copy blk ptr|24640
||mov|7,xr|13,vrval(xr)||load ptr to next trblk|24641
||bne|9,(xr)|22,=b_trt|6,iop03|jump if not trapped|24642
||bne|13,trtyp(xr)|3,ioptt|6,iop02|loop if not same assocn|24643
||mov|7,xr|13,trnxt(xr)||get value and delete old trblk|24644
|iop03|mov|13,vrval(xl)|8,wc||link to this trblk|24650
||mov|7,xl|8,wc||copy pointer|24651
||mov|13,trnxt(xl)|7,xr||store value in trblk|24652
||mov|7,xr|3,r_ion||restore possible vrblk pointer|24653
||mov|8,wb|8,wa||keep offset to name|24654
||jsr|6,setvr|||if vrblk, set vrget,vrsto|24655
||mov|7,xr|3,r_iot||get 0 or trtrf ptr|24656
||bnz|7,xr|6,iop19||jump if trtrf block exists|24657
||exi||||return to caller|24658
|iop04|zer|8,wa|||in case no fcblk found|24663
||ejc|||||24664
|iop05|mov|8,wb|7,xr||remember blk ptr|24670
||mov|7,xr|13,vrval(xr)||chain along|24671
||bne|9,(xr)|22,=b_trt|6,iop06|jump if end of trblk chain|24672
||bne|13,trtyp(xr)|18,=trtfc|6,iop05|loop if more to go|24673
||mov|3,r_iot|7,xr||point to file arg1 trblk|24674
||mov|8,wa|13,trfpt(xr)||get fcblk ptr from trblk|24675
|iop06|mov|3,r_iof|8,wa||keep possible fcblk ptr|24681
||mov|3,r_iop|8,wb||keep preceding blk ptr|24682
||jsr|6,ioppf|||process filearg2|24683
||jsr|6,sysfc|||see if fcblk required|24684
||ppm|6,iop16|||fail|24685
||ppm|6,iop26|||fail|24686
||bze|8,wa|6,iop12||skip if no new fcblk wanted|24687
||blt|8,wc|18,=num02|6,iop6a|jump if fcblk in dynamic|24688
||jsr|6,alost|||get it in static|24689
||brn|6,iop6b|||skip|24690
|iop6a|jsr|6,alloc|||get space for fcblk|24694
|iop6b|mov|7,xl|7,xr||point to fcblk|24698
||mov|8,wb|8,wa||copy its length|24699
||btw|8,wb|||get count as words (sgd apr80)|24700
||lct|8,wb|8,wb||loop counter|24701
|iop07|zer|10,(xr)+|||clear a word|24705
||bct|8,wb|6,iop07||loop|24706
||beq|8,wc|18,=num02|6,iop09|skip if in static - dont set fields|24707
||mov|9,(xl)|22,=b_xnt||store xnblk code in case|24708
||mov|13,num01(xl)|8,wa||store length|24709
||bnz|8,wc|6,iop09||jump if xnblk wanted|24710
||mov|9,(xl)|22,=b_xrt||xrblk code requested|24711
||ejc|||||24713
|iop09|mov|7,xr|3,r_iot||get possible trblk ptr|24718
||mov|3,r_iof|7,xl||store fcblk ptr|24719
||bnz|7,xr|6,iop10||jump if trblk already found|24720
||mov|8,wb|18,=trtfc||trtyp for fcblk trap blk|24724
||jsr|6,trbld|||make the block|24725
||mov|3,r_iot|7,xr||copy trtrf ptr|24726
||mov|7,xl|3,r_iop||point to preceding blk|24727
||mov|13,vrval(xr)|13,vrval(xl)||copy value field to trblk|24728
||mov|13,vrval(xl)|7,xr||link new trblk into chain|24729
||mov|7,xr|7,xl||point to predecessor blk|24730
||jsr|6,setvr|||set trace intercepts|24731
||mov|7,xr|13,vrval(xr)||recover trblk ptr|24732
||brn|6,iop1a|||store fcblk ptr|24733
|iop10|zer|3,r_iop|||do not release if sysio fails|24737
|iop1a|mov|13,trfpt(xr)|3,r_iof||store fcblk ptr|24741
|iop11|mov|8,wa|3,r_iof||copy fcblk ptr or 0|24745
||mov|8,wb|3,ioptt||get input/output flag|24746
||mov|7,xr|3,r_io2||get file arg2|24747
||mov|7,xl|3,r_io1||get file arg1|24748
||jsr|6,sysio|||associate to the file|24749
||ppm|6,iop17|||fail|24750
||ppm|6,iop18|||fail|24751
||bnz|3,r_iot|6,iop01||not std input if non-null trtrf blk|24752
||bnz|3,ioptt|6,iop01||jump if output|24753
||bze|8,wc|6,iop01||no change to standard read length|24754
||mov|3,cswin|8,wc||store new read length for std file|24755
||brn|6,iop01|||merge to finish the task|24756
|iop12|bnz|7,xl|6,iop09||jump if private fcblk|24760
||brn|6,iop11|||finish the association|24761
|iop13|exi|1,1|||3rd arg not a string|24765
|iop14|exi|1,2|||2nd arg unsuitable|24766
|iop15|ica|7,xs|||discard trblk pointer|24767
||exi|1,3|||1st arg unsuitable|24768
|iop16|exi|1,4|||file spec wrong|24769
|iop26|exi|1,7|||fcblk in use|24770
|iop17|mov|7,xr|3,r_iop||is there a trblk to release|24774
||bze|7,xr|6,iopa7||if not|24775
||mov|7,xl|13,vrval(xr)||point to trblk|24776
||mov|13,vrval(xr)|13,vrval(xl)||unsplice it|24777
||jsr|6,setvr|||adjust trace intercepts|24778
|iopa7|exi|1,5|||i/o file does not exist|24779
|iop18|mov|7,xr|3,r_iop||is there a trblk to release|24783
||bze|7,xr|6,iopa7||if not|24784
||mov|7,xl|13,vrval(xr)||point to trblk|24785
||mov|13,vrval(xr)|13,vrval(xl)||unsplice it|24786
||jsr|6,setvr|||adjust trace intercepts|24787
|iopa8|exi|1,6|||i/o file cannot be read/written|24788
||ejc|||||24789
|iop19|mov|8,wc|3,r_ion||wc = name base, wb = name offset|24796
|iop20|mov|7,xr|13,trtrf(xr)||next link of chain|24800
||bze|7,xr|6,iop21||not found|24801
||bne|8,wc|13,ionmb(xr)|6,iop20|no match|24802
||beq|8,wb|13,ionmo(xr)|6,iop22|exit if matched|24803
||brn|6,iop20|||loop|24804
|iop21|mov|8,wa|19,*num05||space needed|24808
||jsr|6,alloc|||get it|24809
||mov|9,(xr)|22,=b_xrt||store xrblk code|24810
||mov|13,num01(xr)|8,wa||store length|24811
||mov|13,ionmb(xr)|8,wc||store name base|24812
||mov|13,ionmo(xr)|8,wb||store name offset|24813
||mov|7,xl|3,r_iot||point to trtrf blk|24814
||mov|8,wa|13,trtrf(xl)||get ptr field contents|24815
||mov|13,trtrf(xl)|7,xr||store ptr to new block|24816
||mov|13,trtrf(xr)|8,wa||complete the linking|24817
|iop22|bze|3,r_iof|6,iop25||skip if no fcblk|24821
||mov|7,xl|3,r_fcb||ptr to head of existing chain|24822
|iop23|bze|7,xl|6,iop24||not on if end of chain|24826
||beq|13,num03(xl)|3,r_iof|6,iop25|dont duplicate if find it|24827
||mov|7,xl|13,num02(xl)||get next link|24828
||brn|6,iop23|||loop|24829
|iop24|mov|8,wa|19,*num04||space needed|24833
||jsr|6,alloc|||get it|24834
||mov|9,(xr)|22,=b_xrt||store block code|24835
||mov|13,num01(xr)|8,wa||store length|24836
||mov|13,num02(xr)|3,r_fcb||store previous link in this node|24837
||mov|13,num03(xr)|3,r_iof||store fcblk ptr|24838
||mov|3,r_fcb|7,xr||insert node into fcblk chain|24839
|iop25|exi||||return to caller|24843
||enp||||end procedure ioput|24844
||ejc|||||24845
|ktrex|prc|25,r|1,0||entry point (recursive)|24857
||bze|7,xl|6,ktrx3||immediate exit if keyword untraced|24858
||bze|3,kvtra|6,ktrx3||immediate exit if trace = 0|24859
||dcv|3,kvtra|||else decrement trace|24860
||mov|11,-(xs)|7,xr||save xr|24861
||mov|7,xr|7,xl||copy trblk pointer|24862
||mov|7,xl|13,trkvr(xr)||load vrblk pointer (nmbas)|24863
||mov|8,wa|19,*vrval||set name offset|24864
||bze|13,trfnc(xr)|6,ktrx1||jump if print trace|24865
||jsr|6,trxeq|||else execute full trace|24866
||brn|6,ktrx2|||and jump to exit|24867
|ktrx1|mov|11,-(xs)|7,xl||stack vrblk ptr for kwnam|24871
||mov|11,-(xs)|8,wa||stack offset for kwnam|24872
||jsr|6,prtsn|||print statement number|24873
||mov|8,wa|18,=ch_am||load ampersand|24874
||jsr|6,prtch|||print ampersand|24875
||jsr|6,prtnm|||print keyword name|24876
||mov|7,xr|21,=tmbeb||point to blank-equal-blank|24877
||jsr|6,prtst|||print blank-equal-blank|24878
||jsr|6,kwnam|||get keyword pseudo-variable name|24879
||mov|3,dnamp|7,xr||reset ptr to delete kvblk|24880
||jsr|6,acess|||get keyword value|24881
||ppm||||failure is impossible|24882
||jsr|6,prtvl|||print keyword value|24883
||jsr|6,prtnl|||terminate print line|24884
|ktrx2|mov|7,xr|10,(xs)+||restore entry xr|24888
|ktrx3|exi||||return to ktrex caller|24892
||enp||||end procedure ktrex|24893
||ejc|||||24894
|kwnam|prc|25,n|1,0||entry point|24905
||ica|7,xs|||ignore name offset|24906
||mov|7,xr|10,(xs)+||load name base|24907
||bge|7,xr|3,state|6,kwnm1|jump if not natural variable name|24908
||bnz|13,vrlen(xr)|6,kwnm1||error if not system variable|24909
||mov|7,xr|13,vrsvp(xr)||else point to svblk|24910
||mov|8,wa|13,svbit(xr)||load bit mask|24911
||anb|8,wa|4,btknm||and with keyword bit|24912
||zrb|8,wa|6,kwnm1||error if no keyword association|24913
||mov|8,wa|13,svlen(xr)||else load name length in characters|24914
||ctb|8,wa|2,svchs||compute offset to field we want|24915
||add|7,xr|8,wa||point to svknm field|24916
||mov|8,wb|9,(xr)||load svknm value|24917
||mov|8,wa|19,*kvsi_||set size of kvblk|24918
||jsr|6,alloc|||allocate kvblk|24919
||mov|9,(xr)|22,=b_kvt||store type word|24920
||mov|13,kvnum(xr)|8,wb||store keyword number|24921
||mov|13,kvvar(xr)|21,=trbkv||set dummy trblk pointer|24922
||mov|7,xl|7,xr||copy kvblk pointer|24923
||mov|8,wa|19,*kvvar||set proper offset|24924
||exi||||return to kvnam caller|24925
|kwnm1|erb|1,251|26,keyword operand is not name of defined keyword|||24929
||enp||||end procedure kwnam|24930
||ejc|||||24931
|lcomp|prc|25,n|1,5||entry point|24948
||jsr|6,gtstg|||convert second arg to string|24950
||ppm|6,lcmp6|||jump if second arg not string|24954
||mov|7,xl|7,xr||else save pointer|24955
||mov|8,wc|8,wa||and length|24956
||jsr|6,gtstg|||convert first argument to string|24958
||ppm|6,lcmp5|||jump if not string|24962
||mov|8,wb|8,wa||save arg 1 length|24963
||plc|7,xr|||point to chars of arg 1|24964
||plc|7,xl|||point to chars of arg 2|24965
||blo|8,wa|8,wc|6,lcmp1|jump if arg 1 length is smaller|24977
||mov|8,wa|8,wc||else set arg 2 length as smaller|24978
|lcmp1|bze|8,wa|6,lcmp7||if null string, compare lengths|24982
||cmc|6,lcmp4|6,lcmp3||compare strings, jump if unequal|24983
|lcmp7|bne|8,wb|8,wc|6,lcmp2|if equal, jump if lengths unequal|24984
||exi|1,4|||else identical strings, leq exit|24985
||ejc|||||24986
|lcmp2|bhi|8,wb|8,wc|6,lcmp4|jump if arg 1 length gt arg 2 leng|24992
|lcmp3|exi|1,3|||take llt exit|24997
|lcmp4|exi|1,5|||take lgt exit|25001
|lcmp5|exi|1,1|||take bad first arg exit|25005
|lcmp6|exi|1,2|||take bad second arg error exit|25009
||enp||||end procedure lcomp|25010
||ejc|||||25011
|listr|prc|25,e|1,0||entry point|25050
||bnz|3,cnttl|6,list5||jump if -title or -stitl|25051
||bnz|3,lstpf|6,list4||immediate exit if already listed|25052
||bge|3,lstlc|3,lstnp|6,list6|jump if no room|25053
|list0|mov|7,xr|3,r_cim||load pointer to current image|25057
||bze|7,xr|6,list4||jump if no image to print|25058
||plc|7,xr|||point to characters|25059
||lch|8,wa|9,(xr)||load first character|25060
||mov|7,xr|3,lstsn||load statement number|25061
||bze|7,xr|6,list2||jump if no statement number|25062
||mti|7,xr|||else get stmnt number as integer|25063
||bne|3,stage|18,=stgic|6,list1|skip if execute time|25064
||beq|8,wa|18,=ch_as|6,list2|no stmnt number list if comment|25065
||beq|8,wa|18,=ch_mn|6,list2|no stmnt no. if control card|25066
|list1|jsr|6,prtin|||else print statement number|25070
||zer|3,lstsn|||and clear for next time in|25071
|list2|mov|7,xr|3,lstid||include depth of image|25076
||bze|7,xr|6,list8||if not from an include file|25077
||mov|8,wa|18,=stnpd||position for start of statement|25078
||sub|8,wa|18,=num03||position to place include depth|25079
||mov|3,profs|8,wa||set as starting position|25080
||mti|7,xr|||include depth as integer|25081
||jsr|6,prtin|||print include depth|25082
||ejc|||||25083
|list8|mov|3,profs|18,=stnpd||point past statement number|25089
||mov|7,xr|3,r_cim||load pointer to current image|25099
||jsr|6,prtst|||print it|25100
||icv|3,lstlc|||bump line counter|25101
||bnz|3,erlst|6,list3||jump if error copy to int.ch.|25102
||jsr|6,prtnl|||terminate line|25103
||bze|3,cswdb|6,list3||jump if -single mode|25104
||jsr|6,prtnl|||else add a blank line|25105
||icv|3,lstlc|||and bump line counter|25106
|list3|mnz|3,lstpf|||set flag for line printed|25110
|list4|exi||||return to listr caller|25114
|list5|zer|3,cnttl|||clear flag|25118
|list6|jsr|6,prtps|||eject|25122
||bze|3,prich|6,list7||skip if listing to regular printer|25123
||beq|3,r_ttl|21,=nulls|6,list0|terminal listing omits null title|25124
|list7|jsr|6,listt|||list title|25128
||brn|6,list0|||merge|25129
||enp||||end procedure listr|25130
||ejc|||||25131
|listt|prc|25,e|1,0||entry point|25140
||mov|7,xr|3,r_ttl||point to source listing title|25141
||jsr|6,prtst|||print title|25142
||mov|3,profs|3,lstpo||set offset|25143
||mov|7,xr|21,=lstms||set page message|25144
||jsr|6,prtst|||print page message|25145
||icv|3,lstpg|||bump page number|25146
||mti|3,lstpg|||load page number as integer|25147
||jsr|6,prtin|||print page number|25148
||jsr|6,prtnl|||terminate title line|25149
||add|3,lstlc|18,=num02||count title line and blank line|25150
||mov|7,xr|3,r_stl||load pointer to sub-title|25154
||bze|7,xr|6,lstt1||jump if no sub-title|25155
||jsr|6,prtst|||else print sub-title|25156
||jsr|6,prtnl|||terminate line|25157
||icv|3,lstlc|||bump line count|25158
|lstt1|jsr|6,prtnl|||print a blank line|25162
||exi||||return to caller|25163
||enp||||end procedure listt|25164
||ejc|||||25165
|newfn|prc|25,e|1,0||entry point|25182
||mov|11,-(xs)|7,xr||save new name|25183
||mov|7,xl|3,r_sfc||load previous name|25184
||jsr|6,ident|||check for equality|25185
||ppm|6,nwfn1|||jump if identical|25186
||mov|7,xr|10,(xs)+||different, restore name|25187
||mov|3,r_sfc|7,xr||record current file name|25188
||mov|8,wb|3,cmpsn||get current statement|25189
||mti|8,wb|||convert to integer|25190
||jsr|6,icbld|||build icblk for stmt number|25191
||mov|7,xl|3,r_sfn||file name table|25192
||mnz|8,wb|||lookup statement number by name|25193
||jsr|6,tfind|||allocate new teblk|25194
||ppm||||always possible to allocate block|25195
||mov|13,teval(xl)|3,r_sfc||record file name as entry value|25196
||exi|||||25197
|nwfn1|ica|7,xs|||pop stack|25201
||exi|||||25202
||ejc|||||25203
|nexts|prc|25,e|1,0||entry point|25235
||bze|3,cswls|6,nxts2||jump if -nolist|25236
||mov|7,xr|3,r_cim||point to image|25237
||bze|7,xr|6,nxts2||jump if no image|25238
||plc|7,xr|||get char ptr|25239
||lch|8,wa|9,(xr)||get first char|25240
||bne|8,wa|18,=ch_mn|6,nxts1|jump if not ctrl card|25241
||bze|3,cswpr|6,nxts2||jump if -noprint|25242
|nxts1|jsr|6,listr|||list line|25246
|nxts2|mov|7,xr|3,r_cni||point to next image|25250
||mov|3,r_cim|7,xr||set as next image|25251
||mov|3,rdcln|3,rdnln||set as current line number|25252
||mov|3,lstid|3,cnind||set as current include depth|25254
||zer|3,r_cni|||clear next image pointer|25256
||mov|8,wa|13,sclen(xr)||get input image length|25257
||mov|8,wb|3,cswin||get max allowable length|25258
||blo|8,wa|8,wb|6,nxts3|skip if not too long|25259
||mov|8,wa|8,wb||else truncate|25260
|nxts3|mov|3,scnil|8,wa||use as record length|25264
||zer|3,scnse|||reset scnse|25265
||zer|3,lstpf|||set line not listed yet|25266
||exi||||return to nexts caller|25267
||enp||||end procedure nexts|25268
||ejc|||||25269
|patin|prc|25,n|1,2||entry point|25285
||mov|7,xl|8,wa||preserve expression arg pcode|25286
||jsr|6,gtsmi|||try to convert arg as small integer|25287
||ppm|6,ptin2|||jump if not integer|25288
||ppm|6,ptin3|||jump if out of range|25289
|ptin1|jsr|6,pbild|||build pattern node|25293
||exi||||return to caller|25294
|ptin2|mov|8,wb|7,xl||copy expr arg case pcode|25298
||blo|9,(xr)|22,=b_e__|6,ptin1|all ok if expression arg|25299
||exi|1,1|||else take error exit for wrong type|25300
|ptin3|exi|1,2|||take out-of-range error exit|25304
||enp||||end procedure patin|25305
||ejc|||||25306
|patst|prc|25,n|1,1||entry point|25330
||jsr|6,gtstg|||convert argument as string|25331
||ppm|6,pats7|||jump if not string|25332
||bze|8,wa|6,pats7||jump if null string (catspaw)|25333
||bne|8,wa|18,=num01|6,pats2|jump if not one char string|25334
||bze|8,wb|6,pats2||treat as multi-char if evals call|25338
||plc|7,xr|||point to character|25339
||lch|7,xr|9,(xr)||load character|25340
|pats1|jsr|6,pbild|||call routine to build node|25344
||exi||||return to patst caller|25345
||ejc|||||25346
|pats2|mov|11,-(xs)|7,xl||save multi-char pcode|25352
||mov|8,wc|3,ctmsk||load current mask bit|25353
||beq|7,xr|3,r_cts|6,pats6|jump if same as last string c3.738|25354
||mov|11,-(xs)|7,xr||save string pointer|25355
||lsh|8,wc|1,1||shift to next position|25356
||nzb|8,wc|6,pats4||skip if position left in this tbl|25357
||mov|8,wa|19,*ctsi_||set size of ctblk|25361
||jsr|6,alloc|||allocate ctblk|25362
||mov|3,r_ctp|7,xr||store ptr to new ctblk|25363
||mov|10,(xr)+|22,=b_ctt||store type code, bump ptr|25364
||lct|8,wb|18,=cfp_a||set number of words to clear|25365
||mov|8,wc|4,bits0||load all zero bits|25366
|pats3|mov|10,(xr)+|8,wc||move word of zero bits|25370
||bct|8,wb|6,pats3||loop till all cleared|25371
||mov|8,wc|4,bits1||set initial bit position|25372
|pats4|mov|3,ctmsk|8,wc||save parm2 (new bit position)|25376
||mov|7,xl|10,(xs)+||restore pointer to argument string|25377
||mov|3,r_cts|7,xl||save for next time   c3.738|25378
||mov|8,wb|13,sclen(xl)||load string length|25379
||bze|8,wb|6,pats6||jump if null string case|25380
||lct|8,wb|8,wb||else set loop counter|25381
||plc|7,xl|||point to characters in argument|25382
||ejc|||||25383
|pats5|lch|8,wa|10,(xl)+||load next character|25389
||wtb|8,wa|||convert to byte offset|25390
||mov|7,xr|3,r_ctp||point to ctblk|25391
||add|7,xr|8,wa||point to ctblk entry|25392
||mov|8,wa|8,wc||copy bit mask|25393
||orb|8,wa|13,ctchs(xr)||or in bits already set|25394
||mov|13,ctchs(xr)|8,wa||store resulting bit string|25395
||bct|8,wb|6,pats5||loop till all bits set|25396
|pats6|mov|7,xr|3,r_ctp||load ctblk ptr as parm1 for pbild|25400
||zer|7,xl|||clear garbage ptr in xl|25401
||mov|8,wb|10,(xs)+||load pcode for multi-char str case|25402
||brn|6,pats1|||back to exit (wc=bitstring=parm2)|25403
|pats7|mov|8,wb|8,wc||set pcode for expression argument|25410
||blo|9,(xr)|22,=b_e__|6,pats1|jump to exit if expression arg|25411
||exi|1,1|||else take wrong type error exit|25412
||enp||||end procedure patst|25413
||ejc|||||25414
|pbild|prc|25,e|1,0||entry point|25425
||mov|11,-(xs)|7,xr||stack possible parm1|25426
||mov|7,xr|8,wb||copy pcode|25427
||lei|7,xr|||load entry point id (bl_px)|25428
||beq|7,xr|18,=bl_p1|6,pbld1|jump if one parameter|25429
||beq|7,xr|18,=bl_p0|6,pbld3|jump if no parameters|25430
||mov|8,wa|19,*pcsi_||set size of p2blk|25434
||jsr|6,alloc|||allocate block|25435
||mov|13,parm2(xr)|8,wc||store second parameter|25436
||brn|6,pbld2|||merge with one parm case|25437
|pbld1|mov|8,wa|19,*pbsi_||set size of p1blk|25441
||jsr|6,alloc|||allocate node|25442
|pbld2|mov|13,parm1(xr)|9,(xs)||store first parameter|25446
||brn|6,pbld4|||merge with no parameter case|25447
|pbld3|mov|8,wa|19,*pasi_||set size of p0blk|25451
||jsr|6,alloc|||allocate node|25452
|pbld4|mov|9,(xr)|8,wb||store pcode|25456
||ica|7,xs|||pop first parameter|25457
||mov|13,pthen(xr)|21,=ndnth||set nothen successor pointer|25458
||exi||||return to pbild caller|25459
||enp||||end procedure pbild|25460
||ejc|||||25461
|pconc|prc|25,e|1,0||entry point|25496
||zer|11,-(xs)|||make room for one entry at bottom|25497
||mov|8,wc|7,xs||store pointer to start of list|25498
||mov|11,-(xs)|21,=ndnth||stack nothen node as old node|25499
||mov|11,-(xs)|7,xl||store right arg as copy of nothen|25500
||mov|7,xt|7,xs||initialize pointer to stack entries|25501
||jsr|6,pcopy|||copy first node of left arg|25502
||mov|13,num02(xt)|8,wa||store as result under list|25503
||ejc|||||25504
|pcnc1|beq|7,xt|7,xs|6,pcnc2|jump if all entries processed|25511
||mov|7,xr|11,-(xt)||else load next old address|25512
||mov|7,xr|13,pthen(xr)||load pointer to successor|25513
||jsr|6,pcopy|||copy successor node|25514
||mov|7,xr|11,-(xt)||load pointer to new node (copy)|25515
||mov|13,pthen(xr)|8,wa||store ptr to new successor|25516
||bne|9,(xr)|22,=p_alt|6,pcnc1|loop back if not|25521
||mov|7,xr|13,parm1(xr)||else load pointer to alternative|25522
||jsr|6,pcopy|||copy it|25523
||mov|7,xr|9,(xt)||restore ptr to new node|25524
||mov|13,parm1(xr)|8,wa||store ptr to copied alternative|25525
||brn|6,pcnc1|||loop back for next entry|25526
|pcnc2|mov|7,xs|8,wc||restore stack pointer|25530
||mov|7,xr|10,(xs)+||load pointer to copy|25531
||exi||||return to pconc caller|25532
||enp||||end procedure pconc|25533
||ejc|||||25534
|pcopy|prc|25,n|1,0||entry point|25549
||mov|8,wb|7,xt||save xt|25550
||mov|7,xt|8,wc||point to start of list|25551
|pcop1|dca|7,xt|||point to next entry on list|25555
||beq|7,xr|9,(xt)|6,pcop2|jump if match|25556
||dca|7,xt|||else skip over copied address|25557
||bne|7,xt|7,xs|6,pcop1|loop back if more to test|25558
||mov|8,wa|9,(xr)||load first word of block|25562
||jsr|6,blkln|||get length of block|25563
||mov|7,xl|7,xr||save pointer to old node|25564
||jsr|6,alloc|||allocate space for copy|25565
||mov|11,-(xs)|7,xl||store old address on list|25566
||mov|11,-(xs)|7,xr||store new address on list|25567
||chk||||check for stack overflow|25568
||mvw||||move words from old block to copy|25569
||mov|8,wa|9,(xs)||load pointer to copy|25570
||brn|6,pcop3|||jump to exit|25571
|pcop2|mov|8,wa|11,-(xt)||load address of copy from list|25575
|pcop3|mov|7,xt|8,wb||restore xt|25579
||exi||||return to pcopy caller|25580
||enp||||end procedure pcopy|25581
||ejc|||||25582
|prflr|prc|25,e|1,0|||25593
||bze|3,pfdmp|6,prfl4||no printing if no profiling done|25594
||mov|11,-(xs)|7,xr||preserve entry xr|25595
||mov|3,pfsvw|8,wb||and also wb|25596
||jsr|6,prtpg|||eject|25597
||mov|7,xr|21,=pfms1||load msg /program profile/|25598
||jsr|6,prtst|||and print it|25599
||jsr|6,prtnl|||followed by newline|25600
||jsr|6,prtnl|||and another|25601
||mov|7,xr|21,=pfms2||point to first hdr|25602
||jsr|6,prtst|||print it|25603
||jsr|6,prtnl|||new line|25604
||mov|7,xr|21,=pfms3||second hdr|25605
||jsr|6,prtst|||print it|25606
||jsr|6,prtnl|||new line|25607
||jsr|6,prtnl|||and another blank line|25608
||zer|8,wb|||initial stmt count|25609
||mov|7,xr|3,pftbl||point to table origin|25610
||add|7,xr|19,*xndta||bias past xnblk header (sgd07)|25611
|prfl1|icv|8,wb|||bump stmt nr|25615
||ldi|9,(xr)|||load nr of executions|25616
||ieq|6,prfl3|||no printing if zero|25617
||mov|3,profs|18,=pfpd1||point where to print|25618
||jsr|6,prtin|||and print it|25619
||zer|3,profs|||back to start of line|25620
||mti|8,wb|||load stmt nr|25621
||jsr|6,prtin|||print it there|25622
||mov|3,profs|18,=pfpd2||and pad past count|25623
||ldi|13,cfp_i(xr)|||load total exec time|25624
||jsr|6,prtin|||print that too|25625
||ldi|13,cfp_i(xr)|||reload time|25626
||mli|4,intth|||convert to microsec|25627
||iov|6,prfl2|||omit next bit if overflow|25628
||dvi|9,(xr)|||divide by executions|25629
||mov|3,profs|18,=pfpd3||pad last print|25630
||jsr|6,prtin|||and print mcsec/execn|25631
|prfl2|jsr|6,prtnl|||thats another line|25635
|prfl3|add|7,xr|19,*pf_i2||bump index ptr (sgd07)|25639
||blt|8,wb|3,pfnte|6,prfl1|loop if more stmts|25640
||mov|7,xr|10,(xs)+||restore callers xr|25641
||mov|8,wb|3,pfsvw||and wb too|25642
|prfl4|exi||||return|25646
||enp||||end of prflr|25647
||ejc|||||25648
|prflu|prc|25,e|1,0|||25657
||bnz|3,pffnc|6,pflu4||skip if just entered function|25658
||mov|11,-(xs)|7,xr||preserve entry xr|25659
||mov|3,pfsvw|8,wa||save wa (sgd07)|25660
||bnz|3,pftbl|6,pflu2||branch if table allocated|25661
||sub|3,pfnte|18,=num01||adjust for extra count (sgd07)|25671
||mti|4,pfi2a|||convrt entry size to int|25672
||sti|3,pfste|||and store safely for later|25673
||mti|3,pfnte|||load table length as integer|25674
||mli|3,pfste|||multiply by entry size|25675
||mfi|8,wa|||get back address-style|25676
||add|8,wa|18,=num02||add on 2 word overhead|25677
||wtb|8,wa|||convert the whole lot to bytes|25678
||jsr|6,alost|||gimme the space|25679
||mov|3,pftbl|7,xr||save block pointer|25680
||mov|10,(xr)+|22,=b_xnt||put block type and ...|25681
||mov|10,(xr)+|8,wa||... length into header|25682
||mfi|8,wa|||get back nr of wds in data area|25683
||lct|8,wa|8,wa||load the counter|25684
|pflu1|zer|10,(xr)+|||blank a word|25688
||bct|8,wa|6,pflu1||and alllllll the rest|25689
|pflu2|mti|3,kvstn|||load nr of stmt just ended|25693
||sbi|4,intv1|||make into index offset|25694
||mli|3,pfste|||make offset of table entry|25695
||mfi|8,wa|||convert to address|25696
||wtb|8,wa|||get as baus|25697
||add|8,wa|19,*num02||offset includes table header|25698
||mov|7,xr|3,pftbl||get table start|25699
||bge|8,wa|13,num01(xr)|6,pflu3|if out of table, skip it|25700
||add|7,xr|8,wa||else point to entry|25701
||ldi|9,(xr)|||get nr of executions so far|25702
||adi|4,intv1|||nudge up one|25703
||sti|9,(xr)|||and put back|25704
||jsr|6,systm|||get time now|25705
||sti|3,pfetm|||stash ending time|25706
||sbi|3,pfstm|||subtract start time|25707
||adi|13,cfp_i(xr)|||add cumulative time so far|25708
||sti|13,cfp_i(xr)|||and put back new total|25709
||ldi|3,pfetm|||load end time of this stmt ...|25710
||sti|3,pfstm|||... which is start time of next|25711
|pflu3|mov|7,xr|10,(xs)+||restore callers xr|25715
||mov|8,wa|3,pfsvw||restore saved reg|25716
||exi||||and return|25717
|pflu4|zer|3,pffnc|||reset the condition flag|25723
||exi||||and immediate return|25724
||enp||||end of procedure prflu|25725
||ejc|||||25726
|prpar|prc|25,e|1,0||entry point|25739
||bnz|8,wc|6,prpa8||jump to associate terminal|25740
||jsr|6,syspp|||get print parameters|25741
||bnz|8,wb|6,prpa1||jump if lines/page specified|25742
||mov|8,wb|3,mxint||else use a large value|25743
||rsh|8,wb|1,1||but not too large|25744
|prpa1|mov|3,lstnp|8,wb||store number of lines/page|25748
||mov|3,lstlc|8,wb||pretend page is full initially|25749
||zer|3,lstpg|||clear page number|25750
||mov|8,wb|3,prlen||get prior length if any|25751
||bze|8,wb|6,prpa2||skip if no length|25752
||bgt|8,wa|8,wb|6,prpa3|skip storing if too big|25753
|prpa2|mov|3,prlen|8,wa||store value|25757
|prpa3|mov|8,wb|4,bits3||bit 3 mask|25761
||anb|8,wb|8,wc||get -nolist bit|25762
||zrb|8,wb|6,prpa4||skip if clear|25763
||zer|3,cswls|||set -nolist|25764
|prpa4|mov|8,wb|4,bits1||bit 1 mask|25768
||anb|8,wb|8,wc||get bit|25769
||mov|3,erich|8,wb||store int. chan. error flag|25770
||mov|8,wb|4,bits2||bit 2 mask|25771
||anb|8,wb|8,wc||get bit|25772
||mov|3,prich|8,wb||flag for std printer on int. chan.|25773
||mov|8,wb|4,bits4||bit 4 mask|25774
||anb|8,wb|8,wc||get bit|25775
||mov|3,cpsts|8,wb||flag for compile stats suppressn.|25776
||mov|8,wb|4,bits5||bit 5 mask|25777
||anb|8,wb|8,wc||get bit|25778
||mov|3,exsts|8,wb||flag for exec stats suppression|25779
||ejc|||||25780
||mov|8,wb|4,bits6||bit 6 mask|25784
||anb|8,wb|8,wc||get bit|25785
||mov|3,precl|8,wb||extended/compact listing flag|25786
||sub|8,wa|18,=num08||point 8 chars from line end|25787
||zrb|8,wb|6,prpa5||jump if not extended|25788
||mov|3,lstpo|8,wa||store for listing page headings|25789
|prpa5|mov|8,wb|4,bits7||bit 7 mask|25793
||anb|8,wb|8,wc||get bit 7|25794
||mov|3,cswex|8,wb||set -noexecute if non-zero|25795
||mov|8,wb|4,bit10||bit 10 mask|25796
||anb|8,wb|8,wc||get bit 10|25797
||mov|3,headp|8,wb||pretend printed to omit headers|25798
||mov|8,wb|4,bits9||bit 9 mask|25799
||anb|8,wb|8,wc||get bit 9|25800
||mov|3,prsto|8,wb||keep it as std listing option|25801
||mov|8,wb|8,wc||copy flags|25803
||rsh|8,wb|1,12||right justify bit 13|25804
||anb|8,wb|4,bits1||get bit|25805
||mov|3,kvcas|8,wb||set -case|25806
||mov|8,wb|4,bit12||bit 12 mask|25808
||anb|8,wb|8,wc||get bit 12|25809
||mov|3,cswer|8,wb||keep it as errors/noerrors option|25810
||zrb|8,wb|6,prpa6||skip if clear|25811
||mov|8,wa|3,prlen||get print buffer length|25812
||sub|8,wa|18,=num08||point 8 chars from line end|25813
||mov|3,lstpo|8,wa||store page offset|25814
|prpa6|mov|8,wb|4,bit11||bit 11 mask|25818
||anb|8,wb|8,wc||get bit 11|25819
||mov|3,cswpr|8,wb||set -print if non-zero|25820
||anb|8,wc|4,bits8||see if terminal to be activated|25824
||bnz|8,wc|6,prpa8||jump if terminal required|25825
||bze|3,initr|6,prpa9||jump if no terminal to detach|25826
||mov|7,xl|21,=v_ter||ptr to /terminal/|25827
||jsr|6,gtnvr|||get vrblk pointer|25828
||ppm||||cant fail|25829
||mov|13,vrval(xr)|21,=nulls||clear value of terminal|25830
||jsr|6,setvr|||remove association|25831
||brn|6,prpa9|||return|25832
|prpa8|mnz|3,initr|||note terminal associated|25836
||bze|3,dnamb|6,prpa9||cant if memory not organised|25837
||mov|7,xl|21,=v_ter||point to terminal string|25838
||mov|8,wb|18,=trtou||output trace type|25839
||jsr|6,inout|||attach output trblk to vrblk|25840
||mov|11,-(xs)|7,xr||stack trblk ptr|25841
||mov|7,xl|21,=v_ter||point to terminal string|25842
||mov|8,wb|18,=trtin||input trace type|25843
||jsr|6,inout|||attach input trace blk|25844
||mov|13,vrval(xr)|10,(xs)+||add output trblk to chain|25845
|prpa9|exi||||return|25849
||enp||||end procedure prpar|25850
||ejc|||||25851
|prtch|prc|25,e|1,0||entry point|25860
||mov|11,-(xs)|7,xr||save xr|25861
||bne|3,profs|3,prlen|6,prch1|jump if room in buffer|25862
||jsr|6,prtnl|||else print this line|25863
|prch1|mov|7,xr|3,prbuf||point to print buffer|25867
||psc|7,xr|3,profs||point to next character location|25868
||sch|8,wa|9,(xr)||store new character|25869
||csc|7,xr|||complete store characters|25870
||icv|3,profs|||bump pointer|25871
||mov|7,xr|10,(xs)+||restore entry xr|25872
||exi||||return to prtch caller|25873
||enp||||end procedure prtch|25874
||ejc|||||25875
|prtic|prc|25,e|1,0||entry point|25887
||mov|11,-(xs)|7,xr||save xr|25888
||mov|7,xr|3,prbuf||point to buffer|25889
||mov|8,wa|3,profs||no of chars|25890
||jsr|6,syspi|||print|25891
||ppm|6,prtc2|||fail return|25892
|prtc1|mov|7,xr|10,(xs)+||restore xr|25896
||exi||||return|25897
|prtc2|zer|3,erich|||prevent looping|25901
||erb|1,252|26,error on printing to interactive channel|||25902
||brn|6,prtc1|||return|25903
||enp||||procedure prtic|25904
||ejc|||||25905
|prtis|prc|25,e|1,0||entry point|25918
||bnz|3,prich|6,prts1||jump if standard printer is int.ch.|25919
||bze|3,erich|6,prts1||skip if not doing int. error reps.|25920
||jsr|6,prtic|||print to interactive channel|25921
|prts1|jsr|6,prtnl|||print to standard printer|25925
||exi||||return|25926
||enp||||end procedure prtis|25927
||ejc|||||25928
|prtin|prc|25,e|1,0||entry point|25940
||mov|11,-(xs)|7,xr||save xr|25941
||jsr|6,icbld|||build integer block|25942
||blo|7,xr|3,dnamb|6,prti1|jump if icblk below dynamic|25943
||bhi|7,xr|3,dnamp|6,prti1|jump if above dynamic|25944
||mov|3,dnamp|7,xr||immediately delete it|25945
|prti1|mov|11,-(xs)|7,xr||stack ptr for gtstg|25949
||jsr|6,gtstg|||convert to string|25950
||ppm||||convert error is impossible|25951
||mov|3,dnamp|7,xr||reset pointer to delete scblk|25952
||jsr|6,prtst|||print integer string|25953
||mov|7,xr|10,(xs)+||restore entry xr|25954
||exi||||return to prtin caller|25955
||enp||||end procedure prtin|25956
||ejc|||||25957
|prtmi|prc|25,e|1,0||entry point|25967
||jsr|6,prtst|||print string message|25968
||mov|3,profs|18,=prtmf||set column offset|25969
||jsr|6,prtin|||print integer|25970
||jsr|6,prtnl|||print line|25971
||exi||||return to prtmi caller|25972
||enp||||end procedure prtmi|25973
||ejc|||||25974
|prtmm|prc|25,e|1,0|||25983
||mov|8,wa|3,dnamp||next available loc|25984
||sub|8,wa|3,statb||minus start|25985
||mti|8,wa|||convert to integer|25990
||mov|7,xr|21,=encm1||point to /memory used (words)/|25991
||jsr|6,prtmi|||print message|25992
||mov|8,wa|3,dname||end of memory|25993
||sub|8,wa|3,dnamp||minus next available loc|25994
||mti|8,wa|||convert to integer|25999
||mov|7,xr|21,=encm2||point to /memory available (words)/|26000
||jsr|6,prtmi|||print line|26001
||exi||||return to prtmm caller|26002
||enp||||end of procedure prtmm|26003
||ejc|||||26004
|prtmx|prc|25,e|1,0||entry point|26011
||jsr|6,prtst|||print string message|26012
||mov|3,profs|18,=prtmf||set column offset|26013
||jsr|6,prtin|||print integer|26014
||jsr|6,prtis|||print line|26015
||exi||||return|26016
||enp||||end procedure prtmx|26017
||ejc|||||26018
|prtnl|prc|25,r|1,0||entry point|26027
||bnz|3,headp|6,prnl0||were headers printed|26028
||jsr|6,prtps|||no - print them|26029
|prnl0|mov|11,-(xs)|7,xr||save entry xr|26033
||mov|3,prtsa|8,wa||save wa|26034
||mov|3,prtsb|8,wb||save wb|26035
||mov|7,xr|3,prbuf||load pointer to buffer|26036
||mov|8,wa|3,profs||load number of chars in buffer|26037
||jsr|6,syspr|||call system print routine|26038
||ppm|6,prnl2|||jump if failed|26039
||lct|8,wa|3,prlnw||load length of buffer in words|26040
||add|7,xr|19,*schar||point to chars of buffer|26041
||mov|8,wb|4,nullw||get word of blanks|26042
|prnl1|mov|10,(xr)+|8,wb||store word of blanks, bump ptr|26046
||bct|8,wa|6,prnl1||loop till all blanked|26047
||mov|8,wb|3,prtsb||restore wb|26051
||mov|8,wa|3,prtsa||restore wa|26052
||mov|7,xr|10,(xs)+||restore entry xr|26053
||zer|3,profs|||reset print buffer pointer|26054
||exi||||return to prtnl caller|26055
|prnl2|bnz|3,prtef|6,prnl3||jump if not first time|26059
||mnz|3,prtef|||mark first occurrence|26060
||erb|1,253|26,print limit exceeded on standard output channel|||26061
|prnl3|mov|8,wb|18,=nini8||ending code|26065
||mov|8,wa|3,kvstn||statement number|26066
||mov|7,xl|3,r_fcb||get fcblk chain head|26067
||jsr|6,sysej|||stop|26068
||enp||||end procedure prtnl|26069
||ejc|||||26070
|prtnm|prc|25,r|1,0||entry point (recursive, see prtvl)|26083
||mov|11,-(xs)|8,wa||save wa (offset is collectable)|26084
||mov|11,-(xs)|7,xr||save entry xr|26085
||mov|11,-(xs)|7,xl||save name base|26086
||bhi|7,xl|3,state|6,prn02|jump if not natural variable|26087
||mov|7,xr|7,xl||point to vrblk|26092
||jsr|6,prtvn|||print name of variable|26093
|prn01|mov|7,xl|10,(xs)+||restore name base|26097
||mov|7,xr|10,(xs)+||restore entry value of xr|26098
||mov|8,wa|10,(xs)+||restore wa|26099
||exi||||return to prtnm caller|26100
|prn02|mov|8,wb|8,wa||copy name offset|26104
||bne|9,(xl)|22,=b_pdt|6,prn03|jump if array or table|26105
||mov|7,xr|13,pddfp(xl)||load pointer to dfblk|26109
||add|7,xr|8,wa||add name offset|26110
||mov|7,xr|13,pdfof(xr)||load vrblk pointer for field|26111
||jsr|6,prtvn|||print field name|26112
||mov|8,wa|18,=ch_pp||load left paren|26113
||jsr|6,prtch|||print character|26114
||ejc|||||26115
|prn03|bne|9,(xl)|22,=b_tet|6,prn04|jump if we got there (or not te)|26128
||mov|7,xl|13,tenxt(xl)||else move out on chain|26129
||brn|6,prn03|||and loop back|26130
|prn04|mov|7,xr|3,prnmv||point to vrblk we found last time|26138
||mov|8,wa|3,hshtb||point to hash table in case not|26139
||brn|6,prn07|||jump into search for special check|26140
|prn05|mov|7,xr|8,wa||copy slot pointer|26144
||ica|8,wa|||bump slot pointer|26145
||sub|7,xr|19,*vrnxt||introduce standard vrblk offset|26146
|prn06|mov|7,xr|13,vrnxt(xr)||point to next vrblk on hash chain|26150
|prn07|mov|8,wc|7,xr||copy vrblk pointer|26154
||bze|8,wc|6,prn09||jump if chain end (or prnmv zero)|26155
||ejc|||||26156
|prn08|mov|7,xr|13,vrval(xr)||load value|26162
||beq|9,(xr)|22,=b_trt|6,prn08|loop if that was a trblk|26163
||beq|7,xr|7,xl|6,prn10|jump if this matches the name base|26167
||mov|7,xr|8,wc||else point back to that vrblk|26168
||brn|6,prn06|||and loop back|26169
|prn09|blt|8,wa|3,hshte|6,prn05|loop back if more to go|26173
||mov|7,xr|7,xl||else not found, copy value pointer|26174
||jsr|6,prtvl|||print value|26175
||brn|6,prn11|||and merge ahead|26176
|prn10|mov|7,xr|8,wc||copy vrblk pointer|26180
||mov|3,prnmv|7,xr||save for next time in|26181
||jsr|6,prtvn|||print variable name|26182
|prn11|mov|8,wc|9,(xl)||load first word of name base|26186
||bne|8,wc|22,=b_pdt|6,prn13|jump if not program defined|26187
||mov|8,wa|18,=ch_rp||load right paren, merge|26191
|prn12|jsr|6,prtch|||print final character|26195
||mov|8,wa|8,wb||restore name offset|26196
||brn|6,prn01|||merge back to exit|26197
||ejc|||||26198
|prn13|mov|8,wa|18,=ch_bb||load left bracket|26204
||jsr|6,prtch|||and print it|26205
||mov|7,xl|9,(xs)||restore block pointer|26206
||mov|8,wc|9,(xl)||load type word again|26207
||bne|8,wc|22,=b_tet|6,prn15|jump if not table|26208
||mov|7,xr|13,tesub(xl)||load subscript value|26212
||mov|7,xl|8,wb||save name offset|26213
||jsr|6,prtvl|||print subscript value|26214
||mov|8,wb|7,xl||restore name offset|26215
|prn14|mov|8,wa|18,=ch_rb||load right bracket|26219
||brn|6,prn12|||merge back to print it|26220
|prn15|mov|8,wa|8,wb||copy name offset|26224
||btw|8,wa|||convert to words|26225
||beq|8,wc|22,=b_art|6,prn16|jump if arblk|26226
||sub|8,wa|18,=vcvlb||adjust for standard fields|26230
||mti|8,wa|||move to integer accum|26231
||jsr|6,prtin|||print linear subscript|26232
||brn|6,prn14|||merge back for right bracket|26233
||ejc|||||26234
|prn16|mov|8,wc|13,arofs(xl)||load length of bounds info|26243
||ica|8,wc|||adjust for arpro field|26244
||btw|8,wc|||convert to words|26245
||sub|8,wa|8,wc||get linear zero-origin subscript|26246
||mti|8,wa|||get integer value|26247
||lct|8,wa|13,arndm(xl)||set num of dimensions as loop count|26248
||add|7,xl|13,arofs(xl)||point past bounds information|26249
||sub|7,xl|19,*arlbd||set ok offset for proper ptr later|26250
|prn17|sub|7,xl|19,*ardms||point to next set of bounds|26254
||sti|3,prnsi|||save current offset|26255
||rmi|13,ardim(xl)|||get remainder on dividing by dimens|26256
||mfi|11,-(xs)|||store on stack (one word)|26257
||ldi|3,prnsi|||reload argument|26258
||dvi|13,ardim(xl)|||divide to get quotient|26259
||bct|8,wa|6,prn17||loop till all stacked|26260
||zer|7,xr|||set offset to first set of bounds|26261
||lct|8,wb|13,arndm(xl)||load count of dims to control loop|26262
||brn|6,prn19|||jump into print loop|26263
|prn18|mov|8,wa|18,=ch_cm||load a comma|26268
||jsr|6,prtch|||print it|26269
|prn19|mti|10,(xs)+|||load subscript offset as integer|26273
||add|7,xl|7,xr||point to current lbd|26274
||adi|13,arlbd(xl)|||add lbd to get signed subscript|26275
||sub|7,xl|7,xr||point back to start of arblk|26276
||jsr|6,prtin|||print subscript|26277
||add|7,xr|19,*ardms||bump offset to next bounds|26278
||bct|8,wb|6,prn18||loop back till all printed|26279
||brn|6,prn14|||merge back to print right bracket|26280
||enp||||end procedure prtnm|26281
||ejc|||||26282
|prtnv|prc|25,e|1,0||entry point|26298
||jsr|6,prtnm|||print argument name|26299
||mov|11,-(xs)|7,xr||save entry xr|26300
||mov|11,-(xs)|8,wa||save name offset (collectable)|26301
||mov|7,xr|21,=tmbeb||point to blank equal blank|26302
||jsr|6,prtst|||print it|26303
||mov|7,xr|7,xl||copy name base|26304
||add|7,xr|8,wa||point to value|26305
||mov|7,xr|9,(xr)||load value pointer|26306
||jsr|6,prtvl|||print value|26307
||jsr|6,prtnl|||terminate line|26308
||mov|8,wa|10,(xs)+||restore name offset|26309
||mov|7,xr|10,(xs)+||restore entry xr|26310
||exi||||return to caller|26311
||enp||||end procedure prtnv|26312
||ejc|||||26313
|prtpg|prc|25,e|1,0||entry point|26322
||beq|3,stage|18,=stgxt|6,prp01|jump if execution time|26323
||bze|3,lstlc|6,prp06||return if top of page already|26324
||zer|3,lstlc|||clear line count|26325
|prp01|mov|11,-(xs)|7,xr||preserve xr|26329
||bnz|3,prstd|6,prp02||eject if flag set|26330
||bnz|3,prich|6,prp03||jump if interactive listing channel|26331
||bze|3,precl|6,prp03||jump if compact listing|26332
|prp02|jsr|6,sysep|||eject|26336
||brn|6,prp04|||merge|26337
|prp03|mov|7,xr|3,headp||remember headp|26343
||mnz|3,headp|||set to avoid repeated prtpg calls|26344
||jsr|6,prtnl|||print blank line|26345
||jsr|6,prtnl|||print blank line|26346
||jsr|6,prtnl|||print blank line|26347
||mov|3,lstlc|18,=num03||count blank lines|26348
||mov|3,headp|7,xr||restore header flag|26349
||ejc|||||26350
|prp04|bnz|3,headp|6,prp05||jump if header listed|26356
||mnz|3,headp|||mark headers printed|26357
||mov|11,-(xs)|7,xl||keep xl|26358
||mov|7,xr|21,=headr||point to listing header|26359
||jsr|6,prtst|||place it|26360
||jsr|6,sysid|||get system identification|26361
||jsr|6,prtst|||append extra chars|26362
||jsr|6,prtnl|||print it|26363
||mov|7,xr|7,xl||extra header line|26364
||jsr|6,prtst|||place it|26365
||jsr|6,prtnl|||print it|26366
||jsr|6,prtnl|||print a blank|26367
||jsr|6,prtnl|||and another|26368
||add|3,lstlc|18,=num04||four header lines printed|26369
||mov|7,xl|10,(xs)+||restore xl|26370
|prp05|mov|7,xr|10,(xs)+||restore xr|26374
|prp06|exi||||return|26378
||enp||||end procedure prtpg|26379
||ejc|||||26380
|prtps|prc|25,e|1,0||entry point|26389
||mov|3,prstd|3,prsto||copy option flag|26390
||jsr|6,prtpg|||print page|26391
||zer|3,prstd|||clear flag|26392
||exi||||return|26393
||enp||||end procedure prtps|26394
||ejc|||||26395
|prtsn|prc|25,e|1,0||entry point|26414
||mov|11,-(xs)|7,xr||save entry xr|26415
||mov|3,prsna|8,wa||save entry wa|26416
||mov|7,xr|21,=tmasb||point to asterisks|26417
||jsr|6,prtst|||print asterisks|26418
||mov|3,profs|18,=num04||point into middle of asterisks|26419
||mti|3,kvstn|||load statement number as integer|26420
||jsr|6,prtin|||print integer statement number|26421
||mov|3,profs|18,=prsnf||point past asterisks plus blank|26422
||mov|7,xr|3,kvfnc||get fnclevel|26423
||mov|8,wa|18,=ch_li||set letter i|26424
|prsn1|bze|7,xr|6,prsn2||jump if all set|26428
||jsr|6,prtch|||else print an i|26429
||dcv|7,xr|||decrement counter|26430
||brn|6,prsn1|||loop back|26431
|prsn2|mov|8,wa|18,=ch_bl||get blank|26435
||jsr|6,prtch|||print blank|26436
||mov|8,wa|3,prsna||restore entry wa|26437
||mov|7,xr|10,(xs)+||restore entry xr|26438
||exi||||return to prtsn caller|26439
||enp||||end procedure prtsn|26440
||ejc|||||26441
|prtst|prc|25,r|1,0||entry point|26456
||bnz|3,headp|6,prst0||were headers printed|26457
||jsr|6,prtps|||no - print them|26458
|prst0|mov|3,prsva|8,wa||save wa|26462
||mov|3,prsvb|8,wb||save wb|26463
||zer|8,wb|||set chars printed count to zero|26464
|prst1|mov|8,wa|13,sclen(xr)||load string length|26468
||sub|8,wa|8,wb||subtract count of chars already out|26469
||bze|8,wa|6,prst4||jump to exit if none left|26470
||mov|11,-(xs)|7,xl||else stack entry xl|26471
||mov|11,-(xs)|7,xr||save argument|26472
||mov|7,xl|7,xr||copy for eventual move|26473
||mov|7,xr|3,prlen||load print buffer length|26474
||sub|7,xr|3,profs||get chars left in print buffer|26475
||bnz|7,xr|6,prst2||skip if room left on this line|26476
||jsr|6,prtnl|||else print this line|26477
||mov|7,xr|3,prlen||and set full width available|26478
||ejc|||||26479
|prst2|blo|8,wa|7,xr|6,prst3|jump if room for rest of string|26485
||mov|8,wa|7,xr||else set to fill line|26486
|prst3|mov|7,xr|3,prbuf||point to print buffer|26490
||plc|7,xl|8,wb||point to location in string|26491
||psc|7,xr|3,profs||point to location in buffer|26492
||add|8,wb|8,wa||bump string chars count|26493
||add|3,profs|8,wa||bump buffer pointer|26494
||mov|3,prsvc|8,wb||preserve char counter|26495
||mvc||||move characters to buffer|26496
||mov|8,wb|3,prsvc||recover char counter|26497
||mov|7,xr|10,(xs)+||restore argument pointer|26498
||mov|7,xl|10,(xs)+||restore entry xl|26499
||brn|6,prst1|||loop back to test for more|26500
|prst4|mov|8,wb|3,prsvb||restore entry wb|26504
||mov|8,wa|3,prsva||restore entry wa|26505
||exi||||return to prtst caller|26506
||enp||||end procedure prtst|26507
||ejc|||||26508
|prttr|prc|25,e|1,0||entry point|26518
||mov|11,-(xs)|7,xr||save xr|26519
||jsr|6,prtic|||print buffer contents|26520
||mov|7,xr|3,prbuf||point to print bfr to clear it|26521
||lct|8,wa|3,prlnw||get buffer length|26522
||add|7,xr|19,*schar||point past scblk header|26523
||mov|8,wb|4,nullw||get blanks|26524
|prtt1|mov|10,(xr)+|8,wb||clear a word|26528
||bct|8,wa|6,prtt1||loop|26529
||zer|3,profs|||reset profs|26530
||mov|7,xr|10,(xs)+||restore xr|26531
||exi||||return|26532
||enp||||end procedure prttr|26533
||ejc|||||26534
|prtvl|prc|25,r|1,0||entry point, recursive|26545
||mov|11,-(xs)|7,xl||save entry xl|26546
||mov|11,-(xs)|7,xr||save argument|26547
||chk||||check for stack overflow|26548
|prv01|mov|3,prvsi|13,idval(xr)||copy idval (if any)|26552
||mov|7,xl|9,(xr)||load first word of block|26553
||lei|7,xl|||load entry point id|26554
||bsw|7,xl|2,bl__t|6,prv02|switch on block type|26555
||iff|2,bl_ar|6,prv05||arblk|26573
||iff|1,1|6,prv02|||26573
||iff|1,2|6,prv02|||26573
||iff|2,bl_ic|6,prv08||icblk|26573
||iff|2,bl_nm|6,prv09||nmblk|26573
||iff|1,5|6,prv02|||26573
||iff|1,6|6,prv02|||26573
||iff|1,7|6,prv02|||26573
||iff|2,bl_rc|6,prv08||rcblk|26573
||iff|2,bl_sc|6,prv11||scblk|26573
||iff|2,bl_se|6,prv12||seblk|26573
||iff|2,bl_tb|6,prv13||tbblk|26573
||iff|2,bl_vc|6,prv13||vcblk|26573
||iff|1,13|6,prv02|||26573
||iff|1,14|6,prv02|||26573
||iff|1,15|6,prv02|||26573
||iff|2,bl_pd|6,prv10||pdblk|26573
||iff|2,bl_tr|6,prv04||trblk|26573
||esw||||end of switch on block type|26573
|prv02|jsr|6,dtype|||get datatype name|26577
||jsr|6,prtst|||print datatype name|26578
|prv03|mov|7,xr|10,(xs)+||reload argument|26582
||mov|7,xl|10,(xs)+||restore xl|26583
||exi||||return to prtvl caller|26584
|prv04|mov|7,xr|13,trval(xr)||load real value|26588
||brn|6,prv01|||and loop back|26589
||ejc|||||26590
|prv05|mov|7,xl|7,xr||preserve argument|26598
||mov|7,xr|21,=scarr||point to datatype name (array)|26599
||jsr|6,prtst|||print it|26600
||mov|8,wa|18,=ch_pp||load left paren|26601
||jsr|6,prtch|||print left paren|26602
||add|7,xl|13,arofs(xl)||point to prototype|26603
||mov|7,xr|9,(xl)||load prototype|26604
||jsr|6,prtst|||print prototype|26605
|prv06|mov|8,wa|18,=ch_rp||load right paren|26609
||jsr|6,prtch|||print right paren|26610
|prv07|mov|8,wa|18,=ch_bl||load blank|26614
||jsr|6,prtch|||print it|26615
||mov|8,wa|18,=ch_nm||load number sign|26616
||jsr|6,prtch|||print it|26617
||mti|3,prvsi|||get idval|26618
||jsr|6,prtin|||print id number|26619
||brn|6,prv03|||back to exit|26620
|prv08|mov|11,-(xs)|7,xr||stack argument for gtstg|26626
||jsr|6,gtstg|||convert to string|26627
||ppm||||error return is impossible|26628
||jsr|6,prtst|||print the string|26629
||mov|3,dnamp|7,xr||delete garbage string from storage|26630
||brn|6,prv03|||back to exit|26631
||ejc|||||26632
|prv09|mov|7,xl|13,nmbas(xr)||load name base|26641
||mov|8,wa|9,(xl)||load first word of block|26642
||beq|8,wa|22,=b_kvt|6,prv02|just print name if keyword|26643
||beq|8,wa|22,=b_evt|6,prv02|just print name if expression var|26644
||mov|8,wa|18,=ch_dt||else get dot|26645
||jsr|6,prtch|||and print it|26646
||mov|8,wa|13,nmofs(xr)||load name offset|26647
||jsr|6,prtnm|||print name|26648
||brn|6,prv03|||back to exit|26649
|prv10|jsr|6,dtype|||get datatype name|26655
||jsr|6,prtst|||print datatype name|26656
||brn|6,prv07|||merge back to print id|26657
|prv11|mov|8,wa|18,=ch_sq||load single quote|26663
||jsr|6,prtch|||print quote|26664
||jsr|6,prtst|||print string value|26665
||jsr|6,prtch|||print another quote|26666
||brn|6,prv03|||back to exit|26667
||ejc|||||26668
|prv12|mov|8,wa|18,=ch_as||load asterisk|26676
||jsr|6,prtch|||print asterisk|26677
||mov|7,xr|13,sevar(xr)||load variable pointer|26678
||jsr|6,prtvn|||print variable name|26679
||brn|6,prv03|||jump back to exit|26680
|prv13|mov|7,xl|7,xr||preserve argument|26686
||jsr|6,dtype|||get datatype name|26687
||jsr|6,prtst|||print datatype name|26688
||mov|8,wa|18,=ch_pp||load left paren|26689
||jsr|6,prtch|||print left paren|26690
||mov|8,wa|13,tblen(xl)||load length of block (=vclen)|26691
||btw|8,wa|||convert to word count|26692
||sub|8,wa|18,=tbsi_||allow for standard fields|26693
||beq|9,(xl)|22,=b_tbt|6,prv14|jump if table|26694
||add|8,wa|18,=vctbd||for vcblk, adjust size|26695
|prv14|mti|8,wa|||move as integer|26699
||jsr|6,prtin|||print integer prototype|26700
||brn|6,prv06|||merge back for rest|26701
||enp||||end procedure prtvl|26724
||ejc|||||26725
|prtvn|prc|25,e|1,0||entry point|26734
||mov|11,-(xs)|7,xr||stack vrblk pointer|26735
||add|7,xr|19,*vrsof||point to possible string name|26736
||bnz|13,sclen(xr)|6,prvn1||jump if not system variable|26737
||mov|7,xr|13,vrsvo(xr)||point to svblk with name|26738
|prvn1|jsr|6,prtst|||print string name of variable|26742
||mov|7,xr|10,(xs)+||restore vrblk pointer|26743
||exi||||return to prtvn caller|26744
||enp||||end procedure prtvn|26745
||ejc|||||26748
|rcbld|prc|25,e|1,0||entry point|26757
||mov|7,xr|3,dnamp||load pointer to next available loc|26758
||add|7,xr|19,*rcsi_||point past new rcblk|26759
||blo|7,xr|3,dname|6,rcbl1|jump if there is room|26760
||mov|8,wa|19,*rcsi_||else load rcblk length|26761
||jsr|6,alloc|||use standard allocator to get block|26762
||add|7,xr|8,wa||point past block to merge|26763
|rcbl1|mov|3,dnamp|7,xr||set new pointer|26767
||sub|7,xr|19,*rcsi_||point back to start of block|26768
||mov|9,(xr)|22,=b_rcl||store type word|26769
||str|13,rcval(xr)|||store real value in rcblk|26770
||exi||||return to rcbld caller|26771
||enp||||end procedure rcbld|26772
||ejc|||||26774
|readr|prc|25,e|1,0||entry point|26788
||mov|7,xr|3,r_cni||get ptr to next image|26789
||bnz|7,xr|6,read3||exit if already read|26790
||bnz|3,cnind|6,reada||if within include file|26792
||bne|3,stage|18,=stgic|6,read3|exit if not initial compile|26794
|reada|mov|8,wa|3,cswin||max read length|26795
||zer|7,xl|||clear any dud value in xl|26796
||jsr|6,alocs|||allocate buffer|26797
||jsr|6,sysrd|||read input image|26798
||ppm|6,read4|||jump if eof or new file name|26799
||icv|3,rdnln|||increment next line number|26800
||dcv|3,polct|||test if time to poll interface|26802
||bnz|3,polct|6,read0||not yet|26803
||zer|8,wa|||=0 for poll|26804
||mov|8,wb|3,rdnln||line number|26805
||jsr|6,syspl|||allow interactive access|26806
||err|1,320|26,user interrupt|||26807
||ppm||||single step|26808
||ppm||||expression evaluation|26809
||mov|3,polcs|8,wa||new countdown start value|26810
||mov|3,polct|8,wa||new counter value|26811
|read0|ble|13,sclen(xr)|3,cswin|6,read1|use smaller of string lnth ...|26813
||mov|13,sclen(xr)|3,cswin||... and xxx of -inxxx|26814
|read1|mnz|8,wb|||set trimr to perform trim|26818
||jsr|6,trimr|||trim trailing blanks|26819
|read2|mov|3,r_cni|7,xr||store copy of pointer|26823
|read3|exi||||return to readr caller|26827
|read4|bze|13,sclen(xr)|6,read5||jump if true end of file|26836
||zer|8,wb|||new source file name|26837
||mov|3,rdnln|8,wb||restart line counter for new file|26838
||jsr|6,trimr|||remove unused space in block|26839
||jsr|6,newfn|||record new file name|26840
||brn|6,reada|||now reissue read for record data|26841
|read5|mov|3,dnamp|7,xr||pop unused scblk|26845
||bze|3,cnind|6,read6||jump if not within an include file|26847
||zer|7,xl|||eof within include file|26848
||jsr|6,sysif|||switch stream back to previous file|26849
||ppm|||||26850
||mov|8,wa|3,cnind||restore prev line number, file name|26851
||add|8,wa|18,=vcvlb||vector offset in words|26852
||wtb|8,wa|||convert to bytes|26853
||mov|7,xr|3,r_ifa||file name array|26854
||add|7,xr|8,wa||ptr to element|26855
||mov|3,r_sfc|9,(xr)||change source file name|26856
||mov|9,(xr)|21,=nulls||release scblk|26857
||mov|7,xr|3,r_ifl||line number array|26858
||add|7,xr|8,wa||ptr to element|26859
||mov|7,xl|9,(xr)||icblk containing saved line number|26860
||ldi|13,icval(xl)|||line number integer|26861
||mfi|3,rdnln|||change source line number|26862
||mov|9,(xr)|21,=inton||release icblk|26863
||dcv|3,cnind|||decrement nesting level|26864
||mov|8,wb|3,cmpsn||current statement number|26865
||icv|8,wb|||anticipate end of previous stmt|26866
||mti|8,wb|||convert to integer|26867
||jsr|6,icbld|||build icblk for stmt number|26868
||mov|7,xl|3,r_sfn||file name table|26869
||mnz|8,wb|||lookup statement number by name|26870
||jsr|6,tfind|||allocate new teblk|26871
||ppm||||always possible to allocate block|26872
||mov|13,teval(xl)|3,r_sfc||record file name as entry value|26873
||beq|3,stage|18,=stgic|6,reada|if initial compile, reissue read|26874
||bnz|3,cnind|6,reada||still reading from include file|26875
||mov|7,xl|3,r_ici||restore code argument string|26880
||zer|3,r_ici|||release original string|26881
||mov|8,wa|3,cnsil||get length of string|26882
||mov|8,wb|3,cnspt||offset of characters left|26883
||sub|8,wa|8,wb||number of characters left|26884
||mov|3,scnil|8,wa||set new scan length|26885
||zer|3,scnpt|||scan from start of substring|26886
||jsr|6,sbstr|||create substring of remainder|26887
||mov|3,r_cim|7,xr||set scan image|26888
||brn|6,read2|||return|26889
|read6|zer|7,xr|||zero ptr as result|26905
||brn|6,read2|||merge|26906
||enp||||end procedure readr|26907
||ejc|||||26908
|sbstr|prc|25,e|1,0||entry point|27003
||bze|8,wa|6,sbst2||jump if null substring|27004
||jsr|6,alocs|||else allocate scblk|27005
||mov|8,wa|8,wc||move number of characters|27006
||mov|8,wc|7,xr||save ptr to new scblk|27007
||plc|7,xl|8,wb||prepare to load chars from old blk|27008
||psc|7,xr|||prepare to store chars in new blk|27009
||mvc||||move characters to new string|27010
||mov|7,xr|8,wc||then restore scblk pointer|27011
|sbst1|zer|7,xl|||clear garbage pointer in xl|27015
||exi||||return to sbstr caller|27016
|sbst2|mov|7,xr|21,=nulls||set null string as result|27020
||brn|6,sbst1|||return|27021
||enp||||end procedure sbstr|27022
||ejc|||||27023
|stgcc|prc|25,e|1,0|||27034
||mov|8,wa|3,polcs||assume no profiling or stcount tracing|27036
||mov|8,wb|18,=num01||poll each time polcs expires|27037
||ldi|3,kvstl|||get stmt limit|27041
||bnz|3,kvpfl|6,stgc1||jump if profiling enabled|27042
||ilt|6,stgc3|||no stcount tracing if negative|27043
||bze|3,r_stc|6,stgc2||jump if not stcount tracing|27044
|stgc1|mov|8,wb|8,wa||count polcs times within stmg|27049
||mov|8,wa|18,=num01||break out of stmgo on each stmt|27050
||brn|6,stgc3||||27054
|stgc2|mti|8,wa|||breakout count start value|27058
||sbi|3,kvstl|||proposed stmcs minus stmt limit|27059
||ile|6,stgc3|||jump if stmt count does not limit|27060
||ldi|3,kvstl|||stlimit limits breakcount count|27061
||mfi|8,wa|||use it instead|27062
|stgc3|mov|3,stmcs|8,wa||update breakout count start value|27066
||mov|3,stmct|8,wa||reset breakout counter|27067
||mov|3,polct|8,wb|||27069
||exi|||||27071
||ejc|||||27072
|tfind|prc|25,e|1,1||entry point|27091
||mov|11,-(xs)|8,wb||save name/value indicator|27092
||mov|11,-(xs)|7,xr||save subscript value|27093
||mov|11,-(xs)|7,xl||save table pointer|27094
||mov|8,wa|13,tblen(xl)||load length of tbblk|27095
||btw|8,wa|||convert to word count|27096
||sub|8,wa|18,=tbbuk||get number of buckets|27097
||mti|8,wa|||convert to integer value|27098
||sti|3,tfnsi|||save for later|27099
||mov|7,xl|9,(xr)||load first word of subscript|27100
||lei|7,xl|||load block entry id (bl_xx)|27101
||bsw|7,xl|2,bl__d|6,tfn00|switch on block type|27102
||iff|1,0|6,tfn00|||27113
||iff|1,1|6,tfn00|||27113
||iff|1,2|6,tfn00|||27113
||iff|2,bl_ic|6,tfn02||jump if integer|27113
||iff|2,bl_nm|6,tfn04||jump if name|27113
||iff|2,bl_p0|6,tfn03||jump if pattern|27113
||iff|2,bl_p1|6,tfn03||jump if pattern|27113
||iff|2,bl_p2|6,tfn03||jump if pattern|27113
||iff|2,bl_rc|6,tfn02||real|27113
||iff|2,bl_sc|6,tfn05||jump if string|27113
||iff|1,10|6,tfn00|||27113
||iff|1,11|6,tfn00|||27113
||iff|1,12|6,tfn00|||27113
||iff|1,13|6,tfn00|||27113
||iff|1,14|6,tfn00|||27113
||iff|1,15|6,tfn00|||27113
||iff|1,16|6,tfn00|||27113
||esw||||end switch on block type|27113
|tfn00|mov|8,wa|12,1(xr)||load second word|27118
|tfn01|mti|8,wa|||convert to integer|27122
||brn|6,tfn06|||jump to merge|27123
||ejc|||||27124
|tfn02|ldi|12,1(xr)|||load value as hash source|27134
||ige|6,tfn06|||ok if positive or zero|27135
||ngi||||make positive|27136
||iov|6,tfn06|||clear possible overflow|27137
||brn|6,tfn06|||merge|27138
|tfn03|mov|8,wa|9,(xr)||load first word as hash source|27142
||brn|6,tfn01|||merge back|27143
|tfn04|mov|8,wa|13,nmofs(xr)||load offset as hash source|27147
||brn|6,tfn01|||merge back|27148
|tfn05|jsr|6,hashs|||call routine to compute hash|27152
|tfn06|rmi|3,tfnsi|||compute hash index by remaindering|27156
||mfi|8,wc|||get as one word integer|27157
||wtb|8,wc|||convert to byte offset|27158
||mov|7,xl|9,(xs)||get table ptr again|27159
||add|7,xl|8,wc||point to proper bucket|27160
||mov|7,xr|13,tbbuk(xl)||load first teblk pointer|27161
||beq|7,xr|9,(xs)|6,tfn10|jump if no teblks on chain|27162
|tfn07|mov|8,wb|7,xr||save teblk pointer|27166
||mov|7,xr|13,tesub(xr)||load subscript value|27167
||mov|7,xl|12,1(xs)||load input argument subscript val|27168
||jsr|6,ident|||compare them|27169
||ppm|6,tfn08|||jump if equal (ident)|27170
||mov|7,xl|8,wb||restore teblk pointer|27174
||mov|7,xr|13,tenxt(xl)||point to next teblk on chain|27175
||bne|7,xr|9,(xs)|6,tfn07|jump if there is one|27176
||mov|8,wc|19,*tenxt||set offset to link field (xl base)|27180
||brn|6,tfn11|||jump to merge|27181
||ejc|||||27182
|tfn08|mov|7,xl|8,wb||restore teblk pointer|27188
||mov|8,wa|19,*teval||set teblk name offset|27189
||mov|8,wb|12,2(xs)||restore name/value indicator|27190
||bnz|8,wb|6,tfn09||jump if called by name|27191
||jsr|6,acess|||else get value|27192
||ppm|6,tfn12|||jump if reference fails|27193
||zer|8,wb|||restore name/value indicator|27194
|tfn09|add|7,xs|19,*num03||pop stack entries|27198
||exi||||return to tfind caller|27199
|tfn10|add|8,wc|19,*tbbuk||get offset to bucket ptr|27203
||mov|7,xl|9,(xs)||set tbblk ptr as base|27204
|tfn11|mov|7,xr|9,(xs)||tbblk pointer|27208
||mov|7,xr|13,tbinv(xr)||load default value in case|27209
||mov|8,wb|12,2(xs)||load name/value indicator|27210
||bze|8,wb|6,tfn09||exit with default if value call|27211
||mov|8,wb|7,xr||copy default value|27212
||mov|8,wa|19,*tesi_||set size of teblk|27216
||jsr|6,alloc|||allocate teblk|27217
||add|7,xl|8,wc||point to hash link|27218
||mov|9,(xl)|7,xr||link new teblk at end of chain|27219
||mov|9,(xr)|22,=b_tet||store type word|27220
||mov|13,teval(xr)|8,wb||set default as initial value|27221
||mov|13,tenxt(xr)|10,(xs)+||set tbblk ptr to mark end of chain|27222
||mov|13,tesub(xr)|10,(xs)+||store subscript value|27223
||mov|8,wb|10,(xs)+||restore name/value indicator|27224
||mov|7,xl|7,xr||copy teblk pointer (name base)|27225
||mov|8,wa|19,*teval||set offset|27226
||exi||||return to caller with new teblk|27227
|tfn12|exi|1,1|||alternative return|27231
||enp||||end procedure tfind|27232
||ejc|||||27233
|tmake|prc|25,e|1,0|||27243
||mov|8,wa|8,wc||copy number of headers|27244
||add|8,wa|18,=tbsi_||adjust for standard fields|27245
||wtb|8,wa|||convert length to bytes|27246
||jsr|6,alloc|||allocate space for tbblk|27247
||mov|8,wb|7,xr||copy pointer to tbblk|27248
||mov|10,(xr)+|22,=b_tbt||store type word|27249
||zer|10,(xr)+|||zero id for the moment|27250
||mov|10,(xr)+|8,wa||store length (tblen)|27251
||mov|10,(xr)+|7,xl||store initial lookup value|27252
||lct|8,wc|8,wc||set loop counter (num headers)|27253
|tma01|mov|10,(xr)+|8,wb||store tbblk ptr in bucket header|27257
||bct|8,wc|6,tma01||loop till all stored|27258
||mov|7,xr|8,wb||recall pointer to tbblk|27259
||exi|||||27260
||enp|||||27261
||ejc|||||27262
|vmake|prc|25,e|1,1||entry point|27274
||lct|8,wb|8,wa||copy elements for loop later on|27275
||add|8,wa|18,=vcsi_||add space for standard fields|27276
||wtb|8,wa|||convert length to bytes|27277
||bgt|8,wa|3,mxlen|6,vmak2|fail if too large|27278
||jsr|6,alloc|||allocate space for vcblk|27279
||mov|9,(xr)|22,=b_vct||store type word|27280
||zer|13,idval(xr)|||initialize idval|27281
||mov|13,vclen(xr)|8,wa||set length|27282
||mov|8,wc|7,xl||copy default value|27283
||mov|7,xl|7,xr||copy vcblk pointer|27284
||add|7,xl|19,*vcvls||point to first element value|27285
|vmak1|mov|10,(xl)+|8,wc||store one value|27289
||bct|8,wb|6,vmak1||loop till all stored|27290
||exi||||success return|27291
|vmak2|exi|1,1|||fail return|27295
||enp|||||27296
||ejc|||||27297
||ejc|||||27345
||ejc|||||27390
|scane|prc|25,e|1,0||entry point|27396
||zer|3,scnbl|||reset blanks flag|27397
||mov|3,scnsa|8,wa||save wa|27398
||mov|3,scnsb|8,wb||save wb|27399
||mov|3,scnsc|8,wc||save wc|27400
||bze|3,scnrs|6,scn03||jump if no rescan|27401
||mov|7,xl|3,scntp||set previous returned scan type|27405
||mov|7,xr|3,r_scp||set previous returned pointer|27406
||zer|3,scnrs|||reset rescan switch|27407
||brn|6,scn13|||jump to exit|27408
|scn01|jsr|6,readr|||read next image|27412
||mov|8,wb|19,*dvubs||set wb for not reading name|27413
||bze|7,xr|6,scn30||treat as semi-colon if none|27414
||plc|7,xr|||else point to first character|27415
||lch|8,wc|9,(xr)||load first character|27416
||beq|8,wc|18,=ch_dt|6,scn02|jump if dot for continuation|27417
||bne|8,wc|18,=ch_pl|6,scn30|else treat as semicolon unless plus|27418
|scn02|jsr|6,nexts|||acquire next source image|27422
||mov|3,scnpt|18,=num01||set scan pointer past continuation|27423
||mnz|3,scnbl|||set blanks flag|27424
||ejc|||||27425
|scn03|mov|8,wa|3,scnpt||load current offset|27431
||beq|8,wa|3,scnil|6,scn01|check continuation if end|27432
||mov|7,xl|3,r_cim||point to current line|27433
||plc|7,xl|8,wa||point to current character|27434
||mov|3,scnse|8,wa||set start of element location|27435
||mov|8,wc|21,=opdvs||point to operator dv list|27436
||mov|8,wb|19,*dvubs||set constant for operator circuit|27437
||brn|6,scn06|||start scanning|27438
|scn05|bze|8,wb|6,scn10||jump if trailing|27442
||icv|3,scnse|||increment start of element|27443
||beq|8,wa|3,scnil|6,scn01|jump if end of image|27444
||mnz|3,scnbl|||note blanks seen|27445
|scn06|lch|7,xr|10,(xl)+||get next character|27457
||icv|8,wa|||bump scan offset|27458
||mov|3,scnpt|8,wa||store offset past char scanned|27459
||bsw|7,xr|2,cfp_u|6,scn07|switch on scanned character|27461
||ejc|||||27488
||ejc|||||27544
||iff|1,0|6,scn07|||27577
||iff|1,1|6,scn07|||27577
||iff|1,2|6,scn07|||27577
||iff|1,3|6,scn07|||27577
||iff|1,4|6,scn07|||27577
||iff|1,5|6,scn07|||27577
||iff|1,6|6,scn07|||27577
||iff|1,7|6,scn07|||27577
||iff|1,8|6,scn07|||27577
||iff|2,ch_ht|6,scn05||horizontal tab|27577
||iff|1,10|6,scn07|||27577
||iff|1,11|6,scn07|||27577
||iff|1,12|6,scn07|||27577
||iff|1,13|6,scn07|||27577
||iff|1,14|6,scn07|||27577
||iff|1,15|6,scn07|||27577
||iff|1,16|6,scn07|||27577
||iff|1,17|6,scn07|||27577
||iff|1,18|6,scn07|||27577
||iff|1,19|6,scn07|||27577
||iff|1,20|6,scn07|||27577
||iff|1,21|6,scn07|||27577
||iff|1,22|6,scn07|||27577
||iff|1,23|6,scn07|||27577
||iff|1,24|6,scn07|||27577
||iff|1,25|6,scn07|||27577
||iff|1,26|6,scn07|||27577
||iff|1,27|6,scn07|||27577
||iff|1,28|6,scn07|||27577
||iff|1,29|6,scn07|||27577
||iff|1,30|6,scn07|||27577
||iff|1,31|6,scn07|||27577
||iff|2,ch_bl|6,scn05||blank|27577
||iff|2,ch_ex|6,scn37||exclamation mark|27577
||iff|2,ch_dq|6,scn17||double quote|27577
||iff|2,ch_nm|6,scn41||number sign|27577
||iff|2,ch_dl|6,scn36||dollar|27577
||iff|1,37|6,scn07|||27577
||iff|2,ch_am|6,scn44||ampersand|27577
||iff|2,ch_sq|6,scn16||single quote|27577
||iff|2,ch_pp|6,scn25||left paren|27577
||iff|2,ch_rp|6,scn26||right paren|27577
||iff|2,ch_as|6,scn49||asterisk|27577
||iff|2,ch_pl|6,scn33||plus|27577
||iff|2,ch_cm|6,scn31||comma|27577
||iff|2,ch_mn|6,scn34||minus|27577
||iff|2,ch_dt|6,scn32||dot|27577
||iff|2,ch_sl|6,scn40||slash|27577
||iff|2,ch_d0|6,scn08||digit 0|27577
||iff|2,ch_d1|6,scn08||digit 1|27577
||iff|2,ch_d2|6,scn08||digit 2|27577
||iff|2,ch_d3|6,scn08||digit 3|27577
||iff|2,ch_d4|6,scn08||digit 4|27577
||iff|2,ch_d5|6,scn08||digit 5|27577
||iff|2,ch_d6|6,scn08||digit 6|27577
||iff|2,ch_d7|6,scn08||digit 7|27577
||iff|2,ch_d8|6,scn08||digit 8|27577
||iff|2,ch_d9|6,scn08||digit 9|27577
||iff|2,ch_cl|6,scn29||colon|27577
||iff|2,ch_sm|6,scn30||semi-colon|27577
||iff|2,ch_bb|6,scn28||left bracket|27577
||iff|2,ch_eq|6,scn46||equal|27577
||iff|2,ch_rb|6,scn27||right bracket|27577
||iff|2,ch_qu|6,scn45||question mark|27577
||iff|2,ch_at|6,scn42||at|27577
||iff|2,ch_ua|6,scn09||shifted a|27577
||iff|2,ch_ub|6,scn09||shifted b|27577
||iff|2,ch_uc|6,scn09||shifted c|27577
||iff|2,ch_ud|6,scn09||shifted d|27577
||iff|2,ch_ue|6,scn09||shifted e|27577
||iff|2,ch_uf|6,scn20||shifted f|27577
||iff|2,ch_ug|6,scn09||shifted g|27577
||iff|2,ch_uh|6,scn09||shifted h|27577
||iff|2,ch_ui|6,scn09||shifted i|27577
||iff|2,ch_uj|6,scn09||shifted j|27577
||iff|2,ch_uk|6,scn09||shifted k|27577
||iff|2,ch_ul|6,scn09||shifted l|27577
||iff|2,ch_um|6,scn09||shifted m|27577
||iff|2,ch_un|6,scn09||shifted n|27577
||iff|2,ch_uo|6,scn09||shifted o|27577
||iff|2,ch_up|6,scn09||shifted p|27577
||iff|2,ch_uq|6,scn09||shifted q|27577
||iff|2,ch_ur|6,scn09||shifted r|27577
||iff|2,ch_us|6,scn21||shifted s|27577
||iff|2,ch_ut|6,scn09||shifted t|27577
||iff|2,ch_uu|6,scn09||shifted u|27577
||iff|2,ch_uv|6,scn09||shifted v|27577
||iff|2,ch_uw|6,scn09||shifted w|27577
||iff|2,ch_ux|6,scn09||shifted x|27577
||iff|2,ch_uy|6,scn09||shifted y|27577
||iff|2,ch_uz|6,scn09||shifted z|27577
||iff|2,ch_ob|6,scn28||left bracket|27577
||iff|1,92|6,scn07|||27577
||iff|2,ch_cb|6,scn27||right bracket|27577
||iff|2,ch_pc|6,scn38||percent|27577
||iff|2,ch_u_|6,scn24||underline|27577
||iff|1,96|6,scn07|||27577
||iff|2,ch_la|6,scn09||letter a|27577
||iff|2,ch_lb|6,scn09||letter b|27577
||iff|2,ch_lc|6,scn09||letter c|27577
||iff|2,ch_ld|6,scn09||letter d|27577
||iff|2,ch_le|6,scn09||letter e|27577
||iff|2,ch_lf|6,scn20||letter f|27577
||iff|2,ch_lg|6,scn09||letter g|27577
||iff|2,ch_lh|6,scn09||letter h|27577
||iff|2,ch_li|6,scn09||letter i|27577
||iff|2,ch_lj|6,scn09||letter j|27577
||iff|2,ch_lk|6,scn09||letter k|27577
||iff|2,ch_ll|6,scn09||letter l|27577
||iff|2,ch_lm|6,scn09||letter m|27577
||iff|2,ch_ln|6,scn09||letter n|27577
||iff|2,ch_lo|6,scn09||letter o|27577
||iff|2,ch_lp|6,scn09||letter p|27577
||iff|2,ch_lq|6,scn09||letter q|27577
||iff|2,ch_lr|6,scn09||letter r|27577
||iff|2,ch_ls|6,scn21||letter s|27577
||iff|2,ch_lt|6,scn09||letter t|27577
||iff|2,ch_lu|6,scn09||letter u|27577
||iff|2,ch_lv|6,scn09||letter v|27577
||iff|2,ch_lw|6,scn09||letter w|27577
||iff|2,ch_lx|6,scn09||letter x|27577
||iff|2,ch_ly|6,scn09||letter y|27577
||iff|2,ch_l_|6,scn09||letter z|27577
||iff|1,123|6,scn07|||27577
||iff|2,ch_br|6,scn43||vertical bar|27577
||iff|1,125|6,scn07|||27577
||iff|2,ch_nt|6,scn35||not|27577
||iff|1,127|6,scn07|||27577
||esw||||end switch on character|27577
|scn07|bze|8,wb|6,scn10||jump if scanning name or constant|27581
||erb|1,230|26,syntax error: illegal character|||27582
||ejc|||||27583
|scn08|bze|8,wb|6,scn09||keep scanning if name/constant|27589
||zer|8,wc|||else set flag for scanning constant|27590
|scn09|beq|8,wa|3,scnil|6,scn11|jump if end of image|27594
||zer|8,wb|||set flag for scanning name/const|27595
||brn|6,scn06|||merge back to continue scan|27596
|scn10|dcv|8,wa|||reset offset to point to delimiter|27600
|scn11|mov|3,scnpt|8,wa||store updated scan offset|27604
||mov|8,wb|3,scnse||point to start of element|27605
||sub|8,wa|8,wb||get number of characters|27606
||mov|7,xl|3,r_cim||point to line image|27607
||bnz|8,wc|6,scn15||jump if name|27608
||jsr|6,sbstr|||get string for constant|27612
||mov|3,dnamp|7,xr||delete from storage (not needed)|27613
||jsr|6,gtnum|||convert to numeric|27614
||ppm|6,scn14|||jump if conversion failure|27615
|scn12|mov|7,xl|18,=t_con||set result type of constant|27619
||ejc|||||27620
|scn13|mov|8,wa|3,scnsa||restore wa|27626
||mov|8,wb|3,scnsb||restore wb|27627
||mov|8,wc|3,scnsc||restore wc|27628
||mov|3,r_scp|7,xr||save xr in case rescan|27629
||mov|3,scntp|7,xl||save xl in case rescan|27630
||zer|3,scngo|||reset possible goto flag|27631
||exi||||return to scane caller|27632
|scn14|erb|1,231|26,syntax error: invalid numeric item|||27636
|scn15|jsr|6,sbstr|||build string name of variable|27640
||bnz|3,scncc|6,scn13||return if cncrd call|27641
||jsr|6,gtnvr|||locate/build vrblk|27642
||ppm||||dummy (unused) error return|27643
||mov|7,xl|18,=t_var||set type as variable|27644
||brn|6,scn13|||back to exit|27645
|scn16|bze|8,wb|6,scn10||terminator if scanning name or cnst|27649
||mov|8,wb|18,=ch_sq||set terminator as single quote|27650
||brn|6,scn18|||merge|27651
|scn17|bze|8,wb|6,scn10||terminator if scanning name or cnst|27655
||mov|8,wb|18,=ch_dq||set double quote terminator, merge|27656
|scn18|beq|8,wa|3,scnil|6,scn19|error if end of image|27660
||lch|8,wc|10,(xl)+||else load next character|27661
||icv|8,wa|||bump offset|27662
||bne|8,wc|8,wb|6,scn18|loop back if not terminator|27663
||ejc|||||27664
||mov|8,wb|3,scnpt||point to first character|27670
||mov|3,scnpt|8,wa||save offset past final quote|27671
||dcv|8,wa|||point back past last character|27672
||sub|8,wa|8,wb||get number of characters|27673
||mov|7,xl|3,r_cim||point to input image|27674
||jsr|6,sbstr|||build substring value|27675
||brn|6,scn12|||back to exit with constant result|27676
|scn19|mov|3,scnpt|8,wa||set updated scan pointer|27680
||erb|1,232|26,syntax error: unmatched string quote|||27681
|scn20|mov|7,xr|18,=t_fgo||set return code for fail goto|27685
||brn|6,scn22|||jump to merge|27686
|scn21|mov|7,xr|18,=t_sgo||set success goto as return code|27690
|scn22|bze|3,scngo|6,scn09||treat as normal letter if not goto|27694
|scn23|bze|8,wb|6,scn10||jump if end of name/constant|27698
||mov|7,xl|7,xr||else copy code|27699
||brn|6,scn13|||and jump to exit|27700
|scn24|bze|8,wb|6,scn09||part of name if scanning name|27704
||brn|6,scn07|||else illegal|27705
||ejc|||||27706
|scn25|mov|7,xr|18,=t_lpr||set left paren return code|27712
||bnz|8,wb|6,scn23||return left paren unless name|27713
||bze|8,wc|6,scn10||delimiter if scanning constant|27714
||mov|8,wb|3,scnse||point to start of name|27718
||mov|3,scnpt|8,wa||set pointer past left paren|27719
||dcv|8,wa|||point back past last char of name|27720
||sub|8,wa|8,wb||get name length|27721
||mov|7,xl|3,r_cim||point to input image|27722
||jsr|6,sbstr|||get string name for function|27723
||jsr|6,gtnvr|||locate/build vrblk|27724
||ppm||||dummy (unused) error return|27725
||mov|7,xl|18,=t_fnc||set code for function call|27726
||brn|6,scn13|||back to exit|27727
|scn26|mov|7,xr|18,=t_rpr||right paren, set code|27731
||brn|6,scn23|||take special character exit|27732
|scn27|mov|7,xr|18,=t_rbr||right bracket, set code|27734
||brn|6,scn23|||take special character exit|27735
|scn28|mov|7,xr|18,=t_lbr||left bracket, set code|27737
||brn|6,scn23|||take special character exit|27738
|scn29|mov|7,xr|18,=t_col||colon, set code|27740
||brn|6,scn23|||take special character exit|27741
|scn30|mov|7,xr|18,=t_smc||semi-colon, set code|27743
||brn|6,scn23|||take special character exit|27744
|scn31|mov|7,xr|18,=t_cma||comma, set code|27746
||brn|6,scn23|||take special character exit|27747
||ejc|||||27748
|scn32|bze|8,wb|6,scn09||dot can be part of name or constant|27760
||add|8,wc|8,wb||else bump pointer|27761
|scn33|bze|8,wc|6,scn09||plus can be part of constant|27763
||bze|8,wb|6,scn48||plus cannot be part of name|27764
||add|8,wc|8,wb||else bump pointer|27765
|scn34|bze|8,wc|6,scn09||minus can be part of constant|27767
||bze|8,wb|6,scn48||minus cannot be part of name|27768
||add|8,wc|8,wb||else bump pointer|27769
|scn35|add|8,wc|8,wb||not|27771
|scn36|add|8,wc|8,wb||dollar|27772
|scn37|add|8,wc|8,wb||exclamation|27773
|scn38|add|8,wc|8,wb||percent|27774
|scn39|add|8,wc|8,wb||asterisk|27775
|scn40|add|8,wc|8,wb||slash|27776
|scn41|add|8,wc|8,wb||number sign|27777
|scn42|add|8,wc|8,wb||at sign|27778
|scn43|add|8,wc|8,wb||vertical bar|27779
|scn44|add|8,wc|8,wb||ampersand|27780
|scn45|add|8,wc|8,wb||question mark|27781
|scn46|bze|8,wb|6,scn10||operator terminates name/constant|27786
||mov|7,xr|8,wc||else copy dv pointer|27787
||lch|8,wc|9,(xl)||load next character|27788
||mov|7,xl|18,=t_bop||set binary op in case|27789
||beq|8,wa|3,scnil|6,scn47|should be binary if image end|27790
||beq|8,wc|18,=ch_bl|6,scn47|should be binary if followed by blk|27791
||beq|8,wc|18,=ch_ht|6,scn47|jump if horizontal tab|27793
||beq|8,wc|18,=ch_sm|6,scn47|semicolon can immediately follow =|27798
||beq|8,wc|18,=ch_cl|6,scn47|colon can immediately follow =|27799
||beq|8,wc|18,=ch_rp|6,scn47|right paren can immediately follow =|27800
||beq|8,wc|18,=ch_rb|6,scn47|right bracket can immediately follow =|27801
||beq|8,wc|18,=ch_cb|6,scn47|right bracket can immediately follow =|27802
||add|7,xr|19,*dvbs_||point to dv for unary op|27806
||mov|7,xl|18,=t_uop||set type for unary operator|27807
||ble|3,scntp|18,=t_uok|6,scn13|ok unary if ok preceding element|27808
||ejc|||||27809
|scn47|bnz|3,scnbl|6,scn13||all ok if preceding blanks, exit|27815
|scn48|erb|1,233|26,syntax error: invalid use of operator|||27819
|scn49|bze|8,wb|6,scn10||end of name if scanning name|27823
||beq|8,wa|3,scnil|6,scn39|not ** if * at image end|27824
||mov|7,xr|8,wa||else save offset past first *|27825
||mov|3,scnof|8,wa||save another copy|27826
||lch|8,wa|10,(xl)+||load next character|27827
||bne|8,wa|18,=ch_as|6,scn50|not ** if next char not *|27828
||icv|7,xr|||else step offset past second *|27829
||beq|7,xr|3,scnil|6,scn51|ok exclam if end of image|27830
||lch|8,wa|9,(xl)||else load next character|27831
||beq|8,wa|18,=ch_bl|6,scn51|exclamation if blank|27832
||beq|8,wa|18,=ch_ht|6,scn51|exclamation if horizontal tab|27834
|scn50|mov|8,wa|3,scnof||recover stored offset|27842
||mov|7,xl|3,r_cim||point to line again|27843
||plc|7,xl|8,wa||point to current char|27844
||brn|6,scn39|||merge with unary *|27845
|scn51|mov|3,scnpt|7,xr||save scan pointer past 2nd *|27849
||mov|8,wa|7,xr||copy scan pointer|27850
||brn|6,scn37|||merge with exclamation|27851
||enp||||end procedure scane|27852
||ejc|||||27853
|scngf|prc|25,e|1,0||entry point|27870
||jsr|6,scane|||scan initial element|27871
||beq|7,xl|18,=t_lpr|6,scng1|skip if left paren (normal goto)|27872
||beq|7,xl|18,=t_lbr|6,scng2|skip if left bracket (direct goto)|27873
||erb|1,234|26,syntax error: goto field incorrect|||27874
|scng1|mov|8,wb|18,=num01||set expan flag for normal goto|27878
||jsr|6,expan|||analyze goto field|27879
||mov|8,wa|21,=opdvn||point to opdv for complex goto|27880
||ble|7,xr|3,statb|6,scng3|jump if not in static (sgd15)|27881
||blo|7,xr|3,state|6,scng4|jump to exit if simple label name|27882
||brn|6,scng3|||complex goto - merge|27883
|scng2|mov|8,wb|18,=num02||set expan flag for direct goto|27887
||jsr|6,expan|||scan goto field|27888
||mov|8,wa|21,=opdvd||set opdv pointer for direct goto|27889
||ejc|||||27890
|scng3|mov|11,-(xs)|8,wa||stack operator dv pointer|27896
||mov|11,-(xs)|7,xr||stack pointer to expression tree|27897
||jsr|6,expop|||pop operator off|27898
||mov|7,xr|10,(xs)+||reload new expression tree pointer|27899
|scng4|exi||||return to caller|27903
||enp||||end procedure scngf|27904
||ejc|||||27905
|setvr|prc|25,e|1,0||entry point|27920
||bhi|7,xr|3,state|6,setv1|exit if not natural variable|27921
||mov|7,xl|7,xr||copy vrblk pointer|27925
||mov|13,vrget(xr)|22,=b_vrl||store normal get value|27926
||beq|13,vrsto(xr)|22,=b_vre|6,setv1|skip if protected variable|27927
||mov|13,vrsto(xr)|22,=b_vrs||store normal store value|27928
||mov|7,xl|13,vrval(xl)||point to next entry on chain|27929
||bne|9,(xl)|22,=b_trt|6,setv1|jump if end of trblk chain|27930
||mov|13,vrget(xr)|22,=b_vra||store trapped routine address|27931
||mov|13,vrsto(xr)|22,=b_vrv||set trapped routine address|27932
|setv1|exi||||return to setvr caller|27936
||enp||||end procedure setvr|27937
||ejc|||||27940
||ejc|||||27977
|sorta|prc|25,n|1,1||entry point|27981
||mov|3,srtsr|8,wa||sort/rsort indicator|27982
||mov|3,srtst|19,*num01||default stride of 1|27983
||zer|3,srtof|||default zero offset to sort key|27984
||mov|3,srtdf|21,=nulls||clear datatype field name|27985
||mov|3,r_sxr|10,(xs)+||unstack argument 2|27986
||mov|7,xr|10,(xs)+||get first argument|27987
||mnz|8,wa|||use key/values of table entries|27988
||jsr|6,gtarr|||convert to array|27989
||ppm|6,srt18|||signal that table is empty|27990
||ppm|6,srt16|||error if non-convertable|27991
||mov|11,-(xs)|7,xr||stack ptr to resulting key array|27992
||mov|11,-(xs)|7,xr||another copy for copyb|27993
||jsr|6,copyb|||get copy array for sorting into|27994
||ppm||||cant fail|27995
||mov|11,-(xs)|7,xr||stack pointer to sort array|27996
||mov|7,xr|3,r_sxr||get second arg|27997
||mov|7,xl|13,num01(xs)||get ptr to key array|27998
||bne|9,(xl)|22,=b_vct|6,srt02|jump if arblk|27999
||beq|7,xr|21,=nulls|6,srt01|jump if null second arg|28000
||jsr|6,gtnvr|||get vrblk ptr for it|28001
||err|1,257|26,erroneous 2nd arg in sort/rsort of vector|||28002
||mov|3,srtdf|7,xr||store datatype field name vrblk|28003
|srt01|mov|8,wc|19,*vclen||offset to a(0)|28007
||mov|8,wb|19,*vcvls||offset to first item|28008
||mov|8,wa|13,vclen(xl)||get block length|28009
||sub|8,wa|19,*vcsi_||get no. of entries, n (in bytes)|28010
||brn|6,srt04|||merge|28011
|srt02|ldi|13,ardim(xl)|||get possible dimension|28015
||mfi|8,wa|||convert to short integer|28016
||wtb|8,wa|||further convert to baus|28017
||mov|8,wb|19,*arvls||offset to first value if one|28018
||mov|8,wc|19,*arpro||offset before values if one dim.|28019
||beq|13,arndm(xl)|18,=num01|6,srt04|jump in fact if one dim.|28020
||bne|13,arndm(xl)|18,=num02|6,srt16|fail unless two dimens|28021
||ldi|13,arlb2(xl)|||get lower bound 2 as default|28022
||beq|7,xr|21,=nulls|6,srt03|jump if default second arg|28023
||jsr|6,gtint|||convert to integer|28024
||ppm|6,srt17|||fail|28025
||ldi|13,icval(xr)|||get actual integer value|28026
||ejc|||||28027
|srt03|sbi|13,arlb2(xl)|||subtract low bound|28033
||iov|6,srt17|||fail if overflow|28034
||ilt|6,srt17|||fail if below low bound|28035
||sbi|13,ardm2(xl)|||check against dimension|28036
||ige|6,srt17|||fail if too large|28037
||adi|13,ardm2(xl)|||restore value|28038
||mfi|8,wa|||get as small integer|28039
||wtb|8,wa|||offset within row to key|28040
||mov|3,srtof|8,wa||keep offset|28041
||ldi|13,ardm2(xl)|||second dimension is row length|28042
||mfi|8,wa|||convert to short integer|28043
||mov|7,xr|8,wa||copy row length|28044
||wtb|8,wa|||convert to bytes|28045
||mov|3,srtst|8,wa||store as stride|28046
||ldi|13,ardim(xl)|||get number of rows|28047
||mfi|8,wa|||as a short integer|28048
||wtb|8,wa|||convert n to baus|28049
||mov|8,wc|13,arlen(xl)||offset past array end|28050
||sub|8,wc|8,wa||adjust, giving space for n offsets|28051
||dca|8,wc|||point to a(0)|28052
||mov|8,wb|13,arofs(xl)||offset to word before first item|28053
||ica|8,wb|||offset to first item|28054
|srt04|ble|8,wa|19,*num01|6,srt15|return if only a single item|28066
||mov|3,srtsn|8,wa||store number of items (in baus)|28067
||mov|3,srtso|8,wc||store offset to a(0)|28068
||mov|8,wc|13,arlen(xl)||length of array or vec (=vclen)|28069
||add|8,wc|7,xl||point past end of array or vector|28070
||mov|3,srtsf|8,wb||store offset to first row|28071
||add|7,xl|8,wb||point to first item in key array|28072
|srt05|mov|7,xr|9,(xl)||get an entry|28076
|srt06|bne|9,(xr)|22,=b_trt|6,srt07|jump out if not trblk|28080
||mov|7,xr|13,trval(xr)||get value field|28081
||brn|6,srt06|||loop|28082
||ejc|||||28083
|srt07|mov|10,(xl)+|7,xr||store as array entry|28089
||blt|7,xl|8,wc|6,srt05|loop if not done|28090
||mov|7,xl|9,(xs)||get adrs of sort array|28091
||mov|7,xr|3,srtsf||initial offset to first key|28092
||mov|8,wb|3,srtst||get stride|28093
||add|7,xl|3,srtso||offset to a(0)|28094
||ica|7,xl|||point to a(1)|28095
||mov|8,wc|3,srtsn||get n|28096
||btw|8,wc|||convert from bytes|28097
||mov|3,srtnr|8,wc||store as row count|28098
||lct|8,wc|8,wc||loop counter|28099
|srt08|mov|10,(xl)+|7,xr||store an offset|28103
||add|7,xr|8,wb||bump offset by stride|28104
||bct|8,wc|6,srt08||loop through rows|28105
|srt09|mov|8,wa|3,srtsn||get n|28112
||mov|8,wc|3,srtnr||get number of rows|28113
||rsh|8,wc|1,1||i = n / 2 (wc=i, index into array)|28114
||wtb|8,wc|||convert back to bytes|28115
|srt10|jsr|6,sorth|||sorth(i,n)|28119
||dca|8,wc|||i = i - 1|28120
||bnz|8,wc|6,srt10||loop if i gt 0|28121
||mov|8,wc|8,wa||i = n|28122
|srt11|dca|8,wc|||i = i - 1 (n - 1 initially)|28128
||bze|8,wc|6,srt12||jump if done|28129
||mov|7,xr|9,(xs)||get sort array address|28130
||add|7,xr|3,srtso||point to a(0)|28131
||mov|7,xl|7,xr||a(0) address|28132
||add|7,xl|8,wc||a(i) address|28133
||mov|8,wb|13,num01(xl)||copy a(i+1)|28134
||mov|13,num01(xl)|13,num01(xr)||move a(1) to a(i+1)|28135
||mov|13,num01(xr)|8,wb||complete exchange of a(1), a(i+1)|28136
||mov|8,wa|8,wc||n = i for sorth|28137
||mov|8,wc|19,*num01||i = 1 for sorth|28138
||jsr|6,sorth|||sorth(1,n)|28139
||mov|8,wc|8,wa||restore wc|28140
||brn|6,srt11|||loop|28141
||ejc|||||28142
|srt12|mov|7,xr|9,(xs)||base adrs of key array|28149
||mov|8,wc|7,xr||copy it|28150
||add|8,wc|3,srtso||offset of a(0)|28151
||add|7,xr|3,srtsf||adrs of first row of sort array|28152
||mov|8,wb|3,srtst||get stride|28153
|srt13|ica|8,wc|||adrs of next of sorted offsets|28158
||mov|7,xl|8,wc||copy it for access|28159
||mov|7,xl|9,(xl)||get offset|28160
||add|7,xl|13,num01(xs)||add key array base adrs|28161
||mov|8,wa|8,wb||get count of characters in row|28162
||mvw||||copy a complete row|28163
||dcv|3,srtnr|||decrement row count|28164
||bnz|3,srtnr|6,srt13||repeat till all rows done|28165
|srt15|mov|7,xr|10,(xs)+||pop result array ptr|28169
||ica|7,xs|||pop key array ptr|28170
||zer|3,r_sxl|||clear junk|28171
||zer|3,r_sxr|||clear junk|28172
||exi||||return|28173
|srt16|erb|1,256|26,sort/rsort 1st arg not suitable array or table|||28177
|srt17|erb|1,258|26,sort/rsort 2nd arg out of range or non-integer|||28178
|srt18|exi|1,1|||return indication of null table|28182
||enp||||end procudure sorta|28183
||ejc|||||28184
|sortc|prc|25,e|1,1||entry point|28205
||mov|3,srts1|8,wa||save offset 1|28206
||mov|3,srts2|8,wb||save offset 2|28207
||mov|3,srtsc|8,wc||save wc|28208
||add|7,xl|3,srtof||add offset to comparand field|28209
||mov|7,xr|7,xl||copy base + offset|28210
||add|7,xl|8,wa||add key1 offset|28211
||add|7,xr|8,wb||add key2 offset|28212
||mov|7,xl|9,(xl)||get key1|28213
||mov|7,xr|9,(xr)||get key2|28214
||bne|3,srtdf|21,=nulls|6,src12|jump if datatype field name used|28215
||ejc|||||28216
|src01|mov|8,wc|9,(xl)||get type code|28222
||bne|8,wc|9,(xr)|6,src02|skip if not same datatype|28223
||beq|8,wc|22,=b_scl|6,src09|jump if both strings|28224
||beq|8,wc|22,=b_icl|6,src14|jump if both integers|28225
|src02|mov|3,r_sxl|7,xl||keep arg1|28233
||mov|3,r_sxr|7,xr||keep arg2|28234
||beq|8,wc|22,=b_scl|6,src11|do not allow conversion to number|28237
||beq|9,(xr)|22,=b_scl|6,src11|if either arg is a string|28238
|src14|mov|11,-(xs)|7,xl||stack|28281
||mov|11,-(xs)|7,xr||args|28282
||jsr|6,acomp|||compare objects|28283
||ppm|6,src10|||not numeric|28284
||ppm|6,src10|||not numeric|28285
||ppm|6,src03|||key1 less|28286
||ppm|6,src08|||keys equal|28287
||ppm|6,src05|||key1 greater|28288
|src03|bnz|3,srtsr|6,src06||jump if rsort|28292
|src04|mov|8,wc|3,srtsc||restore wc|28294
||exi|1,1|||return|28295
|src05|bnz|3,srtsr|6,src04||jump if rsort|28299
|src06|mov|8,wc|3,srtsc||restore wc|28301
||exi||||return|28302
|src07|blt|7,xl|7,xr|6,src03|item first created is less|28306
||bgt|7,xl|7,xr|6,src05|addresses rise in order of creation|28307
|src08|blt|3,srts1|3,srts2|6,src04|test offsets or key addrss instead|28311
||brn|6,src06|||offset 1 greater|28312
||ejc|||||28313
|src09|mov|11,-(xs)|7,xl||stack|28323
||mov|11,-(xs)|7,xr||args|28324
||jsr|6,lcomp|||compare objects|28325
||ppm||||cant|28326
||ppm||||fail|28327
||ppm|6,src03|||key1 less|28328
||ppm|6,src08|||keys equal|28329
||ppm|6,src05|||key1 greater|28330
|src10|mov|7,xl|3,r_sxl||get arg1|28334
||mov|7,xr|3,r_sxr||get arg2|28335
||mov|8,wc|9,(xl)||get type of key1|28336
||beq|8,wc|9,(xr)|6,src07|jump if keys of same type|28337
|src11|mov|7,xl|8,wc||get block type word|28341
||mov|7,xr|9,(xr)||get block type word|28342
||lei|7,xl|||entry point id for key1|28343
||lei|7,xr|||entry point id for key2|28344
||bgt|7,xl|7,xr|6,src05|jump if key1 gt key2|28345
||brn|6,src03|||key1 lt key2|28346
|src12|jsr|6,sortf|||call routine to find field 1|28350
||mov|11,-(xs)|7,xl||stack item pointer|28351
||mov|7,xl|7,xr||get key2|28352
||jsr|6,sortf|||find field 2|28353
||mov|7,xr|7,xl||place as key2|28354
||mov|7,xl|10,(xs)+||recover key1|28355
||brn|6,src01|||merge|28356
||enp||||procedure sortc|28357
||ejc|||||28358
|sortf|prc|25,e|1,0||entry point|28376
||bne|9,(xl)|22,=b_pdt|6,srtf3|return if not pdblk|28377
||mov|11,-(xs)|7,xr||keep xr|28378
||mov|7,xr|3,srtfd||get possible former dfblk ptr|28379
||bze|7,xr|6,srtf4||jump if not|28380
||bne|7,xr|13,pddfp(xl)|6,srtf4|jump if not right datatype|28381
||bne|3,srtdf|3,srtff|6,srtf4|jump if not right field name|28382
||add|7,xl|3,srtfo||add offset to required field|28383
|srtf1|mov|7,xl|9,(xl)||get item from field|28387
|srtf2|mov|7,xr|10,(xs)+||restore xr|28391
|srtf3|exi||||return|28393
||ejc|||||28394
|srtf4|mov|7,xr|7,xl||copy original pointer|28400
||mov|7,xr|13,pddfp(xr)||point to dfblk|28401
||mov|3,srtfd|7,xr||keep a copy|28402
||mov|8,wc|13,fargs(xr)||get number of fields|28403
||wtb|8,wc|||convert to bytes|28404
||add|7,xr|13,dflen(xr)||point past last field|28405
|srtf5|dca|8,wc|||count down|28409
||dca|7,xr|||point in front|28410
||beq|9,(xr)|3,srtdf|6,srtf6|skip out if found|28411
||bnz|8,wc|6,srtf5||loop|28412
||brn|6,srtf2|||return - not found|28413
|srtf6|mov|3,srtff|9,(xr)||keep field name ptr|28417
||add|8,wc|19,*pdfld||add offset to first field|28418
||mov|3,srtfo|8,wc||store as field offset|28419
||add|7,xl|8,wc||point to field|28420
||brn|6,srtf1|||return|28421
||enp||||procedure sortf|28422
||ejc|||||28423
|sorth|prc|25,n|1,0||entry point|28438
||mov|3,srtsn|8,wa||save n|28439
||mov|3,srtwc|8,wc||keep wc|28440
||mov|7,xl|9,(xs)||sort array base adrs|28441
||add|7,xl|3,srtso||add offset to a(0)|28442
||add|7,xl|8,wc||point to a(j)|28443
||mov|3,srtrt|9,(xl)||get offset to root|28444
||add|8,wc|8,wc||double j - cant exceed n|28445
|srh01|bgt|8,wc|3,srtsn|6,srh03|done if j gt n|28449
||beq|8,wc|3,srtsn|6,srh02|skip if j equals n|28450
||mov|7,xr|9,(xs)||sort array base adrs|28451
||mov|7,xl|13,num01(xs)||key array base adrs|28452
||add|7,xr|3,srtso||point to a(0)|28453
||add|7,xr|8,wc||adrs of a(j)|28454
||mov|8,wa|13,num01(xr)||get a(j+1)|28455
||mov|8,wb|9,(xr)||get a(j)|28456
||jsr|6,sortc|||compare keys - lt(a(j+1),a(j))|28460
||ppm|6,srh02|||a(j+1) lt a(j)|28461
||ica|8,wc|||point to greater son, a(j+1)|28462
||ejc|||||28463
|srh02|mov|7,xl|13,num01(xs)||key array base adrs|28469
||mov|7,xr|9,(xs)||get sort array address|28470
||add|7,xr|3,srtso||adrs of a(0)|28471
||mov|8,wb|7,xr||copy this adrs|28472
||add|7,xr|8,wc||adrs of greater son, a(j)|28473
||mov|8,wa|9,(xr)||get a(j)|28474
||mov|7,xr|8,wb||point back to a(0)|28475
||mov|8,wb|3,srtrt||get root|28476
||jsr|6,sortc|||compare them - lt(a(j),root)|28477
||ppm|6,srh03|||father exceeds sons - done|28478
||mov|7,xr|9,(xs)||get sort array adrs|28479
||add|7,xr|3,srtso||point to a(0)|28480
||mov|7,xl|7,xr||copy it|28481
||mov|8,wa|8,wc||copy j|28482
||btw|8,wc|||convert to words|28483
||rsh|8,wc|1,1||get j/2|28484
||wtb|8,wc|||convert back to bytes|28485
||add|7,xl|8,wa||point to a(j)|28486
||add|7,xr|8,wc||adrs of a(j/2)|28487
||mov|9,(xr)|9,(xl)||a(j/2) = a(j)|28488
||mov|8,wc|8,wa||recover j|28489
||aov|8,wc|8,wc|6,srh03|j = j*2. done if too big|28490
||brn|6,srh01|||loop|28491
|srh03|btw|8,wc|||convert to words|28495
||rsh|8,wc|1,1||j = j/2|28496
||wtb|8,wc|||convert back to bytes|28497
||mov|7,xr|9,(xs)||sort array adrs|28498
||add|7,xr|3,srtso||adrs of a(0)|28499
||add|7,xr|8,wc||adrs of a(j/2)|28500
||mov|9,(xr)|3,srtrt||a(j/2) = root|28501
||mov|8,wa|3,srtsn||restore wa|28502
||mov|8,wc|3,srtwc||restore wc|28503
||exi||||return|28504
||enp||||end procedure sorth|28505
||ejc|||||28507
|trace|prc|25,n|1,2||entry point|28523
||jsr|6,gtstg|||get trace type string|28524
||ppm|6,trc15|||jump if not string|28525
||plc|7,xr|||else point to string|28526
||lch|8,wa|9,(xr)||load first character|28527
||flc|8,wa|||fold to lower case|28529
||mov|7,xr|9,(xs)||load name argument|28531
||mov|9,(xs)|7,xl||stack trblk ptr or zero|28532
||mov|8,wc|18,=trtac||set trtyp for access trace|28533
||beq|8,wa|18,=ch_la|6,trc10|jump if a (access)|28534
||mov|8,wc|18,=trtvl||set trtyp for value trace|28535
||beq|8,wa|18,=ch_lv|6,trc10|jump if v (value)|28536
||beq|8,wa|18,=ch_bl|6,trc10|jump if blank (value)|28537
||beq|8,wa|18,=ch_lf|6,trc01|jump if f (function)|28541
||beq|8,wa|18,=ch_lr|6,trc01|jump if r (return)|28542
||beq|8,wa|18,=ch_ll|6,trc03|jump if l (label)|28543
||beq|8,wa|18,=ch_lk|6,trc06|jump if k (keyword)|28544
||bne|8,wa|18,=ch_lc|6,trc15|else error if not c (call)|28545
|trc01|jsr|6,gtnvr|||point to vrblk for name|28549
||ppm|6,trc16|||jump if bad name|28550
||ica|7,xs|||pop stack|28551
||mov|7,xr|13,vrfnc(xr)||point to function block|28552
||bne|9,(xr)|22,=b_pfc|6,trc17|error if not program function|28553
||beq|8,wa|18,=ch_lr|6,trc02|jump if r (return)|28554
||ejc|||||28555
||mov|13,pfctr(xr)|7,xl||set/reset call trace|28561
||beq|8,wa|18,=ch_lc|6,exnul|exit with null if c (call)|28562
|trc02|mov|13,pfrtr(xr)|7,xl||set/reset return trace|28566
||exi||||return|28567
|trc03|jsr|6,gtnvr|||point to vrblk|28571
||ppm|6,trc16|||jump if bad name|28572
||mov|7,xl|13,vrlbl(xr)||load label pointer|28573
||bne|9,(xl)|22,=b_trt|6,trc04|jump if no old trace|28574
||mov|7,xl|13,trlbl(xl)||else delete old trace association|28575
|trc04|beq|7,xl|21,=stndl|6,trc16|error if undefined label|28579
||mov|8,wb|10,(xs)+||get trblk ptr again|28580
||bze|8,wb|6,trc05||jump if stoptr case|28581
||mov|13,vrlbl(xr)|8,wb||else set new trblk pointer|28582
||mov|13,vrtra(xr)|22,=b_vrt||set label trace routine address|28583
||mov|7,xr|8,wb||copy trblk pointer|28584
||mov|13,trlbl(xr)|7,xl||store real label in trblk|28585
||exi||||return|28586
|trc05|mov|13,vrlbl(xr)|7,xl||store label ptr back in vrblk|28590
||mov|13,vrtra(xr)|22,=b_vrg||store normal transfer address|28591
||exi||||return|28592
||ejc|||||28593
|trc06|jsr|6,gtnvr|||point to vrblk|28599
||ppm|6,trc16|||error if not natural var|28600
||bnz|13,vrlen(xr)|6,trc16||error if not system var|28601
||ica|7,xs|||pop stack|28602
||bze|7,xl|6,trc07||jump if stoptr case|28603
||mov|13,trkvr(xl)|7,xr||store vrblk ptr in trblk for ktrex|28604
|trc07|mov|7,xr|13,vrsvp(xr)||point to svblk|28608
||beq|7,xr|21,=v_ert|6,trc08|jump if errtype|28609
||beq|7,xr|21,=v_stc|6,trc09|jump if stcount|28610
||bne|7,xr|21,=v_fnc|6,trc17|else error if not fnclevel|28611
||mov|3,r_fnc|7,xl||set/reset fnclevel trace|28615
||exi||||return|28616
|trc08|mov|3,r_ert|7,xl||set/reset errtype trace|28620
||exi||||return|28621
|trc09|mov|3,r_stc|7,xl||set/reset stcount trace|28625
||jsr|6,stgcc|||update countdown counters|28626
||exi||||return|28627
||ejc|||||28628
|trc10|jsr|6,gtvar|||locate variable|28634
||ppm|6,trc16|||error if not appropriate name|28635
||mov|8,wb|10,(xs)+||get new trblk ptr again|28636
||add|8,wa|7,xl||point to variable location|28637
||mov|7,xr|8,wa||copy variable pointer|28638
|trc11|mov|7,xl|9,(xr)||point to next entry|28642
||bne|9,(xl)|22,=b_trt|6,trc13|jump if not trblk|28643
||blt|8,wc|13,trtyp(xl)|6,trc13|jump if too far out on chain|28644
||beq|8,wc|13,trtyp(xl)|6,trc12|jump if this matches our type|28645
||add|7,xl|19,*trnxt||else point to link field|28646
||mov|7,xr|7,xl||copy pointer|28647
||brn|6,trc11|||and loop back|28648
|trc12|mov|7,xl|13,trnxt(xl)||get ptr to next block or value|28652
||mov|9,(xr)|7,xl||store to delete this trblk|28653
|trc13|bze|8,wb|6,trc14||jump if stoptr case|28657
||mov|9,(xr)|8,wb||else link new trblk in|28658
||mov|7,xr|8,wb||copy trblk pointer|28659
||mov|13,trnxt(xr)|7,xl||store forward pointer|28660
||mov|13,trtyp(xr)|8,wc||store appropriate trap type code|28661
|trc14|mov|7,xr|8,wa||recall possible vrblk pointer|28665
||sub|7,xr|19,*vrval||point back to vrblk|28666
||jsr|6,setvr|||set fields if vrblk|28667
||exi||||return|28668
|trc15|exi|1,2|||take bad trace type error exit|28672
|trc16|ica|7,xs|||pop stack|28676
|trc17|exi|1,1|||take bad name error exit|28680
||enp||||end procedure trace|28681
||ejc|||||28682
|trbld|prc|25,e|1,0||entry point|28696
||mov|11,-(xs)|7,xr||stack trtag (or trfnm)|28697
||mov|8,wa|19,*trsi_||set size of trblk|28698
||jsr|6,alloc|||allocate trblk|28699
||mov|9,(xr)|22,=b_trt||store first word|28700
||mov|13,trfnc(xr)|7,xl||store trfnc (or trfpt)|28701
||mov|13,trtag(xr)|10,(xs)+||store trtag (or trfnm)|28702
||mov|13,trtyp(xr)|8,wb||store type|28703
||mov|13,trval(xr)|21,=nulls||for now, a null value|28704
||exi||||return to caller|28705
||enp||||end procedure trbld|28706
||ejc|||||28707
|trimr|prc|25,e|1,0||entry point|28725
||mov|7,xl|7,xr||copy string pointer|28726
||mov|8,wa|13,sclen(xr)||load string length|28727
||bze|8,wa|6,trim2||jump if null input|28728
||plc|7,xl|8,wa||else point past last character|28729
||bze|8,wb|6,trim3||jump if no trim|28730
||mov|8,wc|18,=ch_bl||load blank character|28731
|trim0|lch|8,wb|11,-(xl)||load next character|28735
||beq|8,wb|18,=ch_ht|6,trim1|jump if horizontal tab|28737
||bne|8,wb|8,wc|6,trim3|jump if non-blank found|28739
|trim1|dcv|8,wa|||else decrement character count|28740
||bnz|8,wa|6,trim0||loop back if more to check|28741
|trim2|mov|3,dnamp|7,xr||wipe out input string block|28745
||mov|7,xr|21,=nulls||load null result|28746
||brn|6,trim5|||merge to exit|28747
||ejc|||||28748
|trim3|mov|13,sclen(xr)|8,wa||set new length|28754
||mov|7,xl|7,xr||copy string pointer|28755
||psc|7,xl|8,wa||ready for storing blanks|28756
||ctb|8,wa|2,schar||get length of block in bytes|28757
||add|8,wa|7,xr||point past new block|28758
||mov|3,dnamp|8,wa||set new top of storage pointer|28759
||lct|8,wa|18,=cfp_c||get count of chars in word|28760
||zer|8,wc|||set zero char|28761
|trim4|sch|8,wc|10,(xl)+||store zero character|28765
||bct|8,wa|6,trim4||loop back till all stored|28766
||csc|7,xl|||complete store characters|28767
|trim5|zer|7,xl|||clear garbage xl pointer|28771
||exi||||return to caller|28772
||enp||||end procedure trimr|28773
||ejc|||||28774
|trxeq|prc|25,r|1,0||entry point (recursive)|28805
||mov|8,wc|3,r_cod||load code block pointer|28806
||scp|8,wb|||get current code pointer|28807
||sub|8,wb|8,wc||make code pointer into offset|28808
||mov|11,-(xs)|3,kvtra||stack trace keyword value|28809
||mov|11,-(xs)|7,xr||stack trblk pointer|28810
||mov|11,-(xs)|7,xl||stack name base|28811
||mov|11,-(xs)|8,wa||stack name offset|28812
||mov|11,-(xs)|8,wc||stack code block pointer|28813
||mov|11,-(xs)|8,wb||stack code pointer offset|28814
||mov|11,-(xs)|3,flptr||stack old failure pointer|28815
||zer|11,-(xs)|||set dummy fail offset|28816
||mov|3,flptr|7,xs||set new failure pointer|28817
||zer|3,kvtra|||reset trace keyword to zero|28818
||mov|8,wc|21,=trxdc||load new (dummy) code blk pointer|28819
||mov|3,r_cod|8,wc||set as code block pointer|28820
||lcp|8,wc|||and new code pointer|28821
||ejc|||||28822
||mov|8,wb|8,wa||save name offset|28828
||mov|8,wa|19,*nmsi_||load nmblk size|28829
||jsr|6,alloc|||allocate space for nmblk|28830
||mov|9,(xr)|22,=b_nml||set type word|28831
||mov|13,nmbas(xr)|7,xl||store name base|28832
||mov|13,nmofs(xr)|8,wb||store name offset|28833
||mov|7,xl|12,6(xs)||reload pointer to trblk|28834
||mov|11,-(xs)|7,xr||stack nmblk pointer (1st argument)|28835
||mov|11,-(xs)|13,trtag(xl)||stack trace tag (2nd argument)|28836
||mov|7,xl|13,trfnc(xl)||load trace vrblk pointer|28837
||mov|7,xl|13,vrfnc(xl)||load trace function pointer|28838
||beq|7,xl|21,=stndf|6,trxq2|jump if not a defined function|28839
||mov|8,wa|18,=num02||set number of arguments to two|28840
||brn|6,cfunc|||jump to call function|28841
|trxq1|mov|7,xs|3,flptr||point back to our stack entries|28845
||ica|7,xs|||pop off garbage fail offset|28846
||mov|3,flptr|10,(xs)+||restore old failure pointer|28847
||mov|8,wb|10,(xs)+||reload code offset|28848
||mov|8,wc|10,(xs)+||load old code base pointer|28849
||mov|7,xr|8,wc||copy cdblk pointer|28850
||mov|3,kvstn|13,cdstm(xr)||restore stmnt no|28851
||mov|8,wa|10,(xs)+||reload name offset|28852
||mov|7,xl|10,(xs)+||reload name base|28853
||mov|7,xr|10,(xs)+||reload trblk pointer|28854
||mov|3,kvtra|10,(xs)+||restore trace keyword value|28855
||add|8,wb|8,wc||recompute absolute code pointer|28856
||lcp|8,wb|||restore code pointer|28857
||mov|3,r_cod|8,wc||and code block pointer|28858
||exi||||return to trxeq caller|28859
|trxq2|erb|1,197|26,trace fourth arg is not function name or null|||28863
||enp||||end procedure trxeq|28865
||ejc|||||28866
||ejc|||||28906
|xscan|prc|25,e|1,0||entry point|28910
||mov|3,xscwb|8,wb||preserve wb|28911
||mov|11,-(xs)|8,wa||record blank skip flag|28912
||mov|11,-(xs)|8,wa||and second copy|28913
||mov|7,xr|3,r_xsc||point to argument string|28914
||mov|8,wa|13,sclen(xr)||load string length|28915
||mov|8,wb|3,xsofs||load current offset|28916
||sub|8,wa|8,wb||get number of remaining characters|28917
||bze|8,wa|6,xscn3||jump if no characters left|28918
||plc|7,xr|8,wb||point to current character|28919
|xscn1|lch|8,wb|10,(xr)+||load next character|28923
||beq|8,wb|8,wc|6,xscn4|jump if delimiter one found|28924
||beq|8,wb|7,xl|6,xscn5|jump if delimiter two found|28925
||bze|9,(xs)|6,xscn2||jump if not skipping blanks|28926
||icv|3,xsofs|||assume blank and delete it|28927
||beq|8,wb|18,=ch_ht|6,xscn2|jump if horizontal tab|28929
||beq|8,wb|18,=ch_bl|6,xscn2|jump if blank|28934
||dcv|3,xsofs|||undelete non-blank character|28935
||zer|9,(xs)|||and discontinue blank checking|28936
|xscn2|dcv|8,wa|||decrement count of chars left|28940
||bnz|8,wa|6,xscn1||loop back if more chars to go|28941
|xscn3|mov|7,xl|3,r_xsc||point to string block|28945
||mov|8,wa|13,sclen(xl)||get string length|28946
||mov|8,wb|3,xsofs||load offset|28947
||sub|8,wa|8,wb||get substring length|28948
||zer|3,r_xsc|||clear string ptr for collector|28949
||zer|3,xscrt|||set zero (runout) return code|28950
||brn|6,xscn7|||jump to exit|28951
||ejc|||||28952
|xscn4|mov|3,xscrt|18,=num01||set return code|28958
||brn|6,xscn6|||jump to merge|28959
|xscn5|mov|3,xscrt|18,=num02||set return code|28963
|xscn6|mov|7,xl|3,r_xsc||reload pointer to string|28967
||mov|8,wc|13,sclen(xl)||get original length of string|28968
||sub|8,wc|8,wa||minus chars left = chars scanned|28969
||mov|8,wa|8,wc||move to reg for sbstr|28970
||mov|8,wb|3,xsofs||set offset|28971
||sub|8,wa|8,wb||compute length for sbstr|28972
||icv|8,wc|||adjust new cursor past delimiter|28973
||mov|3,xsofs|8,wc||store new offset|28974
|xscn7|zer|7,xr|||clear garbage character ptr in xr|28978
||jsr|6,sbstr|||build sub-string|28979
||ica|7,xs|||remove copy of blank flag|28980
||mov|8,wb|10,(xs)+||original blank skip/trim flag|28981
||bze|13,sclen(xr)|6,xscn8||cannot trim the null string|28982
||jsr|6,trimr|||trim trailing blanks if requested|28983
|xscn8|mov|8,wa|3,xscrt||load return code|28987
||mov|8,wb|3,xscwb||restore wb|28988
||exi||||return to xscan caller|28989
||enp||||end procedure xscan|28990
||ejc|||||28991
|xscni|prc|25,n|1,2||entry point|29008
||jsr|6,gtstg|||fetch argument as string|29009
||ppm|6,xsci1|||jump if not convertible|29010
||mov|3,r_xsc|7,xr||else store scblk ptr for xscan|29011
||zer|3,xsofs|||set offset to zero|29012
||bze|8,wa|6,xsci2||jump if null string|29013
||exi||||return to xscni caller|29014
|xsci1|exi|1,1|||take not-string error exit|29018
|xsci2|exi|1,2|||take null-string error exit|29022
||enp||||end procedure xscni|29023
||ttl|27,s p i t b o l -- stack overflow section||||29024
||sec||||start of stack overflow section|29028
||add|3,errft|18,=num04||force conclusive fatal error|29030
||mov|7,xs|3,flptr||pop stack to avoid more fails|29031
||bnz|3,gbcfl|6,stak1||jump if garbage collecting|29032
||erb|1,246|26,stack overflow|||29033
|stak1|mov|7,xr|21,=endso||point to message|29037
||zer|3,kvdmp|||memory is undumpable|29038
||brn|6,stopr|||give up|29039
||ttl|27,s p i t b o l -- error section||||29040
||sec||||start of error section|29070
|error|beq|3,r_cim|20,=cmlab|6,cmple|jump if error in scanning label|29072
||mov|3,kvert|8,wa||save error code|29073
||zer|3,scnrs|||reset rescan switch for scane|29074
||zer|3,scngo|||reset goto switch for scane|29075
||mov|3,polcs|18,=num01||reset poll count|29077
||mov|3,polct|18,=num01||reset poll count|29078
||mov|7,xr|3,stage||load current stage|29080
||bsw|7,xr|2,stgno||jump to appropriate error circuit|29081
||iff|2,stgic|6,err01||initial compile|29089
||iff|2,stgxc|6,err04||execute time compile|29089
||iff|2,stgev|6,err04||eval compiling expr.|29089
||iff|2,stgxt|6,err05||execute time|29089
||iff|2,stgce|6,err01||compile - after end|29089
||iff|2,stgxe|6,err04||xeq compile-past end|29089
||iff|2,stgee|6,err04||eval evaluating expr|29089
||esw||||end switch on error type|29089
||ejc|||||29090
|err01|mov|7,xs|3,cmpxs||reset stack pointer|29106
||ssl|3,cmpss|||restore s-r stack ptr for cmpil|29107
||bnz|3,errsp|6,err03||jump if error suppress flag set|29108
||mov|8,wc|3,cmpsn||current statement|29111
||jsr|6,filnm|||obtain file name for this statement|29112
||mov|8,wb|3,scnse||column number|29114
||mov|8,wc|3,rdcln||line number|29115
||mov|7,xr|3,stage|||29116
||jsr|6,sysea|||advise system of error|29117
||ppm|6,erra3|||if system does not want print|29118
||mov|11,-(xs)|7,xr||save any provided print message|29119
||mov|3,erlst|3,erich||set flag for listr|29121
||jsr|6,listr|||list line|29122
||jsr|6,prtis|||terminate listing|29123
||zer|3,erlst|||clear listr flag|29124
||mov|8,wa|3,scnse||load scan element offset|29125
||bze|8,wa|6,err02||skip if not set|29126
||lct|8,wb|8,wa||loop counter|29128
||icv|8,wa|||increase for ch_ex|29129
||mov|7,xl|3,r_cim||point to bad statement|29130
||jsr|6,alocs|||string block for error flag|29131
||mov|8,wa|7,xr||remember string ptr|29132
||psc|7,xr|||ready for character storing|29133
||plc|7,xl|||ready to get chars|29134
|erra1|lch|8,wc|10,(xl)+||get next char|29138
||beq|8,wc|18,=ch_ht|6,erra2|skip if tab|29139
||mov|8,wc|18,=ch_bl||get a blank|29140
||ejc|||||29141
|erra2|sch|8,wc|10,(xr)+||store char|29145
||bct|8,wb|6,erra1||loop|29146
||mov|7,xl|18,=ch_ex||exclamation mark|29147
||sch|7,xl|9,(xr)||store at end of error line|29148
||csc|7,xr|||end of sch loop|29149
||mov|3,profs|18,=stnpd||allow for statement number|29150
||mov|7,xr|8,wa||point to error line|29151
||jsr|6,prtst|||print error line|29152
|err02|jsr|6,prtis|||print blank line|29166
||mov|7,xr|10,(xs)+||restore any sysea message|29168
||bze|7,xr|6,erra0||did sysea provide message to print|29169
||jsr|6,prtst|||print sysea message|29170
|erra0|jsr|6,ermsg|||generate flag and error message|29172
||add|3,lstlc|18,=num03||bump page ctr for blank, error, blk|29173
|erra3|zer|7,xr|||in case of fatal error|29174
||bhi|3,errft|18,=num03|6,stopr|pack up if several fatals|29175
||icv|3,cmerc|||bump error count|29179
||add|3,noxeq|3,cswer||inhibit xeq if -noerrors|29180
||bne|3,stage|18,=stgic|6,cmp10|special return if after end line|29181
||ejc|||||29182
|err03|mov|7,xr|3,r_cim||point to start of image|29186
||plc|7,xr|||point to first char|29187
||lch|7,xr|9,(xr)||get first char|29188
||beq|7,xr|18,=ch_mn|6,cmpce|jump if error in control card|29189
||zer|3,scnrs|||clear rescan flag|29190
||mnz|3,errsp|||set error suppress flag|29191
||jsr|6,scane|||scan next element|29192
||bne|7,xl|18,=t_smc|6,err03|loop back if not statement end|29193
||zer|3,errsp|||clear error suppress flag|29194
||mov|3,cwcof|19,*cdcod||reset offset in ccblk|29198
||mov|8,wa|21,=ocer_||load compile error call|29199
||jsr|6,cdwrd|||generate it|29200
||mov|13,cmsoc(xs)|3,cwcof||set success fill in offset|29201
||mnz|13,cmffc(xs)|||set failure fill in flag|29202
||jsr|6,cdwrd|||generate succ. fill in word|29203
||brn|6,cmpse|||merge to generate error as cdfal|29204
|err04|bge|3,errft|18,=num03|6,labo1|abort if too many fatal errors|29214
||beq|3,kvert|18,=nm320|6,err06|treat user interrupt specially|29216
||zer|3,r_ccb|||forget garbage code block|29218
||mov|3,cwcof|19,*cccod||set initial offset (mbe catspaw)|29219
||ssl|3,iniss|||restore main prog s-r stack ptr|29220
||jsr|6,ertex|||get fail message text|29221
||dca|7,xs|||ensure stack ok on loop start|29222
|erra4|ica|7,xs|||pop stack|29227
||beq|7,xs|3,flprt|6,errc4|jump if prog defined fn call found|29228
||bne|7,xs|3,gtcef|6,erra4|loop if not eval or code call yet|29229
||mov|3,stage|18,=stgxt||re-set stage for execute|29230
||mov|3,r_cod|3,r_gtc||recover code ptr|29231
||mov|3,flptr|7,xs||restore fail pointer|29232
||zer|3,r_cim|||forget possible image|29233
||zer|3,cnind|||forget possible include|29235
|errb4|bnz|3,kverl|6,err07||jump if errlimit non-zero|29240
||brn|6,exfal|||fail|29241
|errc4|mov|7,xs|3,flptr||restore stack from flptr|29245
||brn|6,errb4|||merge|29246
||ejc|||||29247
|err05|ssl|3,iniss|||restore main prog s-r stack ptr|29265
||bnz|3,dmvch|6,err08||jump if in mid-dump|29266
|err06|bze|3,kverl|6,labo1||abort if errlimit is zero|29270
||jsr|6,ertex|||get fail message text|29271
|err07|bge|3,errft|18,=num03|6,labo1|abort if too many fatal errors|29275
||dcv|3,kverl|||decrement errlimit|29276
||mov|7,xl|3,r_ert||load errtype trace pointer|29277
||jsr|6,ktrex|||generate errtype trace if required|29278
||mov|8,wa|3,r_cod||get current code block|29279
||mov|3,r_cnt|8,wa||set cdblk ptr for continuation|29280
||scp|8,wb|||current code pointer|29281
||sub|8,wb|8,wa||offset within code block|29282
||mov|3,stxoc|8,wb||save code ptr offset for scontinue|29283
||mov|7,xr|3,flptr||set ptr to failure offset|29284
||mov|3,stxof|9,(xr)||save failure offset for continue|29285
||mov|7,xr|3,r_sxc||load setexit cdblk pointer|29286
||bze|7,xr|6,lcnt1||continue if no setexit trap|29287
||zer|3,r_sxc|||else reset trap|29288
||mov|3,stxvr|21,=nulls||reset setexit arg to null|29289
||mov|7,xl|9,(xr)||load ptr to code block routine|29290
||bri|7,xl|||execute first trap statement|29291
|err08|mov|7,xr|3,dmvch||chain head for affected vrblks|29296
||bze|7,xr|6,err06||done if zero|29297
||mov|3,dmvch|9,(xr)||set next link as chain head|29298
||jsr|6,setvr|||restore vrget field|29299
|s_yyy|brn|6,err08|||loop through chain|29303
||ttl|27,s p i t b o l -- here endeth the code||||29304
||end||||end macro-spitbol assembly|29308
