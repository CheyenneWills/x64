       TTL  L I C E N S E -- SOFTWARE LICENSE FOR THIS PROGRAM
.DEF   .CAEX                 DEFINE TO ALLOW UP ARROW FOR EXPON.
.DEF   .CAHT                 DEFINE TO INCLUDE HORIZONTAL TAB
.DEF   .CASL                 DEFINE TO INCLUDE 26 SHIFTED LETTRS
.DEF   .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
.DEF   .CGBC                 DEFINE TO INCLUDE SYSGC FUNCTION
.DEF   .CIOD                 DEFINE TO NOT USE DEFAULT DELIMITER
.DEF   .CNBF                 DEFINE TO OMIT BUFFER EXTENSION
.DEF   .CNBT                 DEFINE TO OMIT BATCH INITIALISATION
.DEF   .CNLD                 DEFINE TO OMIT LOAD() CODE.
.DEF   .CSAX                 DEFINE IF SYSAX IS TO BE CALLED
.DEF   .CSN8                 DEFINE TO PAD STMT NOS TO 8 CHARS
.DEF   .CTET                 DEFINE TO TABLE ENTRY TRACE WANTED
.DEF   .CUCF                 DEFINE TO INCLUDE CFP_U
.DEF   .CUEJ                 DEFINE TO SUPPRESS NEEDLESS EJECTS
.DEF   .CULK                 DEFINE TO INCLUDE &L/UCASE KEYWORDS
.DEF   .CULC                 DEFINE TO INCLUDE &CASE (LC NAMES)
.DEF   .CUST                 DEFINE TO INCLUDE SET() CODE
.IF    .CCMC
.DEF   .CCMK
.FI
       TTL  S P I T B O L -- PROCEDURES SECTION
       SEC                   START OF PROCEDURES SECTION
.IF    .CSAX
SYSAX  EXP  0                DEFINE EXTERNAL ENTRY POINT
.ELSE
.FI
.IF    .CBSP
SYSBS  EXP  3                DEFINE EXTERNAL ENTRY POINT
.FI
SYSBX  EXP  0                DEFINE EXTERNAL ENTRY POINT
.IF    .CNCI
SYSCI  EXP  0
.FI
.IF    .CCMC
SYSCM  EXP  1                DEFINE EXTERNAL ENTRY POINT
.FI
.IF    .CNRA
.ELSE
.IF    .CNCR
SYSCR  EXP  0
.FI
.FI
SYSDC  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSDM  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSDT  EXP  0                DEFINE EXTERNAL ENTRY POINT
.IF    .CERA
SYSEA  EXP  1                DEFINE EXTERNAL ENTRY POINT
.IF    .CSFN
.FI
.FI
SYSEF  EXP  3                DEFINE EXTERNAL ENTRY POINT
SYSEJ  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSEM  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSEN  EXP  3                DEFINE EXTERNAL ENTRY POINT
SYSEP  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSEX  EXP  3                DEFINE EXTERNAL ENTRY POINT
.IF    .CEXP
.ELSE
.FI
SYSFC  EXP  2                DEFINE EXTERNAL ENTRY POINT
.IF    .CGBC
SYSGC  EXP  0                DEFINE EXTERNAL ENTRY POINT
.FI

SYSHS  EXP  8                DEFINE EXTERNAL ENTRY POINT
SYSID  EXP  0                DEFINE EXTERNAL ENTRY POINT
.IF    .CINC
SYSIF  EXP  1                DEFINE EXTERNAL ENTRY POINT
.FI
SYSIL  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSIN  EXP  3                DEFINE EXTERNAL ENTRY POINT
SYSIO  EXP  2                DEFINE EXTERNAL ENTRY POINT
SYSLD  EXP  3                DEFINE EXTERNAL ENTRY POINT
SYSMM  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSMX  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSOU  EXP  2                DEFINE EXTERNAL ENTRY POINT
.IF    .CSOU
.FI
.IF    .CNBF
.ELSE
.FI
SYSPI  EXP  1                DEFINE EXTERNAL ENTRY POINT
.IF    .CPOL
SYSPL  EXP  3                DEFINE EXTERNAL ENTRY POINT
.FI
SYSPP  EXP  0                DEFINE EXTERNAL ENTRY POINT
.IF    .CULC
.FI
SYSPR  EXP  1                DEFINE EXTERNAL ENTRY POINT
SYSRD  EXP  1                DEFINE EXTERNAL ENTRY POINT
.IF    .CSFN
.FI
SYSRI  EXP  1                DEFINE EXTERNAL ENTRY POINT
SYSRW  EXP  3                DEFINE EXTERNAL ENTRY POINT
.IF    .CUST
SYSST  EXP  0                DEFINE EXTERNAL ENTRY POINT
.FI
SYSTM  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSTT  EXP  0                DEFINE EXTERNAL ENTRY POINT
SYSUL  EXP  0                DEFINE EXTERNAL ENTRY POINT
.IF    .CNEX
.ELSE
SYSXI  EXP  2                DEFINE EXTERNAL ENTRY POINT
.FI
ACESS  INP  R,1
ACOMP  INP  N,5
ALLOC  INP  E,0
.IF    .CNBF
.ELSE
ALOBF  INP  E,0
.FI
ALOCS  INP  E,0
ALOST  INP  E,0
.IF    .CNBF
.ELSE
APNDB  INP  E,2
.FI
.IF    .CNRA
ARITH  INP  N,2
.ELSE
ARITH  INP  N,3
.FI
ASIGN  INP  R,1
ASINP  INP  R,1
BLKLN  INP  E,0
CDGCG  INP  E,0
CDGEX  INP  R,0
CDGNM  INP  R,0
CDGVL  INP  R,0
CDWRD  INP  E,0
CMGEN  INP  R,0
CMPIL  INP  E,0
CNCRD  INP  E,0
COPYB  INP  N,1
DFFNC  INP  E,0
DTACH  INP  E,0
DTYPE  INP  E,0
DUMPR  INP  E,0
.IF    .CENG
ENEVS  INP  R,0
ENGTS  INP  E,0
.FI
ERMSG  INP  E,0
ERTEX  INP  E,0
EVALI  INP  R,4
EVALP  INP  R,1
EVALS  INP  R,3
EVALX  INP  R,1
EXBLD  INP  E,0
EXPAN  INP  E,0
EXPAP  INP  E,1
EXPDM  INP  N,0
EXPOP  INP  N,0
.IF    .CSFN
FILNM  INP  E,0
.FI
.IF    .CULC
FLSTG  INP  E,0
.FI
GBCOL  INP  E,0
GBCPF  INP  E,0
GTARR  INP  E,2
GTCOD  INP  E,1
GTEXP  INP  E,1
GTINT  INP  E,1
GTNUM  INP  E,1
GTNVR  INP  E,1
GTPAT  INP  E,1
.IF    .CNRA
.ELSE
GTREA  INP  E,1
.FI
GTSMI  INP  N,2
.IF    .CNBF
.ELSE
GTSTB  INP  N,1
.FI
GTSTG  INP  N,1
GTVAR  INP  E,1
HASHS  INP  E,0
ICBLD  INP  E,0
IDENT  INP  E,1
INOUT  INP  E,0
.IF    .CNBF
.ELSE
INSBF  INP  E,2
.FI
INSTA  INP  E,0
IOFCB  INP  N,3
IOPPF  INP  N,0
IOPUT  INP  N,7
KTREX  INP  R,0
KWNAM  INP  N,0
LCOMP  INP  N,5
LISTR  INP  E,0
LISTT  INP  E,0
.IF    .CSFN
NEWFN  INP  E,0
.FI
NEXTS  INP  E,0
PATIN  INP  N,2
PATST  INP  N,1
PBILD  INP  E,0
PCONC  INP  E,0
PCOPY  INP  N,0
.IF    .CNPF
.ELSE
PRFLR  INP  E,0
PRFLU  INP  E,0
.FI
PRPAR  INP  E,0
PRTCH  INP  E,0
PRTIC  INP  E,0
PRTIS  INP  E,0
PRTIN  INP  E,0
PRTMI  INP  E,0
PRTMM  INP  E,0
PRTMX  INP  E,0
PRTNL  INP  R,0
PRTNM  INP  R,0
PRTNV  INP  E,0
PRTPG  INP  E,0
PRTPS  INP  E,0
PRTSN  INP  E,0
PRTST  INP  R,0
PRTTR  INP  E,0
PRTVL  INP  R,0
PRTVN  INP  E,0
.IF    .CNRA
.ELSE
RCBLD  INP  E,0
.FI
READR  INP  E,0
.IF    .CREL
RELAJ  INP  E,0
RELCR  INP  E,0
RELDN  INP  E,0
RELOC  INP  E,0
RELST  INP  E,0
RELWS  INP  E,0
.FI
RSTRT  INP  E,0
.IF    .C370
SBOOL  INP  N,4
.FI
SBSTR  INP  E,0
SCANE  INP  E,0
SCNGF  INP  E,0
SETVR  INP  E,0
.IF    .CNSR
.ELSE
SORTA  INP  N,1
SORTC  INP  E,1
SORTF  INP  E,0
SORTH  INP  N,0
.FI
START  INP  E,0
STGCC  INP  E,0
TFIND  INP  E,1
TMAKE  INP  E,0
TRACE  INP  N,2
TRBLD  INP  E,0
TRIMR  INP  E,0
TRXEQ  INP  R,0
VMAKE  INP  E,1
XSCAN  INP  E,0
XSCNI  INP  N,2
ARREF  INR
CFUNC  INR
EXFAL  INR
EXINT  INR
EXITS  INR
EXIXR  INR
EXNAM  INR
EXNUL  INR
.IF    .CNRA
.ELSE
EXREA  INR
.FI
EXSID  INR
EXVNM  INR
FAILP  INR
FLPOP  INR
INDIR  INR
MATCH  INR
RETRN  INR
STCOV  INR
STMGO  INR
STOPR  INR
SUCCP  INR
SYSAB  INR
SYSTU  INR
       TTL  S P I T B O L -- DEFINITIONS AND DATA STRUCTURES
       SEC                   START OF DEFINITIONS SECTION
CFP_A  EQU  *                NUMBER OF CHARACTERS IN ALPHABET
CFP_B  EQU  *                BYTES/WORD ADDRESSING FACTOR
CFP_C  EQU  *                NUMBER OF CHARACTERS PER WORD
CFP_F  EQU  *                OFFSET IN BYTES TO CHARS IN
CFP_I  EQU  *                NUMBER OF WORDS IN INTEGER CONSTANT
CFP_M  EQU  *                MAX POSITIVE INTEGER IN ONE WORD
CFP_N  EQU  *                NUMBER OF BITS IN ONE WORD
.IF    .CNRA
NSTMX  EQU  *                NO. OF DECIMAL DIGITS IN CFP_M
.ELSE
CFP_R  EQU  *                NUMBER OF WORDS IN REAL CONSTANT
CFP_S  EQU  *                NUMBER OF SIG DIGS FOR REAL OUTPUT
CFP_X  EQU  *                MAX DIGITS IN REAL EXPONENT
.IF    .CNCR
NSTMX  EQU  *                NO. OF DECIMAL DIGITS IN CFP_M
MXDGS  EQU  CFP_S+CFP_X      MAX DIGITS IN REAL NUMBER
NSTMR  EQU  MXDGS+5          MAX SPACE FOR REAL
.ELSE
MXDGS  EQU  CFP_S+CFP_X      MAX DIGITS IN REAL NUMBER
NSTMX  EQU  MXDGS+5          MAX SPACE FOR REAL
.FI
.FI
.IF    .CUCF
CFP_U  EQU  *                REALISTIC UPPER BOUND ON ALPHABET
.FI
E_SRS  EQU  *                30 WORDS
E_STS  EQU  *                500 WORDS
E_CBS  EQU  *                500 WORDS
E_HNB  EQU  *                127 BUCKET HEADERS
E_HNW  EQU  *                6 WORDS
E_FSP  EQU  *                15 PERCENT
.IF    .CSED
E_SED  EQU  *                25 PERCENT
.FI
CH_LA  EQU  *                LETTER A
CH_LB  EQU  *                LETTER B
CH_LC  EQU  *                LETTER C
CH_LD  EQU  *                LETTER D
CH_LE  EQU  *                LETTER E
CH_LF  EQU  *                LETTER F
CH_LG  EQU  *                LETTER G
CH_LH  EQU  *                LETTER H
CH_LI  EQU  *                LETTER I
CH_LJ  EQU  *                LETTER J
CH_LK  EQU  *                LETTER K
CH_LL  EQU  *                LETTER L
CH_LM  EQU  *                LETTER M
CH_LN  EQU  *                LETTER N
CH_LO  EQU  *                LETTER O
CH_LP  EQU  *                LETTER P
CH_LQ  EQU  *                LETTER Q
CH_LR  EQU  *                LETTER R
CH_LS  EQU  *                LETTER S
CH_LT  EQU  *                LETTER T
CH_LU  EQU  *                LETTER U
CH_LV  EQU  *                LETTER V
CH_LW  EQU  *                LETTER W
CH_LX  EQU  *                LETTER X
CH_LY  EQU  *                LETTER Y
CH_L_  EQU  *                LETTER Z
CH_D0  EQU  *                DIGIT 0
CH_D1  EQU  *                DIGIT 1
CH_D2  EQU  *                DIGIT 2
CH_D3  EQU  *                DIGIT 3
CH_D4  EQU  *                DIGIT 4
CH_D5  EQU  *                DIGIT 5
CH_D6  EQU  *                DIGIT 6
CH_D7  EQU  *                DIGIT 7
CH_D8  EQU  *                DIGIT 8
CH_D9  EQU  *                DIGIT 9
CH_AM  EQU  *                KEYWORD OPERATOR (AMPERSAND)
CH_AS  EQU  *                MULTIPLICATION SYMBOL (ASTERISK)
CH_AT  EQU  *                CURSOR POSITION OPERATOR (AT)
CH_BB  EQU  *                LEFT ARRAY BRACKET (LESS THAN)
CH_BL  EQU  *                BLANK
CH_BR  EQU  *                ALTERNATION OPERATOR (VERTICAL BAR)
CH_CL  EQU  *                GOTO SYMBOL (COLON)
CH_CM  EQU  *                COMMA
CH_DL  EQU  *                INDIRECTION OPERATOR (DOLLAR)
CH_DT  EQU  *                NAME OPERATOR (DOT)
CH_DQ  EQU  *                DOUBLE QUOTE
CH_EQ  EQU  *                EQUAL SIGN
CH_EX  EQU  *                EXPONENTIATION OPERATOR (EXCLM)
CH_MN  EQU  *                MINUS SIGN / HYPHEN
CH_NM  EQU  *                NUMBER SIGN
CH_NT  EQU  *                NEGATION OPERATOR (NOT)
CH_PC  EQU  *                PERCENT
CH_PL  EQU  *                PLUS SIGN
CH_PP  EQU  *                LEFT PARENTHESIS
CH_RB  EQU  *                RIGHT ARRAY BRACKET (GRTR THAN)
CH_RP  EQU  *                RIGHT PARENTHESIS
CH_QU  EQU  *                INTERROGATION OPERATOR (QUESTION)
CH_SL  EQU  *                SLASH
CH_SM  EQU  *                SEMICOLON
CH_SQ  EQU  *                SINGLE QUOTE
CH_UN  EQU  *                SPECIAL IDENTIFIER CHAR (UNDERLINE)
CH_OB  EQU  *                OPENING BRACKET
CH_CB  EQU  *                CLOSING BRACKET
.IF    .CAHT
CH_HT  EQU  *                HORIZONTAL TAB
.FI
.IF    .CAVT
CH_VT  EQU  *                VERTICAL TAB
.FI
.IF    .CAEX
CH_EY  EQU  *                UP ARROW
.FI
.IF    .CASL
CH__A  EQU  *                SHIFTED A
CH__B  EQU  *                SHIFTED B
CH__C  EQU  *                SHIFTED C
CH__D  EQU  *                SHIFTED D
CH__E  EQU  *                SHIFTED E
CH__F  EQU  *                SHIFTED F
CH__G  EQU  *                SHIFTED G
CH__H  EQU  *                SHIFTED H
CH__I  EQU  *                SHIFTED I
CH__J  EQU  *                SHIFTED J
CH__K  EQU  *                SHIFTED K
CH__L  EQU  *                SHIFTED L
CH__M  EQU  *                SHIFTED M
CH__N  EQU  *                SHIFTED N
CH__O  EQU  *                SHIFTED O
CH__P  EQU  *                SHIFTED P
CH__Q  EQU  *                SHIFTED Q
CH__R  EQU  *                SHIFTED R
CH__S  EQU  *                SHIFTED S
CH__T  EQU  *                SHIFTED T
CH__U  EQU  *                SHIFTED U
CH__V  EQU  *                SHIFTED V
CH__W  EQU  *                SHIFTED W
CH__X  EQU  *                SHIFTED X
CH__Y  EQU  *                SHIFTED Y
CH___  EQU  *                SHIFTED Z
.FI
.IF    .CIOD
IODEL  EQU  *
.ELSE
IODEL  EQU  CH_CM
.FI
OFFS1  EQU  1
OFFS2  EQU  2
OFFS3  EQU  3
BL_AR  EQU  0                ARBLK     ARRAY
BL_CD  EQU  BL_AR+1          CDBLK     CODE
BL_EX  EQU  BL_CD+1          EXBLK     EXPRESSION
BL_IC  EQU  BL_EX+1          ICBLK     INTEGER
BL_NM  EQU  BL_IC+1          NMBLK     NAME
BL_P0  EQU  BL_NM+1          P0BLK     PATTERN
BL_P1  EQU  BL_P0+1          P1BLK     PATTERN
BL_P2  EQU  BL_P1+1          P2BLK     PATTERN
BL_RC  EQU  BL_P2+1          RCBLK     REAL
BL_SC  EQU  BL_RC+1          SCBLK     STRING
BL_SE  EQU  BL_SC+1          SEBLK     EXPRESSION
BL_TB  EQU  BL_SE+1          TBBLK     TABLE
BL_VC  EQU  BL_TB+1          VCBLK     ARRAY
BL_XN  EQU  BL_VC+1          XNBLK     EXTERNAL
BL_XR  EQU  BL_XN+1          XRBLK     EXTERNAL
BL_BC  EQU  BL_XR+1          BCBLK     BUFFER
BL_PD  EQU  BL_BC+1          PDBLK     PROGRAM DEFINED DATATYPE
BL__D  EQU  BL_PD+1          NUMBER OF BLOCK CODES FOR DATA
BL_TR  EQU  BL_PD+1          TRBLK
BL_BF  EQU  BL_TR+1          BFBLK
BL_CC  EQU  BL_BF+1          CCBLK
BL_CM  EQU  BL_CC+1          CMBLK
BL_CT  EQU  BL_CM+1          CTBLK
BL_DF  EQU  BL_CT+1          DFBLK
BL_EF  EQU  BL_DF+1          EFBLK
BL_EV  EQU  BL_EF+1          EVBLK
BL_FF  EQU  BL_EV+1          FFBLK
BL_KV  EQU  BL_FF+1          KVBLK
BL_PF  EQU  BL_KV+1          PFBLK
BL_TE  EQU  BL_PF+1          TEBLK
BL__I  EQU  0                DEFAULT IDENTIFICATION CODE
BL__T  EQU  BL_TR+1          CODE FOR DATA OR TRACE BLOCK
BL___  EQU  BL_TE+1          NUMBER OF BLOCK CODES
FCODE  EQU  0                POINTER TO CODE FOR FUNCTION
FARGS  EQU  1                NUMBER OF ARGUMENTS
IDVAL  EQU  1                ID VALUE FIELD
.IF    .CNBF
.ELSE
.FI
ARTYP  EQU  0                POINTER TO DUMMY ROUTINE B_ART
ARLEN  EQU  IDVAL+1          LENGTH OF ARBLK IN BYTES
AROFS  EQU  ARLEN+1          OFFSET IN ARBLK TO ARPRO FIELD
ARNDM  EQU  AROFS+1          NUMBER OF DIMENSIONS
ARLBD  EQU  ARNDM+1          LOW BOUND (FIRST SUBSCRIPT)
ARDIM  EQU  ARLBD+CFP_I      DIMENSION (FIRST SUBSCRIPT)
ARLB2  EQU  ARDIM+CFP_I      LOW BOUND (SECOND SUBSCRIPT)
ARDM2  EQU  ARLB2+CFP_I      DIMENSION (SECOND SUBSCRIPT)
ARPRO  EQU  ARDIM+CFP_I      ARRAY PROTOTYPE (ONE DIMENSION)
ARVLS  EQU  ARPRO+1          START OF VALUES (ONE DIMENSION)
ARPR2  EQU  ARDM2+CFP_I      ARRAY PROTOTYPE (TWO DIMENSIONS)
ARVL2  EQU  ARPR2+1          START OF VALUES (TWO DIMENSIONS)
ARSI_  EQU  ARLBD            NUMBER OF STANDARD FIELDS IN BLOCK
ARDMS  EQU  ARLB2-ARLBD      SIZE OF INFO FOR ONE SET OF BOUNDS
.IF    .CNBF
.ELSE
BCTYP  EQU  0                PTR TO DUMMY ROUTINE B_BCT
BCLEN  EQU  IDVAL+1          DEFINED BUFFER LENGTH
BCBUF  EQU  BCLEN+1          PTR TO BFBLK
BCSI_  EQU  BCBUF+1          SIZE OF BCBLK
BFTYP  EQU  0                PTR TO DUMMY ROUTINE B_BFT
BFALC  EQU  BFTYP+1          ALLOCATED SIZE OF BUFFER
BFCHR  EQU  BFALC+1          CHARACTERS OF STRING
BFSI_  EQU  BFCHR            SIZE OF STANDARD FIELDS IN BFBLK
.FI
.IF    .CSLN
.FI
CCTYP  EQU  0                POINTER TO DUMMY ROUTINE B_CCT
CCLEN  EQU  CCTYP+1          LENGTH OF CCBLK IN BYTES
.IF    .CSLN
CCSLN  EQU  CCLEN+1          SOURCE LINE NUMBER
CCUSE  EQU  CCSLN+1          OFFSET PAST LAST USED WORD (BYTES)
.ELSE
CCUSE  EQU  CCLEN+1          OFFSET PAST LAST USED WORD (BYTES)
.FI
CCCOD  EQU  CCUSE+1          START OF GENERATED CODE IN BLOCK
.IF    .CSLN
.FI
CDJMP  EQU  0                PTR TO ROUTINE TO EXECUTE STATEMENT
CDSTM  EQU  CDJMP+1          STATEMENT NUMBER
.IF    .CSLN
CDSLN  EQU  CDSTM+1          SOURCE LINE NUMBER
CDLEN  EQU  CDSLN+1          LENGTH OF CDBLK IN BYTES
CDFAL  EQU  CDLEN+1          FAILURE EXIT (SEE BELOW)
.ELSE
CDLEN  EQU  OFFS2            LENGTH OF CDBLK IN BYTES
CDFAL  EQU  OFFS3            FAILURE EXIT (SEE BELOW)
.FI
CDCOD  EQU  CDFAL+1          EXECUTABLE PSEUDO-CODE
CDSI_  EQU  CDCOD            NUMBER OF STANDARD FIELDS IN CDBLK
CMIDN  EQU  0                POINTER TO DUMMY ROUTINE B_CMT
CMLEN  EQU  CMIDN+1          LENGTH OF CMBLK IN BYTES
CMTYP  EQU  CMLEN+1          TYPE (C_XXX, SEE LIST BELOW)
CMOPN  EQU  CMTYP+1          OPERAND POINTER (SEE BELOW)
CMVLS  EQU  CMOPN+1          OPERAND VALUE POINTERS (SEE BELOW)
CMROP  EQU  CMVLS            RIGHT (ONLY) OPERATOR OPERAND
CMLOP  EQU  CMVLS+1          LEFT OPERATOR OPERAND
CMSI_  EQU  CMVLS            NUMBER OF STANDARD FIELDS IN CMBLK
CMUS_  EQU  CMSI_+1          SIZE OF UNARY OPERATOR CMBLK
CMBS_  EQU  CMSI_+2          SIZE OF BINARY OPERATOR CMBLK
CMAR1  EQU  CMVLS+1          ARRAY SUBSCRIPT POINTERS
C_ARR  EQU  0                ARRAY REFERENCE
C_FNC  EQU  C_ARR+1          FUNCTION CALL
C_DEF  EQU  C_FNC+1          DEFERRED EXPRESSION (UNARY *)
C_IND  EQU  C_DEF+1          INDIRECTION (UNARY _)
C_KEY  EQU  C_IND+1          KEYWORD REFERENCE (UNARY AMPERSAND)
C_UBO  EQU  C_KEY+1          UNDEFINED BINARY OPERATOR
C_UUO  EQU  C_UBO+1          UNDEFINED UNARY OPERATOR
C_UO_  EQU  C_UUO+1          TEST VALUE (=C_UUO+1=C_UBO+2)
C__NM  EQU  C_UUO+1          NUMBER OF CODES FOR NAME OPERANDS
C_BVL  EQU  C_UUO+1          BINARY OP WITH VALUE OPERANDS
C_UVL  EQU  C_BVL+1          UNARY OPERATOR WITH VALUE OPERAND
C_ALT  EQU  C_UVL+1          ALTERNATION (BINARY BAR)
C_CNC  EQU  C_ALT+1          CONCATENATION
C_CNP  EQU  C_CNC+1          CONCATENATION, NOT PATTERN MATCH
C_UNM  EQU  C_CNP+1          UNARY OP WITH NAME OPERAND
C_BVN  EQU  C_UNM+1          BINARY OP (OPERANDS BY VALUE, NAME)
C_ASS  EQU  C_BVN+1          ASSIGNMENT
C_INT  EQU  C_ASS+1          INTERROGATION
C_NEG  EQU  C_INT+1          NEGATION (UNARY NOT)
C_SEL  EQU  C_NEG+1          SELECTION
C_PMT  EQU  C_SEL+1          PATTERN MATCH
C_PR_  EQU  C_BVN            LAST PREEVALUABLE CODE
C__NV  EQU  C_PMT+1          NUMBER OF DIFFERENT CMBLK TYPES
CTTYP  EQU  0                POINTER TO DUMMY ROUTINE B_CTT
CTCHS  EQU  CTTYP+1          START OF CHARACTER TABLE WORDS
CTSI_  EQU  CTCHS+CFP_A      NUMBER OF WORDS IN CTBLK
DFLEN  EQU  FARGS+1          LENGTH OF DFBLK IN BYTES
DFPDL  EQU  DFLEN+1          LENGTH OF CORRESPONDING PDBLK
DFNAM  EQU  DFPDL+1          POINTER TO SCBLK FOR DATATYPE NAME
DFFLD  EQU  DFNAM+1          START OF VRBLK PTRS FOR FIELD NAMES
DFFLB  EQU  DFFLD-1          OFFSET BEHIND DFFLD FOR FIELD FUNC
DFSI_  EQU  DFFLD            NUMBER OF STANDARD FIELDS IN DFBLK
DVOPN  EQU  0                ENTRY ADDRESS (PTR TO O_XXX)
DVTYP  EQU  DVOPN+1          TYPE CODE (C_XXX, SEE CMBLK)
DVLPR  EQU  DVTYP+1          LEFT PRECEDENCE (LLXXX, SEE BELOW)
DVRPR  EQU  DVLPR+1          RIGHT PRECEDENCE (RRXXX, SEE BELOW)
DVUS_  EQU  DVLPR+1          SIZE OF UNARY OPERATOR DV
DVBS_  EQU  DVRPR+1          SIZE OF BINARY OPERATOR DV
DVUBS  EQU  DVUS_+DVBS_      SIZE OF UNOP + BINOP (SEE SCANE)
RRASS  EQU  10               RIGHT     EQUAL
LLASS  EQU  00               LEFT      EQUAL
RRPMT  EQU  20               RIGHT     QUESTION MARK
LLPMT  EQU  30               LEFT      QUESTION MARK
RRAMP  EQU  40               RIGHT     AMPERSAND
LLAMP  EQU  50               LEFT      AMPERSAND
RRALT  EQU  70               RIGHT     VERTICAL BAR
LLALT  EQU  60               LEFT      VERTICAL BAR
RRCNC  EQU  90               RIGHT     BLANK
LLCNC  EQU  80               LEFT      BLANK
RRATS  EQU  110              RIGHT     AT
LLATS  EQU  100              LEFT      AT
RRPLM  EQU  120              RIGHT     PLUS, MINUS
LLPLM  EQU  130              LEFT      PLUS, MINUS
RRNUM  EQU  140              RIGHT     NUMBER
LLNUM  EQU  150              LEFT      NUMBER
RRDVD  EQU  160              RIGHT     SLASH
LLDVD  EQU  170              LEFT      SLASH
RRMLT  EQU  180              RIGHT     ASTERISK
LLMLT  EQU  190              LEFT      ASTERISK
RRPCT  EQU  200              RIGHT     PERCENT
LLPCT  EQU  210              LEFT      PERCENT
RREXP  EQU  230              RIGHT     EXCLAMATION
LLEXP  EQU  220              LEFT      EXCLAMATION
RRDLD  EQU  240              RIGHT     DOLLAR, DOT
LLDLD  EQU  250              LEFT      DOLLAR, DOT
RRNOT  EQU  270              RIGHT     NOT
LLNOT  EQU  260              LEFT      NOT
LLUNO  EQU  999              LEFT      ALL UNARY OPERATORS
EFLEN  EQU  FARGS+1          LENGTH OF EFBLK IN BYTES
EFUSE  EQU  EFLEN+1          USE COUNT (FOR OPSYN)
EFCOD  EQU  EFUSE+1          PTR TO CODE (FROM SYSLD)
EFVAR  EQU  EFCOD+1          PTR TO ASSOCIATED VRBLK
EFRSL  EQU  EFVAR+1          RESULT TYPE (SEE BELOW)
EFTAR  EQU  EFRSL+1          ARGUMENT TYPES (SEE BELOW)
EFSI_  EQU  EFTAR            NUMBER OF STANDARD FIELDS IN EFBLK
.IF    .CNRA
.IF    .CNLF
.FI
.ELSE
.IF    .CNLF
.FI
.FI
EVTYP  EQU  0                POINTER TO DUMMY ROUTINE B_EVT
EVEXP  EQU  EVTYP+1          POINTER TO EXBLK FOR EXPRESSION
EVVAR  EQU  EVEXP+1          POINTER TO TRBEV DUMMY TRBLK
EVSI_  EQU  EVVAR+1          SIZE OF EVBLK
.IF    .CSLN
.FI
EXTYP  EQU  0                PTR TO ROUTINE B_EXL TO LOAD EXPR
EXSTM  EQU  CDSTM            STORES STMNT NO. DURING EVALUATION
.IF    .CSLN
EXSLN  EQU  EXSTM+1          STORES LINE NO. DURING EVALUATION
EXLEN  EQU  EXSLN+1          LENGTH OF EXBLK IN BYTES
.ELSE
EXLEN  EQU  EXSTM+1          LENGTH OF EXBLK IN BYTES
.FI
EXFLC  EQU  EXLEN+1          FAILURE CODE (=O_FEX)
EXCOD  EQU  EXFLC+1          PSEUDO-CODE FOR EXPRESSION
EXSI_  EQU  EXCOD            NUMBER OF STANDARD FIELDS IN EXBLK
FFDFP  EQU  FARGS+1          POINTER TO ASSOCIATED DFBLK
FFNXT  EQU  FFDFP+1          PTR TO NEXT FFBLK ON CHAIN OR ZERO
FFOFS  EQU  FFNXT+1          OFFSET (BYTES) TO FIELD IN PDBLK
FFSI_  EQU  FFOFS+1          SIZE OF FFBLK IN WORDS
ICGET  EQU  0                PTR TO ROUTINE B_ICL TO LOAD INT
ICVAL  EQU  ICGET+1          INTEGER VALUE
ICSI_  EQU  ICVAL+CFP_I      SIZE OF ICBLK
KVTYP  EQU  0                POINTER TO DUMMY ROUTINE B_KVT
KVVAR  EQU  KVTYP+1          POINTER TO DUMMY BLOCK TRBKV
KVNUM  EQU  KVVAR+1          KEYWORD NUMBER
KVSI_  EQU  KVNUM+1          SIZE OF KVBLK
NMTYP  EQU  0                PTR TO ROUTINE B_NML TO LOAD NAME
NMBAS  EQU  NMTYP+1          BASE POINTER FOR VARIABLE
NMOFS  EQU  NMBAS+1          OFFSET FOR VARIABLE
NMSI_  EQU  NMOFS+1          SIZE OF NMBLK
PCODE  EQU  0                PTR TO MATCH ROUTINE (P_XXX)
PTHEN  EQU  PCODE+1          POINTER TO SUBSEQUENT NODE
PASI_  EQU  PTHEN+1          SIZE OF P0BLK
PARM1  EQU  PTHEN+1          FIRST PARAMETER VALUE
PBSI_  EQU  PARM1+1          SIZE OF P1BLK IN WORDS
PARM2  EQU  PARM1+1          SECOND PARAMETER VALUE
PCSI_  EQU  PARM2+1          SIZE OF P2BLK IN WORDS
PDTYP  EQU  0                PTR TO DUMMY ROUTINE B_PDT
PDDFP  EQU  IDVAL+1          PTR TO ASSOCIATED DFBLK
PDFLD  EQU  PDDFP+1          START OF FIELD VALUE POINTERS
PDFOF  EQU  DFFLD-PDFLD      DIFFERENCE IN OFFSET TO FIELD PTRS
PDSI_  EQU  PDFLD            SIZE OF STANDARD FIELDS IN PDBLK
PDDFS  EQU  DFSI_-PDSI_      DIFFERENCE IN DFBLK, PDBLK SIZES
PFLEN  EQU  FARGS+1          LENGTH OF PFBLK IN BYTES
PFVBL  EQU  PFLEN+1          POINTER TO VRBLK FOR FUNCTION NAME
PFNLO  EQU  PFVBL+1          NUMBER OF LOCALS
PFCOD  EQU  PFNLO+1          PTR TO VRBLK FOR ENTRY LABEL
PFCTR  EQU  PFCOD+1          TRBLK PTR IF CALL TRACED ELSE 0
PFRTR  EQU  PFCTR+1          TRBLK PTR IF RETURN TRACED ELSE 0
PFARG  EQU  PFRTR+1          VRBLK PTRS FOR ARGUMENTS AND LOCALS
PFAGB  EQU  PFARG-1          OFFSET BEHIND PFARG FOR ARG, LOCAL
PFSI_  EQU  PFARG            NUMBER OF STANDARD FIELDS IN PFBLK
.IF    .CNRA
.ELSE
RCGET  EQU  0                PTR TO ROUTINE B_RCL TO LOAD REAL
RCVAL  EQU  RCGET+1          REAL VALUE
RCSI_  EQU  RCVAL+CFP_R      SIZE OF RCBLK
.FI
SCGET  EQU  0                PTR TO ROUTINE B_SCL TO LOAD STRING
SCLEN  EQU  SCGET+1          LENGTH OF STRING IN CHARACTERS
SCHAR  EQU  SCLEN+1          CHARACTERS OF STRING
SCSI_  EQU  SCHAR            SIZE OF STANDARD FIELDS IN SCBLK
SETYP  EQU  0                PTR TO ROUTINE B_SEL TO LOAD EXPR
SEVAR  EQU  SETYP+1          PTR TO VRBLK FOR VARIABLE
SESI_  EQU  SEVAR+1          LENGTH OF SEBLK IN WORDS
SVBIT  EQU  0                BIT STRING INDICATING ATTRIBUTES
SVLEN  EQU  1                (=SCLEN) LENGTH OF NAME IN CHARS
SVCHS  EQU  2                (=SCHAR) CHARACTERS OF NAME
SVSI_  EQU  2                NUMBER OF STANDARD FIELDS IN SVBLK
SVPRE  EQU  1                SET IF PREEVALUATION PERMITTED
SVFFC  EQU  SVPRE+SVPRE      SET ON IF FAST CALL PERMITTED
SVCKW  EQU  SVFFC+SVFFC      SET ON IF KEYWORD VALUE CONSTANT
SVPRD  EQU  SVCKW+SVCKW      SET ON IF PREDICATE FUNCTION
SVNBT  EQU  4                NUMBER OF BITS TO RIGHT OF SVKNM
SVKNM  EQU  SVPRD+SVPRD      SET ON IF KEYWORD ASSOCIATION
SVFNC  EQU  SVKNM+SVKNM      SET ON IF SYSTEM FUNCTION
SVNAR  EQU  SVFNC+SVFNC      SET ON IF SYSTEM FUNCTION
SVLBL  EQU  SVNAR+SVNAR      SET ON IF SYSTEM LABEL
SVVAL  EQU  SVLBL+SVLBL      SET ON IF PREDEFINED VALUE
SVFNF  EQU  SVFNC+SVNAR      FUNCTION WITH NO FAST CALL
SVFNN  EQU  SVFNF+SVFFC      FUNCTION WITH FAST CALL, NO PREEVAL
SVFNP  EQU  SVFNN+SVPRE      FUNCTION ALLOWING PREEVALUATION
SVFPR  EQU  SVFNN+SVPRD      PREDICATE FUNCTION
SVFNK  EQU  SVFNN+SVKNM      NO PREEVAL FUNC + KEYWORD
SVKWV  EQU  SVKNM+SVVAL      KEYWORD + VALUE
SVKWC  EQU  SVCKW+SVKNM      KEYWORD WITH CONSTANT VALUE
SVKVC  EQU  SVKWV+SVCKW      CONSTANT KEYWORD + VALUE
SVKVL  EQU  SVKVC+SVLBL      CONSTANT KEYWORD + VALUE + LABEL
SVFPK  EQU  SVFNP+SVKVC      PREEVAL FCN + CONST KEYWD + VAL
K_ABE  EQU  0                ABEND
K_ANC  EQU  K_ABE+CFP_B      ANCHOR
.IF    .CULC
K_CAS  EQU  K_ANC+CFP_B      CASE
K_COD  EQU  K_CAS+CFP_B      CODE
.ELSE
K_COD  EQU  K_ANC+CFP_B      CODE
.FI
.IF    .CCMK
K_COM  EQU  K_COD+CFP_B      COMPARE
K_DMP  EQU  K_COM+CFP_B      DUMP
.ELSE
K_DMP  EQU  K_COD+CFP_B      DUMP
.FI
K_ERL  EQU  K_DMP+CFP_B      ERRLIMIT
K_ERT  EQU  K_ERL+CFP_B      ERRTYPE
K_FTR  EQU  K_ERT+CFP_B      FTRACE
K_FLS  EQU  K_FTR+CFP_B      FULLSCAN
K_INP  EQU  K_FLS+CFP_B      INPUT
K_MXL  EQU  K_INP+CFP_B      MAXLENGTH
K_OUP  EQU  K_MXL+CFP_B      OUTPUT
.IF    .CNPF
K_TRA  EQU  K_OUP+CFP_B      TRACE
.ELSE
K_PFL  EQU  K_OUP+CFP_B      PROFILE
K_TRA  EQU  K_PFL+CFP_B      TRACE
.FI
K_TRM  EQU  K_TRA+CFP_B      TRIM
K_FNC  EQU  K_TRM+CFP_B      FNCLEVEL
K_LST  EQU  K_FNC+CFP_B      LASTNO
.IF    .CSLN
K_LLN  EQU  K_LST+CFP_B      LASTLINE
K_LIN  EQU  K_LLN+CFP_B      LINE
K_STN  EQU  K_LIN+CFP_B      STNO
.ELSE
K_STN  EQU  K_LST+CFP_B      STNO
.FI
K_ABO  EQU  K_STN+CFP_B      ABORT
K_ARB  EQU  K_ABO+PASI_      ARB
K_BAL  EQU  K_ARB+PASI_      BAL
K_FAL  EQU  K_BAL+PASI_      FAIL
K_FEN  EQU  K_FAL+PASI_      FENCE
K_REM  EQU  K_FEN+PASI_      REM
K_SUC  EQU  K_REM+PASI_      SUCCEED
K_ALP  EQU  K_SUC+1          ALPHABET
K_RTN  EQU  K_ALP+1          RTNTYPE
K_STC  EQU  K_RTN+1          STCOUNT
K_ETX  EQU  K_STC+1          ERRTEXT
.IF    .CSFN
K_FIL  EQU  K_ETX+1          FILE
K_LFL  EQU  K_FIL+1          LASTFILE
K_STL  EQU  K_LFL+1          STLIMIT
.ELSE
K_STL  EQU  K_ETX+1          STLIMIT
.FI
.IF    .CULK
K_LCS  EQU  K_STL+1          LCASE
K_UCS  EQU  K_LCS+1          UCASE
.FI
K__AL  EQU  K_ALP-K_ALP      ALPHABET
K__RT  EQU  K_RTN-K_ALP      RTNTYPE
K__SC  EQU  K_STC-K_ALP      STCOUNT
K__ET  EQU  K_ETX-K_ALP      ERRTEXT
.IF    .CSFN
K__FL  EQU  K_FIL-K_ALP      FILE
K__LF  EQU  K_LFL-K_ALP      LASTFILE
.FI
K__SL  EQU  K_STL-K_ALP      STLIMIT
.IF    .CULK
K__LC  EQU  K_LCS-K_ALP      LCASE
K__UC  EQU  K_UCS-K_ALP      UCASE
K__N_  EQU  K__UC+1          NUMBER OF SPECIAL CASES
.ELSE
K__N_  EQU  K__SL+1          NUMBER OF SPECIAL CASES
.FI
K_P__  EQU  K_FNC            FIRST PROTECTED KEYWORD
K_V__  EQU  K_ABO            FIRST KEYWORD WITH CONSTANT VALUE
K_S__  EQU  K_ALP            FIRST KEYWORD WITH SPECIAL ACESS
TBTYP  EQU  0                POINTER TO DUMMY ROUTINE B_TBT
TBLEN  EQU  OFFS2            LENGTH OF TBBLK IN BYTES
TBINV  EQU  OFFS3            DEFAULT INITIAL LOOKUP VALUE
TBBUK  EQU  TBINV+1          START OF HASH BUCKET POINTERS
TBSI_  EQU  TBBUK            SIZE OF STANDARD FIELDS IN TBBLK
TBNBK  EQU  11               DEFAULT NO. OF BUCKETS
TETYP  EQU  0                POINTER TO DUMMY ROUTINE B_TET
TESUB  EQU  TETYP+1          SUBSCRIPT VALUE
TEVAL  EQU  TESUB+1          (=VRVAL) TABLE ELEMENT VALUE
TENXT  EQU  TEVAL+1          LINK TO NEXT TEBLK
TESI_  EQU  TENXT+1          SIZE OF TEBLK IN WORDS
TRIDN  EQU  0                POINTER TO DUMMY ROUTINE B_TRT
TRTYP  EQU  TRIDN+1          TRAP TYPE CODE
TRVAL  EQU  TRTYP+1          VALUE OF TRAPPED VARIABLE (=VRVAL)
TRNXT  EQU  TRVAL            PTR TO NEXT TRBLK ON TRBLK CHAIN
TRLBL  EQU  TRVAL            PTR TO ACTUAL LABEL (TRACED LABEL)
TRKVR  EQU  TRVAL            VRBLK POINTER FOR KEYWORD TRACE
TRTAG  EQU  TRVAL+1          TRACE TAG
TRTER  EQU  TRTAG            PTR TO TERMINAL VRBLK OR NULL
TRTRF  EQU  TRTAG            PTR TO TRBLK HOLDING FCBLK PTR
TRFNC  EQU  TRTAG+1          TRACE FUNCTION VRBLK (ZERO IF NONE)
TRFPT  EQU  TRFNC            FCBLK PTR FOR SYSIO
TRSI_  EQU  TRFNC+1          NUMBER OF WORDS IN TRBLK
TRTIN  EQU  0                TRACE TYPE FOR INPUT ASSOCIATION
TRTAC  EQU  TRTIN+1          TRACE TYPE FOR ACCESS TRACE
TRTVL  EQU  TRTAC+1          TRACE TYPE FOR VALUE TRACE
TRTOU  EQU  TRTVL+1          TRACE TYPE FOR OUTPUT ASSOCIATION
TRTFC  EQU  TRTOU+1          TRACE TYPE FOR FCBLK IDENTIFICATION
VCTYP  EQU  0                POINTER TO DUMMY ROUTINE B_VCT
VCLEN  EQU  OFFS2            LENGTH OF VCBLK IN BYTES
VCVLS  EQU  OFFS3            START OF VECTOR VALUES
VCSI_  EQU  VCVLS            SIZE OF STANDARD FIELDS IN VCBLK
VCVLB  EQU  VCVLS-1          OFFSET ONE WORD BEHIND VCVLS
VCTBD  EQU  TBSI_-VCSI_      DIFFERENCE IN SIZES - SEE PRTVL
VRGET  EQU  0                POINTER TO ROUTINE TO LOAD VALUE
VRSTO  EQU  VRGET+1          POINTER TO ROUTINE TO STORE VALUE
VRVAL  EQU  VRSTO+1          VARIABLE VALUE
VRVLO  EQU  VRVAL-VRSTO      OFFSET TO VALUE FROM STORE FIELD
VRTRA  EQU  VRVAL+1          POINTER TO ROUTINE TO JUMP TO LABEL
VRLBL  EQU  VRTRA+1          POINTER TO CODE FOR LABEL
VRLBO  EQU  VRLBL-VRTRA      OFFSET TO LABEL FROM TRANSFER FIELD
VRFNC  EQU  VRLBL+1          POINTER TO FUNCTION BLOCK
VRNXT  EQU  VRFNC+1          POINTER TO NEXT VRBLK ON HASH CHAIN
VRLEN  EQU  VRNXT+1          LENGTH OF NAME (OR ZERO)
VRCHS  EQU  VRLEN+1          CHARACTERS OF NAME (VRLEN GT 0)
VRSVP  EQU  VRLEN+1          PTR TO SVBLK (VRLEN EQ 0)
VRSI_  EQU  VRCHS+1          NUMBER OF STANDARD FIELDS IN VRBLK
VRSOF  EQU  VRLEN-SCLEN      OFFSET TO DUMMY SCBLK FOR NAME
VRSVO  EQU  VRSVP-VRSOF      PSEUDO-OFFSET TO VRSVP FIELD
XNTYP  EQU  0                POINTER TO DUMMY ROUTINE B_XNT
XNLEN  EQU  XNTYP+1          LENGTH OF XNBLK IN BYTES
XNDTA  EQU  XNLEN+1          DATA WORDS
XNSI_  EQU  XNDTA            SIZE OF STANDARD FIELDS IN XNBLK
XRTYP  EQU  0                POINTER TO DUMMY ROUTINE B_XRT
XRLEN  EQU  XRTYP+1          LENGTH OF XRBLK IN BYTES
XRPTR  EQU  XRLEN+1          START OF ADDRESS POINTERS
XRSI_  EQU  XRPTR            SIZE OF STANDARD FIELDS IN XRBLK
CNVST  EQU  8                MAX STANDARD TYPE CODE FOR CONVERT
.IF    .CNRA
CNVRT  EQU  CNVST            NO REALS - SAME AS STANDARD TYPES
.ELSE
CNVRT  EQU  CNVST+1          CONVERT CODE FOR REALS
.FI
.IF    .CNBF
CNVBT  EQU  CNVRT            NO BUFFERS - SAME AS REAL CODE
.ELSE
CNVBT  EQU  CNVRT+1          CONVERT CODE FOR BUFFER
.FI
CNVTT  EQU  CNVBT+1          BSW CODE FOR CONVERT
INILN  EQU  1024             DEFAULT IMAGE LENGTH FOR COMPILER
INILS  EQU  1024             IMAGE LENGTH IF -SEQU IN EFFECT
IONMB  EQU  2                NAME BASE USED FOR IOCHN IN SYSIO
IONMO  EQU  4                NAME OFFSET USED FOR IOCHN IN SYSIO
MNLEN  EQU  1024             MIN VALUE ALLOWED KEYWORD MAXLNGTH
MXERN  EQU  329              ERR NUM INADEQUATE STARTUP MEMORY
NUM01  EQU  1
NUM02  EQU  2
NUM03  EQU  3
NUM04  EQU  4
NUM05  EQU  5
NUM06  EQU  6
NUM07  EQU  7
NUM08  EQU  8
NUM09  EQU  9
NUM10  EQU  10
NM320  EQU  320
NM321  EQU  321
NINI8  EQU  998
NINI9  EQU  999
THSND  EQU  1000
OPBUN  EQU  5                NO. OF BINARY UNDEFINED OPS
OPUUN  EQU  6                NO OF UNARY UNDEFINED OPS
PRSNF  EQU  13               OFFSET USED IN PRTSN
PRTMF  EQU  21               OFFSET TO COL 21 (PRTMI)
RILEN  EQU  1024             BUFFER LENGTH FOR SYSRI
STGIC  EQU  0                INITIAL COMPILE
STGXC  EQU  STGIC+1          EXECUTION COMPILE (CODE)
STGEV  EQU  STGXC+1          EXPRESSION EVAL DURING EXECUTION
STGXT  EQU  STGEV+1          EXECUTION TIME
STGCE  EQU  STGXT+1          INITIAL COMPILE AFTER END LINE
STGXE  EQU  STGCE+1          EXEC. COMPILE AFTER END LINE
STGND  EQU  STGCE-STGIC      DIFFERENCE IN STAGE AFTER END
STGEE  EQU  STGXE+1          EVAL EVALUATING EXPRESSION
STGNO  EQU  STGEE+1          NUMBER OF CODES
.IF    .CSN6
STNPD  EQU  6                STATEMENT NO. PAD COUNT
.FI
.IF    .CSN8
STNPD  EQU  8                STATEMENT NO. PAD COUNT
.FI
.IF    .CSN5
STNPD  EQU  5                STATEMENT NO. PAD COUNT
.FI
T_UOP  EQU  0                UNARY OPERATOR
T_LPR  EQU  T_UOP+3          LEFT PAREN
T_LBR  EQU  T_LPR+3          LEFT BRACKET
T_CMA  EQU  T_LBR+3          COMMA
T_FNC  EQU  T_CMA+3          FUNCTION CALL
T_VAR  EQU  T_FNC+3          VARIABLE
T_CON  EQU  T_VAR+3          CONSTANT
T_BOP  EQU  T_CON+3          BINARY OPERATOR
T_RPR  EQU  T_BOP+3          RIGHT PAREN
T_RBR  EQU  T_RPR+3          RIGHT BRACKET
T_COL  EQU  T_RBR+3          COLON
T_SMC  EQU  T_COL+3          SEMI-COLON
T_FGO  EQU  T_SMC+1          FAILURE GOTO
T_SGO  EQU  T_FGO+1          SUCCESS GOTO
T_UOK  EQU  T_FNC            LAST CODE OK BEFORE UNARY OPERATOR
T_UO0  EQU  T_UOP+0          UNARY OPERATOR, STATE ZERO
T_UO1  EQU  T_UOP+1          UNARY OPERATOR, STATE ONE
T_UO2  EQU  T_UOP+2          UNARY OPERATOR, STATE TWO
T_LP0  EQU  T_LPR+0          LEFT PAREN, STATE ZERO
T_LP1  EQU  T_LPR+1          LEFT PAREN, STATE ONE
T_LP2  EQU  T_LPR+2          LEFT PAREN, STATE TWO
T_LB0  EQU  T_LBR+0          LEFT BRACKET, STATE ZERO
T_LB1  EQU  T_LBR+1          LEFT BRACKET, STATE ONE
T_LB2  EQU  T_LBR+2          LEFT BRACKET, STATE TWO
T_CM0  EQU  T_CMA+0          COMMA, STATE ZERO
T_CM1  EQU  T_CMA+1          COMMA, STATE ONE
T_CM2  EQU  T_CMA+2          COMMA, STATE TWO
T_FN0  EQU  T_FNC+0          FUNCTION CALL, STATE ZERO
T_FN1  EQU  T_FNC+1          FUNCTION CALL, STATE ONE
T_FN2  EQU  T_FNC+2          FUNCTION CALL, STATE TWO
T_VA0  EQU  T_VAR+0          VARIABLE, STATE ZERO
T_VA1  EQU  T_VAR+1          VARIABLE, STATE ONE
T_VA2  EQU  T_VAR+2          VARIABLE, STATE TWO
T_CO0  EQU  T_CON+0          CONSTANT, STATE ZERO
T_CO1  EQU  T_CON+1          CONSTANT, STATE ONE
T_CO2  EQU  T_CON+2          CONSTANT, STATE TWO
T_BO0  EQU  T_BOP+0          BINARY OPERATOR, STATE ZERO
T_BO1  EQU  T_BOP+1          BINARY OPERATOR, STATE ONE
T_BO2  EQU  T_BOP+2          BINARY OPERATOR, STATE TWO
T_RP0  EQU  T_RPR+0          RIGHT PAREN, STATE ZERO
T_RP1  EQU  T_RPR+1          RIGHT PAREN, STATE ONE
T_RP2  EQU  T_RPR+2          RIGHT PAREN, STATE TWO
T_RB0  EQU  T_RBR+0          RIGHT BRACKET, STATE ZERO
T_RB1  EQU  T_RBR+1          RIGHT BRACKET, STATE ONE
T_RB2  EQU  T_RBR+2          RIGHT BRACKET, STATE TWO
T_CL0  EQU  T_COL+0          COLON, STATE ZERO
T_CL1  EQU  T_COL+1          COLON, STATE ONE
T_CL2  EQU  T_COL+2          COLON, STATE TWO
T_SM0  EQU  T_SMC+0          SEMICOLON, STATE ZERO
T_SM1  EQU  T_SMC+1          SEMICOLON, STATE ONE
T_SM2  EQU  T_SMC+2          SEMICOLON, STATE TWO
T_NES  EQU  T_SM2+1          NUMBER OF ENTRIES IN BRANCH TABLE
.IF    .CULC
CC_CA  EQU  0                -CASE
CC_DO  EQU  CC_CA+1          -DOUBLE
.ELSE
CC_DO  EQU  0                -DOUBLE
.FI
.IF    .CCMK
CC_CO  EQU  CC_DO+1          -COMPARE
CC_DU  EQU  CC_CO+1          -DUMP
.ELSE
CC_DU  EQU  CC_DO+1          -DUMP
.FI
.IF    .CINC
CC_CP  EQU  CC_DU+1          -COPY
CC_EJ  EQU  CC_CP+1          -EJECT
.ELSE
CC_EJ  EQU  CC_DU+1          -EJECT
.FI
CC_ER  EQU  CC_EJ+1          -ERRORS
CC_EX  EQU  CC_ER+1          -EXECUTE
CC_FA  EQU  CC_EX+1          -FAIL
.IF    .CINC
CC_IN  EQU  CC_FA+1          -INCLUDE
.IF    .CSLN
CC_LN  EQU  CC_IN+1          -LINE
CC_LI  EQU  CC_LN+1          -LIST
.ELSE
CC_LI  EQU  CC_IN+1          -LIST
.FI
.ELSE
.IF    .CSLN
CC_LN  EQU  CC_FA+1          -LINE
CC_LI  EQU  CC_LN+1          -LIST
.ELSE
CC_LI  EQU  CC_FA+1          -LIST
.FI
.FI
CC_NR  EQU  CC_LI+1          -NOERRORS
CC_NX  EQU  CC_NR+1          -NOEXECUTE
CC_NF  EQU  CC_NX+1          -NOFAIL
CC_NL  EQU  CC_NF+1          -NOLIST
CC_NO  EQU  CC_NL+1          -NOOPT
CC_NP  EQU  CC_NO+1          -NOPRINT
CC_OP  EQU  CC_NP+1          -OPTIMISE
CC_PR  EQU  CC_OP+1          -PRINT
CC_SI  EQU  CC_PR+1          -SINGLE
CC_SP  EQU  CC_SI+1          -SPACE
CC_ST  EQU  CC_SP+1          -STITL
CC_TI  EQU  CC_ST+1          -TITLE
CC_TR  EQU  CC_TI+1          -TRACE
CC_NC  EQU  CC_TR+1          NUMBER OF CONTROL CARDS
CCNOC  EQU  4                NO. OF CHARS INCLUDED IN MATCH
CCOFS  EQU  7                OFFSET TO START OF TITLE/SUBTITLE
.IF    .CINC
CCINM  EQU  9                MAX DEPTH OF INCLUDE FILE NESTING
.FI
CMSTM  EQU  0                TREE FOR STATEMENT BODY
CMSGO  EQU  CMSTM+1          TREE FOR SUCCESS GOTO
CMFGO  EQU  CMSGO+1          TREE FOR FAIL GOTO
CMCGO  EQU  CMFGO+1          CONDITIONAL GOTO FLAG
CMPCD  EQU  CMCGO+1          PREVIOUS CDBLK POINTER
CMFFP  EQU  CMPCD+1          FAILURE FILL IN FLAG FOR PREVIOUS
CMFFC  EQU  CMFFP+1          FAILURE FILL IN FLAG FOR CURRENT
CMSOP  EQU  CMFFC+1          SUCCESS FILL IN OFFSET FOR PREVIOUS
CMSOC  EQU  CMSOP+1          SUCCESS FILL IN OFFSET FOR CURRENT
CMLBL  EQU  CMSOC+1          PTR TO VRBLK FOR CURRENT LABEL
CMTRA  EQU  CMLBL+1          PTR TO ENTRY CDBLK
CMNEN  EQU  CMTRA+1          COUNT OF STACK ENTRIES FOR CMPIL
.IF    .CNPF
.ELSE
PFPD1  EQU  8                PAD POSITIONS ...
PFPD2  EQU  20               ... FOR PROFILE ...
PFPD3  EQU  32               ... PRINTOUT
PF_I2  EQU  CFP_I+CFP_I      SIZE OF TABLE ENTRY (2 INTS)
.FI
.IF    .CREL
RLEND  EQU  0                END
RLADJ  EQU  RLEND+1          ADJUSTMENT
RLSTR  EQU  RLADJ+1          START
RSSI_  EQU  RLSTR+1          SIZE OF SECTION
RNSI_  EQU  5                NUMBER OF STRUCTURES
RLDYE  EQU  0                DYNAMIC REGION END
RLDYA  EQU  RLDYE+1          DYNAMIC REGION ADJUSTMENT
RLDYS  EQU  RLDYA+1          DYNAMIC REGION START
RLSTE  EQU  RLDYS+1          STATIC REGION END
RLSTA  EQU  RLSTE+1          STATIC REGION ADJUSTMENT
RLSTS  EQU  RLSTA+1          STATIC REGION START
RLWKE  EQU  RLSTS+1          WORKING SECTION GLOBALS END
RLWKA  EQU  RLWKE+1          WORKING SECTION GLOBALS ADJUSTMENT
RLWKS  EQU  RLWKA+1          WORKING SECTION GLOBALS START
RLCNE  EQU  RLWKS+1          CONSTANTS SECTION END
RLCNA  EQU  RLCNE+1          CONSTANTS SECTION ADJUSTMENT
RLCNS  EQU  RLCNA+1          CONSTANTS SECTION START
RLCDE  EQU  RLCNS+1          CODE SECTION END
RLCDA  EQU  RLCDE+1          CODE SECTION ADJUSTMENT
RLCDS  EQU  RLCDA+1          CODE SECTION START
RLSI_  EQU  RLCDS+1          NUMBER OF FIELDS IN STRUCTURE
.FI
       TTL  S P I T B O L -- CONSTANT SECTION
       SEC                   START OF CONSTANT SECTION
C_AAA  DAC  0                FIRST LOCATION OF CONSTANT SECTION
ALFSP  DAC  E_FSP            FREE STORE PERCENTAGE
BITS0  DBC  0                ALL ZERO BITS
BITS1  DBC  1                ONE BIT IN LOW ORDER POSITION
BITS2  DBC  2                BIT IN POSITION 2
BITS3  DBC  4                BIT IN POSITION 3
BITS4  DBC  8                BIT IN POSITION 4
BITS5  DBC  16               BIT IN POSITION 5
BITS6  DBC  32               BIT IN POSITION 6
BITS7  DBC  64               BIT IN POSITION 7
BITS8  DBC  128              BIT IN POSITION 8
BITS9  DBC  256              BIT IN POSITION 9
BIT10  DBC  512              BIT IN POSITION 10
BIT11  DBC  1024             BIT IN POSITION 11
BIT12  DBC  2048             BIT IN POSITION 12
BITSM  DBC  CFP_M            MASK FOR MAX INTEGER
BTFNC  DBC  SVFNC            BIT TO TEST FOR FUNCTION
BTKNM  DBC  SVKNM            BIT TO TEST FOR KEYWORD NUMBER
BTLBL  DBC  SVLBL            BIT TO TEST FOR LABEL
BTFFC  DBC  SVFFC            BIT TO TEST FOR FAST CALL
BTCKW  DBC  SVCKW            BIT TO TEST FOR CONSTANT KEYWORD
BTKWV  DBC  SVKWV            BITS TO TEST FOR KEWORD WITH VALUE
BTPRD  DBC  SVPRD            BIT TO TEST FOR PREDICATE FUNCTION
BTPRE  DBC  SVPRE            BIT TO TEST FOR PREEVALUATION
BTVAL  DBC  SVVAL            BIT TO TEST FOR VALUE
.IF    .CULC
CCNMS  DTC  /CASE/
       DTC  /DOUB/
.ELSE
CCNMS  DTC  /DOUB/
.FI
.IF    .CCMK
       DTC  /COMP/
.FI
       DTC  /DUMP/
.IF    .CINC
       DTC  /COPY/
.FI
       DTC  /EJEC/
       DTC  /ERRO/
       DTC  /EXEC/
       DTC  /FAIL/
.IF    .CINC
       DTC  /INCL/
.FI
.IF    .CSLN
       DTC  /LINE/
.FI
       DTC  /LIST/
       DTC  /NOER/
       DTC  /NOEX/
       DTC  /NOFA/
       DTC  /NOLI/
       DTC  /NOOP/
       DTC  /NOPR/
       DTC  /OPTI/
       DTC  /PRIN/
       DTC  /SING/
       DTC  /SPAC/
       DTC  /STIT/
       DTC  /TITL/
       DTC  /TRAC/
DMHDK  DAC  B_SCL            DUMP OF KEYWORD VALUES
       DAC  22
       DTC  /Dump of Keyword Values/
DMHDV  DAC  B_SCL            DUMP OF NATURAL VARIABLES
       DAC  25
       DTC  /Dump of Natural Variables/
ENCM1  DAC  B_SCL
.IF    .CBYT
       DAC  19
       DTC  /Memory used (bytes)/
ENCM2  DAC  B_SCL
       DAC  19
       DTC  /Memory left (bytes)/
.ELSE
       DAC  19
       DTC  /Memory used (words)/
ENCM2  DAC  B_SCL
       DAC  19
       DTC  /Memory left (words)/
.FI
ENCM3  DAC  B_SCL
       DAC  11
       DTC  /Comp errors/
ENCM4  DAC  B_SCL
.IF    .CTMD
       DAC  19
       DTC  /Comp time (decisec)/
.ELSE
       DAC  20
       DTC  /Comp time (millisec)/
.FI
ENCM5  DAC  B_SCL            EXECUTION SUPPRESSED
       DAC  20
       DTC  /Execution suppressed/
ENDAB  DAC  B_SCL
       DAC  12
       DTC  /Abnormal End/
ENDMO  DAC  B_SCL
ENDML  DAC  15
       DTC  /Memory Overflow/
ENDMS  DAC  B_SCL
       DAC  10
       DTC  /Normal end/
ENDSO  DAC  B_SCL            STACK OVERFLOW IN GARBAGE COLLECTOR
       DAC  36
       DTC  /Stack overflow in garbage collection/
ENDTU  DAC  B_SCL
       DAC  15
       DTC  /Error - Time Up/
ERMMS  DAC  B_SCL            ERROR
       DAC  5
       DTC  /Error/
ERMNS  DAC  B_SCL            STRING / -- /
       DAC  4
       DTC  / -- /
LSTMS  DAC  B_SCL            PAGE
       DAC  5
       DTC  /Page /
HEADR  DAC  B_SCL
       DAC  24
       DTC  /Macro SPITBOL Version 3.8/
HEADV  DAC  B_SCL            FOR EXIT() VERSION NO. CHECK
       DAC  5
       DTC  /3.8.2/
.IF    .CSED
GBSDP  DAC  E_SED            SEDIMENT PERCENTAGE
.FI
INT_R  DAC  B_ICL
INTV0  DIC  +0               0
INTON  DAC  B_ICL
INTV1  DIC  +1               1
INTTW  DAC  B_ICL
INTV2  DIC  +2               2
INTVT  DIC  +10              10
INTVH  DIC  +100             100
INTTH  DIC  +1000            1000
INTAB  DAC  INT_R            POINTER TO 0
       DAC  INTON            POINTER TO 1
       DAC  INTTW            POINTER TO 2
NDABB  DAC  P_ABB            ARBNO
NDABD  DAC  P_ABD            ARBNO
NDARC  DAC  P_ARC            ARB
NDEXB  DAC  P_EXB            EXPRESSION
NDFNB  DAC  P_FNB            FENCE()
NDFND  DAC  P_FND            FENCE()
NDEXC  DAC  P_EXC            EXPRESSION
NDIMB  DAC  P_IMB            IMMEDIATE ASSIGNMENT
NDIMD  DAC  P_IMD            IMMEDIATE ASSIGNMENT
NDNTH  DAC  P_NTH            PATTERN END (NULL PATTERN)
NDPAB  DAC  P_PAB            PATTERN ASSIGNMENT
NDPAD  DAC  P_PAD            PATTERN ASSIGNMENT
NDUNA  DAC  P_UNA            ANCHOR POINT MOVEMENT
NDABO  DAC  P_ABO            ABORT
       DAC  NDNTH
NDARB  DAC  P_ARB            ARB
       DAC  NDNTH
NDBAL  DAC  P_BAL            BAL
       DAC  NDNTH
NDFAL  DAC  P_FAL            FAIL
       DAC  NDNTH
NDFEN  DAC  P_FEN            FENCE
       DAC  NDNTH
NDREM  DAC  P_REM            REM
       DAC  NDNTH
NDSUC  DAC  P_SUC            SUCCEED
       DAC  NDNTH
NULLS  DAC  B_SCL            NULL STRING VALUE
       DAC  0                SCLEN = 0
NULLW  DTC  /          /
.IF    .CULK
LCASE  DAC  B_SCL
       DAC  26
       DTC  /abcdefghijklmnopqrstuvwxyz/
UCASE  DAC  B_SCL
       DAC  26
       DTC  /ABCDEFGHIJKLMNOPQRSTUVWXYZ/
.FI
OPDVC  DAC  O_CNC            CONCATENATION
       DAC  C_CNC
       DAC  LLCNC
       DAC  RRCNC
OPDVP  DAC  O_CNC            CONCATENATION - NOT PATTERN MATCH
       DAC  C_CNP
       DAC  LLCNC
       DAC  RRCNC
OPDVS  DAC  O_ASS            ASSIGNMENT
       DAC  C_ASS
       DAC  LLASS
       DAC  RRASS
       DAC  6                UNARY EQUAL
       DAC  C_UUO
       DAC  LLUNO
       DAC  O_PMV            PATTERN MATCH
       DAC  C_PMT
       DAC  LLPMT
       DAC  RRPMT
       DAC  O_INT            INTERROGATION
       DAC  C_UVL
       DAC  LLUNO
       DAC  1                BINARY AMPERSAND
       DAC  C_UBO
       DAC  LLAMP
       DAC  RRAMP
       DAC  O_KWV            KEYWORD REFERENCE
       DAC  C_KEY
       DAC  LLUNO
       DAC  O_ALT            ALTERNATION
       DAC  C_ALT
       DAC  LLALT
       DAC  RRALT
       DAC  5                UNARY VERTICAL BAR
       DAC  C_UUO
       DAC  LLUNO
       DAC  0                BINARY AT
       DAC  C_UBO
       DAC  LLATS
       DAC  RRATS
       DAC  O_CAS            CURSOR ASSIGNMENT
       DAC  C_UNM
       DAC  LLUNO
       DAC  2                BINARY NUMBER SIGN
       DAC  C_UBO
       DAC  LLNUM
       DAC  RRNUM
       DAC  7                UNARY NUMBER SIGN
       DAC  C_UUO
       DAC  LLUNO
       DAC  O_DVD            DIVISION
       DAC  C_BVL
       DAC  LLDVD
       DAC  RRDVD
       DAC  9                UNARY SLASH
       DAC  C_UUO
       DAC  LLUNO
       DAC  O_MLT            MULTIPLICATION
       DAC  C_BVL
       DAC  LLMLT
       DAC  RRMLT
       DAC  0                DEFERRED EXPRESSION
       DAC  C_DEF
       DAC  LLUNO
       DAC  3                BINARY PERCENT
       DAC  C_UBO
       DAC  LLPCT
       DAC  RRPCT
       DAC  8                UNARY PERCENT
       DAC  C_UUO
       DAC  LLUNO
       DAC  O_EXP            EXPONENTIATION
       DAC  C_BVL
       DAC  LLEXP
       DAC  RREXP
       DAC  10               UNARY EXCLAMATION
       DAC  C_UUO
       DAC  LLUNO
       DAC  O_IMA            IMMEDIATE ASSIGNMENT
       DAC  C_BVN
       DAC  LLDLD
       DAC  RRDLD
       DAC  O_INV            INDIRECTION
       DAC  C_IND
       DAC  LLUNO
       DAC  4                BINARY NOT
       DAC  C_UBO
       DAC  LLNOT
       DAC  RRNOT
       DAC  0                NEGATION
       DAC  C_NEG
       DAC  LLUNO
       DAC  O_SUB            SUBTRACTION
       DAC  C_BVL
       DAC  LLPLM
       DAC  RRPLM
       DAC  O_COM            COMPLEMENTATION
       DAC  C_UVL
       DAC  LLUNO
       DAC  O_ADD            ADDITION
       DAC  C_BVL
       DAC  LLPLM
       DAC  RRPLM
       DAC  O_AFF            AFFIRMATION
       DAC  C_UVL
       DAC  LLUNO
       DAC  O_PAS            PATTERN ASSIGNMENT
       DAC  C_BVN
       DAC  LLDLD
       DAC  RRDLD
       DAC  O_NAM            NAME REFERENCE
       DAC  C_UNM
       DAC  LLUNO
OPDVD  DAC  O_GOD            DIRECT GOTO
       DAC  C_UVL
       DAC  LLUNO
OPDVN  DAC  O_GOC            COMPLEX NORMAL GOTO
       DAC  C_UNM
       DAC  LLUNO
OAMN_  DAC  O_AMN            ARRAY REF (MULTI-SUBS BY VALUE)
OAMV_  DAC  O_AMV            ARRAY REF (MULTI-SUBS BY VALUE)
OAON_  DAC  O_AON            ARRAY REF (ONE SUB BY NAME)
OAOV_  DAC  O_AOV            ARRAY REF (ONE SUB BY VALUE)
OCER_  DAC  O_CER            COMPILATION ERROR
OFEX_  DAC  O_FEX            FAILURE IN EXPRESSION EVALUATION
OFIF_  DAC  O_FIF            FAILURE DURING GOTO EVALUATION
OFNC_  DAC  O_FNC            FUNCTION CALL (MORE THAN ONE ARG)
OFNE_  DAC  O_FNE            FUNCTION NAME ERROR
OFNS_  DAC  O_FNS            FUNCTION CALL (SINGLE ARGUMENT)
OGOF_  DAC  O_GOF            SET GOTO FAILURE TRAP
OINN_  DAC  O_INN            INDIRECTION BY NAME
OKWN_  DAC  O_KWN            KEYWORD REFERENCE BY NAME
OLEX_  DAC  O_LEX            LOAD EXPRESSION BY NAME
OLPT_  DAC  O_LPT            LOAD PATTERN
OLVN_  DAC  O_LVN            LOAD VARIABLE NAME
ONTA_  DAC  O_NTA            NEGATION, FIRST ENTRY
ONTB_  DAC  O_NTB            NEGATION, SECOND ENTRY
ONTC_  DAC  O_NTC            NEGATION, THIRD ENTRY
OPMN_  DAC  O_PMN            PATTERN MATCH BY NAME
OPMS_  DAC  O_PMS            PATTERN MATCH (STATEMENT)
OPOP_  DAC  O_POP            POP TOP STACK ITEM
ORNM_  DAC  O_RNM            RETURN NAME FROM EXPRESSION
ORPL_  DAC  O_RPL            PATTERN REPLACEMENT
ORVL_  DAC  O_RVL            RETURN VALUE FROM EXPRESSION
OSLA_  DAC  O_SLA            SELECTION, FIRST ENTRY
OSLB_  DAC  O_SLB            SELECTION, SECOND ENTRY
OSLC_  DAC  O_SLC            SELECTION, THIRD ENTRY
OSLD_  DAC  O_SLD            SELECTION, FOURTH ENTRY
OSTP_  DAC  O_STP            STOP EXECUTION
OUNF_  DAC  O_UNF            UNEXPECTED FAILURE
OPSNB  DAC  CH_AT            AT
       DAC  CH_AM            AMPERSAND
       DAC  CH_NM            NUMBER
       DAC  CH_PC            PERCENT
       DAC  CH_NT            NOT
OPNSU  DAC  CH_BR            VERTICAL BAR
       DAC  CH_EQ            EQUAL
       DAC  CH_NM            NUMBER
       DAC  CH_PC            PERCENT
       DAC  CH_SL            SLASH
       DAC  CH_EX            EXCLAMATION
.IF    .CNPF
.ELSE
PFI2A  DAC  PF_I2
PFMS1  DAC  B_SCL
       DAC  15
       DTC  /Program Profile/
PFMS2  DAC  B_SCL
       DAC  42
       DTC  /STMT    Number Of     -- Execution Time --/
PFMS3  DAC  B_SCL
       DAC  47
       DTC  /Number  Executions  Total(MSec) per Excn(MCSec)/
.FI
.IF    .CNRA
.ELSE
REAV0  DRC  +0.0             0.0
.IF    .CNCR
.ELSE
REAP1  DRC  +0.1             0.1
REAP5  DRC  +0.5             0.5
.FI
REAV1  DRC  +1.0             10**0
REAVT  DRC  +1.0E+1          10**1
       DRC  +1.0E+2          10**2
       DRC  +1.0E+3          10**3
       DRC  +1.0E+4          10**4
       DRC  +1.0E+5          10**5
       DRC  +1.0E+6          10**6
       DRC  +1.0E+7          10**7
       DRC  +1.0E+8          10**8
       DRC  +1.0E+9          10**9
REATT  DRC  +1.0E+10         10**10
.FI
SCARR  DAC  B_SCL            ARRAY
       DAC  5
       DTC  /ARRAY/
.IF    .CNBF
.ELSE
SCBUF  DAC  B_SCL            BUFFER
       DAC  6
       DTC  /BUFFER/
.FI
SCCOD  DAC  B_SCL            CODE
       DAC  4
       DTC  /CODE/
SCEXP  DAC  B_SCL            EXPRESSION
       DAC  10
       DTC  /EXPRESSION/
SCEXT  DAC  B_SCL            EXTERNAL
       DAC  8
       DTC  /EXTERNAL/
SCINT  DAC  B_SCL            INTEGER
       DAC  7
       DTC  /INTEGER/
SCNAM  DAC  B_SCL            NAME
       DAC  4
       DTC  /NAME/
SCNUM  DAC  B_SCL            NUMERIC
       DAC  7
       DTC  /NUMERIC/
SCPAT  DAC  B_SCL            PATTERN
       DAC  7
       DTC  /PATTERN/
.IF    .CNRA
.ELSE
SCREA  DAC  B_SCL            REAL
       DAC  4
       DTC  /REAL/
.FI
SCSTR  DAC  B_SCL            STRING
       DAC  6
       DTC  /STRING/
SCTAB  DAC  B_SCL            TABLE
       DAC  5
       DTC  /TABLE/
.IF    .CNLF
SCFIL  DAC  B_SCL            FILE (FOR EXTENDED LOAD ARGUMENTS)
       DAC  4
       DTC  /FILE/
.FI
SCFRT  DAC  B_SCL            FRETURN
       DAC  7
       DTC  /FRETURN/
SCNRT  DAC  B_SCL            NRETURN
       DAC  7
       DTC  /NRETURN/
SCRTN  DAC  B_SCL            RETURN
       DAC  6
       DTC  /RETURN/
SCNMT  DAC  SCARR            ARBLK     ARRAY
       DAC  SCCOD            CDBLK     CODE
       DAC  SCEXP            EXBLK     EXPRESSION
       DAC  SCINT            ICBLK     INTEGER
       DAC  SCNAM            NMBLK     NAME
       DAC  SCPAT            P0BLK     PATTERN
       DAC  SCPAT            P1BLK     PATTERN
       DAC  SCPAT            P2BLK     PATTERN
.IF    .CNRA
       DAC  NULLS            RCBLK     NO REAL IN THIS VERSION
.ELSE

       DAC  SCREA            RCBLK     REAL
.FI
       DAC  SCSTR            SCBLK     STRING
       DAC  SCEXP            SEBLK     EXPRESSION
       DAC  SCTAB            TBBLK     TABLE
       DAC  SCARR            VCBLK     ARRAY
       DAC  SCEXT            XNBLK     EXTERNAL
       DAC  SCEXT            XRBLK     EXTERNAL
.IF    .CNBF
       DAC  NULLS            BFBLK     NO BUFFER IN THIS VERSION
.ELSE
       DAC  SCBUF            BFBLK     BUFFER
.FI
.IF    .CNRA
.ELSE
SCRE0  DAC  B_SCL
       DAC  2
       DTC  /0./
.FI
.IF    .CS16
STLIM  DIC  +32767           DEFAULT STATEMENT LIMIT
.ELSE
.IF    .CS32
STLIM  DIC  +2147483647      DEFAULT STATEMENT LIMIT
.ELSE
STLIM  DIC  +50000           DEFAULT STATEMENT LIMIT
.FI
.FI
STNDF  DAC  O_FUN            PTR TO UNDEFINED FUNCTION ERR CALL
       DAC  0                DUMMY FARGS COUNT FOR CALL CIRCUIT
STNDL  DAC  L_UND            CODE PTR POINTS TO UNDEFINED LBL
STNDO  DAC  O_OUN            PTR TO UNDEFINED OPERATOR ERR CALL
       DAC  0                DUMMY FARGS COUNT FOR CALL CIRCUIT
STNVR  DAC  B_VRL            VRGET
       DAC  B_VRS            VRSTO
       DAC  NULLS            VRVAL
       DAC  B_VRG            VRTRA
       DAC  STNDL            VRLBL
       DAC  STNDF            VRFNC
       DAC  0                VRNXT
STPM1  DAC  B_SCL            IN STATEMENT
       DAC  12
       DTC  /In statement/
STPM2  DAC  B_SCL
       DAC  14
       DTC  /Stmts executed/
STPM3  DAC  B_SCL
.IF    .CTMD
       DAC  18
       DTC  /Run time (decisec)/
.ELSE
       DAC  19
       DTC  /Run time (millisec)/
.FI
STPM4  DAC  B_SCL
       DAC  12
       DTC  _MCSec / Stmt_
STPM5  DAC  B_SCL
       DAC  13
       DTC  /Regenerations/
.IF    .CSLN
STPM6  DAC  B_SCL            IN LINE
       DAC  7
       DTC  /In line/
.FI
.IF    .CSFN
STPM7  DAC  B_SCL            IN FILE
       DAC  7
       DTC  /In file/
.FI
STRTU  DTC  /TU/
SVCTB  DAC  SCSTR            STRING
       DAC  SCINT            INTEGER
       DAC  SCNAM            NAME
       DAC  SCPAT            PATTERN
       DAC  SCARR            ARRAY
       DAC  SCTAB            TABLE
       DAC  SCEXP            EXPRESSION
       DAC  SCCOD            CODE
       DAC  SCNUM            NUMERIC
.IF    .CNRA
.ELSE
       DAC  SCREA            REAL
.FI
.IF    .CNBF
.ELSE
       DAC  SCBUF            BUFFER
.FI
       DAC  0                ZERO MARKS END OF LIST
TMASB  DAC  B_SCL            ASTERISKS FOR TRACE STATEMENT NO
       DAC  13
       DTC  /************ /

TMBEB  DAC  B_SCL            BLANK-EQUAL-BLANK
       DAC  3
       DTC  / = /
TRBEV  DAC  B_TRT            DUMMY TRBLK
TRBKV  DAC  B_TRT            DUMMY TRBLK
TRXDR  DAC  O_TXR            BLOCK POINTS TO RETURN ROUTINE
TRXDC  DAC  TRXDR            POINTER TO BLOCK
V_EQF  DBC  SVFPR            EQ
       DAC  2
       DTC  /EQ/
       DAC  S_EQF
       DAC  2
V_GEF  DBC  SVFPR            GE
       DAC  2
       DTC  /GE/
       DAC  S_GEF
       DAC  2
V_GTF  DBC  SVFPR            GT
       DAC  2
       DTC  /GT/
       DAC  S_GTF
       DAC  2
V_LEF  DBC  SVFPR            LE
       DAC  2
       DTC  /LE/
       DAC  S_LEF
       DAC  2
.IF    .CMTH
V_LNF  DBC  SVFNP            LN
       DAC  2
       DTC  /LN/
       DAC  S_LNF
       DAC  1
.FI
V_LTF  DBC  SVFPR            LT
       DAC  2
       DTC  /LT/
       DAC  S_LTF
       DAC  2
V_NEF  DBC  SVFPR            NE
       DAC  2
       DTC  /NE/
       DAC  S_NEF
       DAC  2
.IF    .C370
V_ORF  DBC  SVFNP            OR
       DAC  2
       DTC  /OR/
       DAC  S_ORF
       DAC  2
.FI
.IF    .C370
V_ABS  DBC  SVFNP            ABS
       DAC  3
       DTC  /ABS/
       DAC  S_ABS
       DAC  1
.FI
.IF    .C370
V_AND  DBC  SVFNP            AND
       DAC  3
       DTC  /AND/
       DAC  S_AND
       DAC  2
.FI
V_ANY  DBC  SVFNP            ANY
       DAC  3
       DTC  /ANY/
       DAC  S_ANY
       DAC  1
V_ARB  DBC  SVKVC            ARB
       DAC  3
       DTC  /ARB/
       DAC  K_ARB
       DAC  NDARB
V_ARG  DBC  SVFNN            ARG
       DAC  3
       DTC  /ARG/
       DAC  S_ARG
       DAC  2
V_BAL  DBC  SVKVC            BAL
       DAC  3
       DTC  /BAL/
       DAC  K_BAL
       DAC  NDBAL
.IF    .CMTH
V_COS  DBC  SVFNP            COS
       DAC  3
       DTC  /COS/
       DAC  S_COS
       DAC  1
.FI
V_END  DBC  SVLBL            END
       DAC  3
       DTC  /END/
       DAC  L_END
.IF    .CMTH
V_EXP  DBC  SVFNP            EXP
       DAC  3
       DTC  /EXP/
       DAC  S_EXP
       DAC  1
.FI
V_LEN  DBC  SVFNP            LEN
       DAC  3
       DTC  /LEN/
       DAC  S_LEN
       DAC  1
V_LEQ  DBC  SVFPR            LEQ
       DAC  3
       DTC  /LEQ/
       DAC  S_LEQ
       DAC  2
V_LGE  DBC  SVFPR            LGE
       DAC  3
       DTC  /LGE/
       DAC  S_LGE
       DAC  2
V_LGT  DBC  SVFPR            LGT
       DAC  3
       DTC  /LGT/
       DAC  S_LGT
       DAC  2
V_LLE  DBC  SVFPR            LLE
       DAC  3
       DTC  /LLE/
       DAC  S_LLE
       DAC  2
V_LLT  DBC  SVFPR            LLT
       DAC  3
       DTC  /LLT/
       DAC  S_LLT
       DAC  2
V_LNE  DBC  SVFPR            LNE
       DAC  3
       DTC  /LNE/
       DAC  S_LNE
       DAC  2
V_POS  DBC  SVFNP            POS
       DAC  3
       DTC  /POS/
       DAC  S_POS
       DAC  1
V_REM  DBC  SVKVC            REM
       DAC  3
       DTC  /REM/
       DAC  K_REM
       DAC  NDREM
.IF    .CUST
V_SET  DBC  SVFNN            SET
       DAC  3
       DTC  /SET/
       DAC  S_SET
       DAC  3
.FI
.IF    .CMTH
V_SIN  DBC  SVFNP            SIN
       DAC  3
       DTC  /SIN/
       DAC  S_SIN
       DAC  1
.FI
V_TAB  DBC  SVFNP            TAB
       DAC  3
       DTC  /TAB/
       DAC  S_TAB
       DAC  1
.IF    .CMTH
V_TAN  DBC  SVFNP            TAN
       DAC  3
       DTC  /TAN/
       DAC  S_TAN
       DAC  1
.FI
.IF    .C370
V_XOR  DBC  SVFNP            XOR
       DAC  3
       DTC  /XOR/
       DAC  S_XOR
       DAC  2
.FI
.IF    .CMTH
V_ATN  DBC  SVFNP            ATAN
       DAC  4
       DTC  /ATAN/
       DAC  S_ATN
       DAC  1
.FI
.IF    .CULC
V_CAS  DBC  SVKNM            CASE
       DAC  4
       DTC  /CASE/
       DAC  K_CAS
.FI
V_CHR  DBC  SVFNP            CHAR
       DAC  4
       DTC  /CHAR/
       DAC  S_CHR
       DAC  1
.IF    .CMTH
V_CHP  DBC  SVFNP            CHOP
       DAC  4
       DTC  /CHOP/
       DAC  S_CHP
       DAC  1
.FI
V_COD  DBC  SVFNK            CODE
       DAC  4
       DTC  /CODE/
       DAC  K_COD
       DAC  S_COD
       DAC  1
V_COP  DBC  SVFNN            COPY
       DAC  4
       DTC  /COPY/
       DAC  S_COP
       DAC  1
V_DAT  DBC  SVFNN            DATA
       DAC  4
       DTC  /DATA/
       DAC  S_DAT
       DAC  1
V_DTE  DBC  SVFNN            DATE
       DAC  4
       DTC  /DATE/
       DAC  S_DTE
       DAC  1
V_DMP  DBC  SVFNK            DUMP
       DAC  4
       DTC  /DUMP/
       DAC  K_DMP
       DAC  S_DMP
       DAC  1
V_DUP  DBC  SVFNN            DUPL
       DAC  4
       DTC  /DUPL/
       DAC  S_DUP
       DAC  2
V_EVL  DBC  SVFNN            EVAL
       DAC  4
       DTC  /EVAL/
       DAC  S_EVL
       DAC  1
.IF    .CNEX
.ELSE
V_EXT  DBC  SVFNN            EXIT
       DAC  4
       DTC  /EXIT/
       DAC  S_EXT
       DAC  2
.FI
V_FAL  DBC  SVKVC            FAIL
       DAC  4
       DTC  /FAIL/
       DAC  K_FAL
       DAC  NDFAL
.IF    .CSFN
V_FIL  DBC  SVKNM            FILE
       DAC  4
       DTC  /FILE/
       DAC  K_FIL
.FI
V_HST  DBC  SVFNN            HOST
       DAC  4
       DTC  /HOST/
       DAC  S_HST
       DAC  5
V_ITM  DBC  SVFNF            ITEM
       DAC  4
       DTC  /ITEM/
       DAC  S_ITM
       DAC  999
.IF    .CSLN
V_LIN  DBC  SVKNM            LINE
       DAC  4
       DTC  /LINE/
       DAC  K_LIN
.FI
.IF    .CNLD
.ELSE
V_LOD  DBC  SVFNN            LOAD
       DAC  4
       DTC  /LOAD/
       DAC  S_LOD
       DAC  2
.FI
V_LPD  DBC  SVFNP            LPAD
       DAC  4
       DTC  /LPAD/
       DAC  S_LPD
       DAC  3
V_RPD  DBC  SVFNP            RPAD
       DAC  4
       DTC  /RPAD/
       DAC  S_RPD
       DAC  3
V_RPS  DBC  SVFNP            RPOS
       DAC  4
       DTC  /RPOS/
       DAC  S_RPS
       DAC  1
V_RTB  DBC  SVFNP            RTAB
       DAC  4
       DTC  /RTAB/
       DAC  S_RTB
       DAC  1
V_SI_  DBC  SVFNP            SIZE
       DAC  4
       DTC  /SIZE/
       DAC  S_SI_
       DAC  1
.IF    .CNSR
.ELSE
V_SRT  DBC  SVFNN            SORT
       DAC  4
       DTC  /SORT/
       DAC  S_SRT
       DAC  2
.FI
V_SPN  DBC  SVFNP            SPAN
       DAC  4
       DTC  /SPAN/
       DAC  S_SPN
       DAC  1
.IF    .CMTH
V_SQR  DBC  SVFNP            SQRT
       DAC  4
       DTC  /SQRT/
       DAC  S_SQR
       DAC  1
.FI
V_STN  DBC  SVKNM            STNO
       DAC  4
       DTC  /STNO/
       DAC  K_STN
V_TIM  DBC  SVFNN            TIME
       DAC  4
       DTC  /TIME/
       DAC  S_TIM
       DAC  0
V_TRM  DBC  SVFNK            TRIM
       DAC  4
       DTC  /TRIM/
       DAC  K_TRM
       DAC  S_TRM
       DAC  1
V_ABE  DBC  SVKNM            ABEND
       DAC  5
       DTC  /ABEND/
       DAC  K_ABE
V_ABO  DBC  SVKVL            ABORT
       DAC  5
       DTC  /ABORT/
       DAC  K_ABO
       DAC  L_ABO
       DAC  NDABO
V_APP  DBC  SVFNF            APPLY
       DAC  5
       DTC  /APPLY/
       DAC  S_APP
       DAC  999
V_ABN  DBC  SVFNP            ARBNO
       DAC  5
       DTC  /ARBNO/
       DAC  S_ABN
       DAC  1
V_ARR  DBC  SVFNN            ARRAY
       DAC  5
       DTC  /ARRAY/
       DAC  S_ARR
       DAC  2
V_BRK  DBC  SVFNP            BREAK
       DAC  5
       DTC  /BREAK/
       DAC  S_BRK
       DAC  1
V_CLR  DBC  SVFNN            CLEAR
       DAC  5
       DTC  /CLEAR/
       DAC  S_CLR
       DAC  1
.IF    .C370
V_CMP  DBC  SVFNP            COMPL
       DAC  5
       DTC  /COMPL/
       DAC  S_CMP
       DAC  1
.FI
V_EJC  DBC  SVFNN            EJECT
       DAC  5
       DTC  /EJECT/
       DAC  S_EJC
       DAC  1
V_FEN  DBC  SVFPK            FENCE
       DAC  5
       DTC  /FENCE/
       DAC  K_FEN
       DAC  S_FNC
       DAC  1
       DAC  NDFEN
V_FLD  DBC  SVFNN            FIELD
       DAC  5
       DTC  /FIELD/
       DAC  S_FLD
       DAC  2
V_IDN  DBC  SVFPR            IDENT
       DAC  5
       DTC  /IDENT/
       DAC  S_IDN
       DAC  2
V_INP  DBC  SVFNK            INPUT
       DAC  5
       DTC  /INPUT/
       DAC  K_INP
       DAC  S_INP
       DAC  3
.IF    .CULK
V_LCS  DBC  SVKWC            LCASE
       DAC  5
       DTC  /LCASE/
       DAC  K_LCS
.FI
V_LOC  DBC  SVFNN            LOCAL
       DAC  5
       DTC  /LOCAL/
       DAC  S_LOC
       DAC  2
V_OPS  DBC  SVFNN            OPSYN
       DAC  5
       DTC  /OPSYN/
       DAC  S_OPS
       DAC  3
V_RMD  DBC  SVFNP            REMDR
       DAC  5
       DTC  /REMDR/
       DAC  S_RMD
       DAC  2
.IF    .CNSR
.ELSE
V_RSR  DBC  SVFNN            RSORT
       DAC  5
       DTC  /RSORT/
       DAC  S_RSR
       DAC  2
.FI
V_TBL  DBC  SVFNN            TABLE
       DAC  5
       DTC  /TABLE/
       DAC  S_TBL
       DAC  3
V_TRA  DBC  SVFNK            TRACE
       DAC  5
       DTC  /TRACE/
       DAC  K_TRA
       DAC  S_TRA
       DAC  4
.IF    .CULK
V_UCS  DBC  SVKWC            UCASE
       DAC  5
       DTC  /UCASE/
       DAC  K_UCS
.FI
V_ANC  DBC  SVKNM            ANCHOR
       DAC  6
       DTC  /ANCHOR/
       DAC  K_ANC
.IF    .CNBF
.ELSE
V_APN  DBC  SVFNN            APPEND
       DAC  6
       DTC  /APPEND/
       DAC  S_APN
       DAC  2
.FI
V_BKX  DBC  SVFNP            BREAKX
       DAC  6
       DTC  /BREAKX/
       DAC  S_BKX
       DAC  1
.IF    .CNBF
.ELSE
V_BUF  DBC  SVFNN            BUFFER
       DAC  6
       DTC  /BUFFER/
       DAC  S_BUF
       DAC  2
.FI
V_DEF  DBC  SVFNN            DEFINE
       DAC  6
       DTC  /DEFINE/
       DAC  S_DEF
       DAC  2
V_DET  DBC  SVFNN            DETACH
       DAC  6
       DTC  /DETACH/
       DAC  S_DET
       DAC  1
V_DIF  DBC  SVFPR            DIFFER
       DAC  6
       DTC  /DIFFER/
       DAC  S_DIF
       DAC  2
V_FTR  DBC  SVKNM            FTRACE
       DAC  6
       DTC  /FTRACE/
       DAC  K_FTR
.IF    .CNBF
.ELSE
V_INS  DBC  SVFNN            INSERT
       DAC  6
       DTC  /INSERT/
       DAC  S_INS
       DAC  4
.FI
V_LST  DBC  SVKNM            LASTNO
       DAC  6
       DTC  /LASTNO/
       DAC  K_LST
V_NAY  DBC  SVFNP            NOTANY
       DAC  6
       DTC  /NOTANY/
       DAC  S_NAY
       DAC  1
V_OUP  DBC  SVFNK            OUTPUT
       DAC  6
       DTC  /OUTPUT/
       DAC  K_OUP
       DAC  S_OUP
       DAC  3
V_RET  DBC  SVLBL            RETURN
       DAC  6
       DTC  /RETURN/
       DAC  L_RTN
V_REW  DBC  SVFNN            REWIND
       DAC  6
       DTC  /REWIND/
       DAC  S_REW
       DAC  1
V_STT  DBC  SVFNN            STOPTR
       DAC  6
       DTC  /STOPTR/
       DAC  S_STT
       DAC  2
V_SUB  DBC  SVFNN            SUBSTR
       DAC  6
       DTC  /SUBSTR/
       DAC  S_SUB
       DAC  3
V_UNL  DBC  SVFNN            UNLOAD
       DAC  6
       DTC  /UNLOAD/
       DAC  S_UNL
       DAC  1
V_COL  DBC  SVFNN            COLLECT
       DAC  7
       DTC  /COLLECT/
       DAC  S_COL
       DAC  1
.IF    .CCMK
V_COM  DBC  SVKNM            COMPARE
       DAC  7
       DTC  /COMPARE/
       DAC  K_COM
.FI
V_CNV  DBC  SVFNN            CONVERT
       DAC  7
       DTC  /CONVERT/
       DAC  S_CNV
       DAC  2
V_ENF  DBC  SVFNN            ENDFILE
       DAC  7
       DTC  /ENDFILE/
       DAC  S_ENF
       DAC  1
V_ETX  DBC  SVKNM            ERRTEXT
       DAC  7
       DTC  /ERRTEXT/
       DAC  K_ETX
V_ERT  DBC  SVKNM            ERRTYPE
       DAC  7
       DTC  /ERRTYPE/
       DAC  K_ERT
V_FRT  DBC  SVLBL            FRETURN
       DAC  7
       DTC  /FRETURN/
       DAC  L_FRT
V_INT  DBC  SVFPR            INTEGER
       DAC  7
       DTC  /INTEGER/
       DAC  S_INT
       DAC  1
V_NRT  DBC  SVLBL            NRETURN
       DAC  7
       DTC  /NRETURN/
       DAC  L_NRT
.IF    .CNPF
.ELSE
V_PFL  DBC  SVKNM            PROFILE
       DAC  7
       DTC  /PROFILE/
       DAC  K_PFL
.FI
V_RPL  DBC  SVFNP            REPLACE
       DAC  7
       DTC  /REPLACE/
       DAC  S_RPL
       DAC  3
V_RVS  DBC  SVFNP            REVERSE
       DAC  7
       DTC  /REVERSE/
       DAC  S_RVS
       DAC  1
V_RTN  DBC  SVKNM            RTNTYPE
       DAC  7
       DTC  /RTNTYPE/
       DAC  K_RTN
V_STX  DBC  SVFNN            SETEXIT
       DAC  7
       DTC  /SETEXIT/
       DAC  S_STX
       DAC  1
V_STC  DBC  SVKNM            STCOUNT
       DAC  7
       DTC  /STCOUNT/
       DAC  K_STC
V_STL  DBC  SVKNM            STLIMIT
       DAC  7
       DTC  /STLIMIT/
       DAC  K_STL
V_SUC  DBC  SVKVC            SUCCEED
       DAC  7
       DTC  /SUCCEED/
       DAC  K_SUC
       DAC  NDSUC
V_ALP  DBC  SVKWC            ALPHABET
       DAC  8
       DTC  /ALPHABET/
       DAC  K_ALP
V_CNT  DBC  SVLBL            CONTINUE
       DAC  8
       DTC  /CONTINUE/
       DAC  L_CNT
V_DTP  DBC  SVFNP            DATATYPE
       DAC  8
       DTC  /DATATYPE/
       DAC  S_DTP
       DAC  1
V_ERL  DBC  SVKNM            ERRLIMIT
       DAC  8
       DTC  /ERRLIMIT/
       DAC  K_ERL
V_FNC  DBC  SVKNM            FNCLEVEL
       DAC  8
       DTC  /FNCLEVEL/
       DAC  K_FNC
V_FLS  DBC  SVKNM            FULLSCAN
       DAC  8
       DTC  /FULLSCAN/
       DAC  K_FLS
.IF    .CSFN
V_LFL  DBC  SVKNM            LASTFILE
       DAC  8
       DTC  /LASTFILE/
       DAC  K_LFL
.FI
.IF    .CSLN
V_LLN  DBC  SVKNM            LASTLINE
       DAC  8
       DTC  /LASTLINE/
       DAC  K_LLN
.FI
V_MXL  DBC  SVKNM            MAXLNGTH
       DAC  8
       DTC  /MAXLNGTH/
       DAC  K_MXL
V_TER  DBC  0                TERMINAL
       DAC  8
       DTC  /TERMINAL/
       DAC  0
.IF    .CBSP
V_BSP  DBC  SVFNN            BACKSPACE
       DAC  9
       DTC  /BACKSPACE/
       DAC  S_BSP
       DAC  1
.FI
V_PRO  DBC  SVFNN            PROTOTYPE
       DAC  9
       DTC  /PROTOTYPE/
       DAC  S_PRO
       DAC  1
V_SCN  DBC  SVLBL            SCONTINUE
       DAC  9
       DTC  /SCONTINUE/
       DAC  L_SCN
       DBC  0                DUMMY ENTRY TO END LIST
       DAC  10               LENGTH GT 9 (SCONTINUE)
VDMKW  DAC  V_ANC            ANCHOR
.IF    .CULC
       DAC  V_CAS            CCASE
.FI
       DAC  V_COD            CODE
.IF    .CCMK
.IF    .CCMC
       DAC  V_COM            COMPARE
.ELSE
       DAC  1                COMPARE NOT PRINTED
.FI
.FI
       DAC  V_DMP            DUMP
       DAC  V_ERL            ERRLIMIT
       DAC  V_ETX            ERRTEXT
       DAC  V_ERT            ERRTYPE
.IF    .CSFN
       DAC  V_FIL            FILE
.FI
       DAC  V_FNC            FNCLEVEL
       DAC  V_FTR            FTRACE
       DAC  V_FLS            FULLSCAN
       DAC  V_INP            INPUT
.IF    .CSFN
       DAC  V_LFL            LASTFILE
.FI
.IF    .CSLN
       DAC  V_LLN            LASTLINE
.FI
       DAC  V_LST            LASTNO
.IF    .CSLN
       DAC  V_LIN            LINE
.FI
       DAC  V_MXL            MAXLENGTH
       DAC  V_OUP            OUTPUT
.IF    .CNPF
.ELSE
       DAC  V_PFL            PROFILE
.FI
       DAC  V_RTN            RTNTYPE
       DAC  V_STC            STCOUNT
       DAC  V_STL            STLIMIT
       DAC  V_STN            STNO
       DAC  V_TRA            TRACE
       DAC  V_TRM            TRIM
       DAC  0                END OF LIST
VSRCH  DAC  0                DUMMY ENTRY TO GET PROPER INDEXING
       DAC  V_EQF            START OF 1 CHAR VARIABLES (NONE)
       DAC  V_EQF            START OF 2 CHAR VARIABLES
       DAC  V_ANY            START OF 3 CHAR VARIABLES
.IF    .CMTH
       DAC  V_ATN            START OF 4 CHAR VARIABLES
.ELSE
.IF    .CULC
       DAC  V_CAS            START OF 4 CHAR VARIABLES
.ELSE
       DAC  V_CHR            START OF 4 CHAR VARIABLES
.FI
.FI
       DAC  V_ABE            START OF 5 CHAR VARIABLES
       DAC  V_ANC            START OF 6 CHAR VARIABLES
       DAC  V_COL            START OF 7 CHAR VARIABLES
       DAC  V_ALP            START OF 8 CHAR VARIABLES
.IF    .CBSP
       DAC  V_BSP            START OF 9 CHAR VARIABLES
.ELSE
       DAC  V_PRO            START OF 9 CHAR VARIABLES
.FI
C_YYY  DAC  0                LAST LOCATION IN CONSTANT SECTION
       TTL  S P I T B O L -- WORKING STORAGE SECTION
       SEC                   START OF WORKING STORAGE SECTION
CMLAB  DAC  B_SCL            STRING USED TO CHECK LABEL LEGALITY
       DAC  2
       DTC  /  /
W_AAA  DAC  0
ACTRM  DAC  0                TRIM INDICATOR
ALDYN  DAC  0                AMOUNT OF DYNAMIC STORE
ALLIA  DIC  +0               DUMP IA
ALLSV  DAC  0                SAVE WB IN ALLOC
ALSTA  DAC  0                SAVE WA IN ALOST
ARCDM  DAC  0                COUNT DIMENSIONS
ARNEL  DIC  +0               COUNT ELEMENTS
ARPTR  DAC  0                OFFSET PTR INTO ARBLK
ARSVL  DIC  +0               SAVE INTEGER LOW BOUND
ARFSI  DIC  +0               SAVE CURRENT EVOLVING SUBSCRIPT
ARFXS  DAC  0                SAVE BASE STACK POINTER
BEFOF  DAC  0                SAVE OFFSET PTR INTO EFBLK
BPFPF  DAC  0                SAVE PFBLK POINTER
BPFSV  DAC  0                SAVE OLD FUNCTION VALUE
BPFXT  DAC  0                POINTER TO STACKED ARGUMENTS
CLSVI  DIC  +0               SAVE INTEGER ARGUMENT
CNSCC  DAC  0                POINTER TO CONTROL CARD STRING
CNSWC  DAC  0                WORD COUNT
CNR_T  DAC  0                POINTER TO R_TTL OR R_STL
CNVTP  DAC  0                SAVE PTR INTO SCVTB
DATDV  DAC  0                SAVE VRBLK PTR FOR DATATYPE NAME
DATXS  DAC  0                SAVE INITIAL STACK POINTER
DEFLB  DAC  0                SAVE VRBLK PTR FOR LABEL
DEFNA  DAC  0                COUNT FUNCTION ARGUMENTS
DEFVR  DAC  0                SAVE VRBLK PTR FOR FUNCTION NAME
DEFXS  DAC  0                SAVE INITIAL STACK POINTER
DMARG  DAC  0                DUMP ARGUMENT
DMPSA  DAC  0                PRESERVE WA OVER PRTVL CALL
.IF    .CCMK
DMPSB  DAC  0                PRESERVE WB OVER SYSCM CALL
.FI
DMPSV  DAC  0                GENERAL SCRATCH SAVE
DMVCH  DAC  0                CHAIN POINTER FOR VARIABLE BLOCKS
DMPCH  DAC  0                SAVE SORTED VRBLK CHAIN POINTER
DMPKB  DAC  0                DUMMY KVBLK FOR USE IN DUMPR
DMPKT  DAC  0                KVVAR TRBLK PTR (MUST FOLLOW DMPKB)
DMPKN  DAC  0                KEYWORD NUMBER (MUST FOLLOW DMPKT)
DTCNB  DAC  0                NAME BASE
DTCNM  DAC  0                NAME PTR
DUPSI  DIC  +0               STORE INTEGER STRING LENGTH
ENFCH  DAC  0                FOR IOCHN CHAIN HEAD
ERTWA  DAC  0                SAVE WA
ERTWB  DAC  0                SAVE WB
EVLIN  DAC  0                DUMMY PATTERN BLOCK PCODE
EVLIS  DAC  0                THEN NODE (MUST FOLLOW EVLIN)
EVLIV  DAC  0                VALUE OF PARM1 (MUST FOLLOW EVLIS)
EVLIO  DAC  0                PTR TO ORIGINAL NODE
EVLIF  DAC  0                FLAG FOR SIMPLE/COMPLEX ARGUMENT
EXPSV  DAC  0                SAVE OP DOPE VECTOR POINTER
GBCFL  DAC  0                GARBAGE COLLECTOR ACTIVE FLAG
GBCLM  DAC  0                POINTER TO LAST MOVE BLOCK (PASS 3)
GBCNM  DAC  0                DUMMY FIRST MOVE BLOCK
GBCNS  DAC  0                REST OF DUMMY BLOCK (FOLLOWS GBCNM)
.IF    .CSED
.IF    .CEPP
.ELSE
GBCMK  DAC  0                BIAS WHEN MARKING ENTRY POINT
.FI
GBCIA  DIC  +0               DUMP IA
GBCSD  DAC  0                FIRST ADDRESS BEYOND SEDIMENT
GBCSF  DAC  0                FREE SPACE WITHIN SEDIMENT
.FI
GBSVA  DAC  0                SAVE WA
GBSVB  DAC  0                SAVE WB
GBSVC  DAC  0                SAVE WC
GNVHE  DAC  0                PTR TO END OF HASH CHAIN
GNVNW  DAC  0                NUMBER OF WORDS IN STRING NAME
GNVSA  DAC  0                SAVE WA
GNVSB  DAC  0                SAVE WB
GNVSP  DAC  0                POINTER INTO VSRCH TABLE
GNVST  DAC  0                POINTER TO CHARS OF STRING
GTAWA  DAC  0                SAVE WA
GTINA  DAC  0                SAVE WA
GTINB  DAC  0                SAVE WB
GTNNF  DAC  0                ZERO/NONZERO FOR RESULT +/-
GTNSI  DIC  +0               GENERAL INTEGER SAVE
.IF    .CNRA
.ELSE
GTNDF  DAC  0                0/1 FOR DEC POINT SO FAR NO/YES
GTNES  DAC  0                ZERO/NONZERO EXPONENT +/-
GTNEX  DIC  +0               REAL EXPONENT
GTNSC  DAC  0                SCALE (PLACES AFTER POINT)
GTNSR  DRC  +0.0             GENERAL REAL SAVE
GTNRD  DAC  0                FLAG FOR OK REAL NUMBER
.FI
GTPSB  DAC  0                SAVE WB
GTSSF  DAC  0                0/1 FOR RESULT +/-
GTSVC  DAC  0                SAVE WC
GTSVB  DAC  0                SAVE WB
.IF    .CNRA
.ELSE
.IF    .CNCR
.ELSE
GTSES  DAC  0                CHAR + OR - FOR EXPONENT +/-
GTSRS  DRC  +0.0             GENERAL REAL SAVE
.FI
.FI
GTVRC  DAC  0                SAVE WC
.IF    .CNBF
.ELSE
INSAB  DAC  0                ENTRY WA + ENTRY WB
INSLN  DAC  0                LENGTH OF INSERTION STRING
INSSA  DAC  0                SAVE ENTRY WA
INSSB  DAC  0                SAVE ENTRY WB
INSSC  DAC  0                SAVE ENTRY WC
.FI
IOPTT  DAC  0                TYPE OF ASSOCIATION
.IF    .CNLD
.ELSE
LODFN  DAC  0                POINTER TO VRBLK FOR FUNC NAME
LODNA  DAC  0                COUNT NUMBER OF ARGUMENTS
.FI
.IF    .CNPF
.ELSE
PFSVW  DAC  0                TO SAVE A W-REG
.FI
PRNSI  DIC  +0               SCRATCH INTEGER LOC
PRSNA  DAC  0                SAVE WA
PRSVA  DAC  0                SAVE WA
PRSVB  DAC  0                SAVE WB
PRSVC  DAC  0                SAVE CHAR COUNTER
PRTSA  DAC  0                SAVE WA
PRTSB  DAC  0                SAVE WB
PRVSI  DAC  0                SAVE IDVAL
PSAVE  DAC  0                TEMPORARY SAVE FOR CURRENT NODE PTR
PSAVC  DAC  0                SAVE CURSOR IN P_SPN, P_STR
.IF    .CREL
RLALS  DAC  0                PTR TO LIST OF BOUNDS AND ADJUSTS
RLDCD  DAC  0                SAVE CODE ADJUSTMENT
RLDST  DAC  0                SAVE STATIC ADJUSTMENT
RLDLS  DAC  0                SAVE LIST POINTER
.FI
RTNBP  DAC  0                TO SAVE A BLOCK POINTER
RTNFV  DAC  0                NEW FUNCTION VALUE (RESULT)
RTNSV  DAC  0                OLD FUNCTION VALUE (SAVED VALUE)
SBSSV  DAC  0                SAVE THIRD ARGUMENT
SCNSA  DAC  0                SAVE WA
SCNSB  DAC  0                SAVE WB
SCNSC  DAC  0                SAVE WC
SCNOF  DAC  0                SAVE OFFSET
.IF    .CNSR
.ELSE
SRTDF  DAC  0                DATATYPE FIELD NAME
SRTFD  DAC  0                FOUND DFBLK ADDRESS
SRTFF  DAC  0                FOUND FIELD NAME
SRTFO  DAC  0                OFFSET TO FIELD NAME
SRTNR  DAC  0                NUMBER OF ROWS
SRTOF  DAC  0                OFFSET WITHIN ROW TO SORT KEY
SRTRT  DAC  0                ROOT OFFSET
SRTS1  DAC  0                SAVE OFFSET 1
SRTS2  DAC  0                SAVE OFFSET 2
SRTSC  DAC  0                SAVE WC
SRTSF  DAC  0                SORT ARRAY FIRST ROW OFFSET
SRTSN  DAC  0                SAVE N
SRTSO  DAC  0                OFFSET TO A(0)
SRTSR  DAC  0                0, NON-ZERO FOR SORT, RSORT
SRTST  DAC  0                STRIDE FROM ONE ROW TO NEXT
SRTWC  DAC  0                DUMP WC
.FI
STPSI  DIC  +0               SAVE VALUE OF STCOUNT
STPTI  DIC  +0               SAVE TIME ELAPSED
TFNSI  DIC  +0               NUMBER OF HEADERS
XSCRT  DAC  0                SAVE RETURN CODE
XSCWB  DAC  0                SAVE REGISTER WB
G_AAA  DAC  0
ALFSF  DIC  +0               FACTOR IN FREE STORE PCNTAGE CHECK
CMERC  DAC  0                COUNT OF INITIAL COMPILE ERRORS
CMPLN  DAC  0                LINE NUMBER OF FIRST LINE OF STMT
CMPXS  DAC  0                SAVE STACK PTR IN CASE OF ERRORS
CMPSN  DAC  1                NUMBER OF NEXT STATEMENT TO COMPILE
.IF    .CINC
CNSIL  DAC  0                SAVE SCNIL DURING INCLUDE PROCESS.
CNIND  DAC  0                CURRENT INCLUDE FILE NEST LEVEL
CNSPT  DAC  0                SAVE SCNPT DURING INCLUDE PROCESS.
.FI
CNTTL  DAC  0                FLAG FOR -TITLE, -STITL
CPSTS  DAC  0                SUPPRESS COMP. STATS IF NON ZERO
CSWDB  DAC  0                0/1 FOR -SINGLE/-DOUBLE
CSWER  DAC  0                0/1 FOR -ERRORS/-NOERRORS
CSWEX  DAC  0                0/1 FOR -EXECUTE/-NOEXECUTE
CSWFL  DAC  1                0/1 FOR -NOFAIL/-FAIL
CSWIN  DAC  INILN            XXX FOR -INXXX
CSWLS  DAC  1                0/1 FOR -NOLIST/-LIST
CSWNO  DAC  0                0/1 FOR -OPTIMISE/-NOOPT
CSWPR  DAC  0                0/1 FOR -NOPRINT/-PRINT
CTMSK  DBC  0                LAST BIT POSITION USED IN R_CTP
CURID  DAC  0                CURRENT ID VALUE
CWCOF  DAC  0                NEXT WORD OFFSET IN CURRENT CCBLK
.IF    .CSED
DNAMS  DAC  0                SIZE OF SEDIMENT IN BAUS
.FI
ERICH  DAC  0                COPY ERROR REPORTS TO INT.CHAN IF 1
ERLST  DAC  0                FOR LISTR WHEN ERRORS GO TO INT.CH.
ERRFT  DAC  0                FATAL ERROR FLAG
ERRSP  DAC  0                ERROR SUPPRESSION FLAG
EXSTS  DAC  0                SUPPRESS EXEC STATS IF SET
FLPRT  DAC  0                LOCATION OF FAIL OFFSET FOR RETURN
FLPTR  DAC  0                LOCATION OF FAILURE OFFSET ON STACK
.IF    .CSED
GBSED  DIC  +0               FACTOR IN SEDIMENT PCNTAGE CHECK
.FI
GBCNT  DAC  0                COUNT OF GARBAGE COLLECTIONS
GTCEF  DAC  0                SAVE FAIL PTR IN CASE OF ERROR
.IF    .CNRA
.ELSE
.IF    .CNCR
.ELSE
GTSRN  DRC  +0.0             ROUNDING FACTOR 0.5*10**-CFP_S
GTSSC  DRC  +0.0             SCALING VALUE 10**CFP_S
.FI
.FI
GTSWK  DAC  0                PTR TO WORK AREA FOR GTSTG
HEADP  DAC  0                HEADER PRINTED FLAG
HSHNB  DIC  +0               NUMBER OF HASH BUCKETS
INITR  DAC  0                SAVE TERMINAL FLAG
KVABE  DAC  0                ABEND
KVANC  DAC  0                ANCHOR
.IF    .CULC
KVCAS  DAC  0                CASE
.FI
KVCOD  DAC  0                CODE
.IF    .CCMK
KVCOM  DAC  0                COMPARE
.FI
KVDMP  DAC  0                DUMP
KVERL  DAC  0                ERRLIMIT
KVERT  DAC  0                ERRTYPE
KVFTR  DAC  0                FTRACE
KVFLS  DAC  1                FULLSCAN
KVINP  DAC  1                INPUT
KVMXL  DAC  5000             MAXLENGTH
KVOUP  DAC  1                OUTPUT
.IF    .CNPF
.ELSE
KVPFL  DAC  0                PROFILE
.FI
KVTRA  DAC  0                TRACE
KVTRM  DAC  0                TRIM
KVFNC  DAC  0                FNCLEVEL
KVLST  DAC  0                LASTNO
.IF    .CSLN
KVLLN  DAC  0                LASTLINE
KVLIN  DAC  0                LINE
.FI
KVSTN  DAC  0                STNO
KVALP  DAC  0                ALPHABET
KVRTN  DAC  NULLS            RTNTYPE (SCBLK POINTER)
.IF    .CS16
KVSTL  DIC  +32767           STLIMIT
KVSTC  DIC  +32767           STCOUNT (COUNTS DOWN FROM STLIMIT)
.ELSE
.IF    .CS32
KVSTL  DIC  +2147483647      STLIMIT
KVSTC  DIC  +2147483647      STCOUNT (COUNTS DOWN FROM STLIMIT)
.ELSE
KVSTL  DIC  +50000           STLIMIT
KVSTC  DIC  +50000           STCOUNT (COUNTS DOWN FROM STLIMIT)
.FI
.FI
.IF    .CINC
LSTID  DAC  0                INCLUDE DEPTH OF CURRENT IMAGE
.FI
LSTLC  DAC  0                COUNT LINES ON SOURCE LIST PAGE
LSTNP  DAC  0                MAX NUMBER OF LINES ON PAGE
LSTPF  DAC  1                SET NONZERO IF CURRENT IMAGE LISTED
LSTPG  DAC  0                CURRENT SOURCE LIST PAGE NUMBER
LSTPO  DAC  0                OFFSET TO   PAGE NNN   MESSAGE
LSTSN  DAC  0                REMEMBER LAST STMNUM LISTED
MXLEN  DAC  0                INITIALISED BY SYSMX CALL
NOXEQ  DAC  0                SET NON-ZERO TO INHIBIT EXECUTION
.IF    .CNPF
.ELSE
PFDMP  DAC  0                SET NON-0 IF &PROFILE SET NON-0
PFFNC  DAC  0                SET NON-0 IF FUNCT JUST ENTERED
PFSTM  DIC  +0               TO STORE STARTING TIME OF STMT
PFETM  DIC  +0               TO STORE ENDING TIME OF STMT
PFNTE  DAC  0                NR OF TABLE ENTRIES
PFSTE  DIC  +0               GETS INT REP OF TABLE ENTRY SIZE
.FI
PMDFL  DAC  0                PATTERN ASSIGNMENT FLAG
PMHBS  DAC  0                HISTORY STACK BASE POINTER
PMSSL  DAC  0                LENGTH OF SUBJECT STRING IN CHARS
.IF    .CPOL
POLCS  DAC  1                POLL INTERVAL START VALUE
POLCT  DAC  1                POLL INTERVAL COUNTER
.FI
PRICH  DAC  0                PRINTER ON INTERACTIVE CHANNEL
PRSTD  DAC  0                TESTED BY PRTPG
PRSTO  DAC  0                STANDARD LISTING OPTION FLAG
PRBUF  DAC  0                PTR TO PRINT BFR IN STATIC
PRECL  DAC  0                EXTENDED/COMPACT LISTING FLAG
PRLEN  DAC  0                LENGTH OF PRINT BUFFER IN CHARS
PRLNW  DAC  0                LENGTH OF PRINT BUFFER IN WORDS
PROFS  DAC  0                OFFSET TO NEXT LOCATION IN PRBUF
PRTEF  DAC  0                ENDFILE FLAG
RDCLN  DAC  0                CURRENT STATEMENT LINE NUMBER
RDNLN  DAC  0                NEXT STATEMENT LINE NUMBER
RSMEM  DAC  0                RESERVE MEMORY
STMCS  DAC  1                COUNTER STARTUP VALUE
STMCT  DAC  1                COUNTER ACTIVE VALUE
A_AAA  DAC  0                START OF ADJUSTABLE VALUES
CMPSS  DAC  0                SAVE SUBROUTINE STACK PTR
DNAMB  DAC  0                START OF DYNAMIC AREA
DNAMP  DAC  0                NEXT AVAILABLE LOC IN DYNAMIC AREA
DNAME  DAC  0                END OF AVAILABLE DYNAMIC AREA
HSHTB  DAC  0                POINTER TO START OF VRBLK HASH TABL
HSHTE  DAC  0                POINTER PAST END OF VRBLK HASH TABL
INISS  DAC  0                SAVE SUBROUTINE STACK PTR
PFTBL  DAC  0                GETS ADRS OF (IMAG) TABLE BASE
PRNMV  DAC  0                VRBLK PTR FROM LAST NAME SEARCH
STATB  DAC  0                START OF STATIC AREA
STATE  DAC  0                END OF STATIC AREA
STXVR  DAC  NULLS            VRBLK POINTER OR NULL

R_AAA  DAC  0                START OF RELOCATABLE VALUES
R_ARF  DAC  0                ARRAY BLOCK POINTER FOR ARREF
R_CCB  DAC  0                PTR TO CCBLK BEING BUILT (CDWRD)
R_CIM  DAC  0                PTR TO CURRENT COMPILER INPUT STR
R_CMP  DAC  0                COPY OF R_CIM USED IN CMPIL
R_CNI  DAC  0                PTR TO NEXT COMPILER INPUT STRING
R_CNT  DAC  0                CDBLK POINTER FOR SETEXIT CONTINUE
R_COD  DAC  0                POINTER TO CURRENT CDBLK OR EXBLK
R_CTP  DAC  0                PTR TO CURRENT CTBLK FOR PATST
R_CTS  DAC  0                PTR TO LAST STRING SCANNED BY PATST
R_ERT  DAC  0                TRBLK POINTER FOR ERRTYPE TRACE
R_ETX  DAC  NULLS            POINTER TO ERRTEXT STRING
R_EXS  DAC  0                = SAVE XL IN EXPDM
R_FCB  DAC  0                FCBLK CHAIN HEAD
R_FNC  DAC  0                TRBLK POINTER FOR FNCLEVEL TRACE
R_GTC  DAC  0                KEEP CODE PTR FOR GTCOD,GTEXP
.IF    .CINC
R_ICI  DAC  0                SAVED R_CIM DURING INCLUDE PROCESS.
.IF    .CSFN
R_IFA  DAC  0                ARRAY OF FILE NAMES BY INCL. DEPTH
R_IFL  DAC  0                ARRAY OF LINE NUMS BY INCLUDE DEPTH
.FI
R_IFN  DAC  0                LAST INCLUDE FILE NAME
R_INC  DAC  0                TABLE OF INCLUDE FILE NAMES SEEN
.FI
R_IO1  DAC  0                FILE ARG1 FOR IOPUT
R_IO2  DAC  0                FILE ARG2 FOR IOPUT
R_IOF  DAC  0                FCBLK PTR OR 0
R_ION  DAC  0                NAME BASE PTR
R_IOP  DAC  0                PREDECESSOR BLOCK PTR FOR IOPUT
R_IOT  DAC  0                TRBLK PTR FOR IOPUT
.IF    .CNBF
.ELSE
R_PMB  DAC  0                BUFFER PTR IN PATTERN MATCH
.FI
R_PMS  DAC  0                SUBJECT STRING PTR IN PATTERN MATCH
R_RA2  DAC  0                REPLACE SECOND ARGUMENT LAST TIME
R_RA3  DAC  0                REPLACE THIRD ARGUMENT LAST TIME
R_RPT  DAC  0                PTR TO CTBLK REPLACE TABLE LAST USD
R_SCP  DAC  0                SAVE POINTER FROM LAST SCANE CALL
.IF    .CSFN
R_SFC  DAC  NULLS            CURRENT SOURCE FILE NAME
R_SFN  DAC  0                PTR TO SOURCE FILE NAME TABLE
.FI
R_SXL  DAC  0                PRESERVE XL IN SORTC
R_SXR  DAC  0                PRESERVE XR IN SORTA/SORTC
R_STC  DAC  0                TRBLK POINTER FOR STCOUNT TRACE
R_STL  DAC  0                SOURCE LISTING SUB-TITLE
R_SXC  DAC  0                CODE (CDBLK) PTR FOR SETEXIT TRAP
R_TTL  DAC  NULLS            SOURCE LISTING TITLE
R_XSC  DAC  0                STRING POINTER FOR XSCAN
R_UBA  DAC  STNDO            BINARY AT
R_UBM  DAC  STNDO            BINARY AMPERSAND
R_UBN  DAC  STNDO            BINARY NUMBER SIGN
R_UBP  DAC  STNDO            BINARY PERCENT
R_UBT  DAC  STNDO            BINARY NOT
R_UUB  DAC  STNDO            UNARY VERTICAL BAR
R_UUE  DAC  STNDO            UNARY EQUAL
R_UUN  DAC  STNDO            UNARY NUMBER SIGN
R_UUP  DAC  STNDO            UNARY PERCENT
R_UUS  DAC  STNDO            UNARY SLASH
R_UUX  DAC  STNDO            UNARY EXCLAMATION
R_YYY  DAC  0                LAST RELOCATABLE LOCATION
SCNBL  DAC  0                SET NON-ZERO IF SCANNED PAST BLANKS
SCNCC  DAC  0                NON-ZERO TO SCAN CONTROL CARD NAME
SCNGO  DAC  0                SET NON-ZERO TO SCAN GOTO FIELD
SCNIL  DAC  0                LENGTH OF CURRENT INPUT IMAGE
SCNPT  DAC  0                POINTER TO NEXT LOCATION IN R_CIM
SCNRS  DAC  0                SET NON-ZERO TO SIGNAL RESCAN
SCNSE  DAC  0                START OF CURRENT ELEMENT
SCNTP  DAC  0                SAVE SYNTAX TYPE FROM LAST CALL
STAGE  DAC  0                INITIAL VALUE = INITIAL COMPILE
STBAS  DAC  0                POINTER PAST STACK BASE
STXOC  DAC  0                CODE POINTER OFFSET
STXOF  DAC  0                FAILURE OFFSET
TIMSX  DIC  +0               TIME AT START OF EXECUTION
TIMUP  DAC  0                SET WHEN TIME UP OCCURS
XSOFS  DAC  0                OFFSET TO CURRENT LOCATION IN R_XSC
W_YYY  DAC  0
       TTL  S P I T B O L -- MINIMAL CODE
       SEC                   START OF PROGRAM SECTION
S_AAA  ENT  BL__I            MARK START OF CODE
.IF    .CREL
       TTL  S P I T B O L -- RELOCATION
RELAJ  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE XR
       MOV  WA,-(XS)         SAVE WA
       MOV  XL,RLALS         SAVE PTR TO LIST OF BOUNDS
       MOV  WB,XR            PTR TO FIRST POINTER TO PROCESS
RLAJ0  MOV  RLALS,XL         RESTORE XL
       BNE  XR,(XS),RLAJ1    PROCEED IF MORE TO DO
       MOV  (XS)+,WA         RESTORE WA
       MOV  (XS)+,XR         RESTORE XR
       EXI                   RETURN TO CALLER
RLAJ1  MOV  (XR),WA          LOAD NEXT POINTER ON LIST
       LCT  WB,=RNSI_        NUMBER OF SECTIONS OF ADJUSTERS
RLAJ2  BGT  WA,RLEND(XL),RLAJ3 OK IF PAST END OF SECTION
       BLT  WA,RLSTR(XL),RLAJ3 OR IF BEFORE START OF SECTION
       ADD  RLADJ(XL),WA     WITHIN SECTION, ADD ADJUSTMENT
       MOV  WA,(XR)          RETURN UPDATED PTR TO MEMORY
       BRN  RLAJ4            DONE WITH THIS POINTER
RLAJ3  ADD  *RSSI_,XL        ADVANCE TO NEXT SECTION
       BCT  WB,RLAJ2         JUMP IF MORE TO GO
RLAJ4  ICA  XR               INCREMENT TO NEXT PTR ON LIST
       BRN  RLAJ0            JUMP TO CHECK  FOR COMPLETION
       ENP                   END PROCEDURE RELAJ
RELCR  PRC  E,0              ENTRY POINT
       ADD  *RLSI_,XL        POINT PAST BUILD AREA
       MOV  WA,-(XL)         SAVE ORIGINAL CODE ADDRESS
       MOV  =S_AAA,WA        COMPUTE ADJUSTMENT
       SUB  (XL),WA          AS NEW S_AAA MINUS ORIGINAL S_AAA
       MOV  WA,-(XL)         SAVE CODE ADJUSTMENT
       MOV  =S_YYY,WA        END OF TARGET CODE SECTION
       SUB  =S_AAA,WA        LENGTH OF CODE SECTION
       ADD  NUM01(XL),WA     PLUS ORIGINAL START ADDRESS
       MOV  WA,-(XL)         END OF ORIGINAL CODE SECTION
       MOV  WB,-(XL)         SAVE CONSTANT SECTION ADDRESS
       MOV  =C_AAA,WB        START OF CONSTANTS SECTION
       MOV  =C_YYY,WA        END OF CONSTANTS SECTION
       SUB  WB,WA            LENGTH OF CONSTANTS SECTION
       SUB  (XL),WB          NEW C_AAA MINUS ORIGINAL C_AAA
       MOV  WB,-(XL)         SAVE CONSTANT ADJUSTMENT
       ADD  NUM01(XL),WA     LENGTH PLUS ORIGINAL START ADR
       MOV  WA,-(XL)         SAVE AS END OF ORIGINAL CONSTANTS
       MOV  WC,-(XL)         SAVE WORKING GLOBALS ADDRESS
       MOV  =G_AAA,WC        START OF WORKING GLOBALS SECTION
       MOV  =W_YYY,WA        END OF WORKING SECTION
       SUB  WC,WA            LENGTH OF WORKING GLOBALS
       SUB  (XL),WC          NEW G_AAA MINUS ORIGINAL G_AAA
       MOV  WC,-(XL)         SAVE WORKING GLOBALS ADJUSTMENT
       ADD  NUM01(XL),WA     LENGTH PLUS ORIGINAL START ADR
       MOV  WA,-(XL)         SAVE AS END OF WORKING GLOBALS
       MOV  STATB,WB         OLD START OF STATIC REGION
       MOV  WB,-(XL)         SAVE
       SUB  WB,XR            COMPUTE ADJUSTMENT
       MOV  XR,-(XL)         SAVE NEW STATB MINUS OLD STATB
       MOV  STATE,-(XL)      OLD END OF STATIC REGION
       MOV  DNAMB,WB         OLD START OF DYNAMIC REGION
       MOV  WB,-(XL)         SAVE
       SCP  WA               NEW START OF DYNAMIC
       SUB  WB,WA            COMPUTE ADJUSTMENT
       MOV  WA,-(XL)         SAVE NEW DNAMB MINUS OLD DNAMB
       MOV  DNAMP,WC         OLD END OF DYNAMIC REGION IN USE
       MOV  WC,-(XL)         SAVE AS END OF OLD DYNAMIC REGION
       EXI
       ENP
RELDN  PRC  E,0              ENTRY POINT
       MOV  RLCDA(XL),RLDCD  SAVE CODE ADJUSTMENT
       MOV  RLSTA(XL),RLDST  SAVE STATIC ADJUSTMENT
       MOV  XL,RLDLS         SAVE LIST POINTER
RLD01  ADD  RLDCD,(XR)       ADJUST BLOCK TYPE WORD
       MOV  (XR),XL          LOAD BLOCK TYPE WORD
       LEI  XL               LOAD ENTRY POINT ID (BL_XX)
       BSW  XL,BL___         SWITCH ON BLOCK TYPE
       IFF  BL_AR,RLD03      ARBLK
.IF    .CNBF
       IFF  BL_BC,RLD05      BCBLK - DUMMY TO FILL OUT IFFS
.ELSE
       IFF  BL_BC,RLD06      BCBLK
.FI
       IFF  BL_BF,RLD05      BFBLK
       IFF  BL_CC,RLD05      CCBLK
       IFF  BL_CD,RLD07      CDBLK
       IFF  BL_CM,RLD05      CMBLK
       IFF  BL_CT,RLD05      CTBLK
       IFF  BL_DF,RLD05      DFBLK
       IFF  BL_EF,RLD08      EFBLK
       IFF  BL_EV,RLD09      EVBLK
       IFF  BL_EX,RLD10      EXBLK
       IFF  BL_FF,RLD11      FFBLK
       IFF  BL_IC,RLD05      ICBLK
       IFF  BL_KV,RLD13      KVBLK
       IFF  BL_NM,RLD13      NMBLK
       IFF  BL_P0,RLD13      P0BLK
       IFF  BL_P1,RLD14      P1BLK
       IFF  BL_P2,RLD14      P2BLK
       IFF  BL_PD,RLD15      PDBLK
       IFF  BL_PF,RLD16      PFBLK
.IF    .CNRA
.ELSE
       IFF  BL_RC,RLD05      RCBLK
.FI
       IFF  BL_SC,RLD05      SCBLK
       IFF  BL_SE,RLD13      SEBLK
       IFF  BL_TB,RLD17      TBBLK
       IFF  BL_TE,RLD18      TEBLK
       IFF  BL_TR,RLD19      TRBLK
       IFF  BL_VC,RLD17      VCBLK
       IFF  BL_XN,RLD05      XNBLK
       IFF  BL_XR,RLD20      XRBLK
       ESW                   END OF JUMP TABLE
RLD03  MOV  ARLEN(XR),WA     LOAD LENGTH
       MOV  AROFS(XR),WB     SET OFFSET TO 1ST RELOC FLD (ARPRO)
RLD04  ADD  XR,WA            POINT PAST LAST RELOC FIELD
       ADD  XR,WB            POINT TO FIRST RELOC FIELD
       MOV  RLDLS,XL         POINT TO LIST OF BOUNDS
       JSR  RELAJ            ADJUST POINTERS
RLD05  MOV  (XR),WA          BLOCK TYPE WORD
       JSR  BLKLN            GET LENGTH OF BLOCK
       ADD  WA,XR            POINT TO NEXT BLOCK
       BLT  XR,WC,RLD01      CONTINUE IF MORE TO PROCESS
       MOV  RLDLS,XL         RESTORE XL
       EXI                   RETURN TO CALLER IF DONE
.IF    .CNBF
.ELSE
RLD06  MOV  *BCSI_,WA        SET LENGTH
       MOV  *BCBUF,WB        AND OFFSET
       BRN  RLD04            ALL SET
.FI
RLD07  MOV  CDLEN(XR),WA     LOAD LENGTH
       MOV  *CDFAL,WB        SET OFFSET
       BNE  (XR),=B_CDC,RLD04 JUMP BACK IF NOT COMPLEX GOTO
       MOV  *CDCOD,WB        DO NOT PROCESS CDFAL WORD
       BRN  RLD04            JUMP BACK
RLD08  MOV  *EFRSL,WA        SET LENGTH
       MOV  *EFCOD,WB        AND OFFSET
       BRN  RLD04            ALL SET
RLD09  MOV  *OFFS3,WA        POINT PAST THIRD FIELD
       MOV  *EVEXP,WB        SET OFFSET
       BRN  RLD04            ALL SET
RLD10  MOV  EXLEN(XR),WA     LOAD LENGTH
       MOV  *EXFLC,WB        SET OFFSET
       BRN  RLD04            JUMP BACK
RLD11  BNE  FFOFS(XR),*PDFLD,RLD12 SKIP DFBLK IF NOT FIRST FIELD
       MOV  XR,-(XS)         SAVE XR
       MOV  FFDFP(XR),XR     LOAD OLD PTR TO DFBLK
       ADD  RLDST,XR         CURRENT LOCATION OF DFBLK
       ADD  RLDCD,(XR)       ADJUST DFBLK TYPE WORD
       MOV  DFLEN(XR),WA     LENGTH OF DFBLK
       MOV  *DFNAM,WB        OFFSET TO DFNAM FIELD
       ADD  XR,WA            POINT PAST LAST RELOC FIELD
       ADD  XR,WB            POINT TO FIRST RELOC FIELD
       MOV  RLDLS,XL         POINT TO LIST OF BOUNDS
       JSR  RELAJ            ADJUST POINTERS
       MOV  DFNAM(XR),XR     POINTER TO STATIC SCBLK
       ADD  RLDCD,(XR)       ADJUST SCBLK TYPE WORD
       MOV  (XS)+,XR         RESTORE FFBLK POINTER
RLD12  MOV  *FFOFS,WA        SET LENGTH
       MOV  *FFDFP,WB        SET OFFSET
       BRN  RLD04            ALL SET
RLD13  MOV  *OFFS2,WA        POINT PAST SECOND FIELD
       MOV  *OFFS1,WB        OFFSET IS ONE (ONLY RELOC FLD IS 2)
       BRN  RLD04            ALL SET
RLD14  MOV  *PARM2,WA        LENGTH (PARM2 IS NON-RELOCATABLE)
       MOV  *PTHEN,WB        SET OFFSET
       BRN  RLD04            ALL SET
RLD15  MOV  PDDFP(XR),XL     LOAD PTR TO DFBLK
       ADD  RLDST,XL         ADJUST FOR STATIC RELOCATION
       MOV  DFPDL(XL),WA     GET PDBLK LENGTH
       MOV  *PDDFP,WB        SET OFFSET
       BRN  RLD04            ALL SET
RLD16  ADD  RLDST,PFVBL(XR)  ADJUST NON-CONTIGUOUS FIELD
       MOV  PFLEN(XR),WA     GET PFBLK LENGTH
       MOV  *PFCOD,WB        OFFSET TO FIRST RELOC
       BRN  RLD04            ALL SET
RLD17  MOV  OFFS2(XR),WA     LOAD LENGTH
       MOV  *OFFS3,WB        SET OFFSET
       BRN  RLD04            JUMP BACK
RLD18  MOV  *TESI_,WA        SET LENGTH
       MOV  *TESUB,WB        AND OFFSET
       BRN  RLD04            ALL SET
RLD19  MOV  *TRSI_,WA        SET LENGTH
       MOV  *TRVAL,WB        AND OFFSET
       BRN  RLD04            ALL SET
RLD20  MOV  XRLEN(XR),WA     LOAD LENGTH
       MOV  *XRPTR,WB        SET OFFSET
       BRN  RLD04            JUMP BACK
       ENP                   END PROCEDURE RELDN
RELOC  PRC  E,0              ENTRY POINT
       MOV  RLDYS(XL),XR     OLD START OF DYNAMIC
       MOV  RLDYE(XL),WC     OLD END OF DYNAMIC
       ADD  RLDYA(XL),XR     CREATE NEW START OF DYNAMIC
       ADD  RLDYA(XL),WC     CREATE NEW END OF DYNAMIC
       JSR  RELDN            RELOCATE POINTERS IN DYNAMIC
       JSR  RELWS            RELOCATE POINTERS IN WORKING SECT
       JSR  RELST            RELOCATE POINTERS IN STATIC
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE RELOC
RELST  PRC  E,0              ENTRY POINT
       MOV  PFTBL,XR         PROFILE TABLE
       BZE  XR,RLS01         BRANCH IF NO TABLE ALLOCATED
       ADD  RLCDA(XL),(XR)   ADJUST BLOCK TYPE WORD
RLS01  MOV  HSHTB,WC         POINT TO START OF HASH TABLE
       MOV  WC,WB            POINT TO FIRST HASH BUCKET
       MOV  HSHTE,WA         POINT BEYOND HASH TABLE
       JSR  RELAJ            ADJUST BUCKET POINTERS
RLS02  BEQ  WC,HSHTE,RLS05   DONE IF NONE LEFT
       MOV  WC,XR            ELSE COPY SLOT POINTER
       ICA  WC               BUMP SLOT POINTER
       SUB  *VRNXT,XR        SET OFFSET TO MERGE INTO LOOP
RLS03  MOV  VRNXT(XR),XR     POINT TO NEXT VRBLK ON CHAIN
       BZE  XR,RLS02         JUMP FOR NEXT BUCKET IF CHAIN END
       MOV  *VRLEN,WA        OFFSET OF FIRST LOC PAST PTR FIELDS
       MOV  *VRGET,WB        OFFSET OF FIRST LOCATION IN VRBLK
       BNZ  VRLEN(XR),RLS04  JUMP IF NOT SYSTEM VARIABLE
       MOV  *VRSI_,WA        OFFSET TO INCLUDE VRSVP FIELD
RLS04  ADD  XR,WA            CREATE END PTR
       ADD  XR,WB            CREATE START PTR
       JSR  RELAJ            ADJUST POINTERS IN VRBLK
       BRN  RLS03            CHECK FOR ANOTHER VRBLK ON CHAIN
RLS05  EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE RELST
RELWS  PRC  E,0              ENTRY POINT
       MOV  =A_AAA,WB        POINT TO START OF ADJUSTABLES
       MOV  =R_YYY,WA        POINT TO END OF ADJUSTABLES
       JSR  RELAJ            RELOCATE ADJUSTABLE POINTERS
       ADD  RLDYA(XL),DNAME  ADJUST PTR MISSED BY RELAJ
       MOV  =KVRTN,WB        CASE OF KVRTN
       MOV  WB,WA            HANDLED SPECIALLY
       ICA  WA               ONE VALUE TO ADJUST
       JSR  RELAJ            ADJUST KVRTN
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE RELWS
.FI
       TTL  S P I T B O L -- INITIALIZATION
START  PRC  E,0              ENTRY POINT
       MOV  WA,XS            DISCARD RETURN
       JSR  SYSTM            INITIALISE TIMER
.IF    .CNBT
       STI  TIMSX            STORE TIME
       MOV  XR,STATB         START ADDRESS OF STATIC
.ELSE
       MOV  XR,WB            PRESERVE XR
       MOV  =W_YYY,WA        POINT TO END OF WORK AREA
       SUB  =W_AAA,WA        GET LENGTH OF WORK AREA
       BTW  WA               CONVERT TO WORDS
       LCT  WA,WA            COUNT FOR LOOP
       MOV  =W_AAA,XR        SET UP INDEX REGISTER
INI01  ZER  (XR)+            CLEAR A WORD
       BCT  WA,INI01         LOOP TILL DONE
       MOV  =STNDO,WA        UNDEFINED OPERATORS POINTER
       MOV  =R_YYY,WC        POINT TO TABLE END
       SUB  =R_UBA,WC        LENGTH OF UNDEF. OPERATORS TABLE
       BTW  WC               CONVERT TO WORDS
       LCT  WC,WC            LOOP COUNTER
       MOV  =R_UBA,XR        SET UP XR
INI02  MOV  WA,(XR)+         STORE VALUE
       BCT  WC,INI02         LOOP TILL ALL DONE
       MOV  =NUM01,WA        GET A 1
.IF    .CPOL
       MOV  WA,POLCS         INTERFACE POLLING INTERVAL
       MOV  WA,POLCT         INTERFACE POLLING INTERVAL
.FI
       MOV  WA,CMPSN         STATEMENT NO
       MOV  WA,CSWFL         NOFAIL
       MOV  WA,CSWLS         LIST
       MOV  WA,KVINP         INPUT
       MOV  WA,KVOUP         OUTPUT
       MOV  WA,LSTPF         NOTHING FOR LISTR YET
       MOV  =INILN,WA        INPUT IMAGE LENGTH
       MOV  WA,CSWIN         -IN72
       MOV  =NULLS,WA        GET NULL STRING POINTER
       MOV  WA,KVRTN         RETURN
       MOV  WA,R_ETX         ERRTEXT
       MOV  WA,R_TTL         TITLE FOR LISTING
       MOV  WA,STXVR         SETEXIT
       STI  TIMSX            STORE TIME IN CORRECT PLACE
       LDI  STLIM            GET DEFAULT STLIMIT
       STI  KVSTL            STATEMENT LIMIT
       STI  KVSTC            STATEMENT COUNT
       MOV  WB,STATB         STORE START ADRS OF STATIC
.FI
       MOV  *E_SRS,RSMEM     RESERVE MEMORY
       MOV  XS,STBAS         STORE STACK BASE
       SSS  INISS            SAVE S-R STACK PTR
       LDI  INTVH            GET 100
       DVI  ALFSP            FORM 100 / ALFSP
       STI  ALFSF            STORE THE FACTOR
.IF    .CSED
       LDI  INTVH            GET 100
       DVI  GBSDP            FORM 100 / GBSDP
       STI  GBSED            STORE THE FACTOR
.FI
.IF    .CNRA
.ELSE
.IF    .CNCR
.ELSE
       LCT  WB,=CFP_S        LOAD COUNTER FOR SIGNIFICANT DIGITS
       LDR  REAV1            LOAD 1.0
INI03  MLR  REAVT            * 10.0
       BCT  WB,INI03         LOOP TILL DONE
       STR  GTSSC            STORE 10**(MAX SIG DIGITS)
       LDR  REAP5            LOAD 0.5
       DVR  GTSSC            COMPUTE 0.5*10**(MAX SIG DIGITS)
       STR  GTSRN            STORE AS ROUNDING BIAS
.FI
.FI
       ZER  WC               SET TO READ PARAMETERS
       JSR  PRPAR            READ THEM
       SUB  *E_SRS,XL        ALLOW FOR RESERVE MEMORY
       MOV  PRLEN,WA         GET PRINT BUFFER LENGTH
       ADD  =CFP_A,WA        ADD NO. OF CHARS IN ALPHABET
       ADD  =NSTMX,WA        ADD CHARS FOR GTSTG BFR
       CTB  WA,8             CONVERT TO BYTES, ALLOWING A MARGIN
       MOV  STATB,XR         POINT TO STATIC BASE
       ADD  WA,XR            INCREMENT FOR ABOVE BUFFERS
       ADD  *E_HNB,XR        INCREMENT FOR HASH TABLE
       ADD  *E_STS,XR        BUMP FOR INITIAL STATIC BLOCK
       JSR  SYSMX            GET MXLEN
       MOV  WA,KVMXL         PROVISIONALLY STORE AS MAXLNGTH
       MOV  WA,MXLEN         AND AS MXLEN
       BGT  XR,WA,INI06      SKIP IF STATIC HI EXCEEDS MXLEN
       CTB  WA,1             ROUND UP AND MAKE BIGGER THAN MXLEN
       MOV  WA,XR            USE IT INSTEAD
INI06  MOV  XR,DNAMB         DYNAMIC BASE ADRS
       MOV  XR,DNAMP         DYNAMIC PTR
       BNZ  WA,INI07         SKIP IF NON-ZERO MXLEN
       DCA  XR               POINT A WORD IN FRONT
       MOV  XR,KVMXL         USE AS MAXLNGTH
       MOV  XR,MXLEN         AND AS MXLEN
INI07  MOV  XL,DNAME         STORE DYNAMIC END ADDRESS
       BLT  DNAMB,XL,INI09   SKIP IF HIGH ENOUGH
       JSR  SYSMM            REQUEST MORE MEMORY
       WTB  XR               GET AS BAUS (SGD05)
       ADD  XR,XL            BUMP BY AMOUNT OBTAINED
       BNZ  XR,INI07         TRY AGAIN
.IF    .CERA
       MOV  =MXERN,WA        INSUFFICIENT MEMORY FOR MAXLENGTH
       ZER  WB               NO COLUMN NUMBER INFO
       ZER  WC               NO LINE NUMBER INFO
       MOV  =STGIC,XR        INITIAL COMPILE STAGE
.IF    .CSFN
       MOV  =NULLS,XL        NO FILE NAME
.FI
       JSR  SYSEA            ADVISE OF ERROR
       PPM  INI08            CANT USE ERROR LOGIC YET
       BRN  INI08            FORCE TERMINATION
       ERB  329,Requested MAXLNGTH too large
.FI
INI08  MOV  =ENDMO,XR        POINT TO FAILURE MESSAGE
       MOV  ENDML,WA         MESSAGE LENGTH
       JSR  SYSPR            PRINT IT (PRTST NOT YET USABLE)
       PPM                   SHOULD NOT FAIL
       ZER  XL               NO FCB CHAIN YET
       MOV  =NUM10,WB        SET SPECIAL CODE VALUE
       JSR  SYSEJ            PACK UP (STOPR NOT YET USABLE)
INI09  MOV  STATB,XR         POINT TO STATIC AGAIN
       JSR  INSTA            INITIALIZE STATIC
       MOV  =E_HNB,WA        GET NUMBER OF HASH HEADERS
       MTI  WA               CONVERT TO INTEGER
       STI  HSHNB            STORE FOR USE BY GTNVR PROCEDURE
       LCT  WA,WA            COUNTER FOR CLEARING HASH TABLE
       MOV  XR,HSHTB         POINTER TO HASH TABLE
INI11  ZER  (XR)+            BLANK A WORD
       BCT  WA,INI11         LOOP
       MOV  XR,HSHTE         END OF HASH TABLE ADRS IS KEPT
       MOV  XR,STATE         STORE STATIC END ADDRESS
.IF    .CSFN
       MOV  =NUM01,WC        TABLE WILL HAVE ONLY ONE BUCKET
       MOV  =NULLS,XL        DEFAULT TABLE VALUE
       MOV  XL,R_SFC         CURRENT SOURCE FILE NAME
       JSR  TMAKE            CREATE TABLE
       MOV  XR,R_SFN         SAVE PTR TO TABLE
.FI
.IF    .CINC
       MOV  =NUM01,WC        TABLE WILL HAVE ONLY ONE BUCKET
       MOV  =NULLS,XL        DEFAULT TABLE VALUE
       JSR  TMAKE            CREATE TABLE
       MOV  XR,R_INC         SAVE PTR TO TABLE
.IF    .CSFN
       MOV  =CCINM,WA        MAXIMUM NESTING LEVEL
       MOV  =NULLS,XL        NULL STRING DEFAULT VALUE
       JSR  VMAKE            CREATE ARRAY
       PPM
       MOV  XR,R_IFA         SAVE PTR TO ARRAY
       MOV  =CCINM,WA        MAXIMUM NESTING LEVEL
       MOV  =INTON,XL        INTEGER ONE DEFAULT VALUE
       JSR  VMAKE            CREATE ARRAY
       PPM
       MOV  XR,R_IFL         SAVE PTR TO ARRAY
.FI
.FI
       MOV  =V_INP,XL        POINT TO STRING /INPUT/
       MOV  =TRTIN,WB        TRBLK TYPE FOR INPUT
       JSR  INOUT            PERFORM INPUT ASSOCIATION
       MOV  =V_OUP,XL        POINT TO STRING /OUTPUT/
       MOV  =TRTOU,WB        TRBLK TYPE FOR OUTPUT
       JSR  INOUT            PERFORM OUTPUT ASSOCIATION
       MOV  INITR,WC         TERMINAL FLAG
       BZE  WC,INI13         SKIP IF NO TERMINAL
       JSR  PRPAR            ASSOCIATE TERMINAL
INI13  JSR  SYSDC            CALL DATE CHECK
       MOV  XS,FLPTR         IN CASE STACK OVERFLOWS IN COMPILER
       JSR  CMPIL            CALL COMPILER
       MOV  XR,R_COD         SET PTR TO FIRST CODE BLOCK
       MOV  =NULLS,R_TTL     FORGET TITLE
       MOV  =NULLS,R_STL     FORGET SUB-TITLE
       ZER  R_CIM            FORGET COMPILER INPUT IMAGE
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
.IF    .CINC
       ZER  CNIND            IN CASE END OCCURRED WITH INCLUDE
       ZER  LSTID            LISTING INCLUDE DEPTH
.FI
       ZER  XL               CLEAR DUD VALUE
       ZER  WB               DONT SHIFT DYNAMIC STORE UP
.IF    .CSED
       ZER  DNAMS            COLLECT SEDIMENT TOO
       JSR  GBCOL            CLEAR GARBAGE LEFT FROM COMPILE
       MOV  XR,DNAMS         RECORD NEW SEDIMENT SIZE
.ELSE
       JSR  GBCOL            CLEAR GARBAGE LEFT FROM COMPILE
.FI
       BNZ  CPSTS,INIX0      SKIP IF NO LISTING OF COMP STATS
       JSR  PRTPG            EJECT PAGE
       JSR  PRTMM            PRINT MEMORY USAGE
       MTI  CMERC            GET COUNT OF ERRORS AS INTEGER
       MOV  =ENCM3,XR        POINT TO /COMPILE ERRORS/
       JSR  PRTMI            PRINT IT
       MTI  GBCNT            GARBAGE COLLECTION COUNT
       SBI  INTV1            ADJUST FOR UNAVOIDABLE COLLECT
       MOV  =STPM5,XR        POINT TO /STORAGE REGENERATIONS/
       JSR  PRTMI            PRINT GBCOL COUNT
       JSR  SYSTM            GET TIME
       SBI  TIMSX            GET COMPILATION TIME
       MOV  =ENCM4,XR        POINT TO COMPILATION TIME (MSEC)/
       JSR  PRTMI            PRINT MESSAGE
       ADD  =NUM05,LSTLC     BUMP LINE COUNT
.IF    .CUEJ
       BZE  HEADP,INIX0      NO EJECT IF NOTHING PRINTED
       JSR  PRTPG            EJECT PRINTER
.FI
INIX0  BGT  CSWIN,=INILN,INIX1 SKIP IF NOT DEFAULT -IN72 USED
       MOV  =INILS,CSWIN     ELSE USE DEFAULT RECORD LENGTH
INIX1  JSR  SYSTM            GET TIME AGAIN
       STI  TIMSX            STORE FOR END RUN PROCESSING
       ZER  GBCNT            INITIALISE COLLECT COUNT
       JSR  SYSBX            CALL BEFORE STARTING EXECUTION
       ADD  CSWEX,NOXEQ      ADD -NOEXECUTE FLAG
       BNZ  NOXEQ,INIX2      JUMP IF EXECUTION SUPPRESSED
.IF    .CUEJ
.ELSE
       BZE  HEADP,INIY0      NO EJECT IF NOTHING PRINTED (SGD11)
       JSR  PRTPG            EJECT PRINTER
.FI
INIY0  MNZ  HEADP            MARK HEADERS OUT REGARDLESS
       ZER  -(XS)            SET FAILURE LOCATION ON STACK
       MOV  XS,FLPTR         SAVE PTR TO FAILURE OFFSET WORD
       MOV  R_COD,XR         LOAD PTR TO ENTRY CODE BLOCK
       MOV  =STGXT,STAGE     SET STAGE FOR EXECUTE TIME
.IF    .CPOL
       MOV  =NUM01,POLCS     RESET INTERFACE POLLING INTERVAL
       MOV  =NUM01,POLCT     RESET INTERFACE POLLING INTERVAL
.FI
.IF    .CNPF
.ELSE
       MOV  CMPSN,PFNTE      COPY STMTS COMPILED COUNT IN CASE
       MOV  KVPFL,PFDMP      START PROFILING IF &PROFILE SET
       JSR  SYSTM            TIME YET AGAIN
       STI  PFSTM
.FI
       JSR  STGCC            COMPUTE STMGO COUNTDOWN COUNTERS
       BRI  (XR)             START XEQ WITH FIRST STATEMENT
.IF    .CERA
INIX2  ZER  WA               SET ABEND VALUE TO ZERO
.ELSE
INIX2  JSR  PRTNL            PRINT A BLANK LINE
       MOV  =ENCM5,XR        POINT TO /EXECUTION SUPPRESSED/
       JSR  PRTST            PRINT STRING
       JSR  PRTNL            OUTPUT LINE
       ZER  WA               SET ABEND VALUE TO ZERO
.FI
       MOV  =NINI9,WB        SET SPECIAL CODE VALUE
       ZER  XL               NO FCB CHAIN
       JSR  SYSEJ            END OF JOB, EXIT TO SYSTEM
       ENP                   END PROCEDURE START
RSTRT  PRC  E,0              ENTRY POINT
       MOV  STBAS,XS         DISCARD RETURN
       ZER  XL               CLEAR XL
       BRN  INIY0            RESUME EXECUTION
       ENP                   END PROCEDURE RSTRT

       TTL  S P I T B O L -- SNOBOL4 OPERATOR ROUTINES
O_ADD  ENT                   ENTRY POINT
       JSR  ARITH            FETCH ARITHMETIC OPERANDS
       ERR  001,Addition left operand is not numeric
       ERR  002,Addition right operand is not numeric
.IF    .CNRA
.ELSE
       PPM  OADD1            JUMP IF REAL OPERANDS
.FI
       ADI  ICVAL(XL)        ADD RIGHT OPERAND TO LEFT
       INO  EXINT            RETURN INTEGER IF NO OVERFLOW
       ERB  003,Addition caused integer overflow
.IF    .CNRA
.ELSE
OADD1  ADR  RCVAL(XL)        ADD RIGHT OPERAND TO LEFT
       RNO  EXREA            RETURN REAL IF NO OVERFLOW
       ERB  261,Addition caused real overflow
.FI
O_AFF  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD OPERAND
       JSR  GTNUM            CONVERT TO NUMERIC
       ERR  004,Affirmation operand is not numeric
       MOV  XR,-(XS)         RESULT IF CONVERTED TO NUMERIC
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_ALT  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD RIGHT OPERAND
       JSR  GTPAT            CONVERT TO PATTERN
       ERR  005,Alternation right operand is not pattern
OALT1  MOV  =P_ALT,WB        SET PCODE FOR ALTERNATIVE NODE
       JSR  PBILD            BUILD ALTERNATIVE NODE
       MOV  XR,XL            SAVE ADDRESS OF ALTERNATIVE NODE
       MOV  (XS)+,XR         LOAD LEFT OPERAND
       JSR  GTPAT            CONVERT TO PATTERN
       ERR  006,Alternation left operand is not pattern
       BEQ  XR,=P_ALT,OALT2  JUMP IF LEFT ARG IS ALTERNATION
       MOV  XR,PTHEN(XL)     SET LEFT OPERAND AS SUCCESSOR
       MOV  XL,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
OALT2  MOV  PARM1(XR),PTHEN(XL) BUILD THE (B / C) NODE
       MOV  PTHEN(XR),-(XS)  SET A AS NEW LEFT ARG
       MOV  XL,XR            SET (B / C) AS NEW RIGHT ARG
       BRN  OALT1            MERGE BACK TO BUILD A / (B / C)
O_AMN  ENT                   ENTRY POINT
       LCW  XR               LOAD NUMBER OF SUBSCRIPTS
       MOV  XR,WB            SET FLAG FOR BY NAME
       BRN  ARREF            JUMP TO ARRAY REFERENCE ROUTINE
O_AMV  ENT                   ENTRY POINT
       LCW  XR               LOAD NUMBER OF SUBSCRIPTS
       ZER  WB               SET FLAG FOR BY VALUE
       BRN  ARREF            JUMP TO ARRAY REFERENCE ROUTINE
O_AON  ENT                   ENTRY POINT
       MOV  (XS),XR          LOAD SUBSCRIPT VALUE
       MOV  NUM01(XS),XL     LOAD ARRAY VALUE
       MOV  (XL),WA          LOAD FIRST WORD OF ARRAY OPERAND
       BEQ  WA,=B_VCT,OAON2  JUMP IF VECTOR REFERENCE
       BEQ  WA,=B_TBT,OAON3  JUMP IF TABLE REFERENCE
OAON1  MOV  =NUM01,XR        SET NUMBER OF SUBSCRIPTS TO ONE
       MOV  XR,WB            SET FLAG FOR BY NAME
       BRN  ARREF            JUMP TO ARRAY REFERENCE ROUTINE
OAON2  BNE  (XR),=B_ICL,OAON1 USE LONG ROUTINE IF NOT INTEGER
       LDI  ICVAL(XR)        LOAD INTEGER SUBSCRIPT VALUE
       MFI  WA,EXFAL         COPY AS ADDRESS INT, FAIL IF OVFLO
       BZE  WA,EXFAL         FAIL IF ZERO
       ADD  =VCVLB,WA        COMPUTE OFFSET IN WORDS
       WTB  WA               CONVERT TO BYTES
       MOV  WA,(XS)          COMPLETE NAME ON STACK
       BLT  WA,VCLEN(XL),OAON4 EXIT IF SUBSCRIPT NOT TOO LARGE
       BRN  EXFAL            ELSE FAIL
OAON3  MNZ  WB               SET FLAG FOR NAME REFERENCE
       JSR  TFIND            LOCATE/CREATE TABLE ELEMENT
       PPM  EXFAL            FAIL IF ACCESS FAILS
       MOV  XL,NUM01(XS)     STORE NAME BASE ON STACK
       MOV  WA,(XS)          STORE NAME OFFSET ON STACK
OAON4  LCW  XR               RESULT ON STACK, GET CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_AOV  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD SUBSCRIPT VALUE
       MOV  (XS)+,XL         LOAD ARRAY VALUE
       MOV  (XL),WA          LOAD FIRST WORD OF ARRAY OPERAND
       BEQ  WA,=B_VCT,OAOV2  JUMP IF VECTOR REFERENCE
       BEQ  WA,=B_TBT,OAOV3  JUMP IF TABLE REFERENCE
OAOV1  MOV  XL,-(XS)         RESTACK ARRAY VALUE
       MOV  XR,-(XS)         RESTACK SUBSCRIPT
       MOV  =NUM01,XR        SET NUMBER OF SUBSCRIPTS TO ONE
       ZER  WB               SET FLAG FOR VALUE CALL
       BRN  ARREF            JUMP TO ARRAY REFERENCE ROUTINE
OAOV2  BNE  (XR),=B_ICL,OAOV1 USE LONG ROUTINE IF NOT INTEGER
       LDI  ICVAL(XR)        LOAD INTEGER SUBSCRIPT VALUE
       MFI  WA,EXFAL         MOVE AS ONE WORD INT, FAIL IF OVFLO
       BZE  WA,EXFAL         FAIL IF ZERO
       ADD  =VCVLB,WA        COMPUTE OFFSET IN WORDS
       WTB  WA               CONVERT TO BYTES
       BGE  WA,VCLEN(XL),EXFAL FAIL IF SUBSCRIPT TOO LARGE
       JSR  ACESS            ACCESS VALUE
       PPM  EXFAL            FAIL IF ACCESS FAILS
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
OAOV3  ZER  WB               SET FLAG FOR VALUE REFERENCE
       JSR  TFIND            CALL TABLE SEARCH ROUTINE
       PPM  EXFAL            FAIL IF ACCESS FAILS
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_ASS  ENT                   ENTRY POINT
OASS0  MOV  (XS)+,WB         LOAD VALUE TO BE ASSIGNED
       MOV  (XS)+,WA         LOAD NAME OFFSET
       MOV  (XS),XL          LOAD NAME BASE
       MOV  WB,(XS)          STORE ASSIGNED VALUE AS RESULT
       JSR  ASIGN            PERFORM ASSIGNMENT
       PPM  EXFAL            FAIL IF ASSIGNMENT FAILS
       LCW  XR               RESULT ON STACK, GET CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_CER  ENT                   ENTRY POINT
       ERB  007,Compilation error encountered during execution
O_CAS  ENT                   ENTRY POINT
       MOV  (XS)+,WC         LOAD NAME OFFSET (PARM2)
       MOV  (XS)+,XR         LOAD NAME BASE (PARM1)
       MOV  =P_CAS,WB        SET PCODE FOR CURSOR ASSIGNMENT
       JSR  PBILD            BUILD NODE
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_CNC  ENT                   ENTRY POINT
       MOV  (XS),XR          LOAD RIGHT ARGUMENT
       BEQ  XR,=NULLS,OCNC3  JUMP IF RIGHT ARG IS NULL
       MOV  1(XS),XL         LOAD LEFT ARGUMENT
       BEQ  XL,=NULLS,OCNC4  JUMP IF LEFT ARGUMENT IS NULL
       MOV  =B_SCL,WA        GET CONSTANT TO TEST FOR STRING
       BNE  WA,(XL),OCNC2    JUMP IF LEFT ARG NOT A STRING
       BNE  WA,(XR),OCNC2    JUMP IF RIGHT ARG NOT A STRING
OCNC1  MOV  SCLEN(XL),WA     LOAD LEFT ARGUMENT LENGTH
       ADD  SCLEN(XR),WA     COMPUTE RESULT LENGTH
       JSR  ALOCS            ALLOCATE SCBLK FOR RESULT
       MOV  XR,1(XS)         STORE RESULT PTR OVER LEFT ARGUMENT
       PSC  XR               PREPARE TO STORE CHARS OF RESULT
       MOV  SCLEN(XL),WA     GET NUMBER OF CHARS IN LEFT ARG
       PLC  XL               PREPARE TO LOAD LEFT ARG CHARS
       MVC                   MOVE CHARACTERS OF LEFT ARGUMENT
       MOV  (XS)+,XL         LOAD RIGHT ARG POINTER, POP STACK
       MOV  SCLEN(XL),WA     LOAD NUMBER OF CHARS IN RIGHT ARG
       PLC  XL               PREPARE TO LOAD RIGHT ARG CHARS
       MVC                   MOVE CHARACTERS OF RIGHT ARGUMENT
       ZER  XL               CLEAR GARBAGE VALUE IN XL
       LCW  XR               RESULT ON STACK, GET CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
OCNC2  JSR  GTSTG            CONVERT RIGHT ARG TO STRING
       PPM  OCNC5            JUMP IF RIGHT ARG IS NOT STRING
       MOV  XR,XL            SAVE RIGHT ARG PTR
       JSR  GTSTG            CONVERT LEFT ARG TO STRING
       PPM  OCNC6            JUMP IF LEFT ARG IS NOT A STRING
       MOV  XR,-(XS)         STACK LEFT ARGUMENT
       MOV  XL,-(XS)         STACK RIGHT ARGUMENT
       MOV  XR,XL            MOVE LEFT ARG TO PROPER REG
       MOV  (XS),XR          MOVE RIGHT ARG TO PROPER REG
       BRN  OCNC1            MERGE BACK TO CONCATENATE STRINGS
OCNC3  ICA  XS               REMOVE RIGHT ARG FROM STACK
       LCW  XR               LEFT ARGUMENT ON STACK
       BRI  (XR)             EXECUTE NEXT CODE WORD
OCNC4  ICA  XS               UNSTACK ONE ARGUMENT
       MOV  XR,(XS)          STORE RIGHT ARGUMENT
       LCW  XR               RESULT ON STACK, GET CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
OCNC5  MOV  XR,XL            MOVE RIGHT ARGUMENT PTR
       MOV  (XS)+,XR         LOAD LEFT ARG POINTER
OCNC6  JSR  GTPAT            CONVERT LEFT ARG TO PATTERN
       ERR  008,Concatenation left operand is not a string or pattern
       MOV  XR,-(XS)         SAVE RESULT ON STACK
       MOV  XL,XR            POINT TO RIGHT OPERAND
       JSR  GTPAT            CONVERT TO PATTERN
       ERR  009,Concatenation right operand is not a string or pattern
       MOV  XR,XL            MOVE FOR PCONC
       MOV  (XS)+,XR         RELOAD LEFT OPERAND PTR
       JSR  PCONC            CONCATENATE PATTERNS
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_COM  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD OPERAND
       MOV  (XR),WA          LOAD TYPE WORD
OCOM1  BEQ  WA,=B_ICL,OCOM2  JUMP IF INTEGER
.IF    .CNRA
.ELSE
       BEQ  WA,=B_RCL,OCOM3  JUMP IF REAL
.FI
       JSR  GTNUM            ELSE CONVERT TO NUMERIC
       ERR  010,Negation operand is not numeric
       BRN  OCOM1            BACK TO CHECK CASES
OCOM2  LDI  ICVAL(XR)        LOAD INTEGER VALUE
       NGI                   NEGATE
       INO  EXINT            RETURN INTEGER IF NO OVERFLOW
       ERB  011,Negation caused integer overflow
.IF    .CNRA
.ELSE
OCOM3  LDR  RCVAL(XR)        LOAD REAL VALUE
       NGR                   NEGATE
       BRN  EXREA            RETURN REAL RESULT
.FI
O_DVD  ENT                   ENTRY POINT
       JSR  ARITH            FETCH ARITHMETIC OPERANDS
       ERR  012,Division left operand is not numeric
       ERR  013,Division right operand is not numeric
.IF    .CNRA
.ELSE
       PPM  ODVD2            JUMP IF REAL OPERANDS
.FI
       DVI  ICVAL(XL)        DIVIDE LEFT OPERAND BY RIGHT
       INO  EXINT            RESULT OK IF NO OVERFLOW
       ERB  014,Division caused integer overflow
.IF    .CNRA
.ELSE
ODVD2  DVR  RCVAL(XL)        DIVIDE LEFT OPERAND BY RIGHT
       RNO  EXREA            RETURN REAL IF NO OVERFLOW
       ERB  262,Division caused real overflow
.FI
O_EXP  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD EXPONENT
       JSR  GTNUM            CONVERT TO NUMBER
       ERR  015,Exponentiation right operand is not numeric
       MOV  XR,XL            MOVE EXPONENT TO XL
       MOV  (XS)+,XR         LOAD BASE
       JSR  GTNUM            CONVERT TO NUMERIC
       ERR  016,Exponentiation left operand is not numeric
.IF    .CNRA
.ELSE
       BEQ  (XL),=B_RCL,OEXP7 JUMP IF REAL EXPONENT
.FI
       LDI  ICVAL(XL)        LOAD EXPONENT
       ILT  OEX12            JUMP IF NEGATIVE EXPONENT
.IF    .CNRA
.ELSE
       BEQ  WA,=B_RCL,OEXP3  JUMP IF BASE IS REAL
.FI
       MFI  WA,OEXP2         CONVERT EXPONENT TO 1 WORD INTEGER
       LCT  WA,WA            SET LOOP COUNTER
       LDI  ICVAL(XR)        LOAD BASE AS INITIAL VALUE
       BNZ  WA,OEXP1         JUMP INTO LOOP IF NON-ZERO EXPONENT
       IEQ  OEXP4            ERROR IF 0**0
       LDI  INTV1            NONZERO**0
       BRN  EXINT            GIVE ONE AS RESULT FOR NONZERO**0
OEX13  MLI  ICVAL(XR)        MULTIPLY BY BASE
       IOV  OEXP2            JUMP IF OVERFLOW
OEXP1  BCT  WA,OEX13         LOOP IF MORE TO GO
       BRN  EXINT            ELSE RETURN INTEGER RESULT
OEXP2  ERB  017,Exponentiation caused integer overflow
.IF    .CNRA
.ELSE
OEXP3  MFI  WA,OEXP6         CONVERT EXPONENT TO ONE WORD
       LCT  WA,WA            SET LOOP COUNTER
       LDR  RCVAL(XR)        LOAD BASE AS INITIAL VALUE
       BNZ  WA,OEXP5         JUMP INTO LOOP IF NON-ZERO EXPONENT
       REQ  OEXP4            ERROR IF 0.0**0
       LDR  REAV1            NONZERO**0
       BRN  EXREA            RETURN 1.0 IF NONZERO**ZERO
.FI
OEXP4  ERB  018,Exponentiation result is undefined
.IF    .CNRA
.ELSE
OEX14  MLR  RCVAL(XR)        MULTIPLY BY BASE
       ROV  OEXP6            JUMP IF OVERFLOW
OEXP5  BCT  WA,OEX14         LOOP TILL COMPUTATION COMPLETE
       BRN  EXREA            THEN RETURN REAL RESULT
OEXP6  ERB  266,Exponentiation caused real overflow
.IF    .CMTH
OEXP7  BEQ  (XR),=B_RCL,OEXP8 JUMP IF BASE REAL
       LDI  ICVAL(XR)        LOAD INTEGER BASE
       ITR                   CONVERT TO REAL
       JSR  RCBLD            CREATE REAL IN (XR)
OEXP8  ZER  WB               SET POSITIVE RESULT FLAG
       LDR  RCVAL(XR)        LOAD BASE TO RA
       RNE  OEXP9            JUMP IF BASE NON-ZERO
       LDR  RCVAL(XL)        BASE IS ZERO.  CHECK EXPONENT
       REQ  OEXP4            JUMP IF 0.0 ** 0.0
       LDR  REAV0            0.0 TO NON-ZERO EXPONENT YIELDS 0.0
       BRN  EXREA            RETURN ZERO RESULT
OEXP9  RGT  OEX10            JUMP IF BASE GT 0.0
       NGR                   MAKE BASE POSITIVE
       JSR  RCBLD            CREATE POSITIVE BASE IN (XR)
       LDR  RCVAL(XL)        EXAMINE EXPONENT
       CHP                   CHOP TO INTEGRAL VALUE
       RTI  OEXP6            CONVERT TO INTEGER, BR IF TOO LARGE
       SBR  RCVAL(XL)        CHOP(EXPONENT) - EXPONENT
       RNE  OEX11            NON-INTEGRAL POWER WITH NEG BASE
       MFI  WB               RECORD EVEN/ODD EXPONENT
       ANB  BITS1,WB         ODD EXPONENT YIELDS NEGATIVE RESULT
       LDR  RCVAL(XR)        RESTORE BASE TO RA
OEX10  LNF                   LOG OF BASE
       ROV  OEXP6            TOO LARGE
       MLR  RCVAL(XL)        TIMES EXPONENT
       ROV  OEXP6            TOO LARGE
       ETX                   E ** (EXPONENT * LN(BASE))
       ROV  OEXP6            TOO LARGE
       BZE  WB,EXREA         IF NO SIGN FIXUP REQUIRED
       NGR                   NEGATIVE RESULT NEEDED
       BRN  EXREA
OEX11  ERB  311,Exponentiation of negative base to non-integral power
.ELSE
OEXP7  ERB  267,Exponentiation right operand is real not integer
.FI
.FI
.IF    .CMTH
OEX12  MOV  XR,-(XS)         STACK BASE
       ITR                   CONVERT TO REAL EXPONENT
       JSR  RCBLD            REAL NEGATIVE EXPONENT IN (XR)
       MOV  XR,XL            PUT EXPONENT IN XL
       MOV  (XS)+,XR         RESTORE BASE VALUE
       BRN  OEXP7            PROCESS REAL EXPONENT
.ELSE
OEX12  ERB  019,Exponentiation right operand is negative
.FI
O_FEX  ENT                   ENTRY POINT
       BRN  EVLX6            JUMP TO FAILURE LOC IN EVALX
O_FIF  ENT                   ENTRY POINT
       ERB  020,Goto evaluation failure
O_FNC  ENT                   ENTRY POINT
       LCW  WA               LOAD NUMBER OF ARGUMENTS
       LCW  XR               LOAD FUNCTION VRBLK POINTER
       MOV  VRFNC(XR),XL     LOAD FUNCTION POINTER
       BNE  WA,FARGS(XL),CFUNC USE CENTRAL ROUTINE IF WRONG NUM
       BRI  (XL)             JUMP TO FUNCTION IF ARG COUNT OK
O_FNE  ENT                   ENTRY POINT
       LCW  WA               GET NEXT CODE WORD
       BNE  WA,=ORNM_,OFNE1  FAIL IF NOT EVALUATING EXPRESSION
       BZE  NUM02(XS),EVLX3  OK IF EXPR. WAS WANTED BY VALUE
OFNE1  ERB  021,Function called by name returned a value
O_FNS  ENT                   ENTRY POINT
       LCW  XR               LOAD FUNCTION VRBLK POINTER
       MOV  =NUM01,WA        SET NUMBER OF ARGUMENTS TO ONE
       MOV  VRFNC(XR),XL     LOAD FUNCTION POINTER
       BNE  WA,FARGS(XL),CFUNC USE CENTRAL ROUTINE IF WRONG NUM
       BRI  (XL)             JUMP TO FUNCTION IF ARG COUNT OK
O_FUN  ENT                   ENTRY POINT
       ERB  022,Undefined function called
O_GOC  ENT                   ENTRY POINT
       MOV  NUM01(XS),XR     LOAD NAME BASE POINTER
       BHI  XR,STATE,OGOC1   JUMP IF NOT NATURAL VARIABLE
       ADD  *VRTRA,XR        ELSE POINT TO VRTRA FIELD
       BRI  (XR)             AND JUMP THROUGH IT
OGOC1  ERB  023,Goto operand is not a natural variable
O_GOD  ENT                   ENTRY POINT
       MOV  (XS),XR          LOAD OPERAND
       MOV  (XR),WA          LOAD FIRST WORD
       BEQ  WA,=B_CDS,BCDS0  JUMP IF CODE BLOCK TO CODE ROUTINE
       BEQ  WA,=B_CDC,BCDC0  JUMP IF CODE BLOCK TO CODE ROUTINE
       ERB  024,Goto operand in direct goto is not code
O_GOF  ENT                   ENTRY POINT
       MOV  FLPTR,XR         POINT TO FAIL OFFSET ON STACK
       ICA  (XR)             POINT FAILURE TO O_FIF WORD
       ICP                   POINT TO NEXT CODE WORD
       LCW  XR               FETCH NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_IMA  ENT                   ENTRY POINT
       MOV  =P_IMC,WB        SET PCODE FOR LAST NODE
       MOV  (XS)+,WC         POP NAME OFFSET (PARM2)
       MOV  (XS)+,XR         POP NAME BASE (PARM1)
       JSR  PBILD            BUILD P_IMC NODE
       MOV  XR,XL            SAVE PTR TO NODE
       MOV  (XS),XR          LOAD LEFT ARGUMENT
       JSR  GTPAT            CONVERT TO PATTERN
       ERR  025,Immediate assignment left operand is not pattern
       MOV  XR,(XS)          SAVE PTR TO LEFT OPERAND PATTERN
       MOV  =P_IMA,WB        SET PCODE FOR FIRST NODE
       JSR  PBILD            BUILD P_IMA NODE
       MOV  (XS)+,PTHEN(XR)  SET LEFT OPERAND AS P_IMA SUCCESSOR
       JSR  PCONC            CONCATENATE TO FORM FINAL PATTERN
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_INN  ENT                   ENTRY POINT
       MNZ  WB               SET FLAG FOR RESULT BY NAME
       BRN  INDIR            JUMP TO COMMON ROUTINE
O_INT  ENT                   ENTRY POINT
       MOV  =NULLS,(XS)      REPLACE OPERAND WITH NULL
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_INV  ENT                   ENTRY POINT
       ZER  WB               SET FLAG FOR BY VALUE
       BRN  INDIR            JUMP TO COMMON ROUTINE
O_KWN  ENT                   ENTRY POINT
       JSR  KWNAM            GET KEYWORD NAME
       BRN  EXNAM            EXIT WITH RESULT NAME
O_KWV  ENT                   ENTRY POINT
       JSR  KWNAM            GET KEYWORD NAME
       MOV  XR,DNAMP         DELETE KVBLK
       JSR  ACESS            ACCESS VALUE
       PPM  EXNUL            DUMMY (UNUSED) FAILURE RETURN
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_LEX  ENT                   ENTRY POINT
       MOV  *EVSI_,WA        SET SIZE OF EVBLK
       JSR  ALLOC            ALLOCATE SPACE FOR EVBLK
       MOV  =B_EVT,(XR)      SET TYPE WORD
       MOV  =TRBEV,EVVAR(XR) SET DUMMY TRBLK POINTER
       LCW  WA               LOAD EXBLK POINTER
       MOV  WA,EVEXP(XR)     SET EXBLK POINTER
       MOV  XR,XL            MOVE NAME BASE TO PROPER REG
       MOV  *EVVAR,WA        SET NAME OFFSET = ZERO
       BRN  EXNAM            EXIT WITH NAME IN (XL,WA)
O_LPT  ENT                   ENTRY POINT
       LCW  XR               LOAD PATTERN POINTER
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_LVN  ENT                   ENTRY POINT
       LCW  WA               LOAD VRBLK POINTER
       MOV  WA,-(XS)         STACK VRBLK PTR (NAME BASE)
       MOV  *VRVAL,-(XS)     STACK NAME OFFSET
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_MLT  ENT                   ENTRY POINT
       JSR  ARITH            FETCH ARITHMETIC OPERANDS
       ERR  026,Multiplication left operand is not numeric
       ERR  027,Multiplication right operand is not numeric
.IF    .CNRA
.ELSE
       PPM  OMLT1            JUMP IF REAL OPERANDS
.FI
       MLI  ICVAL(XL)        MULTIPLY LEFT OPERAND BY RIGHT
       INO  EXINT            RETURN INTEGER IF NO OVERFLOW
       ERB  028,Multiplication caused integer overflow
.IF    .CNRA
.ELSE
OMLT1  MLR  RCVAL(XL)        MULTIPLY LEFT OPERAND BY RIGHT
       RNO  EXREA            RETURN REAL IF NO OVERFLOW
       ERB  263,Multiplication caused real overflow
.FI
O_NAM  ENT                   ENTRY POINT
       MOV  *NMSI_,WA        SET LENGTH OF NMBLK
       JSR  ALLOC            ALLOCATE NMBLK
       MOV  =B_NML,(XR)      SET NAME BLOCK CODE
       MOV  (XS)+,NMOFS(XR)  SET NAME OFFSET FROM OPERAND
       MOV  (XS)+,NMBAS(XR)  SET NAME BASE FROM OPERAND
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_NTA  ENT                   ENTRY POINT
       LCW  WA               LOAD NEW FAILURE OFFSET
       MOV  FLPTR,-(XS)      STACK OLD FAILURE POINTER
       MOV  WA,-(XS)         STACK NEW FAILURE OFFSET
       MOV  XS,FLPTR         SET NEW FAILURE POINTER
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_NTB  ENT                   ENTRY POINT
       MOV  NUM02(XS),FLPTR  RESTORE OLD FAILURE POINTER
       BRN  EXFAL            AND FAIL
O_NTC  ENT                   ENTRY POINT
       ICA  XS               POP FAILURE OFFSET
       MOV  (XS)+,FLPTR      RESTORE OLD FAILURE POINTER
       BRN  EXNUL            EXIT GIVING NULL RESULT
O_OUN  ENT                   ENTRY POINT
       ERB  029,Undefined operator referenced
O_PAS  ENT                   ENTRY POINT
       MOV  =P_PAC,WB        LOAD PCODE FOR P_PAC NODE
       MOV  (XS)+,WC         LOAD NAME OFFSET (PARM2)
       MOV  (XS)+,XR         LOAD NAME BASE (PARM1)
       JSR  PBILD            BUILD P_PAC NODE
       MOV  XR,XL            SAVE PTR TO NODE
       MOV  (XS),XR          LOAD LEFT OPERAND
       JSR  GTPAT            CONVERT TO PATTERN
       ERR  030,Pattern assignment left operand is not pattern
       MOV  XR,(XS)          SAVE PTR TO LEFT OPERAND PATTERN
       MOV  =P_PAA,WB        SET PCODE FOR P_PAA NODE
       JSR  PBILD            BUILD P_PAA NODE
       MOV  (XS)+,PTHEN(XR)  SET LEFT OPERAND AS P_PAA SUCCESSOR
       JSR  PCONC            CONCATENATE TO FORM FINAL PATTERN
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
O_PMN  ENT                   ENTRY POINT
       ZER  WB               SET TYPE CODE FOR MATCH BY NAME
       BRN  MATCH            JUMP TO ROUTINE TO START MATCH
O_PMS  ENT                   ENTRY POINT
       MOV  =NUM02,WB        SET FLAG FOR STATEMENT TO MATCH
       BRN  MATCH            JUMP TO ROUTINE TO START MATCH
O_PMV  ENT                   ENTRY POINT
       MOV  =NUM01,WB        SET TYPE CODE FOR VALUE MATCH
       BRN  MATCH            JUMP TO ROUTINE TO START MATCH
O_POP  ENT                   ENTRY POINT
       ICA  XS               POP TOP STACK ENTRY
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_STP  ENT                   ENTRY POINT
       BRN  LEND0            JUMP TO END CIRCUIT
O_RNM  ENT                   ENTRY POINT
       BRN  EVLX4            RETURN TO EVALX PROCEDURE
O_RPL  ENT                   ENTRY POINT
       JSR  GTSTG            CONVERT REPLACEMENT VAL TO STRING
       ERR  031,Pattern replacement right operand is not a string
       MOV  (XS),XL          LOAD SUBJECT STRING POINTER
.IF    .CNBF
.ELSE
       BEQ  (XL),=B_BCT,ORPL4 BRANCH IF BUFFER ASSIGNMENT
.FI
       ADD  SCLEN(XL),WA     ADD SUBJECT STRING LENGTH
       ADD  NUM02(XS),WA     ADD STARTING CURSOR
       SUB  NUM01(XS),WA     MINUS FINAL CURSOR = TOTAL LENGTH
       BZE  WA,ORPL3         JUMP IF RESULT IS NULL
       MOV  XR,-(XS)         RESTACK REPLACEMENT STRING
       JSR  ALOCS            ALLOCATE SCBLK FOR RESULT
       MOV  NUM03(XS),WA     GET INITIAL CURSOR (PART 1 LEN)
       MOV  XR,NUM03(XS)     STACK RESULT POINTER
       PSC  XR               POINT TO CHARACTERS OF RESULT
       BZE  WA,ORPL1         JUMP IF FIRST PART IS NULL
       MOV  NUM01(XS),XL     ELSE POINT TO SUBJECT STRING
       PLC  XL               POINT TO SUBJECT STRING CHARS
       MVC                   MOVE FIRST PART TO RESULT
ORPL1  MOV  (XS)+,XL         LOAD REPLACEMENT STRING, POP
       MOV  SCLEN(XL),WA     LOAD LENGTH
       BZE  WA,ORPL2         JUMP IF NULL REPLACEMENT
       PLC  XL               ELSE POINT TO CHARS OF REPLACEMENT
       MVC                   MOVE IN CHARS (PART 2)
ORPL2  MOV  (XS)+,XL         LOAD SUBJECT STRING POINTER, POP
       MOV  (XS)+,WC         LOAD FINAL CURSOR, POP
       MOV  SCLEN(XL),WA     LOAD SUBJECT STRING LENGTH
       SUB  WC,WA            MINUS FINAL CURSOR = PART 3 LENGTH
       BZE  WA,OASS0         JUMP TO ASSIGN IF PART 3 IS NULL
       PLC  XL,WC            ELSE POINT TO LAST PART OF STRING
       MVC                   MOVE PART 3 TO RESULT
       BRN  OASS0            JUMP TO PERFORM ASSIGNMENT
ORPL3  ADD  *NUM02,XS        POP SUBJECT STR PTR, FINAL CURSOR
       MOV  =NULLS,(XS)      SET NULL RESULT
       BRN  OASS0            JUMP TO ASSIGN NULL VALUE
.IF    .CNBF
.ELSE
ORPL4  MOV  XR,XL            COPY SCBLK REPLACEMENT PTR
       MOV  (XS)+,XR         UNSTACK BCBLK PTR
       MOV  (XS)+,WB         GET FINAL CURSOR VALUE
       MOV  (XS)+,WA         GET INITIAL CURSOR
       SUB  WA,WB            GET LENGTH IN WB
       ADD  *NUM01,XS        GET RID OF NAME OFFSET
       MOV  XR,(XS)          STORE BUFFER RESULT OVER NAME BASE
       JSR  INSBF            INSERT SUBSTRING
       PPM                   CONVERT FAIL IMPOSSIBLE
       PPM  EXFAL            FAIL IF INSERT FAILS
       LCW  XR               RESULT ON STACK, GET CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
.FI
O_RVL  ENT                   ENTRY POINT
       BRN  EVLX3            RETURN TO EVALX PROCEDURE
O_SLA  ENT                   ENTRY POINT
       LCW  WA               LOAD NEW FAILURE OFFSET
       MOV  FLPTR,-(XS)      STACK OLD FAILURE POINTER
       MOV  WA,-(XS)         STACK NEW FAILURE OFFSET
       MOV  XS,FLPTR         SET NEW FAILURE POINTER
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_SLB  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD RESULT
       ICA  XS               POP FAIL OFFSET
       MOV  (XS),FLPTR       RESTORE OLD FAILURE POINTER
       MOV  XR,(XS)          RESTACK RESULT
       LCW  WA               LOAD NEW CODE OFFSET
       ADD  R_COD,WA         POINT TO ABSOLUTE CODE LOCATION
       LCP  WA               SET NEW CODE POINTER
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_SLC  ENT                   ENTRY POINT
       LCW  WA               LOAD NEW FAIL OFFSET
       MOV  WA,(XS)          STORE NEW FAIL OFFSET
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_SLD  ENT                   ENTRY POINT
       ICA  XS               POP FAILURE OFFSET
       MOV  (XS)+,FLPTR      RESTORE OLD FAILURE POINTER
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
O_SUB  ENT                   ENTRY POINT
       JSR  ARITH            FETCH ARITHMETIC OPERANDS
       ERR  032,Subtraction left operand is not numeric
       ERR  033,Subtraction right operand is not numeric
.IF    .CNRA
.ELSE
       PPM  OSUB1            JUMP IF REAL OPERANDS
.FI
       SBI  ICVAL(XL)        SUBTRACT RIGHT OPERAND FROM LEFT
       INO  EXINT            RETURN INTEGER IF NO OVERFLOW
       ERB  034,Subtraction caused integer overflow
.IF    .CNRA
.ELSE
OSUB1  SBR  RCVAL(XL)        SUBTRACT RIGHT OPERAND FROM LEFT
       RNO  EXREA            RETURN REAL IF NO OVERFLOW
       ERB  264,Subtraction caused real overflow
.FI
O_TXR  ENT                   ENTRY POINT
       BRN  TRXQ1            JUMP INTO TRXEQ PROCEDURE
O_UNF  ENT                   ENTRY POINT
       ERB  035,Unexpected failure in -NOFAIL mode
       TTL  S P I T B O L -- BLOCK ACTION ROUTINES
B_AAA  ENT  BL__I            ENTRY POINT OF FIRST BLOCK ROUTINE
B_EXL  ENT  BL_EX            ENTRY POINT (EXBLK)
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
B_SEL  ENT  BL_SE            ENTRY POINT (SEBLK)
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
B_E__  ENT  BL__I            ENTRY POINT
B_TRT  ENT  BL_TR            ENTRY POINT (TRBLK)
B_T__  ENT  BL__I            END OF TRBLK,SEBLK,EXBLK ENTRIES
B_ART  ENT  BL_AR            ENTRY POINT (ARBLK)
B_BCT  ENT  BL_BC            ENTRY POINT (BCBLK)
B_BFT  ENT  BL_BF            ENTRY POINT (BFBLK)
B_CCT  ENT  BL_CC            ENTRY POINT (CCBLK)
B_CDC  ENT  BL_CD            ENTRY POINT (CDBLK)
BCDC0  MOV  FLPTR,XS         POP GARBAGE OFF STACK
       MOV  CDFAL(XR),(XS)   SET FAILURE OFFSET
       BRN  STMGO            ENTER STMT
B_CDS  ENT  BL_CD            ENTRY POINT (CDBLK)
BCDS0  MOV  FLPTR,XS         POP GARBAGE OFF STACK
       MOV  *CDFAL,(XS)      SET FAILURE OFFSET
       BRN  STMGO            ENTER STMT
B_CMT  ENT  BL_CM            ENTRY POINT (CMBLK)
B_CTT  ENT  BL_CT            ENTRY POINT (CTBLK)
B_DFC  ENT  BL_DF            ENTRY POINT
       MOV  DFPDL(XL),WA     LOAD LENGTH OF PDBLK
       JSR  ALLOC            ALLOCATE PDBLK
       MOV  =B_PDT,(XR)      STORE TYPE WORD
       MOV  XL,PDDFP(XR)     STORE DFBLK POINTER
       MOV  XR,WC            SAVE POINTER TO PDBLK
       ADD  WA,XR            POINT PAST PDBLK
       LCT  WA,FARGS(XL)     SET TO COUNT FIELDS
BDFC1  MOV  (XS)+,-(XR)      MOVE A FIELD VALUE
       BCT  WA,BDFC1         LOOP TILL ALL MOVED
       MOV  WC,XR            RECALL POINTER TO PDBLK
       BRN  EXSID            EXIT SETTING ID FIELD
B_EFC  ENT  BL_EF            ENTRY POINT (EFBLK)
.IF    .CNLD
.ELSE
       MOV  FARGS(XL),WC     LOAD NUMBER OF ARGUMENTS
       WTB  WC               CONVERT TO OFFSET
       MOV  XL,-(XS)         SAVE POINTER TO EFBLK
       MOV  XS,XT            COPY POINTER TO ARGUMENTS
BEFC1  ICA  XT               POINT TO NEXT ENTRY
       MOV  (XS),XR          LOAD POINTER TO EFBLK
       DCA  WC               DECREMENT EFTAR OFFSET
       ADD  WC,XR            POINT TO NEXT EFTAR ENTRY
       MOV  EFTAR(XR),XR     LOAD EFTAR ENTRY
.IF    .CNRA
.IF    .CNLF
       BSW  XR,4             SWITCH ON TYPE
.ELSE
       BSW  XR,3             SWITCH ON TYPE
.FI
.ELSE
.IF    .CNLF
       BSW  XR,5             SWITCH ON TYPE
.ELSE
       BSW  XR,4             SWITCH ON TYPE
.FI
.FI
       IFF  0,BEFC7          NO CONVERSION NEEDED
       IFF  1,BEFC2          STRING
       IFF  2,BEFC3          INTEGER
.IF    .CNRA
.IF    .CNLF
       IFF  3,BEFF1          FILE
.FI
.ELSE
       IFF  3,BEFC4          REAL
.IF    .CNLF
       IFF  4,BEFF1          FILE
.FI
.FI
       ESW                   END OF SWITCH ON TYPE
.IF    .CNLF
BEFF1  MOV  XT,-(XS)         SAVE ENTRY POINTER
       MOV  WC,BEFOF         SAVE OFFSET
       MOV  (XT),-(XS)       STACK ARG POINTER
       JSR  IOFCB            CONVERT TO FCB
       ERR  298,External function argument is not file
       ERR  298,External function argument is not file
       ERR  298,External function argument is not file
       MOV  WA,XR            POINT TO FCB
       MOV  (XS)+,XT         RELOAD ENTRY POINTER
       BRN  BEFC5            JUMP TO MERGE
.FI
BEFC2  MOV  (XT),-(XS)       STACK ARG PTR
       JSR  GTSTG            CONVERT ARGUMENT TO STRING
       ERR  039,External function argument is not a string
       BRN  BEFC6            JUMP TO MERGE
BEFC3  MOV  (XT),XR          LOAD NEXT ARGUMENT
       MOV  WC,BEFOF         SAVE OFFSET
       JSR  GTINT            CONVERT TO INTEGER
       ERR  040,External function argument is not integer
.IF    .CNRA
.ELSE
       BRN  BEFC5            MERGE WITH REAL CASE
BEFC4  MOV  (XT),XR          LOAD NEXT ARGUMENT
       MOV  WC,BEFOF         SAVE OFFSET
       JSR  GTREA            CONVERT TO REAL
       ERR  265,External function argument is not real
.FI
BEFC5  MOV  BEFOF,WC         RESTORE OFFSET
BEFC6  MOV  XR,(XT)          STORE CONVERTED RESULT
BEFC7  BNZ  WC,BEFC1         LOOP BACK IF MORE TO GO
       MOV  (XS)+,XL         RESTORE EFBLK POINTER
       MOV  FARGS(XL),WA     GET NUMBER OF ARGS
       JSR  SYSEX            CALL ROUTINE TO CALL EXTERNAL FNC
       PPM  EXFAL            FAIL IF FAILURE
       ERR  327,Calling external function - not found
       ERR  326,Calling external function - bad argument type
.IF    .CEXP
       WTB  WA               CONVERT NUMBER OF ARGS TO BYTES
       ADD  WA,XS            REMOVE ARGUMENTS FROM STACK
.FI
       MOV  EFRSL(XL),WB     GET RESULT TYPE ID
       BNZ  WB,BEFA8         BRANCH IF NOT UNCONVERTED
       BNE  (XR),=B_SCL,BEFC8 JUMP IF NOT A STRING
       BZE  SCLEN(XR),EXNUL  RETURN NULL IF NULL
BEFA8  BNE  WB,=NUM01,BEFC8  JUMP IF NOT A STRING
       BZE  SCLEN(XR),EXNUL  RETURN NULL IF NULL
BEFC8  BLT  XR,DNAMB,BEFC9   JUMP IF NOT IN DYNAMIC STORAGE
       BLE  XR,DNAMP,EXIXR   RETURN RESULT IF ALREADY DYNAMIC
BEFC9  MOV  (XR),WA          GET POSSIBLE TYPE WORD
       BZE  WB,BEF11         JUMP IF UNCONVERTED RESULT
       MOV  =B_SCL,WA        STRING
       BEQ  WB,=NUM01,BEF10  YES JUMP
       MOV  =B_ICL,WA        INTEGER
       BEQ  WB,=NUM02,BEF10  YES JUMP
.IF    .CNRA
.ELSE
       MOV  =B_RCL,WA        REAL
.FI
BEF10  MOV  WA,(XR)          STORED BEFORE COPYING TO DYNAMIC
BEF11  BEQ  (XR),=B_SCL,BEF12 BRANCH IF STRING RESULT
       JSR  BLKLN            GET LENGTH OF BLOCK
       MOV  XR,XL            COPY ADDRESS OF OLD BLOCK
       JSR  ALLOC            ALLOCATE DYNAMIC BLOCK SAME SIZE
       MOV  XR,-(XS)         SET POINTER TO NEW BLOCK AS RESULT
       MVW                   COPY OLD BLOCK TO DYNAMIC BLOCK
       ZER  XL               CLEAR GARBAGE VALUE
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
BEF12  MOV  XR,XL            SAVE SOURCE STRING POINTER
       MOV  SCLEN(XR),WA     FETCH STRING LENGTH
       BZE  WA,EXNUL         RETURN NULL STRING IF LENGTH ZERO
       JSR  ALOCS            ALLOCATE SPACE FOR STRING
       MOV  XR,-(XS)         SAVE AS RESULT POINTER
       PSC  XR               PREPARE TO STORE CHARS OF RESULT
       PLC  XL               POINT TO CHARS IN SOURCE STRING
       MOV  WC,WA            NUMBER OF CHARACTERS TO COPY
       MVC                   MOVE CHARACTERS TO RESULT STRING
       ZER  XL               CLEAR GARBAGE VALUE
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
.FI
B_EVT  ENT  BL_EV            ENTRY POINT (EVBLK)
B_FFC  ENT  BL_FF            ENTRY POINT (FFBLK)
       MOV  XL,XR            COPY FFBLK POINTER
       LCW  WC               LOAD NEXT CODE WORD
       MOV  (XS),XL          LOAD PDBLK POINTER
       BNE  (XL),=B_PDT,BFFC2 JUMP IF NOT PDBLK AT ALL
       MOV  PDDFP(XL),WA     LOAD DFBLK POINTER FROM PDBLK
BFFC1  BEQ  WA,FFDFP(XR),BFFC3 JUMP IF THIS IS THE CORRECT FFBLK
       MOV  FFNXT(XR),XR     ELSE LINK TO NEXT FFBLK ON CHAIN
       BNZ  XR,BFFC1         LOOP BACK IF ANOTHER ENTRY TO CHECK
BFFC2  ERB  041,FIELD function argument is wrong datatype
BFFC3  MOV  FFOFS(XR),WA     LOAD FIELD OFFSET
       BEQ  WC,=OFNE_,BFFC5  JUMP IF CALLED BY NAME
       ADD  WA,XL            ELSE POINT TO VALUE FIELD
       MOV  (XL),XR          LOAD VALUE
       BNE  (XR),=B_TRT,BFFC4 JUMP IF NOT TRAPPED
       SUB  WA,XL            ELSE RESTORE NAME BASE,OFFSET
       MOV  WC,(XS)          SAVE NEXT CODE WORD OVER PDBLK PTR
       JSR  ACESS            ACCESS VALUE
       PPM  EXFAL            FAIL IF ACCESS FAILS
       MOV  (XS),WC          RESTORE NEXT CODE WORD
BFFC4  MOV  XR,(XS)          STORE VALUE ON STACK (OVER PDBLK)
       MOV  WC,XR            COPY NEXT CODE WORD
       MOV  (XR),XL          LOAD ENTRY ADDRESS
       BRI  XL               JUMP TO ROUTINE FOR NEXT CODE WORD
BFFC5  MOV  WA,-(XS)         STORE NAME OFFSET (BASE IS SET)
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
B_ICL  ENT  BL_IC            ENTRY POINT (ICBLK)
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
B_KVT  ENT  BL_KV            ENTRY POINT (KVBLK)
B_NML  ENT  BL_NM            ENTRY POINT (NMBLK)
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
B_PDT  ENT  BL_PD            ENTRY POINT (PDBLK)
B_PFC  ENT  BL_PF            ENTRY POINT (PFBLK)
       MOV  XL,BPFPF         SAVE PFBLK PTR (NEED NOT BE RELOC)
       MOV  XL,XR            COPY FOR THE MOMENT
       MOV  PFVBL(XR),XL     POINT TO VRBLK FOR FUNCTION
BPF01  MOV  XL,WB            SAVE POINTER
       MOV  VRVAL(XL),XL     LOAD VALUE
       BEQ  (XL),=B_TRT,BPF01 LOOP IF TRBLK
       MOV  XL,BPFSV         SAVE OLD VALUE
       MOV  WB,XL            POINT BACK TO BLOCK WITH VALUE
       MOV  =NULLS,VRVAL(XL) SET VALUE TO NULL
       MOV  FARGS(XR),WA     LOAD NUMBER OF ARGUMENTS
       ADD  *PFARG,XR        POINT TO PFARG ENTRIES
       BZE  WA,BPF04         JUMP IF NO ARGUMENTS
       MOV  XS,XT            PTR TO LAST ARG
       WTB  WA               CONVERT NO. OF ARGS TO BYTES OFFSET
       ADD  WA,XT            POINT BEFORE FIRST ARG
       MOV  XT,BPFXT         REMEMBER ARG POINTER
BPF02  MOV  (XR)+,XL         LOAD VRBLK PTR FOR NEXT ARGUMENT
BPF03  MOV  XL,WC            SAVE POINTER
       MOV  VRVAL(XL),XL     LOAD NEXT VALUE
       BEQ  (XL),=B_TRT,BPF03 LOOP BACK IF TRBLK
       MOV  XL,WA            KEEP OLD VALUE
       MOV  BPFXT,XT         POINT BEFORE NEXT STACKED ARG
       MOV  -(XT),WB         LOAD ARGUMENT (NEW VALUE)
       MOV  WA,(XT)          SAVE OLD VALUE
       MOV  XT,BPFXT         KEEP ARG PTR FOR NEXT TIME
       MOV  WC,XL            POINT BACK TO BLOCK WITH VALUE
       MOV  WB,VRVAL(XL)     SET NEW VALUE
       BNE  XS,BPFXT,BPF02   LOOP IF NOT ALL DONE
BPF04  MOV  BPFPF,XL         RESTORE PFBLK POINTER
       MOV  PFNLO(XL),WA     LOAD NUMBER OF LOCALS
       BZE  WA,BPF07         JUMP IF NO LOCALS
       MOV  =NULLS,WB        GET NULL CONSTANT
       LCT  WA,WA            SET LOCAL COUNTER
BPF05  MOV  (XR)+,XL         LOAD VRBLK PTR FOR NEXT LOCAL
BPF06  MOV  XL,WC            SAVE POINTER
       MOV  VRVAL(XL),XL     LOAD NEXT VALUE
       BEQ  (XL),=B_TRT,BPF06 LOOP BACK IF TRBLK
       MOV  XL,-(XS)         STACK OLD VALUE
       MOV  WC,XL            POINT BACK TO BLOCK WITH VALUE
       MOV  WB,VRVAL(XL)     SET NULL AS NEW VALUE
       BCT  WA,BPF05         LOOP TILL ALL LOCALS PROCESSED
.IF    .CNPF
BPF07  MOV  R_COD,WA         LOAD OLD CODE BLOCK POINTER
.ELSE
BPF07  ZER  XR               ZERO REG XR IN CASE
       BZE  KVPFL,BPF7C      SKIP IF PROFILING IS OFF
       BEQ  KVPFL,=NUM02,BPF7A BRANCH ON TYPE OF PROFILE
       JSR  SYSTM            GET CURRENT TIME
       STI  PFETM            SAVE FOR A SEC
       SBI  PFSTM            FIND TIME USED BY CALLER
       JSR  ICBLD            BUILD INTO AN ICBLK
       LDI  PFETM            RELOAD CURRENT TIME
       BRN  BPF7B            MERGE
BPF7A  LDI  PFSTM            GET START TIME OF CALLING STMT
       JSR  ICBLD            ASSEMBLE AN ICBLK ROUND IT
       JSR  SYSTM            GET NOW TIME
BPF7B  STI  PFSTM            SET START TIME OF 1ST FUNC STMT
       MNZ  PFFNC            FLAG FUNCTION ENTRY
BPF7C  MOV  XR,-(XS)         STACK ICBLK PTR (OR ZERO)
       MOV  R_COD,WA         LOAD OLD CODE BLOCK POINTER
.FI
       SCP  WB               GET CODE POINTER
       SUB  WA,WB            MAKE CODE POINTER INTO OFFSET
       MOV  BPFPF,XL         RECALL PFBLK POINTER
       MOV  BPFSV,-(XS)      STACK OLD VALUE OF FUNCTION NAME
       MOV  WA,-(XS)         STACK CODE BLOCK POINTER
       MOV  WB,-(XS)         STACK CODE OFFSET
       MOV  FLPRT,-(XS)      STACK OLD FLPRT
       MOV  FLPTR,-(XS)      STACK OLD FAILURE POINTER
       MOV  XL,-(XS)         STACK POINTER TO PFBLK
       ZER  -(XS)            DUMMY ZERO ENTRY FOR FAIL RETURN
       CHK                   CHECK FOR STACK OVERFLOW
       MOV  XS,FLPTR         SET NEW FAIL RETURN VALUE
       MOV  XS,FLPRT         SET NEW FLPRT
       MOV  KVTRA,WA         LOAD TRACE VALUE
       ADD  KVFTR,WA         ADD FTRACE VALUE
       BNZ  WA,BPF09         JUMP IF TRACING POSSIBLE
       ICV  KVFNC            ELSE BUMP FNCLEVEL
BPF08  MOV  PFCOD(XL),XR     POINT TO VRBLK OF ENTRY LABEL
       MOV  VRLBL(XR),XR     POINT TO TARGET CODE
       BEQ  XR,=STNDL,BPF17  TEST FOR UNDEFINED LABEL
       BNE  (XR),=B_TRT,BPF8A JUMP IF NOT TRAPPED
       MOV  TRLBL(XR),XR     ELSE LOAD PTR TO REAL LABEL CODE
BPF8A  BRI  (XR)             OFF TO EXECUTE FUNCTION
BPF09  MOV  PFCTR(XL),XR     LOAD POSSIBLE CALL TRACE TRBLK
       MOV  PFVBL(XL),XL     LOAD VRBLK POINTER FOR FUNCTION
       MOV  *VRVAL,WA        SET NAME OFFSET FOR VARIABLE
       BZE  KVTRA,BPF10      JUMP IF TRACE MODE IS OFF
       BZE  XR,BPF10         OR IF THERE IS NO CALL TRACE
       DCV  KVTRA            DECREMENT TRACE COUNT
       BZE  TRFNC(XR),BPF11  JUMP IF PRINT TRACE
       JSR  TRXEQ            EXECUTE FUNCTION TYPE TRACE
BPF10  BZE  KVFTR,BPF16      JUMP IF FTRACE IS OFF
       DCV  KVFTR            ELSE DECREMENT FTRACE
BPF11  JSR  PRTSN            PRINT STATEMENT NUMBER
       JSR  PRTNM            PRINT FUNCTION NAME
       MOV  =CH_PP,WA        LOAD LEFT PAREN
       JSR  PRTCH            PRINT LEFT PAREN
       MOV  NUM01(XS),XL     RECOVER PFBLK POINTER
       BZE  FARGS(XL),BPF15  SKIP IF NO ARGUMENTS
       ZER  WB               ELSE SET ARGUMENT COUNTER
       BRN  BPF13            JUMP INTO LOOP
BPF12  MOV  =CH_CM,WA        LOAD COMMA
       JSR  PRTCH            PRINT TO SEPARATE FROM LAST ARG
BPF13  MOV  WB,(XS)          SAVE ARG CTR (OVER FAILOFFS IS OK)
       WTB  WB               CONVERT TO BYTE OFFSET
       ADD  WB,XL            POINT TO NEXT ARGUMENT POINTER
       MOV  PFARG(XL),XR     LOAD NEXT ARGUMENT VRBLK PTR
       SUB  WB,XL            RESTORE PFBLK POINTER
       MOV  VRVAL(XR),XR     LOAD NEXT VALUE
       JSR  PRTVL            PRINT ARGUMENT VALUE
       MOV  (XS),WB          RESTORE ARGUMENT COUNTER
       ICV  WB               INCREMENT ARGUMENT COUNTER
       BLT  WB,FARGS(XL),BPF12 LOOP IF MORE TO PRINT
BPF15  MOV  =CH_RP,WA        LOAD RIGHT PAREN
       JSR  PRTCH            PRINT TO TERMINATE OUTPUT
       JSR  PRTNL            TERMINATE PRINT LINE
BPF16  ICV  KVFNC            INCREMENT FNCLEVEL
       MOV  R_FNC,XL         LOAD PTR TO POSSIBLE TRBLK
       JSR  KTREX            CALL KEYWORD TRACE ROUTINE
       MOV  NUM01(XS),XL     RESTORE PFBLK POINTER
       BRN  BPF08            JUMP BACK TO EXECUTE FUNCTION
BPF17  MOV  NUM02(XS),FLPTR  RESET SO EXFAL CAN RETURN TO EVALX
       ERB  286,Function call to undefined entry label
.IF    .CNRA
.ELSE
B_RCL  ENT  BL_RC            ENTRY POINT (RCBLK)
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.FI
B_SCL  ENT  BL_SC            ENTRY POINT (SCBLK)
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
B_TBT  ENT  BL_TB            ENTRY POINT (TBBLK)
B_TET  ENT  BL_TE            ENTRY POINT (TEBLK)
B_VCT  ENT  BL_VC            ENTRY POINT (VCBLK)
B_VR_  ENT  BL__I            MARK START OF VRBLK ENTRY POINTS
B_VRA  ENT  BL__I            ENTRY POINT
       MOV  XR,XL            COPY NAME BASE (VRGET = 0)
       MOV  *VRVAL,WA        SET NAME OFFSET
       JSR  ACESS            ACCESS VALUE
       PPM  EXFAL            FAIL IF ACCESS FAILS
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
B_VRE  ENT                   ENTRY POINT
       ERB  042,Attempt to change value of protected variable
B_VRG  ENT                   ENTRY POINT
       MOV  VRLBO(XR),XR     LOAD CODE POINTER
       MOV  (XR),XL          LOAD ENTRY ADDRESS
       BRI  XL               JUMP TO ROUTINE FOR NEXT CODE WORD
B_VRL  ENT                   ENTRY POINT
       MOV  VRVAL(XR),-(XS)  LOAD VALUE ONTO STACK (VRGET = 0)
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
B_VRS  ENT                   ENTRY POINT
       MOV  (XS),VRVLO(XR)   STORE VALUE, LEAVE ON STACK
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
B_VRT  ENT                   ENTRY POINT
       SUB  *VRTRA,XR        POINT BACK TO START OF VRBLK
       MOV  XR,XL            COPY VRBLK POINTER
       MOV  *VRVAL,WA        SET NAME OFFSET
       MOV  VRLBL(XL),XR     LOAD POINTER TO TRBLK
       BZE  KVTRA,BVRT2      JUMP IF TRACE IS OFF
       DCV  KVTRA            ELSE DECREMENT TRACE COUNT
       BZE  TRFNC(XR),BVRT1  JUMP IF PRINT TRACE CASE
       JSR  TRXEQ            ELSE EXECUTE FULL TRACE
       BRN  BVRT2            MERGE TO JUMP TO LABEL
BVRT1  JSR  PRTSN            PRINT STATEMENT NUMBER
       MOV  XL,XR            COPY VRBLK POINTER
       MOV  =CH_CL,WA        COLON
       JSR  PRTCH            PRINT IT
       MOV  =CH_PP,WA        LEFT PAREN
       JSR  PRTCH            PRINT IT
       JSR  PRTVN            PRINT LABEL NAME
       MOV  =CH_RP,WA        RIGHT PAREN
       JSR  PRTCH            PRINT IT
       JSR  PRTNL            TERMINATE LINE
       MOV  VRLBL(XL),XR     POINT BACK TO TRBLK
BVRT2  MOV  TRLBL(XR),XR     LOAD POINTER TO ACTUAL CODE
       BRI  (XR)             EXECUTE STATEMENT AT LABEL
B_VRV  ENT                   ENTRY POINT
       MOV  (XS),WB          LOAD VALUE (LEAVE COPY ON STACK)
       SUB  *VRSTO,XR        POINT TO VRBLK
       MOV  XR,XL            COPY VRBLK POINTER
       MOV  *VRVAL,WA        SET OFFSET
       JSR  ASIGN            CALL ASSIGNMENT ROUTINE
       PPM  EXFAL            FAIL IF ASSIGNMENT FAILS
       LCW  XR               ELSE GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
B_XNT  ENT  BL_XN            ENTRY POINT (XNBLK)
B_XRT  ENT  BL_XR            ENTRY POINT (XRBLK)
B_YYY  ENT  BL__I            LAST BLOCK ROUTINE ENTRY POINT
       TTL  S P I T B O L -- PATTERN MATCHING ROUTINES
P_AAA  ENT  BL__I            ENTRY TO MARK FIRST PATTERN
P_ABA  ENT  BL_P0            P0BLK
       MOV  WB,-(XS)         STACK CURSOR
       MOV  XR,-(XS)         STACK DUMMY NODE PTR
       MOV  PMHBS,-(XS)      STACK OLD STACK BASE PTR
       MOV  =NDABB,-(XS)     STACK PTR TO NODE NDABB
       MOV  XS,PMHBS         STORE NEW STACK BASE PTR
       BRN  SUCCP            SUCCEED
P_ABB  ENT                   ENTRY POINT
       MOV  WB,PMHBS         RESTORE HISTORY STACK BASE PTR
       BRN  FLPOP            FAIL AND POP DUMMY NODE PTR
P_ABC  ENT  BL_P0            P0BLK
       MOV  PMHBS,XT         KEEP P_ABB STACK BASE
       MOV  NUM03(XT),WA     LOAD INITIAL CURSOR
       MOV  NUM01(XT),PMHBS  RESTORE OUTER STACK BASE PTR
       BEQ  XT,XS,PABC1      JUMP IF NO HISTORY STACK ENTRIES
       MOV  XT,-(XS)         ELSE SAVE INNER PMHBS ENTRY
       MOV  =NDABD,-(XS)     STACK PTR TO SPECIAL NODE NDABD
       BRN  PABC2            MERGE
PABC1  ADD  *NUM04,XS        REMOVE NDABB ENTRY AND CURSOR
PABC2  BNE  WA,WB,SUCCP      ALLOW FURTHER ATTEMPT IF NON-NULL
       MOV  PTHEN(XR),XR     BYPASS ALTERNATIVE NODE SO AS TO ...
       BRN  SUCCP            ... REFUSE FURTHER MATCH ATTEMPTS
P_ABD  ENT                   ENTRY POINT
       MOV  WB,PMHBS         RESTORE INNER STACK BASE PTR
       BRN  FAILP            AND FAIL
P_ABO  ENT  BL_P0            P0BLK
       BRN  EXFAL            SIGNAL STATEMENT FAILURE
P_ALT  ENT  BL_P1            P1BLK
       MOV  WB,-(XS)         STACK CURSOR
       MOV  PARM1(XR),-(XS)  STACK POINTER TO ALTERNATIVE
       CHK                   CHECK FOR STACK OVERFLOW
       BRN  SUCCP            IF ALL OK, THEN SUCCEED
P_ANS  ENT  BL_P1            P1BLK
       BEQ  WB,PMSSL,FAILP   FAIL IF NO CHARS LEFT
       MOV  R_PMS,XL         ELSE POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER
       LCH  WA,(XL)          LOAD CURRENT CHARACTER
       BNE  WA,PARM1(XR),FAILP FAIL IF NO MATCH
       ICV  WB               ELSE BUMP CURSOR
       BRN  SUCCP            AND SUCCEED
P_ANY  ENT  BL_P2            P2BLK
PANY1  BEQ  WB,PMSSL,FAILP   FAIL IF NO CHARACTERS LEFT
       MOV  R_PMS,XL         ELSE POINT TO SUBJECT STRING
       PLC  XL,WB            GET CHAR PTR TO CURRENT CHARACTER
       LCH  WA,(XL)          LOAD CURRENT CHARACTER
       MOV  PARM1(XR),XL     POINT TO CTBLK
       WTB  WA               CHANGE TO BYTE OFFSET
       ADD  WA,XL            POINT TO ENTRY IN CTBLK
       MOV  CTCHS(XL),WA     LOAD WORD FROM CTBLK
       ANB  PARM2(XR),WA     AND WITH SELECTED BIT
       ZRB  WA,FAILP         FAIL IF NO MATCH
       ICV  WB               ELSE BUMP CURSOR
       BRN  SUCCP            AND SUCCEED
P_AYD  ENT  BL_P1            P1BLK
       JSR  EVALS            EVALUATE STRING ARGUMENT
       ERR  043,ANY evaluated argument is not a string
       PPM  FAILP            FAIL IF EVALUATION FAILURE
       PPM  PANY1            MERGE MULTI-CHAR CASE IF OK
P_ARB  ENT  BL_P0            P0BLK
       MOV  PTHEN(XR),XR     LOAD SUCCESSOR POINTER
       MOV  WB,-(XS)         STACK DUMMY CURSOR
       MOV  XR,-(XS)         STACK SUCCESSOR POINTER
       MOV  WB,-(XS)         STACK CURSOR
       MOV  =NDARC,-(XS)     STACK PTR TO SPECIAL NODE NDARC
       BRI  (XR)             EXECUTE NEXT NODE MATCHING NULL
P_ARC  ENT                   ENTRY POINT
       BEQ  WB,PMSSL,FLPOP   FAIL AND POP STACK TO SUCCESSOR
       ICV  WB               ELSE BUMP CURSOR
       MOV  WB,-(XS)         STACK UPDATED CURSOR
       MOV  XR,-(XS)         RESTACK POINTER TO NDARC NODE
       MOV  NUM02(XS),XR     LOAD SUCCESSOR POINTER
       BRI  (XR)             OFF TO REEXECUTE SUCCESSOR NODE
P_BAL  ENT  BL_P0            P0BLK
       ZER  WC               ZERO PARENTHESES LEVEL COUNTER
       MOV  R_PMS,XL         POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER
       BRN  PBAL2            JUMP INTO SCAN LOOP
PBAL1  LCH  WA,(XL)+         LOAD NEXT CHARACTER, BUMP POINTER
       ICV  WB               PUSH CURSOR FOR CHARACTER
       BEQ  WA,=CH_PP,PBAL3  JUMP IF LEFT PAREN
       BEQ  WA,=CH_RP,PBAL4  JUMP IF RIGHT PAREN
       BZE  WC,PBAL5         ELSE SUCCEED IF AT OUTER LEVEL
PBAL2  BNE  WB,PMSSL,PBAL1   LOOP BACK UNLESS END OF STRING
       BRN  FAILP            IN WHICH CASE, FAIL
PBAL3  ICV  WC               BUMP PAREN LEVEL
       BRN  PBAL2            LOOP BACK TO CHECK END OF STRING
PBAL4  BZE  WC,FAILP         FAIL IF NO MATCHING LEFT PAREN
       DCV  WC               ELSE DECREMENT LEVEL COUNTER
       BNZ  WC,PBAL2         LOOP BACK IF NOT AT OUTER LEVEL
PBAL5  MOV  WB,-(XS)         STACK CURSOR
       MOV  XR,-(XS)         STACK PTR TO BAL NODE FOR EXTEND
       BRN  SUCCP            AND SUCCEED
P_BKD  ENT  BL_P1            P1BLK
       JSR  EVALS            EVALUATE STRING EXPRESSION
       ERR  044,BREAK evaluated argument is not a string
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PBRK1            MERGE WITH MULTI-CHAR CASE IF OK
P_BKS  ENT  BL_P1            P1BLK
       MOV  PMSSL,WC         GET SUBJECT STRING LENGTH
       SUB  WB,WC            GET NUMBER OF CHARACTERS LEFT
       BZE  WC,FAILP         FAIL IF NO CHARACTERS LEFT
       LCT  WC,WC            SET COUNTER FOR CHARS LEFT
       MOV  R_PMS,XL         POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER
PBKS1  LCH  WA,(XL)+         LOAD NEXT CHAR, BUMP POINTER
       BEQ  WA,PARM1(XR),SUCCP SUCCEED IF BREAK CHARACTER FOUND
       ICV  WB               ELSE PUSH CURSOR
       BCT  WC,PBKS1         LOOP BACK IF MORE TO GO
       BRN  FAILP            FAIL IF END OF STRING, NO BREAK CHR
P_BRK  ENT  BL_P2            P2BLK
PBRK1  MOV  PMSSL,WC         LOAD SUBJECT STRING LENGTH
       SUB  WB,WC            GET NUMBER OF CHARACTERS LEFT
       BZE  WC,FAILP         FAIL IF NO CHARACTERS LEFT
       LCT  WC,WC            SET COUNTER FOR CHARACTERS LEFT
       MOV  R_PMS,XL         ELSE POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER
       MOV  XR,PSAVE         SAVE NODE POINTER
PBRK2  LCH  WA,(XL)+         LOAD NEXT CHAR, BUMP POINTER
       MOV  PARM1(XR),XR     LOAD POINTER TO CTBLK
       WTB  WA               CONVERT TO BYTE OFFSET
       ADD  WA,XR            POINT TO CTBLK ENTRY
       MOV  CTCHS(XR),WA     LOAD CTBLK WORD
       MOV  PSAVE,XR         RESTORE NODE POINTER
       ANB  PARM2(XR),WA     AND WITH SELECTED BIT
       NZB  WA,SUCCP         SUCCEED IF BREAK CHARACTER FOUND
       ICV  WB               ELSE PUSH CURSOR
       BCT  WC,PBRK2         LOOP BACK UNLESS END OF STRING
       BRN  FAILP            FAIL IF END OF STRING, NO BREAK CHR
P_BKX  ENT  BL_P0            P0BLK
       ICV  WB               STEP CURSOR PAST PREVIOUS BREAK CHR
       BRN  SUCCP            SUCCEED TO REMATCH BREAK
P_BXD  ENT  BL_P1            P1BLK
       JSR  EVALS            EVALUATE STRING ARGUMENT
       ERR  045,BREAKX evaluated argument is not a string
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PBRK1            MERGE WITH BREAK IF ALL OK
P_CAS  ENT  BL_P2            P2BLK
       MOV  XR,-(XS)         SAVE NODE POINTER
       MOV  WB,-(XS)         SAVE CURSOR
       MOV  PARM1(XR),XL     LOAD NAME BASE
       MTI  WB               LOAD CURSOR AS INTEGER
       MOV  PARM2(XR),WB     LOAD NAME OFFSET
       JSR  ICBLD            GET ICBLK FOR CURSOR VALUE
       MOV  WB,WA            MOVE NAME OFFSET
       MOV  XR,WB            MOVE VALUE TO ASSIGN
       JSR  ASINP            PERFORM ASSIGNMENT
       PPM  FLPOP            FAIL ON ASSIGNMENT FAILURE
       MOV  (XS)+,WB         ELSE RESTORE CURSOR
       MOV  (XS)+,XR         RESTORE NODE POINTER
       BRN  SUCCP            AND SUCCEED MATCHING NULL
P_EXA  ENT  BL_P1            P1BLK
       JSR  EVALP            EVALUATE EXPRESSION
       PPM  FAILP            FAIL IF EVALUATION FAILS
       BLO  WA,=P_AAA,PEXA1  JUMP IF RESULT IS NOT A PATTERN
       MOV  WB,-(XS)         STACK DUMMY CURSOR
       MOV  XR,-(XS)         STACK PTR TO P_EXA NODE
       MOV  PMHBS,-(XS)      STACK HISTORY STACK BASE PTR
       MOV  =NDEXB,-(XS)     STACK PTR TO SPECIAL NODE NDEXB
       MOV  XS,PMHBS         STORE NEW STACK BASE POINTER
       MOV  XL,XR            COPY NODE POINTER
       BRI  (XR)             MATCH FIRST NODE IN EXPRESSION PAT
PEXA1  BEQ  WA,=B_SCL,PEXA2  JUMP IF IT IS ALREADY A STRING
       MOV  XL,-(XS)         ELSE STACK RESULT
       MOV  XR,XL            SAVE NODE POINTER
       JSR  GTSTG            CONVERT RESULT TO STRING
       ERR  046,Expression does not evaluate to pattern
       MOV  XR,WC            COPY STRING POINTER
       MOV  XL,XR            RESTORE NODE POINTER
       MOV  WC,XL            COPY STRING POINTER AGAIN
PEXA2  BZE  SCLEN(XL),SUCCP  JUST SUCCEED IF NULL STRING
       BRN  PSTR1            ELSE MERGE WITH STRING CIRCUIT
P_EXB  ENT                   ENTRY POINT
       MOV  WB,PMHBS         RESTORE OUTER LEVEL STACK POINTER
       BRN  FLPOP            FAIL AND POP P_EXA NODE PTR
P_EXC  ENT                   ENTRY POINT
       MOV  WB,PMHBS         RESTORE INNER STACK BASE POINTER
       BRN  FAILP            AND FAIL INTO EXPR PATTERN ALTERNVS
P_FAL  ENT  BL_P0            P0BLK
       BRN  FAILP            JUST SIGNAL FAILURE
P_FEN  ENT  BL_P0            P0BLK
       MOV  WB,-(XS)         STACK DUMMY CURSOR
       MOV  =NDABO,-(XS)     STACK PTR TO ABORT NODE
       BRN  SUCCP            AND SUCCEED MATCHING NULL
P_FNA  ENT  BL_P0            P0BLK
       MOV  PMHBS,-(XS)      STACK CURRENT HISTORY STACK BASE
       MOV  =NDFNB,-(XS)     STACK INDIR PTR TO P_FNB (FAILURE)
       MOV  XS,PMHBS         BEGIN NEW HISTORY STACK
       BRN  SUCCP            SUCCEED
P_FNB  ENT  BL_P0            P0BLK
       MOV  WB,PMHBS         RESTORE OUTER PMHBS STACK BASE
       BRN  FAILP            ...AND FAIL
P_FNC  ENT  BL_P0            P0BLK
       MOV  PMHBS,XT         GET INNER STACK BASE PTR
       MOV  NUM01(XT),PMHBS  RESTORE OUTER STACK BASE
       BEQ  XT,XS,PFNC1      OPTIMIZE IF NO ALTERNATIVES
       MOV  XT,-(XS)         ELSE STACK INNER STACK BASE
       MOV  =NDFND,-(XS)     STACK PTR TO NDFND
       BRN  SUCCP            SUCCEED
PFNC1  ADD  *NUM02,XS        POP OFF P_FNB ENTRY
       BRN  SUCCP            SUCCEED
P_FND  ENT  BL_P0            P0BLK
       MOV  WB,XS            POP STACK TO FENCE() HISTORY BASE
       BRN  FLPOP            POP BASE ENTRY AND FAIL
P_IMA  ENT  BL_P0            P0BLK
       MOV  WB,-(XS)         STACK CURSOR
       MOV  XR,-(XS)         STACK DUMMY NODE POINTER
       MOV  PMHBS,-(XS)      STACK OLD STACK BASE POINTER
       MOV  =NDIMB,-(XS)     STACK PTR TO SPECIAL NODE NDIMB
       MOV  XS,PMHBS         STORE NEW STACK BASE POINTER
       BRN  SUCCP            AND SUCCEED
P_IMB  ENT                   ENTRY POINT
       MOV  WB,PMHBS         RESTORE HISTORY STACK BASE PTR
       BRN  FLPOP            FAIL AND POP DUMMY NODE PTR
P_IMC  ENT  BL_P2            P2BLK
       MOV  PMHBS,XT         LOAD POINTER TO P_IMB ENTRY
       MOV  WB,WA            COPY FINAL CURSOR
       MOV  NUM03(XT),WB     LOAD INITIAL CURSOR
       MOV  NUM01(XT),PMHBS  RESTORE OUTER STACK BASE POINTER
       BEQ  XT,XS,PIMC1      JUMP IF NO HISTORY STACK ENTRIES
       MOV  XT,-(XS)         ELSE SAVE INNER PMHBS POINTER
       MOV  =NDIMD,-(XS)     AND A PTR TO SPECIAL NODE NDIMD
       BRN  PIMC2            MERGE
PIMC1  ADD  *NUM04,XS        REMOVE NDIMB ENTRY AND CURSOR
PIMC2  MOV  WA,-(XS)         SAVE CURRENT (FINAL) CURSOR
       MOV  XR,-(XS)         SAVE CURRENT NODE POINTER
       MOV  R_PMS,XL         POINT TO SUBJECT STRING
       SUB  WB,WA            COMPUTE SUBSTRING LENGTH
       JSR  SBSTR            BUILD SUBSTRING
       MOV  XR,WB            MOVE RESULT
       MOV  (XS),XR          RELOAD NODE POINTER
       MOV  PARM1(XR),XL     LOAD NAME BASE
       MOV  PARM2(XR),WA     LOAD NAME OFFSET
       JSR  ASINP            PERFORM ASSIGNMENT
       PPM  FLPOP            FAIL IF ASSIGNMENT FAILS
       MOV  (XS)+,XR         ELSE RESTORE NODE POINTER
       MOV  (XS)+,WB         RESTORE CURSOR
       BRN  SUCCP            AND SUCCEED
P_IMD  ENT                   ENTRY POINT
       MOV  WB,PMHBS         RESTORE INNER STACK BASE POINTER
       BRN  FAILP            AND FAIL
P_LEN  ENT  BL_P1            P1BLK
PLEN1  ADD  PARM1(XR),WB     PUSH CURSOR INDICATED AMOUNT
       BLE  WB,PMSSL,SUCCP   SUCCEED IF NOT OFF END
       BRN  FAILP            ELSE FAIL
P_LND  ENT  BL_P1            P1BLK
       JSR  EVALI            EVALUATE INTEGER ARGUMENT
       ERR  047,LEN evaluated argument is not integer
       ERR  048,LEN evaluated argument is negative or too large
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PLEN1            MERGE WITH NORMAL CIRCUIT IF OK
P_NAD  ENT  BL_P1            P1BLK
       JSR  EVALS            EVALUATE STRING ARGUMENT
       ERR  049,NOTANY evaluated argument is not a string
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PNAY1            MERGE WITH MULTI-CHAR CASE IF OK
P_NAS  ENT  BL_P1            ENTRY POINT
       BEQ  WB,PMSSL,FAILP   FAIL IF NO CHARS LEFT
       MOV  R_PMS,XL         ELSE POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER IN STRIN
       LCH  WA,(XL)          LOAD CURRENT CHARACTER
       BEQ  WA,PARM1(XR),FAILP FAIL IF MATCH
       ICV  WB               ELSE BUMP CURSOR
       BRN  SUCCP            AND SUCCEED
P_NAY  ENT  BL_P2            P2BLK
PNAY1  BEQ  WB,PMSSL,FAILP   FAIL IF NO CHARACTERS LEFT
       MOV  R_PMS,XL         ELSE POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER
       LCH  WA,(XL)          LOAD CURRENT CHARACTER
       WTB  WA               CONVERT TO BYTE OFFSET
       MOV  PARM1(XR),XL     LOAD POINTER TO CTBLK
       ADD  WA,XL            POINT TO ENTRY IN CTBLK
       MOV  CTCHS(XL),WA     LOAD ENTRY FROM CTBLK
       ANB  PARM2(XR),WA     AND WITH SELECTED BIT
       NZB  WA,FAILP         FAIL IF CHARACTER IS MATCHED
       ICV  WB               ELSE BUMP CURSOR
       BRN  SUCCP            AND SUCCEED
P_NTH  ENT  BL_P0            P0BLK (DUMMY)
       MOV  PMHBS,XT         LOAD POINTER TO BASE OF STACK
       MOV  NUM01(XT),WA     LOAD SAVED PMHBS (OR PATTERN TYPE)
       BLE  WA,=NUM02,PNTH2  JUMP IF OUTER LEVEL (PATTERN TYPE)
       MOV  WA,PMHBS         RESTORE OUTER STACK BASE POINTER
       MOV  NUM02(XT),XR     RESTORE POINTER TO P_EXA NODE
       BEQ  XT,XS,PNTH1      JUMP IF NO HISTORY STACK ENTRIES
       MOV  XT,-(XS)         ELSE STACK INNER STACK BASE PTR
       MOV  =NDEXC,-(XS)     STACK PTR TO SPECIAL NODE NDEXC
       BRN  SUCCP            AND SUCCEED
PNTH1  ADD  *NUM04,XS        REMOVE P_EXB ENTRY AND NODE PTR
       BRN  SUCCP            AND SUCCEED
PNTH2  MOV  WB,PMSSL         SAVE FINAL CURSOR IN SAFE PLACE
       BZE  PMDFL,PNTH6      JUMP IF NO PATTERN ASSIGNMENTS
PNTH3  DCA  XT               POINT PAST CURSOR ENTRY
       MOV  -(XT),WA         LOAD NODE POINTER
       BEQ  WA,=NDPAD,PNTH4  JUMP IF NDPAD ENTRY
       BNE  WA,=NDPAB,PNTH5  JUMP IF NOT NDPAB ENTRY
       MOV  NUM01(XT),-(XS)  STACK INITIAL CURSOR
       CHK                   CHECK FOR STACK OVERFLOW
       BRN  PNTH3            LOOP BACK IF OK
PNTH4  MOV  NUM01(XT),WA     LOAD FINAL CURSOR
       MOV  (XS),WB          LOAD INITIAL CURSOR FROM STACK
       MOV  XT,(XS)          SAVE HISTORY STACK SCAN PTR
       SUB  WB,WA            COMPUTE LENGTH OF STRING
       MOV  R_PMS,XL         POINT TO SUBJECT STRING
       JSR  SBSTR            CONSTRUCT SUBSTRING
       MOV  XR,WB            COPY SUBSTRING POINTER
       MOV  (XS),XT          RELOAD HISTORY STACK SCAN PTR
       MOV  NUM02(XT),XL     LOAD POINTER TO P_PAC NODE WITH NAM
       MOV  PARM2(XL),WA     LOAD NAME OFFSET
       MOV  PARM1(XL),XL     LOAD NAME BASE
       JSR  ASINP            PERFORM ASSIGNMENT
       PPM  EXFAL            MATCH FAILS IF NAME EVAL FAILS
       MOV  (XS)+,XT         ELSE RESTORE HISTORY STACK PTR
PNTH5  BNE  XT,XS,PNTH3      LOOP IF MORE ENTRIES TO SCAN
PNTH6  MOV  PMHBS,XS         WIPE OUT HISTORY STACK
       MOV  (XS)+,WB         LOAD INITIAL CURSOR
       MOV  (XS)+,WC         LOAD MATCH TYPE CODE
       MOV  PMSSL,WA         LOAD FINAL CURSOR VALUE
       MOV  R_PMS,XL         POINT TO SUBJECT STRING
       ZER  R_PMS            CLEAR SUBJECT STRING PTR FOR GBCOL
       BZE  WC,PNTH7         JUMP IF CALL BY NAME
       BEQ  WC,=NUM02,PNTH9  EXIT IF STATEMENT LEVEL CALL
       SUB  WB,WA            COMPUTE LENGTH OF STRING
       JSR  SBSTR            BUILD SUBSTRING
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
PNTH7  MOV  WB,-(XS)         STACK INITIAL CURSOR
       MOV  WA,-(XS)         STACK FINAL CURSOR
.IF    .CNBF
.ELSE
       BZE  R_PMB,PNTH8      SKIP IF SUBJECT NOT BUFFER
       MOV  R_PMB,XL         ELSE GET PTR TO BCBLK INSTEAD
.FI
PNTH8  MOV  XL,-(XS)         STACK SUBJECT POINTER
PNTH9  LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
P_POS  ENT  BL_P1            P1BLK
       BEQ  WB,PARM1(XR),SUCCP SUCCEED IF AT RIGHT LOCATION
       BNZ  WB,FAILP         DON'T LOOK FURTHER IF CURSOR NOT 0
       MOV  PMHBS,XT         GET HISTORY STACK BASE PTR
       BNE  XR,-(XT),FAILP   FAIL IF POS IS NOT FIRST NODE
PPOS2  BNE  -(XT),=NDUNA,FAILP  FAIL IF NOT UNANCHORED MODE
       MOV  PARM1(XR),WB     GET DESIRED CURSOR POSITION
       BGT  WB,PMSSL,EXFAL   ABORT IF OFF END
       MOV  WB,NUM02(XT)     FAKE NUMBER OF UNANCHORED MOVES
       BRN  SUCCP            CONTINUE MATCH WITH ADJUSTED CURSOR
P_PSD  ENT  BL_P1            P1BLK
       JSR  EVALI            EVALUATE INTEGER ARGUMENT
       ERR  050,POS evaluated argument is not integer
       ERR  051,POS evaluated argument is negative or too large
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PPOS1            PROCESS EXPRESSION CASE
PPOS1  BEQ  WB,PARM1(XR),SUCCP SUCCEED IF AT RIGHT LOCATION
       BNZ  WB,FAILP         DON'T LOOK FURTHER IF CURSOR NOT 0
       BNZ  EVLIF,FAILP      FAIL IF COMPLEX ARGUMENT
       MOV  PMHBS,XT         GET HISTORY STACK BASE PTR
       MOV  EVLIO,WA         GET ORIGINAL NODE PTR
       BNE  WA,-(XT),FAILP   FAIL IF POS IS NOT FIRST NODE
       BRN  PPOS2            MERGE WITH INTEGER ARGUMENT CODE
P_PAA  ENT  BL_P0            P0BLK
       MOV  WB,-(XS)         STACK INITIAL CURSOR
       MOV  =NDPAB,-(XS)     STACK PTR TO NDPAB SPECIAL NODE
       BRN  SUCCP            AND SUCCEED MATCHING NULL
P_PAB  ENT                   ENTRY POINT
       BRN  FAILP            JUST FAIL (ENTRY IS ALREADY POPPED)
P_PAC  ENT  BL_P2            P2BLK
       MOV  WB,-(XS)         STACK DUMMY CURSOR VALUE
       MOV  XR,-(XS)         STACK POINTER TO P_PAC NODE
       MOV  WB,-(XS)         STACK FINAL CURSOR
       MOV  =NDPAD,-(XS)     STACK PTR TO SPECIAL NDPAD NODE
       MNZ  PMDFL            SET DOT FLAG NON-ZERO
       BRN  SUCCP            AND SUCCEED
P_PAD  ENT                   ENTRY POINT
       BRN  FLPOP            FAIL AND REMOVE P_PAC NODE
P_REM  ENT  BL_P0            P0BLK
       MOV  PMSSL,WB         POINT CURSOR TO END OF STRING
       BRN  SUCCP            AND SUCCEED
P_RPD  ENT  BL_P1            P1BLK
       JSR  EVALI            EVALUATE INTEGER ARGUMENT
       ERR  052,RPOS evaluated argument is not integer
       ERR  053,RPOS evaluated argument is negative or too large
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PRPS1            MERGE WITH NORMAL CASE IF OK
PRPS1  MOV  PMSSL,WC         GET LENGTH OF STRING
       SUB  WB,WC            GET NUMBER OF CHARACTERS REMAINING
       BEQ  WC,PARM1(XR),SUCCP SUCCEED IF AT RIGHT LOCATION
       BNZ  WB,FAILP         DON'T LOOK FURTHER IF CURSOR NOT 0
       BNZ  EVLIF,FAILP      FAIL IF COMPLEX ARGUMENT
       MOV  PMHBS,XT         GET HISTORY STACK BASE PTR
       MOV  EVLIO,WA         GET ORIGINAL NODE PTR
       BNE  WA,-(XT),FAILP   FAIL IF POS IS NOT FIRST NODE
       BRN  PRPS2            MERGE WITH INTEGER ARG CODE
P_RPS  ENT  BL_P1            P1BLK
       MOV  PMSSL,WC         GET LENGTH OF STRING
       SUB  WB,WC            GET NUMBER OF CHARACTERS REMAINING
       BEQ  WC,PARM1(XR),SUCCP SUCCEED IF AT RIGHT LOCATION
       BNZ  WB,FAILP         DON'T LOOK FURTHER IF CURSOR NOT 0
       MOV  PMHBS,XT         GET HISTORY STACK BASE PTR
       BNE  XR,-(XT),FAILP   FAIL IF RPOS IS NOT FIRST NODE
PRPS2  BNE  -(XT),=NDUNA,FAILP  FAIL IF NOT UNANCHORED MODE
       MOV  PMSSL,WB         POINT TO END OF STRING
       BLT  WB,PARM1(XR),FAILP FAIL IF STRING NOT LONG ENOUGH
       SUB  PARM1(XR),WB     ELSE SET NEW CURSOR
       MOV  WB,NUM02(XT)     FAKE NUMBER OF UNANCHORED MOVES
       BRN  SUCCP            CONTINUE MATCH WITH ADJUSTED CURSOR
P_RTB  ENT  BL_P1            P1BLK
PRTB1  MOV  WB,WC            SAVE INITIAL CURSOR
       MOV  PMSSL,WB         POINT TO END OF STRING
       BLT  WB,PARM1(XR),FAILP FAIL IF STRING NOT LONG ENOUGH
       SUB  PARM1(XR),WB     ELSE SET NEW CURSOR
       BGE  WB,WC,SUCCP      AND SUCCEED IF NOT TOO FAR ALREADY
       BRN  FAILP            IN WHICH CASE, FAIL
P_RTD  ENT  BL_P1            P1BLK
       JSR  EVALI            EVALUATE INTEGER ARGUMENT
       ERR  054,RTAB evaluated argument is not integer
       ERR  055,RTAB evaluated argument is negative or too large
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PRTB1            MERGE WITH NORMAL CASE IF SUCCESS
P_SPD  ENT  BL_P1            P1BLK
       JSR  EVALS            EVALUATE STRING ARGUMENT
       ERR  056,SPAN evaluated argument is not a string
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PSPN1            MERGE WITH MULTI-CHAR CASE IF OK
P_SPN  ENT  BL_P2            P2BLK
PSPN1  MOV  PMSSL,WC         COPY SUBJECT STRING LENGTH
       SUB  WB,WC            CALCULATE NUMBER OF CHARACTERS LEFT
       BZE  WC,FAILP         FAIL IF NO CHARACTERS LEFT
       MOV  R_PMS,XL         POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER
       MOV  WB,PSAVC         SAVE INITIAL CURSOR
       MOV  XR,PSAVE         SAVE NODE POINTER
       LCT  WC,WC            SET COUNTER FOR CHARS LEFT
PSPN2  LCH  WA,(XL)+         LOAD NEXT CHARACTER, BUMP POINTER
       WTB  WA               CONVERT TO BYTE OFFSET
       MOV  PARM1(XR),XR     POINT TO CTBLK
       ADD  WA,XR            POINT TO CTBLK ENTRY
       MOV  CTCHS(XR),WA     LOAD CTBLK ENTRY
       MOV  PSAVE,XR         RESTORE NODE POINTER
       ANB  PARM2(XR),WA     AND WITH SELECTED BIT
       ZRB  WA,PSPN3         JUMP IF NO MATCH
       ICV  WB               ELSE PUSH CURSOR
       BCT  WC,PSPN2         LOOP BACK UNLESS END OF STRING
PSPN3  BNE  WB,PSAVC,SUCCP   SUCCEED IF CHARS MATCHED
       BRN  FAILP            ELSE FAIL IF NULL STRING MATCHED
P_SPS  ENT  BL_P1            P1BLK
       MOV  PMSSL,WC         GET SUBJECT STRING LENGTH
       SUB  WB,WC            CALCULATE NUMBER OF CHARACTERS LEFT
       BZE  WC,FAILP         FAIL IF NO CHARACTERS LEFT
       MOV  R_PMS,XL         ELSE POINT TO SUBJECT STRING
       PLC  XL,WB            POINT TO CURRENT CHARACTER
       MOV  WB,PSAVC         SAVE INITIAL CURSOR
       LCT  WC,WC            SET COUNTER FOR CHARACTERS LEFT
PSPS1  LCH  WA,(XL)+         LOAD NEXT CHARACTER, BUMP POINTER
       BNE  WA,PARM1(XR),PSPS2 JUMP IF NO MATCH
       ICV  WB               ELSE PUSH CURSOR
       BCT  WC,PSPS1         AND LOOP UNLESS END OF STRING
PSPS2  BNE  WB,PSAVC,SUCCP   SUCCEED IF CHARS MATCHED
       BRN  FAILP            FAIL IF NULL STRING MATCHED
P_STR  ENT  BL_P1            P1BLK
       MOV  PARM1(XR),XL     GET POINTER TO STRING
PSTR1  MOV  XR,PSAVE         SAVE NODE POINTER
       MOV  R_PMS,XR         LOAD SUBJECT STRING POINTER
       PLC  XR,WB            POINT TO CURRENT CHARACTER
       ADD  SCLEN(XL),WB     COMPUTE NEW CURSOR POSITION
       BGT  WB,PMSSL,FAILP   FAIL IF PAST END OF STRING
       MOV  WB,PSAVC         SAVE UPDATED CURSOR
       MOV  SCLEN(XL),WA     GET NUMBER OF CHARS TO COMPARE
       PLC  XL               POINT TO CHARS OF TEST STRING
       CMC  FAILP,FAILP      COMPARE, FAIL IF NOT EQUAL
       MOV  PSAVE,XR         IF ALL MATCHED, RESTORE NODE PTR
       MOV  PSAVC,WB         RESTORE UPDATED CURSOR
       BRN  SUCCP            AND SUCCEED
P_SUC  ENT  BL_P0            P0BLK
       MOV  WB,-(XS)         STACK CURSOR
       MOV  XR,-(XS)         STACK POINTER TO THIS NODE
       BRN  SUCCP            SUCCEED MATCHING NULL
P_TAB  ENT  BL_P1            P1BLK
PTAB1  BGT  WB,PARM1(XR),FAILP FAIL IF TOO FAR ALREADY
       MOV  PARM1(XR),WB     ELSE SET NEW CURSOR POSITION
       BLE  WB,PMSSL,SUCCP   SUCCEED IF NOT OFF END
       BRN  FAILP            ELSE FAIL
P_TBD  ENT  BL_P1            P1BLK
       JSR  EVALI            EVALUATE INTEGER ARGUMENT
       ERR  057,TAB evaluated argument is not integer
       ERR  058,TAB evaluated argument is negative or too large
       PPM  FAILP            FAIL IF EVALUATION FAILS
       PPM  PTAB1            MERGE WITH NORMAL CASE IF OK
P_UNA  ENT                   ENTRY POINT
       MOV  WB,XR            COPY INITIAL PATTERN NODE POINTER
       MOV  (XS),WB          GET INITIAL CURSOR
       BEQ  WB,PMSSL,EXFAL   MATCH FAILS IF AT END OF STRING
       ICV  WB               ELSE INCREMENT CURSOR
       MOV  WB,(XS)          STORE INCREMENTED CURSOR
       MOV  XR,-(XS)         RESTACK INITIAL NODE PTR
       MOV  =NDUNA,-(XS)     RESTACK UNANCHORED NODE
       BRI  (XR)             REMATCH FIRST NODE
P_YYY  ENT  BL__I            MARK LAST ENTRY IN PATTERN SECTION
       TTL  S P I T B O L -- SNOBOL4 BUILT-IN LABEL ROUTINES
L_ABO  ENT                   ENTRY POINT
LABO1  MOV  KVERT,WA         LOAD ERROR CODE
       BZE  WA,LABO3         JUMP IF NO ERROR HAS OCCURED
.IF    .CSAX
       JSR  SYSAX            CALL AFTER EXECUTION PROC
.FI
.IF    .CERA
.IF    .CSFN
       MOV  KVSTN,WC         CURRENT STATEMENT
       JSR  FILNM            OBTAIN FILE NAME FOR THIS STATEMENT
.FI
.IF    .CSLN
       MOV  R_COD,XR         CURRENT CODE BLOCK
       MOV  CDSLN(XR),WC     LINE NUMBER
.ELSE
       ZER  WC               LINE NUMBER
.FI
       ZER  WB               COLUMN NUMBER
       MOV  STAGE,XR
       JSR  SYSEA            ADVISE SYSTEM OF ERROR
       PPM  STPR4            IF SYSTEM DOES NOT WANT PRINT
.FI
       JSR  PRTPG            ELSE EJECT PRINTER
.IF    .CERA
       BZE  XR,LABO2         DID SYSEA REQUEST PRINT
       JSR  PRTST            PRINT TEXT FROM SYSEA
.FI
LABO2  JSR  ERMSG            PRINT ERROR MESSAGE
       ZER  XR               INDICATE NO MESSAGE TO PRINT
       BRN  STOPR            JUMP TO ROUTINE TO STOP RUN
LABO3  ERB  036,Goto ABORT with no preceding error
L_CNT  ENT                   ENTRY POINT
LCNT1  MOV  R_CNT,XR         LOAD CONTINUATION CODE BLOCK PTR
       BZE  XR,LCNT3         JUMP IF NO PREVIOUS ERROR
       ZER  R_CNT            CLEAR FLAG
       MOV  XR,R_COD         ELSE STORE AS NEW CODE BLOCK PTR
       BNE  (XR),=B_CDC,LCNT2 JUMP IF NOT COMPLEX GO
       MOV  STXOC,WA         GET OFFSET OF ERROR
       BGE  WA,STXOF,LCNT4   JUMP IF ERROR IN GOTO EVALUATION
LCNT2  ADD  STXOF,XR         ADD FAILURE OFFSET
       LCP  XR               LOAD CODE POINTER
       MOV  FLPTR,XS         RESET STACK POINTER
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
LCNT3  ICV  ERRFT            FATAL ERROR
       ERB  037,Goto CONTINUE with no preceding error
LCNT4  ICV  ERRFT            FATAL ERROR
       ERB  332,Goto CONTINUE with error in failure goto
L_END  ENT                   ENTRY POINT
LEND0  MOV  =ENDMS,XR        POINT TO MESSAGE /NORMAL TERM.../
       BRN  STOPR            JUMP TO ROUTINE TO STOP RUN
L_FRT  ENT                   ENTRY POINT
       MOV  =SCFRT,WA        POINT TO STRING /FRETURN/
       BRN  RETRN            JUMP TO COMMON RETURN ROUTINE
L_NRT  ENT                   ENTRY POINT
       MOV  =SCNRT,WA        POINT TO STRING /NRETURN/
       BRN  RETRN            JUMP TO COMMON RETURN ROUTINE
L_RTN  ENT                   ENTRY POINT
       MOV  =SCRTN,WA        POINT TO STRING /RETURN/
       BRN  RETRN            JUMP TO COMMON RETURN ROUTINE
L_SCN  ENT                   ENTRY POINT
       MOV  R_CNT,XR         LOAD CONTINUATION CODE BLOCK PTR
       BZE  XR,LSCN2         JUMP IF NO PREVIOUS ERROR
       ZER  R_CNT            CLEAR FLAG
       BNE  KVERT,=NM320,LSCN1 ERROR MUST BE USER INTERRUPT
       BEQ  KVERT,=NM321,LSCN2 DETECT SCONTINUE LOOP
       MOV  XR,R_COD         ELSE STORE AS NEW CODE BLOCK PTR
       ADD  STXOC,XR         ADD RESUME OFFSET
       LCP  XR               LOAD CODE POINTER
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
LSCN1  ICV  ERRFT            FATAL ERROR
       ERB  331,Goto SCONTINUE with no user interrupt
LSCN2  ICV  ERRFT            FATAL ERROR
       ERB  321,Goto SCONTINUE with no preceding error
L_UND  ENT                   ENTRY POINT
       ERB  038,Goto undefined label
       TTL  S P I T B O L -- PREDEFINED SNOBOL4 FUNCTIONS
.IF    .C370
S_ABS  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTNUM            MAKE NUMERIC
       ERR  xxx,ABS argument not numeric
.IF    .CNRA
.ELSE
       BEQ  WA,=B_RCL,SABS1  JUMP IF REAL
.FI
       LDI  ICVAL(XR)        LOAD INTEGER VALUE
       IGE  EXIXR            NO CHANGE IF NOT NEGATIVE
       NGI                   PRODUCE ABSOLUTE VALUE
       INO  EXINT            RETURN INTEGER IF NO OVERFLOW
       ERB  xxx,ABS caused integer overflow
.IF    .CNRA
.ELSE
SABS1  LDR  RCVAL(XR)        LOAD REAL VALUE
       RGE  EXIXR            NO CHANGE IF NOT NEGATIVE
       NGR                   PRODUCE ABSOLUTE VALUE
       RNO  EXREA            RETURN REAL IF NO OVERFLOW
       ERB  xxx,ABS caused real overflow
.FI
.FI
.IF    .C370
S_AND  ENT                   ENTRY POINT
       MNZ  WB               SIGNAL TWO ARGUMENTS
       JSR  SBOOL            CALL STRING BOOLEAN ROUTINE
       ERR  xxx,AND first argument is not a string
       ERR  xxx,AND second argument is not a string
       ERR  xxx,AND arguments not same length
       PPM  EXITS            NULL STRING ARGUMENTS
SAND1  MOV  (XL)+,WA         GET NEXT CFP_C CHARS FROM ARG 1
       ANB  (XR),WA          AND WITH CHARACTERS FROM ARG 2
       MOV  WA,(XR)+         PUT BACK IN MEMORY
       BCT  WC,SAND1         LOOP OVER ALL WORDS IN STRING BLOCK
       BRN  EXITS            FETCH NEXT CODE WORD
.FI
S_ANY  ENT                   ENTRY POINT
       MOV  =P_ANS,WB        SET PCODE FOR SINGLE CHAR CASE
       MOV  =P_ANY,XL        PCODE FOR MULTI-CHAR CASE
       MOV  =P_AYD,WC        PCODE FOR EXPRESSION CASE
       JSR  PATST            CALL COMMON ROUTINE TO BUILD NODE
       ERR  059,ANY argument is not a string or expression
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CNBF
.ELSE
S_APN  ENT                   ENTRY POINT
       MOV  (XS)+,XL         GET APPEND ARGUMENT
       MOV  (XS)+,XR         GET BCBLK
       BEQ  (XR),=B_BCT,SAPN1 OK IF FIRST ARG IS BCBLK
       ERB  275,APPEND first argument is not a buffer
SAPN1  JSR  APNDB            DO THE APPEND
       ERR  276,APPEND second argument is not a string
       PPM  EXFAL            NO ROOM - FAIL
       BRN  EXNUL            EXIT WITH NULL RESULT
.FI
S_APP  ENT                   ENTRY POINT
       BZE  WA,SAPP3         JUMP IF NO ARGUMENTS
       DCV  WA               ELSE GET APPLIED FUNC ARG COUNT
       MOV  WA,WB            COPY
       WTB  WB               CONVERT TO BYTES
       MOV  XS,XT            COPY STACK POINTER
       ADD  WB,XT            POINT TO FUNCTION ARGUMENT ON STACK
       MOV  (XT),XR          LOAD FUNCTION PTR (APPLY 1ST ARG)
       BZE  WA,SAPP2         JUMP IF NO ARGS FOR APPLIED FUNC
       LCT  WB,WA            ELSE SET COUNTER FOR LOOP
SAPP1  DCA  XT               POINT TO NEXT ARGUMENT
       MOV  (XT),NUM01(XT)   MOVE ARGUMENT UP
       BCT  WB,SAPP1         LOOP TILL ALL MOVED
SAPP2  ICA  XS               ADJUST STACK PTR FOR APPLY 1ST ARG
       JSR  GTNVR            GET VARIABLE BLOCK ADDR FOR FUNC
       PPM  SAPP3            JUMP IF NOT NATURAL VARIABLE
       MOV  VRFNC(XR),XL     ELSE POINT TO FUNCTION BLOCK
       BRN  CFUNC            GO CALL APPLIED FUNCTION
SAPP3  ERB  060,APPLY first arg is not natural variable name
S_ABN  ENT                   ENTRY POINT
       ZER  XR               SET PARM1 = 0 FOR THE MOMENT
       MOV  =P_ALT,WB        SET PCODE FOR ALTERNATIVE NODE
       JSR  PBILD            BUILD ALTERNATIVE NODE
       MOV  XR,XL            SAVE PTR TO ALTERNATIVE PATTERN
       MOV  =P_ABC,WB        PCODE FOR P_ABC
       ZER  XR               P0BLK
       JSR  PBILD            BUILD P_ABC NODE
       MOV  XL,PTHEN(XR)     PUT ALTERNATIVE NODE AS SUCCESSOR
       MOV  XL,WA            REMEMBER ALTERNATIVE NODE POINTER
       MOV  XR,XL            COPY P_ABC NODE PTR
       MOV  (XS),XR          LOAD ARBNO ARGUMENT
       MOV  WA,(XS)          STACK ALTERNATIVE NODE POINTER
       JSR  GTPAT            GET ARBNO ARGUMENT AS PATTERN
       ERR  061,ARBNO argument is not pattern
       JSR  PCONC            CONCAT ARG WITH P_ABC NODE
       MOV  XR,XL            REMEMBER PTR TO CONCD PATTERNS
       MOV  =P_ABA,WB        PCODE FOR P_ABA
       ZER  XR               P0BLK
       JSR  PBILD            BUILD P_ABA NODE
       MOV  XL,PTHEN(XR)     CONCATENATE NODES
       MOV  (XS),XL          RECALL PTR TO ALTERNATIVE NODE
       MOV  XR,PARM1(XL)     POINT ALTERNATIVE BACK TO ARGUMENT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
S_ARG  ENT                   ENTRY POINT
       JSR  GTSMI            GET SECOND ARG AS SMALL INTEGER
       ERR  062,ARG second argument is not integer
       PPM  EXFAL            FAIL IF OUT OF RANGE OR NEGATIVE
       MOV  XR,WA            SAVE ARGUMENT NUMBER
       MOV  (XS)+,XR         LOAD FIRST ARGUMENT
       JSR  GTNVR            LOCATE VRBLK
       PPM  SARG1            JUMP IF NOT NATURAL VARIABLE
       MOV  VRFNC(XR),XR     ELSE LOAD FUNCTION BLOCK POINTER
       BNE  (XR),=B_PFC,SARG1 JUMP IF NOT PROGRAM DEFINED
       BZE  WA,EXFAL         FAIL IF ARG NUMBER IS ZERO
       BGT  WA,FARGS(XR),EXFAL FAIL IF ARG NUMBER IS TOO LARGE
       WTB  WA               ELSE CONVERT TO BYTE OFFSET
       ADD  WA,XR            POINT TO ARGUMENT SELECTED
       MOV  PFAGB(XR),XR     LOAD ARGUMENT VRBLK POINTER
       BRN  EXVNM            EXIT TO BUILD NMBLK
SARG1  ERB  063,ARG first argument is not program function name
S_ARR  ENT                   ENTRY POINT
       MOV  (XS)+,XL         LOAD INITIAL ELEMENT VALUE
       MOV  (XS)+,XR         LOAD FIRST ARGUMENT
       JSR  GTINT            CONVERT FIRST ARG TO INTEGER
       PPM  SAR02            JUMP IF NOT INTEGER
       LDI  ICVAL(XR)        LOAD INTEGER VALUE
       ILE  SAR10            JUMP IF ZERO OR NEG (BAD DIMENSION)
       MFI  WA,SAR11         ELSE CONVERT TO ONE WORD, TEST OVFL
       JSR  VMAKE            CREATE VECTOR
       PPM  SAR11            FAIL IF TOO LARGE
       BRN  EXSID            EXIT SETTING IDVAL
SAR02  MOV  XR,-(XS)         REPLACE ARGUMENT ON STACK
       JSR  XSCNI            INITIALIZE SCAN OF FIRST ARGUMENT
       ERR  064,ARRAY first argument is not integer or string
       PPM  EXNUL            DUMMY (UNUSED) NULL STRING EXIT
       MOV  R_XSC,-(XS)      SAVE PROTOTYPE POINTER
       MOV  XL,-(XS)         SAVE DEFAULT VALUE
       ZER  ARCDM            ZERO COUNT OF DIMENSIONS
       ZER  ARPTR            ZERO OFFSET TO INDICATE PASS ONE
       LDI  INTV1            LOAD INTEGER ONE
       STI  ARNEL            INITIALIZE ELEMENT COUNT
SAR03  LDI  INTV1            LOAD ONE AS DEFAULT LOW BOUND
       STI  ARSVL            SAVE AS LOW BOUND
       MOV  =CH_CL,WC        SET DELIMITER ONE = COLON
       MOV  =CH_CM,XL        SET DELIMITER TWO = COMMA
       ZER  WA               RETAIN BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN NEXT BOUND
       BNE  WA,=NUM01,SAR04  JUMP IF NOT COLON
       JSR  GTINT            CONVERT LOW BOUND
       ERR  065,ARRAY first argument lower bound is not integer
       LDI  ICVAL(XR)        LOAD VALUE OF LOW BOUND
       STI  ARSVL            STORE LOW BOUND VALUE
       MOV  =CH_CM,WC        SET DELIMITER ONE = COMMA
       MOV  WC,XL            AND DELIMITER TWO = COMMA
       ZER  WA               RETAIN BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN HIGH BOUND
SAR04  JSR  GTINT            CONVERT HIGH BOUND TO INTEGER
       ERR  066,ARRAY first argument upper bound is not integer
       LDI  ICVAL(XR)        GET HIGH BOUND
       SBI  ARSVL            SUBTRACT LOWER BOUND
       IOV  SAR10            BAD DIMENSION IF OVERFLOW
       ILT  SAR10            BAD DIMENSION IF NEGATIVE
       ADI  INTV1            ADD 1 TO GET DIMENSION
       IOV  SAR10            BAD DIMENSION IF OVERFLOW
       MOV  ARPTR,XL         LOAD OFFSET (ALSO PASS INDICATOR)
       BZE  XL,SAR05         JUMP IF FIRST PASS
       ADD  (XS),XL          POINT TO CURRENT LOCATION IN ARBLK
       STI  CFP_I(XL)        STORE DIMENSION
       LDI  ARSVL            LOAD LOW BOUND
       STI  (XL)             STORE LOW BOUND
       ADD  *ARDMS,ARPTR     BUMP OFFSET TO NEXT BOUNDS
       BRN  SAR06            JUMP TO CHECK FOR END OF BOUNDS
SAR05  ICV  ARCDM            BUMP DIMENSION COUNT
       MLI  ARNEL            MULTIPLY DIMENSION BY COUNT SO FAR
       IOV  SAR11            TOO LARGE IF OVERFLOW
       STI  ARNEL            ELSE STORE UPDATED ELEMENT COUNT
SAR06  BNZ  WA,SAR03         LOOP BACK UNLESS END OF BOUNDS
       BNZ  ARPTR,SAR09      JUMP IF END OF PASS 2
       LDI  ARNEL            GET NUMBER OF ELEMENTS
       MFI  WB,SAR11         GET AS ADDR INTEGER, TEST OVFLO
       WTB  WB               ELSE CONVERT TO LENGTH IN BYTES
       MOV  *ARSI_,WA        SET SIZE OF STANDARD FIELDS
       LCT  WC,ARCDM         SET DIMENSION COUNT TO CONTROL LOOP
SAR07  ADD  *ARDMS,WA        ALLOW SPACE FOR ONE SET OF BOUNDS
       BCT  WC,SAR07         LOOP BACK TILL ALL ACCOUNTED FOR
       MOV  WA,XL            SAVE SIZE (=AROFS)
       ADD  WB,WA            ADD SPACE FOR ELEMENTS
       ICA  WA               ALLOW FOR ARPRO PROTOTYPE FIELD
       BGT  WA,MXLEN,SAR11   FAIL IF TOO LARGE
       JSR  ALLOC            ELSE ALLOCATE ARBLK
       MOV  (XS),WB          LOAD DEFAULT VALUE
       MOV  XR,(XS)          SAVE ARBLK POINTER
       MOV  WA,WC            SAVE LENGTH IN BYTES
       BTW  WA               CONVERT LENGTH BACK TO WORDS
       LCT  WA,WA            SET COUNTER TO CONTROL LOOP
SAR08  MOV  WB,(XR)+         SET ONE WORD
       BCT  WA,SAR08         LOOP TILL ALL SET
       MOV  (XS)+,XR         RELOAD ARBLK POINTER
       MOV  (XS),WB          LOAD PROTOTYPE
       MOV  =B_ART,(XR)      SET TYPE WORD
       MOV  WC,ARLEN(XR)     STORE LENGTH IN BYTES
       ZER  IDVAL(XR)        ZERO ID TILL WE GET IT BUILT
       MOV  XL,AROFS(XR)     SET PROTOTYPE FIELD PTR
       MOV  ARCDM,ARNDM(XR)  SET NUMBER OF DIMENSIONS
       MOV  XR,WC            SAVE ARBLK POINTER
       ADD  XL,XR            POINT TO PROTOTYPE FIELD
       MOV  WB,(XR)          STORE PROTOTYPE PTR IN ARBLK
       MOV  *ARLBD,ARPTR     SET OFFSET FOR PASS 2 BOUNDS SCAN
       MOV  WB,R_XSC         RESET STRING POINTER FOR XSCAN
       MOV  WC,(XS)          STORE ARBLK POINTER ON STACK
       ZER  XSOFS            RESET OFFSET PTR TO START OF STRING
       BRN  SAR03            JUMP BACK TO RESCAN BOUNDS
SAR09  MOV  (XS)+,XR         RELOAD POINTER TO ARBLK
       BRN  EXSID            EXIT SETTING IDVAL
SAR10  ERB  067,ARRAY dimension is zero, negative or out of range
SAR11  ERB  068,ARRAY size exceeds maximum permitted
.IF    .CMTH
S_ATN  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  301,ATAN argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       ATN                   TAKE ARCTANGENT
       BRN  EXREA            OVERFLOW, OUT OF RANGE NOT POSSIBLE
.FI
.IF    .CBSP
S_BSP  ENT                   ENTRY POINT
       JSR  IOFCB            CALL FCBLK ROUTINE
       ERR  316,BACKSPACE argument is not a suitable name
       ERR  316,BACKSPACE argument is not a suitable name
       ERR  317,BACKSPACE file does not exist
       JSR  SYSBS            CALL BACKSPACE FILE FUNCTION
       ERR  317,BACKSPACE file does not exist
       ERR  318,BACKSPACE file does not permit backspace
       ERR  319,BACKSPACE caused non-recoverable error
       BRN  EXNUL            RETURN NULL AS RESULT
.FI
.IF    .CNBF
.ELSE
S_BUF  ENT                   ENTRY POINT
       MOV  (XS)+,XL         GET INITIAL VALUE
       MOV  (XS)+,XR         GET REQUESTED ALLOCATION
       JSR  GTINT            CONVERT TO INTEGER
       ERR  269,BUFFER first argument is not integer
       LDI  ICVAL(XR)        GET VALUE
       ILE  SBF01            BRANCH IF NEGATIVE OR ZERO
       MFI  WA,SBF02         MOVE WITH OVERFLOW CHECK
       JSR  ALOBF            ALLOCATE THE BUFFER
       JSR  APNDB            COPY IT IN
       ERR  270,BUFFER second argument is not a string or buffer
       ERR  271,BUFFER initial value too big for allocation
       BRN  EXSID            EXIT SETTING IDVAL
SBF01  ERB  272,BUFFER first argument is not positive
SBF02  ERB  273,BUFFER size exceeds value of MAXLNGTH keyword
.FI
S_BRK  ENT                   ENTRY POINT
       MOV  =P_BKS,WB        SET PCODE FOR SINGLE CHAR CASE
       MOV  =P_BRK,XL        PCODE FOR MULTI-CHAR CASE
       MOV  =P_BKD,WC        PCODE FOR EXPRESSION CASE
       JSR  PATST            CALL COMMON ROUTINE TO BUILD NODE
       ERR  069,BREAK argument is not a string or expression
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_BKX  ENT                   ENTRY POINT
       MOV  =P_BKS,WB        PCODE FOR SINGLE CHAR ARGUMENT
       MOV  =P_BRK,XL        PCODE FOR MULTI-CHAR ARGUMENT
       MOV  =P_BXD,WC        PCODE FOR EXPRESSION CASE
       JSR  PATST            CALL COMMON ROUTINE TO BUILD NODE
       ERR  070,BREAKX argument is not a string or expression
       MOV  XR,-(XS)         SAVE PTR TO BREAK NODE
       MOV  =P_BKX,WB        SET PCODE FOR BREAKX NODE
       JSR  PBILD            BUILD IT
       MOV  (XS),PTHEN(XR)   SET BREAK NODE AS SUCCESSOR
       MOV  =P_ALT,WB        SET PCODE FOR ALTERNATION NODE
       JSR  PBILD            BUILD (PARM1=ALT=BREAKX NODE)
       MOV  XR,WA            SAVE PTR TO ALTERNATION NODE
       MOV  (XS),XR          POINT TO BREAK NODE
       MOV  WA,PTHEN(XR)     SET ALTERNATE NODE AS SUCCESSOR
       LCW  XR               RESULT ON STACK
       BRI  (XR)             EXECUTE NEXT CODE WORD
S_CHR  ENT                   ENTRY POINT
       JSR  GTSMI            CONVERT ARG TO INTEGER
       ERR  281,CHAR argument not integer
       PPM  SCHR1            TOO BIG ERROR EXIT
       BGE  WC,=CFP_A,SCHR1  SEE IF OUT OF RANGE OF HOST SET
       MOV  =NUM01,WA        IF NOT SET SCBLK ALLOCATION
       MOV  WC,WB            SAVE CHAR CODE
       JSR  ALOCS            ALLOCATE 1 BAU SCBLK
       MOV  XR,XL            COPY SCBLK POINTER
       PSC  XL               GET SET TO STUFF CHAR
       SCH  WB,(XL)          STUFF IT
       CSC  XL               COMPLETE STORE CHARACTER
       ZER  XL               CLEAR SLOP IN XL
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SCHR1  ERB  282,CHAR argument not in range
.IF    .CMTH
S_CHP  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  302,CHOP argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       CHP                   TRUNCATE TO INTEGER VALUED REAL
       BRN  EXREA            NO OVERFLOW POSSIBLE
.FI
S_CLR  ENT                   ENTRY POINT
       JSR  XSCNI            INITIALIZE TO SCAN ARGUMENT
       ERR  071,CLEAR argument is not a string
       PPM  SCLR2            JUMP IF NULL
SCLR1  MOV  =CH_CM,WC        SET DELIMITER ONE = COMMA
       MOV  WC,XL            DELIMITER TWO = COMMA
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN NEXT VARIABLE NAME
       JSR  GTNVR            LOCATE VRBLK
       ERR  072,CLEAR argument has null variable name
       ZER  VRGET(XR)        ELSE FLAG BY ZEROING VRGET FIELD
       BNZ  WA,SCLR1         LOOP BACK IF STOPPED BY COMMA
SCLR2  MOV  HSHTB,WB         POINT TO START OF HASH TABLE
SCLR3  BEQ  WB,HSHTE,EXNUL   EXIT RETURNING NULL IF NONE LEFT
       MOV  WB,XR            ELSE COPY SLOT POINTER
       ICA  WB               BUMP SLOT POINTER
       SUB  *VRNXT,XR        SET OFFSET TO MERGE INTO LOOP
SCLR4  MOV  VRNXT(XR),XR     POINT TO NEXT VRBLK ON CHAIN
       BZE  XR,SCLR3         JUMP FOR NEXT BUCKET IF CHAIN END
       BNZ  VRGET(XR),SCLR5  JUMP IF NOT FLAGGED
       JSR  SETVR            FOR FLAGGED VAR, RESTORE VRGET
       BRN  SCLR4            AND LOOP BACK FOR NEXT VRBLK
SCLR5  BEQ  VRSTO(XR),=B_VRE,SCLR4 CHECK FOR PROTECTED VARIABLE
       MOV  XR,XL            COPY VRBLK POINTER
SCLR6  MOV  XL,WA            SAVE BLOCK POINTER
       MOV  VRVAL(XL),XL     LOAD NEXT VALUE FIELD
       BEQ  (XL),=B_TRT,SCLR6 LOOP BACK IF TRAPPED
       MOV  WA,XL            RESTORE BLOCK POINTER
       MOV  =NULLS,VRVAL(XL) STORE NULL CONSTANT VALUE
       BRN  SCLR4            LOOP BACK FOR NEXT VRBLK
S_COD  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       JSR  GTCOD            CONVERT TO CODE
       PPM  EXFAL            FAIL IF CONVERSION IS IMPOSSIBLE
       MOV  XR,-(XS)         STACK RESULT
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_COL  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       JSR  GTINT            CONVERT TO INTEGER
       ERR  073,COLLECT argument is not integer
       LDI  ICVAL(XR)        LOAD COLLECT ARGUMENT
       STI  CLSVI            SAVE COLLECT ARGUMENT
       ZER  WB               SET NO MOVE UP
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
.IF    .CSED
       ZER  DNAMS            COLLECT SEDIMENT TOO
       JSR  GBCOL            PERFORM GARBAGE COLLECTION
       MOV  XR,DNAMS         RECORD NEW SEDIMENT SIZE
.ELSE
       JSR  GBCOL            PERFORM GARBAGE COLLECTION
.FI
       MOV  DNAME,WA         POINT TO END OF MEMORY
       SUB  DNAMP,WA         SUBTRACT NEXT LOCATION
       BTW  WA               CONVERT BYTES TO WORDS
       MTI  WA               CONVERT WORDS AVAILABLE AS INTEGER
       SBI  CLSVI            SUBTRACT ARGUMENT
       IOV  EXFAL            FAIL IF OVERFLOW
       ILT  EXFAL            FAIL IF NOT ENOUGH
       ADI  CLSVI            ELSE RECOMPUTE AVAILABLE
       BRN  EXINT            AND EXIT WITH INTEGER RESULT
.IF    .C370
S_CMP  ENT                   ENTRY POINT
       ZER  WB               SIGNAL ONE ARGUMENT
       JSR  SBOOL            CALL STRING BOOLEAN ROUTINE
       PPM                   ONLY ONE ARGUMENT, CANNOT GET HERE
       ERR  xxx,COMPL argument is not a string
       PPM                   CANNOT HAVE TWO STRINGS UNEQUAL
       PPM  EXITS            NULL STRING ARGUMENT
       LCT  WC,WA            PREPARE COUNT
       PLC  XL               PREPARE TO LOAD CHARS FROM (XL)
       PSC  XR               PREPARE TO STORE CHARS INTO (XR)
SCMP1  LCH  WA,(XL)+         GET NEXT CHAR FROM ARG 1
       CMB  WA               COMPLEMENT
       SCH  WA,(XR)+         STORE INTO RESULT
       BCT  WC,SCMP1         LOOP OVER ALL CHARS IN STRING BLOCK
       CSC                   COMPLETE STORE CHARACTER
       BRN  EXITS            FETCH NEXT CODE WORD.
.FI
S_CNV  ENT                   ENTRY POINT
       JSR  GTSTG            CONVERT SECOND ARGUMENT TO STRING
       PPM  SCV29            ERROR IF SECOND ARGUMENT NOT STRING
       BZE  WA,SCV29         OR IF NULL STRING
.IF    .CULC
       JSR  FLSTG            FOLD LOWER CASE TO UPPER CASE
.FI
       MOV  (XS),XL          LOAD FIRST ARGUMENT
       BNE  (XL),=B_PDT,SCV01 JUMP IF NOT PROGRAM DEFINED
       MOV  PDDFP(XL),XL     POINT TO DFBLK
       MOV  DFNAM(XL),XL     LOAD DATATYPE NAME
       JSR  IDENT            COMPARE WITH SECOND ARG
       PPM  EXITS            EXIT IF IDENT WITH ARG AS RESULT
       BRN  EXFAL            ELSE FAIL
SCV01  MOV  XR,-(XS)         SAVE STRING ARGUMENT
       MOV  =SVCTB,XL        POINT TO TABLE OF NAMES TO COMPARE
       ZER  WB               INITIALIZE COUNTER
       MOV  WA,WC            SAVE LENGTH OF ARGUMENT STRING
SCV02  MOV  (XL)+,XR         LOAD NEXT TABLE ENTRY, BUMP POINTER
       BZE  XR,EXFAL         FAIL IF ZERO MARKING END OF LIST
       BNE  WC,SCLEN(XR),SCV05 JUMP IF WRONG LENGTH
       MOV  XL,CNVTP         ELSE STORE TABLE POINTER
       PLC  XR               POINT TO CHARS OF TABLE ENTRY
       MOV  (XS),XL          LOAD POINTER TO STRING ARGUMENT
       PLC  XL               POINT TO CHARS OF STRING ARG
       MOV  WC,WA            SET NUMBER OF CHARS TO COMPARE
       CMC  SCV04,SCV04      COMPARE, JUMP IF NO MATCH
SCV03  MOV  WB,XL            COPY ENTRY NUMBER
       ICA  XS               POP STRING ARG OFF STACK
       MOV  (XS)+,XR         LOAD FIRST ARGUMENT
       BSW  XL,CNVTT         JUMP TO APPROPRIATE ROUTINE
       IFF  0,SCV06          STRING
       IFF  1,SCV07          INTEGER
       IFF  2,SCV09          NAME
       IFF  3,SCV10          PATTERN
       IFF  4,SCV11          ARRAY
       IFF  5,SCV19          TABLE
       IFF  6,SCV25          EXPRESSION
       IFF  7,SCV26          CODE
       IFF  8,SCV27          NUMERIC
.IF    .CNRA
.ELSE
       IFF  CNVRT,SCV08      REAL
.FI
.IF    .CNBF
.ELSE
       IFF  CNVBT,SCV28      BUFFER
.FI
       ESW                   END OF SWITCH TABLE
SCV04  MOV  CNVTP,XL         RESTORE TABLE POINTER, MERGE
SCV05  ICV  WB               BUMP ENTRY NUMBER
       BRN  SCV02            LOOP BACK TO CHECK NEXT ENTRY
SCV06  MOV  XR,-(XS)         REPLACE STRING ARGUMENT ON STACK
       JSR  GTSTG            CONVERT TO STRING
       PPM  EXFAL            FAIL IF CONVERSION NOT POSSIBLE
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SCV07  JSR  GTINT            CONVERT TO INTEGER
       PPM  EXFAL            FAIL IF CONVERSION NOT POSSIBLE
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CNRA
.ELSE
SCV08  JSR  GTREA            CONVERT TO REAL
       PPM  EXFAL            FAIL IF CONVERSION NOT POSSIBLE
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.FI
SCV09  BEQ  (XR),=B_NML,EXIXR RETURN IF ALREADY A NAME
       JSR  GTNVR            ELSE TRY STRING TO NAME CONVERT
       PPM  EXFAL            FAIL IF CONVERSION NOT POSSIBLE
       BRN  EXVNM            ELSE EXIT BUILDING NMBLK FOR VRBLK
SCV10  JSR  GTPAT            CONVERT TO PATTERN
       PPM  EXFAL            FAIL IF CONVERSION NOT POSSIBLE
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SCV11  MOV  XR,-(XS)         SAVE ARGUMENT ON STACK
       ZER  WA               USE TABLE CHAIN BLOCK ADDRESSES
       JSR  GTARR            GET AN ARRAY
       PPM  EXFAL            FAIL IF EMPTY TABLE
       PPM  EXFAL            FAIL IF NOT CONVERTIBLE
       MOV  (XS)+,XL         RELOAD ORIGINAL ARG
       BNE  (XL),=B_TBT,EXSID EXIT IF ORIGINAL NOT A TABLE
       MOV  XR,-(XS)         SORT THE INTERMEDIATE ARRAY
       MOV  =NULLS,-(XS)     ON FIRST COLUMN
       ZER  WA               SORT ASCENDING
       JSR  SORTA            DO SORT
       PPM  EXFAL            IF SORT FAILS, SO SHALL WE
       MOV  XR,WB            SAVE ARRAY RESULT
       LDI  ARDIM(XR)        LOAD DIM 1 (NUMBER OF ELEMENTS)
       MFI  WA               GET AS ONE WORD INTEGER
       LCT  WA,WA            COPY TO CONTROL LOOP
       ADD  *ARVL2,XR        POINT TO FIRST ELEMENT IN ARRAY
SCV12  MOV  (XR),XL          GET TEBLK ADDRESS
       MOV  TESUB(XL),(XR)+  REPLACE WITH SUBSCRIPT
       MOV  TEVAL(XL),(XR)+  REPLACE WITH VALUE
       BCT  WA,SCV12         LOOP TILL ALL COPIED OVER
       MOV  WB,XR            RETRIEVE ARRAY ADDRESS
       BRN  EXSID            EXIT SETTING ID FIELD
SCV19  MOV  (XR),WA          LOAD FIRST WORD OF BLOCK
       MOV  XR,-(XS)         REPLACE ARBLK POINTER ON STACK
       BEQ  WA,=B_TBT,EXITS  RETURN ARG IF ALREADY A TABLE
       BNE  WA,=B_ART,EXFAL  ELSE FAIL IF NOT AN ARRAY
       BNE  ARNDM(XR),=NUM02,EXFAL FAIL IF NOT 2-DIM ARRAY
       LDI  ARDM2(XR)        LOAD DIM 2
       SBI  INTV2            SUBTRACT 2 TO COMPARE
       INE  EXFAL            FAIL IF DIM2 NOT 2
       LDI  ARDIM(XR)        LOAD DIM 1 (NUMBER OF ELEMENTS)
       MFI  WA               GET AS ONE WORD INTEGER
       LCT  WB,WA            COPY TO CONTROL LOOP
       ADD  =TBSI_,WA        ADD SPACE FOR STANDARD FIELDS
       WTB  WA               CONVERT LENGTH TO BYTES
       JSR  ALLOC            ALLOCATE SPACE FOR TBBLK
       MOV  XR,WC            COPY TBBLK POINTER
       MOV  XR,-(XS)         SAVE TBBLK POINTER
       MOV  =B_TBT,(XR)+     STORE TYPE WORD
       ZER  (XR)+            STORE ZERO FOR IDVAL FOR NOW
       MOV  WA,(XR)+         STORE LENGTH
       MOV  =NULLS,(XR)+     NULL INITIAL LOOKUP VALUE
SCV20  MOV  WC,(XR)+         SET BUCKET PTR TO POINT TO TBBLK
       BCT  WB,SCV20         LOOP TILL ALL INITIALIZED
       MOV  *ARVL2,WB        SET OFFSET TO FIRST ARBLK ELEMENT
SCV21  MOV  NUM01(XS),XL     POINT TO ARBLK
       BEQ  WB,ARLEN(XL),SCV24 JUMP IF ALL MOVED
       ADD  WB,XL            ELSE POINT TO CURRENT LOCATION
       ADD  *NUM02,WB        BUMP OFFSET
       MOV  (XL),XR          LOAD SUBSCRIPT NAME
       DCA  XL               ADJUST PTR TO MERGE (TRVAL=1+1)
SCV22  MOV  TRVAL(XL),XL     POINT TO NEXT VALUE
       BEQ  (XL),=B_TRT,SCV22 LOOP BACK IF TRAPPED
SCV23  MOV  XL,-(XS)         STACK VALUE
       MOV  NUM01(XS),XL     LOAD TBBLK POINTER
       JSR  TFIND            BUILD TEBLK (NOTE WB GT 0 BY NAME)
       PPM  EXFAL            FAIL IF ACESS FAILS
       MOV  (XS)+,TEVAL(XL)  STORE VALUE IN TEBLK
       BRN  SCV21            LOOP BACK FOR NEXT ELEMENT
SCV24  MOV  (XS)+,XR         LOAD TBBLK POINTER
       ICA  XS               POP ARBLK POINTER
       BRN  EXSID            EXIT SETTING IDVAL
.IF    .CEVB
SCV25  ZER  WB               BY VALUE
       JSR  GTEXP            CONVERT TO EXPRESSION
.ELSE
SCV25  JSR  GTEXP            CONVERT TO EXPRESSION
.FI
       PPM  EXFAL            FAIL IF CONVERSION NOT POSSIBLE
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SCV26  JSR  GTCOD            CONVERT TO CODE
       PPM  EXFAL            FAIL IF CONVERSION IS NOT POSSIBLE
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SCV27  JSR  GTNUM            CONVERT TO NUMERIC
       PPM  EXFAL            FAIL IF UNCONVERTIBLE
SCV31  MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CNBF
.ELSE
SCV28  MOV  XR,-(XS)         STACK FIRST ARG FOR PROCEDURE
       JSR  GTSTB            GET STRING OR BUFFER
       PPM  EXFAL            FAIL IF CONVERSION NOT POSSIBLE
       BNZ  WB,SCV30         JUMP IF ALREADY A BUFFER
       MOV  XR,XL            SAVE STRING POINTER
       JSR  ALOBF            ALLOCATE BUFFER OF SAME SIZE
       JSR  APNDB            COPY IN THE STRING
       PPM                   ALREADY STRING - CANT FAIL TO CNV
       PPM                   MUST BE ENOUGH ROOM
       BRN  EXSID            EXIT SETTING IDVAL FIELD
SCV30  MOV  WB,XR            RETURN BUFFER WITHOUT CONVERSION
       BRN  SCV31            MERGE TO RETURN RESULT
.FI
SCV29  ERB  074,CONVERT second argument is not a string
S_COP  ENT                   ENTRY POINT
       JSR  COPYB            COPY THE BLOCK
       PPM  EXITS            RETURN IF NO IDVAL FIELD
       BRN  EXSID            EXIT SETTING ID VALUE
.IF    .CMTH
S_COS  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  303,COS argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       COS                   TAKE COSINE
       RNO  EXREA            IF NO OVERFLOW, RETURN RESULT IN RA
       ERB  322,COS argument is out of range
.FI
S_DAT  ENT                   ENTRY POINT
       JSR  XSCNI            PREPARE TO SCAN ARGUMENT
       ERR  075,DATA argument is not a string
       ERR  076,DATA argument is null
       MOV  =CH_PP,WC        DELIMITER ONE = LEFT PAREN
       MOV  WC,XL            DELIMITER TWO = LEFT PAREN
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN DATATYPE NAME
       BNZ  WA,SDAT1         SKIP IF LEFT PAREN FOUND
       ERB  077,DATA argument is missing a left paren
.IF    .CULC
SDAT1  MOV  SCLEN(XR),WA     GET LENGTH
       BZE  WA,SDT1A         AVOID FOLDING IF NULL STRING
       JSR  FLSTG            FOLD LOWER CASE TO UPPER CASE
SDT1A  MOV  XR,XL            SAVE NAME PTR
.ELSE
SDAT1  MOV  XR,XL            SAVE NAME PTR
.FI
       MOV  SCLEN(XR),WA     GET LENGTH
       CTB  WA,SCSI_         COMPUTE SPACE NEEDED
       JSR  ALOST            REQUEST STATIC STORE FOR NAME
       MOV  XR,-(XS)         SAVE DATATYPE NAME
       MVW                   COPY NAME TO STATIC
       MOV  (XS),XR          GET NAME PTR
       ZER  XL               SCRUB DUD REGISTER
       JSR  GTNVR            LOCATE VRBLK FOR DATATYPE NAME
       ERR  078,DATA argument has null datatype name
       MOV  XR,DATDV         SAVE VRBLK POINTER FOR DATATYPE
       MOV  XS,DATXS         STORE STARTING STACK VALUE
       ZER  WB               ZERO COUNT OF FIELD NAMES
SDAT2  MOV  =CH_RP,WC        DELIMITER ONE = RIGHT PAREN
       MOV  =CH_CM,XL        DELIMITER TWO = COMMA
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN NEXT FIELD NAME
       BNZ  WA,SDAT3         JUMP IF DELIMITER FOUND
       ERB  079,DATA argument is missing a right paren
SDAT3  JSR  GTNVR            LOCATE VRBLK FOR FIELD NAME
       ERR  080,DATA argument has null field name
       MOV  XR,-(XS)         STACK VRBLK POINTER
       ICV  WB               INCREMENT COUNTER
       BEQ  WA,=NUM02,SDAT2  LOOP BACK IF STOPPED BY COMMA
       MOV  =DFSI_,WA        SET SIZE OF DFBLK STANDARD FIELDS
       ADD  WB,WA            ADD NUMBER OF FIELDS
       WTB  WA               CONVERT LENGTH TO BYTES
       MOV  WB,WC            PRESERVE NO. OF FIELDS
       JSR  ALOST            ALLOCATE SPACE FOR DFBLK
       MOV  WC,WB            GET NO OF FIELDS
       MOV  DATXS,XT         POINT TO START OF STACK
       MOV  (XT),WC          LOAD DATATYPE NAME
       MOV  XR,(XT)          SAVE DFBLK POINTER ON STACK
       MOV  =B_DFC,(XR)+     STORE TYPE WORD
       MOV  WB,(XR)+         STORE NUMBER OF FIELDS (FARGS)
       MOV  WA,(XR)+         STORE LENGTH (DFLEN)
       SUB  *PDDFS,WA        COMPUTE PDBLK LENGTH (FOR DFPDL)
       MOV  WA,(XR)+         STORE PDBLK LENGTH (DFPDL)
       MOV  WC,(XR)+         STORE DATATYPE NAME (DFNAM)
       LCT  WC,WB            COPY NUMBER OF FIELDS
SDAT4  MOV  -(XT),(XR)+      MOVE ONE FIELD NAME VRBLK POINTER
       BCT  WC,SDAT4         LOOP TILL ALL MOVED
       MOV  WA,WC            COPY LENGTH OF PDBLK FOR LATER LOOP
       MOV  DATDV,XR         POINT TO VRBLK
       MOV  DATXS,XT         POINT BACK ON STACK
       MOV  (XT),XL          LOAD DFBLK POINTER
       JSR  DFFNC            DEFINE FUNCTION
SDAT5  MOV  *FFSI_,WA        SET LENGTH OF FFBLK
       JSR  ALLOC            ALLOCATE SPACE FOR FFBLK
       MOV  =B_FFC,(XR)      SET TYPE WORD
       MOV  =NUM01,FARGS(XR) STORE FARGS (ALWAYS ONE)
       MOV  DATXS,XT         POINT BACK ON STACK
       MOV  (XT),FFDFP(XR)   COPY DFBLK PTR TO FFBLK
       DCA  WC               DECREMENT OLD DFPDL TO GET NEXT OFS
       MOV  WC,FFOFS(XR)     SET OFFSET TO THIS FIELD
       ZER  FFNXT(XR)        TENTATIVELY SET ZERO FORWARD PTR
       MOV  XR,XL            COPY FFBLK POINTER FOR DFFNC
       MOV  (XS),XR          LOAD VRBLK POINTER FOR FIELD
       MOV  VRFNC(XR),XR     LOAD CURRENT FUNCTION POINTER
       BNE  (XR),=B_FFC,SDAT6 SKIP IF NOT CURRENTLY A FIELD FUNC
       MOV  XR,FFNXT(XL)     LINK NEW FFBLK TO PREVIOUS CHAIN
SDAT6  MOV  (XS)+,XR         LOAD VRBLK POINTER
       JSR  DFFNC            DEFINE FIELD FUNCTION
       BNE  XS,DATXS,SDAT5   LOOP BACK TILL ALL DONE
       ICA  XS               POP DFBLK POINTER
       BRN  EXNUL            RETURN WITH NULL RESULT
S_DTP  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       JSR  DTYPE            GET DATATYPE
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_DTE  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       JSR  GTINT            CONVERT TO AN INTEGER
       ERR  330,DATE argument is not integer
       JSR  SYSDT            CALL SYSTEM DATE ROUTINE
       MOV  NUM01(XL),WA     LOAD LENGTH FOR SBSTR
       BZE  WA,EXNUL         RETURN NULL IF LENGTH IS ZERO
       ZER  WB               SET ZERO OFFSET
       JSR  SBSTR            USE SBSTR TO BUILD SCBLK
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_DEF  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD SECOND ARGUMENT
       ZER  DEFLB            ZERO LABEL POINTER IN CASE NULL
       BEQ  XR,=NULLS,SDF01  JUMP IF NULL SECOND ARGUMENT
       JSR  GTNVR            ELSE FIND VRBLK FOR LABEL
       PPM  SDF12            JUMP IF NOT A VARIABLE NAME
       MOV  XR,DEFLB         ELSE SET SPECIFIED ENTRY
SDF01  JSR  XSCNI            PREPARE TO SCAN FIRST ARGUMENT
       ERR  081,DEFINE first argument is not a string
       ERR  082,DEFINE first argument is null
       MOV  =CH_PP,WC        DELIMITER ONE = LEFT PAREN
       MOV  WC,XL            DELIMITER TWO = LEFT PAREN
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN OUT FUNCTION NAME
       BNZ  WA,SDF02         JUMP IF LEFT PAREN FOUND
       ERB  083,DEFINE first argument is missing a left paren
SDF02  JSR  GTNVR            GET VARIABLE NAME
       ERR  084,DEFINE first argument has null function name
       MOV  XR,DEFVR         SAVE VRBLK POINTER FOR FUNCTION NAM
       ZER  WB               ZERO COUNT OF ARGUMENTS
       MOV  XS,DEFXS         SAVE INITIAL STACK POINTER
       BNZ  DEFLB,SDF03      JUMP IF SECOND ARGUMENT GIVEN
       MOV  XR,DEFLB         ELSE DEFAULT IS FUNCTION NAME
SDF03  MOV  =CH_RP,WC        DELIMITER ONE = RIGHT PAREN
       MOV  =CH_CM,XL        DELIMITER TWO = COMMA
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN OUT NEXT ARGUMENT NAME
       BNZ  WA,SDF04         SKIP IF DELIMITER FOUND
       ERB  085,Null arg name or missing ) in DEFINE first arg.
SDF04  BNE  XR,=NULLS,SDF05  SKIP IF NON-NULL
       BZE  WB,SDF06         IGNORE NULL IF CASE OF NO ARGUMENTS
SDF05  JSR  GTNVR            GET VRBLK POINTER
       PPM  SDF03            LOOP BACK TO IGNORE NULL NAME
       MOV  XR,-(XS)         STACK ARGUMENT VRBLK POINTER
       ICV  WB               INCREMENT COUNTER
       BEQ  WA,=NUM02,SDF03  LOOP BACK IF STOPPED BY A COMMA
SDF06  MOV  WB,DEFNA         SAVE NUMBER OF ARGUMENTS
       ZER  WB               ZERO COUNT OF LOCALS
SDF07  MOV  =CH_CM,WC        SET DELIMITER ONE = COMMA
       MOV  WC,XL            SET DELIMITER TWO = COMMA
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN OUT NEXT LOCAL NAME
       BNE  XR,=NULLS,SDF08  SKIP IF NON-NULL
       BZE  WA,SDF09         EXIT SCAN IF END OF STRING
SDF08  JSR  GTNVR            GET VRBLK POINTER
       PPM  SDF07            LOOP BACK TO IGNORE NULL NAME
       ICV  WB               IF OK, INCREMENT COUNT
       MOV  XR,-(XS)         STACK VRBLK POINTER
       BNZ  WA,SDF07         LOOP BACK IF STOPPED BY A COMMA
SDF09  MOV  WB,WA            COPY COUNT OF LOCALS
       ADD  DEFNA,WA         ADD NUMBER OF ARGUMENTS
       MOV  WA,WC            SET SUM ARGS+LOCALS AS LOOP COUNT
       ADD  =PFSI_,WA        ADD SPACE FOR STANDARD FIELDS
       WTB  WA               CONVERT LENGTH TO BYTES
       JSR  ALLOC            ALLOCATE SPACE FOR PFBLK
       MOV  XR,XL            SAVE POINTER TO PFBLK
       MOV  =B_PFC,(XR)+     STORE FIRST WORD
       MOV  DEFNA,(XR)+      STORE NUMBER OF ARGUMENTS
       MOV  WA,(XR)+         STORE LENGTH (PFLEN)
       MOV  DEFVR,(XR)+      STORE VRBLK PTR FOR FUNCTION NAME
       MOV  WB,(XR)+         STORE NUMBER OF LOCALS
       ZER  (XR)+            DEAL WITH LABEL LATER
       ZER  (XR)+            ZERO PFCTR
       ZER  (XR)+            ZERO PFRTR
       BZE  WC,SDF11         SKIP IF NO ARGS OR LOCALS
       MOV  XL,WA            KEEP PFBLK POINTER
       MOV  DEFXS,XT         POINT BEFORE ARGUMENTS
       LCT  WC,WC            GET COUNT OF ARGS+LOCALS FOR LOOP
SDF10  MOV  -(XT),(XR)+      STORE ONE ENTRY AND BUMP POINTERS
       BCT  WC,SDF10         LOOP TILL ALL STORED
       MOV  WA,XL            RECOVER PFBLK POINTER
SDF11  MOV  DEFXS,XS         POP STACK
       MOV  DEFLB,PFCOD(XL)  STORE LABEL VRBLK IN PFBLK
       MOV  DEFVR,XR         POINT BACK TO VRBLK FOR FUNCTION
       JSR  DFFNC            DEFINE FUNCTION
       BRN  EXNUL            AND EXIT RETURNING NULL
SDF12  ERB  086,DEFINE function entry point is not defined label
S_DET  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       JSR  GTVAR            LOCATE VARIABLE
       ERR  087,DETACH argument is not appropriate name
       JSR  DTACH            DETACH I/O ASSOCIATION FROM NAME
       BRN  EXNUL            RETURN NULL RESULT
S_DIF  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD SECOND ARGUMENT
       MOV  (XS)+,XL         LOAD FIRST ARGUMENT
       JSR  IDENT            CALL IDENT COMPARISON ROUTINE
       PPM  EXFAL            FAIL IF IDENT
       BRN  EXNUL            RETURN NULL IF DIFFER
S_DMP  ENT                   ENTRY POINT
       JSR  GTSMI            LOAD DUMP ARG AS SMALL INTEGER
       ERR  088,DUMP argument is not integer
       ERR  089,DUMP argument is negative or too large
       JSR  DUMPR            ELSE CALL DUMP ROUTINE
       BRN  EXNUL            AND RETURN NULL AS RESULT
S_DUP  ENT                   ENTRY POINT
       JSR  GTSMI            GET SECOND ARGUMENT AS SMALL INTEGR
       ERR  090,DUPL second argument is not integer
       PPM  SDUP7            JUMP IF NEGATIVE OR TOO BIG
       MOV  XR,WB            SAVE DUPLICATION FACTOR
       JSR  GTSTG            GET FIRST ARG AS STRING
       PPM  SDUP4            JUMP IF NOT A STRING
       MTI  WA               ACQUIRE LENGTH AS INTEGER
       STI  DUPSI            SAVE FOR THE MOMENT
       MTI  WB               GET DUPLICATION FACTOR AS INTEGER
       MLI  DUPSI            FORM PRODUCT
       IOV  SDUP3            JUMP IF OVERFLOW
       IEQ  EXNUL            RETURN NULL IF RESULT LENGTH = 0
       MFI  WA,SDUP3         GET AS ADDR INTEGER, CHECK OVFLO
SDUP1  MOV  XR,XL            SAVE STRING POINTER
       JSR  ALOCS            ALLOCATE SPACE FOR STRING
       MOV  XR,-(XS)         SAVE AS RESULT POINTER
       MOV  XL,WC            SAVE POINTER TO ARGUMENT STRING
       PSC  XR               PREPARE TO STORE CHARS OF RESULT
       LCT  WB,WB            SET COUNTER TO CONTROL LOOP
SDUP2  MOV  WC,XL            POINT BACK TO ARGUMENT STRING
       MOV  SCLEN(XL),WA     GET NUMBER OF CHARACTERS
       PLC  XL               POINT TO CHARS IN ARGUMENT STRING
       MVC                   MOVE CHARACTERS TO RESULT STRING
       BCT  WB,SDUP2         LOOP TILL ALL DUPLICATIONS DONE
       ZER  XL               CLEAR GARBAGE VALUE
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
SDUP3  MOV  DNAME,WA         SET IMPOSSIBLE LENGTH FOR ALOCS
       BRN  SDUP1            MERGE BACK
SDUP4  JSR  GTPAT            CONVERT ARGUMENT TO PATTERN
       ERR  091,DUPL first argument is not a string or pattern
       MOV  XR,-(XS)         STORE PATTERN ON STACK
       MOV  =NDNTH,XR        START OFF WITH NULL PATTERN
       BZE  WB,SDUP6         NULL PATTERN IS RESULT IF DUPFAC=0
       MOV  WB,-(XS)         PRESERVE LOOP COUNT
SDUP5  MOV  XR,XL            COPY CURRENT VALUE AS RIGHT ARGUMNT
       MOV  NUM01(XS),XR     GET A NEW COPY OF LEFT
       JSR  PCONC            CONCATENATE
       DCV  (XS)             COUNT DOWN
       BNZ  (XS),SDUP5       LOOP
       ICA  XS               POP LOOP COUNT
SDUP6  MOV  XR,(XS)          STORE RESULT ON STACK
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
SDUP7  ICA  XS               POP FIRST ARGUMENT
       BRN  EXFAL            FAIL
S_EJC  ENT                   ENTRY POINT
       JSR  IOFCB            CALL FCBLK ROUTINE
       ERR  092,EJECT argument is not a suitable name
       PPM  SEJC1            NULL ARGUMENT
       ERR  093,EJECT file does not exist
       JSR  SYSEF            CALL EJECT FILE FUNCTION
       ERR  093,EJECT file does not exist
       ERR  094,EJECT file does not permit page eject
       ERR  095,EJECT caused non-recoverable output error
       BRN  EXNUL            RETURN NULL AS RESULT
SEJC1  JSR  SYSEP            CALL ROUTINE TO EJECT PRINTER
       BRN  EXNUL            EXIT WITH NULL RESULT
S_ENF  ENT                   ENTRY POINT
       JSR  IOFCB            CALL FCBLK ROUTINE
       ERR  096,ENDFILE argument is not a suitable name
       ERR  097,ENDFILE argument is null
       ERR  098,ENDFILE file does not exist
       JSR  SYSEN            CALL ENDFILE ROUTINE
       ERR  098,ENDFILE file does not exist
       ERR  099,ENDFILE file does not permit endfile
       ERR  100,ENDFILE caused non-recoverable output error
       MOV  XL,WB            REMEMBER VRBLK PTR FROM IOFCB CALL
       MOV  XL,XR            COPY POINTER
SENF1  MOV  XR,XL            REMEMBER PREVIOUS ENTRY
       MOV  TRVAL(XR),XR     CHAIN ALONG
       BNE  (XR),=B_TRT,EXNUL SKIP OUT IF CHAIN END
       BNE  TRTYP(XR),=TRTFC,SENF1 LOOP IF NOT FOUND
       MOV  TRVAL(XR),TRVAL(XL) REMOVE TRTRF
       MOV  TRTRF(XR),ENFCH  POINT TO HEAD OF IOCHN
       MOV  TRFPT(XR),WC     POINT TO FCBLK
       MOV  WB,XR            FILEARG1 VRBLK FROM IOFCB
       JSR  SETVR            RESET IT
       MOV  =R_FCB,XL        PTR TO HEAD OF FCBLK CHAIN
       SUB  *NUM02,XL        ADJUST READY TO ENTER LOOP
SENF2  MOV  XL,XR            COPY PTR
       MOV  NUM02(XL),XL     GET NEXT LINK
       BZE  XL,SENF4         STOP IF CHAIN END
       BEQ  NUM03(XL),WC,SENF3 JUMP IF FCBLK FOUND
       BRN  SENF2            LOOP
SENF3  MOV  NUM02(XL),NUM02(XR) DELETE FCBLK FROM CHAIN
SENF4  MOV  ENFCH,XL         GET CHAIN HEAD
       BZE  XL,EXNUL         FINISHED IF CHAIN END
       MOV  TRTRF(XL),ENFCH  CHAIN ALONG
       MOV  IONMO(XL),WA     NAME OFFSET
       MOV  IONMB(XL),XL     NAME BASE
       JSR  DTACH            DETACH NAME
       BRN  SENF4            LOOP TILL DONE
S_EQF  ENT                   ENTRY POINT
       JSR  ACOMP            CALL ARITHMETIC COMPARISON ROUTINE
       ERR  101,EQ first argument is not numeric
       ERR  102,EQ second argument is not numeric
       PPM  EXFAL            FAIL IF LT
       PPM  EXNUL            RETURN NULL IF EQ
       PPM  EXFAL            FAIL IF GT
S_EVL  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
.IF    .CEVB
.ELSE
       JSR  GTEXP            CONVERT TO EXPRESSION
       ERR  103,EVAL argument is not expression
.FI
       LCW  WC               LOAD NEXT CODE WORD
       BNE  WC,=OFNE_,SEVL1  JUMP IF CALLED BY VALUE
       SCP  XL               COPY CODE POINTER
       MOV  (XL),WA          GET NEXT CODE WORD
       BNE  WA,=ORNM_,SEVL2  BY NAME UNLESS EXPRESSION
       BNZ  NUM01(XS),SEVL2  JUMP IF BY NAME
SEVL1  ZER  WB               SET FLAG FOR BY VALUE
.IF    .CEVB
       MOV  WC,-(XS)         SAVE CODE WORD
       JSR  GTEXP            CONVERT TO EXPRESSION
       ERR  103,EVAL argument is not expression
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
       ZER  WB               SET FLAG FOR BY VALUE
.ELSE
       MOV  WC,-(XS)         SAVE CODE WORD
.FI
       JSR  EVALX            EVALUATE EXPRESSION BY VALUE
       PPM  EXFAL            FAIL IF EVALUATION FAILS
       MOV  XR,XL            COPY RESULT
       MOV  (XS),XR          RELOAD NEXT CODE WORD
       MOV  XL,(XS)          STACK RESULT
       BRI  (XR)             JUMP TO EXECUTE NEXT CODE WORD
SEVL2  MOV  =NUM01,WB        SET FLAG FOR BY NAME
.IF    .CEVB
       JSR  GTEXP            CONVERT TO EXPRESSION
       ERR  103,EVAL argument is not expression
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
       MOV  =NUM01,WB        SET FLAG FOR BY NAME
.FI
       JSR  EVALX            EVALUATE EXPRESSION BY NAME
       PPM  EXFAL            FAIL IF EVALUATION FAILS
       BRN  EXNAM            EXIT WITH NAME
.IF    .CNEX
.ELSE
S_EXT  ENT                   ENTRY POINT
       ZER  WB               CLEAR AMOUNT OF STATIC SHIFT
       ZER  R_CCB            FORGET INTERIM CODE BLOCK
.IF    .CSED
       ZER  DNAMS            COLLECT SEDIMENT TOO
       JSR  GBCOL            COMPACT MEMORY BY COLLECTING
       MOV  XR,DNAMS         RECORD NEW SEDIMENT SIZE
.ELSE
       JSR  GBCOL            COMPACT MEMORY BY COLLECTING
.FI
       JSR  GTSTG
       ERR  288,EXIT second argument is not a string
       MOV  XR,XL            COPY SECOND ARG STRING POINTER
       JSR  GTSTG            CONVERT ARG TO STRING
       ERR  104,EXIT first argument is not suitable integer or string
       MOV  XL,-(XS)         SAVE SECOND ARGUMENT
       MOV  XR,XL            COPY FIRST ARG STRING PTR
       JSR  GTINT            CHECK IT IS INTEGER
       PPM  SEXT1            SKIP IF UNCONVERTIBLE
       ZER  XL               NOTE IT IS INTEGER
       LDI  ICVAL(XR)        GET INTEGER ARG
SEXT1  MOV  R_FCB,WB         GET FCBLK CHAIN HEADER
       MOV  =HEADV,XR        POINT TO V.V STRING
       MOV  (XS)+,WA         PROVIDE SECOND ARGUMENT SCBLK
       JSR  SYSXI            CALL EXTERNAL ROUTINE
       ERR  105,EXIT action not available in this implementation
       ERR  106,EXIT action caused irrecoverable error
       IEQ  EXNUL            RETURN IF ARGUMENT 0
       IGT  SEXT2            SKIP IF POSITIVE
       NGI                   MAKE POSITIVE
SEXT2  MFI  WC               GET VALUE IN WORK REG
       ADD  WC,WA            PREPARE TO TEST FOR CONTINUE
       BEQ  WA,=NUM05,SEXT5  CONTINUED EXECUTION IF 4 PLUS 1
       ZER  GBCNT            RESUMING EXECUTION SO RESET
       BGE  WC,=NUM03,SEXT3  SKIP IF WAS 3 OR 4
       MOV  WC,-(XS)         SAVE VALUE
       ZER  WC               SET TO READ OPTIONS
       JSR  PRPAR            READ SYSPP OPTIONS
       MOV  (XS)+,WC         RESTORE VALUE
SEXT3  MNZ  HEADP            ASSUME NO HEADERS
       BNE  WC,=NUM01,SEXT4  SKIP IF NOT 1
       ZER  HEADP            REQUEST HEADER PRINTING
SEXT4  JSR  SYSTM            GET EXECUTION TIME START (SGD11)
       STI  TIMSX            SAVE AS INITIAL TIME
       LDI  KVSTC            RESET TO ENSURE ...
       STI  KVSTL            ... CORRECT EXECUTION STATS
       JSR  STGCC            RECOMPUTE COUNTDOWN COUNTERS
       BRN  EXNUL            RESUME EXECUTION
SEXT5  MOV  =INTON,XR        INTEGER ONE
       BRN  EXIXR            RETURN AS RESULT
.FI
.IF    .CMTH
S_EXP  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  304,EXP argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       ETX                   TAKE EXPONENTIAL
       RNO  EXREA            IF NO OVERFLOW, RETURN RESULT IN RA
       ERB  305,EXP produced real overflow
.FI
S_FLD  ENT                   ENTRY POINT
       JSR  GTSMI            GET SECOND ARGUMENT (FIELD NUMBER)
       ERR  107,FIELD second argument is not integer
       PPM  EXFAL            FAIL IF OUT OF RANGE
       MOV  XR,WB            ELSE SAVE INTEGER VALUE
       MOV  (XS)+,XR         LOAD FIRST ARGUMENT
       JSR  GTNVR            POINT TO VRBLK
       PPM  SFLD1            JUMP (ERROR) IF NOT VARIABLE NAME
       MOV  VRFNC(XR),XR     ELSE POINT TO FUNCTION BLOCK
       BNE  (XR),=B_DFC,SFLD1 ERROR IF NOT DATATYPE FUNCTION
       BZE  WB,EXFAL         FAIL IF ARGUMENT NUMBER IS ZERO
       BGT  WB,FARGS(XR),EXFAL FAIL IF TOO LARGE
       WTB  WB               ELSE CONVERT TO BYTE OFFSET
       ADD  WB,XR            POINT TO FIELD NAME
       MOV  DFFLB(XR),XR     LOAD VRBLK POINTER
       BRN  EXVNM            EXIT TO BUILD NMBLK
SFLD1  ERB  108,FIELD first argument is not datatype name
S_FNC  ENT                   ENTRY POINT
       MOV  =P_FNC,WB        SET PCODE FOR P_FNC
       ZER  XR               P0BLK
       JSR  PBILD            BUILD P_FNC NODE
       MOV  XR,XL            SAVE POINTER TO IT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTPAT            CONVERT TO PATTERN
       ERR  259,FENCE argument is not pattern
       JSR  PCONC            CONCATENATE TO P_FNC NODE
       MOV  XR,XL            SAVE PTR TO CONCATENATED PATTERN
       MOV  =P_FNA,WB        SET FOR P_FNA PCODE
       ZER  XR               P0BLK
       JSR  PBILD            CONSTRUCT P_FNA NODE
       MOV  XL,PTHEN(XR)     SET PATTERN AS PTHEN
       MOV  XR,-(XS)         SET AS RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE NEXT CODE WORD
S_GEF  ENT                   ENTRY POINT
       JSR  ACOMP            CALL ARITHMETIC COMPARISON ROUTINE
       ERR  109,GE first argument is not numeric
       ERR  110,GE second argument is not numeric
       PPM  EXFAL            FAIL IF LT
       PPM  EXNUL            RETURN NULL IF EQ
       PPM  EXNUL            RETURN NULL IF GT
S_GTF  ENT                   ENTRY POINT
       JSR  ACOMP            CALL ARITHMETIC COMPARISON ROUTINE
       ERR  111,GT first argument is not numeric
       ERR  112,GT second argument is not numeric
       PPM  EXFAL            FAIL IF LT
       PPM  EXFAL            FAIL IF EQ
       PPM  EXNUL            RETURN NULL IF GT
S_HST  ENT                   ENTRY POINT
       MOV  (XS)+,WC         GET FIFTH ARG
       MOV  (XS)+,WB         GET FOURTH ARG
       MOV  (XS)+,XR         GET THIRD ARG
       MOV  (XS)+,XL         GET SECOND ARG
       MOV  (XS)+,WA         GET FIRST ARG
       JSR  SYSHS            ENTER SYSHS ROUTINE
       ERR  254,Erroneous argument for HOST
       ERR  255,Error during execution of HOST
       PPM  SHST1            STORE HOST STRING
       PPM  EXNUL            RETURN NULL RESULT
       PPM  EXIXR            RETURN XR
       PPM  EXFAL            FAIL RETURN
       PPM  SHST3            STORE ACTUAL STRING
       PPM  SHST4            RETURN COPY OF XR
SHST1  BZE  XL,EXNUL         NULL STRING IF SYSHS UNCOOPERATIVE
       MOV  SCLEN(XL),WA     LENGTH
       ZER  WB               ZERO OFFSET
SHST2  JSR  SBSTR            BUILD COPY OF STRING
       MOV  XR,-(XS)         STACK THE RESULT
       LCW  XR               LOAD NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SHST3  ZER  WB               TREAT XL LIKE AN SCBLK PTR
       SUB  =CFP_F,WB        BY CREATING A NEGATIVE OFFSET
       BRN  SHST2            JOIN TO COPY STRING
SHST4  MOV  XR,-(XS)         STACK RESULTS
       JSR  COPYB            MAKE COPY OF BLOCK
       PPM  EXITS            IF NOT AN AGGREGATE STRUCTURE
       BRN  EXSID            SET CURRENT ID VALUE OTHERWISE
S_IDN  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD SECOND ARGUMENT
       MOV  (XS)+,XL         LOAD FIRST ARGUMENT
       JSR  IDENT            CALL IDENT COMPARISON ROUTINE
       PPM  EXNUL            RETURN NULL IF IDENT
       BRN  EXFAL            FAIL IF DIFFER
S_INP  ENT                   ENTRY POINT
       ZER  WB               INPUT FLAG
       JSR  IOPUT            CALL INPUT/OUTPUT ASSOC. ROUTINE
       ERR  113,INPUT third argument is not a string
       ERR  114,Inappropriate second argument for INPUT
       ERR  115,Inappropriate first argument for INPUT
       ERR  116,Inappropriate file specification for INPUT
       PPM  EXFAL            FAIL IF FILE DOES NOT EXIST
       ERR  117,INPUT file cannot be read
       ERR  289,INPUT channel currently in use
       BRN  EXNUL            RETURN NULL STRING
.IF    .CNBF
.ELSE
S_INS  ENT                   ENTRY POINT
       MOV  (XS)+,XL         GET STRING ARG
       JSR  GTSMI            GET REPLACE LENGTH
       ERR  277,INSERT third argument not integer
       PPM  EXFAL            FAIL IF OUT OF RANGE
       MOV  WC,WB            COPY TO PROPER REG
       JSR  GTSMI            GET REPLACE POSITION
       ERR  278,INSERT second argument not integer
       PPM  EXFAL            FAIL IF OUT OF RANGE
       BZE  WC,EXFAL         FAIL IF ZERO
       DCV  WC               DECREMENT TO GET OFFSET
       MOV  WC,WA            PUT IN PROPER REGISTER
       MOV  (XS)+,XR         GET BUFFER
       BEQ  (XR),=B_BCT,SINS1 PRESS ON IF TYPE OK
       ERB  279,INSERT first argument is not a buffer
SINS1  JSR  INSBF            CALL TO INSERT
       ERR  280,INSERT fourth argument is not a string
       PPM  EXFAL            FAIL IF OUT OF RANGE
       BRN  EXNUL            ELSE OK - EXIT WITH NULL
.FI
S_INT  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       JSR  GTNUM            CONVERT TO NUMERIC
       PPM  EXFAL            FAIL IF NON-NUMERIC
       BEQ  WA,=B_ICL,EXNUL  RETURN NULL IF INTEGER
       BRN  EXFAL            FAIL IF REAL
S_ITM  ENT                   ENTRY POINT
       BNZ  WA,SITM1         JUMP IF AT LEAST ONE ARG
       MOV  =NULLS,-(XS)     ELSE SUPPLY GARBAGE NULL ARG
       MOV  =NUM01,WA        AND FIX ARGUMENT COUNT
SITM1  SCP  XR               GET CURRENT CODE POINTER
       MOV  (XR),XL          LOAD NEXT CODE WORD
       DCV  WA               GET NUMBER OF SUBSCRIPTS
       MOV  WA,XR            COPY FOR ARREF
       BEQ  XL,=OFNE_,SITM2  JUMP IF CALLED BY NAME
       ZER  WB               SET CODE FOR CALL BY VALUE
       BRN  ARREF            OFF TO ARRAY REFERENCE ROUTINE
SITM2  MNZ  WB               SET CODE FOR CALL BY NAME
       LCW  WA               LOAD AND IGNORE OFNE_ CALL
       BRN  ARREF            OFF TO ARRAY REFERENCE ROUTINE
S_LEF  ENT                   ENTRY POINT
       JSR  ACOMP            CALL ARITHMETIC COMPARISON ROUTINE
       ERR  118,LE first argument is not numeric
       ERR  119,LE second argument is not numeric
       PPM  EXNUL            RETURN NULL IF LT
       PPM  EXNUL            RETURN NULL IF EQ
       PPM  EXFAL            FAIL IF GT
S_LEN  ENT                   ENTRY POINT
       MOV  =P_LEN,WB        SET PCODE FOR INTEGER ARG CASE
       MOV  =P_LND,WA        SET PCODE FOR EXPR ARG CASE
       JSR  PATIN            CALL COMMON ROUTINE TO BUILD NODE
       ERR  120,LEN argument is not integer or expression
       ERR  121,LEN argument is negative or too large
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_LEQ  ENT                   ENTRY POINT
       JSR  LCOMP            CALL STRING COMPARISON ROUTINE
       ERR  122,LEQ first argument is not a string
       ERR  123,LEQ second argument is not a string
       PPM  EXFAL            FAIL IF LLT
       PPM  EXNUL            RETURN NULL IF LEQ
       PPM  EXFAL            FAIL IF LGT
S_LGE  ENT                   ENTRY POINT
       JSR  LCOMP            CALL STRING COMPARISON ROUTINE
       ERR  124,LGE first argument is not a string
       ERR  125,LGE second argument is not a string
       PPM  EXFAL            FAIL IF LLT
       PPM  EXNUL            RETURN NULL IF LEQ
       PPM  EXNUL            RETURN NULL IF LGT
S_LGT  ENT                   ENTRY POINT
       JSR  LCOMP            CALL STRING COMPARISON ROUTINE
       ERR  126,LGT first argument is not a string
       ERR  127,LGT second argument is not a string
       PPM  EXFAL            FAIL IF LLT
       PPM  EXFAL            FAIL IF LEQ
       PPM  EXNUL            RETURN NULL IF LGT
S_LLE  ENT                   ENTRY POINT
       JSR  LCOMP            CALL STRING COMPARISON ROUTINE
       ERR  128,LLE first argument is not a string
       ERR  129,LLE second argument is not a string
       PPM  EXNUL            RETURN NULL IF LLT
       PPM  EXNUL            RETURN NULL IF LEQ
       PPM  EXFAL            FAIL IF LGT
S_LLT  ENT                   ENTRY POINT
       JSR  LCOMP            CALL STRING COMPARISON ROUTINE
       ERR  130,LLT first argument is not a string
       ERR  131,LLT second argument is not a string
       PPM  EXNUL            RETURN NULL IF LLT
       PPM  EXFAL            FAIL IF LEQ
       PPM  EXFAL            FAIL IF LGT
S_LNE  ENT                   ENTRY POINT
       JSR  LCOMP            CALL STRING COMPARISON ROUTINE
       ERR  132,LNE first argument is not a string
       ERR  133,LNE second argument is not a string
       PPM  EXNUL            RETURN NULL IF LLT
       PPM  EXFAL            FAIL IF LEQ
       PPM  EXNUL            RETURN NULL IF LGT
.IF    .CMTH
S_LNF  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  306,LN argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       REQ  SLNF1            OVERFLOW IF ARGUMENT IS 0
       RLT  SLNF2            ERROR IF ARGUMENT LESS THAN 0
       LNF                   TAKE NATURAL LOGARITHM
       RNO  EXREA            IF NO OVERFLOW, RETURN RESULT IN RA
SLNF1  ERB  307,LN produced real overflow
SLNF2  ERB  315,LN argument negative
.FI
S_LOC  ENT                   ENTRY POINT
       JSR  GTSMI            GET SECOND ARGUMENT (LOCAL NUMBER)
       ERR  134,LOCAL second argument is not integer
       PPM  EXFAL            FAIL IF OUT OF RANGE
       MOV  XR,WB            SAVE LOCAL NUMBER
       MOV  (XS)+,XR         LOAD FIRST ARGUMENT
       JSR  GTNVR            POINT TO VRBLK
       PPM  SLOC1            JUMP IF NOT VARIABLE NAME
       MOV  VRFNC(XR),XR     ELSE LOAD FUNCTION POINTER
       BNE  (XR),=B_PFC,SLOC1 JUMP IF NOT PROGRAM DEFINED
       BZE  WB,EXFAL         FAIL IF SECOND ARG IS ZERO
       BGT  WB,PFNLO(XR),EXFAL OR TOO LARGE
       ADD  FARGS(XR),WB     ELSE ADJUST OFFSET TO INCLUDE ARGS
       WTB  WB               CONVERT TO BYTES
       ADD  WB,XR            POINT TO LOCAL POINTER
       MOV  PFAGB(XR),XR     LOAD VRBLK POINTER
       BRN  EXVNM            EXIT BUILDING NMBLK
SLOC1  ERB  135,LOCAL first arg is not a program function name
.IF    .CNLD
.ELSE
S_LOD  ENT                   ENTRY POINT
       JSR  GTSTG            LOAD LIBRARY NAME
       ERR  136,LOAD second argument is not a string
       MOV  XR,XL            SAVE LIBRARY NAME
       JSR  XSCNI            PREPARE TO SCAN FIRST ARGUMENT
       ERR  137,LOAD first argument is not a string
       ERR  138,LOAD first argument is null
       MOV  XL,-(XS)         STACK LIBRARY NAME
       MOV  =CH_PP,WC        SET DELIMITER ONE = LEFT PAREN
       MOV  WC,XL            SET DELIMITER TWO = LEFT PAREN
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN FUNCTION NAME
       MOV  XR,-(XS)         SAVE PTR TO FUNCTION NAME
       BNZ  WA,SLOD1         JUMP IF LEFT PAREN FOUND
       ERB  139,LOAD first argument is missing a left paren
SLOD1  JSR  GTNVR            LOCATE VRBLK
       ERR  140,LOAD first argument has null function name
       MOV  XR,LODFN         SAVE VRBLK POINTER
       ZER  LODNA            ZERO COUNT OF ARGUMENTS
SLOD2  MOV  =CH_RP,WC        DELIMITER ONE IS RIGHT PAREN
       MOV  =CH_CM,XL        DELIMITER TWO IS COMMA
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN NEXT ARGUMENT NAME
       ICV  LODNA            BUMP ARGUMENT COUNT
       BNZ  WA,SLOD3         JUMP IF OK DELIMITER WAS FOUND
       ERB  141,LOAD first argument is missing a right paren
.IF    .CULC
SLOD3  MOV  WA,WB            SAVE SCAN MODE
       MOV  SCLEN(XR),WA     DATATYPE LENGTH
       BZE  WA,SLD3A         BYPASS IF NULL STRING
       JSR  FLSTG            FOLD TO UPPER CASE
SLD3A  MOV  WB,WA            RESTORE SCAN MODE
       MOV  XR,-(XS)         STACK DATATYPE NAME POINTER
.ELSE
SLOD3  MOV  XR,-(XS)         STACK DATATYPE NAME POINTER
.FI
       MOV  =NUM01,WB        SET STRING CODE IN CASE
       MOV  =SCSTR,XL        POINT TO /STRING/
       JSR  IDENT            CHECK FOR MATCH
       PPM  SLOD4            JUMP IF MATCH
       MOV  (XS),XR          ELSE RELOAD NAME
       ADD  WB,WB            SET CODE FOR INTEGER (2)
       MOV  =SCINT,XL        POINT TO /INTEGER/
       JSR  IDENT            CHECK FOR MATCH
       PPM  SLOD4            JUMP IF MATCH
.IF    .CNRA
.ELSE
       MOV  (XS),XR          ELSE RELOAD STRING POINTER
       ICV  WB               SET CODE FOR REAL (3)
       MOV  =SCREA,XL        POINT TO /REAL/
       JSR  IDENT            CHECK FOR MATCH
       PPM  SLOD4            JUMP IF MATCH
.FI
.IF    .CNLF
       MOV  (XS),XR          RELOAD STRING POINTER
       ICV  WB               CODE FOR FILE (4, OR 3 IF NO REALS)
       MOV  =SCFIL,XL        POINT TO /FILE/
       JSR  IDENT            CHECK FOR MATCH
       PPM  SLOD4            JUMP IF MATCH
.FI
       ZER  WB               ELSE GET CODE FOR NO CONVERT
SLOD4  MOV  WB,(XS)          STORE CODE ON STACK
       BEQ  WA,=NUM02,SLOD2  LOOP BACK IF ARG STOPPED BY COMMA
       BZE  WA,SLOD5         JUMP IF THAT WAS THE RESULT TYPE
       MOV  MXLEN,WC         SET DUMMY (IMPOSSIBLE) DELIMITER 1
       MOV  WC,XL            AND DELIMITER TWO
       MNZ  WA               SKIP/TRIM BLANKS IN PROTOTYPE
       JSR  XSCAN            SCAN RESULT NAME
       ZER  WA               SET CODE FOR PROCESSING RESULT
       BRN  SLOD3            JUMP BACK TO PROCESS RESULT NAME
SLOD5  MOV  LODNA,WA         GET NUMBER OF ARGUMENTS
       MOV  WA,WC            COPY FOR LATER
       WTB  WA               CONVERT LENGTH TO BYTES
       ADD  *EFSI_,WA        ADD SPACE FOR STANDARD FIELDS
       JSR  ALLOC            ALLOCATE EFBLK
       MOV  =B_EFC,(XR)      SET TYPE WORD
       MOV  WC,FARGS(XR)     SET NUMBER OF ARGUMENTS
       ZER  EFUSE(XR)        SET USE COUNT (DFFNC WILL SET TO 1)
       ZER  EFCOD(XR)        ZERO CODE POINTER FOR NOW
       MOV  (XS)+,EFRSL(XR)  STORE RESULT TYPE CODE
       MOV  LODFN,EFVAR(XR)  STORE FUNCTION VRBLK POINTER
       MOV  WA,EFLEN(XR)     STORE EFBLK LENGTH
       MOV  XR,WB            SAVE EFBLK POINTER
       ADD  WA,XR            POINT PAST END OF EFBLK
       LCT  WC,WC            SET NUMBER OF ARGUMENTS FOR LOOP
SLOD6  MOV  (XS)+,-(XR)      STORE ONE TYPE CODE FROM STACK
       BCT  WC,SLOD6         LOOP TILL ALL STORED
       MOV  (XS)+,XR         LOAD FUNCTION STRING NAME
.IF    .CULC
       MOV  SCLEN(XR),WA     FUNCTION NAME LENGTH
       JSR  FLSTG            FOLD TO UPPER CASE
.FI
       MOV  (XS),XL          LOAD LIBRARY NAME
       MOV  WB,(XS)          STORE EFBLK POINTER
       JSR  SYSLD            CALL FUNCTION TO LOAD EXTERNAL FUNC
       ERR  142,LOAD function does not exist
       ERR  143,LOAD function caused input error during load
       ERR  328,LOAD function - insufficient memory
       MOV  (XS)+,XL         RECALL EFBLK POINTER
       MOV  XR,EFCOD(XL)     STORE CODE POINTER
       MOV  LODFN,XR         POINT TO VRBLK FOR FUNCTION
       JSR  DFFNC            PERFORM FUNCTION DEFINITION
       BRN  EXNUL            RETURN NULL RESULT
.FI
S_LPD  ENT                   ENTRY POINT
       JSR  GTSTG            GET PAD CHARACTER
       ERR  144,LPAD third argument is not a string
       PLC  XR               POINT TO CHARACTER (NULL IS BLANK)
       LCH  WB,(XR)          LOAD PAD CHARACTER
       JSR  GTSMI            GET PAD LENGTH
       ERR  145,LPAD second argument is not integer
       PPM  SLPD4            SKIP IF NEGATIVE OR LARGE
SLPD1  JSR  GTSTG            GET FIRST ARGUMENT (STRING TO PAD)
       ERR  146,LPAD first argument is not a string
       BGE  WA,WC,EXIXR      RETURN 1ST ARG IF TOO LONG TO PAD
       MOV  XR,XL            ELSE MOVE PTR TO STRING TO PAD
       MOV  WC,WA            COPY LENGTH
       JSR  ALOCS            ALLOCATE SCBLK FOR NEW STRING
       MOV  XR,-(XS)         SAVE AS RESULT
       MOV  SCLEN(XL),WA     LOAD LENGTH OF ARGUMENT
       SUB  WA,WC            CALCULATE NUMBER OF PAD CHARACTERS
       PSC  XR               POINT TO CHARS IN RESULT STRING
       LCT  WC,WC            SET COUNTER FOR PAD LOOP
SLPD2  SCH  WB,(XR)+         STORE PAD CHARACTER, BUMP PTR
       BCT  WC,SLPD2         LOOP TILL ALL PAD CHARS STORED
       CSC  XR               COMPLETE STORE CHARACTERS
       BZE  WA,SLPD3         EXIT IF NULL STRING
       PLC  XL               ELSE POINT TO CHARS IN ARGUMENT
       MVC                   MOVE CHARACTERS TO RESULT STRING
       ZER  XL               CLEAR GARBAGE XL
SLPD3  LCW  XR               LOAD NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SLPD4  ZER  WC               ZERO PAD COUNT
       BRN  SLPD1            MERGE
S_LTF  ENT                   ENTRY POINT
       JSR  ACOMP            CALL ARITHMETIC COMPARISON ROUTINE
       ERR  147,LT first argument is not numeric
       ERR  148,LT second argument is not numeric
       PPM  EXNUL            RETURN NULL IF LT
       PPM  EXFAL            FAIL IF EQ
       PPM  EXFAL            FAIL IF GT
S_NEF  ENT                   ENTRY POINT
       JSR  ACOMP            CALL ARITHMETIC COMPARISON ROUTINE
       ERR  149,NE first argument is not numeric
       ERR  150,NE second argument is not numeric
       PPM  EXNUL            RETURN NULL IF LT
       PPM  EXFAL            FAIL IF EQ
       PPM  EXNUL            RETURN NULL IF GT
S_NAY  ENT                   ENTRY POINT
       MOV  =P_NAS,WB        SET PCODE FOR SINGLE CHAR ARG
       MOV  =P_NAY,XL        PCODE FOR MULTI-CHAR ARG
       MOV  =P_NAD,WC        SET PCODE FOR EXPR ARG
       JSR  PATST            CALL COMMON ROUTINE TO BUILD NODE
       ERR  151,NOTANY argument is not a string or expression
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_OPS  ENT                   ENTRY POINT
       JSR  GTSMI            LOAD THIRD ARGUMENT
       ERR  152,OPSYN third argument is not integer
       ERR  153,OPSYN third argument is negative or too large
       MOV  WC,WB            IF OK, SAVE THIRD ARGUMNET
       MOV  (XS)+,XR         LOAD SECOND ARGUMENT
       JSR  GTNVR            LOCATE VARIABLE BLOCK
       ERR  154,OPSYN second arg is not natural variable name
       MOV  VRFNC(XR),XL     IF OK, LOAD FUNCTION BLOCK POINTER
       BNZ  WB,SOPS2         JUMP IF OPERATOR OPSYN CASE
       MOV  (XS)+,XR         LOAD FIRST ARGUMENT
       JSR  GTNVR            GET VRBLK POINTER
       ERR  155,OPSYN first arg is not natural variable name
SOPS1  JSR  DFFNC            CALL FUNCTION DEFINER
       BRN  EXNUL            EXIT WITH NULL RESULT
SOPS2  JSR  GTSTG            GET OPERATOR NAME
       PPM  SOPS5            JUMP IF NOT STRING
       BNE  WA,=NUM01,SOPS5  ERROR IF NOT ONE CHAR LONG
       PLC  XR               ELSE POINT TO CHARACTER
       LCH  WC,(XR)          LOAD CHARACTER NAME
       MOV  =R_UUB,WA        POINT TO UNOP POINTERS IN CASE
       MOV  =OPNSU,XR        POINT TO NAMES OF UNARY OPERATORS
       ADD  =OPBUN,WB        ADD NO. OF UNDEFINED BINARY OPS
       BEQ  WB,=OPUUN,SOPS3  JUMP IF UNOP (THIRD ARG WAS 1)
       MOV  =R_UBA,WA        ELSE POINT TO BINARY OPERATOR PTRS
       MOV  =OPSNB,XR        POINT TO NAMES OF BINARY OPERATORS
       MOV  =OPBUN,WB        SET NUMBER OF UNDEFINED BINOPS
SOPS3  LCT  WB,WB            SET COUNTER TO CONTROL LOOP
SOPS4  BEQ  WC,(XR),SOPS6    JUMP IF NAMES MATCH
       ICA  WA               ELSE PUSH POINTER TO FUNCTION PTR
       ICA  XR               BUMP POINTER
       BCT  WB,SOPS4         LOOP BACK TILL ALL CHECKED
SOPS5  ERB  156,OPSYN first arg is not correct operator name
SOPS6  MOV  WA,XR            COPY POINTER TO FUNCTION BLOCK PTR
       SUB  *VRFNC,XR        MAKE IT LOOK LIKE DUMMY VRBLK
       BRN  SOPS1            MERGE BACK TO DEFINE OPERATOR
.IF    .C370
S_ORF  ENT                   ENTRY POINT
       MNZ  WB               SIGNAL TWO ARGUMENTS
       JSR  SBOOL            CALL STRING BOOLEAN ROUTINE
       ERR  xxx,OR first argument is not a string
       ERR  xxx,OR second argument is not a string
       ERR  xxx,OR arguments not same length
       PPM  EXITS            NULL STRING ARGUMENTS
SORF1  MOV  (XL)+,WA         GET NEXT CFP_C CHARS FROM ARG 1
       ORB  (XR),WA          OR WITH CHARACTERS FROM ARG 2
       MOV  WA,(XR)+         PUT BACK IN MEMORY
       BCT  WC,SORF1         LOOP OVER ALL WORDS IN STRING BLOCK
       BRN  EXITS            FETCH NEXT CODE WORD
.FI
S_OUP  ENT                   ENTRY POINT
       MOV  =NUM03,WB        OUTPUT FLAG
       JSR  IOPUT            CALL INPUT/OUTPUT ASSOC. ROUTINE
       ERR  157,OUTPUT third argument is not a string
       ERR  158,Inappropriate second argument for OUTPUT
       ERR  159,Inappropriate first argument for OUTPUT
       ERR  160,Inappropriate file specification for OUTPUT
       PPM  EXFAL            FAIL IF FILE DOES NOT EXIST
       ERR  161,OUTPUT file cannot be written to
       ERR  290,OUTPUT channel currently in use
       BRN  EXNUL            RETURN NULL STRING
S_POS  ENT                   ENTRY POINT
       MOV  =P_POS,WB        SET PCODE FOR INTEGER ARG CASE
       MOV  =P_PSD,WA        SET PCODE FOR EXPRESSION ARG CASE
       JSR  PATIN            CALL COMMON ROUTINE TO BUILD NODE
       ERR  162,POS argument is not integer or expression
       ERR  163,POS argument is negative or too large
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_PRO  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       MOV  TBLEN(XR),WB     LENGTH IF TABLE, VECTOR (=VCLEN)
       BTW  WB               CONVERT TO WORDS
       MOV  (XR),WA          LOAD TYPE WORD OF ARGUMENT BLOCK
       BEQ  WA,=B_ART,SPRO4  JUMP IF ARRAY
       BEQ  WA,=B_TBT,SPRO1  JUMP IF TABLE
       BEQ  WA,=B_VCT,SPRO3  JUMP IF VECTOR
.IF    .CNBF
.ELSE
       BEQ  WA,=B_BCT,SPR05  JUMP IF BUFFER
.FI
       ERB  164,PROTOTYPE argument is not valid object
SPRO1  SUB  =TBSI_,WB        SUBTRACT STANDARD FIELDS
SPRO2  MTI  WB               CONVERT TO INTEGER
       BRN  EXINT            EXIT WITH INTEGER RESULT
SPRO3  SUB  =VCSI_,WB        SUBTRACT STANDARD FIELDS
       BRN  SPRO2            MERGE
SPRO4  ADD  AROFS(XR),XR     POINT TO PROTOTYPE FIELD
       MOV  (XR),XR          LOAD PROTOTYPE
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CNBF
.ELSE
SPR05  MOV  BCBUF(XR),XR     POINT TO BFBLK
       MTI  BFALC(XR)        LOAD ALLOCATED LENGTH
       BRN  EXINT            EXIT WITH INTEGER ALLOCATION
.FI
S_RMD  ENT                   ENTRY POINT
.IF    .CMTH
       JSR  ARITH            GET TWO INTEGERS OR TWO REALS
       ERR  166,REMDR first argument is not numeric
       ERR  165,REMDR second argument is not numeric
       PPM  SRM06            IF REAL
.ELSE
       MOV  (XS),XR          LOAD SECOND ARGUMENT
       JSR  GTINT            CONVERT TO INTEGER
       ERR  165,REMDR second argument is not integer
       MOV  XR,(XS)          PLACE CONVERTED ARG IN STACK
       JSR  ARITH            CONVERT ARGS
       PPM  SRM04            FIRST ARG NOT INTEGER
       PPM                   SECOND ARG CHECKED ABOVE
.IF    .CNRA
.ELSE
       PPM  SRM01            FIRST ARG REAL
.FI
.FI
       ZER  WB               SET POSITIVE FLAG
       LDI  ICVAL(XR)        LOAD LEFT ARGUMENT VALUE
       IGE  SRM01            JUMP IF POSITIVE
       MNZ  WB               SET NEGATIVE FLAG
SRM01  RMI  ICVAL(XL)        GET REMAINDER
       IOV  SRM05            ERROR IF OVERFLOW
       BZE  WB,SRM03         IF RESULT SHOULD BE POSITIVE
       ILE  EXINT            IF SHOULD BE NEGATIVE, AND IS
SRM02  NGI                   ADJUST SIGN OF RESULT
       BRN  EXINT            RETURN RESULT
SRM03  ILT  SRM02            SHOULD BE POS, AND RESULT NEGATIVE
       BRN  EXINT            SHOULD BE POSITIVE, AND IS
SRM04  ERB  166,REMDR first argument is not numeric
SRM05  ERB  167,REMDR caused integer overflow
.IF    .CMTH
SRM06  ZER  WB               SET POSITIVE FLAG
       LDR  RCVAL(XR)        LOAD LEFT ARGUMENT VALUE
       RGE  SRM07            JUMP IF POSITIVE
       MNZ  WB               SET NEGATIVE FLAG
SRM07  DVR  RCVAL(XL)        COMPUTE N1/N2
       ROV  SRM10            JUMP IF OVERFLOW
       CHP                   CHOP RESULT
       MLR  RCVAL(XL)        TIMES N2
       SBR  RCVAL(XR)        COMPUTE DIFFERENCE
       BZE  WB,SRM09         IF RESULT SHOULD BE POSITIVE
       RLE  EXREA            IF SHOULD BE NEGATIVE, AND IS
SRM08  NGR                   ADJUST SIGN OF RESULT
       BRN  EXREA            RETURN RESULT
SRM09  RLT  SRM08            SHOULD BE POS, AND RESULT NEGATIVE
       BRN  EXREA            SHOULD BE POSITIVE, AND IS
SRM10  ERB  312,REMDR caused real overflow
.FI
S_RPL  ENT                   ENTRY POINT
       JSR  GTSTG            LOAD THIRD ARGUMENT AS STRING
       ERR  168,REPLACE third argument is not a string
       MOV  XR,XL            SAVE THIRD ARG PTR
       JSR  GTSTG            GET SECOND ARGUMENT
       ERR  169,REPLACE second argument is not a string
       BNE  XR,R_RA2,SRPL1   JUMP IF 2ND ARGUMENT DIFFERENT
       BEQ  XL,R_RA3,SRPL4   JUMP IF ARGS SAME AS LAST TIME
SRPL1  MOV  SCLEN(XL),WB     LOAD 3RD ARGUMENT LENGTH
       BNE  WA,WB,SRPL6      JUMP IF ARGUMENTS NOT SAME LENGTH
       BEQ  XR,KVALP,SRPL5   JUMP IF 2ND ARG IS ALPHABET STRING
       BZE  WB,SRPL6         JUMP IF NULL 2ND ARGUMENT
       MOV  XL,R_RA3         SAVE THIRD ARG FOR NEXT TIME IN
       MOV  XR,R_RA2         SAVE SECOND ARG FOR NEXT TIME IN
       MOV  KVALP,XL         POINT TO ALPHABET STRING
       MOV  SCLEN(XL),WA     LOAD ALPHABET SCBLK LENGTH
       MOV  R_RPT,XR         POINT TO CURRENT TABLE (IF ANY)
       BNZ  XR,SRPL2         JUMP IF WE ALREADY HAVE A TABLE
       JSR  ALOCS            ALLOCATE NEW TABLE
       MOV  WC,WA            KEEP SCBLK LENGTH
       MOV  XR,R_RPT         SAVE TABLE POINTER FOR NEXT TIME
SRPL2  CTB  WA,SCSI_         COMPUTE LENGTH OF SCBLK
       MVW                   COPY TO GET INITIAL TABLE VALUES
       MOV  R_RA2,XL         POINT TO SECOND ARGUMENT
       LCT  WB,WB            NUMBER OF CHARS TO PLUG
       ZER  WC               ZERO CHAR OFFSET
       MOV  R_RA3,XR         POINT TO 3RD ARG
       PLC  XR               GET CHAR PTR FOR 3RD ARG
SRPL3  MOV  R_RA2,XL         POINT TO 2ND ARG
       PLC  XL,WC            POINT TO NEXT CHAR
       ICV  WC               INCREMENT OFFSET
       LCH  WA,(XL)          GET NEXT CHAR
       MOV  R_RPT,XL         POINT TO TRANSLATE TABLE
       PSC  XL,WA            CONVERT CHAR TO OFFSET INTO TABLE
       LCH  WA,(XR)+         GET TRANSLATED CHAR
       SCH  WA,(XL)          STORE IN TABLE
       CSC  XL               COMPLETE STORE CHARACTERS
       BCT  WB,SRPL3         LOOP TILL DONE
SRPL4  MOV  R_RPT,XL         REPLACE TABLE TO USE
.IF    .CNBF
SRPL5  JSR  GTSTG            GET FIRST ARGUMENT
       ERR  170,REPLACE first argument is not a string
.ELSE
SRPL5  JSR  GTSTB            GET FIRST ARGUMENT
       ERR  170,REPLACE first argument is not a string or buffer
       BNZ  WB,SRPL7         BRANCH IF BUFFER
.FI
       BZE  WA,EXNUL         RETURN NULL IF NULL ARGUMENT
       MOV  XL,-(XS)         STACK REPLACE TABLE TO USE
       MOV  XR,XL            COPY POINTER
       MOV  WA,WC            SAVE LENGTH
       CTB  WA,SCHAR         GET SCBLK LENGTH
       JSR  ALLOC            ALLOCATE SPACE FOR COPY
       MOV  XR,WB            SAVE ADDRESS OF COPY
       MVW                   MOVE SCBLK CONTENTS TO COPY
       MOV  (XS)+,XR         UNSTACK REPLACE TABLE
       PLC  XR               POINT TO CHARS OF TABLE
       MOV  WB,XL            POINT TO STRING TO TRANSLATE
       PLC  XL               POINT TO CHARS OF STRING
       MOV  WC,WA            SET NUMBER OF CHARS TO TRANSLATE
       TRC                   PERFORM TRANSLATION
SRPL8  MOV  WB,-(XS)         STACK RESULT
       LCW  XR               LOAD NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SRPL6  ERB  171,Null or unequally long 2nd, 3rd args to REPLACE
.IF    .CNBF
.ELSE
SRPL7  BZE  WA,SRPL8         RETURN BUFFER UNCHANGED IF EMPTY
       MOV  XR,WC            COPY BFBLK POINTER TO WC
       MOV  XL,XR            TRANSLATE TABLE TO XR
       PLC  XR               POINT TO CHARS OF TABLE
       MOV  WC,XL            POINT TO STRING TO TRANSLATE
       PLC  XL               POINT TO CHARS OF STRING
       TRC                   PERFORM TRANSLATION
       BRN  SRPL8            STACK RESULT AND EXIT
.FI
S_REW  ENT                   ENTRY POINT
       JSR  IOFCB            CALL FCBLK ROUTINE
       ERR  172,REWIND argument is not a suitable name
       ERR  173,REWIND argument is null
       ERR  174,REWIND file does not exist
       JSR  SYSRW            CALL SYSTEM REWIND FUNCTION
       ERR  174,REWIND file does not exist
       ERR  175,REWIND file does not permit rewind
       ERR  176,REWIND caused non-recoverable error
       BRN  EXNUL            EXIT WITH NULL RESULT IF NO ERROR
S_RVS  ENT                   ENTRY POINT
.IF    .CNBF
       JSR  GTSTG            LOAD STRING ARGUMENT
       ERR  177,REVERSE argument is not a string
.ELSE
       JSR  GTSTB            LOAD STRING OR BUFFER ARGUMENT
       ERR  177,REVERSE argument is not a string or buffer
       BNZ  WB,SRVS3         BRANCH IF BUFFER
.FI
       BZE  WA,EXIXR         RETURN ARGUMENT IF NULL
       MOV  XR,XL            ELSE SAVE POINTER TO STRING ARG
       JSR  ALOCS            ALLOCATE SPACE FOR NEW SCBLK
       MOV  XR,-(XS)         STORE SCBLK PTR ON STACK AS RESULT
       PSC  XR               PREPARE TO STORE IN NEW SCBLK
       PLC  XL,WC            POINT PAST LAST CHAR IN ARGUMENT
       LCT  WC,WC            SET LOOP COUNTER
SRVS1  LCH  WB,-(XL)         LOAD NEXT CHAR FROM ARGUMENT
       SCH  WB,(XR)+         STORE IN RESULT
       BCT  WC,SRVS1         LOOP TILL ALL MOVED
SRVS4  CSC  XR               COMPLETE STORE CHARACTERS
       ZER  XL               CLEAR GARBAGE XL
SRVS2  LCW  XR               LOAD NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CNBF
.ELSE
SRVS3  MOV  WB,-(XS)         STACK BUFFER AS RESULT
       BZE  WA,SRVS2         RETURN BUFFER UNCHANGED IF EMPTY
       MOV  XR,XL            COPY BFBLK POINTER TO XL
       PSC  XR               PREPARE TO STORE AT FIRST CHAR
       PLC  XL,WA            POINT PAST LAST CHAR IN ARGUMENT
       RSH  WA,1             OPERATE ON HALF THE STRING
       LCT  WC,WA            SET LOOP COUNTER
SRVS5  LCH  WB,-(XL)         LOAD NEXT CHAR FROM END
       LCH  WA,(XR)          LOAD NEXT CHAR FROM FRONT
       SCH  WB,(XR)+         STORE END CHAR IN FRONT
       SCH  WA,(XL)          STORE FRONT CHAR AT END
       BCT  WC,SRVS5         LOOP TILL ALL MOVED
       BRN  SRVS4            COMPLETE STORE
.FI
S_RPD  ENT                   ENTRY POINT
       JSR  GTSTG            GET PAD CHARACTER
       ERR  178,RPAD third argument is not a string
       PLC  XR               POINT TO CHARACTER (NULL IS BLANK)
       LCH  WB,(XR)          LOAD PAD CHARACTER
       JSR  GTSMI            GET PAD LENGTH
       ERR  179,RPAD second argument is not integer
       PPM  SRPD3            SKIP IF NEGATIVE OR LARGE
SRPD1  JSR  GTSTG            GET FIRST ARGUMENT (STRING TO PAD)
       ERR  180,RPAD first argument is not a string
       BGE  WA,WC,EXIXR      RETURN 1ST ARG IF TOO LONG TO PAD
       MOV  XR,XL            ELSE MOVE PTR TO STRING TO PAD
       MOV  WC,WA            COPY LENGTH
       JSR  ALOCS            ALLOCATE SCBLK FOR NEW STRING
       MOV  XR,-(XS)         SAVE AS RESULT
       MOV  SCLEN(XL),WA     LOAD LENGTH OF ARGUMENT
       SUB  WA,WC            CALCULATE NUMBER OF PAD CHARACTERS
       PSC  XR               POINT TO CHARS IN RESULT STRING
       LCT  WC,WC            SET COUNTER FOR PAD LOOP
       BZE  WA,SRPD2         JUMP IF ARGUMENT IS NULL
       PLC  XL               ELSE POINT TO ARGUMENT CHARS
       MVC                   MOVE CHARACTERS TO RESULT STRING
       ZER  XL               CLEAR GARBAGE XL
SRPD2  SCH  WB,(XR)+         STORE PAD CHARACTER, BUMP PTR
       BCT  WC,SRPD2         LOOP TILL ALL PAD CHARS STORED
       CSC  XR               COMPLETE CHARACTER STORING
       LCW  XR               LOAD NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
SRPD3  ZER  WC               ZERO PAD COUNT
       BRN  SRPD1            MERGE
S_RTB  ENT                   ENTRY POINT
       MOV  =P_RTB,WB        SET PCODE FOR INTEGER ARG CASE
       MOV  =P_RTD,WA        SET PCODE FOR EXPRESSION ARG CASE
       JSR  PATIN            CALL COMMON ROUTINE TO BUILD NODE
       ERR  181,RTAB argument is not integer or expression
       ERR  182,RTAB argument is negative or too large
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CUST
S_SET  ENT                   ENTRY POINT
       MOV  (XS)+,R_IO2      SAVE THIRD ARG (WHENCE)
.IF    .CUSR
       MOV  (XS)+,XR         GET SECOND ARG (OFFSET)
       JSR  GTREA            CONVERT TO REAL
       ERR  324,SET second argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
.ELSE
       MOV  (XS)+,R_IO1      SAVE SECOND ARG (OFFSET)
.FI
       JSR  IOFCB            CALL FCBLK ROUTINE
       ERR  291,SET first argument is not a suitable name
       ERR  292,SET first argument is null
       ERR  295,SET file does not exist
.IF    .CUSR
.ELSE
       MOV  R_IO1,WB         LOAD SECOND ARG
.FI
       MOV  R_IO2,WC         LOAD THIRD ARG
       JSR  SYSST            CALL SYSTEM SET ROUTINE
       ERR  293,Inappropriate second argument to SET
       ERR  294,Inappropriate third argument to SET
       ERR  295,SET file does not exist
       ERR  296,SET file does not permit setting file pointer
       ERR  297,SET caused non-recoverable I/O error
.IF    .CUSR
       RTI  EXREA            RETURN REAL POSITION IF NOT ABLE
       BRN  EXINT            TO RETURN INTEGER POSITION
.ELSE
       BRN  EXINT            OTHERWISE RETURN POSITION
.FI
.FI
S_TAB  ENT                   ENTRY POINT
       MOV  =P_TAB,WB        SET PCODE FOR INTEGER ARG CASE
       MOV  =P_TBD,WA        SET PCODE FOR EXPRESSION ARG CASE
       JSR  PATIN            CALL COMMON ROUTINE TO BUILD NODE
       ERR  183,TAB argument is not integer or expression
       ERR  184,TAB argument is negative or too large
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_RPS  ENT                   ENTRY POINT
       MOV  =P_RPS,WB        SET PCODE FOR INTEGER ARG CASE
       MOV  =P_RPD,WA        SET PCODE FOR EXPRESSION ARG CASE
       JSR  PATIN            CALL COMMON ROUTINE TO BUILD NODE
       ERR  185,RPOS argument is not integer or expression
       ERR  186,RPOS argument is negative or too large
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CNSR
.ELSE
S_RSR  ENT                   ENTRY POINT
       MNZ  WA               MARK AS RSORT
       JSR  SORTA            CALL SORT ROUTINE
       PPM  EXFAL            IF CONVERSION FAILS, SO SHALL WE
       BRN  EXSID            RETURN, SETTING IDVAL
.FI
S_STX  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       MOV  STXVR,WA         LOAD OLD VRBLK POINTER
       ZER  XL               LOAD ZERO IN CASE NULL ARG
       BEQ  XR,=NULLS,SSTX1  JUMP IF NULL ARGUMENT (RESET CALL)
       JSR  GTNVR            ELSE GET SPECIFIED VRBLK
       PPM  SSTX2            JUMP IF NOT NATURAL VARIABLE
       MOV  VRLBL(XR),XL     ELSE LOAD LABEL
       BEQ  XL,=STNDL,SSTX2  JUMP IF LABEL IS NOT DEFINED
       BNE  (XL),=B_TRT,SSTX1 JUMP IF NOT TRAPPED
       MOV  TRLBL(XL),XL     ELSE LOAD PTR TO REAL LABEL CODE
SSTX1  MOV  XR,STXVR         STORE NEW VRBLK POINTER (OR NULL)
       MOV  XL,R_SXC         STORE NEW CODE PTR (OR ZERO)
       BEQ  WA,=NULLS,EXNUL  RETURN NULL IF NULL RESULT
       MOV  WA,XR            ELSE COPY VRBLK POINTER
       BRN  EXVNM            AND RETURN BUILDING NMBLK
SSTX2  ERB  187,SETEXIT argument is not label name or null
.IF    .CMTH
S_SIN  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  308,SIN argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       SIN                   TAKE SINE
       RNO  EXREA            IF NO OVERFLOW, RETURN RESULT IN RA
       ERB  323,SIN argument is out of range
.FI
.IF    .CMTH
S_SQR  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  313,SQRT argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       RLT  SSQR1            NEGATIVE NUMBER
       SQR                   TAKE SQUARE ROOT
       BRN  EXREA            NO OVERFLOW POSSIBLE, RESULT IN RA
SSQR1  ERB  314,SQRT argument negative
.FI
.IF    .CNSR
.ELSE
S_SRT  ENT                   ENTRY POINT
       ZER  WA               MARK AS SORT
       JSR  SORTA            CALL SORT ROUTINE
       PPM  EXFAL            IF CONVERSION FAILS, SO SHALL WE
       BRN  EXSID            RETURN, SETTING IDVAL
.FI
S_SPN  ENT                   ENTRY POINT
       MOV  =P_SPS,WB        SET PCODE FOR SINGLE CHAR ARG
       MOV  =P_SPN,XL        SET PCODE FOR MULTI-CHAR ARG
       MOV  =P_SPD,WC        SET PCODE FOR EXPRESSION ARG
       JSR  PATST            CALL COMMON ROUTINE TO BUILD NODE
       ERR  188,SPAN argument is not a string or expression
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_SI_  ENT                   ENTRY POINT
.IF    .CNBF
       JSR  GTSTG            LOAD STRING ARGUMENT
       ERR  189,SIZE argument is not a string
.ELSE
       JSR  GTSTB            LOAD STRING ARGUMENT
       ERR  189,SIZE argument is not a string or buffer
.FI
       MTI  WA               LOAD LENGTH AS INTEGER
       BRN  EXINT            EXIT WITH INTEGER RESULT
S_STT  ENT                   ENTRY POINT
       ZER  XL               INDICATE STOPTR CASE
       JSR  TRACE            CALL TRACE PROCEDURE
       ERR  190,STOPTR first argument is not appropriate name
       ERR  191,STOPTR second argument is not trace type
       BRN  EXNUL            RETURN NULL
S_SUB  ENT                   ENTRY POINT
       JSR  GTSMI            LOAD THIRD ARGUMENT
       ERR  192,SUBSTR third argument is not integer
       PPM  EXFAL            JUMP IF NEGATIVE OR TOO LARGE
       MOV  XR,SBSSV         SAVE THIRD ARGUMENT
       JSR  GTSMI            LOAD SECOND ARGUMENT
       ERR  193,SUBSTR second argument is not integer
       PPM  EXFAL            JUMP IF OUT OF RANGE
       MOV  XR,WC            SAVE SECOND ARGUMENT
       BZE  WC,EXFAL         JUMP IF SECOND ARGUMENT ZERO
       DCV  WC               ELSE DECREMENT FOR ONES ORIGIN
.IF    .CNBF
       JSR  GTSTG            LOAD FIRST ARGUMENT
       ERR  194,SUBSTR first argument is not a string
.ELSE
       JSR  GTSTB            LOAD FIRST ARGUMENT
       ERR  194,SUBSTR first argument is not a string or buffer
.FI
       MOV  WC,WB            COPY SECOND ARG TO WB
       MOV  SBSSV,WC         RELOAD THIRD ARGUMENT
       BNZ  WC,SSUB2         SKIP IF THIRD ARG GIVEN
       MOV  WA,WC            ELSE GET STRING LENGTH
       BGT  WB,WC,EXFAL      FAIL IF IMPROPER
       SUB  WB,WC            REDUCE BY OFFSET TO START
SSUB2  MOV  WA,XL            SAVE STRING LENGTH
       MOV  WC,WA            SET LENGTH OF SUBSTRING
       ADD  WB,WC            ADD 2ND ARG TO 3RD ARG
       BGT  WC,XL,EXFAL      JUMP IF IMPROPER SUBSTRING
       MOV  XR,XL            COPY POINTER TO FIRST ARG
       JSR  SBSTR            BUILD SUBSTRING
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
S_TBL  ENT                   ENTRY POINT
       MOV  (XS)+,XL         GET INITIAL LOOKUP VALUE
       ICA  XS               POP SECOND ARGUMENT
       JSR  GTSMI            LOAD ARGUMENT
       ERR  195,TABLE argument is not integer
       ERR  196,TABLE argument is out of range
       BNZ  WC,STBL1         JUMP IF NON-ZERO
       MOV  =TBNBK,WC        ELSE SUPPLY DEFAULT VALUE
STBL1  JSR  TMAKE            MAKE TABLE
       BRN  EXSID            EXIT SETTING IDVAL
.IF    .CMTH
S_TAN  ENT                   ENTRY POINT
       MOV  (XS)+,XR         GET ARGUMENT
       JSR  GTREA            CONVERT TO REAL
       ERR  309,TAN argument not numeric
       LDR  RCVAL(XR)        LOAD ACCUMULATOR WITH ARGUMENT
       TAN                   TAKE TANGENT
       RNO  EXREA            IF NO OVERFLOW, RETURN RESULT IN RA
       ERB  310,TAN produced real overflow or argument is out of range
.FI
S_TIM  ENT                   ENTRY POINT
       JSR  SYSTM            GET TIMER VALUE
       SBI  TIMSX            SUBTRACT STARTING TIME
       BRN  EXINT            EXIT WITH INTEGER VALUE
S_TRA  ENT                   ENTRY POINT
       BEQ  NUM03(XS),=NULLS,STR02 JUMP IF FIRST ARGUMENT IS NULL
       MOV  (XS)+,XR         LOAD FOURTH ARGUMENT
       ZER  XL               TENTATIVELY SET ZERO POINTER
       BEQ  XR,=NULLS,STR01  JUMP IF 4TH ARGUMENT IS NULL
       JSR  GTNVR            ELSE POINT TO VRBLK
       PPM  STR03            JUMP IF NOT VARIABLE NAME
       MOV  XR,XL            ELSE SAVE VRBLK IN TRFNC
STR01  MOV  (XS)+,XR         LOAD THIRD ARGUMENT (TAG)
       ZER  WB               SET ZERO AS TRTYP VALUE FOR NOW
       JSR  TRBLD            BUILD TRBLK FOR TRACE CALL
       MOV  XR,XL            MOVE TRBLK POINTER FOR TRACE
       JSR  TRACE            CALL TRACE PROCEDURE
       ERR  198,TRACE first argument is not appropriate name
       ERR  199,TRACE second argument is not trace type
       BRN  EXNUL            RETURN NULL
STR02  JSR  SYSTT            CALL IT
       ADD  *NUM04,XS        POP TRACE ARGUMENTS
       BRN  EXNUL            RETURN
STR03  ERB  197,TRACE fourth arg is not function name or null
S_TRM  ENT                   ENTRY POINT
.IF    .CNBF
       JSR  GTSTG            LOAD ARGUMENT AS STRING
       ERR  200,TRIM argument is not a string
.ELSE
       JSR  GTSTB            LOAD ARGUMENT AS STRING
       ERR  200,TRIM argument is not a string or buffer
       BNZ  WB,STRM0         BRANCH IF BUFFER
.FI
       BZE  WA,EXNUL         RETURN NULL IF ARGUMENT IS NULL
       MOV  XR,XL            COPY STRING POINTER
       CTB  WA,SCHAR         GET BLOCK LENGTH
       JSR  ALLOC            ALLOCATE COPY SAME SIZE
       MOV  XR,WB            SAVE POINTER TO COPY
       MVW                   COPY OLD STRING BLOCK TO NEW
       MOV  WB,XR            RESTORE PTR TO NEW BLOCK
       JSR  TRIMR            TRIM BLANKS (WB IS NON-ZERO)
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.IF    .CNBF
.ELSE
STRM0  MOV  WB,-(XS)         STACK BUFFER AS RESULT
       BZE  WA,STRM6         RETURN BUFFER UNCHANGED IF EMPTY
       MOV  XR,XL            GET BFBLK PTR
       MOV  WB,XR            COPY BCBLK PTR TO XR
       PLC  XL,WA            POINT PAST LAST CHARACTER
       MOV  =CH_BL,WC        LOAD BLANK CHARACTER
STRM1  LCH  WB,-(XL)         LOAD NEXT CHARACTER
.IF    .CAHT
       BEQ  WB,=CH_HT,STRM2  JUMP IF HORIZONTAL TAB
.FI
       BNE  WB,WC,STRM3      JUMP IF NON-BLANK FOUND
STRM2  DCV  WA               ELSE DECREMENT CHARACTER COUNT
       BNZ  WA,STRM1         LOOP BACK IF MORE TO CHECK
STRM3  MOV  WA,BCLEN(XR)     SET NEW LENGTH IN BCBLK
       MOV  BCBUF(XR),XR     GET BFBLK PTR
       MOV  WA,WB            COPY LENGTH
       CTB  WB,0             WORDS NEEDED CONVERTED TO BYTES
       SUB  WA,WB            NUMBER OF ZEROS NEEDED
       PSC  XR,WA            READY FOR STORING ZEROS
       ZER  WC               SET ZERO CHAR
STRM4  BZE  WB,STRM5         LOOP WHILE MORE TO BE DONE
       SCH  WC,(XR)+         STORE ZERO CHARACTER
       DCV  WB               DECREMENT COUNT
       BRN  STRM4            CONTINUE LOOP
STRM5  CSC  XR               COMPLETE STORE CHARACTERS
STRM6  LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
.FI
S_UNL  ENT                   ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       JSR  GTNVR            POINT TO VRBLK
       ERR  201,UNLOAD argument is not natural variable name
       MOV  =STNDF,XL        GET PTR TO UNDEFINED FUNCTION
       JSR  DFFNC            UNDEFINE NAMED FUNCTION
       BRN  EXNUL            RETURN NULL AS RESULT
.IF    .C370
S_XOR  ENT                   ENTRY POINT
       MNZ  WB               SIGNAL TWO ARGUMENTS
       JSR  SBOOL            CALL STRING BOOLEAN ROUTINE
       ERR  xxx,XOR first argument is not a string
       ERR  xxx,XOR second argument is not a string
       ERR  xxx,XOR arguments not same length
       PPM  EXITS            NULL STRING ARGUMENTS
SXOR1  MOV  (XL)+,WA         GET NEXT CFP_C CHARS FROM ARG 1
       XOB  (XR),WA          XOR WITH CHARACTERS FROM ARG 2
       MOV  WA,(XR)+         PUT BACK IN MEMORY
       BCT  WC,SXOR1         LOOP OVER ALL WORDS IN STRING BLOCK
       BRN  EXITS            FETCH NEXT CODE WORD
.FI
       TTL  S P I T B O L -- UTILITY ROUTINES
ARREF  RTN
       MOV  XR,WA            COPY NUMBER OF SUBSCRIPTS
       MOV  XS,XT            POINT TO STACK FRONT
       WTB  XR               CONVERT TO BYTE OFFSET
       ADD  XR,XT            POINT TO ARRAY OPERAND ON STACK
       ICA  XT               FINAL VALUE FOR STACK POPPING
       MOV  XT,ARFXS         KEEP FOR LATER
       MOV  -(XT),XR         LOAD ARRAY OPERAND POINTER
       MOV  XR,R_ARF         KEEP ARRAY POINTER
       MOV  XT,XR            SAVE POINTER TO SUBSCRIPTS
       MOV  R_ARF,XL         POINT XL TO POSSIBLE VCBLK OR TBBLK
       MOV  (XL),WC          LOAD FIRST WORD
       BEQ  WC,=B_ART,ARF01  JUMP IF ARBLK
       BEQ  WC,=B_VCT,ARF07  JUMP IF VCBLK
       BEQ  WC,=B_TBT,ARF10  JUMP IF TBBLK
       ERB  235,Subscripted operand is not table or array
ARF01  BNE  WA,ARNDM(XL),ARF09 JUMP IF WRONG NUMBER OF DIMS
       LDI  INTV0            GET INITIAL SUBSCRIPT OF ZERO
       MOV  XR,XT            POINT BEFORE SUBSCRIPTS
       ZER  WA               INITIAL OFFSET TO BOUNDS
       BRN  ARF03            JUMP INTO LOOP
ARF02  MLI  ARDM2(XR)        MULTIPLY TOTAL BY NEXT DIMENSION
ARF03  MOV  -(XT),XR         LOAD NEXT SUBSCRIPT
       STI  ARFSI            SAVE CURRENT SUBSCRIPT
       LDI  ICVAL(XR)        LOAD INTEGER VALUE IN CASE
       BEQ  (XR),=B_ICL,ARF04 JUMP IF IT WAS AN INTEGER
       JSR  GTINT            CONVERT TO INTEGER
       PPM  ARF12            JUMP IF NOT INTEGER
       LDI  ICVAL(XR)        IF OK, LOAD INTEGER VALUE
ARF04  MOV  R_ARF,XR         POINT TO ARRAY
       ADD  WA,XR            OFFSET TO NEXT BOUNDS
       SBI  ARLBD(XR)        SUBTRACT LOW BOUND TO COMPARE
       IOV  ARF13            OUT OF RANGE FAIL IF OVERFLOW
       ILT  ARF13            OUT OF RANGE FAIL IF TOO SMALL
       SBI  ARDIM(XR)        SUBTRACT DIMENSION
       IGE  ARF13            OUT OF RANGE FAIL IF TOO LARGE
       ADI  ARDIM(XR)        ELSE RESTORE SUBSCRIPT OFFSET
       ADI  ARFSI            ADD TO CURRENT TOTAL
       ADD  *ARDMS,WA        POINT TO NEXT BOUNDS
       BNE  XT,XS,ARF02      LOOP BACK IF MORE TO GO
       MFI  WA               GET AS ONE WORD INTEGER
       WTB  WA               CONVERT TO OFFSET
       MOV  R_ARF,XL         POINT TO ARBLK
       ADD  AROFS(XL),WA     ADD OFFSET PAST BOUNDS
       ICA  WA               ADJUST FOR ARPRO FIELD
       BNZ  WB,ARF08         EXIT WITH NAME IF NAME CALL
ARF05  JSR  ACESS            GET VALUE
       PPM  ARF13            FAIL IF ACESS FAILS
ARF06  MOV  ARFXS,XS         POP STACK ENTRIES
       ZER  R_ARF            FINISHED WITH ARRAY POINTER
       MOV  XR,-(XS)         STACK RESULT
       LCW  XR               GET NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
ARF07  BNE  WA,=NUM01,ARF09  ERROR IF MORE THAN 1 SUBSCRIPT
       MOV  (XS),XR          ELSE LOAD SUBSCRIPT
       JSR  GTINT            CONVERT TO INTEGER
       PPM  ARF12            ERROR IF NOT INTEGER
       LDI  ICVAL(XR)        ELSE LOAD INTEGER VALUE
       SBI  INTV1            SUBTRACT FOR ONES OFFSET
       MFI  WA,ARF13         GET SUBSCRIPT AS ONE WORD
       ADD  =VCVLS,WA        ADD OFFSET FOR STANDARD FIELDS
       WTB  WA               CONVERT OFFSET TO BYTES
       BGE  WA,VCLEN(XL),ARF13 FAIL IF OUT OF RANGE SUBSCRIPT
       BZE  WB,ARF05         BACK TO GET VALUE IF VALUE CALL
ARF08  MOV  ARFXS,XS         POP STACK ENTRIES
       ZER  R_ARF            FINISHED WITH ARRAY POINTER
       BRN  EXNAM            ELSE EXIT WITH NAME
ARF09  ERB  236,Array referenced with wrong number of subscripts
ARF10  BNE  WA,=NUM01,ARF11  ERROR IF MORE THAN 1 SUBSCRIPT
       MOV  (XS),XR          ELSE LOAD SUBSCRIPT
       JSR  TFIND            CALL TABLE SEARCH ROUTINE
       PPM  ARF13            FAIL IF FAILED
       BNZ  WB,ARF08         EXIT WITH NAME IF NAME CALL
       BRN  ARF06            ELSE EXIT WITH VALUE
ARF11  ERB  237,Table referenced with more than one subscript
ARF12  ERB  238,Array subscript is not integer
ARF13  ZER  R_ARF            FINISHED WITH ARRAY POINTER
       BRN  EXFAL            FAIL
CFUNC  RTN
       BLT  WA,FARGS(XL),CFNC1 JUMP IF TOO FEW ARGUMENTS
       BEQ  WA,FARGS(XL),CFNC3 JUMP IF CORRECT NUMBER OF ARGS
       MOV  WA,WB            COPY ACTUAL NUMBER
       SUB  FARGS(XL),WB     GET NUMBER OF EXTRA ARGS
       WTB  WB               CONVERT TO BYTES
       ADD  WB,XS            POP OFF UNWANTED ARGUMENTS
       BRN  CFNC3            JUMP TO GO OFF TO FUNCTION
CFNC1  MOV  FARGS(XL),WB     LOAD REQUIRED NUMBER OF ARGUMENTS
       BEQ  WB,=NINI9,CFNC3  JUMP IF CASE OF VAR NUM OF ARGS
       SUB  WA,WB            CALCULATE NUMBER MISSING
       LCT  WB,WB            SET COUNTER TO CONTROL LOOP
CFNC2  MOV  =NULLS,-(XS)     STACK A NULL ARGUMENT
       BCT  WB,CFNC2         LOOP TILL PROPER NUMBER STACKED
CFNC3  BRI  (XL)             JUMP THROUGH FCODE FIELD
EXFAL  RTN
       MOV  FLPTR,XS         POP STACK
       MOV  (XS),XR          LOAD FAILURE OFFSET
       ADD  R_COD,XR         POINT TO FAILURE CODE LOCATION
       LCP  XR               SET CODE POINTER
       LCW  XR               LOAD NEXT CODE WORD
       MOV  (XR),XL          LOAD ENTRY ADDRESS
       BRI  XL               JUMP TO EXECUTE NEXT CODE WORD
EXINT  RTN
       ZER  XL               CLEAR DUD VALUE
       JSR  ICBLD            BUILD ICBLK
EXIXR  RTN
       MOV  XR,-(XS)         STACK RESULT
EXITS  RTN
       LCW  XR               LOAD NEXT CODE WORD
       MOV  (XR),XL          LOAD ENTRY ADDRESS
       BRI  XL               JUMP TO EXECUTE NEXT CODE WORD
EXNAM  RTN
       MOV  XL,-(XS)         STACK NAME BASE
       MOV  WA,-(XS)         STACK NAME OFFSET
       LCW  XR               LOAD NEXT CODE WORD
       BRI  (XR)             EXECUTE IT
EXNUL  RTN
       MOV  =NULLS,-(XS)     STACK NULL VALUE
       LCW  XR               LOAD NEXT CODE WORD
       MOV  (XR),XL          LOAD ENTRY ADDRESS
       BRI  XL               JUMP TO EXECUTE NEXT CODE WORD
.IF    .CNRA
.ELSE
EXREA  RTN
       ZER  XL               CLEAR DUD VALUE
       JSR  RCBLD            BUILD RCBLK
       BRN  EXIXR            JUMP TO EXIT WITH RESULT IN XR
.FI
EXSID  RTN
       MOV  CURID,WA         LOAD CURRENT ID VALUE
       BNE  WA,=CFP_M,EXSI1  JUMP IF NO OVERFLOW
       ZER  WA               ELSE RESET FOR WRAPAROUND
EXSI1  ICV  WA               BUMP ID VALUE
       MOV  WA,CURID         STORE FOR NEXT TIME
       MOV  WA,IDVAL(XR)     STORE ID VALUE
       BRN  EXIXR            EXIT WITH RESULT IN (XR)
EXVNM  RTN
       MOV  XR,XL            COPY NAME BASE POINTER
       MOV  *NMSI_,WA        SET SIZE OF NMBLK
       JSR  ALLOC            ALLOCATE NMBLK
       MOV  =B_NML,(XR)      STORE TYPE WORD
       MOV  XL,NMBAS(XR)     STORE NAME BASE
       MOV  *VRVAL,NMOFS(XR) STORE NAME OFFSET
       BRN  EXIXR            EXIT WITH RESULT IN XR
FLPOP  RTN
       ADD  *NUM02,XS        POP TWO ENTRIES OFF STACK
FAILP  RTN
       MOV  (XS)+,XR         LOAD ALTERNATIVE NODE POINTER
       MOV  (XS)+,WB         RESTORE OLD CURSOR
       MOV  (XR),XL          LOAD PCODE ENTRY POINTER
       BRI  XL               JUMP TO EXECUTE CODE FOR NODE
INDIR  RTN
       MOV  (XS)+,XR         LOAD ARGUMENT
       BEQ  (XR),=B_NML,INDR2 JUMP IF A NAME
       JSR  GTNVR            ELSE CONVERT TO VARIABLE
       ERR  239,Indirection operand is not name
       BZE  WB,INDR1         SKIP IF BY VALUE
       MOV  XR,-(XS)         ELSE STACK VRBLK PTR
       MOV  *VRVAL,-(XS)     STACK NAME OFFSET
       LCW  XR               LOAD NEXT CODE WORD
       MOV  (XR),XL          LOAD ENTRY ADDRESS
       BRI  XL               JUMP TO EXECUTE NEXT CODE WORD
INDR1  BRI  (XR)             JUMP THROUGH VRGET FIELD OF VRBLK
INDR2  MOV  NMBAS(XR),XL     LOAD NAME BASE
       MOV  NMOFS(XR),WA     LOAD NAME OFFSET
       BNZ  WB,EXNAM         EXIT IF CALLED BY NAME
       JSR  ACESS            ELSE GET VALUE FIRST
       PPM  EXFAL            FAIL IF ACCESS FAILS
       BRN  EXIXR            ELSE RETURN WITH VALUE IN XR
MATCH  RTN
       MOV  (XS)+,XR         LOAD PATTERN OPERAND
       JSR  GTPAT            CONVERT TO PATTERN
       ERR  240,Pattern match right operand is not pattern
       MOV  XR,XL            IF OK, SAVE PATTERN POINTER
       BNZ  WB,MTCH1         JUMP IF NOT MATCH BY NAME
       MOV  (XS),WA          ELSE LOAD NAME OFFSET
       MOV  XL,-(XS)         SAVE PATTERN POINTER
       MOV  NUM02(XS),XL     LOAD NAME BASE
       JSR  ACESS            ACCESS SUBJECT VALUE
       PPM  EXFAL            FAIL IF ACCESS FAILS
       MOV  (XS),XL          RESTORE PATTERN POINTER
       MOV  XR,(XS)          STACK SUBJECT STRING VAL FOR MERGE
       ZER  WB               RESTORE TYPE CODE
.IF    .CNBF
MTCH1  JSR  GTSTG            CONVERT SUBJECT TO STRING
       ERR  241,Pattern match left operand is not a string
       MOV  WB,-(XS)         STACK MATCH TYPE CODE
.ELSE
MTCH1  MOV  WB,WC            SAVE MATCH TYPE IN WC
       JSR  GTSTB            CONVERT SUBJECT TO STRING
       ERR  241,Pattern match left operand is not a string or buffer
       MOV  WB,R_PMB         SET TO ZERO/BCBLK IF STRING/BUFFER
       MOV  WC,-(XS)         STACK MATCH TYPE CODE
.FI
       MOV  XR,R_PMS         IF OK, STORE SUBJECT STRING POINTER
       MOV  WA,PMSSL         AND LENGTH
       ZER  -(XS)            STACK INITIAL CURSOR (ZERO)
       ZER  WB               SET INITIAL CURSOR
       MOV  XS,PMHBS         SET HISTORY STACK BASE PTR
       ZER  PMDFL            RESET PATTERN ASSIGNMENT FLAG
       MOV  XL,XR            SET INITIAL NODE POINTER
       BNZ  KVANC,MTCH2      JUMP IF ANCHORED
       MOV  XR,-(XS)         STACK INITIAL NODE POINTER
       MOV  =NDUNA,-(XS)     STACK POINTER TO ANCHOR MOVE NODE
       BRI  (XR)             START MATCH OF FIRST NODE
MTCH2  ZER  -(XS)            DUMMY CURSOR VALUE
       MOV  =NDABO,-(XS)     STACK POINTER TO ABORT NODE
       BRI  (XR)             START MATCH OF FIRST NODE
RETRN  RTN
       BNZ  KVFNC,RTN01      JUMP IF NOT LEVEL ZERO
       ERB  242,Function return from level zero
RTN01  MOV  FLPRT,XS         POP STACK
       ICA  XS               REMOVE FAILURE OFFSET
       MOV  (XS)+,XR         POP PFBLK POINTER
       MOV  (XS)+,FLPTR      POP FAILURE POINTER
       MOV  (XS)+,FLPRT      POP OLD FLPRT
       MOV  (XS)+,WB         POP CODE POINTER OFFSET
       MOV  (XS)+,WC         POP OLD CODE BLOCK POINTER
       ADD  WC,WB            MAKE OLD CODE POINTER ABSOLUTE
       LCP  WB               RESTORE OLD CODE POINTER
       MOV  WC,R_COD         RESTORE OLD CODE BLOCK POINTER
       DCV  KVFNC            DECREMENT FUNCTION LEVEL
       MOV  KVTRA,WB         LOAD TRACE
       ADD  KVFTR,WB         ADD FTRACE
       BZE  WB,RTN06         JUMP IF NO TRACING POSSIBLE
       MOV  WA,-(XS)         SAVE FUNCTION RETURN TYPE
       MOV  XR,-(XS)         SAVE PFBLK POINTER
       MOV  WA,KVRTN         SET RTNTYPE FOR TRACE FUNCTION
       MOV  R_FNC,XL         LOAD FNCLEVEL TRBLK PTR (IF ANY)
       JSR  KTREX            EXECUTE POSSIBLE FNCLEVEL TRACE
       MOV  PFVBL(XR),XL     LOAD VRBLK PTR (SGD13)
       BZE  KVTRA,RTN02      JUMP IF TRACE IS OFF
       MOV  PFRTR(XR),XR     ELSE LOAD RETURN TRACE TRBLK PTR
       BZE  XR,RTN02         JUMP IF NOT RETURN TRACED
       DCV  KVTRA            ELSE DECREMENT TRACE COUNT
       BZE  TRFNC(XR),RTN03  JUMP IF PRINT TRACE
       MOV  *VRVAL,WA        ELSE SET NAME OFFSET
       MOV  NUM01(XS),KVRTN  MAKE SURE RTNTYPE IS SET RIGHT
       JSR  TRXEQ            EXECUTE FULL TRACE
RTN02  BZE  KVFTR,RTN05      JUMP IF FTRACE IS OFF
       DCV  KVFTR            ELSE DECREMENT FTRACE
RTN03  JSR  PRTSN            PRINT STATEMENT NUMBER
       MOV  NUM01(XS),XR     LOAD RETURN TYPE
       JSR  PRTST            PRINT IT
       MOV  =CH_BL,WA        LOAD BLANK
       JSR  PRTCH            PRINT IT
       MOV  0(XS),XL         LOAD PFBLK PTR
       MOV  PFVBL(XL),XL     LOAD FUNCTION VRBLK PTR
       MOV  *VRVAL,WA        SET VRBLK NAME OFFSET
       BNE  XR,=SCFRT,RTN04  JUMP IF NOT FRETURN CASE
       JSR  PRTNM            PRINT NAME
       JSR  PRTNL            TERMINATE PRINT LINE
       BRN  RTN05            MERGE
RTN04  JSR  PRTNV            PRINT NAME = VALUE
RTN05  MOV  (XS)+,XR         POP PFBLK POINTER
       MOV  (XS)+,WA         POP RETURN TYPE STRING
RTN06  MOV  WA,KVRTN         SET RTNTYPE KEYWORD
       MOV  PFVBL(XR),XL     LOAD POINTER TO FN VRBLK
RTN07  MOV  XL,RTNBP         SAVE BLOCK POINTER
       MOV  VRVAL(XL),XL     LOAD VALUE
       BEQ  (XL),=B_TRT,RTN07 LOOP BACK IF TRAPPED
       MOV  XL,RTNFV         ELSE SAVE FUNCTION RESULT VALUE
       MOV  (XS)+,RTNSV      SAVE ORIGINAL FUNCTION VALUE
.IF    .CNPF
       MOV  FARGS(XR),WB     GET NUMBER OF ARGUMENTS
.ELSE
       MOV  (XS)+,XL         POP SAVED POINTER
       BZE  XL,RTN7C         NO ACTION IF NONE
       BZE  KVPFL,RTN7C      JUMP IF NO PROFILING
       JSR  PRFLU            ELSE PROFILE LAST FUNC STMT
       BEQ  KVPFL,=NUM02,RTN7A BRANCH ON VALUE OF PROFILE KEYWD
       LDI  PFSTM            LOAD CURRENT TIME
       SBI  ICVAL(XL)        FRIG BY SUBTRACTING SAVED AMOUNT
       BRN  RTN7B            AND MERGE
RTN7A  LDI  ICVAL(XL)        LOAD SAVED TIME
RTN7B  STI  PFSTM            STORE BACK CORRECT START TIME
RTN7C  MOV  FARGS(XR),WB     GET NUMBER OF ARGS
.FI
       ADD  PFNLO(XR),WB     ADD NUMBER OF LOCALS
       BZE  WB,RTN10         JUMP IF NO ARGS/LOCALS
       LCT  WB,WB            ELSE SET LOOP COUNTER
       ADD  PFLEN(XR),XR     AND POINT TO END OF PFBLK
RTN08  MOV  -(XR),XL         LOAD NEXT VRBLK POINTER
RTN09  MOV  XL,WA            SAVE BLOCK POINTER
       MOV  VRVAL(XL),XL     LOAD POINTER TO NEXT VALUE
       BEQ  (XL),=B_TRT,RTN09 LOOP BACK IF TRAPPED
       MOV  WA,XL            ELSE RESTORE LAST BLOCK POINTER
       MOV  (XS)+,VRVAL(XL)  RESTORE OLD VARIABLE VALUE
       BCT  WB,RTN08         LOOP TILL ALL PROCESSED
RTN10  MOV  RTNBP,XL         RESTORE PTR TO LAST FUNCTION BLOCK
       MOV  RTNSV,VRVAL(XL)  RESTORE OLD FUNCTION VALUE
       MOV  RTNFV,XR         RELOAD FUNCTION RESULT
       MOV  R_COD,XL         POINT TO NEW CODE BLOCK
       MOV  KVSTN,KVLST      SET LASTNO FROM STNO
       MOV  CDSTM(XL),KVSTN  RESET PROPER STNO VALUE
.IF    .CSLN
       MOV  KVLIN,KVLLN      SET LASTLINE FROM LINE
       MOV  CDSLN(XL),KVLIN  RESET PROPER LINE VALUE
.FI
       MOV  KVRTN,WA         LOAD RETURN TYPE
       BEQ  WA,=SCRTN,EXIXR  EXIT WITH RESULT IN XR IF RETURN
       BEQ  WA,=SCFRT,EXFAL  FAIL IF FRETURN
       BEQ  (XR),=B_NML,RTN11 JUMP IF IS A NAME
       JSR  GTNVR            ELSE TRY CONVERT TO VARIABLE NAME
       ERR  243,Function result in NRETURN is not name
       MOV  XR,XL            IF OK, COPY VRBLK (NAME BASE) PTR
       MOV  *VRVAL,WA        SET NAME OFFSET
       BRN  RTN12            AND MERGE
RTN11  MOV  NMBAS(XR),XL     LOAD NAME BASE
       MOV  NMOFS(XR),WA     LOAD NAME OFFSET
RTN12  MOV  XL,XR            PRESERVE XL
       LCW  WB               LOAD NEXT WORD
       MOV  XR,XL            RESTORE XL
       BEQ  WB,=OFNE_,EXNAM  EXIT IF CALLED BY NAME
       MOV  WB,-(XS)         ELSE SAVE CODE WORD
       JSR  ACESS            GET VALUE
       PPM  EXFAL            FAIL IF ACCESS FAILS
       MOV  XR,XL            IF OK, COPY RESULT
       MOV  (XS),XR          RELOAD NEXT CODE WORD
       MOV  XL,(XS)          STORE RESULT ON STACK
       MOV  (XR),XL          LOAD ROUTINE ADDRESS
       BRI  XL               JUMP TO EXECUTE NEXT CODE WORD
STCOV  RTN
       ICV  ERRFT            FATAL ERROR
       LDI  INTVT            GET 10
       ADI  KVSTL            ADD TO FORMER LIMIT
       STI  KVSTL            STORE AS NEW STLIMIT
       LDI  INTVT            GET 10
       STI  KVSTC            SET AS NEW COUNT
       JSR  STGCC            RECOMPUTE COUNTDOWN COUNTERS
       ERB  244,Statement count exceeds value of STLIMIT keyword
STMGO  RTN
       MOV  XR,R_COD         SET NEW CODE BLOCK POINTER
       DCV  STMCT            SEE IF TIME TO CHECK SOMETHING
       BZE  STMCT,STGO2      JUMP IF SO
       MOV  KVSTN,KVLST      SET LASTNO
       MOV  CDSTM(XR),KVSTN  SET STNO
.IF    .CSLN
       MOV  KVLIN,KVLLN      SET LASTLINE
       MOV  CDSLN(XR),KVLIN  SET LINE
.FI
       ADD  *CDCOD,XR        POINT TO FIRST CODE WORD
       LCP  XR               SET CODE POINTER
STGO1  LCW  XR               LOAD NEXT CODE WORD
       ZER  XL               CLEAR GARBAGE XL
       BRI  (XR)             EXECUTE IT
STGO2  BZE  KVPFL,STGO3      SKIP IF NO PROFILING
       JSR  PRFLU            ELSE PROFILE THE STATEMENT IN KVSTN
STGO3  MOV  KVSTN,KVLST      SET LASTNO
       MOV  CDSTM(XR),KVSTN  SET STNO
.IF    .CSLN
       MOV  KVLIN,KVLLN      SET LASTLINE
       MOV  CDSLN(XR),KVLIN  SET LINE
.FI
       ADD  *CDCOD,XR        POINT TO FIRST CODE WORD
       LCP  XR               SET CODE POINTER
.IF    .CPOL
       MOV  STMCS,-(XS)      SAVE PRESENT COUNT START ON STACK
       DCV  POLCT            POLL INTERVAL WITHIN STMCT
       BNZ  POLCT,STGO4      JUMP IF NOT POLL TIME YET
       ZER  WA               =0 FOR POLL
       MOV  KVSTN,WB         STATEMENT NUMBER
       MOV  XR,XL            MAKE COLLECTABLE
       JSR  SYSPL            ALLOW INTERACTIVE ACCESS
       ERR  320,User interrupt
       PPM                   SINGLE STEP
       PPM                   EXPRESSION EVALUATION
       MOV  XL,XR            RESTORE CODE BLOCK POINTER
       MOV  WA,POLCS         POLL INTERVAL START VALUE
       JSR  STGCC            RECOMPUTE COUNTER VALUES
.FI
STGO4  LDI  KVSTC            GET STMT COUNT
       ILT  STGO5            OMIT COUNTING IF NEGATIVE
       MTI  (XS)+            RELOAD START VALUE OF COUNTER
       NGI                   NEGATE
       ADI  KVSTC            STMT COUNT MINUS COUNTER
       STI  KVSTC            REPLACE IT
       ILE  STCOV            FAIL IF STLIMIT REACHED
       BZE  R_STC,STGO5      JUMP IF NO STATEMENT TRACE
       ZER  XR               CLEAR GARBAGE VALUE IN XR
       MOV  R_STC,XL         LOAD POINTER TO STCOUNT TRBLK
       JSR  KTREX            EXECUTE KEYWORD TRACE
STGO5  MOV  STMCS,STMCT      RESET COUNTER
       BRN  STGO1            FETCH NEXT CODE WORD
STOPR  RTN
.IF    .CSAX
       BZE  XR,STPRA         SKIP IF SYSAX ALREADY CALLED
       JSR  SYSAX            CALL AFTER EXECUTION PROC
STPRA  ADD  RSMEM,DNAME      USE THE RESERVE MEMORY
.ELSE
       ADD  RSMEM,DNAME      USE THE RESERVE MEMORY
.FI
       BNE  XR,=ENDMS,STPR0  SKIP IF NOT NORMAL END MESSAGE
       BNZ  EXSTS,STPR3      SKIP IF EXEC STATS SUPPRESSED
       ZER  ERICH            CLEAR ERRORS TO INT.CH. FLAG
STPR0  JSR  PRTPG            EJECT PRINTER
       BZE  XR,STPR1         SKIP IF NO MESSAGE
       JSR  PRTST            PRINT MESSAGE
STPR1  JSR  PRTIS            PRINT BLANK LINE
.IF    .CSFN
       BNZ  GBCFL,STPR5      IF IN GARBAGE COLLECTION, SKIP
       MOV  =STPM7,XR        POINT TO MESSAGE /IN FILE XXX/
       JSR  PRTST            PRINT IT
       MOV  =PRTMF,PROFS     SET COLUMN OFFSET
       MOV  KVSTN,WC         GET STATEMENT NUMBER
       JSR  FILNM            GET FILE NAME
       MOV  XL,XR            PREPARE TO PRINT
       JSR  PRTST            PRINT FILE NAME
       JSR  PRTIS            PRINT TO INTERACTIVE CHANNEL
.FI
.IF    .CSLN
.IF    .CSFN
.ELSE
       BNZ  GBCFL,STPR5      IF IN GARBAGE COLLECTION, SKIP
.FI
       MOV  R_COD,XR         GET CODE POINTER
       MTI  CDSLN(XR)        GET SOURCE LINE NUMBER
       MOV  =STPM6,XR        POINT TO MESSAGE /IN LINE XXX/
       JSR  PRTMX            PRINT IT
.FI
STPR5  MTI  KVSTN            GET STATEMENT NUMBER
       MOV  =STPM1,XR        POINT TO MESSAGE /IN STATEMENT XXX/
       JSR  PRTMX            PRINT IT
       JSR  SYSTM            GET CURRENT TIME
       SBI  TIMSX            MINUS START TIME = ELAPSED EXEC TIM
       STI  STPTI            SAVE FOR LATER
       MOV  =STPM3,XR        POINT TO MSG /EXECUTION TIME MSEC /
       JSR  PRTMX            PRINT IT
       LDI  KVSTL            GET STATEMENT LIMIT
       ILT  STPR2            SKIP IF NEGATIVE
       SBI  KVSTC            MINUS COUNTER = COURSE COUNT
       STI  STPSI            SAVE
       MOV  STMCS,WA         REFINE WITH COUNTER START VALUE
       SUB  STMCT,WA         MINUS CURRENT COUNTER
       MTI  WA               CONVERT TO INTEGER
       ADI  STPSI            ADD IN COURSE COUNT
       STI  STPSI            SAVE
       MOV  =STPM2,XR        POINT TO MESSAGE /STMTS EXECUTED/
       JSR  PRTMX            PRINT IT
.IF    .CTMD
.ELSE
       LDI  STPTI            RELOAD ELAPSED TIME
       MLI  INTTH            *1000 (MICROSECS)
       IOV  STPR2            JUMP IF WE CANNOT COMPUTE
       DVI  STPSI            DIVIDE BY STATEMENT COUNT
       IOV  STPR2            JUMP IF OVERFLOW
       MOV  =STPM4,XR        POINT TO MSG (MCSEC PER STATEMENT /
       JSR  PRTMX            PRINT IT
.FI
STPR2  MTI  GBCNT            LOAD COUNT OF COLLECTIONS
       MOV  =STPM5,XR        POINT TO MESSAGE /REGENERATIONS /
       JSR  PRTMX            PRINT IT
       JSR  PRTMM            PRINT MEMORY USAGE
       JSR  PRTIS            ONE MORE BLANK FOR LUCK
.IF    .CNPF
STPR3  MOV  KVDMP,XR         LOAD DUMP KEYWORD
.ELSE
STPR3  JSR  PRFLR            PRINT PROFILE IF WANTED
       MOV  KVDMP,XR         LOAD DUMP KEYWORD
.FI
       JSR  DUMPR            EXECUTE DUMP IF REQUESTED
       MOV  R_FCB,XL         GET FCBLK CHAIN HEAD
       MOV  KVABE,WA         LOAD ABEND VALUE
       MOV  KVCOD,WB         LOAD CODE VALUE
       JSR  SYSEJ            EXIT TO SYSTEM
.IF    .CERA
STPR4  RTN
       ADD  RSMEM,DNAME      USE THE RESERVE MEMORY
       BZE  EXSTS,STPR1      IF EXECUTION STATS REQUESTED
       BRN  STPR3            CHECK IF DUMP OR PROFILE NEEDED
.FI

SUCCP  RTN
       MOV  PTHEN(XR),XR     LOAD SUCCESSOR NODE
       MOV  (XR),XL          LOAD NODE CODE ENTRY ADDRESS
       BRI  XL               JUMP TO MATCH SUCCESSOR NODE
SYSAB  RTN
       MOV  =ENDAB,XR        POINT TO MESSAGE
       MOV  =NUM01,KVABE     SET ABEND FLAG
       JSR  PRTNL            SKIP TO NEW LINE
       BRN  STOPR            JUMP TO PACK UP
SYSTU  RTN
       MOV  =ENDTU,XR        POINT TO MESSAGE
       MOV  STRTU,WA         GET CHARS /TU/
       MOV  WA,KVCOD         PUT IN KVCOD
       MOV  TIMUP,WA         CHECK STATE OF TIMEUP SWITCH
       MNZ  TIMUP            SET SWITCH
       BNZ  WA,STOPR         STOP RUN IF ALREADY SET
       ERB  245,Translation/execution time expired
       TTL  S P I T B O L -- UTILITY PROCEDURES
ACESS  PRC  R,1              ENTRY POINT (RECURSIVE)
       MOV  XL,XR            COPY NAME BASE
       ADD  WA,XR            POINT TO VARIABLE LOCATION
       MOV  (XR),XR          LOAD VARIABLE VALUE
ACS02  BNE  (XR),=B_TRT,ACS18 JUMP IF NOT TRAPPED
       BEQ  XR,=TRBKV,ACS12  JUMP IF KEYWORD VARIABLE
       BNE  XR,=TRBEV,ACS05  JUMP IF NOT EXPRESSION VARIABLE
       MOV  EVEXP(XL),XR     LOAD EXPRESSION POINTER
       ZER  WB               EVALUATE BY VALUE
       JSR  EVALX            EVALUATE EXPRESSION
       PPM  ACS04            JUMP IF EVALUATION FAILURE
       BRN  ACS02            CHECK VALUE FOR MORE TRBLKS
ACS03  ADD  *NUM03,XS        POP TRBLK PTR, NAME BASE AND OFFSET
       MOV  XR,DNAMP         POP UNUSED SCBLK
ACS04  EXI  1                TAKE ALTERNATE (FAILURE) RETURN
ACS05  MOV  TRTYP(XR),WB     LOAD TRAP TYPE CODE
       BNZ  WB,ACS10         JUMP IF NOT INPUT ASSOCIATION
       BZE  KVINP,ACS09      IGNORE INPUT ASSOC IF INPUT IS OFF
       MOV  XL,-(XS)         STACK NAME BASE
       MOV  WA,-(XS)         STACK NAME OFFSET
       MOV  XR,-(XS)         STACK TRBLK POINTER
       MOV  KVTRM,ACTRM      TEMP TO HOLD TRIM KEYWORD
       MOV  TRFPT(XR),XL     GET FILE CTRL BLK PTR OR ZERO
       BNZ  XL,ACS06         JUMP IF NOT STANDARD INPUT FILE
       BEQ  TRTER(XR),=V_TER,ACS21 JUMP IF TERMINAL
       MOV  CSWIN,WA         LENGTH FOR READ BUFFER
       JSR  ALOCS            BUILD STRING OF APPROPRIATE LENGTH
       JSR  SYSRD            READ NEXT STANDARD INPUT IMAGE
       PPM  ACS03            JUMP TO FAIL EXIT IF END OF FILE
       BRN  ACS07            ELSE MERGE WITH OTHER FILE CASE
ACS06  MOV  XL,WA            FCBLK PTR
       JSR  SYSIL            GET INPUT RECORD MAX LENGTH (TO WA)
       BNZ  WC,ACS6A         JUMP IF NOT BINARY FILE
       MOV  WC,ACTRM         DISABLE TRIM FOR BINARY FILE
ACS6A  JSR  ALOCS            ALLOCATE STRING OF CORRECT SIZE
       MOV  XL,WA            FCBLK PTR
       JSR  SYSIN            CALL SYSTEM INPUT ROUTINE
       PPM  ACS03            JUMP TO FAIL EXIT IF END OF FILE
       PPM  ACS22            ERROR
       PPM  ACS23            ERROR
ACS07  MOV  ACTRM,WB         LOAD TRIM INDICATOR
       JSR  TRIMR            TRIM RECORD AS REQUIRED
       MOV  XR,WB            COPY RESULT POINTER
       MOV  (XS),XR          RELOAD POINTER TO TRBLK
ACS08  MOV  XR,XL            SAVE POINTER TO THIS TRBLK
       MOV  TRNXT(XR),XR     LOAD FORWARD POINTER
       BEQ  (XR),=B_TRT,ACS08 LOOP IF THIS IS ANOTHER TRBLK
       MOV  WB,TRNXT(XL)     ELSE STORE RESULT AT END OF CHAIN
       MOV  (XS)+,XR         RESTORE INITIAL TRBLK POINTER
       MOV  (XS)+,WA         RESTORE NAME OFFSET
       MOV  (XS)+,XL         RESTORE NAME BASE POINTER
ACS09  MOV  TRNXT(XR),XR     LOAD FORWARD PTR TO NEXT VALUE
       BRN  ACS02            BACK TO CHECK IF TRAPPED
ACS10  BNE  WB,=TRTAC,ACS09  LOOP BACK IF NOT ACCESS TRACE
       BZE  KVTRA,ACS09      IGNORE ACCESS TRACE IF TRACE OFF
       DCV  KVTRA            ELSE DECREMENT TRACE COUNT
       BZE  TRFNC(XR),ACS11  JUMP IF PRINT TRACE
       JSR  TRXEQ            CALL ROUTINE TO EXECUTE TRACE
       BRN  ACS09            JUMP FOR NEXT TRBLK
ACS11  JSR  PRTSN            PRINT STATEMENT NUMBER
       JSR  PRTNV            PRINT NAME = VALUE
       BRN  ACS09            JUMP BACK FOR NEXT TRBLK
ACS12  MOV  KVNUM(XL),XR     LOAD KEYWORD NUMBER
       BGE  XR,=K_V__,ACS14  JUMP IF NOT ONE WORD VALUE
       MTI  KVABE(XR)        ELSE LOAD VALUE AS INTEGER
ACS13  JSR  ICBLD            BUILD ICBLK
       BRN  ACS18            JUMP TO EXIT
ACS14  BGE  XR,=K_S__,ACS15  JUMP IF SPECIAL CASE
       SUB  =K_V__,XR        ELSE GET OFFSET
       WTB  XR               CONVERT TO BYTE OFFSET
       ADD  =NDABO,XR        POINT TO PATTERN VALUE
       BRN  ACS18            JUMP TO EXIT
ACS15  MOV  KVRTN,XL         LOAD RTNTYPE IN CASE
       LDI  KVSTL            LOAD STLIMIT IN CASE
       SUB  =K_S__,XR        GET CASE NUMBER
       BSW  XR,K__N_         SWITCH ON KEYWORD NUMBER
.IF    .CSFN
       IFF  K__FL,ACS26      FILE
       IFF  K__LF,ACS27      LASTFILE
.FI
.IF    .CULK
       IFF  K__LC,ACS24      LCASE
       IFF  K__UC,ACS25      UCASE
.FI
       IFF  K__AL,ACS16      JUMP IF ALPHABET
       IFF  K__RT,ACS17      RTNTYPE
       IFF  K__SC,ACS19      STCOUNT
       IFF  K__SL,ACS13      STLIMIT
       IFF  K__ET,ACS20      ERRTEXT
       ESW                   END SWITCH ON KEYWORD NUMBER
.IF    .CULK
ACS24  MOV  =LCASE,XR        LOAD POINTER TO LCASE STRING
       BRN  ACS18            COMMON RETURN
ACS25  MOV  =UCASE,XR        LOAD POINTER TO UCASE STRING
       BRN  ACS18            COMMON RETURN
.FI
.IF    .CSFN
ACS26  MOV  KVSTN,WC         LOAD CURRENT STMT NUMBER
       BRN  ACS28            MERGE TO OBTAIN FILE NAME
ACS27  MOV  KVLST,WC         LOAD LAST STMT NUMBER
ACS28  JSR  FILNM            OBTAIN FILE NAME FOR THIS STMT
       BRN  ACS17            MERGE TO RETURN STRING IN XL
.FI
ACS16  MOV  KVALP,XL         LOAD POINTER TO ALPHABET STRING
ACS17  MOV  XL,XR            COPY STRING PTR TO PROPER REG
ACS18  EXI                   RETURN TO ACESS CALLER
ACS19  ILT  ACS29            IF COUNTING SUPPRESSED
       MOV  STMCS,WA         REFINE WITH COUNTER START VALUE
       SUB  STMCT,WA         MINUS CURRENT COUNTER
       MTI  WA               CONVERT TO INTEGER
       ADI  KVSTL            ADD STLIMIT
ACS29  SBI  KVSTC            STCOUNT = LIMIT - LEFT
       BRN  ACS13            MERGE BACK WITH INTEGER RESULT
ACS20  MOV  R_ETX,XR         GET ERRTEXT STRING
       BRN  ACS18            MERGE WITH RESULT
ACS21  MOV  =RILEN,WA        BUFFER LENGTH
       JSR  ALOCS            ALLOCATE BUFFER
       JSR  SYSRI            READ RECORD
       PPM  ACS03            ENDFILE
       BRN  ACS07            MERGE WITH RECORD READ
ACS22  MOV  XR,DNAMP         POP UNUSED SCBLK
       ERB  202,Input from file caused non-recoverable error
ACS23  MOV  XR,DNAMP         POP UNUSED SCBLK
       ERB  203,Input file record has incorrect format
       ENP                   END PROCEDURE ACESS
ACOMP  PRC  N,5              ENTRY POINT
       JSR  ARITH            LOAD ARITHMETIC OPERANDS
       PPM  ACMP7            JUMP IF FIRST ARG NON-NUMERIC
       PPM  ACMP8            JUMP IF SECOND ARG NON-NUMERIC
.IF    .CNRA
.ELSE
       PPM  ACMP4            JUMP IF REAL ARGUMENTS
.FI
       SBI  ICVAL(XL)        SUBTRACT TO COMPARE
       IOV  ACMP3            JUMP IF OVERFLOW
       ILT  ACMP5            ELSE JUMP IF ARG1 LT ARG2
       IEQ  ACMP2            JUMP IF ARG1 EQ ARG2
ACMP1  EXI  5                TAKE GT EXIT
ACMP2  EXI  4                TAKE EQ EXIT
ACMP3  LDI  ICVAL(XL)        LOAD SECOND ARGUMENT
       ILT  ACMP1            GT IF NEGATIVE
       BRN  ACMP5            ELSE LT
.IF    .CNRA
.ELSE
ACMP4  SBR  RCVAL(XL)        SUBTRACT TO COMPARE
       ROV  ACMP6            JUMP IF OVERFLOW
       RGT  ACMP1            ELSE JUMP IF ARG1 GT
       REQ  ACMP2            JUMP IF ARG1 EQ ARG2
.FI
ACMP5  EXI  3                TAKE LT EXIT
.IF    .CNRA
.ELSE
ACMP6  LDR  RCVAL(XL)        RELOAD ARG2
       RLT  ACMP1            GT IF NEGATIVE
       BRN  ACMP5            ELSE LT
.FI
ACMP7  EXI  1                TAKE ERROR EXIT
ACMP8  EXI  2                TAKE ERROR EXIT
       ENP                   END PROCEDURE ACOMP
ALLOC  PRC  E,0              ENTRY POINT
ALOC1  MOV  DNAMP,XR         POINT TO NEXT AVAILABLE LOC
       AOV  WA,XR,ALOC2      POINT PAST ALLOCATED BLOCK
       BGT  XR,DNAME,ALOC2   JUMP IF NOT ENOUGH ROOM
       MOV  XR,DNAMP         STORE NEW POINTER
       SUB  WA,XR            POINT BACK TO START OF ALLOCATED BK
       EXI                   RETURN TO CALLER
ALOC2  MOV  WB,ALLSV         SAVE WB
ALC2A  ZER  WB               SET NO UPWARD MOVE FOR GBCOL
       JSR  GBCOL            GARBAGE COLLECT
.IF    .CSED
       MOV  XR,WB            REMEMBER NEW SEDIMENT SIZE
.FI
ALOC3  MOV  DNAMP,XR         POINT TO FIRST AVAILABLE LOC
       AOV  WA,XR,ALC3A      POINT PAST NEW BLOCK
       BLO  XR,DNAME,ALOC4   JUMP IF THERE IS ROOM NOW
ALC3A  JSR  SYSMM            TRY TO GET MORE MEMORY
       WTB  XR               CONVERT TO BAUS (SGD05)
       ADD  XR,DNAME         BUMP PTR BY AMOUNT OBTAINED
       BNZ  XR,ALOC3         JUMP IF GOT MORE CORE
.IF    .CSED
       BZE  DNAMS,ALC3B      JUMP IF THERE WAS NO SEDIMENT
       ZER  DNAMS            TRY COLLECTING THE SEDIMENT
       BRN  ALC2A
ALC3B  ADD  RSMEM,DNAME      GET THE RESERVE MEMORY
.ELSE
       ADD  RSMEM,DNAME      GET THE RESERVE MEMORY
.FI
       ZER  RSMEM            ONLY PERMISSIBLE ONCE
       ICV  ERRFT            FATAL ERROR
       ERB  204,Memory overflow
ALOC4  STI  ALLIA            SAVE IA
.IF    .CSED
       MOV  WB,DNAMS         RECORD NEW SEDIMENT SIZE
.FI
       MOV  DNAME,WB         GET DYNAMIC END ADRS
       SUB  DNAMP,WB         COMPUTE FREE STORE
       BTW  WB               CONVERT BYTES TO WORDS
       MTI  WB               PUT FREE STORE IN IA
       MLI  ALFSF            MULTIPLY BY FREE STORE FACTOR
       IOV  ALOC5            JUMP IF OVERFLOWED
       MOV  DNAME,WB         DYNAMIC END ADRS
       SUB  DNAMB,WB         COMPUTE TOTAL AMOUNT OF DYNAMIC
       BTW  WB               CONVERT TO WORDS
       MOV  WB,ALDYN         STORE IT
       SBI  ALDYN            SUBTRACT FROM SCALED UP FREE STORE
       IGT  ALOC5            JUMP IF SUFFICIENT FREE STORE
       JSR  SYSMM            TRY TO GET MORE STORE
       WTB  XR               CONVERT TO BAUS (SGD05)
       ADD  XR,DNAME         ADJUST DYNAMIC END ADRS
ALOC5  LDI  ALLIA            RECOVER IA
       MOV  ALLSV,WB         RESTORE WB
       BRN  ALOC1            JUMP BACK TO EXIT
       ENP                   END PROCEDURE ALLOC
.IF    .CNBF
.ELSE
ALOBF  PRC  E,0              ENTRY POINT
       BGT  WA,KVMXL,ALB01   CHECK FOR MAXLNGTH EXCEEDED
       MOV  WA,WB            HANG ONTO ALLOCATION SIZE
       CTB  WA,BFSI_         GET TOTAL BLOCK SIZE
       ADD  *BCSI_,WA        ADD IN ALLOCATION FOR BCBLK
       JSR  ALLOC            ALLOCATE FRAME
       MOV  =B_BCT,(XR)      SET TYPE
       ZER  IDVAL(XR)        NO ID YET
       ZER  BCLEN(XR)        NO DEFINED LENGTH
       MOV  XL,WA            SAVE XL
       MOV  XR,XL            COPY BCBLK PTR
       ADD  *BCSI_,XL        BIAS PAST PARTIALLY BUILT BCBLK
       MOV  =B_BFT,(XL)      SET BFBLK TYPE WORD
       MOV  WB,BFALC(XL)     SET ALLOCATED SIZE
       MOV  XL,BCBUF(XR)     SET POINTER IN BCBLK
       ZER  BFCHR(XL)        CLEAR FIRST WORD (NULL PAD)
       MOV  WA,XL            RESTORE ENTRY XL
       EXI                   RETURN TO CALLER
ALB01  ERB  273,BUFFER size exceeds value of MAXLNGTH keyword
       ENP                   END PROCEDURE ALOBF
.FI
ALOCS  PRC  E,0              ENTRY POINT
       BGT  WA,KVMXL,ALCS2   JUMP IF LENGTH EXCEEDS MAXLENGTH
       MOV  WA,WC            ELSE COPY LENGTH
       CTB  WA,SCSI_         COMPUTE LENGTH OF SCBLK IN BYTES
       MOV  DNAMP,XR         POINT TO NEXT AVAILABLE LOCATION
       AOV  WA,XR,ALCS0      POINT PAST BLOCK
       BLO  XR,DNAME,ALCS1   JUMP IF THERE IS ROOM
ALCS0  ZER  XR               ELSE CLEAR GARBAGE XR VALUE
       JSR  ALLOC            AND USE STANDARD ALLOCATOR
       ADD  WA,XR            POINT PAST END OF BLOCK TO MERGE
ALCS1  MOV  XR,DNAMP         SET UPDATED STORAGE POINTER
       ZER  -(XR)            STORE ZERO CHARS IN LAST WORD
       DCA  WA               DECREMENT LENGTH
       SUB  WA,XR            POINT BACK TO START OF BLOCK
       MOV  =B_SCL,(XR)      SET TYPE WORD
       MOV  WC,SCLEN(XR)     STORE LENGTH IN CHARS
       EXI                   RETURN TO ALOCS CALLER
ALCS2  ERB  205,String length exceeds value of MAXLNGTH keyword
       ENP                   END PROCEDURE ALOCS
ALOST  PRC  E,0              ENTRY POINT
ALST1  MOV  STATE,XR         POINT TO CURRENT END OF AREA
       AOV  WA,XR,ALST2      POINT BEYOND PROPOSED BLOCK
       BGE  XR,DNAMB,ALST2   JUMP IF OVERLAP WITH DYNAMIC AREA
       MOV  XR,STATE         ELSE STORE NEW POINTER
       SUB  WA,XR            POINT BACK TO START OF BLOCK
       EXI                   RETURN TO ALOST CALLER
ALST2  MOV  WA,ALSTA         SAVE WA
       BGE  WA,*E_STS,ALST3  SKIP IF REQUESTED CHUNK IS LARGE
       MOV  *E_STS,WA        ELSE SET TO GET LARGE ENOUGH CHUNK
ALST3  JSR  ALLOC            ALLOCATE BLOCK TO ENSURE ROOM
       MOV  XR,DNAMP         AND DELETE IT
       MOV  WA,WB            COPY MOVE UP AMOUNT
       JSR  GBCOL            CALL GBCOL TO MOVE DYNAMIC AREA UP
.IF    .CSED
       MOV  XR,DNAMS         REMEMBER NEW SEDIMENT SIZE
.FI
       MOV  ALSTA,WA         RESTORE WA
       BRN  ALST1            LOOP BACK TO TRY AGAIN
       ENP                   END PROCEDURE ALOST
.IF    .CNBF
.ELSE
APNDB  PRC  E,2              ENTRY POINT
       MOV  BCLEN(XR),WA     LOAD OFFSET TO INSERT
       ZER  WB               REPLACE SECTION IS NULL
       JSR  INSBF            CALL TO INSERT AT END
       PPM  APN01            CONVERT ERROR
       PPM  APN02            NO ROOM
       EXI                   RETURN TO CALLER
APN01  EXI  1                RETURN TO CALLER ALTERNATE
APN02  EXI  2                ALTERNATE EXIT TO CALLER
       ENP                   END PROCEDURE APNDB
.FI
.IF    .CNRA
.ELSE
.FI
.IF    .CNRA
.ELSE
.FI
.IF    .CNRA
ARITH  PRC  N,2              ENTRY POINT
.ELSE
ARITH  PRC  N,3              ENTRY POINT
.FI
       MOV  (XS)+,XL         LOAD RIGHT OPERAND
       MOV  (XS)+,XR         LOAD LEFT OPERAND
       MOV  (XL),WA          GET RIGHT OPERAND TYPE WORD
       BEQ  WA,=B_ICL,ARTH1  JUMP IF INTEGER
.IF    .CNRA
.ELSE
       BEQ  WA,=B_RCL,ARTH4  JUMP IF REAL
.FI
       MOV  XR,-(XS)         ELSE REPLACE LEFT ARG ON STACK
       MOV  XL,XR            COPY LEFT ARG POINTER
       JSR  GTNUM            CONVERT TO NUMERIC
       PPM  ARTH6            JUMP IF UNCONVERTIBLE
       MOV  XR,XL            ELSE COPY CONVERTED RESULT
       MOV  (XL),WA          GET RIGHT OPERAND TYPE WORD
       MOV  (XS)+,XR         RELOAD LEFT ARGUMENT
.IF    .CNRA
.ELSE
       BEQ  WA,=B_RCL,ARTH4  JUMP IF RIGHT ARG IS REAL
.FI
ARTH1  BNE  (XR),=B_ICL,ARTH3 JUMP IF LEFT ARG NOT INTEGER
ARTH2  LDI  ICVAL(XR)        LOAD LEFT OPERAND VALUE
       EXI                   RETURN TO ARITH CALLER
ARTH3  JSR  GTNUM            CONVERT LEFT ARG TO NUMERIC
       PPM  ARTH7            JUMP IF NOT CONVERTIBLE
       BEQ  WA,=B_ICL,ARTH2  JUMP BACK IF INTEGER-INTEGER
.IF    .CNRA
.ELSE
       MOV  XR,-(XS)         PUT LEFT ARG BACK ON STACK
       LDI  ICVAL(XL)        LOAD RIGHT ARGUMENT VALUE
       ITR                   CONVERT TO REAL
       JSR  RCBLD            GET REAL BLOCK FOR RIGHT ARG, MERGE
       MOV  XR,XL            COPY RIGHT ARG PTR
       MOV  (XS)+,XR         LOAD LEFT ARGUMENT
       BRN  ARTH5            MERGE FOR REAL-REAL CASE
ARTH4  BEQ  (XR),=B_RCL,ARTH5 JUMP IF LEFT ARG REAL
       JSR  GTREA            ELSE CONVERT TO REAL
       PPM  ARTH7            ERROR IF UNCONVERTIBLE
ARTH5  LDR  RCVAL(XR)        LOAD LEFT OPERAND VALUE
       EXI  3                TAKE REAL-REAL EXIT
.FI
ARTH6  ICA  XS               POP UNWANTED LEFT ARG
       EXI  2                TAKE APPROPRIATE ERROR EXIT
ARTH7  EXI  1                TAKE APPROPRIATE ERROR RETURN
       ENP                   END PROCEDURE ARITH
ASIGN  PRC  R,1              ENTRY POINT (RECURSIVE)
ASG01  ADD  WA,XL            POINT TO VARIABLE VALUE
       MOV  (XL),XR          LOAD VARIABLE VALUE
       BEQ  (XR),=B_TRT,ASG02 JUMP IF TRAPPED
       MOV  WB,(XL)          ELSE PERFORM ASSIGNMENT
       ZER  XL               CLEAR GARBAGE VALUE IN XL
       EXI                   AND RETURN TO ASIGN CALLER
ASG02  SUB  WA,XL            RESTORE NAME BASE
       BEQ  XR,=TRBKV,ASG14  JUMP IF KEYWORD VARIABLE
       BNE  XR,=TRBEV,ASG04  JUMP IF NOT EXPRESSION VARIABLE
       MOV  EVEXP(XL),XR     POINT TO EXPRESSION
       MOV  WB,-(XS)         STORE VALUE TO ASSIGN ON STACK
       MOV  =NUM01,WB        SET FOR EVALUATION BY NAME
       JSR  EVALX            EVALUATE EXPRESSION BY NAME
       PPM  ASG03            JUMP IF EVALUATION FAILS
       MOV  (XS)+,WB         ELSE RELOAD VALUE TO ASSIGN
       BRN  ASG01            LOOP BACK TO PERFORM ASSIGNMENT
ASG03  ICA  XS               REMOVE STACKED VALUE ENTRY
       EXI  1                TAKE FAILURE EXIT
ASG04  MOV  XR,-(XS)         SAVE PTR TO FIRST TRBLK
ASG05  MOV  XR,WC            SAVE PTR TO THIS TRBLK
       MOV  TRNXT(XR),XR     POINT TO NEXT TRBLK
       BEQ  (XR),=B_TRT,ASG05 LOOP BACK IF ANOTHER TRBLK
       MOV  WC,XR            ELSE POINT BACK TO LAST TRBLK
       MOV  WB,TRVAL(XR)     STORE VALUE AT END OF CHAIN
       MOV  (XS)+,XR         RESTORE PTR TO FIRST TRBLK
ASG06  MOV  TRTYP(XR),WB     LOAD TYPE CODE OF TRBLK
       BEQ  WB,=TRTVL,ASG08  JUMP IF VALUE TRACE
       BEQ  WB,=TRTOU,ASG10  JUMP IF OUTPUT ASSOCIATION
ASG07  MOV  TRNXT(XR),XR     POINT TO NEXT TRBLK ON CHAIN
       BEQ  (XR),=B_TRT,ASG06 LOOP BACK IF ANOTHER TRBLK
       EXI                   ELSE END OF CHAIN, RETURN TO CALLER
ASG08  BZE  KVTRA,ASG07      IGNORE VALUE TRACE IF TRACE OFF
       DCV  KVTRA            ELSE DECREMENT TRACE COUNT
       BZE  TRFNC(XR),ASG09  JUMP IF PRINT TRACE
       JSR  TRXEQ            ELSE EXECUTE FUNCTION TRACE
       BRN  ASG07            AND LOOP BACK
ASG09  JSR  PRTSN            PRINT STATEMENT NUMBER
       JSR  PRTNV            PRINT NAME = VALUE
       BRN  ASG07            LOOP BACK FOR NEXT TRBLK
ASG10  BZE  KVOUP,ASG07      IGNORE OUTPUT ASSOC IF OUTPUT OFF
ASG1B  MOV  XR,XL            COPY TRBLK POINTER
       MOV  TRNXT(XR),XR     POINT TO NEXT TRBLK
       BEQ  (XR),=B_TRT,ASG1B LOOP BACK IF ANOTHER TRBLK
       MOV  XL,XR            ELSE POINT BACK TO LAST TRBLK
.IF    .CNBF
       MOV  TRVAL(XR),-(XS)  STACK VALUE TO OUTPUT
.ELSE
       MOV  TRVAL(XR),XR     GET VALUE TO OUTPUT
       BEQ  (XR),=B_BCT,ASG11 BRANCH IF BUFFER
       MOV  XR,-(XS)         STACK VALUE TO OUTPUT
.FI
       JSR  GTSTG            CONVERT TO STRING
       PPM  ASG12            GET DATATYPE NAME IF UNCONVERTIBLE
ASG11  MOV  TRFPT(XL),WA     FCBLK PTR
       BZE  WA,ASG13         JUMP IF STANDARD OUTPUT FILE
ASG1A  JSR  SYSOU            CALL SYSTEM OUTPUT ROUTINE
       ERR  206,Output caused file overflow
       ERR  207,Output caused non-recoverable error
       EXI                   ELSE ALL DONE, RETURN TO CALLER
ASG12  JSR  DTYPE            CALL DATATYPE ROUTINE
       BRN  ASG11            MERGE
.IF    .CSOU
ASG13  BEQ  TRTER(XL),=V_TER,ASG1A JUMP IF TERMINAL OUTPUT
       ICV  WA               SIGNAL STANDARD OUTPUT
       BRN  ASG1A            USE SYSOU TO PERFORM OUTPUT
.ELSE
.IF    .CNBF
ASG13  JSR  PRTST            PRINT STRING VALUE
.ELSE
ASG13  BNE  (XR),=B_BCT,ASG1C BRANCH IF NOT BUFFER
       MOV  XR,-(XS)         STACK BUFFER
       JSR  GTSTG            CONVERT TO STRING
       PPM                   ALWAYS SUCCEEDS
ASG1C  JSR  PRTST            PRINT STRING VALUE
.FI
       BEQ  TRTER(XL),=V_TER,ASG20 JUMP IF TERMINAL OUTPUT
       JSR  PRTNL            END OF LINE
       EXI                   RETURN TO CALLER
.FI
ASG14  MOV  KVNUM(XL),XL     LOAD KEYWORD NUMBER
       BEQ  XL,=K_ETX,ASG19  JUMP IF ERRTEXT
       MOV  WB,XR            COPY VALUE TO BE ASSIGNED
       JSR  GTINT            CONVERT TO INTEGER
       ERR  208,Keyword value assigned is not integer
       LDI  ICVAL(XR)        ELSE LOAD VALUE
       BEQ  XL,=K_STL,ASG16  JUMP IF SPECIAL CASE OF STLIMIT
       MFI  WA,ASG18         ELSE GET ADDR INTEGER, TEST OVFLOW
       BGT  WA,MXLEN,ASG18   FAIL IF TOO LARGE
       BEQ  XL,=K_ERT,ASG17  JUMP IF SPECIAL CASE OF ERRTYPE
.IF    .CNPF
.ELSE
       BEQ  XL,=K_PFL,ASG21  JUMP IF SPECIAL CASE OF PROFILE
.FI
       BEQ  XL,=K_MXL,ASG24  JUMP IF SPECIAL CASE OF MAXLNGTH
       BEQ  XL,=K_FLS,ASG26  JUMP IF SPECIAL CASE OF FULLSCAN
       BLT  XL,=K_P__,ASG15  JUMP UNLESS PROTECTED
       ERB  209,Keyword in assignment is protected
ASG15  MOV  WA,KVABE(XL)     STORE NEW VALUE
       EXI                   RETURN TO ASIGN CALLER
ASG16  SBI  KVSTL            SUBTRACT OLD LIMIT
       ADI  KVSTC            ADD OLD COUNTER
       STI  KVSTC            STORE COURSE COUNTER VALUE
       LDI  KVSTL            CHECK IF COUNTING SUPPRESSED
       ILT  ASG25            DO NOT REFINE IF SO
       MOV  STMCS,WA         REFINE WITH COUNTER BREAKOUT
       SUB  STMCT,WA         VALUES
       MTI  WA               CONVERT TO INTEGER
       NGI                   CURRENT-START VALUE
       ADI  KVSTC            ADD IN COURSE COUNTER VALUE
       STI  KVSTC            SAVE REFINED VALUE
ASG25  LDI  ICVAL(XR)        RELOAD NEW LIMIT VALUE
       STI  KVSTL            STORE NEW LIMIT VALUE
       JSR  STGCC            RECOMPUTE COUNTDOWN COUNTERS
       EXI                   RETURN TO ASIGN CALLER
ASG17  BLE  WA,=NINI9,ERROR  OK TO SIGNAL IF IN RANGE
ASG18  ERB  210,Keyword value assigned is negative or too large
ASG19  MOV  WB,-(XS)         STACK VALUE
       JSR  GTSTG            CONVERT TO STRING
       ERR  211,Value assigned to keyword ERRTEXT not a string
       MOV  XR,R_ETX         MAKE ASSIGNMENT
       EXI                   RETURN TO CALLER
.IF    .CSOU
.ELSE
ASG20  JSR  PRTTR            PRINT
       EXI                   RETURN
.FI
.IF    .CNPF
.ELSE
ASG21  BGT  WA,=NUM02,ASG18  MOAN IF NOT 0,1, OR 2
       BZE  WA,ASG15         JUST ASSIGN IF ZERO
       BZE  PFDMP,ASG22      BRANCH IF FIRST ASSIGNMENT
       BEQ  WA,PFDMP,ASG23   ALSO IF SAME VALUE AS BEFORE
       ERB  268,Inconsistent value assigned to keyword PROFILE
ASG22  MOV  WA,PFDMP         NOTE VALUE ON FIRST ASSIGNMENT
ASG23  MOV  WA,KVPFL         STORE NEW VALUE
       JSR  STGCC            RECOMPUTE COUNTDOWN COUNTS
       JSR  SYSTM            GET THE TIME
       STI  PFSTM            FUDGE SOME KIND OF START TIME
       EXI                   RETURN TO ASIGN CALLER
.FI
ASG24  BGE  WA,=MNLEN,ASG15  IF ACCEPTABLE VALUE
       ERB  287,Value assigned to keyword MAXLNGTH is too small
ASG26  BNZ  WA,ASG15         IF ACCEPTABLE VALUE
       ERB  274,Value assigned to keyword FULLSCAN is zero
       ENP                   END PROCEDURE ASIGN
ASINP  PRC  R,1              ENTRY POINT, RECURSIVE
       ADD  WA,XL            POINT TO VARIABLE
       MOV  (XL),XR          LOAD CURRENT CONTENTS
       BEQ  (XR),=B_TRT,ASNP1 JUMP IF TRAPPED
       MOV  WB,(XL)          ELSE PERFORM ASSIGNMENT
       ZER  XL               CLEAR GARBAGE VALUE IN XL
       EXI                   RETURN TO ASINP CALLER
ASNP1  SUB  WA,XL            RESTORE BASE POINTER
       MOV  PMSSL,-(XS)      STACK SUBJECT STRING LENGTH
       MOV  PMHBS,-(XS)      STACK HISTORY STACK BASE PTR
       MOV  R_PMS,-(XS)      STACK SUBJECT STRING POINTER
       MOV  PMDFL,-(XS)      STACK DOT FLAG
       JSR  ASIGN            CALL FULL-BLOWN ASSIGNMENT ROUTINE
       PPM  ASNP2            JUMP IF FAILURE
       MOV  (XS)+,PMDFL      RESTORE DOT FLAG
       MOV  (XS)+,R_PMS      RESTORE SUBJECT STRING POINTER
       MOV  (XS)+,PMHBS      RESTORE HISTORY STACK BASE POINTER
       MOV  (XS)+,PMSSL      RESTORE SUBJECT STRING LENGTH
       EXI                   RETURN TO ASINP CALLER
ASNP2  MOV  (XS)+,PMDFL      RESTORE DOT FLAG
       MOV  (XS)+,R_PMS      RESTORE SUBJECT STRING POINTER
       MOV  (XS)+,PMHBS      RESTORE HISTORY STACK BASE POINTER
       MOV  (XS)+,PMSSL      RESTORE SUBJECT STRING LENGTH
       EXI  1                TAKE FAILURE EXIT
       ENP                   END PROCEDURE ASINP
BLKLN  PRC  E,0              ENTRY POINT
       MOV  WA,XL            COPY FIRST WORD
       LEI  XL               GET ENTRY ID (BL_XX)
       BSW  XL,BL___,BLN00   SWITCH ON BLOCK TYPE
       IFF  BL_AR,BLN01      ARBLK
.IF    .CNBF
.ELSE
       IFF  BL_BC,BLN04      BCBLK
       IFF  BL_BF,BLN11      BFBLK
.FI
.IF    .CSLN
       IFF  BL_CD,BLN12      CDBLK
.ELSE
       IFF  BL_CD,BLN01      CDBLK
.FI
       IFF  BL_DF,BLN01      DFBLK
       IFF  BL_EF,BLN01      EFBLK
.IF    .CSLN
       IFF  BL_EX,BLN12      EXBLK
.ELSE
       IFF  BL_EX,BLN01      EXBLK
.FI
       IFF  BL_PF,BLN01      PFBLK
       IFF  BL_TB,BLN01      TBBLK
       IFF  BL_VC,BLN01      VCBLK
       IFF  BL_EV,BLN03      EVBLK
       IFF  BL_KV,BLN03      KVBLK
       IFF  BL_P0,BLN02      P0BLK
       IFF  BL_SE,BLN02      SEBLK
       IFF  BL_NM,BLN03      NMBLK
       IFF  BL_P1,BLN03      P1BLK
       IFF  BL_P2,BLN04      P2BLK
       IFF  BL_TE,BLN04      TEBLK
       IFF  BL_FF,BLN05      FFBLK
       IFF  BL_TR,BLN05      TRBLK
       IFF  BL_CT,BLN06      CTBLK
       IFF  BL_IC,BLN07      ICBLK
       IFF  BL_PD,BLN08      PDBLK
.IF    .CNRA
.ELSE
       IFF  BL_RC,BLN09      RCBLK
.FI
       IFF  BL_SC,BLN10      SCBLK
       ESW                   END OF JUMP TABLE ON BLOCK TYPE
BLN00  MOV  NUM01(XR),WA     LOAD LENGTH
       EXI                   RETURN TO BLKLN CALLER
BLN01  MOV  NUM02(XR),WA     LOAD LENGTH FROM THIRD WORD
       EXI                   RETURN TO BLKLN CALLER
BLN02  MOV  *NUM02,WA        LOAD LENGTH (TWO WORDS)
       EXI                   RETURN TO BLKLN CALLER
BLN03  MOV  *NUM03,WA        LOAD LENGTH (THREE WORDS)
       EXI                   RETURN TO BLKLN CALLER
BLN04  MOV  *NUM04,WA        LOAD LENGTH (FOUR WORDS)
       EXI                   RETURN TO BLKLN CALLER
BLN05  MOV  *NUM05,WA        LOAD LENGTH
       EXI                   RETURN TO BLKLN CALLER
BLN06  MOV  *CTSI_,WA        SET SIZE OF CTBLK
       EXI                   RETURN TO BLKLN CALLER
BLN07  MOV  *ICSI_,WA        SET SIZE OF ICBLK
       EXI                   RETURN TO BLKLN CALLER
BLN08  MOV  PDDFP(XR),XL     POINT TO DFBLK
       MOV  DFPDL(XL),WA     LOAD PDBLK LENGTH FROM DFBLK
       EXI                   RETURN TO BLKLN CALLER
.IF    .CNRA
.ELSE
BLN09  MOV  *RCSI_,WA        SET SIZE OF RCBLK
       EXI                   RETURN TO BLKLN CALLER
.FI
BLN10  MOV  SCLEN(XR),WA     LOAD LENGTH IN CHARACTERS
       CTB  WA,SCSI_         CALCULATE LENGTH IN BYTES
       EXI                   RETURN TO BLKLN CALLER
.IF    .CNBF
.ELSE
BLN11  MOV  BFALC(XR),WA     GET ALLOCATION IN BYTES
       CTB  WA,BFSI_         CALCULATE LENGTH IN BYTES
       EXI                   RETURN TO BLKLN CALLER
.FI
.IF    .CSLN
BLN12  MOV  NUM03(XR),WA     LOAD LENGTH FROM CDLEN/EXLEN
       EXI                   RETURN TO BLKLN CALLER
.FI
       ENP                   END PROCEDURE BLKLN
COPYB  PRC  N,1              ENTRY POINT
       MOV  (XS),XR          LOAD ARGUMENT
       BEQ  XR,=NULLS,COP10  RETURN ARGUMENT IF IT IS NULL
       MOV  (XR),WA          ELSE LOAD TYPE WORD
       MOV  WA,WB            COPY TYPE WORD
       JSR  BLKLN            GET LENGTH OF ARGUMENT BLOCK
       MOV  XR,XL            COPY POINTER
       JSR  ALLOC            ALLOCATE BLOCK OF SAME SIZE
       MOV  XR,(XS)          STORE POINTER TO COPY
       MVW                   COPY CONTENTS OF OLD BLOCK TO NEW
       ZER  XL               CLEAR GARBAGE XL
       MOV  (XS),XR          RELOAD POINTER TO START OF COPY
       BEQ  WB,=B_TBT,COP05  JUMP IF TABLE
       BEQ  WB,=B_VCT,COP01  JUMP IF VECTOR
       BEQ  WB,=B_PDT,COP01  JUMP IF PROGRAM DEFINED
.IF    .CNBF
.ELSE
       BEQ  WB,=B_BCT,COP11  JUMP IF BUFFER
.FI
       BNE  WB,=B_ART,COP10  RETURN COPY IF NOT ARRAY
       ADD  AROFS(XR),XR     POINT TO PROTOTYPE FIELD
       BRN  COP02            JUMP TO MERGE
COP01  ADD  *PDFLD,XR        POINT TO PDFLD = VCVLS
COP02  MOV  (XR),XL          LOAD NEXT POINTER
COP03  BNE  (XL),=B_TRT,COP04 JUMP IF NOT TRAPPED
       MOV  TRVAL(XL),XL     ELSE POINT TO NEXT VALUE
       BRN  COP03            AND LOOP BACK
COP04  MOV  XL,(XR)+         STORE REAL VALUE, BUMP POINTER
       BNE  XR,DNAMP,COP02   LOOP BACK IF MORE TO GO
       BRN  COP09            ELSE JUMP TO EXIT
COP05  ZER  IDVAL(XR)        ZERO ID TO STOP DUMP BLOWING UP
       MOV  *TESI_,WA        SET SIZE OF TEBLK
       MOV  *TBBUK,WC        SET INITIAL OFFSET
COP06  MOV  (XS),XR          LOAD TABLE POINTER
       BEQ  WC,TBLEN(XR),COP09 JUMP TO EXIT IF ALL DONE
       MOV  WC,WB            ELSE COPY OFFSET
       SUB  *TENXT,WB        SUBTRACT LINK OFFSET TO MERGE
       ADD  WB,XR            NEXT BUCKET HEADER LESS LINK OFFSET
       ICA  WC               BUMP OFFSET
COP07  MOV  TENXT(XR),XL     LOAD POINTER TO NEXT TEBLK
       MOV  (XS),TENXT(XR)   SET END OF CHAIN POINTER IN CASE
       BEQ  (XL),=B_TBT,COP06 BACK FOR NEXT BUCKET IF CHAIN END
       SUB  WB,XR            POINT TO HEAD OF PREVIOUS BLOCK
       MOV  XR,-(XS)         STACK PTR TO PREVIOUS BLOCK
       MOV  *TESI_,WA        SET SIZE OF TEBLK
       JSR  ALLOC            ALLOCATE NEW TEBLK
       MOV  XR,-(XS)         STACK PTR TO NEW TEBLK
       MVW                   COPY OLD TEBLK TO NEW TEBLK
       MOV  (XS)+,XR         RESTORE POINTER TO NEW TEBLK
       MOV  (XS)+,XL         RESTORE POINTER TO PREVIOUS BLOCK
       ADD  WB,XL            ADD OFFSET BACK IN
       MOV  XR,TENXT(XL)     LINK NEW BLOCK TO PREVIOUS
       MOV  XR,XL            COPY POINTER TO NEW BLOCK
COP08  MOV  TEVAL(XL),XL     LOAD VALUE
       BEQ  (XL),=B_TRT,COP08 LOOP BACK IF TRAPPED
       MOV  XL,TEVAL(XR)     STORE UNTRAPPED VALUE IN TEBLK
       ZER  WB               ZERO OFFSET WITHIN TEBLK
       BRN  COP07            BACK FOR NEXT TEBLK
COP09  MOV  (XS)+,XR         LOAD POINTER TO BLOCK
       EXI                   RETURN
COP10  EXI  1                RETURN
.IF    .CNBF
.ELSE
COP11  MOV  BCBUF(XR),XL     GET BFBLK PTR
       MOV  BFALC(XL),WA     GET ALLOCATION
       CTB  WA,BFSI_         SET TOTAL SIZE
       MOV  XR,XL            SAVE BCBLK PTR
       JSR  ALLOC            ALLOCATE BFBLK
       MOV  BCBUF(XL),WB     GET OLD BFBLK
       MOV  XR,BCBUF(XL)     SET POINTER TO NEW BFBLK
       MOV  WB,XL            POINT TO OLD BFBLK
       MVW                   COPY BFBLK TOO
       ZER  XL               CLEAR RUBBISH PTR
       BRN  COP09            BRANCH TO EXIT
.FI
       ENP                   END PROCEDURE COPYB
CDGCG  PRC  E,0              ENTRY POINT
       MOV  CMOPN(XR),XL     GET UNARY GOTO OPERATOR
       MOV  CMROP(XR),XR     POINT TO GOTO OPERAND
       BEQ  XL,=OPDVD,CDGC2  JUMP IF DIRECT GOTO
       JSR  CDGNM            GENERATE OPND BY NAME IF NOT DIRECT
CDGC1  MOV  XL,WA            GOTO OPERATOR
       JSR  CDWRD            GENERATE IT
       EXI                   RETURN TO CALLER
CDGC2  JSR  CDGVL            GENERATE OPERAND BY VALUE
       BRN  CDGC1            MERGE TO RETURN
       ENP                   END PROCEDURE CDGCG
.IF    .CEVB
.FI
CDGEX  PRC  R,0              ENTRY POINT, RECURSIVE
       BLO  (XL),=B_VR_,CDGX1 JUMP IF NOT VARIABLE
       MOV  *SESI_,WA        SET SIZE OF SEBLK
       JSR  ALLOC            ALLOCATE SPACE FOR SEBLK
       MOV  =B_SEL,(XR)      SET TYPE WORD
       MOV  XL,SEVAR(XR)     STORE VRBLK POINTER
       EXI                   RETURN TO CDGEX CALLER
CDGX1  MOV  XL,XR            COPY TREE POINTER
       MOV  WC,-(XS)         SAVE WC
       MOV  CWCOF,XL         SAVE CURRENT OFFSET
.IF    .CEVB
       BZE  WA,CDGX2         JUMP IF BY VALUE
.FI
       MOV  (XR),WA          GET TYPE WORD
       BNE  WA,=B_CMT,CDGX2  CALL BY VALUE IF NOT CMBLK
       BGE  CMTYP(XR),=C__NM,CDGX2 JUMP IF CMBLK ONLY BY VALUE
       JSR  CDGNM            GENERATE CODE BY NAME
       MOV  =ORNM_,WA        LOAD RETURN BY NAME WORD
       BRN  CDGX3            MERGE WITH VALUE CASE
CDGX2  JSR  CDGVL            GENERATE CODE BY VALUE
       MOV  =ORVL_,WA        LOAD RETURN BY VALUE WORD
CDGX3  JSR  CDWRD            GENERATE RETURN WORD
       JSR  EXBLD            BUILD EXBLK
       MOV  (XS)+,WC         RESTORE WC
       EXI                   RETURN TO CDGEX CALLER
       ENP                   END PROCEDURE CDGEX
CDGNM  PRC  R,0              ENTRY POINT, RECURSIVE
       MOV  XL,-(XS)         SAVE ENTRY XL
       MOV  WB,-(XS)         SAVE ENTRY WB
       CHK                   CHECK FOR STACK OVERFLOW
       MOV  (XR),WA          LOAD TYPE WORD
       BEQ  WA,=B_CMT,CGN04  JUMP IF CMBLK
       BHI  WA,=B_VR_,CGN02  JUMP IF SIMPLE VARIABLE
CGN01  ERB  212,Syntax error: Value used where name is required
CGN02  MOV  =OLVN_,WA        LOAD VARIABLE LOAD CALL
       JSR  CDWRD            GENERATE IT
       MOV  XR,WA            COPY VRBLK POINTER
       JSR  CDWRD            GENERATE VRBLK POINTER
CGN03  MOV  (XS)+,WB         RESTORE ENTRY WB
       MOV  (XS)+,XL         RESTORE ENTRY XL
       EXI                   RETURN TO CDGNM CALLER
CGN04  MOV  XR,XL            COPY CMBLK POINTER
       MOV  CMTYP(XR),XR     LOAD CMBLK TYPE
       BGE  XR,=C__NM,CGN01  ERROR IF NOT NAME OPERAND
       BSW  XR,C__NM         ELSE SWITCH ON TYPE
       IFF  C_ARR,CGN05      ARRAY REFERENCE
       IFF  C_FNC,CGN08      FUNCTION CALL
       IFF  C_DEF,CGN09      DEFERRED EXPRESSION
       IFF  C_IND,CGN10      INDIRECT REFERENCE
       IFF  C_KEY,CGN11      KEYWORD REFERENCE
       IFF  C_UBO,CGN08      UNDEFINED BINARY OP
       IFF  C_UUO,CGN08      UNDEFINED UNARY OP
       ESW                   END SWITCH ON CMBLK TYPE
CGN05  MOV  *CMOPN,WB        POINT TO ARRAY OPERAND
CGN06  JSR  CMGEN            GENERATE CODE FOR NEXT OPERAND
       MOV  CMLEN(XL),WC     LOAD LENGTH OF CMBLK
       BLT  WB,WC,CGN06      LOOP TILL ALL GENERATED
       MOV  =OAON_,WA        LOAD ONE-SUBSCRIPT CASE CALL
       BEQ  WC,*CMAR1,CGN07  JUMP TO EXIT IF ONE SUBSCRIPT CASE
       MOV  =OAMN_,WA        ELSE LOAD MULTI-SUBSCRIPT CASE CALL
       JSR  CDWRD            GENERATE CALL
       MOV  WC,WA            COPY CMBLK LENGTH
       BTW  WA               CONVERT TO WORDS
       SUB  =CMVLS,WA        CALCULATE NUMBER OF SUBSCRIPTS
CGN07  MNZ  WC               SET RESULT NON-CONSTANT
       JSR  CDWRD            GENERATE WORD
       BRN  CGN03            BACK TO EXIT
CGN08  MOV  XL,XR            COPY CMBLK POINTER
       JSR  CDGVL            GEN CODE BY VALUE FOR CALL
       MOV  =OFNE_,WA        GET EXTRA CALL FOR BY NAME
       BRN  CGN07            BACK TO GENERATE AND EXIT
CGN09  MOV  CMROP(XL),XR     CHECK IF VARIABLE
       BHI  (XR),=B_VR_,CGN02 TREAT *VARIABLE AS SIMPLE VAR
       MOV  XR,XL            COPY PTR TO EXPRESSION TREE
.IF    .CEVB
       MOV  =NUM01,WA        RETURN NAME
.FI
       JSR  CDGEX            ELSE BUILD EXBLK
       MOV  =OLEX_,WA        SET CALL TO LOAD EXPR BY NAME
       JSR  CDWRD            GENERATE IT
       MOV  XR,WA            COPY EXBLK POINTER
       JSR  CDWRD            GENERATE EXBLK POINTER
       BRN  CGN03            BACK TO EXIT
CGN10  MOV  CMROP(XL),XR     GET OPERAND
       JSR  CDGVL            GENERATE CODE BY VALUE FOR IT
       MOV  =OINN_,WA        LOAD CALL FOR INDIRECT BY NAME
       BRN  CGN12            MERGE
CGN11  MOV  CMROP(XL),XR     GET OPERAND
       JSR  CDGNM            GENERATE CODE BY NAME FOR IT
       MOV  =OKWN_,WA        LOAD CALL FOR KEYWORD BY NAME
CGN12  JSR  CDWRD            GENERATE CODE FOR OPERATOR
       BRN  CGN03            EXIT
       ENP                   END PROCEDURE CDGNM
CDGVL  PRC  R,0              ENTRY POINT, RECURSIVE
       MOV  (XR),WA          LOAD TYPE WORD
       BEQ  WA,=B_CMT,CGV01  JUMP IF CMBLK
       BLT  WA,=B_VRA,CGV00  JUMP IF ICBLK, RCBLK, SCBLK
       BNZ  VRLEN(XR),CGVL0  JUMP IF NOT SYSTEM VARIABLE
       MOV  XR,-(XS)         STACK XR
       MOV  VRSVP(XR),XR     POINT TO SVBLK
       MOV  SVBIT(XR),WA     GET SVBLK PROPERTY BITS
       MOV  (XS)+,XR         RECOVER XR
       ANB  BTKWV,WA         CHECK IF CONSTANT KEYWORD VALUE
       BEQ  WA,BTKWV,CGV00   JUMP IF CONSTANT KEYWORD VALUE
CGVL0  MNZ  WC               INDICATE NON-CONSTANT VALUE
CGV00  MOV  XR,WA            COPY PTR TO VAR OR CONSTANT
       JSR  CDWRD            GENERATE AS CODE WORD
       EXI                   RETURN TO CALLER
CGV01  MOV  WB,-(XS)         SAVE ENTRY WB
       MOV  XL,-(XS)         SAVE ENTRY XL
       MOV  WC,-(XS)         SAVE ENTRY CONSTANT FLAG
       MOV  CWCOF,-(XS)      SAVE INITIAL CODE OFFSET
       CHK                   CHECK FOR STACK OVERFLOW
       MOV  XR,XL            COPY CMBLK POINTER
       MOV  CMTYP(XR),XR     LOAD CMBLK TYPE
       MOV  CSWNO,WC         RESET CONSTANT FLAG
       BLE  XR,=C_PR_,CGV02  JUMP IF NOT PREDICATE VALUE
       MNZ  WC               ELSE FORCE NON-CONSTANT CASE
CGV02  BSW  XR,C__NV         SWITCH TO APPROPRIATE GENERATOR
       IFF  C_ARR,CGV03      ARRAY REFERENCE
       IFF  C_FNC,CGV05      FUNCTION CALL
       IFF  C_DEF,CGV14      DEFERRED EXPRESSION
       IFF  C_SEL,CGV15      SELECTION
       IFF  C_IND,CGV31      INDIRECT REFERENCE
       IFF  C_KEY,CGV27      KEYWORD REFERENCE
       IFF  C_UBO,CGV29      UNDEFINED BINOP
       IFF  C_UUO,CGV30      UNDEFINED UNOP
       IFF  C_BVL,CGV18      BINOPS WITH VAL OPDS
       IFF  C_ALT,CGV18      ALTERNATION
       IFF  C_UVL,CGV19      UNOPS WITH VALU OPND
       IFF  C_ASS,CGV21      ASSIGNMENT
       IFF  C_CNC,CGV24      CONCATENATION
       IFF  C_CNP,CGV24      CONCATENATION (NOT PATTERN MATCH)
       IFF  C_UNM,CGV27      UNOPS WITH NAME OPND
       IFF  C_BVN,CGV26      BINARY _ AND .
       IFF  C_INT,CGV31      INTERROGATION
       IFF  C_NEG,CGV28      NEGATION
       IFF  C_PMT,CGV18      PATTERN MATCH
       ESW                   END SWITCH ON CMBLK TYPE
CGV03  MOV  *CMOPN,WB        SET OFFSET TO ARRAY OPERAND
CGV04  JSR  CMGEN            GEN VALUE CODE FOR NEXT OPERAND
       MOV  CMLEN(XL),WC     LOAD CMBLK LENGTH
       BLT  WB,WC,CGV04      LOOP BACK IF MORE TO GO
       MOV  =OAOV_,WA        SET ONE SUBSCRIPT CALL IN CASE
       BEQ  WC,*CMAR1,CGV32  JUMP TO EXIT IF 1-SUB CASE
       MOV  =OAMV_,WA        ELSE SET CALL FOR MULTI-SUBSCRIPTS
       JSR  CDWRD            GENERATE CALL
       MOV  WC,WA            COPY LENGTH OF CMBLK
       SUB  *CMVLS,WA        SUBTRACT STANDARD LENGTH
       BTW  WA               GET NUMBER OF WORDS
       BRN  CGV32            JUMP TO GENERATE SUBSCRIPT COUNT
CGV05  MOV  *CMVLS,WB        SET OFFSET TO FIRST ARGUMENT
CGV06  BEQ  WB,CMLEN(XL),CGV07 JUMP IF ALL GENERATED
       JSR  CMGEN            ELSE GEN VALUE CODE FOR NEXT ARG
       BRN  CGV06            BACK TO GENERATE NEXT ARGUMENT
CGV07  SUB  *CMVLS,WB        GET NUMBER OF ARG PTRS (BYTES)
       BTW  WB               CONVERT BYTES TO WORDS
       MOV  CMOPN(XL),XR     LOAD FUNCTION VRBLK POINTER
       BNZ  VRLEN(XR),CGV12  JUMP IF NOT SYSTEM FUNCTION
       MOV  VRSVP(XR),XL     LOAD SVBLK PTR IF SYSTEM VAR
       MOV  SVBIT(XL),WA     LOAD BIT MASK
       ANB  BTFFC,WA         TEST FOR FAST FUNCTION CALL ALLOWED
       ZRB  WA,CGV12         JUMP IF NOT
       MOV  SVBIT(XL),WA     RELOAD BIT INDICATORS
       ANB  BTPRE,WA         TEST FOR PREEVALUATION OK
       NZB  WA,CGV08         JUMP IF PREEVALUATION PERMITTED
       MNZ  WC               ELSE SET RESULT NON-CONSTANT
CGV08  MOV  VRFNC(XR),XL     LOAD PTR TO SVFNC FIELD
       MOV  FARGS(XL),WA     LOAD SVNAR FIELD VALUE
       BEQ  WA,WB,CGV11      JUMP IF ARGUMENT COUNT IS CORRECT
       BHI  WA,WB,CGV09      JUMP IF TOO FEW ARGUMENTS GIVEN
       SUB  WA,WB            GET NUMBER OF EXTRA ARGS
       LCT  WB,WB            SET AS COUNT TO CONTROL LOOP
       MOV  =OPOP_,WA        SET POP CALL
       BRN  CGV10            JUMP TO COMMON LOOP
CGV09  SUB  WB,WA            GET NUMBER OF MISSING ARGUMENTS
       LCT  WB,WA            LOAD AS COUNT TO CONTROL LOOP
       MOV  =NULLS,WA        LOAD PTR TO NULL CONSTANT
CGV10  JSR  CDWRD            GENERATE ONE CALL
       BCT  WB,CGV10         LOOP TILL ALL GENERATED
CGV11  MOV  XL,WA            COPY POINTER TO SVFNC FIELD
       BRN  CGV36            JUMP TO GENERATE CALL
CGV12  MOV  =OFNS_,WA        SET ONE ARG CALL IN CASE
       BEQ  WB,=NUM01,CGV13  JUMP IF ONE ARG CASE
       MOV  =OFNC_,WA        ELSE LOAD CALL FOR MORE THAN 1 ARG
       JSR  CDWRD            GENERATE IT
       MOV  WB,WA            COPY ARGUMENT COUNT
CGV13  JSR  CDWRD            GENERATE =O_FNS OR ARG COUNT
       MOV  XR,WA            COPY VRBLK POINTER
       BRN  CGV32            JUMP TO GENERATE VRBLK PTR
CGV14  MOV  CMROP(XL),XL     POINT TO EXPRESSION TREE
.IF    .CEVB
       ZER  WA               RETURN VALUE
.FI
       JSR  CDGEX            BUILD EXBLK OR SEBLK
       MOV  XR,WA            COPY BLOCK PTR
       JSR  CDWRD            GENERATE PTR TO EXBLK OR SEBLK
       BRN  CGV34            JUMP TO EXIT, CONSTANT TEST
CGV15  ZER  -(XS)            ZERO PTR TO CHAIN OF FORWARD JUMPS
       ZER  -(XS)            ZERO PTR TO PREV O_SLC FORWARD PTR
       MOV  *CMVLS,WB        POINT TO FIRST ALTERNATIVE
       MOV  =OSLA_,WA        SET INITIAL CODE WORD
CGV16  JSR  CDWRD            GENERATE O_SLC (O_SLA FIRST TIME)
       MOV  CWCOF,(XS)       SET CURRENT LOC AS PTR TO FILL IN
       JSR  CDWRD            GENERATE GARBAGE WORD THERE FOR NOW
       JSR  CMGEN            GEN VALUE CODE FOR ALTERNATIVE
       MOV  =OSLB_,WA        LOAD O_SLB POINTER
       JSR  CDWRD            GENERATE O_SLB CALL
       MOV  NUM01(XS),WA     LOAD OLD CHAIN PTR
       MOV  CWCOF,NUM01(XS)  SET CURRENT LOC AS NEW CHAIN HEAD
       JSR  CDWRD            GENERATE FORWARD CHAIN LINK
       MOV  (XS),XR          LOAD OFFSET TO WORD TO PLUG
       ADD  R_CCB,XR         POINT TO ACTUAL LOCATION TO PLUG
       MOV  CWCOF,(XR)       PLUG PROPER OFFSET IN
       MOV  =OSLC_,WA        LOAD O_SLC PTR FOR NEXT ALTERNATIVE
       MOV  WB,XR            COPY OFFSET (DESTROY GARBAGE XR)
       ICA  XR               BUMP EXTRA TIME FOR TEST
       BLT  XR,CMLEN(XL),CGV16 LOOP BACK IF NOT LAST ALTERNATIVE
       MOV  =OSLD_,WA        GET HEADER CALL
       JSR  CDWRD            GENERATE O_SLD CALL
       JSR  CMGEN            GENERATE CODE FOR LAST ALTERNATIVE
       ICA  XS               POP OFFSET PTR
       MOV  (XS)+,XR         LOAD CHAIN PTR
CGV17  ADD  R_CCB,XR         MAKE NEXT PTR ABSOLUTE
       MOV  (XR),WA          LOAD FORWARD PTR
       MOV  CWCOF,(XR)       PLUG REQUIRED OFFSET
       MOV  WA,XR            COPY FORWARD PTR
       BNZ  WA,CGV17         LOOP BACK IF MORE TO GO
       BRN  CGV33            ELSE JUMP TO EXIT (NOT CONSTANT)
CGV18  MOV  CMLOP(XL),XR     LOAD LEFT OPERAND POINTER
       JSR  CDGVL            GEN VALUE CODE FOR LEFT OPERAND
CGV19  MOV  CMROP(XL),XR     LOAD RIGHT (ONLY) OPERAND PTR
       JSR  CDGVL            GEN CODE BY VALUE
CGV20  MOV  CMOPN(XL),WA     LOAD OPERATOR CALL POINTER
       BRN  CGV36            JUMP TO GENERATE IT WITH CONS TEST
CGV21  MOV  CMLOP(XL),XR     LOAD LEFT OPERAND POINTER
       BLO  (XR),=B_VR_,CGV22 JUMP IF NOT VARIABLE
       MOV  CMROP(XL),XR     LOAD RIGHT OPERAND PTR
       JSR  CDGVL            GENERATE CODE BY VALUE
       MOV  CMLOP(XL),WA     RELOAD LEFT OPERAND VRBLK PTR
       ADD  *VRSTO,WA        POINT TO VRSTO FIELD
       BRN  CGV32            JUMP TO GENERATE STORE PTR
CGV22  JSR  EXPAP            TEST FOR PATTERN MATCH ON LEFT SIDE
       PPM  CGV23            JUMP IF NOT PATTERN MATCH
       MOV  CMROP(XR),CMLOP(XL) SAVE PATTERN PTR IN SAFE PLACE
       MOV  CMLOP(XR),XR     LOAD SUBJECT PTR
       JSR  CDGNM            GEN CODE BY NAME FOR SUBJECT
       MOV  CMLOP(XL),XR     LOAD PATTERN PTR
       JSR  CDGVL            GEN CODE BY VALUE FOR PATTERN
       MOV  =OPMN_,WA        LOAD MATCH BY NAME CALL
       JSR  CDWRD            GENERATE IT
       MOV  CMROP(XL),XR     LOAD REPLACEMENT VALUE PTR
       JSR  CDGVL            GEN CODE BY VALUE
       MOV  =ORPL_,WA        LOAD REPLACE CALL
       BRN  CGV32            JUMP TO GEN AND EXIT (NOT CONSTANT)
CGV23  MNZ  WC               INHIBIT PRE-EVALUATION
       JSR  CDGNM            GEN CODE BY NAME FOR LEFT SIDE
       BRN  CGV31            MERGE WITH UNOP CIRCUIT
CGV24  MOV  CMLOP(XL),XR     LOAD LEFT OPERAND PTR
       BNE  (XR),=B_CMT,CGV18 ORDINARY BINOP IF NOT CMBLK
       MOV  CMTYP(XR),WB     LOAD CMBLK TYPE CODE
       BEQ  WB,=C_INT,CGV25  SPECIAL CASE IF INTERROGATION
       BEQ  WB,=C_NEG,CGV25  OR NEGATION
       BNE  WB,=C_FNC,CGV18  ELSE ORDINARY BINOP IF NOT FUNCTION
       MOV  CMOPN(XR),XR     ELSE LOAD FUNCTION VRBLK PTR
       BNZ  VRLEN(XR),CGV18  ORDINARY BINOP IF NOT SYSTEM VAR
       MOV  VRSVP(XR),XR     ELSE POINT TO SVBLK
       MOV  SVBIT(XR),WA     LOAD BIT INDICATORS
       ANB  BTPRD,WA         TEST FOR PREDICATE FUNCTION
       ZRB  WA,CGV18         ORDINARY BINOP IF NOT
CGV25  MOV  CMLOP(XL),XR     RELOAD LEFT ARG
       JSR  CDGVL            GEN CODE BY VALUE
       MOV  =OPOP_,WA        LOAD POP CALL
       JSR  CDWRD            GENERATE IT
       MOV  CMROP(XL),XR     LOAD RIGHT OPERAND
       JSR  CDGVL            GEN CODE BY VALUE AS RESULT CODE
       BRN  CGV33            EXIT (NOT CONSTANT)
CGV26  MOV  CMLOP(XL),XR     LOAD LEFT OPERAND
       JSR  CDGVL            GEN CODE BY VALUE, MERGE
CGV27  MOV  CMROP(XL),XR     LOAD RIGHT OPERAND PTR
       JSR  CDGNM            GEN CODE BY NAME FOR RIGHT ARG
       MOV  CMOPN(XL),XR     GET OPERATOR CODE WORD
       BNE  (XR),=O_KWV,CGV20 GEN CALL UNLESS KEYWORD VALUE
       BNZ  WC,CGV20         GEN CALL IF NON-CONSTANT (NOT VAR)
       MNZ  WC               ELSE SET NON-CONSTANT IN CASE
       MOV  CMROP(XL),XR     LOAD PTR TO OPERAND VRBLK
       BNZ  VRLEN(XR),CGV20  GEN (NON-CONSTANT) IF NOT SYS VAR
       MOV  VRSVP(XR),XR     ELSE LOAD PTR TO SVBLK
       MOV  SVBIT(XR),WA     LOAD BIT MASK
       ANB  BTCKW,WA         TEST FOR CONSTANT KEYWORD
       ZRB  WA,CGV20         GO GEN IF NOT CONSTANT
       ZER  WC               ELSE SET RESULT CONSTANT
       BRN  CGV20            AND JUMP BACK TO GENERATE CALL
CGV28  MOV  =ONTA_,WA        GET INITIAL WORD
       JSR  CDWRD            GENERATE IT
       MOV  CWCOF,WB         SAVE NEXT OFFSET
       JSR  CDWRD            GENERATE GUNK WORD FOR NOW
       MOV  CMROP(XL),XR     LOAD RIGHT OPERAND PTR
       JSR  CDGVL            GEN CODE BY VALUE
       MOV  =ONTB_,WA        LOAD END OF EVALUATION CALL
       JSR  CDWRD            GENERATE IT
       MOV  WB,XR            COPY OFFSET TO WORD TO PLUG
       ADD  R_CCB,XR         POINT TO ACTUAL WORD TO PLUG
       MOV  CWCOF,(XR)       PLUG WORD WITH CURRENT OFFSET
       MOV  =ONTC_,WA        LOAD FINAL CALL
       BRN  CGV32            JUMP TO GENERATE IT (NOT CONSTANT)
CGV29  MOV  CMLOP(XL),XR     LOAD LEFT OPERAND PTR
       JSR  CDGVL            GENERATE CODE BY VALUE
CGV30  MOV  =C_UO_,WB        SET UNOP CODE + 1
       SUB  CMTYP(XL),WB     SET NUMBER OF ARGS (1 OR 2)
       MOV  CMROP(XL),XR     LOAD RIGHT (ONLY) OPERAND POINTER
       JSR  CDGVL            GEN VALUE CODE FOR RIGHT OPERAND
       MOV  CMOPN(XL),XR     LOAD POINTER TO OPERATOR DV
       MOV  DVOPN(XR),XR     LOAD POINTER OFFSET
       WTB  XR               CONVERT WORD OFFSET TO BYTES
       ADD  =R_UBA,XR        POINT TO PROPER FUNCTION PTR
       SUB  *VRFNC,XR        SET STANDARD FUNCTION OFFSET
       BRN  CGV12            MERGE WITH FUNCTION CALL CIRCUIT
CGV31  MNZ  WC               SET NON CONSTANT
       BRN  CGV19            MERGE
CGV32  JSR  CDWRD            GENERATE WORD, MERGE
CGV33  MNZ  WC               INDICATE RESULT IS NOT CONSTANT
CGV34  ICA  XS               POP INITIAL CODE OFFSET
       MOV  (XS)+,WA         RESTORE OLD CONSTANT FLAG
       MOV  (XS)+,XL         RESTORE ENTRY XL
       MOV  (XS)+,WB         RESTORE ENTRY WB
       BNZ  WC,CGV35         JUMP IF NOT CONSTANT
       MOV  WA,WC            ELSE RESTORE ENTRY CONSTANT FLAG
CGV35  EXI                   RETURN TO CDGVL CALLER
CGV36  JSR  CDWRD            GENERATE WORD
       BNZ  WC,CGV34         JUMP TO EXIT IF NOT CONSTANT
       MOV  =ORVL_,WA        LOAD CALL TO RETURN VALUE
       JSR  CDWRD            GENERATE IT
       MOV  (XS),XL          LOAD INITIAL CODE OFFSET
       JSR  EXBLD            BUILD EXBLK FOR EXPRESSION
       ZER  WB               SET TO EVALUATE BY VALUE
       JSR  EVALX            EVALUATE EXPRESSION
       PPM                   SHOULD NOT FAIL
       MOV  (XR),WA          LOAD TYPE WORD OF RESULT
       BLO  WA,=P_AAA,CGV37  JUMP IF NOT PATTERN
       MOV  =OLPT_,WA        ELSE LOAD SPECIAL PATTERN LOAD CALL
       JSR  CDWRD            GENERATE IT
CGV37  MOV  XR,WA            COPY CONSTANT POINTER
       JSR  CDWRD            GENERATE PTR
       ZER  WC               SET RESULT CONSTANT
       BRN  CGV34            JUMP BACK TO EXIT
       ENP                   END PROCEDURE CDGVL
.IF    .CSLN
.ELSE
.FI
CDWRD  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE ENTRY XR
       MOV  WA,-(XS)         SAVE CODE WORD TO BE GENERATED
CDWD1  MOV  R_CCB,XR         LOAD PTR TO CCBLK BEING BUILT
       BNZ  XR,CDWD2         JUMP IF BLOCK ALLOCATED
       MOV  *E_CBS,WA        LOAD INITIAL LENGTH
       JSR  ALLOC            ALLOCATE CCBLK
       MOV  =B_CCT,(XR)      STORE TYPE WORD
       MOV  *CCCOD,CWCOF     SET INITIAL OFFSET
       MOV  WA,CCLEN(XR)     STORE BLOCK LENGTH
.IF    .CSLN
       ZER  CCSLN(XR)        ZERO LINE NUMBER
.FI
       MOV  XR,R_CCB         STORE PTR TO NEW BLOCK
CDWD2  MOV  CWCOF,WA         LOAD CURRENT OFFSET
.IF    .CSLN
       ADD  *NUM05,WA        ADJUST FOR TEST (FIVE WORDS)
.ELSE
       ADD  *NUM04,WA        ADJUST FOR TEST (FOUR WORDS)
.FI
       BLO  WA,CCLEN(XR),CDWD4 JUMP IF ROOM IN THIS BLOCK
       BGE  WA,MXLEN,CDWD5   JUMP IF ALREADY AT MAX SIZE
       ADD  *E_CBS,WA        ELSE GET NEW SIZE
       MOV  XL,-(XS)         SAVE ENTRY XL
       MOV  XR,XL            COPY POINTER
       BLT  WA,MXLEN,CDWD3   JUMP IF NOT TOO LARGE
       MOV  MXLEN,WA         ELSE RESET TO MAX ALLOWED SIZE
CDWD3  JSR  ALLOC            ALLOCATE NEW BLOCK
       MOV  XR,R_CCB         STORE POINTER TO NEW BLOCK
       MOV  =B_CCT,(XR)+     STORE TYPE WORD IN NEW BLOCK
       MOV  WA,(XR)+         STORE BLOCK LENGTH
.IF    .CSLN
       MOV  CCSLN(XL),(XR)+  COPY SOURCE LINE NUMBER WORD
.FI
       ADD  *CCUSE,XL        POINT TO CCUSE,CCCOD FIELDS IN OLD
       MOV  (XL),WA          LOAD CCUSE VALUE
       MVW                   COPY USEFUL WORDS FROM OLD BLOCK
       MOV  (XS)+,XL         RESTORE XL
       BRN  CDWD1            MERGE BACK TO TRY AGAIN
CDWD4  MOV  CWCOF,WA         LOAD CURRENT OFFSET
       ICA  WA               GET NEW OFFSET
       MOV  WA,CWCOF         STORE NEW OFFSET
       MOV  WA,CCUSE(XR)     STORE IN CCBLK FOR GBCOL
       DCA  WA               RESTORE PTR TO THIS WORD
       ADD  WA,XR            POINT TO CURRENT ENTRY
       MOV  (XS)+,WA         RELOAD WORD TO GENERATE
       MOV  WA,(XR)          STORE WORD IN BLOCK
       MOV  (XS)+,XR         RESTORE ENTRY XR
       EXI                   RETURN TO CALLER
CDWD5  ERB  213,Syntax error: Statement is too complicated.
       ENP                   END PROCEDURE CDWRD
CMGEN  PRC  R,0              ENTRY POINT, RECURSIVE
       MOV  XL,XR            COPY CMBLK POINTER
       ADD  WB,XR            POINT TO CMBLK POINTER
       MOV  (XR),XR          LOAD CMBLK POINTER
       JSR  CDGVL            GENERATE CODE BY VALUE
       ICA  WB               BUMP OFFSET
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE CMGEN
CMPIL  PRC  E,0              ENTRY POINT
       LCT  WB,=CMNEN        SET NUMBER OF STACK WORK LOCATIONS
CMP00  ZER  -(XS)            STORE A ZERO, MAKE ONE ENTRY
       BCT  WB,CMP00         LOOP BACK UNTIL ALL SET
       MOV  XS,CMPXS         SAVE STACK POINTER FOR ERROR SEC
       SSS  CMPSS            SAVE S-R STACK POINTER IF ANY
CMP01  MOV  SCNPT,WB         SET SCAN POINTER OFFSET
       MOV  WB,SCNSE         SET START OF ELEMENT LOCATION
       MOV  =OCER_,WA        POINT TO COMPILE ERROR CALL
       JSR  CDWRD            GENERATE AS TEMPORARY CDFAL
       BLT  WB,SCNIL,CMP04   JUMP IF CHARS LEFT ON THIS IMAGE
CMPCE  ZER  XR               CLEAR POSSIBLE GARBAGE XR VALUE
.IF    .CINC
       BNZ  CNIND,CMPC2      IF WITHIN INCLUDE FILE
.FI
       BNE  STAGE,=STGIC,CMP02 SKIP UNLESS INITIAL COMPILE
CMPC2  JSR  READR            READ NEXT INPUT IMAGE
       BZE  XR,CMP09         JUMP IF NO INPUT AVAILABLE
       JSR  NEXTS            ACQUIRE NEXT SOURCE IMAGE
       MOV  CMPSN,LSTSN      STORE STMT NO FOR USE BY LISTR
       MOV  RDCLN,CMPLN      STORE LINE NUMBER AT START OF STMT
       ZER  SCNPT            RESET SCAN POINTER
       BRN  CMP04            GO PROCESS IMAGE
CMP02  MOV  R_CIM,XR         GET CURRENT IMAGE
       MOV  SCNPT,WB         GET CURRENT OFFSET
       PLC  XR,WB            PREPARE TO GET CHARS
CMP03  BGE  SCNPT,SCNIL,CMP09 END LOOP IF END OF IMAGE
       LCH  WC,(XR)+         GET CHAR
       ICV  SCNPT            ADVANCE OFFSET
       BNE  WC,=CH_SM,CMP03  LOOP IF NOT SEMI-COLON
CMP04  MOV  R_CIM,XR         POINT TO CURRENT IMAGE
       MOV  SCNPT,WB         LOAD CURRENT OFFSET
       MOV  WB,WA            COPY FOR LABEL SCAN
       PLC  XR,WB            POINT TO FIRST CHARACTER
       LCH  WC,(XR)+         LOAD FIRST CHARACTER
       BEQ  WC,=CH_SM,CMP12  NO LABEL IF SEMICOLON
       BEQ  WC,=CH_AS,CMPCE  LOOP BACK IF COMMENT CARD
       BEQ  WC,=CH_MN,CMP32  JUMP IF CONTROL CARD
       MOV  R_CIM,R_CMP      ABOUT TO DESTROY R_CIM
       MOV  =CMLAB,XL        POINT TO LABEL WORK STRING
       MOV  XL,R_CIM         SCANE IS TO SCAN WORK STRING
       PSC  XL               POINT TO FIRST CHARACTER POSITION
       SCH  WC,(XL)+         STORE CHAR JUST LOADED
       MOV  =CH_SM,WC        GET A SEMICOLON
       SCH  WC,(XL)          STORE AFTER FIRST CHAR
       CSC  XL               FINISHED CHARACTER STORING
       ZER  XL               CLEAR POINTER
       ZER  SCNPT            START AT FIRST CHARACTER
       MOV  SCNIL,-(XS)      PRESERVE IMAGE LENGTH
       MOV  =NUM02,SCNIL     READ 2 CHARS AT MOST
       JSR  SCANE            SCAN FIRST CHAR FOR TYPE
       MOV  (XS)+,SCNIL      RESTORE IMAGE LENGTH
       MOV  XL,WC            NOTE RETURN CODE
       MOV  R_CMP,XL         GET OLD R_CIM
       MOV  XL,R_CIM         PUT IT BACK
       MOV  WB,SCNPT         REINSTATE OFFSET
       BNZ  SCNBL,CMP12      BLANK SEEN - CANT BE LABEL
       MOV  XL,XR            POINT TO CURRENT IMAGE
       PLC  XR,WB            POINT TO FIRST CHAR AGAIN
       BEQ  WC,=T_VAR,CMP06  OK IF LETTER
       BEQ  WC,=T_CON,CMP06  OK IF DIGIT
CMPLE  MOV  R_CMP,R_CIM      POINT TO BAD LINE
       ERB  214,Bad label or misplaced continuation line
CMP05  BEQ  WC,=CH_SM,CMP07  SKIP IF SEMICOLON
       ICV  WA               BUMP OFFSET
       BEQ  WA,SCNIL,CMP07   JUMP IF END OF IMAGE (LABEL END)
CMP06  LCH  WC,(XR)+         ELSE LOAD NEXT CHARACTER
.IF    .CAHT
       BEQ  WC,=CH_HT,CMP07  JUMP IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WC,=CH_VT,CMP07  JUMP IF VERTICAL TAB
.FI
       BNE  WC,=CH_BL,CMP05  LOOP BACK IF NON-BLANK
CMP07  MOV  WA,SCNPT         SAVE UPDATED SCAN OFFSET
       SUB  WB,WA            GET LENGTH OF LABEL
       BZE  WA,CMP12         SKIP IF LABEL LENGTH ZERO
       ZER  XR               CLEAR GARBAGE XR VALUE
       JSR  SBSTR            BUILD SCBLK FOR LABEL NAME
       JSR  GTNVR            LOCATE/CONTRUCT VRBLK
       PPM                   DUMMY (IMPOSSIBLE) ERROR RETURN
       MOV  XR,CMLBL(XS)     STORE LABEL POINTER
       BNZ  VRLEN(XR),CMP11  JUMP IF NOT SYSTEM LABEL
       BNE  VRSVP(XR),=V_END,CMP11 JUMP IF NOT END LABEL
       ADD  =STGND,STAGE     ADJUST STAGE APPROPRIATELY
       JSR  SCANE            SCAN OUT NEXT ELEMENT
       BEQ  XL,=T_SMC,CMP10  JUMP IF END OF IMAGE
       BNE  XL,=T_VAR,CMP08  ELSE ERROR IF NOT VARIABLE
       BEQ  VRLBL(XR),=STNDL,CMP08 JUMP IF NOT DEFINED (ERROR)
       MOV  VRLBL(XR),CMTRA(XS) ELSE SET INITIAL ENTRY POINTER
       JSR  SCANE            SCAN NEXT ELEMENT
       BEQ  XL,=T_SMC,CMP10  JUMP IF OK (END OF IMAGE)
CMP08  ERB  215,Syntax error: Undefined or erroneous entry label
CMP09  ZER  XR               CLEAR GARBAGE XR VALUE
       ADD  =STGND,STAGE     ADJUST STAGE APPROPRIATELY
       BEQ  STAGE,=STGXE,CMP10 JUMP IF CODE CALL (OK)
       ERB  216,Syntax error: Missing END line
CMP10  MOV  =OSTP_,WA        SET STOP CALL POINTER
       JSR  CDWRD            GENERATE AS STATEMENT CALL
       BRN  CMPSE            JUMP TO GENERATE AS FAILURE
CMP11  BNE  STAGE,=STGIC,CMP12 JUMP IF CODE CALL - REDEF. OK
       BEQ  VRLBL(XR),=STNDL,CMP12 ELSE CHECK FOR REDEFINITION
       ZER  CMLBL(XS)        LEAVE FIRST LABEL DECLN UNDISTURBED
       ERB  217,Syntax error: Duplicate label
CMP12  ZER  WB               SET FLAG FOR STATEMENT BODY
       JSR  EXPAN            GET TREE FOR STATEMENT BODY
       MOV  XR,CMSTM(XS)     STORE FOR LATER USE
       ZER  CMSGO(XS)        CLEAR SUCCESS GOTO POINTER
       ZER  CMFGO(XS)        CLEAR FAILURE GOTO POINTER
       ZER  CMCGO(XS)        CLEAR CONDITIONAL GOTO FLAG
       JSR  SCANE            SCAN NEXT ELEMENT
       BEQ  XL,=T_COL,CMP13  JUMP IF COLON (GOTO)
       BNZ  CSWNO,CMP18      JUMP IF NOT OPTIMIZING
       BNZ  CMLBL(XS),CMP18  JUMP IF LABEL PRESENT
       MOV  CMSTM(XS),XR     LOAD TREE PTR FOR STATEMENT BODY
       MOV  (XR),WA          LOAD TYPE WORD
       BEQ  WA,=B_CMT,CMP18  JUMP IF CMBLK
       BGE  WA,=B_VRA,CMP18  JUMP IF NOT ICBLK, SCBLK, OR RCBLK
       MOV  R_CCB,XL         LOAD PTR TO CCBLK
       MOV  *CCCOD,CCUSE(XL) RESET USE OFFSET IN CCBLK
       MOV  *CCCOD,CWCOF     AND IN GLOBAL
       ICV  CMPSN            BUMP STATEMENT NUMBER
       BRN  CMP01            GENERATE NO CODE FOR STATEMENT
CMP13  MNZ  SCNGO            SET GOTO FLAG
       JSR  SCANE            SCAN NEXT ELEMENT
       BEQ  XL,=T_SMC,CMP31  JUMP IF NO FIELDS LEFT
       BEQ  XL,=T_SGO,CMP14  JUMP IF S FOR SUCCESS GOTO
       BEQ  XL,=T_FGO,CMP16  JUMP IF F FOR FAILURE GOTO
       MNZ  SCNRS            SET TO RESCAN ELEMENT NOT F,S
       JSR  SCNGF            SCAN OUT GOTO FIELD
       BNZ  CMFGO(XS),CMP17  ERROR IF FGOTO ALREADY
       MOV  XR,CMFGO(XS)     ELSE SET AS FGOTO
       BRN  CMP15            MERGE WITH SGOTO CIRCUIT
CMP14  JSR  SCNGF            SCAN SUCCESS GOTO FIELD
       MOV  =NUM01,CMCGO(XS) SET CONDITIONAL GOTO FLAG
CMP15  BNZ  CMSGO(XS),CMP17  ERROR IF SGOTO ALREADY GIVEN
       MOV  XR,CMSGO(XS)     ELSE SET SGOTO
       BRN  CMP13            LOOP BACK FOR NEXT GOTO FIELD
CMP16  JSR  SCNGF            SCAN GOTO FIELD
       MOV  =NUM01,CMCGO(XS) SET CONDITONAL GOTO FLAG
       BNZ  CMFGO(XS),CMP17  ERROR IF FGOTO ALREADY GIVEN
       MOV  XR,CMFGO(XS)     ELSE STORE FGOTO POINTER
       BRN  CMP13            LOOP BACK FOR NEXT FIELD
CMP17  ERB  218,Syntax error: Duplicated goto field
CMP18  ZER  SCNSE            STOP POSITIONAL ERROR FLAGS
       MOV  CMSTM(XS),XR     LOAD TREE PTR FOR STATEMENT BODY
       ZER  WB               COLLECTABLE VALUE FOR WB FOR CDGVL
       ZER  WC               RESET CONSTANT FLAG FOR CDGVL
       JSR  EXPAP            TEST FOR PATTERN MATCH
       PPM  CMP19            JUMP IF NOT PATTERN MATCH
       MOV  =OPMS_,CMOPN(XR) ELSE SET PATTERN MATCH POINTER
       MOV  =C_PMT,CMTYP(XR)
CMP19  JSR  CDGVL            GENERATE CODE FOR BODY OF STATEMENT
       MOV  CMSGO(XS),XR     LOAD SGOTO POINTER
       MOV  XR,WA            COPY IT
       BZE  XR,CMP21         JUMP IF NO SUCCESS GOTO
       ZER  CMSOC(XS)        CLEAR SUCCESS OFFSET FILLIN PTR
       BHI  XR,STATE,CMP20   JUMP IF COMPLEX GOTO
       ADD  *VRTRA,WA        POINT TO VRTRA FIELD AS REQUIRED
       JSR  CDWRD            GENERATE SUCCESS GOTO
       BRN  CMP22            JUMP TO DEAL WITH FGOTO
CMP20  BEQ  XR,CMFGO(XS),CMP22 NO CODE IF SAME AS FGOTO
       ZER  WB               ELSE SET OK VALUE FOR CDGVL IN WB
       JSR  CDGCG            GENERATE CODE FOR SUCCESS GOTO
       BRN  CMP22            JUMP TO DEAL WITH FGOTO
CMP21  MOV  CWCOF,CMSOC(XS)  SET SUCCESS FILL IN OFFSET
       MOV  =OCER_,WA        POINT TO COMPILE ERROR CALL
       JSR  CDWRD            GENERATE AS TEMPORARY VALUE
CMP22  MOV  CMFGO(XS),XR     LOAD FAILURE GOTO POINTER
       MOV  XR,WA            COPY IT
       ZER  CMFFC(XS)        SET NO FILL IN REQUIRED YET
       BZE  XR,CMP23         JUMP IF NO FAILURE GOTO GIVEN
       ADD  *VRTRA,WA        POINT TO VRTRA FIELD IN CASE
       BLO  XR,STATE,CMPSE   JUMP TO GEN IF SIMPLE FGOTO
       MOV  CWCOF,WB         SAVE OFFSET TO O_GOF CALL
       MOV  =OGOF_,WA        POINT TO FAILURE GOTO CALL
       JSR  CDWRD            GENERATE
       MOV  =OFIF_,WA        POINT TO FAIL IN FAIL WORD
       JSR  CDWRD            GENERATE
       JSR  CDGCG            GENERATE CODE FOR FAILURE GOTO
       MOV  WB,WA            COPY OFFSET TO O_GOF FOR CDFAL
       MOV  =B_CDC,WB        SET COMPLEX CASE CDTYP
       BRN  CMP25            JUMP TO BUILD CDBLK
CMP23  MOV  =OUNF_,WA        LOAD UNEXPECTED FAILURE CALL IN CAS
       MOV  CSWFL,WC         GET -NOFAIL FLAG
       ORB  CMCGO(XS),WC     CHECK IF CONDITIONAL GOTO
       ZRB  WC,CMPSE         JUMP IF -NOFAIL AND NO COND. GOTO
       MNZ  CMFFC(XS)        ELSE SET FILL IN FLAG
       MOV  =OCER_,WA        AND SET COMPILE ERROR FOR TEMPORARY
CMPSE  MOV  =B_CDS,WB        SET CDTYP FOR SIMPLE CASE
CMP25  MOV  R_CCB,XR         POINT TO CCBLK
       MOV  CMLBL(XS),XL     GET POSSIBLE LABEL POINTER
       BZE  XL,CMP26         SKIP IF NO LABEL
       ZER  CMLBL(XS)        CLEAR FLAG FOR NEXT STATEMENT
       MOV  XR,VRLBL(XL)     PUT CDBLK PTR IN VRBLK LABEL FIELD
CMP26  MOV  WB,(XR)          SET TYPE WORD FOR NEW CDBLK
       MOV  WA,CDFAL(XR)     SET FAILURE WORD
       MOV  XR,XL            COPY POINTER TO CCBLK
       MOV  CCUSE(XR),WB     LOAD LENGTH GEN (= NEW CDLEN)
       MOV  CCLEN(XR),WC     LOAD TOTAL CCBLK LENGTH
       ADD  WB,XL            POINT PAST CDBLK
       SUB  WB,WC            GET LENGTH LEFT FOR CHOP OFF
       MOV  =B_CCT,(XL)      SET TYPE CODE FOR NEW CCBLK AT END
       MOV  *CCCOD,CCUSE(XL) SET INITIAL CODE OFFSET
       MOV  *CCCOD,CWCOF     REINITIALISE CWCOF
       MOV  WC,CCLEN(XL)     SET NEW LENGTH
       MOV  XL,R_CCB         SET NEW CCBLK POINTER
.IF    .CSLN
       ZER  CCSLN(XL)        INITIALIZE NEW LINE NUMBER
       MOV  CMPLN,CDSLN(XR)  SET LINE NUMBER IN OLD BLOCK
.FI
       MOV  CMPSN,CDSTM(XR)  SET STATEMENT NUMBER
       ICV  CMPSN            BUMP STATEMENT NUMBER
       MOV  CMPCD(XS),XL     LOAD PTR TO PREVIOUS CDBLK
       BZE  CMFFP(XS),CMP27  JUMP IF NO FAILURE FILL IN REQUIRED
       MOV  XR,CDFAL(XL)     ELSE SET FAILURE PTR IN PREVIOUS
CMP27  MOV  CMSOP(XS),WA     LOAD SUCCESS OFFSET
       BZE  WA,CMP28         JUMP IF NO FILL IN REQUIRED
       ADD  WA,XL            ELSE POINT TO FILL IN LOCATION
       MOV  XR,(XL)          STORE FORWARD POINTER
       ZER  XL               CLEAR GARBAGE XL VALUE
CMP28  MOV  CMFFC(XS),CMFFP(XS) COPY FAILURE FILL IN FLAG
       MOV  CMSOC(XS),CMSOP(XS) COPY SUCCESS FILL IN OFFSET
       MOV  XR,CMPCD(XS)     SAVE PTR TO THIS CDBLK
       BNZ  CMTRA(XS),CMP29  JUMP IF INITIAL ENTRY ALREADY SET
       MOV  XR,CMTRA(XS)     ELSE SET PTR HERE AS DEFAULT
CMP29  BLT  STAGE,=STGCE,CMP01 JUMP IF NOT END LINE JUST DONE
       BZE  CSWLS,CMP30      SKIP IF -NOLIST
       JSR  LISTR            LIST LAST LINE
CMP30  MOV  CMTRA(XS),XR     LOAD INITIAL ENTRY CDBLK POINTER
       ADD  *CMNEN,XS        POP WORK LOCATIONS OFF STACK
       EXI                   AND RETURN TO CMPIL CALLER
CMP31  MOV  CMFGO(XS),WB     GET FAIL GOTO
       ORB  CMSGO(XS),WB     OR IN SUCCESS GOTO
       BNZ  WB,CMP18         OK IF NON-NULL FIELD
       ERB  219,Syntax error: Empty goto field
CMP32  ICV  WB               POINT PAST CH_MN
       JSR  CNCRD            PROCESS CONTROL CARD
       ZER  SCNSE            CLEAR START OF ELEMENT LOC.
       BRN  CMPCE            LOOP FOR NEXT STATEMENT
       ENP                   END PROCEDURE CMPIL
CNCRD  PRC  E,0              ENTRY POINT
       MOV  WB,SCNPT         OFFSET FOR CONTROL CARD SCAN
       MOV  =CCNOC,WA        NUMBER OF CHARS FOR COMPARISON
       CTW  WA,0             CONVERT TO WORD COUNT
       MOV  WA,CNSWC         SAVE WORD COUNT
CNC01  BGE  SCNPT,SCNIL,CNC09 RETURN IF END OF IMAGE
       MOV  R_CIM,XR         POINT TO IMAGE
       PLC  XR,SCNPT         CHAR PTR FOR FIRST CHAR
       LCH  WA,(XR)+         GET FIRST CHAR
.IF    .CULC
       FLC  WA               FOLD TO UPPER CASE
.FI
       BEQ  WA,=CH_LI,CNC07  SPECIAL CASE OF -INXXX
CNC0A  MNZ  SCNCC            SET FLAG FOR SCANE
       JSR  SCANE            SCAN CARD NAME
       ZER  SCNCC            CLEAR SCANE FLAG
       BNZ  XL,CNC06         FAIL UNLESS CONTROL CARD NAME
       MOV  =CCNOC,WA        NO. OF CHARS TO BE COMPARED
.IF    .CICC
       BLT  SCLEN(XR),WA,CNC08  FAIL IF TOO FEW CHARS
.ELSE
       BLT  SCLEN(XR),WA,CNC06  FAIL IF TOO FEW CHARS
.FI
       MOV  XR,XL            POINT TO CONTROL CARD NAME
       ZER  WB               ZERO OFFSET FOR SUBSTRING
       JSR  SBSTR            EXTRACT SUBSTRING FOR COMPARISON
.IF    .CULC
       MOV  SCLEN(XR),WA     RELOAD LENGTH
       JSR  FLSTG            FOLD TO UPPER CASE
.FI
       MOV  XR,CNSCC         KEEP CONTROL CARD SUBSTRING PTR
       MOV  =CCNMS,XR        POINT TO LIST OF STANDARD NAMES
       ZER  WB               INITIALISE NAME OFFSET
       LCT  WC,=CC_NC        NUMBER OF STANDARD NAMES
CNC02  MOV  CNSCC,XL         POINT TO NAME
       LCT  WA,CNSWC         COUNTER FOR INNER LOOP
       BRN  CNC04            JUMP INTO LOOP
CNC03  ICA  XR               BUMP STANDARD NAMES PTR
       ICA  XL               BUMP NAME POINTER
CNC04  CNE  SCHAR(XL),(XR),CNC05 COMP. UP TO CFP_C CHARS AT ONCE
       BCT  WA,CNC03         LOOP IF MORE WORDS TO COMPARE
       MOV  WB,XL            GET NAME OFFSET
.IF    .CICC
       BSW  XL,CC_NC,CNC08   SWITCH
.ELSE
       BSW  XL,CC_NC,CNC06   SWITCH
.FI
.IF    .CULC
       IFF  CC_CA,CNC37      -CASE
.FI
.IF    .CCMC
       IFF  CC_CO,CNC39      -COMPARE
.FI
       IFF  CC_DO,CNC10      -DOUBLE
       IFF  CC_DU,CNC11      -DUMP
.IF    .CINC
       IFF  CC_CP,CNC41      -COPY
.FI
       IFF  CC_EJ,CNC12      -EJECT
       IFF  CC_ER,CNC13      -ERRORS
       IFF  CC_EX,CNC14      -EXECUTE
       IFF  CC_FA,CNC15      -FAIL
.IF    .CINC
       IFF  CC_IN,CNC41      -INCLUDE
.FI
.IF    .CSLN
       IFF  CC_LN,CNC44      -LINE
.FI
       IFF  CC_LI,CNC16      -LIST
       IFF  CC_NR,CNC17      -NOERRORS
       IFF  CC_NX,CNC18      -NOEXECUTE
       IFF  CC_NF,CNC19      -NOFAIL
       IFF  CC_NL,CNC20      -NOLIST
       IFF  CC_NO,CNC21      -NOOPT
       IFF  CC_NP,CNC22      -NOPRINT
       IFF  CC_OP,CNC24      -OPTIMISE
       IFF  CC_PR,CNC25      -PRINT
       IFF  CC_SI,CNC27      -SINGLE
       IFF  CC_SP,CNC28      -SPACE
       IFF  CC_ST,CNC31      -STITLE
       IFF  CC_TI,CNC32      -TITLE
       IFF  CC_TR,CNC36      -TRACE
       ESW                   END SWITCH
CNC05  ICA  XR               BUMP STANDARD NAMES PTR
       BCT  WA,CNC05         LOOP
       ICV  WB               BUMP NAMES OFFSET
       BCT  WC,CNC02         CONTINUE IF MORE NAMES
.IF    .CICC
       BRN  CNC08            IGNORE UNRECOGNIZED CONTROL CARD
.FI
CNC06  ERB  247,Invalid control statement
CNC07  LCH  WA,(XR)+         GET NEXT CHAR
.IF    .CULC
       FLC  WA               FOLD TO UPPER CASE
.FI
       BNE  WA,=CH_LN,CNC0A  IF NOT LETTER N
       LCH  WA,(XR)          GET THIRD CHAR
       BLT  WA,=CH_D0,CNC0A  IF NOT DIGIT
       BGT  WA,=CH_D9,CNC0A  IF NOT DIGIT
       ADD  =NUM02,SCNPT     BUMP OFFSET PAST -IN
       JSR  SCANE            SCAN INTEGER AFTER -IN
       MOV  XR,-(XS)         STACK SCANNED ITEM
       JSR  GTSMI            CHECK IF INTEGER
       PPM  CNC06            FAIL IF NOT INTEGER
       PPM  CNC06            FAIL IF NEGATIVE OR LARGE
       MOV  XR,CSWIN         KEEP INTEGER
CNC08  MOV  SCNPT,WA         PRESERVE IN CASE XEQ TIME COMPILE
       JSR  SCANE            LOOK FOR COMMA
       BEQ  XL,=T_CMA,CNC01  LOOP IF COMMA FOUND
       MOV  WA,SCNPT         RESTORE SCNPT IN CASE XEQ TIME
CNC09  EXI                   RETURN
CNC10  MNZ  CSWDB            SET SWITCH
       BRN  CNC08            MERGE
CNC11  JSR  SYSDM            CALL DUMPER
       BRN  CNC09            FINISHED
CNC12  BZE  CSWLS,CNC09      RETURN IF -NOLIST
       JSR  PRTPS            EJECT
       JSR  LISTT            LIST TITLE
       BRN  CNC09            FINISHED
CNC13  ZER  CSWER            CLEAR SWITCH
       BRN  CNC08            MERGE
CNC14  ZER  CSWEX            CLEAR SWITCH
       BRN  CNC08            MERGE
CNC15  MNZ  CSWFL            SET SWITCH
       BRN  CNC08            MERGE
CNC16  MNZ  CSWLS            SET SWITCH
       BEQ  STAGE,=STGIC,CNC08 DONE IF COMPILE TIME
       ZER  LSTPF            PERMIT LISTING
       JSR  LISTR            LIST LINE
       BRN  CNC08            MERGE
CNC17  MNZ  CSWER            SET SWITCH
       BRN  CNC08            MERGE
CNC18  MNZ  CSWEX            SET SWITCH
       BRN  CNC08            MERGE
CNC19  ZER  CSWFL            CLEAR SWITCH
       BRN  CNC08            MERGE
CNC20  ZER  CSWLS            CLEAR SWITCH
       BRN  CNC08            MERGE
CNC21  MNZ  CSWNO            SET SWITCH
       BRN  CNC08            MERGE
CNC22  ZER  CSWPR            CLEAR SWITCH
       BRN  CNC08            MERGE
CNC24  ZER  CSWNO            CLEAR SWITCH
       BRN  CNC08            MERGE
CNC25  MNZ  CSWPR            SET SWITCH
       BRN  CNC08            MERGE
CNC27  ZER  CSWDB            CLEAR SWITCH
       BRN  CNC08            MERGE
CNC28  BZE  CSWLS,CNC09      RETURN IF -NOLIST
       JSR  SCANE            SCAN INTEGER AFTER -SPACE
       MOV  =NUM01,WC        1 SPACE IN CASE
       BEQ  XR,=T_SMC,CNC29  JUMP IF NO INTEGER
       MOV  XR,-(XS)         STACK IT
       JSR  GTSMI            CHECK INTEGER
       PPM  CNC06            FAIL IF NOT INTEGER
       PPM  CNC06            FAIL IF NEGATIVE OR LARGE
       BNZ  WC,CNC29         JUMP IF NON ZERO
       MOV  =NUM01,WC        ELSE 1 SPACE
CNC29  ADD  WC,LSTLC         BUMP LINE COUNT
       LCT  WC,WC            CONVERT TO LOOP COUNTER
       BLT  LSTLC,LSTNP,CNC30 JUMP IF FITS ON PAGE
       JSR  PRTPS            EJECT
       JSR  LISTT            LIST TITLE
       BRN  CNC09            MERGE
CNC30  JSR  PRTNL            PRINT A BLANK
       BCT  WC,CNC30         LOOP
       BRN  CNC09            MERGE
CNC31  MOV  =R_STL,CNR_T     PTR TO R_STL
       BRN  CNC33            MERGE
CNC32  MOV  =NULLS,R_STL     CLEAR SUBTITLE
       MOV  =R_TTL,CNR_T     PTR TO R_TTL
CNC33  MOV  =NULLS,XR        NULL IN CASE NEEDED
       MNZ  CNTTL            SET FLAG FOR NEXT LISTR CALL
       MOV  =CCOFS,WB        OFFSET TO TITLE/SUBTITLE
       MOV  SCNIL,WA         INPUT IMAGE LENGTH
       BLO  WA,WB,CNC34      JUMP IF NO CHARS LEFT
       SUB  WB,WA            NO OF CHARS TO EXTRACT
       MOV  R_CIM,XL         POINT TO IMAGE
       JSR  SBSTR            GET TITLE/SUBTITLE
CNC34  MOV  CNR_T,XL         POINT TO STORAGE LOCATION
       MOV  XR,(XL)          STORE TITLE/SUBTITLE
       BEQ  XL,=R_STL,CNC09  RETURN IF STITL
       BNZ  PRECL,CNC09      RETURN IF EXTENDED LISTING
       BZE  PRICH,CNC09      RETURN IF REGULAR PRINTER
       MOV  SCLEN(XR),XL     GET LENGTH OF TITLE
       MOV  XL,WA            COPY IT
       BZE  XL,CNC35         JUMP IF NULL
       ADD  =NUM10,XL        INCREMENT
       BHI  XL,PRLEN,CNC09   USE DEFAULT LSTP0 VAL IF TOO LONG
       ADD  =NUM04,WA        POINT JUST PAST TITLE
CNC35  MOV  WA,LSTPO         STORE OFFSET
       BRN  CNC09            RETURN
CNC36  JSR  SYSTT            TOGGLE SWITCH
       BRN  CNC08            MERGE
.IF    .CULC
CNC37  JSR  SCANE            SCAN INTEGER AFTER -CASE
       ZER  WC               GET 0 IN CASE NONE THERE
       BEQ  XL,=T_SMC,CNC38  SKIP IF NO INTEGER
       MOV  XR,-(XS)         STACK IT
       JSR  GTSMI            CHECK INTEGER
       PPM  CNC06            FAIL IF NOT INTEGER
       PPM  CNC06            FAIL IF NEGATIVE OR TOO LARGE
CNC38  MOV  WC,KVCAS         STORE NEW CASE VALUE
       BRN  CNC09            MERGE
.FI
.IF    .CCMC
CNC39  JSR  SCANE            SCAN INTEGER AFTER -COMPARE
       ZER  WC               GET 0 IN CASE NONE THERE
       BEQ  XL,=T_SMC,CNC40  SKIP IF NO INTEGER
       MOV  XR,-(XS)         STACK IT
       JSR  GTSMI            CHECK INTEGER
       PPM  CNC06            FAIL IF NOT INTEGER
       PPM  CNC06            FAIL IF NEGATIVE OR TOO LARGE
CNC40  MOV  WC,KVCOM         STORE NEW COMPARE VALUE
       BRN  CNC09            MERGE
.FI
.IF    .CINC
CNC41  MNZ  SCNCC            SET FLAG FOR SCANE
       JSR  SCANE            SCAN QUOTED FILE NAME
       ZER  SCNCC            CLEAR SCANE FLAG
       BNE  XL,=T_CON,CNC06  IF NOT CONSTANT
       BNE  (XR),=B_SCL,CNC06  IF NOT STRING CONSTANT
       MOV  XR,R_IFN         SAVE FILE NAME
       MOV  R_INC,XL         EXAMINE INCLUDE FILE NAME TABLE
       ZER  WB               LOOKUP BY VALUE
       JSR  TFIND            DO LOOKUP
       PPM                   NEVER FAILS
       BEQ  XR,=INTON,CNC09  IGNORE IF ALREADY IN TABLE
       MNZ  WB               SET FOR TRIM
       MOV  R_IFN,XR         FILE NAME
       JSR  TRIMR            REMOVE TRAILING BLANKS
       MOV  R_INC,XL         INCLUDE FILE NAME TABLE
       MNZ  WB               LOOKUP BY NAME THIS TIME
       JSR  TFIND            DO LOOKUP
       PPM                   NEVER FAILS
       MOV  =INTON,TEVAL(XL) MAKE TABLE VALUE INTEGER 1
       ICV  CNIND            INCREASE NESTING LEVEL
       MOV  CNIND,WA         LOAD NEW NEST LEVEL
       BGT  WA,=CCINM,CNC42  FAIL IF EXCESSIVE NESTING
.IF    .CSFN
       MOV  R_IFA,XL         ARRAY OF NESTED FILE NAMES
       ADD  =VCVLB,WA        COMPUTE OFFSET IN WORDS
       WTB  WA               CONVERT TO BYTES
       ADD  WA,XL            POINT TO ELEMENT
       MOV  R_SFC,(XL)       RECORD CURRENT FILE NAME
       MOV  WA,XL            PRESERVE NESTING BYTE OFFSET
       MTI  RDNLN            FETCH SOURCE LINE NUMBER AS INTEGER
       JSR  ICBLD            CONVERT TO ICBLK
       ADD  R_IFL,XL         ENTRY IN NESTED LINE NUMBER ARRAY
       MOV  XR,(XL)          RECORD IN ARRAY
.FI
       MOV  CSWIN,WA         MAX READ LENGTH
       MOV  R_IFN,XL         INCLUDE FILE NAME
       JSR  ALOCS            GET BUFFER FOR COMPLETE FILE NAME
       JSR  SYSIF            OPEN INCLUDE FILE
       PPM  CNC43            COULD NOT OPEN
.IF    .CSFN
       ZER  WB               DO NOT TRIM TRAILING BLANKS
       JSR  TRIMR            ADJUST SCBLK FOR ACTUAL LENGTH
       MOV  XR,R_SFC         SAVE PTR TO FILE NAME
       MTI  CMPSN            CURRENT STATEMENT AS INTEGER
       JSR  ICBLD            BUILD ICBLK FOR STMT NUMBER
       MOV  R_SFN,XL         FILE NAME TABLE
       MNZ  WB               LOOKUP STATEMENT NUMBER BY NAME
       JSR  TFIND            ALLOCATE NEW TEBLK
       PPM                   ALWAYS POSSIBLE TO ALLOCATE BLOCK
       MOV  R_SFC,TEVAL(XL)  RECORD FILE NAME AS ENTRY VALUE
.ELSE
       MOV  XR,DNAMP         RELEASE ALLOCATED SCBLK
.FI
       ZER  RDNLN            RESTART LINE COUNTER FOR NEW FILE
       BEQ  STAGE,=STGIC,CNC09 IF INITIAL COMPILE
       BNE  CNIND,=NUM01,CNC09 IF NOT FIRST EXECUTE-TIME NESTING
       MOV  R_CIM,R_ICI      REMEMBER CODE ARGUMENT STRING
       MOV  SCNPT,CNSPT      SAVE POSITION IN STRING
       MOV  SCNIL,CNSIL      AND LENGTH OF STRING
       BRN  CNC09            ALL DONE, MERGE
CNC42  ERB  284,Excessively nested INCLUDE files
CNC43  MOV  XR,DNAMP         RELEASE ALLOCATED SCBLK
       ERB  285,INCLUDE file cannot be opened
.FI
.IF    .CSLN
CNC44  JSR  SCANE            SCAN INTEGER AFTER -LINE
       BNE  XL,=T_CON,CNC06  JUMP IF NO LINE NUMBER
       BNE  (XR),=B_ICL,CNC06 JUMP IF NOT INTEGER
       LDI  ICVAL(XR)        FETCH INTEGER LINE NUMBER
       ILE  CNC06            ERROR IF NEGATIVE OR ZERO
       BEQ  STAGE,=STGIC,CNC45 SKIP IF INITIAL COMPILE
       MFI  CMPLN            SET DIRECTLY FOR OTHER COMPILES
       BRN  CNC46            NO NEED TO SET RDNLN
CNC45  SBI  INTV1            ADJUST NUMBER BY ONE
       MFI  RDNLN            SAVE LINE NUMBER
.IF    .CSFN
CNC46  MNZ  SCNCC            SET FLAG FOR SCANE
       JSR  SCANE            SCAN QUOTED FILE NAME
       ZER  SCNCC            CLEAR SCANE FLAG
       BEQ  XL,=T_SMC,CNC47  DONE IF NO FILE NAME
       BNE  XL,=T_CON,CNC06  ERROR IF NOT CONSTANT
       BNE  (XR),=B_SCL,CNC06 IF NOT STRING CONSTANT
       JSR  NEWFN            RECORD NEW FILE NAME
       BRN  CNC09            MERGE
CNC47  DCV  SCNPT            SET TO RESCAN THE TERMINATOR
       BRN  CNC09            MERGE
.ELSE
CNC46  BRN  CNC09            MERGE
.FI
.FI
       ENP                   END PROCEDURE CNCRD
.IF    .CENG
.IF    .CEVB
.FI
ENEVS  PRC  R,0              ENTRY POINT (RECURSIVE)
.IF    .CEVB
       MOV  WB,-(XS)         SAVE VALUE/NAME FLAG
.FI
       JSR  GTEXP            CONVERT TO EXPRESSION
       PPM  ENEV2            CONVERSION FAILS
.IF    .CEVB
       MOV  (XS)+,WB         RECOVER VALUE/NAME FLAG
.FI
       JSR  EVALX            EVALUATE EXPRESSION BY VALUE
       PPM  ENEV1            EVALUATION FAILS
       EXI
ENEV1  ZER  XR               RETURN ZERO RESULT
       EXI
.IF    .CEVB
ENEV2  ICA  XS               DISCARD VALUE/NAME FLAG
       MOV  =NUM01,XR        RETURN INTEGER ONE RESULT
.ELSE
ENEV2  MOV  =NUM01,XR        RETURN INTEGER ONE RESULT
.FI
       EXI
       ENP
ENGTS  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         STACK ARGUMENT TO CONVERT
       JSR  GTSTG            CONVERT TO STRING
       PPM  ENGT1            CONVERT IMPOSSIBLE
       EXI
ENGT1  ZER  XR               RETURN ZERO
       EXI
       ENP
.FI
DFFNC  PRC  E,0              ENTRY POINT
.IF    .CNLD
.ELSE
       BNE  (XL),=B_EFC,DFFN1 SKIP IF NEW FUNCTION NOT EXTERNAL
       ICV  EFUSE(XL)        ELSE INCREMENT ITS USE COUNT
DFFN1  MOV  XR,WA            SAVE VRBLK POINTER
       MOV  VRFNC(XR),XR     LOAD OLD FUNCTION POINTER
       BNE  (XR),=B_EFC,DFFN2 JUMP IF OLD FUNCTION NOT EXTERNAL
       MOV  EFUSE(XR),WB     ELSE GET USE COUNT
       DCV  WB               DECREMENT
       MOV  WB,EFUSE(XR)     STORE DECREMENTED VALUE
       BNZ  WB,DFFN2         JUMP IF USE COUNT STILL NON-ZERO
       JSR  SYSUL            ELSE CALL SYSTEM UNLOAD FUNCTION
DFFN2  MOV  WA,XR            RESTORE VRBLK POINTER
.FI
       MOV  XL,WA            COPY FUNCTION BLOCK PTR
       BLT  XR,=R_YYY,DFFN3  SKIP CHECKS IF OPSYN OP DEFINITION
       BNZ  VRLEN(XR),DFFN3  JUMP IF NOT SYSTEM VARIABLE
       MOV  VRSVP(XR),XL     POINT TO SVBLK
       MOV  SVBIT(XL),WB     LOAD BIT INDICATORS
       ANB  BTFNC,WB         IS IT A SYSTEM FUNCTION
       ZRB  WB,DFFN3         REDEF OK IF NOT
       ERB  248,Attempted redefinition of system function
DFFN3  MOV  WA,VRFNC(XR)     STORE NEW FUNCTION POINTER
       MOV  WA,XL            RESTORE FUNCTION BLOCK POINTER
       EXI                   RETURN TO DFFNC CALLER
       ENP                   END PROCEDURE DFFNC
DTACH  PRC  E,0              ENTRY POINT
       MOV  XL,DTCNB         STORE NAME BASE (GBCOL NOT CALLED)
       ADD  WA,XL            POINT TO NAME LOCATION
       MOV  XL,DTCNM         STORE IT
DTCH1  MOV  XL,XR            COPY NAME POINTER
DTCH2  MOV  (XL),XL          POINT TO NEXT VALUE
       BNE  (XL),=B_TRT,DTCH6 JUMP AT CHAIN END
       MOV  TRTYP(XL),WA     GET TRAP BLOCK TYPE
       BEQ  WA,=TRTIN,DTCH3  JUMP IF INPUT
       BEQ  WA,=TRTOU,DTCH3  JUMP IF OUTPUT
       ADD  *TRNXT,XL        POINT TO NEXT LINK
       BRN  DTCH1            LOOP
DTCH3  MOV  TRVAL(XL),(XR)   DELETE TRBLK
       MOV  XL,WA            DUMP XL ...
       MOV  XR,WB            ... AND XR
       MOV  TRTRF(XL),XL     POINT TO TRTRF TRAP BLOCK
       BZE  XL,DTCH5         JUMP IF NO IOCHN
       BNE  (XL),=B_TRT,DTCH5 JUMP IF INPUT, OUTPUT, TERMINAL
DTCH4  MOV  XL,XR            REMEMBER LINK PTR
       MOV  TRTRF(XL),XL     POINT TO NEXT LINK
       BZE  XL,DTCH5         JUMP IF END OF CHAIN
       MOV  IONMB(XL),WC     GET NAME BASE
       ADD  IONMO(XL),WC     ADD OFFSET
       BNE  WC,DTCNM,DTCH4   LOOP IF NO MATCH
       MOV  TRTRF(XL),TRTRF(XR) REMOVE NAME FROM CHAIN
DTCH5  MOV  WA,XL            RECOVER XL ...
       MOV  WB,XR            ... AND XR
       ADD  *TRVAL,XL        POINT TO VALUE FIELD
       BRN  DTCH2            CONTINUE
DTCH6  MOV  DTCNB,XR         POSSIBLE VRBLK PTR
       JSR  SETVR            RESET VRBLK IF NECESSARY
       EXI                   RETURN
       ENP                   END PROCEDURE DTACH
DTYPE  PRC  E,0              ENTRY POINT
       BEQ  (XR),=B_PDT,DTYP1   JUMP IF PROG.DEFINED
       MOV  (XR),XR          LOAD TYPE WORD
       LEI  XR               GET ENTRY POINT ID (BLOCK CODE)
       WTB  XR               CONVERT TO BYTE OFFSET
       MOV  SCNMT(XR),XR     LOAD TABLE ENTRY
       EXI                   EXIT TO DTYPE CALLER
DTYP1  MOV  PDDFP(XR),XR     POINT TO DFBLK
       MOV  DFNAM(XR),XR     GET DATATYPE NAME FROM DFBLK
       EXI                   RETURN TO DTYPE CALLER
       ENP                   END PROCEDURE DTYPE
DUMPR  PRC  E,0              ENTRY POINT
       BZE  XR,DMP28         SKIP DUMP IF ARGUMENT IS ZERO
       BGT  XR,=NUM03,DMP29  JUMP IF CORE DUMP REQUIRED
       ZER  XL               CLEAR XL
       ZER  WB               ZERO MOVE OFFSET
       MOV  XR,DMARG         SAVE DUMP ARGUMENT
.IF    .CSED
       ZER  DNAMS            COLLECT SEDIMENT TOO
.FI
       JSR  GBCOL            COLLECT GARBAGE
       JSR  PRTPG            EJECT PRINTER
       MOV  =DMHDV,XR        POINT TO HEADING FOR VARIABLES
       JSR  PRTST            PRINT IT
       JSR  PRTNL            TERMINATE PRINT LINE
       JSR  PRTNL            AND PRINT A BLANK LINE
       ZER  DMVCH            SET NULL CHAIN TO START
       MOV  HSHTB,WA         POINT TO HASH TABLE
DMP00  MOV  WA,XR            COPY HASH BUCKET POINTER
       ICA  WA               BUMP POINTER
       SUB  *VRNXT,XR        SET OFFSET TO MERGE
DMP01  MOV  VRNXT(XR),XR     POINT TO NEXT VRBLK ON CHAIN
       BZE  XR,DMP09         JUMP IF END OF THIS HASH CHAIN
       MOV  XR,XL            ELSE COPY VRBLK POINTER
DMP02  MOV  VRVAL(XL),XL     LOAD VALUE
       BEQ  DMARG,=NUM03,DMP2A SKIP NULL VALUE CHECK IF DUMP(3)
       BEQ  XL,=NULLS,DMP01  LOOP FOR NEXT VRBLK IF NULL VALUE
DMP2A  BEQ  (XL),=B_TRT,DMP02 LOOP BACK IF VALUE IS TRAPPED
       MOV  XR,WC            SAVE VRBLK POINTER
       ADD  *VRSOF,XR        ADJUST PTR TO BE LIKE SCBLK PTR
       BNZ  SCLEN(XR),DMP03  JUMP IF NON-SYSTEM VARIABLE
       MOV  VRSVO(XR),XR     ELSE LOAD PTR TO NAME IN SVBLK
DMP03  MOV  XR,WB            SAVE POINTER TO CHARS
       MOV  WA,DMPSV         SAVE HASH BUCKET POINTER
       MOV  =DMVCH,WA        POINT TO CHAIN HEAD
DMP04  MOV  WA,DMPCH         SAVE CHAIN POINTER
       MOV  WA,XL            COPY IT
       MOV  (XL),XR          LOAD POINTER TO NEXT ENTRY
       BZE  XR,DMP08         JUMP IF END OF CHAIN TO INSERT
       ADD  *VRSOF,XR        ELSE GET NAME PTR FOR CHAINED VRBLK
       BNZ  SCLEN(XR),DMP05  JUMP IF NOT SYSTEM VARIABLE
       MOV  VRSVO(XR),XR     ELSE POINT TO NAME IN SVBLK
DMP05  MOV  WB,XL            POINT TO ENTERING VRBLK STRING
       MOV  SCLEN(XL),WA     LOAD ITS LENGTH
       PLC  XL               POINT TO CHARS OF ENTERING STRING
.IF    .CCMC
       MOV  WB,DMPSB         SAVE WB
       MOV  SCLEN(XR),WB     LENGTH OF OLD STRING
       PLC  XR               POINT TO CHARS OF OLD STRING
       JSR  SYSCM            GENERALIZED LEXICAL COMPARE
       PPM  DMP06            STRING TOO LONG, TREAT LIKE EQ
       PPM  DMP06            ENTERING STRING LT OLD STRING
       PPM  DMP07            ENTERING STRING GT OLD STRING
DMP06  MOV  DMPSB,WB         RESTORE WB
       BRN  DMP08            FOUND INSERTION POINT
DMP07  MOV  DMPSB,WB         RESTORE WB
       MOV  DMPCH,XL         COPY CHAIN POINTER
.ELSE
       BHI  WA,SCLEN(XR),DMP06 JUMP IF ENTERING LENGTH HIGH
       PLC  XR               ELSE POINT TO CHARS OF OLD STRING
       CMC  DMP08,DMP07      COMPARE, INSERT IF NEW IS LLT OLD
       BRN  DMP08            OR IF LEQ (WE HAD SHORTER LENGTH)
DMP06  MOV  SCLEN(XR),WA     LOAD SHORTER LENGTH
       PLC  XR               POINT TO CHARS OF OLD STRING
       CMC  DMP08,DMP07      COMPARE, INSERT IF NEW ONE LOW
DMP07  MOV  DMPCH,XL         COPY CHAIN POINTER
.FI
       MOV  (XL),WA          MOVE TO NEXT ENTRY ON CHAIN
       BRN  DMP04            LOOP BACK
DMP08  MOV  DMPCH,XL         COPY CHAIN POINTER
       MOV  DMPSV,WA         RESTORE HASH BUCKET POINTER
       MOV  WC,XR            RESTORE VRBLK POINTER
       MOV  (XL),VRGET(XR)   LINK VRBLK TO REST OF CHAIN
       MOV  XR,(XL)          LINK VRBLK INTO CURRENT CHAIN LOC
       BRN  DMP01            LOOP BACK FOR NEXT VRBLK
DMP09  BNE  WA,HSHTE,DMP00   LOOP BACK IF MORE BUCKETS TO GO
DMP10  MOV  DMVCH,XR         LOAD POINTER TO NEXT ENTRY ON CHAIN
       BZE  XR,DMP11         JUMP IF END OF CHAIN
       MOV  (XR),DMVCH       ELSE UPDATE CHAIN PTR TO NEXT ENTRY
       JSR  SETVR            RESTORE VRGET FIELD
       MOV  XR,XL            COPY VRBLK POINTER (NAME BASE)
       MOV  *VRVAL,WA        SET OFFSET FOR VRBLK NAME
       JSR  PRTNV            PRINT NAME = VALUE
       BRN  DMP10            LOOP BACK TILL ALL PRINTED
DMP11  JSR  PRTNL            PRINT BLANK LINE
       JSR  PRTNL            AND ANOTHER
       MOV  =DMHDK,XR        POINT TO KEYWORD HEADING
       JSR  PRTST            PRINT HEADING
       JSR  PRTNL            END LINE
       JSR  PRTNL            PRINT ONE BLANK LINE
       MOV  =VDMKW,XL        POINT TO LIST OF KEYWORD SVBLK PTRS
DMP12  MOV  (XL)+,XR         LOAD NEXT SVBLK PTR FROM TABLE
       BZE  XR,DMP13         JUMP IF END OF LIST
.IF    .CCMK
       BEQ  XR,=NUM01,DMP12  &COMPARE IGNORED IF NOT IMPLEMENTED
.FI
       MOV  =CH_AM,WA        LOAD AMPERSAND
       JSR  PRTCH            PRINT AMPERSAND
       JSR  PRTST            PRINT KEYWORD NAME
       MOV  SVLEN(XR),WA     LOAD NAME LENGTH FROM SVBLK
       CTB  WA,SVCHS         GET LENGTH OF NAME
       ADD  WA,XR            POINT TO SVKNM FIELD
       MOV  (XR),DMPKN       STORE IN DUMMY KVBLK
       MOV  =TMBEB,XR        POINT TO BLANK-EQUAL-BLANK
       JSR  PRTST            PRINT IT
       MOV  XL,DMPSV         SAVE TABLE POINTER
       MOV  =DMPKB,XL        POINT TO DUMMY KVBLK
       MOV  =B_KVT,(XL)      BUILD TYPE WORD
       MOV  =TRBKV,KVVAR(XL) BUILD PTR TO DUMMY TRACE BLOCK
       MOV  *KVVAR,WA        SET ZERO OFFSET
       JSR  ACESS            GET KEYWORD VALUE
       PPM                   FAILURE IS IMPOSSIBLE
       JSR  PRTVL            PRINT KEYWORD VALUE
       JSR  PRTNL            TERMINATE PRINT LINE
       MOV  DMPSV,XL         RESTORE TABLE POINTER
       BRN  DMP12            LOOP BACK TILL ALL PRINTED
DMP13  BEQ  DMARG,=NUM01,DMP27 EXIT IF PARTIAL DUMP COMPLETE
       MOV  DNAMB,XR         ELSE POINT TO FIRST DYNAMIC BLOCK
DMP14  BEQ  XR,DNAMP,DMP27   JUMP IF END OF USED REGION
       MOV  (XR),WA          ELSE LOAD FIRST WORD OF BLOCK
       BEQ  WA,=B_VCT,DMP16  JUMP IF VECTOR
       BEQ  WA,=B_ART,DMP17  JUMP IF ARRAY
       BEQ  WA,=B_PDT,DMP18  JUMP IF PROGRAM DEFINED
       BEQ  WA,=B_TBT,DMP19  JUMP IF TABLE
.IF    .CNBF
.ELSE
       BEQ  WA,=B_BCT,DMP30  JUMP IF BUFFER
.FI
DMP15  JSR  BLKLN            GET LENGTH OF BLOCK
       ADD  WA,XR            POINT PAST THIS BLOCK
       BRN  DMP14            LOOP BACK FOR NEXT BLOCK
DMP16  MOV  *VCVLS,WB        SET OFFSET TO FIRST VALUE
       BRN  DMP19            JUMP TO MERGE
DMP17  MOV  AROFS(XR),WB     SET OFFSET TO ARPRO FIELD
       ICA  WB               BUMP TO GET OFFSET TO VALUES
       BRN  DMP19            JUMP TO MERGE
DMP18  MOV  *PDFLD,WB        POINT TO VALUES, MERGE
DMP19  BZE  IDVAL(XR),DMP15  IGNORE BLOCK IF ZERO ID VALUE
       JSR  BLKLN            ELSE GET BLOCK LENGTH
       MOV  XR,XL            COPY BLOCK POINTER
       MOV  WA,DMPSV         SAVE LENGTH
       MOV  WB,WA            COPY OFFSET TO FIRST VALUE
       JSR  PRTNL            PRINT BLANK LINE
       MOV  WA,DMPSA         PRESERVE OFFSET
       JSR  PRTVL            PRINT BLOCK VALUE (FOR TITLE)
       MOV  DMPSA,WA         RECOVER OFFSET
       JSR  PRTNL            END PRINT LINE
       BEQ  (XR),=B_TBT,DMP22 JUMP IF TABLE
       DCA  WA               POINT BEFORE FIRST WORD
DMP20  MOV  XL,XR            COPY BLOCK POINTER
       ICA  WA               BUMP OFFSET
       ADD  WA,XR            POINT TO NEXT VALUE
       BEQ  WA,DMPSV,DMP14   EXIT IF END (XR PAST BLOCK)
       SUB  *VRVAL,XR        SUBTRACT OFFSET TO MERGE INTO LOOP
DMP21  MOV  VRVAL(XR),XR     LOAD NEXT VALUE
       BEQ  DMARG,=NUM03,DMP2B SKIP NULL VALUE CHECK IF DUMP(3)
       BEQ  XR,=NULLS,DMP20  LOOP BACK IF NULL VALUE
DMP2B  BEQ  (XR),=B_TRT,DMP21 LOOP BACK IF TRAPPED
       JSR  PRTNV            ELSE PRINT NAME = VALUE
       BRN  DMP20            LOOP BACK FOR NEXT FIELD
DMP22  MOV  *TBBUK,WC        SET OFFSET TO FIRST BUCKET
       MOV  *TEVAL,WA        SET NAME OFFSET FOR ALL TEBLKS
DMP23  MOV  XL,-(XS)         SAVE TBBLK POINTER
       ADD  WC,XL            POINT TO NEXT BUCKET HEADER
       ICA  WC               BUMP BUCKET OFFSET
       SUB  *TENXT,XL        SUBTRACT OFFSET TO MERGE INTO LOOP
DMP24  MOV  TENXT(XL),XL     POINT TO NEXT TEBLK
       BEQ  XL,(XS),DMP26    JUMP IF END OF CHAIN
       MOV  XL,XR            ELSE COPY TEBLK POINTER
DMP25  MOV  TEVAL(XR),XR     LOAD NEXT VALUE
       BEQ  XR,=NULLS,DMP24  IGNORE IF NULL VALUE
       BEQ  (XR),=B_TRT,DMP25 LOOP BACK IF TRAPPED
       MOV  WC,DMPSV         ELSE SAVE OFFSET POINTER
       JSR  PRTNV            PRINT NAME = VALUE
       MOV  DMPSV,WC         RELOAD OFFSET
       BRN  DMP24            LOOP BACK FOR NEXT TEBLK
DMP26  MOV  (XS)+,XL         RESTORE TBBLK POINTER
       BNE  WC,TBLEN(XL),DMP23 LOOP BACK IF MORE BUCKETS TO GO
       MOV  XL,XR            ELSE COPY TABLE POINTER
       ADD  WC,XR            POINT TO FOLLOWING BLOCK
       BRN  DMP14            LOOP BACK TO PROCESS NEXT BLOCK
DMP27  JSR  PRTPG            EJECT PRINTER
DMP28  EXI                   RETURN TO DUMP CALLER
DMP29  JSR  SYSDM            CALL IT
       BRN  DMP28            RETURN
.IF    .CNBF
.ELSE
DMP30  JSR  PRTNL            PRINT BLANK LINE
       JSR  PRTVL            PRINT VALUE ID FOR TITLE
       JSR  PRTNL            FORCE NEW LINE
       MOV  =CH_DQ,WA        LOAD DOUBLE QUOTE
       JSR  PRTCH            PRINT IT
       MOV  BCLEN(XR),WC     LOAD DEFINED LENGTH
       BZE  WC,DMP32         SKIP CHARACTERS IF NONE
       LCT  WC,WC            LOAD COUNT FOR LOOP
       MOV  XR,WB            SAVE BCBLK PTR
       MOV  BCBUF(XR),XR     POINT TO BFBLK
       PLC  XR               GET SET TO LOAD CHARACTERS
DMP31  LCH  WA,(XR)+         GET NEXT CHARACTER
       JSR  PRTCH            STUFF IT
       BCT  WC,DMP31         BRANCH FOR NEXT ONE
       MOV  WB,XR            RESTORE BCBLK POINTER
DMP32  MOV  =CH_DQ,WA        STUFF QUOTE
       JSR  PRTCH            PRINT IT
       JSR  PRTNL            PRINT NEW LINE
       MOV  (XR),WA          GET FIRST WD FOR BLKLN
       BRN  DMP15            MERGE TO GET NEXT BLOCK
.FI
       ENP                   END PROCEDURE DUMPR
ERMSG  PRC  E,0              ENTRY POINT
       MOV  KVERT,WA         LOAD ERROR CODE
       MOV  =ERMMS,XR        POINT TO ERROR MESSAGE /ERROR/
       JSR  PRTST            PRINT IT
       JSR  ERTEX            GET ERROR MESSAGE TEXT
       ADD  =THSND,WA        BUMP ERROR CODE FOR PRINT
       MTI  WA               FAIL CODE IN INT ACC
       MOV  PROFS,WB         SAVE CURRENT BUFFER POSITION
       JSR  PRTIN            PRINT CODE (NOW HAVE ERROR1XXX)
       MOV  PRBUF,XL         POINT TO PRINT BUFFER
       PSC  XL,WB            POINT TO THE 1
       MOV  =CH_BL,WA        LOAD A BLANK
       SCH  WA,(XL)          STORE BLANK OVER 1 (ERROR XXX)
       CSC  XL               COMPLETE STORE CHARACTERS
       ZER  XL               CLEAR GARBAGE POINTER IN XL
       MOV  XR,WA            KEEP ERROR TEXT
       MOV  =ERMNS,XR        POINT TO / -- /
       JSR  PRTST            PRINT IT
       MOV  WA,XR            GET ERROR TEXT AGAIN
       JSR  PRTST            PRINT ERROR MESSAGE TEXT
       JSR  PRTIS            PRINT LINE
       JSR  PRTIS            PRINT BLANK LINE
       EXI                   RETURN TO ERMSG CALLER
       ENP                   END PROCEDURE ERMSG
ERTEX  PRC  E,0              ENTRY POINT
       MOV  WA,ERTWA         SAVE WA
       MOV  WB,ERTWB         SAVE WB
       JSR  SYSEM            GET FAILURE MESSAGE TEXT
       MOV  XR,XL            COPY POINTER TO IT
       MOV  SCLEN(XR),WA     GET LENGTH OF STRING
       BZE  WA,ERT02         JUMP IF NULL
       ZER  WB               OFFSET OF ZERO
       JSR  SBSTR            COPY INTO DYNAMIC STORE
       MOV  XR,R_ETX         STORE FOR RELOCATION
ERT01  MOV  ERTWB,WB         RESTORE WB
       MOV  ERTWA,WA         RESTORE WA
       EXI                   RETURN TO CALLER
ERT02  MOV  R_ETX,XR         GET ERRTEXT
       BRN  ERT01            RETURN
       ENP
EVALI  PRC  R,4              ENTRY POINT (RECURSIVE)
       JSR  EVALP            EVALUATE EXPRESSION
       PPM  EVLI1            JUMP ON FAILURE
       MOV  XL,-(XS)         STACK RESULT FOR GTSMI
       MOV  PTHEN(XR),XL     LOAD SUCCESSOR POINTER
       MOV  XR,EVLIO         SAVE ORIGINAL NODE POINTER
       MOV  WC,EVLIF         ZERO IF SIMPLE ARGUMENT
       JSR  GTSMI            CONVERT ARG TO SMALL INTEGER
       PPM  EVLI2            JUMP IF NOT INTEGER
       PPM  EVLI3            JUMP IF OUT OF RANGE
       MOV  XR,EVLIV         STORE RESULT IN SPECIAL DUMMY NODE
       MOV  =EVLIN,XR        POINT TO DUMMY NODE WITH RESULT
       MOV  =P_LEN,(XR)      DUMMY PATTERN BLOCK PCODE
       MOV  XL,PTHEN(XR)     STORE SUCCESSOR POINTER
       EXI  4                TAKE SUCCESSFUL EXIT
EVLI1  EXI  3                TAKE FAILURE RETURN
EVLI2  EXI  1                TAKE NON-INTEGER ERROR EXIT
EVLI3  EXI  2                TAKE OUT-OF-RANGE ERROR EXIT
       ENP                   END PROCEDURE EVALI
EVALP  PRC  R,1              ENTRY POINT (RECURSIVE)
       MOV  PARM1(XR),XL     LOAD EXPRESSION POINTER
       BEQ  (XL),=B_EXL,EVLP1 JUMP IF EXBLK CASE
       MOV  SEVAR(XL),XL     LOAD VRBLK POINTER
       MOV  VRVAL(XL),XL     LOAD VALUE OF VRBLK
       MOV  (XL),WA          LOAD FIRST WORD OF VALUE
       BHI  WA,=B_T__,EVLP3  JUMP IF NOT SEBLK, TRBLK OR EXBLK
EVLP1  CHK                   CHECK FOR STACK SPACE
       MOV  XR,-(XS)         STACK NODE POINTER
       MOV  WB,-(XS)         STACK CURSOR
       MOV  R_PMS,-(XS)      STACK SUBJECT STRING POINTER
       MOV  PMSSL,-(XS)      STACK SUBJECT STRING LENGTH
       MOV  PMDFL,-(XS)      STACK DOT FLAG
       MOV  PMHBS,-(XS)      STACK HISTORY STACK BASE POINTER
       MOV  PARM1(XR),XR     LOAD EXPRESSION POINTER
EVLP2  ZER  WB               SET FLAG FOR BY VALUE
       JSR  EVALX            EVALUATE EXPRESSION
       PPM  EVLP4            JUMP ON FAILURE
       MOV  (XR),WA          ELSE LOAD FIRST WORD OF VALUE
       BLO  WA,=B_E__,EVLP2  LOOP BACK TO REEVALUATE EXPRESSION
       MOV  XR,XL            COPY RESULT POINTER
       MOV  (XS)+,PMHBS      RESTORE HISTORY STACK BASE POINTER
       MOV  (XS)+,PMDFL      RESTORE DOT FLAG
       MOV  (XS)+,PMSSL      RESTORE SUBJECT STRING LENGTH
       MOV  (XS)+,R_PMS      RESTORE SUBJECT STRING POINTER
       MOV  (XS)+,WB         RESTORE CURSOR
       MOV  (XS)+,XR         RESTORE NODE POINTER
       MOV  XR,WC            NON-ZERO FOR SIMPLE VRBLK
       EXI                   RETURN TO EVALP CALLER
EVLP3  ZER  WC               SIMPLE VRBLK, NO SIDE EFFECTS
       EXI                   RETURN TO EVALP CALLER
EVLP4  MOV  (XS)+,PMHBS      RESTORE HISTORY STACK BASE POINTER
       MOV  (XS)+,PMDFL      RESTORE DOT FLAG
       MOV  (XS)+,PMSSL      RESTORE SUBJECT STRING LENGTH
       MOV  (XS)+,R_PMS      RESTORE SUBJECT STRING POINTER
       ADD  *NUM02,XS        REMOVE NODE PTR, CURSOR
       EXI  1                TAKE FAILURE EXIT
       ENP                   END PROCEDURE EVALP
EVALS  PRC  R,3              ENTRY POINT (RECURSIVE)
       JSR  EVALP            EVALUATE EXPRESSION
       PPM  EVLS1            JUMP IF EVALUATION FAILS
       MOV  PTHEN(XR),-(XS)  SAVE SUCCESSOR POINTER
       MOV  WB,-(XS)         SAVE CURSOR
       MOV  XL,-(XS)         STACK RESULT PTR FOR PATST
       ZER  WB               DUMMY PCODE FOR ONE CHAR STRING
       ZER  WC               DUMMY PCODE FOR EXPRESSION ARG
       MOV  =P_BRK,XL        APPROPRIATE PCODE FOR OUR USE
       JSR  PATST            CALL ROUTINE TO BUILD NODE
       PPM  EVLS2            JUMP IF NOT STRING
       MOV  (XS)+,WB         RESTORE CURSOR
       MOV  (XS)+,PTHEN(XR)  STORE SUCCESSOR POINTER
       EXI  3                TAKE SUCCESS RETURN
EVLS1  EXI  2                TAKE FAILURE RETURN
EVLS2  ADD  *NUM02,XS        POP SUCCESSOR AND CURSOR
       EXI  1                TAKE NON-STRING ERROR EXIT
       ENP                   END PROCEDURE EVALS
EVALX  PRC  R,1              ENTRY POINT, RECURSIVE
       BEQ  (XR),=B_EXL,EVLX2 JUMP IF EXBLK CASE
       MOV  SEVAR(XR),XL     LOAD VRBLK POINTER (NAME BASE)
       MOV  *VRVAL,WA        SET NAME OFFSET
       BNZ  WB,EVLX1         JUMP IF CALLED BY NAME
       JSR  ACESS            CALL ROUTINE TO ACCESS VALUE
       PPM  EVLX9            JUMP IF FAILURE ON ACCESS
EVLX1  EXI                   RETURN TO EVALX CALLER
EVLX2  SCP  WC               GET CODE POINTER
       MOV  R_COD,WA         LOAD CODE BLOCK POINTER
       SUB  WA,WC            GET CODE POINTER AS OFFSET
       MOV  WA,-(XS)         STACK OLD CODE BLOCK POINTER
       MOV  WC,-(XS)         STACK RELATIVE CODE OFFSET
       MOV  FLPTR,-(XS)      STACK OLD FAILURE POINTER
       MOV  WB,-(XS)         STACK NAME/VALUE INDICATOR
       MOV  *EXFLC,-(XS)     STACK NEW FAIL OFFSET
       MOV  FLPTR,GTCEF      KEEP IN CASE OF ERROR
       MOV  R_COD,R_GTC      KEEP CODE BLOCK POINTER SIMILARLY
       MOV  XS,FLPTR         SET NEW FAILURE POINTER
       MOV  XR,R_COD         SET NEW CODE BLOCK POINTER
       MOV  KVSTN,EXSTM(XR)  REMEMBER STMNT NUMBER
       ADD  *EXCOD,XR        POINT TO FIRST CODE WORD
       LCP  XR               SET CODE POINTER
       BNE  STAGE,=STGXT,EVLX0 JUMP IF NOT EXECUTION TIME
       MOV  =STGEE,STAGE     EVALUATING EXPRESSION
EVLX0  ZER  XL               CLEAR GARBAGE XL
       LCW  XR               LOAD FIRST CODE WORD
       BRI  (XR)             EXECUTE IT
EVLX3  MOV  (XS)+,XR         LOAD VALUE
       BZE  NUM01(XS),EVLX5  JUMP IF CALLED BY VALUE
       ERB  249,Expression evaluated by name returned value
EVLX4  MOV  (XS)+,WA         LOAD NAME OFFSET
       MOV  (XS)+,XL         LOAD NAME BASE
       BNZ  NUM01(XS),EVLX5  JUMP IF CALLED BY NAME
       JSR  ACESS            ELSE ACCESS VALUE FIRST
       PPM  EVLX6            JUMP IF FAILURE DURING ACCESS
EVLX5  ZER  WB               NOTE SUCCESSFUL
       BRN  EVLX7            MERGE
EVLX6  MNZ  WB               NOTE UNSUCCESSFUL
EVLX7  BNE  STAGE,=STGEE,EVLX8 SKIP IF WAS NOT PREVIOUSLY XT
       MOV  =STGXT,STAGE     EXECUTE TIME
EVLX8  ADD  *NUM02,XS        POP NAME/VALUE INDICATOR, *EXFAL
       MOV  (XS)+,FLPTR      RESTORE OLD FAILURE POINTER
       MOV  (XS)+,WC         LOAD CODE OFFSET
       ADD  (XS),WC          MAKE CODE POINTER ABSOLUTE
       MOV  (XS)+,R_COD      RESTORE OLD CODE BLOCK POINTER
       LCP  WC               RESTORE OLD CODE POINTER
       BZE  WB,EVLX1         JUMP FOR SUCCESSFUL RETURN
EVLX9  EXI  1                TAKE FAILURE EXIT
       ENP                   END OF PROCEDURE EVALX
EXBLD  PRC  E,0              ENTRY POINT
       MOV  XL,WA            COPY OFFSET TO START OF CODE
       SUB  *EXCOD,WA        CALC REDUCTION IN OFFSET IN EXBLK
       MOV  WA,-(XS)         STACK FOR LATER
       MOV  CWCOF,WA         LOAD FINAL OFFSET
       SUB  XL,WA            COMPUTE LENGTH OF CODE
       ADD  *EXSI_,WA        ADD SPACE FOR STANDARD FIELDS
       JSR  ALLOC            ALLOCATE SPACE FOR EXBLK
       MOV  XR,-(XS)         SAVE POINTER TO EXBLK
       MOV  =B_EXL,EXTYP(XR) STORE TYPE WORD
       ZER  EXSTM(XR)        ZEROISE STMNT NUMBER FIELD
.IF    .CSLN
       MOV  CMPLN,EXSLN(XR)  SET LINE NUMBER FIELD
.FI
       MOV  WA,EXLEN(XR)     STORE LENGTH
       MOV  =OFEX_,EXFLC(XR) STORE FAILURE WORD
       ADD  *EXSI_,XR        SET XR FOR MVW
       MOV  XL,CWCOF         RESET OFFSET TO START OF CODE
       ADD  R_CCB,XL         POINT TO START OF CODE
       SUB  *EXSI_,WA        LENGTH OF CODE TO MOVE
       MOV  WA,-(XS)         STACK LENGTH OF CODE
       MVW                   MOVE CODE TO EXBLK
       MOV  (XS)+,WA         GET LENGTH OF CODE
       BTW  WA               CONVERT BYTE COUNT TO WORD COUNT
       LCT  WA,WA            PREPARE COUNTER FOR LOOP
       MOV  (XS),XL          COPY EXBLK PTR, DONT UNSTACK
       ADD  *EXCOD,XL        POINT TO CODE ITSELF
       MOV  NUM01(XS),WB     GET REDUCTION IN OFFSET
EXBL1  MOV  (XL)+,XR         GET NEXT CODE WORD
       BEQ  XR,=OSLA_,EXBL3  JUMP IF SELECTION FOUND
       BEQ  XR,=ONTA_,EXBL3  JUMP IF NEGATION FOUND
       BCT  WA,EXBL1         LOOP TO END OF CODE
EXBL2  MOV  (XS)+,XR         POP EXBLK PTR INTO XR
       MOV  (XS)+,XL         POP REDUCTION CONSTANT
       EXI                   RETURN TO CALLER
EXBL3  SUB  WB,(XL)+         ADJUST OFFSET
       BCT  WA,EXBL4         DECREMENT COUNT
EXBL4  BCT  WA,EXBL5         DECREMENT COUNT
EXBL5  MOV  (XL)+,XR         GET NEXT CODE WORD
       BEQ  XR,=OSLA_,EXBL3  JUMP IF OFFSET FOUND
       BEQ  XR,=OSLB_,EXBL3  JUMP IF OFFSET FOUND
       BEQ  XR,=OSLC_,EXBL3  JUMP IF OFFSET FOUND
       BEQ  XR,=ONTA_,EXBL3  JUMP IF OFFSET FOUND
       BCT  WA,EXBL5         LOOP
       BRN  EXBL2            MERGE TO RETURN
       ENP                   END PROCEDURE EXBLD
EXPAN  PRC  E,0              ENTRY POINT
       ZER  -(XS)            SET TOP OF STACK INDICATOR
       ZER  WA               SET INITIAL STATE TO ZERO
       ZER  WC               ZERO COUNTER VALUE
EXP01  JSR  SCANE            SCAN NEXT ELEMENT
       ADD  WA,XL            ADD STATE TO SYNTAX CODE
       BSW  XL,T_NES         SWITCH ON ELEMENT TYPE/STATE
       IFF  T_VA0,EXP03      VARIABLE, S=0
       IFF  T_VA1,EXP03      VARIABLE, STATE ONE
       IFF  T_VA2,EXP04      VARIABLE, S=2
       IFF  T_CO0,EXP03      CONSTANT, S=0
       IFF  T_CO1,EXP03      CONSTANT, S=1
       IFF  T_CO2,EXP04      CONSTANT, S=2
       IFF  T_LP0,EXP06      LEFT PAREN, S=0
       IFF  T_LP1,EXP06      LEFT PAREN, S=1
       IFF  T_LP2,EXP04      LEFT PAREN, S=2
       IFF  T_FN0,EXP10      FUNCTION, S=0
       IFF  T_FN1,EXP10      FUNCTION, S=1
       IFF  T_FN2,EXP04      FUNCTION, S=2
       IFF  T_RP0,EXP02      RIGHT PAREN, S=0
       IFF  T_RP1,EXP05      RIGHT PAREN, S=1
       IFF  T_RP2,EXP12      RIGHT PAREN, S=2
       IFF  T_LB0,EXP08      LEFT BRKT, S=0
       IFF  T_LB1,EXP08      LEFT BRKT, S=1
       IFF  T_LB2,EXP09      LEFT BRKT, S=2
       IFF  T_RB0,EXP02      RIGHT BRKT, S=0
       IFF  T_RB1,EXP05      RIGHT BRKT, S=1
       IFF  T_RB2,EXP18      RIGHT BRKT, S=2
       IFF  T_UO0,EXP27      UNOP, S=0
       IFF  T_UO1,EXP27      UNOP, S=1
       IFF  T_UO2,EXP04      UNOP, S=2
       IFF  T_BO0,EXP05      BINOP, S=0
       IFF  T_BO1,EXP05      BINOP, S=1
       IFF  T_BO2,EXP26      BINOP, S=2
       IFF  T_CM0,EXP02      COMMA, S=0
       IFF  T_CM1,EXP05      COMMA, S=1
       IFF  T_CM2,EXP11      COMMA, S=2
       IFF  T_CL0,EXP02      COLON, S=0
       IFF  T_CL1,EXP05      COLON, S=1
       IFF  T_CL2,EXP19      COLON, S=2
       IFF  T_SM0,EXP02      SEMICOLON, S=0
       IFF  T_SM1,EXP05      SEMICOLON, S=1
       IFF  T_SM2,EXP19      SEMICOLON, S=2
       ESW                   END SWITCH ON ELEMENT TYPE/STATE
EXP02  MNZ  SCNRS            SET TO RESCAN ELEMENT
       MOV  =NULLS,XR        POINT TO NULL, MERGE
EXP03  MOV  XR,-(XS)         STACK POINTER TO OPERAND
       MOV  =NUM02,WA        SET STATE 2
       BRN  EXP01            JUMP FOR NEXT ELEMENT
EXP04  MNZ  SCNRS            SET TO RESCAN ELEMENT
       MOV  =OPDVC,XR        POINT TO CONCAT OPERATOR DV
       BZE  WB,EXP4A         OK IF AT TOP LEVEL
       MOV  =OPDVP,XR        ELSE POINT TO UNMISTAKABLE CONCAT.
EXP4A  BNZ  SCNBL,EXP26      MERGE BOP IF BLANKS, ELSE ERROR
       ERB  220,Syntax error: Missing operator

EXP05  ERB  221,Syntax error: Missing operand
EXP06  MOV  =NUM04,XL        SET NEW LEVEL INDICATOR
       ZER  XR               SET ZERO VALUE FOR CMOPN
EXP07  MOV  XR,-(XS)         STACK CMOPN VALUE
       MOV  WC,-(XS)         STACK OLD COUNTER
       MOV  WB,-(XS)         STACK OLD LEVEL INDICATOR
       CHK                   CHECK FOR STACK OVERFLOW
       ZER  WA               SET NEW STATE TO ZERO
       MOV  XL,WB            SET NEW LEVEL INDICATOR
       MOV  =NUM01,WC        INITIALIZE NEW COUNTER
       BRN  EXP01            JUMP TO SCAN NEXT ELEMENT
EXP08  ERB  222,Syntax error: Invalid use of left bracket
EXP09  MOV  (XS)+,XR         LOAD ARRAY PTR FOR CMOPN
       MOV  =NUM03,XL        SET NEW LEVEL INDICATOR
       BRN  EXP07            JUMP TO STACK OLD AND START NEW
EXP10  MOV  =NUM05,XL        SET NEW LEV INDIC (XR=VRBLK=CMOPN)
       BRN  EXP07            JUMP TO STACK OLD AND START NEW
EXP11  ICV  WC               INCREMENT COUNTER
       JSR  EXPDM            DUMP OPERATORS AT THIS LEVEL
       ZER  -(XS)            SET NEW LEVEL FOR PARAMETER
       ZER  WA               SET NEW STATE
       BGT  WB,=NUM02,EXP01  LOOP BACK UNLESS OUTER LEVEL
       ERB  223,Syntax error: Invalid use of comma
EXP12  BEQ  WB,=NUM01,EXP20  END OF NORMAL GOTO
       BEQ  WB,=NUM05,EXP13  END OF FUNCTION ARGUMENTS
       BEQ  WB,=NUM04,EXP14  END OF GROUPING / SELECTION
       ERB  224,Syntax error: Unbalanced right parenthesis
EXP13  MOV  =C_FNC,XL        SET CMTYP VALUE FOR FUNCTION
       BRN  EXP15            JUMP TO BUILD CMBLK
EXP14  BEQ  WC,=NUM01,EXP17  JUMP IF END OF GROUPING
       MOV  =C_SEL,XL        ELSE SET CMTYP FOR SELECTION
EXP15  JSR  EXPDM            DUMP OPERATORS AT THIS LEVEL
       MOV  WC,WA            COPY COUNT
       ADD  =CMVLS,WA        ADD FOR STANDARD FIELDS AT START
       WTB  WA               CONVERT LENGTH TO BYTES
       JSR  ALLOC            ALLOCATE SPACE FOR CMBLK
       MOV  =B_CMT,(XR)      STORE TYPE CODE FOR CMBLK
       MOV  XL,CMTYP(XR)     STORE CMBLK NODE TYPE INDICATOR
       MOV  WA,CMLEN(XR)     STORE LENGTH
       ADD  WA,XR            POINT PAST END OF BLOCK
       LCT  WC,WC            SET LOOP COUNTER
EXP16  MOV  (XS)+,-(XR)      MOVE ONE OPERAND PTR FROM STACK
       MOV  (XS)+,WB         POP TO OLD LEVEL INDICATOR
       BCT  WC,EXP16         LOOP TILL ALL MOVED
       SUB  *CMVLS,XR        POINT BACK TO START OF BLOCK
       MOV  (XS)+,WC         RESTORE OLD COUNTER
       MOV  (XS),CMOPN(XR)   STORE OPERAND PTR IN CMBLK
       MOV  XR,(XS)          STACK CMBLK POINTER
       MOV  =NUM02,WA        SET NEW STATE
       BRN  EXP01            BACK FOR NEXT ELEMENT
EXP17  JSR  EXPDM            DUMP OPERATORS AT THIS LEVEL
       MOV  (XS)+,XR         RESTORE XR
       MOV  (XS)+,WB         RESTORE OUTER LEVEL
       MOV  (XS)+,WC         RESTORE OUTER COUNT
       MOV  XR,(XS)          STORE OPND OVER UNUSED CMOPN VAL
       MOV  =NUM02,WA        SET NEW STATE
       BRN  EXP01            BACK FOR NEXT ELE8ENT
EXP18  MOV  =C_ARR,XL        SET CMTYP FOR ARRAY REFERENCE
       BEQ  WB,=NUM03,EXP15  JUMP TO BUILD CMBLK IF END ARRAYREF
       BEQ  WB,=NUM02,EXP20  JUMP IF END OF DIRECT GOTO
       ERB  225,Syntax error: Unbalanced right bracket
EXP19  MNZ  SCNRS            RESCAN TERMINATOR
       MOV  WB,XL            COPY LEVEL INDICATOR
       BSW  XL,6             SWITCH ON LEVEL INDICATOR
       IFF  0,EXP20          NORMAL OUTER LEVEL
       IFF  1,EXP22          FAIL IF NORMAL GOTO
       IFF  2,EXP23          FAIL IF DIRECT GOTO
       IFF  3,EXP24          FAIL ARRAY BRACKETS
       IFF  4,EXP21          FAIL IF IN GROUPING
       IFF  5,EXP21          FAIL FUNCTION ARGS
       ESW                   END SWITCH ON LEVEL
EXP20  JSR  EXPDM            DUMP REMAINING OPERATORS
       MOV  (XS)+,XR         LOAD TREE POINTER
       ICA  XS               POP OFF BOTTOM OF STACK MARKER
       EXI                   RETURN TO EXPAN CALLER
EXP21  ERB  226,Syntax error: Missing right paren
EXP22  ERB  227,Syntax error: Right paren missing from goto
EXP23  ERB  228,Syntax error: Right bracket missing from goto
EXP24  ERB  229,Syntax error: Missing right array bracket
EXP25  MOV  XR,EXPSV
       JSR  EXPOP            POP ONE OPERATOR
       MOV  EXPSV,XR         RESTORE OP DV POINTER AND MERGE
EXP26  MOV  NUM01(XS),XL     LOAD OPERATOR DVPTR FROM STACK
       BLE  XL,=NUM05,EXP27  JUMP IF BOTTOM OF STACK LEVEL
       BLT  DVRPR(XR),DVLPR(XL),EXP25 ELSE POP IF NEW PREC IS LO
EXP27  MOV  XR,-(XS)         STACK OPERATOR DVPTR ON STACK
       CHK                   CHECK FOR STACK OVERFLOW
       MOV  =NUM01,WA        SET NEW STATE
       BNE  XR,=OPDVS,EXP01  BACK FOR NEXT ELEMENT UNLESS =
       ZER  WA               SET STATE ZERO
       BRN  EXP01            JUMP FOR NEXT ELEMENT
       ENP                   END PROCEDURE EXPAN
EXPAP  PRC  E,1              ENTRY POINT
       MOV  XL,-(XS)         SAVE XL
       BNE  (XR),=B_CMT,EXPP2 NO MATCH IF NOT COMPLEX
       MOV  CMTYP(XR),WA     ELSE LOAD TYPE CODE
       BEQ  WA,=C_CNC,EXPP1  CONCATENATION IS A MATCH
       BEQ  WA,=C_PMT,EXPP1  BINARY QUESTION MARK IS A MATCH
       BNE  WA,=C_ALT,EXPP2  ELSE NOT MATCH UNLESS ALTERNATION
       MOV  CMLOP(XR),XL     LOAD LEFT OPERAND POINTER
       BNE  (XL),=B_CMT,EXPP2 NOT MATCH IF LEFT OPND NOT COMPLEX
       BNE  CMTYP(XL),=C_CNC,EXPP2 NOT MATCH IF LEFT OP NOT CONC
       MOV  CMROP(XL),CMLOP(XR) XR POINTS TO (B / C)
       MOV  XR,CMROP(XL)     SET XL OPNDS TO A, (B / C)
       MOV  XL,XR            POINT TO THIS ALTERED NODE
EXPP1  MOV  (XS)+,XL         RESTORE ENTRY XL
       EXI                   GIVE PATTERN MATCH RETURN
EXPP2  MOV  (XS)+,XL         RESTORE ENTRY XL
       EXI  1                GIVE NON-MATCH RETURN
       ENP                   END PROCEDURE EXPAP
EXPDM  PRC  N,0              ENTRY POINT
       MOV  XL,R_EXS         SAVE XL VALUE
EXDM1  BLE  NUM01(XS),=NUM05,EXDM2 JUMP IF STACK BOTTOM (SAVED LEVEL
       JSR  EXPOP            ELSE POP ONE OPERATOR
       BRN  EXDM1            AND LOOP BACK
EXDM2  MOV  R_EXS,XL         RESTORE XL
       ZER  R_EXS            RELEASE SAVE LOCATION
       EXI                   RETURN TO EXPDM CALLER
       ENP                   END PROCEDURE EXPDM
EXPOP  PRC  N,0              ENTRY POINT
       MOV  NUM01(XS),XR     LOAD OPERATOR DV POINTER
       BEQ  DVLPR(XR),=LLUNO,EXPO2 JUMP IF UNARY
       MOV  *CMBS_,WA        SET SIZE OF BINARY OPERATOR CMBLK
       JSR  ALLOC            ALLOCATE SPACE FOR CMBLK
       MOV  (XS)+,CMROP(XR)  POP AND STORE RIGHT OPERAND PTR
       MOV  (XS)+,XL         POP AND LOAD OPERATOR DV PTR
       MOV  (XS),CMLOP(XR)   STORE LEFT OPERAND POINTER
EXPO1  MOV  =B_CMT,(XR)      STORE TYPE CODE FOR CMBLK
       MOV  DVTYP(XL),CMTYP(XR) STORE CMBLK NODE TYPE CODE
       MOV  XL,CMOPN(XR)     STORE DVPTR (=PTR TO DAC O_XXX)
       MOV  WA,CMLEN(XR)     STORE CMBLK LENGTH
       MOV  XR,(XS)          STORE RESULTING NODE PTR ON STACK
       EXI                   RETURN TO EXPOP CALLER
EXPO2  MOV  *CMUS_,WA        SET SIZE OF UNARY OPERATOR CMBLK
       JSR  ALLOC            ALLOCATE SPACE FOR CMBLK
       MOV  (XS)+,CMROP(XR)  POP AND STORE OPERAND POINTER
       MOV  (XS),XL          LOAD OPERATOR DV POINTER
       BRN  EXPO1            MERGE BACK TO EXIT
       ENP                   END PROCEDURE EXPOP
.IF    .CSFN
FILNM  PRC  E,0              ENTRY POINT
       MOV  WB,-(XS)         PRESERVE WB
       BZE  WC,FILN3         RETURN NULLS IF STNO IS ZERO
       MOV  R_SFN,XL         FILE NAME TABLE
       BZE  XL,FILN3         IF NO TABLE
       MOV  TBBUK(XL),WB     GET BUCKET ENTRY
       BEQ  WB,R_SFN,FILN3   JUMP IF NO TEBLKS ON CHAIN
       MOV  XR,-(XS)         PRESERVE XR
       MOV  WB,XR            PREVIOUS BLOCK POINTER
       MOV  WC,-(XS)         PRESERVE STMT NUMBER
FILN1  MOV  XR,XL            NEXT ELEMENT TO EXAMINE
       MOV  TESUB(XL),XR     LOAD SUBSCRIPT VALUE (AN ICBLK)
       LDI  ICVAL(XR)        LOAD THE STATEMENT NUMBER
       MFI  WC               CONVERT TO ADDRESS CONSTANT
       BLT  (XS),WC,FILN2    COMPARE ARG WITH TEBLK STMT NUMBER
       MOV  XL,WB            SAVE PREVIOUS ENTRY POINTER
       MOV  TENXT(XL),XR     POINT TO NEXT TEBLK ON CHAIN
       BNE  XR,R_SFN,FILN1   JUMP IF THERE IS ONE
FILN2  MOV  WB,XL            PREVIOUS TEBLK
       MOV  TEVAL(XL),XL     GET PTR TO FILE NAME SCBLK
       MOV  (XS)+,WC         RESTORE STMT NUMBER
       MOV  (XS)+,XR         RESTORE XR
       MOV  (XS)+,WB         RESTORE WB
       EXI
FILN3  MOV  (XS)+,WB         RESTORE WB
       MOV  =NULLS,XL        RETURN NULL STRING
       EXI
       ENP
.FI
.IF    .CULC
FLSTG  PRC  E,0              ENTRY POINT
       BZE  KVCAS,FST99      SKIP IF &CASE IS 0
       MOV  XL,-(XS)         SAVE XL ACROSS CALL
       MOV  XR,-(XS)         SAVE ORIGINAL SCBLK PTR
       JSR  ALOCS            ALLOCATE NEW STRING BLOCK
       MOV  (XS),XL          POINT TO ORIGINAL SCBLK
       MOV  XR,-(XS)         SAVE POINTER TO NEW SCBLK
       PLC  XL               POINT TO ORIGINAL CHARS
       PSC  XR               POINT TO NEW CHARS
       ZER  -(XS)            INIT DID FOLD FLAG
       LCT  WC,WC            LOAD LOOP COUNTER
FST01  LCH  WA,(XL)+         LOAD CHARACTER
       BLT  WA,=CH__A,FST02  SKIP IF LESS THAN LC A
       BGT  WA,=CH___,FST02  SKIP IF GREATER THAN LC Z
       FLC  WA               FOLD CHARACTER TO UPPER CASE
       MNZ  (XS)             SET DID FOLD CHARACTER FLAG
FST02  SCH  WA,(XR)+         STORE (POSSIBLY FOLDED) CHARACTER
       BCT  WC,FST01         LOOP THRU ENTIRE STRING
       CSC  XR               COMPLETE STORE CHARACTERS
       MOV  (XS)+,XR         SEE IF ANY CHANGE
       BNZ  XR,FST10         SKIP IF FOLDING DONE (NO CHANGE)
       MOV  (XS)+,DNAMP      DO NOT NEED NEW SCBLK
       MOV  (XS)+,XR         RETURN ORIGINAL SCBLK
       BRN  FST20            MERGE BELOW
FST10  MOV  (XS)+,XR         RETURN NEW SCBLK
       ICA  XS               THROW AWAY ORIGINAL SCBLK POINTER
FST20  MOV  SCLEN(XR),WA     RELOAD STRING LENGTH
       MOV  (XS)+,XL         RESTORE XL
FST99  EXI                   RETURN
       ENP
.FI
.IF    .CSED
.ELSE
.FI
.IF    .CSED
.IF    .CEPP
.ELSE
.FI
.FI
GBCOL  PRC  E,0              ENTRY POINT
       BNZ  DMVCH,GBC14      FAIL IF IN MID-DUMP
       MNZ  GBCFL            NOTE GBCOL ENTERED
       MOV  WA,GBSVA         SAVE ENTRY WA
       MOV  WB,GBSVB         SAVE ENTRY WB
       MOV  WC,GBSVC         SAVE ENTRY WC
       MOV  XL,-(XS)         SAVE ENTRY XL
       SCP  WA               GET CODE POINTER VALUE
       SUB  R_COD,WA         MAKE RELATIVE
       LCP  WA               AND RESTORE
.IF    .CSED
       BZE  WB,GBC0A         CHECK THERE IS NO MOVE OFFSET
       ZER  DNAMS            COLLECT SEDIMENT IF MUST MOVE IT
GBC0A  MOV  DNAMB,WA         START OF DYNAMIC AREA
       ADD  DNAMS,WA         SIZE OF SEDIMENT
       MOV  WA,GBCSD         FIRST LOCATION PAST SEDIMENT
.IF    .CEPP
.ELSE
       MOV  =P_YYY,WA        LAST ENTRY POINT
       ICV  WA               ADDRESS PAST LAST ENTRY POINT
       SUB  =B_AAA,WA        SIZE OF ENTRY POINT AREA
       MOV  WA,GBCMK         USE TO MARK PROCESSED SED. BLOCKS
.FI
.FI
.IF    .CGBC
       MNZ  XR               NON-ZERO FLAGS START OF COLLECTION
       MOV  DNAMB,WA         START OF DYNAMIC AREA
       MOV  DNAMP,WB         NEXT AVAILABLE LOCATION
       MOV  DNAME,WC         LAST AVAILABLE LOCATION + 1
       JSR  SYSGC            INFORM OF COLLECTION
.FI
       MOV  XS,XR            POINT TO STACK FRONT
       MOV  STBAS,XL         POINT PAST END OF STACK
       BGE  XL,XR,GBC00      OK IF D-STACK
       MOV  XL,XR            REVERSE IF ...
       MOV  XS,XL            ... U-STACK
GBC00  JSR  GBCPF            PROCESS POINTERS ON STACK
       MOV  =R_AAA,XR        POINT TO START OF RELOCATABLE LOCS
       MOV  =R_YYY,XL        POINT PAST END OF RELOCATABLE LOCS
       JSR  GBCPF            PROCESS WORK FIELDS
       MOV  HSHTB,WA         POINT TO FIRST HASH SLOT POINTER
GBC01  MOV  WA,XL            POINT TO NEXT SLOT
       ICA  WA               BUMP BUCKET POINTER
       MOV  WA,GBCNM         SAVE BUCKET POINTER
GBC02  MOV  (XL),XR          LOAD PTR TO NEXT VRBLK
       BZE  XR,GBC03         JUMP IF END OF CHAIN
       MOV  XR,XL            ELSE COPY VRBLK POINTER
       ADD  *VRVAL,XR        POINT TO FIRST RELOC FLD
       ADD  *VRNXT,XL        POINT PAST LAST (AND TO LINK PTR)
       JSR  GBCPF            PROCESS RELOC FIELDS IN VRBLK
       BRN  GBC02            LOOP BACK FOR NEXT BLOCK
GBC03  MOV  GBCNM,WA         RESTORE BUCKET POINTER
       BNE  WA,HSHTE,GBC01   LOOP BACK IF MORE BUCKETS TO GO
.IF    .CSED
       MOV  DNAMB,XR         POINT TO FIRST BLOCK
       ZER  WB               ACCUMULATE SIZE OF DEAD BLOCKS
GBC04  BEQ  XR,GBCSD,GBC4C   JUMP IF END OF SEDIMENT
       MOV  (XR),WA          ELSE GET FIRST WORD
.IF    .CEPP
       BOD  WA,GBC4B         JUMP IF ENTRY POINTER (UNUSED)
       DCV  WA               RESTORE ENTRY POINTER
.ELSE
       BHI  WA,=P_YYY,GBC4A  SKIP IF NOT ENTRY PTR (IN USE)
       BHI  WA,=B_AAA,GBC4B  JUMP IF ENTRY POINTER (UNUSED)
GBC4A  SUB  GBCMK,WA         RESTORE ENTRY POINTER
.FI
       MOV  WA,(XR)          RESTORE FIRST WORD
       JSR  BLKLN            GET LENGTH OF THIS BLOCK
       ADD  WA,XR            BUMP ACTUAL POINTER
       BRN  GBC04            CONTINUE SCAN THROUGH SEDIMENT
GBC4B  JSR  BLKLN            GET LENGTH OF THIS BLOCK
       ADD  WA,XR            BUMP ACTUAL POINTER
       ADD  WA,WB            COUNT SIZE OF UNUSED BLOCKS
       BRN  GBC04            CONTINUE SCAN THROUGH SEDIMENT
GBC4C  MOV  WB,GBCSF         SIZE OF SEDIMENT FREE SPACE
.ELSE
       MOV  DNAMB,XR         POINT TO FIRST BLOCK
.FI
       MOV  XR,WC            SET AS FIRST EVENTUAL LOCATION
       ADD  GBSVB,WC         ADD OFFSET FOR EVENTUAL MOVE UP
       ZER  GBCNM            CLEAR INITIAL FORWARD POINTER
       MOV  =GBCNM,GBCLM     INITIALIZE PTR TO LAST MOVE BLOCK
       MOV  XR,GBCNS         INITIALIZE FIRST ADDRESS
GBC05  BEQ  XR,DNAMP,GBC07   JUMP IF END OF USED REGION
       MOV  (XR),WA          ELSE GET FIRST WORD
.IF    .CEPP
       BOD  WA,GBC07         JUMP IF ENTRY POINTER (UNUSED)
.ELSE
       BHI  WA,=P_YYY,GBC06  SKIP IF NOT ENTRY PTR (IN USE)
       BHI  WA,=B_AAA,GBC07  JUMP IF ENTRY POINTER (UNUSED)
.FI
GBC06  MOV  WA,XL            COPY POINTER
       MOV  (XL),WA          LOAD FORWARD POINTER
       MOV  WC,(XL)          RELOCATE REFERENCE
.IF    .CEPP
       BEV  WA,GBC06         LOOP BACK IF NOT END OF CHAIN
.ELSE
       BHI  WA,=P_YYY,GBC06  LOOP BACK IF NOT END OF CHAIN
       BLO  WA,=B_AAA,GBC06  LOOP BACK IF NOT END OF CHAIN
.FI
       MOV  WA,(XR)          RESTORE FIRST WORD
       JSR  BLKLN            GET LENGTH OF THIS BLOCK
       ADD  WA,XR            BUMP ACTUAL POINTER
       ADD  WA,WC            BUMP EVENTUAL POINTER
       BRN  GBC05            LOOP BACK FOR NEXT BLOCK
GBC07  MOV  XR,WA            COPY POINTER PAST LAST BLOCK
       MOV  GBCLM,XL         POINT TO PREVIOUS MOVE BLOCK
       SUB  NUM01(XL),WA     SUBTRACT STARTING ADDRESS
       MOV  WA,NUM01(XL)     STORE LENGTH OF BLOCK TO BE MOVED
GBC08  BEQ  XR,DNAMP,GBC10   JUMP IF END OF USED REGION
       MOV  (XR),WA          ELSE LOAD FIRST WORD OF NEXT BLOCK
.IF    .CEPP
       BEV  WA,GBC09         JUMP IF IN USE
.ELSE
       BHI  WA,=P_YYY,GBC09  JUMP IF IN USE
       BLO  WA,=B_AAA,GBC09  JUMP IF IN USE
.FI
       JSR  BLKLN            ELSE GET LENGTH OF NEXT BLOCK
       ADD  WA,XR            PUSH POINTER
       BRN  GBC08            AND LOOP BACK
GBC09  SUB  *NUM02,XR        POINT 2 WORDS BEHIND FOR MOVE BLOCK
       MOV  GBCLM,XL         POINT TO PREVIOUS MOVE BLOCK
       MOV  XR,(XL)          SET FORWARD PTR IN PREVIOUS BLOCK
       ZER  (XR)             ZERO FORWARD PTR OF NEW BLOCK
       MOV  XR,GBCLM         REMEMBER ADDRESS OF THIS BLOCK
       MOV  XR,XL            COPY PTR TO MOVE BLOCK
       ADD  *NUM02,XR        POINT BACK TO BLOCK IN USE
       MOV  XR,NUM01(XL)     STORE STARTING ADDRESS
       BRN  GBC06            JUMP TO PROCESS BLOCK IN USE
.IF    .CSED
GBC10  MOV  GBCSD,XR         POINT TO STORAGE ABOVE SEDIMENT
.ELSE
GBC10  MOV  DNAMB,XR         POINT TO START OF STORAGE
.FI
       ADD  GBCNS,XR         BUMP PAST UNMOVED BLOCKS AT START
GBC11  MOV  GBCNM,XL         POINT TO NEXT MOVE BLOCK
       BZE  XL,GBC12         JUMP IF END OF CHAIN
       MOV  (XL)+,GBCNM      MOVE POINTER DOWN CHAIN
       MOV  (XL)+,WA         GET LENGTH TO MOVE
       MVW                   PERFORM MOVE
       BRN  GBC11            LOOP BACK
GBC12  MOV  XR,DNAMP         SET NEXT AVAILABLE LOC PTR
       MOV  GBSVB,WB         RELOAD MOVE OFFSET
       BZE  WB,GBC13         JUMP IF NO MOVE REQUIRED
       MOV  XR,XL            ELSE COPY OLD TOP OF CORE
       ADD  WB,XR            POINT TO NEW TOP OF CORE
       MOV  XR,DNAMP         SAVE NEW TOP OF CORE POINTER
       MOV  XL,WA            COPY OLD TOP
       SUB  DNAMB,WA         MINUS OLD BOTTOM = LENGTH
       ADD  WB,DNAMB         BUMP BOTTOM TO GET NEW VALUE
       MWB                   PERFORM MOVE (BACKWARDS)
GBC13  ZER  XR               CLEAR GARBAGE VALUE IN XR
       MOV  XR,GBCFL         NOTE EXIT FROM GBCOL
.IF    .CGBC
       MOV  DNAMB,WA         START OF DYNAMIC AREA
       MOV  DNAMP,WB         NEXT AVAILABLE LOCATION
       MOV  DNAME,WC         LAST AVAILABLE LOCATION + 1
       JSR  SYSGC            INFORM SYSGC OF COMPLETION
.FI
.IF    .CSED
       STI  GBCIA            SAVE IA
       ZER  XR               PRESUME NO SEDIMENT WILL REMAIN
       MOV  GBCSF,WB         FREE SPACE IN SEDIMENT
       BTW  WB               CONVERT BYTES TO WORDS
       MTI  WB               PUT SEDIMENT FREE STORE IN IA
       MLI  GBSED            MULTIPLY BY SEDIMENT FACTOR
       IOV  GB13A            JUMP IF OVERFLOWED
       MOV  DNAMP,WB         END OF DYNAMIC AREA IN USE
       SUB  DNAMB,WB         MINUS START IS SEDIMENT REMAINING
       BTW  WB               CONVERT TO WORDS
       MOV  WB,GBCSF         STORE IT
       SBI  GBCSF            SUBTRACT FROM SCALED UP FREE STORE
       IGT  GB13A            JUMP IF LARGE FREE STORE IN SEDIMNT
       MOV  DNAMP,XR         BELOW THRESHOLD, RETURN SEDIMENT
       SUB  DNAMB,XR         FOR USE BY CALLER
GB13A  LDI  GBCIA            RESTORE IA
.FI
       MOV  GBSVA,WA         RESTORE WA
       MOV  GBSVB,WB         RESTORE WB
       SCP  WC               GET CODE POINTER
       ADD  R_COD,WC         MAKE ABSOLUTE AGAIN
       LCP  WC               AND REPLACE ABSOLUTE VALUE
       MOV  GBSVC,WC         RESTORE WC
       MOV  (XS)+,XL         RESTORE ENTRY XL
       ICV  GBCNT            INCREMENT COUNT OF COLLECTIONS
       EXI                   EXIT TO GBCOL CALLER
GBC14  ICV  ERRFT            FATAL ERROR
       ERB  250,Insufficient memory to complete dump
       ENP                   END PROCEDURE GBCOL
GBCPF  PRC  E,0              ENTRY POINT
       ZER  -(XS)            SET ZERO TO MARK BOTTOM OF STACK
       MOV  XL,-(XS)         SAVE END POINTER
GPF01  MOV  (XR),XL          LOAD FIELD CONTENTS
       MOV  XR,WC            SAVE FIELD POINTER
.IF    .CRPP
       BOD  XL,GPF2A         JUMP IF NOT PTR INTO DYNAMIC AREA
.FI
       BLT  XL,DNAMB,GPF2A   JUMP IF NOT PTR INTO DYNAMIC AREA
       BGE  XL,DNAMP,GPF2A   JUMP IF NOT PTR INTO DYNAMIC AREA
       MOV  (XL),WA          LOAD PTR TO CHAIN (OR ENTRY PTR)
.IF    .CSED
       BLT  XL,GBCSD,GPF1A   DO NOT CHAIN IF WITHIN SEDIMENT
.FI
       MOV  XR,(XL)          SET THIS FIELD AS NEW HEAD OF CHAIN
       MOV  WA,(XR)          SET FORWARD POINTER
.IF    .CEPP
GPF1A  BOD  WA,GPF03         JUMP IF NOT ALREADY PROCESSED
.ELSE
GPF1A  BHI  WA,=P_YYY,GPF2A  JUMP IF ALREADY PROCESSED
       BHI  WA,=B_AAA,GPF03  JUMP IF NOT ALREADY PROCESSED
.FI
GPF02  MOV  WC,XR            RESTORE FIELD POINTER
GPF2A  ICA  XR               BUMP TO NEXT FIELD
       BNE  XR,(XS),GPF01    LOOP BACK IF MORE TO GO
       MOV  (XS)+,XL         RESTORE POINTER PAST END
       MOV  (XS)+,XR         RESTORE BLOCK POINTER
       BNZ  XR,GPF2A         CONTINUE LOOP UNLESS OUTER LEVL
       EXI                   RETURN TO CALLER IF OUTER LEVEL
.IF    .CSED
GPF03  BGE  XL,GBCSD,GPF3A   IF NOT WITHIN SEDIMENT
.IF    .CEPP
       ICV  (XL)             MARK BY MAKING ENTRY POINT EVEN
.ELSE
       ADD  GBCMK,(XL)       MARK BY BIASING ENTRY POINT
.FI
GPF3A  MOV  XL,XR            COPY BLOCK POINTER
.ELSE
GPF03  MOV  XL,XR            COPY BLOCK POINTER
.FI
       MOV  WA,XL            COPY FIRST WORD OF BLOCK
       LEI  XL               LOAD ENTRY POINT ID (BL_XX)
       BSW  XL,BL___         SWITCH ON BLOCK TYPE
       IFF  BL_AR,GPF06      ARBLK
.IF    .CNBF
       IFF  BL_BC,GPF02      BCBLK - DUMMY TO FILL OUT IFFS
.ELSE
       IFF  BL_BC,GPF18      BCBLK
.FI
       IFF  BL_BF,GPF02      BFBLK
       IFF  BL_CC,GPF07      CCBLK
.IF    .CSLN
       IFF  BL_CD,GPF19      CDBLK
.ELSE
       IFF  BL_CD,GPF08      CDBLK
.FI
       IFF  BL_CM,GPF04      CMBLK
       IFF  BL_DF,GPF02      DFBLK
       IFF  BL_EV,GPF10      EVBLK
       IFF  BL_EX,GPF17      EXBLK
       IFF  BL_FF,GPF11      FFBLK
       IFF  BL_NM,GPF10      NMBLK
       IFF  BL_P0,GPF10      P0BLK
       IFF  BL_P1,GPF12      P1BLK
       IFF  BL_P2,GPF12      P2BLK
       IFF  BL_PD,GPF13      PDBLK
       IFF  BL_PF,GPF14      PFBLK
       IFF  BL_TB,GPF08      TBBLK
       IFF  BL_TE,GPF15      TEBLK
       IFF  BL_TR,GPF16      TRBLK
       IFF  BL_VC,GPF08      VCBLK
       IFF  BL_XR,GPF09      XRBLK
       IFF  BL_CT,GPF02      CTBLK
       IFF  BL_EF,GPF02      EFBLK
       IFF  BL_IC,GPF02      ICBLK
       IFF  BL_KV,GPF02      KVBLK
       IFF  BL_RC,GPF02      RCBLK
       IFF  BL_SC,GPF02      SCBLK
       IFF  BL_SE,GPF02      SEBLK
       IFF  BL_XN,GPF02      XNBLK
       ESW                   END OF JUMP TABLE
GPF04  MOV  CMLEN(XR),WA     LOAD LENGTH
       MOV  *CMTYP,WB        SET OFFSET
GPF05  ADD  XR,WA            POINT PAST LAST RELOC FIELD
       ADD  WB,XR            POINT TO FIRST RELOC FIELD
       MOV  WC,-(XS)         STACK OLD FIELD POINTER
       MOV  WA,-(XS)         STACK NEW LIMIT POINTER
       CHK                   CHECK FOR STACK OVERFLOW
       BRN  GPF01            IF OK, BACK TO PROCESS
GPF06  MOV  ARLEN(XR),WA     LOAD LENGTH
       MOV  AROFS(XR),WB     SET OFFSET TO 1ST RELOC FLD (ARPRO)
       BRN  GPF05            ALL SET
GPF07  MOV  CCUSE(XR),WA     SET LENGTH IN USE
       MOV  *CCUSE,WB        1ST WORD (MAKE SURE AT LEAST ONE)
       BRN  GPF05            ALL SET
.IF    .CSLN
GPF19  MOV  CDLEN(XR),WA     LOAD LENGTH
       MOV  *CDFAL,WB        SET OFFSET
       BRN  GPF05            JUMP BACK
.ELSE
.FI
GPF08  MOV  OFFS2(XR),WA     LOAD LENGTH
       MOV  *OFFS3,WB        SET OFFSET
       BRN  GPF05            JUMP BACK
GPF09  MOV  XRLEN(XR),WA     LOAD LENGTH
       MOV  *XRPTR,WB        SET OFFSET
       BRN  GPF05            JUMP BACK
GPF10  MOV  *OFFS2,WA        POINT PAST SECOND FIELD
       MOV  *OFFS1,WB        OFFSET IS ONE (ONLY RELOC FLD IS 2)
       BRN  GPF05            ALL SET
GPF11  MOV  *FFOFS,WA        SET LENGTH
       MOV  *FFNXT,WB        SET OFFSET
       BRN  GPF05            ALL SET
GPF12  MOV  *PARM2,WA        LENGTH (PARM2 IS NON-RELOCATABLE)
       MOV  *PTHEN,WB        SET OFFSET
       BRN  GPF05            ALL SET
GPF13  MOV  PDDFP(XR),XL     LOAD PTR TO DFBLK
       MOV  DFPDL(XL),WA     GET PDBLK LENGTH
       MOV  *PDFLD,WB        SET OFFSET
       BRN  GPF05            ALL SET
GPF14  MOV  *PFARG,WA        LENGTH PAST LAST RELOC
       MOV  *PFCOD,WB        OFFSET TO FIRST RELOC
       BRN  GPF05            ALL SET
GPF15  MOV  *TESI_,WA        SET LENGTH
       MOV  *TESUB,WB        AND OFFSET
       BRN  GPF05            ALL SET
GPF16  MOV  *TRSI_,WA        SET LENGTH
       MOV  *TRVAL,WB        AND OFFSET
       BRN  GPF05            ALL SET
GPF17  MOV  EXLEN(XR),WA     LOAD LENGTH
       MOV  *EXFLC,WB        SET OFFSET
       BRN  GPF05            JUMP BACK
.IF    .CNBF
.ELSE
GPF18  MOV  *BCSI_,WA        SET LENGTH
       MOV  *BCBUF,WB        AND OFFSET
       BRN  GPF05            ALL SET
.FI
       ENP                   END PROCEDURE GBCPF
GTARR  PRC  E,2              ENTRY POINT
       MOV  WA,GTAWA         SAVE WA INDICATOR
       MOV  (XR),WA          LOAD TYPE WORD
       BEQ  WA,=B_ART,GTAR8  EXIT IF ALREADY AN ARRAY
       BEQ  WA,=B_VCT,GTAR8  EXIT IF ALREADY AN ARRAY
       BNE  WA,=B_TBT,GTA9A  ELSE FAIL IF NOT A TABLE (SGD02)
       MOV  XR,-(XS)         REPLACE TBBLK POINTER ON STACK
       ZER  XR               SIGNAL FIRST PASS
       ZER  WB               ZERO NON-NULL ELEMENT COUNT
GTAR1  MOV  (XS),XL          POINT TO TABLE
       ADD  TBLEN(XL),XL     POINT PAST LAST BUCKET
       SUB  *TBBUK,XL        SET FIRST BUCKET OFFSET
       MOV  XL,WA            COPY ADJUSTED POINTER
GTAR2  MOV  WA,XL            COPY BUCKET POINTER
       DCA  WA               DECREMENT BUCKET POINTER
GTAR3  MOV  TENXT(XL),XL     POINT TO NEXT TEBLK
       BEQ  XL,(XS),GTAR6    JUMP IF CHAIN END (TBBLK PTR)
       MOV  XL,CNVTP         ELSE SAVE TEBLK POINTER
GTAR4  MOV  TEVAL(XL),XL     LOAD VALUE
       BEQ  (XL),=B_TRT,GTAR4 LOOP TILL VALUE FOUND
       MOV  XL,WC            COPY VALUE
       MOV  CNVTP,XL         RESTORE TEBLK POINTER
       BEQ  WC,=NULLS,GTAR3  LOOP BACK TO IGNORE NULL VALUE
       BNZ  XR,GTAR5         JUMP IF SECOND PASS
       ICV  WB               FOR THE FIRST PASS, BUMP COUNT
       BRN  GTAR3            AND LOOP BACK FOR NEXT TEBLK
GTAR5  BZE  GTAWA,GTA5A      JUMP IF ADDRESS WANTED
       MOV  TESUB(XL),(XR)+  STORE SUBSCRIPT NAME
       MOV  WC,(XR)+         STORE VALUE IN ARBLK
       BRN  GTAR3            LOOP BACK FOR NEXT TEBLK
GTA5A  MOV  XL,(XR)+         STORE TEBLK ADDRESS IN NAME
       MOV  XL,(XR)+         AND VALUE SLOTS
       BRN  GTAR3            LOOP BACK FOR NEXT TEBLK
GTAR6  BNE  WA,(XS),GTAR2    LOOP BACK IF MORE BUCKETS TO GO
       BNZ  XR,GTAR7         ELSE JUMP IF SECOND PASS
       BZE  WB,GTAR9         FAIL IF NO NON-NULL ELEMENTS
       MOV  WB,WA            ELSE COPY COUNT
       ADD  WB,WA            DOUBLE (TWO WORDS/ELEMENT)
       ADD  =ARVL2,WA        ADD SPACE FOR STANDARD FIELDS
       WTB  WA               CONVERT LENGTH TO BYTES
       BGT  WA,MXLEN,GTA9B   ERROR IF TOO LONG FOR ARRAY
       JSR  ALLOC            ELSE ALLOCATE SPACE FOR ARBLK
       MOV  =B_ART,(XR)      STORE TYPE WORD
       ZER  IDVAL(XR)        ZERO ID FOR THE MOMENT
       MOV  WA,ARLEN(XR)     STORE LENGTH
       MOV  =NUM02,ARNDM(XR) SET DIMENSIONS = 2
       LDI  INTV1            GET INTEGER ONE
       STI  ARLBD(XR)        STORE AS LBD 1
       STI  ARLB2(XR)        STORE AS LBD 2
       LDI  INTV2            LOAD INTEGER TWO
       STI  ARDM2(XR)        STORE AS DIM 2
       MTI  WB               GET ELEMENT COUNT AS INTEGER
       STI  ARDIM(XR)        STORE AS DIM 1
       ZER  ARPR2(XR)        ZERO PROTOTYPE FIELD FOR NOW
       MOV  *ARPR2,AROFS(XR) SET OFFSET FIELD (SIGNAL PASS 2)
       MOV  XR,WB            SAVE ARBLK POINTER
       ADD  *ARVL2,XR        POINT TO FIRST ELEMENT LOCATION
       BRN  GTAR1            JUMP BACK TO FILL IN ELEMENTS
GTAR7  MOV  WB,XR            RESTORE ARBLK POINTER
       MOV  WB,(XS)          STORE AS RESULT
       LDI  ARDIM(XR)        GET NUMBER OF ELEMENTS (NN)
       MLI  INTVH            MULTIPLY BY 100
       ADI  INTV2            ADD 2 (NN02)
       JSR  ICBLD            BUILD INTEGER
       MOV  XR,-(XS)         STORE PTR FOR GTSTG
       JSR  GTSTG            CONVERT TO STRING
       PPM                   CONVERT FAIL IS IMPOSSIBLE
       MOV  XR,XL            COPY STRING POINTER
       MOV  (XS)+,XR         RELOAD ARBLK POINTER
       MOV  XL,ARPR2(XR)     STORE PROTOTYPE PTR (NN02)
       SUB  =NUM02,WA        ADJUST LENGTH TO POINT TO ZERO
       PSC  XL,WA            POINT TO ZERO
       MOV  =CH_CM,WB        LOAD A COMMA
       SCH  WB,(XL)          STORE A COMMA OVER THE ZERO
       CSC  XL               COMPLETE STORE CHARACTERS
GTAR8  EXI                   RETURN TO CALLER
GTAR9  MOV  (XS)+,XR         RESTORE STACK FOR CONV ERR (SGD02)
       EXI  1                RETURN
GTA9A  EXI  2                RETURN
GTA9B  ERB  260,Conversion array size exceeds maximum permitted
       ENP                   PROCEDURE GTARR
GTCOD  PRC  E,1              ENTRY POINT
       BEQ  (XR),=B_CDS,GTCD1 JUMP IF ALREADY CODE
       BEQ  (XR),=B_CDC,GTCD1 JUMP IF ALREADY CODE
       MOV  XR,-(XS)         STACK ARGUMENT FOR GTSTG
       JSR  GTSTG            CONVERT ARGUMENT TO STRING
       PPM  GTCD2            JUMP IF NON-CONVERTIBLE
       MOV  FLPTR,GTCEF      SAVE FAIL PTR IN CASE OF ERROR
       MOV  R_COD,R_GTC      ALSO SAVE CODE PTR
       MOV  XR,R_CIM         ELSE SET IMAGE POINTER
       MOV  WA,SCNIL         SET IMAGE LENGTH
       ZER  SCNPT            SET SCAN POINTER
       MOV  =STGXC,STAGE     SET STAGE FOR EXECUTE COMPILE
       MOV  CMPSN,LSTSN      IN CASE LISTR CALLED
.IF    .CSLN
       ICV  CMPLN            BUMP LINE NUMBER
.FI
       JSR  CMPIL            COMPILE STRING
       MOV  =STGXT,STAGE     RESET STAGE FOR EXECUTE TIME
       ZER  R_CIM            CLEAR IMAGE
GTCD1  EXI                   GIVE NORMAL GTCOD RETURN
GTCD2  EXI  1                GIVE ERROR RETURN
       ENP                   END PROCEDURE GTCOD
.IF    .CEVB
.FI
GTEXP  PRC  E,1              ENTRY POINT
       BLO  (XR),=B_E__,GTEX1 JUMP IF ALREADY AN EXPRESSION
       MOV  XR,-(XS)         STORE ARGUMENT FOR GTSTG
       JSR  GTSTG            CONVERT ARGUMENT TO STRING
       PPM  GTEX2            JUMP IF UNCONVERTIBLE
       MOV  XR,XL            COPY INPUT STRING POINTER
       PLC  XL,WA            POINT ONE PAST THE STRING END
       LCH  XL,-(XL)         FETCH THE LAST CHARACTER
       BEQ  XL,=CH_CL,GTEX2  ERROR IF IT IS A SEMICOLON
       BEQ  XL,=CH_SM,GTEX2  OR IF IT IS A COLON
       MOV  XR,R_CIM         SET INPUT IMAGE POINTER
       ZER  SCNPT            SET SCAN POINTER
       MOV  WA,SCNIL         SET INPUT IMAGE LENGTH
.IF    .CEVB
       MOV  WB,-(XS)         SAVE VALUE/NAME FLAG
.FI
       ZER  WB               SET CODE FOR NORMAL SCAN
       MOV  FLPTR,GTCEF      SAVE FAIL PTR IN CASE OF ERROR
       MOV  R_COD,R_GTC      ALSO SAVE CODE PTR
       MOV  =STGEV,STAGE     ADJUST STAGE FOR COMPILE
       MOV  =T_UOK,SCNTP     INDICATE UNARY OPERATOR ACCEPTABLE
       JSR  EXPAN            BUILD TREE FOR EXPRESSION
       ZER  SCNRS            RESET RESCAN FLAG
.IF    .CEVB
       MOV  (XS)+,WA         RESTORE VALUE/NAME FLAG
.FI
       BNE  SCNPT,SCNIL,GTEX2 ERROR IF NOT END OF IMAGE
       ZER  WB               SET OK VALUE FOR CDGEX CALL
       MOV  XR,XL            COPY TREE POINTER
       JSR  CDGEX            BUILD EXPRESSION BLOCK
       ZER  R_CIM            CLEAR POINTER
       MOV  =STGXT,STAGE     RESTORE STAGE FOR EXECUTE TIME
GTEX1  EXI                   RETURN TO GTEXP CALLER
GTEX2  EXI  1                TAKE ERROR EXIT
       ENP                   END PROCEDURE GTEXP
GTINT  PRC  E,1              ENTRY POINT
       BEQ  (XR),=B_ICL,GTIN2 JUMP IF ALREADY AN INTEGER
       MOV  WA,GTINA         ELSE SAVE WA
       MOV  WB,GTINB         SAVE WB
       JSR  GTNUM            CONVERT TO NUMERIC
       PPM  GTIN3            JUMP IF UNCONVERTIBLE
.IF    .CNRA
.ELSE
       BEQ  WA,=B_ICL,GTIN1  JUMP IF INTEGER
       LDR  RCVAL(XR)        LOAD REAL VALUE
       RTI  GTIN3            CONVERT TO INTEGER (ERR IF OVFLOW)
       JSR  ICBLD            IF OK BUILD ICBLK
.FI
GTIN1  MOV  GTINA,WA         RESTORE WA
       MOV  GTINB,WB         RESTORE WB
GTIN2  EXI                   RETURN TO GTINT CALLER
GTIN3  EXI  1                TAKE CONVERT ERROR EXIT
       ENP                   END PROCEDURE GTINT
GTNUM  PRC  E,1              ENTRY POINT
       MOV  (XR),WA          LOAD FIRST WORD OF BLOCK
       BEQ  WA,=B_ICL,GTN34  JUMP IF INTEGER (NO CONVERSION)
.IF    .CNRA
.ELSE
       BEQ  WA,=B_RCL,GTN34  JUMP IF REAL (NO CONVERSION)
.FI
       MOV  XR,-(XS)         STACK ARGUMENT IN CASE CONVERT ERR
       MOV  XR,-(XS)         STACK ARGUMENT FOR GTSTG
.IF    .CNBF
       JSR  GTSTG            CONVERT ARGUMENT TO STRING
.ELSE
       JSR  GTSTB            GET ARGUMENT AS STRING OR BUFFER
.FI
       PPM  GTN36            JUMP IF UNCONVERTIBLE
       LDI  INTV0            INITIALIZE INTEGER RESULT TO ZERO
       BZE  WA,GTN32         JUMP TO EXIT WITH ZERO IF NULL
       LCT  WA,WA            SET BCT COUNTER FOR FOLLOWING LOOPS
       ZER  GTNNF            TENTATIVELY INDICATE RESULT +
.IF    .CNRA
.ELSE
       STI  GTNEX            INITIALISE EXPONENT TO ZERO
       ZER  GTNSC            ZERO SCALE IN CASE REAL
       ZER  GTNDF            RESET FLAG FOR DEC POINT FOUND
       ZER  GTNRD            RESET FLAG FOR DIGITS FOUND
       LDR  REAV0            ZERO REAL ACCUM IN CASE REAL
.FI
       PLC  XR               POINT TO ARGUMENT CHARACTERS
GTN01  LCH  WB,(XR)+         LOAD FIRST CHARACTER
       BLT  WB,=CH_D0,GTN02  JUMP IF NOT DIGIT
       BLE  WB,=CH_D9,GTN06  JUMP IF FIRST CHAR IS A DIGIT
GTN02  BNE  WB,=CH_BL,GTN03  JUMP IF NON-BLANK
GTNA2  BCT  WA,GTN01         ELSE DECR COUNT AND LOOP BACK
       BRN  GTN07            JUMP TO RETURN ZERO IF ALL BLANKS
GTN03  BEQ  WB,=CH_PL,GTN04  JUMP IF PLUS SIGN
.IF    .CAHT
       BEQ  WB,=CH_HT,GTNA2  HORIZONTAL TAB EQUIV TO BLANK
.FI
.IF    .CAVT
       BEQ  WB,=CH_VT,GTNA2  VERTICAL TAB EQUIV TO BLANK
.FI
.IF    .CNRA
       BNE  WB,=CH_MN,GTN36  ELSE FAIL
.ELSE
       BNE  WB,=CH_MN,GTN12  JUMP IF NOT MINUS (MAY BE REAL)
.FI
       MNZ  GTNNF            IF MINUS SIGN, SET NEGATIVE FLAG
GTN04  BCT  WA,GTN05         JUMP IF CHARS LEFT
       BRN  GTN36            ELSE ERROR
GTN05  LCH  WB,(XR)+         LOAD NEXT CHARACTER
       BLT  WB,=CH_D0,GTN08  JUMP IF NOT A DIGIT
       BGT  WB,=CH_D9,GTN08  JUMP IF NOT A DIGIT
GTN06  STI  GTNSI            SAVE CURRENT VALUE
.IF    .CNRA
       CVM  GTN36            CURRENT*10-(NEW DIG) JUMP IF OVFLOW
.ELSE
       CVM  GTN35            CURRENT*10-(NEW DIG) JUMP IF OVFLOW
       MNZ  GTNRD            SET DIGIT READ FLAG
.FI
       BCT  WA,GTN05         ELSE LOOP BACK IF MORE CHARS
GTN07  BNZ  GTNNF,GTN32      JUMP IF NEGATIVE (ALL SET)
       NGI                   ELSE NEGATE
       INO  GTN32            JUMP IF NO OVERFLOW
       BRN  GTN36            ELSE SIGNAL ERROR
GTN08  BEQ  WB,=CH_BL,GTNA9  JUMP IF A BLANK
.IF    .CAHT
       BEQ  WB,=CH_HT,GTNA9  JUMP IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WB,=CH_VT,GTNA9  JUMP IF VERTICAL TAB
.FI
.IF    .CNRA
       BRN  GTN36            ERROR
.ELSE
       ITR                   ELSE CONVERT INTEGER TO REAL
       NGR                   NEGATE TO GET POSITIVE VALUE
       BRN  GTN12            JUMP TO TRY FOR REAL
.FI
GTN09  LCH  WB,(XR)+         GET NEXT CHAR
.IF    .CAHT
       BEQ  WB,=CH_HT,GTNA9  JUMP IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WB,=CH_VT,GTNA9  JUMP IF VERTICAL TAB
.FI
       BNE  WB,=CH_BL,GTN36  ERROR IF NON-BLANK
GTNA9  BCT  WA,GTN09         LOOP BACK IF MORE CHARS TO CHECK
       BRN  GTN07            RETURN INTEGER IF ALL BLANKS
.IF    .CNRA
.ELSE
GTN10  LCH  WB,(XR)+         LOAD NEXT CHARACTER
       BLT  WB,=CH_D0,GTN12  JUMP IF NON-NUMERIC
       BGT  WB,=CH_D9,GTN12  JUMP IF NON-NUMERIC
GTN11  SUB  =CH_D0,WB        CONVERT DIGIT TO NUMBER
       MLR  REAVT            MULTIPLY REAL BY 10.0
       ROV  GTN36            CONVERT ERROR IF OVERFLOW
       STR  GTNSR            SAVE RESULT
       MTI  WB               GET NEW DIGIT AS INTEGER
       ITR                   CONVERT NEW DIGIT TO REAL
       ADR  GTNSR            ADD TO GET NEW TOTAL
       ADD  GTNDF,GTNSC      INCREMENT SCALE IF AFTER DEC POINT
       MNZ  GTNRD            SET DIGIT FOUND FLAG
       BCT  WA,GTN10         LOOP BACK IF MORE CHARS
       BRN  GTN22            ELSE JUMP TO SCALE
GTN12  BNE  WB,=CH_DT,GTN13  JUMP IF NOT DEC POINT
       BNZ  GTNDF,GTN36      IF DEC POINT, ERROR IF ONE ALREADY
       MOV  =NUM01,GTNDF     ELSE SET FLAG FOR DEC POINT
       BCT  WA,GTN10         LOOP BACK IF MORE CHARS
       BRN  GTN22            ELSE JUMP TO SCALE
GTN13  BEQ  WB,=CH_LE,GTN15  JUMP IF E FOR EXPONENT
       BEQ  WB,=CH_LD,GTN15  JUMP IF D FOR EXPONENT
.IF    .CULC
       BEQ  WB,=CH__E,GTN15  JUMP IF E FOR EXPONENT
       BEQ  WB,=CH__D,GTN15  JUMP IF D FOR EXPONENT
.FI
GTN14  BEQ  WB,=CH_BL,GTNB4  JUMP IF BLANK
.IF    .CAHT
       BEQ  WB,=CH_HT,GTNB4  JUMP IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WB,=CH_VT,GTNB4  JUMP IF VERTICAL TAB
.FI
       BRN  GTN36            ERROR IF NON-BLANK
GTNB4  LCH  WB,(XR)+         GET NEXT CHARACTER
       BCT  WA,GTN14         LOOP BACK TO CHECK IF MORE
       BRN  GTN22            ELSE JUMP TO SCALE
GTN15  ZER  GTNES            SET EXPONENT SIGN POSITIVE
       LDI  INTV0            INITIALIZE EXPONENT TO ZERO
       MNZ  GTNDF            RESET NO DEC POINT INDICATION
       BCT  WA,GTN16         JUMP SKIPPING PAST E OR D
       BRN  GTN36            ERROR IF NULL EXPONENT
GTN16  LCH  WB,(XR)+         LOAD FIRST EXPONENT CHARACTER
       BEQ  WB,=CH_PL,GTN17  JUMP IF PLUS SIGN
       BNE  WB,=CH_MN,GTN19  ELSE JUMP IF NOT MINUS SIGN
       MNZ  GTNES            SET SIGN NEGATIVE IF MINUS SIGN
GTN17  BCT  WA,GTN18         JUMP IF CHARS LEFT
       BRN  GTN36            ELSE ERROR
GTN18  LCH  WB,(XR)+         LOAD NEXT CHARACTER
GTN19  BLT  WB,=CH_D0,GTN20  JUMP IF NOT DIGIT
       BGT  WB,=CH_D9,GTN20  JUMP IF NOT DIGIT
       CVM  GTN36            ELSE CURRENT*10, SUBTRACT NEW DIGIT
       BCT  WA,GTN18         LOOP BACK IF MORE CHARS
       BRN  GTN21            JUMP IF EXPONENT FIELD IS EXHAUSTED
GTN20  BEQ  WB,=CH_BL,GTNC0  JUMP IF BLANK
.IF    .CAHT
       BEQ  WB,=CH_HT,GTNC0  JUMP IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WC,=CH_VT,GTNC0  JUMP IF VERTICAL TAB
.FI
       BRN  GTN36            ERROR IF NON-BLANK
GTNC0  LCH  WB,(XR)+         GET NEXT CHARACTER
       BCT  WA,GTN20         LOOP BACK TILL ALL BLANKS SCANNED
GTN21  STI  GTNEX            SAVE COLLECTED EXPONENT
       BNZ  GTNES,GTN22      JUMP IF IT WAS NEGATIVE
       NGI                   ELSE COMPLEMENT
       IOV  GTN36            ERROR IF OVERFLOW
       STI  GTNEX            AND STORE POSITIVE EXPONENT
GTN22  BZE  GTNRD,GTN36      ERROR IF NOT DIGITS COLLECTED
       BZE  GTNDF,GTN36      ERROR IF NO EXPONENT OR DEC POINT
       MTI  GTNSC            ELSE LOAD SCALE AS INTEGER
       SBI  GTNEX            SUBTRACT EXPONENT
       IOV  GTN36            ERROR IF OVERFLOW
       ILT  GTN26            JUMP IF WE MUST SCALE UP
       MFI  WA,GTN36         LOAD SCALE FACTOR, ERR IF OVFLOW
GTN23  BLE  WA,=NUM10,GTN24  JUMP IF 10 OR LESS TO GO
       DVR  REATT            ELSE DIVIDE BY 10**10
       SUB  =NUM10,WA        DECREMENT SCALE
       BRN  GTN23            AND LOOP BACK
GTN24  BZE  WA,GTN30         JUMP IF SCALED
       LCT  WB,=CFP_R        ELSE GET INDEXING FACTOR
       MOV  =REAV1,XR        POINT TO POWERS OF TEN TABLE
       WTB  WA               CONVERT REMAINING SCALE TO BYTE OFS
GTN25  ADD  WA,XR            BUMP POINTER
       BCT  WB,GTN25         ONCE FOR EACH VALUE WORD
       DVR  (XR)             SCALE DOWN AS REQUIRED
       BRN  GTN30            AND JUMP
GTN26  NGI                   GET ABSOLUTE VALUE OF EXPONENT
       IOV  GTN36            ERROR IF OVERFLOW
       MFI  WA,GTN36         ACQUIRE SCALE, ERROR IF OVFLOW
GTN27  BLE  WA,=NUM10,GTN28  JUMP IF 10 OR LESS TO GO
       MLR  REATT            ELSE MULTIPLY BY 10**10
       ROV  GTN36            ERROR IF OVERFLOW
       SUB  =NUM10,WA        ELSE DECREMENT SCALE
       BRN  GTN27            AND LOOP BACK
GTN28  BZE  WA,GTN30         JUMP IF SCALED
       LCT  WB,=CFP_R        ELSE GET INDEXING FACTOR
       MOV  =REAV1,XR        POINT TO POWERS OF TEN TABLE
       WTB  WA               CONVERT REMAINING SCALE TO BYTE OFS
GTN29  ADD  WA,XR            BUMP POINTER
       BCT  WB,GTN29         ONCE FOR EACH WORD IN VALUE
       MLR  (XR)             SCALE UP
       ROV  GTN36            ERROR IF OVERFLOW
GTN30  BZE  GTNNF,GTN31      JUMP IF POSITIVE
       NGR                   ELSE NEGATE
GTN31  JSR  RCBLD            BUILD REAL BLOCK
       BRN  GTN33            MERGE TO EXIT
.FI
GTN32  JSR  ICBLD            BUILD ICBLK
GTN33  MOV  (XR),WA          LOAD FIRST WORD OF RESULT BLOCK
       ICA  XS               POP ARGUMENT OFF STACK
GTN34  EXI                   RETURN TO GTNUM CALLER
.IF    .CNRA
.ELSE
GTN35  LCH  WB,-(XR)         RELOAD CURRENT CHARACTER
       LCH  WB,(XR)+         BUMP CHARACTER POINTER
       LDI  GTNSI            RELOAD INTEGER SO FAR
       ITR                   CONVERT TO REAL
       NGR                   MAKE VALUE POSITIVE
       BRN  GTN11            MERGE WITH REAL CIRCUIT
.FI
GTN36  MOV  (XS)+,XR         RELOAD ORIGINAL ARGUMENT
       EXI  1                TAKE CONVERT-ERROR EXIT
       ENP                   END PROCEDURE GTNUM
GTNVR  PRC  E,1              ENTRY POINT
       BNE  (XR),=B_NML,GNV02 JUMP IF NOT NAME
       MOV  NMBAS(XR),XR     ELSE LOAD NAME BASE IF NAME
       BLO  XR,STATE,GNV07   SKIP IF VRBLK (IN STATIC REGION)
GNV01  EXI  1                TAKE CONVERT-ERROR EXIT
GNV02  MOV  WA,GNVSA         SAVE WA
       MOV  WB,GNVSB         SAVE WB
       MOV  XR,-(XS)         STACK ARGUMENT FOR GTSTG
       JSR  GTSTG            CONVERT ARGUMENT TO STRING
       PPM  GNV01            JUMP IF CONVERSION ERROR
       BZE  WA,GNV01         NULL STRING IS AN ERROR
.IF    .CULC
       JSR  FLSTG            FOLD LOWER CASE TO UPPER CASE
.FI
       MOV  XL,-(XS)         SAVE XL
       MOV  XR,-(XS)         STACK STRING PTR FOR LATER
       MOV  XR,WB            COPY STRING POINTER
       ADD  *SCHAR,WB        POINT TO CHARACTERS OF STRING
       MOV  WB,GNVST         SAVE POINTER TO CHARACTERS
       MOV  WA,WB            COPY LENGTH
       CTW  WB,0             GET NUMBER OF WORDS IN NAME
       MOV  WB,GNVNW         SAVE FOR LATER
       JSR  HASHS            COMPUTE HASH INDEX FOR STRING
       RMI  HSHNB            COMPUTE HASH OFFSET BY TAKING MOD
       MFI  WC               GET AS OFFSET
       WTB  WC               CONVERT OFFSET TO BYTES
       ADD  HSHTB,WC         POINT TO PROPER HASH CHAIN
       SUB  *VRNXT,WC        SUBTRACT OFFSET TO MERGE INTO LOOP
GNV03  MOV  WC,XL            COPY HASH CHAIN POINTER
       MOV  VRNXT(XL),XL     POINT TO NEXT VRBLK ON CHAIN
       BZE  XL,GNV08         JUMP IF END OF CHAIN
       MOV  XL,WC            SAVE POINTER TO THIS VRBLK
       BNZ  VRLEN(XL),GNV04  JUMP IF NOT SYSTEM VARIABLE
       MOV  VRSVP(XL),XL     ELSE POINT TO SVBLK
       SUB  *VRSOF,XL        ADJUST OFFSET FOR MERGE
GNV04  BNE  WA,VRLEN(XL),GNV03 BACK FOR NEXT VRBLK IF LENGTHS NE
       ADD  *VRCHS,XL        ELSE POINT TO CHARS OF CHAIN ENTRY
       LCT  WB,GNVNW         GET WORD COUNTER TO CONTROL LOOP
       MOV  GNVST,XR         POINT TO CHARS OF NEW NAME
GNV05  CNE  (XR),(XL),GNV03  JUMP IF NO MATCH FOR NEXT VRBLK
       ICA  XR               BUMP NEW NAME POINTER
       ICA  XL               BUMP VRBLK IN CHAIN NAME POINTER
       BCT  WB,GNV05         ELSE LOOP TILL ALL COMPARED
       MOV  WC,XR            WE HAVE FOUND A MATCH, GET VRBLK
GNV06  MOV  GNVSA,WA         RESTORE WA
       MOV  GNVSB,WB         RESTORE WB
       ICA  XS               POP STRING POINTER
       MOV  (XS)+,XL         RESTORE XL
GNV07  EXI                   RETURN TO GTNVR CALLER
GNV08  ZER  XR               CLEAR GARBAGE XR POINTER
       MOV  WC,GNVHE         SAVE PTR TO END OF HASH CHAIN
       BGT  WA,=NUM09,GNV14  CANNOT BE SYSTEM VAR IF LENGTH GT 9
       MOV  WA,XL            ELSE COPY LENGTH
       WTB  XL               CONVERT TO BYTE OFFSET
       MOV  VSRCH(XL),XL     POINT TO FIRST SVBLK OF THIS LENGTH
GNV09  MOV  XL,GNVSP         SAVE TABLE POINTER
       MOV  (XL)+,WC         LOAD SVBIT BIT STRING
       MOV  (XL)+,WB         LOAD LENGTH FROM TABLE ENTRY
       BNE  WA,WB,GNV14      JUMP IF END OF RIGHT LENGTH ENTRIES
       LCT  WB,GNVNW         GET WORD COUNTER TO CONTROL LOOP
       MOV  GNVST,XR         POINT TO CHARS OF NEW NAME
GNV10  CNE  (XR),(XL),GNV11  JUMP IF NAME MISMATCH
       ICA  XR               ELSE BUMP NEW NAME POINTER
       ICA  XL               BUMP SVBLK POINTER
       BCT  WB,GNV10         ELSE LOOP UNTIL ALL CHECKED
       ZER  WC               SET VRLEN VALUE ZERO
       MOV  *VRSI_,WA        SET STANDARD SIZE
       BRN  GNV15            JUMP TO BUILD VRBLK
GNV11  ICA  XL               BUMP PAST WORD OF CHARS
       BCT  WB,GNV11         LOOP BACK IF MORE TO GO
       RSH  WC,SVNBT         REMOVE UNINTERESTING BITS
GNV12  MOV  BITS1,WB         LOAD BIT TO TEST
       ANB  WC,WB            TEST FOR WORD PRESENT
       ZRB  WB,GNV13         JUMP IF NOT PRESENT
       ICA  XL               ELSE BUMP TABLE POINTER
GNV13  RSH  WC,1             REMOVE BIT ALREADY PROCESSED
       NZB  WC,GNV12         LOOP BACK IF MORE BITS TO TEST
       BRN  GNV09            ELSE LOOP BACK FOR NEXT SVBLK
GNV14  MOV  WA,WC            COPY VRLEN VALUE
       MOV  =VRCHS,WA        LOAD STANDARD SIZE -CHARS
       ADD  GNVNW,WA         ADJUST FOR CHARS OF NAME
       WTB  WA               CONVERT LENGTH TO BYTES
GNV15  JSR  ALOST            ALLOCATE SPACE FOR VRBLK (STATIC)
       MOV  XR,WB            SAVE VRBLK POINTER
       MOV  =STNVR,XL        POINT TO MODEL VARIABLE BLOCK
       MOV  *VRLEN,WA        SET LENGTH OF STANDARD FIELDS
       MVW                   SET INITIAL FIELDS OF NEW BLOCK
       MOV  GNVHE,XL         LOAD POINTER TO END OF HASH CHAIN
       MOV  WB,VRNXT(XL)     ADD NEW BLOCK TO END OF CHAIN
       MOV  WC,(XR)+         SET VRLEN FIELD, BUMP PTR
       MOV  GNVNW,WA         GET LENGTH IN WORDS
       WTB  WA               CONVERT TO LENGTH IN BYTES
       BZE  WC,GNV16         JUMP IF SYSTEM VARIABLE
       MOV  (XS),XL          POINT BACK TO STRING NAME
       ADD  *SCHAR,XL        POINT TO CHARS OF NAME
       MVW                   MOVE CHARACTERS INTO PLACE
       MOV  WB,XR            RESTORE VRBLK POINTER
       BRN  GNV06            JUMP BACK TO EXIT
GNV16  MOV  GNVSP,XL         LOAD POINTER TO SVBLK
       MOV  XL,(XR)          SET SVBLK PTR IN VRBLK
       MOV  WB,XR            RESTORE VRBLK POINTER
       MOV  SVBIT(XL),WB     LOAD BIT INDICATORS
       ADD  *SVCHS,XL        POINT TO CHARACTERS OF NAME
       ADD  WA,XL            POINT PAST CHARACTERS
       MOV  BTKNM,WC         LOAD TEST BIT
       ANB  WB,WC            AND TO TEST
       ZRB  WC,GNV17         JUMP IF NO KEYWORD NUMBER
       ICA  XL               ELSE BUMP POINTER
GNV17  MOV  BTFNC,WC         GET TEST BIT
       ANB  WB,WC            AND TO TEST
       ZRB  WC,GNV18         SKIP IF NO SYSTEM FUNCTION
       MOV  XL,VRFNC(XR)     ELSE POINT VRFNC TO SVFNC FIELD
       ADD  *NUM02,XL        AND BUMP PAST SVFNC, SVNAR FIELDS
GNV18  MOV  BTLBL,WC         GET TEST BIT
       ANB  WB,WC            AND TO TEST
       ZRB  WC,GNV19         JUMP IF BIT IS OFF (NO SYSTEM LABL)
       MOV  XL,VRLBL(XR)     ELSE POINT VRLBL TO SVLBL FIELD
       ICA  XL               BUMP PAST SVLBL FIELD
GNV19  MOV  BTVAL,WC         LOAD TEST BIT
       ANB  WB,WC            AND TO TEST
       ZRB  WC,GNV06         ALL DONE IF NO VALUE
       MOV  (XL),VRVAL(XR)   ELSE SET INITIAL VALUE
       MOV  =B_VRE,VRSTO(XR) SET ERROR STORE ACCESS
       BRN  GNV06            MERGE BACK TO EXIT TO CALLER
       ENP                   END PROCEDURE GTNVR
GTPAT  PRC  E,1              ENTRY POINT
       BHI  (XR),=P_AAA,GTPT5 JUMP IF PATTERN ALREADY
       MOV  WB,GTPSB         SAVE WB
       MOV  XR,-(XS)         STACK ARGUMENT FOR GTSTG
       JSR  GTSTG            CONVERT ARGUMENT TO STRING
       PPM  GTPT2            JUMP IF IMPOSSIBLE
       BNZ  WA,GTPT1         JUMP IF NON-NULL
       MOV  =NDNTH,XR        POINT TO NOTHEN NODE
       BRN  GTPT4            JUMP TO EXIT
GTPT1  MOV  =P_STR,WB        LOAD PCODE FOR MULTI-CHAR STRING
       BNE  WA,=NUM01,GTPT3  JUMP IF MULTI-CHAR STRING
       PLC  XR               POINT TO CHARACTER
       LCH  WA,(XR)          LOAD CHARACTER
       MOV  WA,XR            SET AS PARM1
       MOV  =P_ANS,WB        POINT TO PCODE FOR 1-CHAR ANY
       BRN  GTPT3            JUMP TO BUILD NODE
GTPT2  MOV  =P_EXA,WB        SET PCODE FOR EXPRESSION IN CASE
       BLO  (XR),=B_E__,GTPT3 JUMP TO BUILD NODE IF EXPRESSION
       EXI  1                TAKE CONVERT ERROR EXIT
GTPT3  JSR  PBILD            CALL ROUTINE TO BUILD PATTERN NODE
GTPT4  MOV  GTPSB,WB         RESTORE WB
GTPT5  EXI                   RETURN TO GTPAT CALLER
       ENP                   END PROCEDURE GTPAT
.IF    .CNRA
.ELSE
GTREA  PRC  E,1              ENTRY POINT
       MOV  (XR),WA          GET FIRST WORD OF BLOCK
       BEQ  WA,=B_RCL,GTRE2  JUMP IF REAL
       JSR  GTNUM            ELSE CONVERT ARGUMENT TO NUMERIC
       PPM  GTRE3            JUMP IF UNCONVERTIBLE
       BEQ  WA,=B_RCL,GTRE2  JUMP IF REAL WAS RETURNED
GTRE1  LDI  ICVAL(XR)        LOAD INTEGER
       ITR                   CONVERT TO REAL
       JSR  RCBLD            BUILD RCBLK
GTRE2  EXI                   RETURN TO GTREA CALLER
GTRE3  EXI  1                TAKE CONVERT ERROR EXIT
       ENP                   END PROCEDURE GTREA
.FI
GTSMI  PRC  N,2              ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT
       BEQ  (XR),=B_ICL,GTSM1 SKIP IF ALREADY AN INTEGER
       JSR  GTINT            CONVERT ARGUMENT TO INTEGER
       PPM  GTSM2            JUMP IF CONVERT IS IMPOSSIBLE
GTSM1  LDI  ICVAL(XR)        LOAD INTEGER VALUE
       MFI  WC,GTSM3         MOVE AS ONE WORD, JUMP IF OVFLOW
       BGT  WC,MXLEN,GTSM3   OR IF TOO LARGE
       MOV  WC,XR            COPY RESULT TO XR
       EXI                   RETURN TO GTSMI CALLER
GTSM2  EXI  1                TAKE NON-INTEGER ERROR EXIT
GTSM3  EXI  2                TAKE OUT-OF-RANGE ERROR EXIT
       ENP                   END PROCEDURE GTSMI
.IF    .CNBF
.ELSE
GTSTB  PRC  N,1              ENTRY POINT
       MOV  (XS),XR          LOAD ARGUMENT, LEAVE ON STACK
       MOV  (XR),WA          LOAD BLOCK TYPE
       BEQ  WA,=B_SCL,GTSB2  JUMP IF ALREADY A STRING
       BEQ  WA,=B_BCT,GTSB3  JUMP IF ALREADY A BUFFER
       JSR  GTSTG            CONVERT TO STRING
       PPM  GTSB1            CONVERSION FAILED
       ZER  WB               SIGNAL STRING RESULT
       EXI                   CONVERT WITH STRING RESULT
GTSB1  EXI  1                TAKE CONVERT ERROR EXIT
GTSB2  ICA  XS               POP ARGUMENT
       MOV  SCLEN(XR),WA     LOAD STRING LENGTH
       ZER  WB               SIGNAL STRING RESULT
       EXI                   RETURN WITH STRING RESULT
GTSB3  ICA  XS               POP ARGUMENT
       MOV  BCLEN(XR),WA     LOAD LENGTH OF STRING IN BUFFER
       MOV  XR,WB            RETURN BCBLK POINTER IN WB
       MOV  BCBUF(XR),XR     RETURN BFBLK POINTER IN XR
       EXI                   RETURN WITH BUFFER RESULT
       ENP                   END PROCEDURE GTSTG
.FI
GTSTG  PRC  N,1              ENTRY POINT
       MOV  (XS)+,XR         LOAD ARGUMENT, POP STACK
       BEQ  (XR),=B_SCL,GTS30 JUMP IF ALREADY A STRING
GTS01  MOV  XR,-(XS)         RESTACK ARGUMENT IN CASE ERROR
       MOV  XL,-(XS)         SAVE XL
       MOV  WB,GTSVB         SAVE WB
       MOV  WC,GTSVC         SAVE WC
       MOV  (XR),WA          LOAD FIRST WORD OF BLOCK
       BEQ  WA,=B_ICL,GTS05  JUMP TO CONVERT INTEGER
.IF    .CNRA
.ELSE
       BEQ  WA,=B_RCL,GTS10  JUMP TO CONVERT REAL
.FI
       BEQ  WA,=B_NML,GTS03  JUMP TO CONVERT NAME
.IF    .CNBF
.ELSE
       BEQ  WA,=B_BCT,GTS32  JUMP TO CONVERT BUFFER
.FI
GTS02  MOV  (XS)+,XL         RESTORE XL
       MOV  (XS)+,XR         RELOAD INPUT ARGUMENT
       EXI  1                TAKE CONVERT ERROR EXIT
GTS03  MOV  NMBAS(XR),XL     LOAD NAME BASE
       BHI  XL,STATE,GTS02   ERROR IF NOT NATURAL VAR (STATIC)
       ADD  *VRSOF,XL        ELSE POINT TO POSSIBLE STRING NAME
       MOV  SCLEN(XL),WA     LOAD LENGTH
       BNZ  WA,GTS04         JUMP IF NOT SYSTEM VARIABLE
       MOV  VRSVO(XL),XL     ELSE POINT TO SVBLK
       MOV  SVLEN(XL),WA     AND LOAD NAME LENGTH
GTS04  ZER  WB               SET OFFSET TO ZERO
       JSR  SBSTR            USE SBSTR TO COPY STRING
       BRN  GTS29            JUMP TO EXIT
GTS05  LDI  ICVAL(XR)        LOAD INTEGER VALUE
.IF    .CNCI
       JSR  SYSCI            CONVERT INTEGER
       MOV  SCLEN(XL),WA     GET LENGTH
       ZER  WB               ZERO OFFSET FOR SBSTR
       JSR  SBSTR            COPY IN RESULT FROM SYSCI
       BRN  GTS29            EXIT
.ELSE
       MOV  =NUM01,GTSSF     SET SIGN FLAG NEGATIVE
       ILT  GTS06            SKIP IF INTEGER IS NEGATIVE
       NGI                   ELSE NEGATE INTEGER
       ZER  GTSSF            AND RESET NEGATIVE FLAG
GTS06  MOV  GTSWK,XR         POINT TO RESULT WORK AREA
       MOV  =NSTMX,WB        INITIALIZE COUNTER TO MAX LENGTH
       PSC  XR,WB            PREPARE TO STORE (RIGHT-LEFT)
GTS07  CVD                   CONVERT ONE DIGIT INTO WA
       SCH  WA,-(XR)         STORE IN WORK AREA
       DCV  WB               DECREMENT COUNTER
       INE  GTS07            LOOP IF MORE DIGITS TO GO
       CSC  XR               COMPLETE STORE CHARACTERS
.FI
GTS08  MOV  =NSTMX,WA        GET MAX NUMBER OF CHARACTERS
       SUB  WB,WA            COMPUTE LENGTH OF RESULT
       MOV  WA,XL            REMEMBER LENGTH FOR MOVE LATER ON
       ADD  GTSSF,WA         ADD ONE FOR NEGATIVE SIGN IF NEEDED
       JSR  ALOCS            ALLOCATE STRING FOR RESULT
       MOV  XR,WC            SAVE RESULT POINTER FOR THE MOMENT
       PSC  XR               POINT TO CHARS OF RESULT BLOCK
       BZE  GTSSF,GTS09      SKIP IF POSITIVE
       MOV  =CH_MN,WA        ELSE LOAD NEGATIVE SIGN
       SCH  WA,(XR)+         AND STORE IT
       CSC  XR               COMPLETE STORE CHARACTERS
GTS09  MOV  XL,WA            RECALL LENGTH TO MOVE
       MOV  GTSWK,XL         POINT TO RESULT WORK AREA
       PLC  XL,WB            POINT TO FIRST RESULT CHARACTER
       MVC                   MOVE CHARS TO RESULT STRING
       MOV  WC,XR            RESTORE RESULT POINTER
.IF    .CNRA
.ELSE
       BRN  GTS29            JUMP TO EXIT
GTS10  LDR  RCVAL(XR)        LOAD REAL
.IF    .CNCR
       MOV  =NSTMR,WA        MAX NUMBER OF RESULT CHARS
       ZER  XL               CLEAR DUD VALUE
       JSR  ALOCS            ALLOCATE RESULT AREA
       MOV  =CFP_S,WA        SIGNIFICANT DIGITS TO PRODUCE
       ZER  WB               CONVERSION TYPE
       JSR  SYSCR            CONVERT REAL TO STRING
       MOV  WA,SCLEN(XR)     STORE RESULT SIZE
       ZER  WB               NO TRAILING BLANKS TO REMOVE
       JSR  TRIMR            DISCARD EXCESS MEMORY
.ELSE
       ZER  GTSSF            RESET NEGATIVE FLAG
       REQ  GTS31            SKIP IF ZERO
       RGE  GTS11            JUMP IF REAL IS POSITIVE
       MOV  =NUM01,GTSSF     ELSE SET NEGATIVE FLAG
       NGR                   AND GET ABSOLUTE VALUE OF REAL
GTS11  LDI  INTV0            INITIALIZE EXPONENT TO ZERO
GTS12  STR  GTSRS            SAVE REAL VALUE
       SBR  REAP1            SUBTRACT 0.1 TO COMPARE
       RGE  GTS13            JUMP IF SCALE UP NOT REQUIRED
       LDR  GTSRS            ELSE RELOAD VALUE
       MLR  REATT            MULTIPLY BY 10**10
       SBI  INTVT            DECREMENT EXPONENT BY 10
       BRN  GTS12            LOOP BACK TO TEST AGAIN
GTS13  LDR  GTSRS            RELOAD VALUE
       SBR  REAV1            SUBTRACT 1.0
       RLT  GTS17            JUMP IF NO SCALE DOWN REQUIRED
       LDR  GTSRS            ELSE RELOAD VALUE
GTS14  SBR  REATT            SUBTRACT 10**10 TO COMPARE
       RLT  GTS15            JUMP IF LARGE STEP NOT REQUIRED
       LDR  GTSRS            ELSE RESTORE VALUE
       DVR  REATT            DIVIDE BY 10**10
       STR  GTSRS            STORE NEW VALUE
       ADI  INTVT            INCREMENT EXPONENT BY 10
       BRN  GTS14            LOOP BACK
GTS15  MOV  =REAV1,XR        POINT TO POWERS OF TEN TABLE
GTS16  LDR  GTSRS            RELOAD VALUE
       ADI  INTV1            INCREMENT EXPONENT
       ADD  *CFP_R,XR        POINT TO NEXT ENTRY IN TABLE
       SBR  (XR)             SUBTRACT IT TO COMPARE
       RGE  GTS16            LOOP TILL WE FIND A LARGER ENTRY
       LDR  GTSRS            THEN RELOAD THE VALUE
       DVR  (XR)             AND COMPLETE SCALING
       STR  GTSRS            STORE VALUE
GTS17  LDR  GTSRS            GET VALUE AGAIN
       ADR  GTSRN            ADD ROUNDING FACTOR
       STR  GTSRS            STORE RESULT
       SBR  REAV1            SUBTRACT 1.0 TO COMPARE
       RLT  GTS18            SKIP IF OK
       ADI  INTV1            ELSE INCREMENT EXPONENT
       LDR  GTSRS            RELOAD VALUE
       DVR  REAVT            DIVIDE BY 10.0 TO RESCALE
       BRN  GTS19            JUMP TO MERGE
GTS18  LDR  GTSRS            RELOAD ROUNDED VALUE
GTS19  MOV  =CFP_S,XL        SET NUM DEC DIGITS = CFP_S
       MOV  =CH_MN,GTSES     SET EXPONENT SIGN NEGATIVE
       ILT  GTS21            ALL SET IF EXPONENT IS NEGATIVE
       MFI  WA               ELSE FETCH EXPONENT
       BLE  WA,=CFP_S,GTS20  SKIP IF WE CAN USE SPECIAL FORMAT
       MTI  WA               ELSE RESTORE EXPONENT
       NGI                   SET NEGATIVE FOR CVD
       MOV  =CH_PL,GTSES     SET PLUS SIGN FOR EXPONENT SIGN
       BRN  GTS21            JUMP TO GENERATE EXPONENT
GTS20  SUB  WA,XL            COMPUTE DIGITS AFTER DECIMAL POINT
       LDI  INTV0            RESET EXPONENT TO ZERO
GTS21  MOV  GTSWK,XR         POINT TO WORK AREA
       MOV  =NSTMX,WB        SET CHARACTER CTR TO MAX LENGTH
       PSC  XR,WB            PREPARE TO STORE (RIGHT TO LEFT)
       IEQ  GTS23            SKIP EXPONENT IF IT IS ZERO
GTS22  CVD                   CONVERT A DIGIT INTO WA
       SCH  WA,-(XR)         STORE IN WORK AREA
       DCV  WB               DECREMENT COUNTER
       INE  GTS22            LOOP BACK IF MORE DIGITS TO GO
       MOV  GTSES,WA         LOAD EXPONENT SIGN
       SCH  WA,-(XR)         STORE IN WORK AREA
       MOV  =CH_LE,WA        GET CHARACTER LETTER E
       SCH  WA,-(XR)         STORE IN WORK AREA
       SUB  =NUM02,WB        DECREMENT COUNTER FOR SIGN AND E
GTS23  MLR  GTSSC            CONVERT REAL TO INTEGER (10**CFP_S)
       RTI                   GET INTEGER (OVERFLOW IMPOSSIBLE)
       NGI                   NEGATE AS REQUIRED BY CVD
GTS24  BZE  XL,GTS27         JUMP IF NO DIGITS LEFT TO DO
       CVD                   ELSE CONVERT ONE DIGIT
       BNE  WA,=CH_D0,GTS26  JUMP IF NOT A ZERO
       DCV  XL               DECREMENT COUNTER
       BRN  GTS24            LOOP BACK FOR NEXT DIGIT
GTS25  CVD                   CONVERT A DIGIT INTO WA
GTS26  SCH  WA,-(XR)         STORE DIGIT
       DCV  WB               DECREMENT COUNTER
       DCV  XL               DECREMENT COUNTER
       BNZ  XL,GTS25         LOOP BACK IF MORE TO GO
GTS27  MOV  =CH_DT,WA        LOAD DECIMAL POINT
       SCH  WA,-(XR)         STORE IN WORK AREA
       DCV  WB               DECREMENT COUNTER
GTS28  CVD                   CONVERT A DIGIT INTO WA
       SCH  WA,-(XR)         STORE IN WORK AREA
       DCV  WB               DECREMENT COUNTER
       INE  GTS28            LOOP BACK IF MORE TO GO
       CSC  XR               COMPLETE STORE CHARACTERS
       BRN  GTS08            ELSE JUMP BACK TO EXIT
.FI
.FI
GTS29  MOV  (XS)+,XL         RESTORE XL
       ICA  XS               POP ARGUMENT
       MOV  GTSVB,WB         RESTORE WB
       MOV  GTSVC,WC         RESTORE WC
GTS30  MOV  SCLEN(XR),WA     LOAD STRING LENGTH
       EXI                   RETURN TO CALLER
.IF    .CNRA
.ELSE
GTS31  MOV  =SCRE0,XL        POINT TO STRING
       MOV  =NUM02,WA        2 CHARS
       ZER  WB               ZERO OFFSET
       JSR  SBSTR            COPY STRING
       BRN  GTS29            RETURN
.FI
.IF    .CNBF
.ELSE
GTS32  MOV  XR,XL            COPY ARG PTR
       MOV  BCLEN(XL),WA     GET SIZE TO ALLOCATE
       BZE  WA,GTS33         IF NULL THEN RETURN NULL
       JSR  ALOCS            ALLOCATE STRING FRAME
       MOV  XR,WB            SAVE STRING PTR
       MOV  SCLEN(XR),WA     GET LENGTH TO MOVE
       CTB  WA,0             GET AS MULTIPLE OF WORD SIZE
       MOV  BCBUF(XL),XL     POINT TO BFBLK
       ADD  *SCSI_,XR        POINT TO START OF CHARACTER AREA
       ADD  *BFSI_,XL        POINT TO START OF BUFFER CHARS
       MVW                   COPY WORDS
       MOV  WB,XR            RESTORE SCBLK PTR
       BRN  GTS29            EXIT WITH SCBLK
GTS33  MOV  =NULLS,XR        POINT TO NULL
       BRN  GTS29            EXIT WITH NULL
.FI
       ENP                   END PROCEDURE GTSTG
GTVAR  PRC  E,1              ENTRY POINT
       BNE  (XR),=B_NML,GTVR2 JUMP IF NOT A NAME
       MOV  NMOFS(XR),WA     ELSE LOAD NAME OFFSET
       MOV  NMBAS(XR),XL     LOAD NAME BASE
       BEQ  (XL),=B_EVT,GTVR1 ERROR IF EXPRESSION VARIABLE
       BNE  (XL),=B_KVT,GTVR3 ALL OK IF NOT KEYWORD VARIABLE
GTVR1  EXI  1                TAKE CONVERT ERROR EXIT
GTVR2  MOV  WC,GTVRC         SAVE WC
       JSR  GTNVR            LOCATE VRBLK IF POSSIBLE
       PPM  GTVR1            JUMP IF CONVERT ERROR
       MOV  XR,XL            ELSE COPY VRBLK NAME BASE
       MOV  *VRVAL,WA        AND SET OFFSET
       MOV  GTVRC,WC         RESTORE WC
GTVR3  BHI  XL,STATE,GTVR4   ALL OK IF NOT NATURAL VARIABLE
       BEQ  VRSTO(XL),=B_VRE,GTVR1 ERROR IF PROTECTED VARIABLE
GTVR4  EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE GTVAR
HASHS  PRC  E,0              ENTRY POINT
       MOV  SCLEN(XR),WC     LOAD STRING LENGTH IN CHARACTERS
       MOV  WC,WB            INITIALIZE WITH LENGTH
       BZE  WC,HSHS3         JUMP IF NULL STRING
       ZGB  WB               CORRECT BYTE ORDERING IF NECESSARY
       CTW  WC,0             GET NUMBER OF WORDS OF CHARS
       ADD  *SCHAR,XR        POINT TO CHARACTERS OF STRING
       BLO  WC,=E_HNW,HSHS1  USE WHOLE STRING IF SHORT
       MOV  =E_HNW,WC        ELSE SET TO INVOLVE FIRST E_HNW WDS
HSHS1  LCT  WC,WC            SET COUNTER TO CONTROL LOOP
HSHS2  XOB  (XR)+,WB         EXCLUSIVE OR NEXT WORD OF CHARS
       BCT  WC,HSHS2         LOOP TILL ALL PROCESSED
HSHS3  ZGB  WB               ZEROISE UNDEFINED BITS
       ANB  BITSM,WB         ENSURE IN RANGE 0 TO CFP_M
       MTI  WB               MOVE RESULT AS INTEGER
       ZER  XR               CLEAR GARBAGE VALUE IN XR
       EXI                   RETURN TO HASHS CALLER
       ENP                   END PROCEDURE HASHS
ICBLD  PRC  E,0              ENTRY POINT
       MFI  XR,ICBL1         COPY SMALL INTEGERS
       BLE  XR,=NUM02,ICBL3  JUMP IF 0,1 OR 2
ICBL1  MOV  DNAMP,XR         LOAD POINTER TO NEXT AVAILABLE LOC
       ADD  *ICSI_,XR        POINT PAST NEW ICBLK
       BLO  XR,DNAME,ICBL2   JUMP IF THERE IS ROOM
       MOV  *ICSI_,WA        ELSE LOAD LENGTH OF ICBLK
       JSR  ALLOC            USE STANDARD ALLOCATOR TO GET BLOCK
       ADD  WA,XR            POINT PAST BLOCK TO MERGE
ICBL2  MOV  XR,DNAMP         SET NEW POINTER
       SUB  *ICSI_,XR        POINT BACK TO START OF BLOCK
       MOV  =B_ICL,(XR)      STORE TYPE WORD
       STI  ICVAL(XR)        STORE INTEGER VALUE IN ICBLK
       EXI                   RETURN TO ICBLD CALLER
ICBL3  WTB  XR               CONVERT INTEGER TO OFFSET
       MOV  INTAB(XR),XR     POINT TO PRE-BUILT ICBLK
       EXI                   RETURN
       ENP                   END PROCEDURE ICBLD
IDENT  PRC  E,1              ENTRY POINT
       BEQ  XR,XL,IDEN7      JUMP IF SAME POINTER (IDENT)
       MOV  (XR),WC          ELSE LOAD ARG 1 TYPE WORD
.IF    .CNBF
       BNE  WC,(XL),IDEN1    DIFFER IF ARG 2 TYPE WORD DIFFER
.ELSE
       BNE  WC,(XL),IDEN0    DIFFER IF ARG 2 TYPE WORD DIFFER
.FI
       BEQ  WC,=B_SCL,IDEN2  JUMP IF STRINGS
       BEQ  WC,=B_ICL,IDEN4  JUMP IF INTEGERS
.IF    .CNRA
.ELSE
       BEQ  WC,=B_RCL,IDEN5  JUMP IF REALS
.FI
       BEQ  WC,=B_NML,IDEN6  JUMP IF NAMES
.IF    .CNBF
.ELSE
       BNE  WC,=B_BCT,IDEN1  JUMP IF NOT BUFFERS
       MOV  BCLEN(XR),WC     LOAD ARG 1 LENGTH
       BNE  WC,BCLEN(XL),IDEN1 DIFFER IF LENGTHS DIFFER
       BZE  WC,IDEN7         IDENTICAL IF LENGTH 0
       MOV  BCBUF(XR),XR     ARG 1 BUFFER BLOCK
       MOV  BCBUF(XL),XL     ARG 2 BUFFER BLOCK
       BRN  IDN2A            COMPARE CHARACTERS
IDEN0  BEQ  WC,=B_SCL,IDN0A  JUMP IF ARG 1 IS A STRING
       BNE  WC,=B_BCT,IDEN1  JUMP IF ARG 1 NOT STRING OR BUFFER
       BNE  (XL),=B_SCL,IDEN1 JUMP IF ARG 2 IS NOT STRING
       MOV  BCLEN(XR),WC     LOAD ARG 1 LENGTH
       BNE  WC,SCLEN(XL),IDEN1 DIFFER IF LENGTHS DIFFER
       BZE  WC,IDEN7         IDENTICAL IF LENGTH 0
       MOV  BCBUF(XR),XR     ARG 1 BUFFER BLOCK
       BRN  IDN2A            COMPARE CHARACTERS
IDN0A  BNE  (XL),=B_BCT,IDEN1 JUMP IF ARG 2 IS NOT BUFFER
       MOV  SCLEN(XR),WC     LOAD ARG 1 LENGTH
       BNE  WC,BCLEN(XL),IDEN1 DIFFER IF LENGTHS DIFFER
       BZE  WC,IDEN7         IDENTICAL IF LENGTH 0
       MOV  BCBUF(XL),XL     ARG 2 BUFFER BLOCK
       BRN  IDN2A            COMPARE CHARACTERS
.FI
IDEN1  EXI                   TAKE DIFFER EXIT
IDEN2  MOV  SCLEN(XR),WC     LOAD ARG 1 LENGTH
       BNE  WC,SCLEN(XL),IDEN1 DIFFER IF LENGTHS DIFFER
IDN2A  ADD  *SCHAR,XR        POINT TO CHARS OF ARG 1
       ADD  *SCHAR,XL        POINT TO CHARS OF ARG 2
       CTW  WC,0             GET NUMBER OF WORDS IN STRINGS
       LCT  WC,WC            SET LOOP COUNTER
IDEN3  CNE  (XR),(XL),IDEN8  DIFFER IF CHARS DO NOT MATCH
       ICA  XR               ELSE BUMP ARG ONE POINTER
       ICA  XL               BUMP ARG TWO POINTER
       BCT  WC,IDEN3         LOOP BACK TILL ALL CHECKED
       ZER  XL               CLEAR GARBAGE VALUE IN XL
       ZER  XR               CLEAR GARBAGE VALUE IN XR
       EXI  1                TAKE IDENT EXIT
IDEN4  LDI  ICVAL(XR)        LOAD ARG 1
       SBI  ICVAL(XL)        SUBTRACT ARG 2 TO COMPARE
       IOV  IDEN1            DIFFER IF OVERFLOW
       INE  IDEN1            DIFFER IF RESULT IS NOT ZERO
       EXI  1                TAKE IDENT EXIT
.IF    .CNRA
.ELSE
IDEN5  LDR  RCVAL(XR)        LOAD ARG 1
       SBR  RCVAL(XL)        SUBTRACT ARG 2 TO COMPARE
       ROV  IDEN1            DIFFER IF OVERFLOW
       RNE  IDEN1            DIFFER IF RESULT IS NOT ZERO
       EXI  1                TAKE IDENT EXIT
.FI
IDEN6  BNE  NMOFS(XR),NMOFS(XL),IDEN1 DIFFER IF DIFFERENT OFFSET
       BNE  NMBAS(XR),NMBAS(XL),IDEN1 DIFFER IF DIFFERENT BASE
IDEN7  EXI  1                TAKE IDENT EXIT
IDEN8  ZER  XR               CLEAR GARBAGE PTR IN XR
       ZER  XL               CLEAR GARBAGE PTR IN XL
       EXI                   RETURN TO CALLER (DIFFER)
       ENP                   END PROCEDURE IDENT
INOUT  PRC  E,0              ENTRY POINT
       MOV  WB,-(XS)         STACK TRBLK TYPE
       MOV  SCLEN(XL),WA     GET NAME LENGTH
       ZER  WB               POINT TO START OF NAME
       JSR  SBSTR            BUILD A PROPER SCBLK
       JSR  GTNVR            BUILD VRBLK
       PPM                   NO ERROR RETURN
       MOV  XR,WC            SAVE VRBLK POINTER
       MOV  (XS)+,WB         GET TRTER FIELD
       ZER  XL               ZERO TRFPT
       JSR  TRBLD            BUILD TRBLK
       MOV  WC,XL            RECALL VRBLK POINTER
       MOV  VRSVP(XL),TRTER(XR) STORE SVBLK POINTER
       MOV  XR,VRVAL(XL)     STORE TRBLK PTR IN VRBLK
       MOV  =B_VRA,VRGET(XL) SET TRAPPED ACCESS
       MOV  =B_VRV,VRSTO(XL) SET TRAPPED STORE
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE INOUT
.IF    .CNBF
.ELSE
INSBF  PRC  E,2              ENTRY POINT
       MOV  WA,INSSA         SAVE ENTRY WA
       MOV  WB,INSSB         SAVE ENTRY WB
       MOV  WC,INSSC         SAVE ENTRY WC
       ADD  WB,WA            ADD TO GET OFFSET PAST REPLACE PART
       MOV  WA,INSAB         SAVE WA+WB
       MOV  BCLEN(XR),WC     GET CURRENT DEFINED LENGTH
       BGT  INSSA,WC,INS07   FAIL IF START OFFSET TOO BIG
       BGT  WA,WC,INS07      FAIL IF FINAL OFFSET TOO BIG
       MOV  XL,-(XS)         SAVE ENTRY XL
       MOV  XR,-(XS)         SAVE BCBLK PTR
       MOV  XL,-(XS)         STACK AGAIN FOR GTSTG OR GTSTB
       BEQ  XR,XL,INS08      B IF INSERTING SAME BUFFER
       JSR  GTSTB            CALL TO GET STRING OR BUFFER
       PPM  INS05            TAKE STRING CONVERT ERR EXIT
INS09  MOV  XR,XL            SAVE STRING PTR
       MOV  WA,INSLN         SAVE ITS LENGTH
       MOV  (XS),XR          RESTORE BCBLK PTR
       ADD  WC,WA            ADD BUFFER LEN TO STRING LEN
       SUB  INSSB,WA         BIAS OUT COMPONENT BEING REPLACED
       MOV  BCBUF(XR),XR     POINT TO BFBLK
       BGT  WA,BFALC(XR),INS06 FAIL IF RESULT EXCEEDS ALLOCATION
       MOV  (XS),XR          RESTORE BCBLK PTR
       MOV  WC,WA            GET BUFFER LENGTH
       SUB  INSAB,WA         SUBTRACT TO GET SHIFT LENGTH
       ADD  INSLN,WC         ADD LENGTH OF NEW
       SUB  INSSB,WC         SUBTRACT OLD TO GET TOTAL NEW LEN
       MOV  BCLEN(XR),WB     GET OLD BCLEN
       MOV  WC,BCLEN(XR)     STUFF NEW LENGTH
       BZE  WA,INS04         SKIP SHIFT IF NOTHING TO DO
       BEQ  INSSB,INSLN,INS04 SKIP SHIFT IF LENGTHS MATCH
       MOV  BCBUF(XR),XR     POINT TO BFBLK
       MOV  XL,-(XS)         SAVE SCBLK PTR
       BLO  INSSB,INSLN,INS01 BRN IF SHIFT IS FOR MORE ROOM
       MOV  INSSA,WB         GET OFFSET TO INSERT
       ADD  INSLN,WB         ADD INSERT LENGTH TO GET DEST OFF
       MOV  XR,XL            MAKE COPY
       PLC  XL,INSAB         PREPARE SOURCE FOR MOVE
       PSC  XR,WB            PREPARE DESTINATION REG FOR MOVE
       MVC                   MOVE EM OUT
       BRN  INS02            BRANCH TO PAD
INS01  MOV  XR,XL            COPY BFBLK PTR
       PLC  XL,WB            SET SOURCE REG FOR MOVE BACKWARDS
       PSC  XR,WC            SET DESTINATION PTR FOR MOVE
       MCB                   MOVE BACKWARDS (POSSIBLE OVERLAP)
INS02  MOV  (XS)+,XL         RESTORE SCBLK OR BFBLK PTR
       MOV  WC,WA            COPY NEW BUFFER END
       CTB  WA,0             ROUND OUT
       SUB  WC,WA            SUBTRACT TO GET REMAINDER
       BZE  WA,INS04         NO PAD IF ALREADY EVEN BOUNDARY
       MOV  (XS),XR          GET BCBLK PTR
       MOV  BCBUF(XR),XR     GET BFBLK PTR
       PSC  XR,WC            PREPARE TO PAD
       ZER  WB               CLEAR WB
       LCT  WA,WA            LOAD LOOP COUNT
INS03  SCH  WB,(XR)+         STUFF ZERO PAD
       BCT  WA,INS03         BRANCH FOR MORE
       CSC  XR               COMPLETE STORE CHARACTER
INS04  MOV  INSLN,WA         GET INSERT LENGTH
       BZE  WA,INS4B         IF NOTHING TO INSERT
       MOV  (XS),XR          GET BCBLK PTR
       MOV  BCBUF(XR),XR     GET BFBLK PTR
       PLC  XL               PREPARE TO COPY FROM FIRST CHAR
       PSC  XR,INSSA         PREPARE TO STORE IN HOLE
       MVC                   COPY THE CHARACTERS
INS4B  MOV  (XS)+,XR         RESTORE ENTRY XR
       MOV  (XS)+,XL         RESTORE ENTRY XL
       MOV  INSSA,WA         RESTORE ENTRY WA
       MOV  INSSB,WB         RESTORE ENTRY WB
       MOV  INSSC,WC         RESTORE ENTRY WC
       EXI                   RETURN TO CALLER
INS05  MOV  (XS)+,XR         RESTORE ENTRY XR
       MOV  (XS)+,XL         RESTORE ENTRY XL
       MOV  INSSA,WA         RESTORE ENTRY WA
       MOV  INSSB,WB         RESTORE ENTRY WB
       MOV  INSSC,WC         RESTORE ENTRY WC
       EXI  1                ALTERNATE EXIT
INS06  MOV  (XS)+,XR         RESTORE ENTRY XR
       MOV  (XS)+,XL         RESTORE ENTRY XL
INS07  MOV  INSSA,WA         RESTORE ENTRY WA
       MOV  INSSB,WB         RESTORE ENTRY WB
       MOV  INSSC,WC         RESTORE ENTRY WC
       EXI  2                ALTERNATE EXIT
INS08  JSR  GTSTG            CALL TO GET STRING
       PPM  INS05            TAKE STRING CONVERT ERR EXIT
       BRN  INS09            MERGE BACK TO PERFORM INSERTION
       ENP                   END PROCEDURE INSBF
.FI
INSTA  PRC  E,0              ENTRY POINT
       MOV  PRLEN,WC         NO. OF CHARS IN PRINT BFR
       MOV  XR,PRBUF         PRINT BFR IS PUT AT STATIC START
       MOV  =B_SCL,(XR)+     STORE STRING TYPE CODE
       MOV  WC,(XR)+         AND STRING LENGTH
       CTW  WC,0             GET NUMBER OF WORDS IN BUFFER
       MOV  WC,PRLNW         STORE FOR BUFFER CLEAR
       LCT  WC,WC            WORDS TO CLEAR
INST1  MOV  NULLW,(XR)+      STORE BLANK
       BCT  WC,INST1         LOOP
       MOV  =NSTMX,WA        GET MAX NUM CHARS IN OUTPUT NUMBER
       CTB  WA,SCSI_         NO OF BYTES NEEDED
       MOV  XR,GTSWK         STORE BFR ADRS
       ADD  WA,XR            BUMP FOR WORK BFR
       MOV  XR,KVALP         SAVE ALPHABET POINTER
       MOV  =B_SCL,(XR)      STRING BLK TYPE
       MOV  =CFP_A,WC        NO OF CHARS IN ALPHABET
       MOV  WC,SCLEN(XR)     STORE AS STRING LENGTH
       MOV  WC,WB            COPY CHAR COUNT
       CTB  WB,SCSI_         NO. OF BYTES NEEDED
       ADD  XR,WB            CURRENT END ADDRESS FOR STATIC
       MOV  WB,WA            SAVE ADRS PAST ALPHABET STRING
       LCT  WC,WC            LOOP COUNTER
       PSC  XR               POINT TO CHARS OF STRING
       ZER  WB               SET INITIAL CHARACTER VALUE
INST2  SCH  WB,(XR)+         STORE NEXT CODE
       ICV  WB               BUMP CODE VALUE
       BCT  WC,INST2         LOOP TILL ALL STORED
       CSC  XR               COMPLETE STORE CHARACTERS
       MOV  WA,XR            RETURN CURRENT STATIC PTR
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE INSTA
IOFCB  PRC  N,3              ENTRY POINT
       JSR  GTSTG            GET ARG AS STRING
       PPM  IOFC2            FAIL
       MOV  XR,XL            COPY STRING PTR
       JSR  GTNVR            GET AS NATURAL VARIABLE
       PPM  IOFC3            FAIL IF NULL
       MOV  XL,WB            COPY STRING POINTER AGAIN
       MOV  XR,XL            COPY VRBLK PTR FOR RETURN
       ZER  WA               IN CASE NO TRBLK FOUND
IOFC1  MOV  VRVAL(XR),XR     GET POSSIBLE TRBLK PTR
       BNE  (XR),=B_TRT,IOFC4 FAIL IF END OF CHAIN
       BNE  TRTYP(XR),=TRTFC,IOFC1 LOOP IF NOT FILE ARG TRBLK
       MOV  TRFPT(XR),WA     GET FCBLK PTR
       MOV  WB,XR            COPY ARG
       EXI                   RETURN
IOFC2  EXI  1                FAIL
IOFC3  EXI  2                NULL ARG RETURN
IOFC4  EXI  3                FILE NOT FOUND RETURN
       ENP                   END PROCEDURE IOFCB
IOPPF  PRC  N,0              ENTRY POINT
       ZER  WB               TO COUNT FIELDS EXTRACTED
IOPP1  MOV  =IODEL,XL        GET DELIMITER
       MOV  XL,WC            COPY IT
       ZER  WA               RETAIN LEADING BLANKS IN FILEARG2
       JSR  XSCAN            GET NEXT FIELD
       MOV  XR,-(XS)         STACK IT
       ICV  WB               INCREMENT COUNT
       BNZ  WA,IOPP1         LOOP
       MOV  WB,WC            COUNT OF FIELDS
       MOV  IOPTT,WB         I/O MARKER
       MOV  R_IOF,WA         FCBLK PTR OR 0
       MOV  R_IO2,XR         FILE ARG2 PTR
       MOV  R_IO1,XL         FILEARG1
       EXI                   RETURN
       ENP                   END PROCEDURE IOPPF
IOPUT  PRC  N,7              ENTRY POINT
       ZER  R_IOT            IN CASE NO TRTRF BLOCK USED
       ZER  R_IOF            IN CASE NO FCBLK ALOCATED
       ZER  R_IOP            IN CASE SYSIO FAILS
       MOV  WB,IOPTT         STORE I/O TRACE TYPE
       JSR  XSCNI            PREPARE TO SCAN FILEARG2
       PPM  IOP13            FAIL
       PPM  IOPA0            NULL FILE ARG2
IOPA0  MOV  XR,R_IO2         KEEP FILE ARG2
       MOV  WA,XL            COPY LENGTH
       JSR  GTSTG            CONVERT FILEARG1 TO STRING
       PPM  IOP14            FAIL
       MOV  XR,R_IO1         KEEP FILEARG1 PTR
       JSR  GTNVR            CONVERT TO NATURAL VARIABLE
       PPM  IOP00            JUMP IF NULL
       BRN  IOP04            JUMP TO PROCESS NON-NULL ARGS
IOP00  BZE  XL,IOP01         SKIP IF BOTH ARGS NULL
       JSR  IOPPF            PROCESS FILEARG2
       JSR  SYSFC            CALL FOR FILEARG2 CHECK
       PPM  IOP16            FAIL
       PPM  IOP26            FAIL
       BRN  IOP11            COMPLETE FILE ASSOCIATION
IOP01  MOV  IOPTT,WB         GET TRACE TYPE
       MOV  R_IOT,XR         GET 0 OR TRTRF PTR
       JSR  TRBLD            BUILD TRBLK
       MOV  XR,WC            COPY TRBLK POINTER
       MOV  (XS)+,XR         GET VARIABLE FROM STACK
       MOV  WC,-(XS)         MAKE TRBLK COLLECTABLE
       JSR  GTVAR            POINT TO VARIABLE
       PPM  IOP15            FAIL
       MOV  (XS)+,WC         RECOVER TRBLK POINTER
       MOV  XL,R_ION         SAVE NAME POINTER
       MOV  XL,XR            COPY NAME POINTER
       ADD  WA,XR            POINT TO VARIABLE
       SUB  *VRVAL,XR        SUBTRACT OFFSET,MERGE INTO LOOP
IOP02  MOV  XR,XL            COPY BLK PTR
       MOV  VRVAL(XR),XR     LOAD PTR TO NEXT TRBLK
       BNE  (XR),=B_TRT,IOP03    JUMP IF NOT TRAPPED
       BNE  TRTYP(XR),IOPTT,IOP02 LOOP IF NOT SAME ASSOCN
       MOV  TRNXT(XR),XR     GET VALUE AND DELETE OLD TRBLK
IOP03  MOV  WC,VRVAL(XL)     LINK TO THIS TRBLK
       MOV  WC,XL            COPY POINTER
       MOV  XR,TRNXT(XL)     STORE VALUE IN TRBLK
       MOV  R_ION,XR         RESTORE POSSIBLE VRBLK POINTER
       MOV  WA,WB            KEEP OFFSET TO NAME
       JSR  SETVR            IF VRBLK, SET VRGET,VRSTO
       MOV  R_IOT,XR         GET 0 OR TRTRF PTR
       BNZ  XR,IOP19         JUMP IF TRTRF BLOCK EXISTS
       EXI                   RETURN TO CALLER
IOP04  ZER  WA               IN CASE NO FCBLK FOUND
IOP05  MOV  XR,WB            REMEMBER BLK PTR
       MOV  VRVAL(XR),XR     CHAIN ALONG
       BNE  (XR),=B_TRT,IOP06 JUMP IF END OF TRBLK CHAIN
       BNE  TRTYP(XR),=TRTFC,IOP05 LOOP IF MORE TO GO
       MOV  XR,R_IOT         POINT TO FILE ARG1 TRBLK
       MOV  TRFPT(XR),WA     GET FCBLK PTR FROM TRBLK
IOP06  MOV  WA,R_IOF         KEEP POSSIBLE FCBLK PTR
       MOV  WB,R_IOP         KEEP PRECEDING BLK PTR
       JSR  IOPPF            PROCESS FILEARG2
       JSR  SYSFC            SEE IF FCBLK REQUIRED
       PPM  IOP16            FAIL
       PPM  IOP26            FAIL
       BZE  WA,IOP12         SKIP IF NO NEW FCBLK WANTED
       BLT  WC,=NUM02,IOP6A  JUMP IF FCBLK IN DYNAMIC
       JSR  ALOST            GET IT IN STATIC
       BRN  IOP6B            SKIP
IOP6A  JSR  ALLOC            GET SPACE FOR FCBLK
IOP6B  MOV  XR,XL            POINT TO FCBLK
       MOV  WA,WB            COPY ITS LENGTH
       BTW  WB               GET COUNT AS WORDS (SGD APR80)
       LCT  WB,WB            LOOP COUNTER
IOP07  ZER  (XR)+            CLEAR A WORD
       BCT  WB,IOP07         LOOP
       BEQ  WC,=NUM02,IOP09  SKIP IF IN STATIC - DONT SET FIELDS
       MOV  =B_XNT,(XL)      STORE XNBLK CODE IN CASE
       MOV  WA,NUM01(XL)     STORE LENGTH
       BNZ  WC,IOP09         JUMP IF XNBLK WANTED
       MOV  =B_XRT,(XL)      XRBLK CODE REQUESTED
IOP09  MOV  R_IOT,XR         GET POSSIBLE TRBLK PTR
       MOV  XL,R_IOF         STORE FCBLK PTR
       BNZ  XR,IOP10         JUMP IF TRBLK ALREADY FOUND
       MOV  =TRTFC,WB        TRTYP FOR FCBLK TRAP BLK
       JSR  TRBLD            MAKE THE BLOCK
       MOV  XR,R_IOT         COPY TRTRF PTR
       MOV  R_IOP,XL         POINT TO PRECEDING BLK
       MOV  VRVAL(XL),VRVAL(XR) COPY VALUE FIELD TO TRBLK
       MOV  XR,VRVAL(XL)     LINK NEW TRBLK INTO CHAIN
       MOV  XL,XR            POINT TO PREDECESSOR BLK
       JSR  SETVR            SET TRACE INTERCEPTS
       MOV  VRVAL(XR),XR     RECOVER TRBLK PTR
       BRN  IOP1A            STORE FCBLK PTR
IOP10  ZER  R_IOP            DO NOT RELEASE IF SYSIO FAILS
IOP1A  MOV  R_IOF,TRFPT(XR)  STORE FCBLK PTR
IOP11  MOV  R_IOF,WA         COPY FCBLK PTR OR 0
       MOV  IOPTT,WB         GET INPUT/OUTPUT FLAG
       MOV  R_IO2,XR         GET FILE ARG2
       MOV  R_IO1,XL         GET FILE ARG1
       JSR  SYSIO            ASSOCIATE TO THE FILE
       PPM  IOP17            FAIL
       PPM  IOP18            FAIL
       BNZ  R_IOT,IOP01      NOT STD INPUT IF NON-NULL TRTRF BLK
       BNZ  IOPTT,IOP01      JUMP IF OUTPUT
       BZE  WC,IOP01         NO CHANGE TO STANDARD READ LENGTH
       MOV  WC,CSWIN         STORE NEW READ LENGTH FOR STD FILE
       BRN  IOP01            MERGE TO FINISH THE TASK
IOP12  BNZ  XL,IOP09         JUMP IF PRIVATE FCBLK
       BRN  IOP11            FINISH THE ASSOCIATION
IOP13  EXI  1                3RD ARG NOT A STRING
IOP14  EXI  2                2ND ARG UNSUITABLE
IOP15  ICA  XS               DISCARD TRBLK POINTER
       EXI  3                1ST ARG UNSUITABLE
IOP16  EXI  4                FILE SPEC WRONG
IOP26  EXI  7                FCBLK IN USE
IOP17  MOV  R_IOP,XR         IS THERE A TRBLK TO RELEASE
       BZE  XR,IOPA7         IF NOT
       MOV  VRVAL(XR),XL     POINT TO TRBLK
       MOV  VRVAL(XL),VRVAL(XR) UNSPLICE IT
       JSR  SETVR            ADJUST TRACE INTERCEPTS
IOPA7  EXI  5                I/O FILE DOES NOT EXIST
IOP18  MOV  R_IOP,XR         IS THERE A TRBLK TO RELEASE
       BZE  XR,IOPA7         IF NOT
       MOV  VRVAL(XR),XL     POINT TO TRBLK
       MOV  VRVAL(XL),VRVAL(XR) UNSPLICE IT
       JSR  SETVR            ADJUST TRACE INTERCEPTS
IOPA8  EXI  6                I/O FILE CANNOT BE READ/WRITTEN
IOP19  MOV  R_ION,WC         WC = NAME BASE, WB = NAME OFFSET
IOP20  MOV  TRTRF(XR),XR     NEXT LINK OF CHAIN
       BZE  XR,IOP21         NOT FOUND
       BNE  WC,IONMB(XR),IOP20 NO MATCH
       BEQ  WB,IONMO(XR),IOP22 EXIT IF MATCHED
       BRN  IOP20            LOOP
IOP21  MOV  *NUM05,WA        SPACE NEEDED
       JSR  ALLOC            GET IT
       MOV  =B_XRT,(XR)      STORE XRBLK CODE
       MOV  WA,NUM01(XR)     STORE LENGTH
       MOV  WC,IONMB(XR)     STORE NAME BASE
       MOV  WB,IONMO(XR)     STORE NAME OFFSET
       MOV  R_IOT,XL         POINT TO TRTRF BLK
       MOV  TRTRF(XL),WA     GET PTR FIELD CONTENTS
       MOV  XR,TRTRF(XL)     STORE PTR TO NEW BLOCK
       MOV  WA,TRTRF(XR)     COMPLETE THE LINKING
IOP22  BZE  R_IOF,IOP25      SKIP IF NO FCBLK
       MOV  R_FCB,XL         PTR TO HEAD OF EXISTING CHAIN
IOP23  BZE  XL,IOP24         NOT ON IF END OF CHAIN
       BEQ  NUM03(XL),R_IOF,IOP25 DONT DUPLICATE IF FIND IT
       MOV  NUM02(XL),XL     GET NEXT LINK
       BRN  IOP23            LOOP
IOP24  MOV  *NUM04,WA        SPACE NEEDED
       JSR  ALLOC            GET IT
       MOV  =B_XRT,(XR)      STORE BLOCK CODE
       MOV  WA,NUM01(XR)     STORE LENGTH
       MOV  R_FCB,NUM02(XR)  STORE PREVIOUS LINK IN THIS NODE
       MOV  R_IOF,NUM03(XR)  STORE FCBLK PTR
       MOV  XR,R_FCB         INSERT NODE INTO FCBLK CHAIN
IOP25  EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE IOPUT
KTREX  PRC  R,0              ENTRY POINT (RECURSIVE)
       BZE  XL,KTRX3         IMMEDIATE EXIT IF KEYWORD UNTRACED
       BZE  KVTRA,KTRX3      IMMEDIATE EXIT IF TRACE = 0
       DCV  KVTRA            ELSE DECREMENT TRACE
       MOV  XR,-(XS)         SAVE XR
       MOV  XL,XR            COPY TRBLK POINTER
       MOV  TRKVR(XR),XL     LOAD VRBLK POINTER (NMBAS)
       MOV  *VRVAL,WA        SET NAME OFFSET
       BZE  TRFNC(XR),KTRX1  JUMP IF PRINT TRACE
       JSR  TRXEQ            ELSE EXECUTE FULL TRACE
       BRN  KTRX2            AND JUMP TO EXIT
KTRX1  MOV  XL,-(XS)         STACK VRBLK PTR FOR KWNAM
       MOV  WA,-(XS)         STACK OFFSET FOR KWNAM
       JSR  PRTSN            PRINT STATEMENT NUMBER
       MOV  =CH_AM,WA        LOAD AMPERSAND
       JSR  PRTCH            PRINT AMPERSAND
       JSR  PRTNM            PRINT KEYWORD NAME
       MOV  =TMBEB,XR        POINT TO BLANK-EQUAL-BLANK
       JSR  PRTST            PRINT BLANK-EQUAL-BLANK
       JSR  KWNAM            GET KEYWORD PSEUDO-VARIABLE NAME
       MOV  XR,DNAMP         RESET PTR TO DELETE KVBLK
       JSR  ACESS            GET KEYWORD VALUE
       PPM                   FAILURE IS IMPOSSIBLE
       JSR  PRTVL            PRINT KEYWORD VALUE
       JSR  PRTNL            TERMINATE PRINT LINE
KTRX2  MOV  (XS)+,XR         RESTORE ENTRY XR
KTRX3  EXI                   RETURN TO KTREX CALLER
       ENP                   END PROCEDURE KTREX
KWNAM  PRC  N,0              ENTRY POINT
       ICA  XS               IGNORE NAME OFFSET
       MOV  (XS)+,XR         LOAD NAME BASE
       BGE  XR,STATE,KWNM1   JUMP IF NOT NATURAL VARIABLE NAME
       BNZ  VRLEN(XR),KWNM1  ERROR IF NOT SYSTEM VARIABLE
       MOV  VRSVP(XR),XR     ELSE POINT TO SVBLK
       MOV  SVBIT(XR),WA     LOAD BIT MASK
       ANB  BTKNM,WA         AND WITH KEYWORD BIT
       ZRB  WA,KWNM1         ERROR IF NO KEYWORD ASSOCIATION
       MOV  SVLEN(XR),WA     ELSE LOAD NAME LENGTH IN CHARACTERS
       CTB  WA,SVCHS         COMPUTE OFFSET TO FIELD WE WANT
       ADD  WA,XR            POINT TO SVKNM FIELD
       MOV  (XR),WB          LOAD SVKNM VALUE
       MOV  *KVSI_,WA        SET SIZE OF KVBLK
       JSR  ALLOC            ALLOCATE KVBLK
       MOV  =B_KVT,(XR)      STORE TYPE WORD
       MOV  WB,KVNUM(XR)     STORE KEYWORD NUMBER
       MOV  =TRBKV,KVVAR(XR) SET DUMMY TRBLK POINTER
       MOV  XR,XL            COPY KVBLK POINTER
       MOV  *KVVAR,WA        SET PROPER OFFSET
       EXI                   RETURN TO KVNAM CALLER
KWNM1  ERB  251,Keyword operand is not name of defined keyword
       ENP                   END PROCEDURE KWNAM
LCOMP  PRC  N,5              ENTRY POINT
.IF    .CNBF
       JSR  GTSTG            CONVERT SECOND ARG TO STRING
.ELSE
       JSR  GTSTB            GET SECOND ARG AS STRING OR BUFFER
.FI
       PPM  LCMP6            JUMP IF SECOND ARG NOT STRING
       MOV  XR,XL            ELSE SAVE POINTER
       MOV  WA,WC            AND LENGTH
.IF    .CNBF
       JSR  GTSTG            CONVERT FIRST ARGUMENT TO STRING
.ELSE
       JSR  GTSTB            GET FIRST ARG AS STRING OR BUFFER
.FI
       PPM  LCMP5            JUMP IF NOT STRING
       MOV  WA,WB            SAVE ARG 1 LENGTH
       PLC  XR               POINT TO CHARS OF ARG 1
       PLC  XL               POINT TO CHARS OF ARG 2
.IF    .CCMC
       MOV  WC,WA            ARG 2 LENGTH TO WA
       JSR  SYSCM            COMPARE (XL,WA=ARG2  XR,WB=ARG1)
       ERR  283,String length exceeded for generalized lexical comparison
       PPM  LCMP4            ARG 2 LT ARG 1, LGT EXIT
       PPM  LCMP3            ARG 2 GT ARG 1, LLT EXIT
       EXI  4                ELSE IDENTICAL STRINGS, LEQ EXIT
.ELSE
       BLO  WA,WC,LCMP1      JUMP IF ARG 1 LENGTH IS SMALLER
       MOV  WC,WA            ELSE SET ARG 2 LENGTH AS SMALLER
LCMP1  BZE  WA,LCMP7         IF NULL STRING, COMPARE LENGTHS
       CMC  LCMP4,LCMP3      COMPARE STRINGS, JUMP IF UNEQUAL
LCMP7  BNE  WB,WC,LCMP2      IF EQUAL, JUMP IF LENGTHS UNEQUAL
       EXI  4                ELSE IDENTICAL STRINGS, LEQ EXIT
LCMP2  BHI  WB,WC,LCMP4      JUMP IF ARG 1 LENGTH GT ARG 2 LENG
.FI
LCMP3  EXI  3                TAKE LLT EXIT
LCMP4  EXI  5                TAKE LGT EXIT
LCMP5  EXI  1                TAKE BAD FIRST ARG EXIT
LCMP6  EXI  2                TAKE BAD SECOND ARG ERROR EXIT
       ENP                   END PROCEDURE LCOMP
.IF    .CINC
.FI
LISTR  PRC  E,0              ENTRY POINT
       BNZ  CNTTL,LIST5      JUMP IF -TITLE OR -STITL
       BNZ  LSTPF,LIST4      IMMEDIATE EXIT IF ALREADY LISTED
       BGE  LSTLC,LSTNP,LIST6 JUMP IF NO ROOM
LIST0  MOV  R_CIM,XR         LOAD POINTER TO CURRENT IMAGE
       BZE  XR,LIST4         JUMP IF NO IMAGE TO PRINT
       PLC  XR               POINT TO CHARACTERS
       LCH  WA,(XR)          LOAD FIRST CHARACTER
       MOV  LSTSN,XR         LOAD STATEMENT NUMBER
       BZE  XR,LIST2         JUMP IF NO STATEMENT NUMBER
       MTI  XR               ELSE GET STMNT NUMBER AS INTEGER
       BNE  STAGE,=STGIC,LIST1 SKIP IF EXECUTE TIME
       BEQ  WA,=CH_AS,LIST2  NO STMNT NUMBER LIST IF COMMENT
       BEQ  WA,=CH_MN,LIST2  NO STMNT NO. IF CONTROL CARD
LIST1  JSR  PRTIN            ELSE PRINT STATEMENT NUMBER
       ZER  LSTSN            AND CLEAR FOR NEXT TIME IN
.IF    .CINC
LIST2  MOV  LSTID,XR         INCLUDE DEPTH OF IMAGE
       BZE  XR,LIST8         IF NOT FROM AN INCLUDE FILE
       MOV  =STNPD,WA        POSITION FOR START OF STATEMENT
       SUB  =NUM03,WA        POSITION TO PLACE INCLUDE DEPTH
       MOV  WA,PROFS         SET AS STARTING POSITION
       MTI  XR               INCLUDE DEPTH AS INTEGER
       JSR  PRTIN            PRINT INCLUDE DEPTH
LIST8  MOV  =STNPD,PROFS     POINT PAST STATEMENT NUMBER
.ELSE
LIST2  MOV  =STNPD,PROFS     POINT PAST STATEMENT NUMBER
.FI
       MOV  R_CIM,XR         LOAD POINTER TO CURRENT IMAGE
       JSR  PRTST            PRINT IT
       ICV  LSTLC            BUMP LINE COUNTER
       BNZ  ERLST,LIST3      JUMP IF ERROR COPY TO INT.CH.
       JSR  PRTNL            TERMINATE LINE
       BZE  CSWDB,LIST3      JUMP IF -SINGLE MODE
       JSR  PRTNL            ELSE ADD A BLANK LINE
       ICV  LSTLC            AND BUMP LINE COUNTER
LIST3  MNZ  LSTPF            SET FLAG FOR LINE PRINTED
LIST4  EXI                   RETURN TO LISTR CALLER
LIST5  ZER  CNTTL            CLEAR FLAG
LIST6  JSR  PRTPS            EJECT
       BZE  PRICH,LIST7      SKIP IF LISTING TO REGULAR PRINTER
       BEQ  R_TTL,=NULLS,LIST0 TERMINAL LISTING OMITS NULL TITLE
LIST7  JSR  LISTT            LIST TITLE
       BRN  LIST0            MERGE
       ENP                   END PROCEDURE LISTR
LISTT  PRC  E,0              ENTRY POINT
       MOV  R_TTL,XR         POINT TO SOURCE LISTING TITLE
       JSR  PRTST            PRINT TITLE
       MOV  LSTPO,PROFS      SET OFFSET
       MOV  =LSTMS,XR        SET PAGE MESSAGE
       JSR  PRTST            PRINT PAGE MESSAGE
       ICV  LSTPG            BUMP PAGE NUMBER
       MTI  LSTPG            LOAD PAGE NUMBER AS INTEGER
       JSR  PRTIN            PRINT PAGE NUMBER
       JSR  PRTNL            TERMINATE TITLE LINE
       ADD  =NUM02,LSTLC     COUNT TITLE LINE AND BLANK LINE
       MOV  R_STL,XR         LOAD POINTER TO SUB-TITLE
       BZE  XR,LSTT1         JUMP IF NO SUB-TITLE
       JSR  PRTST            ELSE PRINT SUB-TITLE
       JSR  PRTNL            TERMINATE LINE
       ICV  LSTLC            BUMP LINE COUNT
LSTT1  JSR  PRTNL            PRINT A BLANK LINE
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE LISTT
.IF    .CSFN
NEWFN  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE NEW NAME
       MOV  R_SFC,XL         LOAD PREVIOUS NAME
       JSR  IDENT            CHECK FOR EQUALITY
       PPM  NWFN1            JUMP IF IDENTICAL
       MOV  (XS)+,XR         DIFFERENT, RESTORE NAME
       MOV  XR,R_SFC         RECORD CURRENT FILE NAME
       MOV  CMPSN,WB         GET CURRENT STATEMENT
       MTI  WB               CONVERT TO INTEGER
       JSR  ICBLD            BUILD ICBLK FOR STMT NUMBER
       MOV  R_SFN,XL         FILE NAME TABLE
       MNZ  WB               LOOKUP STATEMENT NUMBER BY NAME
       JSR  TFIND            ALLOCATE NEW TEBLK
       PPM                   ALWAYS POSSIBLE TO ALLOCATE BLOCK
       MOV  R_SFC,TEVAL(XL)  RECORD FILE NAME AS ENTRY VALUE
       EXI
NWFN1  ICA  XS               POP STACK
       EXI
.FI
.IF    .CINC
.FI
NEXTS  PRC  E,0              ENTRY POINT
       BZE  CSWLS,NXTS2      JUMP IF -NOLIST
       MOV  R_CIM,XR         POINT TO IMAGE
       BZE  XR,NXTS2         JUMP IF NO IMAGE
       PLC  XR               GET CHAR PTR
       LCH  WA,(XR)          GET FIRST CHAR
       BNE  WA,=CH_MN,NXTS1  JUMP IF NOT CTRL CARD
       BZE  CSWPR,NXTS2      JUMP IF -NOPRINT
NXTS1  JSR  LISTR            LIST LINE
NXTS2  MOV  R_CNI,XR         POINT TO NEXT IMAGE
       MOV  XR,R_CIM         SET AS NEXT IMAGE
       MOV  RDNLN,RDCLN      SET AS CURRENT LINE NUMBER
.IF    .CINC
       MOV  CNIND,LSTID      SET AS CURRENT INCLUDE DEPTH
.FI
       ZER  R_CNI            CLEAR NEXT IMAGE POINTER
       MOV  SCLEN(XR),WA     GET INPUT IMAGE LENGTH
       MOV  CSWIN,WB         GET MAX ALLOWABLE LENGTH
       BLO  WA,WB,NXTS3      SKIP IF NOT TOO LONG
       MOV  WB,WA            ELSE TRUNCATE
NXTS3  MOV  WA,SCNIL         USE AS RECORD LENGTH
       ZER  SCNSE            RESET SCNSE
       ZER  LSTPF            SET LINE NOT LISTED YET
       EXI                   RETURN TO NEXTS CALLER
       ENP                   END PROCEDURE NEXTS
PATIN  PRC  N,2              ENTRY POINT
       MOV  WA,XL            PRESERVE EXPRESSION ARG PCODE
       JSR  GTSMI            TRY TO CONVERT ARG AS SMALL INTEGER
       PPM  PTIN2            JUMP IF NOT INTEGER
       PPM  PTIN3            JUMP IF OUT OF RANGE
PTIN1  JSR  PBILD            BUILD PATTERN NODE
       EXI                   RETURN TO CALLER
PTIN2  MOV  XL,WB            COPY EXPR ARG CASE PCODE
       BLO  (XR),=B_E__,PTIN1 ALL OK IF EXPRESSION ARG
       EXI  1                ELSE TAKE ERROR EXIT FOR WRONG TYPE
PTIN3  EXI  2                TAKE OUT-OF-RANGE ERROR EXIT
       ENP                   END PROCEDURE PATIN
PATST  PRC  N,1              ENTRY POINT
       JSR  GTSTG            CONVERT ARGUMENT AS STRING
       PPM  PATS7            JUMP IF NOT STRING
       BZE  WA,PATS7         JUMP IF NULL STRING (CATSPAW)
       BNE  WA,=NUM01,PATS2  JUMP IF NOT ONE CHAR STRING
       BZE  WB,PATS2         TREAT AS MULTI-CHAR IF EVALS CALL
       PLC  XR               POINT TO CHARACTER
       LCH  XR,(XR)          LOAD CHARACTER
PATS1  JSR  PBILD            CALL ROUTINE TO BUILD NODE
       EXI                   RETURN TO PATST CALLER
PATS2  MOV  XL,-(XS)         SAVE MULTI-CHAR PCODE
       MOV  CTMSK,WC         LOAD CURRENT MASK BIT
       BEQ  XR,R_CTS,PATS6   JUMP IF SAME AS LAST STRING C3.738
       MOV  XR,-(XS)         SAVE STRING POINTER
       LSH  WC,1             SHIFT TO NEXT POSITION
       NZB  WC,PATS4         SKIP IF POSITION LEFT IN THIS TBL
       MOV  *CTSI_,WA        SET SIZE OF CTBLK
       JSR  ALLOC            ALLOCATE CTBLK
       MOV  XR,R_CTP         STORE PTR TO NEW CTBLK
       MOV  =B_CTT,(XR)+     STORE TYPE CODE, BUMP PTR
       LCT  WB,=CFP_A        SET NUMBER OF WORDS TO CLEAR
       MOV  BITS0,WC         LOAD ALL ZERO BITS
PATS3  MOV  WC,(XR)+         MOVE WORD OF ZERO BITS
       BCT  WB,PATS3         LOOP TILL ALL CLEARED
       MOV  BITS1,WC         SET INITIAL BIT POSITION
PATS4  MOV  WC,CTMSK         SAVE PARM2 (NEW BIT POSITION)
       MOV  (XS)+,XL         RESTORE POINTER TO ARGUMENT STRING
       MOV  XL,R_CTS         SAVE FOR NEXT TIME   C3.738
       MOV  SCLEN(XL),WB     LOAD STRING LENGTH
       BZE  WB,PATS6         JUMP IF NULL STRING CASE
       LCT  WB,WB            ELSE SET LOOP COUNTER
       PLC  XL               POINT TO CHARACTERS IN ARGUMENT
PATS5  LCH  WA,(XL)+         LOAD NEXT CHARACTER
       WTB  WA               CONVERT TO BYTE OFFSET
       MOV  R_CTP,XR         POINT TO CTBLK
       ADD  WA,XR            POINT TO CTBLK ENTRY
       MOV  WC,WA            COPY BIT MASK
       ORB  CTCHS(XR),WA     OR IN BITS ALREADY SET
       MOV  WA,CTCHS(XR)     STORE RESULTING BIT STRING
       BCT  WB,PATS5         LOOP TILL ALL BITS SET
PATS6  MOV  R_CTP,XR         LOAD CTBLK PTR AS PARM1 FOR PBILD
       ZER  XL               CLEAR GARBAGE PTR IN XL
       MOV  (XS)+,WB         LOAD PCODE FOR MULTI-CHAR STR CASE
       BRN  PATS1            BACK TO EXIT (WC=BITSTRING=PARM2)
PATS7  MOV  WC,WB            SET PCODE FOR EXPRESSION ARGUMENT
       BLO  (XR),=B_E__,PATS1 JUMP TO EXIT IF EXPRESSION ARG
       EXI  1                ELSE TAKE WRONG TYPE ERROR EXIT
       ENP                   END PROCEDURE PATST
PBILD  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         STACK POSSIBLE PARM1
       MOV  WB,XR            COPY PCODE
       LEI  XR               LOAD ENTRY POINT ID (BL_PX)
       BEQ  XR,=BL_P1,PBLD1  JUMP IF ONE PARAMETER
       BEQ  XR,=BL_P0,PBLD3  JUMP IF NO PARAMETERS
       MOV  *PCSI_,WA        SET SIZE OF P2BLK
       JSR  ALLOC            ALLOCATE BLOCK
       MOV  WC,PARM2(XR)     STORE SECOND PARAMETER
       BRN  PBLD2            MERGE WITH ONE PARM CASE
PBLD1  MOV  *PBSI_,WA        SET SIZE OF P1BLK
       JSR  ALLOC            ALLOCATE NODE
PBLD2  MOV  (XS),PARM1(XR)   STORE FIRST PARAMETER
       BRN  PBLD4            MERGE WITH NO PARAMETER CASE
PBLD3  MOV  *PASI_,WA        SET SIZE OF P0BLK
       JSR  ALLOC            ALLOCATE NODE
PBLD4  MOV  WB,(XR)          STORE PCODE
       ICA  XS               POP FIRST PARAMETER
       MOV  =NDNTH,PTHEN(XR) SET NOTHEN SUCCESSOR POINTER
       EXI                   RETURN TO PBILD CALLER
       ENP                   END PROCEDURE PBILD
PCONC  PRC  E,0              ENTRY POINT
       ZER  -(XS)            MAKE ROOM FOR ONE ENTRY AT BOTTOM
       MOV  XS,WC            STORE POINTER TO START OF LIST
       MOV  =NDNTH,-(XS)     STACK NOTHEN NODE AS OLD NODE
       MOV  XL,-(XS)         STORE RIGHT ARG AS COPY OF NOTHEN
       MOV  XS,XT            INITIALIZE POINTER TO STACK ENTRIES
       JSR  PCOPY            COPY FIRST NODE OF LEFT ARG
       MOV  WA,NUM02(XT)     STORE AS RESULT UNDER LIST
PCNC1  BEQ  XT,XS,PCNC2      JUMP IF ALL ENTRIES PROCESSED
       MOV  -(XT),XR         ELSE LOAD NEXT OLD ADDRESS
       MOV  PTHEN(XR),XR     LOAD POINTER TO SUCCESSOR
       JSR  PCOPY            COPY SUCCESSOR NODE
       MOV  -(XT),XR         LOAD POINTER TO NEW NODE (COPY)
       MOV  WA,PTHEN(XR)     STORE PTR TO NEW SUCCESSOR
       BNE  (XR),=P_ALT,PCNC1 LOOP BACK IF NOT
       MOV  PARM1(XR),XR     ELSE LOAD POINTER TO ALTERNATIVE
       JSR  PCOPY            COPY IT
       MOV  (XT),XR          RESTORE PTR TO NEW NODE
       MOV  WA,PARM1(XR)     STORE PTR TO COPIED ALTERNATIVE
       BRN  PCNC1            LOOP BACK FOR NEXT ENTRY
PCNC2  MOV  WC,XS            RESTORE STACK POINTER
       MOV  (XS)+,XR         LOAD POINTER TO COPY
       EXI                   RETURN TO PCONC CALLER
       ENP                   END PROCEDURE PCONC
PCOPY  PRC  N,0              ENTRY POINT
       MOV  XT,WB            SAVE XT
       MOV  WC,XT            POINT TO START OF LIST
PCOP1  DCA  XT               POINT TO NEXT ENTRY ON LIST
       BEQ  XR,(XT),PCOP2    JUMP IF MATCH
       DCA  XT               ELSE SKIP OVER COPIED ADDRESS
       BNE  XT,XS,PCOP1      LOOP BACK IF MORE TO TEST
       MOV  (XR),WA          LOAD FIRST WORD OF BLOCK
       JSR  BLKLN            GET LENGTH OF BLOCK
       MOV  XR,XL            SAVE POINTER TO OLD NODE
       JSR  ALLOC            ALLOCATE SPACE FOR COPY
       MOV  XL,-(XS)         STORE OLD ADDRESS ON LIST
       MOV  XR,-(XS)         STORE NEW ADDRESS ON LIST
       CHK                   CHECK FOR STACK OVERFLOW
       MVW                   MOVE WORDS FROM OLD BLOCK TO COPY
       MOV  (XS),WA          LOAD POINTER TO COPY
       BRN  PCOP3            JUMP TO EXIT
PCOP2  MOV  -(XT),WA         LOAD ADDRESS OF COPY FROM LIST
PCOP3  MOV  WB,XT            RESTORE XT
       EXI                   RETURN TO PCOPY CALLER
       ENP                   END PROCEDURE PCOPY
.IF    .CNPF
.ELSE
PRFLR  PRC  E,0
       BZE  PFDMP,PRFL4      NO PRINTING IF NO PROFILING DONE
       MOV  XR,-(XS)         PRESERVE ENTRY XR
       MOV  WB,PFSVW         AND ALSO WB
       JSR  PRTPG            EJECT
       MOV  =PFMS1,XR        LOAD MSG /PROGRAM PROFILE/
       JSR  PRTST            AND PRINT IT
       JSR  PRTNL            FOLLOWED BY NEWLINE
       JSR  PRTNL            AND ANOTHER
       MOV  =PFMS2,XR        POINT TO FIRST HDR
       JSR  PRTST            PRINT IT
       JSR  PRTNL            NEW LINE
       MOV  =PFMS3,XR        SECOND HDR
       JSR  PRTST            PRINT IT
       JSR  PRTNL            NEW LINE
       JSR  PRTNL            AND ANOTHER BLANK LINE
       ZER  WB               INITIAL STMT COUNT
       MOV  PFTBL,XR         POINT TO TABLE ORIGIN
       ADD  *XNDTA,XR        BIAS PAST XNBLK HEADER (SGD07)
PRFL1  ICV  WB               BUMP STMT NR
       LDI  (XR)             LOAD NR OF EXECUTIONS
       IEQ  PRFL3            NO PRINTING IF ZERO
       MOV  =PFPD1,PROFS     POINT WHERE TO PRINT
       JSR  PRTIN            AND PRINT IT
       ZER  PROFS            BACK TO START OF LINE
       MTI  WB               LOAD STMT NR
       JSR  PRTIN            PRINT IT THERE
       MOV  =PFPD2,PROFS     AND PAD PAST COUNT
       LDI  CFP_I(XR)        LOAD TOTAL EXEC TIME
       JSR  PRTIN            PRINT THAT TOO
       LDI  CFP_I(XR)        RELOAD TIME
       MLI  INTTH            CONVERT TO MICROSEC
       IOV  PRFL2            OMIT NEXT BIT IF OVERFLOW
       DVI  (XR)             DIVIDE BY EXECUTIONS
       MOV  =PFPD3,PROFS     PAD LAST PRINT
       JSR  PRTIN            AND PRINT MCSEC/EXECN
PRFL2  JSR  PRTNL            THATS ANOTHER LINE
PRFL3  ADD  *PF_I2,XR        BUMP INDEX PTR (SGD07)
       BLT  WB,PFNTE,PRFL1   LOOP IF MORE STMTS
       MOV  (XS)+,XR         RESTORE CALLERS XR
       MOV  PFSVW,WB         AND WB TOO
PRFL4  EXI                   RETURN
       ENP                   END OF PRFLR
PRFLU  PRC  E,0
       BNZ  PFFNC,PFLU4      SKIP IF JUST ENTERED FUNCTION
       MOV  XR,-(XS)         PRESERVE ENTRY XR
       MOV  WA,PFSVW         SAVE WA (SGD07)
       BNZ  PFTBL,PFLU2      BRANCH IF TABLE ALLOCATED
       SUB  =NUM01,PFNTE     ADJUST FOR EXTRA COUNT (SGD07)
       MTI  PFI2A            CONVRT ENTRY SIZE TO INT
       STI  PFSTE            AND STORE SAFELY FOR LATER
       MTI  PFNTE            LOAD TABLE LENGTH AS INTEGER
       MLI  PFSTE            MULTIPLY BY ENTRY SIZE
       MFI  WA               GET BACK ADDRESS-STYLE
       ADD  =NUM02,WA        ADD ON 2 WORD OVERHEAD
       WTB  WA               CONVERT THE WHOLE LOT TO BYTES
       JSR  ALOST            GIMME THE SPACE
       MOV  XR,PFTBL         SAVE BLOCK POINTER
       MOV  =B_XNT,(XR)+     PUT BLOCK TYPE AND ...
       MOV  WA,(XR)+         ... LENGTH INTO HEADER
       MFI  WA               GET BACK NR OF WDS IN DATA AREA
       LCT  WA,WA            LOAD THE COUNTER
PFLU1  ZER  (XR)+            BLANK A WORD
       BCT  WA,PFLU1         AND ALLLLLLL THE REST
PFLU2  MTI  KVSTN            LOAD NR OF STMT JUST ENDED
       SBI  INTV1            MAKE INTO INDEX OFFSET
       MLI  PFSTE            MAKE OFFSET OF TABLE ENTRY
       MFI  WA               CONVERT TO ADDRESS
       WTB  WA               GET AS BAUS
       ADD  *NUM02,WA        OFFSET INCLUDES TABLE HEADER
       MOV  PFTBL,XR         GET TABLE START
       BGE  WA,NUM01(XR),PFLU3  IF OUT OF TABLE, SKIP IT
       ADD  WA,XR            ELSE POINT TO ENTRY
       LDI  (XR)             GET NR OF EXECUTIONS SO FAR
       ADI  INTV1            NUDGE UP ONE
       STI  (XR)             AND PUT BACK
       JSR  SYSTM            GET TIME NOW
       STI  PFETM            STASH ENDING TIME
       SBI  PFSTM            SUBTRACT START TIME
       ADI  CFP_I(XR)        ADD CUMULATIVE TIME SO FAR
       STI  CFP_I(XR)        AND PUT BACK NEW TOTAL
       LDI  PFETM            LOAD END TIME OF THIS STMT ...
       STI  PFSTM            ... WHICH IS START TIME OF NEXT
PFLU3  MOV  (XS)+,XR         RESTORE CALLERS XR
       MOV  PFSVW,WA         RESTORE SAVED REG
       EXI                   AND RETURN
PFLU4  ZER  PFFNC            RESET THE CONDITION FLAG
       EXI                   AND IMMEDIATE RETURN
       ENP                   END OF PROCEDURE PRFLU
.FI
PRPAR  PRC  E,0              ENTRY POINT
       BNZ  WC,PRPA8         JUMP TO ASSOCIATE TERMINAL
       JSR  SYSPP            GET PRINT PARAMETERS
       BNZ  WB,PRPA1         JUMP IF LINES/PAGE SPECIFIED
       MOV  =CFP_M,WB        ELSE USE A LARGE VALUE
       RSH  WB,1             BUT NOT TOO LARGE
PRPA1  MOV  WB,LSTNP         STORE NUMBER OF LINES/PAGE
       MOV  WB,LSTLC         PRETEND PAGE IS FULL INITIALLY
       ZER  LSTPG            CLEAR PAGE NUMBER
       MOV  PRLEN,WB         GET PRIOR LENGTH IF ANY
       BZE  WB,PRPA2         SKIP IF NO LENGTH
       BGT  WA,WB,PRPA3      SKIP STORING IF TOO BIG
PRPA2  MOV  WA,PRLEN         STORE VALUE
PRPA3  MOV  BITS3,WB         BIT 3 MASK
       ANB  WC,WB            GET -NOLIST BIT
       ZRB  WB,PRPA4         SKIP IF CLEAR
       ZER  CSWLS            SET -NOLIST
PRPA4  MOV  BITS1,WB         BIT 1 MASK
       ANB  WC,WB            GET BIT
       MOV  WB,ERICH         STORE INT. CHAN. ERROR FLAG
       MOV  BITS2,WB         BIT 2 MASK
       ANB  WC,WB            GET BIT
       MOV  WB,PRICH         FLAG FOR STD PRINTER ON INT. CHAN.
       MOV  BITS4,WB         BIT 4 MASK
       ANB  WC,WB            GET BIT
       MOV  WB,CPSTS         FLAG FOR COMPILE STATS SUPPRESSN.
       MOV  BITS5,WB         BIT 5 MASK
       ANB  WC,WB            GET BIT
       MOV  WB,EXSTS         FLAG FOR EXEC STATS SUPPRESSION
       MOV  BITS6,WB         BIT 6 MASK
       ANB  WC,WB            GET BIT
       MOV  WB,PRECL         EXTENDED/COMPACT LISTING FLAG
       SUB  =NUM08,WA        POINT 8 CHARS FROM LINE END
       ZRB  WB,PRPA5         JUMP IF NOT EXTENDED
       MOV  WA,LSTPO         STORE FOR LISTING PAGE HEADINGS
PRPA5  MOV  BITS7,WB         BIT 7 MASK
       ANB  WC,WB            GET BIT 7
       MOV  WB,CSWEX         SET -NOEXECUTE IF NON-ZERO
       MOV  BIT10,WB         BIT 10 MASK
       ANB  WC,WB            GET BIT 10
       MOV  WB,HEADP         PRETEND PRINTED TO OMIT HEADERS
       MOV  BITS9,WB         BIT 9 MASK
       ANB  WC,WB            GET BIT 9
       MOV  WB,PRSTO         KEEP IT AS STD LISTING OPTION
.IF    .CULC
       MOV  WC,WB            COPY FLAGS
       RSH  WB,12            RIGHT JUSTIFY BIT 13
       ANB  BITS1,WB         GET BIT
       MOV  WB,KVCAS         SET -CASE
.FI
       MOV  BIT12,WB         BIT 12 MASK
       ANB  WC,WB            GET BIT 12
       MOV  WB,CSWER         KEEP IT AS ERRORS/NOERRORS OPTION
       ZRB  WB,PRPA6         SKIP IF CLEAR
       MOV  PRLEN,WA         GET PRINT BUFFER LENGTH
       SUB  =NUM08,WA        POINT 8 CHARS FROM LINE END
       MOV  WA,LSTPO         STORE PAGE OFFSET
PRPA6  MOV  BIT11,WB         BIT 11 MASK
       ANB  WC,WB            GET BIT 11
       MOV  WB,CSWPR         SET -PRINT IF NON-ZERO
       ANB  BITS8,WC         SEE IF TERMINAL TO BE ACTIVATED
       BNZ  WC,PRPA8         JUMP IF TERMINAL REQUIRED
       BZE  INITR,PRPA9      JUMP IF NO TERMINAL TO DETACH
       MOV  =V_TER,XL        PTR TO /TERMINAL/
       JSR  GTNVR            GET VRBLK POINTER
       PPM                   CANT FAIL
       MOV  =NULLS,VRVAL(XR) CLEAR VALUE OF TERMINAL
       JSR  SETVR            REMOVE ASSOCIATION
       BRN  PRPA9            RETURN
PRPA8  MNZ  INITR            NOTE TERMINAL ASSOCIATED
       BZE  DNAMB,PRPA9      CANT IF MEMORY NOT ORGANISED
       MOV  =V_TER,XL        POINT TO TERMINAL STRING
       MOV  =TRTOU,WB        OUTPUT TRACE TYPE
       JSR  INOUT            ATTACH OUTPUT TRBLK TO VRBLK
       MOV  XR,-(XS)         STACK TRBLK PTR
       MOV  =V_TER,XL        POINT TO TERMINAL STRING
       MOV  =TRTIN,WB        INPUT TRACE TYPE
       JSR  INOUT            ATTACH INPUT TRACE BLK
       MOV  (XS)+,VRVAL(XR)  ADD OUTPUT TRBLK TO CHAIN
PRPA9  EXI                   RETURN
       ENP                   END PROCEDURE PRPAR
PRTCH  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE XR
       BNE  PROFS,PRLEN,PRCH1 JUMP IF ROOM IN BUFFER
       JSR  PRTNL            ELSE PRINT THIS LINE
PRCH1  MOV  PRBUF,XR         POINT TO PRINT BUFFER
       PSC  XR,PROFS         POINT TO NEXT CHARACTER LOCATION
       SCH  WA,(XR)          STORE NEW CHARACTER
       CSC  XR               COMPLETE STORE CHARACTERS
       ICV  PROFS            BUMP POINTER
       MOV  (XS)+,XR         RESTORE ENTRY XR
       EXI                   RETURN TO PRTCH CALLER
       ENP                   END PROCEDURE PRTCH
PRTIC  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE XR
       MOV  PRBUF,XR         POINT TO BUFFER
       MOV  PROFS,WA         NO OF CHARS
       JSR  SYSPI            PRINT
       PPM  PRTC2            FAIL RETURN
PRTC1  MOV  (XS)+,XR         RESTORE XR
       EXI                   RETURN
PRTC2  ZER  ERICH            PREVENT LOOPING
       ERB  252,Error on printing to interactive channel
       BRN  PRTC1            RETURN
       ENP                   PROCEDURE PRTIC
PRTIS  PRC  E,0              ENTRY POINT
       BNZ  PRICH,PRTS1      JUMP IF STANDARD PRINTER IS INT.CH.
       BZE  ERICH,PRTS1      SKIP IF NOT DOING INT. ERROR REPS.
       JSR  PRTIC            PRINT TO INTERACTIVE CHANNEL
PRTS1  JSR  PRTNL            PRINT TO STANDARD PRINTER
       EXI                   RETURN
       ENP                   END PROCEDURE PRTIS
PRTIN  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE XR
       JSR  ICBLD            BUILD INTEGER BLOCK
       BLO  XR,DNAMB,PRTI1   JUMP IF ICBLK BELOW DYNAMIC
       BHI  XR,DNAMP,PRTI1   JUMP IF ABOVE DYNAMIC
       MOV  XR,DNAMP         IMMEDIATELY DELETE IT
PRTI1  MOV  XR,-(XS)         STACK PTR FOR GTSTG
       JSR  GTSTG            CONVERT TO STRING
       PPM                   CONVERT ERROR IS IMPOSSIBLE
       MOV  XR,DNAMP         RESET POINTER TO DELETE SCBLK
       JSR  PRTST            PRINT INTEGER STRING
       MOV  (XS)+,XR         RESTORE ENTRY XR
       EXI                   RETURN TO PRTIN CALLER
       ENP                   END PROCEDURE PRTIN
PRTMI  PRC  E,0              ENTRY POINT
       JSR  PRTST            PRINT STRING MESSAGE
       MOV  =PRTMF,PROFS     SET COLUMN OFFSET
       JSR  PRTIN            PRINT INTEGER
       JSR  PRTNL            PRINT LINE
       EXI                   RETURN TO PRTMI CALLER
       ENP                   END PROCEDURE PRTMI
PRTMM  PRC  E,0
       MOV  DNAMP,WA         NEXT AVAILABLE LOC
       SUB  STATB,WA         MINUS START
.IF    .CBYT
.ELSE
       BTW  WA               CONVERT TO WORDS
.FI
       MTI  WA               CONVERT TO INTEGER
       MOV  =ENCM1,XR        POINT TO /MEMORY USED (WORDS)/
       JSR  PRTMI            PRINT MESSAGE
       MOV  DNAME,WA         END OF MEMORY
       SUB  DNAMP,WA         MINUS NEXT AVAILABLE LOC
.IF    .CBYT
.ELSE
       BTW  WA               CONVERT TO WORDS
.FI
       MTI  WA               CONVERT TO INTEGER
       MOV  =ENCM2,XR        POINT TO /MEMORY AVAILABLE (WORDS)/
       JSR  PRTMI            PRINT LINE
       EXI                   RETURN TO PRTMM CALLER
       ENP                   END OF PROCEDURE PRTMM
PRTMX  PRC  E,0              ENTRY POINT
       JSR  PRTST            PRINT STRING MESSAGE
       MOV  =PRTMF,PROFS     SET COLUMN OFFSET
       JSR  PRTIN            PRINT INTEGER
       JSR  PRTIS            PRINT LINE
       EXI                   RETURN
       ENP                   END PROCEDURE PRTMX
PRTNL  PRC  R,0              ENTRY POINT
       BNZ  HEADP,PRNL0      WERE HEADERS PRINTED
       JSR  PRTPS            NO - PRINT THEM
PRNL0  MOV  XR,-(XS)         SAVE ENTRY XR
       MOV  WA,PRTSA         SAVE WA
       MOV  WB,PRTSB         SAVE WB
       MOV  PRBUF,XR         LOAD POINTER TO BUFFER
       MOV  PROFS,WA         LOAD NUMBER OF CHARS IN BUFFER
       JSR  SYSPR            CALL SYSTEM PRINT ROUTINE
       PPM  PRNL2            JUMP IF FAILED
       LCT  WA,PRLNW         LOAD LENGTH OF BUFFER IN WORDS
       ADD  *SCHAR,XR        POINT TO CHARS OF BUFFER
       MOV  NULLW,WB         GET WORD OF BLANKS
PRNL1  MOV  WB,(XR)+         STORE WORD OF BLANKS, BUMP PTR
       BCT  WA,PRNL1         LOOP TILL ALL BLANKED
       MOV  PRTSB,WB         RESTORE WB
       MOV  PRTSA,WA         RESTORE WA
       MOV  (XS)+,XR         RESTORE ENTRY XR
       ZER  PROFS            RESET PRINT BUFFER POINTER
       EXI                   RETURN TO PRTNL CALLER
PRNL2  BNZ  PRTEF,PRNL3      JUMP IF NOT FIRST TIME
       MNZ  PRTEF            MARK FIRST OCCURRENCE
       ERB  253,Print limit exceeded on standard output channel
PRNL3  MOV  =NINI8,WB        ENDING CODE
       MOV  KVSTN,WA         STATEMENT NUMBER
       MOV  R_FCB,XL         GET FCBLK CHAIN HEAD
       JSR  SYSEJ            STOP
       ENP                   END PROCEDURE PRTNL
PRTNM  PRC  R,0              ENTRY POINT (RECURSIVE, SEE PRTVL)
       MOV  WA,-(XS)         SAVE WA (OFFSET IS COLLECTABLE)
       MOV  XR,-(XS)         SAVE ENTRY XR
       MOV  XL,-(XS)         SAVE NAME BASE
       BHI  XL,STATE,PRN02   JUMP IF NOT NATURAL VARIABLE
       MOV  XL,XR            POINT TO VRBLK
       JSR  PRTVN            PRINT NAME OF VARIABLE
PRN01  MOV  (XS)+,XL         RESTORE NAME BASE
       MOV  (XS)+,XR         RESTORE ENTRY VALUE OF XR
       MOV  (XS)+,WA         RESTORE WA
       EXI                   RETURN TO PRTNM CALLER
PRN02  MOV  WA,WB            COPY NAME OFFSET
       BNE  (XL),=B_PDT,PRN03 JUMP IF ARRAY OR TABLE
       MOV  PDDFP(XL),XR     LOAD POINTER TO DFBLK
       ADD  WA,XR            ADD NAME OFFSET
       MOV  PDFOF(XR),XR     LOAD VRBLK POINTER FOR FIELD
       JSR  PRTVN            PRINT FIELD NAME
       MOV  =CH_PP,WA        LOAD LEFT PAREN
       JSR  PRTCH            PRINT CHARACTER
PRN03  BNE  (XL),=B_TET,PRN04 JUMP IF WE GOT THERE (OR NOT TE)
       MOV  TENXT(XL),XL     ELSE MOVE OUT ON CHAIN
       BRN  PRN03            AND LOOP BACK
PRN04  MOV  PRNMV,XR         POINT TO VRBLK WE FOUND LAST TIME
       MOV  HSHTB,WA         POINT TO HASH TABLE IN CASE NOT
       BRN  PRN07            JUMP INTO SEARCH FOR SPECIAL CHECK
PRN05  MOV  WA,XR            COPY SLOT POINTER
       ICA  WA               BUMP SLOT POINTER
       SUB  *VRNXT,XR        INTRODUCE STANDARD VRBLK OFFSET
PRN06  MOV  VRNXT(XR),XR     POINT TO NEXT VRBLK ON HASH CHAIN
PRN07  MOV  XR,WC            COPY VRBLK POINTER
       BZE  WC,PRN09         JUMP IF CHAIN END (OR PRNMV ZERO)
PRN08  MOV  VRVAL(XR),XR     LOAD VALUE
       BEQ  (XR),=B_TRT,PRN08 LOOP IF THAT WAS A TRBLK
       BEQ  XR,XL,PRN10      JUMP IF THIS MATCHES THE NAME BASE
       MOV  WC,XR            ELSE POINT BACK TO THAT VRBLK
       BRN  PRN06            AND LOOP BACK
PRN09  BLT  WA,HSHTE,PRN05   LOOP BACK IF MORE TO GO
       MOV  XL,XR            ELSE NOT FOUND, COPY VALUE POINTER
       JSR  PRTVL            PRINT VALUE
       BRN  PRN11            AND MERGE AHEAD
PRN10  MOV  WC,XR            COPY VRBLK POINTER
       MOV  XR,PRNMV         SAVE FOR NEXT TIME IN
       JSR  PRTVN            PRINT VARIABLE NAME
PRN11  MOV  (XL),WC          LOAD FIRST WORD OF NAME BASE
       BNE  WC,=B_PDT,PRN13  JUMP IF NOT PROGRAM DEFINED
       MOV  =CH_RP,WA        LOAD RIGHT PAREN, MERGE
PRN12  JSR  PRTCH            PRINT FINAL CHARACTER
       MOV  WB,WA            RESTORE NAME OFFSET
       BRN  PRN01            MERGE BACK TO EXIT
PRN13  MOV  =CH_BB,WA        LOAD LEFT BRACKET
       JSR  PRTCH            AND PRINT IT
       MOV  (XS),XL          RESTORE BLOCK POINTER
       MOV  (XL),WC          LOAD TYPE WORD AGAIN
       BNE  WC,=B_TET,PRN15  JUMP IF NOT TABLE
       MOV  TESUB(XL),XR     LOAD SUBSCRIPT VALUE
       MOV  WB,XL            SAVE NAME OFFSET
       JSR  PRTVL            PRINT SUBSCRIPT VALUE
       MOV  XL,WB            RESTORE NAME OFFSET
PRN14  MOV  =CH_RB,WA        LOAD RIGHT BRACKET
       BRN  PRN12            MERGE BACK TO PRINT IT
PRN15  MOV  WB,WA            COPY NAME OFFSET
       BTW  WA               CONVERT TO WORDS
       BEQ  WC,=B_ART,PRN16  JUMP IF ARBLK
       SUB  =VCVLB,WA        ADJUST FOR STANDARD FIELDS
       MTI  WA               MOVE TO INTEGER ACCUM
       JSR  PRTIN            PRINT LINEAR SUBSCRIPT
       BRN  PRN14            MERGE BACK FOR RIGHT BRACKET
PRN16  MOV  AROFS(XL),WC     LOAD LENGTH OF BOUNDS INFO
       ICA  WC               ADJUST FOR ARPRO FIELD
       BTW  WC               CONVERT TO WORDS
       SUB  WC,WA            GET LINEAR ZERO-ORIGIN SUBSCRIPT
       MTI  WA               GET INTEGER VALUE
       LCT  WA,ARNDM(XL)     SET NUM OF DIMENSIONS AS LOOP COUNT
       ADD  AROFS(XL),XL     POINT PAST BOUNDS INFORMATION
       SUB  *ARLBD,XL        SET OK OFFSET FOR PROPER PTR LATER
PRN17  SUB  *ARDMS,XL        POINT TO NEXT SET OF BOUNDS
       STI  PRNSI            SAVE CURRENT OFFSET
       RMI  ARDIM(XL)        GET REMAINDER ON DIVIDING BY DIMENS
       MFI  -(XS)            STORE ON STACK (ONE WORD)
       LDI  PRNSI            RELOAD ARGUMENT
       DVI  ARDIM(XL)        DIVIDE TO GET QUOTIENT
       BCT  WA,PRN17         LOOP TILL ALL STACKED
       ZER  XR               SET OFFSET TO FIRST SET OF BOUNDS
       LCT  WB,ARNDM(XL)     LOAD COUNT OF DIMS TO CONTROL LOOP
       BRN  PRN19            JUMP INTO PRINT LOOP
PRN18  MOV  =CH_CM,WA        LOAD A COMMA
       JSR  PRTCH            PRINT IT
PRN19  MTI  (XS)+            LOAD SUBSCRIPT OFFSET AS INTEGER
       ADD  XR,XL            POINT TO CURRENT LBD
       ADI  ARLBD(XL)        ADD LBD TO GET SIGNED SUBSCRIPT
       SUB  XR,XL            POINT BACK TO START OF ARBLK
       JSR  PRTIN            PRINT SUBSCRIPT
       ADD  *ARDMS,XR        BUMP OFFSET TO NEXT BOUNDS
       BCT  WB,PRN18         LOOP BACK TILL ALL PRINTED
       BRN  PRN14            MERGE BACK TO PRINT RIGHT BRACKET
       ENP                   END PROCEDURE PRTNM
PRTNV  PRC  E,0              ENTRY POINT
       JSR  PRTNM            PRINT ARGUMENT NAME
       MOV  XR,-(XS)         SAVE ENTRY XR
       MOV  WA,-(XS)         SAVE NAME OFFSET (COLLECTABLE)
       MOV  =TMBEB,XR        POINT TO BLANK EQUAL BLANK
       JSR  PRTST            PRINT IT
       MOV  XL,XR            COPY NAME BASE
       ADD  WA,XR            POINT TO VALUE
       MOV  (XR),XR          LOAD VALUE POINTER
       JSR  PRTVL            PRINT VALUE
       JSR  PRTNL            TERMINATE LINE
       MOV  (XS)+,WA         RESTORE NAME OFFSET
       MOV  (XS)+,XR         RESTORE ENTRY XR
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE PRTNV
PRTPG  PRC  E,0              ENTRY POINT
       BEQ  STAGE,=STGXT,PRP01 JUMP IF EXECUTION TIME
       BZE  LSTLC,PRP06      RETURN IF TOP OF PAGE ALREADY
       ZER  LSTLC            CLEAR LINE COUNT
PRP01  MOV  XR,-(XS)         PRESERVE XR
       BNZ  PRSTD,PRP02      EJECT IF FLAG SET
       BNZ  PRICH,PRP03      JUMP IF INTERACTIVE LISTING CHANNEL
       BZE  PRECL,PRP03      JUMP IF COMPACT LISTING
PRP02  JSR  SYSEP            EJECT
       BRN  PRP04            MERGE
PRP03  MOV  HEADP,XR         REMEMBER HEADP
       MNZ  HEADP            SET TO AVOID REPEATED PRTPG CALLS
       JSR  PRTNL            PRINT BLANK LINE
       JSR  PRTNL            PRINT BLANK LINE
       JSR  PRTNL            PRINT BLANK LINE
       MOV  =NUM03,LSTLC     COUNT BLANK LINES
       MOV  XR,HEADP         RESTORE HEADER FLAG
PRP04  BNZ  HEADP,PRP05      JUMP IF HEADER LISTED
       MNZ  HEADP            MARK HEADERS PRINTED
       MOV  XL,-(XS)         KEEP XL
       MOV  =HEADR,XR        POINT TO LISTING HEADER
       JSR  PRTST            PLACE IT
       JSR  SYSID            GET SYSTEM IDENTIFICATION
       JSR  PRTST            APPEND EXTRA CHARS
       JSR  PRTNL            PRINT IT
       MOV  XL,XR            EXTRA HEADER LINE
       JSR  PRTST            PLACE IT
       JSR  PRTNL            PRINT IT
       JSR  PRTNL            PRINT A BLANK
       JSR  PRTNL            AND ANOTHER
       ADD  =NUM04,LSTLC     FOUR HEADER LINES PRINTED
       MOV  (XS)+,XL         RESTORE XL
PRP05  MOV  (XS)+,XR         RESTORE XR
PRP06  EXI                   RETURN
       ENP                   END PROCEDURE PRTPG
PRTPS  PRC  E,0              ENTRY POINT
       MOV  PRSTO,PRSTD      COPY OPTION FLAG
       JSR  PRTPG            PRINT PAGE
       ZER  PRSTD            CLEAR FLAG
       EXI                   RETURN
       ENP                   END PROCEDURE PRTPS
PRTSN  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE ENTRY XR
       MOV  WA,PRSNA         SAVE ENTRY WA
       MOV  =TMASB,XR        POINT TO ASTERISKS
       JSR  PRTST            PRINT ASTERISKS
       MOV  =NUM04,PROFS     POINT INTO MIDDLE OF ASTERISKS
       MTI  KVSTN            LOAD STATEMENT NUMBER AS INTEGER
       JSR  PRTIN            PRINT INTEGER STATEMENT NUMBER
       MOV  =PRSNF,PROFS     POINT PAST ASTERISKS PLUS BLANK
       MOV  KVFNC,XR         GET FNCLEVEL
       MOV  =CH_LI,WA        SET LETTER I
PRSN1  BZE  XR,PRSN2         JUMP IF ALL SET
       JSR  PRTCH            ELSE PRINT AN I
       DCV  XR               DECREMENT COUNTER
       BRN  PRSN1            LOOP BACK
PRSN2  MOV  =CH_BL,WA        GET BLANK
       JSR  PRTCH            PRINT BLANK
       MOV  PRSNA,WA         RESTORE ENTRY WA
       MOV  (XS)+,XR         RESTORE ENTRY XR
       EXI                   RETURN TO PRTSN CALLER
       ENP                   END PROCEDURE PRTSN
PRTST  PRC  R,0              ENTRY POINT
       BNZ  HEADP,PRST0      WERE HEADERS PRINTED
       JSR  PRTPS            NO - PRINT THEM
PRST0  MOV  WA,PRSVA         SAVE WA
       MOV  WB,PRSVB         SAVE WB
       ZER  WB               SET CHARS PRINTED COUNT TO ZERO
PRST1  MOV  SCLEN(XR),WA     LOAD STRING LENGTH
       SUB  WB,WA            SUBTRACT COUNT OF CHARS ALREADY OUT
       BZE  WA,PRST4         JUMP TO EXIT IF NONE LEFT
       MOV  XL,-(XS)         ELSE STACK ENTRY XL
       MOV  XR,-(XS)         SAVE ARGUMENT
       MOV  XR,XL            COPY FOR EVENTUAL MOVE
       MOV  PRLEN,XR         LOAD PRINT BUFFER LENGTH
       SUB  PROFS,XR         GET CHARS LEFT IN PRINT BUFFER
       BNZ  XR,PRST2         SKIP IF ROOM LEFT ON THIS LINE
       JSR  PRTNL            ELSE PRINT THIS LINE
       MOV  PRLEN,XR         AND SET FULL WIDTH AVAILABLE
PRST2  BLO  WA,XR,PRST3      JUMP IF ROOM FOR REST OF STRING
       MOV  XR,WA            ELSE SET TO FILL LINE
PRST3  MOV  PRBUF,XR         POINT TO PRINT BUFFER
       PLC  XL,WB            POINT TO LOCATION IN STRING
       PSC  XR,PROFS         POINT TO LOCATION IN BUFFER
       ADD  WA,WB            BUMP STRING CHARS COUNT
       ADD  WA,PROFS         BUMP BUFFER POINTER
       MOV  WB,PRSVC         PRESERVE CHAR COUNTER
       MVC                   MOVE CHARACTERS TO BUFFER
       MOV  PRSVC,WB         RECOVER CHAR COUNTER
       MOV  (XS)+,XR         RESTORE ARGUMENT POINTER
       MOV  (XS)+,XL         RESTORE ENTRY XL
       BRN  PRST1            LOOP BACK TO TEST FOR MORE
PRST4  MOV  PRSVB,WB         RESTORE ENTRY WB
       MOV  PRSVA,WA         RESTORE ENTRY WA
       EXI                   RETURN TO PRTST CALLER
       ENP                   END PROCEDURE PRTST
PRTTR  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE XR
       JSR  PRTIC            PRINT BUFFER CONTENTS
       MOV  PRBUF,XR         POINT TO PRINT BFR TO CLEAR IT
       LCT  WA,PRLNW         GET BUFFER LENGTH
       ADD  *SCHAR,XR        POINT PAST SCBLK HEADER
       MOV  NULLW,WB         GET BLANKS
PRTT1  MOV  WB,(XR)+         CLEAR A WORD
       BCT  WA,PRTT1         LOOP
       ZER  PROFS            RESET PROFS
       MOV  (XS)+,XR         RESTORE XR
       EXI                   RETURN
       ENP                   END PROCEDURE PRTTR
PRTVL  PRC  R,0              ENTRY POINT, RECURSIVE
       MOV  XL,-(XS)         SAVE ENTRY XL
       MOV  XR,-(XS)         SAVE ARGUMENT
       CHK                   CHECK FOR STACK OVERFLOW
PRV01  MOV  IDVAL(XR),PRVSI  COPY IDVAL (IF ANY)
       MOV  (XR),XL          LOAD FIRST WORD OF BLOCK
       LEI  XL               LOAD ENTRY POINT ID
       BSW  XL,BL__T,PRV02   SWITCH ON BLOCK TYPE
       IFF  BL_TR,PRV04      TRBLK
       IFF  BL_AR,PRV05      ARBLK
       IFF  BL_IC,PRV08      ICBLK
       IFF  BL_NM,PRV09      NMBLK
       IFF  BL_PD,PRV10      PDBLK
.IF    .CNRA
.ELSE
       IFF  BL_RC,PRV08      RCBLK
.FI
       IFF  BL_SC,PRV11      SCBLK
       IFF  BL_SE,PRV12      SEBLK
       IFF  BL_TB,PRV13      TBBLK
       IFF  BL_VC,PRV13      VCBLK
.IF    .CNBF
.ELSE
       IFF  BL_BC,PRV15      BCBLK
.FI
       ESW                   END OF SWITCH ON BLOCK TYPE
PRV02  JSR  DTYPE            GET DATATYPE NAME
       JSR  PRTST            PRINT DATATYPE NAME
PRV03  MOV  (XS)+,XR         RELOAD ARGUMENT
       MOV  (XS)+,XL         RESTORE XL
       EXI                   RETURN TO PRTVL CALLER
PRV04  MOV  TRVAL(XR),XR     LOAD REAL VALUE
       BRN  PRV01            AND LOOP BACK
PRV05  MOV  XR,XL            PRESERVE ARGUMENT
       MOV  =SCARR,XR        POINT TO DATATYPE NAME (ARRAY)
       JSR  PRTST            PRINT IT
       MOV  =CH_PP,WA        LOAD LEFT PAREN
       JSR  PRTCH            PRINT LEFT PAREN
       ADD  AROFS(XL),XL     POINT TO PROTOTYPE
       MOV  (XL),XR          LOAD PROTOTYPE
       JSR  PRTST            PRINT PROTOTYPE
PRV06  MOV  =CH_RP,WA        LOAD RIGHT PAREN
       JSR  PRTCH            PRINT RIGHT PAREN
PRV07  MOV  =CH_BL,WA        LOAD BLANK
       JSR  PRTCH            PRINT IT
       MOV  =CH_NM,WA        LOAD NUMBER SIGN
       JSR  PRTCH            PRINT IT
       MTI  PRVSI            GET IDVAL
       JSR  PRTIN            PRINT ID NUMBER
       BRN  PRV03            BACK TO EXIT
PRV08  MOV  XR,-(XS)         STACK ARGUMENT FOR GTSTG
       JSR  GTSTG            CONVERT TO STRING
       PPM                   ERROR RETURN IS IMPOSSIBLE
       JSR  PRTST            PRINT THE STRING
       MOV  XR,DNAMP         DELETE GARBAGE STRING FROM STORAGE
       BRN  PRV03            BACK TO EXIT
PRV09  MOV  NMBAS(XR),XL     LOAD NAME BASE
       MOV  (XL),WA          LOAD FIRST WORD OF BLOCK
       BEQ  WA,=B_KVT,PRV02  JUST PRINT NAME IF KEYWORD
       BEQ  WA,=B_EVT,PRV02  JUST PRINT NAME IF EXPRESSION VAR
       MOV  =CH_DT,WA        ELSE GET DOT
       JSR  PRTCH            AND PRINT IT
       MOV  NMOFS(XR),WA     LOAD NAME OFFSET
       JSR  PRTNM            PRINT NAME
       BRN  PRV03            BACK TO EXIT
PRV10  JSR  DTYPE            GET DATATYPE NAME
       JSR  PRTST            PRINT DATATYPE NAME
       BRN  PRV07            MERGE BACK TO PRINT ID
PRV11  MOV  =CH_SQ,WA        LOAD SINGLE QUOTE
       JSR  PRTCH            PRINT QUOTE
       JSR  PRTST            PRINT STRING VALUE
       JSR  PRTCH            PRINT ANOTHER QUOTE
       BRN  PRV03            BACK TO EXIT
PRV12  MOV  =CH_AS,WA        LOAD ASTERISK
       JSR  PRTCH            PRINT ASTERISK
       MOV  SEVAR(XR),XR     LOAD VARIABLE POINTER
       JSR  PRTVN            PRINT VARIABLE NAME
       BRN  PRV03            JUMP BACK TO EXIT
PRV13  MOV  XR,XL            PRESERVE ARGUMENT
       JSR  DTYPE            GET DATATYPE NAME
       JSR  PRTST            PRINT DATATYPE NAME
       MOV  =CH_PP,WA        LOAD LEFT PAREN
       JSR  PRTCH            PRINT LEFT PAREN
       MOV  TBLEN(XL),WA     LOAD LENGTH OF BLOCK (=VCLEN)
       BTW  WA               CONVERT TO WORD COUNT
       SUB  =TBSI_,WA        ALLOW FOR STANDARD FIELDS
       BEQ  (XL),=B_TBT,PRV14 JUMP IF TABLE
       ADD  =VCTBD,WA        FOR VCBLK, ADJUST SIZE
PRV14  MTI  WA               MOVE AS INTEGER
       JSR  PRTIN            PRINT INTEGER PROTOTYPE
       BRN  PRV06            MERGE BACK FOR REST
.IF    .CNBF
.ELSE
PRV15  MOV  XR,XL            PRESERVE ARGUMENT
       MOV  =SCBUF,XR        POINT TO DATATYPE NAME (BUFFER)
       JSR  PRTST            PRINT IT
       MOV  =CH_PP,WA        LOAD LEFT PAREN
       JSR  PRTCH            PRINT LEFT PAREN
       MOV  BCBUF(XL),XR     POINT TO BFBLK
       MTI  BFALC(XR)        LOAD ALLOCATION SIZE
       JSR  PRTIN            PRINT IT
       MOV  =CH_CM,WA        LOAD COMMA
       JSR  PRTCH            PRINT IT
       MTI  BCLEN(XL)        LOAD DEFINED LENGTH
       JSR  PRTIN            PRINT IT
       BRN  PRV06            MERGE TO FINISH UP
.FI
       ENP                   END PROCEDURE PRTVL
PRTVN  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         STACK VRBLK POINTER
       ADD  *VRSOF,XR        POINT TO POSSIBLE STRING NAME
       BNZ  SCLEN(XR),PRVN1  JUMP IF NOT SYSTEM VARIABLE
       MOV  VRSVO(XR),XR     POINT TO SVBLK WITH NAME
PRVN1  JSR  PRTST            PRINT STRING NAME OF VARIABLE
       MOV  (XS)+,XR         RESTORE VRBLK POINTER
       EXI                   RETURN TO PRTVN CALLER
       ENP                   END PROCEDURE PRTVN
.IF    .CNRA
.ELSE
RCBLD  PRC  E,0              ENTRY POINT
       MOV  DNAMP,XR         LOAD POINTER TO NEXT AVAILABLE LOC
       ADD  *RCSI_,XR        POINT PAST NEW RCBLK
       BLO  XR,DNAME,RCBL1   JUMP IF THERE IS ROOM
       MOV  *RCSI_,WA        ELSE LOAD RCBLK LENGTH
       JSR  ALLOC            USE STANDARD ALLOCATOR TO GET BLOCK
       ADD  WA,XR            POINT PAST BLOCK TO MERGE
RCBL1  MOV  XR,DNAMP         SET NEW POINTER
       SUB  *RCSI_,XR        POINT BACK TO START OF BLOCK
       MOV  =B_RCL,(XR)      STORE TYPE WORD
       STR  RCVAL(XR)        STORE REAL VALUE IN RCBLK
       EXI                   RETURN TO RCBLD CALLER
       ENP                   END PROCEDURE RCBLD
.FI
READR  PRC  E,0              ENTRY POINT
       MOV  R_CNI,XR         GET PTR TO NEXT IMAGE
       BNZ  XR,READ3         EXIT IF ALREADY READ
.IF    .CINC
       BNZ  CNIND,READA      IF WITHIN INCLUDE FILE
.FI
       BNE  STAGE,=STGIC,READ3 EXIT IF NOT INITIAL COMPILE
READA  MOV  CSWIN,WA         MAX READ LENGTH
       ZER  XL               CLEAR ANY DUD VALUE IN XL
       JSR  ALOCS            ALLOCATE BUFFER
       JSR  SYSRD            READ INPUT IMAGE
       PPM  READ4            JUMP IF EOF OR NEW FILE NAME
       ICV  RDNLN            INCREMENT NEXT LINE NUMBER
.IF    .CPOL
       DCV  POLCT            TEST IF TIME TO POLL INTERFACE
       BNZ  POLCT,READ0      NOT YET
       ZER  WA               =0 FOR POLL
       MOV  RDNLN,WB         LINE NUMBER
       JSR  SYSPL            ALLOW INTERACTIVE ACCESS
       ERR  320,User interrupt
       PPM                   SINGLE STEP
       PPM                   EXPRESSION EVALUATION
       MOV  WA,POLCS         NEW COUNTDOWN START VALUE
       MOV  WA,POLCT         NEW COUNTER VALUE
.FI
READ0  BLE  SCLEN(XR),CSWIN,READ1  USE SMALLER OF STRING LNTH ...
       MOV  CSWIN,SCLEN(XR)  ... AND XXX OF -INXXX
READ1  MNZ  WB               SET TRIMR TO PERFORM TRIM
       JSR  TRIMR            TRIM TRAILING BLANKS
READ2  MOV  XR,R_CNI         STORE COPY OF POINTER
READ3  EXI                   RETURN TO READR CALLER
.IF    .CSFN
READ4  BZE  SCLEN(XR),READ5  JUMP IF TRUE END OF FILE
       ZER  WB               NEW SOURCE FILE NAME
       MOV  WB,RDNLN         RESTART LINE COUNTER FOR NEW FILE
       JSR  TRIMR            REMOVE UNUSED SPACE IN BLOCK
       JSR  NEWFN            RECORD NEW FILE NAME
       BRN  READA            NOW REISSUE READ FOR RECORD DATA
READ5  MOV  XR,DNAMP         POP UNUSED SCBLK
.IF    .CINC
       BZE  CNIND,READ6      JUMP IF NOT WITHIN AN INCLUDE FILE
       ZER  XL               EOF WITHIN INCLUDE FILE
       JSR  SYSIF            SWITCH STREAM BACK TO PREVIOUS FILE
       PPM
       MOV  CNIND,WA         RESTORE PREV LINE NUMBER, FILE NAME
       ADD  =VCVLB,WA        VECTOR OFFSET IN WORDS
       WTB  WA               CONVERT TO BYTES
       MOV  R_IFA,XR         FILE NAME ARRAY
       ADD  WA,XR            PTR TO ELEMENT
       MOV  (XR),R_SFC       CHANGE SOURCE FILE NAME
       MOV  =NULLS,(XR)      RELEASE SCBLK
       MOV  R_IFL,XR         LINE NUMBER ARRAY
       ADD  WA,XR            PTR TO ELEMENT
       MOV  (XR),XL          ICBLK CONTAINING SAVED LINE NUMBER
       LDI  ICVAL(XL)        LINE NUMBER INTEGER
       MFI  RDNLN            CHANGE SOURCE LINE NUMBER
       MOV  =INTON,(XR)      RELEASE ICBLK
       DCV  CNIND            DECREMENT NESTING LEVEL
       MOV  CMPSN,WB         CURRENT STATEMENT NUMBER
       ICV  WB               ANTICIPATE END OF PREVIOUS STMT
       MTI  WB               CONVERT TO INTEGER
       JSR  ICBLD            BUILD ICBLK FOR STMT NUMBER
       MOV  R_SFN,XL         FILE NAME TABLE
       MNZ  WB               LOOKUP STATEMENT NUMBER BY NAME
       JSR  TFIND            ALLOCATE NEW TEBLK
       PPM                   ALWAYS POSSIBLE TO ALLOCATE BLOCK
       MOV  R_SFC,TEVAL(XL)  RECORD FILE NAME AS ENTRY VALUE
       BEQ  STAGE,=STGIC,READA IF INITIAL COMPILE, REISSUE READ
       BNZ  CNIND,READA      STILL READING FROM INCLUDE FILE
       MOV  R_ICI,XL         RESTORE CODE ARGUMENT STRING
       ZER  R_ICI            RELEASE ORIGINAL STRING
       MOV  CNSIL,WA         GET LENGTH OF STRING
       MOV  CNSPT,WB         OFFSET OF CHARACTERS LEFT
       SUB  WB,WA            NUMBER OF CHARACTERS LEFT
       MOV  WA,SCNIL         SET NEW SCAN LENGTH
       ZER  SCNPT            SCAN FROM START OF SUBSTRING
       JSR  SBSTR            CREATE SUBSTRING OF REMAINDER
       MOV  XR,R_CIM         SET SCAN IMAGE
       BRN  READ2            RETURN
.FI
.ELSE
READ4  MOV  XR,DNAMP         POP UNUSED SCBLK
.IF    .CINC
       BZE  CNIND,READ6      JUMP IF NOT WITHIN AN INCLUDE FILE
       ZER  XL               EOF WITHIN INCLUDE FILE
       JSR  SYSIF            SWITCH STREAM BACK TO PREVIOUS FILE
       PPM
       DCV  CNIND            DECREMENT NESTING LEVEL
       BRN  READA            REISSUE READ FROM PREVIOUS STREAM
.FI
.FI
READ6  ZER  XR               ZERO PTR AS RESULT
       BRN  READ2            MERGE
       ENP                   END PROCEDURE READR
.IF    .C370
SBOOL  PRC  N,3              ENTRY POINT
       JSR  GTSTG            CONVERT SECOND ARG TO STRING
       PPM  SBL05            JUMP IF SECOND ARG NOT STRING
       MOV  XR,XL            ELSE SAVE POINTER
       MOV  WA,WC            AND LENGTH
       BZE  WB,SBL01         ONLY ONE ARGUMENT IF COMPL
       JSR  GTSTG            CONVERT FIRST ARGUMENT TO STRING
       PPM  SBL04            JUMP IF NOT STRING
       BNE  WA,WC,SBL03      JUMP IF LENGTHS UNEQUAL
SBL01  MOV  XR,-(XS)         STACK FIRST ARGUMENT
       BZE  WC,SBL02         RETURN NULL IF NULL ARGUMENT
       JSR  ALOCS            ALLOCATE SPACE FOR COPY
       BZE  WB,SBL06         ONLY ONE ARGUMENT IF COMPL
       MOV  WC,WA            STRING LENGTH
       MOV  XR,WB            SAVE ADDRESS OF COPY
       CTB  WA,SCHAR         GET SCBLK LENGTH
       MVW                   MOVE ARG2 CONTENTS TO COPY
       MOV  WB,XR            RELOAD RESULT PTR
SBL06  MOV  (XS)+,XL         RELOAD FIRST ARGUMENT
       MOV  XR,-(XS)         STACK RESULT
       ADD  *SCHAR,XL        POINT TO CHARACTERS IN ARG 1 BLOCK
       ADD  *SCHAR,XR        POINT TO CHARACTERS IN RESULT BLOCK
       MOV  WC,WA            CHARACTER COUNT
       CTW  WC,0             NUMBER OF WORDS OF CHARACTERS
       LCT  WC,WC            PREPARE COUNTER
       EXI
SBL02  EXI  4                TAKE NULL STRING EXIT
SBL03  EXI  3                TAKE UNEQUAL LENGTH ERROR EXIT
SBL04  EXI  1                TAKE BAD FIRST ARG ERROR EXIT
SBL05  EXI  2                TAKE BAD SECOND ARG ERROR EXIT
       ENP                   END PROCEDURE SBOOL
.FI
SBSTR  PRC  E,0              ENTRY POINT
       BZE  WA,SBST2         JUMP IF NULL SUBSTRING
       JSR  ALOCS            ELSE ALLOCATE SCBLK
       MOV  WC,WA            MOVE NUMBER OF CHARACTERS
       MOV  XR,WC            SAVE PTR TO NEW SCBLK
       PLC  XL,WB            PREPARE TO LOAD CHARS FROM OLD BLK
       PSC  XR               PREPARE TO STORE CHARS IN NEW BLK
       MVC                   MOVE CHARACTERS TO NEW STRING
       MOV  WC,XR            THEN RESTORE SCBLK POINTER
SBST1  ZER  XL               CLEAR GARBAGE POINTER IN XL
       EXI                   RETURN TO SBSTR CALLER
SBST2  MOV  =NULLS,XR        SET NULL STRING AS RESULT
       BRN  SBST1            RETURN
       ENP                   END PROCEDURE SBSTR
STGCC  PRC  E,0
.IF    .CPOL
       MOV  POLCS,WA         ASSUME NO PROFILING OR STCOUNT TRACING
       MOV  =NUM01,WB        POLL EACH TIME POLCS EXPIRES
.ELSE
       MOV  CFP_M,WA         ASSUME NO PROFILING OR STCOUNT TRACING
.FI
       LDI  KVSTL            GET STMT LIMIT
       BNZ  KVPFL,STGC1      JUMP IF PROFILING ENABLED
       ILT  STGC3            NO STCOUNT TRACING IF NEGATIVE
       BZE  R_STC,STGC2      JUMP IF NOT STCOUNT TRACING
.IF    .CPOL
STGC1  MOV  WA,WB            COUNT POLCS TIMES WITHIN STMG
       MOV  =NUM01,WA        BREAK OUT OF STMGO ON EACH STMT
.ELSE
STGC1  MOV  =NUM01,WA        BREAK OUT OF STMGO ON EACH STMT
.FI
       BRN  STGC3
STGC2  MTI  WA               BREAKOUT COUNT START VALUE
       SBI  KVSTL            PROPOSED STMCS MINUS STMT LIMIT
       ILE  STGC3            JUMP IF STMT COUNT DOES NOT LIMIT
       LDI  KVSTL            STLIMIT LIMITS BREAKCOUNT COUNT
       MFI  WA               USE IT INSTEAD
STGC3  MOV  WA,STMCS         UPDATE BREAKOUT COUNT START VALUE
       MOV  WA,STMCT         RESET BREAKOUT COUNTER
.IF    .CPOL
       MOV  WB,POLCT
.FI
       EXI
TFIND  PRC  E,1              ENTRY POINT
       MOV  WB,-(XS)         SAVE NAME/VALUE INDICATOR
       MOV  XR,-(XS)         SAVE SUBSCRIPT VALUE
       MOV  XL,-(XS)         SAVE TABLE POINTER
       MOV  TBLEN(XL),WA     LOAD LENGTH OF TBBLK
       BTW  WA               CONVERT TO WORD COUNT
       SUB  =TBBUK,WA        GET NUMBER OF BUCKETS
       MTI  WA               CONVERT TO INTEGER VALUE
       STI  TFNSI            SAVE FOR LATER
       MOV  (XR),XL          LOAD FIRST WORD OF SUBSCRIPT
       LEI  XL               LOAD BLOCK ENTRY ID (BL_XX)
       BSW  XL,BL__D,TFN00   SWITCH ON BLOCK TYPE
       IFF  BL_IC,TFN02      JUMP IF INTEGER
.IF    .CNRA
.ELSE
       IFF  BL_RC,TFN02      REAL
.FI
       IFF  BL_P0,TFN03      JUMP IF PATTERN
       IFF  BL_P1,TFN03      JUMP IF PATTERN
       IFF  BL_P2,TFN03      JUMP IF PATTERN
       IFF  BL_NM,TFN04      JUMP IF NAME
       IFF  BL_SC,TFN05      JUMP IF STRING
       ESW                   END SWITCH ON BLOCK TYPE
TFN00  MOV  1(XR),WA         LOAD SECOND WORD
TFN01  MTI  WA               CONVERT TO INTEGER
       BRN  TFN06            JUMP TO MERGE
TFN02  LDI  1(XR)            LOAD VALUE AS HASH SOURCE
       IGE  TFN06            OK IF POSITIVE OR ZERO
       NGI                   MAKE POSITIVE
       IOV  TFN06            CLEAR POSSIBLE OVERFLOW
       BRN  TFN06            MERGE
TFN03  MOV  (XR),WA          LOAD FIRST WORD AS HASH SOURCE
       BRN  TFN01            MERGE BACK
TFN04  MOV  NMOFS(XR),WA     LOAD OFFSET AS HASH SOURCE
       BRN  TFN01            MERGE BACK
TFN05  JSR  HASHS            CALL ROUTINE TO COMPUTE HASH
TFN06  RMI  TFNSI            COMPUTE HASH INDEX BY REMAINDERING
       MFI  WC               GET AS ONE WORD INTEGER
       WTB  WC               CONVERT TO BYTE OFFSET
       MOV  (XS),XL          GET TABLE PTR AGAIN
       ADD  WC,XL            POINT TO PROPER BUCKET
       MOV  TBBUK(XL),XR     LOAD FIRST TEBLK POINTER
       BEQ  XR,(XS),TFN10    JUMP IF NO TEBLKS ON CHAIN
TFN07  MOV  XR,WB            SAVE TEBLK POINTER
       MOV  TESUB(XR),XR     LOAD SUBSCRIPT VALUE
       MOV  1(XS),XL         LOAD INPUT ARGUMENT SUBSCRIPT VAL
       JSR  IDENT            COMPARE THEM
       PPM  TFN08            JUMP IF EQUAL (IDENT)
       MOV  WB,XL            RESTORE TEBLK POINTER
       MOV  TENXT(XL),XR     POINT TO NEXT TEBLK ON CHAIN
       BNE  XR,(XS),TFN07    JUMP IF THERE IS ONE
       MOV  *TENXT,WC        SET OFFSET TO LINK FIELD (XL BASE)
       BRN  TFN11            JUMP TO MERGE
TFN08  MOV  WB,XL            RESTORE TEBLK POINTER
       MOV  *TEVAL,WA        SET TEBLK NAME OFFSET
       MOV  2(XS),WB         RESTORE NAME/VALUE INDICATOR
       BNZ  WB,TFN09         JUMP IF CALLED BY NAME
       JSR  ACESS            ELSE GET VALUE
       PPM  TFN12            JUMP IF REFERENCE FAILS
       ZER  WB               RESTORE NAME/VALUE INDICATOR
TFN09  ADD  *NUM03,XS        POP STACK ENTRIES
       EXI                   RETURN TO TFIND CALLER
TFN10  ADD  *TBBUK,WC        GET OFFSET TO BUCKET PTR
       MOV  (XS),XL          SET TBBLK PTR AS BASE
TFN11  MOV  (XS),XR          TBBLK POINTER
       MOV  TBINV(XR),XR     LOAD DEFAULT VALUE IN CASE
       MOV  2(XS),WB         LOAD NAME/VALUE INDICATOR
       BZE  WB,TFN09         EXIT WITH DEFAULT IF VALUE CALL
       MOV  XR,WB            COPY DEFAULT VALUE
       MOV  *TESI_,WA        SET SIZE OF TEBLK
       JSR  ALLOC            ALLOCATE TEBLK
       ADD  WC,XL            POINT TO HASH LINK
       MOV  XR,(XL)          LINK NEW TEBLK AT END OF CHAIN
       MOV  =B_TET,(XR)      STORE TYPE WORD
       MOV  WB,TEVAL(XR)     SET DEFAULT AS INITIAL VALUE
       MOV  (XS)+,TENXT(XR)  SET TBBLK PTR TO MARK END OF CHAIN
       MOV  (XS)+,TESUB(XR)  STORE SUBSCRIPT VALUE
       MOV  (XS)+,WB         RESTORE NAME/VALUE INDICATOR
       MOV  XR,XL            COPY TEBLK POINTER (NAME BASE)
       MOV  *TEVAL,WA        SET OFFSET
       EXI                   RETURN TO CALLER WITH NEW TEBLK
TFN12  EXI  1                ALTERNATIVE RETURN
       ENP                   END PROCEDURE TFIND
TMAKE  PRC  E,0
       MOV  WC,WA            COPY NUMBER OF HEADERS
       ADD  =TBSI_,WA        ADJUST FOR STANDARD FIELDS
       WTB  WA               CONVERT LENGTH TO BYTES
       JSR  ALLOC            ALLOCATE SPACE FOR TBBLK
       MOV  XR,WB            COPY POINTER TO TBBLK
       MOV  =B_TBT,(XR)+     STORE TYPE WORD
       ZER  (XR)+            ZERO ID FOR THE MOMENT
       MOV  WA,(XR)+         STORE LENGTH (TBLEN)
       MOV  XL,(XR)+         STORE INITIAL LOOKUP VALUE
       LCT  WC,WC            SET LOOP COUNTER (NUM HEADERS)
TMA01  MOV  WB,(XR)+         STORE TBBLK PTR IN BUCKET HEADER
       BCT  WC,TMA01         LOOP TILL ALL STORED
       MOV  WB,XR            RECALL POINTER TO TBBLK
       EXI
       ENP
VMAKE  PRC  E,1              ENTRY POINT
       LCT  WB,WA            COPY ELEMENTS FOR LOOP LATER ON
       ADD  =VCSI_,WA        ADD SPACE FOR STANDARD FIELDS
       WTB  WA               CONVERT LENGTH TO BYTES
       BGT  WA,MXLEN,VMAK2   FAIL IF TOO LARGE
       JSR  ALLOC            ALLOCATE SPACE FOR VCBLK
       MOV  =B_VCT,(XR)      STORE TYPE WORD
       ZER  IDVAL(XR)        INITIALIZE IDVAL
       MOV  WA,VCLEN(XR)     SET LENGTH
       MOV  XL,WC            COPY DEFAULT VALUE
       MOV  XR,XL            COPY VCBLK POINTER
       ADD  *VCVLS,XL        POINT TO FIRST ELEMENT VALUE
VMAK1  MOV  WC,(XL)+         STORE ONE VALUE
       BCT  WB,VMAK1         LOOP TILL ALL STORED
       EXI                   SUCCESS RETURN
VMAK2  EXI  1                FAIL RETURN
       ENP
.IF    .CNRA
.ELSE
.FI
SCANE  PRC  E,0              ENTRY POINT
       ZER  SCNBL            RESET BLANKS FLAG
       MOV  WA,SCNSA         SAVE WA
       MOV  WB,SCNSB         SAVE WB
       MOV  WC,SCNSC         SAVE WC
       BZE  SCNRS,SCN03      JUMP IF NO RESCAN
       MOV  SCNTP,XL         SET PREVIOUS RETURNED SCAN TYPE
       MOV  R_SCP,XR         SET PREVIOUS RETURNED POINTER
       ZER  SCNRS            RESET RESCAN SWITCH
       BRN  SCN13            JUMP TO EXIT
SCN01  JSR  READR            READ NEXT IMAGE
       MOV  *DVUBS,WB        SET WB FOR NOT READING NAME
       BZE  XR,SCN30         TREAT AS SEMI-COLON IF NONE
       PLC  XR               ELSE POINT TO FIRST CHARACTER
       LCH  WC,(XR)          LOAD FIRST CHARACTER
       BEQ  WC,=CH_DT,SCN02  JUMP IF DOT FOR CONTINUATION
       BNE  WC,=CH_PL,SCN30  ELSE TREAT AS SEMICOLON UNLESS PLUS
SCN02  JSR  NEXTS            ACQUIRE NEXT SOURCE IMAGE
       MOV  =NUM01,SCNPT     SET SCAN POINTER PAST CONTINUATION
       MNZ  SCNBL            SET BLANKS FLAG
SCN03  MOV  SCNPT,WA         LOAD CURRENT OFFSET
       BEQ  WA,SCNIL,SCN01   CHECK CONTINUATION IF END
       MOV  R_CIM,XL         POINT TO CURRENT LINE
       PLC  XL,WA            POINT TO CURRENT CHARACTER
       MOV  WA,SCNSE         SET START OF ELEMENT LOCATION
       MOV  =OPDVS,WC        POINT TO OPERATOR DV LIST
       MOV  *DVUBS,WB        SET CONSTANT FOR OPERATOR CIRCUIT
       BRN  SCN06            START SCANNING
SCN05  BZE  WB,SCN10         JUMP IF TRAILING
       ICV  SCNSE            INCREMENT START OF ELEMENT
       BEQ  WA,SCNIL,SCN01   JUMP IF END OF IMAGE
       MNZ  SCNBL            NOTE BLANKS SEEN
SCN06  LCH  XR,(XL)+         GET NEXT CHARACTER
       ICV  WA               BUMP SCAN OFFSET
       MOV  WA,SCNPT         STORE OFFSET PAST CHAR SCANNED
.IF    .CUCF
       BSW  XR,CFP_U,SCN07   SWITCH ON SCANNED CHARACTER
.ELSE
       BSW  XR,CFP_A,SCN07   SWITCH ON SCANNED CHARACTER
.FI
       IFF  CH_BL,SCN05      BLANK
.IF    .CAHT
       IFF  CH_HT,SCN05      HORIZONTAL TAB
.FI
.IF    .CAVT
       IFF  CH_VT,SCN05      VERTICAL TAB
.FI
.IF    .CAEX
       IFF  CH_EY,SCN37      UP ARROW
.FI
       IFF  CH_D0,SCN08      DIGIT 0
       IFF  CH_D1,SCN08      DIGIT 1
       IFF  CH_D2,SCN08      DIGIT 2
       IFF  CH_D3,SCN08      DIGIT 3
       IFF  CH_D4,SCN08      DIGIT 4
       IFF  CH_D5,SCN08      DIGIT 5
       IFF  CH_D6,SCN08      DIGIT 6
       IFF  CH_D7,SCN08      DIGIT 7
       IFF  CH_D8,SCN08      DIGIT 8
       IFF  CH_D9,SCN08      DIGIT 9
       IFF  CH_LA,SCN09      LETTER A
       IFF  CH_LB,SCN09      LETTER B
       IFF  CH_LC,SCN09      LETTER C
       IFF  CH_LD,SCN09      LETTER D
       IFF  CH_LE,SCN09      LETTER E
       IFF  CH_LG,SCN09      LETTER G
       IFF  CH_LH,SCN09      LETTER H
       IFF  CH_LI,SCN09      LETTER I
       IFF  CH_LJ,SCN09      LETTER J
       IFF  CH_LK,SCN09      LETTER K
       IFF  CH_LL,SCN09      LETTER L
       IFF  CH_LM,SCN09      LETTER M
       IFF  CH_LN,SCN09      LETTER N
       IFF  CH_LO,SCN09      LETTER O
       IFF  CH_LP,SCN09      LETTER P
       IFF  CH_LQ,SCN09      LETTER Q
       IFF  CH_LR,SCN09      LETTER R
       IFF  CH_LT,SCN09      LETTER T
       IFF  CH_LU,SCN09      LETTER U
       IFF  CH_LV,SCN09      LETTER V
       IFF  CH_LW,SCN09      LETTER W
       IFF  CH_LX,SCN09      LETTER X
       IFF  CH_LY,SCN09      LETTER Y
       IFF  CH_L_,SCN09      LETTER Z
.IF    .CASL
       IFF  CH__A,SCN09      SHIFTED A
       IFF  CH__B,SCN09      SHIFTED B
       IFF  CH__C,SCN09      SHIFTED C
       IFF  CH__D,SCN09      SHIFTED D
       IFF  CH__E,SCN09      SHIFTED E
       IFF  CH__F,SCN20      SHIFTED F
       IFF  CH__G,SCN09      SHIFTED G
       IFF  CH__H,SCN09      SHIFTED H
       IFF  CH__I,SCN09      SHIFTED I
       IFF  CH__J,SCN09      SHIFTED J
       IFF  CH__K,SCN09      SHIFTED K
       IFF  CH__L,SCN09      SHIFTED L
       IFF  CH__M,SCN09      SHIFTED M
       IFF  CH__N,SCN09      SHIFTED N
       IFF  CH__O,SCN09      SHIFTED O
       IFF  CH__P,SCN09      SHIFTED P
       IFF  CH__Q,SCN09      SHIFTED Q
       IFF  CH__R,SCN09      SHIFTED R
       IFF  CH__S,SCN21      SHIFTED S
       IFF  CH__T,SCN09      SHIFTED T
       IFF  CH__U,SCN09      SHIFTED U
       IFF  CH__V,SCN09      SHIFTED V
       IFF  CH__W,SCN09      SHIFTED W
       IFF  CH__X,SCN09      SHIFTED X
       IFF  CH__Y,SCN09      SHIFTED Y
       IFF  CH___,SCN09      SHIFTED Z
.FI
       IFF  CH_SQ,SCN16      SINGLE QUOTE
       IFF  CH_DQ,SCN17      DOUBLE QUOTE
       IFF  CH_LF,SCN20      LETTER F
       IFF  CH_LS,SCN21      LETTER S
       IFF  CH_UN,SCN24      UNDERLINE
       IFF  CH_PP,SCN25      LEFT PAREN
       IFF  CH_RP,SCN26      RIGHT PAREN
       IFF  CH_RB,SCN27      RIGHT BRACKET
       IFF  CH_BB,SCN28      LEFT BRACKET
       IFF  CH_CB,SCN27      RIGHT BRACKET
       IFF  CH_OB,SCN28      LEFT BRACKET
       IFF  CH_CL,SCN29      COLON
       IFF  CH_SM,SCN30      SEMI-COLON
       IFF  CH_CM,SCN31      COMMA
       IFF  CH_DT,SCN32      DOT
       IFF  CH_PL,SCN33      PLUS
       IFF  CH_MN,SCN34      MINUS
       IFF  CH_NT,SCN35      NOT
       IFF  CH_DL,SCN36      DOLLAR
       IFF  CH_EX,SCN37      EXCLAMATION MARK
       IFF  CH_PC,SCN38      PERCENT
       IFF  CH_SL,SCN40      SLASH
       IFF  CH_NM,SCN41      NUMBER SIGN
       IFF  CH_AT,SCN42      AT
       IFF  CH_BR,SCN43      VERTICAL BAR
       IFF  CH_AM,SCN44      AMPERSAND
       IFF  CH_QU,SCN45      QUESTION MARK
       IFF  CH_EQ,SCN46      EQUAL
       IFF  CH_AS,SCN49      ASTERISK
       ESW                   END SWITCH ON CHARACTER
SCN07  BZE  WB,SCN10         JUMP IF SCANNING NAME OR CONSTANT
       ERB  230,Syntax error: Illegal character
SCN08  BZE  WB,SCN09         KEEP SCANNING IF NAME/CONSTANT
       ZER  WC               ELSE SET FLAG FOR SCANNING CONSTANT
SCN09  BEQ  WA,SCNIL,SCN11   JUMP IF END OF IMAGE
       ZER  WB               SET FLAG FOR SCANNING NAME/CONST
       BRN  SCN06            MERGE BACK TO CONTINUE SCAN
SCN10  DCV  WA               RESET OFFSET TO POINT TO DELIMITER
SCN11  MOV  WA,SCNPT         STORE UPDATED SCAN OFFSET
       MOV  SCNSE,WB         POINT TO START OF ELEMENT
       SUB  WB,WA            GET NUMBER OF CHARACTERS
       MOV  R_CIM,XL         POINT TO LINE IMAGE
       BNZ  WC,SCN15         JUMP IF NAME
       JSR  SBSTR            GET STRING FOR CONSTANT
       MOV  XR,DNAMP         DELETE FROM STORAGE (NOT NEEDED)
       JSR  GTNUM            CONVERT TO NUMERIC
       PPM  SCN14            JUMP IF CONVERSION FAILURE
SCN12  MOV  =T_CON,XL        SET RESULT TYPE OF CONSTANT
SCN13  MOV  SCNSA,WA         RESTORE WA
       MOV  SCNSB,WB         RESTORE WB
       MOV  SCNSC,WC         RESTORE WC
       MOV  XR,R_SCP         SAVE XR IN CASE RESCAN
       MOV  XL,SCNTP         SAVE XL IN CASE RESCAN
       ZER  SCNGO            RESET POSSIBLE GOTO FLAG
       EXI                   RETURN TO SCANE CALLER
SCN14  ERB  231,Syntax error: Invalid numeric item
SCN15  JSR  SBSTR            BUILD STRING NAME OF VARIABLE
       BNZ  SCNCC,SCN13      RETURN IF CNCRD CALL
       JSR  GTNVR            LOCATE/BUILD VRBLK
       PPM                   DUMMY (UNUSED) ERROR RETURN
       MOV  =T_VAR,XL        SET TYPE AS VARIABLE
       BRN  SCN13            BACK TO EXIT
SCN16  BZE  WB,SCN10         TERMINATOR IF SCANNING NAME OR CNST
       MOV  =CH_SQ,WB        SET TERMINATOR AS SINGLE QUOTE
       BRN  SCN18            MERGE
SCN17  BZE  WB,SCN10         TERMINATOR IF SCANNING NAME OR CNST
       MOV  =CH_DQ,WB        SET DOUBLE QUOTE TERMINATOR, MERGE
SCN18  BEQ  WA,SCNIL,SCN19   ERROR IF END OF IMAGE
       LCH  WC,(XL)+         ELSE LOAD NEXT CHARACTER
       ICV  WA               BUMP OFFSET
       BNE  WC,WB,SCN18      LOOP BACK IF NOT TERMINATOR
       MOV  SCNPT,WB         POINT TO FIRST CHARACTER
       MOV  WA,SCNPT         SAVE OFFSET PAST FINAL QUOTE
       DCV  WA               POINT BACK PAST LAST CHARACTER
       SUB  WB,WA            GET NUMBER OF CHARACTERS
       MOV  R_CIM,XL         POINT TO INPUT IMAGE
       JSR  SBSTR            BUILD SUBSTRING VALUE
       BRN  SCN12            BACK TO EXIT WITH CONSTANT RESULT
SCN19  MOV  WA,SCNPT         SET UPDATED SCAN POINTER
       ERB  232,Syntax error: Unmatched string quote
SCN20  MOV  =T_FGO,XR        SET RETURN CODE FOR FAIL GOTO
       BRN  SCN22            JUMP TO MERGE
SCN21  MOV  =T_SGO,XR        SET SUCCESS GOTO AS RETURN CODE
SCN22  BZE  SCNGO,SCN09      TREAT AS NORMAL LETTER IF NOT GOTO
SCN23  BZE  WB,SCN10         JUMP IF END OF NAME/CONSTANT
       MOV  XR,XL            ELSE COPY CODE
       BRN  SCN13            AND JUMP TO EXIT
SCN24  BZE  WB,SCN09         PART OF NAME IF SCANNING NAME
       BRN  SCN07            ELSE ILLEGAL
SCN25  MOV  =T_LPR,XR        SET LEFT PAREN RETURN CODE
       BNZ  WB,SCN23         RETURN LEFT PAREN UNLESS NAME
       BZE  WC,SCN10         DELIMITER IF SCANNING CONSTANT
       MOV  SCNSE,WB         POINT TO START OF NAME
       MOV  WA,SCNPT         SET POINTER PAST LEFT PAREN
       DCV  WA               POINT BACK PAST LAST CHAR OF NAME
       SUB  WB,WA            GET NAME LENGTH
       MOV  R_CIM,XL         POINT TO INPUT IMAGE
       JSR  SBSTR            GET STRING NAME FOR FUNCTION
       JSR  GTNVR            LOCATE/BUILD VRBLK
       PPM                   DUMMY (UNUSED) ERROR RETURN
       MOV  =T_FNC,XL        SET CODE FOR FUNCTION CALL
       BRN  SCN13            BACK TO EXIT
SCN26  MOV  =T_RPR,XR        RIGHT PAREN, SET CODE
       BRN  SCN23            TAKE SPECIAL CHARACTER EXIT
SCN27  MOV  =T_RBR,XR        RIGHT BRACKET, SET CODE
       BRN  SCN23            TAKE SPECIAL CHARACTER EXIT
SCN28  MOV  =T_LBR,XR        LEFT BRACKET, SET CODE
       BRN  SCN23            TAKE SPECIAL CHARACTER EXIT
SCN29  MOV  =T_COL,XR        COLON, SET CODE
       BRN  SCN23            TAKE SPECIAL CHARACTER EXIT
SCN30  MOV  =T_SMC,XR        SEMI-COLON, SET CODE
       BRN  SCN23            TAKE SPECIAL CHARACTER EXIT
SCN31  MOV  =T_CMA,XR        COMMA, SET CODE
       BRN  SCN23            TAKE SPECIAL CHARACTER EXIT
SCN32  BZE  WB,SCN09         DOT CAN BE PART OF NAME OR CONSTANT
       ADD  WB,WC            ELSE BUMP POINTER
SCN33  BZE  WC,SCN09         PLUS CAN BE PART OF CONSTANT
       BZE  WB,SCN48         PLUS CANNOT BE PART OF NAME
       ADD  WB,WC            ELSE BUMP POINTER
SCN34  BZE  WC,SCN09         MINUS CAN BE PART OF CONSTANT
       BZE  WB,SCN48         MINUS CANNOT BE PART OF NAME
       ADD  WB,WC            ELSE BUMP POINTER
SCN35  ADD  WB,WC            NOT
SCN36  ADD  WB,WC            DOLLAR
SCN37  ADD  WB,WC            EXCLAMATION
SCN38  ADD  WB,WC            PERCENT
SCN39  ADD  WB,WC            ASTERISK
SCN40  ADD  WB,WC            SLASH
SCN41  ADD  WB,WC            NUMBER SIGN
SCN42  ADD  WB,WC            AT SIGN
SCN43  ADD  WB,WC            VERTICAL BAR
SCN44  ADD  WB,WC            AMPERSAND
SCN45  ADD  WB,WC            QUESTION MARK
SCN46  BZE  WB,SCN10         OPERATOR TERMINATES NAME/CONSTANT
       MOV  WC,XR            ELSE COPY DV POINTER
       LCH  WC,(XL)          LOAD NEXT CHARACTER
       MOV  =T_BOP,XL        SET BINARY OP IN CASE
       BEQ  WA,SCNIL,SCN47   SHOULD BE BINARY IF IMAGE END
       BEQ  WC,=CH_BL,SCN47  SHOULD BE BINARY IF FOLLOWED BY BLK
.IF    .CAHT
       BEQ  WC,=CH_HT,SCN47  JUMP IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WC,=CH_VT,SCN47  JUMP IF VERTICAL TAB
.FI
       BEQ  WC,=CH_SM,SCN47  SEMICOLON CAN IMMEDIATELY FOLLOW =
       BEQ  WC,=CH_CL,SCN47  COLON CAN IMMEDIATELY FOLLOW =
       BEQ  WC,=CH_RP,SCN47  RIGHT PAREN CAN IMMEDIATELY FOLLOW =
       BEQ  WC,=CH_RB,SCN47  RIGHT BRACKET CAN IMMEDIATELY FOLLOW =
       BEQ  WC,=CH_CB,SCN47  RIGHT BRACKET CAN IMMEDIATELY FOLLOW =
       ADD  *DVBS_,XR        POINT TO DV FOR UNARY OP
       MOV  =T_UOP,XL        SET TYPE FOR UNARY OPERATOR
       BLE  SCNTP,=T_UOK,SCN13 OK UNARY IF OK PRECEDING ELEMENT
SCN47  BNZ  SCNBL,SCN13      ALL OK IF PRECEDING BLANKS, EXIT
SCN48  ERB  233,Syntax error: Invalid use of operator
SCN49  BZE  WB,SCN10         END OF NAME IF SCANNING NAME
       BEQ  WA,SCNIL,SCN39   NOT ** IF * AT IMAGE END
       MOV  WA,XR            ELSE SAVE OFFSET PAST FIRST *
       MOV  WA,SCNOF         SAVE ANOTHER COPY
       LCH  WA,(XL)+         LOAD NEXT CHARACTER
       BNE  WA,=CH_AS,SCN50  NOT ** IF NEXT CHAR NOT *
       ICV  XR               ELSE STEP OFFSET PAST SECOND *
       BEQ  XR,SCNIL,SCN51   OK EXCLAM IF END OF IMAGE
       LCH  WA,(XL)          ELSE LOAD NEXT CHARACTER
       BEQ  WA,=CH_BL,SCN51  EXCLAMATION IF BLANK
.IF    .CAHT
       BEQ  WA,=CH_HT,SCN51  EXCLAMATION IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WA,=CH_VT,SCN51  EXCLAMATION IF VERTICAL TAB
.FI
SCN50  MOV  SCNOF,WA         RECOVER STORED OFFSET
       MOV  R_CIM,XL         POINT TO LINE AGAIN
       PLC  XL,WA            POINT TO CURRENT CHAR
       BRN  SCN39            MERGE WITH UNARY *
SCN51  MOV  XR,SCNPT         SAVE SCAN POINTER PAST 2ND *
       MOV  XR,WA            COPY SCAN POINTER
       BRN  SCN37            MERGE WITH EXCLAMATION
       ENP                   END PROCEDURE SCANE
SCNGF  PRC  E,0              ENTRY POINT
       JSR  SCANE            SCAN INITIAL ELEMENT
       BEQ  XL,=T_LPR,SCNG1  SKIP IF LEFT PAREN (NORMAL GOTO)
       BEQ  XL,=T_LBR,SCNG2  SKIP IF LEFT BRACKET (DIRECT GOTO)
       ERB  234,Syntax error: Goto field incorrect
SCNG1  MOV  =NUM01,WB        SET EXPAN FLAG FOR NORMAL GOTO
       JSR  EXPAN            ANALYZE GOTO FIELD
       MOV  =OPDVN,WA        POINT TO OPDV FOR COMPLEX GOTO
       BLE  XR,STATB,SCNG3   JUMP IF NOT IN STATIC (SGD15)
       BLO  XR,STATE,SCNG4   JUMP TO EXIT IF SIMPLE LABEL NAME
       BRN  SCNG3            COMPLEX GOTO - MERGE
SCNG2  MOV  =NUM02,WB        SET EXPAN FLAG FOR DIRECT GOTO
       JSR  EXPAN            SCAN GOTO FIELD
       MOV  =OPDVD,WA        SET OPDV POINTER FOR DIRECT GOTO
SCNG3  MOV  WA,-(XS)         STACK OPERATOR DV POINTER
       MOV  XR,-(XS)         STACK POINTER TO EXPRESSION TREE
       JSR  EXPOP            POP OPERATOR OFF
       MOV  (XS)+,XR         RELOAD NEW EXPRESSION TREE POINTER
SCNG4  EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE SCNGF
SETVR  PRC  E,0              ENTRY POINT
       BHI  XR,STATE,SETV1   EXIT IF NOT NATURAL VARIABLE
       MOV  XR,XL            COPY VRBLK POINTER
       MOV  =B_VRL,VRGET(XR) STORE NORMAL GET VALUE
       BEQ  VRSTO(XR),=B_VRE,SETV1 SKIP IF PROTECTED VARIABLE
       MOV  =B_VRS,VRSTO(XR) STORE NORMAL STORE VALUE
       MOV  VRVAL(XL),XL     POINT TO NEXT ENTRY ON CHAIN
       BNE  (XL),=B_TRT,SETV1 JUMP IF END OF TRBLK CHAIN
       MOV  =B_VRA,VRGET(XR) STORE TRAPPED ROUTINE ADDRESS
       MOV  =B_VRV,VRSTO(XR) SET TRAPPED ROUTINE ADDRESS
SETV1  EXI                   RETURN TO SETVR CALLER
       ENP                   END PROCEDURE SETVR
.IF    .CNSR
.ELSE
SORTA  PRC  N,1              ENTRY POINT
       MOV  WA,SRTSR         SORT/RSORT INDICATOR
       MOV  *NUM01,SRTST     DEFAULT STRIDE OF 1
       ZER  SRTOF            DEFAULT ZERO OFFSET TO SORT KEY
       MOV  =NULLS,SRTDF     CLEAR DATATYPE FIELD NAME
       MOV  (XS)+,R_SXR      UNSTACK ARGUMENT 2
       MOV  (XS)+,XR         GET FIRST ARGUMENT
       MNZ  WA               USE KEY/VALUES OF TABLE ENTRIES
       JSR  GTARR            CONVERT TO ARRAY
       PPM  SRT18            SIGNAL THAT TABLE IS EMPTY
       PPM  SRT16            ERROR IF NON-CONVERTABLE
       MOV  XR,-(XS)         STACK PTR TO RESULTING KEY ARRAY
       MOV  XR,-(XS)         ANOTHER COPY FOR COPYB
       JSR  COPYB            GET COPY ARRAY FOR SORTING INTO
       PPM                   CANT FAIL
       MOV  XR,-(XS)         STACK POINTER TO SORT ARRAY
       MOV  R_SXR,XR         GET SECOND ARG
       MOV  NUM01(XS),XL     GET PTR TO KEY ARRAY
       BNE  (XL),=B_VCT,SRT02 JUMP IF ARBLK
       BEQ  XR,=NULLS,SRT01  JUMP IF NULL SECOND ARG
       JSR  GTNVR            GET VRBLK PTR FOR IT
       ERR  257,Erroneous 2nd arg in SORT/RSORT of vector
       MOV  XR,SRTDF         STORE DATATYPE FIELD NAME VRBLK
SRT01  MOV  *VCLEN,WC        OFFSET TO A(0)
       MOV  *VCVLS,WB        OFFSET TO FIRST ITEM
       MOV  VCLEN(XL),WA     GET BLOCK LENGTH
       SUB  *VCSI_,WA        GET NO. OF ENTRIES, N (IN BYTES)
       BRN  SRT04            MERGE
SRT02  LDI  ARDIM(XL)        GET POSSIBLE DIMENSION
       MFI  WA               CONVERT TO SHORT INTEGER
       WTB  WA               FURTHER CONVERT TO BAUS
       MOV  *ARVLS,WB        OFFSET TO FIRST VALUE IF ONE
       MOV  *ARPRO,WC        OFFSET BEFORE VALUES IF ONE DIM.
       BEQ  ARNDM(XL),=NUM01,SRT04 JUMP IN FACT IF ONE DIM.
       BNE  ARNDM(XL),=NUM02,SRT16  FAIL UNLESS TWO DIMENS
       LDI  ARLB2(XL)        GET LOWER BOUND 2 AS DEFAULT
       BEQ  XR,=NULLS,SRT03  JUMP IF DEFAULT SECOND ARG
       JSR  GTINT            CONVERT TO INTEGER
       PPM  SRT17            FAIL
       LDI  ICVAL(XR)        GET ACTUAL INTEGER VALUE
SRT03  SBI  ARLB2(XL)        SUBTRACT LOW BOUND
       IOV  SRT17            FAIL IF OVERFLOW
       ILT  SRT17            FAIL IF BELOW LOW BOUND
       SBI  ARDM2(XL)        CHECK AGAINST DIMENSION
       IGE  SRT17            FAIL IF TOO LARGE
       ADI  ARDM2(XL)        RESTORE VALUE
       MFI  WA               GET AS SMALL INTEGER
       WTB  WA               OFFSET WITHIN ROW TO KEY
       MOV  WA,SRTOF         KEEP OFFSET
       LDI  ARDM2(XL)        SECOND DIMENSION IS ROW LENGTH
       MFI  WA               CONVERT TO SHORT INTEGER
       MOV  WA,XR            COPY ROW LENGTH
       WTB  WA               CONVERT TO BYTES
       MOV  WA,SRTST         STORE AS STRIDE
       LDI  ARDIM(XL)        GET NUMBER OF ROWS
       MFI  WA               AS A SHORT INTEGER
       WTB  WA               CONVERT N TO BAUS
       MOV  ARLEN(XL),WC     OFFSET PAST ARRAY END
       SUB  WA,WC            ADJUST, GIVING SPACE FOR N OFFSETS
       DCA  WC               POINT TO A(0)
       MOV  AROFS(XL),WB     OFFSET TO WORD BEFORE FIRST ITEM
       ICA  WB               OFFSET TO FIRST ITEM
SRT04  BLE  WA,*NUM01,SRT15  RETURN IF ONLY A SINGLE ITEM
       MOV  WA,SRTSN         STORE NUMBER OF ITEMS (IN BAUS)
       MOV  WC,SRTSO         STORE OFFSET TO A(0)
       MOV  ARLEN(XL),WC     LENGTH OF ARRAY OR VEC (=VCLEN)
       ADD  XL,WC            POINT PAST END OF ARRAY OR VECTOR
       MOV  WB,SRTSF         STORE OFFSET TO FIRST ROW
       ADD  WB,XL            POINT TO FIRST ITEM IN KEY ARRAY
SRT05  MOV  (XL),XR          GET AN ENTRY
SRT06  BNE  (XR),=B_TRT,SRT07 JUMP OUT IF NOT TRBLK
       MOV  TRVAL(XR),XR     GET VALUE FIELD
       BRN  SRT06            LOOP
SRT07  MOV  XR,(XL)+         STORE AS ARRAY ENTRY
       BLT  XL,WC,SRT05      LOOP IF NOT DONE
       MOV  (XS),XL          GET ADRS OF SORT ARRAY
       MOV  SRTSF,XR         INITIAL OFFSET TO FIRST KEY
       MOV  SRTST,WB         GET STRIDE
       ADD  SRTSO,XL         OFFSET TO A(0)
       ICA  XL               POINT TO A(1)
       MOV  SRTSN,WC         GET N
       BTW  WC               CONVERT FROM BYTES
       MOV  WC,SRTNR         STORE AS ROW COUNT
       LCT  WC,WC            LOOP COUNTER
SRT08  MOV  XR,(XL)+         STORE AN OFFSET
       ADD  WB,XR            BUMP OFFSET BY STRIDE
       BCT  WC,SRT08         LOOP THROUGH ROWS
SRT09  MOV  SRTSN,WA         GET N
       MOV  SRTNR,WC         GET NUMBER OF ROWS
       RSH  WC,1             I = N / 2 (WC=I, INDEX INTO ARRAY)
       WTB  WC               CONVERT BACK TO BYTES
SRT10  JSR  SORTH            SORTH(I,N)
       DCA  WC               I = I - 1
       BNZ  WC,SRT10         LOOP IF I GT 0
       MOV  WA,WC            I = N
SRT11  DCA  WC               I = I - 1 (N - 1 INITIALLY)
       BZE  WC,SRT12         JUMP IF DONE
       MOV  (XS),XR          GET SORT ARRAY ADDRESS
       ADD  SRTSO,XR         POINT TO A(0)
       MOV  XR,XL            A(0) ADDRESS
       ADD  WC,XL            A(I) ADDRESS
       MOV  NUM01(XL),WB     COPY A(I+1)
       MOV  NUM01(XR),NUM01(XL)  MOVE A(1) TO A(I+1)
       MOV  WB,NUM01(XR)     COMPLETE EXCHANGE OF A(1), A(I+1)
       MOV  WC,WA            N = I FOR SORTH
       MOV  *NUM01,WC        I = 1 FOR SORTH
       JSR  SORTH            SORTH(1,N)
       MOV  WA,WC            RESTORE WC
       BRN  SRT11            LOOP
SRT12  MOV  (XS),XR          BASE ADRS OF KEY ARRAY
       MOV  XR,WC            COPY IT
       ADD  SRTSO,WC         OFFSET OF A(0)
       ADD  SRTSF,XR         ADRS OF FIRST ROW OF SORT ARRAY
       MOV  SRTST,WB         GET STRIDE
SRT13  ICA  WC               ADRS OF NEXT OF SORTED OFFSETS
       MOV  WC,XL            COPY IT FOR ACCESS
       MOV  (XL),XL          GET OFFSET
       ADD  NUM01(XS),XL     ADD KEY ARRAY BASE ADRS
       MOV  WB,WA            GET COUNT OF CHARACTERS IN ROW
       MVW                   COPY A COMPLETE ROW
       DCV  SRTNR            DECREMENT ROW COUNT
       BNZ  SRTNR,SRT13      REPEAT TILL ALL ROWS DONE
SRT15  MOV  (XS)+,XR         POP RESULT ARRAY PTR
       ICA  XS               POP KEY ARRAY PTR
       ZER  R_SXL            CLEAR JUNK
       ZER  R_SXR            CLEAR JUNK
       EXI                   RETURN
SRT16  ERB  256,SORT/RSORT 1st arg not suitable ARRAY or TABLE
SRT17  ERB  258,SORT/RSORT 2nd arg out of range or non-integer
SRT18  EXI  1                RETURN INDICATION OF NULL TABLE
       ENP                   END PROCUDURE SORTA
SORTC  PRC  E,1              ENTRY POINT
       MOV  WA,SRTS1         SAVE OFFSET 1
       MOV  WB,SRTS2         SAVE OFFSET 2
       MOV  WC,SRTSC         SAVE WC
       ADD  SRTOF,XL         ADD OFFSET TO COMPARAND FIELD
       MOV  XL,XR            COPY BASE + OFFSET
       ADD  WA,XL            ADD KEY1 OFFSET
       ADD  WB,XR            ADD KEY2 OFFSET
       MOV  (XL),XL          GET KEY1
       MOV  (XR),XR          GET KEY2
       BNE  SRTDF,=NULLS,SRC12 JUMP IF DATATYPE FIELD NAME USED
SRC01  MOV  (XL),WC          GET TYPE CODE
       BNE  WC,(XR),SRC02    SKIP IF NOT SAME DATATYPE
       BEQ  WC,=B_SCL,SRC09  JUMP IF BOTH STRINGS
       BEQ  WC,=B_ICL,SRC14  JUMP IF BOTH INTEGERS
.IF    .CNBF
.ELSE
       BEQ  WC,=B_BCT,SRC09  JUMP IF BOTH BUFFERS
.FI
SRC02  MOV  XL,R_SXL         KEEP ARG1
       MOV  XR,R_SXR         KEEP ARG2
.IF    .CNBF
.IF    .CNSC
       BEQ  WC,=B_SCL,SRC11  DO NOT ALLOW CONVERSION TO NUMBER
       BEQ  (XR),=B_SCL,SRC11 IF EITHER ARG IS A STRING
.FI
.ELSE
       BEQ  WC,=B_SCL,SRC13  JUMP IF KEY1 IS A STRING
.IF    .CNSC
       BNE  WC,=B_BCT,SRC15  J IF KEY1 IS NOT A STRING OR BUFFER
.ELSE
       BNE  WC,=B_BCT,SRC14  TRY CONVERTING KEY 2 TO A NUMBER
.FI
       BEQ  (XR),=B_SCL,SRC09 J IF KEYS 1/2 ARE BUFFER/STRING
.IF    .CNSC
       BRN  SRC11            PREVENT CONVERT OF KEY 1 TO NUMBER
.ELSE
       BRN  SRC14            TRY CONVERTING KEY 1 TO NUMBER
.FI
SRC13  BEQ  (XR),=B_BCT,SRC09 J IF KEYS 1/2 ARE STRING/BUFFER
.IF    .CNSC
       BRN  SRC11            PREVENT CONVERT OF KEY 1 TO NUMBER
SRC15  BEQ  (XR),=B_SCL,SRC11 J IF KEY 2 IS A STRING
       BEQ  (XR),=B_BCT,SRC11 J IF KEY 2 IS A BUFFER
.FI
.FI
SRC14  MOV  XL,-(XS)         STACK
       MOV  XR,-(XS)         ARGS
       JSR  ACOMP            COMPARE OBJECTS
       PPM  SRC10            NOT NUMERIC
       PPM  SRC10            NOT NUMERIC
       PPM  SRC03            KEY1 LESS
       PPM  SRC08            KEYS EQUAL
       PPM  SRC05            KEY1 GREATER
SRC03  BNZ  SRTSR,SRC06      JUMP IF RSORT
SRC04  MOV  SRTSC,WC         RESTORE WC
       EXI  1                RETURN
SRC05  BNZ  SRTSR,SRC04      JUMP IF RSORT
SRC06  MOV  SRTSC,WC         RESTORE WC
       EXI                   RETURN
SRC07  BLT  XL,XR,SRC03      ITEM FIRST CREATED IS LESS
       BGT  XL,XR,SRC05      ADDRESSES RISE IN ORDER OF CREATION
SRC08  BLT  SRTS1,SRTS2,SRC04 TEST OFFSETS OR KEY ADDRSS INSTEAD
       BRN  SRC06            OFFSET 1 GREATER
.IF    .CNBF
.ELSE
.FI
SRC09  MOV  XL,-(XS)         STACK
       MOV  XR,-(XS)         ARGS
       JSR  LCOMP            COMPARE OBJECTS
       PPM                   CANT
       PPM                   FAIL
       PPM  SRC03            KEY1 LESS
       PPM  SRC08            KEYS EQUAL
       PPM  SRC05            KEY1 GREATER
SRC10  MOV  R_SXL,XL         GET ARG1
       MOV  R_SXR,XR         GET ARG2
       MOV  (XL),WC          GET TYPE OF KEY1
       BEQ  WC,(XR),SRC07    JUMP IF KEYS OF SAME TYPE
SRC11  MOV  WC,XL            GET BLOCK TYPE WORD
       MOV  (XR),XR          GET BLOCK TYPE WORD
       LEI  XL               ENTRY POINT ID FOR KEY1
       LEI  XR               ENTRY POINT ID FOR KEY2
       BGT  XL,XR,SRC05      JUMP IF KEY1 GT KEY2
       BRN  SRC03            KEY1 LT KEY2
SRC12  JSR  SORTF            CALL ROUTINE TO FIND FIELD 1
       MOV  XL,-(XS)         STACK ITEM POINTER
       MOV  XR,XL            GET KEY2
       JSR  SORTF            FIND FIELD 2
       MOV  XL,XR            PLACE AS KEY2
       MOV  (XS)+,XL         RECOVER KEY1
       BRN  SRC01            MERGE
       ENP                   PROCEDURE SORTC
SORTF  PRC  E,0              ENTRY POINT
       BNE  (XL),=B_PDT,SRTF3 RETURN IF NOT PDBLK
       MOV  XR,-(XS)         KEEP XR
       MOV  SRTFD,XR         GET POSSIBLE FORMER DFBLK PTR
       BZE  XR,SRTF4         JUMP IF NOT
       BNE  XR,PDDFP(XL),SRTF4 JUMP IF NOT RIGHT DATATYPE
       BNE  SRTDF,SRTFF,SRTF4 JUMP IF NOT RIGHT FIELD NAME
       ADD  SRTFO,XL         ADD OFFSET TO REQUIRED FIELD
SRTF1  MOV  (XL),XL          GET ITEM FROM FIELD
SRTF2  MOV  (XS)+,XR         RESTORE XR
SRTF3  EXI                   RETURN
SRTF4  MOV  XL,XR            COPY ORIGINAL POINTER
       MOV  PDDFP(XR),XR     POINT TO DFBLK
       MOV  XR,SRTFD         KEEP A COPY
       MOV  FARGS(XR),WC     GET NUMBER OF FIELDS
       WTB  WC               CONVERT TO BYTES
       ADD  DFLEN(XR),XR     POINT PAST LAST FIELD
SRTF5  DCA  WC               COUNT DOWN
       DCA  XR               POINT IN FRONT
       BEQ  (XR),SRTDF,SRTF6 SKIP OUT IF FOUND
       BNZ  WC,SRTF5         LOOP
       BRN  SRTF2            RETURN - NOT FOUND
SRTF6  MOV  (XR),SRTFF       KEEP FIELD NAME PTR
       ADD  *PDFLD,WC        ADD OFFSET TO FIRST FIELD
       MOV  WC,SRTFO         STORE AS FIELD OFFSET
       ADD  WC,XL            POINT TO FIELD
       BRN  SRTF1            RETURN
       ENP                   PROCEDURE SORTF
SORTH  PRC  N,0              ENTRY POINT
       MOV  WA,SRTSN         SAVE N
       MOV  WC,SRTWC         KEEP WC
       MOV  (XS),XL          SORT ARRAY BASE ADRS
       ADD  SRTSO,XL         ADD OFFSET TO A(0)
       ADD  WC,XL            POINT TO A(J)
       MOV  (XL),SRTRT       GET OFFSET TO ROOT
       ADD  WC,WC            DOUBLE J - CANT EXCEED N
SRH01  BGT  WC,SRTSN,SRH03   DONE IF J GT N
       BEQ  WC,SRTSN,SRH02   SKIP IF J EQUALS N
       MOV  (XS),XR          SORT ARRAY BASE ADRS
       MOV  NUM01(XS),XL     KEY ARRAY BASE ADRS
       ADD  SRTSO,XR         POINT TO A(0)
       ADD  WC,XR            ADRS OF A(J)
       MOV  NUM01(XR),WA     GET A(J+1)
       MOV  (XR),WB          GET A(J)
       JSR  SORTC            COMPARE KEYS - LT(A(J+1),A(J))
       PPM  SRH02            A(J+1) LT A(J)
       ICA  WC               POINT TO GREATER SON, A(J+1)
SRH02  MOV  NUM01(XS),XL     KEY ARRAY BASE ADRS
       MOV  (XS),XR          GET SORT ARRAY ADDRESS
       ADD  SRTSO,XR         ADRS OF A(0)
       MOV  XR,WB            COPY THIS ADRS
       ADD  WC,XR            ADRS OF GREATER SON, A(J)
       MOV  (XR),WA          GET A(J)
       MOV  WB,XR            POINT BACK TO A(0)
       MOV  SRTRT,WB         GET ROOT
       JSR  SORTC            COMPARE THEM - LT(A(J),ROOT)
       PPM  SRH03            FATHER EXCEEDS SONS - DONE
       MOV  (XS),XR          GET SORT ARRAY ADRS
       ADD  SRTSO,XR         POINT TO A(0)
       MOV  XR,XL            COPY IT
       MOV  WC,WA            COPY J
       BTW  WC               CONVERT TO WORDS
       RSH  WC,1             GET J/2
       WTB  WC               CONVERT BACK TO BYTES
       ADD  WA,XL            POINT TO A(J)
       ADD  WC,XR            ADRS OF A(J/2)
       MOV  (XL),(XR)        A(J/2) = A(J)
       MOV  WA,WC            RECOVER J
       AOV  WC,WC,SRH03      J = J*2. DONE IF TOO BIG
       BRN  SRH01            LOOP
SRH03  BTW  WC               CONVERT TO WORDS
       RSH  WC,1             J = J/2
       WTB  WC               CONVERT BACK TO BYTES
       MOV  (XS),XR          SORT ARRAY ADRS
       ADD  SRTSO,XR         ADRS OF A(0)
       ADD  WC,XR            ADRS OF A(J/2)
       MOV  SRTRT,(XR)       A(J/2) = ROOT
       MOV  SRTSN,WA         RESTORE WA
       MOV  SRTWC,WC         RESTORE WC
       EXI                   RETURN
       ENP                   END PROCEDURE SORTH
.FI
TRACE  PRC  N,2              ENTRY POINT
       JSR  GTSTG            GET TRACE TYPE STRING
       PPM  TRC15            JUMP IF NOT STRING
       PLC  XR               ELSE POINT TO STRING
       LCH  WA,(XR)          LOAD FIRST CHARACTER
.IF    .CULC
       FLC  WA               FOLD TO UPPER CASE
.FI
       MOV  (XS),XR          LOAD NAME ARGUMENT
       MOV  XL,(XS)          STACK TRBLK PTR OR ZERO
       MOV  =TRTAC,WC        SET TRTYP FOR ACCESS TRACE
       BEQ  WA,=CH_LA,TRC10  JUMP IF A (ACCESS)
       MOV  =TRTVL,WC        SET TRTYP FOR VALUE TRACE
       BEQ  WA,=CH_LV,TRC10  JUMP IF V (VALUE)
       BEQ  WA,=CH_BL,TRC10  JUMP IF BLANK (VALUE)
       BEQ  WA,=CH_LF,TRC01  JUMP IF F (FUNCTION)
       BEQ  WA,=CH_LR,TRC01  JUMP IF R (RETURN)
       BEQ  WA,=CH_LL,TRC03  JUMP IF L (LABEL)
       BEQ  WA,=CH_LK,TRC06  JUMP IF K (KEYWORD)
       BNE  WA,=CH_LC,TRC15  ELSE ERROR IF NOT C (CALL)
TRC01  JSR  GTNVR            POINT TO VRBLK FOR NAME
       PPM  TRC16            JUMP IF BAD NAME
       ICA  XS               POP STACK
       MOV  VRFNC(XR),XR     POINT TO FUNCTION BLOCK
       BNE  (XR),=B_PFC,TRC17 ERROR IF NOT PROGRAM FUNCTION
       BEQ  WA,=CH_LR,TRC02  JUMP IF R (RETURN)
       MOV  XL,PFCTR(XR)     SET/RESET CALL TRACE
       BEQ  WA,=CH_LC,EXNUL  EXIT WITH NULL IF C (CALL)
TRC02  MOV  XL,PFRTR(XR)     SET/RESET RETURN TRACE
       EXI                   RETURN
TRC03  JSR  GTNVR            POINT TO VRBLK
       PPM  TRC16            JUMP IF BAD NAME
       MOV  VRLBL(XR),XL     LOAD LABEL POINTER
       BNE  (XL),=B_TRT,TRC04 JUMP IF NO OLD TRACE
       MOV  TRLBL(XL),XL     ELSE DELETE OLD TRACE ASSOCIATION
TRC04  BEQ  XL,=STNDL,TRC16  ERROR IF UNDEFINED LABEL
       MOV  (XS)+,WB         GET TRBLK PTR AGAIN
       BZE  WB,TRC05         JUMP IF STOPTR CASE
       MOV  WB,VRLBL(XR)     ELSE SET NEW TRBLK POINTER
       MOV  =B_VRT,VRTRA(XR) SET LABEL TRACE ROUTINE ADDRESS
       MOV  WB,XR            COPY TRBLK POINTER
       MOV  XL,TRLBL(XR)     STORE REAL LABEL IN TRBLK
       EXI                   RETURN
TRC05  MOV  XL,VRLBL(XR)     STORE LABEL PTR BACK IN VRBLK
       MOV  =B_VRG,VRTRA(XR) STORE NORMAL TRANSFER ADDRESS
       EXI                   RETURN
TRC06  JSR  GTNVR            POINT TO VRBLK
       PPM  TRC16            ERROR IF NOT NATURAL VAR
       BNZ  VRLEN(XR),TRC16  ERROR IF NOT SYSTEM VAR
       ICA  XS               POP STACK
       BZE  XL,TRC07         JUMP IF STOPTR CASE
       MOV  XR,TRKVR(XL)     STORE VRBLK PTR IN TRBLK FOR KTREX
TRC07  MOV  VRSVP(XR),XR     POINT TO SVBLK
       BEQ  XR,=V_ERT,TRC08  JUMP IF ERRTYPE
       BEQ  XR,=V_STC,TRC09  JUMP IF STCOUNT
       BNE  XR,=V_FNC,TRC17  ELSE ERROR IF NOT FNCLEVEL
       MOV  XL,R_FNC         SET/RESET FNCLEVEL TRACE
       EXI                   RETURN
TRC08  MOV  XL,R_ERT         SET/RESET ERRTYPE TRACE
       EXI                   RETURN
TRC09  MOV  XL,R_STC         SET/RESET STCOUNT TRACE
       JSR  STGCC            UPDATE COUNTDOWN COUNTERS
       EXI                   RETURN
TRC10  JSR  GTVAR            LOCATE VARIABLE
       PPM  TRC16            ERROR IF NOT APPROPRIATE NAME
       MOV  (XS)+,WB         GET NEW TRBLK PTR AGAIN
       ADD  XL,WA            POINT TO VARIABLE LOCATION
       MOV  WA,XR            COPY VARIABLE POINTER
TRC11  MOV  (XR),XL          POINT TO NEXT ENTRY
       BNE  (XL),=B_TRT,TRC13  JUMP IF NOT TRBLK
       BLT  WC,TRTYP(XL),TRC13 JUMP IF TOO FAR OUT ON CHAIN
       BEQ  WC,TRTYP(XL),TRC12 JUMP IF THIS MATCHES OUR TYPE
       ADD  *TRNXT,XL        ELSE POINT TO LINK FIELD
       MOV  XL,XR            COPY POINTER
       BRN  TRC11            AND LOOP BACK
TRC12  MOV  TRNXT(XL),XL     GET PTR TO NEXT BLOCK OR VALUE
       MOV  XL,(XR)          STORE TO DELETE THIS TRBLK
TRC13  BZE  WB,TRC14         JUMP IF STOPTR CASE
       MOV  WB,(XR)          ELSE LINK NEW TRBLK IN
       MOV  WB,XR            COPY TRBLK POINTER
       MOV  XL,TRNXT(XR)     STORE FORWARD POINTER
       MOV  WC,TRTYP(XR)     STORE APPROPRIATE TRAP TYPE CODE
TRC14  MOV  WA,XR            RECALL POSSIBLE VRBLK POINTER
       SUB  *VRVAL,XR        POINT BACK TO VRBLK
       JSR  SETVR            SET FIELDS IF VRBLK
       EXI                   RETURN
TRC15  EXI  2                TAKE BAD TRACE TYPE ERROR EXIT
TRC16  ICA  XS               POP STACK
TRC17  EXI  1                TAKE BAD NAME ERROR EXIT
       ENP                   END PROCEDURE TRACE
TRBLD  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         STACK TRTAG (OR TRFNM)
       MOV  *TRSI_,WA        SET SIZE OF TRBLK
       JSR  ALLOC            ALLOCATE TRBLK
       MOV  =B_TRT,(XR)      STORE FIRST WORD
       MOV  XL,TRFNC(XR)     STORE TRFNC (OR TRFPT)
       MOV  (XS)+,TRTAG(XR)  STORE TRTAG (OR TRFNM)
       MOV  WB,TRTYP(XR)     STORE TYPE
       MOV  =NULLS,TRVAL(XR) FOR NOW, A NULL VALUE
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE TRBLD
TRIMR  PRC  E,0              ENTRY POINT
       MOV  XR,XL            COPY STRING POINTER
       MOV  SCLEN(XR),WA     LOAD STRING LENGTH
       BZE  WA,TRIM2         JUMP IF NULL INPUT
       PLC  XL,WA            ELSE POINT PAST LAST CHARACTER
       BZE  WB,TRIM3         JUMP IF NO TRIM
       MOV  =CH_BL,WC        LOAD BLANK CHARACTER
TRIM0  LCH  WB,-(XL)         LOAD NEXT CHARACTER
.IF    .CAHT
       BEQ  WB,=CH_HT,TRIM1  JUMP IF HORIZONTAL TAB
.FI
       BNE  WB,WC,TRIM3      JUMP IF NON-BLANK FOUND
TRIM1  DCV  WA               ELSE DECREMENT CHARACTER COUNT
       BNZ  WA,TRIM0         LOOP BACK IF MORE TO CHECK
TRIM2  MOV  XR,DNAMP         WIPE OUT INPUT STRING BLOCK
       MOV  =NULLS,XR        LOAD NULL RESULT
       BRN  TRIM5            MERGE TO EXIT
TRIM3  MOV  WA,SCLEN(XR)     SET NEW LENGTH
       MOV  XR,XL            COPY STRING POINTER
       PSC  XL,WA            READY FOR STORING BLANKS
       CTB  WA,SCHAR         GET LENGTH OF BLOCK IN BYTES
       ADD  XR,WA            POINT PAST NEW BLOCK
       MOV  WA,DNAMP         SET NEW TOP OF STORAGE POINTER
       LCT  WA,=CFP_C        GET COUNT OF CHARS IN WORD
       ZER  WC               SET ZERO CHAR
TRIM4  SCH  WC,(XL)+         STORE ZERO CHARACTER
       BCT  WA,TRIM4         LOOP BACK TILL ALL STORED
       CSC  XL               COMPLETE STORE CHARACTERS
TRIM5  ZER  XL               CLEAR GARBAGE XL POINTER
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE TRIMR
TRXEQ  PRC  R,0              ENTRY POINT (RECURSIVE)
       MOV  R_COD,WC         LOAD CODE BLOCK POINTER
       SCP  WB               GET CURRENT CODE POINTER
       SUB  WC,WB            MAKE CODE POINTER INTO OFFSET
       MOV  KVTRA,-(XS)      STACK TRACE KEYWORD VALUE
       MOV  XR,-(XS)         STACK TRBLK POINTER
       MOV  XL,-(XS)         STACK NAME BASE
       MOV  WA,-(XS)         STACK NAME OFFSET
       MOV  WC,-(XS)         STACK CODE BLOCK POINTER
       MOV  WB,-(XS)         STACK CODE POINTER OFFSET
       MOV  FLPTR,-(XS)      STACK OLD FAILURE POINTER
       ZER  -(XS)            SET DUMMY FAIL OFFSET
       MOV  XS,FLPTR         SET NEW FAILURE POINTER
       ZER  KVTRA            RESET TRACE KEYWORD TO ZERO
       MOV  =TRXDC,WC        LOAD NEW (DUMMY) CODE BLK POINTER
       MOV  WC,R_COD         SET AS CODE BLOCK POINTER
       LCP  WC               AND NEW CODE POINTER
       MOV  WA,WB            SAVE NAME OFFSET
       MOV  *NMSI_,WA        LOAD NMBLK SIZE
       JSR  ALLOC            ALLOCATE SPACE FOR NMBLK
       MOV  =B_NML,(XR)      SET TYPE WORD
       MOV  XL,NMBAS(XR)     STORE NAME BASE
       MOV  WB,NMOFS(XR)     STORE NAME OFFSET
       MOV  6(XS),XL         RELOAD POINTER TO TRBLK
       MOV  XR,-(XS)         STACK NMBLK POINTER (1ST ARGUMENT)
       MOV  TRTAG(XL),-(XS)  STACK TRACE TAG (2ND ARGUMENT)
       MOV  TRFNC(XL),XL     LOAD TRACE VRBLK POINTER
       MOV  VRFNC(XL),XL     LOAD TRACE FUNCTION POINTER
       BEQ  XL,=STNDF,TRXQ2  JUMP IF NOT A DEFINED FUNCTION
       MOV  =NUM02,WA        SET NUMBER OF ARGUMENTS TO TWO
       BRN  CFUNC            JUMP TO CALL FUNCTION
TRXQ1  MOV  FLPTR,XS         POINT BACK TO OUR STACK ENTRIES
       ICA  XS               POP OFF GARBAGE FAIL OFFSET
       MOV  (XS)+,FLPTR      RESTORE OLD FAILURE POINTER
       MOV  (XS)+,WB         RELOAD CODE OFFSET
       MOV  (XS)+,WC         LOAD OLD CODE BASE POINTER
       MOV  WC,XR            COPY CDBLK POINTER
       MOV  CDSTM(XR),KVSTN  RESTORE STMNT NO
       MOV  (XS)+,WA         RELOAD NAME OFFSET
       MOV  (XS)+,XL         RELOAD NAME BASE
       MOV  (XS)+,XR         RELOAD TRBLK POINTER
       MOV  (XS)+,KVTRA      RESTORE TRACE KEYWORD VALUE
       ADD  WC,WB            RECOMPUTE ABSOLUTE CODE POINTER
       LCP  WB               RESTORE CODE POINTER
       MOV  WC,R_COD         AND CODE BLOCK POINTER
       EXI                   RETURN TO TRXEQ CALLER
TRXQ2  ERB  197,TRACE fourth arg is not function name or null
       ENP                   END PROCEDURE TRXEQ
XSCAN  PRC  E,0              ENTRY POINT
       MOV  WB,XSCWB         PRESERVE WB
       MOV  WA,-(XS)         RECORD BLANK SKIP FLAG
       MOV  WA,-(XS)         AND SECOND COPY
       MOV  R_XSC,XR         POINT TO ARGUMENT STRING
       MOV  SCLEN(XR),WA     LOAD STRING LENGTH
       MOV  XSOFS,WB         LOAD CURRENT OFFSET
       SUB  WB,WA            GET NUMBER OF REMAINING CHARACTERS
       BZE  WA,XSCN3         JUMP IF NO CHARACTERS LEFT
       PLC  XR,WB            POINT TO CURRENT CHARACTER
XSCN1  LCH  WB,(XR)+         LOAD NEXT CHARACTER
       BEQ  WB,WC,XSCN4      JUMP IF DELIMITER ONE FOUND
       BEQ  WB,XL,XSCN5      JUMP IF DELIMITER TWO FOUND
       BZE  (XS),XSCN2       JUMP IF NOT SKIPPING BLANKS
       ICV  XSOFS            ASSUME BLANK AND DELETE IT
.IF    .CAHT
       BEQ  WB,=CH_HT,XSCN2  JUMP IF HORIZONTAL TAB
.FI
.IF    .CAVT
       BEQ  WB,=CH_VT,XSCN2  JUMP IF VERTICAL TAB
.FI
       BEQ  WB,=CH_BL,XSCN2  JUMP IF BLANK
       DCV  XSOFS            UNDELETE NON-BLANK CHARACTER
       ZER  (XS)             AND DISCONTINUE BLANK CHECKING
XSCN2  DCV  WA               DECREMENT COUNT OF CHARS LEFT
       BNZ  WA,XSCN1         LOOP BACK IF MORE CHARS TO GO
XSCN3  MOV  R_XSC,XL         POINT TO STRING BLOCK
       MOV  SCLEN(XL),WA     GET STRING LENGTH
       MOV  XSOFS,WB         LOAD OFFSET
       SUB  WB,WA            GET SUBSTRING LENGTH
       ZER  R_XSC            CLEAR STRING PTR FOR COLLECTOR
       ZER  XSCRT            SET ZERO (RUNOUT) RETURN CODE
       BRN  XSCN7            JUMP TO EXIT
XSCN4  MOV  =NUM01,XSCRT     SET RETURN CODE
       BRN  XSCN6            JUMP TO MERGE
XSCN5  MOV  =NUM02,XSCRT     SET RETURN CODE
XSCN6  MOV  R_XSC,XL         RELOAD POINTER TO STRING
       MOV  SCLEN(XL),WC     GET ORIGINAL LENGTH OF STRING
       SUB  WA,WC            MINUS CHARS LEFT = CHARS SCANNED
       MOV  WC,WA            MOVE TO REG FOR SBSTR
       MOV  XSOFS,WB         SET OFFSET
       SUB  WB,WA            COMPUTE LENGTH FOR SBSTR
       ICV  WC               ADJUST NEW CURSOR PAST DELIMITER
       MOV  WC,XSOFS         STORE NEW OFFSET
XSCN7  ZER  XR               CLEAR GARBAGE CHARACTER PTR IN XR
       JSR  SBSTR            BUILD SUB-STRING
       ICA  XS               REMOVE COPY OF BLANK FLAG
       MOV  (XS)+,WB         ORIGINAL BLANK SKIP/TRIM FLAG
       BZE  SCLEN(XR),XSCN8  CANNOT TRIM THE NULL STRING
       JSR  TRIMR            TRIM TRAILING BLANKS IF REQUESTED
XSCN8  MOV  XSCRT,WA         LOAD RETURN CODE
       MOV  XSCWB,WB         RESTORE WB
       EXI                   RETURN TO XSCAN CALLER
       ENP                   END PROCEDURE XSCAN
XSCNI  PRC  N,2              ENTRY POINT
       JSR  GTSTG            FETCH ARGUMENT AS STRING
       PPM  XSCI1            JUMP IF NOT CONVERTIBLE
       MOV  XR,R_XSC         ELSE STORE SCBLK PTR FOR XSCAN
       ZER  XSOFS            SET OFFSET TO ZERO
       BZE  WA,XSCI2         JUMP IF NULL STRING
       EXI                   RETURN TO XSCNI CALLER
XSCI1  EXI  1                TAKE NOT-STRING ERROR EXIT
XSCI2  EXI  2                TAKE NULL-STRING ERROR EXIT
       ENP                   END PROCEDURE XSCNI
       TTL  S P I T B O L -- STACK OVERFLOW SECTION
       SEC                   START OF STACK OVERFLOW SECTION
       ADD  =NUM04,ERRFT     FORCE CONCLUSIVE FATAL ERROR
       MOV  FLPTR,XS         POP STACK TO AVOID MORE FAILS
       BNZ  GBCFL,STAK1      JUMP IF GARBAGE COLLECTING
       ERB  246,Stack overflow
STAK1  MOV  =ENDSO,XR        POINT TO MESSAGE
       ZER  KVDMP            MEMORY IS UNDUMPABLE
       BRN  STOPR            GIVE UP
       TTL  S P I T B O L -- ERROR SECTION
       SEC                   START OF ERROR SECTION
ERROR  BEQ  R_CIM,=CMLAB,CMPLE JUMP IF ERROR IN SCANNING LABEL
       MOV  WA,KVERT         SAVE ERROR CODE
       ZER  SCNRS            RESET RESCAN SWITCH FOR SCANE
       ZER  SCNGO            RESET GOTO SWITCH FOR SCANE
.IF    .CPOL
       MOV  =NUM01,POLCS     RESET POLL COUNT
       MOV  =NUM01,POLCT     RESET POLL COUNT
.FI
       MOV  STAGE,XR         LOAD CURRENT STAGE
       BSW  XR,STGNO         JUMP TO APPROPRIATE ERROR CIRCUIT
       IFF  STGIC,ERR01      INITIAL COMPILE
       IFF  STGXC,ERR04      EXECUTE TIME COMPILE
       IFF  STGEV,ERR04      EVAL COMPILING EXPR.
       IFF  STGEE,ERR04      EVAL EVALUATING EXPR
       IFF  STGXT,ERR05      EXECUTE TIME
       IFF  STGCE,ERR01      COMPILE - AFTER END
       IFF  STGXE,ERR04      XEQ COMPILE-PAST END
       ESW                   END SWITCH ON ERROR TYPE
ERR01  MOV  CMPXS,XS         RESET STACK POINTER
       SSL  CMPSS            RESTORE S-R STACK PTR FOR CMPIL
       BNZ  ERRSP,ERR03      JUMP IF ERROR SUPPRESS FLAG SET
.IF    .CERA
.IF    .CSFN
       MOV  CMPSN,WC         CURRENT STATEMENT
       JSR  FILNM            OBTAIN FILE NAME FOR THIS STATEMENT
.FI
       MOV  SCNSE,WB         COLUMN NUMBER
       MOV  RDCLN,WC         LINE NUMBER
       MOV  STAGE,XR
       JSR  SYSEA            ADVISE SYSTEM OF ERROR
       PPM  ERRA3            IF SYSTEM DOES NOT WANT PRINT
       MOV  XR,-(XS)         SAVE ANY PROVIDED PRINT MESSAGE
.FI
       MOV  ERICH,ERLST      SET FLAG FOR LISTR
       JSR  LISTR            LIST LINE
       JSR  PRTIS            TERMINATE LISTING
       ZER  ERLST            CLEAR LISTR FLAG
       MOV  SCNSE,WA         LOAD SCAN ELEMENT OFFSET
       BZE  WA,ERR02         SKIP IF NOT SET
.IF    .CAHT
       LCT  WB,WA            LOOP COUNTER
       ICV  WA               INCREASE FOR CH_EX
       MOV  R_CIM,XL         POINT TO BAD STATEMENT
       JSR  ALOCS            STRING BLOCK FOR ERROR FLAG
       MOV  XR,WA            REMEMBER STRING PTR
       PSC  XR               READY FOR CHARACTER STORING
       PLC  XL               READY TO GET CHARS
ERRA1  LCH  WC,(XL)+         GET NEXT CHAR
       BEQ  WC,=CH_HT,ERRA2  SKIP IF TAB
       MOV  =CH_BL,WC        GET A BLANK
ERRA2  SCH  WC,(XR)+         STORE CHAR
       BCT  WB,ERRA1         LOOP
       MOV  =CH_EX,XL        EXCLAMATION MARK
       SCH  XL,(XR)          STORE AT END OF ERROR LINE
       CSC  XR               END OF SCH LOOP
       MOV  =STNPD,PROFS     ALLOW FOR STATEMENT NUMBER
       MOV  WA,XR            POINT TO ERROR LINE
       JSR  PRTST            PRINT ERROR LINE
.ELSE
       MTI  PRLEN            GET PRINT BUFFER LENGTH
       MFI  GTNSI            STORE AS SIGNED INTEGER
       ADD  =STNPD,WA        ADJUST FOR STATEMENT NUMBER
       MTI  WA               COPY TO INTEGER ACCUMULATOR
       RMI  GTNSI            REMAINDER MODULO PRINT BFR LENGTH
       STI  PROFS            USE AS CHARACTER OFFSET
       MOV  =CH_EX,WA        GET EXCLAMATION MARK
       JSR  PRTCH            GENERATE UNDER BAD COLUMN
.FI
ERR02  JSR  PRTIS            PRINT BLANK LINE
.IF    .CERA
       MOV  (XS)+,XR         RESTORE ANY SYSEA MESSAGE
       BZE  XR,ERRA0         DID SYSEA PROVIDE MESSAGE TO PRINT
       JSR  PRTST            PRINT SYSEA MESSAGE
.FI
ERRA0  JSR  ERMSG            GENERATE FLAG AND ERROR MESSAGE
       ADD  =NUM03,LSTLC     BUMP PAGE CTR FOR BLANK, ERROR, BLK
ERRA3  ZER  XR               IN CASE OF FATAL ERROR
       BHI  ERRFT,=NUM03,STOPR PACK UP IF SEVERAL FATALS
       ICV  CMERC            BUMP ERROR COUNT
       ADD  CSWER,NOXEQ      INHIBIT XEQ IF -NOERRORS
       BNE  STAGE,=STGIC,CMP10  SPECIAL RETURN IF AFTER END LINE
ERR03  MOV  R_CIM,XR         POINT TO START OF IMAGE
       PLC  XR               POINT TO FIRST CHAR
       LCH  XR,(XR)          GET FIRST CHAR
       BEQ  XR,=CH_MN,CMPCE  JUMP IF ERROR IN CONTROL CARD
       ZER  SCNRS            CLEAR RESCAN FLAG
       MNZ  ERRSP            SET ERROR SUPPRESS FLAG
       JSR  SCANE            SCAN NEXT ELEMENT
       BNE  XL,=T_SMC,ERR03  LOOP BACK IF NOT STATEMENT END
       ZER  ERRSP            CLEAR ERROR SUPPRESS FLAG
       MOV  *CDCOD,CWCOF     RESET OFFSET IN CCBLK
       MOV  =OCER_,WA        LOAD COMPILE ERROR CALL
       JSR  CDWRD            GENERATE IT
       MOV  CWCOF,CMSOC(XS)  SET SUCCESS FILL IN OFFSET
       MNZ  CMFFC(XS)        SET FAILURE FILL IN FLAG
       JSR  CDWRD            GENERATE SUCC. FILL IN WORD
       BRN  CMPSE            MERGE TO GENERATE ERROR AS CDFAL
ERR04  BGE  ERRFT,=NUM03,LABO1 ABORT IF TOO MANY FATAL ERRORS
.IF    .CPOL
       BEQ  KVERT,=NM320,ERR06 TREAT USER INTERRUPT SPECIALLY
.FI
       ZER  R_CCB            FORGET GARBAGE CODE BLOCK
       MOV  *CCCOD,CWCOF     SET INITIAL OFFSET (MBE CATSPAW)
       SSL  INISS            RESTORE MAIN PROG S-R STACK PTR
       JSR  ERTEX            GET FAIL MESSAGE TEXT
       DCA  XS               ENSURE STACK OK ON LOOP START
ERRA4  ICA  XS               POP STACK
       BEQ  XS,FLPRT,ERRC4   JUMP IF PROG DEFINED FN CALL FOUND
       BNE  XS,GTCEF,ERRA4   LOOP IF NOT EVAL OR CODE CALL YET
       MOV  =STGXT,STAGE     RE-SET STAGE FOR EXECUTE
       MOV  R_GTC,R_COD      RECOVER CODE PTR
       MOV  XS,FLPTR         RESTORE FAIL POINTER
       ZER  R_CIM            FORGET POSSIBLE IMAGE
.IF    .CINC
       ZER  CNIND            FORGET POSSIBLE INCLUDE
.FI
ERRB4  BNZ  KVERL,ERR07      JUMP IF ERRLIMIT NON-ZERO
       BRN  EXFAL            FAIL
ERRC4  MOV  FLPTR,XS         RESTORE STACK FROM FLPTR
       BRN  ERRB4            MERGE
ERR05  SSL  INISS            RESTORE MAIN PROG S-R STACK PTR
       BNZ  DMVCH,ERR08      JUMP IF IN MID-DUMP
ERR06  BZE  KVERL,LABO1      ABORT IF ERRLIMIT IS ZERO
       JSR  ERTEX            GET FAIL MESSAGE TEXT
ERR07  BGE  ERRFT,=NUM03,LABO1 ABORT IF TOO MANY FATAL ERRORS
       DCV  KVERL            DECREMENT ERRLIMIT
       MOV  R_ERT,XL         LOAD ERRTYPE TRACE POINTER
       JSR  KTREX            GENERATE ERRTYPE TRACE IF REQUIRED
       MOV  R_COD,WA         GET CURRENT CODE BLOCK
       MOV  WA,R_CNT         SET CDBLK PTR FOR CONTINUATION
       SCP  WB               CURRENT CODE POINTER
       SUB  WA,WB            OFFSET WITHIN CODE BLOCK
       MOV  WB,STXOC         SAVE CODE PTR OFFSET FOR SCONTINUE
       MOV  FLPTR,XR         SET PTR TO FAILURE OFFSET
       MOV  (XR),STXOF       SAVE FAILURE OFFSET FOR CONTINUE
       MOV  R_SXC,XR         LOAD SETEXIT CDBLK POINTER
       BZE  XR,LCNT1         CONTINUE IF NO SETEXIT TRAP
       ZER  R_SXC            ELSE RESET TRAP
       MOV  =NULLS,STXVR     RESET SETEXIT ARG TO NULL
       MOV  (XR),XL          LOAD PTR TO CODE BLOCK ROUTINE
       BRI  XL               EXECUTE FIRST TRAP STATEMENT
ERR08  MOV  DMVCH,XR         CHAIN HEAD FOR AFFECTED VRBLKS
       BZE  XR,ERR06         DONE IF ZERO
       MOV  (XR),DMVCH       SET NEXT LINK AS CHAIN HEAD
       JSR  SETVR            RESTORE VRGET FIELD
S_YYY  BRN  ERR08            LOOP THROUGH CHAIN
       TTL  S P I T B O L -- HERE ENDETH THE CODE
       END                   END MACRO-SPITBOL ASSEMBLY
